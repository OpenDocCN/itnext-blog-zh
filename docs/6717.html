<html>
<head>
<title>The Gilded Rose Kata in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铁锈色镀金玫瑰形</h1>
<blockquote>原文：<a href="https://itnext.io/gilded-rose-kata-in-rust-e00f51f1e8d8?source=collection_archive---------6-----------------------#2022-02-06">https://itnext.io/gilded-rose-kata-in-rust-e00f51f1e8d8?source=collection_archive---------6-----------------------#2022-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f29d07a7d602c3d4866b7f88655e916d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjZzFXSM--oP81_06KMghQ.jpeg"/></div></div></figure><p id="d8a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">镀金的玫瑰形是一个重构练习。GitHub 上的<a class="ae kw" href="https://github.com/NotMyself/GildedRose" rel="noopener ugc nofollow" target="_blank">提供了完整的描述。我很晚才知道这个形，也就是在2016年的雪营会议上。</a><a class="ae kw" href="https://twitter.com/johan_alps" rel="noopener ugc nofollow" target="_blank">约翰·马丁森</a>和<a class="ae kw" href="https://twitter.com/sanlaville" rel="noopener ugc nofollow" target="_blank">雷米·桑拉维尔</a>基于《镀金的玫瑰》做了一次现场代码重构。</p><p id="6686" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如今，我认为形更加广泛。它在很多语言中都有<a class="ae kw" href="https://github.com/emilybache/GildedRose-Refactoring-Kata" rel="noopener ugc nofollow" target="_blank">版本</a>，甚至包括一些不被认为是主流的语言<em class="kx">，例如</em>，XSLT或者ABAP。在这篇文章中，我想用Rust来做。我的想法是少关注一般的重构原则，多关注Rust细节。</p><ul class=""><li id="8fe8" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/1/" rel="noopener ugc nofollow" target="_blank">我的第一杯铁锈</a></li><li id="e5e3" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/2/" rel="noopener ugc nofollow" target="_blank">我的第二杯铁锈</a></li><li id="4bca" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/3/" rel="noopener ugc nofollow" target="_blank">生锈练习—第一部分</a></li><li id="da8c" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/4/" rel="noopener ugc nofollow" target="_blank">生锈练习—第二部分</a></li><li id="1e64" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/5/" rel="noopener ugc nofollow" target="_blank">前端生锈</a></li><li id="44b2" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/6/" rel="noopener ugc nofollow" target="_blank">库伯内特公司的铁锈控制器</a></li><li id="e305" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/7/" rel="noopener ugc nofollow" target="_blank"> Rust和JVM </a></li><li id="5694" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/8/" rel="noopener ugc nofollow" target="_blank"> diceroller，一个样本生锈项目</a></li><li id="ab2a" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated"><a class="ae kw" href="https://blog.frankel.ch/start-rust/9/" rel="noopener ugc nofollow" target="_blank">铁锈的矢量</a></li></ul><h1 id="3bae" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">实施测试</h1><p id="0107" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们需要通过实现测试来开始kata，以确保重构不会破坏现有的逻辑。</p><p id="12a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没什么好说的，但还是:</p><ul class=""><li id="a8a0" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">Infinitest: IntelliJ IDEA为JVM语言提供了Infinitest插件。您可以将其配置为在每次代码更改时运行您的测试。一旦你的重构破坏了测试，横幅就会从绿色变成红色。我没有找到任何类似Rust的插件。</li><li id="55ff" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">测试位置:在Java中，Maven已经普及了配置方法的约定，<code class="fe mp mq mr ms b">src/main/java</code>用于应用程序代码，<code class="fe mp mq mr ms b">src/test/java</code>用于测试。通常，测试结构遵循主结构。我们可以在同一个文件中编写测试，但是在Rust的一个专用模块中。</li></ul><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="9699" class="nb ln iq ms b gy nc nd l ne nf">// Main code<br/><br/>#[cfg(test)]                                                    // 1<br/>mod tests {                                                     // 2<br/><br/>    use super::{GildedRose, Item};                              // 3<br/><br/>    #[test]<br/>    pub fn regular_item_sell_in_and_quality_decrease() {}       // 4<br/><br/>    #[test]<br/>    pub fn regular_item_quality_stop_decreasing_at_0() {}       // 4<br/><br/>    // Other tests<br/>}</span></pre><ol class=""><li id="e6ff" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">作为常规应用程序启动时被忽略</li><li id="b137" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">专用模块</li><li id="5372" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">因为<code class="fe mp mq mr ms b">tests</code>是一个专用模块，我们需要从父模块导入<code class="fe mp mq mr ms b">struct</code></li><li id="68df" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">测试功能</li></ol><h1 id="fc11" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Clippy是你的朋友！</h1><blockquote class="nh ni nj"><p id="348c" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">收集lints来捕捉常见错误并改进您的Rust代码。</em></p><p id="62b5" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated">这个板条箱里有500多根棉绒！</p><p id="7e1b" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">棉绒分为多个类别，每个类别都有一个默认的棉绒级别。你可以选择多少Clippy应该骚扰帮助你，通过改变类别的棉绒水平。</em></p><p id="6598" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">—</em><a class="ae kw" href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank"><em class="iq">GitHub</em></a></p></blockquote><p id="9f1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在命令行上，<code class="fe mp mq mr ms b">cargo</code>原生集成了Clippy。您可以通过在项目文件夹中运行以下命令来使用它:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2abd" class="nb ln iq ms b gy nc nd l ne nf">cargo clippy</span></pre><p id="59ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在IntelliJ中显示Clippy的警告。转到首选项&gt;语言和框架&gt; Rust &gt;外部Linters。然后，您可以选择工具<em class="kx">，例如</em>、Clippy，以及是否在后台运行它。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/8544153e6426ef864bffd6836070aac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nwHeL3v3Tjs5yPMq0A0eaw.png"/></div></div></figure><p id="0cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">IntelliJ警告你，它可能是CPU繁重。</p><p id="44b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Clippy强调了以下陈述:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="e53d" class="nb ln iq ms b gy nc nd l ne nf">item.quality = item.quality + 1;<br/>item.quality = item.quality - 1;</span></pre><p id="fd0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和Java一样，IntelliJ IDEA非常适合重构。你可以使用<code class="fe mp mq mr ms b">Alt+Enter</code>组合键，IDE会处理这些琐碎的工作。新代码是:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5c60" class="nb ln iq ms b gy nc nd l ne nf">item.quality += 1;<br/>item.quality -= 1;</span></pre><h1 id="51cf" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">关于实现的函数</h1><p id="028d" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在Java中，很大一部分重构致力于改进面向对象方法。虽然Rust不是OO，但它提供了功能。函数可以是顶级的:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="d8c6" class="nb ln iq ms b gy nc nd l ne nf">fn increase_quality() {}</span></pre><p id="a67b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">功能也可以是<code class="fe mp mq mr ms b">impl</code>的一部分:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="9930" class="nb ln iq ms b gy nc nd l ne nf">struct Item {<br/>    pub quality: i32,<br/>}</span><span id="a321" class="nb ln iq ms b gy no nd l ne nf">impl Item {<br/>    fn increase_quality() {}   // 1<br/>}</span><span id="1193" class="nb ln iq ms b gy no nd l ne nf">Item::increase_quality();      // 2</span></pre><ol class=""><li id="a40c" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">定义函数</li><li id="0ea6" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">打电话吧</li></ol><p id="1ff2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mp mq mr ms b">impl</code>中定义的函数可以访问它的<code class="fe mp mq mr ms b">struct</code>:它的第一个参数必须是<code class="fe mp mq mr ms b">self</code>或者它的一个替代- <code class="fe mp mq mr ms b">mut self</code>和<code class="fe mp mq mr ms b">&amp;mut self</code>:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="04b9" class="nb ln iq ms b gy nc nd l ne nf">struct Item {<br/>    pub quality: i32,<br/>}</span><span id="5d1b" class="nb ln iq ms b gy no nd l ne nf">impl Item {<br/>    fn increase_quality(&amp;mut self) {    // 1<br/>        self.quality += 1;              // 2<br/>    }<br/>}</span><span id="485f" class="nb ln iq ms b gy no nd l ne nf">let item = Item { quality: 32 };<br/>item.increase_quality();                // 3</span></pre><ol class=""><li id="dae3" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">第一个参数是对<code class="fe mp mq mr ms b">Item</code>的可变引用</li><li id="6035" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">更新<code class="fe mp mq mr ms b">quality</code>属性</li><li id="b7b4" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">调用<code class="fe mp mq mr ms b">item</code>变量上的函数</li></ol><h1 id="8854" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">字符串匹配</h1><p id="a8b5" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">原始代码库使用大量条件表达式进行字符串比较:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="ed21" class="nb ln iq ms b gy nc nd l ne nf">if self.name == "Aged Brie" { /* A */}<br/>else if self.name == "Backstage passes to a TAFKAL80ETC concert" { /* B */ }<br/>else if self.name == "Sulfuras, Hand of Ragnaros" { /* C */ }<br/>else { /* D */ }</span></pre><p id="631f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以利用<code class="fe mp mq mr ms b">match</code>关键字。然而，锈分为<code class="fe mp mq mr ms b">String</code>型和<code class="fe mp mq mr ms b">&amp;str</code>型。为此，我们必须将前者转化为后者:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="04ee" class="nb ln iq ms b gy nc nd l ne nf">match self.name.as_str() {                                      // 1<br/>    "Aged Brie"                                 =&gt; { /* A */ }<br/>    "Backstage passes to a TAFKAL80ETC concert" =&gt; { /* B */ }<br/>    "Sulfuras, Hand of Ragnaros"                =&gt; { /* C */ }<br/>    _                                           =&gt; { /* D */ }<br/>}</span></pre><ol class=""><li id="0839" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">将<code class="fe mp mq mr ms b">String</code>转换为<code class="fe mp mq mr ms b">&amp;str</code> -需要编译</li></ol><h1 id="fe01" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">空火柴</h1><p id="fa83" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">“拉格纳罗斯之手”产品的质量始终如一。因此，它的相关逻辑是空的。语法是<code class="fe mp mq mr ms b">()</code>定义空语句。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="eb1b" class="nb ln iq ms b gy nc nd l ne nf">match self.name.as_str() {<br/>    "Aged Brie"                                 =&gt; { /* A */ }<br/>    "Backstage passes to a TAFKAL80ETC concert" =&gt; { /* B */ }<br/>    "Sulfuras, Hand of Ragnaros"                =&gt; (),         // 1<br/>    _                                           =&gt; { /* D */ }<br/>}</span></pre><ol class=""><li id="40ee" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">什么也不做</li></ol><h1 id="8848" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">列举</h1><p id="a187" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">项目类型由其名称引用。重构后的代码公开了以下生命周期阶段:销售前、销售中和销售后。代码在销售前和销售后阶段使用相同的字符串。显而易见，使用枚举只写一次字符串。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="887e" class="nb ln iq ms b gy nc nd l ne nf">enum ItemType {                                        // 1<br/>    AgedBrie,<br/>    HandOfRagnaros,<br/>    BackstagePass,<br/>    Regular<br/>}</span><span id="9138" class="nb ln iq ms b gy no nd l ne nf">impl Item {<br/>  fn get_type(&amp;self) -&gt; ItemType {                     // 2<br/>    match self.name.as_str() {                         // 3<br/>      "Aged Brie"                             =&gt; ItemType::AgedBrie,<br/>      "Sulfuras, Hand of Ragnaros"      =&gt; ItemType::HandOfRagnaros,<br/>      "Backstage passes to a TAFKAL80ETC concert" =&gt; ItemType::BackstagePass,<br/>      _                                        =&gt; ItemType::Regular<br/>    }<br/>  }<br/>}</span></pre><ol class=""><li id="7741" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">枚举所有可能的项类型</li><li id="3872" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">函数将项类型从其名称中去掉</li><li id="df07" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ng le lf lg bi translated">字符串匹配只发生在这里。错别字的可能性在单个位置。</li></ol><p id="8ba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们可以在match子句中使用枚举。它要求<code class="fe mp mq mr ms b">enum</code>实现<code class="fe mp mq mr ms b">PartialEq</code>。对于枚举，我们可以使用宏。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="d1c0" class="nb ln iq ms b gy nc nd l ne nf">#[derive(PartialEq)]<br/>enum ItemType {<br/>    // same as above<br/>}</span><span id="217a" class="nb ln iq ms b gy no nd l ne nf">fn pre_sell_in(&amp;mut self) {<br/>    match self.get_type() {<br/>        ItemType::AgedBrie       =&gt; { /* A */ }<br/>        ItemType::BackstagePass  =&gt; { /* B */ }<br/>        ItemType::HandOfRagnaros =&gt; (),<br/>        ItemType::Regular        =&gt; { /* D */ }<br/>    }<br/>}</span><span id="2e61" class="nb ln iq ms b gy no nd l ne nf">// Same for post_sell_in</span></pre><h1 id="5b9a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">惯用铁锈:<code class="fe mp mq mr ms b">From</code>和<code class="fe mp mq mr ms b">Into</code></h1><p id="6489" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">由于其强大的类型系统，从一种类型转换到另一种类型在Rust中非常常见。出于这个原因，Rust在其标准库中提供了两个特征:<code class="fe mp mq mr ms b">From</code>和<code class="fe mp mq mr ms b">Into</code>。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/6aef0c78f26a544a50aada137a4d256d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J75Zr7fxYIWoWcgNbSZt7A.png"/></div></div></figure><blockquote class="nh ni nj"><p id="a91b" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">用于在消耗输入值的同时进行值到值的转换。是</em> <code class="fe mp mq mr ms b"><em class="iq">Into</em></code> <em class="iq">的倒数。</em></p><p id="827d" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq">比起</em> <code class="fe mp mq mr ms b"><em class="iq">Into</em></code> <em class="iq">，人们应该总是更喜欢实现</em> <code class="fe mp mq mr ms b"><em class="iq">From</em></code> <em class="iq">，因为实现</em> <code class="fe mp mq mr ms b"><em class="iq">From</em></code> <em class="iq">自动为人们提供了</em> <code class="fe mp mq mr ms b"><em class="iq">Into</em></code> <em class="iq">的实现，这得益于标准库中的一揽子实现。</em></p><p id="e383" class="jy jz kx ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae kw" href="https://doc.rust-lang.org/std/convert/trait.From.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">特质std::convert::From </em> </a></p></blockquote><p id="4352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一节中，我们使用一个定制的<code class="fe mp mq mr ms b">get_type()</code>函数将一个<code class="fe mp mq mr ms b">String</code>转换为一个<code class="fe mp mq mr ms b">ItemType</code>。为了编写更地道的Rust，我们将用一个<code class="fe mp mq mr ms b">From</code>实现替换这个函数:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="4129" class="nb ln iq ms b gy nc nd l ne nf">impl From&lt;&amp;str&gt; for ItemType {<br/>    fn from(slice: &amp;str) -&gt; Self {<br/>        match slice {<br/>            "Aged Brie"                       =&gt; ItemType::AgedBrie,<br/>            "Sulfuras, Hand of Ragnaros"=&gt; ItemType::HandOfRagnaros,<br/>            "Backstage passes to a TAFKAL80ETC concert" =&gt; ItemType::BackstagePass,<br/>            _                                  =&gt; ItemType::Regular<br/>        }<br/>    }<br/>}</span></pre><p id="6c70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以使用它:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="82bd" class="nb ln iq ms b gy nc nd l ne nf">fn pre_sell_in(&amp;mut self) {<br/>    match ItemType::from(self.name.as_str())  {       // 1<br/>        ItemType::AgedBrie       =&gt; { /* A */ }<br/>        ItemType::BackstagePass  =&gt; { /* B */ }<br/>        ItemType::HandOfRagnaros =&gt; (),<br/>        ItemType::Regular        =&gt; { /* D */ }<br/>    }<br/>}</span></pre><ol class=""><li id="c49c" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">使用惯用的<code class="fe mp mq mr ms b">From</code>特征</li></ol><p id="8216" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为实现<code class="fe mp mq mr ms b">From</code>提供了对称的<code class="fe mp mq mr ms b">Into</code>，我们可以相应地更新代码:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="7cb6" class="nb ln iq ms b gy nc nd l ne nf">fn pre_sell_in(&amp;mut self) {<br/>    match self.name.as_str().into()  {                // 1<br/>        ItemType::AgedBrie       =&gt; { /* A */ }<br/>        ItemType::BackstagePass  =&gt; { /* B */ }<br/>        ItemType::HandOfRagnaros =&gt; (),<br/>        ItemType::Regular        =&gt; { /* D */ }<br/>    }<br/>}</span></pre><ol class=""><li id="35b2" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ng le lf lg bi translated">将<code class="fe mp mq mr ms b">From</code>替换为<code class="fe mp mq mr ms b">into()</code></li></ol><h1 id="2df6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="a71f" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">不管是哪种语言，重构代码都是一个很好的学习练习。在这篇文章中，我展示了几个使用更地道Rust的技巧。在我学习这门语言的过程中，请随时提供额外的技巧来进一步改进代码。</p><p id="ae8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的完整源代码可以在GitHub 上找到<a class="ae kw" href="https://github.com/ajavageek/gilded-rose-rust" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="7a6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/start-rust/10/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">一个Java极客</em></a><em class="kx">2021年2月6日</em></p></div></div>    
</body>
</html>