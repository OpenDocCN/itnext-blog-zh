<html>
<head>
<title>Decoding Dynamic JSON with Swift Codable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Swift Codable解码动态JSON</h1>
<blockquote>原文：<a href="https://itnext.io/decoding-dynamic-json-with-swift-codable-64160d06b456?source=collection_archive---------1-----------------------#2022-07-06">https://itnext.io/decoding-dynamic-json-with-swift-codable-64160d06b456?source=collection_archive---------1-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4185" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Swift的声音类型系统处理动态服务器响应</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/501bf257feef03d2a3db06c140533d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1baFkR1wWxMue812JWuekQ.png"/></div></div></figure><p id="eb04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在应用程序中提供动态内容需要与外部服务通信以获取数据。如今最常用的格式是JSON，在swift中处理JSON数据的常见方式是借助<a class="ae ln" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank"> Codable </a>将其转换成swift类型。在大多数用例中，数据可以用具有静态属性列表的具体swift类型来表示。</p><p id="ebb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在其他情况下，当应用程序中的内容高度动态且范围广泛时，响应数据可能会在多种格式之间变化。一些常见的例子有:</p><ul class=""><li id="3737" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">用<a class="ae ln" href="https://en.wikipedia.org/wiki/Content_management_system" rel="noopener ugc nofollow" target="_blank"> CMS </a>构建动态的服务器驱动UI。</li><li id="ae4a" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">在电子商务网站上展示各种产品。</li><li id="7ce0" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">社交网络中的动态内容提要。</li></ul><p id="174a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本帖中，我们将看到处理解码这类响应的典型方式，以及<a class="ae ln" href="https://github.com/SwiftyLab/DynamicCodableKit" rel="noopener ugc nofollow" target="_blank"> DynamicCodableKit </a>如何通过构建在Swift的<a class="ae ln" href="https://developer.apple.com/documentation/swift/codable" rel="noopener ugc nofollow" target="_blank">可编码</a>之上来无缝处理动态响应。</p><h1 id="89b8" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">初速电流状态</h1><p id="4c5a" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">以下是当用户在搜索框中键入任何文本时，亚马逊的建议响应数据，在这个场景中为“<strong class="kt ir">微波”</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2bba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属性包含搜索的动态结果列表，每个结果包含一个字段<code class="fe nb nc nd ne b">type</code>,表示结果的实际类型。在上面的响应中，收到了<code class="fe nb nc nd ne b">KEYWORD</code>和<code class="fe nb nc nd ne b">WIDGET</code>类型的结果，每种类型都包含一些额外的元数据，这些元数据反过来用于向用户显示额外的选项，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/9657a62e3ad2308ccf4d1d29e4168a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JisPLGXlF2ubv5pKoTcKlw.png"/></div></div></figure><p id="1377" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一种方法是使用带有可选字段的单个<code class="fe nb nc nd ne b">struct</code>。尽管这种方法看起来更简单，但是通过这种方法，您可以使用默认的合成<code class="fe nb nc nd ne b">Codable</code>实现。这种方法的缺点是，您必须用数据验证代码来污染您的业务逻辑，并且对于相同的属性可能有不同类型的情况，这种方法就不太好了。</p><p id="979e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一种更受欢迎的方法是使用带有相关值的<code class="fe nb nc nd ne b">enum</code>。它通过为要解码的每种类型添加单独的案例，解决了以前方法的缺点，即删除<code class="fe nb nc nd ne b">nil</code>属性需求并解决属性类型冲突。可以为<code class="fe nb nc nd ne b">enum</code>提供定制的<code class="fe nb nc nd ne b">init(from:)</code>实现，它将解码底层的案例/类型。</p><p id="98ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们可以检查每个对象的<code class="fe nb nc nd ne b">type</code>字段，并相应地解码建议:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="4af1" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">使用DynamicCodableKit</h1><p id="83d0" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">虽然上述方法适用于动态性水平较低的响应，但是维护所有这些样板文件会变得更加困难。主要的缺点是你必须做一些额外的工作来访问所有情况下的公共属性，并且使用枚举，你必须在每次添加新类型时更新所有的开关情况。</p><p id="21b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是<a class="ae ln" href="https://github.com/SwiftyLab/DynamicCodableKit" rel="noopener ugc nofollow" target="_blank"> DynamicCodableKit </a>通过使用通用属性包装器而大放异彩的地方。它处理基于<code class="fe nb nc nd ne b">DynamicDecodingContext</code>的动态解码，T5是一个<a class="ae ln" href="https://fabernovel.github.io/2020-06-03/approaches-to-type-erasure-in-swift#:~:text=%20Approaches%20to%20Type%20Erasure%20in%20Swift%20,are%20very%20constrained%20to%20work%20with.%20More%20" rel="noopener ugc nofollow" target="_blank">类型擦除</a>，它解码一个特定的<code class="fe nb nc nd ne b">DynamicDecodable</code>类型并将其转换为其通用类型。可以在不同场景下自定义<code class="fe nb nc nd ne b">DynamicDecodingContext</code>动态解码多种类型。<a class="ae ln" href="https://github.com/SwiftyLab/DynamicCodableKit" rel="noopener ugc nofollow" target="_blank"> DynamicCodableKit </a>还为集合解码提供了<a class="ae ln" href="https://swiftylab.github.io/DynamicCodableKit/documentation/dynamiccodablekit/collectiondecoding/" rel="noopener ugc nofollow" target="_blank">多种配置</a>，以定制当遇到无效数据时会发生什么，即您可以选择只解码有效数据而忽略无效数据，而不是仅仅抛出一个错误。</p><p id="d351" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们当前的例子，我们可以创建一个<code class="fe nb nc nd ne b">Suggestion</code>协议类型，它将提供对底层实际建议的公共属性和方法的访问，即<code class="fe nb nc nd ne b">KeywordSuggestion</code>、<code class="fe nb nc nd ne b">WidgetSuggestion</code>。<code class="fe nb nc nd ne b">SuggestionType</code>和<code class="fe nb nc nd ne b">SuggestionTypeCodingKey</code>可以分别实现<code class="fe nb nc nd ne b">DynamicDecodingContextIdentifierKey</code>和<code class="fe nb nc nd ne b">DynamicDecodingContextIdentifierCodingKey</code>来解码实际类型。与前面的方法相比，添加新类型只需要改变<code class="fe nb nc nd ne b">SuggestionType</code>的<code class="fe nb nc nd ne b">associatedContext</code>实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="ng nh ni"><p id="0a6a" class="kr ks nj kt b ku kv jr kw kx ky ju kz nk lb lc ld nl lf lg lh nm lj lk ll lm ij bi translated">注意:默认情况下，<code class="fe nb nc nd ne b"><em class="iq">DynamicDecodable</em></code>只支持向下强制转换，如果你想强制转换成一个不相关的类型，你必须提供一个自定义的实现。</p></blockquote><h1 id="1a75" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="dcc9" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">除了上面的例子，<a class="ae ln" href="https://github.com/SwiftyLab/DynamicCodableKit" rel="noopener ugc nofollow" target="_blank"> DynamicCodableKit </a>提供了几个属性包装器和相关的协议来处理各种动态解码场景，所有这些都在<a class="ae ln" href="https://swiftylab.github.io/DynamicCodableKit/documentation/dynamiccodablekit/" rel="noopener ugc nofollow" target="_blank">文档</a>中有详细的解释，使得动态解码在使用最少的boiler-plate时更加简单。</p><div class="nn no gp gr np nq"><a href="https://github.com/SwiftyLab/DynamicCodableKit" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">GitHub-swifty lab/DynamicCodableKit:在…的约束下实现动态JSON解码</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">通过在Swift的基础上工作，在Swift的声音类型系统的限制内实现动态JSON解码…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div></div></div>    
</body>
</html>