<html>
<head>
<title>Should You Switch to Quarkus?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该换成夸库斯吗？</h1>
<blockquote>原文：<a href="https://itnext.io/should-you-switch-to-quarkus-4b89eedfe5fe?source=collection_archive---------0-----------------------#2020-07-16">https://itnext.io/should-you-switch-to-quarkus-4b89eedfe5fe?source=collection_archive---------0-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ca6e5f4a2bf69b62cc4be59e69bff6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEpHlu1C70fW5W9sIrwT5Q.jpeg"/></div></div></figure><div class=""/><p id="c104" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我曾经有一个经理说“问第二个问题”。当我问我的一个女儿“你的作业做完了吗？”我总是得到一个肯定的回答。然后，我会问第二个问题“所以它准备好了吗？”通常的回答是“嗯，我还有一件事要完成”。一个问题永远不够，第一个答案通常是被提问的人希望你或者他们自己相信的。</p><p id="10f3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近和一位Red Hat架构师谈论微服务和OpenShift，在那次谈话中<a class="ae kz" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>出现了。在过去做了很多Java开发之后，我对Quarkus这个想法非常感兴趣。这是一个“为OpenJDK HotSpot和GraalVM量身定制的Kubernetes原生Java堆栈”，它承诺显著加快基于Java的微服务的启动时间，并减少其占用空间。我怎么能错过呢？我搜索并找到了一些文章，展示了Quarkus应用程序比标准的基于JVM的应用程序启动要快得多。我决定自己试试，果然我的应用程序启动更快，占用空间更小。然后，按照我前任经理的建议，我问了第二个问题:它跑得更快吗？事实证明，这个问题的答案是“视情况而定”。</p><h1 id="dfed" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置</h1><p id="5f1f" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了对Quarkus的潜力进行真正的测试，我不想以运行Quarkus为目标定制一个应用程序——这可能会因为有目的地构建而扭曲结果。我的大多数客户都有遗留应用程序，因此，转换现有应用程序是一个更现实的用例。我正好有一小组微服务，我已经在其他几篇文章中使用过，其中一篇是Spring Boot应用程序。这个微服务，<em class="md"> capitol-info，</em>通过REST操作提供CRUD能力。第一个操作通过一个<strong class="kd jf"> HTTP GET </strong>调用返回国家首都。第二个操作支持通过一个<strong class="kd jf"> HTTP POST </strong>插入/更新capitols。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi me"><img src="../Images/53f590dbcad8f2fb347ffd8809eab51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*e9vlSKM_A9q0CeJOrsef8g.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">性能测试案例</figcaption></figure><p id="352b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Red Hat有一篇关于如何将Spring Boot应用程序转换成Quarkus的好文章。本文涵盖了删除Spring Boot代码和构建工件，并用Quarkus等价物替换它们。我没有太大困难地按照文章中的说明做了。我会说它花了不到半个小时就完成了修改并获得了一个干净的构建。当然，我只做了两次REST手术，但这个过程还是相当顺利的。</p><h2 id="8afb" class="mn lb je bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">本地夸库人</h2><p id="e68a" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下一步是按照<a class="ae kz" href="https://quarkus.io/guides/building-native-image" rel="noopener ugc nofollow" target="_blank">的指示</a>构建Quarkus本地版本，包括安装C编译器。我在构建应用程序的本地版本时没有任何问题。然而，当我去运行它时，微服务无法找到库，出现了运行时错误。具体来说，它试图找到我的<a class="ae kz" href="http://jsondb.io/" rel="noopener ugc nofollow" target="_blank"> JSON数据库库</a>。我研究了这个问题，并决定如果可能的话，我应该为项目依赖项使用Quarkus扩展。因为JSON数据库库有注释，所以使用扩展是一个硬性要求。不幸的是，我使用的JSON数据库库没有Quarkus扩展。我只能选择构建一个扩展或者替换代码。我决定更换。</p><p id="9160" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了模拟类似于JSON数据库的功能，我用HashMap和JSON序列化替换了相关代码。为了序列化，我使用了<a class="ae kz" href="https://github.com/google/gson/blob/master/UserGuide.md" rel="noopener ugc nofollow" target="_blank"> GSON </a>库，我已经在应用程序的其他地方使用了。这个库没有Quarkus扩展(顺便提一下，有一个Apache Camel GSON扩展，但是这个微服务没有使用Camel)，但是可以编译，因为它没有使用注释。没有扩展被证明是重要的，我们将在后面看到。</p><p id="a08d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了确保磁盘I/O是等式中的一部分，而不仅仅是CPU，我用GSON添加了JSON序列化，以JSON的形式将HashMap写到文件系统中。我相信这有助于一个更现实的测试，覆盖更多的用例。基本上，测试包括从散列表中为<strong class="kd jf"> GET </strong>操作查找一个大写字母。在<strong class="kd jf"> POST </strong>操作的情况下，它在一个循环中执行几个函数，同时将JSON写入一个文件，以模拟负载。</p><p id="46b7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于每个测试，我从邮递员到<em class="md"> capitol-info </em>微服务进行了三次1000个批量调用。每个批处理调用都有一个<strong class="kd jf"> HTTP GET </strong>调用和一个<strong class="kd jf"> HTTP POST </strong>调用，批处理之间有10毫秒的延迟。对每组三次运行(总共6000次HTTP调用)的结果进行平均，以帮助最小化异常值和外部因素的影响。测试在MacBook Pro上进行，配备2.4 GHz 8核英特尔酷睿i9处理器和32 GB内存。Spring Boot和Quarkus版本都使用GraalVM运行。</p><h1 id="9bb9" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结果</h1><p id="c63c" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然更快的启动时间很好，但我真正寻求的是运行时的性能改进。正如下面将要看到的，Quarkus已经产生了一些意想不到的，也许是有争议的运行时性能结果。首先，让我们快速看一下启动时间。正如你在下面看到的，Quarkus启动比Spring Boot快得多，Quarkus本地版本比两者都快几个数量级，以毫秒为单位启动。这些启动时间表明了我在运行测试时所看到的，并且与其他使用Quarkus的人的发现一致。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/0109cc3ab8d8b54654ef4dc4b6f362c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nx4IT7SnzIJAHHFrhiYWNg.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Spring Boot在GraalVM上的启动时间大约为2.8秒</figcaption></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/1c127b2d2ac7aaad863cf5054230452b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAf2g-3w2ZdYl1PF6loZIA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">GraalVM上的Quarkus启动时间大约为0.57秒</figcaption></figure><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/8b76f1229a5dbc6ee4117d135852e1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_eUcIWGUvT71P2KvR9OuA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Quarkus本机可执行文件的启动时间约为0.2秒</figcaption></figure><p id="ac34" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止一切顺利。请注意在Quarkus截图中，您可以看到已安装的特性或扩展:cdiresteasy和resteasy-jsonb。现在，让我们从测试运行所需时间的角度来看一下运行时测试的结果:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nc"><img src="../Images/1feee96990f01ceb485049ad20f424e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zvg80VyivsV_n96J4Ongxw.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">MacOS上的REST操作测试结果</figcaption></figure><p id="acdd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">等等，什么？<strong class="kd jf"> GET </strong>响应时间图看起来不错，本地可执行应用程序轻松击败了GraalVM版本。但是，为什么针对本地版本的<strong class="kd jf"> POST </strong>调用运行时间(134 ms)是Spring Boot (43 ms)或GraalVM中quark us(42 ms)的三倍呢？<strong class="kd jf"> GET </strong>和<strong class="kd jf"> POST </strong>操作之间的主要区别是引入了文件I/O，所以我的第一个想法是它可能与MacOS磁盘I/O库有关。我决定将代码移植到一台运行Ubuntu的旧笔记本电脑上，进行同样的测试。笔记本电脑是第三代i7，8GB内存，固态硬盘。以下是平均测试时间:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nd"><img src="../Images/885fdd34730cabbcf8a211d6443179ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYJHDFUCiMFdPctZEAZ0kQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Ubuntu上的REST操作测试结果</figcaption></figure><p id="6713" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果是一样的，在Linux机器上，使用文件I/O的本地<strong class="kd jf"> POST </strong>调用同样慢。MacOS和Ubuntu测试时间也在下表中列出，便于参考。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5b3ef7597e9786b2c5b83ebdcd18f792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*JtbpeR6W2WBZKLgG27Um6g.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">性能测试结果—以毫秒为单位的时间</figcaption></figure><h1 id="2ceb" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">集装箱化</h1><p id="c3ba" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下一步是在Docker容器和Kubernetes中运行时，比较Spring Boot版本和Quarkus本地可执行版本。我构建了Docker映像，为Quarkus使用了ubi8最小基本Docker映像，为Spring Boot容器使用了OpenJDK 11.0.7-jre-slim基本映像。然后对Docker和Kubernetes进行测试。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f2874e90f70dfdad115185834c35aedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*PhXZaTby-9r5Ns8vTxWS6g.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">使用Docker和Kubernetes的测试用例</figcaption></figure><p id="9a13" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Spring Boot和Quarkus Native之间的启动时间仍然显示了从Spring Boot切换到Quarkus的惊人性能改进。下面是Spring Boot容器的日志输出，启动大约需要4秒钟。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/fc103109eb917e05481d6886cdb4dfa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZs60UreDIkkY4Ow7q4G1w.png"/></div></div></figure><p id="22ff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行Quarkus本地可执行应用程序的Docker容器需要0.012秒才能启动，如下所示。这在开始时间上是一个惊人的改进。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/4a7b2b0283b381e447d394c7543ceb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDQhwas7iPlOBA7qlTK_Pg.png"/></div></div></figure><p id="7f91" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不幸的是，运行时结果仍然显示Quarkus本机代码POST调用时间比同等的JVM慢，而本机GET仍然比JVM GET快。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/9b6b28ffe9258c2626417826bbbb77a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtKcFcpAn6CWPg9rqK-ZVA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">容器中运行的REST操作测试结果</figcaption></figure><p id="c56f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">奇怪的是，<strong class="kd jf"> POST </strong>操作在Docker中运行比直接在OS上运行要稍微快一些。</p><h1 id="c8d7" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">调查</h1><p id="cf16" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">此时，很明显Quarkus本地可执行版本中的<strong class="kd jf"> POST </strong>操作比JVM版本慢得多。不管它是运行在Spring Boot还是Quarkus上，或者直接在操作系统上运行还是在容器上运行，它都要慢一些。因为<strong class="kd jf"> GET </strong>和<strong class="kd jf"> POST </strong>之间的主要区别是序列化和磁盘I/O，所以我将调查重点放在了那个领域。知道它没有使用Quarkus GSON扩展，我把它换成了基于JSON-B的代码。JSON-B有一个Quarkus扩展，所以我希望看到本机版本比JVM版本有更好的性能。下面是使用GSON将Java对象序列化为JSON并写入磁盘的代码。</p><figure class="mf mg mh mi gt iv"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">GSON Java对象序列化</figcaption></figure><p id="067b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码被转换成使用JSON-B，它有一个Quarkus扩展。</p><figure class="mf mg mh mi gt iv"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">JSON-B Java对象序列化</figcaption></figure><p id="bac7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦代码被转换，我再次测试。下图显示了Spring Boot和夸尔库斯本地的HTTP POST操作平均时间。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/688ea75e9488ee8fa60930bedd26b1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*AqKxuLOmSFDUf-z4OcIMqA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">REST POST操作测试结果，在MacOS上使用JSON-B</figcaption></figure><p id="6cb9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下表显示了GET和POST调用的结果:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/20a79d6833bf4cf5bb4ea8f9c5aec279.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*97Gudbzl9WejUDKmA71VDQ.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">在MacOS上使用JSON-B的REST POST操作测试时间</figcaption></figure><p id="e44a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如所料，原生编译代码现在击败了JVM代码，但是JSON-B代码仍然比GSON版本慢。</p><h1 id="4e07" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="f1be" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我将Spring Boot转换成夸库，然后进行后续测试的工作，留给我的问题比答案还多。这也给了我一些启示。首先，在开发REST服务时，Quarkus代码比Spring Boot代码更干净、更简洁。第二，在做大量自动缩放并且开始时间很关键的情况下，Quarkus再次轻松获胜。第三，很明显，如果没有适当的扩展，Quarkus可能会引入相当大的延迟，以至于停止采用Quarkus的本地可执行版本。在这一点上，如果我能获得或创建所需的扩展，我可能会选择用Quarkus开发一个新的REST应用程序。</p><p id="e89c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这些测试中还有一些其他的观察结果，熊大声叫道:</p><ol class=""><li id="161f" class="nl nm je kd b ke kf ki kj km nn kq no ku np ky nq nr ns nt bi translated">Java库的选择会对性能产生重大影响。根据我参与的大多数项目的经验，开发人员倾向于获取众所周知的库并使用它们，而不独立测量它们的性能。性能问题通常集中在更粗粒度的领域，如网络协议、数据冗长、消息引擎等。有大量的Java库，一个团队几乎不可能对它们进行性能测试。我也没有发现这方面的信息，这似乎本身就是一个问题。</li><li id="9500" class="nl nm je kd b ke nu ki nv km nw kq nx ku ny ky nq nr ns nt bi translated">我不得不说，我的新MacBook Pro运行i9处理器，性能并不比一台七年前只有四分之一内存的Ubuntu笔记本电脑好多少，这让我非常震惊。我不确定这是否是Java的一种措施，热节流，两者都使用固态硬盘这一事实是一个限制因素，或者其他一些原因，但我认为它需要进一步的调查和针对各种硬件的更多测试。</li></ol></div></div>    
</body>
</html>