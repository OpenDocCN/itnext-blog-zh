<html>
<head>
<title>Acceptance Test-Driven Development in .net core with Specflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验收测试驱动的开发。带Specflow的网络核心</h1>
<blockquote>原文：<a href="https://itnext.io/acceptance-test-driven-development-in-net-core-with-specflow-dcb17fb7a893?source=collection_archive---------0-----------------------#2020-01-20">https://itnext.io/acceptance-test-driven-development-in-net-core-with-specflow-dcb17fb7a893?source=collection_archive---------0-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0c38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试驱动的开发非常棒，它给了你一个可以依赖的安全网，所以你可以放心地重构代码。TDD学习者通常从单元测试开始，单元测试涵盖了软件的独立部分的细节，这是一件很棒的事情，但是当你把所有的类粘在一起时，有什么保证它们像预期的那样工作呢？</p><p id="ec59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试所有的东西都能一起工作，我们需要不同类型的测试。</p><h2 id="3cb8" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">在我们深入ATDD之前</h2><p id="bb41" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">您必须对TDD有一个基本的了解，如果您不熟悉它，可以在这里学习:</p><ul class=""><li id="9829" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@raphaelyoshiga/why-tdd-will-change-your-developer-life-b0bf234e15ac" rel="noopener">为什么TDD会改变你的开发者生活</a></li><li id="bda4" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@raphaelyoshiga/practical-tdd-first-lesson-1c689fffe4ec" rel="noopener">实用TDD —第一课</a></li><li id="7a1a" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@raphaelyoshiga/practical-tdd-lesson-2-d9d48283b0c4" rel="noopener">实用TDD —第二课</a></li><li id="3573" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated"><a class="ae lv" href="https://medium.com/@raphaelyoshiga/practical-tdd-3-9a76b3e045d8" rel="noopener">实用TDD——第三课课堂协作</a></li></ul><h1 id="f460" class="mb kp it bd kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo mp mq lf mr bi translated">什么是ATDD？</h1><p id="83a3" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">ATDD是验收测试驱动的开发，测试将驱动实现。我在双环TDD的概念中使用这些，所以外环是验收测试:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi gj"><img src="../Images/1ff481b95d66630dfc17f64cbf82422c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c5ahAZusp87Bo6Io.jpg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">双环TDD循环—图像<a class="ae lv" href="http://myscribbledthoughts.info/page/a/atdd-tdd.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="8d07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将对此做一个外部循环，使验收测试失败，然后为单元测试实现多个TDD循环，直到验收测试通过，而不是只有红色&gt;绿色&gt;重构的小TDD循环。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="05c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">验收测试可以表示为:</p><h2 id="a1e4" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">正常测试代码</h2><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">示例测试计算器</figcaption></figure><p id="82c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些都是用你写单元测试的同一种语言写的，你可以从测试中提取许多方法，使它更容易被人理解，因为范围会变得相当大。</p><p id="cb4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> BDD语言</strong></p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/04bda10319384b56cd39ba8e11c300bf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gRxf74HoJSC8JdLD8-kODA.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">用Specflow编写的示例测试</figcaption></figure><p id="569a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为它是以人类可读的格式编写的，所以很好地记录了应用程序的特性，并且是向业务部门举例说明您试图为他们开发什么的好方法。</p><p id="ff04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现BDD测试更适合验收测试，因为范围通常很大，并且BDD可以更有效地显示更多的数据。</p><h2 id="d261" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">测试示波器</h2><p id="a44f" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">当创建您的验收测试时，您将不得不定义您要模拟多少系统，如果有的话:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nr"><img src="../Images/66134edea7b98a1d9fb3dfb07a5b815a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bxd-D5Eufxxbg50D3vHaAA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">测试范围—使用<a class="ae lv" href="http://draw.io" rel="noopener ugc nofollow" target="_blank"> http://draw.io </a>创建</figcaption></figure><p id="f7ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">端到端</strong></p><p id="fd1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些将是黑盒测试，这意味着测试是针对一个已部署的实例运行的，而没有系统如何工作的内部知识。这对以后的技术迁移很有用。</p><p id="ef2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这提供了您所能获得的最佳覆盖率，但是它们也带来了测试执行速度的缺点，不得不依赖于预先存在的数据，并且由于依赖失败而得到误报。</p><p id="f629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集成测试</strong></p><p id="6004" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些不会在已部署的实例上运行，而是在应用程序的某种引导中运行，使用真正的依赖项，如数据库和外部系统。这些依赖项可以是模拟实例，模拟另一个团队API，但是通过HTTP与它们通信的方式将是真实的。这些测试从头到尾都有一些相同的问题</p><p id="9a8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">进程内，没有被称为</strong>的依赖项</p><p id="6a52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在集成测试中，我们将引导应用程序入口点，但不调用任何真正的依赖，我们将在最后一级模拟所有的依赖。例如，在图中，SqlProductSearch类超出了测试覆盖范围。</p><p id="82cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的好处是测试会运行得非常快，你甚至可以用NCrunch这样的工具连续运行它们。此外，它们不会因为依赖失败而出现误报。坏处是你在嘲讽的东西，有时候你把真正的依赖塞住了，意想不到的事情就发生了。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="e065" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然没有一个正确的答案，但是我会为每个应用程序和团队经验评估使用什么范围和测试结构。我个人的偏好通常是进程内BDD，所以这就是我接下来要展示的:</p><h1 id="37ba" class="mb kp it bd kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo mp mq lf mr bi translated">使用设置规格流。网络核心</h1><p id="5816" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">首先，我们需要一个控制台应用程序和一个Xunit测试项目。net core with Visual Studio 2019:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ns"><img src="../Images/ae965e7457a2955b86a1541a970dda66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMKtJ3P67GW-LjG4gM_-_w.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Visual Studio 2019中的控制台应用程序</figcaption></figure><p id="0b5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向其中添加一个新的XUnit项目:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nt"><img src="../Images/fa23df619efa490230071e52ea66fa9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vETrqzYaW__LJSnQJtvZ3g.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">新xUnit项目— Visual Studio 2019</figcaption></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nu"><img src="../Images/d32e1c68dd6e3e298dd5c0dab50e98d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WbgUhE34fn1QvDHY49Xbg.png"/></div></div></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ae7a5e1abcf4d94dba38daa2e6fdb89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*kLp0h3uNMOFi6UQymuoUHQ.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">控制台加XUnit项目示例</figcaption></figure><h2 id="0df9" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">安装SpecFlow Visual Studio扩展:</h2><p id="1536" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">对于使用SpecFlow进行开发来说，拥有像语法突出显示和自动格式化这样的IDE优势是非常有用的，因此我们需要安装一个Visual Studio扩展，如下所示:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nw"><img src="../Images/aca4138972bcba88689e582f2eea4e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQY4wCidnrvqc8yg9brIjQ.png"/></div></div></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nx"><img src="../Images/74da68644a9c78d7b572f01de0c45e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hVZtvu7u_gX1rywwM2bJEw.png"/></div></div></figure><p id="16d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下载后，需要关闭Visual studio，以便触发安装程序:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/307a64446e70d648a2802135bb053531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*o85DhXMceHB5xfwiBqEhhg.png"/></div></figure><p id="7b09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装完成后，重新打开解决方案。右键单击项目，添加&gt;新建项目…</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nz"><img src="../Images/2fd991c1ffb3883ba1842138fed62b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v-jaufVyKl6CnQIYawAIA.png"/></div></div></figure><p id="cdb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在已经添加了Specflow扩展，在添加新项目时，您可以看到一个Specflow部分:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nx"><img src="../Images/45ce658dcacad17d69ebe2a0fe586c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCEQCncxXZjKmfdpprhoaA.png"/></div></div></figure><h2 id="02d5" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">包依赖关系</strong></h2><p id="01b7" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在将扩展安装到visual studio中之后，我们仍然需要配置我们的测试项目来使用SpecFlow，并使用正确的测试运行程序。(XUnit、NUnit、MsTest等)。我们会用XUnit做这个教程。</p><p id="e9d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">右键单击项目依赖项，管理NuGet包…</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9bb673eb085729a5594ab35cb084b9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*q9tKUMGwM9IMLKnRoOgUaw.png"/></div></figure><p id="39ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">搜索SpecFlow并安装Specflow.xUnit包:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ob"><img src="../Images/6e9e22edf6ec56ce9325cfd4ece4b660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4VkocWe84guZGNc_voXOw.png"/></div></div></figure><p id="6111" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给了我一个错误:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oc"><img src="../Images/eaa745e4dea6953676a2d70b5fc5a08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAxU5Nti2TMwelBNVMrd8A.png"/></div></div></figure><p id="7702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我更新添加了XUnit这个包。核心到2.4.1，安装完成。</p><h2 id="70f5" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">代码隐藏</h2><p id="8b8d" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在以前的Specflow实例中，有一个代码隐藏的概念，这是一个C#文件，是。特征文件Feature.cs通常在每次更改。特征文件。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5f6806326bbf7fdb3d53783117c39232.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*7z0PR2fzesebUT9aA08WAw.png"/></div></figure><p id="526d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着Specflow的发展，这些文件现在是在构建时通过安装包SPE flow . tools . msbuildgeneration生成的。</p><blockquote class="oe of og"><p id="ba17" class="jq jr oh js b jt ju jv jw jx jy jz ka oi kc kd ke oj kg kh ki ok kk kl km kn im bi translated">因为这些是在构建时生成的，所以我建议您不要对它们进行源代码控制。通过将*.feature.cs添加到. gitignore。</p></blockquote><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ol"><img src="../Images/6931994d7a92c0220cb0ac8e581e25d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJwYjqasyTKQ5F1jdskjeA.png"/></div></div></figure><p id="b9ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我们终于可以在Test Explorer中看到并运行我们的Specflow测试了。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi om"><img src="../Images/001dd259507d3f21a8a5d54ff579fce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JMueqHMym_JRszbq5UPBw.png"/></div></div></figure><p id="ac83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，可以从命令行安装这些软件包:</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="962c" class="mb kp it bd kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo mp mq lf mr bi translated">实施简单的SpecFlow测试:</h1><p id="3775" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">Specflow附带了一个用于创建计算器的默认示例，这将非常有用，因此我们可以使用一个非常基本的示例:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6ffeb595cc4cef8527abe0cb6ef0e9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*-g9fHnk6FUmv_2JwktRRVw.png"/></div></figure><p id="3daf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们的场景“添加两个数字”，所有步骤都以紫色突出显示，这意味着SpecFlow不知道在其中做什么。为了告诉SpecFlow每个步骤要运行什么代码，我们需要生成步骤定义:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oo"><img src="../Images/7340a28bb52ccd7e8e6832e92e9d1fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YbOh0BxSYcpzpjME5kT1A.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Specflow生成步骤定义菜单项</figcaption></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi op"><img src="../Images/f079e65b40a80440fd62b9c89b6e988d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqkLQ3RkkcP3ybS6tsDR7w.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Specflow生成步骤定义弹出窗口</figcaption></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/704e722be3cbb84255783e1846438dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*BsvhArt-rnugQlbcOM5gwQ.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">默认生成的Specflow步骤文件</figcaption></figure><p id="d204" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，特征文件应该如下所示:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div class="ab gu cl nq"><img src="../Images/04bda10319384b56cd39ba8e11c300bf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gRxf74HoJSC8JdLD8-kODA.png"/></div></figure><blockquote class="oe of og"><p id="2d7a" class="jq jr oh js b jt ju jv jw jx jy jz ka oi kc kd ke oj kg kh ki ok kk kl km kn im bi translated">初始设置有点不稳定，所以您可能需要重新启动visual studio并进行一些重建，直到它看起来正确为止。</p></blockquote><p id="7631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有几点:</p><ul class=""><li id="9921" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated">白色的所有步骤意味着SpecFlow知道每个步骤要执行哪个代码。您可以右键单击它们并“转到步骤定义”来测试它的映射是否正确。</li><li id="9fce" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">深灰色的数字表示这些是步进方法的参数。</li></ul><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi or"><img src="../Images/f474d78713abd529a3c218f606465f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBZcww_p34goU_xPJO42zg.png"/></div></div></figure><p id="775e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Specflow知道如何通过在绑定字符串中执行正则表达式来接收参数，因此任何进入该字符串的内容(。*)位置将被转换为方法签名中定义的int。您可以将多个参数接收到一个方法中，这些参数将根据顺序传递给该方法。参数名并不重要，所以可以随意添加有意义的名称。</p><p id="1dc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">场景。context . current . pending()；是测试失败的SpecFlow方式，因为这是待定的实现。</p><p id="c094" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果我们开始链接，每一步代码应该做什么，我们应该得到这样的东西:</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">CalculatorSteps.cs</figcaption></figure><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi os"><img src="../Images/1834f00ca193e86af9212391d755548e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*yokUBUwvVusd4BtW5XuYGQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">规格通过测试图片</figcaption></figure><h2 id="e61f" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">更真实的规格流量测试</h2><p id="813c" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">很好，我们的第一个基本测试运行并通过了！耶！</p><p id="265e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们开始接近生产测试的样子。假设我们有一个简单的需求，我们需要将订单从消息队列同步到我们的后台:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ot"><img src="../Images/38243b068d55be9fc2f4f83d246c9ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndkrurad-ZgoZgLE-KC-fg.png"/></div></div></figure><p id="7446" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里重要的一点是我们的测试范围，我们不一定预先知道将订单同步到数据库需要哪些类，但是我们知道我们的外部依赖性:</p><ul class=""><li id="398d" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated">我们流程的OrderProcessor入口点</li><li id="6389" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">ISalesChannelQuery —根据描述获取销售渠道id</li><li id="832c" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">IOrderPersister —将它插入数据库的类</li><li id="d919" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">？我们还不知道我们的设计。</li></ul><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi or"><img src="../Images/bf2dc526c5f56ad2ea85d548f10f6d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkzB83Qq_EsXoblNIPQfuA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Specflow —依赖性测试示例</figcaption></figure><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Specflow依赖性测试示例默认步骤</figcaption></figure><p id="d5b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试完美地描述了，软件从外部世界接收到什么，以及期望向外部世界发送什么。</p><p id="f375" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的其他事情是，我们使用了Specflow的一些更高级的概念，我们在给定的中使用了两个参数，其中一个是字符串(就像以前的regex一样)。</p><p id="19ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于“何时”,我们对所有这些管道使用了一种奇怪的语法，那就是SpecFlow表。当您需要传递多个参数或多行时，这很有用。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi gj"><img src="../Images/1ff481b95d66630dfc17f64cbf82422c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c5ahAZusp87Bo6Io.jpg"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">双环TDD循环—图像<a class="ae lv" href="http://myscribbledthoughts.info/page/a/atdd-tdd.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="de47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像在双循环TDD中一样，我们将首先让验收测试失败，原因是正确的。</p><p id="b7a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们得到了这样的东西:</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">Specflow —依赖性测试实施步骤</figcaption></figure><p id="a414" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们失败的原因是正确的:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ou"><img src="../Images/d1ba19e4f94021904f3d4a7402de6206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dGlnlJYSEL3Vd1Q5dBp_Q.png"/></div></div></figure><h2 id="27d3" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">解释实施步骤:</h2><p id="f555" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">“Given”是一种简单的类协作技术，我们正在存根销售渠道查询，以便在需要时返回正确的id。</p><p id="0902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“何时”是您的“行为”，我们需要在测试中执行该行为，在这种情况下，它是软件入口点。你可以看到一张“桌子。创建实例”:</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5f41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就像MVC绑定一样，它通过反射基于属性名解析属性。如果表中有多行，可以使用CreateSet而不是Create Instance。</p><p id="936a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于“Then ”,你会看到我没有通过引用相等来处理参数名，所以我必须单独检查每个属性。这是因为不像单元测试，我不能访问存根对象创建。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">模拟验证调用中比较属性的示例</figcaption></figure><h2 id="eea9" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">履行</h2><p id="f223" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">在很好地建立了规范之后，我们得到了驱动实现的测试，通过每个失败指出了实现中缺少的东西。为了不把博文延长太久，我就不一步一步来了。我按照步骤解释了这里的<a class="ae lv" href="https://medium.com/@raphaelyoshiga/practical-tdd-3-9a76b3e045d8" rel="noopener">和</a>。你仍然可以在<a class="ae lv" href="https://github.com/RaphaelYoshiga/Outside.OrderStreamSync" rel="noopener ugc nofollow" target="_blank"> Github </a>中看到最终的结果。</p><h2 id="c87a" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">我的依赖关系是否被测试过？</h2><p id="5037" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">如果你使用进程内无依赖的策略，那么我如何测试我的依赖呢？</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ot"><img src="../Images/38243b068d55be9fc2f4f83d246c9ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndkrurad-ZgoZgLE-KC-fg.png"/></div></div></figure><p id="a137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，为了测试我们是否可以获得正确的销售渠道id，我们必须在数据库中设置数据或者使用预先存在的数据，这样我们就可以在通过销售渠道描述进行查询时进行检查，然后获得预期的id。</p><h1 id="a9e1" class="mb kp it bd kq mc md me kt mf mg mh kw mi mj mk kz ml mm mn lc mo mp mq lf mr bi translated">结论</h1><p id="8669" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">对我来说，内存中的那些验收测试就像第一次发现TDD，以前没有它我怎么工作？我如何测试我的应用程序？花了几个小时试图设置数据，这样我就可以检查特定的场景工作，或者修复那些测试会发现的明显错误。</p><p id="5d8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章能让你:</p><ul class=""><li id="10c0" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated">了解ATDD及其变体的基本概念</li><li id="11a3" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">能够使用引导Specflow单元测试项目。网络核心</li><li id="94a9" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">找到在日常工作中应用ATDD的切入点</li></ul><p id="4e9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干杯，为了更好的编程行业=)</p><h2 id="f8af" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">参考</h2><ul class=""><li id="94a6" class="lm ln it js b jt lh jx li kb ov kf ow kj ox kn lr ls lt lu bi translated"><a class="ae lv" href="https://github.com/RaphaelYoshiga/Outside.OrderStreamSync" rel="noopener ugc nofollow" target="_blank">示例代码</a></li><li id="a90b" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">在测试中，我用<a class="ae lv" href="https://www.nuget.org/packages/moq/" rel="noopener ugc nofollow" target="_blank">的Moq </a>表示模拟，用<a class="ae lv" href="https://github.com/shouldly/shouldly" rel="noopener ugc nofollow" target="_blank">的Shouldly </a>表示断言。</li></ul><p id="b06c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干杯，为了更好的编程行业=)</p><h2 id="f234" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">参考</h2><ul class=""><li id="947a" class="lm ln it js b jt lh jx li kb ov kf ow kj ox kn lr ls lt lu bi translated"><a class="ae lv" href="https://github.com/RaphaelYoshiga/Outside.OrderStreamSync" rel="noopener ugc nofollow" target="_blank">示例代码</a></li><li id="2a02" class="lm ln it js b jt lw jx lx kb ly kf lz kj ma kn lr ls lt lu bi translated">在测试中，我用<a class="ae lv" href="https://www.nuget.org/packages/moq/" rel="noopener ugc nofollow" target="_blank"> Moq </a>表示模拟，用<a class="ae lv" href="https://github.com/shouldly/shouldly" rel="noopener ugc nofollow" target="_blank"> Shouldly </a>表示断言。</li></ul></div></div>    
</body>
</html>