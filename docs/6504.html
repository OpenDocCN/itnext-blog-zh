<html>
<head>
<title>RxJS Operators: Angular — KISS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS运算符:角度-吻</h1>
<blockquote>原文：<a href="https://itnext.io/rxjs-operators-angular-kiss-36d875d2ff7d?source=collection_archive---------3-----------------------#2021-12-05">https://itnext.io/rxjs-operators-angular-kiss-36d875d2ff7d?source=collection_archive---------3-----------------------#2021-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bf87c4fe29e3acaec4052dcac65fec62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZstqIxM_ZDBMucXUsp0yvw.jpeg"/></div></div></figure><p id="a9d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文的目的是为初学者提供使用最常见的RxJS操作符的基本信息，并有望成为未来拥抱反应式编程的火花。本文的目标是不仅提供switchMap、mergeMap、exhaustMap、concatMap的真实用例，而且提供一个小项目作为起点。</p><p id="660e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我研究这些操作符的过程中，我讨厌那些看起来简单容易，但没有揭示操作符真正目的和潜力的例子。我将尽我最大的努力在你的应用程序中提供可理解、可复制的用例，并帮助你获得基本的权利。</p><h2 id="f29b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">项目信息和结构</h2><p id="ad9a" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">今天的项目是一个管理工具，管理员工对公司共享文件夹的访问。让我们欢迎一个空前经典的分页表，它的右边有一个小复选框，这样我们就可以将员工的状态设置为“活动”或“非活动”。我们还能够导出现有员工的文件，并导入新员工的文件。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/d37151e9628b2e2c37cc063f1c9025ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mE3U_X38A3AMSYXPHN89nQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">我们精美的用户界面</figcaption></figure><p id="7844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个智能组件来托管公司员工的表。特定用户的动作触发来自智能组件的事件，并向一个API(在我们的特定例子中是in-memory-web-api)发出一些HTTP调用。当然，任何人都可以在用户选择另一个页面或单击按钮时调用API，并用响应填充视图，但是现在是时候面对一些挑战了。</p><h2 id="a3e4" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">挑战#1:用户快速点击分页器</h2><p id="b901" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">因此，我们有一个用户点击下一页按钮如此之快，以至于一个新的请求在上一个请求完成之前就开始了。当然，我们可以禁用按钮，直到第一个响应到达，但这种方法破坏了用户体验，我们还迫使用户等到数据到达，然后再次单击按钮。相反，我们应该能够无声地<strong class="ka ir">取消</strong>挂起的请求，并开始一个新的请求，而不会打断用户。</p><blockquote class="md me mf"><p id="a7b1" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">当用户点击分页器区域并持有对<code class="fe mk ml mm mn b">users$</code> observable的订阅时，组件发出一个事件。</p></blockquote><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/093b1fd3ab98dde4729750b3fd8e776c.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*L9MBpqqe0B0Mdmlip8P6Wg.png"/></div></figure><blockquote class="md me mf"><p id="344e" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">该服务将主体的事件转换成HTTP调用。因此，由于组件订阅了<code class="fe mk ml mm mn b">users$ </code> observable，所以当数据到达时，组件会得到通知。<code class="fe mk ml mm mn b">switchMap</code>操作符用于取消对当前订阅的订阅(如果没有其他订阅者，则取消未决的HTTP请求),只订阅新的可观察对象。</p></blockquote><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/1edc48f6e7c122acb275acd5d64af287.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*6qLFQtJHaGUFxBCgL53Eww.png"/></div></figure><p id="c101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这绝对有道理。当用户快速换页时，他们真的不关心前几页的结果，而只关心他们将登陆的最后一页。这与<code class="fe mk ml mm mn b">switchMap</code>操作符是一个完美的类比，该操作符取消订阅之前的内部可观察对象，并订阅最新的。</p><h2 id="8dc5" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">挑战2:用户快速点击复选框</strong><em class="mq"/></h2><p id="f0fd" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在这种情况下，用户希望快速点击几个复选框。同样，我们可以在屏幕中央使用加载器，等待复选框的HTTP请求完成，然后触发另一个请求来刷新页面的雇员，只有在更新的数据到达后，隐藏加载器并允许用户继续。让我们关注用户。用户希望单击几个复选框来更改员工的状态，并在没有任何中断的情况下等待更新的数据。因此，我们处于一种会发出几个事件的情况，我们将在<strong class="ka ir">并行</strong>中管理它们，并在之后更新数据。</p><blockquote class="md me mf"><p id="f721" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">当用户点击复选框并订阅<code class="fe mk ml mm mn b">user$</code>观察对象时，组件发出一个事件。当一个雇员被成功更新时，一个新的请求被触发来更新数据。</p></blockquote><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/b7f47ba47b8d1a0366bcc573c6b3e8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*J4u7qdmYwthFFA9__hpAHg.png"/></div></figure><p id="3750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该服务遵循与以前相同的模式，但是这次使用了<code class="fe mk ml mm mn b">mergeMap</code>操作符。因此，该组件维护所有活动请求中的订阅，并且当其中任何一个请求完成时，它将得到通知。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/0171d32143c44e600fee103ff156c5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*UCAiDENkjNRbleI0xO9FvQ.png"/></div></div></figure><p id="e656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种方法，用户能够非常快速地点击许多复选框，并且应用程序能够并行处理请求。当然，有时向一个API发出多个请求并不是最佳的解决方案。更新现有雇员记录布尔值可能没问题，但是如果我们试图创建许多新用户，会发生什么情况呢？</p><h2 id="1a62" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">挑战3:用户导入新员工的JSON文件</h2><p id="bab6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">对于这个用例，让我们假设API每次只能创建一个雇员，但是我们希望允许用户提供一个包含雇员列表的文件，以获得更好的体验。应用程序将读取文件，并为列表中的每个雇员发出一个HTTP请求，但是如果我们并行发出请求，我们将会给后端产生不必要的负载。正确的做法是每次保持一个活动请求，只有在前一个请求完成后才开始下一个请求。当创建了所有新员工后，我们应该刷新数据。</p><blockquote class="md me mf"><p id="e5a1" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">该组件将解析JSON并创建一个雇员列表。我们使用<code class="fe mk ml mm mn b">take</code>操作符来订阅与我们想要创建的雇员数量相等的请求。之后，我们将刷新数据。</p></blockquote><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/c4955e02a908d9048e5fccd197fbde4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*mWAofXGwvY95XlEBpw-s9g.png"/></div></figure><p id="3526" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该服务将使用“from”操作符为每个新员工记录创建一个新的可观察对象。<code class="fe mk ml mm mn b">concatMap</code>操作员将保留一个带有可观察值的队列，并在完成前一个后订阅新的<strong class="ka ir">，因此现在我们能够按顺序处理它们。</strong></p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9888d1d767324b8be0563eaf60870f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*DO-4HJUdi8AuUm4xVw16AQ.png"/></div></figure><h2 id="8f24" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">挑战#4:用户快速点击导出CSV按钮</strong><em class="mq"/></h2><p id="c3ed" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">现在，用户试图下载一个包含所有可用员工的文件。当然，这个动作需要一些时间，并且后端资源非常紧张。我们应该保护API，所以我们必须<strong class="ka ir">忽略</strong>进一步的事件，直到活动的HTTP请求完成。</p><blockquote class="md me mf"><p id="45dc" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">组件订阅了<code class="fe mk ml mm mn b">allUsers$</code> observable，并为每个按钮点击发出一个事件。</p></blockquote><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/f1612b35a8a254df015969e22421211a.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*HfjLfwJTVY1okGCHMTx4cg.png"/></div></figure><blockquote class="md me mf"><p id="db6b" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">当一个CSV文件被请求时，该服务将创建一个新的可观察对象，但是如果有一个已经激活的事件，它将忽略所有其他事件。所以，所有这些大规模点击将不会产生任何影响。如果请求另一种文件类型(如JSON ), filter操作符用于跳过事件。</p></blockquote><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3b8af3b5a79ab4e245e0d3f488fe455f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*89NK762wpAPWaLJhntJRZQ.png"/></div></figure></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="63a8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">奖金</strong></h2><ul class=""><li id="1efa" class="ne nf iq ka b kb lp kf lq kj ng kn nh kr ni kv nj nk nl nm bi translated">当用户想要一次上传多个文件，但是API只接受每个请求一个文件，并且您知道文件处理需要大量资源时，使用<code class="fe mk ml mm mn b">concatMap</code>操作符。您可以在请求中使用一个相关id，还可以包括文件的索引，只要文件的总数。</li><li id="0c87" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">尽可能多地使用<code class="fe mk ml mm mn b">asyncPipe</code>,这样angular就可以退订那些可观的东西了。对于我们必须手动订阅的情况，我们应该确保取消订阅以避免内存泄漏。一种简单的方法是利用<code class="fe mk ml mm mn b">takeUntil</code>操作符，结合一个在组件被销毁时发出一个值的主题。</li></ul><blockquote class="md me mf"><p id="37be" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">在这里  <em class="iq">找到角度代码<a class="ae ns" href="https://github.com/stavrosdro/rxjs-operators" rel="noopener ugc nofollow" target="_blank"> <em class="iq">。</em></a></em></p></blockquote><p id="c6cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mg">享受</em>🚀🚀🚀</p></div></div>    
</body>
</html>