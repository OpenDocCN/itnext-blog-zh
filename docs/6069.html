<html>
<head>
<title>JavaScript Development: Making a Web Worker optional</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript开发:让Web Worker成为可选的</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-development-making-a-web-worker-optional-f23a13490b28?source=collection_archive---------2-----------------------#2021-08-09">https://itnext.io/javascript-development-making-a-web-worker-optional-f23a13490b28?source=collection_archive---------2-----------------------#2021-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在主线程或<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener ugc nofollow" target="_blank"> Web Worker </a>中运行大量JavaScript相关逻辑，那么将昂贵的逻辑转移到另一个Worker中是非常明智的。如果可能的话，工作线程使用自己的CPU在不同的线程中运行。</p><p id="f4d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在某些场景中，一个给定的线程上有很多与JS相关的工作负载，而在其他场景中，这个线程大部分时间是空闲的。</p><p id="beb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的线程大部分时间都是空闲的，您不希望创建额外的工作线程，因为与直接在目标线程中运行相关的业务逻辑相比，基于<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" rel="noopener ugc nofollow" target="_blank"> postMessage </a>的通信会导致延迟。</p><p id="a9be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将介绍一种非常通用的方法，说明如何在保持相同API不变的情况下，有选择地使用额外的工人。</p><h1 id="abcb" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">内容</h1><ol class=""><li id="9425" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">介绍</li><li id="7dc2" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">创建使用可选工作线程的框架配置</li><li id="5935" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">如果需要，创建可选员工</li><li id="3b66" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">查看虚拟dom worker</li><li id="e3b1" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">将vdom引擎动态导入应用工作进程</li><li id="2dd6" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">调查vdom。助手</li><li id="fcdb" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">我们需要调整我们的远程定义吗？</li><li id="ba25" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">远程API是如何工作的？</li><li id="fe3b" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">不使用vdom worker有什么副作用吗？</li><li id="00e7" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">最后的想法</li></ol><h1 id="40ea" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.介绍</h1><p id="3906" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我刚刚完成了<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a> UI框架的PoC实现，使虚拟DOM worker成为可选的。</p><p id="7855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用vdom worker时，我们的workers设置如下所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/50d1e02d9d8dbf987cc30b4153487a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-veT3mNdcZ0jJ4owiQwcQ.png"/></div></div></figure><p id="3cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的应用程序工作人员(主要参与者)大部分时间都处于空闲状态，那么在这个范围内直接运行vdom引擎是有意义的:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6e786310fdaef0aed6e9a3a4f55acbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*CkxpdeEBFoi2Z8ERDn1HrA.png"/></div></figure><p id="8606" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，我们希望两个版本保持相同的API。</p><p id="b80e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现这一点的概念可以在neo.mjs范围之外应用。唯一的需求是一个可靠的抽象层来处理跨工作者的通信。我们还将涉及远程API(远程方法访问),因为它为通信部分提供了一个非常优雅的解决方案。</p><h1 id="8299" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.创建使用可选工作线程的框架配置</h1><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mq"><img src="../Images/8d0ae272aeadaa48ba7fd5ba22c41d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmmUiPvZoWVEtHdZsIJ5_A.png"/></div></div></figure><p id="0917" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这部分比较琐碎。我们只是将新配置放入:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/DefaultConfig.mjs#L190" rel="noopener ugc nofollow" target="_blank">src/default config . mjs # L190</a></p><p id="5261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以在我们要构建的每个应用程序的<code class="fe mr ms mt mu b">neo-config.json</code>文件中使用这个配置:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5e29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(该文件将使用<code class="fe mr ms mt mu b">npx neo-app</code>自动生成)</p><h1 id="0a1c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.如果需要，创建可选员工</h1><p id="edcf" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这部分也很简单。我们正在调整<code class="fe mr ms mt mu b">worker.Manager</code>:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/worker/Manager.mjs#L174" rel="noopener ugc nofollow" target="_blank">src/worker/manager . mjs # L174</a>中的<code class="fe mr ms mt mu b">createWorkers()</code>方法</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8348" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的worker key (name)是“vdom ”,我们的新配置被设置为false，我们就跳过创建。</p><h1 id="2848" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.查看虚拟dom worker</h1><p id="d2d1" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了了解我们需要调整哪个逻辑，我们应该快速查看:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/worker/VDom.mjs" rel="noopener ugc nofollow" target="_blank">src/worker/vdom . mjs</a></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6d54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个工人只是导入<code class="fe mr ms mt mu b">vdom.Helper</code>(vdom引擎)，所以这是唯一需要调整的JS模块。</p><h1 id="2975" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.将vdom引擎动态导入应用工作进程</h1><p id="faec" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">一旦我们的app worker获得了<code class="fe mr ms mt mu b">Neo.config</code>对象，我们需要惰性加载(动态导入)我们的助手类:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/worker/App.mjs#L222" rel="noopener ugc nofollow" target="_blank">src/worker/app . mjs # L222</a></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b79d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在开发模式下运行良好(没有构建/传输),并且<a class="ae kl" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack </a>将为我们调整<code class="fe mr ms mt mu b">dist/development</code>和<code class="fe mr ms mt mu b">dist/production</code>环境的分割块。</p><p id="1c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[旁注]如果您使用基于<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank"> SharedWorkers </a>的多窗口应用程序设置，您需要对运行在同一共享应用程序worker实例中的所有应用程序使用相同的<code class="fe mr ms mt mu b">useVdomWorker</code>配置值。</p><h1 id="867f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">6.调查vdom。助手</h1><p id="b63a" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这个类(singleton)包含了很多不同的方法:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/vdom/Helper.mjs" rel="noopener ugc nofollow" target="_blank">src/vdom/helper . mjs</a></p><p id="f78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关键部分在<code class="fe mr ms mt mu b">static getConfig()</code>里面:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b2f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只向应用程序工作人员公开了<code class="fe mr ms mt mu b">create()</code>和<code class="fe mr ms mt mu b">update()</code>方法。</p><p id="d03d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还不熟悉“远程方法访问”API，您肯定需要更多的输入来了解它的确切含义。</p><p id="2529" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用vdom worker，我们的<code class="fe mr ms mt mu b">vdom.Helper</code> singleton就在vdom worker范围内。在这种情况下，<code class="fe mr ms mt mu b">Neo.vdom</code>是app worker范围内的<code class="fe mr ms mt mu b">undefined</code>。</p><p id="6f3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用remotes API会将这两种方法公开给应用程序工作器。框架将在app worker全局范围内创建<code class="fe mr ms mt mu b">Neo.vdom</code>名称空间。然后我们可以直接调用公开的方法作为承诺。<code class="fe mr ms mt mu b">component.Base</code> (app worker)内部示例:</p><pre class="me mf mg mh gt mx mu my mz aw na bi"><span id="a7e6" class="nb kn iq mu b gy nc nd l ne nf"><strong class="mu ir"><em class="ng">Neo</em></strong>.<strong class="mu ir"><em class="ng">vdom</em></strong>.Helper.update(opts).then(data =&gt; {/*...*/});</span></pre><p id="95df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用公开的方法作为承诺将在内部从应用程序向vdom工作者发送postMessage，用传递的opts参数触发<code class="fe mr ms mt mu b">update()</code>,并将返回值发送回应用程序工作者，应用程序工作者解析承诺。</p><p id="b4ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持我们的API同步，我们需要稍微调整一下我们的<code class="fe mr ms mt mu b">create()</code>和<code class="fe mr ms mt mu b">update()</code>方法的返回值。</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="55f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上我们有两个选择:</p><p id="abb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择一是在我们的代码库中改变这个方法的所有调用(有vdom工作者吗？→称之为承诺，否则直接称之)。这会破坏我们的API。</p><p id="5506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选项二是更改返回值:</p><pre class="me mf mg mh gt mx mu my mz aw na bi"><span id="7a5e" class="nb kn iq mu b gy nc nd l ne nf">return <strong class="mu ir"><em class="ng">Neo</em></strong>.config.useVdomWorker ? node : <strong class="mu ir"><em class="ng">Promise</em></strong>.resolve(node);</span></pre><p id="27e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法已经使API在两种模式下保持同步。</p><p id="d550" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对<code class="fe mr ms mt mu b">update()</code>方法进行同样的修改后，我们就完成了。</p><h1 id="5c81" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">7.我们需要调整我们的远程定义吗？</h1><p id="7e08" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果我们在app worker范围内运行<code class="fe mr ms mt mu b">vdom.Helper</code>，您可能会怀疑<code class="fe mr ms mt mu b">remote</code>定义是否有问题。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b4626c235d9a504a682854b6449642b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*0rJ0rzZHV9NXPP-MiCdq0A.png"/></div></figure><p id="47c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毕竟，我们是在向我们已经在的范围公开方法:)</p><p id="745b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">core.Base</code>将检查相同的作用域，并在这种情况下忽略注册方法:<a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/core/Base.mjs#L357" rel="noopener ugc nofollow" target="_blank"> src/core/Base.mjs#L357 </a></p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="72f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以答案是“不，我们很好”。</p><h1 id="019e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">8.远程API是如何工作的？</h1><p id="a2b0" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果您想将这个概念应用到非基于<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>的环境中，欢迎您根据需要使用代码库(毕竟，整个项目都是MIT授权的)。</p><p id="9e6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经在使用neo，你只需要知道如何使用API。</p><p id="083d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种情况下，我强烈建议深入研究代码库(只有160行)。</p><div class="ni nj gp gr nk nl"><a href="https://github.com/neomjs/neo/blob/dev/src/worker/mixin/RemoteMethodAccess.mjs" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">neo/RemoteMethodAccess.mjs位于dev neomjs/neo</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">应用工人驱动的前端框架。通过创建一个关于…的帐户，为neomjs/neo开发做出贡献</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz mn nl"/></div></div></a></div><p id="8411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">worker.mixin.RemoteMethodAccess</code>确实包含在<code class="fe mr ms mt mu b">worker.Manager</code>(主线程)中，还有<code class="fe mr ms mt mu b">worker.Base</code>。</p><h1 id="fd2f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">9.不使用vdom worker有什么副作用吗？</h1><p id="44a7" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">实际上有一些。Rich Waters早在2015年就实现了这种沟通逻辑，远在我将<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel" rel="noopener ugc nofollow" target="_blank"> MessageChannels </a>添加到组合中之前。</p><p id="f3cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">vdom工作通信的运行方式如下:</p><p id="5c68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">App → Main → VDom → Main → App</p><p id="c1f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在vdom工作器使用<code class="fe mr ms mt mu b">update()</code>方法创建增量或初始vnode通过<code class="fe mr ms mt mu b">create()</code>返回后，这些消息将在返回到应用工作器的途中将更改丢弃到它们所经过的主线程中。</p><p id="0016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是为了保存一个额外的消息链:</p><p id="7ef6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">App → Main → App</p><p id="fddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，如果我们直接在app worker范围内运行vdom引擎，则根本没有后消息链。</p><p id="5376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我调整了<code class="fe mr ms mt mu b">component.Base.render()</code>来触发<code class="fe mr ms mt mu b">this.mount()</code>以及<code class="fe mr ms mt mu b">updateVdom()</code>来触发<code class="fe mr ms mt mu b">Neo.applyDeltas()</code>，以防我们不使用vdom工作器。</p><p id="8916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使我们在新的非vdom工作环境中即时解析承诺，承诺仍然是异步的:</p><figure class="me mf mg mh gt mi"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="697e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">意思是:如果你在一个类方法中触发了一个更新，比如:</p><pre class="me mf mg mh gt mx mu my mz aw na bi"><span id="f430" class="nb kn iq mu b gy nc nd l ne nf">this.vdom = vdom;</span></pre><p id="4091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新状态(vnode)在此方法中不可用。显然你可以在1ms后使用<code class="fe mr ms mt mu b">setTimeout()</code>来确保安全。</p><p id="ede4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在新的vnode就位之前触发了另一个vdom引擎更新，这可能会带来麻烦。</p><p id="24de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mr ms mt mu b">component.Base</code>内部有一个故障保险，防止在更新仍在运行时调用新的引擎。在这种情况下，累积更新将发生在上次更新之后。</p><p id="7cff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，引擎调用不会锁定父组件树进行更新。这可能是一个很好的补充(随意开一张票)。</p><h1 id="ecf9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">10.最后的想法</h1><p id="d88c" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">“应用程序工作人员是主要参与者”范例可以显著提高您的前端相关代码库的性能。</p><p id="5bb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在生态系统内进行了12，000多次提交后，使用neo的好处是我无法在此列出的。</p><p id="0d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只能重复我自己的话，并强烈建议深入研究代码库:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">GitHub - neomjs/neo:应用工人驱动的前端框架</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序。不需要照顾一个…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz mn nl"/></div></div></a></div><p id="9322" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您希望看到可选工作器的概念也应用于neo数据工作器，欢迎您开一张票。</p><p id="ea55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用日历应用程序测试了非vdom工作者设置，这个运行得非常好。</p><p id="de1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">covid应用程序也可以很好地渲染，但是有一些副作用(例如，表格选择没有得到可视化应用)。</p><p id="2897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于演示应用程序不会触发大量与JS相关的逻辑，因此不使用vdom工作人员会感觉快一拍。</p><p id="5e8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以做一些基准测试，让“感觉”变成更精确的数字。非常感谢您的帮助！</p><p id="79f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我确实在寻找更多关于这个话题的反馈:</p><p id="f334" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在app worker中运行虚拟dom引擎的设置是不是一个有趣的话题，是不是我们应该投入更多时间来完善它？</p><p id="3db6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路线图仍然很紧张，所以进一步推动这个主题<strong class="jp ir">强烈</strong>依赖于你的投入。</p><p id="07e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常欢迎您加入Slack频道:</p><div class="ni nj gp gr nk nl"><a href="https://join.slack.com/t/neomjs/shared_invite/zt-6c50ueeu-3E1~M4T9xkNnb~M_prEEOA" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">在Slack上加入neo.mjs</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">Slack是一种与团队沟通的新方式。它比电子邮件更快、更有条理、更安全。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">join.slack.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz mn nl"/></div></div></a></div><p id="8b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><p id="2e54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:下面是使vdom worker可选的完整更改日志:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/neomjs/neo/commit/4287eb438e40fbfd44b5956323fa74b766761f5e" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">来自neomjs/dev neomjs/neo@4287eb4的合并拉取请求#2690</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">应用工人驱动的前端框架。通过创建一个关于…的帐户，为neomjs/neo开发做出贡献</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="oc l nw nx ny nu nz mn nl"/></div></div></a></div><p id="6b7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">56处增加，27处删除。</p></div></div>    
</body>
</html>