<html>
<head>
<title>Kubernetes GitOps Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes GitOps工具</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-gitops-tools-cf0247eb5368?source=collection_archive---------0-----------------------#2021-10-26">https://itnext.io/kubernetes-gitops-tools-cf0247eb5368?source=collection_archive---------0-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/574fab7df66238fe911f10294d1e174b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hgpN9VUW-0RPz3KD"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e501" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="2dfe" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我将回顾一下我最喜欢的<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>工具目前在<a class="ae kf" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kubernetes </strong> </a>中可用。这篇文章基于我之前的一篇文章，在这篇文章中我回顾了更多我最喜欢的Kubernetes工具。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="bb13" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">在我看来，<a class="ae kf" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kubernetes </strong> </a>的主要优势在于其<strong class="lg iu">声明性</strong>与控制循环相结合，控制循环持续观察集群的实时状态，确保其与<a class="ae kf" href="https://www.ibm.com/cloud/learn/etcd" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> etcd </strong> </a>中存储的期望状态相匹配。这个想法本身非常强大，但它仅限于不能提供足够可见性的<a class="ae kf" href="https://www.ibm.com/cloud/learn/etcd" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> etcd </strong> </a>数据库。这限制了应用到集群中的变更的责任性和可审核性。另一个缺点是，我们最终会有两个真实的来源，<a class="ae kf" href="https://www.ibm.com/cloud/learn/etcd" rel="noopener ugc nofollow" target="_blank"> etcd </a>和代码库，这可能会产生非常难以管理的配置漂移。</p><p id="6888" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">开发人员长期以来一直在使用代码库，以便以一种安全且完全可追踪的方式轻松存储代码。<a class="ae kf" href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">开发工作流</strong> </a>是为了以一种高效的方式管理一个中央存储库，在这里不同的团队成员可以并行工作而不会有太多的摩擦，同时确保任何更改都是可审查的、可追踪的并且易于回滚。</p><p id="b108" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">如果我们能够从围绕Git存储库创建的流程中获得所有这些巨大的优势，并将它们扩展到基础设施中，这不是很好吗？Kubernetes怎么样？…欢迎来到<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>世界！</p><p id="9c20" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">首先，我将简单介绍一下什么是<strong class="lg iu"> GitOps </strong>以及如何将其应用于Kubernetes，然后转向声明性GitOps工具，即用于在Kubernetes中实现GitOps的工具，最后回顾一些对<strong class="lg iu"> GitOps </strong>友好的工具，即它们是声明性的，并作为代码实现。</p><h1 id="20f8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是GitOps？</h1><p id="00e6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>的目标是将这种声明性从<a class="ae kf" href="https://www.ibm.com/cloud/learn/etcd" rel="noopener ugc nofollow" target="_blank"> etcd </a>一直扩展到代码所在的<strong class="lg iu"> Git </strong> <strong class="lg iu">库</strong>中，从而创建一个单一的事实来源。通过这样做，我们还获得了成熟Git过程的所有优势，如代码审查、历史、快速回滚、可追溯性等等。</p><blockquote class="mo mp mq"><p id="9db6" class="le lf mr lg b lh mj lj lk ll mk ln lo ms ml lr ls mt mm lv lw mu mn lz ma mb im bi translated">GitOps的核心思想是拥有一个Git存储库，该存储库总是包含生产环境中当前所需的基础设施的声明性描述，以及一个使生产环境与存储库中描述的状态相匹配的自动化过程。如果您想要部署一个新的应用程序或更新一个现有的应用程序，您只需要更新存储库—自动化过程会处理所有其他事情。这就像用巡航控制来管理生产中的应用程序一样。—<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank">https://www.gitops.tech/</a></p></blockquote><p id="bee8" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> GitOps </strong>并不特定于Kubernetes，事实上它是通过将<a class="ae kf" href="https://www.ibm.com/cloud/learn/infrastructure-as-code" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">基础设施作为代码</strong> </a>存储在Git存储库中，将应用程序代码最佳实践扩展到基础设施。这是通过<a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>等工具推广的。注意<a class="ae kf" href="https://www.ibm.com/cloud/learn/infrastructure-as-code" rel="noopener ugc nofollow" target="_blank">代码形式的声明性基础设施</a>对于实现GitOps起着巨大的作用，但不仅仅如此。GitOps利用Git的整个生态系统和工具，并将其应用于基础设施。仅仅将Terraform文件放在Git中并不能保证基础设施的状态总是与生产环境的状态相匹配。您将需要连续运行Terraform命令(<code class="fe mv mw mx my b">terraform apply</code>)来观看实况版本，并且您将需要在您的管道中实现手动批准等等。</p><p id="5925" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">GitOps的思想是持续观察集群的状态，并将其与Git存储库进行比较，并在出现配置偏差时立即做出任何更改。最重要的是，您可以获得Git的所有好处，比如可以用于人工批准的代码审查。</p><p id="a648" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">对我来说，这个想法是革命性的，如果做得好，将使组织更多地关注特性，而不是为自动化编写脚本。这个概念可以扩展到软件开发的其他领域，例如，您可以在代码中存储您的文档，以跟踪更改的历史，并确保文档是最新的；或者使用<a class="ae kf" href="https://github.com/jamesmh/architecture_decision_record" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> ADRs </strong> </a>跟踪架构决策。</p><h1 id="f476" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">库贝内特斯的吉托普</h1><p id="13bb" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu"> Kubernetes </strong>采用了自下而上的控制循环的理念，这意味着Kubernetes总是在观察集群的状态，以确保它与所需的状态相匹配，例如，运行的副本数量与所需的副本数量相匹配。GitOps的想法是将其扩展到应用程序，这样您就可以将您的服务定义为代码，例如，通过定义<a class="ae kf" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Helm </strong> </a>图表，并使用一个利用K8s功能的工具来监控您的应用程序的状态并相应地调整集群。也就是说，如果更新您的代码库，或者您的舵图，生产集群也会更新。这才是真正的<a class="ae kf" href="https://en.wikipedia.org/wiki/Continuous_deployment" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">连续部署</strong> </a>。核心原则是应用程序部署和生命周期管理应该是自动化的、可审计的和易于理解的。</p><p id="09dd" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">这个想法是为每个环境建立一个代码存储库，您可以在其中定义给定集群的期望状态。然后，Kubernetes <a class="ae kf" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">操作符</strong> </a>将继续监控特定的分支(通常是主分支),当在Git中检测到变化时，它将传播到集群，并在<strong class="lg iu"> etcd </strong>中更新状态。通过这种方式，<a class="ae kf" href="https://www.ibm.com/cloud/learn/etcd" rel="noopener ugc nofollow" target="_blank"> etcd </a>只是作为一个数据库，而不是事实的集群单一来源。在包含声明性Kubernetes基础设施的Git存储库中，可以有定义应用程序的Helm chart定义。此外，您可以链接存储库，以便一个存储库监视另一个存储库，以此类推。Kubernetes <strong class="lg iu"> GitOps </strong>工具可以监视其他存储库，如<strong class="lg iu"> Helm </strong>图表存储库，这样您的集群环境存储库就不必拥有Helm图表本身，而是拥有一个指向Helm存储库的链接，该存储库也会被监控更改，因此当您发布新图表时，它会自动部署到集群中。这样，您可以拥有自动的端到端<strong class="lg iu">声明性CI/CD管道</strong>。</p><h1 id="c015" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">声明性GitOps工具</h1><p id="fa7b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果我们正在讨论Kubernetes中的GitOps，我们应该从讨论Kubernetes中实现GitOps原则的工具开始，这些工具负责监视Git的状态，并将其与集群同步。</p><h2 id="59ba" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">ArgoCD</h2><p id="8bb1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在我看来，<strong class="lg iu"> Kubernetes </strong>中最好的GitOps工具是<a class="ae kf" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> ArgoCD </strong> </a>。你可以在这里了解更多。ArgoCD是Argo生态系统的一部分，该生态系统还包括一些其他优秀的工具，其中一些我们将在后面讨论。</p><p id="59c5" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">有了ArgoCD，你可以在一个代码库中拥有每一个环境，在这里你可以定义该环境的所有配置。Argo CD在指定的目标环境中自动部署所需的应用程序状态。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/2f0f1d3bea9330841f270e4760fe3225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gsrntsULnIcFYmtO.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">ArgoCD建筑</figcaption></figure><p id="36e8" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">Argo CD被实现为一个<strong class="lg iu"> kubernetes控制器</strong>，该控制器持续监控运行的应用程序，并将当前的实时状态与所需的目标状态进行比较(如Git报告中所指定的)。Argo CD报告并可视化这些差异，并且可以自动或手动将实时状态同步回所需的目标状态。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/3626873805b8f2fda3438a6c48763b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_81kpMBn5SDDKFPt.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">行动中的ArgoCD</figcaption></figure><p id="9372" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">ArgoCD 有一个优秀的用户界面，<strong class="lg iu"> SSO </strong>支持，它是安全的，可扩展的，非常容易使用。</p><h2 id="d4de" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">流量</h2><p id="2be1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Flux </strong> </a>是ArgoCD的另一个非常受欢迎的替代品。新版本包括许多改进，功能与ArgoCD非常相似。Flux是一个<strong class="lg iu"> CNCF </strong>在孵项目。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/491535eb196eb5db1705f728e1eca0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKWgzWN26QmwRBVEHxJ4dg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">通量特征</figcaption></figure><h1 id="2bba" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">GitOps工具</h1><p id="d233" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这一节中，我们将回顾一些我最喜欢的<strong class="lg iu"> GitOps友好</strong>工具。简而言之，任何基于<a class="ae kf" href="https://www.bmc.com/blogs/kubernetes-crd-custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">自定义资源定义(CRDs) </strong> </a>的工具都应该是GitOps友好的。</p><h2 id="0568" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">舵</h2><p id="f8cf" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">掌舵人</strong> </a>应该不需要介绍，对于Kubernetes来说最著名的<strong class="lg iu">包经理</strong>。是的，你应该在K8s中使用包管理器，就像你在编程语言中使用它一样。Helm允许您将应用打包在<a class="ae kf" href="https://artifacthub.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">图表</strong> </a>中，这些图表将复杂的应用抽象为可重用的简单组件，易于定义、安装和更新。</p><p id="00eb" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">它还提供了强大的<strong class="lg iu">模板引擎</strong>。Helm 很成熟，有很多预定义的图表，很好的支持，并且很容易使用。</p><p id="8c2e" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">Helm 与<strong class="lg iu"> ArgoCD </strong>或<strong class="lg iu"> Flux </strong>完美集成，因为两者都可以查看Helm存储库并在新图表发布时部署它们。这个想法是将ArgoCD或Flux指向一个Helm存储库，并指定一个特定的版本或通配符版本。如果使用通配符，每当发布新版本时，都会自动部署它。您可以使用主要版本或次要版本。我通常喜欢将我的应用程序打包成图表，作为CI/CD的一部分构建，然后让ArgoCD监视特定的存储库。这种<strong class="lg iu">关注点分离</strong>允许开发人员在独立于环境的单独存储库中管理他们的应用程序，然后让<strong class="lg iu">argod</strong>选择将哪些图表部署到哪些环境。您可以使用多个Helm存储库，并根据不同的环境执行提升。例如，在一个PR被合并之后，你可以做一个“bronce”构建，它作为一个掌舵图被发布到一个“bronce”存储库中。dev environment ArgoCD存储库将指向“bronce”存储库，并将在可用时部署新版本。暂存环境ArgoCD存储库将指向“白银”存储库，而生产环境将指向黄金存储库。当您想要将某些内容升级到试运行或生产时，您的CI/CD只需将图表发布到下一个存储库。</p><p id="75bf" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> ArgoCD </strong>可以覆盖任何环境特定的<strong class="lg iu">舵</strong>值。</p><p id="8475" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">Kustomize  是helm的一个更新更好的选择，它不使用模板引擎，而是一个覆盖引擎，你可以在上面有基本定义和覆盖。</p><h2 id="3e22" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">Argo工作流和Argo事件</h2><p id="877c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在Kubernetes中，您可能还需要运行<strong class="lg iu">批处理作业或复杂的工作流</strong>。这可能是您的数据管道、异步流程甚至CI/CD的一部分。除此之外，您甚至可能需要运行驱动的微服务，对某些事件做出反应，如文件上传或消息发送到队列。对于这一切，我们有<a class="ae kf" href="https://argoproj.github.io/argo-workflows/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">蓉城</strong> </a>和<a class="ae kf" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">蓉城事件</strong> </a>。</p><p id="c1b1" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">尽管它们是独立的项目，但它们往往会一起部署。</p><p id="e70e" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">Argo Workflows是一个<strong class="lg iu">编排</strong> <strong class="lg iu">引擎</strong>，类似于<a class="ae kf" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a>，但原生于Kubernetes。它使用自定义的<strong class="lg iu"> CRDs </strong>来定义复杂的工作流程，使用K8s中感觉更自然的<a class="ae kf" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Dag</strong></a>来定义复杂的工作流程。它有一个很好的用户界面，重试机制，基于cron的工作，输入和输出跟踪等等。您可以使用它来编排数据管道、批处理作业等等。</p><p id="a2a7" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">有时，您可能希望将您的管道与异步服务集成，如流引擎(如<a class="ae kf" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Kafka</strong></a><strong class="lg iu">)</strong>、队列、webhooks或深度存储服务。例如，您可能希望对上传到S3的文件等事件做出反应。为此，你要用<a class="ae kf" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">蓉城事件</strong> </a>。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/80130a0fa5ae09067f24270a2ea5e75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0vRh9VPFHhGPkimQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阿尔戈事件</figcaption></figure><p id="ee33" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">这两个工具结合起来为您的所有管道需求提供了一个简单而强大的解决方案，包括<strong class="lg iu"> CI/CD </strong>管道，它将允许您在Kubernetes中本地运行CI/CD管道。</p><p id="7ea7" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">正如您所料，Argo工作流与<strong class="lg iu"> ArgoCD </strong>完美集成，因为所有工作流定义都是<strong class="lg iu"> CRDs </strong>，可以打包到舵图中。</p><p id="d38e" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">对于ML管道，您可以使用为此目的而构建的<a class="ae kf" href="https://www.kubeflow.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">kube flow</strong></a><strong class="lg iu"/>。</p><p id="a9fd" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">对于CI/CD管线，您可以使用<a class="ae kf" href="https://tekton.dev/docs/pipelines/pipelines/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Tekton </strong> </a>。</p><h1 id="8da3" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">伊斯迪奥</h1><p id="eadb" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Istio </strong> </a>是市面上最著名的<a class="ae kf" href="https://en.wikipedia.org/wiki/Service_mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">服务网</strong> </a>，它是开源的，非常受欢迎。我不会详细讨论什么是服务网格，因为这是一个很大的话题，但是如果您正在构建<a class="ae kf" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">微服务</strong> </a>，并且很可能您应该这样做，那么您将需要一个服务网格来管理通信、可观察性、错误处理、安全性以及作为<strong class="lg iu">微服务架构</strong>一部分的所有其他交叉方面。与其用重复的逻辑污染每个微服务的代码，不如利用服务网格来为您做这件事。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/8cbd35689ae5ddf73a52c9c4a96477d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*75sT0YpmxgH13h1n"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Istio建筑</figcaption></figure><p id="c412" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">简而言之，服务网格是一个可以添加到应用程序中的专用基础设施层。它允许您透明地添加诸如可观察性、流量管理和安全性等功能，而无需将它们添加到您自己的代码中。</p><p id="7c43" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> Istio </strong>使用<a class="ae kf" href="https://www.bmc.com/blogs/kubernetes-crd-custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank"> CRDs </a>实现其所有功能，因此虚拟服务、网关、策略等可以定义为代码，打包为舵图，并与ArgoCD或Flux making Istio一起使用，不仅非常强大，而且<strong class="lg iu">gitop</strong>友好。</p><p id="cec5" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://linkerd.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">Linkerd</strong></a><strong class="lg iu"/>或者<strong class="lg iu"> </strong> <a class="ae kf" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">领事</strong> </a>都是<strong class="lg iu"> Istio的绝佳替代品。</strong></p><h2 id="7a19" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">阿尔戈推出</h2><p id="b3f6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们已经提到过，您可以使用Kubernetes，通过使用<strong class="lg iu"> Argo工作流</strong>或类似的工具来运行您的CI/CD管道。下一个合乎逻辑的步骤是继续进行<strong class="lg iu">连续部署</strong>。由于所涉及的高风险，这在现实场景中极具挑战性，这就是为什么大多数公司只做<strong class="lg iu">连续交付</strong>，这意味着他们已经有了自动化，但他们仍然有手动批准和验证，这一手动步骤是由团队<strong class="lg iu">不能完全信任他们的自动化这一事实造成的。</strong></p><p id="daf8" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">那么，如何建立这种信任，以便能够摆脱所有的脚本，从源代码到生产全自动化呢？答案是:<strong class="lg iu">可观测性</strong>。您需要将资源更多地集中在指标上，并收集准确表示应用程序状态所需的所有数据。目标是使用一组指标来建立信任。如果您在<a class="ae kf" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">普罗米修斯</strong> </a>中拥有所有数据，那么您可以自动化部署，因为您可以基于这些指标自动化应用程序的逐步推出。</p><p id="102a" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">简而言之，你需要比K8s现成提供的<a class="ae kf" href="https://www.educative.io/blog/kubernetes-deployments-strategies" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">滚动更新</strong> </a>更高级的部署技术。我们需要使用<a class="ae kf" href="https://semaphoreci.com/blog/what-is-canary-deployment" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">金丝雀</strong>部署</a>的渐进式交付。目标是逐步将流量路由到新版本的应用程序，等待收集指标，分析这些指标，并将其与预定义的规则进行匹配。如果一切正常，我们增加流量；如果有任何问题，我们将回滚部署。</p><p id="9ee2" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">要在Kubernetes中做到这一点，你可以使用<a class="ae kf" href="https://argoproj.github.io/argo-rollouts/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Argo Rollouts </strong> </a>，它提供金丝雀版本等等。</p><blockquote class="mo mp mq"><p id="c8e6" class="le lf mr lg b lh mj lj lk ll mk ln lo ms ml lr ls mt mm lv lw mu mn lz ma mb im bi translated"><em class="it"> Argo Rollouts是一个</em> <a class="ae kf" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Kubernetes控制器</em> </a> <em class="it">和一组</em><a class="ae kf" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="it">CRDs</em></strong></a><em class="it">为Kubernetes提供高级部署功能，如蓝绿、金丝雀、金丝雀分析、实验和渐进式交付功能。</em></p></blockquote><p id="ee18" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">虽然像<a class="ae kf" href="https://istio.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Istio </strong> </a>这样的服务网格提供金丝雀版本，但Argo Rollouts使这一过程变得更加容易和以开发者为中心，因为它是专门为此目的而构建的。除此之外，<strong class="lg iu"> Argo部署</strong>可以与任何服务网格集成。</p><p id="56d3" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> Argo展示</strong>是<strong class="lg iu"> GitOps </strong>友好的，并且与<strong class="lg iu"> Argo工作流程</strong>和<strong class="lg iu"> ArgoCD完美集成；结合这3个工具，你可以创建一个非常强大的声明性工具集来满足你所有的部署需求。</strong></p><p id="b6a5" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://flagger.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Flagger </strong> </a>非常类似于Argo的推出，并且它与<a class="ae kf" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Flux </strong> </a>非常好地集成在一起，所以如果你的ar使用Flux，请考虑<a class="ae kf" href="https://flagger.app/" rel="noopener ugc nofollow" target="_blank"> Flagger </a>。</p><h2 id="af1b" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">交叉平面</h2><p id="b15b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://crossplane.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Crossplane </strong> </a>是我的新宠<strong class="lg iu"> K8s </strong>工具，它为Kubernetes带来了关键的缺失部分:<strong class="lg iu">管理第三方服务，就像它们是K8s资源一样</strong>。这意味着，您可以供应云提供商数据库，如<strong class="lg iu">AWS</strong><a class="ae kf" href="https://aws.amazon.com/rds/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">RDS</strong></a>或<strong class="lg iu"> GCP </strong> <strong class="lg iu">云SQL </strong>，就像您在K8s中供应数据库一样，使用在<strong class="lg iu"> YAML </strong>中定义的K8s资源。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/62c28ba20ef6e25f39b432bb66858e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*7LoW6t9We-cEOuTL.png"/></div></figure><p id="5187" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">有了<strong class="lg iu">交叉平面</strong>，就不需要使用不同的工具和方法来分离基础设施和代码。<strong class="lg iu">你可以用K8s资源定义一切。</strong>这样就不需要学习<a class="ae kf" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Terraform </strong> </a>等新工具，单独保存。</p><blockquote class="mo mp mq"><p id="6100" class="le lf mr lg b lh mj lj lk ll mk ln lo ms ml lr ls mt mm lv lw mu mn lz ma mb im bi translated"><em class="it"> Crossplane是一个开源的Kubernetes插件，它使平台团队能够组装来自多个供应商的基础设施，并为应用团队提供更高级别的自助服务API，而无需编写任何代码。</em></p></blockquote><p id="b5d8" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> Crossplane </strong>扩展您的Kubernetes集群，为您提供适用于任何基础设施或托管云服务的<strong class="lg iu"> CRDs </strong>。此外，它允许您完全实施<strong class="lg iu">连续部署</strong>，因为与其他工具(如Terraform)相反，Crossplane使用现有的K8s功能(如控制循环)来持续监视您的集群，并自动检测任何配置漂移。例如，如果您定义了一个托管数据库实例，而有人手动更改了它，Crossplane将自动检测到该问题，并将其设置回以前的值。这将基础设施作为代码和<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>原则来实施。</p><p id="8bf3" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> Crossplane </strong>与Argo CD配合使用非常好，它可以查看源代码，并确保您的代码报告是真实的单一来源，并且代码中的任何更改都会传播到集群和外部云服务。</p><p id="8925" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">如果没有Crossplane，您只能在K8s服务中实现<a class="ae kf" href="https://www.gitops.tech/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> GitOps </strong> </a>，而不能在不使用单独流程的情况下实现云服务，现在您可以这样做了，这太棒了。</p><h2 id="9e16" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">Kyverno</h2><p id="f75e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Kubernetes提供了很大的灵活性，以增强敏捷自治团队的能力，但是能力越大，责任越大。必须有一套<strong class="lg iu">最佳实践和规则</strong>来确保以一致和连贯的方式部署和管理符合公司政策和安全要求的工作负载。</p><p id="6899" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">有几个工具可以做到这一点，但没有一个是Kubernetes自带的…直到现在。<a class="ae kf" href="https://kyverno.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kyverno </strong> </a>是一个为Kubernetes设计的策略引擎，策略作为Kubernetes的资源进行管理，不需要新的语言来编写策略。Kyverno策略可以验证、变异和生成Kubernetes资源。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/fae8547cb6a5f811870f8db134ae2751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-WICZOre7z73YkaZ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Kyverno政策是一系列规则的集合。每个规则由一个<code class="fe mv mw mx my b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/match-exclude/" rel="noopener ugc nofollow" target="_blank">match</a></code>子句、一个可选的<code class="fe mv mw mx my b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/match-exclude/" rel="noopener ugc nofollow" target="_blank">exclude</a></code>子句以及一个<code class="fe mv mw mx my b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/validate/" rel="noopener ugc nofollow" target="_blank">validate</a></code>、<code class="fe mv mw mx my b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/mutate/" rel="noopener ugc nofollow" target="_blank">mutate</a></code>或<code class="fe mv mw mx my b"><a class="ae kf" href="https://kyverno.io/docs/writing-policies/generate" rel="noopener ugc nofollow" target="_blank">generate</a></code>子句组成。一个规则定义只能包含一个<code class="fe mv mw mx my b">validate</code>、<code class="fe mv mw mx my b">mutate</code>或<code class="fe mv mw mx my b">generate</code>子节点。</figcaption></figure><p id="a792" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">您可以应用任何一种关于最佳实践、网络或安全性的策略。例如，您可以强制所有服务都有标签，或者所有容器都作为非根运行。你可以点击查看一些政策示例<a class="ae kf" href="https://github.com/kyverno/policies/" rel="noopener ugc nofollow" target="_blank">。策略可以应用于整个集群或给定的命名空间。您还可以选择是否只想<strong class="lg iu">审核</strong>策略或者强制执行这些策略来阻止用户部署资源。</a></p><h2 id="5392" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">库伯韦拉</h2><p id="6152" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Kubernetes的一个问题是，开发人员需要非常了解平台和集群配置。许多人会认为K8s的抽象层次太低，这给那些只想专注于编写和发布应用程序的开发人员造成了很多摩擦。</p><p id="2f70" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu">开放应用模型</strong> ( <a class="ae kf" href="https://oam.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> OAM </strong> </a>)就是为了克服这个问题而产生的。这个想法是围绕独立于底层运行时的应用程序创建一个更高层次的抽象。你可以在这里阅读规格<a class="ae kf" href="https://github.com/oam-dev/spec" rel="noopener ugc nofollow" target="_blank"/>。</p><blockquote class="mo mp mq"><p id="b188" class="le lf mr lg b lh mj lj lk ll mk ln lo ms ml lr ls mt mm lv lw mu mn lz ma mb im bi translated"><em class="it">开放式应用模型[OAM]专注于应用，而不是容器或流程编排器，它采用模块化、可扩展和可移植的设计，通过更高级但一致的API为应用部署建模。</em></p></blockquote><p id="b1ce" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://kubevela.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Kubevela </strong> </a>是OAM模型的一种实现。KubeVela是运行时不可知的，本机可扩展，但最重要的是，<em class="mr">以应用为中心</em>。在Kubevela中，应用程序是作为Kubernetes资源实现的一等公民。<strong class="lg iu">集群运营者(平台团队)和开发者(应用团队)是有区别的。</strong>集群操作员通过定义<strong class="lg iu">组件</strong>(组成您的应用程序的可部署/可临时提供的实体，如helm charts)和<a class="ae kf" href="https://kubevela.io/docs/platform-engineers/cue/trait/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">特征</strong> </a> <strong class="lg iu">来管理集群和不同的环境。</strong>开发者通过组装组件和特征来定义应用。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/410cb42b5067a625672761074d589952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZRwUM9bljhCXfAhm.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">平台团队:将平台功能建模和管理为组件或特征，以及目标环境规范。应用程序团队:选择一个环境，根据需要用组件和特征组装应用程序，并将其部署到目标环境。</figcaption></figure><p id="5974" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><strong class="lg iu"> KubeVela </strong>是一个<a class="ae kf" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a>沙盒项目，尽管它仍处于起步阶段，但它可以在不久的将来改变我们使用Kubernetes的方式，允许开发人员专注于应用程序，而无需成为Kubernetes专家。然而，我确实对<strong class="lg iu"> OAM </strong>在现实世界中的适用性有些担心，因为一些服务，如系统应用程序、ML或大数据流程，在很大程度上依赖于底层细节，这些细节可能很难融入OAM模型。</p><h2 id="a1b2" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">模式英雄</h2><p id="a717" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">软件开发中的另一个常见过程是在使用关系数据库时管理<strong class="lg iu">模式演变</strong>。</p><p id="8ec5" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">SchemaHero  是一个开源数据库<strong class="lg iu">模式迁移</strong>工具，它将模式定义转换成可以在任何环境中应用的迁移脚本。它使用Kubernetes的声明性来管理数据库模式迁移。您只需指定所需的状态，其余的由SchemaHero 管理。</p><h2 id="515d" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">比特纳米密封的秘密</h2><p id="5d57" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们已经涵盖了许多<strong class="lg iu"> GitOps </strong>工具，如<a class="ae kf" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> ArgoCD </strong> </a>。我们的目标是将一切都保存在Git中，并使用Kubernetes的声明性来保持环境同步。我们刚刚看到了我们如何能够(也应该)在Git中保留我们的真实来源，并让自动化流程处理配置更改。</p><p id="9aef" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">在Git中通常很难保存的一件事是秘密，比如数据库密码或API密匙，这是因为<strong class="lg iu">你不应该在你的代码库中保存秘密。</strong>一种常见的解决方案是使用外部保险库，如<a class="ae kf" href="https://aws.amazon.com/secrets-manager/" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu">AWS Secret Manager</strong></a><strong class="lg iu"/>或HashiCorp <strong class="lg iu"> </strong> <a class="ae kf" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">保险库</strong> </a> <strong class="lg iu"> </strong>来存储机密，但这造成了很多摩擦，因为您需要有一个单独的进程来处理机密。理想情况下，我们希望能够像其他资源一样，在Git中安全地存储秘密。</p><p id="7652" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://github.com/bitnami-labs/sealed-secrets" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">密封机密</strong> </a>就是为了克服这个问题而产生的，它允许你通过使用强加密将你的敏感数据存储在Git中。Bitnami <strong class="lg iu"> Sealed Secrets </strong>原生集成在Kubernetes中，允许您仅通过运行在Kubernetes中的Kubernetes控制器解密秘密，而不是其他人。控制器将解密数据并创建安全存储的本地K8s秘密。这使我们能够将所有内容作为代码存储在我们的repo中，使我们能够安全地执行连续部署，而无需任何外部依赖。</p><p id="31e0" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">密封的秘密由<strong class="lg iu">和</strong>两部分组成:</p><ul class=""><li id="dc6b" class="nu nv it lg b lh mj ll mk lp nw lt nx lx ny mb nz oa ob oc bi translated">集群侧控制器</li><li id="0449" class="nu nv it lg b lh od ll oe lp of lt og lx oh mb nz oa ob oc bi translated">客户端实用程序:<code class="fe mv mw mx my b">kubeseal</code></li></ul><p id="5f4d" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><code class="fe mv mw mx my b">kubeseal</code>实用程序使用非对称加密来加密只有控制器才能解密的秘密。这些加密的秘密被编码在一个<code class="fe mv mw mx my b">SealedSecret</code> K8s资源中，您可以将它存储在<strong class="lg iu"> Git </strong>中。</p><h2 id="6aed" class="mz kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">胶囊</h2><p id="1962" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">许多公司使用多租户来管理不同的客户。这在软件开发中很常见，但在Kubernetes中很难实现。<strong class="lg iu">名称空间</strong>是将集群的逻辑分区创建为隔离的<em class="mr">片</em>的好方法，但是这还不够，为了安全地隔离客户，我们需要实施网络策略、配额等等。您可以为每个名称空间创建网络策略和规则，但这是一个很难扩展的繁琐过程。此外，租户将不能使用一个以上的名称空间，这是一个很大的限制。</p><p id="9ec3" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://kubernetes.io/blog/2020/08/14/introducing-hierarchical-namespaces/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">分层名称空间</strong> </a>就是为了克服这些问题而产生的。这个想法是为每个租户提供一个父名称空间，并为租户提供通用的网络策略和配额，同时允许创建子名称空间。这是一个很大的改进，但是它在安全性和治理方面没有对租户的本地支持。此外，它还没有达到生产状态，但版本1.0预计将在未来几个月内发布。</p><p id="e96d" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">目前解决这一问题的一种常见方法是为每个客户创建一个群集，这是安全的，可以提供租户所需的一切，但这很难管理，而且非常昂贵。</p><p id="ef16" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://github.com/clastix/capsule" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Capsule </strong> </a>是一个为单个集群中的多个租户提供原生Kubernetes <strong class="lg iu">支持的工具。</strong>使用Capsule，您可以为所有租户创建一个集群。Capsule将为租户提供“几乎”本地的体验(有一些小的限制)，租户将能够创建多个名称空间并使用集群，因为集群对他们来说是完全可用的，从而隐藏了集群实际上是共享的这一事实。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/bcd3411647101a28fc7bf7ebdc54afd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S4BCtusn_Ko0K3-D.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">胶囊建筑</figcaption></figure><p id="4f2a" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">在单个集群中，Capsule控制器在一个名为<strong class="lg iu"> <em class="mr"> Tenant </em> </strong>的轻量级Kubernetes抽象中聚合了多个名称空间，这是Kubernetes名称空间的一个分组。在每个租户内，用户可以自由创建他们的命名空间并共享所有分配的资源，而策略引擎会将不同的租户相互隔离。</p><p id="930d" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><em class="mr">网络和安全策略</em>、<em class="mr">资源配额</em>、<em class="mr">限制范围</em>、<em class="mr"> RBAC </em>以及在租户级定义的其他策略被租户中所有类似于分层名称空间的名称空间自动继承。然后，用户可以自由自主地操作他们的租户，而无需集群管理员的干预。</p><p id="e546" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">Capsule已经准备好了，因为它是声明性的，所有的配置都可以存储在Git中。</p><h1 id="bcbf" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="73d2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我们回顾了我最喜欢的<strong class="lg iu"> GitOps </strong>友好<strong class="lg iu"> Kubernetes </strong>工具。我关注的是可以包含在任何Kubernetes发行版中的开源项目。</p><p id="1806" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated">我的目标是向您展示<strong class="lg iu">您可以在Kubernetes </strong>中做任何事情，这得益于GitOps的最佳实践，利用了它的<strong class="lg iu">声明性</strong>特性。</p><p id="72f1" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><em class="mr">记得来</em> <strong class="lg iu"> <em class="mr">拍拍</em> </strong> <em class="mr">如果你喜欢这篇文章</em> <a class="ae kf" href="https://javier-ramos.medium.com/subscribe" rel="noopener"> <em class="mr"> </em> <strong class="lg iu"> <em class="mr">关注</em></strong><em class="mr"/><strong class="lg iu"><em class="mr">me</em></strong></a><em class="mr">或</em><a class="ae kf" href="https://javier-ramos.medium.com/membership" rel="noopener"><em class="mr">订阅</em>  </a> <em class="mr">获取更多更新！</em></p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="9203" class="pw-post-body-paragraph le lf it lg b lh mj lj lk ll mk ln lo lp ml lr ls lt mm lv lw lx mn lz ma mb im bi translated"><a class="ae kf" href="https://javier-ramos.medium.com/subscribe" rel="noopener"> <strong class="lg iu">订阅</strong> </a>获得<strong class="lg iu">通知</strong>当我发表一篇文章和<a class="ae kf" href="https://javier-ramos.medium.com/membership" rel="noopener"> <strong class="lg iu">加入Medium.com</strong></a>访问数百万或文章！</p></div></div>    
</body>
</html>