<html>
<head>
<title>Me, flutter web, and the making of an experimental book trailer :-)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我，flutter web，和实验性图书预告片的制作:-)</h1>
<blockquote>原文：<a href="https://itnext.io/me-flutter-web-and-the-making-of-an-experimental-book-trailer-8f1625173759?source=collection_archive---------5-----------------------#2019-12-28">https://itnext.io/me-flutter-web-and-the-making-of-an-experimental-book-trailer-8f1625173759?source=collection_archive---------5-----------------------#2019-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/fad682faba460f8d4a59a0df6538482b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6vF-LMjRnDM1Egk47_r_2A.png"/></div></figure></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="2005" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">简介</strong></p></blockquote><p id="965f" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在这最后的日子里，我终于有时间和Flutter web在一起了，所以我不能错过测试它的能力的机会。我开始玩几个月前用flutter做的一些实验性动画，但我想做一些不同的东西。然后我有了一个想法，为我十月份出版的小说《最后的星期天》(意大利语为“L'ultima domenica”)制作一个书籍预告片。</p><p id="3de5" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">我对结果很满意，即使，说实话，这没什么特别的，但我真的很喜欢建造它，所以我决定写一篇文章来分享这本书预告片的制作。这将是很长的时间，也许我可能错过了一些重要的点，所以如果有什么需要澄清的，或者如果你有任何建议，或者发现一些错误，请随时评论这篇文章(我肯定有！).</p><p id="8b4e" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在这里可以看到现场:<a class="ae lg" href="https://frideosapps.github.io/booktrailer" rel="noopener ugc nofollow" target="_blank">https://frideosapps.github.io/booktrailer</a></p></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="56d2" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">图片</strong></p></blockquote><p id="3883" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">对于预告片，我用了十张图片。为了处理它们，我创建了<code class="fe lh li lj lk b">AssetsImages</code>枚举和映射<code class="fe lh li lj lk b">imagesFilenames,</code>,用于为AssetsImage的每个值分配一个文件路径。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="30f8" class="lt lu iq lk b gy lv lw l lx ly">enum <strong class="lk ir">AssetsImages</strong> {<br/>  cover,<br/>  black,<br/>  rain,<br/>  smoke,<br/>  city,<br/>  man,<br/>  alone,<br/>  tunnel,<br/>  eyes,<br/>  coverPhoto,<br/>}</span><span id="cff2" class="lt lu iq lk b gy lz lw l lx ly">final <strong class="lk ir">imageFilenames</strong> = {<br/>  AssetsImages.cover: 'assets/images/cover.png',<br/>  AssetsImages.black: 'assets/images/black.png',<br/>  AssetsImages.rain: 'assets/images/rain.png',<br/>  AssetsImages.smoke: 'assets/images/smoke.png',<br/>  AssetsImages.alone: 'assets/images/alone.png',<br/>  AssetsImages.city: 'assets/images/city.png',<br/>  AssetsImages.eyes: 'assets/images/eyes.png',<br/>  AssetsImages.man: 'assets/images/man.png',<br/>  AssetsImages.tunnel: 'assets/images/tunnel.png',<br/>  AssetsImages.coverPhoto: 'assets/images/cover_photo.png',<br/>};</span></pre><p id="f527" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">从现在开始，为了展示一幅图像，我们将这样使用<code class="fe lh li lj lk b">Image.assets</code>小部件:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="187f" class="lt lu iq lk b gy lv lw l lx ly">// Show the image of the first scene<br/>Image.asset(<strong class="lk ir">imageFilenames[AssetsImages.city]</strong>);</span></pre></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="5022" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">预缓存，加载widget </strong></p></blockquote><p id="6376" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">为了避免在图像加载之前开始播放场景(并错过一些帧)，我们将预先缓存在这个预告片中使用的图像，并使用FutureBuilder显示一个显示加载文本和进度条的小部件，或者显示播放预告片的小部件。</p><p id="effc" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">让我们来看看<strong class="kh ir">setup assets</strong>State小部件的State类。我们可以看到三个属性:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="6d37" class="lt lu iq lk b gy lv lw l lx ly">final List&lt;Image&gt; images = [];<br/>Future&lt;bool&gt; precache;<br/>int loadingProgress = 0;</span></pre><p id="1bab" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在<strong class="kh ir"> initState </strong>方法中，通过迭代AssetsImages的值，将所有图像添加到图像列表中:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="de93" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>void initState() {<br/>  super.initState();</span><span id="e0d8" class="lt lu iq lk b gy lz lw l lx ly">for (var img in AssetsImages.values) {<br/>    images.add(Image.asset(imageFilenames[img]));<br/>  }<br/>}</span></pre><p id="e43b" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">然后我创建了<strong class="kh ir"> precachingImages </strong>异步方法来预缓存每个图像:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="dd43" class="lt lu iq lk b gy lv lw l lx ly"><strong class="lk ir">Future&lt;bool&gt;</strong> <strong class="lk ir">precachingImages</strong>(BuildContext context) async {<br/>  for (var image in images) {<br/>    await <strong class="lk ir">precacheImage</strong>(image.image, context);</span><span id="d2c2" class="lt lu iq lk b gy lz lw l lx ly">setState(() {<br/>       <strong class="lk ir">loadingProgress++</strong>;<br/>    });<br/>  }</span><span id="3b55" class="lt lu iq lk b gy lz lw l lx ly">return true;<br/>}</span></pre><p id="0699" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在for循环的每一次迭代中，<strong class="kh ir"> loadingProgress </strong>增加1，它将用于驱动<strong class="kh ir"> LoadingWidget </strong>小部件中的加载栏。</p><p id="31da" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在<strong class="kh ir"> didChangeDependencies </strong>中，用<strong class="kh ir"> precachingImages </strong>方法的结果初始化<strong class="kh ir"> precache </strong> future。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="95f7" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>void didChangeDependencies() {<br/>  super.didChangeDependencies();<br/>  <strong class="lk ir">precache</strong> = <strong class="lk ir">precachingImages(context)</strong>;<br/>}</span></pre><p id="a9b8" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在<strong class="kh ir">构建</strong>方法中，这个future将与FutureBuilder一起使用，以显示未完成的<strong class="kh ir"> LoadingWidget </strong>。未来一旦完成，<strong class="kh ir"> snapshot.hasData </strong>变为真，就会显示出<strong class="kh ir">菜单/PlayScenes </strong>小部件。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="63ef" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>Widget build(BuildContext context) {<br/>  return <strong class="lk ir">FutureBuilder</strong>&lt;bool&gt;(<br/>    future: <strong class="lk ir">precache</strong>,<br/>    builder: (context, snapshot) {<br/>      if (!<strong class="lk ir">snapshot.hasData</strong>) {<br/>        return <strong class="lk ir">LoadingWidget</strong>(<br/>          progress: loadingProgress / (images.length - 1),<br/>        );<br/>    } else {<br/>      return ValueBuilder&lt;bool&gt;(<br/>        streamed: appState.isPlaying,<br/>        builder: (context, snapshot) {<br/>          if (snapshot.data) {<br/>            return PlayScenes(<br/>              key: Key(appState.playScenesKey),<br/>              language: appState.lang,<br/>            );<br/>          } else {<br/>            return Menu();<br/>          }<br/>         },<br/>       );<br/>      }<br/>    },<br/>  );<br/>}</span></pre></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="16dc" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">装上车</strong></p></blockquote><p id="b7c1" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">加载小部件显示一个文本，指示拖车正在加载，并使用传递给其<strong class="kh ir">进度</strong>参数的参数来构建进度条。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8166" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">为了给文本的不透明度设置动画，我们将使用我的<a class="ae lg" href="https://pub.dev/packages/frideos" rel="noopener ugc nofollow" target="_blank"> frideos包</a>中的<strong class="kh ir"> AnimationCreate </strong>小部件。想法是在循环模式下，将其不透明度从0.1更改为1.0，然后返回0.1。为此，只需将<strong class="kh ir">真</strong>传递给微件的参数<strong class="kh ir">重复</strong>和<strong class="kh ir">反转</strong>。<strong class="kh ir">持续时间</strong>参数告诉小部件该值从0.1到1.0需要多少毫秒(反向也是同样的时间)。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="1e43" class="lt lu iq lk b gy lv lw l lx ly"><strong class="lk ir">AnimationCreate</strong>&lt;double&gt;(<br/>  <strong class="lk ir">begin</strong>: 0.1,<br/>  <strong class="lk ir">end</strong>: 1.0,<br/>  <strong class="lk ir">curve</strong>: Curves.easeIn,<br/>  <strong class="lk ir">duration</strong>: 1000,<br/>  <strong class="lk ir">repeat</strong>: true,<br/>  <strong class="lk ir">reverse</strong>: true,<br/>  <strong class="lk ir">builder</strong>: (context, anim) {<br/>    return Column(<br/>     mainAxisAlignment: MainAxisAlignment.center,<br/>     children: [<br/>       Opacity(<br/>         opacity: <strong class="lk ir">anim.value</strong>,<br/>         child: Text(<br/>           'Loading...',<br/>           style: TextStyle(<br/>             color: Colors.white,<br/>             fontSize: 26.0,<br/>           ),<br/>         ),<br/>       ),</span></pre></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="fe58" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">应用状态</strong></p></blockquote><p id="7b40" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">让我们来看看<strong class="kh ir"> _SetupAssetsState </strong>类的构建方法的第二部分:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="5cd5" class="lt lu iq lk b gy lv lw l lx ly">return <strong class="lk ir">ValueBuilder</strong>&lt;bool&gt;(<br/>  streamed: <strong class="lk ir">appState.isPlaying</strong>,<br/>  builder: (context, snapshot) {<br/>    if (snapshot.data) {<br/>      return <strong class="lk ir">PlayScenes</strong>(<br/>        <strong class="lk ir">key</strong>: Key(<strong class="lk ir">appState.playScenesKey</strong>),<br/>        <strong class="lk ir">language</strong>: <strong class="lk ir">appState.lang</strong>,<br/>      );<br/>    } else {<br/>      return<strong class="lk ir"> Menu()</strong>;<br/>    }<br/>  },<br/>);</span></pre><p id="ac7d" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><code class="fe lh li lj lk b">ValueBuilder</code>是一个小部件，它以<code class="fe lh li lj lk b">StreamedValue</code>对象作为参数，并在每次有新事件发送到流中时重建其构建器。在这种情况下，<strong class="kh ir"> appState </strong>(全局singleton)是<strong class="kh ir"> AppState </strong>类的一个实例，<strong class="kh ir"> </strong>和<strong class="kh ir"> isPlaying </strong>是在该类中声明的<strong class="kh ir"> StreamedValue </strong>类型的bool 。<strong class="kh ir"> isPlaying </strong>对象<strong class="kh ir"> </strong>将用于重建ValueBuilder，根据发送到流中的值显示<strong class="kh ir"> PlayScenes </strong>或<strong class="kh ir"> Menu </strong>小部件。</p><p id="f6dc" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">让我们来看看<strong class="kh ir"> AppState </strong>类:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="054a" class="lt lu iq lk b gy lv lw l lx ly">class <strong class="lk ir">AppState</strong> extends <strong class="lk ir">AppStateModel</strong> {<br/>  factory AppState() =&gt; _singletonAppState;</span><span id="3012" class="lt lu iq lk b gy lz lw l lx ly">  AppState._internal();<br/>  static final AppState _singletonAppState = AppState._internal();</span><span id="003b" class="lt lu iq lk b gy lz lw l lx ly">  // STREAM<br/>  final <strong class="lk ir">isPlaying</strong> = <strong class="lk ir">StreamedValue&lt;bool&gt;</strong>(initialData: false);</span><span id="dc85" class="lt lu iq lk b gy lz lw l lx ly">  // PlayingScenes widget key<br/>  <strong class="lk ir">String playScenesKey</strong> = DateTime.now().toString();</span><span id="e10e" class="lt lu iq lk b gy lz lw l lx ly">  Language lang = Language.english;</span><span id="4c30" class="lt lu iq lk b gy lz lw l lx ly">  final particlesSystem = ParticlesSystem();<br/>  bool isParticlesSystemInitialized = false;</span><span id="8600" class="lt lu iq lk b gy lz lw l lx ly">  void <strong class="lk ir">goToMenu()</strong> {<br/>    isPlaying.value = false;<br/>  }</span><span id="2625" class="lt lu iq lk b gy lz lw l lx ly">  void <strong class="lk ir">play()</strong> {<br/>     playScenesKey = DateTime.now().toString(); <br/>     isPlaying.value = true;<br/>  }</span><span id="4004" class="lt lu iq lk b gy lz lw l lx ly">  @override<br/>  void init() {}</span><span id="c327" class="lt lu iq lk b gy lz lw l lx ly">  @override<br/>  void dispose() {<br/>    isPlaying.dispose();<br/>  }<br/>}</span><span id="fc8f" class="lt lu iq lk b gy lz lw l lx ly"><strong class="lk ir">final appState</strong> <strong class="lk ir">=</strong> <strong class="lk ir">AppState()</strong>;</span></pre><ul class=""><li id="ba29" class="mc md iq kh b ki kj km kn ld me le mf lf mg lc mh mi mj mk bi translated"><strong class="kh ir"> isPlaying </strong>以<strong class="kh ir"> false </strong>作为initialData初始化，因此当应用程序启动时，它将显示<strong class="kh ir">菜单</strong>。</li><li id="90f3" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> playScenesKey </strong>是用作<strong class="kh ir"> PlayScenes </strong>小部件的键的字符串。在<strong class="kh ir"> play </strong>方法中，每次调用都会给它分配一个新的日期时间，以便更改小部件的键。当点击<strong class="kh ir">重放</strong>按钮时，这对于强制重建小部件是必要的，从而使场景从头开始再次播放。</li><li id="7479" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> lang: </strong>用于存储用户选择的语言。</li><li id="a0e4" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> goToMenu() </strong>:一旦到达预告片的两端，用户可以选择返回菜单或再次播放预告片。通过点击菜单按钮，调用<strong class="kh ir"> goToMenu </strong>方法，<strong class="kh ir">正在显示</strong> StreamedValue被赋予<strong class="kh ir"> false </strong>值，导致<strong class="kh ir"> ValueBuilder </strong>的重新构建，由于<strong class="kh ir"> snapshot.data </strong>为false，将显示<strong class="kh ir">菜单</strong>小部件。</li><li id="8022" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> Play() </strong>:在这个方法中<strong class="kh ir"> playSceneKey </strong>将被赋予一个新的值，与goToMenu方法类似，<strong class="kh ir">正在播放</strong>被赋予一个新的值，<strong class="kh ir"> true </strong>这次，重新启动预告片。</li><li id="614b" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir">particlesystem</strong>和<strong class="kh ir">isparticlesysteminitialized</strong>:见下一段。</li></ul></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="b75b" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">菜单</strong></p></blockquote><p id="ac97" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">这个小部件显示在<strong class="kh ir">栈</strong>小部件中，一个粒子系统在后台，一个<strong class="kh ir">列</strong>有我小说的封面，两个按钮选择预告片的语言，底部还有一段文字。</p><p id="3eac" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">重点强调<strong class="kh ir"> initState </strong>方法是很重要的:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="8d76" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>void initState() {<br/>  super.initState();</span><span id="f4f8" class="lt lu iq lk b gy lz lw l lx ly">  WidgetsBinding.instance.<strong class="lk ir">addPostFrameCallback</strong>((_) {<strong class="lk ir">         <br/>    appState.particlesSystem.init</strong>(<br/>      totalParticles: 150,<br/>      width: context.size.width,<br/>      height: context.size.height,<br/>    );</span><span id="8050" class="lt lu iq lk b gy lz lw l lx ly">    setState(() {<br/>      <strong class="lk ir">appState.isParticlesSystemInitialized = true</strong>;<br/>    });<br/>  });<br/>}</span></pre><p id="706f" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">为了初始化粒子系统，使用了<strong class="kh ir"> addPostFrameCallback </strong>方法的回调，这里上下文已经准备好用于获取<strong class="kh ir">粒子系统</strong>类的<strong class="kh ir"> init </strong>方法所需的小部件的大小。然后<strong class="kh ir">isparticlesysteminitialized</strong>标志被设置为true，这样小部件就可以在build方法中显示。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="3725" class="lt lu iq lk b gy lv lw l lx ly">GestureDetector(<br/>  onTap: () {<br/>    <strong class="lk ir">appState.lang</strong> = <strong class="lk ir">Language.english</strong>;<br/>    <strong class="lk ir">appState.play();</strong><br/>  },<br/>  child: LanguageWidget(<br/>    text: 'English',<br/>  ),<br/>),</span></pre><p id="c97e" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">当用户点击<strong class="kh ir"> LanguageWidget </strong>(一个显示语言的简单框)时，属性<strong class="kh ir"> lang </strong>的值被赋予所选择的语言，并调用方法<strong class="kh ir"> play </strong>开始播放预告片。</p><blockquote class="kb kc kd"><p id="7af5" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">粒子系统</strong></p></blockquote><p id="8ca8" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">为了展示一种雪的效果，我创建了一个非常简单的粒子系统。粒子类处理单个粒子的信息。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d7b4" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">使用<strong class="kh ir"> ParticlesSystem </strong>类，我们可以定义一个粒子系统，其中包含数量可变的项目，具有随机的初始位置和特征(<strong class="kh ir"> init </strong>方法)，并在每个新帧上移动它们(<strong class="kh ir"> update </strong>方法)。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="e269" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">ParticlesSystemPlayer小部件只是将ParticlesSystem类的一个实例作为参数，然后在每次重建时更新粒子的位置，并在堆栈小部件中显示它们。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="4454" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> PlayScenes页面:FadeInWidget，ScenesWidget，场景</strong></p></blockquote><p id="6bea" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">一旦菜单出现，用户点击语言框，预告片就开始了。在<strong class="kh ir"> PlayScenes </strong>小部件中有一个持续时间为2500ms的<strong class="kh ir"> FadeInWidget </strong>和一个作为孩子的<strong class="kh ir">scene create</strong>。这个小部件来自我的包，只播放传递给它的<strong class="kh ir">场景</strong>参数的场景。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2070" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">每个场景都是<strong class="kh ir">场景</strong>类的一个实例。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="3224" class="lt lu iq lk b gy lv lw l lx ly">class <strong class="lk ir">Scene </strong>{<br/>  Scene({this.widget, this.time, this.onShow});</span><span id="74ed" class="lt lu iq lk b gy lz lw l lx ly">Widget <strong class="lk ir">widget</strong>;<br/>  int <strong class="lk ir">time</strong>; // milliseconds<br/>  Function <strong class="lk ir">onShow</strong>;<br/>}</span></pre><p id="9a08" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">它基本上处理关于每个场景的信息，要显示的小部件，以毫秒为单位的持续时间，以及当场景显示时将被调用的回调。</p><p id="e712" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">正如我们在要点中看到的，向<strong class="kh ir">scene create</strong>传递了一个场景列表，在它们的小部件参数中传递了一个<strong class="kh ir"> BuildScene </strong>小部件，每个场景都有不同的设置。省略<strong class="kh ir"> onShow </strong>参数，因为在这种情况下不需要。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="277f" class="lt lu iq lk b gy lv lw l lx ly"><strong class="lk ir">ScenesCreate</strong>(<br/>  <strong class="lk ir">scenes</strong>: [<br/>    <strong class="lk ir">Scene</strong>(<br/>      widget: <strong class="lk ir">BuildScene</strong>(<br/>        <strong class="lk ir">key</strong>: Key('1'),<br/>        texts: textsScenes[TrailerScene.first][language],<br/>        image: imageFilenames[AssetsImages.city],<br/>        transitionType: TransitionType.circular,<br/>        textAnimationType: TextAnimationType.scale,<br/>        duration: 11500,<br/>      ),<br/>      time: 11500,<br/>    ),<br/>    Scene(<br/>      widget: BuildScene(<br/>        key: Key('2'),<br/>        texts: textsScenes[TrailerScene.second][language],<br/>        image: imageFilenames[AssetsImages.man],<br/>        transitionType: TransitionType.vertical,<br/>        textAnimationType: TextAnimationType.split,<br/>        duration: 11500,<br/>        blur: true,<br/>        blink: true,<br/>      ),<br/>      time: 11500,<br/>     ),</span></pre><p id="d359" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">给<strong class="kh ir"> BuildScene </strong>小部件的<strong class="kh ir">键</strong>参数一个不同的键，告诉Flutter它们不是同一个小部件，强制重新构建小部件。</p></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="be7a" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> BuildScene widget </strong></p></blockquote><p id="dd92" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">为了避免为每个场景创建不同的小部件，我创建了BuildScene小部件，它将一些标志作为参数来改变其行为。这样，用一个小部件我们就可以处理不同的场景，而不需要一遍又一遍地写同样的代码。</p><p id="dbf9" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">基本上，这些场景都有一个共同的背景(有或没有模糊效果)，一个粒子系统，一个动画文本(有两种类型的动画)，以及一个场景结尾的过渡效果。</p><p id="6618" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">让我们检查一下<strong class="kh ir"> BuildScene </strong>小部件的签名:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="e336" class="lt lu iq lk b gy lv lw l lx ly">class BuildScene extends StatefulWidget {<br/>  const BuildScene({<br/>    Key key,<br/>    @required this.<strong class="lk ir">texts</strong>,<br/>    @required this.<strong class="lk ir">image</strong>,<br/>    this.<strong class="lk ir">boxFit </strong>= BoxFit.cover,<br/>    this.<strong class="lk ir">blink </strong>= false,<br/>    this.<strong class="lk ir">textAnimationReverse </strong>= false,<br/>    this.<strong class="lk ir">textAnimationType </strong>= TextAnimationType.split,<br/>    this.<strong class="lk ir">transitionType </strong>= TransitionType.circular,<br/>    this.<strong class="lk ir">duration </strong>= 10000,<br/>    this.<strong class="lk ir">blur </strong>= false,<br/>}) : super(key: key);</span></pre><ul class=""><li id="6868" class="mc md iq kh b ki kj km kn ld me le mf lf mg lc mh mi mj mk bi translated"><strong class="kh ir">文本</strong>:该参数告诉小工具要显示的文本。这是一个字符串列表，其中每个字符串都是一个列小部件的子部件。</li><li id="f379" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir">图像</strong>:显示为背景的图像。</li><li id="6a44" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> boxFit </strong></li><li id="5831" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir">闪烁</strong>:在文字动画过程中，使图像闪烁</li><li id="6e71" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> textAnimationReverse: </strong>如果为真，文本动画将反向播放。</li><li id="72b6" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir"> textAnimationType </strong>:文本动画的类型。</li><li id="aac1" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir">持续时间</strong>:场景持续时间，将设置为等于场景持续时间。</li><li id="13d8" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated"><strong class="kh ir">模糊</strong>:如果为真，背景将被动画化和模糊化。</li></ul><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="e79e" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">让我们来看看<strong class="kh ir"> initState </strong>方法:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="9c69" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>void initState() {<br/>  super.initState();</span><span id="163e" class="lt lu iq lk b gy lz lw l lx ly"><strong class="lk ir">particlesAnim </strong>= <strong class="lk ir">AnimationCurved</strong>&lt;double&gt;(<br/>    duration: Duration(milliseconds: 3500),<br/>    setState: setState,<br/>    tickerProvider: this,<br/>    begin: -1.0,<br/>    end: 1.0,<br/>    onAnimating: _onAnimating,<br/>    curve: Curves.easeIn,<br/>  );<br/>}</span></pre><p id="ec12" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">一个<strong class="kh ir">动画曲线</strong>类的实例被初始化。AnimationCurved是我为我的frideos软件包制作的一个助手，可以更容易地处理动画。这个动画将驱动粒子系统。</p></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="900d" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">复合创建，复合项目，动画类型</strong></p></blockquote><p id="daf1" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><strong class="kh ir">composite create</strong>widget<strong class="kh ir"/>是我的frideos包的另一个助手，用来处理复杂的动画。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="e6f2" class="lt lu iq lk b gy lv lw l lx ly">class <strong class="lk ir">CompositeCreate </strong>extends StatefulWidget {<br/>  const CompositeCreate({<br/>    Key key,<br/>    this.<strong class="lk ir">duration </strong>= 1000,<br/>    this.<strong class="lk ir">compositeMap</strong>,<br/>    this.<strong class="lk ir">repeat </strong>= false,<br/>    this.<strong class="lk ir">onAnimating</strong>,<br/>    this.<strong class="lk ir">onStart</strong>,<br/>    this.<strong class="lk ir">onCompleted</strong>,<br/>    this.<strong class="lk ir">builder</strong>,<br/>}) : super(key: key);</span></pre><p id="2d9f" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">参数的含义很简单，值得花些时间来解释一下<strong class="kh ir"> compositeMap </strong>参数:传递一个值是<strong class="kh ir"> CompositeItem </strong>的实例的Map，然后就可以通过使用它的键来获得动画的值。这样，就有可能以一种非常简单的方式制作交错/复合动画。</p><p id="8a31" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">让我们检查一下<strong class="kh ir">_ buildscestate</strong>小部件的构建方法:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="a39c" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>Widget <strong class="lk ir">build</strong>(BuildContext context) {<br/>  return <strong class="lk ir">CompositeCreate</strong>(<br/>    duration: widget.duration,<br/>    <strong class="lk ir">compositeMap</strong>: {<br/>      <strong class="lk ir">AnimationType.fadeIn</strong>: <strong class="lk ir">CompositeItem&lt;double&gt;</strong>(<br/>        begin: 0.2,<br/>        end: 1.0,<br/>        curve: const Interval(<br/>          0.6,<br/>          0.8,<br/>          curve: Curves.easeIn,<br/>        ),<br/>      ),<br/>      AnimationType.transition: CompositeItem&lt;double&gt;(<br/>        begin: 0.0,<br/>        end: 100.0,<br/>        curve: const Interval(<br/>          0.75,<br/>          1.0,<br/>          curve: Curves.easeIn,<br/>        ),<br/>      ),<br/>     },<br/>     repeat: false,<br/>     builder: (context, <strong class="lk ir">comp</strong>) {</span></pre><p id="9d16" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在这种情况下，向duration参数传递了<strong class="kh ir"> BuildScene </strong>小部件的<strong class="kh ir"> duration </strong>属性(该值为11500 ms，您可以在<strong class="kh ir"> PlayScenes </strong>小部件中看到)。这意味着合成动画将持续11.5秒。记住这个值，我们可以组成一个动画地图，给每个动画一个持续时间间隔。</p><p id="c0b1" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">向<strong class="kh ir"> compositeMap </strong>参数传递类型为<code class="fe lh li lj lk b">Map&lt;AnimationType, CompositeItem&gt;</code>的映射。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="6c5c" class="lt lu iq lk b gy lv lw l lx ly">enum AnimationType {<br/>  fadeOut,<br/>  fadeIn,<br/>  mov,<br/>  scale,<br/>  grow,<br/>  color,<br/>  transition,<br/>}</span></pre><p id="ad96" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">获取单个动画的值真的很简单，只需要使用动画的键(例如。<strong class="kh ir"> AnimationType.fadeIn </strong>为第一个)，带有<strong class="kh ir"> CompositeAnimation </strong>类的getter <strong class="kh ir">值</strong>，在<strong class="kh ir"> CompositeCreate小工具的构建器中传递一个实例。</strong></p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="97f5" class="lt lu iq lk b gy lv lw l lx ly"><strong class="lk ir">comp.value(AnimationType.fadeIn)</strong></span></pre><p id="b62b" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">第一个动画以动画的0.6–0.8的间隔播放，而第二个动画以0.75到1.0的间隔播放。这两个动画在0.75–0.8的区间内重叠。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="c740" class="lt lu iq lk b gy lv lw l lx ly"><strong class="lk ir">Opacity</strong>(<br/>  opacity: _calcOpacity(<br/>    isOverlay,<br/>    <strong class="lk ir">comp.value(AnimationType.fadeIn)</strong>,<br/>  ),<br/>  child: <strong class="lk ir">ParticlesSystemPlayer</strong>(    <br/>    particlesSystem: particlesSystem,<br/>  ),<br/>),</span></pre><p id="ee43" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">这里我们将动画中<strong class="kh ir">淡入的值传递给<strong class="kh ir"> _calcOpacity </strong>方法，以便计算给予<strong class="kh ir"> ParticleSystemPlayer </strong>小部件的不透明度。</strong></p></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="7bfc" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">动画文本</strong></p></blockquote><p id="803c" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">这个小部件以两种形式显示预告片的动画文本:一种简单的缩放动画，一种更复杂的动画，其中文本被分解成单词，每个单词都单独制作动画。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="33bf" class="lt lu iq lk b gy lv lw l lx ly"><strong class="lk ir">AnimatedText</strong>(<br/>  <strong class="lk ir">textAnimationType</strong>: widget.textAnimationType,<br/>  width: width,<br/>  texts: !isOverlay ? widget.texts : [''],<br/>  reverse: widget.textAnimationReverse,<br/>  onAnimating: (progress) {<br/>    if (widget.blink) {<br/>      if (progress &gt;= 30 &amp;&amp; progress &lt;= 34 ||<br/>          progress &gt;= 46 &amp;&amp; progress &lt;= 50) {<br/>        isOverlay = true;<br/>      } else {<br/>        isOverlay = false;<br/>      }<br/>    }<br/>  },<br/>),</span></pre><p id="3e3b" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">使用参数<strong class="kh ir"> textAnimationType </strong>改变动画的类型:缩放或分割。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="4144" class="lt lu iq lk b gy lv lw l lx ly">enum <strong class="lk ir">TextAnimationType </strong>{ scale, split }</span></pre><p id="656b" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">texts参数接受一系列字符串。<strong class="kh ir"> isOverlay </strong>标志用于在显示叠加图像时隐藏文本。<strong class="kh ir">反转</strong>改变动画的行为，如果反转为真，文本的大小从最小值开始并随时间增加。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9784" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><strong class="kh ir">动画文本尺度</strong></p><p id="7d44" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">查看<strong class="kh ir">合成图</strong>我们可以看到，该动画由三个子动画组成。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="4caf" class="lt lu iq lk b gy lv lw l lx ly">CompositeCreate(<br/>  duration: duration,<br/>  repeat: false,<br/>  <strong class="lk ir">compositeMap</strong>: {<br/>    <strong class="lk ir">AnimationType.fadeIn</strong>: CompositeItem&lt;double&gt;(<br/>      begin: 0.2,<br/>      end: 1.0,<br/>      curve: const Interval(<br/>        0.0,<br/>        0.2,<br/>        curve: Curves.linear,<br/>      ),<br/>     ),<br/>     <strong class="lk ir">AnimationType.scale</strong>: CompositeItem&lt;double&gt;(<br/>       begin: <strong class="lk ir">reverse </strong>? 0.8 : 1.0,<br/>       end: <strong class="lk ir">reverse </strong>? 1.0 : 0.8,<br/>       curve: const Interval(<br/>         0.2,<br/>         0.6,<br/>        curve: Curves.linear,<br/>       ),<br/>     ),<br/>     <strong class="lk ir">AnimationType.fadeOut</strong>: CompositeItem&lt;double&gt;(<br/>       begin: 1.0,<br/>       end: 0.0,<br/>       curve: Interval(<br/>         <strong class="lk ir">isLastScene</strong> ? 0.8 : 0.7,<br/>         <strong class="lk ir">isLastScene</strong> ? 1.0 : 0.8,<br/>         curve: Curves.linear,<br/>       ),<br/>     ),<br/>   },<br/>   onCompleted: onCompleted,<br/>   builder: (context, <strong class="lk ir">comp</strong>) {</span></pre><ul class=""><li id="5ba4" class="mc md iq kh b ki kj km kn ld me le mf lf mg lc mh mi mj mk bi translated">一开始，从0.0-0.2文本淡入</li><li id="7d91" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated">从0.2到0.6，文本变大或变小(取决于<strong class="kh ir">反转</strong>参数)</li><li id="64da" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated">然后淡出。如果场景是最后一个，此处的间隔会有所不同，为0.8–1.0，而在其他场景中，文本会从0.7–0.8淡出，因为从0.8开始过渡动画。</li></ul><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="d118" class="lt lu iq lk b gy lv lw l lx ly">return <strong class="lk ir">Transform.scale</strong>(<br/>  scale: <strong class="lk ir">comp.value(AnimationType.scale)</strong> * _scale(width),<br/>  child: Column(<br/>    mainAxisAlignment: MainAxisAlignment.center,<br/>    children: [<br/>      for (var i = 0; i &lt;= texts.length - 1; i++)<br/>      <strong class="lk ir">Opacity</strong>(<br/>        opacity: opacity: comp.progress &lt;= 0.2<br/>            ? comp.value(AnimationType.fadeIn)<br/>            : comp.value(AnimationType.fadeOut),<br/>        child: Text(<br/>          <strong class="lk ir">texts[i]</strong>,            <br/>        ),<br/>      ),       <br/>    ],<br/>  ),<br/>);</span></pre><p id="0344" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在不透明度小部件的不透明度参数中，您可以看到如何使用CompositeCreate小部件的生成器中传递的动画的<strong class="kh ir">进度</strong>属性，来选择分配值给<strong class="kh ir">淡入</strong>(从0.0到0.2)或<strong class="kh ir">淡出</strong>动画(取决于<strong class="kh ir"> isLastScene </strong>标志，其间隔为0.8–1.0或0.7–0.8)。这样，当<strong class="kh ir"> comp.progress </strong>小于0.2时，我们处于动画淡入的区间，否则处于淡出。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a848" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><strong class="kh ir">动画文本分割</strong>:</p><p id="05c0" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">这里的动画有点复杂:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="5af3" class="lt lu iq lk b gy lv lw l lx ly">return <strong class="lk ir">CompositeAnimationWidget</strong>(<br/>  duration: widget.duration,<br/>  repeat: false,<br/>  <strong class="lk ir">compositeMap</strong>: {<br/>    <strong class="lk ir">AnimationType.fadeIn</strong>: CompositeItem&lt;double&gt;(<br/>      begin: 0.0,<br/>      end: 1.0,<br/>      curve: const Interval(<br/>        0.0,<br/>        0.4,<br/>        curve: Curves.linear,<br/>      ),<br/>     ),<br/>     <strong class="lk ir">AnimationType.mov</strong>: CompositeItem&lt;double&gt;(<br/>       begin: 0.5,<br/>       end: 0.0,<br/>       curve: const Interval(<br/>         0.0,<br/>         0.5,<br/>         curve: Curves.linearToEaseOut,<br/>       ),<br/>     ),<br/>     <strong class="lk ir">AnimationType.grow</strong>: CompositeItem&lt;double&gt;(<br/>       begin: 1.5,<br/>       end: 1.0,<br/>       curve: const Interval(<br/>         0.2,<br/>         0.6,<br/>         curve: Curves.linearToEaseOut,<br/>       ),<br/>     ),<br/>     <strong class="lk ir">AnimationType.color</strong>: CompositeItem&lt;int&gt;(<br/>       begin: 255,<br/>       end: 170,<br/>       curve: const Interval(<br/>         0.3,<br/>         0.6,<br/>         curve: Curves.linear,<br/>       ),<br/>      ),<br/>      <strong class="lk ir">AnimationType.fadeOut</strong>: CompositeItem&lt;double&gt;(<br/>        begin: 1.0,<br/>        end: 0.0,<br/>        curve: Interval(<br/>          0.6,<br/>          0.8,<br/>          curve: Curves.linear,<br/>        ),<br/>      ),<br/>   },<br/>   onCompleted: widget.onCompleted,<br/>   builder: (context, comp) {</span></pre><ul class=""><li id="a10a" class="mc md iq kh b ki kj km kn ld me le mf lf mg lc mh mi mj mk bi translated">从0.0到0.4，单词淡入</li><li id="2eb2" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated">0.0–0.5:分解的单词移动</li><li id="e791" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated">0.2–0.6:文字缩小尺寸</li><li id="1a54" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated">0.3–0.6:一些单词的颜色逐渐由黄色变为白色</li><li id="6100" class="mc md iq kh b ki ml km mm ld mn le mo lf mp lc mh mi mj mk bi translated">0.6–0.8:单词淡出</li></ul><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="92ca" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">过渡小工具</strong></p></blockquote><p id="ab2f" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">在场景(或动画，它们具有相同的持续时间)的0.75到1.0的间隔中，<strong class="kh ir">过渡</strong>小部件显示一种过渡效果，以跳转到另一个场景。</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="7eff" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">这里最重要的参数是<strong class="kh ir"> transitionType </strong>，用于改变要使用的过渡类型。它将一个<strong class="kh ir">转换类型</strong>作为输入:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="98e4" class="lt lu iq lk b gy lv lw l lx ly">enum TransitionType { horizontal, vertical, circular }</span></pre><p id="1cda" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">它的值将在构建方法中使用，以在运行时选择使用哪种过渡小部件。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="4fbd" class="lt lu iq lk b gy lv lw l lx ly">@override<br/>Widget build(BuildContext context) {<br/>  Widget <strong class="lk ir">child</strong>;<br/>  <br/>  switch (transitionType) {<br/>    case <strong class="lk ir">TransitionType.vertical</strong>:<br/>      <strong class="lk ir">child = TransitionVertical</strong>(<br/>        height: height,<br/>        width: width,<br/>        transition: transition,<br/>        image: image,<br/>        fit: fit,<br/>      );<br/>      break;<br/>    case <strong class="lk ir">TransitionType.circular</strong>:<br/>       <strong class="lk ir">child </strong>= <strong class="lk ir">TransitionCircular</strong>(<br/>         height: height,<br/>         width: width,<br/>         transition: transition,<br/>         image: image,<br/>         fit: fit,<br/>       );<br/>       break;<br/>    <strong class="lk ir">default</strong>:<br/>       child = <strong class="lk ir">TransitionHorizontal</strong>(<br/>         height: height,<br/>         width: width,<br/>         transition: transition,<br/>         image: image,<br/>         fit: fit,<br/>       );<br/>  }</span><span id="3ca6" class="lt lu iq lk b gy lz lw l lx ly">if (!<strong class="lk ir">blur</strong>) return <strong class="lk ir">child</strong>;</span><span id="4d12" class="lt lu iq lk b gy lz lw l lx ly">return <strong class="lk ir">AnimatedBlurWeb</strong>(<br/>    strength: 12.0,<br/>    duration: 4000,<br/>    child: child,<br/>  );<br/>}</span></pre><p id="4f9a" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><strong class="kh ir">过渡垂直</strong>:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9fce" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><strong class="kh ir">过渡水平</strong>:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="aa32" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated"><strong class="kh ir">过渡通告</strong>:</p><figure class="ll lm ln lo gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="7bba" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">最后一幕</strong></p></blockquote><p id="c35d" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">最后一个场景与菜单非常相似。它显示了这本书的图片和两个按钮:第一个是去菜单，另一个是重播预告片。</p><p id="fab9" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">点击菜单按钮将触发<strong class="kh ir"> appState </strong>对象的<strong class="kh ir"> goToMenu </strong>方法的调用，向<strong class="kh ir">isplay</strong>streamed value对象的流发送“false”事件，并且<strong class="kh ir">_ setupassetstate</strong>的build方法的<strong class="kh ir"> ValueBuilder </strong>将重新构建，显示菜单:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="eb7f" class="lt lu iq lk b gy lv lw l lx ly">GestureDetector(<br/>  onTap: <strong class="lk ir">appState.goToMenu</strong>,<br/>  child: Container(<br/>  padding: EdgeInsets.all(10.0),<br/>  child: Text('Menu',</span></pre><p id="53cf" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">相反，重放按钮，像菜单上的播放按钮，将调用<strong class="kh ir">播放</strong>方法:</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="7465" class="lt lu iq lk b gy lv lw l lx ly">GestureDetector(<br/>  onTap: <strong class="lk ir">appState.play</strong>,<br/>  child: Container(<br/>    padding: EdgeInsets.all(10.0),<br/>    child: Text('Replay',</span></pre></div><div class="ab cl ju jv hu jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ij ik il im in"><blockquote class="kb kc kd"><p id="0d27" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">结论</strong></p></blockquote><p id="d60a" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">正如我在介绍中所说，我真的很喜欢制作这个实验性的图书预告片。但是，我也发现了一些问题。例如，但我不确定这是不是flutter web的问题，或者是我做错了什么，有时图像的堆栈小部件会有奇怪的行为，就像图像并不总是遵守堆栈顺序。另一件事，我找不到用ImageFilter类制作一个真正的模糊效果的方法，所以我最终制作了一个“假”模糊，用一堆不同偏移量和不透明度的三张图像。此外，我想添加一些音乐和音效，但我仍然没有找到一个简单的方法来做到这一点。</p><p id="e4d8" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">我用我为制作这个预告片而创建的一些助手更新了我的<a class="ae lg" href="https://pub.dev/packages/frideos" rel="noopener ugc nofollow" target="_blank">frid IOs包</a>。现在它是0.10.0版本，但是我想我会在接下来的几周/几个月增加一些fx的东西。</p><p id="c138" class="pw-post-body-paragraph ke kf iq kh b ki kj kk kl km kn ko kp ld kr ks kt le kv kw kx lf kz la lb lc ij bi translated">你可以在GitHub 上我的<a class="ae lg" href="https://github.com/frideosapps/booktrailer" rel="noopener ugc nofollow" target="_blank">资源库中找到预告片的源代码。</a></p></div></div>    
</body>
</html>