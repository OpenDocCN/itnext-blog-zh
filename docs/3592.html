<html>
<head>
<title>BLoC pattern — Building blocs for Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堵塞模式——为颤振建立堵塞</h1>
<blockquote>原文：<a href="https://itnext.io/bloc-pattern-building-blocs-for-flutter-81a17410b09?source=collection_archive---------0-----------------------#2020-01-14">https://itnext.io/bloc-pattern-building-blocs-for-flutter-81a17410b09?source=collection_archive---------0-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b466a6568fc9a2c6dcca6355d357554d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4FlJbmMaEeEVCFfoIa2eQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://www.allnewbricks.com" rel="noopener ugc nofollow" target="_blank">allnewbricks.com</a></figcaption></figure><div class=""/><p id="bfd7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">每当你开始研究Flutter的架构时，没有办法绕过BLoC模式，但是它是如何工作的，我们如何实现它？</em></p><p id="61ec" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">BLoC代表<em class="le">业务逻辑组件</em>，是在Flutter架构中比较流行的方法之一。通过在我们的屏幕和数据层之间放置一个块，它让我们有可能在我们的存储库和小部件之间传递数据，并在数据发生变化时更新UI，而不必手动更新状态。它来自Android，实际上与我们在本地开发中使用的ViewModel &amp; LiveData结构有一些相似之处。</p><h1 id="f1d6" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">获得正确的包</h1><p id="93b3" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">让我们先来看看我们使用了哪些包。由于我们想要观察数据，<code class="fe mi mj mk ml b">rxdart</code>是一个简单的选择，它提供了我们大多数人都熟悉的基本Rx功能。接下来，我们决定用<code class="fe mi mj mk ml b">bloc_provider</code>包开始实现BLoCs。</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f104" class="mu lg jj ml b gy mv mw l mx my">rxdart: 0.22.6<br/>bloc_provider: 0.6.2+2</span></pre><p id="cb90" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在确保<code class="fe mi mj mk ml b">pub get</code>和让我们得到编码！</p><h1 id="f099" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建集团</h1><p id="7de7" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在创建一个新类，姑且称之为我们的<code class="fe mi mj mk ml b">LoginBloc</code>。我们将实现<code class="fe mi mj mk ml b">Bloc</code>，让我们覆盖<code class="fe mi mj mk ml b">dispose()</code>方法。在这里，我们将关闭我们的溪流。</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="b457" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">定义流</h1><p id="d0ba" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在我们已经有了我们块，我们可以开始定义我们的流了。我们总是从定义私有类型<code class="fe mi mj mk ml b">Subject</code>开始。</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3053" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之:<code class="fe mi mj mk ml b">Observable</code>通常是单行道(监听数据),而<code class="fe mi mj mk ml b">Subject</code>是双向的:我们可以监听数据，也可以将数据放入其中。</p><p id="f05b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我们希望使用私有主题的目的(观察数据或数据输入)，我们将该部分公开为公共变量，这样我们的UI就可以访问它。观察数据通常导致<code class="fe mi mj mk ml b">ValueObservable</code>，数据输入需要<code class="fe mi mj mk ml b">Sink</code>。</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5a47" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数情况下，我们只公开两种类型中的一种，所以我们总是使用一个私有控制器，结合UI的公开的<code class="fe mi mj mk ml b">ValueObservable</code>或<code class="fe mi mj mk ml b">Sink</code>。</p><p id="d5e2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回顾一下，并以此<code class="fe mi mj mk ml b">LoginBloc</code>为例说明我们刚刚学到的内容:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="d9cb" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">利用我们的集团</h1><p id="949b" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们有自己的BLoC，但是如何在我们的UI中使用它呢？如果我们打开一个屏幕，我们经常会发现一个<code class="fe mi mj mk ml b">Scaffold</code>作为我们的小部件树的根。现在我们想使用一个块，我们将使<code class="fe mi mj mk ml b">BlocProvider</code>成为根，并通过它的构建器初始化我们的块:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7a52" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们现在已经初始化了我们的程序块，可以通过构建器的参数或通过<code class="fe mi mj mk ml b">context</code>访问它👌</p><p id="f21b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">观察数据</strong> <br/>观察数据的方式与我们通常在Flutter中处理流的方式相同:通过<code class="fe mi mj mk ml b">StreamBuilder</code>小部件。只需将受数据影响的小部件包装在一个<code class="fe mi mj mk ml b">StreamBuilder</code>中，监听数据流并处理<code class="fe mi mj mk ml b">snapshot</code>结果:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ecfb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，每当我们的块中的<code class="fe mi mj mk ml b">loginState</code>改变时，<code class="fe mi mj mk ml b">StreamBuilder</code>将再次触发它的<code class="fe mi mj mk ml b">builder</code>方法，我们可以基于新数据返回一个小部件。</p><p id="0f39" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">输入数据<br/> </strong>将数据从我们的UI推送到我们的Bloc非常简单。还记得我们如何在我们的块中暴露一个<code class="fe mi mj mk ml b">Sink</code>以便UI可以访问它吗？只要从你的UI调用sink，推送一些新的数据，就可以了！假设我们有之前作为示例使用的<code class="fe mi mj mk ml b">login</code>水槽:</p><figure class="mm mn mo mp gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="df87" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！当然，您也可以选择将它隐藏在代码块中一个不错的方法后面，并在您的UI中引用它。</p><p id="d2a5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">就这么定了！区块模式101，或者至少我们现在在</em> <a class="ae jg" href="https://pinch.nl/en/" rel="noopener ugc nofollow" target="_blank"> <em class="le">捏</em> </a> <em class="le">如何使用它。我们仍在不断学习和改进我们的方法，但这是一个很好的起点，可以为您的项目打下良好的基础。编码快乐！</em></p></div></div>    
</body>
</html>