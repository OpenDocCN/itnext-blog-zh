<html>
<head>
<title>How to build a DAG based Task Scheduling tool for Multiprocessor systems using python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用python为多处理器系统构建基于DAG的任务调度工具</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-build-a-dag-based-task-scheduling-tool-for-multiprocessor-systems-using-python-d11a093a835b?source=collection_archive---------3-----------------------#2022-06-07">https://itnext.io/how-to-build-a-dag-based-task-scheduling-tool-for-multiprocessor-systems-using-python-d11a093a835b?source=collection_archive---------3-----------------------#2022-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用pyDag在云中调度大数据工作负载和数据管道</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ad202380989b81c86af17c8c387f3a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfUdWxE6QPIysnXl9tuLcg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> PyDag </strong></figcaption></figure><p id="bb75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从初创公司到大公司，不同规模的数据驱动型公司的成功很大程度上是基于他们良好的运营实践以及他们保持数据更新的方式，他们每天都在处理数据的<strong class="js iu">多样性</strong>、<strong class="js iu">速度</strong>和<strong class="js iu">量</strong>，在大多数情况下，他们的战略依赖于这些特征。这类公司中数据团队的一些目标是:</p><ul class=""><li id="8d60" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">设计和部署经济高效且可扩展的数据架构</li><li id="4364" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">从他们的数据中获得洞察力</li><li id="c1aa" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">保持业务和运营正常运行</li></ul><p id="6400" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现这些目标，数据团队使用工具，这些工具中的大多数允许他们<strong class="js iu">提取</strong>、<strong class="js iu">转换</strong>和<strong class="js iu">加载</strong>数据到其他地方或目的地数据源，可视化数据并将数据转换成信息。在这些团队中很常见到ETL工具、<strong class="js iu"> <em class="lt">任务调度</em> </strong>、<strong class="js iu"> <em class="lt">作业调度</em> </strong>或<strong class="js iu"> <em class="lt">工作流调度</em> </strong>工具。值得一提的术语:<strong class="js iu"> <em class="lt">任务调度</em> </strong>，<strong class="js iu"> <em class="lt">作业调度</em> </strong>，<strong class="js iu"> <em class="lt">工作流调度</em> </strong>，<strong class="js iu"> <em class="lt">任务编排</em> </strong>，<strong class="js iu"> <em class="lt">作业编排</em> </strong>和<strong class="js iu"> <em class="lt">工作流编排</em> </strong>是同一个概念，在某些情况下区别它们的是工具的用途 其中一些工具仅用于编排ETL过程，并通过使用管道架构简单地指定何时执行它们，其他工具使用DAG架构，并提供指定何时执行DAG以及如何以正确的顺序编排其任务(顶点)的执行。</p><p id="f4e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一种架构的优点是，所有计算都可以在执行DAG的机器上使用，优先并行运行DAG的一些任务(vetices)。</p><blockquote class="lu lv lw"><p id="7c16" class="jq jr lt js b jt ju jv jw jx jy jz ka lx kc kd ke ly kg kh ki lz kk kl km kn im bi translated">图是顶点(任务)和边(顶点之间的连接或依赖)的集合。因此，有向无环图或DAG是没有圈的有向图。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ma"><img src="../Images/cbec3fda903668f43202eb58e9f9a74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gH-Pszet0ud8WxiPzjNww.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">十克</figcaption></figure><blockquote class="lu lv lw"><p id="4066" class="jq jr lt js b jt ju jv jw jx jy jz ka lx kc kd ke ly kg kh ki lz kk kl km kn im bi translated">流水线是一种DAG，但是有限制，每个顶点(任务)最多有一个上游和一个下游依赖。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/7115f9be411d9c29ef2a0ddbf918761a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlSIRWD56nSIt0_n-_mqXA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">管道</figcaption></figure><p id="fcfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这类工具在过去几年中蓬勃发展，提供了一些共同的功能:</p><ul class=""><li id="5e7f" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">自动化工作流程</li><li id="4f03" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">任务/工作的调度或协调</li><li id="d073" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">它们允许ETL或数据集成过程的创建或自动化</li><li id="62a2" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">Dag或管道数据结构的使用</li><li id="5ee7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">有的是<strong class="js iu"> <em class="lt">单片架构</em> </strong>有的是<strong class="js iu"> <em class="lt">高度分布式</em> </strong>。</li><li id="be5b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">一些工具不能在多处理器机器上利用优势，而另一些工具可以。</li><li id="e177" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">有些自带基础架构，有些则允许您使用云中或内部的任何基础架构。</li><li id="865f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">有些允许您编写与每个Dag的任务相关的代码或脚本，有些是拖放组件。</li></ul><blockquote class="lu lv lw"><p id="3b49" class="jq jr lt js b jt ju jv jw jx jy jz ka lx kc kd ke ly kg kh ki lz kk kl km kn im bi translated">总结一下:<strong class="js iu">编排</strong>和<strong class="js iu">调度</strong>是一些ETL工具具有的一些特性。</p></blockquote><p id="4776" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在此提及其中一些:</p><h2 id="337e" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated"><a class="ae mu" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a>，<a class="ae mu" href="https://www.jamsscheduler.com/" rel="noopener ugc nofollow" target="_blank">杰姆调度器</a>，<a class="ae mu" href="https://www.hitachivantara.com/es-latam/products/data-management-analytics/pentaho.html" rel="noopener ugc nofollow" target="_blank">彭塔霍</a>，<a class="ae mu" href="https://www.prefect.io/" rel="noopener ugc nofollow" target="_blank">提督io </a>，<a class="ae mu" href="https://argoproj.github.io/" rel="noopener ugc nofollow" target="_blank">阿尔戈</a>，<a class="ae mu" href="https://luigi.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">路易吉</a>，<a class="ae mu" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank">达斯克</a>，<a class="ae mu" href="https://www.matillion.com/" rel="noopener ugc nofollow" target="_blank">马提利昂</a>，<a class="ae mu" href="https://airbyte.com/" rel="noopener ugc nofollow" target="_blank">空气团</a>，<a class="ae mu" href="https://dolphinscheduler.apache.org/" rel="noopener ugc nofollow" target="_blank">海豚调度器</a>，<a class="ae mu" href="https://www.stonebranch.com/" rel="noopener ugc nofollow" target="_blank">斯通布兰奇</a></h2></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="16c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些工具的使用涉及到大企业，从咨询、昂贵的许可，到维护开源工具并拥有交付模式的公司，在这种模式下，集中托管的软件通过订阅计划许可给客户。</p><h1 id="5073" class="nc md it bd le nd ne nf mg ng nh ni mj nj nk nl mm nm nn no mp np nq nr ms ns bi translated">问题陈述</h1><p id="43ca" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">本文的目标是教你如何为多处理器系统设计和构建一个简单的基于DAG的任务调度工具，它可以帮助你减少公司中由这种技术产生的账单成本，或者基于这种工具创建你自己的并开始一个有利可图的业务。</p><h1 id="5175" class="nc md it bd le nd ne nf mg ng nh ni mj nj nk nl mm nm nn no mp np nq nr ms ns bi translated">功能需求</h1><ul class=""><li id="66bc" class="lf lg it js b jt nt jx nu kb ny kf nz kj oa kn lk ll lm ln bi translated">应该是Python模块</li><li id="d56a" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">到目前为止，该模块应该只接收一个. json或。yaml文件，其中包含任务及其依赖项的规范。</li><li id="37df" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">这些任务将基于独立脚本</li><li id="470a" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">该工具应该适用于任何云或内部提供商</li><li id="54f8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">该工具应该在选定的云提供商中启动、关闭和停止基础架构</li><li id="52e6" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">该工具应该利用运行DAG的机器上的计算，因此，一些任务可以并行执行，并可以独立地分配给每个处理器，从而利用机器的资源。</li><li id="7ae7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">任务之间不应传输数据，状态之间也不应传输数据。</li><li id="e5f3" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">当且仅当所有任务都成功运行时，DAG才会显示为成功状态。</li><li id="26f8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">该工具应该在运行时显示和分配任务的状态。</li></ul><h1 id="612e" class="nc md it bd le nd ne nf mg ng nh ni mj nj nk nl mm nm nn no mp np nq nr ms ns bi translated">让我们一步一步地构建pyDag:</h1><h2 id="db6e" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">1.选择的基础设施:谷歌云平台</h2><p id="73c8" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">虽然该库旨在接受任何类型的云提供商或内部基础设施，但在这种情况下，我们将使用<a class="ae mu" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> Google云平台</a>作为云提供商，我们将创建三个层:</p><ul class=""><li id="12d7" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">一个将作为<strong class="js iu">摄取层</strong>的层，专门用于大数据工作负载，这样我们可以将数据从任何外部数据源移动到我们的暂存区，在这种情况下，我们将使用一个使用<a class="ae mu" href="https://cloud.google.com/dataproc" rel="noopener ugc nofollow" target="_blank"> Google Cloud Dataproc </a>的Apache Spark集群。另一个选择是使用<a class="ae mu" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank"> Google Cloud Functions </a>作为数据摄取层，但是如果我们需要在将数据移动到暂存区之前进行转换，该怎么办呢？在这种情况下，Google cloud functions相比Google Cloud Dataproc有一个非常明显的劣势，<a class="ae mu" href="https://www.analyticsvidhya.com/blog/2020/10/data-engineering-101-data-sources-apache-spark/#:~:text=Spark%20has%20six%20%E2%80%9Ccore%E2%80%9D%20data,sources%20written%20by%20the%20community." rel="noopener ugc nofollow" target="_blank">Google Cloud data proc的另一个优势是可以使用多种外部数据源</a>。<a class="ae mu" href="https://livy.apache.org/" rel="noopener ugc nofollow" target="_blank">如果您选择本地基础设施，Apache livy </a>可能是另一个选择。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/b1dda796546ccb7ac17c569ebf2b726c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mz1p4nZOdRwV8maRneFCsQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">1.Google Cloud Dataproc，2。Apache Livy用于内部基础架构，Google Cloud功能用于数据接收</figcaption></figure><ul class=""><li id="019a" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">该层将作为具有<a class="ae mu" href="https://cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>的<strong class="js iu">暂存区</strong>、分布式数据存储和数据仓库，所有来自外部源的数据将使用摄取层移动到该层。一切交给bigquery。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2b3c00885f2353c5e218ab139d080037.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*AxPii3K1gIM_WXMmDQFaCA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> BigQuery </strong></figcaption></figure><ul class=""><li id="f96d" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">使用<a class="ae mu" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank"> Google云存储</a>的<strong class="js iu">存储层</strong>，它将负责:</li></ul><p id="5272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">▹ <em class="lt">存储在bigquery </em>上执行的SQL脚本</p><p id="96d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">▹ <em class="lt">商店IAC脚本</em></p><p id="3a2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">▹ <em class="lt">存储pySpark脚本，用于从dataproc到bigquery的数据摄取</em></p><p id="c8da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">▹ <em class="lt">存储启动到dataproc集群的作业的输出日志</em></p><p id="49d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">▹ <em class="lt">在</em><strong class="js iu"><em class="lt">temporarygcsbucket</em></strong><em class="lt">桶中存储要从dataproc作业移动到bigquery的临时数据。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/d8c12cea770e647fae62f2186949effe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nm3e3w1cSGha-OJ0oPyGmw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">默认<strong class="bd le">谷歌云平台</strong>基础设施为<strong class="bd le"> pyDag </strong></figcaption></figure><h2 id="6681" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">2.DAG数据结构</h2><p id="7a66" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">这一步包括创建一个对象类，该对象类包含图的结构和一些方法，如向图中添加顶点(任务)，在顶点(任务)之间创建边(依赖关系),并执行基本验证，如检测图何时生成循环。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/80dace95f3bdbdd0ef2c525eca6efd3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsI0Jux5ddoXrBPq5b_urg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> Dag数据结构</strong></figcaption></figure><h2 id="f389" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">3.拓扑排序和并行执行</h2><p id="7162" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">这是一个有趣的部分，考虑调度它们之间有依赖关系的任务的问题，让我们假设任务“sendOrders”只能在任务“getProviders”和“getItems”成功完成之后进行。我们可以使用包含边“get providers”-&gt;“send orders”和边“getItems”-&gt;“send orders”的DAG来获得这种依赖关系，因此，通过使用上面的示例，拓扑排序算法将为我们提供一种顺序，按照这种顺序，这些任务可以按照它们之间的正确顺序及其依赖关系逐步完成。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/2ddcc25035f7c666a040ca133d505536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNUFUKs3RzIYXOPxEYmNDw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">拓扑排序</strong>、<strong class="bd le">并行处理器</strong>和<strong class="bd le">执行器</strong></figcaption></figure><p id="e918" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，拓扑排序算法将是pyDag类中的一个方法，它将被称为“run ”,该算法在每一步中都将提供可以并行执行的下一个任务。有很多关于这种技术的研究，但我将采取最快的解决方案，即对DAG应用拓扑排序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7c449a6fa948b41e2e779920c96a805e.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*uL-YjRQ4DQgYWD1kfLwvLQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> DAG使用4个处理器，完成DAG需要三个步骤</strong></figcaption></figure><p id="22ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将使用多重处理来并行执行更少或相同数量的任务。假设最初在拓扑排序算法的第一次迭代中，有许多可以并行执行的非依赖任务，并且该数目可能大于计算机中可用处理器的数目，则ParallelProcessor类将能够仅使用一个具有可用处理器的池来接受和执行这些任务，而其他任务在下一次迭代中执行。方便的是向pyDag类发送它可以并行执行多少任务，这将是可以同时执行的非依赖顶点(任务)的数量。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/20f6aa8c45cf0466c3f9ad95156e8b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5RgGky_sbPfmUv700y0gw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">多处理器系统中pyDag中任务实例的可能状态</figcaption></figure><p id="700f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">executor类将帮助我保存状态，并知道DAG中每个任务的当前状态</p><h2 id="9a62" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">4.引擎和处理器</h2><p id="9794" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">每个任务都与特定类型的引擎相关联，这样就可以实现多功能性，能够与任何云提供商交流采用不同技术实施的任务，但在深入了解之前，让我们先解释一下pyDag中任务的基本结构:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak">pyDag中的任务</strong></figcaption></figure><p id="57d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在。json文件，代表DAG，专门针对一个任务，<strong class="js iu"> <em class="lt">脚本</em> </strong>属性给出了关于一个特定任务的所有信息。使用5个级别的信息:</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><blockquote class="oj"><p id="2e3c" class="ok ol it bd om on oo op oq or os kn dk translated">位置。桶.文件夹.引擎.脚本_名称</p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><ul class=""><li id="fa06" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> <em class="lt"> Location: </em> </strong>它告诉我们脚本存储在什么类型的平台上，默认情况下最好是在相同类型的云提供商或位置上，不一定是这样，一些选项可以是:gcs、s3、local或database。</li><li id="b2e1" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu"> <em class="lt">桶:</em> </strong>这将是托管脚本的桶的名称，它不会影响是否选择“gcs”或“s3”，如果选择“local”，那么这一级和下一级将代表文件夹，如果是“database”，这一级和下一级将代表数据库名称和数据库中的表。建议使用项目名称作为存储桶名称。</li><li id="ddb4" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu"> <em class="lt">文件夹:</em> </strong>是桶内的文件夹，或者是本地文件夹，或者是数据库中的表。这里建议使用项目中模块的名称。</li><li id="0f6e" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu"> <em class="lt">引擎:</em> </strong>它告诉我们下一级“<strong class="js iu"> Script_name </strong>”将使用什么类型的引擎，例如，如果我的<strong class="js iu">引擎= spark </strong>这意味着脚本在Dataproc集群上执行，如果我的<strong class="js iu">引擎= bq </strong>这意味着我的脚本将在BigQuery中执行，如果我的<strong class="js iu">引擎= iac </strong>这意味着我的脚本将在所选的云平台上提供基础设施。</li><li id="45a8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu"> <em class="lt">脚本名称:</em> </strong>脚本名称或文件</li></ul><p id="8204" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">举例</strong>:</p><p id="5ab2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lt">【脚本】:" GCS . project-pydag . IAC _ scripts . IAC . data proc _ create _ cluster "</em></strong></p><p id="b2b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">名为"<strong class="js iu">data proc _ create _ cluster</strong>的脚本托管在GCS中的bucket " <strong class="js iu"> project-pydag </strong>"文件夹内:"<strong class="js iu"> iac_scripts </strong>"并且它的引擎是:"<strong class="js iu"> iac </strong>，这个句柄在云中设置infraestructure。</p><p id="1365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lt">【脚本】:" GCS . project-pydag . module _ name . spark . CSV _ GCS _ to _ bq "</em></strong></p><p id="5585" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">名为"<strong class="js iu"> csv_gcs_to_bq </strong>"的脚本驻留在gcs中，在文件夹"<strong class="js iu"> module_name </strong>"内的桶"<strong class="js iu"> project-pydag </strong>"中，其引擎是"<strong class="js iu"> spark </strong>"这意味着脚本将在Dataproc集群中执行。</p><p id="8b70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lt">【脚本】:" GCS . project-pydag . module _ name . bq . create _ table "</em></strong></p><p id="89f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">名为"<strong class="js iu"> create_table </strong>"的脚本托管在GCS中，在bucket " <strong class="js iu"> project-pydag </strong>"文件夹"<strong class="js iu"> module_name </strong>"内，其引擎为:"<strong class="js iu"> bq </strong>"这意味着脚本将在BigQuery集群中执行。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="58c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">运行任务的过程是完全动态的，并且基于以下步骤:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/f48143db5abfb24ba1533e300dc94f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCX9uIc6EdfyzkcmltJDRw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">引擎处理器，脚本处理器，引擎</strong></figcaption></figure><ul class=""><li id="3e26" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">每当它试图运行一个任务时，<strong class="js iu"> pyDag </strong>调用属于"<strong class="js iu"> Engine </strong>"类的继承方法"<strong class="js iu"> run </strong>",在内部，该方法使用另外两个继承方法"<strong class="js iu"> format_script </strong>"来自"<strong class="js iu"> script_handler </strong>"类和"<strong class="js iu"> run_script </strong>"来自"<strong class="js iu"> engine_handler 【T】</strong></li><li id="b5ea" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">首先，“<strong class="js iu"> format_script </strong>”方法从其位置获取脚本，并返回脚本接收到的格式良好的参数，以及一个Engine类的对象。</li><li id="dab8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">一旦返回来自上一步的数据，则“<strong class="js iu">引擎_处理程序</strong>的“<strong class="js iu">运行_脚本</strong>”方法将负责动态创建引擎，并且它将针对接收到的引擎调用“<strong class="js iu">运行_脚本</strong>方法，这样我们避免了向库中添加更多代码，并且我们只专注于设计新的引擎，我们具有任务可以在云上或本地使用任何类型的技术的灵活性。</li></ul><p id="bceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方式可能会导致将来的安全问题，但是在下一个版本中我会改进它</p><p id="1814" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引擎是您应该添加到pyDag的客户端应用程序，为了向您的任务提供您想要的技术，添加新引擎的步骤是添加到您的引擎所在的<strong class="js iu"> config.cfg </strong>文件，并使用名为“<strong class="js iu"> run_script </strong>的方法添加您的“<strong class="js iu"> clientclass.py </strong>”，该方法将负责接收脚本名称或脚本字符串。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/d7f683d5589f73c86b69d9a5e93f745e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuQrkX_18eyRE4_3Ylw5tg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">负责与基础设施交互的三个引擎:<strong class="bd le"> BQClient </strong>、<strong class="bd le"> IACClient </strong>和<strong class="bd le"> DPClient </strong></figcaption></figure><p id="e3ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，pyDag提供三种类型的引擎:</p><ul class=""><li id="5eab" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> BQClient </strong>:接收任何sql脚本并针对<em class="lt"> BigQuery </em>执行的客户端</li><li id="5ccb" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><strong class="js iu"> DPClient </strong>:它是<em class="lt"> Google Cloud Datapro </em> c客户端，它接收pyspark脚本及其所有相关参数，并针对您应该在参数中指明的集群执行它。</li><li id="b79b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">这是我发明的一个客户端，所以，有些任务只能作为云中基础设施的构建者，例如:创建一个dataproc集群，删除一个dataproc集群或者停止一个dataproc集群。</li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="7734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个很好的练习是创建一个Google Cloud函数引擎，这样你可以创建只在云中执行Python代码的任务。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="2723" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">5.通过将流量保持在本地来减少延迟</h2><p id="48c2" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">如果一个DAG有10个任务，并且在生产中每天运行4次，这意味着我们将在一天内提取字符串脚本40次，仅仅是为了一个DAG，那么如果您的业务或企业运营有10个以不同间隔运行的DAG，并且每个DAG平均有10个任务，那会怎么样呢？对GCS bucket会有许多不必要的请求，这会增加成本并增加任务的执行时间，不必要的请求可以使用redis在本地缓存。“<strong class="js iu"> script_handler </strong>”类将负责保存缓存的脚本。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/550b8ddb94cc29c9af507dea1a206b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57Y6nBK__VdD_epDU5PTaA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">redis缓存</figcaption></figure><h2 id="7f15" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">6.pyDag的多处理器机器体系结构。</h2><p id="c745" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">正如我们所见，<strong class="js iu"> pyDag </strong>类的一个对象包含了上面提到的所有东西，架构几乎准备好了。下面我将向您展示整个架构的概况。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/a100bafa0060515714a632cbee2c6586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLpdZj4zOpRWSI4ISbFIbg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> pyDag </strong></figcaption></figure><h2 id="d22a" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">7 .<strong class="ak">。让我们运行一个例子</strong></h2><h2 id="bb8a" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">GCP-JSON中的API凭证</h2><ul class=""><li id="548c" class="lf lg it js b jt nt jx nu kb ny kf nz kj oa kn lk ll lm ln bi translated">转到谷歌云控制台</li><li id="312f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">创建新项目</li></ul><p id="5074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lt">按照本视频中的步骤在Json : </em> </strong>中创建Api凭证</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ov oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> <em class="ow">在Json中创建Api凭证</em> </strong></figcaption></figure><h2 id="e2a9" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">GCP -大查询</h2><ul class=""><li id="2a0f" class="lf lg it js b jt nt jx nu kb ny kf nz kj oa kn lk ll lm ln bi translated">转到BigQuery</li><li id="3251" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">创建一个名为<strong class="js iu"> <em class="lt">的新数据集</em></strong></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/98bd74db57d43a2185954f3ef045198b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWgq-0kHlrFiizhejfV6zg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">BigQuery数据集:<strong class="bd le"> <em class="ow">数据集测试</em> </strong></figcaption></figure><h2 id="42f0" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">GCP数据公司</h2><ul class=""><li id="2702" class="lf lg it js b jt nt jx nu kb ny kf nz kj oa kn lk ll lm ln bi translated">转到Dataproc</li><li id="bee8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">现在点击启用API</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/7505cb58e5f9200863aa38b9a72e855e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nc_EFsB0xaCjgGoXVobGeA.png"/></div></div></figure><h2 id="d545" class="mc md it bd le me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">本地机器</h2><ul class=""><li id="35d0" class="lf lg it js b jt nt jx nu kb ny kf nz kj oa kn lk ll lm ln bi translated">在Windows   上安装<a class="ae mu" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> <em class="lt"> Docker Desktop，它也会安装Docker Compose，Docker Compose会让你运行多个容器应用。</em></strong></a></li><li id="ca77" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">安装<a class="ae mu" href="https://www.stanleyulili.com/git/how-to-install-git-bash-on-windows/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="lt">git-bash for windows</em></strong></a>，安装完成后，打开git bash并下载这个库，这样就会下载<strong class="js iu"><em class="lt">docker-compose . YAML</em></strong>文件，以及其他需要的文件。</li></ul><pre class="kp kq kr ks gt oz pa pb pc aw pd bi"><span id="cd37" class="mc md it pa b gy pe pf l pg ph">ramse@DESKTOP-K6K6E5A MINGW64 /c<br/>$ git clone <a class="ae mu" href="https://github.com/Wittline/uber-expenses-tracking.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Wittline/pyDag.git</a></span></pre><ul class=""><li id="cd4a" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">一旦从存储库中下载了所有需要的文件，让我们运行所有的程序。我们将再次使用git bash工具，转到文件夹<em class="lt"> pyDag </em>，我们将运行Docker Compose命令:</li></ul><pre class="kp kq kr ks gt oz pa pb pc aw pd bi"><span id="ac0f" class="mc md it pa b gy pe pf l pg ph">ramse@DESKTOP-K6K6E5A MINGW64 /c<br/>$ cd pyDag</span><span id="4f5a" class="mc md it pa b gy pi pf l pg ph">ramse@DESKTOP-K6K6E5A MINGW64 /c/pyDag<br/>$ cd code</span><span id="562e" class="mc md it pa b gy pi pf l pg ph">ramse@DESKTOP-K6K6E5A MINGW64 /c/pyDag/code<br/>$ cd apps</span><span id="2386" class="mc md it pa b gy pi pf l pg ph">@DESKTOP-K6K6E5A MINGW64 /c/pyDag/code/apps<br/>$ docker-compose up</span></pre><ul class=""><li id="b176" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">转到日志文件夹并检查输出</li></ul><p id="8ec1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们来解释一下这个例子</strong></p><p id="106d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多DAG配置可用于此示例，最合适且最短的是下图所示的第二种方法，我放弃了第一种方法，这两种方法实现了相同的目标，但是第二种方法有更多机会利用并行性并改善整体延迟。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/98ad85e5f92a7c3a346e057c34debf98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCXV8bQPq9MtYT3YLZ46dA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> DAG第一次接近</strong></figcaption></figure><p id="338a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个例子只是为了演示这个工具可以达到不同的粒度级别，这个例子可以用更少的步骤构建，实际上使用一个针对<em class="lt"> BigQuery </em>的查询，但是这是一个非常简单的例子来看看它是如何工作的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/5e34126cf6c56619955d953824d8ee64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qmJ2FrUFxiwxIXNhy_ATw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">达格第二次接近</strong></figcaption></figure><ul class=""><li id="a78a" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> startup_dataproc_1 </strong>:在GCP创建一个dataproc集群，名称为:“<em class="lt">cluster-data proc-pydag-2022”。</em></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak">data proc _ create _ cluster . IAC</strong></figcaption></figure><ul class=""><li id="6670" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> create_table_final: </strong>创建最终表"<em class="lt">my table 3</em><strong class="js iu"/>在BigQuery <strong class="js iu">，</strong>这里<strong class="js iu"> </strong>我们要选择和清理的数据。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> create_table.sql </strong></figcaption></figure><ul class=""><li id="509a" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> create_table_stg_1: </strong>在BigQuery中创建表<strong class="js iu"><em class="lt">"</em></strong><em class="lt">my table 1 "</em>。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> create_table_stg.sql </strong></figcaption></figure><ul class=""><li id="8ace" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> create_table_stg_2: </strong>在BigQuery中创建表<strong class="js iu"><em class="lt">"</em></strong><em class="lt">my table 2 "</em>。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> create_table_stg.sql </strong></figcaption></figure><ul class=""><li id="66f1" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> initial_ingestion_1: </strong>此任务将从。CSV文件存储在Google云存储中到BigQuery，这个脚本将在已经创建的Dataproc集群中执行，任务为:"<em class="lt"> startup_dataproc_1" </em>。在这种情况下，Dataproc集群将作为摄取层工作，目标表称为“table_stg <em class="lt">”。</em></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> csv_gcs_to_bq.py </strong></figcaption></figure><ul class=""><li id="8da0" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> extract_from_stg_1: </strong>该任务将把数据从<em class="lt"> table_stg </em>移动到<em class="lt"> mytable1 </em>中，只记录以下条件<strong class="js iu"> : </strong> <em class="lt">【年份】:【2022】和【类别】:【汽车】</em></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> extract_from_stg.sql </strong></figcaption></figure><ul class=""><li id="148a" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> extract_from_stg_2: </strong>此任务会将数据从"<em class="lt"> table_stg </em>"移动到"<em class="lt"> mytable2 </em>"中，并且只记录以下条件<strong class="js iu"> : </strong> <em class="lt">【年份】:【2021】和【类别】:【食品】。</em></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> extract_from_stg.sql </strong></figcaption></figure><ul class=""><li id="97a4" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu"> insert_to_fact: </strong>此任务将使用UNION ALL将数据从<strong class="js iu"> </strong> " <em class="lt"> mytable1 </em>"和"<em class="lt"> mytable2 </em>"填充到"<em class="lt"> mytable3 "中。</em></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> insert_to_fact.sql </strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/b7426aa50c3f073e562d23b887b0623f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*OnQsft9yCpzoH0H9FGD7aA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">期望的结果</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/f9484904a920e87470a139d4998f2fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0HUkec4Oq0ZMzp9QR85rw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">日志</strong></figcaption></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><blockquote class="oj"><p id="7b8b" class="ok ol it bd om on oo op oq or os kn dk translated">记住在这个例子中添加任务来关闭Google Dataproc集群，并删除在BigQuery中不再使用的临时表</p></blockquote></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="4f2d" class="nc md it bd le nd pn nf mg ng po ni mj nj pp nl mm nm pq no mp np pr nr ms ns bi translated">后续步骤</h1><p id="e717" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">为了有一个可接受的产品，需要最少的功能，我将努力增加以下内容:</p><ol class=""><li id="02df" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn ps ll lm ln bi translated">集中式日志</li><li id="1901" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ps ll lm ln bi translated"><em class="lt">一个元数据库</em></li><li id="0bc9" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ps ll lm ln bi translated"><em class="lt">在多台机器上分布式执行任务</em></li><li id="3694" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ps ll lm ln bi translated"><em class="lt">分支</em></li><li id="4f4b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ps ll lm ln bi translated"><em class="lt">使用API REST的DAG即服务。</em></li><li id="b5d1" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ps ll lm ln bi translated">带有拖放组件的GUI</li></ol><h1 id="78ca" class="nc md it bd le nd ne nf mg ng nh ni mj nj nk nl mm nm nn no mp np nq nr ms ns bi translated">结论</h1><p id="0ece" class="pw-post-body-paragraph jq jr it js b jt nt jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj nx kl km kn im bi translated">您可以清楚地观察到，在所有情况下，都有两个任务需要很长时间才能完成"<strong class="js iu"> startup_dataproc_1 </strong>"和"<strong class="js iu"> initial_ingestion_1 </strong>"，这两个任务都与使用<em class="lt"> Google DataProc </em>有关，避免使用在dataproc中创建集群的任务的一个方法是保持已经创建的集群并保持其打开以等待任务，通过水平扩展，这是对通过提交任务而具有高工作负荷的公司的强烈推荐</p><p id="abf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在执行中看到缓存的效果，在打开缓存的情况下，<strong class="js iu"> <em class="lt">短任务更短</em> </strong> <em class="lt"> </em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pt"><img src="../Images/330258ad35949a12a18097e7d4ee72dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sLwuKMew0qMktojpFvKijQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">甘特图:<strong class="bd le">具有多处理器和缓存的pyDag中的DAG行为</strong></figcaption></figure><p id="d24a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然任务执行中的并行性可以被确认<em class="lt">，</em>我们可以为每个DAG  分配一个<strong class="js iu"> <em class="lt">固定数量的处理器，它代表DAG </em>中可以并行执行的<em class="lt">最大任务数量或者<strong class="js iu"> <em class="lt">最大并行度</em> </strong>，但是这意味着有时会有处理器被浪费， 避免这种情况的一种方法是分配一个动态数量的处理器</em>，它只适应当前需要执行的任务数量，这样多个DAGS可以在一台机器上执行，并利用其他DAGS没有使用的处理器。 上述图表的唯一问题是，这些结果来自每个案例的一次执行，每个案例应该执行多次，并且每个案例需要平均时间，但是我没有足够的预算来进行这种测试，代码仍然非常不正式，还没有准备好投入生产，我将致力于这些细节，以便发布更稳定的版本。</strong></p><blockquote class="oj"><p id="9e4a" class="ok ol it bd om on oo op oq or os kn dk translated">查看我的GitHub库<a class="ae mu" href="https://github.com/Wittline/pyDag" rel="noopener ugc nofollow" target="_blank"> pyDag </a>以获得关于该项目的更多信息</p></blockquote><h1 id="eaab" class="nc md it bd le nd ne nf mg ng nh ni mj nj pu nl mm nm pv no mp np pw nr ms ns bi translated">参考</h1><ul class=""><li id="3066" class="lf lg it js b jt nt jx nu kb ny kf nz kj oa kn lk ll lm ln bi translated"><a class="ae mu" href="https://github.com/victor-gil-sepulveda/pyScheduler" rel="noopener ugc nofollow" target="_blank">https://github.com/victor-gil-sepulveda/pyScheduler</a></li><li id="1fd3" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://github.com/xianghuzhao/paradag" rel="noopener ugc nofollow" target="_blank">https://github.com/xianghuzhao/paradag</a></li><li id="34e5" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://medium.com/@ApacheDolphinScheduler/apache-dolphinscheduler-is-ranked-on-the-top-10-open-source-job-schedulers-wla-tools-in-2022-5d52990e6b57" rel="noopener">https://medium . com/@ Apache dolphinscheduler/Apache-dolphinscheduler-is-ranking-on-top-10-open-source-job-schedulers-wla-tools-in-2022-5d 52990 e6b 57</a></li><li id="fc3f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://medium.com/@raxshah/system-design-design-a-distributed-job-scheduler-kiss-interview-series-753107c0104c" rel="noopener">https://medium . com/@ rax shah/system-design-design-a-distributed-job-scheduler-kiss-interview-series-753107 c 0104 c</a></li><li id="8ce7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://dropbox.tech/infrastructure/asynchronous-task-scheduling-at-dropbox" rel="noopener ugc nofollow" target="_blank">https://Dropbox . tech/infra structure/asynchronous-task-scheduling-at-Dropbox</a></li><li id="b950" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://www.datarevenue.com/en-blog/airflow-vs-luigi-vs-argo-vs-mlflow-vs-kubeflow" rel="noopener ugc nofollow" target="_blank">https://www . data revenue . com/en-blog/air flow-vs-Luigi-vs-Argo-vs-ml flow-vs-kube flow</a></li><li id="7aaa" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://link.springer.com/chapter/10.1007/978-981-15-5566-4_23" rel="noopener ugc nofollow" target="_blank">https://link . springer . com/chapter/10.1007/978-981-15-5566-4 _ 23</a></li><li id="3887" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://www.researchgate.net/publication/2954491_Task_scheduling_in_multiprocessing_systems" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/publication/2954491 _ Task _ scheduling _ in _ multi processing _ systems</a></li><li id="d203" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="https://conference.scipy.org/proceedings/scipy2015/matthew_rocklin.html" rel="noopener ugc nofollow" target="_blank">https://conference . scipy . org/proceedings/scipy 2015/Matthew _ rocklin . html</a></li><li id="0eea" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae mu" href="http://article.nadiapub.com/IJGDC/vol9_no9/10.pdf" rel="noopener ugc nofollow" target="_blank">http://article.nadiapub.com/IJGDC/vol9_no9/10.pdf</a></li></ul><blockquote class="oj"><p id="5ffe" class="ok ol it bd om on px py pz qa qb kn dk translated">查看我的GitHub库<a class="ae mu" href="https://github.com/Wittline/pyDag" rel="noopener ugc nofollow" target="_blank"> pyDa </a> g以获得关于该项目的更多信息</p></blockquote></div></div>    
</body>
</html>