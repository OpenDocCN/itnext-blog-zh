<html>
<head>
<title>Beware of depends_on for Terraform modules. It might bite you!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小心Terraform模块的依赖关系。它可能会咬你！</h1>
<blockquote>原文：<a href="https://itnext.io/beware-of-depends-on-for-modules-it-might-bite-you-da4741caac70?source=collection_archive---------0-----------------------#2022-07-21">https://itnext.io/beware-of-depends-on-for-modules-it-might-bite-you-da4741caac70?source=collection_archive---------0-----------------------#2022-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b1d731aeb49eea05fb7be22a381aff1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dsZkuzIxgXWip6jF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@pastorthomasbwilson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汤姆·威尔森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f087" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">TLDR</h1><p id="f5ea" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">由于<a class="ae kc" href="https://www.hashicorp.com/blog/announcing-hashicorp-terraform-0-13" rel="noopener ugc nofollow" target="_blank"> Terraform 0.13 </a>，可以在模块中使用Terraform的<a class="ae kc" href="https://www.terraform.io/language/meta-arguments/depends_on" rel="noopener ugc nofollow" target="_blank"> depends_on </a>元参数。起初，这似乎是表达模块间依赖关系并确保资源按一定顺序应用的好方法。</p><p id="3fe8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">然而，<code class="fe me mf mg mh b">depends_on</code>对Terraform如何创建计划有着<a class="ae kc" href="https://www.terraform.io/language/meta-arguments/depends_on#processing-and-planning-consequences" rel="noopener ugc nofollow" target="_blank">重大影响</a>，尤其是在与数据源结合使用时。这甚至可能导致意外的资源重新创建！</p><p id="10d5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">除了意识到这种行为，你还可以做几件事来避免不受欢迎的意外。主要思想是尽可能地依赖隐式依赖关系，同时保持数据源靠近工作空间的根。这些将避免对<code class="fe me mf mg mh b">depends_on</code>的需求或大大减轻其不受欢迎的副作用。</p><blockquote class="mi mj mk"><p id="dee8" class="lb lc ml ld b le lz lg lh li ma lk ll mm mb lo lp mn mc ls lt mo md lw lx ly ij bi translated">这些例子使用了Azure，但是它们说明的问题和模式一般适用于Terraform代码</p></blockquote><h1 id="726f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">为什么模块的依赖行为会导致不受欢迎的意外</h1><p id="80c1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一个不知情的Terraform用户可能会认为<code class="fe me mf mg mh b">depends_on</code>只不过是一种指定模块和/或资源之间顺序的方式。虽然这是事实，但这只是故事的一部分。</p><p id="1e07" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b">depends_on</code>的使用对terraform如何计算计划也有很大的影响。虽然每个人都可以在文档<a class="ae kc" href="https://www.terraform.io/language/meta-arguments/depends_on#processing-and-planning-consequences" rel="noopener ugc nofollow" target="_blank">中看到这种影响</a>，但它的真实含义可能不会被注意到(<em class="ml">粗体字是我的</em>)</p><blockquote class="mi mj mk"><p id="193a" class="lb lc ml ld b le lz lg lh li ma lk ll mm mb lo lp mn mc ls lt mo md lw lx ly ij bi translated"><code class="fe me mf mg mh b"><em class="iq">depends_on</em></code>元参数指示Terraform在对声明依赖关系的对象执行操作之前，完成对依赖关系对象的所有操作(<strong class="ld ir">，包括读取操作</strong>)。当依赖对象是一个完整的模块时，<code class="fe me mf mg mh b"><em class="iq">depends_on</em></code>影响Terraform处理与该模块相关的所有资源和数据源的顺序。更多细节请参考<a class="ae kc" href="https://www.terraform.io/language/resources/behavior#resource-dependencies" rel="noopener ugc nofollow" target="_blank">资源依赖</a>和<a class="ae kc" href="https://www.terraform.io/language/data-sources#data-resource-dependencies" rel="noopener ugc nofollow" target="_blank">数据资源依赖</a>。</p></blockquote><p id="8706" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">而在链接的<a class="ae kc" href="https://www.terraform.io/language/data-sources#data-resource-dependencies" rel="noopener ugc nofollow" target="_blank">数据资源依赖关系</a>文档中，我们读到:</p><blockquote class="mi mj mk"><p id="f4bf" class="lb lc ml ld b le lz lg lh li ma lk ll mm mb lo lp mn mc ls lt mo md lw lx ly ij bi translated">[…]在<code class="fe me mf mg mh b"><em class="iq">data</em></code>块<strong class="ld ir">中设置<code class="fe me mf mg mh b"><em class="iq">depends_on</em></code>元参数会将数据源的读取</strong>推迟到<strong class="ld ir">应用完对依赖关系的所有更改</strong>之后。</p></blockquote></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="08a5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">还不确定它的含义吗？我们举个例子试试。想象你的主要地形如下图所示。</p><ul class=""><li id="7e35" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated">我们正在创建AKS集群以及VNET/子网和其他网络元素。</li><li id="7bf9" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated">因为像VNET和子网这样的资源名称是预先知道的，所以我们将它们传递给网络和集群模块。</li><li id="6b1f" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated">集群模块将检索带有数据源的子网的id，并且为了确保它在被创建后是只读的，在模块之间添加了一个显式的<code class="fe me mf mg mh b">depends_on</code>依赖。</li></ul><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="07b5" class="ns ke iq mh b gy nt nu l nv nw"># in main.tf<br/>module "my_aks_network" {<br/>  vnet_name = local.vnet_name<br/>  subnet_name = local.subnet_name<br/>  resource_group_name = local.resource_group_name<br/>  ...<br/>}</span><span id="beec" class="ns ke iq mh b gy nx nu l nv nw">module "my_aks_cluster" {<br/>  <strong class="mh ir">depends_on = [module.my_aks_network]</strong><br/>  <br/>  vnet_name = local.vnet_name<br/>  subnet_name = local.subnet_name<br/>  resource_group_name = local.resource_group_name<br/>  ...<br/>}</span><span id="9504" class="ns ke iq mh b gy nx nu l nv nw"># inside "my_aks_cluster" module:<br/><strong class="mh ir">data "azurerm_subnet" "sn"</strong> {<br/>  name                 = var.subnet_name<br/>  virtual_network_name = var.vnet_name<br/>  resource_group_name  = var.resource_group_name<br/>}</span><span id="73bd" class="ns ke iq mh b gy nx nu l nv nw">resource "azurerm_kubernetes_cluster" "cluster" {<br/>  ...<br/>  default_node_pool {<br/>    <strong class="mh ir">vnet_subnet_id = data.azurerm_subnet.sn.id<br/>    ...<br/>  </strong>}<br/>}</span></pre><p id="8d82" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">有了这个Terraform代码，每次my_aks_network模块内<strong class="ld ir">有任何变化</strong>，就会替换<strong class="ld ir"> AKS集群</strong>！</p><p id="bb92" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这是为什么呢？因为<code class="fe me mf mg mh b">depends_on</code>使Terraform在计划阶段不评估<code class="fe me mf mg mh b">data.azurerm_subnet</code>。由于默认节点池的<code class="fe me mf mg mh b">vnet_subnet_id</code>参数未知(并且是一个在不替换集群的情况下无法修改的参数)，这导致了替换AKS集群的计划。当您看到计划输出时，这一点很明显:</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="ca89" class="ns ke iq mh b gy nt nu l nv nw"># module.my_aks_cluster.data.azurerm_subnet.sn <strong class="mh ir">will be read during apply</strong><br/>  # (config refers to values not yet known)<br/> &lt;= data "azurerm_subnet" "sn"  {<br/>  ...      <br/>  <strong class="mh ir">+ id = (known after apply)</strong><br/>  ...<br/>}</span><span id="cb0a" class="ns ke iq mh b gy nx nu l nv nw"># module.my_aks_cluster.azurerm_kubernetes_cluster.cluster <strong class="mh ir">must be replaced</strong><br/>-/+ resource "azurerm_kubernetes_cluster" "cluster" {<br/>  ...      <br/>~ default_node_pool {<br/>    ...<br/>    <strong class="mh ir">~ vnet_subnet_id = "/subscriptions/..." -&gt; (known after apply) # forces replacement</strong><br/>  }<br/>}</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="74d7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这就是为什么讨论计划中<code class="fe me mf mg mh b">depends_on</code>含义的同一<a class="ae kc" href="https://www.terraform.io/language/meta-arguments/depends_on#processing-and-planning-consequences" rel="noopener ugc nofollow" target="_blank">文档</a>也<strong class="ld ir">建议您将它作为最后手段</strong>的原因。内容如下，虽然在我看来这应该是一个大红色警告在页面顶部:</p><blockquote class="ny"><p id="fef7" class="nz oa iq bd ob oc od oe of og oh ly dk translated">你应该把<code class="fe me mf mg mh b"><strong class="ak"><em class="oi">depends_on</em></strong></code>作为最后的手段，因为它会导致Terraform创建更保守的计划，替换更多不必要的资源。[……]当您使用<code class="fe me mf mg mh b"><em class="oi">depends_on</em></code>作为模块时，这尤其可能。</p><p id="1fc6" class="nz oa iq bd ob oc od oe of og oh ly dk translated">我们建议尽可能使用<a class="ae kc" href="https://www.terraform.io/language/expressions/references" rel="noopener ugc nofollow" target="_blank">表达式引用</a>来暗示依赖关系，而不是<code class="fe me mf mg mh b"><em class="oi">depends_on</em></code>。</p></blockquote><p id="d4fc" class="pw-post-body-paragraph lb lc iq ld b le oj lg lh li ok lk ll lm ol lo lp lq om ls lt lu on lw lx ly ij bi translated">文章的其余部分讨论了备选方案，可以总结为:</p><ul class=""><li id="f6b4" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated">首选隐式依赖关系</li><li id="fb9d" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated">避免模块内的数据源声明显式的<code class="fe me mf mg mh b">depends_on</code>依赖</li></ul><p id="af49" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果您必须将<code class="fe me mf mg mh b">depends_on</code>用于模块，我们将以一些简短的提示结束。</p><h1 id="c793" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">你能做什么来代替</h1><h2 id="4c5f" class="ns ke iq bd kf oo op dn kj oq or dp kn lm os ot kr lq ou ov kv lu ow ox kz oy bi translated">将数据源移到模块之外，将它们带到工作空间的根</h2><p id="04d4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">由于模块中最令人担忧的问题是由数据源引起的，一个显而易见的方法是将数据源移出依赖模块，并将读取值注入模块。</p><p id="52c6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">即，而不是:</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="c515" class="ns ke iq mh b gy nt nu l nv nw"># in main.tf<br/>module "my_aks_network"{<br/>  ...<br/>}<br/>module "my_aks_cluster" {<br/>  <strong class="mh ir">depends_on = [module.my_aks_network]</strong><br/>  ...<br/>}</span><span id="f794" class="ns ke iq mh b gy nx nu l nv nw"># inside "my_aks_cluster" module. <br/># Load resource group with a data source and use its id in some resources<br/><strong class="mh ir">data "azurerm_resource_group" "rg" {</strong><br/>  name = ...<br/>}</span><span id="572c" class="ns ke iq mh b gy nx nu l nv nw"># For example, when assigning a role to the cluster principal<br/>resource "azurerm_role_assignment" "ra" {<br/>  <strong class="mh ir">scope                = data.azurerm_resource_group.rg.id</strong><br/>  role_definition_name = ...<br/>  principal_id         = ...<br/>}</span></pre><p id="2b32" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">将代码重构为如下形式:</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="9853" class="ns ke iq mh b gy nt nu l nv nw"># in main.tf<br/><strong class="mh ir">data "azurerm_resource_group" "rg" {<br/>  name = ...<br/>}</strong></span><span id="43ab" class="ns ke iq mh b gy nx nu l nv nw">module "my_aks_network"{<br/>  ...<br/>}<br/>module "my_aks_cluster" {<br/>  depends_on = [module.my_vnet_and_subnets]<br/>  <strong class="mh ir">resource_group = data.azurerm_resource_group.rg</strong><br/>  ...<br/>}</span><span id="deb0" class="ns ke iq mh b gy nx nu l nv nw"># inside "my_aks_cluster" module:<br/>resource "azurerm_role_assignment" "ra" {<br/>  <strong class="mh ir">scope                = var.resource_group.id</strong><br/>  role_definition_name = ...<br/>  principal_id         = ...<br/>}</span></pre><p id="315c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe me mf mg mh b">depends_on</code>仍然会导致更保守的计划，但是现在这不会影响数据源的读取。这样，您就避免了更严重的副作用，这些副作用会导致不必要的更新或更糟的资源重建。</p><h2 id="a1bf" class="ns ke iq bd kf oo op dn kj oq or dp kn lm os ot kr lq ou ov kv lu ow ox kz oy bi translated">定义资源之间的隐式相关性</h2><p id="2caa" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有时你有两个互相依赖的资源，但是这种依赖是基于一个预先知道的参数，就像它的<code class="fe me mf mg mh b">name</code>。</p><p id="23b0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这些情况下，很容易在两个资源中使用相同的<code class="fe me mf mg mh b">name</code>参数/local。例如，您可以创建Azure网络安全组和一些规则，代码如下:</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="0fd2" class="ns ke iq mh b gy nt nu l nv nw">resource "azurerm_network_security_group" "nsg" {<br/>  name = var.network_security_group_name<br/>  ...<br/>}</span><span id="8e68" class="ns ke iq mh b gy nx nu l nv nw">resource "azurerm_network_security_rule" "my_rule" {<br/>  ...<br/>  network_security_group_name = var.network_security_group_name<br/>}</span></pre><p id="335b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">然而，使用这段代码，Terraform无法知道这两个资源之间存在依赖关系，因此它会试图同时创建这两个资源，这会带来麻烦。您可能想使用<code class="fe me mf mg mh b">depends_on</code>来明确定义这种关系:</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="62c4" class="ns ke iq mh b gy nt nu l nv nw">resource "azurerm_network_security_group" "nsg" {<br/>  name = var.network_security_group_name<br/>  ...<br/>}</span><span id="9648" class="ns ke iq mh b gy nx nu l nv nw">resource "azurerm_network_security_rule" "my_rule" {<br/>  ...<br/>  network_security_group_name = var.network_security_group_name<br/>  <strong class="mh ir">depends_on = [azurerm_network_security_group.nsg]</strong><br/>}</span></pre><p id="80c4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">由于<code class="fe me mf mg mh b">depends_on</code>，这将引导你走向惊喜之路。幸运的是，有一种简单的方法可以避免<code class="fe me mf mg mh b">depends_on</code>，并且仍然定义资源之间的隐含关系。</p><p id="0431" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">代替<code class="fe me mf mg mh b">depends_on</code>，使用依赖项的输出属性(上面的NSG)作为依赖项的输入参数(上面的NSG规则)</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="a874" class="ns ke iq mh b gy nt nu l nv nw">resource "azurerm_network_security_group" "nsg" {<br/>  name = var.network_security_group_name<br/>  ...<br/>}</span><span id="99c5" class="ns ke iq mh b gy nx nu l nv nw">resource "azurerm_network_security_rule" "my_rule" {<br/>  ...<br/>  network_security_group_name = <strong class="mh ir">azurerm_network_security_group.nsg.name</strong><br/>}</span></pre><h2 id="4c07" class="ns ke iq bd kf oo op dn kj oq or dp kn lm os ot kr lq ou ov kv lu ow ox kz oy bi translated">通过菊花链模块输出和输入，定义模块资源之间的隐式依赖关系</h2><p id="311c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">前面的模式可以跨模块推广。当在模块A中创建了模块B需要的东西时，将其细节(名称、id等)作为模块A的输出公开，并作为输入参数注入模块B。</p><p id="544f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当依赖关系基于设计时未知的参数(比如云提供商分配的id)时，这直接避免了可能的资源重建。这正是本文开头的示例中发生的情况，它导致AKS集群被重新创建。解决问题的方法是:</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="bc9c" class="ns ke iq mh b gy nt nu l nv nw"># in main.tf<br/>module "my_aks_network" {<br/>  ...<br/>}</span><span id="62bd" class="ns ke iq mh b gy nx nu l nv nw">module "my_aks_cluster" {<br/>  ... <br/>  # this way cluster module implicit depends on cluster_subnet<br/>  <strong class="mh ir">subnet_id = module.my_aks_network.id</strong><br/>}</span><span id="97a8" class="ns ke iq mh b gy nx nu l nv nw"># inside my_aks_network module<br/>output "id" { <br/><strong class="mh ir">  value = azurerm_subnet.snet.id </strong><br/>}</span><span id="79e8" class="ns ke iq mh b gy nx nu l nv nw"># inside my_aks_cluster module<br/>resource "azurerm_kubernetes_cluster" "cluster" {<br/>  ...<br/>  default_node_pool {<br/>    <strong class="mh ir">vnet_subnet_id = var.subnet_id<br/>    ...<br/>  </strong>}<br/>}</span></pre><p id="f80a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">然而，即使依赖关系是基于设计时已知的参数(比如用户分配的参数，比如子网的CIDR)，使用它们的输出和输入而不是<code class="fe me mf mg mh b">depends_on</code>来链接它们也是值得的。</p><p id="23ff" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个依赖项不会直接导致重新创建，但是添加一个<code class="fe me mf mg mh b">depends_on</code>可能会由于其他依赖项/资源而导致重新创建！在此过程中，您还将显式地链接各个资源，从而允许Terraform更好地理解依赖关系图，并按照预期的顺序创建/更新/删除它们。</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="6b02" class="ns ke iq mh b gy nt nu l nv nw"># in main.tf<br/>module "app_gw_subnet" {<br/>  subnet_cidr = local.app_gw_cidr<br/>  ...<br/>}</span><span id="1b23" class="ns ke iq mh b gy nx nu l nv nw">module "app_gw" {<br/>  ...</span><span id="8a3f" class="ns ke iq mh b gy nx nu l nv nw">  # <strong class="mh ir">do not do this </strong><br/>  # subnet_cidr = local.app_gw_cidr <br/>  # depends_on = [module.app_gw_subnet]<br/>  # <strong class="mh ir">Instead do this, so app_gw implicitly depends on app_gw_subnet</strong><br/>  subnet_cidr = <strong class="mh ir">module.app_gw_subnet.cidr</strong><br/>}</span><span id="bca4" class="ns ke iq mh b gy nx nu l nv nw"># inside app_gw_subnet module<br/>output "id" { <br/><strong class="mh ir">  value = azurerm_subnet.snet.address_prefixes.0</strong><br/>}</span></pre><blockquote class="mi mj mk"><p id="bd2d" class="lb lc ml ld b le lz lg lh li ma lk ll mm mb lo lp mn mc ls lt mo md lw lx ly ij bi translated">将资源的实际输出属性作为模块输出公开是很重要的，即使它的值是从输入参数中得知的！</p></blockquote><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="83e7" class="ns ke iq mh b gy nt nu l nv nw"># given a subnet where cidr is a user assigned parameter<br/>resource "azurerm_subnet" "snet" {<br/>  address_prefixes = [var.subnet_cidr]<br/>}</span><span id="ef95" class="ns ke iq mh b gy nx nu l nv nw"># Do not expose the cidr as an output like this<br/>output "cidr" { <br/><strong class="mh ir">  </strong>value<strong class="mh ir"> = var.subnet_cidr </strong><br/>}</span><span id="a244" class="ns ke iq mh b gy nx nu l nv nw"># Instead, do this<br/>output "cidr" { <br/><strong class="mh ir">  </strong>value<strong class="mh ir"> = azurerm_subnet.snet.address_prefixes.0</strong><br/>}</span></pre><h2 id="8af7" class="ns ke iq bd kf oo op dn kj oq or dp kn lm os ot kr lq ou ov kv lu ow ox kz oy bi translated">用一个<em class="oi">假的</em>输入变量定义隐式依赖关系</h2><p id="26ed" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有时没有参数可以用来链接一个模块的输出和另一个模块的输入。</p><p id="6a39" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">当这种情况发生时，您可以创建一个<em class="ml">假的</em>输入参数，并把它作为一个无害的东西使用，比如一个标签。通过添加和使用这个参数，您现在已经向您的模块添加了一种创建隐式依赖关系的方法(如果您只是添加了参数而没有使用它，那么就没有真正的隐式依赖关系)。</p><pre class="nk nl nm nn gt no mh np nq aw nr bi"><span id="618e" class="ns ke iq mh b gy nt nu l nv nw"># main.tf<br/>module "module_a" {<br/>  ...<br/>}</span><span id="9801" class="ns ke iq mh b gy nx nu l nv nw">module "module_b" {<br/>  ...<br/>  <strong class="mh ir">phony_depends_on_a = module_a.some_output</strong><br/>}</span><span id="7091" class="ns ke iq mh b gy nx nu l nv nw"># inside module_b code<br/>variable "phony_depends_on_a" {<br/>  ...<br/>}</span><span id="5d3e" class="ns ke iq mh b gy nx nu l nv nw">resource "azurerm_some_resource" "my_resource" { <br/>  ...<br/>  # use the fake input as something harmless, like a tag<br/>  <strong class="mh ir">tags</strong> = {<br/>    ... <br/>    module_a_dep = <strong class="mh ir">var.phony_depends_on_a</strong><br/>  }<br/>}</span></pre><p id="4b39" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Hashicorp的以下博客文章详细阐述了“假模块依赖”的思想，以防您需要走这条路(我必须说，以一种更简洁的方式，避免了像我示例中的标签那样的强制使用)。参见:</p><p id="2f25" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><a class="ae kc" href="https://medium.com/hashicorp-engineering/creating-module-dependencies-in-terraform-0-13-4322702dac4a" rel="noopener">https://medium . com/hashi corp-engineering/creating-module-dependencies-in-terra form-0-13-4322702 DAC 4a</a></p><h1 id="e3c0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">如果您仍然需要用depends_on显式定义依赖关系</h1><p id="43ed" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">尽量将<code class="fe me mf mg mh b">depends_on</code>的使用限制在同一个模块内的单个资源上，而不是模块之间。</p><p id="32cd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是如果你必须在模块之间使用<code class="fe me mf mg mh b">depends_on</code>呢？然后尝试确保声明<code class="fe me mf mg mh b">depends_on</code>依赖关系的模块(即<em class="ml">依赖</em>)或者:</p><ul class=""><li id="039d" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated">内部没有数据源</li><li id="2b84" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated">有数据源，但是由于从这些数据源读取的输入参数，不会重新创建使用它们的资源。例如，从数据源获取资源组名称可能会替换资源，但是从数据源获取标记值只会导致不必要的标记更新。</li></ul><p id="736d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">仅此而已。在我得到一些令人惊讶的计划后，我艰难地学会了这些陷阱和技巧。因此，我希望这能帮助其他人找到了解他们的简单方法！</p></div></div>    
</body>
</html>