<html>
<head>
<title>Mixing React modules into a legacy application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将React模块混合到遗留应用程序中</h1>
<blockquote>原文：<a href="https://itnext.io/mixing-react-modules-into-a-legacy-application-ddc0c5660ecd?source=collection_archive---------2-----------------------#2020-01-25">https://itnext.io/mixing-react-modules-into-a-legacy-application-ddc0c5660ecd?source=collection_archive---------2-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a0f53a2ecfd3655ce6d86356c1b4161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwwXxRHbPtQm2gOBu2-d2w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用React-modules概念验证的主干屏幕截图</figcaption></figure><p id="d6d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着一个巨大的单片前端应用程序的使用，您将会发现维护和增量更改的成本是相当大的，彻底的更改似乎是不可能的，并且为一个过时的技术招聘人员是一个大麻烦。是时候重写了！</p><p id="e09b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开始这个令人生畏的过程有不同的策略。但是在某些情况下，更好的选择可能是混合新旧的模块化重写。这种策略永远不会是最佳的，因为使用两个框架会增加大量的开销。但是，让我们说，总的权衡仍然可以有利于这一战略，并转移到技术的实用性。在这里，我将描述如何做到这一点的概念证明。它混合了Backbone中的React，因为那是我们的用例，但是这些原则也应该适用于其他框架。</p><h1 id="c369" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">概念验证</h1><p id="ffa7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">概念验证是基于主干ToDo应用程序(<a class="ae md" href="https://backbonejs.org/docs/todos.html" rel="noopener ugc nofollow" target="_blank">https://backbonejs.org/docs/todos.html</a>)，加入了一些材料设计。</p><p id="3590" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为此，我添加了两个React模块。一个是主干列表视图的替代(它仍然在那里，被一个复选框隐藏，以显示它们是同步的)，另一个是向待办事项的编辑添加特性。他们都使用Material UI(【https://material-ui.com/】T2)，这样风格就可以和主干应用保持一致。这两个模块相互独立地编译和部署，但是它们仍然共享mui-theme和Redux-store。</p><p id="8e98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">演示:【https://custom-react-elements.now.sh/ T4】</p><p id="e0a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GitHub:<a class="ae md" href="https://github.com/kjartanm/custom-react-elements" rel="noopener ugc nofollow" target="_blank">https://github.com/kjartanm/custom-react-elements</a></p><p id="c856" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是PoC解决的一些问题:</p><ul class=""><li id="0fd8" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">它不应该给遗留应用程序增加不必要的复杂性。</li><li id="94f0" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">它不应该给遗留应用程序增加不必要的开销。</li><li id="2e93" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">应该可以在不同React模块之间共享状态。</li><li id="706f" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">React模块和遗留应用程序之间应该可以轻松地传递状态。</li></ul><p id="4ce8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些问题通过以下步骤解决:</p><h2 id="07da" class="ms lb iq bd lc mt mu dn lg mv mw dp lk kn mx my lo kr mz na ls kv nb nc lw nd bi translated">步骤1:将React模块作为定制元素进行部署和集成</h2><p id="1de3" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">将React混合到遗留框架中有不同的方式。PoC使用一种技术，其中React模块被编译成一个定制元素。这种技术的“hello world”示例如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="04e2" class="ms lb iq nj b gy nn no l np nq">const HelloWorldComponent = () =&gt; {<br/>    return (<br/>        &lt;h1&gt;Hello world!&lt;/h1&gt;<br/>    )<br/>}</span><span id="b316" class="ms lb iq nj b gy nr no l np nq">class HelloWorldElement extends HTMLElement {<br/>    connectedCallback() {<br/>        ReactDOM.render(HelloWorldComponent(), this);<br/>    }<br/>}<br/>customElements.define('hello-world', HelloWorldElement);</span><span id="a284" class="ms lb iq nj b gy nr no l np nq">//Then you can just use the custom element to render and add the React component to the DOM</span><span id="f18e" class="ms lb iq nj b gy nr no l np nq">&lt;div class="legacyapp-container"&gt;<br/>    &lt;hello-world&gt;&lt;/hello-world&gt;<br/>&lt;/div&gt;</span></pre><p id="2377" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种技术的好处是，您可以添加React模块，而对遗留应用程序的代码库影响最小。相反，您可以通过遗留框架模板处理来间接实现。然后，您可以专注于从遗留应用程序中删除代码，用哑组件替换完整的逻辑组件，只是为了用自定义元素呈现模板。</p><h2 id="baf3" class="ms lb iq bd lc mt mu dn lg mv mw dp lk kn mx my lo kr mz na ls kv nb nc lw nd bi translated">步骤2:在React模块之间共享资源</h2><p id="5ed1" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">你不喜欢捆绑React和Redux等。对于每个组件。幸运的是，在编译模块时，很容易将这些依赖项设置为共享的外部依赖项。PoC从CDN加载React &amp; Co，而汇总配置(但这可能与使用webpack一样容易)告诉脚本在哪里可以找到它们:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4678" class="ms lb iq nj b gy nn no l np nq">//from rollup.config.js<br/> <br/>const globals = {<br/>    react: 'React',<br/>    redux: 'Redux',<br/>    'react-dom': 'ReactDOM',<br/>    'react-theme': 'reactTheme',<br/>    'react-store': 'reactStore',<br/>}</span><span id="8f8e" class="ms lb iq nj b gy nr no l np nq">const externals = ['react', 'redux', 'react-dom', 'react-theme', 'react-store']</span><span id="5905" class="ms lb iq nj b gy nr no l np nq">export default [<br/>    {<br/>        input: 'src/Module1Wrapper.js',<br/>        output: {<br/>            file: 'public/module1.js',<br/>            format: 'iife',<br/>            globals,<br/>            name: 'Module1'<br/>        },<br/>        externals,<br/>        plugins<br/>    },<br/>    ...<br/>]</span></pre><p id="3209" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本地依赖关系可以用同样的方式处理。共享主题导出为iife(立即调用的函数表达式),它将导出设置为可用作共享依赖项的命名全局:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="85f2" class="ms lb iq nj b gy nn no l np nq">//from rollup.config.js</span><span id="fcbb" class="ms lb iq nj b gy nr no l np nq">{<br/>    input: 'src/theme.js',<br/>    output: {<br/>        file: 'public/theme.js',<br/>        format: 'iife',<br/>        globals,<br/>        name: 'reactTheme'<br/>     },<br/>     external,<br/>     plugins<br/> }</span></pre><p id="bb4a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">资源是否应该共享，并不总是一目了然的。在PoC中，我可以通过CDN加载材质UI库，并像对待React、Redux一样对待它。但是加载整个库的开销超过了好处。相反，如果我真的需要优化，我可以创建一个只包含所需组件的本地包，并以与主题相同的方式提供这些组件。</p><h2 id="fb70" class="ms lb iq bd lc mt mu dn lg mv mw dp lk kn mx my lo kr mz na ls kv nb nc lw nd bi translated">步骤3:在React模块之间共享状态</h2><p id="5436" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">您可以像主题一样在模块之间共享redux存储:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2c83" class="ms lb iq nj b gy nn no l np nq">//from rollup.config.js</span><span id="8cda" class="ms lb iq nj b gy nr no l np nq">{<br/>    input: 'src/store.js',<br/>    output: {<br/>        file: 'public/store.js',<br/>        format: 'iife',<br/>        globals,<br/>        name: 'reactStore'<br/>    },<br/>    external,<br/>    plugins<br/>},</span></pre><p id="059e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，React模块将“导入”全局存储，使其与主题一起可用于模块:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2ca3" class="ms lb iq nj b gy nn no l np nq">const App = () =&gt; {<br/>    return (<br/>        &lt;Provider store={reactStore}&gt;<br/>            &lt;ThemeProvider theme={reactTheme}&gt;<br/>                &lt;SimpleEdit&gt;&lt;/SimpleEdit&gt;<br/>            &lt;/ThemeProvider&gt;<br/>        &lt;/Provider&gt;<br/>    )<br/>}</span></pre><p id="b844" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为共享资源是一个已创建的现成存储，所以状态将在模块之间共享。</p><h2 id="828c" class="ms lb iq bd lc mt mu dn lg mv mw dp lk kn mx my lo kr mz na ls kv nb nc lw nd bi translated">步骤4:在React模块和遗留应用程序之间交流状态</h2><p id="f2ce" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">共享Redux store的好处是，它还可以用于在遗留应用程序和React模块之间传递状态。在这里，我们需要给遗留应用程序添加一些东西，但是要注意集中完成，而不是分散在整个应用程序中。例如，在PoC中，我在主脚本中的Todos-collection上设置了一个监听器，用于将Todos分派给模块:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="a2a4" class="ms lb iq nj b gy nn no l np nq">Todos.on("change destroy", ()=&gt;{<br/>    window.reactStore.dispatch({ type: 'SET_TODOS', payload: Todos.toJSON() })<br/>})</span></pre><p id="cf8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面也是如此:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2747" class="ms lb iq nj b gy nn no l np nq">window.reactStore.subscribe(() =&gt; {<br/>    const state = window.reactStore.getState();<br/>    const items = (state.items?state.items:[]);<br/>    Todos.set(items);<br/>    Todos.each(todo=&gt;todo.save())<br/>})</span></pre><p id="e14b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这最后一个相当愚蠢。你很快就会需要一些抽象，让集合和模型只听状态的一部分，而不是整个状态，因为那会产生很多噪音。</p><p id="903b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还存在无限循环的危险，因为模型和状态正在相互监听，但是只要传入状态可以被检查为与现有状态等价，它就会停止。如果没有，你将需要一些簿记来确定。但是所有这些都不在PoC的范围内，所以改天再说。</p><h1 id="271e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="db0b" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">PoC可以工作，但是当然，创建PoC和在成熟的遗留应用程序中使用这种策略是有区别的。将会有hick ups，synhcing的问题，以及开销的显著增加——即使它是可以控制的。这是否是一个值得花的时间，是一个开放的问题，唯一的答案是，它取决于。</p></div></div>    
</body>
</html>