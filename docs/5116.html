<html>
<head>
<title>React Hooks with Context as a state management solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将上下文挂钩作为状态管理解决方案</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-with-context-as-a-state-management-solution-526d1c13a07d?source=collection_archive---------1-----------------------#2020-12-15">https://itnext.io/react-hooks-with-context-as-a-state-management-solution-526d1c13a07d?source=collection_archive---------1-----------------------#2020-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0a8cfecea216a961920204fe27865ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxPtpqA9D4hjzXjOmzlWNA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片由<a class="ae kc" href="https://pixabay.com/users/michaelgaida-652234/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3994109" rel="noopener ugc nofollow" target="_blank"> MichaelGaida </a>来自<a class="ae kc" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3994109" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="5325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都知道在大多数客户端应用程序中用来管理应用程序状态的大玩家<a class="ae kc" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Redux </strong> </a>和<a class="ae kc" href="https://mobx.js.org/README.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Mobx </strong> </a>库。但有时它们并不符合我们的需求，这就是你从react库中取出的<a class="ae kc" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">上下文</strong> </a>可以用来管理我们的应用程序状态的地方？</p><blockquote class="lb"><p id="dcbd" class="lc ld iq bd le lf lg lh li lj lk la dk translated">为什么要看这篇文章？因为我将提供一个简单而详细的例子来说明如何在您的应用程序中实现这个解决方案。</p></blockquote><p id="d82c" class="pw-post-body-paragraph kd ke iq kf b kg ll ki kj kk lm km kn ko ln kq kr ks lo ku kv kw lp ky kz la ij bi translated">在我们的应用程序中使用这个解决方案一年多之后，我可以有把握地说，是的，你可以使用<a class="ae kc" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> react context </a>，在这篇文章中，我将尝试以一种简化的方式展示我是如何使用它的。</p><p id="edd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将要展示的代码使用了<a class="ae kc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> react钩子</a>，这是目前推荐的编写react组件的方式，与编写类相反。</p><p id="3405" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">为什么我没有用Redux？<br/> </strong>我从事的项目是angular应用程序中react的混合，它已经管理了整个应用程序的状态，我想添加一个轻量级的状态库，可以减少组件之间传递的状态参数。由于Redux非常健壮，并且针对单个商店，所以它不太适合这个项目。</p><p id="156e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我为什么不用Mobx？我以前在一个不同的项目中使用过Mobx，感觉就像使用上下文一样，因为我在寻找一个轻量级的解决方案，这次Mobx似乎不是一个合适的选择。</strong></p><p id="46bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么我要使用上下文？React引入了Context API，这是状态管理包的一种替代方案。它提供了一种通过组件树传递数据的方法，而不必在每一层手动向下传递属性。</p><p id="81d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上下文API只在需要从3+级嵌套组件中访问数据时使用。</p><p id="f6fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Context API很棒，因为它使开发人员摆脱了必须理解、使用外部状态管理并将其集成到react应用程序中的麻烦。</p><p id="17ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何用钩子实现上下文？<br/>  <em class="lq"> context/index.js //这是我们配置上下文提供者的地方<br/>这是最重要的文件，我们在这里创建“本地”上下文提供者，它将使我们能够创建单独的上下文(如商店)。我们还使用了</em><a class="ae kc" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"><em class="lq">useReducer</em></a><em class="lq">钩子，使我们能够使用和更新本地上下文，就像使用redux一样。</em></p><p id="12d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">操作以这种方式编写，因此我们可以有一个该上下文可用操作的文档。我们还可以在每个函数的上方添加文档来说明不同的参数。</em></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c432" class="ma mb iq lw b gy mc md l me mf">import React, { useReducer } from 'react';</span><span id="1c0e" class="ma mb iq lw b gy mg md l me mf">const initialState = {<br/> todoList: ['buy dinner', 'run 5 km', 'finish work']<br/>};</span><span id="2869" class="ma mb iq lw b gy mg md l me mf">const actions = {<br/> add: (list, newItem) =&gt; {<br/>  return newItem === '' ? list : list.concat(newItem);<br/> },</span><span id="61e5" class="ma mb iq lw b gy mg md l me mf"> remove: (list, itemToRemove) =&gt; {<br/>  return itemToRemove === '' ? list : list.filter(item =&gt; item !==   itemToRemove);<br/> }</span><span id="4d80" class="ma mb iq lw b gy mg md l me mf">};</span><span id="2a74" class="ma mb iq lw b gy mg md l me mf">const PageContext = React.createContext(initialState);<br/>const pageReducer = (state, action) =&gt; {<br/> switch (action.type) {<br/>  case 'add':<br/>   state.todoList = actions.add(state.todoList, action.payload);<br/>   return { ...state };<br/>  default:<br/>   throw new Error();<br/>  }<br/>};</span><span id="476f" class="ma mb iq lw b gy mg md l me mf">const PageContextProvider = props =&gt; {<br/>const [contextState, updateContext] = useReducer(pageReducer, initialState);</span><span id="96d0" class="ma mb iq lw b gy mg md l me mf">return (<br/> &lt;PageContext.Provider value={{ contextState, updateContext }}&gt; <br/>  {props.children}<br/> &lt;/PageContext.Provider&gt;<br/>);</span><span id="a7eb" class="ma mb iq lw b gy mg md l me mf">};</span><span id="1348" class="ma mb iq lw b gy mg md l me mf">export { PageContext, PageContextProvider, actions };</span></pre><p id="d496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq"> your-page/index.js//这是容器页面使用上下文的地方</em></p><p id="e473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">在该文件中，我们导入内容提供者，因此我们将本地上下文的访问权授予上下文下的所有子节点，在本例中为ChildA、ChildB、ChildC。只有当我们在子组件</em>中使用useContext时，它们中的每一个才会在上下文改变时呈现</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="17ca" class="ma mb iq lw b gy mc md l me mf">import React, { useEffect } from 'react';<br/>import { PageContextProvider } from './context';<br/>import ChildA from './ChildA';<br/>import ChildB from './ChildB';<br/>import ChildC from './ChildC';</span><span id="d510" class="ma mb iq lw b gy mg md l me mf">import './style.less';</span><span id="d9d5" class="ma mb iq lw b gy mg md l me mf">export default function TemplatePage() {</span><span id="f67e" class="ma mb iq lw b gy mg md l me mf">return (</span><span id="7a15" class="ma mb iq lw b gy mg md l me mf">&lt;div className="template-page-wrapper"&gt;<br/> &lt;PageContextProvider&gt;<br/>  &lt;h2&gt;** This is a template for page component **&lt;/h2&gt;<br/>  &lt;ChildB /&gt;<br/>  &lt;ChildA /&gt;<br/>  &lt;ChildC /&gt;<br/> &lt;/PageContextProvider&gt;<br/>&lt;/div&gt;<br/>);</span></pre><p id="c070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq"> ChildA/index.js//使用上下文的页面中的一个子节点</em></p><p id="ab89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lq">在这个子组件中，我们可以看到如何导入pageContext，并使用useContext钩子从PageContext中提取状态和使用useReducer钩子公开的更新函数。</em></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5b61" class="ma mb iq lw b gy mc md l me mf">import React, { useContext } from 'react';<br/>import { PageContext } from '../context';</span><span id="0832" class="ma mb iq lw b gy mg md l me mf">import './style.less';</span><span id="5c26" class="ma mb iq lw b gy mg md l me mf">export default function ChildA() {<br/> const { contextState, updateContext } = useContext(PageContext);<br/> return (<br/>  &lt;div className="child-a-wrapper"&gt;<br/>   &lt;strong&gt;List of todos:&lt;/strong&gt;<br/>   {contextState.todoList.map((item, index) =&gt; (<br/>     &lt;div key={index} onClick={i =&gt; clickHandler(i)}&gt;{item}&lt;/div&gt;<br/>   ))}<br/>  &lt;/div&gt;<br/> );</span><span id="ec70" class="ma mb iq lw b gy mg md l me mf">function clickHandler(item) {<br/>   updateContext({<br/>     type: 'add',<br/>     payload: item  <br/>   });<br/> }<br/>}</span></pre><p id="fc54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是什么？</p><p id="08e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.改进减速器<br/>当你开始使用这种方法时，你很快就会看到减速器的开关盒变得越来越大，需要放在单独的文件中，这很难，我的意思是你如何组合几个开关盒？我不知道..因此，我想到了一种替代方案，可以给出同样的结果。这是代码:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5fc1" class="ma mb iq lw b gy mc md l me mf">// the new pageReducer varaible<br/>const pageReducer = (state, action) =&gt; {</span><span id="b4be" class="ma mb iq lw b gy mg md l me mf"> const combinedReducer = {<br/>  ...reducerA,<br/>  ...reducerB,<br/>  ...reducerC<br/> };</span><span id="e9b2" class="ma mb iq lw b gy mg md l me mf"> return combinedReducer[action.type](state, action);</span><span id="ea38" class="ma mb iq lw b gy mg md l me mf">};</span></pre><p id="c814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在单独的文件中，我放置了单独的减速器，这是它们的样子</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5c31" class="ma mb iq lw b gy mc md l me mf">const reducerA = {</span><span id="7909" class="ma mb iq lw b gy mg md l me mf">  functionA: (state, action) =&gt; {<br/>    ....<br/>  },<br/>  functionB: (state, action) =&gt; {<br/>    ....<br/>  }</span><span id="60a9" class="ma mb iq lw b gy mg md l me mf">}</span><span id="3d43" class="ma mb iq lw b gy mg md l me mf">export default reducerA;</span></pre><p id="0412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.了解局限性并为其制定解决方案。我想展示一个有趣的限制和解决方案。在大多数应用程序中，我们有一个容器，它是页面组件，在页面组件内部，我们有更小的组件。如果没有状态管理库，大多数应用程序将在页面中提取数据并作为道具传递给子组件，而在有状态管理库的应用程序中，提取数据的操作也将更新存储，每个“连接”的子组件都可以访问存储数据。在上下文中，这是有限制的。用提供者包装子组件的页面不能访问本地上下文，因此它不能将获取的数据传递给存储以供其他子组件使用。这是一个限制，因此有两种方法可以解决这个问题。你可以为那个页面组件制作另一个包装组件，我不认为这很好。或者…你可以使用特殊的子组件，我们称之为“APIConnect”。子组件可以访问本地上下文，因此他可以进行所有的获取并更新所有其他子组件，这使得父页面更干净，并为这一限制提供了一个很好的解决方案。</p><p id="c2b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这个特殊孩子的代码:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="332b" class="ma mb iq lw b gy mc md l me mf">import React, { useEffect, useContext } from 'react';<br/>import { PageContext } from '../context';<br/>import { /* all the services */} from '../services';</span><span id="844e" class="ma mb iq lw b gy mg md l me mf">export default function APiConnect() {<br/> const { updateContext } = useContext(PageContext);<br/> useEffect(() =&gt; {<br/>  async function getData() {<br/>  Promise.all([<br/>   promisify(blaService),<br/>   promisify(bliService),<br/>   promisify(bloService),<br/>  ]).then(data =&gt; {<br/>  const [bla, bli, blo] = data;</span><span id="434f" class="ma mb iq lw b gy mg md l me mf">   updateContext({<br/>    type: 'initialiseData',<br/>    payload: { bla, bli, blo }<br/>   });<br/>  });</span><span id="eb03" class="ma mb iq lw b gy mg md l me mf"> }<br/> getData();<br/>}, []);</span><span id="98e6" class="ma mb iq lw b gy mg md l me mf">return &lt;&gt;&lt;/&gt;;</span><span id="e085" class="ma mb iq lw b gy mg md l me mf">}</span></pre><p id="1c9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">promisify是promise的一个很好的包装函数，它采用了一个常规的回调函数和一个有效载荷(POST所需要的),并将回调函数转化为Promise，这样我们就可以使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> Promise.all </a></p><figure class="lr ls lt lu gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7cc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能激励你，关于提高性能的后续文章可以在<a class="ae kc" href="https://talwaserman.medium.com/react-context-and-react-tracked-296a6b86f890" rel="noopener">这里</a>找到</p></div></div>    
</body>
</html>