<html>
<head>
<title>Things I wish python packaging learned from the JVM Jars</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我希望python打包从JVM Jars中学到的东西</h1>
<blockquote>原文：<a href="https://itnext.io/things-i-wish-python-packaging-learned-from-the-jvm-jars-aed19133c121?source=collection_archive---------1-----------------------#2022-01-28">https://itnext.io/things-i-wish-python-packaging-learned-from-the-jvm-jars-aed19133c121?source=collection_archive---------1-----------------------#2022-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在python中的依赖性管理方面取得了很大进步，但是仍然缺少一个关键部分。</p><p id="9280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经分享了python依赖管理工具的经验，但是你必须承认python依赖管理已经走了很长的路。像<a class="ae kl" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">诗歌</a>这样的工具，基于一系列的pep，给了我们NPM的依赖锁定能力和管理一个真正简单的包构建流程的能力。不再有神秘的“显现”和设置。py黑魔法，而是干净，清晰和简单的“诗歌构建”,你就有了你的轮子。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/33073d23e85f03ffacfad65e255cbdf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*S7PaRKHq2oEeF-oqjVj_Yw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Ljubljana_Marshes_Wheel" rel="noopener ugc nofollow" target="_blank">约公元前3150年的卢布尔雅那沼泽车轮</a>(世界上最古老的精确放射性碳年代测定的木制车轮部件的复原模型)。</figcaption></figure><p id="193a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有<a class="ae kl" href="https://realpython.com/python-wheels/" rel="noopener ugc nofollow" target="_blank">轮子</a>都很棒！但是..安装时，下载所有指定的依赖项，这也是目前大多数用例的逻辑解决方案，除非..你的库包依赖于一个私有的回购包？还是打算安装在没有互联网的“安全”环境中？那我们就有麻烦了。</p><p id="bcdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人是最近才撞见这个的。我的大多数依赖项安装在docker构建中，在托管CI环境中，我可以提供私有的repo凭证，而不会在实际的工件上公开它们。但我需要在我的Databricks installed wheel中添加一个带有spark工作的私有包，突然我遇到了麻烦。</p><p id="9c62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些变通办法，您可以在安装wheel之前专门安装您的私有依赖项，您可以在生产环境中提供凭证。或者设置一个镜像/缓存来用您的包替换pypi。其他选项包括类似于<a class="ae kl" href="https://github.com/cloudify-cosmo/wagon" rel="noopener ugc nofollow" target="_blank">旅行车</a>或<a class="ae kl" href="https://pypi.org/project/shiv/" rel="noopener ugc nofollow" target="_blank"> Shiv </a>的项目，或者手动捆绑依赖关系的所有车轮</p><p id="71ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">进入优步罐</strong></p><p id="0200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JVM生态系统很久以前就遇到了这个问题，并为此开发了工具。汇编插件存在于所有主要的构建工具(gradle、maven、sbt for scala等)中，允许你创建包含所有依赖项的“优步罐”,并将它们一起交付给生产。它们还允许您控制不包括什么，例如，如果您在每个集群中预装了spark，您就不需要它成为UberJar的一部分，如果需要，还可以使用工具来解决冲突。</p><p id="47f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">后记</strong></p><p id="55d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很乐意接受纠正，并找到一种简单的方法将我的依赖项打包到一个锁死环境的轮子中。但是如果没有，我真的希望python依赖管理工具能给我们提供一个解决方案。我敢肯定有人已经在努力了。</p><p id="a085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别感谢<a class="ae kl" href="https://twitter.com/shaib_il" rel="noopener ugc nofollow" target="_blank"> Shai Berge </a> r、<a class="ae kl" href="https://twitter.com/taleinat" rel="noopener ugc nofollow" target="_blank"> Tal Einat </a>、<a class="ae kl" href="https://twitter.com/mkriheli" rel="noopener ugc nofollow" target="_blank"> Meir Kriheli </a>、<a class="ae kl" href="https://github.com/tovmeod" rel="noopener ugc nofollow" target="_blank"> Avraham Serour </a>以及整个<a class="ae kl" href="https://groups.google.com/g/pyweb-ilhttps://groups.google.com/g/pyweb-il" rel="noopener ugc nofollow" target="_blank"> Pyweb-IL group </a>的建议和投入，感谢他们这么多年来为我们提供了一个很好的学习场所和社区。</p></div></div>    
</body>
</html>