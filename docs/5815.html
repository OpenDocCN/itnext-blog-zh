<html>
<head>
<title>Easy Modular Monolith — Part 2— The OutBox Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简易模块化整体结构—第2部分—发件箱模式</h1>
<blockquote>原文：<a href="https://itnext.io/easy-modular-monolith-part-2-the-outbox-pattern-b4566724fb68?source=collection_archive---------1-----------------------#2021-06-01">https://itnext.io/easy-modular-monolith-part-2-the-outbox-pattern-b4566724fb68?source=collection_archive---------1-----------------------#2021-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一部分中，我们以模块化的方式准备了一个简单应用程序的MVP版本。有了框架，我们就可以实现进一步的改进。</p><p id="98eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将尝试实现一个发件箱模式，它将为我们处理消息传递，更重要的是，确保消息的消费者能够收到消息。</p><p id="d7df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在IT系统领域，有一件事是肯定的——如果某个东西可能会失败，它迟早会失败。让我们来看看我们的<strong class="jp ir">addproductcommandler</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/49f436ad017abe5d9bd0ecd40e5aa4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfGYSATryKyCdOPBSHC9SQ.png"/></div></div></figure><p id="0ba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到的是，在我们将数据保存到我们的数据库后，我们产生了一个应该由其他“模块”消费的事件。在一个完美的世界里，发送这个事件永远不会失败，消费者总是能够处理它——但在我们的世界里不会:)</p><p id="bf61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有搜索很远—mediator可能由于某种原因无法发布事件—配置错误/基础设施失败等。即使在成功发布之后，事件处理程序仍然会因为一些内部规则/验证/问题而抛出异常。MVP版本不能很好地处理这种情况——在失败的情况下，我们将以不一致的数据结束——更何况我们没有存储关于失败的信息，我们缺乏上下文，无法做出反应。</p><h1 id="e79b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">体系结构</h1><p id="df87" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了防止这种情况，我们将实现一种叫做“发件箱模式”的东西。这种模式背后的整个想法是，不要立即发布消息，而是将它存储在某个地方，并将发布的责任转移给其他人。</p><p id="f425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要的警告是记住保存消息和CommandHandler中的更改应该发生在一个事务中！</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a332195adf800f222a1d4ab4d3aa10d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*eMqiE9bQ42eo2c3q--_UXw.png"/></div></figure><p id="a3ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看一下上面的图片——看起来非常简单——我们有OutBox模块，它处理将消息存储到DB中，还有WorkerProcess，它使用OutBox模块获取消息，并通过MediatR通知发布它们。</p><p id="64a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着将它连接到我们的ModularMonolith应用程序——它看起来有点不同，也更复杂，但整体思想是相同的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/e1ced10598e1ca42c4feb66fc2c67065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_OYMbk8YSFI6KzEPsW-Aw.png"/></div></div></figure><p id="55da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Web Api项目是我们进入应用程序的入口点。它注册所有其他依赖项，因此可以访问任何模块。这里最大的变化是它将注册两个新的东西。</p><ul class=""><li id="4ba5" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">发件箱模块—从数据库中迁移和获取存储的消息。它包含一个OutboxDbContext，用于将发件箱数据集传递给其他模块。</li><li id="db80" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">发件箱工作进程—后台进程，将分派所有未处理的消息，并将它们发布到MediatR通知。</li></ul><p id="a302" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是将所有发件箱消息(来自我们的任何模块)存储到同一个数据库和表中的一个单独的模式中— <strong class="jp ir"> out.OutBoxMessages. </strong></p><h1 id="0e54" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">履行</h1><h2 id="f06c" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">契约</h2><p id="8de5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，我们需要在消息发布接口上创建一个抽象。这将允许我们在将来实现多种处理消息发布的方式。现在它将有如下两种方法:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/92383f789f6fc991e11dc9d7ae39bd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQUPDKoFh8mPByG0cAkOdg.png"/></div></div></figure><p id="7567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，也有一个新的界面。<strong class="jp ir">iintegratineven</strong>接口将是所有应该在模块间发布的事件的标记接口。</p><h2 id="d56a" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">发件箱模块</h2><p id="9b43" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">发件箱模块会比历史或者产品简单很多。让我们把它弄平。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/49b41b48e9fd2d354198fed98c453009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*7ne4VD3BKj6S4ttYrqIWzQ.png"/></div></figure><p id="9b22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这里的大部分代码属于基础设施层。从实用的角度来看，没有理由像在产品和历史模块中那样进行拆分。这里没有任何与域/应用相关的东西的计划，即使这样，我们也可以通过按文件夹而不是小项目划分层来扩展这种方法。</p><p id="4699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，该模块的使用方式也有所不同。它包含了发件箱模式的基本逻辑，因此它将被任何想要启用发件箱支持的模块引用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/53162299a8e5ed28101d9e5dbd0ee766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*no00oGix5PdEeDFs6E_9BQ.png"/></div></div></figure><p id="2aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的部分是我们的OutBoxDbContext，它用于交付负责保存/获取发件箱消息的代码。</p><p id="c706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OutBoxMessage实体如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/c9a72371270f10d1fe6c3a2b24e2c9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*RyXkotJ3QfjOKHKIkOlMHg.png"/></div></figure><p id="1c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Type属性中，我们将存储关于消息类型的信息(例如ProductCreatedEvent)。<br/>在消息属性中——“类型”的整个序列化对象。<br/>这两个属性稍后将在WorkerProcess中用于反序列化消息。</p><h2 id="814c" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">ModularMonolith。基础设施</h2><p id="288d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在这个项目中，我们将实现横切功能*——在这种情况下，它将是一个处理发布消息的<strong class="jp ir"> InMemoryEventBus </strong>。在这个版本中，我们将只处理<strong class="jp ir">iintegratinevent。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cad290fae7ab786e20917996ed9a048d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*hebroniTpknKVcsbTCGmIQ.png"/></div></figure><p id="fab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，MediatR不会立即发布消息，而是将它们存储在我们的数据库中。由于这一点，我们将能够在以后获取并处理所有这些消息。</p><p id="dd39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个EventBus实现中最棘手的部分是如何在不违反DRY原则的情况下实现它。正如我前面提到的，警告是命令处理程序的改变和保存消息必须在一个事务中发生。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/9fbcbbd5371665881ce2a6915085c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPZ3hUBrEg0t0Fj1qIlnNA.png"/></div></div></figure><p id="838d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再来看看我们的<strong class="jp ir"> AddProductCommandHandler </strong>。正如您所看到的，这里有几行新代码:<br/>第一行调用EventBus上的Publish(第27行)，第二行调用存储库上的Commit()(第29行)。</p><p id="3104" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ef Core的工作方式是，在其生命周期中添加到上下文的所有更改都不会提交到数据库，直到调用SaveChange。</p><p id="ba7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的第1部分中，我们的存储库在“Add”方法中调用SaveChanges，立即提交事务。在这个版本中，我们将稍后调用commit在调用EventBus上的“Publish”之后。</p><h2 id="1e12" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">那么这里有什么棘手的呢？</h2><p id="3989" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们可以有多个模块，它们都将使用同一个实体- <strong class="jp ir"> OutBoxMessage </strong>。我们不希望创建多个数据库上下文，并在它们之间共享一个数据库连接，以允许在一个事务中提交—当我们将来想要将我们的模块移动到单独的微服务*时，这将使我们的生活变得更加困难。</p><p id="1e39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再来看看我们的内存事件总线:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/cad290fae7ab786e20917996ed9a048d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*hebroniTpknKVcsbTCGmIQ.png"/></div></figure><p id="bbcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，作为输入参数，它接受OutBoxDbContext。<br/>整个想法是——在我们想要应用发件箱的模块中——通过OutBoxDbContext继承“模块”DbContext，如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/e6d2b166f8d9ab0669dc1c948c03bf8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLJX2Va-HI0wpCvAJ1v79Q.png"/></div></div></figure><p id="e584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们应该创建一个独立的、具体的模块EventBus，它将从我们的基础InMemoryEventBus继承——它将允许我们在运行时解析正确的EventBus:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/66d4e693f6653e456e318039988921b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhX9q0jzT3fwFO1jSgSBAg.png"/></div></div></figure><h2 id="8c01" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">好的——那么这里发生了什么？</h2><p id="02c8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这允许我们在InMemoryEventBus和CommandHandler之间共享DbContext的一个实例(因为它注册为scoped)——因此Commit()将保存来自命令处理程序的所有更改，并在一个事务中“发布”。</p><h2 id="fa0f" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">工作进程</h2><p id="d44c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">worker进程是我们的特殊人员，负责从数据库中获取所有消息，并使用MediatR发布它们。<br/>我们来看看:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/e6c722f7b3fee556b24507b2dc93acf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YpePcWhLgkwZpKaHvvXCYw.png"/></div></div></figure><p id="5106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要从DI容器中获取两个服务。(第34行)<br/> OutBoxDbContext用于DB访问，MediatR用于发布。</p><p id="ff40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的部分发生在循环中(第38行)。<br/>首先，我们需要确定信息的类型。由于我们的模块化整体是一个应用程序，我们能够加载一个包含所有契约(Modular Monolith)的DLL。合同项目)并从那里解决类型。(第42行)<br/>有了契约类型，我们就能够反序列化消息。(第44行)。</p><p id="f219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们使用MediatR发布一个消息。如果一切正常，我们更新ExecutionData，记录关于处理消息的信息，并转移到下一个。<br/>如果出现错误，记录错误信息并尝试处理下一条消息。重要的是，在这个版本中，我们不会实现任何更复杂的错误处理方式(重试/有害消息/通知)。这是将会发生的事情，并且已经放在路线图中:)</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7743" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的缺点是工作进程在循环中处理消息。在我们的例子中，它每1秒执行一次消息。如果我们被迫处理大量的消息，那么这个地方将成为我们的瓶颈。我们将来会更仔细地研究这个问题。</p><h2 id="d700" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">没错。</h2><p id="7e03" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们有一个可行的解决方案，可以保证我们的信息得到存储和处理。在最近的功能中，我们将改进发件箱中处理异常的方式，使解决方案更能抵抗失败。</p><h1 id="b47c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">总结:</h1><ul class=""><li id="933c" class="mc md iq jp b jq lv ju lw jy nn kc no kg np kk mh mi mj mk bi translated">OutBoxPattern是一种模式，它通过将消息持久化(在一个事务中)并将分派委托给外部“应用程序”来保证将消息传递给消费者。</li><li id="7629" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">OutBoxModule提供了一个OutBoxDbContext，可以在其他模块中使用它来提供发件箱支持。要为下一个模块添加对Outbox的支持，我们只需要通过OutBoxDbContext继承DBContext，并通过继承InMemoryEventBus创建一个模块EventBus。</li></ul><h1 id="9fb0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">完整代码可在此处获得:</h1><p id="ac45" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><a class="ae nq" href="https://github.com/Ridikk12/ModularMonolith/tree/OutBoxPattern" rel="noopener ugc nofollow" target="_blank">https://github . com/ridikk 12/ModularMonolith/tree/outbox pattern</a></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr nm l"/></div></figure><h1 id="cda3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">上一个:</h1><div class="ns nt gp gr nu nv"><a href="https://ridikk12.medium.com/easy-modular-monolith-part-1-mvp-d57f47935e24" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">简易模块化整体结构—第1部分— MVP</h2><div class="oc l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">ridikk12.medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kv nv"/></div></div></a></div><h1 id="941f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在下一部分:</h1><div class="ns nt gp gr nu nv"><a href="https://ridikk12.medium.com/easy-modular-monolith-part-3-logging-57caceac1ff5" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">简易模块化整体式设备—第3部分—测井</h2><div class="oj l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在一个完美的世界里，IT系统中没有漏洞和维护的位置。作为开发人员，我们更喜欢提供新的…</h3></div><div class="oc l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">ridikk12.medium.com</p></div></div><div class="od l"><div class="ok l of og oh od oi kv nv"/></div></div></a></div><h1 id="3fa9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将来(此列表可能会更改):</h1><ul class=""><li id="3b26" class="mc md iq jp b jq lv ju lw jy nn kc no kg np kk mh mi mj mk bi translated">发件箱改进。</li><li id="b97a" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">域事件。</li><li id="de91" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">单元/集成测试。</li><li id="2c52" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">存储配置。</li><li id="5736" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">模块之间的直接通信。</li><li id="2b1d" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">数据库方法(多个数据源)。</li><li id="a14d" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">准备微服务(用RabbitMq代替MediatR)。</li><li id="6574" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">迁移到微服务。</li></ul><h2 id="7c98" class="mq ky iq bd kz mr ms dn ld mt mu dp lh jy mv mw ll kc mx my lp kg mz na lt nb bi translated">参考资料:</h2><p id="8897" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">https://docs . Microsoft . com/en-us/ef/core/saving/transactions<br/>https://micro services . io/patterns/data/transactional-outbox . html<br/><a class="ae nq" href="https://en.wikipedia.org/wiki/Cross-cutting_concern#:~:text=Cross%2Dcutting%20concerns%20are%20parts,oriented%20programming%20or%20procedural%20programming" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Cross-cutting _ concern #:~:text = Cross % 2d cutting % 20 concerns % 20 are % 20 parts，面向% 20编程% 20或% 20程序性% 20编程</a>。</p></div></div>    
</body>
</html>