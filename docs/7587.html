<html>
<head>
<title>Spring Modulith: have we reached modularity maturity?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Modulith:我们已经达到模块化成熟度了吗？</h1>
<blockquote>原文：<a href="https://itnext.io/spring-modulith-modularity-maturity-118eca138533?source=collection_archive---------2-----------------------#2022-11-16">https://itnext.io/spring-modulith-modularity-maturity-118eca138533?source=collection_archive---------2-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c317760c8db003cf8b1e0fa84d3115fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_Bz7zZ7U37wP8HDz8IPzQ.jpeg"/></div></div></figure><p id="bf00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设计微服务的一个主要原因是它们强化了<a class="ae kw" href="https://martinfowler.com/articles/microservice-trade-offs.html#boundaries" rel="noopener ugc nofollow" target="_blank">强模块边界</a>。然而，微服务的缺点是巨大的，就像砍掉你的右手来学习用左手写字一样；还有更易管理的(也更少痛苦！)达到同样结果的方法。</p><p id="2ed1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">甚至从微服务热潮开始，就有一些比较冷静的头脑占了上风。特别是，Spring框架的开发人员奥利弗·德罗特博姆(Oliver Drotbohm)长期以来一直是替代方案<a class="ae kw" href="https://github.com/moduliths/moduliths" rel="noopener ugc nofollow" target="_blank">的支持者。这个想法是保持一个整体，但围绕模块进行设计。</a></p><p id="0487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多人涌向微服务，因为他们工作的应用程序就像意大利面条拼盘。如果他们的应用程序设计得更好，微服务的吸引力就不会这么强。</p><h1 id="4589" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么模块化？</h1><p id="d020" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">模块化是减少变更对代码库影响的一种方式。这非常类似于一个人如何设计(大)船。</p><p id="4643" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当水不断渗入船内时，由于阿基米德推力的减小，船一般会下沉。为了避免一个漏洞使船沉没，它被设计成围绕多个水密的隔间。如果发生一次泄漏，它会被限制在一个单独的隔间里。虽然它并不理想，但它可以防止船下沉，让它改道到最近的港口进行修理。</p><p id="7b7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块化的工作方式类似:它为代码的各个部分划定界限。这样，变化的影响就被限制在零件内部，不会扩散到边界之外。</p><p id="5cc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Java中，这样的部分被称为包。与船舶的相似之处就到此为止，因为软件包必须一起工作才能达到预期的结果。包装不可能“滴水不漏”。Java语言提供了跨包边界工作的可见性修饰符。有趣的是，最著名的一个<code class="fe ma mb mc md b">public</code>，完全允许跨包。</p><p id="a6bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设计遵循最小特权原则的边界是一项持续的工作。有可能在项目初始开发的压力下，或者在维护过程中，随着时间的推移，努力将会失败，界限将会消失。</p><p id="ddee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一种更先进的方法来加强边界。</p><h1 id="0dc0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模块，到处都是模块</h1><p id="493f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Java的漫长历史中，“模块”一直是一种加强边界的解决方案。事实是，即使在今天，模块也有许多定义。</p><p id="ab07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OSGI 始于2000年，旨在提供可以在运行时安全部署和取消部署的版本化组件。它保留了JAR部署单元，但在其清单中添加了元数据。OSGi是强大的，但是开发一个OSGi <em class="me">包</em>(一个模块的名字)是复杂的。开发者付出了更高的开发成本，而运营团队却享受到了部署的好处。DevOps还没有出生；这并没有让OSGi像它本来应该的那样受欢迎。</p><p id="fb78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与此同时，Java的架构师们也在寻找模块化JDK的方法。与OSGI相比，这种方法要简单得多，因为它避免了部署和版本问题。Java 9中引入的Java模块将自己限制为以下数据:名称、公共API和对其他模块的依赖。</p><p id="75a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Java模块在JDK上工作得很好，但在应用程序上就不那么好了，因为这是一个先有鸡还是先有蛋的问题。为了对应用程序有所帮助，开发人员必须模块化库——不依赖于自动模块。但是只有当足够多的应用程序开发人员使用它时，库开发人员才会这样做。<a class="ae kw" href="https://blog.frankel.ch/update-state-java-modularization/" rel="noopener ugc nofollow" target="_blank">上次我查了一下</a>，20个commons库中只有一半是模块化的。</p><p id="4ca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构建方面，我需要引用Maven模块。它们允许将一个人的代码分成多个项目。</p><p id="445b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JVM上还有其他模块系统，但这三个是最著名的。</p><h1 id="da68" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实施边界的尝试性方法</h1><p id="4949" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如上所述，微服务在开发和部署过程中提供了最终的边界。它们在大多数情况下都是过度的。另一方面，不可否认的是，随着时间的推移，项目会腐烂。即使是制作最精美、重视模块化的，如果不经常打理，也注定会变得一团糟。</p><p id="8dfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要规则来加强边界，并且需要像测试一样对待它们:当测试失败时，必须修复它们。同样，当一个人打破了规则，他必须修复它。ArchUnit是一个创建和执行规则的工具。一个人配置规则并作为测试来验证它们。不幸的是，这种配置非常耗时，并且必须不断维护才能提供价值。下面是一个遵循六角形架构原则的<a class="ae kw" href="https://github.com/thombergs/buckpal" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>的片段:</p><pre class="mf mg mh mi gt mj md mk bn ml mm bi"><span id="34cf" class="mn ky iq md b be mo mp l mq mr">HexagonalArchitecture.boundedContext("io.reflectoring.buckpal.account")<br/>                     .withDomainLayer("domain")<br/>                     .withAdaptersLayer("adapter")<br/>                     .incoming("in.web")<br/>                     .outgoing("out.persistence")<br/>                     .and()<br/>                         .withApplicationLayer("application")<br/>                         .services("service")<br/>                         .incomingPorts("port.in")<br/>                         .outgoingPorts("port.out")<br/>                     .and()<br/>                         .withConfiguration("configuration")<br/>                         .check(new ClassFileImporter()<br/>                         .importPackages("io.reflectoring.buckpal.."));</span></pre><p id="000e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe ma mb mc md b">HexagonalArchitecture</code>类是在ArchUnit API上定制的DSL外观。</p><p id="cc55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，ArchUnit总比什么都没有好，但也不尽然。它的主要好处是通过测试实现自动化。如果能够自动推断出体系结构规则，将会有很大的改进。这就是Spring Modulith项目背后的想法。</p><h1 id="8ae2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">弹簧模量</h1><p id="0251" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Spring Modulith是Oliver Drotbohm的<a class="ae kw" href="https://github.com/moduliths/moduliths" rel="noopener ugc nofollow" target="_blank"> Moduliths项目</a>(后面有一个S)的继承者。它同时使用ArchUnit和<a class="ae kw" href="https://github.com/xmolecules/jmolecules" rel="noopener ugc nofollow" target="_blank">j分子</a>。在写这篇文章的时候，它还处于实验阶段。</p><p id="18c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">弹簧模数允许:</p><ul class=""><li id="6cf6" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">记录项目包之间的关系</li><li id="3ecc" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">限制某些关系</li><li id="833d" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">在测试期间测试限制</li></ul><p id="238c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它要求一个人的应用程序使用Spring框架:它利用后者对前者的理解，后者是通过DI组装获得的。</p><p id="f2fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，Modulith模块是一个与带<code class="fe ma mb mc md b">SpringBootApplication</code>注释的类位于同一层的包。</p><pre class="mf mg mh mi gt mj md mk bn ml mm bi"><span id="590e" class="mn ky iq md b be mo mp l ng mr">|_ ch.frankel.blog<br/>    |_ DummyApplication       // 1<br/>        |_ packagex           // 2<br/>        |  |_ subpackagex     // 3<br/>        |_ packagey           // 2<br/>        |_ packagez           // 2<br/>          |_ subpackagez      // 3</span></pre><ol class=""><li id="86f2" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv nh my mz na bi translated">应用程序类别</li><li id="4280" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated">模数</li><li id="4e9b" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated">不是一个模块</li></ol><p id="8d14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，一个模块可以访问任何其他模块的内容，但不能访问</p><p id="9664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring Modulith提供基于PlantUML生成基于文本的图，使用UML或者<a class="ae kw" href="https://c4model.com/" rel="noopener ugc nofollow" target="_blank"> C4 </a>(默认)皮肤。这一代人非常容易:</p><pre class="mf mg mh mi gt mj md mk bn ml mm bi"><span id="7367" class="mn ky iq md b be mo mp l mq mr">var modules = ApplicationModules.of(DummyApplication.class);<br/>new Documenter(modules).writeModulesAsPlantUml();</span></pre><p id="147f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一个模块访问一个常规包，要中断构建，在测试中调用<code class="fe ma mb mc md b">verify()</code>方法。</p><pre class="mf mg mh mi gt mj md mk bn ml mm bi"><span id="05c5" class="mn ky iq md b be mo mp l mq mr">var modules = ApplicationModules.of(DummyApplication.class).verify();</span></pre><h1 id="a3a4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可以玩的样品</h1><p id="dd0b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我已经创建了一个<a class="ae kw" href="https://github.com/ajavageek/spring-modulith-sample" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>来玩:它模拟了一个在线商店的主页。主页由服务器端的百里香生成，显示目录项目和新闻提要。后者也可以通过HTTP API进行客户端调用(我懒得编码)。商品显示有价格，因此需要定价服务。</p><p id="33ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个特性——页面、目录、新闻提要和定价——都位于一个包中，该包被视为一个Spring模块。Spring Modulith的记录功能会生成以下内容:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d7e6ab8879e4de2976884aa440527a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*lsKUZyG0LsUdzqnCUIUgQA.png"/></div></figure><p id="a256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看定价功能的设计:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/480cb0a7f2af5036546ca33b92aa6cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*UxZ3v1NEsSLSO0MnZcd0ZA.png"/></div></figure><p id="cec2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当前的设计有两个问题:</p><ul class=""><li id="31a3" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">在模块外部可以访问<code class="fe ma mb mc md b">PricingRepository</code></li><li id="cea0" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><code class="fe ma mb mc md b">PricingService</code>泄露<code class="fe ma mb mc md b">Pricing</code> JPA实体</li></ul><p id="293d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过封装不应该暴露的类型来修复设计。我们将<code class="fe ma mb mc md b">Pricing</code>和<code class="fe ma mb mc md b">PricingRepository</code>类型移动到<code class="fe ma mb mc md b">pricing</code>模块的<code class="fe ma mb mc md b">internal</code>子文件夹中:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5cb0794759261be0a82de7ee1515818a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*Es_v-0L39NmbjjLzBWbDRg.png"/></div></figure><p id="8c14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们调用<code class="fe ma mb mc md b">verify()</code>方法，它会抛出并中断构建，因为从<code class="fe ma mb mc md b">pricing</code>模块外部无法访问<code class="fe ma mb mc md b">Pricing</code>:</p><pre class="mf mg mh mi gt mj md mk bn ml mm bi"><span id="271c" class="mn ky iq md b be mo mp l ng mr">Module 'home' depends on non-exposed type ch.frankel.blog.pricing.internal.Pricing within module 'pricing'!</span></pre><p id="ec29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过以下更改来解决违规问题:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/6a001538d8b7f92d10d5b05ec9e1c4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EG6J8WkaCZeB3FB9f05CJQ.png"/></div></div></figure><h1 id="5a93" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="b7b4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">通过摆弄一个示例应用程序，我确实喜欢Spring Modulith。</p><p id="8dfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以看到两个突出的用例:记录现有的应用程序和保持设计“干净”。后者避免了应用程序随着时间的推移而“腐烂”的影响。这样，我们可以保持设计的意图，避免意大利面条的效果。</p><p id="8bca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">锦上添花:当我们需要<a class="ae kw" href="https://blog.frankel.ch/chopping-monolith/" rel="noopener ugc nofollow" target="_blank">砍掉一个</a> <a class="ae kw" href="https://blog.frankel.ch/chopping-monolith-demo/" rel="noopener ugc nofollow" target="_blank">或者更多的特性</a>到他们的部署单位时，这是很棒的。这将是一个非常直截了当的举措，无需浪费时间来解决依赖性。Spring Modulith提供了一个巨大的好处:<strong class="ka ir">将每一个有影响力的架构决策推迟到最后一刻</strong>。</p><p id="b0dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢<a class="ae kw" href="https://twitter.com/odrotbohm" rel="noopener ugc nofollow" target="_blank"> Oliver Drotbohm </a>的点评。</p><p id="7e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae kw" href="https://github.com/ajavageek/spring-modulith-sample" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到源代码。</p><p id="6725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="85d8" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><a class="ae kw" href="https://spring.io/blog/2022/10/21/introducing-spring-modulith" rel="noopener ugc nofollow" target="_blank">介绍弹簧模数</a></li><li id="ce36" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae kw" href="https://spring.io/projects/spring-modulith" rel="noopener ugc nofollow" target="_blank">快速启动</a></li><li id="2656" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated"><a class="ae kw" href="https://docs.spring.io/spring-modulith/docs/0.1.0-M1/reference/html/" rel="noopener ugc nofollow" target="_blank">参考文件</a></li></ul></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="d126" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="me">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/spring-modulith-modularity-maturity/" rel="noopener ugc nofollow" target="_blank"> <em class="me">一个Java怪胎</em></a><em class="me">2022年11月13日</em></p></div></div>    
</body>
</html>