<html>
<head>
<title>Write your Kubernetes Infrastructure as Go code — Manage AWS services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的Kubernetes基础设施编写为Go代码—管理AWS服务</h1>
<blockquote>原文：<a href="https://itnext.io/write-your-kubernetes-infrastructure-as-go-code-manage-aws-services-815ecd4d1af8?source=collection_archive---------0-----------------------#2022-11-01">https://itnext.io/write-your-kubernetes-infrastructure-as-go-code-manage-aws-services-815ecd4d1af8?source=collection_archive---------0-----------------------#2022-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/aa0c154d626b1f56bbc2933878a741d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlHypfWYZXvMu2Ak7CzyYg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">cdk8s.io</figcaption></figure><div class=""/><div class=""><h2 id="4b06" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">使用<code class="fe ku kv kw kx b">cdk8s</code>和AWS控制器为Kubernetes部署DynamoDB和一个客户端应用程序</h2></div><p id="2be3" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/overview/" rel="noopener ugc nofollow" target="_blank">Kubernetes</a>(也称为<strong class="la jg"> ACK </strong>)的AWS控制器是围绕<a class="ae lu" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#custom-resources" rel="noopener ugc nofollow" target="_blank">自定义资源和自定义资源定义</a>的Kubernetes扩展概念构建的。您可以使用<code class="fe ku kv kw kx b">ACK</code>直接从Kubernetes定义和使用AWS服务。这有助于您利用Kubernetes应用程序的托管AWS服务，而无需在集群之外定义资源。</p><p id="3cd9" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设您需要在部署到Kubernetes的应用程序中使用一个<a class="ae lu" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingBucket.html" rel="noopener ugc nofollow" target="_blank"> AWS S3桶</a>。而不是使用AWS控制台、AWS CLI、AWS CloudFormation等。，您可以在YAML清单文件中定义AWS <code class="fe ku kv kw kx b">S3</code>存储桶，并使用熟悉的工具如<code class="fe ku kv kw kx b">kubectl</code>部署它。最终目标是允许用户(软件工程师、开发工程师、操作员等。)使用相同的接口(本例中为Kubernetes API)来描述和管理AWS服务以及本地Kubernetes资源，如<code class="fe ku kv kw kx b">Deployment</code>、<code class="fe ku kv kw kx b">Service</code>等。</p><p id="b64c" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">以下是ACK文档中的图表，提供了一个高层次的概述:</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lv"><img src="../Images/b6755d4032826d002434df2b4cbddc91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0wl0IGjKigrwLsUW.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/images/ack-how-it-works.png" rel="noopener ugc nofollow" target="_blank">https://AWS-controllers-k8s . github . io/community/docs/community/images/ack-how-it-works . png</a></figcaption></figure><h1 id="da63" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">这篇博文涵盖了哪些内容？</h1><p id="e6df" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">ACK支持<a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/services/#amazon-dynamodb" rel="noopener ugc nofollow" target="_blank">很多AWS服务</a>，包括<a class="ae lu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html" rel="noopener ugc nofollow" target="_blank">亚马逊DynamoDB </a>。这篇博文涉及的话题之一是<em class="mx">如何在</em> <a class="ae lu" href="https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html" rel="noopener ugc nofollow" target="_blank"> <em class="mx">亚马逊EKS </em> </a> <em class="mx">上使用</em> <code class="fe ku kv kw kx b"><em class="mx">ACK</em></code> <em class="mx">来管理</em> <code class="fe ku kv kw kx b"><em class="mx">DynamoDB</em></code>。但是，仅仅创建一个<code class="fe ku kv kw kx b">DynamoDB</code>表并没有那么有趣！</p><p id="f5af" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">除此之外，您还将使用和部署一个客户端应用程序——这是一个URL shortener应用程序的精简版本，在<a class="ae lu" href="https://dev.to/aws/build-a-serverless-url-shortener-with-go-10i2" rel="noopener ugc nofollow" target="_blank">以前的博客文章</a>中有所介绍。虽然博客的前半部分将涉及帮助您理解机制和开始的手动步骤，但在后半部分，我们将切换到<code class="fe ku kv kw kx b">cdk8s</code>并使用Go代码实现相同的目标。</p><figure class="lw lx ly lz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/83e6992a6e3ac922afb0a2a337410f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWvV_J9MyTo3zQKNqRx0DQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">高层建筑</figcaption></figure><h2 id="3a7e" class="mz mb jf bd mc na nb dn mg nc nd dp mk lh ne nf mm ll ng nh mo lp ni nj mq nk bi translated">cdk8s？什么，为什么？因为，基础设施就是代码</h2><p id="b1e5" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">cdk8s(Kubernetes的云开发工具包)是一个开源框架(CNCF的一部分)，它允许你使用常规编程语言(而不是T4)来定义你的Kubernetes应用。我已经围绕cdk8s和Go 写了<a class="ae lu" href="https://betterprogramming.pub/kubernetes-infrastructure-as-code-for-go-developers-cdk8s-plus-in-action-ee3eb2203745" rel="noopener ugc nofollow" target="_blank">几篇博文，你可能会觉得有用。</a></p><p id="1951" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将继续走同一条路，即把<code class="fe ku kv kw kx b">yaml</code>推到后台，并使用<a class="ae lu" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank">Go编程语言</a>来定义核心基础设施(在本例中恰好是<code class="fe ku kv kw kx b">DynamoDB</code>，但也可能更多)以及应用组件(Kubernetes <code class="fe ku kv kw kx b">Deployment</code>、<code class="fe ku kv kw kx b">Service</code>等)。).</p><p id="0194" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是由于以下<code class="fe ku kv kw kx b">cdk8s</code>特性而成为可能:</p><ol class=""><li id="30bf" class="nl nm jf la b lb lc le lf lh nn ll no lp np lt nq nr ns nt bi translated"><code class="fe ku kv kw kx b">cdk8s</code>支持<a class="ae lu" href="https://dev.to/abhirockzz/write-your-kubernetes-infrastructure-as-go-code-using-custom-resource-definitions-with-cdk8s-1eei" rel="noopener ugc nofollow" target="_blank"> Kubernetes自定义资源定义</a>，让我们神奇地将CRD作为API导入。</li><li id="c287" class="nl nm jf la b lb nu le nv lh nw ll nx lp ny lt nq nr ns nt bi translated">cdk8s-plus库在我们的Go代码(或任何其他语言)中使用Kubernetes资源时，它有助于减少/消除大量样板代码</li></ol><p id="2112" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在开始学习之前，请确保您已经完成了完成本教程所需的先决条件。</p><blockquote class="nz oa ob"><p id="ca60" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><em class="jf">GitHub</em>上的 <a class="ae lu" href="https://github.com/abhirockzz/cdk8s-for-go-developers/tree/master/part5-dynamodb-eks-ack-cdk8s" rel="noopener ugc nofollow" target="_blank"> <em class="jf">是基础设施和应用程序的全部代码</em></a></p></blockquote></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="0880" class="ma mb jf bd mc md om mf mg mh on mj mk kl oo km mm ko op kp mo kr oq ks mq mr bi translated">先决条件</h1><p id="3c76" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">要一步一步地学习，除了一个AWS账户，你还需要安装<a class="ae lu" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>、<a class="ae lu" href="https://cdk8s.io/docs/latest/getting-started/#install-the-cli" rel="noopener ugc nofollow" target="_blank"> cdk8s CLI </a>、<a class="ae lu" href="https://kubernetes.io/docs/tasks/tools/#kubectl" rel="noopener ugc nofollow" target="_blank"> kubectl </a>、<a class="ae lu" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank"> helm </a>和<a class="ae lu" href="https://go.dev/dl/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>。</p><p id="f5d8" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有很多种方法可以创建一个亚马逊EKS集群。我更喜欢使用eks CTL CLI，因为它提供了方便！</p><p id="373f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，我们开始吧。我们需要做的第一件事是…</p><h1 id="ae3a" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">设置DynamoDB控制器</h1><blockquote class="nz oa ob"><p id="474a" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><em class="jf">以下大部分步骤改编自</em> <code class="fe ku kv kw kx b"><em class="jf">ACK</em></code> <em class="jf">文档- </em> <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/user-docs/install/" rel="noopener ugc nofollow" target="_blank"> <em class="jf">安装ACK控制器</em> </a></p></blockquote><p id="548c" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">使用</strong> <code class="fe ku kv kw kx b"><strong class="la jg">Helm</strong></code> <strong class="la jg"> : </strong>安装</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="d91c" class="mz mb jf kx b gy ov ow l ox oy">export SERVICE=dynamodb</span><span id="99c8" class="mz mb jf kx b gy oz ow l ox oy">#change/update this as required as per <a class="ae lu" href="https://api.github.com/repos/aws-controllers-k8s/dynamodb-controller/releases/latest" rel="noopener ugc nofollow" target="_blank">https://api.github.com/repos/aws-controllers-k8s/dynamodb-controller/releases/latest</a></span><span id="4f2b" class="mz mb jf kx b gy oz ow l ox oy">export RELEASE_VERSION=0.1.7</span><span id="1221" class="mz mb jf kx b gy oz ow l ox oy">export ACK_SYSTEM_NAMESPACE=ack-system<br/><br/># you can change the region if required<br/>export AWS_REGION=us-east-1<br/><br/>aws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws<br/><br/>helm install --create-namespace -n $ACK_SYSTEM_NAMESPACE ack-$SERVICE-controller \<br/>  oci://public.ecr.aws/aws-controllers-k8s/$SERVICE-chart --version=$RELEASE_VERSION --set=aws.region=$AWS_REGION</span></pre><p id="0b8b" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要确认，请运行:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="8955" class="mz mb jf kx b gy ov ow l ox oy">kubectl get crd</span><span id="207a" class="mz mb jf kx b gy oz ow l ox oy"># output (multiple CRDs)<br/>tables.dynamodb.services.k8s.aws<br/>fieldexports.services.k8s.aws<br/>globaltables.dynamodb.services.k8s.aws<br/># etc....</span></pre><p id="b343" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于<code class="fe ku kv kw kx b">DynamoDB</code>控制器必须与AWS服务交互(进行API调用)，我们需要为服务帐户(也称为<strong class="la jg"> IRSA </strong>)配置<a class="ae lu" href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html" rel="noopener ugc nofollow" target="_blank"> IAM角色。</a></p><blockquote class="nz oa ob"><p id="2ac9" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><em class="jf">详见</em> <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/user-docs/irsa/" rel="noopener ugc nofollow" target="_blank"> <em class="jf">配置IAM权限</em> </a> <em class="jf"/></p></blockquote><p id="2bb1" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg"> IRSA配置</strong></p><p id="91b8" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，为您的群集创建一个OIDC身份提供者。</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="b012" class="mz mb jf kx b gy ov ow l ox oy">export EKS_CLUSTER_NAME=&lt;name of your EKS cluster&gt;<br/>export AWS_REGION=&lt;cluster region&gt;<br/>eksctl utils associate-iam-oidc-provider --cluster $EKS_CLUSTER_NAME --region $AWS_REGION --approve</span></pre><p id="3ffe" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">目标是创建一个IAM角色并通过策略附加适当的权限。然后，我们可以创建一个<a class="ae lu" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务帐户</a>，并将IAM角色附加到它上面。因此，控制器<code class="fe ku kv kw kx b">Pod</code>将能够进行AWS API调用。请注意，我们通过<code class="fe ku kv kw kx b">arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess</code>策略向我们的控件提供所有<code class="fe ku kv kw kx b">DynamoDB</code>权限。</p><p id="bf16" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">多亏了<code class="fe ku kv kw kx b">eksctl</code>，这可以用一行代码完成！</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="dde5" class="mz mb jf kx b gy ov ow l ox oy">export SERVICE=dynamodb<br/>export ACK_K8S_SERVICE_ACCOUNT_NAME=ack-$SERVICE-controller</span><span id="0dc2" class="mz mb jf kx b gy oz ow l ox oy"># recommend using the same name<br/>export ACK_SYSTEM_NAMESPACE=ack-system<br/>export EKS_CLUSTER_NAME=&lt;enter EKS cluster name&gt;<br/>export POLICY_ARN=arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess</span><span id="a6ff" class="mz mb jf kx b gy oz ow l ox oy"># IAM role has a format - do not change it. you can't use any arbitrary name<br/>export IAM_ROLE_NAME=ack-$SERVICE-controller-role</span><span id="f4a1" class="mz mb jf kx b gy oz ow l ox oy">eksctl create iamserviceaccount \<br/>    --name $ACK_K8S_SERVICE_ACCOUNT_NAME \<br/>    --namespace $ACK_SYSTEM_NAMESPACE \<br/>    --cluster $EKS_CLUSTER_NAME \<br/>    --role-name $IAM_ROLE_NAME \<br/>    --attach-policy-arn $POLICY_ARN \<br/>    --approve \<br/>    --override-existing-serviceaccounts</span></pre><blockquote class="nz oa ob"><p id="2f4b" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><em class="jf">策略是根据</em><a class="ae lu" href="https://github.com/aws-controllers-k8s/dynamodb-controller/blob/main/config/iam/recommended-policy-arn" rel="noopener ugc nofollow" target="_blank"><em class="jf">https://github . com/AWS-controllers-k8s/dynamo db-controller/blob/main/config/iam/recommended-policy-arn</em></a></p></blockquote><p id="e1f2" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要进行确认，您可以检查IAM角色是否已创建，并检查Kubernetes服务帐户</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="ec76" class="mz mb jf kx b gy ov ow l ox oy">aws iam get-role --role-name=$IAM_ROLE_NAME --query Role.Arn --output text</span><span id="5c63" class="mz mb jf kx b gy oz ow l ox oy">kubectl describe serviceaccount/$ACK_K8S_SERVICE_ACCOUNT_NAME -n $ACK_SYSTEM_NAMESPACE</span><span id="2515" class="mz mb jf kx b gy oz ow l ox oy"># you will see similar output</span><span id="e4d1" class="mz mb jf kx b gy oz ow l ox oy">Name:                ack-dynamodb-controller<br/>Namespace:           ack-system<br/>Labels:              app.kubernetes.io/instance=ack-dynamodb-controller<br/>                     app.kubernetes.io/managed-by=eksctl<br/>                     app.kubernetes.io/name=dynamodb-chart<br/>                     app.kubernetes.io/version=v0.1.3<br/>                     helm.sh/chart=dynamodb-chart-v0.1.3<br/>                     k8s-app=dynamodb-chart<br/>Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::&lt;your AWS account ID&gt;:role/ack-dynamodb-controller-role<br/>                     meta.helm.sh/release-name: ack-dynamodb-controller<br/>                     meta.helm.sh/release-namespace: ack-system<br/>Image pull secrets:  &lt;none&gt;<br/>Mountable secrets:   ack-dynamodb-controller-token-bbzxv<br/>Tokens:              ack-dynamodb-controller-token-bbzxv<br/>Events:              &lt;none&gt;</span></pre><p id="ecf0" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了使<code class="fe ku kv kw kx b">IRSA</code>生效，您需要重新启动ACK <code class="fe ku kv kw kx b">Deployment</code>:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="f302" class="mz mb jf kx b gy ov ow l ox oy"># Note the deployment name for ACK service controller from following command<br/>kubectl get deployments -n $ACK_SYSTEM_NAMESPACE</span><span id="a838" class="mz mb jf kx b gy oz ow l ox oy">kubectl -n $ACK_SYSTEM_NAMESPACE rollout restart deployment ack-dynamodb-controller-dynamodb-chart</span></pre><p id="c22d" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">确认<code class="fe ku kv kw kx b">Deployment</code>已重启(当前为<code class="fe ku kv kw kx b">Running</code>)且<code class="fe ku kv kw kx b">IRSA</code>已正确配置:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="9472" class="mz mb jf kx b gy ov ow l ox oy">kubectl get pods -n $ACK_SYSTEM_NAMESPACE</span><span id="ef24" class="mz mb jf kx b gy oz ow l ox oy">kubectl describe pod -n $ACK_SYSTEM_NAMESPACE ack-dynamodb-controller-dynamodb-chart-7dc99456c6-6shrm | grep "^\s*AWS_"<br/># The output should contain following two lines:</span><span id="3747" class="mz mb jf kx b gy oz ow l ox oy">AWS_ROLE_ARN=arn:aws:iam::&lt;AWS_ACCOUNT_ID&gt;:role/&lt;IAM_ROLE_NAME&gt;<br/>AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token</span></pre><p id="a272" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在我们已经完成了配置…</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="4417" class="ma mb jf bd mc md om mf mg mh on mj mk kl oo km mm ko op kp mo kr oq ks mq mr bi translated">我们可以开始有趣的部分了！</h1><p id="9d73" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated"><strong class="la jg">首先创建DynamoDB表</strong></p><p id="8624" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">清单看起来是这样的:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="13c9" class="mz mb jf kx b gy ov ow l ox oy">apiVersion: dynamodb.services.k8s.aws/v1alpha1<br/>kind: Table<br/>metadata:<br/>  name: dynamodb-urls-ack<br/>spec:<br/>  tableName: urls<br/>  attributeDefinitions:<br/>    - attributeName: shortcode<br/>      attributeType: S<br/>  billingMode: PAY_PER_REQUEST<br/>  keySchema:<br/>    - attributeName: email<br/>      keyType: HASH</span></pre><p id="92b3" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">克隆项目，转到正确的目录并应用清单:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="7945" class="mz mb jf kx b gy ov ow l ox oy">git clone https://github.com/abhirockzz/dynamodb-ack-cdk8s<br/>cd dynamodb-ack-cdk8s</span><span id="a470" class="mz mb jf kx b gy oz ow l ox oy"># create table<br/>kubectl apply -f manual/dynamodb-ack.yaml</span></pre><p id="43b0" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以在AWS控制台中检查DynamoDB表，或者使用AWS CLI ( <code class="fe ku kv kw kx b">aws dynamodb list-tables</code>)进行确认。我们的表已经准备好了，现在我们可以部署我们的URL shortener应用程序了。</p><p id="f8d1" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">但是，在此之前，我们需要创建一个Docker映像，并将其推送到亚马逊弹性容器注册中心的私有存储库中。</p><p id="ed8e" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">在亚马逊ECR中创建私有存储库</strong></p><p id="6161" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">登录到ECR:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="716d" class="mz mb jf kx b gy ov ow l ox oy">aws ecr get-login-password --region &lt;enter region&gt; | docker login --username AWS --password-stdin &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com</span></pre><p id="ecc8" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">创建存储库:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="e7c6" class="mz mb jf kx b gy ov ow l ox oy">aws ecr create-repository \<br/>    --repository-name dynamodb-app \<br/>    --region &lt;enter AWS region&gt;</span></pre><p id="a40d" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">构建映像并推送到ECR </strong></p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="4822" class="mz mb jf kx b gy ov ow l ox oy"># if you're on Mac M1<br/>#export DOCKER_DEFAULT_PLATFORM=linux/amd64<br/>docker build -t dynamodb-app .</span><span id="c54d" class="mz mb jf kx b gy oz ow l ox oy">docker tag dynamodb-app:latest &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com/dynamodb-app:latest</span><span id="7318" class="mz mb jf kx b gy oz ow l ox oy">docker push &lt;enter aws_account_id&gt;.dkr.ecr.&lt;enter region&gt;.amazonaws.com/dynamodb-app:latest</span></pre><p id="79b6" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">就像控制器一样，我们的应用程序也需要<code class="fe ku kv kw kx b">IRSA</code>来执行<code class="fe ku kv kw kx b">GetItem</code>和<code class="fe ku kv kw kx b">PutItem</code> API对<code class="fe ku kv kw kx b">DynamoDB</code>的调用。</p><p id="fcac" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">让我们为应用程序创建另一个IRSA</strong></p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="f4f2" class="mz mb jf kx b gy ov ow l ox oy"># you can change the policy name. make sure yo use the same name in subsequent commands<br/>aws iam create-policy --policy-name dynamodb-irsa-policy --policy-document file://manual/policy.json</span><span id="6d30" class="mz mb jf kx b gy oz ow l ox oy">eksctl create iamserviceaccount --name eks-dynamodb-app-sa --namespace default --cluster &lt;enter EKS cluster name&gt; --attach-policy-arn arn:aws:iam::&lt;enter AWS account ID&gt;:policy/dynamodb-irsa-policy --approve</span><span id="8bf0" class="mz mb jf kx b gy oz ow l ox oy">kubectl describe serviceaccount/eks-dynamodb-app-sa</span><span id="a1b1" class="mz mb jf kx b gy oz ow l ox oy"># output</span><span id="9013" class="mz mb jf kx b gy oz ow l ox oy">Name:                eks-dynamodb-app-sa<br/>Namespace:           default<br/>Labels:              app.kubernetes.io/managed-by=eksctl<br/>Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::&lt;AWS account ID&gt;:role/eksctl-eks-cluster-addon-iamserviceaccount-d-Role1-2KTGZO1GJRN<br/>Image pull secrets:  &lt;none&gt;<br/>Mountable secrets:   eks-dynamodb-app-sa-token-5fcvf<br/>Tokens:              eks-dynamodb-app-sa-token-5fcvf<br/>Events:              &lt;none&gt;</span></pre><p id="307c" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我们可以部署我们的应用程序了！</p><p id="777d" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在<code class="fe ku kv kw kx b">manual/app.yaml</code>文件中，确保根据您的环境替换以下属性:</p><ul class=""><li id="ee54" class="nl nm jf la b lb lc le lf lh nn ll no lp np lt pa nr ns nt bi translated">服务帐户名称—上面的例子使用了<code class="fe ku kv kw kx b">eks-dynamodb-app-sa</code></li><li id="4adf" class="nl nm jf la b lb nu le nv lh nw ll nx lp ny lt pa nr ns nt bi translated">Docker图像</li><li id="7039" class="nl nm jf la b lb nu le nv lh nw ll nx lp ny lt pa nr ns nt bi translated">AWS区域的容器环境变量(例如<code class="fe ku kv kw kx b">us-east-1</code>)和表名(这将是<code class="fe ku kv kw kx b">urls</code>，因为这是我们使用的名称)</li></ul><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="11af" class="mz mb jf kx b gy ov ow l ox oy">kubectl apply -f app.yaml</span><span id="35a6" class="mz mb jf kx b gy oz ow l ox oy"># output<br/>deployment.apps/dynamodb-app configured<br/>service/dynamodb-app-service created</span></pre><p id="2fbe" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这将创建一个<code class="fe ku kv kw kx b">Deployment</code>和<code class="fe ku kv kw kx b">Service</code>来访问应用程序。</p><blockquote class="nz oa ob"><p id="a453" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><em class="jf">由于服务类型是</em> <code class="fe ku kv kw kx b"><em class="jf">LoadBalancer</em></code> <em class="jf">，将提供适当的</em> <a class="ae lu" href="https://docs.aws.amazon.com/eks/latest/userguide/network-load-balancing.html" rel="noopener ugc nofollow" target="_blank"> <em class="jf"> AWS负载平衡器</em> </a> <em class="jf">以允许外部访问。</em></p></blockquote><p id="88df" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">检查<code class="fe ku kv kw kx b">Pod</code>和<code class="fe ku kv kw kx b">Service</code>:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="cfa9" class="mz mb jf kx b gy ov ow l ox oy">kubectl get pods<br/>kubectl get service/dynamodb-app-service</span><span id="aa5f" class="mz mb jf kx b gy oz ow l ox oy"># to get the load balancer IP<br/>APP_URL=$(kubectl get service/dynamodb-app-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")<br/>echo $APP_URL</span><span id="72b8" class="mz mb jf kx b gy oz ow l ox oy"># output example<br/>a0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com</span></pre><p id="812e" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您已经部署了应用程序，并且知道可以公开访问它的端点。</p><p id="e654" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可以尝试网址缩写服务</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="a1c6" class="mz mb jf kx b gy ov ow l ox oy">curl -i -X POST -d 'https://abhirockzz.github.io/' $APP_URL:9090/</span><span id="a204" class="mz mb jf kx b gy oz ow l ox oy"># output<br/>HTTP/1.1 200 OK<br/>Date: Thu, 21 Jul 2022 11:03:40 GMT<br/>Content-Length: 25<br/>Content-Type: text/plain; charset=utf-8</span><span id="a843" class="mz mb jf kx b gy oz ow l ox oy">{"ShortCode":"ae1e31a6"}</span></pre><blockquote class="nz oa ob"><p id="69c8" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><em class="jf">如果在访问LB URL时出现</em> <code class="fe ku kv kw kx b"><em class="jf">Could not resolve host</em></code> <em class="jf">错误，请等待一分钟左右，然后重试</em></p></blockquote><p id="0d2f" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您应该会收到一个带有简短代码的JSON响应。在您的浏览器中输入以下内容<code class="fe ku kv kw kx b">http://&lt;enter APP_URL&gt;:9090/&lt;shortcode&gt;</code>，例如<code class="fe ku kv kw kx b">http://a0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com:9090/ae1e31a6</code> -您将被重定向至原始URL。</p><p id="1caf" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您也可以使用<code class="fe ku kv kw kx b">curl</code>:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="361a" class="mz mb jf kx b gy ov ow l ox oy"># example<br/>curl -i http://a0042d5b5b0ad40abba9c6c42e6342a2-879424587.us-east-1.elb.amazonaws.com:9090/ae1e31a6</span><span id="ecb3" class="mz mb jf kx b gy oz ow l ox oy"># output<br/>HTTP/1.1 302 Found<br/>Location: https://abhirockzz.github.io/<br/>Date: Thu, 21 Jul 2022 11:07:58 GMT<br/>Content-Length: 0</span></pre><p id="f035" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我想YAML够了！正如我之前承诺的，后半部分将演示如何使用<code class="fe ku kv kw kx b">cdk8s</code>和Go实现同样的功能。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="d825" class="ma mb jf bd mc md om mf mg mh on mj mk kl oo km mm ko op kp mo kr oq ks mq mr bi translated">Kubernetes基础设施作为带有cdk8s的Go代码</h1><p id="f16d" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">假设您已经克隆了项目(按照上面的说明)，切换到不同的目录:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="80fa" class="mz mb jf kx b gy ov ow l ox oy">cd dynamodb-cdk8s</span></pre><p id="3b2e" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是一个预先创建的<code class="fe ku kv kw kx b">cdk8s</code>项目，您可以使用。整个逻辑存在于<a class="ae lu" href="https://github.com/abhirockzz/dynamodb-ack-cdk8s/blob/master/dynamodb-cdk8s/main.go" rel="noopener ugc nofollow" target="_blank"> main.go文件</a>中。我们将首先试用它，并确认它的工作方式相同。之后，我们将深入代码的本质。</p><p id="1ef7" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">删除之前创建的<code class="fe ku kv kw kx b">DynamoDB</code>表以及<code class="fe ku kv kw kx b">Deployment</code>(和<code class="fe ku kv kw kx b">Service</code>):</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="c33c" class="mz mb jf kx b gy ov ow l ox oy"># you can also delete the table directly from AWS console<br/>aws dynamodb delete-table --table-name urls</span><span id="0ec7" class="mz mb jf kx b gy oz ow l ox oy"># this will delete Deployment and Service (as well as AWS Load Balancer)<br/>kubectl delete -f manual/app.yaml</span></pre><p id="59ca" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<code class="fe ku kv kw kx b">cdk8s synth</code>为DynamoDB表和应用程序生成清单。然后我们可以使用<code class="fe ku kv kw kx b">kubectl</code>来应用它</p><blockquote class="nz oa ob"><p id="d497" class="ky kz mx la b lb lc kg ld le lf kj lg oc li lj lk od lm ln lo oe lq lr ls lt ij bi translated"><strong class="la jg"> <em class="jf">看出区别了吗？</em> </strong> <em class="jf">前面，我们定义了</em> <code class="fe ku kv kw kx b"><em class="jf">DynamoDB</em></code> <em class="jf">表、</em> <code class="fe ku kv kw kx b"><em class="jf">Deployment</em></code> <em class="jf">(以及</em> <code class="fe ku kv kw kx b"><em class="jf">Service</em></code> <em class="jf">)手工清单。</em><code class="fe ku kv kw kx b"><em class="jf">cdk8s</em></code><em class="jf"/>不是<em class="jf">完全移除了YAML，但是它为我们提供了一种利用常规编程语言(在本例中为</em> <code class="fe ku kv kw kx b"><em class="jf">Go</em></code> <em class="jf">)来定义我们的解决方案的组件的方式。</em></p></blockquote><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="a2cd" class="mz mb jf kx b gy ov ow l ox oy">export TABLE_NAME=urls<br/>export SERVICE_ACCOUNT=eks-dynamodb-app-sa<br/>export DOCKER_IMAGE=&lt;enter ECR repo that you created earlier&gt;</span><span id="92d1" class="mz mb jf kx b gy oz ow l ox oy">cdk8s synth</span><span id="3290" class="mz mb jf kx b gy oz ow l ox oy">ls -lrt dist/</span><span id="89fa" class="mz mb jf kx b gy oz ow l ox oy">#output<br/>0000-dynamodb.k8s.yaml<br/>0001-deployment.k8s.yaml</span></pre><p id="7550" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你会看到<em class="mx">两个</em>不同的清单由<code class="fe ku kv kw kx b">cdk8s</code>生成，因为我们在代码中定义了两个独立的<code class="fe ku kv kw kx b">cdk8s.Chart</code>——稍后会有更多的介绍。</p><p id="52e4" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以逐个部署它们:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="7aee" class="mz mb jf kx b gy ov ow l ox oy">kubectl apply -f dist/0000-dynamodb.k8s.yaml</span><span id="e9f0" class="mz mb jf kx b gy oz ow l ox oy">#output<br/>table.dynamodb.services.k8s.aws/dynamodb-dynamodb-ack-cdk8s-table-c88d874d created<br/>configmap/export-dynamodb-urls-info created<br/>fieldexport.services.k8s.aws/export-dynamodb-tablename created<br/>fieldexport.services.k8s.aws/export-dynamodb-region created</span></pre><p id="ac21" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">和往常一样，您可以在控制台或AWS CLI - <code class="fe ku kv kw kx b">aws dynamodb describe-table --table-name urls</code>中检查<code class="fe ku kv kw kx b">DynamoDB</code>表。查看输出，<code class="fe ku kv kw kx b">DynamoDB</code>表格部分似乎很熟悉...</p><h2 id="3ee2" class="mz mb jf bd mc na nb dn mg nc nd dp mk lh ne nf mm ll ng nh mo lp ni nj mq nk bi translated">但是什么是<code class="fe ku kv kw kx b">fieldexport.services.k8s.aws</code>？？</h2><p id="77c3" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">…我们为什么需要一个<code class="fe ku kv kw kx b">ConfigMap</code>？我会在这里给你要点。</p><p id="31f5" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在前一次迭代中，我们在<code class="fe ku kv kw kx b">manual/app.yaml</code>中硬编码了表名和区域。虽然这适用于这个示例应用程序，但它是不可伸缩的，甚至可能不适用于一些元数据(如名称等)的资源。)是随机生成的。这就是为什么有了这个概念，即“T1”可以“从ACK资源中导出任何规范或状态字段到Kubernetes  <code class="fe ku kv kw kx b"><em class="mx">ConfigMap</em></code> <em class="mx">或</em><code class="fe ku kv kw kx b"><em class="mx">Secret</em></code><em class="mx"/></p><p id="5543" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以阅读<a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/user-docs/field-export/" rel="noopener ugc nofollow" target="_blank"> ACK文档</a>中的详细信息以及一些示例。您将在这里看到如何定义一个<code class="fe ku kv kw kx b">FieldExport</code>和<code class="fe ku kv kw kx b">ConfigMap</code>以及<code class="fe ku kv kw kx b">Deployment</code>，后者需要被配置为接受来自<code class="fe ku kv kw kx b">ConfigMap</code>的环境变量——所有这些都在代码中使用Go实现(在代码遍历中会有更多相关内容)。</p><p id="efe6" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">检查<code class="fe ku kv kw kx b">FieldExport</code>和<code class="fe ku kv kw kx b">ConfigMap</code>:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="0bf5" class="mz mb jf kx b gy ov ow l ox oy">kubectl get fieldexport</span><span id="e129" class="mz mb jf kx b gy oz ow l ox oy">#output<br/>NAME                        AGE<br/>export-dynamodb-region      19s<br/>export-dynamodb-tablename   19s</span><span id="fb8e" class="mz mb jf kx b gy oz ow l ox oy">kubectl get configmap/export-dynamodb-urls-info -o yaml</span></pre><p id="5dee" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们从一个空白的<code class="fe ku kv kw kx b">ConfigMap</code>开始(按照<code class="fe ku kv kw kx b">cdk8s</code>逻辑)，但是<code class="fe ku kv kw kx b">ACK</code>神奇地用来自<code class="fe ku kv kw kx b">Table</code>定制资源的属性填充了它。</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="d4bd" class="mz mb jf kx b gy ov ow l ox oy">apiVersion: v1<br/>data:<br/>  default.export-dynamodb-region: us-east-1<br/>  default.export-dynamodb-tablename: urls<br/>immutable: false<br/>kind: ConfigMap<br/>#....omitted</span></pre><p id="7ac6" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在可以使用第二份清单了——这并不奇怪。就像之前的迭代一样，它包含的只是应用程序<code class="fe ku kv kw kx b">Deployment</code>和<code class="fe ku kv kw kx b">Service</code>。检查<code class="fe ku kv kw kx b">Pod</code>和<code class="fe ku kv kw kx b">Service</code>:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="346e" class="mz mb jf kx b gy ov ow l ox oy">kubectl apply -f dist/0001-deployment.k8s.yaml</span><span id="b36e" class="mz mb jf kx b gy oz ow l ox oy">#output<br/>deployment.apps/dynamodb-app created<br/>service/dynamodb-app-service configured</span><span id="f7dd" class="mz mb jf kx b gy oz ow l ox oy">kubectl get pods<br/>kubectl get svc</span></pre><p id="e8ac" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">整个设置已经准备好了，就像之前一样，您可以用同样的方式进行测试。这里就不重复步骤了。相反，我会去做一些更有趣的事情。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="eb5f" class="ma mb jf bd mc md om mf mg mh on mj mk kl oo km mm ko op kp mo kr oq ks mq mr bi translated">cdk8s代码演练</h1><p id="a44d" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">逻辑分为两部分。为了简洁起见，我将只关注代码的关键部分，其余部分将被忽略。</p><p id="cfcd" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg"> DynamoDB和配置</strong></p><p id="6b29" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们首先定义<code class="fe ku kv kw kx b">DynamoDB</code>表(命名为<code class="fe ku kv kw kx b">urls</code>)以及<code class="fe ku kv kw kx b">ConfigMap</code>(注意，此时<em class="mx">没有</em>任何数据):</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="024e" class="mz mb jf kx b gy ov ow l ox oy">func NewDynamoDBChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {<br/>    //...<br/>    table := ddbcrd.NewTable(chart, jsii.String("dynamodb-ack-cdk8s-table"), &amp;ddbcrd.TableProps{<br/>        Spec: &amp;ddbcrd.TableSpec{<br/>            AttributeDefinitions: &amp;[]*ddbcrd.TableSpecAttributeDefinitions{<br/>                {AttributeName: jsii.String(primaryKeyName), AttributeType: jsii.String("S")}},<br/>            BillingMode: jsii.String(billingMode),<br/>            TableName:   jsii.String(tableName),<br/>            KeySchema: &amp;[]*ddbcrd.TableSpecKeySchema{<br/>                {AttributeName: jsii.String(primaryKeyName),<br/>                    KeyType: jsii.String(hashKeyType)}}}})</span><span id="3df6" class="mz mb jf kx b gy oz ow l ox oy">  //...<br/>  cfgMap = cdk8splus22.NewConfigMap(chart, jsii.String("config-map"),<br/>        &amp;cdk8splus22.ConfigMapProps{<br/>            Metadata: &amp;cdk8s.ApiObjectMetadata{<br/>                Name: jsii.String(configMapName)}})</span></pre><p id="e2f4" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后我们移动到<code class="fe ku kv kw kx b">FieldExport</code>s——AWS区域和表名各一个。一旦这些被创建，根据<code class="fe ku kv kw kx b">FieldExport</code>中的<code class="fe ku kv kw kx b">from</code>和<code class="fe ku kv kw kx b">to</code>配置，<code class="fe ku kv kw kx b">ConfigMap</code>将被填充所需的数据。</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="1d76" class="mz mb jf kx b gy ov ow l ox oy">//...<br/>    fieldExportForTable = servicesk8saws.NewFieldExport(chart, jsii.String("fexp-table"), &amp;servicesk8saws.FieldExportProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(fieldExportNameForTable)},<br/>        Spec: &amp;servicesk8saws.FieldExportSpec{<br/>            From: &amp;servicesk8saws.FieldExportSpecFrom{Path: jsii.String(".spec.tableName"),<br/>                Resource: &amp;servicesk8saws.FieldExportSpecFromResource{<br/>                    Group: jsii.String("dynamodb.services.k8s.aws"),<br/>                    Kind:  jsii.String("Table"),<br/>                    Name:  table.Name()}},<br/>            To: &amp;servicesk8saws.FieldExportSpecTo{<br/>                Name: cfgMap.Name(),<br/>                Kind: servicesk8saws.FieldExportSpecToKind_CONFIGMAP}}})</span><span id="389b" class="mz mb jf kx b gy oz ow l ox oy">    fieldExportForRegion = servicesk8saws.NewFieldExport(chart, jsii.String("fexp-region"), &amp;servicesk8saws.FieldExportProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{Name: jsii.String(fieldExportNameForRegion)},<br/>        Spec: &amp;servicesk8saws.FieldExportSpec{<br/>            From: &amp;servicesk8saws.FieldExportSpecFrom{<br/>                Path: jsii.String(".status.ackResourceMetadata.region"),<br/>                Resource: &amp;servicesk8saws.FieldExportSpecFromResource{<br/>                    Group: jsii.String("dynamodb.services.k8s.aws"),<br/>                    Kind:  jsii.String("Table"),<br/>                    Name:  table.Name()}},<br/>            To: &amp;servicesk8saws.FieldExportSpecTo{<br/>                Name: cfgMap.Name(),<br/>                Kind: servicesk8saws.FieldExportSpecToKind_CONFIGMAP}}})<br/>//...</span></pre><p id="9b52" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la jg">应用图表</strong></p><p id="3127" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们应用的核心是<code class="fe ku kv kw kx b">Deployment</code>本身:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="afa2" class="mz mb jf kx b gy ov ow l ox oy">func NewDeploymentChart(scope constructs.Construct, id string, props *MyChartProps) cdk8s.Chart {<br/>  //...<br/>  dep := cdk8splus22.NewDeployment(chart, jsii.String("dynamodb-app-deployment"), &amp;cdk8splus22.DeploymentProps{<br/>        Metadata: &amp;cdk8s.ApiObjectMetadata{<br/>            Name: jsii.String("dynamodb-app")},<br/>        ServiceAccount: cdk8splus22.ServiceAccount_FromServiceAccountName(<br/>            chart,<br/>            jsii.String("aws-irsa"),<br/>            jsii.String(serviceAccountName))})</span></pre><p id="4220" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下一个重要的部分是容器及其配置。我们指定了ECR图像存储库和环境变量——它们引用了我们在前面的图表中定义的<code class="fe ku kv kw kx b">ConfigMap</code>(一切都是相互关联的！):</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="a901" class="mz mb jf kx b gy ov ow l ox oy">//...<br/>container := dep.AddContainer(<br/>        &amp;cdk8splus22.ContainerProps{<br/>            Name:  jsii.String("dynamodb-app-container"),<br/>            Image: jsii.String(image),<br/>            Port:  jsii.Number(appPort)})</span><span id="0a4d" class="mz mb jf kx b gy oz ow l ox oy">    container.Env().AddVariable(jsii.String("TABLE_NAME"), cdk8splus22.EnvValue_FromConfigMap(<br/>        cfgMap, jsii.String("default."+*fieldExportForTable.Name()),<br/>        &amp;cdk8splus22.EnvValueFromConfigMapOptions{Optional: jsii.Bool(false)}))</span><span id="61da" class="mz mb jf kx b gy oz ow l ox oy">    container.Env().AddVariable(jsii.String("AWS_REGION"), cdk8splus22.EnvValue_FromConfigMap(<br/>        cfgMap, jsii.String("default."+*fieldExportForRegion.Name()),<br/>        &amp;cdk8splus22.EnvValueFromConfigMapOptions{Optional: jsii.Bool(false)}))</span></pre><p id="daf4" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我们定义了支持外部应用程序访问的<code class="fe ku kv kw kx b">Service</code>(类型<code class="fe ku kv kw kx b">LoadBalancer</code>)，并在<code class="fe ku kv kw kx b">main</code>函数中将它们联系在一起:</p><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="04c8" class="mz mb jf kx b gy ov ow l ox oy">//...<br/>    dep.ExposeViaService(<br/>        &amp;cdk8splus22.DeploymentExposeViaServiceOptions{<br/>            Name:        jsii.String("dynamodb-app-service"),<br/>            ServiceType: cdk8splus22.ServiceType_LOAD_BALANCER,<br/>            Ports: &amp;[]*cdk8splus22.ServicePort{<br/>                {Protocol: cdk8splus22.Protocol_TCP,<br/>                    Port:       jsii.Number(lbPort),<br/>                    TargetPort: jsii.Number(appPort)}}})<br/>//...</span><span id="cbdf" class="mz mb jf kx b gy oz ow l ox oy">func main() {<br/>    app := cdk8s.NewApp(nil)</span><span id="8f3e" class="mz mb jf kx b gy oz ow l ox oy">    dynamodDB := NewDynamoDBChart(app, "dynamodb", nil)<br/>    deployment := NewDeploymentChart(app, "deployment", nil)</span><span id="c580" class="mz mb jf kx b gy oz ow l ox oy">    deployment.AddDependency(dynamodDB)</span><span id="2f7a" class="mz mb jf kx b gy oz ow l ox oy">    app.Synth()<br/>}</span></pre><p id="a1a6" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就是我在这个博客里给你的全部！</p><h1 id="1260" class="ma mb jf bd mc md me mf mg mh mi mj mk kl ml km mm ko mn kp mo kr mp ks mq mr bi translated">不要忘记删除资源..</h1><pre class="lw lx ly lz gt or kx os ot aw ou bi"><span id="5c5a" class="mz mb jf kx b gy ov ow l ox oy"># delete DynamoDB table, Deployment, Service etc.<br/>kubectl delete -f dist/</span><span id="d68c" class="mz mb jf kx b gy oz ow l ox oy"># to uninstall the ACK controller<br/>export SERVICE=dynamodb<br/>helm uninstall -n $ACK_SYSTEM_NAMESPACE ack-$SERVICE-controller</span><span id="8a05" class="mz mb jf kx b gy oz ow l ox oy"># delete the EKS cluster. if created via eksctl:<br/>eksctl delete cluster --name &lt;enter name of eks cluster&gt;</span></pre></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="f5de" class="ma mb jf bd mc md om mf mg mh on mj mk kl oo km mm ko op kp mo kr oq ks mq mr bi translated">包裹..</h1><p id="24c9" class="pw-post-body-paragraph ky kz jf la b lb ms kg ld le mt kj lg lh mu lj lk ll mv ln lo lp mw lr ls lt ij bi translated">用于Kubernetes的AWS控制器允许您从单个控制平面管理传统的Kubernetes资源和AWS服务，从而有助于弥合二者之间的差距。在这篇博客中，您看到了如何在<code class="fe ku kv kw kx b">DynamoDB</code>和一个URL shortener应用程序(部署到Kubernetes)的上下文中实现这一点。我鼓励你尝试ACK支持的其他AWS服务- <a class="ae lu" href="https://aws-controllers-k8s.github.io/community/docs/community/services/" rel="noopener ugc nofollow" target="_blank">这里有一个完整的列表</a>。</p><p id="3050" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果只是想使用<code class="fe ku kv kw kx b">cdk8s</code>，这里介绍的方法将会工作得很好。然而，根据您的要求，还有另一种方法可以做到这一点，那就是将<a class="ae lu" href="https://docs.aws.amazon.com/cdk/v2/guide/home.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>引入到画面中。我想在这里暂停一下，因为这是我可能会在未来的博客文章中涉及的内容。</p><p id="794c" class="pw-post-body-paragraph ky kz jf la b lb lc kg ld le lf kj lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在那之前，快乐大厦！</p></div></div>    
</body>
</html>