<html>
<head>
<title>MySQL Docker Container For Integration Testing Using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go进行集成测试的MySQL Docker容器</h1>
<blockquote>原文：<a href="https://itnext.io/mysql-docker-container-for-integration-testing-using-go-f784b70a03b?source=collection_archive---------1-----------------------#2018-12-27">https://itnext.io/mysql-docker-container-for-integration-testing-using-go-f784b70a03b?source=collection_archive---------1-----------------------#2018-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/04d6516c3cc5c2079183f7e1782742cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J_YyC-lAiGTG53Ir"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@erwanhesry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erwan Hesry </a>拍摄的照片</figcaption></figure><p id="7491" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在生产中，bug是最昂贵的。在开发过程中使用测试用例来捕捉它们是我们能做的降低成本的最好的事情之一。测试在所有软件中都非常重要。这有助于确保我们代码的正确性，并有助于减少回归。单元测试有助于在没有任何外部依赖性的情况下独立测试组件。单元测试不足以确保我们有一个稳定的、经过良好测试的系统。事实上，失败发生在不同组件的集成过程中。当我们从未在真实数据库上运行测试时，具有数据库后端的应用程序会面临这个问题，我们可能永远不会注意到由于事务未提交、数据库版本错误等问题而导致的事情无法工作。集成测试在端到端测试中扮演着重要的角色。</p><p id="52f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在当今世界，我们用数据库作为存储后端编写了许多软件应用程序。模仿这些数据库调用进行单元测试可能很麻烦。在模式中做一些小的改变会导致重写一些或者所有的模拟。由于查询不进入实际的数据库引擎，所以没有查询语法或约束的验证。需要模拟每个查询会导致重复工作。为了避免这种情况，我们应该使用一个真实的数据库进行测试，这个数据库在测试完成后会被销毁。<a class="ae kc" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Docker </strong> </a>非常适合运行测试用例，因为我们可以在几秒钟内旋转容器，并在完成后杀死它们。</p><p id="c11a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们了解如何启动MySQL docker容器，并使用go代码对其进行测试。我们首先需要确保运行我们的测试用例的系统安装了docker，这可以通过运行命令"<strong class="kf ir"> docker ps </strong>"来检查。如果没有安装docker，从这里的<a class="ae kc" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank">安装docker</a>。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b36f" class="lk ll iq lg b gy lm ln l lo lp">func (d *Docker) isInstalled() bool {<br/>  command := exec.Command("docker", "ps")<br/>  err := command.Run()<br/>  if err != nil {<br/>    return false<br/>  }<br/>  return true<br/>}</span></pre><p id="87b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦docker安装完毕，我们需要用一个用户名和密码来运行MySQL容器，这个用户名和密码可以用来连接MySQL服务器。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="774e" class="lk ll iq lg b gy lm ln l lo lp">docker run --name our-mysql-container -e MYSQL_ROOT_PASSWORD=root -e MYSQL_USER=gouser -e MYSQL_PASSWORD=gopassword -e MYSQL_DATABASE=godb -p 3306:3306 --tmpfs /var/lib/mysql mysql:5.7</span></pre><p id="c46b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这运行了一个MySQL 5.7版本的docker映像，容器名为“our-mysql-container”。“-e”指定了我们需要为MySQL docker容器设置的运行时变量。我们将root设置为我们的root密码。创建一个密码为“gopassword”的用户“gouser ”,我们用它从我们的应用程序连接到MySQL服务器。我们公开了docker容器的3306端口，这样我们就可以连接到Docker容器内部运行的mysql服务器。我们使用的是<a class="ae kc" href="https://docs.docker.com/v17.09/engine/admin/volumes/tmpfs/" rel="noopener ugc nofollow" target="_blank"> tmpfs挂载</a>，它只在主机的内存中存储数据。当容器停止时，tmpfs装载将被删除。因为我们正在运行它的测试目的，所以没有必要在永久存储数据。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b399" class="lk ll iq lg b gy lm ln l lo lp">type ContainerOption struct {<br/>  Name              string<br/>  ContainerFileName string<br/>  Options           map[string]string<br/>  MountVolumePath   string<br/>  PortExpose        string<br/>}</span><span id="8e1d" class="lk ll iq lg b gy lq ln l lo lp">func (d *Docker) getDockerRunOptions(c ContainerOption) []string {<br/>  portExpose := fmt.Sprintf("%s:%s", c.PortExpose, c.PortExpose)<br/>  var args []string<br/>  for key, value := range c.Options {<br/>    args = append(args, []string{"-e", fmt.Sprintf("%s=%s", key, value)}...)<br/>  }<br/>  args = append(args, []string{"--tmpfs", c.MountVolumePath, c.ContainerFileName}...)<br/>  dockerArgs := append([]string{"run", "-d", "--name", c.Name, "-p", portExpose}, args...)<br/>  return dockerArgs<br/>}</span><span id="4ed5" class="lk ll iq lg b gy lq ln l lo lp">func (d *Docker) Start(c ContainerOption) (string, error) {<br/>  dockerArgs := d.getDockerRunOptions(c)<br/>  command := exec.Command("docker", dockerArgs...)<br/>  command.Stderr = os.Stderr<br/>  result, err := command.Output()<br/>  if err != nil {<br/>    return "", err<br/>  }<br/>  d.ContainerID = strings.TrimSpace(string(result))<br/>  d.ContainerName = c.Name<br/>  command = exec.Command("docker", "inspect", d.ContainerID)<br/>  result, err = command.Output()<br/>  if err != nil {<br/>    d.Stop()<br/>    return "", err<br/>  }<br/>  return string(result), nil<br/>}</span><span id="d33e" class="lk ll iq lg b gy lq ln l lo lp">func (m *MysqlDocker) StartMysqlDocker() {<br/>  mysqlOptions := map[string]string{<br/>    "MYSQL_ROOT_PASSWORD": "root",<br/>    "MYSQL_USER":          "gouser",<br/>    "MYSQL_PASSWORD":      "gopassword",<br/>    "MYSQL_DATABASE":      "godb",<br/>  }<br/>  containerOption := ContainerOption{<br/>    Name:              "our-mysql-container",<br/>    Options:           mysqlOptions,<br/>    MountVolumePath:   "/var/lib/mysql",<br/>    PortExpose:        "3306",<br/>    ContainerFileName: "mysql:5.7",<br/>  }<br/>  m.Docker = Docker{}<br/>  m.Docker.Start(containerOption)<br/>}</span></pre><p id="5fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用containerId来检查容器的细节。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6cb4" class="lk ll iq lg b gy lm ln l lo lp">docker inspect containerId</span></pre><p id="36f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们运行了docker容器，我们需要等到我们的Docker容器启动并运行。我们可以使用下面的命令检查这一点。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="40ab" class="lk ll iq lg b gy lm ln l lo lp">docker ps -a</span></pre><p id="bd16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦docker启动并运行，我们就可以开始在我们的应用程序中使用它来运行与真实数据库的集成测试用例。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0f53" class="lk ll iq lg b gy lm ln l lo lp">func (d *Docker) WaitForStartOrKill(timeout int) error {<br/>  for tick := 0; tick &lt; timeout; tick++ {<br/>    containerStatus := d.getContainerStatus()<br/>    if containerStatus == dockerStatusRunning {<br/>     return nil<br/>    }<br/>    if containerStatus == dockerStatusExited {<br/>     return nil<br/>    }<br/>    time.Sleep(time.Second)<br/>  }<br/>  d.Stop()<br/>  return errors.New("Docker faile to start in given time period so stopped")<br/>}</span><span id="f8e8" class="lk ll iq lg b gy lq ln l lo lp">func (d *Docker) getContainerStatus() string {<br/>  command := exec.Command("docker", "ps", "-a", "--format", "{{.ID}}|{{.Status}}|{{.Ports}}|{{.Names}}")<br/>  output, err := command.CombinedOutput()<br/>  if err != nil {<br/>    d.Stop()<br/>    return dockerStatusExited<br/>  }<br/>  outputString := string(output)<br/>  outputString = strings.TrimSpace(outputString)<br/>  dockerPsResponse := strings.Split(outputString, "\n")<br/>  for _, response := range dockerPsResponse {<br/>    containerStatusData := strings.Split(response, "|")<br/>    containerStatus := containerStatusData[1]<br/>    containerName := containerStatusData[3]<br/>    if containerName == d.ContainerName {<br/>      if strings.HasPrefix(containerStatus, "Up ") {<br/>        return dockerStatusRunning<br/>      }<br/>    }<br/>  }<br/>  return dockerStatusStarting<br/>}</span></pre><p id="e4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用下面的连接字符串从go代码连接到docker中运行的MySQL服务器。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9a73" class="lk ll iq lg b gy lm ln l lo lp">gouser:gopassword@tcp(localhost:3306)/godb?charset=utf8&amp;parseTime=True&amp;loc=Local</span></pre><p id="d5fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些都有助于使用真实的数据库运行集成测试，该数据库可以在每次运行时重新创建。这有助于确保我们的应用程序为产品发布做好准备。</p><p id="e356" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的代码可以在这个git资源库中找到:【https://github.com/MiteshSharma/DockerMysqlGo<a class="ae kc" href="https://github.com/MiteshSharma/DockerMysqlGo" rel="noopener ugc nofollow" target="_blank"/></p><p id="5e26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lr"> PS:如果你喜欢这篇文章，请鼓掌支持</em> </strong>👏<strong class="kf ir"> <em class="lr">。欢呼</em> </strong></p></div></div>    
</body>
</html>