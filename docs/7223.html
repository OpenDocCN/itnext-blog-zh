<html>
<head>
<title>Maintainable React — A story about round-up (Part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的反应——一个关于综述的故事(上)</h1>
<blockquote>原文：<a href="https://itnext.io/a-not-too-short-story-about-rounding-up-24cb4bdfcb69?source=collection_archive---------2-----------------------#2022-07-20">https://itnext.io/a-not-too-short-story-about-rounding-up-24cb4bdfcb69?source=collection_archive---------2-----------------------#2022-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d9122d4279097c6c0605558deb84b013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Je1QsI5guBNqjvke"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马文·迈耶在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1ade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">【更新11。现在整个系列都完成了，我在leanpub上为它创作了一本书</em><a class="ae kf" href="https://leanpub.com/react-clean-code" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">。可以用</em> <a class="ae kf" href="https://leanpub.com/react-clean-code/c/mYXp686cMFw1" rel="noopener ugc nofollow" target="_blank"> <em class="le">这个链接七折获得一份</em> </a> <em class="le">。自从本文(和第二部分)首次发表以来，我已经做了许多修改，我真的相信新的方法要好得多。请读一读，我相信你会成为一个更高效、更优秀的开发人员。</em></p><p id="f419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新(2022年9月25日):我在这篇</em> <a class="ae kf" href="https://icodeit.ck.page/maintainable-react-tips" rel="noopener ugc nofollow" target="_blank"> <em class="le">中总结了7个小技巧，可在这里</em> </a> <em class="le">免费下载</em> <a class="ae kf" href="https://icodeit.ck.page/maintainable-react-tips" rel="noopener ugc nofollow" target="_blank"> <em class="le">。</em></a></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="7d0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想在本教程中分享一些关于干净代码和重构的有趣技巧。虽然有一些来回，但整个过程是一个很好的体验——特别是因为我已经用测试驱动的开发方法完成了。</p><p id="467d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为这很有趣，因为1)这是实际项目中的一个特性(你也可以在你的应用程序中找到它)，2)实现这个特性的迭代方式很有趣，更不用说我还学到了许多其他东西(比如日本和丹麦货币)。</p><p id="edaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以这个专题是关于四舍五入的。基本上，我们网站上的商品价格是类似于<code class="fe lm ln lo lp b">$9.49</code>或<code class="fe lm ln lo lp b">$4.95</code>的价格。让这个数字看起来比实际小是一个聪明的策略——有一些研究支持这个观点。无论如何，我们在这里讨论的功能是，我们希望为用户提供一个选项，让他们在下单前捐赠少量的钱。是的，你猜对了——金额是四舍五入后的价格减去原始价格。例如，如果订单是<code class="fe lm ln lo lp b">$9.9</code>，那么我们问他们是否愿意捐赠<code class="fe lm ln lo lp b">$0.1</code>，如果原价是<code class="fe lm ln lo lp b">$4.95</code>，那么我们问<code class="fe lm ln lo lp b">$0.05</code>，那么总数将是最接近的整数。</p><p id="1326" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是有一个例外，当原始价格已经是一个整数时，我们要求捐赠一美元而不是零美元。</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lq"><img src="../Images/8c0240216db995fbb7210b6638a7a720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqk0Gr85sxQw-UFpgbfIFQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">具有取整选项的付款部分</figcaption></figure><h1 id="d0d9" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">从主要逻辑开始</h1><p id="32fa" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">因此，如果我遵循测试驱动的开发，这里至少要涵盖两个测试:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="adbc" class="nc lw it lp b gy nd ne l nf ng">describe('round up logic', () =&gt; {<br/>  it('rounds up to nearest integer', () =&gt; {<br/>    const total = getRoundedUpTotal(99.9)<br/>    expect(total).toEqual(100)<br/>  })</span><span id="727b" class="nc lw it lp b gy nh ne l nf ng">  it('adds 1 for integer number', () =&gt; {<br/>    const total = getRoundedUpTotal(100)<br/>    expect(total).toEqual(101)<br/>  })<br/>})</span></pre><p id="fbbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过谷歌搜索，我发现使用<code class="fe lm ln lo lp b">Math.floor</code>很容易做到这一点:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="6321" class="nc lw it lp b gy nd ne l nf ng">const getRoundedUpTotal = (total: number) =&gt; Math.floor(total + 1)</span></pre><p id="e998" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码正如预期的那样工作。</p><p id="19fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了显示捐赠金额，我需要一个函数来计算差额。所以我需要一些相应的测试，比如:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="2861" class="nc lw it lp b gy nd ne l nf ng">it('returns the diff between origin price and rounded up price', () =&gt; {<br/>    const diff = getRoundedUpAmount(99.9)<br/>    expect(diff).toEqual(0.1)<br/>  })</span><span id="98a6" class="nc lw it lp b gy nh ne l nf ng">  it('returns the diff between origin price and rounded up price - integer', () =&gt; {<br/>    const diff = getRoundedUpAmount(100)<br/>    expect(diff).toEqual(1)<br/>  })</span></pre><p id="85e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浮点数部分，<code class="fe lm ln lo lp b">getRoundedUpAmount</code>的实现有点棘手，但是一旦我引入了<code class="fe lm ln lo lp b">toPrecision</code>，一切都很好。</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="0afb" class="nc lw it lp b gy nd ne l nf ng">const getRoundedUpAmount = (total: number) =&gt; {<br/>  const roundedUpAmount = getRoundedUpTotal(total) - total<br/>  return parseFloat(roundedUpAmount.toPrecision(10))<br/>}</span></pre><p id="8bc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里需要注意的是，当你比较两个浮点数时，你可能会惊讶地发现<code class="fe lm ln lo lp b">0.2</code>并不真的等于<code class="fe lm ln lo lp b">1 - 0.8</code>。如果你想知道更多关于浮点数的奇怪行为，这里有一个<a class="ae kf" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" rel="noopener ugc nofollow" target="_blank">好(长)</a>的阅读材料。</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/039458bf4d804ed1873a2e55e1910aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94hCeONRCwOoah6UwwsmNw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">比较两个浮点数</figcaption></figure><p id="5ed1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是啊，我知道。</p><h1 id="81dc" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">让我们做用户界面</h1><p id="532d" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我们还需要确保用户界面按预期工作。让我们从一些测试开始。</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="d58e" class="nc lw it lp b gy nd ne l nf ng">it('shows rounded-up amount when user agreed to donate', () =&gt; {<br/>  render(&lt;Payment price={99.9} /&gt;)</span><span id="39da" class="nc lw it lp b gy nh ne l nf ng">  expect(screen.getByTestId('total')).toHaveTextContent(`Place order $99.9`)</span><span id="528b" class="nc lw it lp b gy nh ne l nf ng">  const checkbox = screen.getByTestId('checkbox')<br/>  fireEvent.click(checkbox)</span><span id="0740" class="nc lw it lp b gy nh ne l nf ng">  expect(screen.getByTestId('total')).toHaveTextContent(`Place order $100`)<br/>})</span><span id="d017" class="nc lw it lp b gy nh ne l nf ng">it('shows message correspondingly', () =&gt; {<br/>  render(&lt;Payment price={99.9} /&gt;)</span><span id="8d24" class="nc lw it lp b gy nh ne l nf ng">  expect(screen.getByText(`I'd like to round up and donate $0.1 to charity.`)).toBeInTheDocument()</span><span id="9242" class="nc lw it lp b gy nh ne l nf ng">  const checkbox = screen.getByTestId('checkbox')<br/>  fireEvent.click(checkbox)</span><span id="a3a9" class="nc lw it lp b gy nh ne l nf ng">  expect(screen.getByText(`Thanks, your donation will make a difference.`)).toBeInTheDocument()<br/>})</span></pre><p id="f084" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在该功能的用户界面部分，我可以使用这两个助手函数来使用户界面正常工作:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="528d" class="nc lw it lp b gy nd ne l nf ng">const Payment = ({price}: { price: number }) =&gt; {<br/>  const [withDonation, setWithDonation] = useState&lt;boolean&gt;(false)</span><span id="71d7" class="nc lw it lp b gy nh ne l nf ng">  const roundedUpAmount = getRoundedUpAmount(price)</span><span id="0280" class="nc lw it lp b gy nh ne l nf ng">  const total = withDonation ? getRoundedUpTotal(price) : price</span><span id="36f7" class="nc lw it lp b gy nh ne l nf ng">  const onChange = () =&gt; setWithDonation(withDonation =&gt; !withDonation)</span><span id="f13f" class="nc lw it lp b gy nh ne l nf ng">  return (<br/>    &lt;div className="payment-container"&gt;<br/>      &lt;h4&gt;Payment&lt;/h4&gt;</span><span id="d21f" class="nc lw it lp b gy nh ne l nf ng">      &lt;div&gt;<br/>        &lt;label&gt;<br/>          &lt;input type="checkbox" checked={withDonation} onChange={onChange}/&gt;<br/>          {<br/>            withDonation ?<br/>              `Thanks, your donation will make a difference.` :<br/>              `I'd like to round up and donate $${roundedUpAmount} to charity.`<br/>          }<br/>        &lt;/label&gt;<br/>      &lt;/div&gt;</span><span id="55ef" class="nc lw it lp b gy nh ne l nf ng">      &lt;button className="payment-button"&gt;<br/>        Place order ${total}<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="2f0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里也没什么特别的。一个复选框允许用户选择加入捐赠，一旦他们选择了它，我们就将其四舍五入并更新按钮上的<code class="fe lm ln lo lp b">total</code>金额。</p><h1 id="908c" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">新要求—日本货币</h1><p id="a713" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">你已经发布了这个功能，哇哦！当人们可以享受食物并更好地帮助世界时，他们会感觉很好，市场数量也看起来不错。</p><p id="643a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在业务扩展到日本市场之前，一切都很完美。日本人喜欢你的申请提供的食物。唯一的问题是，在他们的货币中，四舍五入没有多大意义。与美元相比，日元通常看起来非常大。例如，一个不起眼的比萨饼要花3549英镑。目前的舍入逻辑将增加1日元，因为它已经是一个整数，但向慈善机构捐款1日元几乎是零。</p><p id="d300" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们的策略是，在这种情况下，我们需要针对日本市场的具体规则——我们需要四舍五入到最接近的百。让我们先写几个测试来验证新的变化。</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="4a68" class="nc lw it lp b gy nd ne l nf ng">describe('JPY', () =&gt; {<br/>    it('rounds up to nearest hundred', () =&gt; {<br/>      const total = getRoundedUpTotalForJP(3549)<br/>      expect(total).toEqual(3600)<br/>    })</span><span id="c022" class="nc lw it lp b gy nh ne l nf ng">    it('add 100 for integers', () =&gt; {<br/>      const total = getRoundedUpTotalForJP(3600)<br/>      expect(total).toEqual(3700)<br/>    })<br/>  })</span></pre><p id="9ad1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现方法是除以100，向下舍入，然后乘以100:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="0db5" class="nc lw it lp b gy nd ne l nf ng">const getRoundedUpTotalForJP = (total: number) =&gt; Math.floor(total / 100 + 1) * 100</span></pre><p id="437a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相应地，为了计算差异，我们也需要通过这些测试:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="a118" class="nc lw it lp b gy nd ne l nf ng">describe('JPY', () =&gt; {<br/>    it('returns the diff between origin price and rounded up price', () =&gt; {<br/>      const diff = getRoundedUpAmountForJP(3549)<br/>      expect(diff).toEqual(51)<br/>    })</span><span id="426d" class="nc lw it lp b gy nh ne l nf ng">    it('returns the diff between origin price and rounded up price - integer', () =&gt; {<br/>      const diff = getRoundedUpAmountForJP(3600)<br/>      expect(diff).toEqual(100)<br/>    })<br/>  })</span></pre><h1 id="78ec" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">重构视图</h1><p id="8806" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">为了对日本市场使用新的逻辑，我们可以在<code class="fe lm ln lo lp b">Payment</code>中放一些if-else。但是我认为，如果我们能够对它进行评估，看看我们是否能够稍微清理一下代码以使更改更容易，这将是一个更好的主意。</p><p id="7d4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自定义挂钩将有助于拆分计算逻辑和视图。</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="0545" class="nc lw it lp b gy nd ne l nf ng">const useRoundUp = (price: number) =&gt; {<br/>  const [agreeWithDonation, setAgreeWithDonation] = useState&lt;boolean&gt;(false)</span><span id="0530" class="nc lw it lp b gy nh ne l nf ng">  const roundedUpAmount = getRoundedUpAmount(price)</span><span id="2e31" class="nc lw it lp b gy nh ne l nf ng">  const total = agreeWithDonation ? getRoundedUpTotal(price) : price</span><span id="b5f7" class="nc lw it lp b gy nh ne l nf ng">  const updateDonationAgreement = () =&gt; setAgreeWithDonation(withDonation =&gt; !withDonation)</span><span id="1e8e" class="nc lw it lp b gy nh ne l nf ng">  return {<br/>    agreeWithDonation,<br/>    updateDonationAgreement,<br/>    total,<br/>    roundedUpAmount<br/>  }<br/>}</span></pre><p id="22a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，本质上，我们将这些与视图无关的代码移到了一个钩子中，并重命名了变量，使它们更清晰，并与业务语言保持一致。然后我们从视图中的钩子请求所有必要的部分:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="5f02" class="nc lw it lp b gy nd ne l nf ng">const Payment = ({price}: { price: number }) =&gt; {<br/>  const {<br/>    agreeWithDonation,<br/>    updateDonationAgreement,<br/>    total,<br/>    roundedUpAmount<br/>  } = useRoundUp(price)</span><span id="b4bb" class="nc lw it lp b gy nh ne l nf ng">  //...<br/>}</span></pre><p id="e9b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷，我喜欢这个主意！现在让我们假设我们可以从URL(或其他地方，但这并不重要)获得国家代码，而<code class="fe lm ln lo lp b">Payment</code>的调用者会将国家代码传递给我们。</p><p id="d7dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="0b83" class="nc lw it lp b gy nd ne l nf ng">&lt;Payment price={99.9} countryCode="AU" /&gt;<br/>&lt;Payment price={3459} countryCode="JP" /&gt;</span></pre><p id="d3c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把它传给<code class="fe lm ln lo lp b">useRoundUp</code>胡克:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="0c05" class="nc lw it lp b gy nd ne l nf ng">const useRoundUp = (price: number, countryCode: string) =&gt; {}</span></pre><h1 id="d337" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">如果-否则</h1><p id="70b0" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在钩子内部想出一些if-else来在不同的算法之间切换并不太难:</p><pre class="lr ls lt lu gt my lp mz na aw nb bi"><span id="cd07" class="nc lw it lp b gy nd ne l nf ng">const useRoundUp = (price: number, countryCode: string) =&gt; {<br/>  const [agreeWithDonation, setAgreeWithDonation] = useState&lt;boolean&gt;(false)<br/>  const updateDonationAgreement = () =&gt; setAgreeWithDonation(withDonation =&gt; !withDonation)</span><span id="39d5" class="nc lw it lp b gy nh ne l nf ng">  const roundedUpAmount = <br/>    countryCode === 'JP' ? getRoundedUpAmountForJP(price): getRoundedUpAmount(price)<br/>  const total = <br/>    agreeWithDonation ? <br/>      (countryCode === 'JP' ? getRoundedUpTotalForJP(price) : getRoundedUpTotal(price)) : price</span><span id="b12b" class="nc lw it lp b gy nh ne l nf ng">  return {<br/>    agreeWithDonation,<br/>    updateDonationAgreement,<br/>    total,<br/>    roundedUpAmount<br/>  }<br/>}</span></pre><p id="5768" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们的代码有三层:</p><ul class=""><li id="4c91" class="nj nk it ki b kj kk kn ko kr nl kv nm kz nn ld no np nq nr bi translated">像<code class="fe lm ln lo lp b">getRoundedUpAmountForJP</code>和<code class="fe lm ln lo lp b">getRoundedUpAmount</code>这样的函数的纯计算逻辑</li><li id="5098" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated">挂钩<code class="fe lm ln lo lp b">useRoundUp</code></li><li id="59c5" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated">无逻辑视图<code class="fe lm ln lo lp b">Payment</code>组件</li></ul><p id="6121" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每一层都有自己的职责，这很好，因为我们可以在一层进行更改，而不必太担心其他层。</p><h1 id="8ad1" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">摘要</h1><p id="4599" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在教程的第一部分，我们已经实现了该特性的一些核心功能，并且通过测试驱动的开发方法，我们已经做了一些很好的重构和清理。在第2部分中，我们将继续实现rest部分，以及更多奇特的重构。</p></div></div>    
</body>
</html>