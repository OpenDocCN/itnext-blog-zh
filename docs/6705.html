<html>
<head>
<title>Fixing vulnerabilities found in a dependency tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复在依赖关系树中发现的漏洞</h1>
<blockquote>原文：<a href="https://itnext.io/fixing-vulnerabilities-found-in-a-dependency-tree-3a2a70cee43?source=collection_archive---------1-----------------------#2022-02-04">https://itnext.io/fixing-vulnerabilities-found-in-a-dependency-tree-3a2a70cee43?source=collection_archive---------1-----------------------#2022-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fb33678ca99b1ab01cd8e22ec484e966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rjT05OvkYtNljNr8bY4_Q.jpeg"/></div></div></figure><div class=""/><p id="16b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在一家生产金融云解决方案的公司工作。我们正在制作一个新的应用程序——一个在<em class="kw"> React Native </em>开发的移动应用程序。该应用程序尚未公开发布，在准备发布期间，我们对<strong class="ka jc"> <em class="kw">进行了全面的代码扫描，以找到任何漏洞</em> </strong>。我们发现我们的代码库中使用的一些依赖项依赖于旧的和潜在有害的包。</p><p id="5668" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就像当我们需要<code class="fe kx ky kz la b">packageA</code>时，但是那个库(<code class="fe kx ky kz la b">packageA</code>)依赖于易受攻击的库<code class="fe kx ky kz la b">packageB</code>。</p><p id="9e1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要采取适当的行动。我被指派去🪂执行任务</p><h1 id="635e" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">纱线溶液</h1><p id="da86" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我发现的事实是，在<em class="kw"> yarn package </em> manager中强制一些深度嵌套的依赖关系是相对容易的:</p><p id="4821" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Yarn支持<a class="ae me" href="https://classic.yarnpkg.com/lang/en/docs/selective-version-resolutions/" rel="noopener ugc nofollow" target="_blank">选择性版本解析</a>，它允许您通过package.json文件中的resolutions字段在依赖项中定义定制的包版本或范围。通常，这需要在yarn.lock文件中进行手动编辑。</p><h2 id="23e7" class="mf lc jb bd ld mg mh dn lh mi mj dp ll kj mk ml lp kn mm mn lt kr mo mp lx mq bi translated">怎么用？</h2><p id="9096" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们需要将<code class="fe kx ky kz la b">resolutions</code>添加到我们的<code class="fe kx ky kz la b">package.json</code>中，指导Yarn如何处理依赖性:</p><pre class="mr ms mt mu gt mv la mw mx aw my bi"><span id="7820" class="mf lc jb la b gy mz na l nb nc">{<br/>  "name": "project",<br/>  "version": "1.0.0",<br/>  "dependencies": {<br/>    "left-pad": "1.0.0",<br/>    "c": "file:../c-1",<br/>    "d2": "file:../d2-1"<br/>  },<br/>  "resolutions": {<br/>    "d2/left-pad": "1.1.1",<br/>    "c/**/left-pad": "^1.1.2"<br/>  }<br/>}</span></pre><p id="fc8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在本地存储的<code class="fe kx ky kz la b">c</code>和<code class="fe kx ky kz la b">d2</code>旁边安装<code class="fe kx ky kz la b">left-pad</code>的版本<em class="kw"> 1.0.0 </em>。但是它会为<code class="fe kx ky kz la b">d2 </code>安装<code class="fe kx ky kz la b">left-pad</code>的<em class="kw"> 1.1.1 </em>版本，为<code class="fe kx ky kz la b">c</code>下任何需要<code class="fe kx ky kz la b">left-pad</code>的依赖项安装<em class="kw"> ^1.1.2 </em>版本。</p><h1 id="303b" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">NPM实施</h1><p id="a556" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">如果您使用npm而不是yarn，您可以使用<code class="fe kx ky kz la b">package.json</code>中的<a class="ae me" href="https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides" rel="noopener ugc nofollow" target="_blank">覆盖</a>设置来实现类似的效果。尽管有一些不同。</p><p id="d91e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不能使用全局匹配(双星号— <code class="fe kx ky kz la b">**</code>)来代替，我们必须嵌套依赖关系:</p><pre class="mr ms mt mu gt mv la mw mx aw my bi"><span id="fdbf" class="mf lc jb la b gy mz na l nb nc">{<br/>  "overrides": {<br/>    "foo": {<br/>      ".": "1.0.0",<br/>      "bar": "1.0.0"<br/>    }<br/>  }<br/>}</span></pre><p id="b461" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在那个例子中，我们覆盖了版本为<em class="kw"> 1.0.0 </em>的<code class="fe kx ky kz la b">foo</code>包，并使<code class="fe kx ky kz la b">bar</code>在<code class="fe kx ky kz la b">foo</code>之外的任何深度也是<em class="kw"> 1.0.0 </em>。</p><h1 id="69a8" class="lb lc jb bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后的话</h1><p id="ad61" class="pw-post-body-paragraph jy jz jb ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">有了这些不太为人所知的选项，我们可以强制任何深度嵌套包的更新版本(或简单的其他版本)。这是一种当我们的依赖包之一依赖于例如不再维护任何包含例如漏洞的包时修复问题的方法。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="6dd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">克劳迪奥·施瓦兹在<a class="ae me" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></div></div>    
</body>
</html>