<html>
<head>
<title>The reality of PHP WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP WebSockets的现实</h1>
<blockquote>原文：<a href="https://itnext.io/the-reality-of-php-websockets-4c680bc2bc60?source=collection_archive---------0-----------------------#2021-05-07">https://itnext.io/the-reality-of-php-websockets-4c680bc2bc60?source=collection_archive---------0-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="71dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一旦进入循环，就永远不要离开循环</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd0b858777f343c52c4c30998493ccf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hZ7XCpCO3UHWpyJO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@calvinhanson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡尔文·汉森</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="34cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不得不违背自己意愿实现的一件事是一个Websocket服务器…用PHP实现。你没听错。</p><p id="d580" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当语言和运行时本身的本质是单线程的，或者你可以说是“阻塞”的时候，我总是强烈反对PHP被用于不适合的事情，比如保持套接字连接。</p><p id="0898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，即使我不想这样做，并研究了Go和Rust的实现，我发现PHP上的WebSocket并没有那么糟糕，但是有一些警告。</p><h1 id="c1c6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Websockets和PHP的异步特性</h1><p id="4290" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">不久前，一些人发现PHP可以通过使用<a class="ae kv" href="https://www.php.net/manual/en/language.generators.overview.php" rel="noopener ugc nofollow" target="_blank">生成器</a>来处理某种并发性。</p><p id="b09b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，生成器是可以迭代“未知”并在收到值时返回值的函数，只需暂停函数执行并等待下一个值。<a class="ae kv" href="https://betterprogramming.pub/a-look-at-the-new-php-8-1-fibers-feature-979489399918" rel="noopener ugc nofollow" target="_blank">这就像纤维不太友好的表亲</a>。</p><p id="832c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器是并发性的关键，并发性是一些编程语言中使用的技术，如Javascript。您可以在一个值中注册的多个“可调用项”上生成一个循环，该循环总是返回堆栈中可调用项的结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">几乎异步函数的简单方法。</figcaption></figure><p id="5dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那只是冰山一角。这个例子很简单，如果你运行，它将返回“bar foo”<a class="ae kv" href="https://www.tehplayground.com/FFBbBKxE4quTCeR4" rel="noopener ugc nofollow" target="_blank">。有一本有趣的</a><a class="ae kv" href="https://sof3.github.io/await-generator/master/intro.html" rel="noopener ugc nofollow" target="_blank">小书，讲述了生成器</a>以及它们如何使代码异步。</p><p id="8cbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些想要性能的人，这些库可以“绕过”生成器性能损失，直接使用控制事件本身的库，如<code class="fe ms mt mu mv b">libuv</code>、<code class="fe ms mt mu mv b">libevent</code>和<code class="fe ms mt mu mv b">libev</code>。ReactPHP将要求用户设置一个“驱动程序”，而Amphp将按照这个顺序自动使用它们。</p><h2 id="ac23" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj nh bi translated">插座作为发电机电源</h2><p id="91f6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">事实是，PHP拥有了与WebSockets一起<em class="ls">工作</em>所需的一切。PHP中的<code class="fe ms mt mu mv b"><a class="ae kv" href="https://www.php.net/manual/es/function.stream-socket-server.php" rel="noopener ugc nofollow" target="_blank">stream_socket_server</a></code>函数允许创建一个套接字，该套接字返回任何进入的连接，因为它像一个生成器一样工作，同时将<code class="fe ms mt mu mv b"><a class="ae kv" href="https://www.php.net/manual/es/function.stream-set-blocking.php" rel="noopener ugc nofollow" target="_blank">stream_set_blocking</a></code>设置为非阻塞。</p><p id="fd24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再加上目前使用最多的异步库ReactPHP或Amp，您就可以拥有一个在等待下一个连接时不会阻塞整个应用程序的连接处理程序。一言以蔽之，因为细节本身就值得写一整篇文章。</p><h1 id="c998" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">走向网络插座</h1><p id="ca95" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们已经有了在PHP上进行异步调用的非常“笨拙”但稳定的方法——至少在今年年底PHP 8.1 中出现<a class="ae kv" href="https://betterprogramming.pub/a-look-at-the-new-php-8-1-fibers-feature-979489399918" rel="noopener ugc nofollow" target="_blank">纤程之前——下一步是连接到套接字服务器，然后将传入的HTTP请求连接升级到WebSockets连接，保持它们在内存中开放。</a></p><p id="067c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，已经有一些图书馆考虑到了这一点，并提供了他们自己的WebSocket服务器。从使用最多的来说，有<a class="ae kv" href="https://github.com/ratchetphp/Ratchet" rel="noopener ugc nofollow" target="_blank">棘轮</a>在幕后使用ReactPHP，而<a class="ae kv" href="https://github.com/amphp/websocket-server" rel="noopener ugc nofollow" target="_blank"> Amp有自己成熟的WebSocket服务器</a>。</p><p id="cdcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在选择了毒药之后，您将主要专注于做一些与客户端连接的事情，以及使用一个持久的PHP实例在服务器上来回传递消息。</p><h2 id="2f85" class="mw lu iq bd lv mx my dn lz mz na dp md lf nb nc mf lj nd ne mh ln nf ng mj nh bi translated">Swoole和Roadrunner网络插座</h2><p id="2062" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Swoole和Roadrunner的问题是，它们是一种不同的野兽，每一种都有自己的方式让PHP更快。</p><p id="689c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Roadrunner更容易理解，因为它可以被视为NGINX或Apache的完全替代品。它是一个web服务器二进制文件，它将自己连接到PHP并对其进行负载平衡，而不会在每次服务请求时关闭PHP运行时，而是保持运行时的活力。PHP本身不受影响，不需要添加外部依赖和扩展。<strong class="ky ir">这是一个非常干净的实现</strong>，很快<a class="ae kv" href="https://github.com/spiral/roadrunner/issues/513" rel="noopener ugc nofollow" target="_blank">就应该有友好的支持来接收WebSockets连接并将它们传递给PHP </a>。它甚至支持gRPC、metrics和<em class="ls"> braindead-easy配置</em>。</p><p id="c3b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，Swoole本身是一个扩展，你必须<em class="ls">将</em>加载到PHP中。这个扩展允许<strong class="ky ir">在PHP </strong>内部运行Web服务器。你可以考虑在你的代码中使用NGINX，但是有更细粒度的控制。</p><p id="38ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是你需要通过PECL编译和安装Swoole扩展，这不是每个人都热衷于做的事情，特别是在Windows中考虑到你需要使用WSL2来实际使用它。Swoole的优势是通过替换数据库驱动程序、HTTP客户端和Redis来实现异步工作，从而重用其自己的并发堆栈，如果您大量使用这些部分，有时会产生更好的性能。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="801e" class="lt lu iq bd lv lw np ly lz ma nq mc md jw nr jx mf jz ns ka mh kc nt kd mj mk bi translated">Websocket现在已经成为可能</h1><p id="f329" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，您可以在PHP服务器中使用和部署WebSocket服务器。考虑一下，如果你使用基于ReactPHP或Amp的纯PHP实现，就意味着要进入它们的事件循环，并遵守它们在异步上下文中的工作方式。</p><p id="8cfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">纯PHP制作的Websocket服务器性能还不错。在<a class="ae kv" href="https://beyondco.de/docs/laravel-websockets" rel="noopener ugc nofollow" target="_blank"> BeyondCode的家伙们使用棘轮</a>，并在一个Laravel应用程序上与他们的服务器分享这个性能指标。</p><blockquote class="nu nv nw"><p id="4252" class="kw kx ls ky b kz la jr lb lc ld ju le nx lg lh li ny lk ll lm nz lo lp lq lr ij bi translated">这是另一个在2GB数字Ocean droplet上用2个CPU运行的基准测试。在这个服务器设置上，<strong class="ky ir">并发</strong>连接的最大数量接近60，000。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8b7f04b548d6001579932c85d3954b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*htxqCzeizR_MrfD-.png"/></div></figure><p id="c3e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，使用PHP产生的性能会低于任何编译语言，如C++、Rust，甚至Go，如果我们考虑一下著名的例子<a class="ae kv" href="https://github.com/eranyanay/1m-go-websockets" rel="noopener ugc nofollow" target="_blank">100万个连接</a>只使用600MB的内存。在用c语言编写的WebSockets库的帮助下，我们还可以让Node.js处理一百万个连接。</p><p id="befd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的优势是代码重用。如果你已经用PHP编写了应用程序的一部分，用相同的代码库运行WebSocket意味着更快的开发，因为你不需要翻译任何东西。</p><p id="7703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，如果你的服务器开始处理成千上万的连接用户，你可能会开始寻找更大的解决方案，如<a class="ae kv" href="https://pusher.com/" rel="noopener ugc nofollow" target="_blank"> Pusher </a>、<a class="ae kv" href="https://www.pubnub.com/" rel="noopener ugc nofollow" target="_blank"> PubNub </a>、<a class="ae kv" href="https://getstream.io/" rel="noopener ugc nofollow" target="_blank"> Stream </a>、<a class="ae kv" href="https://www.piesocket.com/" rel="noopener ugc nofollow" target="_blank"> PieSocket </a>、<a class="ae kv" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API Gateway </a>、<a class="ae kv" href="https://firebase.google.com/products/realtime-database" rel="noopener ugc nofollow" target="_blank"> Firebase实时数据库</a>，以及其他用于健壮流的系统。</p><p id="3aac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有希望的是，一旦Fibers登陆PHP并且异步库更新了他们的代码库，PHP上的WebSockets可能会变得更快，并且有希望被更广泛地用于像<a class="ae kv" href="https://laravel-livewire.com/" rel="noopener ugc nofollow" target="_blank"> Laravel Livewire </a>这样的实验，以变得更好。</p></div></div>    
</body>
</html>