<html>
<head>
<title>Building a Synthesizer in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中构建合成器</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-synthesizer-in-typescript-5a85ea17e2f2?source=collection_archive---------1-----------------------#2020-05-24">https://itnext.io/building-a-synthesizer-in-typescript-5a85ea17e2f2?source=collection_archive---------1-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1387" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用Web Audio API在TypeScript中构建合成器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eac4f5e903d94fe8a94d16f8e6925f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PVHKn6q443scmuXnPAqvgg.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://kenreilly.github.io/typescript-synth-demo/" rel="noopener ugc nofollow" target="_blank">示例项目</a>的屏幕录制</figcaption></figure><h2 id="d096" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="f8bd" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi mo translated"><span class="l mp mq mr bm ms mt mu mv mw di">T</span>type script语言提供了许多功能，使其成为音频工程的绝佳选择，音频工程具有挑战性，需要关注细节(<em class="mx">当出现问题时，可以清晰地听到结果</em>)。</p><p id="0fed" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">在本文中，我们将了解如何在TypeScript中构建一个音乐合成器，包括一个键盘、音符读出器、示波器和两个具有增益、失谐和延迟功能的振荡器，并使用Web Audio API提供的许多功能来创建和处理声音。</p><p id="af71" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">对于示例应用程序源代码的副本，克隆这个repo 。要观看该项目的现场演示，请查看本页<a class="ae ky" href="https://kenreilly.github.io/typescript-synth-demo/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="c41a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概念</h2><p id="26fa" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">该项目利用音频工程和编程中的一些概念，以模块化的方式定义合成器，每个组件都提供独立的功能以及与其他组件通信的清晰接口。这些概念是:</p><ul class=""><li id="3b09" class="nk nl it lx b ly my mb mz li nm lm nn lq no mn np nq nr ns bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Audio_signal" rel="noopener ugc nofollow" target="_blank">音频信号、</a> <a class="ae ky" href="https://en.wikipedia.org/wiki/Waveform" rel="noopener ugc nofollow" target="_blank">波形</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Digital_signal_processing" rel="noopener ugc nofollow" target="_blank"> DSP </a></li><li id="27ed" class="nk nl it lx b ly nt mb nu li nv lm nw lq nx mn np nq nr ns bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅</a>模式</li><li id="32fb" class="nk nl it lx b ly nt mb nu li nv lm nw lq nx mn np nq nr ns bi translated">HTML、CSS和类型脚本</li><li id="10cd" class="nk nl it lx b ly nt mb nu li nv lm nw lq nx mn np nq nr ns bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank"> FP </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>范例</li><li id="68c7" class="nk nl it lx b ly nt mb nu li nv lm nw lq nx mn np nq nr ns bi translated"><a class="ae ky" href="https://www.google.com/search?client=firefox-b-1-d&amp;q=web+audio+api" rel="noopener ugc nofollow" target="_blank">网络音频API </a></li></ul><p id="0085" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">虽然对这些概念的一些理解会有所帮助，但本文将为坚定的读者提供足够的指导，以学习用于构建该应用程序和其他类似应用程序的技能。</p><blockquote class="ny nz oa"><p id="b162" class="lv lw mx lx b ly my ju ma mb mz jx md ob na mf mg oc nb mi mj od nc ml mm mn im bi translated">为了清楚起见，HTML和CSS被省略了，因为它们是基本的，不包含任何在普通网站上不容易找到的内容。</p></blockquote></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="f196" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主文件</h2><p id="3b10" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">应用程序的入口点是<strong class="lx iu"> synth.ts </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7606" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">synth类为键定义、synth引擎、Synth中每种类型事件的事件总线(信号和控制)以及UI中组件的HTML元素定义了属性。在初始化期间，synth查询文档中所需的元素，创建键定义类、synth引擎、示波器和控制滑块的实例，然后遍历滑块和键定义，将它们附加到UI。</p><p id="0cdf" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">一个监听器连接到信号总线，将音符开/关事件传递到<code class="fe og oh oi oj b">on_signal</code>，它将使用当前音符更新显示。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="ddb3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">事件总线</h2><p id="45fa" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">EventBus是<a class="ae ky" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" rel="noopener ugc nofollow" target="_blank">发布-订阅</a>模式的一个实现，对于需要独立于系统中其他组件在内部管理状态的音频组件来说，这是一个理想的选择，这些组件既相似又有不同之处。让我们来看看<strong class="lx iu"> event-bus.ts </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="dac9" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">事件类扩展了基本合成事件，该事件返回其构造函数作为<code class="fe og oh oi oj b">type</code>属性，创建了一个非常精简的<a class="ae ky" href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" rel="noopener ugc nofollow" target="_blank">反射</a>实现，使总线上的侦听器更容易<code class="fe og oh oi oj b">switch</code>事件类型并相应地处理它。每个事件都包含正在执行的操作的预定目标所需的数据。利用EventBus的两个实例，一个用于音符开/关事件，一个用于参数控制。UI控件(<em class="mx">如按键和滑块</em> ) <code class="fe og oh oi oj b">fire</code>事件沿总线向下，由<code class="fe og oh oi oj b">listeners</code>接收并相应转发或处理。</p><p id="258a" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">这种体系结构非常适合于模拟硬件设备，这些设备总是相互传递信息，并且从来没有任何控制，甚至不知道系统内其他组件的内部工作方式。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="40e2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">合成引擎</h2><p id="5a92" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">下一个要检查的文件是<strong class="lx iu"> synth-engine.ts </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="be2b" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">SynthEngine定义了对传递到构造函数中的信号和控制事件总线实例的两个本地引用，以及音频上下文和增益、振荡器和延迟组件，我们将很快对此进行研究。构造器还将每个振荡器连接到同一通道的延迟，将每个延迟连接到主输出增益，然后使用单独的SynthEvent和ControlEvent处理程序监听事件。</p><p id="7d14" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">当引擎接收到音符开/关事件时，该事件被转发到两个振荡器中的每一个，以触发开始/停止操作。类似地，当接收到控制事件时，在具有匹配类型和通道的组件上设置属性。每个属性在内部处理所提供的值，并将在内部执行必要的数学和其他操作，以允许它完全控制自己，同时提供一个干净、简单的接口。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="0df9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">合成键</h2><p id="4b7f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">SynthKey和KeyDefinition类在<strong class="lx iu"> synth-keys.ts </strong>中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4a64" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">KeyDefinition定义了一个八度音程的<code class="fe og oh oi oj b">notes</code>和两个八度音程的<code class="fe og oh oi oj b">scale</code>，这将被<code class="fe og oh oi oj b">keys</code>属性用来生成一个HTML按钮数组。当对每个键定义调用<code class="fe og oh oi oj b">SynthKey.create</code>时，会创建一个按钮，并将<a class="ae ky" href="https://www.tutorialsteacher.com/typescript/arrow-function" rel="noopener ugc nofollow" target="_blank"> arrow </a> (lambda)函数分配到按钮事件处理程序中，以触发总线上的音符开/关事件。</p><h2 id="1ba7" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">滑块</h2><p id="bca0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">slider小部件类位于<strong class="lx iu"> slider.ts </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7263" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">滑块设计简单，返回一个放置在synth参数控制面板上的range input元素，带有最小值/最大值/默认值，以及输入上的一个事件处理程序，该处理程序将通过通道、控制类型和更新值在事件总线上触发一个事件。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="0581" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Synth组件库</h2><p id="a21a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们检查一下<strong class="lx iu"> synth-component.ts </strong>中的组件基类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7200" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">这个简单的抽象类为<code class="fe og oh oi oj b">node</code>定义了一个类型化的属性，它可以是任何Web Audio API对象，这些对象被包装在一个扩展这个对象的类中。每个组件都将继承音频上下文、通道和组件的属性，以便从这个组件的输出接收信号。</p><p id="3b32" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">还继承了<code class="fe og oh oi oj b">drive</code>方法，用于将音频信号数据转发到信号链中的目标器件。这允许每个组件根据需要自动重新启动和重新连接到目标，并简单地通过批处理操作。</p><p id="3349" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">这充分利用了函数式和面向对象的范例，允许synth在保持良好工作状态的同时进行扩展和升级。这种架构类似于真正的音频设备，具有用于音频和控制数据的标准化io连接。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="9c50" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">获得</h2><p id="86b7" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">最简单的音频组件是增益，在<strong class="lx iu"> gain.ts </strong>中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="837b" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">Gain创建一个内部使用的GainNode，并简单地通过<code class="fe og oh oi oj b">gain</code>属性传递该对象的gain属性。因此，处理这个对象的对象可以修改节点的增益，而无需访问GainNode实例上的其他属性。如果提供给构造函数的通道是<code class="fe og oh oi oj b">CHANNEL.MASTER</code>,组件将连接到音频上下文的目的地(您设备的音频驱动程序)并将增益设置为10%,这很重要，因为默认情况下合成器的声音非常大。这是音频工程中的一个重要概念，因为吹喇叭和损坏耳膜并不难，这两者都是非常机械敏感的。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="32b0" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">振荡器</h2><p id="11bf" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来，我们来看看oscillator.ts中的振荡器组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="21dc" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">振荡器保存对网络音频振荡器节点的引用，每次播放音符时都会重新创建该节点，因为内部振荡器一旦停止就无法重新启动。波形可以是正弦或方波，并且创建了两个内部增益节点，一个用作可控音量，另一个用作音量包络，当音符开始时快速提高音量，当音符停止时降低音量(这消除了内部振荡器开始或停止时可以听到的“砰”声，这种声音很大，在高音量下可能会损坏设备)。</p><p id="3bea" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated"><code class="fe og oh oi oj b">gain</code>和<code class="fe og oh oi oj b">detune</code>属性允许引擎在处理控制事件时从外部设置这些参数，并且每个属性执行将传入的原始滑块值转换为与目标音频节点兼容的值所需的数学运算。</p><p id="8bed" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">当<code class="fe og oh oi oj b">play</code>被调用时，一个新的振荡器节点被创建并配置了频率、失谐和波形，然后内部音频链被建立，振荡器被启动并增大音量。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="9138" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">耽搁</h2><p id="3713" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">延迟组件在<strong class="lx iu"> delay.ts </strong>中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7a44" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">Delay包含一个<code class="fe og oh oi oj b">node</code>属性，它将使用该属性接收来自其他组件的信号，以及一个网络音频延迟节点和两个用于干/湿混合的附加增益节点。创建延迟组件时，会设置内部音频链，并设置0.2秒的延迟值。延迟也覆盖了组合湿/干输出的<code class="fe og oh oi oj b">drive</code>方法。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="4e2f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示波器</h2><p id="c4f1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">合成器的最终输出波形由<strong class="lx iu"> scope.ts </strong>渲染:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6038" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">示波器的核心是网络音频<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode" rel="noopener ugc nofollow" target="_blank">分析器节点</a>，它为它作为输入接收的任何音频信号提供实时频域和时域分析，以及HTML <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank">画布</a>，它提供2D图形功能，非常适合呈现音频波形。使用大小为2048的<a class="ae ky" href="https://en.wikipedia.org/wiki/Fast_Fourier_transform" rel="noopener ugc nofollow" target="_blank"> FFT </a>创建一个AnalyserNode，设置canvas呈现属性，范围从<code class="fe og oh oi oj b">run </code>开始，它将从分析器中检索数据并呈现它。</p><p id="b17c" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">渲染周期用<code class="fe og oh oi oj b">requestAnimationFrame</code>排队，它将在下次浏览器引擎准备重画屏幕时运行这个周期。通过步进音频样本并跟踪当前<a class="ae ky" href="https://en.wikipedia.org/wiki/Phase_(waves)" rel="noopener ugc nofollow" target="_blank">相位来检索波形，当相位达到360度时</a>返回捕获的波形。然后，通过计算水平步长并在画布的宽度上迭代，绘制捕获的波形，沿y轴绘制一个点，对应于每步的样本幅度。还沿x/y轴添加了虚线以供参考。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="fe75" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6659e86201ca6dd6a17498547ffcba99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*JT5VcoSV7gPpQoHxwFq2Tw.gif"/></div></figure><p id="c2a1" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">TypeScript为实现高性能应用程序提供了出色的功能，其体系结构适用于音频工程、图形和其他异步程序，在这些程序中，用户可以听到和/或看到小的性能错误。</p><p id="668d" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">这个synth演示了Web Audio API提供的用于生成、处理和播放各种声音的几个组件。</p><p id="6746" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">感谢阅读！</p><p id="8688" class="pw-post-body-paragraph lv lw it lx b ly my ju ma mb mz jx md li na mf mg lm nb mi mj lq nc ml mm mn im bi translated">~ <a class="ae ky" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a></p></div></div>    
</body>
</html>