<html>
<head>
<title>Debugging ASP.NET Core in Kubernetes from VSCode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从VSCode调试Kubernetes中的ASP.NET内核</h1>
<blockquote>原文：<a href="https://itnext.io/debugging-asp-net-core-in-kubernetes-from-vscode-294a728031e6?source=collection_archive---------1-----------------------#2018-09-19">https://itnext.io/debugging-asp-net-core-in-kubernetes-from-vscode-294a728031e6?source=collection_archive---------1-----------------------#2018-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想从Visual Studio 2019中调试你的应用程序，这里有一篇<a class="ae kl" href="https://pavel-agarkov.medium.com/how-to-debug-asp-net-core-in-kubernetes-from-visual-studio-2019-1e9d16099d99" rel="noopener">文章</a>适合你。</p><p id="1e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您有一个结构如下的工作区文件夹:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="5c04" class="kv kw iq kr b gy kx ky l kz la">Root Workspace Folder<br/>+-- Dockerfile<br/>`-- app<br/>    +-- App.csproj<br/>    `-- ...</span></pre><p id="85a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于这个假设，我们可以在docker文件中编写第一个构建阶段<a class="ae kl" href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/" rel="noopener ugc nofollow" target="_blank">如下:</a></p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="fb77" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">FROM </strong>microsoft/dotnet:2.1-sdk <strong class="kr ir">as</strong> dotnet-build<br/><strong class="kr ir">ARG </strong>DOTNET_CONFIG=Release<br/><strong class="kr ir">WORKDIR </strong>/build<br/><strong class="kr ir">COPY </strong>/app/*.csproj ./<br/><strong class="kr ir">RUN </strong>dotnet restore<br/><strong class="kr ir">COPY </strong>/app/ .<br/><strong class="kr ir">RUN </strong>dotnet publish -c ${DOTNET_CONFIG} -o ./results</span></pre><p id="08bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们首先只复制App.csproj文件并恢复依赖关系，以便缓存该层，如果自上次构建以来依赖关系没有变化，则跳过该层。请记住，我们将所有代码放入<code class="fe lb lc ld kr b">/build</code>文件夹中——我们稍后将需要它来指定源代码映射。</p><p id="94ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是编写映像构建的最后阶段:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="883a" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">FROM </strong>microsoft/dotnet:2.1-aspnetcore-runtime <strong class="kr ir">as </strong>app<br/><strong class="kr ir">ARG </strong>INSTALL_CLRDBG=exit<br/><strong class="kr ir">RUN </strong>bash -c "${INSTALL_CLRDBG}"<br/><strong class="kr ir">WORKDIR </strong>/app<br/><strong class="kr ir">EXPOSE </strong>80<br/><strong class="kr ir">COPY </strong>--from="dotnet-build" /build/results .<br/><strong class="kr ir">ENTRYPOINT </strong>["dotnet", "App.dll"]</span></pre><p id="2f41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第2–3行，我们提供了一种稍后从<code class="fe lb lc ld kr b">docker build</code>命令指定调试器安装脚本的方法。最后，我们复制来自<code class="fe lb lc ld kr b">dotnet-build</code>阶段的构建结果并指定入口点。</p><p id="7d38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用下面的shell脚本构建这个映像:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="9263" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">IMAGE</strong>=your-registry/your-app-image;<br/><strong class="kr ir">docker build</strong> -t <strong class="kr ir">$IMAGE </strong>\<br/>  --build-arg DOTNET_CONFIG=<strong class="kr ir">Build </strong>\<br/>  --build-arg INSTALL_CLRDBG="apt-get update \<br/>    &amp;&amp; apt-get install -y --no-install-recommends unzip \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/* \<br/>    &amp;&amp; curl -sSL https://aka.ms/getvsdbgsh | \<br/>       bash /dev/stdin -v latest -l <strong class="kr ir">/vsdbg"</strong> \<br/>  <strong class="kr ir">.</strong>;<br/><strong class="kr ir">docker push</strong> <strong class="kr ir">$IMAGE</strong>;</span></pre><p id="e83c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你得用真实值代替<code class="fe lb lc ld kr b">your-registry/your-app-image</code>。在<code class="fe lb lc ld kr b">docker build</code>命令中，我们指定<code class="fe lb lc ld kr b">dotnet publish</code>命令的配置为<code class="fe lb lc ld kr b">Build </code>并覆盖调试器安装脚本。在生产中，你可以跳过那些<code class="fe lb lc ld kr b">--build-arg</code>。</p><p id="d48f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，您可以像往常一样将这个映像部署到kubernetes集群中，但是不要忘记删除或调整活性/就绪性问题。或者，您可以只运行以下命令来启动新的pod:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="3ae6" class="kv kw iq kr b gy kx ky l kz la"><strong class="kr ir">kubectl run</strong> my-app --image=<strong class="kr ir">$IMAGE</strong> --labels="<strong class="kr ir">app=my-app</strong>"</span></pre><p id="0e53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了开始调试我们应用程序的这个新实例，我们需要将以下shell脚本添加到根工作区文件夹中:</p><figure class="km kn ko kp gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="ae1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们需要调整<code class="fe lb lc ld kr b">launch.json</code>来使用这个脚本:</p><figure class="km kn ko kp gt le"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="c650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lb lc ld kr b">sourceFileMap</code>中，我们在容器端指定了<code class="fe lb lc ld kr b">/debug</code>文件夹，因为我们在<code class="fe lb lc ld kr b">dotnet-build</code>阶段将所有源代码放入该文件夹，在主机端指定了<code class="fe lb lc ld kr b">${workspaceRoot}/app</code>，因为它是我们原始源代码的位置。在多个dotnet项目的情况下，我们不需要在末尾添加<code class="fe lb lc ld kr b">/app</code>，因为<code class="fe lb lc ld kr b">dotnet </code>会自动添加与解决方案相关的每个项目文件夹。</p><p id="dfb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个<code class="fe lb lc ld kr b">pipeProgram </code>,我们使用Git Bash(因为我们在Windows上)并传递我们在上一步创建的<code class="fe lb lc ld kr b">kube-debug.sh</code>脚本。接下来，我们指定相同的<code class="fe lb lc ld kr b">--selector</code>作为我们在<code class="fe lb lc ld kr b">kubectl run</code>命令和可选的<code class="fe lb lc ld kr b">--namespace</code>中使用的标签。</p><p id="56b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lb lc ld kr b">debuggerPath</code>是相对于<code class="fe lb lc ld kr b">WORKDIR /app</code>的，因为它只在Windows上这样工作，否则Git Bash认为该路径是相对于主机的。不要问我为什么…</p><p id="3976" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以按F5键，享受调试会话！</p><figure class="km kn ko kp gt le gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lh"><img src="../Images/d9019b1ee2e3715fabe4a6bc0f6b01c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZx6x78epE6G-sgU70ru2Q.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">我的应用程序正在运行:)</figcaption></figure></div></div>    
</body>
</html>