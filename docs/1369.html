<html>
<head>
<title>Handling the Next button automatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动处理下一个按钮</h1>
<blockquote>原文：<a href="https://itnext.io/handling-the-next-button-automatically-b9f6f1bf9015?source=collection_archive---------1-----------------------#2018-09-26">https://itnext.io/handling-the-next-button-automatically-b9f6f1bf9015?source=collection_archive---------1-----------------------#2018-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0924350466b62a01f122f14acdf5330c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jubJIGe_x4BuS1MoURJXQ@2x.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由eleven x在Unsplash上拍摄</figcaption></figure><div class=""/><p id="74e3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在多个文本字段中输入文本是如此常见的模式——在任何地方，不仅仅是iOS——应该有一种方法可以轻松地从一个字段导航到下一个字段，最好是“正确的”字段。遗憾的是，iOS没有提供这一功能，但让我们看看如何自己实现这一功能。</p><p id="f759" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，快速回顾一下我们需要什么:</p><ul class=""><li id="3abd" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">如果当前字段之后有任何字段，请查看“下一步”按钮；最好是那些还空着的。</li><li id="8379" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">点击“下一步”按钮，我们将进入正确的字段。</li><li id="3b58" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如果当前字段之后没有更多的字段，请查看返回按钮；最好考虑空的。</li><li id="c749" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">点击“返回”按钮会退出当前响应者。</li><li id="4499" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">不管是什么视图，也不管有多少字段，一切都应该自动工作。</li><li id="fe37" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">一切都应该封装在一个协议中。</li></ul><p id="be9a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">太好了，我们开始吧，从协议开始。我们在这里需要什么？</p><ul class=""><li id="27d1" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">文本字段列表(1)。</li><li id="3780" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">一个处理文本字段编辑的方法开始，显示正确的按钮(2)。</li><li id="6466" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">一种处理文本字段的编辑结束/回车的方法，以执行正确的操作(3)。</li></ul><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="0735" class="lx ly jf lt b gy lz ma l mb mc">protocol NextTextFieldHandler {</span><span id="3576" class="lx ly jf lt b gy md ma l mb mc">    var textFields: [UITextField] { get } // 1 <br/>    func setupReturnKeyType(for textField: UITextField) // 2 <br/>    func handleReturnKeyTapped(on textField: UITextField) // 3 </span><span id="cfb3" class="lx ly jf lt b gy md ma l mb mc">}</span></pre><p id="44f4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe me mf mg lt b">textFields</code>属性(1)可以保存视图中的所有字段，也可以只保存我们感兴趣的字段——协议并不关心这一点，当遵守协议时，我们的工作就是决定需要什么。这两个函数用于满足我们的另外两个需求(2，3)。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5c27" class="lx ly jf lt b gy lz ma l mb mc">extension NextTextFieldHandler { </span><span id="edf0" class="lx ly jf lt b gy md ma l mb mc">    private var _textFields: [UITextField] { <br/>    <!-- -->    return textFields.filter { !$0.isHidden &amp;&amp; $0.alpha != 0 &amp;&amp; $0.isEnabled } // 1 <br/>    }</span><span id="4305" class="lx ly jf lt b gy md ma l mb mc">}</span></pre><p id="859c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以添加一些安全措施，以防我们不小心，这也是一种便利:这些条件将不得不一遍又一遍地编写，因此我们可以自动过滤掉隐藏的字段和禁用的字段(1)。</p><p id="66e9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如上所述，协议不应该关心<code class="fe me mf mg lt b">textFields</code>中的内容；不管出于什么原因，我们可能想要包含一个禁用的文本字段，但是没有办法做到这一点。如果你<em class="mh">确实</em>确定这个项目没有怪异的场景，你可以添加上面的属性并用它代替<code class="fe me mf mg lt b">textFields</code>。</p><p id="e32c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们需要一种方法来提取当前字段之后的所有字段:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c19d" class="lx ly jf lt b gy lz ma l mb mc">extension NextTextFieldHandler { </span><span id="6270" class="lx ly jf lt b gy md ma l mb mc">    private func fields(after textField: UITextField) -&gt; ArraySlice&lt;UITextField&gt; { <br/>    <!-- -->    let textFields = self.textFields // 1 </span><span id="a119" class="lx ly jf lt b gy md ma l mb mc">        guard let currentIndex = textFields.index(of: textField) else { return [] } // 2 <br/>        <br/>        return textFields.suffix(from: min(currentIndex + 1, textFields.endIndex - 1)) // 3 <br/>    }<br/> <br/>}</span></pre><p id="2afe" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们首先将数组保存在一个局部常量中，以略微提高效率(1)，因为<code class="fe me mf mg lt b">textFields</code>属性可能是计算出来的。在少数文本字段中，这种提升可以忽略不计，但是不遍历计算出的属性仍然是一个好习惯——特别是在迭代时——除非我们实际上需要反复重新计算属性，而我们并不需要。</p><p id="ef2c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们找到传入的文本字段的索引，如果找不到就退出。最后，我们返回一个<code class="fe me mf mg lt b">ArraySlice</code>,其中所有文本字段都从当前文本字段之后的字段开始。</p><p id="9c20" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为什么要用切片？因为它保留了原始索引。因此，举例来说，如果我们有<code class="fe me mf mg lt b">[field1, field2, field3, field4]</code>并且我们从索引2开始做切片，我们会得到<code class="fe me mf mg lt b">[field3, field4]</code>，但是每个元素会有以下索引:<code class="fe me mf mg lt b">[2, 3]</code>。我们一会儿就会明白为什么需要这样做。</p><p id="ac11" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们转到这两个函数之前，还有最后一件事:一个简单的助手来检查上面的切片中是否有任何空字段:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="788d" class="lx ly jf lt b gy lz ma l mb mc">extension NextTextFieldHandler { </span><span id="6eec" class="lx ly jf lt b gy md ma l mb mc">    private func emptyFieldsExist(after textField: UITextField) -&gt; Bool { <br/>    <!-- -->    return fields(after: textField)<br/>            .filter { $0.text?.isEmpty != false }<br/>            .isEmpty == false <br/>    } </span><span id="7537" class="lx ly jf lt b gy md ma l mb mc">}</span></pre><p id="dcc3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它只接受当前之后的字段，筛选其中有文本的字段，并检查结果是否为空。</p><p id="dea4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们可以开始实施:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="963b" class="lx ly jf lt b gy lz ma l mb mc">extension NextTextFieldHandler { </span><span id="0080" class="lx ly jf lt b gy md ma l mb mc">    func setupReturnKeyType(for textField: UITextField) { <br/>    <!-- -->    let textFields = self.textFields // 1 </span><span id="1a55" class="lx ly jf lt b gy md ma l mb mc">        guard let currentIndex = textFields.index(of: textField) else { return } // 2 </span><span id="e4e3" class="lx ly jf lt b gy md ma l mb mc">        let emptyFieldsExistAfterCurrent = emptyFieldsExist(after: textField) </span><span id="6cd9" class="lx ly jf lt b gy md ma l mb mc">        if currentIndex &lt; textFields.endIndex - 1, emptyFieldsExistAfterCurrent { // 2 <br/>            textField.returnKeyType = .next <br/>        } <br/>        else { // 3 <br/>            textField.returnKeyType = .done <br/>        } <br/>    } </span><span id="a133" class="lx ly jf lt b gy md ma l mb mc">}</span></pre><p id="4a34" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和以前一样，我们将<code class="fe me mf mg lt b">textFields</code>数组保存在一个本地常量(1)中，如果我们找不到传递给<code class="fe me mf mg lt b">textField</code> (2)的索引，我们就退出。</p><p id="a4c7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们要做出一个决定:</p><ul class=""><li id="7900" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">如果我们不在最后一个<code class="fe me mf mg lt b">textField</code>上，并且我们在当前字段之后有空字段，那么返回键应该是<code class="fe me mf mg lt b">.next</code> (2)。</li><li id="fd25" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如果我们在最后一个<code class="fe me mf mg lt b">textField</code>，或者当前字段之后的所有字段都被填充，则回车键应为<code class="fe me mf mg lt b">.done</code> (3)。</li></ul><p id="b545" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，点击Next/Return键的逻辑稍微复杂一点，我们最终会明白为什么要使用上面的<code class="fe me mf mg lt b">ArraySlice</code>:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f4c5" class="lx ly jf lt b gy lz ma l mb mc">extension NextTextFieldHandler { </span><span id="0aa4" class="lx ly jf lt b gy md ma l mb mc">    func handleReturnKeyTapped(on textField: UITextField) { <br/>    <!-- -->    let textFields = self.textFields // 1 </span><span id="f27b" class="lx ly jf lt b gy md ma l mb mc">        guard let currentIndex = textFields.index(of: textField) else { return } // 2 </span><span id="6c0c" class="lx ly jf lt b gy md ma l mb mc">        let fieldsAfterCurrent = fields(after: textField) // 3 <br/>        let nextEmptyIndex = fieldsAfterCurrent<br/>            .firstIndex { $0.text?.isEmpty != false } // 4 <br/>            ?? textFields.index(currentIndex, offsetBy: 1, limitedBy: textFields.endIndex - 1) // 5 <br/>            ?? textFields.endIndex - 1 // 6 </span><span id="7eb3" class="lx ly jf lt b gy md ma l mb mc">        let emptyFieldsExistAfterCurrent =	emptyFieldsExist(after: textField) </span><span id="803b" class="lx ly jf lt b gy md ma l mb mc">        if currentIndex == textFields.endIndex - 1 || !emptyFieldsExistAfterCurrent { // 7 <br/>            textField.resignFirstResponder() <br/>        } <br/>        else { // 8 <br/>            textFields[nextEmptyIndex].becomeFirstResponder() <br/>        } <br/>    } </span><span id="5d17" class="lx ly jf lt b gy md ma l mb mc">}</span></pre><p id="bc93" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和往常一样，我们首先将<code class="fe me mf mg lt b">textFields</code>数组保存在一个本地常量(1)中，如果我们找不到传递给<code class="fe me mf mg lt b">textField</code> (2)的索引，我们就退出。然后，我们获取作为切片传入的字段之后的下一个字段(3)，并找到第一个空字段的索引(4)，如果失败，则返回到下一个文本字段(5)，如果也失败，则再次返回到最后一个文本字段(6)。</p><p id="8ccb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在要做另一个决定:</p><ul class=""><li id="35e5" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">如果我们在最后一个<code class="fe me mf mg lt b">textField</code>或当前字段填写后的所有字段，请退出第一响应者(7)。</li><li id="4a51" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">如果我们不在最后一个<code class="fe me mf mg lt b">textField</code>上，并且我们在当前字段之后有空字段，聚焦当前字段(8)之后的第一个空<code class="fe me mf mg lt b">textField</code>。</li></ul><p id="7d13" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是我们需要<code class="fe me mf mg lt b">ArraySlice</code>的地方。让我们看一下前面的例子:</p><ul class=""><li id="384e" class="la lb jf ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><code class="fe me mf mg lt b">textFields = [field1, field2, field3, field4]</code>。</li><li id="84a8" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">我们在<code class="fe me mf mg lt b">field1</code>上，第一个空文本字段是<code class="fe me mf mg lt b">field3</code>，它的索引为2。</li><li id="13b0" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe me mf mg lt b">fields(after: field1)</code>返回<code class="fe me mf mg lt b">[field2, field3, field4]</code>带指标<code class="fe me mf mg lt b">[1, 2, 3]</code>。</li><li id="8b43" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe me mf mg lt b">firstIndex { $0.text?.isEmpty != false }</code> (4)将返回索引<code class="fe me mf mg lt b">2</code>，这是应该的。</li><li id="2c0d" class="la lb jf ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated"><code class="fe me mf mg lt b">textFields[nextEmptyIndex].becomeFirstResponder()</code>将注意力集中到正确的领域，<code class="fe me mf mg lt b">field3</code>。</li></ul><p id="5914" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们不使用切片，<code class="fe me mf mg lt b">fields(after: field)</code>仍然会返回<code class="fe me mf mg lt b">field2, field3, field4]</code>，但是带有索引<code class="fe me mf mg lt b">[0, 1, 2]</code>。此外，我们没有在<code class="fe me mf mg lt b">fields(after:)</code>中使用<code class="fe me mf mg lt b">filter</code>，因为那样会重置索引，使它们从<code class="fe me mf mg lt b">0</code>开始。</p><p id="5a9e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们不使用切片，我们也可以通过在(4)处使用<code class="fe me mf mg lt b">first { $0.text?.isEmpty != false }</code>来找到<code class="fe me mf mg lt b">field3</code>，然后通过调用<code class="fe me mf mg lt b">textFields.index(of: nextField)</code>来找到它的索引，但是我认为切片稍微好一些，因为我们可以编写更容易的回退(5，6)。</p><p id="943e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们如何使用它？实际上很简单:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ef65" class="lx ly jf lt b gy lz ma l mb mc">extension LoginViewController: UITextFieldDelegate, NextTextFieldHandler { </span><span id="46bd" class="lx ly jf lt b gy md ma l mb mc">    var textFields: [UITextField] { // 1 <br/>    <!-- -->    return aStackView.arrangedSubviews<br/>            .compactMap { $0 as? UITextField }<br/>            .filter { !$0.isHidden &amp;&amp; $0.alpha != 0 &amp;&amp; $0.isEnabled } // 2 </span><span id="63fb" class="lx ly jf lt b gy md ma l mb mc">        /* 3 <br/>        if mode == .login { <br/>            return [emailTextField, passwordTextField] <br/>        } <br/>        else { <br/>            return [nameTextField, emailTextField, passwordTextField] <br/>        } <br/>        */ <br/>    } </span><span id="b4f0" class="lx ly jf lt b gy md ma l mb mc">    func textFieldShouldBeginEditing(_ textField: UITextField) -&gt; Bool { <br/>        setupReturnKeyType(for: textField) // 4 </span><span id="69cf" class="lx ly jf lt b gy md ma l mb mc">        return true <br/>    } </span><span id="55dd" class="lx ly jf lt b gy md ma l mb mc">    func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool { <br/>        handleReturnKeyTapped(on: textField) // 5 </span><span id="8a52" class="lx ly jf lt b gy md ma l mb mc">        return true <br/>    } </span><span id="9552" class="lx ly jf lt b gy md ma l mb mc">}</span></pre><p id="8f9e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们设置我们需要的<code class="fe me mf mg lt b">textFields</code>(1)。我们从假想的<code class="fe me mf mg lt b">UIStackView</code> (2)中提取所有文本字段(或者手动返回— 3)，然后从<code class="fe me mf mg lt b">textFieldShouldBeginEditing(:_)</code> (4)中调用<code class="fe me mf mg lt b">setupReturnKeyType(for:)</code>，从<code class="fe me mf mg lt b">textFieldShouldReturn(:_)</code> (5)中调用<code class="fe me mf mg lt b">handleReturnKeyTapped(on:)</code>。</p><p id="5245" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一如既往，我很想知道你的想法，或者是否有任何可以改进的地方。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="2acd" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【rolandleth.com】原载于<a class="ae mi" href="https://rolandleth.com/handling-the-next-button-automatically" rel="noopener ugc nofollow" target="_blank"><em class="mh"/></a><em class="mh">。</em></p></div></div>    
</body>
</html>