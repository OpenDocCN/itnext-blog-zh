<html>
<head>
<title>TypeScript and Turing Completeness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本和图灵完备性</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-and-turing-completeness-ba8ded8f3de3?source=collection_archive---------1-----------------------#2021-09-23">https://itnext.io/typescript-and-turing-completeness-ba8ded8f3de3?source=collection_archive---------1-----------------------#2021-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/48c85ebd0dd41124262b72afdfe3ef01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mbUyBFPP7NcUBvcP"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@siora18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="8e4a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">在整篇文章中，我们会看到</em> <code class="fe lc ld le lf b"><em class="lb">SomeGeneric&lt;...&gt; extends number ? ... : never</em></code> <em class="lb">的一个常见构造。这是因为我们的一些泛型类型的操作方式使得TypeScript无法确定结果是数值型的，尽管我们知道结果是数值型的。如果没有这个检查，我们就不能将</em> <code class="fe lc ld le lf b"><em class="lb">SomeGeneric&lt;...&gt;</em></code> <em class="lb">传递给另一个需要数字的泛型类型。这个类型保护允许我们向类型检查器提供这些信息。下面代码中的任何使用仅仅是对TypeScript的安抚，而不是我们试图构建的逻辑需求。</em></p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="edcf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的一篇文章中，我展示了如何在TypeScript中使用类型系统来产生一个基本的算术系统。一个自然的问题是，从这个系统或基于它的更复杂的系统中，什么是可以计算的，什么是不可以计算的。换句话说:我们的类型系统可以计算或不计算什么？它能计算任何东西吗？还是在某个计算方面有先天限制？</p><p id="50b4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们开始问这类问题，我们就进入了可计算性理论的领域，更具体地说，就是图灵完备性。我不会对“图灵完备性”这个短语的含义进行详尽的讨论，我只会给出一个与文章其余部分相关的高层次概述，并让读者参考另一篇文章<a class="ae jd" href="https://evinsellin.medium.com/what-exactly-is-turing-completeness-a08cc36b26e2" rel="noopener">更深入地讨论这个问题。</a></p><p id="8faa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">概括地说，当我们说一个系统是图灵完备的时，我们的意思是它可以处理任何可以用有限数量的输入在有限数量的步骤中描述的计算。本质上，它足够强大，可以对算法进行一般性编码。这样的系统可以是通用编程语言、图灵机、lambda演算和细胞自动机。指定和执行这种算法的方式可能看起来非常不同，因为我们可以从以下事实中看出，我们所有的示例本身看起来彼此非常不同。</p><p id="495f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数编程语言都被认为是图灵完全的，甚至一些类型系统<a class="ae jd" href="https://sdleffler.github.io/RustTypeSystemTuringComplete/" rel="noopener ugc nofollow" target="_blank">(比如Rust的)</a>也被证明是图灵完全的。那么，TypeScript呢？显然，TypeScript的JavaScript部分是图灵完全的，所以我们将只关注TypeScript的类型系统(因为它不能从JavaScript继承可计算性),并表明它确实也是图灵完全的。</p><p id="2bc7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了证明这一点，我们可以采取三种通用方法:</p><ol class=""><li id="d497" class="ln lo jg kf b kg kh kk kl ko lp ks lq kw lr la ls lt lu lv bi translated">证明任何图灵机都可以翻译成TypeScript。</li><li id="ce17" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ls lt lu lv bi translated">说明TypeScript可以实现一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Universal_Turing_machine" rel="noopener ugc nofollow" target="_blank">通用图灵机</a>。</li><li id="ebc5" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ls lt lu lv bi translated">表明TypeScript可以实现另一个已知的图灵完备系统。</li></ol><p id="c978" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将采取的方法是第三种。我们将通过为称为<a class="ae jd" href="https://esolangs.org/wiki/Smallfuck" rel="noopener ugc nofollow" target="_blank"> Smallfuck </a>的图灵完全深奥编程语言实现一个解释器来做到这一点。</p><h1 id="487f" class="mb mc jg bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">小混蛋</h1><p id="eb36" class="pw-post-body-paragraph kd ke jg kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在架构上，Smallfuck在有限长度的位磁带上运行(初始化为所有的<code class="fe lc ld le lf b">0</code>),能够一次扫描该磁带上的一位。由于这种架构，它的操作非常少；事实上，它的语言中正好有五个符号，其中三个对应于涉及该磁带的动作，而其余两个涉及基于当前位的值有条件地绕过程序的指令集。</p><p id="97e6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些符号是:</p><ul class=""><li id="7476" class="ln lo jg kf b kg kh kk kl ko lp ks lq kw lr la ne lt lu lv bi translated"><code class="fe lc ld le lf b">*</code>:翻转当前位</li><li id="6586" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">&lt;</code>:向左移动一点</li><li id="a8ae" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">&gt;</code>:右移一位</li><li id="f162" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">[</code>:如果当前位为<code class="fe lc ld le lf b">0</code>，则向前跳一位超过匹配的<code class="fe lc ld le lf b">]</code></li><li id="d1c5" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">]</code>:向后跳转到匹配<code class="fe lc ld le lf b">[</code></li></ul><p id="7b00" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当Smallfuck解释器执行<code class="fe lc ld le lf b">&lt;</code>或<code class="fe lc ld le lf b">&gt;</code>操作时，它还必须考虑磁带的边界。当它在磁带的开头时不能向左，当它在结尾时不能向右。任何此类尝试将导致该计划立即终止。</p><p id="816d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将创建一小组有代表性的程序来说明这种语言的各种特性，并且我们需要我们的解释器来正确地执行这些程序。这些方案是:</p><ul class=""><li id="65d2" class="ln lo jg kf b kg kh kk kl ko lp ks lq kw lr la ne lt lu lv bi translated"><code class="fe lc ld le lf b">*&gt;*&gt;*</code>:连续翻转三位，终止于最后翻转的位</li><li id="c0eb" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">&gt;*&gt;*&gt;*[*&lt;]</code>:将连续三位翻转到<code class="fe lc ld le lf b">1</code>，然后在这些位上向后循环，并翻转回<code class="fe lc ld le lf b">0</code></li><li id="990a" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">*[]</code>:将该位翻转到<code class="fe lc ld le lf b">1</code>，然后在两个括号字符之间无限循环——该程序永远不会终止</li><li id="1d5f" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">*[&gt;*]</code>:在磁带上循环，当它超出磁带边界时，在终止之前将每个位翻转到<code class="fe lc ld le lf b">1</code></li><li id="0740" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated"><code class="fe lc ld le lf b">*[&gt;&gt;*[&lt;*]]</code>:翻转一个位，然后进入一个循环，在进入一个子循环以向后翻转位之前绕着磁带移动</li></ul><p id="c247" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了阐明我们自己的解释器正确地评估一个任意的程序所必须采取的步骤，给出一个完整的一步一步的程序评估是有帮助的。为此，我们将选择上面列出的第二个选项(<code class="fe lc ld le lf b">&gt;*&gt;*&gt;*[*&lt;]).</code></p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="7dd8" class="nn mc jg lf b gy no np l nq nr">1. Initialize a tape with the first bit and first instruction "in scope"</span><span id="630a" class="nn mc jg lf b gy ns np l nq nr">      v                                         v<br/>Tape: 00000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="180a" class="nn mc jg lf b gy ns np l nq nr">2. Evaluate `&gt;` and move to next instruction</span><span id="e7fb" class="nn mc jg lf b gy ns np l nq nr">       v                                         v<br/>Tape: 00000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="083c" class="nn mc jg lf b gy ns np l nq nr">3. Evaluate `*` and move to next instruction</span><span id="f7e7" class="nn mc jg lf b gy ns np l nq nr">       v                                          v<br/>Tape: 01000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="9b8e" class="nn mc jg lf b gy ns np l nq nr">4. Evaluate `&gt;` and move to next instruction</span><span id="7437" class="nn mc jg lf b gy ns np l nq nr">        v                                          v<br/>Tape: 01000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="4792" class="nn mc jg lf b gy ns np l nq nr">5. Evaluate `*` and move to next instruction</span><span id="6b57" class="nn mc jg lf b gy ns np l nq nr">        v                                           v<br/>Tape: 01100000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="90bf" class="nn mc jg lf b gy ns np l nq nr">6. Evaluate `&gt;` and move to next instruction</span><span id="fae7" class="nn mc jg lf b gy ns np l nq nr">         v                                           v<br/>Tape: 01100000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="b576" class="nn mc jg lf b gy ns np l nq nr">7. Evaluate `*` and move to next instruction</span><span id="4de0" class="nn mc jg lf b gy ns np l nq nr">         v                                            v<br/>Tape: 01110000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="065a" class="nn mc jg lf b gy ns np l nq nr">8. Evaluate `[`. Since the current bit is not `0`, move to next instruction</span><span id="4053" class="nn mc jg lf b gy ns np l nq nr">         v                                             v<br/>Tape: 01110000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="2ee7" class="nn mc jg lf b gy ns np l nq nr">9. Evaluate `*` and move to next instruction</span><span id="768a" class="nn mc jg lf b gy ns np l nq nr">         v                                              v<br/>Tape: 01100000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="0aa4" class="nn mc jg lf b gy ns np l nq nr">10. Evaluate `&lt;` and move to next instruction</span><span id="872f" class="nn mc jg lf b gy ns np l nq nr">        v                                                v<br/>Tape: 01100000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="3593" class="nn mc jg lf b gy ns np l nq nr">11. Evaluate `]` and move to matching `[`</span><span id="d4af" class="nn mc jg lf b gy ns np l nq nr">        v                                             v<br/>Tape: 01100000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="b670" class="nn mc jg lf b gy ns np l nq nr">12. Evaluate `[`. Since the current bit is not `0`, move to next instruction</span><span id="e2dd" class="nn mc jg lf b gy ns np l nq nr">        v                                              v<br/>Tape: 01100000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="63ac" class="nn mc jg lf b gy ns np l nq nr">13. Evaluate `*` and move to next instruction</span><span id="10b8" class="nn mc jg lf b gy ns np l nq nr">        v                                               v<br/>Tape: 01000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="9c26" class="nn mc jg lf b gy ns np l nq nr">14. Evaluate `&lt;` and move to next instruction</span><span id="99ab" class="nn mc jg lf b gy ns np l nq nr">       v                                                 v<br/>Tape: 01000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="0aee" class="nn mc jg lf b gy ns np l nq nr">15. Evaluate `]` and move to matching `[`</span><span id="f72a" class="nn mc jg lf b gy ns np l nq nr">       v                                              v<br/>Tape: 01000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="4cf9" class="nn mc jg lf b gy ns np l nq nr">16. Evaluate `[`. Since the current bit is not `0`, move to next instruction</span><span id="055d" class="nn mc jg lf b gy ns np l nq nr">       v                                               v<br/>Tape: 01000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="14b1" class="nn mc jg lf b gy ns np l nq nr">17. Evaluate `*` and move to next instruction</span><span id="dd86" class="nn mc jg lf b gy ns np l nq nr">       v                                                v<br/>Tape: 00000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="ae33" class="nn mc jg lf b gy ns np l nq nr">18. Evaluate `&lt;` and move to next instruction</span><span id="dca4" class="nn mc jg lf b gy ns np l nq nr">      v                                                  v<br/>Tape: 00000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="47ce" class="nn mc jg lf b gy ns np l nq nr">19. Evaluate `]` and move to matching `[`</span><span id="3caa" class="nn mc jg lf b gy ns np l nq nr">      v                                               v<br/>Tape: 00000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span><span id="9669" class="nn mc jg lf b gy ns np l nq nr">20. Evaluate `[`. Since the current bit is `0`, move to next instruction after matching `]`</span><span id="b220" class="nn mc jg lf b gy ns np l nq nr">      v                                                   v<br/>Tape: 00000000                    Instructions: &gt;*&gt;*&gt;*[*&lt;]</span></pre><p id="88f5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">20步后，我们的程序消耗完所有指令(由试图查看一条不存在的指令的指令指针指示)并暂停。然而，停止并不是图灵完备性的必要条件，我们可以使用同样的逐步技术来证明我们的第三个程序(<code class="fe lc ld le lf b">*[]</code>)永远不会停止。</p><h1 id="64bf" class="mb mc jg bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">Smallfuck解释器</h1><h2 id="bf8d" class="nn mc jg bd md nt nu dn mh nv nw dp ml ko nx ny mp ks nz oa mt kw ob oc mx od bi translated">预赛</h2><p id="fbb1" class="pw-post-body-paragraph kd ke jg kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在我们开始实现解释器的内部之前，反思一下上面的评估，了解一下我们想要构建的东西，会对我们有所帮助。</p><p id="5423" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，为了正确评估Smallfuck程序，我们需要跟踪四条信息:</p><ul class=""><li id="ca04" class="ln lo jg kf b kg kh kk kl ko lp ks lq kw lr la ne lt lu lv bi translated">磁带的状态</li><li id="3a51" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated">磁带上的哪个位当前在范围内</li><li id="28d5" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated">指令集</li><li id="72fb" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated">当前正在执行哪条指令</li></ul><p id="f8d3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很自然地使用元组来表示磁带和指令。这允许我们将指向当前位和指令的指针表示为数字。</p><p id="8e60" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这四条信息组成了我们的执行状态，我们的主要任务是实现上面列出的五个动作中的每一个。但是，如果没有一些实用程序操作作为基础，这些操作都无法实现。因此，我们将首先设置这些先决条件，并在它们的基础上构建核心解释器。这些是我们需要支持的初步行动:</p><ul class=""><li id="d8dc" class="ln lo jg kf b kg kh kk kl ko lp ks lq kw lr la ne lt lu lv bi translated">递增一个数字(一次或直到满足终止条件)</li><li id="c7e7" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated">递减一个数字(一次或直到满足终止条件)</li><li id="6e3b" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated">分割数组</li><li id="f0e5" class="ln lo jg kf b kg lw kk lx ko ly ks lz kw ma la ne lt lu lv bi translated">翻转一点(既包括一般翻转，也包括磁带上特定位置的翻转)</li></ul><p id="52e0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">递增/递减数字与我们在上一篇关于实现算术的文章中所涉及的非常相似，因此我们将把它们放在这里，不做过多解释。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="5ae2" class="nn mc jg lf b gy no np l nq nr">type ArrayFromNumber&lt;<br/>    N extends number, <br/>    A extends any[] = []<br/>&gt; = A['length'] extends N ? A : ArrayFromNumber&lt;N, [...A, any]&gt;;</span><span id="a463" class="nn mc jg lf b gy ns np l nq nr">type Increment&lt;T extends number&gt; = <br/>    [...ArrayFromNumber&lt;T&gt;, any]['length'];</span><span id="f78d" class="nn mc jg lf b gy ns np l nq nr">type Decrement&lt;T extends number&gt; = <br/>    ArrayFromNumber&lt;T&gt; extends [...(infer U), any] <br/>        ? U['length'] <br/>        : never;</span></pre><p id="5cb6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这处理了执行已知数量的递增/递减操作的简单情况，但没有处理任意数量的情况。毕竟，如果不简单地扫描中间的每个字符，就无法判断一个<code class="fe lc ld le lf b">]</code>比它匹配的<code class="fe lc ld le lf b">[</code>多多少个字符。因此，我们将编写一个通用的倒带和快进操作。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="2ed5" class="nn mc jg lf b gy no np l nq nr">type Rewind&lt;<br/>    Arr extends any[],<br/>    I extends number<br/>&gt; = Arr[I] extends '[' ? I : Rewind&lt;Arr, Decrement&lt;I&gt;&gt;;</span><span id="89ed" class="nn mc jg lf b gy ns np l nq nr">type FastForward&lt;<br/>    Arr extends any[],<br/>    I extends number<br/>&gt; = Arr[I] extends ']'<br/>    ? Increment&lt;I&gt;<br/>    : Increment&lt;I&gt; extends number<br/>        ? FastForward&lt;Arr, Increment&lt;I&gt;&gt;<br/>        : never;</span></pre><p id="4fb9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两种类型接受一个数组(这将是我们的指令集)和一个指向数组中当前指令的索引。接下来会发生的是，我们将询问在<code class="fe lc ld le lf b">Arr[I]</code>的任何指令是否等于终止字符，如果是，我们返回索引号。如果没有，我们将索引移动一个位置，再试一次。</p><p id="681e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，<code class="fe lc ld le lf b">FastForward</code>给出了一个比多一个<em class="lb">的数字，它终止于该字符的位置。因此，如果它将程序<code class="fe lc ld le lf b">[***]&gt;*</code>从位置1 (= <code class="fe lc ld le lf b">[</code>)推进到位置5 (= <code class="fe lc ld le lf b">]</code>)，它将返回位置6 (= <code class="fe lc ld le lf b">&gt;</code>)。这是因为如果我们被给定位置5，我们的解释器的下一次执行将把我们倒回到开始的括号，我们将在两者之间无限循环，而不是像预期的那样跳出循环。</em></p><p id="0797" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，这两种类型还不足以满足我们的需求。Smallfuck程序可能有嵌套循环(如<code class="fe lc ld le lf b">*[&gt;*[&gt;*]&gt;*]*</code>)，如果我们使用刚刚构建的内容从第一个<code class="fe lc ld le lf b">[</code>前进到其匹配的<code class="fe lc ld le lf b">]</code>，我们将前进到<code class="fe lc ld le lf b">]</code>的第一个出现的<em class="lb">，而不是匹配</em>出现的<em class="lb">。因此，我们将从位置2的起点前进到位置8，而不是位置11。这意味着我们需要增加我们的<code class="fe lc ld le lf b">Rewind</code>和<code class="fe lc ld le lf b">FastForward</code>类型来处理深度。</em></p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="d626" class="nn mc jg lf b gy no np l nq nr">type Rewind&lt;<br/>    Arr extends any[],<br/>    I extends number,<br/>    Depth extends number = 0<br/>&gt; = Arr[I] extends '['<br/>    ? Depth extends 0<br/>        ? I<br/>        : Rewind&lt;Arr, Decrement&lt;I&gt;, Decrement&lt;Depth&gt;&gt;<br/>    : Arr[I] extends ']'<br/>        ? Increment&lt;Depth&gt; extends number<br/>            ? Rewind&lt;Arr, Decrement&lt;I&gt;, Increment&lt;Depth&gt;&gt;<br/>            : never<br/>        : Rewind&lt;Arr, Decrement&lt;I&gt;, Depth&gt;;</span><span id="3cfd" class="nn mc jg lf b gy ns np l nq nr">type FastForward&lt;<br/>    Arr extends any[],<br/>    I extends number,<br/>    Depth extends number = 0<br/>&gt; = Arr[I] extends ']'<br/>    ? Depth extends 0<br/>        ? Increment&lt;I&gt;<br/>        : Increment&lt;I&gt; extends number<br/>            ? FastForward&lt;Arr, Increment&lt;I&gt;, Decrement&lt;Depth&gt;&gt;<br/>            : never<br/>    : Arr[I] extends '['<br/>        ? Increment&lt;Depth&gt; extends number<br/>            ? Increment&lt;I&gt; extends number<br/>                ? FastForward&lt;Arr, Increment&lt;I&gt;, Increment&lt;Depth&gt;&gt;<br/>                : never<br/>            : never<br/>        : Increment&lt;I&gt; extends number<br/>            ? FastForward&lt;Arr, Increment&lt;I&gt;, Depth&gt;<br/>            : never;</span></pre><p id="b078" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，计算深度增加了我们操作的复杂性。然而，总的要点是这样的:当遍历命令数组时，我们寻找一个特定的符号来终止。如果我们看到那个符号，我们必须确保我们是深度为0(这表明这个符号是适当的匹配符号)。如果我们在深度0不是T21，我们继续移动，但是我们从深度减去1。如果所有的括号都适当地平衡，当我们遇到一个终止符号时，我们将最终到达深度0。然而，如果我们遇到了终止符号的反义词，我们就进入了一个嵌套循环，因此我们需要将深度增加1，以免在遇到结束这个嵌套循环的终止符号时过早停止。</p><p id="7ee2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为TypeScript的类型系统中没有赋值操作，所以我们不能做类似于<code class="fe lc ld le lf b">Arr[I] = SomeType</code>的事情。如果我们想在数组的某个索引<code class="fe lc ld le lf b">I</code>处改变类型，我们需要创建一个全新的数组，其中<code class="fe lc ld le lf b">I</code>左边的所有内容保持不变，第<code class="fe lc ld le lf b">I</code>个位置更新，然后<code class="fe lc ld le lf b">I</code>右边的所有内容保持不变。这种限制使得修改数组类型的方式变得冗长，但是使用<code class="fe lc ld le lf b">Slice</code>实用程序，我们可以使它变得优雅。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="524f" class="nn mc jg lf b gy no np l nq nr">type Slice&lt;<br/>    T extends any[],<br/>    S extends number = 0,<br/>    E extends number = T['length'],<br/>    A extends any[] = []<br/>&gt; = S extends E<br/>    ? A<br/>    : Increment&lt;S&gt; extends number<br/>        ? Slice&lt;T, Increment&lt;S&gt;, E, [...A, T[S]]&gt;<br/>        : never;</span></pre><p id="cd17" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">Slice</code>将原始数组<code class="fe lc ld le lf b">T</code>、起始索引<code class="fe lc ld le lf b">S</code>、结束索引<code class="fe lc ld le lf b">E</code>和累积数组<code class="fe lc ld le lf b">A</code>作为参数。<code class="fe lc ld le lf b">Slice</code>然后将检查我们的开始索引是否等于我们的结束索引，如果是，则返回累积数组。否则，它增加我们的起始位置，将<code class="fe lc ld le lf b">T[S]</code>处的项目添加到我们的累加器数组，并使用那些更新的值再次递归检查。</p><p id="ce83" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的最简单的动作之一就是翻转一下。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="365f" class="nn mc jg lf b gy no np l nq nr">type FlipBit&lt;B extends Bit&gt; = B extends 0 ? 1 : 0;</span></pre><p id="2058" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，要在磁带的任何位置翻转一点，我们只需利用get上面的<code class="fe lc ld le lf b">Slice</code>操作</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="ad6f" class="nn mc jg lf b gy no np l nq nr">type FlipBitAtPos&lt;T extends Tape, P extends number&gt; =<br/>    Increment&lt;P&gt; extends number<br/>        ? [<br/>            ...Slice&lt;T, 0, P&gt;, <br/>            FlipBit&lt;T[P]&gt;,<br/>            ...Slice&lt;T, Increment&lt;P&gt;&gt;<br/>          ]<br/>        : never;</span></pre><h2 id="d07e" class="nn mc jg bd md nt nu dn mh nv nw dp ml ko nx ny mp ks nz oa mt kw ob oc mx od bi translated">编写解释器</h2><p id="3c46" class="pw-post-body-paragraph kd ke jg kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">现在，是时候开始建立起那些起重要作用的部分了。</p><p id="7759" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种类型将作为解释器的必要构件:</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="99d0" class="nn mc jg lf b gy no np l nq nr">type Command = '&gt;' | '&lt;' | '*' | '[' | ']'<br/>type Bit = 0 | 1;<br/>type Tape = Bit[];</span></pre><p id="33c4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们设计解释器的方式是，我们希望它接收一个由<code class="fe lc ld le lf b">Command</code>组成的数组，我们希望在给定的<code class="fe lc ld le lf b">0</code>磁带上执行该数组。评估的每一步都将操作磁带(或我们在磁带上的位置),并将指针移动到下一个要执行的命令。每个评估的结果将是我们的命令和磁带的组合状态，我们将递归地调用我们的评估器，直到我们到达评估必须停止的点。</p><p id="c86c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们的最后一块积木将会是</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="b251" class="nn mc jg lf b gy no np l nq nr">type ExecutionState = [<br/>    commands: Command[],<br/>    commandPosition: number,<br/>    tape: Tape,<br/>    tapePosition: number<br/>];</span><span id="1986" class="nn mc jg lf b gy ns np l nq nr">type GetCommands&lt;T extends [any, ...any[]]&gt; = T[0];<br/>type GetCommandPtr&lt;T extends [any, any, ...any[]]&gt; = T[1];<br/>type GetTape&lt;T extends [any, any, any, ...any[]]&gt; = T[2];<br/>type GetTapePtr&lt;T extends [any, any, any, any, ...any[]]&gt; = T[3];</span></pre><p id="fc89" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe lc ld le lf b">ExecutionState</code>是一个4元组，所以我们也有一些方便的getters来提取该元组的特定部分。</p><p id="94e2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些，让我们构建解释器，从面向用户的入口点开始，向后工作到执行评估的机制。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="1297" class="nn mc jg lf b gy no np l nq nr">type Smallfuck&lt;<br/>    CS extends Command[],<br/>    T extends Tape<br/>&gt; = Evaluate&lt;[CS, 0, T, 0]&gt;;</span></pre><p id="d34c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">Smallfuck</code>将获取一个要评估的命令列表和一个固定长度的磁带，然后构建一个初始<code class="fe lc ld le lf b">ExecutionState</code>以传入<code class="fe lc ld le lf b">Evaluate</code>。</p><p id="ab4d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本身将充当我们的程序运行程序。它将获取程序的当前状态，执行该程序，获取该执行的结果，并无限地再次执行<em class="lb">直到最后一条指令被执行。<code class="fe lc ld le lf b">Evaluate</code>会是什么样子</em></p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="19ce" class="nn mc jg lf b gy no np l nq nr">type Evaluate&lt;S extends ExecutionState&gt; = <br/>    GetCommands&lt;S&gt;[GetCommandPtr&lt;S&gt;] extends undefined<br/>        ? S<br/>        : Execute&lt;<br/>              GetCommands&lt;S&gt;,<br/>              GetCommandPtr&lt;S&gt;,<br/>              GetTape&lt;S&gt;,<br/>              GetTapePtr&lt;S&gt;<br/>          &gt; extends ExecutionState<br/>              ? Evaluate&lt;<br/>                    Execute&lt;<br/>                        GetCommands&lt;S&gt;,<br/>                        GetCommandPtr&lt;S&gt;,<br/>                        GetTape&lt;S&gt;,<br/>                        GetTapePtr&lt;S&gt;<br/>                    &gt;<br/>                &gt;<br/>              : never;</span></pre><p id="5784" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">递归类型的基本情况是，要执行的命令的索引超出了命令列表的范围。这代表了我们的解释器在上面第20步中所处的情况，它试图读取一个根本不存在的命令。</p><p id="804e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们的<code class="fe lc ld le lf b">Execute</code>类型相当复杂，TypeScript不能正确地推断出它的返回类型是一个<code class="fe lc ld le lf b">ExecutionState</code>类型，所以我们必须添加<code class="fe lc ld le lf b">extends ExecutionState</code>检查，原因与我们有时必须进行本文开头讨论的<code class="fe lc ld le lf b">extends number</code>检查相同。</p><p id="97d7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lc ld le lf b">Execute</code>类型将根据每个命令对我们的<code class="fe lc ld le lf b">ExecutionState</code>进行适当的修改。本质上，它所要做的是获取当前命令，并通过一系列case语句对我们的执行状态进行适当的更改，然后返回更新后的版本。</p><p id="19f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命令<code class="fe lc ld le lf b">*</code>、<code class="fe lc ld le lf b">&lt;</code>、<code class="fe lc ld le lf b">&gt;</code>和<code class="fe lc ld le lf b">]</code>所需的操作都相当简单，因此我们将列出部分<code class="fe lc ld le lf b">Execute</code>类型，然后讨论对<code class="fe lc ld le lf b">[</code>命令的特殊处理。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="bc54" class="nn mc jg lf b gy no np l nq nr">type Execute&lt;<br/>    CS extends Command[],<br/>    CPos extends number,<br/>    T extends Tape,<br/>    TPos extends number<br/>&gt; =<br/>    CS[CPos] extends '*'<br/>        ? [CS, Increment&lt;CPos&gt;, FlipBitAtPos&lt;T, TPos&gt;, TPos]<br/>        :<br/>    CS[CPos] extends '&gt;'<br/>        ? [CS, Increment&lt;CPos&gt;, T, Increment&lt;TPos&gt;]<br/>        :<br/>    CS[CPos] extends '&lt;'<br/>        ? [CS, Increment&lt;CPos&gt;, T, Decrement&lt;TPos&gt;]<br/>        :<br/>    CS[CPos] extends ']'<br/>        ? [CS, Rewind&lt;CS, Decrement&lt;CPos&gt;&gt;, T, TPos]<br/>        :<br/>    never;</span></pre><p id="de22" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们看到一个命令，我们总是需要增加指向下一个命令的命令指针。其他操作只是简单地执行简单的动作，在磁带上的某一点翻转一点，增加/减少磁带的指针，或者返回命令列表以找到匹配的<code class="fe lc ld le lf b">[</code>命令。</p><p id="4c7a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们对<code class="fe lc ld le lf b">&gt;</code>和<code class="fe lc ld le lf b">&lt;</code>的实现并不完整。请记住，因为我们的磁带是有限的，所以有可能试图超越它的界限。在这种情况下，我们的计划应该停止。我们需要用一个检查来增加这两个命令，看看我们是否将要越界，如果是，立即将我们的命令指针移到越界，而不改变磁带的任何内容。这将触发<code class="fe lc ld le lf b">Evaluate</code>类型中止任何更多的执行。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="a4f6" class="nn mc jg lf b gy no np l nq nr">type Execute&lt;<br/>    CS extends Command[],<br/>    CPos extends number,<br/>    T extends Tape,<br/>    TPos extends number<br/>&gt; =<br/>    CS[CPos] extends '*'<br/>        ? [CS, Increment&lt;CPos&gt;, FlipBitAtPos&lt;T, TPos&gt;, TPos]<br/>        :<br/>    CS[CPos] extends '&gt;'<br/>        ? TPos extends Decrement&lt;T['length']&gt; <br/>            ? [CS, CS['length'], T, TPos] <br/>            : [CS, Increment&lt;CPos&gt;, T, Increment&lt;TPos&gt;]<br/>        :<br/>    CS[CPos] extends '&lt;'<br/>        ? TPos extends 0<br/>            ? [CS, CS['length'], T, TPos]<br/>            : [CS, Increment&lt;CPos&gt;, T, Decrement&lt;TPos&gt;]<br/>        :<br/>    CS[CPos] extends ']'<br/>        ? [CS, Rewind&lt;CS, Decrement&lt;CPos&gt;&gt;, T, TPos]<br/>        :<br/>    never;</span></pre><p id="28ce" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个命令(我们的<code class="fe lc ld le lf b">[</code>指令)是一个条件快进。所以我们必须实现逻辑来确定解释器是一直跳到匹配的<code class="fe lc ld le lf b">]</code>命令，还是直接跳到下一个命令。我们称之为我们的<code class="fe lc ld le lf b">MaybeFastForward</code>类型。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="d137" class="nn mc jg lf b gy no np l nq nr">type MaybeFastForward&lt;<br/>    CS extends Command[],<br/>    CPos extends number,<br/>    T extends Tape,<br/>    P extends number<br/>&gt; = T[P] extends 0 ? FastForward&lt;CS, CPos&gt; : CPos;</span></pre><p id="2f08" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们当前的位是<code class="fe lc ld le lf b">0</code>，我们不进入循环，所以需要前进通过我们匹配的<code class="fe lc ld le lf b">]</code>。否则我们<em class="lb"> do </em>进入循环，并转到该循环中的第一个命令。注意，如果我们进入循环，我们只是返回<code class="fe lc ld le lf b">CPos</code>，而不是增加它。我们将在下面看到原因。</p><p id="a50e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终的<code class="fe lc ld le lf b">Execute</code>型号将是</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="9c04" class="nn mc jg lf b gy no np l nq nr">type Execute&lt;<br/>    CS extends Command[],<br/>    CPos extends number,<br/>    T extends Tape,<br/>    TPos extends number<br/>&gt; =<br/>    CS[CPos] extends '*'<br/>        ? [CS, Increment&lt;CPos&gt;, FlipBitAtPos&lt;T, TPos&gt;, TPos]<br/>        :<br/>    CS[CPos] extends '&gt;'<br/>        ? TPos extends Decrement&lt;T['length']&gt;<br/>            ? [CS, CS['length'], T, TPos]<br/>            : [CS, Increment&lt;CPos&gt;, T, Increment&lt;TPos&gt;]<br/>        :<br/>    CS[CPos] extends '&lt;'<br/>        ? TPos extends 0<br/>            ? [CS, CS['length'], T, TPos]<br/>            : [CS, Increment&lt;CPos&gt;, T, Decrement&lt;TPos&gt;]<br/>        :<br/>    CS[CPos] extends ']'<br/>        ? [CS, Rewind&lt;CS, Decrement&lt;CPos&gt;&gt;, T, TPos]<br/>        :<br/>    CS[CPos] extends '['<br/>        ? Increment&lt;CPos&gt; extends number<br/>            ? [<br/>                  CS,<br/>                  MaybeFastForward&lt;CS, Increment&lt;CPos&gt;, T, TPos&gt;,<br/>                  T,<br/>                  TPos<br/>              ]<br/>            : never<br/>        : never;</span></pre><p id="2d88" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在<code class="fe lc ld le lf b">[</code>的实现中看到，当我们将<code class="fe lc ld le lf b">CPos</code>传递给<code class="fe lc ld le lf b">MaybeFastForward</code>时，我们已经增加了它的值(因此我们从那个动作中返回了它，没有改变)。这是因为我们如何追踪深度；如果我们从刚刚执行的同一个命令(<em class="lb">即</em>)开始快进。我们会立即给我们的日常工作增加一个深度。这将导致快进操作跳过它应该寻找的实际匹配括号<code class="fe lc ld le lf b">]</code>。</p><h2 id="28ed" class="nn mc jg bd md nt nu dn mh nv nw dp ml ko nx ny mp ks nz oa mt kw ob oc mx od bi translated">测试解释器</h2><p id="3d5d" class="pw-post-body-paragraph kd ke jg kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">不幸的是，当评估一个程序时，不可能看到TypeScript采取的一步一步的动作，但是我们至少可以将我们解释器的磁带输出与另一个解释器的进行比较。我们将使用上面列出的程序，或者比较磁带的最终状态(对于那些终止的程序)，或者确定两者是否都产生某种错误/无限循环(对于那些不会终止的程序)。</p><p id="fae2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用作比较的外部解释器将是<a class="ae jd" href="https://gist.github.com/cnexans/45276bf6f8e1954ed14de6b5e8ad71c2" rel="noopener ugc nofollow" target="_blank">这个</a>(有趣的是用TypeScript编写——只是不完全在它自己的类型系统中)。它公开了一个名为<code class="fe lc ld le lf b">interpreter</code>的函数，该函数为初始磁带获取一串命令和一串零。当我们的解释器返回整个执行上下文时，我们可以通过用一个<code class="fe lc ld le lf b">GetTape&lt;...&gt;</code>调用包装每个<code class="fe lc ld le lf b">Smallfuck</code>调用来轻松地获取磁带进行评估。</p><pre class="nf ng nh ni gt nj lf nk nl aw nm bi"><span id="bfd1" class="nn mc jg lf b gy no np l nq nr">/**<br/> * Evaluate '<!-- -->*&gt;*&gt;*' on tape 000000<br/> */<br/>type Test1 = GetTape&lt;<br/>    Smallfuck&lt;<br/>        [<!-- -->'*', '&gt;', '*', '&gt;', '*'],<br/>        [0, 0, 0, 0, 0, 0]<br/>    &gt;<br/>&gt;; // [1, 1, 1, 0, 0, 0]</span><span id="5642" class="nn mc jg lf b gy ns np l nq nr">const test1 = interpreter('<!-- -->*&gt;*&gt;*', '000000'); // '111000'</span><span id="8c58" class="nn mc jg lf b gy ns np l nq nr">/**<br/> * Evaluate '*[]<!-- -->' on tape 000000<br/> */<br/>type Test2 = GetTape&lt;<br/>    Smallfuck&lt;<br/>        ['*', '[', ']'],<br/>        [0, 0, 0, 0, 0, 0]<br/>    &gt;<br/>&gt;; // Type instantiation is excessively deep and possibly infinite.</span><span id="44e0" class="nn mc jg lf b gy ns np l nq nr">const test2 = interpreter('*[]', '000000'); // Environment hangs</span><span id="5b08" class="nn mc jg lf b gy ns np l nq nr">/**<br/> * Evaluate '*[&gt;*]<!-- -->' on tape 000000<br/> */<br/>type Test3 = GetTape&lt;<br/>    Smallfuck&lt;<br/>        ['*', '[', '&gt;', '*', ']'],<br/>        [0, 0, 0, 0, 0, 0]<br/>    &gt;<br/>&gt;; // [1, 1, 1, 1, 1, 1]</span><span id="d4c6" class="nn mc jg lf b gy ns np l nq nr">const test3 = interpreter('*[&gt;*]<!-- -->', '000000'); // '<!-- -->111111<!-- -->'</span><span id="f1c1" class="nn mc jg lf b gy ns np l nq nr">/**<br/> * Evaluate '&gt;*&gt;*&gt;*[*&lt;]<!-- -->' on tape 000000<br/> */<br/>type Test4 = GetTape&lt;<br/>    Smallfuck&lt;<br/>        ['&gt;', '*', '&gt;', '*', '&gt;', '*', '[', '*', '&lt;', ']'],<br/>        [0, 0, 0, 0, 0, 0]<br/>    &gt;<br/>&gt;; // [0, 0, 0, 0, 0, 0]</span><span id="b172" class="nn mc jg lf b gy ns np l nq nr">const test4 = interpreter('&gt;*&gt;*&gt;*[*&lt;]<!-- -->', '000000'); // '000000'</span><span id="c9a1" class="nn mc jg lf b gy ns np l nq nr">/**<br/> * Evaluate '*[&gt;&gt;*[&lt;*]]<!-- -->' on tape 000000<br/> */<br/>type Test5 = GetTape&lt;<br/>    Smallfuck&lt;<br/>        [<!-- -->'*', '[', '&gt;', '&gt;', '*', '[', '&lt;', '*', ']', ']'<!-- -->],<br/>        [0, 0, 0, 0, 0, 0]<br/>    &gt;<br/>&gt;; // [0, 1, 1, 0, 0, 0]</span><span id="ff01" class="nn mc jg lf b gy ns np l nq nr">const test5 = interpreter('*[&gt;&gt;*[&lt;*]]<!-- -->', '000000'); // '011000'</span></pre><h1 id="d826" class="mb mc jg bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">评论</h1><p id="8682" class="pw-post-body-paragraph kd ke jg kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们可以看到，对于上面的示例程序，我们的解释器的输出与另一个解释器的输出相匹配。虽然这与证明这两者总是给出相同的输出相差甚远，但它给了我们一些验证，证明我们已经正确地编写了我们的解释器。幸运的是，Smallfuck是一种简单的语言，所以如果我们能让它为一些说明该语言主要特征的程序工作，我们就不太可能找到一个更复杂的情况来破坏解释器。</p><p id="674a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对Smallfuck的实际实现完全是在TypeScript的类型系统中，这意味着我们永远无法确定任何<code class="fe lc ld le lf b">Type instantiation is excessively deep and possibly infinite.</code>错误是否表示一个无限循环的程序。由于递归类型对于类型检查器来说有性能问题，因此TypeScript有严格的递归限制，防止计算非常递归的类型。在我们的情况下，这意味着一旦达到递归极限，实际上无限的程序<em class="lb">和足够复杂的</em>程序都将终止。</p><p id="058f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文从TypeScript是否有图灵完整类型系统的问题开始。我们已经通过Smallfuck解释器的实现表明答案是肯定的，尽管有一些限制。</p><p id="b126" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于初学者来说，TypeScript有一个递归限制，因此我们永远无法评估复杂的程序。此外，即使没有这种限制，TypeScript也有与图灵机中不存在的任何其他编程语言相同的限制。有限的内存和身体寿命使得它不可能执行一个需要一百万年才能完成的程序。然而，这些限制是<em class="lb">实现</em>的限制，并不是我们的解释器的逻辑所固有的，所以如果我们可以取消它们，我们就会有一个真正的<em class="lb">图灵完整类型系统。</em></p><p id="ae54" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们证明TypeScript可以计算任何东西的一个有趣的特征是，它的计算框架看起来一点也不像我们在以前的文章中实现的算术系统(它执行我们习惯看到的更多“函数”计算)。这是因为“计算”实际上表示一个抽象的术语，并且有许多不同的具体方法来计算同一事物。我们的解释器采用这些具体方法中的一种(在我们的例子中，类似于图灵机)并赋予它实体；如果我们决定实现递归函数或lambda演算，它看起来会有所不同。</p><p id="ecfd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也不是在TypeScript中证明图灵完备性的唯一尝试。几年前有一个更早的尝试来证明这一点。我们的证明看起来一点也不像那个，因为我们在我们的证明中利用了五年前不可用的TypeScript的最新功能。</p><p id="c487" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个链接，链接到完全实现了解释器的<a class="ae jd" href="https://www.typescriptlang.org/play?ssl=25&amp;ssc=87&amp;pln=9&amp;pc=1#code/PTBQIAgWh2og4gUwHZIE4EMA2ECuALgJbZHFIDO0M4YBAngA5IQCC6W9AYugPYC2AOTz8ARhgA8giEgAeBVABMqKEePQAaNjPlKqmFPQDaAXQgBeCKYB8FtkYDk2VAHMCACwdm5ClMojSAPzaAFxsHJjcfEJqkoJaRgB0yaxaBvQm1gDcoKAMzBAAkigAxuhI-KgEEgAqOr7+qmIYtpZJKRFRAsLN6LXWaYYmjs4obp4mOfksACJIZRVVtfV6EE3qreGcPN2xfTW2PqvtiQAURCgAZhgQAKoAlIMZEMG3I64eXhBhaABuGDk8kwWAAlJAAdwuigk7HQKz8+kMpi0hXhjT2WjmjA8aJUezsAAZNrCjIVvLoERAHI5QBA6S8IFicUdKQSGaiwmDIX4YRxMfNypUUNVCgNGQLFsKJEz3NZrLT6WESWTcVSTA4FfT6cFigshdUZYcKejegyuVDeZpxXqlqKUaVBUtDbYfkh-uhNVrvhBzTzYfybVK7eLsbLAdMIFxMBQCFxeOhwZh0NDYar0siiqr1hh+aGs-jLES7MryQ0qF4NVrgjLVQTPVWig7JSL5V7FY3Ay386bglGY3GE0mU3yO46g2K5p3pUhQ3LvX8MJ6lRxSaXVtTK232U39dPZ931PWtzqd7ajWW1nsj1vtZHo7H44nk5b7VPg7qxwaZx45deb-O3UXf92wXD0bzCD9mwkUUDxuXt7wHJ9hytSDd2DQ0APdcNgQgABlUgSiQZYWX8dMTC0XDYLhQstAAUSouwaneMZPnI7QSMRYwzDaTI7EojiIFoz1glYJdRyg3Dz1WbM4WCfCiEI2pX0-CRJLohJkkSVIICY3CTF410sNyCMuFIRgACEyAkczVUsghNhsgS2WCABGb0CWwgpTKICyyFYAgAAVeAoYjjSoGpMGYLQAqozZUKWAKpMpGThKsTT5MUmotAJaKxW83zqiYgLMi0dKCKIrLxN3RLrBMMTQMBEBaGoOB4Fw-gcGwS48BKABrfBiFIcgqFgWggQKABhAQOr8OwHGsBwIAAHypCRFpWhwACp1qpRxlrVDUIzswl9pcqYcIigpLDs0xzoKWjZHmQgiF4FBcIITAFDsIxPRKaaDGUMIpv4GbFGRX7-r8IKKDIF6UB+DFPQ+5gwkupANCRyKkGh2HXoR3pQEmYycOQAhgdBkK6gEox0lK5IyN4ywmIJImI1J8mAYCgh9lVGnDCeOnEgZzYmJc1mSaQAg0dCi8+foAWIFpiBNOFxijAAJnFgpSbRrmeeppXDf5xXjZVpF9JFowAGYifGlgAFlInEPsH0HZ9PQm-iwogDm-HBrUJuhqiMa1KnvbRkP6RigSUst4rawZF3EKHCRPa0QPgpdH3ocasBIFamA8I67Aup6-qLgUdBGHKSuWrGiMHqehRU69i9fbBtiM6oGOMR01UI50oOe96VoPdwowu7XSktsW4IJ9w5SoK7vKzLs-zoaUwfM60GpobMEIx4nvfVXmzc22CXfgtVScVKYpwPgmWw57Tn3x-vliJh3nfj7CefF93ZeX8qpLEvhQWq3xD6TxPmtP8F8h7e2clYF+ntmLjC8EA0B+8kEL2AVKQBOkAy32huAg+Adx5QIEhWBkf8fQQgtC-G+S9iFikqpgiBZCj7BSnv4DcsDcHVGXgxZ+ODHb0GdghR8KcX7xTwcQjBciCFbyoFg0C7D6QNWJvdX4OA8CfSIq3VYjcSjPVeu9PRmxPTs0hsoVS1gjBWJBpzbmtjuFUDwH4JAlwLhIEUHw3Cf4whGMIERBxFNbFaFCU4voalECS2ljEnWWM9a2KSv4IJxBTEfQUH+c+gltHYF0c3HJwFBKPWMUUkplTYlk2sSFNSxSqnVPbsk+pjTgKJOYOEhpVSOnY2cZJbpN5WxtOGZUwyAJNEsHap1bqfUW6qnbhmMOF40abFovkwpREaE5UUSzbIuQmr5wLjpSgBARo0CarSSAW1rCbVuYdC6py3KWGmSXWZvUJCOG2loU+PzvlUgWn89BVgdmguyuCiAezc5Uk2qYB5BQainPVnxYupc5lfIcD8xwPz1RsSMGCyFELQWZCyBASANQcIXBjAYYgn04YQCIN3WQhEKAw3+NgegEBFBIBnCbRQEBGDBRhqIDlDKrgXDIEgRIBzgB0i2kYW56o7YnJjFbFFMyy6fJnlizFALdXaoOniglxrsokplQCu5lqjCbQkEqiMiKYwABZ1VvM1Y4QFML9UeoNb8z1OqgU-LWji4F+KiVhshWa5q8q5SwokJtfS8KWAOoIAAVhdWij5GL-V6p+d6-5G5A36vzeqYNRrw3GrNUAA" rel="noopener ugc nofollow" target="_blank"> TypeScript playground </a>，以及相同代码的<a class="ae jd" href="https://gist.github.com/ryandabler/fd7884cb9072e66717d9f5d4b23bd5e8" rel="noopener ugc nofollow" target="_blank">要点</a>。</p></div></div>    
</body>
</html>