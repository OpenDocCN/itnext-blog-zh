<html>
<head>
<title>Continuous deployment of ASP .Net Core app to Azure with Azure DevOps Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP的持续部署。使用Azure DevOps管道将. Net Core应用程序迁移到Azure</h1>
<blockquote>原文：<a href="https://itnext.io/continuous-deployment-of-asp-net-core-app-to-azure-with-azure-devops-pipelines-d561198f4e61?source=collection_archive---------1-----------------------#2020-03-04">https://itnext.io/continuous-deployment-of-asp-net-core-app-to-azure-with-azure-devops-pipelines-d561198f4e61?source=collection_archive---------1-----------------------#2020-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="72da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第1部分:定义策略| Azure Pipelines YAML菜谱</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e26d2ac74ddbee39a2bb58b9bd0cd1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PDKlXpRIzvTeuP-ZrijBw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.flickr.com/photos/htakashi/16277420261" rel="noopener ugc nofollow" target="_blank">送货服务车</a>——<a class="ae lb" href="https://www.flickr.com/photos/htakashi/" rel="noopener ugc nofollow" target="_blank">星岛孝</a></figcaption></figure><p id="985a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/azure-devops-yaml-pipeline-recipes-578b5eda3e76">上一篇文章</a>中，我们看到了如何使用Azure Pipelines持续构建Nuget包并将其部署到Azure DevOps工件。在下一部分中，我们将看到如何持续地部署ASP。使用Azure管道将. Net核心web应用程序转换为Azure应用程序服务。在第一部分中，我将讨论CI/CD和部署策略，下一篇文章将解释如何实现该策略。</p><h1 id="382f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">持续集成、交付、部署？</h1><p id="1b84" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在我们深入技术部分之前，我想澄清这三个术语。持续集成、持续交付和持续部署的区别是什么？</p><p id="b878" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">持续集成</em>是当代码被合并到一个主线分支时，系统地运行自动化构建脚本的实践(例如“主”)。这个构建脚本将尝试构建解决方案，并对构建结果运行自动化测试(单元测试，可能是集成测试)。</p><p id="d3cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">持续交付</em>基本上更进一步，它使用持续集成结果来创建打包的应用程序，准备交付给客户。在桌面应用程序的情况下，它可以创建安装包(例如msi)。对于一个ASP。它通常调用<code class="fe mg mh mi mj b">dotnet publish</code>命令并创建一个准备部署的包。部署本身不是自动化的，需要手动完成。</p><p id="205e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">持续部署</em>又向前迈进了一步，自动将包部署到您的最终用户，以便您可以进行“按钮式”交付。在我在本文中演示的解决方案中，我使用Azure Pipelines验证特性来“阻止”部署，直到有人审查了交付，但是只需要在界面中单击一下就可以部署到生产中。</p><p id="2d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想更深入地了解这个主题，你应该读一读<a class="ae lb" href="https://martinfowler.com/bliki/ContinuousDelivery.html" rel="noopener ugc nofollow" target="_blank">马丁·福勒关于这个主题的小文章</a>和这篇非常完整有趣的<a class="ae lb" href="https://circleci.com/blog/a-brief-history-of-devops-part-iv-continuous-delivery-and-continuous-deployment/?gclid=CjwKCAiAnfjyBRBxEiwA-EECLO6MyEgcKIfOpkcf8cqvv1yE8HUzA9rwtnQHRvjwew-3bDER_zHg5hoCT7MQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> Circle CI博文</a>。</p><h1 id="7473" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">定义您的部署策略</h1><p id="8e0b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">创建构建和发布脚本而没有定义这些脚本将如何以及何时被触发，以及定义它们将被部署的环境是非常无用的。因此，首先为我们的持续部署定义一个好的策略是非常重要的。</p><p id="36ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个策略将定义何时触发构建和交付，我们将有多少个部署环境，以及交付将在哪个环境中基于触发它的原因被推动。</p><p id="e7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将描述一个我和我的团队已经成功测试过的策略。可以把它看作一个样本，可以根据你的口味和需要进行修改。我也很想听听您对这一战略的想法和评论。</p><h2 id="512a" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">GitHub式流程</h2><p id="6cfa" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">一个好的持续集成/持续交付(CI/CD)策略从定义一个好的分支策略来管理您的源代码控制开始。有一些分支策略，<a class="ae lb" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> Git Flow </a>可能是最广为人知的策略之一。如果你好奇的话，可以查一下关于这个主题的<a class="ae lb" href="https://www.creativebloq.com/web-design/choose-right-git-branching-strategy-121518344" rel="noopener ugc nofollow" target="_blank">几篇</a> <a class="ae lb" href="https://docs.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="5283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用一个更简单的策略，<a class="ae lb" href="https://guides.github.com/introduction/flow/" rel="noopener ugc nofollow" target="_blank"> GitHub流</a>。在其核心，它非常接近Git流，除了它移除了<em class="mf">开发</em>分支，一旦它被合并到<em class="mf">主</em>中，或者甚至在Pull请求期间，系统地部署生产中的变更。</p><p id="be16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个策略中，<em class="mf">主</em>被锁定，没有人可以在上面合并工作。要进行更改，您必须创建一个<em class="mf">特征</em>分支，该分支将通过<em class="mf">拉动请求</em>合并到主特征。这允许代码在合并(并因此部署)之前被审查和讨论，强制执行代码审查，这提高了代码质量以及整个团队对源代码的了解。</p><p id="8dfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将我的策略称为类似GitHub的流，因为在教科书GitHub流中，生产中的部署是在Pull请求期间进行的，这不是我要设置的。我更喜欢在拉请求完成后部署到开发环境中，并且特性分支合并到主特性中。</p><h2 id="c287" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">Azure DevOps中的GitHub流</h2><p id="e87b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Azure DevOps允许您创建分支策略来实现GitHub流，并强制使用Pull请求来将更改合并到主分支中。</p><p id="b41e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，转到存储库的<em class="mf">分支</em>菜单，打开带有三个点的上下文菜单，并选择<em class="mf">分支策略</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/f111ebe6be87d94504a83d03ef91ac95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axQL-eQUXs-aL4NclK-qeg.png"/></div></div></figure><p id="5e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将带您进入一个菜单，允许您通过设置一些规则来保护您的分支，这些规则必须为真，开放拉取请求才能通过。我通常会制定以下规则:</p><ul class=""><li id="57fd" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">要求至少有2名评审员。所有其他选项保持未选中状态。如果有新的变化，重置投票在某些情况下可能是有用的，但对我们来说有点太苛刻了。</li><li id="880e" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">检查关联的工作项目，需要<em class="mf"/>。我们使用Azure DevOps进行项目管理，每个变更都必须链接到一个工作项(通常是一个任务)。这使我们能够半自动地创建发送给客户的变更日志。</li><li id="bfd9" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">检查注释解析，需要<em class="mf">。代码审查是我们日常工作的重要部分，我们的目标是获得尽可能高的代码质量。我们要求写在拉请求中的注释在完成之前得到解决。通常应该由评论者来解决评论，但是如果被评论者完全按照评论者的要求去做，我们也接受被评论者来解决。</em></li><li id="4ab5" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">添加构建策略，<em class="mf">要求</em>。使用将在持续集成阶段使用的构建管道系统地构建拉请求。单元测试在构建期间运行。这样，我们可以确保拉请求通过构建和单元测试。</li><li id="3a02" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">对于我们有专家的代码的某些部分，我们有时会添加自动审查者，以便在投入生产之前由那些开发人员进行更彻底的检查。</li></ul><p id="5b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您的策略被设置在您的分支上，您将不能直接推送到它，如果您尝试的话，您将从Git得到一个错误消息。转到“拉”请求并启动一个新请求，以将更改合并回主请求。</p><h2 id="cfa8" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">定义部署环境</h2><p id="e7f1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">持续部署(至少我是这样理解的)并不意味着必须将您发布到主分支的所有代码直接部署到您的<strong class="jp ir">客户</strong>那里。这样做将需要一个接受工作流，对于我们的业务需求来说太复杂了。</p><p id="7e24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们决定定义三种环境:</p><ul class=""><li id="2740" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">一个“开发”环境，或“测试版”。这是合并到master中的代码被直接部署的地方。这个环境链接到它自己的数据库，没有生产数据。它用于支持新功能的内部演示，并支持同意为我们进行测试的选定客户，例如特定功能的测试。</li><li id="42dd" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">一个“暂存”环境，在此环境中，我们在将正式版本发送给客户之前准备好它。发布到这个环境是通过在master上推送一个带有版本号的标签来触发的。<br/>在部署到此环境之前，我们将生产数据库(根据数据库的大小和复杂程度，可以是整个数据库，也可以只是数据库的结构和子集)复制到连接此环境的临时数据库。<br/>这使我们能够确保我们的数据库迁移脚本不会在生产中中断，并进行最终验收测试(手动和一些自动测试)。</li><li id="418f" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">我们的客户使用的“生产”环境。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/f1ea567b23d66c392a4f260f6e5dc57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfG2jC3t1h-14BpBgHmM1Q.png"/></div></div></figure><h2 id="f39c" class="mk ld iq bd le ml mm dn li mn mo dp lm jy mp mq lq kc mr ms lu kg mt mu ly mv bi translated">Azure应用服务中的环境</h2><p id="55c5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Azure App Services有一个很好的特性，可以管理同一个应用程序的不同环境。它被称为<em class="mf">部署插槽</em>，允许创建实时运行的应用程序，运行不同的代码，可以“热”交换。这意味着一个环境将“变成”另一个环境，直接重定向您的用户，而无需重启应用程序。</p><p id="c032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，开发/测试应用服务计划(F1和B1)不支持部署插槽，您需要在生产计划中添加一个，最小S1。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/f1442741821d2ed708c0332a0d0d5fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWPSMUDnOOYjPREm51GpLg.png"/></div></div></figure><p id="9d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个部署插槽非常简单，点击<em class="mf">添加插槽</em>，为你的新插槽选择一个名称，然后点击<em class="mf">添加</em>。几秒钟后，你会看到你的新插槽。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/1282e20ddfec797a3cd93a816a14e8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TypmmqYLK5-rorDzdfCA7w.png"/></div></div></figure><p id="2d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个插槽都有自己的应用服务，运行在同一个计划上。您将为每个插槽获得一个发布配置文件，这意味着您可以在每个插槽上发布不同代码。</p><p id="10aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们将只在开发和登台槽上部署代码，代码将通过交换登台和生产环境而投入生产。这将允许在灾难性故障的情况下，通过再次交换回到先前部署的版本。</p><p id="e7d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交换可以通过点击<em class="mf"> Swap </em>按钮直接在Azure门户中完成，但是我们将看到如何通过Azure管道脚本自动完成。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/aae529892a773cca77af597fa256b80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_Evofw0CZzo6JnGLLDRHA.png"/></div></div></figure><p id="04b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常部署插槽会有不同的设置。例如，您可能有不同的数据库，这意味着不同的连接字符串。</p><p id="dd67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以很容易地通过将<em class="mf">部署插槽设置</em>复选框设置为true来解决，我们不希望<strong class="jp ir">被交换</strong>。该复选框定义该设置是该插槽的<em class="mf">特定设置，不应被交换。没有此复选框的设置将被复制到交换到的环境中。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/36a17df6381a98ffdfc4710199e4cfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2U67DHMvNpW9zRlzSVDFA.png"/></div></div></figure><p id="fdf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在官方文档中找到更多关于部署槽的信息。</p><h1 id="2a1e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="eeb4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">本文的第一部分到此结束。我们已经看到了如何定义一个持续部署的策略，以及如何定义Azure应用服务环境来实现我们的策略。</p><p id="b05c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我将描述用于实现持续集成和部署的Azure管道。</p></div></div>    
</body>
</html>