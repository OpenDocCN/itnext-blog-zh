<html>
<head>
<title>Knapsack Pattern — Identify Pattern &amp; Solve with Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">背包模式——模式识别与动态规划求解</h1>
<blockquote>原文：<a href="https://itnext.io/identify-knapsack-pattern-solve-with-dynamic-programming-b673bed3324f?source=collection_archive---------2-----------------------#2022-06-14">https://itnext.io/identify-knapsack-pattern-solve-with-dynamic-programming-b673bed3324f?source=collection_archive---------2-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="b120" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="295b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">组合优化</strong>是一种优化方法，包括从有限的一组对象中找到一个最佳对象。它有许多著名的问题，如旅行推销员问题、最小生成树问题和背包问题。</p><p id="28d1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">背包问题</strong>是一个组合优化问题。它也被称为<strong class="kn ir">背包问题</strong>。它的名字来源于下面的最大化问题，即选择最合适的必需品放在一个包里，以便在旅行中携带。</p><blockquote class="lo lp lq"><p id="ec35" class="kl km lr kn b ko lj kq kr ks lk ku kv ls ll ky kz lt lm lc ld lu ln lg lh li ij bi translated">给定一组项目，每个项目都有一个重量和一个值，确定集合中每个项目的数量，使总重量小于给定的限制，并且总值尽可能大。</p></blockquote><p id="3778" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><p id="b517" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">假设有一个包，它的最大容量为<strong class="kn ir"> 15公斤</strong>重，可以携带物品。有几组给定的项目，每一组都有一个利润值。因此，背包问题决定了每一个项目，以最大限度地增加收入。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/f1c5829dba4d6f7560e2ee8e7784cdc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7bLfPpqUe5IdVIVebfI3Q.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">图1:背包示例</figcaption></figure><h1 id="01ad" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背包问题的类型</h1><p id="05b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">背包问题有三种类型:</p><ul class=""><li id="17d7" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated">0/1背包问题</li><li id="9843" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">有界背包问题</li><li id="075a" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">无界背包问题</li></ul><h2 id="6fad" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">0/1背包问题</h2><p id="f49d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一个非常常见的背包问题。它将每种项目的数量限制为零或一。</p><p id="097c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><p id="5d47" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">假设阿米尔希望在旅行中携带<strong class="kn ir"> <em class="lr"> n </em> </strong>件物品，并且它具有以下条件:</p><ul class=""><li id="229f" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated"><em class="lr"/><strong class="kn ir"><em class="lr">I</em></strong><em class="lr"/>项的重量是<strong class="kn ir"> <em class="lr">作业指导书</em> </strong> <em class="lr">项和项都不一样。</em></li><li id="3efa" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">物品放在一个载重量为c的背包中携带:<em class="lr"> (a)当物品重量之和≤ c时，n件物品都可以放在背包中。</em> <em class="lr"> (b)当物品权重之和&gt; c时，某些物品必须被留下。</em></li></ul><p id="2365" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果不允许我们取小数，那么这就是0/1背包问题。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nl"><img src="../Images/afde33153a362b1c69909fd866874f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uLWMF3wdiB72pb5AIHkPRg.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">图2:背包0/1</figcaption></figure><h2 id="3489" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">有界背包问题</h2><p id="2780" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有界背包问题将每个物品的数量限制在一个特定的值。它取消了每种项目只有一个的限制，而是将每种项目的拷贝数<strong class="kn ir"><em class="lr">【Xi】</em></strong><em class="lr"/>限制为最大非负整数值<strong class="kn ir"> <em class="lr"> c </em> </strong> <em class="lr">。</em></p><h2 id="3d3b" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">无界背包问题</h2><p id="f0b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">无界背包问题对每个物品的数量没有限制。项目可以重复。</p><h1 id="511c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">0/1背包问题——有界</h1><h2 id="c0fa" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">最大化小偷的利润</h2><p id="26f6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个小偷拿着一个包走进一家商店，开始从商店里偷东西。他包的最大容量是10公斤。他不能在包里放超过10公斤的东西。他只想把那些他能从中获得更多利润的东西放进他的包里。<strong class="kn ir"> </strong> <em class="lr">(这里盗贼不能分也不能啄物品，要么拿一个物品要么不拿(0–1属性)。</em></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="0665" class="mz jo iq nn b gy nr ns l nt nu">price = [ 20, 5, 10, 40, 15, 25 ]<br/>weight = [ 1, 2, 3, 8, 7, 4 ]<br/>bagWeight = 10 kg</span><span id="e6a5" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Output: 60</strong></span><span id="3361" class="mz jo iq nn b gy nv ns l nt nu">price = 20 + 40 = 60<br/>total weight = 1 + 8 = 9 &lt; bagWeight</span></pre><p id="9685" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><p id="2a7d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这个问题可以通过使用两种不同的可能性来解决:</p><ul class=""><li id="097a" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated">包括背包中的当前物品，对剩余物品重复，然后减少重量。</li><li id="f48e" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">不要将当前物品放入背包，并重复剩余物品。</li></ul><p id="f72a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过使用递归:</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="9ed6" class="mz jo iq nn b gy nr ns l nt nu">def getMaxProfitForThief(price, weight, n, bagCapacity):<br/>    if bagCapacity &lt; 0:<br/>        return float('-inf')<br/>    <br/>    if n &lt; 0 or bagCapacity == 0:<br/>        return 0</span><span id="aa0f" class="mz jo iq nn b gy nv ns l nt nu">exclude = getMaxProfitForThief(price, weight, n-1, bagCapacity)<br/>    include = getMaxProfitForThief(price, weight, n-1, bagCapacity - weight[n]) + value[n]<br/>    <br/>    return max(exclude, include)</span><span id="8e37" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  price = [ 20, 5, 10, 40, 15, 25 ]<br/>  weight = [ 1, 2, 3, 8, 7, 4 ]<br/>  bagCapacity = 10</span><span id="9b71" class="mz jo iq nn b gy nv ns l nt nu">  getMaxProfitForThief(price, weight, len(price) - 1, bagCapacity)</span></pre><p id="dc9c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过使用动态编程(记忆化):</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="52b8" class="mz jo iq nn b gy nr ns l nt nu">def getMaxProfitForThief(price, weight, n, bagCapacity, memo):<br/>    if bagCapacity &lt; 0:<br/>        return float('-inf')<br/>    <br/>    if n &lt; 0 or bagCapacity == 0:<br/>        return 0<br/>    <br/>    key = str(n) + '-' + str(bagCapacity)<br/>    if key in memo:<br/>        return memo[key]</span><span id="9c98" class="mz jo iq nn b gy nv ns l nt nu">exclude = getMaxProfitForThief(price, weight, n-1, bagCapacity, memo)<br/>    include = getMaxProfitForThief(price, weight, n-1, bagCapacity - weight[n], memo) + value[n]<br/>    <br/>    memo[key] = max(exclude, include)<br/>    return memo[key]</span><span id="aa99" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  price = [ 20, 5, 10, 40, 15, 25 ]<br/>  weight = [ 1, 2, 3, 8, 7, 4 ]<br/>  bagCapacity = 10</span><span id="2bda" class="mz jo iq nn b gy nv ns l nt nu">getMaxProfitForThief(price, weight, len(value) - 1, bagCapacity, {})</span></pre><p id="1931" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过使用动态编程(制表):</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="46df" class="mz jo iq nn b gy nr ns l nt nu">def getMaxProfitForThief(price, weight, bagCapacity):<br/>    n = len(price)<br/>    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]<br/>    <br/>    for i in range(1, n + 1):<br/>        for j in range(1, bagCapacity + 1):<br/>            if weight[i - 1] &gt; j:<br/>                dp[i][j] = dp[i-1][j]<br/>            else:<br/>                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1])<br/>          <br/>    return dp[n][bagCapacity]</span><span id="fffc" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  price = [ 20, 5, 10, 40, 15, 25 ]<br/>  weight = [ 1, 2, 3, 8, 7, 4 ]<br/>  bagCapacity = 10</span><span id="d4d5" class="mz jo iq nn b gy nv ns l nt nu">getMaxProfitForThief(price, weight, bagCapacity)</span></pre><h2 id="524a" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">子集和问题</h2><p id="181b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">存在一组非负整数，目标值和确定是否存在给定集合的和等于给定目标和的子集。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="7733" class="mz jo iq nn b gy nr ns l nt nu">arr = [3, 34, 4, 12, 5, 2]<br/>target = 9</span><span id="e6d9" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Output: </strong>True</span><span id="d6ba" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation: </strong>There is a subset (4, 5) with target sum 9.</span></pre><p id="bfed" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><p id="d606" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过使用递归:</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="299e" class="mz jo iq nn b gy nr ns l nt nu">def getSubset(arr, n, target):<br/>    if target == 0:<br/>        return True<br/>    <br/>    if n == 0:<br/>        return False<br/>    <br/>    if arr[n-1] &gt; target:<br/>        return getSubset(arr, n-1, target)<br/>    <br/>    return getSubset(arr, n-1, target - arr[n-1]) or getSubset(arr, n-1, target)</span><span id="9f2c" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>   arr = [3, 34, 4, 12, 5, 2]<br/>   target = 9<br/>   getSubset(arr, len(arr)-1, target)</span></pre><p id="86a4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过使用动态编程(制表):</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="8668" class="mz jo iq nn b gy nr ns l nt nu">def getSubset(arr, target):<br/>    n = len(arr)<br/>    dp = [[False for _ in range(target + 1)] for _ in range(n+1)]<br/>    for i in range(n+1):<br/>        dp[i][0] = True<br/>    <br/>    for i in range(1, n+1):<br/>        for j in range(1, target+1):<br/>            if arr[i-1] &gt; j:<br/>                dp[i][j] = dp[i-1][j]<br/>            else:<br/>                dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]]<br/>    <br/>    return dp[n][target]</span><span id="8688" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  arr = [3, 34, 4, 12, 5, 2]<br/>  target = 9<br/>  getSubset(arr, target)</span></pre><h2 id="32c2" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">划分相等子集和</h2><p id="020c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定非空正整数，找出数组是否可以分成两个子集，使得两个子集的元素之和相等。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="455b" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [1,5,11,5]<br/><strong class="nn ir">Output:</strong> true<br/><strong class="nn ir">Explanation:</strong> The array can be partitioned as [1, 5, 5] and [11].</span></pre><p id="538d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="2d5e" class="mz jo iq nn b gy nr ns l nt nu">def canPartition(nums):<br/>    n = len(nums)<br/>    total = sum(nums)<br/>    <br/>    if total % 2 != 0:<br/>        return False<br/>    <br/>    W = total // 2<br/>    dp = [[False for _ in range(W + 1)] for _ in range(n + 1)]<br/>    <br/>    for i in range(n + 1):<br/>        dp[i][0] = True<br/>        <br/>    for i in range(1, n + 1):<br/>        for j in range(1, W + 1):<br/>            if nums[i-1] &gt; j:<br/>                dp[i][j] = dp[i-1][j]<br/>            else:<br/>                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]<br/>                <br/>    return dp[n][W]</span><span id="a5b0" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  nums = [1,5,11,5]<br/>  canPartition(nums)</span></pre><h2 id="6516" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">总和等于目标值的子集计数</h2><p id="deb8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个包含元素和一个目标的非空数组，找出和等于目标的子集数。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="d555" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> arr = [1, 2, 3, 3] target = 6 <br/><strong class="nn ir">Output:</strong> 3</span><span id="596d" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation: </strong>All possible subsets are = [1, 2, 3], [1, 2, 3], [3, 3]</span></pre><p id="b95e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="fe5e" class="mz jo iq nn b gy nr ns l nt nu">def getCountOfSubset(nums, target):<br/>    n = len(nums)<br/>    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]<br/>    dp[0][0] = 1<br/>    <br/>    for i in range(1, n + 1):<br/>        for j in range(target + 1):<br/>            if nums[i-1] &gt; target:<br/>                dp[i][j] = dp[i-1][j]<br/>            else:<br/>                dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]<br/>                <br/>    return dp[n][target]</span><span id="c884" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  nums = [ 3, 3, 3, 3 ]<br/>  target = 6</span><span id="a894" class="mz jo iq nn b gy nv ns l nt nu">  getCountOfSubset(nums, target)</span></pre><p id="3a6a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">另一种方法:</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="4d28" class="mz jo iq nn b gy nr ns l nt nu">def getCountSubsets(arr, target):<br/>    n = len(arr)<br/>    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]<br/>    dp[0][0] = 0<br/>    <br/>    for i in range(1, n + 1):<br/>        for j in range(target + 1):<br/>            if arr[i-1] &gt; j:<br/>                dp[i][j] = dp[i-1][j]<br/>            else:<br/>                dp[i][j] = max(dp[i-1][j], dp[i-1][j-arr[i-1]] + 1)<br/>    <br/>    return dp[n][target]</span><span id="5c82" class="mz jo iq nn b gy nv ns l nt nu">arr = [1, 2, 3, 3]<br/>target = 6<br/>getCountSubsets(arr, target)</span></pre><h2 id="0105" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">目标总和</h2><p id="32ed" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe nw nx ny nn b">nums</code>和一个整数<code class="fe nw nx ny nn b">target</code>。</p><p id="8909" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您希望通过在nums中的每个整数前添加符号<code class="fe nw nx ny nn b">'+'</code>和<code class="fe nw nx ny nn b">'-'</code>中的一个来构建nums中的<strong class="kn ir">表达式</strong>，然后连接所有的整数。</p><ul class=""><li id="1a21" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated">举个例子，如果<code class="fe nw nx ny nn b">nums = [2, 1]</code>，你可以在<code class="fe nw nx ny nn b">2</code>前加一个<code class="fe nw nx ny nn b">'+'</code>，在<code class="fe nw nx ny nn b">1</code>前加一个<code class="fe nw nx ny nn b">'-'</code>，串联起来构建表达式<code class="fe nw nx ny nn b">"+2-1"</code>。</li></ul><p id="2ff2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回您可以构建的不同<strong class="kn ir">表达式</strong>的数量，其计算结果为<code class="fe nw nx ny nn b">target</code>。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="37d0" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [1,1,1,1,1], target = 3<br/><strong class="nn ir">Output:</strong> 5<br/><strong class="nn ir">Explanation:</strong> There are 5 ways to assign symbols to make the sum of nums be target 3.<br/>-1 + 1 + 1 + 1 + 1 = 3<br/>+1 - 1 + 1 + 1 + 1 = 3<br/>+1 + 1 - 1 + 1 + 1 = 3<br/>+1 + 1 + 1 - 1 + 1 = 3<br/>+1 + 1 + 1 + 1 - 1 = 3</span></pre><p id="0c7d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="3690" class="mz jo iq nn b gy nr ns l nt nu">def findTargetSumWays(nums, target):<br/>    n = len(nums)<br/>    total = sum(nums)<br/>    <br/>    if target &gt; total:<br/>        return 0<br/>    <br/>    if (target + total) % 2 != 0:<br/>        return 0<br/>    <br/>    s1 = (total + target) // 2</span><span id="ea3e" class="mz jo iq nn b gy nv ns l nt nu">dp = [[0] * (s1 + 1) for i in range(n + 1)]<br/>    if len(dp) &lt;= 0 or len(dp[0]) == 0:<br/>        return 0<br/>    <br/>    dp[0][0] = 1<br/>    <br/>    for i in range(1, n + 1):<br/>        for j in range(s1+1):<br/>            if nums[i-1] &gt; j:<br/>                dp[i][j] = dp[i-1][j]<br/>            else:<br/>                dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i-1]]<br/>                <br/>    return dp[n][s1]</span><span id="06c1" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>    nums = [1,1,1,1,1]<br/>    target = 3<br/>    findTargetSumWays(nums, target)</span></pre><h2 id="6862" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">最后一石重量II</h2><p id="7454" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个整数数组<code class="fe nw nx ny nn b">stones</code>，其中<code class="fe nw nx ny nn b">stones[i]</code>是<code class="fe nw nx ny nn b">ith</code>宝石的重量。</p><p id="f213" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们在用石头玩游戏。在每一轮，我们选择任意两块石头，然后一起打碎它们。假设石头有重量<code class="fe nw nx ny nn b">x</code>和<code class="fe nw nx ny nn b">y</code>和<code class="fe nw nx ny nn b">x &lt;= y</code>。这次粉碎的结果是:</p><ul class=""><li id="3cca" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated">如果<code class="fe nw nx ny nn b">x == y</code>，两块石头都被摧毁，并且</li><li id="aae3" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">如果<code class="fe nw nx ny nn b">x != y</code>，重量<code class="fe nw nx ny nn b">x</code>的石头被破坏，重量<code class="fe nw nx ny nn b">y</code>的石头有了新的重量<code class="fe nw nx ny nn b">y - x</code>。</li></ul><p id="b0ef" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">游戏结束，最多剩下<strong class="kn ir">一块</strong>石头。</p><p id="0cde" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="lr">左侧宝石</em>的最小可能重量。如果没有剩余的石头，返回<code class="fe nw nx ny nn b">0</code>。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="d2ea" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> stones = [2,7,4,1,8,1]<br/><strong class="nn ir">Output:</strong> 1<br/><strong class="nn ir">Explanation:</strong><br/>We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,<br/>we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,<br/>we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,<br/>we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.</span></pre><p id="248d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="5349" class="mz jo iq nn b gy nr ns l nt nu">def lastStoneWeightII(stones):<br/>    n = len(stones)<br/>    total = sum(stones)<br/>    target = total // 2<br/>    dp = [0  for i in range(target + 1)]<br/>    <br/>    for stone in stones:<br/>        for w in range(target, stone-1, -1):<br/>            dp[w] = max(dp[w], dp[w-stone] + stone)<br/>            <br/>    return (total - (2 * dp[target]))</span><span id="0aa6" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>   stones = [2,7,4,1,8,1]<br/>   lastStoneWeightII(stones)</span></pre><h2 id="93b3" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">完美的正方形</h2><p id="1313" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数<code class="fe nw nx ny nn b">n</code>，返回<em class="lr">与</em>和<code class="fe nw nx ny nn b">n</code>之和的最小的完美平方数。</p><p id="2f10" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一个<strong class="kn ir">完美平方</strong>是一个整数，它是一个整数的平方；换句话说，它是某个整数与自身的乘积。例如，<code class="fe nw nx ny nn b">1</code>、<code class="fe nw nx ny nn b">4</code>、<code class="fe nw nx ny nn b">9</code>和<code class="fe nw nx ny nn b">16</code>是完美的正方形，而<code class="fe nw nx ny nn b">3</code>和<code class="fe nw nx ny nn b">11</code>不是。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="54fa" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> n = 12<br/><strong class="nn ir">Output:</strong> 3<br/><strong class="nn ir">Explanation:</strong> 12 = 4 + 4 + 4.</span></pre><p id="4142" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="4662" class="mz jo iq nn b gy nr ns l nt nu">import math</span><span id="9775" class="mz jo iq nn b gy nv ns l nt nu">def numSquares(n):<br/>    square_nums = [i ** 2 for i in range(1, int(math.sqrt(n)) + 1)]<br/>    dp = [float('inf')] * (n + 1)<br/>    dp[0] = 0<br/>    <br/>    for i in range(1, n + 1):<br/>        for square_num in square_nums:<br/>            if i &lt; square_num: <br/>                break<br/>                <br/>            dp[i] = min(dp[i], dp[i - square_num] + 1)<br/>                <br/>    return dp[-1]</span><span id="d502" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  n = 12<br/>  numSquares(n)</span></pre><h2 id="9613" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">1和0</h2><p id="f66e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个二进制字符串数组<code class="fe nw nx ny nn b">strs</code>和两个整数<code class="fe nw nx ny nn b">m</code>和<code class="fe nw nx ny nn b">n</code>。</p><p id="472b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="lr"/><code class="fe nw nx ny nn b"><em class="lr">strs</em></code><em class="lr">的最大子集的大小，使得</em><em class="lr"/><code class="fe nw nx ny nn b">m</code><em class="lr"/><code class="fe nw nx ny nn b">0</code><em class="lr">和</em> <code class="fe nw nx ny nn b">n</code> <em class="lr"> </em> <code class="fe nw nx ny nn b">1</code> <em class="lr">的子集</em>中最多有<strong class="kn ir"><em class="lr"><em class="lr">的。</em></em></strong></p><p id="8ebc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果<code class="fe nw nx ny nn b">x</code>的所有元素也是<code class="fe nw nx ny nn b">y</code>的元素，则集合<code class="fe nw nx ny nn b">x</code>是集合<code class="fe nw nx ny nn b">y</code>的子集<strong class="kn ir">。</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="a0fb" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> strs = ["10","0001","111001","1","0"], m = 5, n = 3<br/><strong class="nn ir">Output:</strong> 4</span><span id="3a30" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong> The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.<br/>Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.<br/>{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.</span></pre><p id="afe5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="7e51" class="mz jo iq nn b gy nr ns l nt nu">def findMaxForm(strs, m, n):<br/>    dp = [[0] * (n + 1) for _ in range(m + 1)]<br/>        <br/>    for s in strs:<br/>        zeros = s.count("0")<br/>        ones = s.count("1")<br/>        <br/>        for i in range(m, zeros-1, -1):<br/>            for j in range(n, ones-1, -1):<br/>                dp[i][j] = max( 1 + dp[i - zeros][j- ones], dp[i][j] )<br/>        <br/>    return dp[m][n]</span><span id="bd65" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>   strs = ["10","0001","111001","1","0"]<br/>   m = 5<br/>   n = 3<br/>   findMaxForm(strs, m, n)</span></pre><h2 id="60b8" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">整数分隔符</h2><p id="33b1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数<code class="fe nw nx ny nn b">n</code>，将其分解为<code class="fe nw nx ny nn b">k</code> <strong class="kn ir">个正整数</strong>之和，其中<code class="fe nw nx ny nn b">k &gt;= 2</code>，最大化那些整数的乘积。</p><p id="cdf6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="lr">你能得到的最大产品</em>。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="c9e2" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> n = 2<br/><strong class="nn ir">Output:</strong> 1<br/><strong class="nn ir">Explanation:</strong> 2 = 1 + 1, 1 × 1 = 1.</span></pre><p id="6e49" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="35cf" class="mz jo iq nn b gy nr ns l nt nu">def integerBreak(n):<br/>    dp = [0]*(n+1)<br/>    dp[2] = 1<br/>        <br/>    for i in range(3, n+1):<br/>        for j in range(1, i-1):<br/>            dp[i] = max(dp[i], j*max(i-j, dp[i-j]))<br/>        <br/>    return dp[-1]</span><span id="efe9" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  n = 2<br/>  integerBreak(n)</span></pre><h1 id="831a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">0/1背包问题——无界</h1><h2 id="9036" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">硬币零钱</h2><p id="6c8e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个整数数组<code class="fe nw nx ny nn b">coins</code>代表不同面额的硬币，一个整数<code class="fe nw nx ny nn b">amount</code>代表钱的总数。</p><p id="db1d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回你需要的最少数量的硬币来补足这个数目。如果硬币的任何组合都无法补足该金额，则返回<code class="fe nw nx ny nn b">-1</code>。</p><p id="5ec5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你可以假设每种硬币都有无限个。</p><p id="cb42" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="bf41" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> coins = [1,2,5], amount = 11<br/><strong class="nn ir">Output:</strong> 3</span><span id="35e6" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong> 11 = 5 + 5 + 1</span></pre><p id="7257" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="8e5c" class="mz jo iq nn b gy nr ns l nt nu">def coinChange(coins, amount):<br/>  dp = [float("inf")] * (amount + 1)<br/>  dp[0] = 0<br/>        <br/>  for a in range(1, amount + 1):<br/>     for coin in coins:<br/>         if a - coin &gt;= 0:<br/>             dp[a] = min(dp[a], 1 + dp[a - coin])<br/>        <br/>  if dp[amount] != float("inf"):<br/>        return dp[amount]<br/>        <br/>  return -1</span><span id="a3dd" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  coins = [1,2,5]<br/>  amount = 11<br/>  coinChange(coins, amount)</span></pre><h2 id="b4b1" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">硬币零钱2</h2><p id="4702" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个整数数组<code class="fe nw nx ny nn b">coins</code>代表不同面值的硬币，一个整数<code class="fe nw nx ny nn b">amount</code>代表钱的总数。</p><p id="c544" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回组成该金额的组合数。如果硬币的任何组合都无法补足该金额，则返回<code class="fe nw nx ny nn b">0</code>。</p><p id="0632" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你可以假设每种硬币都有无限个。</p><p id="40d0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">答案是<strong class="kn ir">保证</strong>适合一个带符号的<strong class="kn ir"> 32位</strong>整数。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="53b4" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> amount = 5, coins = [1,2,5]<br/><strong class="nn ir">Output:</strong> 4</span><span id="5442" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong> there are four ways to make up the amount:<br/>5=5<br/>5=2+2+1<br/>5=2+1+1+1<br/>5=1+1+1+1+1</span></pre><p id="87c4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="c9cc" class="mz jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def change(self, amount, coins):<br/>        """<br/>        :type amount: int<br/>        :type coins: List[int]<br/>        :rtype: int<br/>        """<br/>        dp = [0] * (amount + 1)<br/>        dp[0] = 1<br/>        <br/>        for coin in coins:<br/>            for i in range(coin, amount + 1):<br/>                dp[i] += dp[i-coin]<br/>        <br/>        return dp[-1]</span><span id="972e" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>  amount = 5<br/>  coins = [1,2,5]<br/>  change(amount, coins)</span></pre><p id="74f4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">组合和四</strong></p><p id="1828" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">给定一个由<strong class="kn ir">个不同的</strong>个整数<code class="fe nw nx ny nn b">nums</code>和一个目标整数<code class="fe nw nx ny nn b">target</code>组成的数组，返回<em class="lr">加起来等于</em> <code class="fe nw nx ny nn b">target</code>的可能组合数。</p><p id="ee65" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">测试用例被生成，以便答案可以适合一个32位的<strong class="kn ir">整数。</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="4017" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> nums = [1,2,3], target = 4<br/><strong class="nn ir">Output:</strong> 7<br/><strong class="nn ir">Explanation:</strong><br/>The possible combination ways are:<br/>(1, 1, 1, 1)<br/>(1, 1, 2)<br/>(1, 2, 1)<br/>(1, 3)<br/>(2, 1, 1)<br/>(2, 2)<br/>(3, 1)<br/>Note that different sequences are counted as different combinations.</span></pre><p id="df6b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="5c6f" class="mz jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def combinationSum4(self, nums, target):<br/>        """<br/>        :type nums: List[int]<br/>        :type target: int<br/>        :rtype: int<br/>        """<br/>        dp = [ 0 for _ in range(target+1) ]<br/>        dp[0] = 1<br/>        <br/>        for i in range(target):<br/>            for num in nums:<br/>                if i + num &lt; target + 1: dp[i+num] += dp[i]<br/>                    <br/>        return dp[-1]</span><span id="ed78" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main__':<br/>   nums = [1,2,3]<br/>   target = 4<br/>   combinationSum4(nums, target):</span></pre><h2 id="211f" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">最低票价</h2><p id="49ef" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你已经提前一年计划了一些火车旅行。一年中你将要旅行的日子以整数数组<code class="fe nw nx ny nn b">days</code>的形式给出。每天是从<code class="fe nw nx ny nn b">1</code>到<code class="fe nw nx ny nn b">365</code>的整数。</p><p id="8461" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">火车票以三种不同的方式出售:</p><ul class=""><li id="6c60" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated">一张<strong class="kn ir">一日</strong>通行证售价<code class="fe nw nx ny nn b">costs[0]</code>美元，</li><li id="7671" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">一张<strong class="kn ir"> 7天</strong>通行证售价<code class="fe nw nx ny nn b">costs[1]</code>美元，以及</li><li id="0743" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">一张<strong class="kn ir"> 30天</strong>通行证售价<code class="fe nw nx ny nn b">costs[2]</code>美元。</li></ul><p id="a2bd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通行证允许多日连续旅行。</p><ul class=""><li id="28c2" class="ml mm iq kn b ko lj ks lk kw mn la mo le mp li mq mr ms mt bi translated">例如，如果我们在<code class="fe nw nx ny nn b">2</code>日获得<strong class="kn ir"> 7天</strong>通行证，那么我们可以旅行<code class="fe nw nx ny nn b">7</code>天:<code class="fe nw nx ny nn b">2</code>、<code class="fe nw nx ny nn b">3</code>、<code class="fe nw nx ny nn b">4</code>、<code class="fe nw nx ny nn b">5</code>、<code class="fe nw nx ny nn b">6</code>、<code class="fe nw nx ny nn b">7</code>和<code class="fe nw nx ny nn b">8</code>。</li></ul><p id="1b3d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="lr">在给定的天数列表中</em>你每天需要旅行的最小美元数。</p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="3b2e" class="mz jo iq nn b gy nr ns l nt nu"><strong class="nn ir">Input:</strong> days = [1,4,6,7,8,20], costs = [2,7,15]<br/><strong class="nn ir">Output:</strong> 11</span><span id="9cc7" class="mz jo iq nn b gy nv ns l nt nu"><strong class="nn ir">Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:<br/>On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.<br/>On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.<br/>On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.<br/>In total, you spent $11 and covered all the days of your travel.</span></pre><p id="ddee" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="lw lx ly lz gt nm nn no np aw nq bi"><span id="f55f" class="mz jo iq nn b gy nr ns l nt nu">class Solution(object):<br/>    def mincostTickets(self, days, costs):<br/>        """<br/>        :type days: List[int]<br/>        :type costs: List[int]<br/>        :rtype: int<br/>        """<br/>        dp = [0 for _ in range(days[-1] + 1)]<br/>        <br/>        for i in range(1, days[-1] + 1):<br/>            if i in days:<br/>                if i &lt; 7:<br/>                    dp[i] = min(dp[i - 1] + costs[0], dp[0] + costs[1], dp[0] + costs[2])<br/>                elif i &lt; 30:<br/>                    dp[i] = min(dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[0] + costs[2])<br/>                else:<br/>                    dp[i] = min(dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2])<br/>            else:<br/>                dp[i] = dp[i-1]<br/>        <br/>        return dp[-1]</span><span id="4851" class="mz jo iq nn b gy nv ns l nt nu">if __name__ == '__main':<br/>    days = [1,4,6,7,8,20]<br/>    costs = [2,7,15]</span><span id="134a" class="mz jo iq nn b gy nv ns l nt nu">    mincostTickets(days, costs)</span></pre><h1 id="2268" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背包问题的复杂性分析</h1><p id="fe17" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，背包问题是NP难的。这意味着对于这个问题没有已知的多项式时间算法。这里，我们采用贪婪的启发式方法，它不能保证最优解。</p><h2 id="f7d1" class="mz jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">结论</h2><p id="f1f5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">背包问题是组合优化中的一个问题。有许多基于背包问题模式的问题陈述。一旦完全理解了背包问题，就可以通过使用动态规划方法来轻松解决这些问题。</p></div></div>    
</body>
</html>