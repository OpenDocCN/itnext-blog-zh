<html>
<head>
<title>The Kubernetes Ownership Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes所有权模型</h1>
<blockquote>原文：<a href="https://itnext.io/the-kubernetes-ownership-model-50802b9f264?source=collection_archive---------0-----------------------#2020-10-30">https://itnext.io/the-kubernetes-ownership-model-50802b9f264?source=collection_archive---------0-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f6cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以你决定在你的组织中采用Kubernetes？恭喜你！你可能做了一个很棒或者很糟糕的决定，我不知道。这个博客不会帮你回答这个问题。相反，本博客的重点是解决任何规模的组织在采用Kubernetes时面临的最初挑战，以及如果您从一开始就仔细规划，如何避免一些陷阱。我们开始吧！</p><h1 id="b39e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是所有权模型？</h1><p id="5812" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Kubernetes所有权模型描述了负责管理Kubernetes实现的不同方面的人员或团队的职责和责任。它确保了人们不会互相冒犯，治理也变得更加简单。让我来介绍一下对我有效的模式。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/634c24d79976f7c51c91541aab707fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXNalsk9FDKPHhdpNPnSAA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Kubernetes所有权模型</figcaption></figure><p id="bd27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该模型不仅描述了所有权团队，还描述了实现所有权的工具。这些工具鼓励<a class="ae me" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank">基础设施作为代码</a>原则，比如GitOps，这样你就可以得到可审计和可重复的系统。这些绝不是唯一可用于这项工作的工具，还有许多其他工具。我在这里提供了一个对我有用的固执己见的列表。</p><p id="0afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一件要记住的事情是，拥有团队是代表角色。这些角色(如IAM角色)可以由同一个人担任。这在初创企业中很常见，一个人身兼数职来满足各种需求。</p><h1 id="273b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">为什么我们需要所有权模型？</h1><p id="ddd7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当开始采用Kubernetes时，您会很快意识到，在部署您自己的容器化应用程序之前，您必须安装无数的工具来支持您的应用程序所需的不同功能。这些功能包括Nginx Ingress之类的第7层路由、使用外部DNS的DNS管理、使用Cert Manager的TLS证书等等。不久之后，你将会面临这样的问题:“谁负责这些应用程序？”，“我们应该在哪里部署它？”，“我们如何跟踪各种应用程序部署？”诸如此类。</p><p id="993a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">甚至在此之前就出现了Kubernetes本身的问题。"谁负责维护库伯内特集群(EKS、阿拉斯加、GKE、KOPS等)？"，“任何人都可以请求/创建新的Kubernetes集群吗？”还有更多。</p><p id="57e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些问题以及更多的问题都可以通过实现所有权模型来解决。</p><h1 id="fdf8" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">核心基础设施层</h1><p id="eb2b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">模型中的第一层描述了Kubernetes集群本身和工作节点。无论您是决定使用Kops创建自己的集群，还是选择EKS、AKS等云提供商的托管产品。，将需要一些管理。您仍然负责升级控制平面、更新工作节点ami等。对此负责的人员将需要提升权限，而这些权限不应属于常规开发运维团队。</p><p id="15a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的公司设置这一层时(我们选择了EKS和AKS)，我发现Terraform是这项工作最简单的工具。这是HashiCorp的成熟产品，拥有强大的社区。特别是对于EKS，需要一些安装后的步骤来设置<code class="fe mf mg mh mi b">aws-auth</code>配置图，我发现<a class="ae me" href="https://github.com/terraform-aws-modules/terraform-aws-eks/" rel="noopener ugc nofollow" target="_blank">地形EKS模块</a>非常有用。事实上，你应该使用Terraform来管理你所有的云基础设施。</p><p id="2556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个简单的EKS集群和带有EKS模块的节点组的示例。</p><pre class="lp lq lr ls gt mj mi mk ml aw mm bi"><span id="f482" class="mn km iq mi b gy mo mp l mq mr">module "my_dev_eks" {<br/>  source  = "terraform-aws-modules/eks/aws"<br/>  version = "12.2.0"<br/><br/>  cluster_name                    = "my-dev-eks"<br/>  cluster_version                 = "1.18"<br/>  cluster_endpoint_private_access = true<br/>  cluster_endpoint_public_access  = true<br/><br/>  cluster_endpoint_public_access_cidrs = [<br/><em class="ms">    </em>"0.0.0.0/0"<br/>  ]<br/><br/>  subnets     = flatten([<em class="ms">module</em>.my_dev_eks_vpc.public_subnets, <em class="ms">module</em>.my_dev_eks_vpc.private_subnets])<br/>  vpc_id      = <em class="ms">module</em>.my_dev_eks_vpc.vpc_id<br/>  enable_irsa = true<em class="ms"><br/><br/>  </em>cluster_log_retention_in_days = 7<em class="ms"><br/>  </em>cluster_enabled_log_types     = ["api", "scheduler", "audit"]<em class="ms"><br/><br/>  </em>tags = <em class="ms">var</em>.tags<br/><br/>  node_groups_defaults = {<br/>    ami_type  = "AL2_x86_64"<br/>    disk_size = 20<br/>  }<br/><br/>  # to manage aws-auth config map.<br/>  map_users = [<br/>    {<br/>      userarn  = "arn:aws:iam::xxxxx:user/user@domain.com"<br/>      username = "username"<br/>      groups   = ["system:masters"]<br/>    }<br/>  ]</span><span id="5092" class="mn km iq mi b gy mt mp l mq mr">  node_groups = {<br/>    node_a = {<br/>      instance_type       = <em class="ms">var</em>.nodegroup_kafka_brokers<br/>      subnets             = [<em class="ms">module</em>.my_dev_eks_vpc.private_subnets[0]]<br/>      ami_release_version = "1.18.8-20201007"<br/>      version             = "1.18"<br/>      desired_capacity    = 1<br/>      max_capacity        = 3<br/>      min_capacity        = 1<br/>      key_name            = "my ssh key"<br/>    }<br/>  }<br/>}</span></pre><p id="3854" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要确保只允许特定的人对保存terraform文件的Git存储库进行写访问，就可以了。</p><h1 id="6afc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">基础设施应用层</h1><p id="b4c7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">模型中的第二层描述了为您的实际业务应用程序所需的基础设施提供动力的应用程序。Kubernetes的承诺不仅仅在于它的调度和容器编排，还在于基础设施自动化和由Kubernetes社区构建的很酷的应用程序，其中大部分现在被CNCF采用。</p><blockquote class="mu"><p id="31e2" class="mv mw iq bd mx my mz na nb nc nd kk dk translated">我记得申请更换防火墙需要14个工作日。今天，它是Git存储库中的一个提交，然后一些应用程序在几秒钟内就变得不可思议了。这是一个多么适合做行动人员的时代啊！</p></blockquote><p id="4735" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">这一层可以由拥有第一层的同一个团队拥有，即系统管理员。但是，如果您想要进行分离，这些应用程序集可以由单独的基础架构管理团队来处理。这里的正确答案是任何适合你现有组织结构的。</p><p id="0c08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这一层有哪些应用呢？这一层处理基础设施问题，如DNS、TLS证书、TCP/HTTP路由、连续部署等。并且旨在尽可能自动地启用它们。Kubernetes控制器应用，如外部DNS、证书管理器、入口控制器、ArgoCD等。通过构建Kubernetes API扩展(定制资源控制器或CRD)来实现这一点。在架构中采用这些应用程序，让您的生活变得轻松！</p><p id="5f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个问题是如何采用这些工具。几乎所有的基础设施应用都有一个共同点:<strong class="jp ir">掌舵图</strong>。它们都提供了复杂的导航图，允许配置应用程序的各个方面。我发现这是测试应用程序甚至在生产中部署的最快方法。它也有助于多种环境(您有单独的Kubernetes集群用于生产和测试，对吗？)，你也不想发现自己直接在PROD里把Nginx Ingress升级到新版本。一次错误配置，突然之间你的应用就没有流量了——哎哟！</p><p id="e01e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们决定采用这些应用程序使用他们的舵图。太好了！我们如何在这些掌舵图上应用IaC原则？您是否正在使用通过<code class="fe mf mg mh mi b">--set ...</code>设置的配置来部署舵图？这是命令式命令的经典例子。你在哪里追踪它？您能肯定地说一下当前应用于PROD中运行的应用程序的配置吗？我在<strong class="jp ir"> Helmfile </strong>中找到了这些问题的答案。如果Helm是Kubernetes资源的包管理器，那么Helmfile就是Helm本身的包管理器。疯狂吧？Helmfile允许您在多种环境中以声明方式定义您的helm部署。这里是一个<code class="fe mf mg mh mi b">helmfile</code>的例子，它可以在两个不同的Kubernetes集群中声明性地部署<code class="fe mf mg mh mi b">ingress-nginx</code>和<code class="fe mf mg mh mi b">external-dns</code> helm图表。</p><pre class="lp lq lr ls gt mj mi mk ml aw mm bi"><span id="67e4" class="mn km iq mi b gy mo mp l mq mr">environments:<br/>  my-dev-eks:<br/>  my-prod-eks:</span><span id="0253" class="mn km iq mi b gy mt mp l mq mr">repositories:<br/>  - name: ingress-nginx<br/>    url: <a class="ae me" href="https://kubernetes.github.io/ingress-nginx" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx</a><br/>  - name: bitnami<br/>    url: https://charts.bitnami.com/bitnami</span><span id="a5b2" class="mn km iq mi b gy mt mp l mq mr">helmDefaults:<br/>  {{ if eq .Environment.Name "my-dev-eks" }}<br/>  kubeContext: arn:aws:eks:eu-central-1:xxxx:cluster/my-dev-eks<br/>  {{ end }}<br/>  {{ if eq .Environment.Name "my-prod-eks" }}<br/>  kubeContext: arn:aws:eks:eu-central-1:xxxx:cluster/my-prod-eks<br/>  {{ end }}</span><span id="f90b" class="mn km iq mi b gy mt mp l mq mr">releases:<br/>  - name: nginx-ingress<br/>    namespace: nginx<br/>    createNamespace: true<br/>    chart: ingress-nginx/ingress-nginx<br/>    labels:<br/>      app: nginx-ingress<br/>    version: 3.3.0<br/>    values:<br/>      - apps/nginx-ingress/values-{{ .Environment.Name }}.yaml<br/>    secrets:<br/>      - apps/nginx-ingress/secrets-{{ .Environment.Name }}.yaml</span><span id="3c1e" class="mn km iq mi b gy mt mp l mq mr">  - name: external-dns<br/>    namespace: external-dns<br/>    createNamespace: true<br/>    chart: bitnami/external-dns<br/>    labels:<br/>      app: external-dns<br/>    version: 3.2.3<br/>    values:<br/>      - apps/external-dns/values-{{ .Environment.Name }}.yaml<br/>    secrets:<br/>      - apps/external-dns/secrets-{{ .Environment.Name }}.yaml</span></pre><p id="5afd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义好之后，在<code class="fe mf mg mh mi b">my-dev-eks</code>集群中部署Nginx入口就像下面这样简单:</p><pre class="lp lq lr ls gt mj mi mk ml aw mm bi"><span id="5561" class="mn km iq mi b gy mo mp l mq mr">helmfile -e my-dev-eks -l app=ingress-nginx apply</span></pre><p id="5c33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mf mg mh mi b">-e</code>选择环境，<code class="fe mf mg mh mi b">-l</code>选择通过标签发布。</p><p id="66fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单吧？当然，除了手动运行该命令，您还可以设置一个管道，在某些配置发生变化时自动运行该命令，但这超出了本博客的范围。</p><h1 id="54ad" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">业务应用层</h1><p id="e30e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">最后，我们来到模型的最后一层，这一层是我们最初采用Kubernetes的最终原因——业务应用层。这些应用程序为您的客户提供价值，并为您的企业赚钱。这是最后一局。容易忘记真正的目标，在Kubernetes迷失自我！</p><p id="20fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是您最熟悉的应用程序。你可能已经把它装箱了，或者正在去的路上。你可能也已经决定了如何创建你的Kubernetes资源:Kustomize，Helm Charts，Jsonnet等。将它们部署到不同的Kubernetes集群的最佳方式是什么？</p><p id="f564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到GitOps，在我的公司，我决定使用ArgoCD。FluxCD紧随其后，但ArgoCD最终胜出，因为它具有多租户、多集群、与Azure AD/OIDC的集成以及令人印象深刻的用户界面等特性。这些对我来说很重要。经过6个月的使用，我对这个选择非常满意。使用Kubernetes资源的Helm charts和持续部署的ArgoCD，开发人员的工作简化为简单地在Git存储库中提交新版本。将这个逻辑放入您现有的CI管道中，您就有了一个端到端的CI/CD管道，可以自动将新的提交部署到Kubernetes集群。</p><p id="5212" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个ArgoCD应用程序CRD规范的例子，它从包含在<code class="fe mf mg mh mi b">source</code>中定义的Kubernetes资源的Git存储库中读取数据，并将它们应用到在<code class="fe mf mg mh mi b">target</code>中定义的Kubernetes集群:</p><pre class="lp lq lr ls gt mj mi mk ml aw mm bi"><span id="3962" class="mn km iq mi b gy mo mp l mq mr">apiVersion: argoproj.io/v1alpha1<br/>kind: Application<br/>metadata:<br/>  name: my-awesome-app<br/>  finalizers:<br/>    - resources-finalizer.argocd.argoproj.io<br/>spec:<br/>  destination:<br/>    namespace: prod<br/>    server: https://kubernetes.default.svc<br/>  source:<br/>    path: my-awesome-helm-charts<br/>    repoURL: git@gitlab.com/my-awesome-app-resources-repo<br/>    targetRevision: master<br/>    helm:<br/>      valueFiles:<br/>        - values/values.yaml<br/>        - values/secrets.yaml<br/>  project: my-apps<br/>  syncPolicy:<br/>    automated: {}</span></pre><p id="81b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想知道为什么我没有使用Helmfile进行商业应用，即使我使用了Helm Charts。答案在于部署节奏。</p><h1 id="0b74" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">部署节奏</h1><p id="f120" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">部署节奏定义了软件新版本发布和部署的频率。在Kubernetes所有权模型中，部署节奏在第一层最慢，在最终的业务应用层最快。</p><p id="59b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一层，EKS和AK的新版本通常在Kubernetes新版本发布一个月后发布。EKS工人节点AMI版本发布更频繁，我们通常选择每月<strong class="jp ir">部署一次</strong>或更少。对于这样一个低节奏，Terraform符合要求。它不需要在集群或任何其他地方运行任何东西。它是管道在请求时调用的潜在代码。所有地形状态在不同的S3桶中维护。</p><p id="7b74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二层，基础设施应用程序的发布要频繁得多。根据发布的重要性和有用性，您可以选择每周<strong class="jp ir">或大约</strong>部署它们。Helmfile也不需要任何活动组件一直运行。它是另一段隐藏的代码，只在需要时才执行。非常适合这个节奏。</p><p id="28e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在业务应用程序层，部署节奏是最高的。新功能一直在增加，部署每隔一天进行一次，如果不是每天进行<strong class="jp ir"/>(这是梦想)。在这种节奏下，你需要最大的控制力和灵活性。ArgoCD有自己的应用程序控制器，它在集群中运行，每两分钟轮询一次Git存储库，寻找要应用到集群的更改。尽管Helmfile很好，但它不适合这一层的节奏要求。另外值得注意的是，ArgoCD实际上并没有部署helm版本，它相当于<code class="fe mf mg mh mi b">helm template | kubectl apply -f -</code>，有效地将Helm图表转换为直接应用于集群的原始Kubernetes资源的集合。对于我的商业应用程序，我更喜欢这个版本。</p><h1 id="0d96" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="b666" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在这篇博客中，我想强调Kubernetes采用之旅不仅仅是部署您的容器化业务应用程序。您可以很快开始，但要在不影响治理、安全性和可靠性的情况下保持生产规模，您需要将基础架构作为代码原则应用于整个基础架构堆栈。我希望这里介绍的Kubernetes所有权模型能够帮助您安全地开始这一旅程！</p></div></div>    
</body>
</html>