<html>
<head>
<title>Kubernetes for dummies: Deployment auto-scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes for dummies:部署自动伸缩</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-for-dummies-deployment-auto-scaling-28ad0f9da1df?source=collection_archive---------0-----------------------#2022-01-12">https://itnext.io/kubernetes-for-dummies-deployment-auto-scaling-28ad0f9da1df?source=collection_archive---------0-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="cbd2" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">KUBERNETES |云概念</h2><div class=""/><div class=""><h2 id="9121" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">第5部分—使用水平Pod自动缩放器</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fb750a5e74e8f782542d65d505d752ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8uNFXIsxwGCSEcCk"/></div></div></figure><p id="1e99" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">欢迎回来，我的绝地学徒伙伴！现在我们已经很好地掌握了使用原力的基本知识。让我们开始进入一些有趣的相邻概念。如果你需要复习，这里有我们到目前为止讨论过的内容的链接:</p><ul class=""><li id="df6e" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">第1部分kubernetes到底是什么？</li><li id="ef9a" class="lw lx iq lc b ld mg lg mh lj mi ln mj lr mk lv mb mc md me bi translated"><a class="ae mf" href="https://bit.ly/fawix-k8s-p2" rel="noopener ugc nofollow" target="_blank">第二部分——引擎盖下的一瞥</a></li><li id="b2b6" class="lw lx iq lc b ld mg lg mh lj mi ln mj lr mk lv mb mc md me bi translated"><a class="ae mf" href="https://bit.ly/fawix-k8s-p3" rel="noopener ugc nofollow" target="_blank">第三部分——豆荚的寿命</a></li><li id="3ac3" class="lw lx iq lc b ld mg lg mh lj mi ln mj lr mk lv mb mc md me bi translated"><a class="ae mf" href="https://bit.ly/fawix-k8s-p4" rel="noopener ugc nofollow" target="_blank">第4部分—部署和服务</a></li></ul><p id="c3fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在我们可以开始探索如何使用部署来实现一些很酷的东西，比如自动伸缩、自动修复和适度降级；这一部分将基于我们在第4部分中学到的概念。这篇文章是关于使用部署自动伸缩的！</p><h1 id="ebd5" class="ml mm iq bd mn mo mp mq mr ms mt mu mv kf mw kg mx ki my kj mz kl na km nb nc bi translated">自动缩放#WTF</h1><p id="dd7d" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">这是一个简单的概念:您的工作负载可以根据集群中的负载或工作负载资源进行伸缩。</p><p id="2c01" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我所说的扩大规模，实际上是指部署新的分离舱，然后缩小规模摧毁它们。为了实现这一点，Kubernetes有一个名为“Horizontal Pod AutoScaler”(又名HPA)的对象，它必须引用带有ReplicaSet的部署(第4部分)。幸运的是，一旦您在部署中定义了HPA，ReplicaSet就变成隐含的了。还有，有HPA控制器；它监视资源并更改ReplicaSet对象中的replicas值。HPA对象告诉k8s我们想要自动扩展部署，这样控制器就知道它应该监视Pod及其资源(啊哈！“构建模块”😉 ).</p><p id="c8c9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，这就是k8s中扩展的基本工作方式，但是请记住，我们需要一个参考点…工作负载是根据某个东西进行扩展的。那东西是豆荚资源。最基本的Pod资源是CPU和内存。群集自动监控它们的利用率，并保持相关的Pod资源对象是最新的；它使用一个度量服务器来实现这一点，该服务器通过查询每个节点的kubelet来聚集跨节点的度量。下面的图表是为了说明的目的，但是给你一个很好的感觉这是如何适合图片的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/04eeddd3891c9c88a475fcddc37dd0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qP2ztGvHIgNQn9YG"/></div></div></figure><p id="c8e1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此外，资源也可以是其他参数。任何可以作为Pod资源导入的内容都可以用作缩放参考。Kubernetes有一些机制可以做到这一点。度量服务器中最常见的“自定义度量”。也可以使用一个叫做“扩展资源”的对象。这有效地允许您从集群外部声明可能影响您的工作负载规模的资源(对于事件驱动的架构很有用)。让我知道，如果你想要一个关于这方面的帖子，我们可以进一步深入探讨！</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="601d" class="ml mm iq bd mn mo nq mq mr ms nr mu mv kf ns kg mx ki nt kj mz kl nu km nb nc bi translated">避免噪音邻居#最佳实践</h1><p id="e334" class="pw-post-body-paragraph la lb iq lc b ld nd ka lf lg ne kd li lj nf ll lm ln ng lp lq lr nh lt lu lv ij bi translated">我们应该讨论一下，是的，邻居！本质上，噪声邻居是消耗太多资源而损害集群中其他单元的单元。因此，为您的pod至少定义内存和CPU消耗(即使您没有使用HPA)是一个好的实践，以避免您的节点过度拥挤的风险。这样做的另一个好处是kubelet将跟踪节点中的CPU和内存利用率，因此控制平面可以为pod选择具有足够容量的节点。此外，当您定义最小值和最大值时，它允许pod通过从一开始就拥有专用的资源量来预热，并防止流氓工作负载在出现问题或容器受损的情况下消耗所有可用资源。</p><p id="b29e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">理想情况下，您应该测量一个Pod的工作负载资源消耗情况。负载测试是帮助您理解这一点的最佳工具。只需监视Pod的CPU和内存使用情况，同时确保应用程序保持稳定，并且在您的可靠性参数(延迟、可用性、错误率等)范围内。</p><p id="7910" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有几件事你应该考虑；把这个练习想象成一条高斯曲线，你选择什么取决于你的交通模式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/9de3877434a3d0a61d487bcc03c2efbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UxB0qkmVG86wc_NK"/></div></div></figure><p id="34ab" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">上图意在说明这一点:</p><ul class=""><li id="7cdc" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">最小负载(黄色):您得到的最低负载(这可能是空闲的或有涓流流量)</li><li id="1720" class="lw lx iq lc b ld mg lg mh lj mi ln mj lr mk lv mb mc md me bi translated">标称负载(蓝色):一个周期中选定的百分比，代表您的应用程序最常见的负载(例如一天中的第99或95个负载)</li><li id="fef8" class="lw lx iq lc b ld mg lg mh lj mi ln mj lr mk lv mb mc md me bi translated">峰值负载(红色):应用程序能够可靠服务的最大负载。</li></ul><p id="ae8f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您希望配置Pod资源，以便在达到峰值负载之前，在启动和扩大时请求额定或最小负载。您选择哪一个取决于您的应用程序花费时间最多的地方。当然，这种情况会随着时间的推移而改变，所以一定要经常重温这一点。主要版本或流量模式的变化是您的价值需要审查的良好指标。</p><p id="b423" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在你问我，这有这么多工作…我不能只是猜测吗？好吧，年轻的绝地学徒…没人会阻止你的！但是，要意识到这意味着什么。您可能会过早或过晚地结束扩展，也可能会阻塞比您需要的更多或更少的资源。因此，测量是更好的方法(即使是部分测量，让你做出一个有根据的猜测)。如果可以，消除猜测！！</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="e8dc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好了，回到我们的部署！让我们从定义部署中的资源开始。还记得第4部分中我们友好的NGINX部署吗？下面是为内存和CPU定义了资源的对象的样子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0203" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">正如您所看到的，我们不再需要告诉部署我们需要的副本数量(HPA将负责这一点)，因此我们删除了<code class="fe ny nz oa ob b">spec.replicas</code>。我们还设置了<code class="fe ny nz oa ob b">spec.containers.resources</code>字段，限制了我们需要多少CPU和内存。这也是您引用自定义指标的地方。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/511bfe8bd0b11d333d554319c51b1cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*SJ-4r4zShzpWITVd.jpg"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">信用:imgflip.com</figcaption></figure><p id="9724" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">关于读取CPU和内存值的侧边栏。他们第一眼看上去相当混乱！（</p><ul class=""><li id="46d7" class="lw lx iq lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">内存——以字节计量，可以用<em class="oh">二进制前缀</em> (Ki，Mi，Gi)或<em class="oh">十进制前缀</em> (K，M，G)来表示。</li><li id="7f99" class="lw lx iq lc b ld mg lg mh lj mi ln mj lr mk lv mb mc md me bi translated">CPU——以CPU单位衡量(这取决于您在哪里运行),对于裸机来说是1个超线程，但在GCP是1个内核。该指标允许分数，因此我们实际上可以请求半个CPU (0.5 —读作50%)。大多数工作负载实际上不会占用那么多，所以kubernetes使用“m”前缀来表示milli(在<em class="oh">十进制前缀</em>中)——因此请求200m相当于请求0.2个单位的CPU(又名:20%的CPU利用率)。</li></ul><p id="d3ec" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我强烈建议您选择二进制或十进制前缀。保持所有部署文件的一致性，尤其是对于大规模工作负载。</p><p id="885a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我希望这有用！)</p><p id="8448" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在添加HPA很简单…算是吧。HPA对象仍在发展。特别注意你选择的<code class="fe ny nz oa ob b">apiVersion</code>(<code class="fe ny nz oa ob b">autoscaling/v1</code>vs<code class="fe ny nz oa ob b">autoscaling/v2beta2</code>)。在v2上，您可以扩展多个指标，而v1不能。这里我们用的是v2口味。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="94b7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">出于自动扩展的目的，我们定义了Pod资源。我们还定义了升级应该发生的消耗阈值。HPA控制器将每15秒查询一次资源(默认)，并根据阈值和实际消耗进行调整。正如你在上面的对象上看到的，那是<code class="fe ny nz oa ob b">spec.metrics[].resource.target</code>字段；它通过<code class="fe ny nz oa ob b">spec.scaleTargetRef</code>字段链接回部署。</p><p id="c220" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们来看看这个动作——抓住上面的YAML，跟着做吧！现在你已经非常熟悉<code class="fe ny nz oa ob b">kubectl apply</code>了，所以我将跳过这一步。让我们专注于酷的东西！</p><p id="e92b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">是时候检查部署了！您可以看到资源参数和副本集；请注意，它从单个pod开始。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/b41017f2843174f7a8100d4f166e7703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qSRjJJAlqEk9UKbP"/></div></div></figure><p id="26a0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们检查实际的HPA对象，注意指标部分:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/43045cac7e3b37bb17b4175b74f8542d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KGUM4bvFU0MHpqJU"/></div></div></figure><p id="e866" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如您所见，它引用了我们的nginx部署，当前部署的pod数量是一个。现在，作为一个快速测试，我们可以生成一些负载并查看自动伸缩的效果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/1bf09283ac894e64b24495978625312f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2GSgEEXzWZ09tHjj"/></div></div></figure><p id="3645" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">进行自动扩展配置需要做几件事情。然而，从你所拥有的开始。如果你不能做预测或者没有所有需要的数据(我看到你的新应用)，它不应该阻止你从足够好的数字开始。你可以随着时间的推移进行微调。</p><p id="167f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是一个非常酷的概念，可以进一步探索，我建议花一些时间来玩这个配置；作为一个练习，试着预测你将使用3、5和10个吊舱的TPS，看看你是否正确。注意到负载消失后缩减所需的时间了吗？在不同的交通模式下会有怎样的表现？</p><p id="250c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">像往常一样，如果你还没有你的集群<a class="ae mf" href="https://www.katacoda.com/courses/kubernetes/playground" rel="noopener ugc nofollow" target="_blank"> Katacoda游乐场</a>仍然是一个选择。你也可以使用<a class="ae mf" href="https://cloud.google.com/free" rel="noopener ugc nofollow" target="_blank">免费等级和GCP </a>的积分来创建一个你可以玩的GKE集群！</p><p id="3553" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在这篇文章中，我们回顾了如何实现部署的自动伸缩，在下一篇文章中，我们将关注自动修复、适度降级，这使我们能够在kubernetes中创建更具弹性的工作负载。</p><p id="ef21" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">到目前为止你喜欢这个系列吗？让我知道！另外，请在<a class="ae mf" href="https://twitter.com/fawix" rel="noopener ugc nofollow" target="_blank">推特(@fawix) </a>或<a class="ae mf" href="https://www.linkedin.com/in/fatimasilv/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，这样你就不会错过更新了！愿集装箱与你同在！</p></div></div>    
</body>
</html>