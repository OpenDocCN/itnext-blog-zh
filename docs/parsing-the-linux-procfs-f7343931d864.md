# 解析 Linux procfs

> 原文：<https://itnext.io/parsing-the-linux-procfs-f7343931d864?source=collection_archive---------7----------------------->

![](img/ea94037894df6a79b32a4d589dc6ea46.png)

[***→链接到 Github 上的库***](https://github.com/dtrugman/pfs)

我为 Unix 环境编写 C++代码已经快十年了。有趣的是，在过去的五年里，在为三家不同的公司工作时，我每次都必须编写一个新的 procfs 解析库。所有这些公司都在开发安全产品，监控运行在 Linux 机器上的应用程序，所以使用 procfs 是不可避免的。
但久而久之，必要性变成了极大的赞赏。我只是越来越喜欢这个叫做 procfs 的神奇的发明。有幸编写了使用相同机制输出值的 Linux 内核代码，我也体验了事情的另一面，并且更加喜欢它。

由于我没有读过很多来自图书馆作者的博客帖子，而且我开始写作已经有一段时间了，所以我决定记录下我正在经历的心理过程。希望这能成为一篇有趣的读物，或者更好的是，让我接触到读者和我可以从中学习的想法。这篇博客文章是关于我写的 [*pfs* 库](https://github.com/dtrugman/pfs)，我所做的决定以及我为什么做这些决定。

# 式样

我努力对自己诚实，承认我意识到的错误。其中之一是“轻微”强迫症。例如:看一个标准大小的屏幕，屏幕上有 60 行代码，我很容易忽略一些没有对齐的行。当我开始编码的时候，它困扰着我，在工作的时候，它困扰着我，它可能会一直困扰着我。我相信，我们感知和理解代码的能力很大一部分依赖于我们的潜意识与所见同步的能力，并知道会发生什么。
这就是为什么**任何编码标准总比没有标准好**。我见过伟大的开发人员浪费数小时试图阅读和理解与他们习惯的格式不同的代码(不，不是那些用 IDA 做代码评审的)。
对于那些取笑我的人，请记住，伟大的开发人员通常是逻辑技能非常发达的结构化人员。为了利用这些技能，你必须确保所有的部分都很好地结合在一起。

总而言之，我决定通过简单地添加一个带有预提交钩子的 clang-format 配置来防止这个问题在这里发生。我真的希望这个项目能够成长，其他人也愿意参与进来，确保代码是可访问的&对其他人有吸引力是一件大事。

# 命名规格

这是一个漫长而艰难的过程。我尝试了至少 3 种不同的风格，但后来决定采用(几乎)与标准库相同的惯例。
**优点:**

*   对大多数 C++开发人员来说很熟悉，感觉很自然
*   被许多其他广泛使用的库使用，包括:boost、fmt 和 spdlog
*   传达了它是一个库的事实，因为大多数应用程序使用不同的风格(是的，我觉得这很讽刺，但仍然…)

**缺点:**

*   因为类型名都是小写的，所以有时不能对变量使用简单明了的名称。

我对标准库的一个偏离是私有枚举和常量值所选择的样式。我觉得保留那些小写字母会让解析包含许多常量的代码变得非常困难，所以我决定将它们改为大写的 snake_case 的 C POSIX 风格。

# 应用程序接口

就我个人而言，我使用 VIM 编写代码，没有任何智能形式的自动完成。当我用 C、C++、Bash、Python 或其他我熟悉的语言写代码时，我会这样做。我为什么要告诉你这些？因为对我来说，**可预测的**API 就是一切。我喜欢标准库，因为所有容器的行为都是一样的。
是的，我知道你不能`emplace_back`进入`std::set`，但是如果你了解你的容器，这是一个很容易遵守的约束。

这就是为什么我试图让 API 的名字尽可能容易预测。
我问自己，当我试图从`/procfs`中挖掘一些信息时，我希望别人怎么做？我得到的答案是:

*   使用交互式 shell 来查找包含该位的文件
*   将路径转换成函数调用:`/proc/net/tcp6`会变成`procfs().get_net().get_tcp6()`

但是因为所有的规则都是被打破的，所以也有一个例外。由于一些 API 实际上是底层目录的包装器，例如`/proc/[pid]/fd`，我决定目录的 API 将采用复数形式:`procfs().get_task([pid]).get_fds()`。

# 分解成子 API(和子类)

将所有方法放在一个 API 下根本不是一个选项。如果你还不明白，我是某些代码实践的忠实追随者。其中之一是将代码分解成小单元，每个单元负责一项任务。

幸运的是，procfs 已经被很好地分解了，遵循相同的结构是最简单的解决方案。

所有直接在`procfs`下的文件都被映射到`procfs`对象的方法。并且该对象是库中唯一的“入口点”。如果一个人想要与一个特定的任务交互，它可以要求`procfs`对象为他获取一个`task`对象。如果您希望从该任务的网络名称空间获得一些信息，您可以请求`net`对象。

决定只允许通过`procfs`对象创建`task`对象有两个目的:

1.  对 procfs 子系统安装在定制位置的系统的无缝支持——一旦您创建了具有实际路径的根`procfs`对象，它创建的所有对象都已经知道这个“系统配置”,让您在运行时初始化其他对象时不必总是传递路径。
2.  允许更容易的未来可扩展性。因为所有属性都可以无缝地从主`procfs`对象向下传播到`task`对象。

# 类型和返回值

因为这是一个“美化”的解析器，而且解析器都是为了获得您想要的信息，所以我决定返回值应该尽可能简单易用，并决定只使用枚举和结构(而不是类)。
我避免使用访问器(getters 或 setters ),因为我不能预测所有可能的用例。更自然的做法是返回原始信息，让调用者来处理。

接下来是结构中的变量名。我尽量让这些名字接近终极指南 proc(5)中描述的名字。在没有特定名称的地方，我试图与 Linux 的命名约定保持一致。

有一些类型，如`ip`或 `cap_mask`结构，我在其中包装了原始值并添加了助手方法。在撰写本文时，我不知道这个库的潜在用户可能想要什么。我只是假设对某些类型有用的实用程序，比如对功能屏蔽的每功能 getter(`cap_mask`)，可能肯定是一个受欢迎的增强。

为了保持简单明了，我做的另一个决定是避免标准容器类型的别名。例如，`get_cmdline`返回一个`std::vector<std::string>`，而不是某个`cmdline_args`类型。我发现 API 中的这种明确性有助于预测输出格式，从而支持我的主要设计目标。

# 错误处理

我想错误处理是现代 C++编写中的主要难点之一。
就语言版主而言，官方的立场是使用例外来使其更加干净和安全。但是，当像 Google 这样的大组织正式在他们的编码指南中阻止例外时，这个决定从来都不容易。
说实话，我们在工作中也有同样的反例外惯例。在我看来，两种形式都能很好的发挥作用，这里最重要的是**一致**。
由于我使用的是标准库，代码很容易被抛出异常，主要是`bad_alloc`。
我不想在内部包装我所有的方法，将分配问题转化为`ENOMEM`，我还希望能够编写 RAII 代码。因此，我决定提供一致的体验，希望当用户调用该库的 API 时，他们也足够明智地处理底层异常。

# 下一步是什么

我必须做出的最艰难的决定之一是:“什么是最有价值球员？”

每个公司都知道，在首次向市场推出新产品和/或新功能时，这个问题非常重要。如果过早，客户根本不会用。如果它太成熟了，很有可能你在没人会使用的额外功能上投入了大量的工作。

如果你看看我为 v0.1.0 发布的代码(第一个、最新的和目前唯一可用的版本)，我决定覆盖 80%最有趣的(当然是我的主观观点)文件。当然，其中一些文件被解析到位分辨率；比如来自`/proc/[pid]/status`的能力掩码，而其他的只是用户可以嵌入到他们的日志文件中的单个字符串，比如`/proc/cmdline`。我决定在投入更多时间之前，先看看人们对此有何反应。

然而，我确实有很多想法在酝酿中，我只能希望这个项目得到一些牵引，我可以把它们付诸实施。

就这样，我希望这是一个简单而有趣的阅读。你可以在 [Github](https://github.com/dtrugman/pfs) 上找到这个项目的源代码。我很高兴听到你的意见，更高兴知道你正在使用它。