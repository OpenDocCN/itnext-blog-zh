<html>
<head>
<title>Go Modules Done Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋模块做得更好</h1>
<blockquote>原文：<a href="https://itnext.io/go-modules-done-better-ae09783ae2f8?source=collection_archive---------3-----------------------#2020-10-03">https://itnext.io/go-modules-done-better-ae09783ae2f8?source=collection_archive---------3-----------------------#2020-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c10ff6ceec54067ae1f52bd17fd970df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ggiOBoBQPYy4SSem.jpg"/></div></div></figure><blockquote class="kb kc kd"><p id="32fd" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我之前的文章<a class="ae ld" href="https://medium.com/@ckeyes88/go-modules-in-real-life-87a21fb4d8aa" rel="noopener">现实生活中的围棋模块</a>的后续</p></blockquote><p id="d506" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">一年多前，我发表了一篇文章，详细介绍了我和我在<a class="ae ld" href="https://helpfulhuman.com" rel="noopener ugc nofollow" target="_blank">的团队如何使用go模块建立我们的项目。我们使用了一个多模块repo，并使用了<code class="fe lh li lj lk b">replace</code>指令将Go工具链指向相对路径模块。如果你对我们是如何做到的感兴趣，你可以回去看看上面链接的那个帖子。</a></p><h2 id="c6ed" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">我们最初的方法</h2><p id="2b4e" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">如果你读过我的前一篇文章，你会记得我们的项目由一个不断增长的webhook处理程序集合组成。这些webhooks都是单独的AWS Lambda函数，作为独立的可执行文件。他们还共享了许多功能，因为他们都来自同一个应用程序。因此，我们包含了一些共享数据结构、数据库访问库等。在这个项目中，我们建立了一个多模块存储库。我们在<code class="fe lh li lj lk b">go.mod</code>文件中使用Go的<code class="fe lh li lj lk b">replace</code>指令来告诉任何模块在哪里可以找到本地依赖。</p><p id="f92d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这使得我们可以在不同的webhooks上共享模块。它还允许我们将所有代码保存在同一个存储库中。我们不必跨7个以上的webhooks复制代码，也不必为每个web hooks建立单独的CI/CD管道。我们可以根据你认为微服务应该有多微来讨论最后一个目标的优点，但这是另一篇文章的主题。</p><p id="05c8" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">老实说，让这些网络钩子工作起来，我也有点时间紧张。所以当它起作用时，我非常兴奋，没有考虑其他的解决方案。</p><p id="614d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我在之前的文章中已经列出了这些细节。也就是说，自从写了那篇文章后，我的心和思想最近发生了变化。</p><h2 id="6ba0" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">那种挥之不去的感觉</h2><blockquote class="kb kc kd"><p id="c507" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你从来没有写过让你想在一个月甚至一个星期后回去重写的代码，那么你做代码的时间还不够长。</p></blockquote><p id="aa2c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">自从我们设置了webhooks并按预期工作后，我就有一种挥之不去的感觉，我的解决方案有点粗糙。<em class="kg">我肯定你们没有人知道这是什么感觉，因为你们从一开始就写出了完美的代码，但是请你迁就我一下</em></p><p id="3b0d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Russ Cox(核心Go贡献者)证实了我的怀疑，他说你应该谨慎使用多模块回购。我知道我需要找到一个更好的方法来解决这个问题，但是直到最近我才有时间去做这件事。</p><p id="7fb9" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">让我们进入一些代码，看看在过去的一年里，我们的回购发生了怎样的变化。</p><h2 id="00cb" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">一个模块来管理它们</h2><p id="3339" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">如果你跟随我之前的介绍，那么你会认出一些代码。</p><p id="bc59" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">为了让您跟上我们的进度，我们有三个模块。其中两个是独立的可执行文件，作为简单的web服务器工作。这些可以是任何有主要功能的东西。第三个是表示共享逻辑的日志库。它可以是一个数据库连接、中间件或者任何不作为主可执行文件运行的东西。原始文件结构应该与您在下面看到的相匹配:</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="04ee" class="ll lm it lk b gy mr ms l mt mu">/my_project<br/>    /web_server<br/>        go.mod<br/>        go.sum<br/>        main.go<br/>    /logger<br/>        go.mod<br/>        go.sum<br/>        logger.go<br/>    /web_server_two<br/>        go.mod<br/>        go.sum<br/>        main.go</span></pre><h2 id="4a61" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">步骤1:组合成一个模块</h2><p id="2055" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">我们要做的第一件事是删除三个子模块。</p><p id="798d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">为此，删除所有子目录中的<code class="fe lh li lj lk b">go.mod</code>和<code class="fe lh li lj lk b">go.sum</code>文件。如果你刚刚加入我们，创建一个顶级工作目录和三个子目录，就像你在上面看到的那样。</p><p id="bd4b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">接下来，我们将在顶层目录中创建一个新的单个模块。为此，请运行以下命令:</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="0b36" class="ll lm it lk b gy mr ms l mt mu">go mod init github.com/&lt;GH USERNAME&gt;/myproject</span></pre><blockquote class="kb kc kd"><p id="b984" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">关于模块名的旁注。实际上你可以给它起任何你想起的名字，但是有一些理由说明为什么坚持使用github url是好的。只有当你打算把它作为一个公共的go模块发布时，这个命名约定才是重要的。如果它是一个私有模块，那么你想怎么命名就怎么命名。这也有助于Go&lt;1.11. To my knowledge this only matters if you’re building a module for use with &lt;1.11 so if you’re not then don’t worry about it.</p></blockquote><p id="b46b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">At the end of this, your file structure should match what’s below.</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="0836" class="ll lm it lk b gy mr ms l mt mu">/my_project<br/>    go.mod<br/>    /web_server<br/>        main.go<br/>    /logger<br/>        logger.go<br/>    /web_server_two<br/>        main.go</span></pre><p id="8ff1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">We now have a single go module (or the start of one) that contains two executables and a shared logging library. The `go.mod` file will be empty except for the two lines below:</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="c265" class="ll lm it lk b gy mr ms l mt mu">module github.com//my_project<br/><br/>go 1.12</span></pre><h2 id="9d7a" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">Step 2: Update the Logger</h2><p id="7d92" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">I’ve switched up the logger a little from the last post to show a 3rd party dependency. I’ll be using the logging library `logrus` which I wrapped with my own logger package. In a real project, you might do this so that you can report a log to multiple outputs, create a middleware function and to make it easy to mock for testing.</p><p id="021d" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">In our case, we’re going to wrap the logrus library and expose a log function for each of our severity levels, `error`, `warn`, `info`, and `debug`. Your logger should match my logger file below:</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="2210" class="ll lm it lk b gy mr ms l mt mu">package logger<br/><br/>import (<br/>    log "github.com/sirupsen/logrus"<br/>)<br/><br/>// Logger is a base struct that could eventually maintain connections to something like bugsnag or logging tools<br/>type Logger struct {<br/>    serviceName string<br/>}<br/><br/>// NewLogger creates a new instance of the custom logger struct and returns it<br/>func NewLogger(serviceName string) *Logger {<br/>    var l = new(Logger)<br/>    l.serviceName = serviceName<br/><br/>    return l<br/>}<br/><br/>// LogDebug is a publicly exposed info log that passes the message along correctly<br/>func (l *Logger) LogDebug(messages ...interface{}) {<br/>    log.WithField("service-name", l.serviceName).Debug(messages)<br/>}<br/><br/>// LogInfo is a publicly exposed info log that passes the message along correctly<br/>func (l *Logger) LogInfo(messages ...interface{}) {<br/>    log.WithField("service-name", l.serviceName).Info(messages)<br/>}<br/><br/>// LogWarning is a publicly exposed info log that passes the message along correctly<br/>func (l *Logger) LogWarning(messages ...interface{}) {<br/>    log.WithField("service-name", l.serviceName).Warn(messages)<br/>}<br/><br/>// LogError is a publicly exposed info log that passes the message along correctly<br/>func (l *Logger) LogError(messages ...interface{}) {<br/>    log.WithField("service-name", l.serviceName).Error(messages)<br/>}</span></pre><p id="9606" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">Once you get the logger in place you can run `go get -u` to fetch the `logrus` dependency. Note that this is the package `logger` which is inside the module `github.com/<gh username="">/my _ project’的向后兼容性。</gh></p><p id="8d59" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">现在，让我们通过将它导入到我们的一个主要应用程序中来测试一下。</p><h2 id="1c1f" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">步骤3:导入您的子包</h2><p id="4a1e" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">现在我们已经设置了这个子包，我们可以使用“import”github . com/<gh username="">/my _ project/<sub pkg="">" '将它导入到这个项目中的任何其他地方。</sub></gh></p><p id="9a04" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">让我们通过将它导入到我们的web服务器来看看它的运行情况。</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="6bae" class="ll lm it lk b gy mr ms l mt mu">package main<br/><br/>import (<br/>    "net/http"<br/><br/>    "github.com/ckeyes88/my_project/logger"<br/>)<br/><br/>func main() {<br/>    // Create a new logger initialized with the service name<br/>    l := logger.NewLogger("Web Server 1")<br/><br/>    // wrap our hello handler function<br/>    http.Handle("/hello", loggerware(l, http.HandlerFunc(handle)))<br/>    http.ListenAndServe(":5600", nil)<br/>}<br/><br/>func handle(w http.ResponseWriter, r *http.Request) {<br/>    w.Write([]byte("world"))<br/>}<br/><br/>// loggerware can wrap any handler function and will print out the datetime of the request<br/>// as well as the path that the request was made to.<br/>func loggerware(l *logger.Logger, next http.HandlerFunc) http.HandlerFunc {<br/>    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>        requestPath := r.URL<br/>        l.LogInfo("Request Made To: ", requestPath)<br/>    })<br/>}</span></pre><p id="4fa3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">正如你所看到的，我们几乎不需要改变我们的web服务器。我们所做的唯一更改是对logger构造函数的更改，因为我们添加了那个初始化函数。</p><h2 id="ea5c" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">步骤4:更新Web服务器2</h2><p id="f9a1" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">最后，为了证明它的可共享性和对多模块版本的模仿，让我们添加第二台web服务器，巧妙地命名为“web_server_two”。</p><p id="1e7c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">将此代码添加到您的“web_server_two/main.go”文件中:</p><pre class="mj mk ml mm gt mn lk mo mp aw mq bi"><span id="b1fa" class="ll lm it lk b gy mr ms l mt mu">package main<br/><br/>import (<br/>    "net/http"<br/><br/>    "github.com/ckeyes88/my_project/logger"<br/>)<br/><br/>func main() {<br/>    l := logger.NewLogger("Web Server 2")<br/><br/>    http.Handle("/valar-morghulis", loggerware(l, http.HandlerFunc(handle)))<br/>    http.ListenAndServe(":5500", nil)<br/>}<br/><br/>func handle(w http.ResponseWriter, r *http.Request) {<br/>    w.Write([]byte("valar dohaeris"))<br/>}<br/><br/>func loggerware(l *logger.Logger, next http.HandlerFunc) http.HandlerFunc {<br/>    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>        requestPath := r.URL<br/>        l.LogInfo("Request Made To Server Two: ", requestPath)<br/>    })<br/>}</span></pre><p id="dd24" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">正如您所看到的，在模块的任何地方导入共享日志库都没有问题。当您运行它时，您会看到与相应的服务名称相对应的特定消息。这演示了一种更简单的方法来在许多主要的可执行文件之间共享代码。</p><h2 id="2289" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">为什么我们应该避免替换，什么时候应该使用它？</h2><p id="2e00" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">最后，我想提出一些相对于原始解决方案的改进。我还想提供一两个你可能仍然使用<code class="fe lh li lj lk b">replace</code>指令的理由。</p><p id="d7c9" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如您所见，对于相同的功能，该解决方案的维护量要少得多。当您试图实现我们的初始目标时，多模块方法没有任何真正的好处:</p><ul class=""><li id="a580" class="mv mw it kh b ki kj km kn le mx lf my lg mz lc na nb nc nd bi translated">单个共享子包</li><li id="0355" class="mv mw it kh b ki ne km nf le ng lf nh lg ni lc na nb nc nd bi translated">多个主可执行文件和一个repo</li><li id="aed9" class="mv mw it kh b ki ne km nf le ng lf nh lg ni lc na nb nc nd bi translated">单个CI/CD管道</li></ul><p id="b161" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">多模块方法增加了不必要的复杂性，因为它迫使您管理所有子模块之间的独立依赖关系。</p><p id="5b46" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">没有任何理由按照我在上一篇文章中的方式使用多模块存储库。多模块方法的一个更合理的用例是隔离您的模块的一个版本，该版本在您的存储库中总是可用的。这允许您在主控级别对主版本进行潜在的重大更改。Go团队提供了这个例外，因为他们知道人们可能希望在进行重大更改之前锁定当前的稳定版本。</p><p id="747a" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><code class="fe lh li lj lk b">replace</code>的另一个好的用例是当你对另一个项目中使用的Go模块进行局部修改时。这是在本地测试您的开发变更的好方法，这样您就不必在每次想要测试时发布新版本的Go模块。</p><h2 id="207a" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">结论</h2><p id="0a88" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">希望这能给你更多的工具来构建你的Go模块。谢谢你读到这里。如果您有任何问题或意见，请随时使用下面的表格联系我们！</p><h2 id="8aa0" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">更多资源</h2><p id="c737" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">这里有一些继续学习围棋模块的好资源。</p><ul class=""><li id="a9e8" class="mv mw it kh b ki kj km kn le mx lf my lg mz lc na nb nc nd bi translated"><a class="ae ld" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank">官方文件</a></li><li id="04a8" class="mv mw it kh b ki ne km nf le ng lf nh lg ni lc na nb nc nd bi translated"><a class="ae ld" href="https://research.swtch.com/vgo" rel="noopener ugc nofollow" target="_blank">更多来自围棋模块作者</a></li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="d61e" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">非常感谢你读到这里！如果你喜欢这篇文章，一定要与他人分享。如果你有任何想法或问题，请留下评论。如果你想知道新文章发布的时间，你可以在我的网站上注册我的邮件列表。</p><p id="54cd" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><em class="kg">原载于</em> <a class="ae ld" href="https://www.chipkeyes.me/go-modules-done-right/" rel="noopener ugc nofollow" target="_blank"> <em class="kg">芯片博客</em> </a> <em class="kg">。</em></p></div></div>    
</body>
</html>