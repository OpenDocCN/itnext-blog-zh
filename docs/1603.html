<html>
<head>
<title>Use Recursion with Reducers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用递归和归约器</h1>
<blockquote>原文：<a href="https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af?source=collection_archive---------2-----------------------#2018-12-08">https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af?source=collection_archive---------2-----------------------#2018-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/340a0bbf86d5ec4926929328322c8f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPr1Dhzh8XB2BckHqZkrQ.png"/></div></div></figure><h2 id="f3d7" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">表情符号爱好者的函数式编程指南</h2><div class=""/><div class=""><h2 id="28e7" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">功能组合、减压器和换能器模式的高级使用。</h2></div><p id="f2c9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">用表情符号和JavaScript学习函数式编程。代码示例应该足够简单，不需要任何先验知识就可以理解，但是我可以想象它看起来有点奇怪。还有，JavaScript实际上不允许表情符号作为JavaScript变量名。出于这个原因，这些代码示例不会在没有修改的情况下运行。</em></p><ul class=""><li id="5d08" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener"> <em class="lv">用食物表情符号制作便便。</em> </a></li><li id="4cf2" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener"> <em class="lv">把暴风云变成晴朗的云。</em>T12】</a></li><li id="34ed" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener"> <em class="lv">用减速器造独角兽！</em> </a></li><li id="f0f3" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener"> <em class="lv">管道操作员现在！</em> </a></li><li id="cb51" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener"> <em class="lv">为食肉动物过滤肉类。</em>T24】</a></li><li id="e0fe" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener"> <em class="lv">使用递归与归约。</em> </a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="8f7c" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">仍然有一些情况，你可能仍然需要一个<code class="fe ms mt mu mv b">for</code>循环，或者你是这样想的。为什么不用递归？因为复杂？那又怎样？自从JavaScript有了尾递归，你就可以在调用一个反复调用自己的函数时防止内存溢出(<strong class="lb jl">编辑:</strong>尾递归被移除)。</p><p id="ce9b" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">不过，递归是一个复杂的话题，不一定是函数式编程的一部分。相反，我将解释我们如何使用归约器来模拟递归。</p><p id="d8b5" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们先看看我们的老朋友，那个讨厌的<code class="fe ms mt mu mv b">for</code>循环，然后尽快切换到一个功能性的reducer模式:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7238" class="ne nf jb mv b gy ng nh l ni nj">food = [🍔, 🍟, 🍪]<br/>initialValue = 🍽️</span><span id="2591" class="ne nf jb mv b gy nk nh l ni nj">reducedValue = initialValue</span><span id="1d8f" class="ne nf jb mv b gy nk nh l ni nj">for (let i = 0, l = food.length; i &lt; l; i++) {<br/>    reducedValue += food[i]<br/>}</span><span id="9294" class="ne nf jb mv b gy nk nh l ni nj">💩 = reducedValue</span></pre><p id="4223" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">看起来很合法，对吧？这一过程将食物减少为其他东西；在这种情况下，减少值为💩。我们现在做的是求和。把我们的食物和盘子加在一起，我们得到💩。</p><p id="079f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们可以把这种缩减归结为一个叫做“缩减器”的<code class="fe ms mt mu mv b">eat</code>函数:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3013" class="ne nf jb mv b gy ng nh l ni nj">eat = (combined, value) =&gt; (<br/>    combined + value<br/>)</span></pre><p id="33b7" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">Reducers是接受两个值并返回一个新值的函数。第一个值是总计或累加器，第二个值是循环中的当前项。</p><p id="b8cc" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">数组有一个<code class="fe ms mt mu mv b">reduce</code>方法，它接受一个缩减器和一个初始状态。这是一个类似的概念，你可能在流行的州立图书馆<a class="ae mf" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>中见过。</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="fed0" class="ne nf jb mv b gy ng nh l ni nj">💩 = [🍔, 🍟, 🍪].reduce(eat, 🍽️)</span></pre><p id="c7d9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">第一个值是我们的<code class="fe ms mt mu mv b">eat</code>函数，第二个值是我们的初始状态:🍽️.</p><p id="cfe3" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是一个非常简单的缩减器，但是我们还可以做更多的事情，比如创建新的数组或者把一个数组变成一个对象，数字，字符串，你能想到的！</p><p id="45e0" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">下面是从<code class="fe ms mt mu mv b">reduce</code>创建一个<code class="fe ms mt mu mv b">filter</code>方法的样子:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="829e" class="ne nf jb mv b gy ng nh l ni nj">filterReducer = (<br/>    condition,<br/>) =&gt; (<br/>    combined,<br/>    value,<br/>) =&gt; (<br/>    condition(value)<br/>    ? combined.concat(value)<br/>    : combined<br/>)</span></pre><p id="05df" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果<code class="fe ms mt mu mv b">condition(value)</code>是<code class="fe ms mt mu mv b">true</code>，那么用那个值创建一个新数组；否则，返回前一个数组。我们在这里所做的是创建类似于<code class="fe ms mt mu mv b">Array.prototype.filter</code>的东西。它在第一次被调用时接受一个条件，然后返回一个reducer。</p><p id="35db" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们看看它的实际效果吧！：</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d8bc" class="ne nf jb mv b gy ng nh l ni nj">handFilterReducer = (<br/>    filterReducer(value =&gt; (<br/>        value<br/>        .includes(✋)<br/>    ))<br/>)</span><span id="ecec" class="ne nf jb mv b gy nk nh l ni nj">[🤷, 💁, 🙋] = (<br/>    [🤷, 💁, 🙋, 🙍]<br/>    .reduce(handFilterReducer)<br/>)</span></pre><p id="1c3a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe ms mt mu mv b">handFilterReducer</code>检查数值是否包含手牌。然后，我们将它传递到我们的缩减器中，并过滤掉没有手的人。</p><p id="bd53" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">首先，没有初始状态。当您有一个数组时，它将第一个数组值与初始状态相结合，但是如果您没有传入一个数组，那么<code class="fe ms mt mu mv b">reduce</code>将第一个数组值与第二个数组值相结合。</p><p id="89d2" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这种方法使用了我们在第一部分的<a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener">中讨论过的叫做合成的东西。这在函数式编程中非常重要，因为它允许你通过组合函数来创建新的函数。</a></p><p id="e060" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">因为我们将<code class="fe ms mt mu mv b">filterReducer</code>开发为一个返回函数的函数，所以我们能够像在第一部分中编写<code class="fe ms mt mu mv b">add</code>来创建<code class="fe ms mt mu mv b">addLightning</code>一样编写<code class="fe ms mt mu mv b">filterReducer</code>来创建<code class="fe ms mt mu mv b">handFilterReducer</code>。</p><p id="8d69" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">像<code class="fe ms mt mu mv b">filterReducer</code>这样的缩减器对于状态管理很有用。如果你的值对这个缩减器没有任何作用，那么这个缩减器就返回之前的状态。</p><p id="02ec" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们看一个状态管理的例子:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1f25" class="ne nf jb mv b gy ng nh l ni nj">countReducer = (<br/>    total,<br/>    value,<br/>) =&gt; (<br/>    value<br/>    ? total + 1<br/>    : total<br/>)</span><span id="7555" class="ne nf jb mv b gy nk nh l ni nj">4️⃣ = (<br/>    [🤷, 💁, 🙋, 🙍]<br/>    .reduce(countReducer, 0)<br/>)</span></pre><p id="dbbb" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们的<code class="fe ms mt mu mv b">total</code>是数组项数的和。<strong class="lb jl">挺没用的对吧？</strong></p><p id="c7f5" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们来看一个真实的例子！：</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8cd7" class="ne nf jb mv b gy ng nh l ni nj">partitionReducer = (<br/>    getPartitionName,<br/>) =&gt; (<br/>    paritions,<br/>    value,<br/>) =&gt; ({<br/>    ...partitions<br/>    [getPartitionName(value)]: {<br/>        ...partitions[getPartitionName(value)]<br/>        value,<br/>    }<br/>})</span></pre><p id="70f9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">尽管看起来很复杂，但这是一个将我们的状态分割或拆分成多个其他状态的缩减器。它需要一个初始函数，就像我们的<code class="fe ms mt mu mv b">filterReducer</code>；在这种情况下，它是一个函数，它获得了我们将要用来划分状态的名称。</p><p id="451f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">综上所述，<code class="fe ms mt mu mv b">partitionReducer</code>拿了我们的状态，又创造了一个新的。我们的状态由一个数组对象组成，我们给它多少数组，<code class="fe ms mt mu mv b">partitionReducer</code>就可以维护多少数组。</p><p id="ebb8" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这是它在使用中的样子:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e38e" class="ne nf jb mv b gy ng nh l ni nj">bunchPartitionReducer = (<br/>    partitionReducer(value =&gt; (<br/>        value<br/>        .isBunch<br/>        ? 'multiple'<br/>        : 'single'<br/>    ))<br/>)</span><span id="b7ce" class="ne nf jb mv b gy nk nh l ni nj">initialState = {<br/>    single: [],<br/>    multiple: [],<br/>}</span><span id="15f9" class="ne nf jb mv b gy nk nh l ni nj">{<br/>    single: [🍈, 🍋],<br/>    multiple: [🍇, 🍒],<br/>} = (<br/>    [🍇, 🍈, 🍒, 🍋]<br/>    .reduce(<br/>        bunchPartitionReducer,<br/>        initialState,<br/>    )<br/>)</span></pre><p id="a566" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">再次注意构图。我们创作了<code class="fe ms mt mu mv b">partitionReducer</code>来创造<code class="fe ms mt mu mv b">bunchPartitionReducer</code>。我们用<code class="fe ms mt mu mv b">initialState</code>初始化我们的reducer，并传递给它一个水果数组。有些水果是成串的，比如🍇和🍒而另外两个是单身:🍈和🍋。</p><p id="0c4d" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们从一个包含两个数组的对象开始，最终我们得到了一个包含两个由<code class="fe ms mt mu mv b">value.isBunch</code>分隔的数组的对象。</p><p id="7974" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果你在这一点上迷失了，不要担心，从这里开始只会变得更糟；实际上不，我们结束了。这是给你一个减速器的快速概述。它们功能强大得令人难以置信，并允许许多功能概念，例如我们在第3部分和第4部分中讨论过的管道化。</p><p id="75cd" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在我们谈到的所有函数数组方法中，它们都可以用<code class="fe ms mt mu mv b">reduce</code>来编写。这个系列已经介绍了基础知识，但是<code class="fe ms mt mu mv b">reduce</code>是其中最强大的。这就是为什么这些例子如此疯狂。</p><p id="ca13" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">换能器模式，另一种形式的功能流水线，特别依赖于减速器。实际上，它接受一个缩减器并返回一个缩减器。我们实际上已经创建了两个与传感器非常相似的函数:<code class="fe ms mt mu mv b">filterReducer</code>和<code class="fe ms mt mu mv b">partitionReducer</code>。这些可组合的函数允许复杂的函数管道，你将在像RxJS这样的库中看到。随便翻翻<a class="ae mf" href="https://rxjs-dev.firebaseapp.com/api" rel="noopener ugc nofollow" target="_blank"> RxJS的运营商列表</a>，你就明白我的意思了。</p><p id="330d" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果您只能在工具箱中选择一个工具来进行函数式编程，请选择reducer。您可以根据需要创建所有其他工具。</p><h1 id="64ae" class="nl nf jb bd nm nn no np nq nr ns nt nu kq nv kr nw kt nx ku ny kw nz kx oa ob bi translated">递归</h1><p id="8fa0" class="pw-post-body-paragraph kz la jb lb b lc oc kl le lf od ko lh li oe lk ll lm of lo lp lq og ls lt lu ij bi translated">您可能已经注意到，我们的<code class="fe ms mt mu mv b">reduce</code>方法类似于递归函数，因为它依赖于前一个值来计算下一个值。因为你不需要自己管理递归，所以归约器是推理递归的一种更简单的方法。你一直不知道就明白了！</p><p id="ef1e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">感受递归！</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="af41" class="nl nf jb bd nm nn oh np nq nr oi nt nu kq oj kr nw kt ok ku ny kw ol kx oa ob bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kz la jb lb b lc oc kl le lf od ko lh li oe lk ll lm of lo lp lq og ls lt lu ij bi translated">如果您对与函数式编程相关的更多主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="f12a" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-to-safely-refactor-old-code-part-1-a1a853263fec">防止现有系统发生重大变化</a></li><li id="21e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="c569" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div></div>    
</body>
</html>