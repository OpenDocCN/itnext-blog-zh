<html>
<head>
<title>From parsimmon to nom — playing with parser combinators (Typescript → Rust)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从parsimmon到nom —使用解析器组合子(Typescript → Rust)</h1>
<blockquote>原文：<a href="https://itnext.io/from-parsimmon-to-nom-playing-with-parser-combinators-typescript-rust-c915865edd91?source=collection_archive---------2-----------------------#2021-06-19">https://itnext.io/from-parsimmon-to-nom-playing-with-parser-combinators-typescript-rust-c915865edd91?source=collection_archive---------2-----------------------#2021-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93e6b5314912e2bda10f0fedec67da4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yckdrObbheTVKQiRQYk-dA.png"/></div></div></figure><p id="191d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将快速介绍用Typescript编写的虚拟查询语言解析器的重新实现过程。新的实现正在进行中。</p><p id="305c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">解析器组合子</strong>是一个高阶函数，它接受几个<strong class="ka ir">解析器</strong>作为输入，并返回一个新的<strong class="ka ir">解析器</strong>作为输出。</p><p id="b0bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当构建我们的解析器时，我们可能希望从底层开始，组成最终构建我们的主解析器的最小单元。</p><p id="8318" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始:</p><h2 id="6d60" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">虚拟QL</h2><p id="9fc4" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有效的查询语法如下所示:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5be9" class="kw kx iq lz b gy md me l mf mg">1. foo == "hey there" &amp;&amp; foo == "eatPizza"<br/><br/>2. foo == "hey there"</span></pre><h2 id="44ac" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">Typescript分析器:</h2><p id="2704" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">对于我使用的Parsimmon的Typescript虚拟查询lang，我建议您深入研究一下它的github repo，它基于有趣的函数概念。</p><p id="09b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Parsimmon  是一个小库，用于编写由许多小解析器组成的大解析器。</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/178c63bf41b41d9f3922ca045f995e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*OGJA4bhGrR2Et3OyQLq3QA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图像取自parsimmon repo</figcaption></figure><p id="60c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">用户API </strong>很简单。<br/>我们有一个parseDummyQL()函数，它获取查询字符串输入，如果查询有效，它将输出某种扁平树🌲表示我们的查询语言规则结构(类似于一个<a class="ae mh" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>)。</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1c28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在检查完解析器实现之后，我们将深入研究输出。</p><h2 id="9032" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">QL实施</h2><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="dad3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的部分是在创建我们的主解析器时组合的小解析器函数。</p><p id="8079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会过多地解释Parsimmon API，我们应该只关心下面的流程:</p><ol class=""><li id="52b2" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">dummy_query() combinator调用expression() combinator，并应用<strong class="ka ir"> "many "，</strong>这是解析器API中的一种常见方式，用于声明规则可以重复n次。</li><li id="2075" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">expression()组合器引入了<strong class="ka ir"> "alt()" </strong>组合器，它接受n个解析器并检查输入字符串是否符合其中一个输入解析器规则，您可能会在其他库中看到它是“选择”组合器。在我们的例子中，选择/替代是“base()”或“sub()”组合子。</li><li id="5b2e" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">" base()"和" sub()"都引入了" seq()"组合子(序列)，查看" base()"规则，我们可以看到它得到的解析器的顺序如下:" field "然后" operator "然后" value "<br/>" sub()"组合子序列如下:<br/> alt("and "，" or ")然后" base "，这意味着" sub "解析规则可以以" and" or "开头，后跟" base "查询。</li><li id="5fdd" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">其余的组合子都是简单的单元，不涉及其他组合子，比如我们的运算符需要eq '== '运算符，字段需要字符串“foo”，或者值需要双引号内的任何字符串，等等..</li></ol><h2 id="259a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">现在让我们用Nom来做</h2><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/85be4e6cd50da669ed32cee56ba48c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*WU4uuH6u-n_QrBAbpCJwCg.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图像取自nom的回购协议</figcaption></figure><p id="97f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mh" href="https://github.com/Geal/nom" rel="noopener ugc nofollow" target="_blank"> nom </a>是一个用Rust编写的解析器组合子库。它的目标是提供工具来构建安全的解析器，而不牺牲速度或内存消耗。</p><p id="980c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这对我来说是有挑战性的部分:)我真的很喜欢Rust，但是我写得不多，认为自己是一个不熟练的开发人员..</p><h2 id="60bb" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">QL实施</h2><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9bfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">**免责声明:</p><ul class=""><li id="4d84" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv ne mv mw mx bi translated"><a class="ae mh" href="https://doc.rust-lang.org/book/ch09-00-error-handling.html" rel="noopener ugc nofollow" target="_blank">错误处理</a>是我喜欢Rust的地方之一，但在这一点上我忽略了潜在的错误，这样我就可以专注于学习API。</li><li id="6312" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv ne mv mw mx bi translated">我实际上调整了下面的parse_quoted函数<a class="ae mh" href="https://stackoverflow.com/questions/58511515/parse-string-with-escaped-single-quotes" rel="noopener ugc nofollow" target="_blank"> stackoverflow答案</a>。</li><li id="ac87" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv ne mv mw mx bi translated">我真的不觉得我抓伤了nom的能力，所以你更然后欢迎评论与提示，让我们一起成长。</li><li id="4fd9" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv ne mv mw mx bi translated">我简化了最终的输出，不像最初的实现那样转换输出:))</li></ul><h2 id="350e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">类型背景:</h2><p id="cbcf" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md" rel="noopener ugc nofollow" target="_blank">名词解析器是到处使用</a> <code class="fe nf ng nh lz b"><a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md" rel="noopener ugc nofollow" target="_blank">nom::IResult</a></code> <a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md" rel="noopener ugc nofollow" target="_blank">类型的函数。<br/></a><code class="fe nf ng nh lz b"><a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md" rel="noopener ugc nofollow" target="_blank">IResult</a></code><a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md" rel="noopener ugc nofollow" target="_blank">类型取决于输入和输出类型，以及一个可选的自定义错误类型。</a></p><p id="d461" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试的查询看起来像:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c722" class="kw kx iq lz b gy md me l mf mg">foo == "jj" &amp;&amp; foo == "bazz"</span></pre><p id="ba78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">字段→空格→ eqOperator →空格→值→空格→和逻辑运算符→空格→字段→空格→ eqOperator →空格→值</p><h2 id="cdf5" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">代码概述，从上到下:</h2><p id="d537" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">1.我们的入口点是dummy _ parser()(lib中唯一的公共函数)，它接受查询作为参数并返回代表我们最终输出的IResult，并返回“tuple”序列组合子的结果:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="eed0" class="kw kx iq lz b gy md me l mf mg">tuple((base_parser, tag(" "), and_or_choice, sub_parser))(i)</span></pre><p id="fd02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">元组</strong> </a>链接解析器，并将子结果组装成元组。您可以使用尽可能多的子解析器，因为您可以将元素放入一个元组中。</p><p id="b97b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mh" href="http://Recognizes a specific suite of characters or bytes" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">标签</strong> </a>“基本元素”识别一组特定的字符或字节。</p><p id="bf07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以顺序很简单，输入首先由<strong class="ka ir"> base_parser </strong>解析，然后是空格，接着是<strong class="ka ir">和_or_choice </strong>，接着是<strong class="ka ir"> sub_parser。</strong></p><p id="9187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<strong class="ka ir"> and_or_choice </strong>返回alt()组合子的结果</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="eaf2" class="kw kx iq lz b gy md me l mf mg">alt((and_parser, or_parser))(i)</span></pre><p id="d9cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mh" href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">alt</strong></a><strong class="ka ir"/>choice组合器将尝试一系列解析器，并返回第一个成功解析器的结果。</p><p id="f50a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.<strong class="ka ir"> sub_parser </strong>将空格与base_parser结合起来</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7b97" class="kw kx iq lz b gy md me l mf mg">tuple((tag(" "), base_parser))(i)</span></pre><p id="7d7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.base_parser 解析最简单的查询</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="59b9" class="kw kx iq lz b gy md me l mf mg">tuple((f, tag(" "), eq_op, tag(" "), value))(i)</span></pre><p id="f5dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fff3" class="kw kx iq lz b gy md me l mf mg"><br/>let exp_tuple = (<br/>    (<br/>        "foo",<br/>        " ",<br/>        "==",<br/>        " ",<br/>        "jj",<br/>    ),<br/>    " ",<br/>    "&amp;&amp;",<br/>    (<br/>        " ",<br/>        (<br/>            "foo",<br/>            " ",<br/>            "==",<br/>            " ",<br/>            "bazz",<br/>        ),<br/>    ),<br/>);</span></pre><p id="70ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是这篇文章的全部内容，希望你喜欢！欢迎您点击拍手，并检查<a class="ae mh" href="https://github.com/LironHazan/nom-dummy-ql-example" rel="noopener ugc nofollow" target="_blank">回购</a>，我可能会在稍后改进代码:)</p><p id="87fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读🙏<br/>立荣。</p></div></div>    
</body>
</html>