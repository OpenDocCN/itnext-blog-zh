<html>
<head>
<title>.NET 7: suspicious places and errors in the source code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。NET 7:源代码中可疑的地方和错误</h1>
<blockquote>原文：<a href="https://itnext.io/net-7-suspicious-places-and-errors-in-the-source-code-34dfa107a9c9?source=collection_archive---------0-----------------------#2022-12-14">https://itnext.io/net-7-suspicious-places-and-errors-in-the-source-code-34dfa107a9c9?source=collection_archive---------0-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eeaafd6c7602e132d163d509de624cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R9yX0khBRodFEvPC"/></div></div></figure><p id="ed82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">。NET 7已经发布了！是时候让我们深入挖掘它的源代码，开始寻找错误和奇怪的代码片段了。在这篇文章中，您将看到来自。NET开发人员。毕竟他们比任何人都了解平台代码。系好安全带。</p><p id="eb69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我分析了。NET 7。可以在GitHub上找到:<a class="ae kw" href="https://github.com/dotnet/runtime/tree/v7.0.0" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="bc4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在主版本之前有两个候选版本(RC ),所以大部分的bug都已经被修复了。这样更有趣——我们可以调查其中一些是否已经投入生产。</p><p id="27fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub上为每个可疑的代码片段创建了一个问题。这帮助我了解了哪些是多余的，哪些是不正确的，以及哪些是开发人员修复的。</p><p id="5505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第一期</strong></p><p id="ccfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能发现这里的错误吗？让我们检查一下！</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="bd3b" class="lg lh iq lc b be li lj l lk ll">internal sealed record IncrementalStubGenerationContext(<br/>  StubEnvironment Environment,<br/>  SignatureContext SignatureContext,<br/>  ContainingSyntaxContext ContainingSyntaxContext,<br/>  ContainingSyntax StubMethodSyntaxTemplate,<br/>  MethodSignatureDiagnosticLocations DiagnosticLocation,<br/>  ImmutableArray&lt;AttributeSyntax&gt; ForwardedAttributes,<br/>  LibraryImportData LibraryImportData,<br/>  MarshallingGeneratorFactoryKey&lt;<br/>    (TargetFramework, Version, LibraryImportGeneratorOptions)<br/>  &gt; GeneratorFactoryKey,<br/>  ImmutableArray&lt;Diagnostic&gt; Diagnostics)<br/>{<br/>  public bool Equals(IncrementalStubGenerationContext? other)<br/>  {<br/>    return    other is not null<br/>           &amp;&amp; StubEnvironment.AreCompilationSettingsEqual(Environment, <br/>                                                          other.Environment)<br/>           &amp;&amp; SignatureContext.Equals(other.SignatureContext)<br/>           &amp;&amp; ContainingSyntaxContext.Equals(other.ContainingSyntaxContext)<br/>           &amp;&amp; StubMethodSyntaxTemplate.Equals(other.StubMethodSyntaxTemplate)<br/>           &amp;&amp; LibraryImportData.Equals(other.LibraryImportData)<br/>           &amp;&amp; DiagnosticLocation.Equals(DiagnosticLocation)<br/>           &amp;&amp; ForwardedAttributes.SequenceEqual(other.ForwardedAttributes, <br/>                (IEqualityComparer&lt;AttributeSyntax&gt;)<br/>                  SyntaxEquivalentComparer.Instance)<br/>          &amp;&amp; GeneratorFactoryKey.Equals(other.GeneratorFactoryKey)<br/>          &amp;&amp; Diagnostics.SequenceEqual(other.Diagnostics);<br/>    }<br/><br/>    public override int GetHashCode()<br/>    {<br/>      throw new UnreachableException();<br/>    }<br/>}</span></pre><p id="6b46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码片段检查<em class="lm">这个</em>和<em class="lm">其他</em>对象是否等价。但是，开发人员犯了一个错误，将<em class="lm"> DiagnosticLocation </em>属性与自身进行了比较。</p><p id="959f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不正确的比较:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="b754" class="lg lh iq lc b be li lj l lk ll">DiagnosticLocation.Equals(DiagnosticLocation)</span></pre><p id="0d4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正确的比较:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="c077" class="lg lh iq lc b be li lj l lk ll">DiagnosticLocation.Equals(other.DiagnosticLocation)</span></pre><p id="b6f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在<em class="lm"> LibraryImportGenerator </em>类中发现了这个错误(<a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Runtime.InteropServices/gen/LibraryImportGenerator/LibraryImportGenerator.cs#L43" rel="noopener ugc nofollow" target="_blank">链接到GitHub </a>)。过了一会儿，我又发现了两个片段——同样的错误，但是在不同的类中:</p><ul class=""><li id="d0b9" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated"><em class="lm"> JSImportGenerator </em>类，<a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Runtime.InteropServices.JavaScript/gen/JSImportGenerator/JSImportGenerator.cs#L42" rel="noopener ugc nofollow" target="_blank">链接到GitHub</a>；</li><li id="e230" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">JSExportGenerator 类<a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Runtime.InteropServices.JavaScript/gen/JSImportGenerator/JSExportGenerator.cs#L37" rel="noopener ugc nofollow" target="_blank">链接到GitHub </a>。</li></ul><p id="20f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的事实:。NET 7对此特性进行了测试。然而，测试也是不正确的，这就是为什么它没有检测到这个错误。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e851657f0000d115a2e6b2de8a598209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VW_C7Pht7XGWHF0G"/></div></div></figure><p id="fb47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">英寸NET 8的代码被大量重写。然而，开发人员还没有修复。NET 7代码——他们决定等待反馈。你可以在GitHub 上的<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78145" rel="noopener ugc nofollow" target="_blank">期了解更多信息。</a></p><p id="7eee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第2期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="f755" class="lg lh iq lc b be li lj l lk ll">internal static void CheckNullable(JSMarshalerType underlyingSig)<br/>{<br/>    MarshalerType underlying = underlyingSig._signatureType.Type;<br/>    if (underlying == MarshalerType.Boolean<br/>        || underlying == MarshalerType.Byte<br/>        || underlying == MarshalerType.Int16<br/>        || underlying == MarshalerType.Int32<br/>        || underlying == MarshalerType.BigInt64<br/>        || underlying == MarshalerType.Int52<br/>        || underlying == MarshalerType.IntPtr<br/>        || underlying == MarshalerType.Double<br/>        || underlying == MarshalerType.Single // &lt;=<br/>        || underlying == MarshalerType.Single // &lt;=<br/>        || underlying == MarshalerType.Char<br/>        || underlying == MarshalerType.DateTime<br/>        || underlying == MarshalerType.DateTimeOffset<br/>        ) return;<br/>    throw new ArgumentException("Bad nullable value type");<br/>}</span></pre><p id="2ea6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:JSMarshalerType.cs，387 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Runtime.InteropServices.JavaScript/src/System/Runtime/InteropServices/JavaScript/JSMarshalerType.cs#L387" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="1ee8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，开发人员再次检查底层的<em class="lm">变量</em>是否等于<em class="lm"> MarshalerType。单曲</em>。有时这种检查会隐藏错误:例如，应该检查左和右<em class="lm">变量，但是左<em class="lm">变量被检查了两次。这里有一个在开源项目中发现的类似错误的列表。</em></em></p><p id="146c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub上创建了一个问题:<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78682" rel="noopener ugc nofollow" target="_blank">链接</a>。幸运的是，这段代码没有错误——这只是一个多余的检查。</p><p id="0706" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第三期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="d240" class="lg lh iq lc b be li lj l lk ll">public static bool TryParse(string text, out MetricSpec spec)<br/>{<br/>  int slashIdx = text.IndexOf(MeterInstrumentSeparator);<br/>  if (slashIdx == -1)<br/>  {<br/>    spec = new MetricSpec(text.Trim(), null);<br/>    return true;<br/>  }<br/>  else<br/>  {<br/>    string meterName = text.Substring(0, slashIdx).Trim();<br/>    string? instrumentName = text.Substring(slashIdx + 1).Trim();<br/>    spec = new MetricSpec(meterName, instrumentName);<br/>    return true;<br/>  }<br/>}</span></pre><p id="04d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:MetricsEventSource.cs，453 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Metrics/MetricsEventSource.cs#L453" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="c6de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm"> TryParse </em>方法总是返回<em class="lm"> true </em>。这太奇怪了。让我们看看这种方法在哪里使用:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="6d21" class="lg lh iq lc b be li lj l lk ll">private void ParseSpecs(string? metricsSpecs)<br/>{<br/>  ....<br/>  string[] specStrings = ....<br/>  foreach (string specString in specStrings)<br/>  {<br/>    if (!MetricSpec.TryParse(specString, out MetricSpec spec))<br/>    {<br/>      Log.Message($"Failed to parse metric spec: {specString}");<br/>    }<br/>    else<br/>    {<br/>      Log.Message($"Parsed metric: {spec}");<br/>      ....<br/>    }<br/>  }<br/>}</span></pre><p id="f63e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:MetricsEventSource.cs，375 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Metrics/MetricsEventSource.cs#L375" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="5641" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm"> TryParse </em>方法的返回值作为<em class="lm"> if </em>语句的条件。如果<em class="lm"> specString </em>无法解析，应记录原始值。否则，接收到的表示(<em class="lm"> spec </em>)将被记录，并对其执行一些操作。</p><p id="af56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，<em class="lm"> TryParse </em>总是返回<em class="lm"> true。</em>因此,<em class="lm"> if </em>语句的<em class="lm">然后</em>分支永远不会执行——解析总是成功的。</p><p id="6c1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub上的问题:<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78625" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="8a5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为修复的结果，<em class="lm"> TryParse </em>变成了<em class="lm"> Parse </em>，调用者方法失去了<em class="lm"> if </em>语句。开发人员还将<em class="lm"> TryParse </em>中的<em class="lm">子串</em>改为<em class="lm">作为Span </em>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4069a1ba431ff0fd6dc159e73ed92d69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R4aRVje7klBO0nTR"/></div></div></figure><p id="a80d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，这是我在研究。NET 6源代码。但是当时，日志记录方法中缺少插值字符:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="bb4c" class="lg lh iq lc b be li lj l lk ll">if (!MetricSpec.TryParse(specString, out MetricSpec spec))<br/>{<br/>  Log.Message("Failed to parse metric spec: {specString}");<br/>}<br/>else<br/>{<br/>  Log.Message("Parsed metric: {spec}");<br/>  ....<br/>}</span></pre><p id="f7a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在关于的文章中读到更多关于这个问题的信息。网6检查(第14期)。</p><p id="5eab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第4期</strong></p><p id="731d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们提到了具有奇怪返回值的方法，让我们看另一个:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="abbb" class="lg lh iq lc b be li lj l lk ll">public virtual bool TryAdd(XmlDictionaryString value, out int key)<br/>{<br/>  ArgumentNullException.ThrowIfNull(value);<br/>  IntArray? keys;<br/>  if (_maps.TryGetValue(value.Dictionary, out keys))<br/>  {<br/>    key = (keys[value.Key] - 1);<br/>    if (key != -1)<br/>    {<br/>      // If the key is already set, then something is wrong<br/>      throw System.Runtime<br/>                  .Serialization<br/>                  .DiagnosticUtility<br/>                  .ExceptionUtility<br/>                  .ThrowHelperError(<br/>      new InvalidOperationException(SR.XmlKeyAlreadyExists));<br/>     }<br/>     key = Add(value.Value);<br/>     keys[value.Key] = (key + 1);<br/>     return true;               // &lt;=<br/>  }<br/>  key = Add(value.Value);<br/>  keys = AddKeys(value.Dictionary, value.Key + 1);<br/>  keys[value.Key] = (key + 1);<br/>  return true;                  // &lt;=<br/>}</span></pre><p id="dc6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">地点:XmlBinaryWriterSession.cs，28 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Private.DataContractSerialization/src/System/Xml/XmlBinaryWriterSession.cs#L28" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="4cf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该方法要么返回<em class="lm">真</em>要么抛出一个异常——它从不返回<em class="lm">假</em>。这是一个公共API，所以对质量有更多的要求。</p><p id="8fd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<a class="ae kw" href="https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmlbinarywritersession.tryadd?view=net-7.0" rel="noopener ugc nofollow" target="_blank">learn.microsoft.com</a>上的描述:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b0356cb01944819fa9bb013b5aa2fbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qLptvjADqfSUiXN5"/></div></div></figure><p id="ba4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦，太好了。我也在GitHub上为它创建了一个问题(<a class="ae kw" href="https://github.com/dotnet/dotnet-api-docs/issues/8656" rel="noopener ugc nofollow" target="_blank">链接</a>)，但是在写这篇文章的时候，还没有关于它的任何消息。</p><p id="1679" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第五期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="cbb4" class="lg lh iq lc b be li lj l lk ll">public static Attribute? GetCustomAttribute(ParameterInfo element, <br/>                                            Type attributeType, <br/>                                            bool inherit)<br/>{<br/>  // ....<br/>  Attribute[] attrib = GetCustomAttributes(element, attributeType, inherit);<br/>  if (attrib == null || attrib.Length == 0)<br/>    return null;<br/>  if (attrib.Length == 0)<br/>    return null;<br/>  if (attrib.Length == 1)<br/>    return attrib[0];<br/>  throw new AmbiguousMatchException(SR.RFLCT_AmbigCust);<br/>}</span></pre><p id="4212" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:属性。CoreCLR.cs，617 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/coreclr/System.Private.CoreLib/src/System/Attribute.CoreCLR.cs#L617" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="17c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这段代码中，同一个表达式— <em class="lm"> attrib。Length == 0 </em> —检查两次:第一次作为“||”运算符的右操作数，然后作为<em class="lm"> if </em>语句的条件。</p><p id="6edb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时这可能是一个错误——开发人员想检查一件事，却检查另一件事。我们很幸运:第二次检查只是多余的，开发人员删除了它。</p><p id="44e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub上的问题:<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78683" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b756e2377744bd399b04df48bad6e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*16W0G8JEYKg6aaeK"/></div></div></figure><p id="8f23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第六期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="2a72" class="lg lh iq lc b be li lj l lk ll">protected virtual XmlSchema? GetSchema()<br/>{<br/>  if (GetType() == typeof(DataTable))<br/>  {<br/>    return null;<br/>  }<br/>  MemoryStream stream = new MemoryStream();<br/>  XmlWriter writer = new XmlTextWriter(stream, null);<br/>  if (writer != null)<br/>  {<br/>    (new XmlTreeGen(SchemaFormat.WebService)).Save(this, writer);<br/>  }<br/>  stream.Position = 0;<br/>  return XmlSchema.Read(new XmlTextReader(stream), null);<br/>}</span></pre><p id="3d5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:DataTable.cs，6678 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Data.Common/src/System/Data/DataTable.cs#L6678" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="fc1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发人员创建了一个<em class="lm"> XmlTextWriter </em>类型的实例。然后将对该实例的引用分配给<em class="lm">写入器</em>变量。然而，在下一行中，开发人员检查了<em class="lm">写入器</em>中的<em class="lm"> null </em>。检查总是返回<em class="lm">真</em>，这意味着该条件在这里是多余的。</p><p id="d2f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不恐怖，但是还是把支票去掉比较好。实际上，开发人员就是这么做的(GitHub上的<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78684" rel="noopener ugc nofollow" target="_blank">问题</a>)。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78e5feea88f21c8621f9c1850e687543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NKqmCyDACSvXS003"/></div></div></figure><p id="84f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第七期</strong></p><p id="eca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">又是冗余代码，但这次不太明显:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="adc7" class="lg lh iq lc b be li lj l lk ll">public int ToFourDigitYear(int year, int twoDigitYearMax)<br/>{<br/>  if (year &lt; 0)<br/>  {<br/>    throw new ArgumentOutOfRangeException(nameof(year), <br/>                                          SR.ArgumentOutOfRange_NeedPosNum);<br/>  }<br/>  if (year &lt; 100)<br/>  {<br/>    int y = year % 100;<br/>    return (twoDigitYearMax / 100 - (y &gt; twoDigitYearMax % 100 ? 1 : 0)) <br/>             * 100 + y;<br/>  }<br/>  ....<br/>}</span></pre><p id="ee5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">地点:GregorianCalendarHelper.cs，526 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Private.CoreLib/src/System/Globalization/GregorianCalendarHelper.cs#L526" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="15d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看在整个代码执行过程中如何检查<em class="lm"> year </em>变量的范围:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="e150" class="lg lh iq lc b be li lj l lk ll">ToFourDigitYear(int year, int twoDigitYearMax)</span></pre><p id="b5e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm">年份</em>是<em class="lm"> int </em>类型<em class="lm">的一个参数。</em>这意味着它的值在[ <em class="lm"> int内。MinValue</em>；<em class="lm"> int。最大值</em>范围。</p><p id="0fd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码执行时，首先满足<em class="lm"> if </em>语句；在此语句中，会引发一个异常:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="8099" class="lg lh iq lc b be li lj l lk ll">if (year &lt; 0)<br/>{<br/>  throw ....;<br/>}</span></pre><p id="0363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有异常，那么<em class="lm">年</em>值在[0；智力。最大值。</p><p id="42ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，另一个<em class="lm"> if </em>语句:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="2a9d" class="lg lh iq lc b be li lj l lk ll">if (year &lt; 100)<br/>{<br/>  int y = year % 100;<br/>  ....<br/>}</span></pre><p id="ae4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果代码执行在<em class="lm">那么<em class="lm">的</em>分支，如果</em>，那么<em class="lm">年</em>值在[0；99]范围。这导致了一个有趣的结果——取除法的余数:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="f75d" class="lg lh iq lc b be li lj l lk ll">int y = year % 100;</span></pre><p id="3af5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm">年</em>值始终小于100(即该值介于0-99之间)。因此，<em class="lm">年% 100 </em>运算的结果总是等于左操作数— <em class="lm">年</em>。因此，<em class="lm"> y </em>总是等于<em class="lm">年</em>。</p><p id="401d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码要么是多余的，要么是错误的。在我打开GitHub 上的<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78627" rel="noopener ugc nofollow" target="_blank">问题后，代码被修复，并且<em class="lm"> y </em>变量被移除。</a></p><p id="135e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第8期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="3e13" class="lg lh iq lc b be li lj l lk ll">internal ConfigurationSection<br/>FindImmediateParentSection(ConfigurationSection section)<br/>{<br/>  ....<br/>  SectionRecord sectionRecord = ....<br/>  if (sectionRecord.HasLocationInputs)<br/>  {<br/>    SectionInput input = sectionRecord.LastLocationInput;<br/>    Debug.Assert(input.HasResult, "input.HasResult");<br/>    result = (ConfigurationSection)input.Result;<br/>  }<br/>  else<br/>  {<br/>    if (sectionRecord.HasIndirectLocationInputs)<br/>    {<br/>      Debug.Assert(IsLocationConfig, <br/>                   "Indirect location inputs exist <br/>                    only in location config record");<br/>      SectionInput input = sectionRecord.LastIndirectLocationInput;<br/>      Debug.Assert(input != null);<br/>      Debug.Assert(input.HasResult, "input.HasResult");<br/>      result = (ConfigurationSection)input.Result;<br/>    }<br/>    ....<br/>  ....<br/>}</span></pre><p id="f141" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:MgmtConfigurationRecord.cs，341 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Configuration.ConfigurationManager/src/System/Configuration/MgmtConfigurationRecord.cs#L341" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="2504" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要在这里挖得更深一点。首先，让我们看看第二个<em class="lm"> if </em>语句:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="9036" class="lg lh iq lc b be li lj l lk ll">if (sectionRecord.HasIndirectLocationInputs)<br/>{<br/>  Debug.Assert(IsLocationConfig, <br/>               "Indirect location inputs exist <br/>                only in location config record");<br/>  SectionInput input = sectionRecord.LastIndirectLocationInput;<br/>  Debug.Assert(input != null);<br/>  Debug.Assert(input.HasResult, "input.HasResult");<br/>  result = (ConfigurationSection)input.Result;<br/>}</span></pre><p id="33cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lm">LastIndirectLocationInput</em>属性的值被写入<em class="lm">输入</em>变量<em class="lm">。</em>之后，<em class="lm">输入</em>分两次被检查:检查<em class="lm">是否为空</em> ( <em class="lm">输入！= null </em>)和结果(<em class="lm">输入的存在。HasResult </em>)。</p><p id="1ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一下<em class="lm">LastIndirectLocationInput</em>属性的主体，以了解哪个值可以写入<em class="lm">输入</em>变量:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="c556" class="lg lh iq lc b be li lj l lk ll">internal SectionInput LastIndirectLocationInput<br/>  =&gt;   HasIndirectLocationInputs <br/>     ? IndirectLocationInputs[IndirectLocationInputs.Count - 1] <br/>     : null;</span></pre><p id="5b6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一方面，属性可能返回<em class="lm"> null </em>。另一方面，如果<em class="lm">具有IndirectLocationInputs </em>为<em class="lm">真</em>，那么<em class="lm">为IndirectLocationInputs【IndirectLocationInputs。返回count-1]</em>而不是显式的<em class="lm"> null </em>。</p><p id="a930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，<em class="lm"> IndirectLocationInputs </em>集合中的值是否可以为空值<em class="lm">？可能是的，虽然从代码上看不清楚。顺便说一下，可空注释在这里可能会有所帮助，但是它们根本没有被启用。NET项目。</em></p><p id="b8ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到<em class="lm">如果</em>:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="fbca" class="lg lh iq lc b be li lj l lk ll">if (sectionRecord.HasIndirectLocationInputs)<br/>{<br/>  Debug.Assert(IsLocationConfig, <br/>               "Indirect location inputs exist <br/>                only in location config record");<br/>  SectionInput input = sectionRecord.LastIndirectLocationInput;<br/>  Debug.Assert(input != null);<br/>  Debug.Assert(input.HasResult, "input.HasResult");<br/>  result = (ConfigurationSection)input.Result;<br/>}</span></pre><p id="c703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">条件表达式是<em class="lm">section record . hasindirectlocationinputs .</em>与在<em class="lm">LastIndirectLocationInput</em>中检查的属性相同。这意味着<em class="lm">LastIndirectLocationInput</em>肯定不会显式返回<em class="lm"> null </em>。然而，不清楚哪个值将从<em class="lm">间接位置输入</em>接收并写入<em class="lm">输入</em>。</p><p id="fb80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发者首先检查<em class="lm">输入！= null </em>，然后只检查结果的存在— <em class="lm">输入。散列结果</em>。看起来没问题。</p><p id="c3dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们回到第一个<em class="lm"> if </em>语句:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="8586" class="lg lh iq lc b be li lj l lk ll">if (sectionRecord.HasLocationInputs)<br/>{<br/>  SectionInput input = sectionRecord.LastLocationInput;<br/>  Debug.Assert(input.HasResult, "input.HasResult");<br/>  result = (ConfigurationSection)input.Result;<br/>}</span></pre><p id="5c73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<em class="lm"> LastLocationInput </em>属性:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="07df" class="lg lh iq lc b be li lj l lk ll">internal SectionInput LastLocationInput <br/>  =&gt;  HasLocationInputs <br/>    ? LocationInputs[LocationInputs.Count - 1] <br/>    : null;</span></pre><p id="51c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和<em class="lm">LastIndirectLocationInput</em>的写法一样。就像前一个例子一样，根据标志(<em class="lm"> HasLocationInputs </em>)，要么返回空值<em class="lm">要么返回来自<em class="lm"> LocationInputs </em>集合的值。</em></p><p id="fad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在返回到<em class="lm"> if </em>语句。其条件表达式是<em class="lm"> HasLocationInputs </em>属性，在<em class="lm"> LastLocationInput </em>中检查。如果代码在<em class="lm">然后<em class="lm"> if </em>语句的</em>分支中执行，这意味着<em class="lm"> LastLocationInput </em>不能显式返回<em class="lm"> null </em>。来自<em class="lm">位置输入</em>集合的值是否可以为空值<em class="lm">？这个问题仍然没有答案。如果可以，那么<em class="lm">空值</em>也将被写入<em class="lm">输入</em>。</em></p><p id="9488" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如在第一次被检查的情况下<em class="lm">如果</em>，<em class="lm">输入。HasResult </em>被检查但没有<em class="lm">输入！= null </em>这次。</p><p id="37fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再一次。第一个检查的代码片段:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="29a8" class="lg lh iq lc b be li lj l lk ll">SectionInput input = sectionRecord.LastIndirectLocationInput;<br/>Debug.Assert(input != null);<br/>Debug.Assert(input.HasResult, "input.HasResult");<br/>result = (ConfigurationSection)input.Result;</span></pre><p id="78c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="bf22" class="lg lh iq lc b be li lj l lk ll">SectionInput input = sectionRecord.LastLocationInput;<br/>Debug.Assert(input.HasResult, "input.HasResult");<br/>result = (ConfigurationSection)input.Result;</span></pre><p id="ee36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来像是<em class="lm">调试。断言(输入！= null) </em>表达式缺失。</p><p id="5bb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub 上开了一个<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78634" rel="noopener ugc nofollow" target="_blank">问题，在那里我描述了这个和其他与<em class="lm"> null </em>支票相关的可疑地方(你会在下面看到它们)。</a></p><p id="7e47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开发人员决定不修复这个片段，让它保持原样:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/217229296bbd15b9542e3d57668f29a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xotKaJEuUTfCK1Rm"/></div></div></figure><p id="9ea0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">空支票的问题</strong></p><p id="efc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在代码中遇到过几个引用被解引用的地方，只有在那里才会检查是否有<em class="lm"> null。</em>我为GitHub上所有类似的代码片段创建了<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78634" rel="noopener ugc nofollow" target="_blank">一期</a>。</p><p id="ca47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来检查一下。</p><p id="07b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第九期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="da54" class="lg lh iq lc b be li lj l lk ll">private static RuntimeBinderException BadOperatorTypesError(Expr pOperand1, <br/>                                                            Expr pOperand2)<br/>{<br/>  // ....<br/>  string strOp = pOperand1.ErrorString;<br/>  Debug.Assert(pOperand1 != null);<br/>  Debug.Assert(pOperand1.Type != null);<br/>  if (pOperand2 != null)<br/>  {<br/>    Debug.Assert(pOperand2.Type != null);<br/>    return ErrorHandling.Error(ErrorCode.ERR_BadBinaryOps,<br/>                               strOp, <br/>                               pOperand1.Type, <br/>                               pOperand2.Type);<br/>  }<br/>  return ErrorHandling.Error(ErrorCode.ERR_BadUnaryOp, strOp, pOperand1.Type);<br/>}</span></pre><p id="bfc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:ExpressionBinder.cs，798 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExpressionBinder.cs#L798" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="a40e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，<em class="lm"> pOperand1 </em>被解引用(<em class="lm"> pOperand1。ErrorString </em>)并在<em class="lm">调试中检查<em class="lm">空值</em>。在下一个代码行断言</em>。如果<em class="lm"> pOperand1 </em>为<em class="lm"> null </em>，则不触发断言，而是抛出<em class="lm"> NullReferenceException </em>类型的异常。</p><p id="c4c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码已修复—使用前检查了<em class="lm"> pOperand1 </em>。</p><p id="559a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="9521" class="lg lh iq lc b be li lj l lk ll">string strOp = pOperand1.ErrorString;<br/>Debug.Assert(pOperand1 != null);<br/>Debug.Assert(pOperand1.Type != null);</span></pre><p id="34e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="9ad1" class="lg lh iq lc b be li lj l lk ll">Debug.Assert(pOperand1 != null);<br/>Debug.Assert(pOperand1.Type != null);<br/>string strOp = pOperand1.ErrorString;</span></pre><p id="c84e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第10期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="8ba2" class="lg lh iq lc b be li lj l lk ll">public void Execute()<br/>{<br/>  var count = _callbacks.Count;<br/>  if (count == 0)<br/>  {<br/>    return;<br/>  }<br/><br/>  List&lt;Exception&gt;? exceptions = null;<br/>  if (_callbacks != null)<br/>  {<br/>    for (int i = 0; i &lt; count; i++)<br/>    {<br/>      var callback = _callbacks[i];<br/>      Execute(callback, ref exceptions);<br/>    }<br/>  }<br/>  if (exceptions != null)<br/>  {<br/>    throw new AggregateException(exceptions);<br/>  }<br/>}</span></pre><p id="01f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:PipeCompletionCallbacks.cs，20 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.IO.Pipelines/src/System/IO/Pipelines/PipeCompletionCallbacks.cs#L20" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="58cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先使用<em class="lm"> _callbacks </em>变量，然后检查<em class="lm">是否为空</em>:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="eac4" class="lg lh iq lc b be li lj l lk ll">public void Execute()<br/>{<br/>  var count = _callbacks.Count;<br/>  ....<br/>  if (_callbacks != null)<br/>  ....<br/>}</span></pre><p id="ed46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在写这篇文章的时候，开发人员移除了检查<em class="lm">_回调</em>为<em class="lm">空</em>。</p><p id="42de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，<em class="lm"> _callbacks </em>是一个在构造函数中初始化的<em class="lm">只读</em>字段:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="dabc" class="lg lh iq lc b be li lj l lk ll">internal sealed class PipeCompletionCallbacks<br/>{<br/>  private readonly List&lt;PipeCompletionCallback&gt; _callbacks;<br/>  private readonly Exception? _exception;<br/>  public PipeCompletionCallbacks(List&lt;PipeCompletionCallback&gt; callbacks, <br/>                                 ExceptionDispatchInfo? edi)<br/>  {<br/>    _callbacks = callbacks;<br/>    _exception = edi?.SourceException;<br/>  }<br/>  ....<br/>}</span></pre><p id="22f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在修复后的线程中，开发人员讨论了是否值得添加<em class="lm"> Debug。断言</em>并检查<em class="lm">_回调</em>中的<em class="lm">为空</em>进入构造函数。最后，他们决定不是。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/055e893a0564388922e628d32806a93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C69RNGWznqDdS8wq"/></div></div></figure><p id="7ca5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第11期</strong></p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="e414" class="lg lh iq lc b be li lj l lk ll">private void ValidateAttributes(XmlElement elementNode)<br/>{<br/>  ....<br/>  XmlSchemaAttribute schemaAttribute <br/>    = (_defaultAttributes[i] as XmlSchemaAttribute)!;<br/>  attrQName = schemaAttribute.QualifiedName;<br/>  Debug.Assert(schemaAttribute != null);<br/>  ....<br/>}</span></pre><p id="bbc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:DocumentSchemaValidator.cs，421 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Private.Xml/src/System/Xml/Dom/DocumentSchemaValidator.cs#L421" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="9792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有争议的代码:</p><ul class=""><li id="5479" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated"><em class="lm">作为</em>运算符的结果被写入<em class="lm"> schemaAttribute </em>。如果<em class="lm">_ default attributes[I]</em>—<em class="lm">null</em>或者转换失败，结果将是<em class="lm"> null </em>。</li><li id="57ba" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">允许空值的运算符(“！”)暗示了造型的结果不能是<em class="lm"> null </em>。因此，<em class="lm"> schemaAttribute </em>不能为<em class="lm"> null </em>。</li><li id="a495" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">在下一行代码中，<em class="lm"> schemaAttribute </em>被取消引用。然后在下面的一行中，检查引用的<em class="lm">是否为空</em>。</li></ul><p id="ecea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题来了。<em class="lm"> schemaAttribute </em>会不会是<em class="lm"> null </em>？从代码上看不是很清楚。</p><p id="f631" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码是这样修复的:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="e757" class="lg lh iq lc b be li lj l lk ll">....<br/>XmlSchemaAttribute schemaAttribute <br/>  = (XmlSchemaAttribute)_defaultAttributes[i]!;<br/>attrQName = schemaAttribute.QualifiedName;<br/>....</span></pre><p id="fa84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在讨论修复过程中，开发人员提议转移<em class="lm">调试。断言</em>调用上面的行，而不是删除它。代码应该是这样的:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="0604" class="lg lh iq lc b be li lj l lk ll">....<br/>XmlSchemaAttribute schemaAttribute = (XmlSchemaAttribute)_defaultAttributes[i]!;<br/>Debug.Assert(schemaAttribute != null);<br/>attrQName = schemaAttribute.QualifiedName;<br/>....</span></pre><p id="1d30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，他们决定不返回<em class="lm">断言</em>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4b99898792a96046870639d91ce4fef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4rIfbgGOp0v4Ixw3"/></div></div></figure><p id="40af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第12期</strong></p><p id="ba4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<em class="lm">XmlConfigurationElementTextContent</em>类型的构造函数:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="61d2" class="lg lh iq lc b be li lj l lk ll">public XmlConfigurationElementTextContent(string textContent, <br/>                                          int? linePosition, <br/>                                          int? lineNumber)<br/>{ .... }</span></pre><p id="8b11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:xmlconfigurationelementtextcontent . cs，10 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/Microsoft.Extensions.Configuration.Xml/src/XmlConfigurationElementTextContent.cs#L10" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="27c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看它的使用场合:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="4acc" class="lg lh iq lc b be li lj l lk ll">public static IDictionary&lt;string, string?&gt; Read(....)<br/>{<br/>  ....<br/>  case XmlNodeType.EndElement:<br/>    ....<br/>    var lineInfo = reader as IXmlLineInfo;<br/>    var lineNumber = lineInfo?.LineNumber;<br/>    var linePosition = lineInfo?.LinePosition;<br/>    parent.TextContent = new XmlConfigurationElementTextContent(string.Empty, <br/>                                                                lineNumber,<br/>                                                                linePosition);<br/>    ....<br/>    break;<br/>  ....<br/>  case XmlNodeType.Text:<br/>    ....<br/>    var lineInfo = reader as IXmlLineInfo;<br/>    var lineNumber = lineInfo?.LineNumber;<br/>    var linePosition = lineInfo?.LinePosition;<br/>    XmlConfigurationElement parent = currentPath.Peek();<br/>    parent.TextContent = new XmlConfigurationElementTextContent(reader.Value,<br/>                                                                lineNumber, <br/>                                                                linePosition);<br/>    ....<br/>    break;<br/>  ....<br/>}</span></pre><p id="31e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:</p><ul class=""><li id="148c" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">xmlstreamconfigurationprovider . cs，133 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/Microsoft.Extensions.Configuration.Xml/src/XmlStreamConfigurationProvider.cs#L133" rel="noopener ugc nofollow" target="_blank">链接</a>)</li><li id="915f" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">xmlstreamconfigurationprovider . cs，148 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/Microsoft.Extensions.Configuration.Xml/src/XmlStreamConfigurationProvider.cs#L148" rel="noopener ugc nofollow" target="_blank">链接</a>)</li></ul><p id="2889" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你注意到代码中有什么奇怪的地方吗？</p><p id="60fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意自变量和参数的顺序:</p><ul class=""><li id="1594" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">自变量:…，<em class="lm">行号</em>，<em class="lm">行位置</em>；</li><li id="84b4" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">参数:…，<em class="lm">线位置</em>，<em class="lm">线号</em>。</li></ul><p id="8d4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub ( <a class="ae kw" href="https://github.com/dotnet/runtime/issues/78212" rel="noopener ugc nofollow" target="_blank">链接</a>)上创建了一个问题，代码被修复:开发人员将参数按正确的顺序排列，并添加了一个测试。</p><p id="17de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第13期</strong></p><p id="0c6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个可疑案例:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="c05d" class="lg lh iq lc b be li lj l lk ll">public virtual bool Nested<br/>{<br/>  get {....}<br/>  set <br/>  {<br/>    ....<br/>    ForeignKeyConstraint? constraint <br/>      = ChildTable.Constraints<br/>                  .FindForeignKeyConstraint(ChildKey.ColumnsReference, <br/>                                            ParentKey.ColumnsReference); <br/>    ....<br/>  }<br/>}</span></pre><p id="11b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:DataRelation.cs，486 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Data.Common/src/System/Data/DataRelation.cs#L486" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="f077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看<em class="lm">findforeignkey constraint</em>方法:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="25b4" class="lg lh iq lc b be li lj l lk ll">internal ForeignKeyConstraint? <br/>FindForeignKeyConstraint(DataColumn[] parentColumns, <br/>                         DataColumn[] childColumns)<br/>{ .... }</span></pre><p id="7136" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:ConstraintCollection.cs，548 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/System.Data.Common/src/System/Data/ConstraintCollection.cs#L548" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="d39f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">似乎论点的顺序又混淆了:</p><ul class=""><li id="061f" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">参数:<em class="lm">父</em> …，<em class="lm">子</em> …</li><li id="2ee8" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">参数:<em class="lm"> ChildKey </em> …，<em class="lm"> ParentKey </em> …</li></ul><p id="9a28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有另一个方法调用:参数顺序是正确的。</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="02bc" class="lg lh iq lc b be li lj l lk ll">ForeignKeyConstraint? foreignKey<br/>  = relation.ChildTable<br/>            .Constraints<br/>            .FindForeignKeyConstraint(relation.ParentColumnsReference,<br/>                                      relation.ChildColumnsReference);</span></pre><p id="a51e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub上创建了一个问题:<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78628" rel="noopener ugc nofollow" target="_blank">链接</a>。不幸的是，在写这篇文章的时候，我还没有收到任何关于它的评论。</p><p id="356e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第14期</strong></p><p id="7185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些地方并不是所有的论点顺序都是混乱的——我发现了另一个:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="787b" class="lg lh iq lc b be li lj l lk ll">void RecurseChildren(....)<br/>{<br/>  ....<br/>  string? value <br/>    =  processValue != null<br/>      ? processValue(new ConfigurationDebugViewContext(<br/>                           child.Key, <br/>                           child.Path, <br/>                           valueAndProvider.Value, <br/>                           valueAndProvider.Provider))<br/>      : valueAndProvider.Value;<br/>  ....<br/>}</span></pre><p id="7d5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:configurationrootwextensions . cs，50 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/Microsoft.Extensions.Configuration.Abstractions/src/ConfigurationRootExtensions.cs#L50" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="dc67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看<em class="lm">ConfigurationDebugViewContext</em>构造函数:</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="c2a8" class="lg lh iq lc b be li lj l lk ll">public ConfigurationDebugViewContext(<br/>  string path, <br/>  string key, <br/>  string? value, <br/>  IConfigurationProvider configurationProvider) <br/>{ .... }</span></pre><p id="b545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">位置:configurationdebugviewcontext . cs，11 ( <a class="ae kw" href="https://github.com/dotnet/runtime/blob/d099f075e45d2aa6007a22b71b45a08758559f80/src/libraries/Microsoft.Extensions.Configuration.Abstractions/src/ConfigurationDebugViewContext.cs#L11" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="d43d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">订单:</p><ul class=""><li id="b327" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">参数:<em class="lm">路径</em>，<em class="lm">按键</em>，…</li><li id="6e98" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">自变量:<em class="lm">子。关键</em>，<em class="lm">子。路径</em>，…</li></ul><p id="7d31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub上创建了一个问题:<a class="ae kw" href="https://github.com/dotnet/runtime/issues/78306" rel="noopener ugc nofollow" target="_blank">链接</a>。据开发商说，这种情况下没有任何问题，尽管错误。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b9d91b033f495787f42b4a8c8934e7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5VUpknD8vGLaeZ8R"/></div></div></figure><p id="5957" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，他们仍然固定了辩论的顺序。</p><p id="3991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">结论</strong></p><p id="8084" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">的。NET代码质量很高。我相信这是通过一个既定的开发过程实现的——开发人员知道确切的发布日期。此外，发布候选有助于发现最严重的错误，并为发布做好项目准备。</p><p id="b268" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，我仍然设法在代码中找到一些有趣的东西。这一次，我最喜欢的是在方法调用过程中混淆的参数。</p><p id="1e7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中描述的所有代码片段都是由PVS-Studio analyzer找到的。是的，现在它可以检查项目了。NET 7。</p><p id="0fb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想检查你的项目(个人或商业)，在这里下载分析器<a class="ae kw" href="https://pvs-studio.com/en/pvs-studio/try-free/?utm_source=website&amp;utm_medium=our_site&amp;utm_campaign=article&amp;utm_content=1015&amp;utm_term=link_try-free" rel="noopener ugc nofollow" target="_blank"/>。这个页面上还有一个文档链接:我们描述了如何输入许可并运行分析。如果您有任何问题，请告诉我们，我们会帮助您。</p></div></div>    
</body>
</html>