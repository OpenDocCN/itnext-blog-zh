<html>
<head>
<title>Collapsible App Bar With MotionLayout in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack Compose中带有MotionLayout的可折叠应用程序栏</h1>
<blockquote>原文：<a href="https://itnext.io/collapsible-app-bar-with-motionlayout-in-jetpack-compose-1fb2502acacc?source=collection_archive---------0-----------------------#2022-06-09">https://itnext.io/collapsible-app-bar-with-motionlayout-in-jetpack-compose-1fb2502acacc?source=collection_archive---------0-----------------------#2022-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e56b435ae08d85bb5a4aaf51b7bac08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESkUEbFkVntTBcEJHpSadA.png"/></div></div></figure><p id="8d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们之前已经看到了如何使用视图系统，使用<strong class="ka ir">appbar layout</strong>&amp;<strong class="ka ir">collapsing toolbar layout</strong>来创建折叠的应用程序栏/工具栏。现在在Jetpack Compose中，几乎所有东西都是完全可定制的。扩展和折叠工具栏可以在没有<strong class="ka ir"> MotionLayout </strong>的帮助下实现，因为在Android中制作动画从来没有像使用Compose animation APIs这样简单。但是，我们希望根据动画的关键帧来制作视图或可组合的多个属性/特性的动画，或者我们可能希望有一个复杂的动画。因此，<strong class="ka ir"> MotionLayout </strong>来拯救这个过程，因为它通过定义<strong class="ka ir">约束集</strong>来告诉布局/UI如何看待动画的开始以及它在动画结束时的样子，并且简单地<strong class="ka ir"> MotionLayout </strong>将通过这些集来制作动画。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="52a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从添加我们的依赖项开始，或者实际上是我们的单个依赖项</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="964b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在视图系统中，运动布局是约束布局的子类，这就是为什么我们在这里使用约束布局依赖的原因。</p><p id="7d8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来定义约束集。与在视图系统中用XML定义不同，compos中的motion layout使用了与JSON非常相似的JSON5语法。创建一个新的json5文件，将其放入res下的raw文件中。如果没有raw文件，请右键单击app&gt;New&gt;Android Resource Directory创建一个，然后在resource type下选择raw。最后，创建一个名为motion_scene.json5的文件。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="6108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像JSON一样，我们启动一个对象，然后定义另一个ConstraintSets对象，在那里放置我们的布局集。注意这里我们没有在键名之间添加引号，因为JSON5不要求我们这样做。</p><p id="9695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每个集合(开始和结束)中，我们添加我们的子视图作为对象，然后我们开始给它们属性和约束，就像约束布局和运动布局一样。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="04ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们定义了每个视图在动画开始阶段的样子。每个对象的名称代表该视图的ID(例如，用户名。box_image等。)我们稍后将在我们的compose项目中使用它。宽度和高度属性是不言自明的，它们的值被认为是Dp。将“spread”作为值传递给width或height键相当于视图系统中的0dp或match约束。现在，为了给我们的对象或视图提供约束，我们将使用top、bottom、start和end属性。如您所见，weapon_icon被约束为从它的开始到父对象的开始，从它的结束到父对象的结束，最后从它的底部到user_image的顶部，有8dp的边距。</p><p id="0faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以定义约束就像定义一个列表。首先，给出列表的名称，该名称指向要约束当前视图的方向(顶部、起点、底部或终点)，然后是要约束对象的目标视图，最后是要约束的目标视图的方向。最后一个参数是可选的，它是您从目标视图向当前视图添加一些边距的地方。</p><p id="d22f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还为box_image定义了一个alpha，它是视图系统中的一个已知属性。但是什么是习俗呢？我们在box对象中放置了一个自定义键，这就是我们在compose的motion布局中为视图定义自定义属性的方式。它相当于旧视图世界中的<strong class="ka ir"> CustomAttribute </strong>标签。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">在视图系统中定义自定义属性</figcaption></figure><p id="ad71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在完成我们动画的开始阶段后，是时候宣布它的最终外观了。现在，在最终集合中，让我们放置相同的视图，但是它们的属性值不同。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="e150" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几乎相同的流程、相同的id和相同的属性。您可能会注意到我们更改了一些值，例如，box_image的alpha在开始集合中是1，现在在结束集合中是0。类似地，在将框的宽度和高度设为25后，框的roundValue现在为0，其他视图也是如此。</p><p id="ea74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，运动布局将尽最大努力从开始集过渡到结束集。在添加任何自定义过渡之前，让我们看看我们的结果。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="5bd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在MotionAppBar composable中，我们从原始资源访问运动场景文件，然后定义进度变量，我们将使用该变量根据0和1之间的浮点值从开始过渡到结束。如果lazyColumn中列表的第一个可见项不是第一、第二、第三或第四项，我们希望动画开始。我们还为MotionLayout composable定义了motionHeight，以便在动画过程中相应地更改，从而充当顶部应用程序栏。获取运动场景后，我们将它与进度一起传递给MotionLayout composable，最后在运动布局的范围内，我们放置我们的子组件，并通过使用<strong class="ka ir"> layoutId </strong>修改器给它们在运动场景文件中定义的Id，它们将根据我们的约束放置。现在为了使用我们的定制属性，我们通过<strong class="ka ir">motion properties</strong>composable函数访问它们，并传递我们想要从中检索定制属性的视图的ID。最后，我们通过调用。值来获取值和。datatype来确定这个自定义属性的值的类型，在本例中是int。所以我们打电话。int并传递属性名(roundValue)。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="ee0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在我们的<strong class="ka ir"> MainActivity.kt </strong>文件中测试这个行为，我们创建一个可组合的Scaffold来将我们的可组合的MotionAppBar传递给topBar参数。注意，相同的惰性状态被传递到LazyColumn composable和我们的自定义应用程序栏，以跟踪第一个项目的可见性。同样重要的是添加<strong class="ka ir"> animateContentSize() </strong>修改器，一旦顶部应用程序栏的高度发生变化，就可以动画显示懒惰栏的高度。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lo li l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">我们的结果</figcaption></figure><p id="10d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很棒吧？现在，让我们添加我们的自定义过渡，使应用程序栏结束状态更优雅。在父对象中，就在我们的motion_scene.json5文件中的<strong class="ka ir"> ConstraintSets </strong>键下面，我们定义了我们的<strong class="ka ir">过渡</strong> JSON对象。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="cdf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里在<strong class="ka ir">过渡下，</strong>我们为动画定义默认行为。首先，在默认对象中，我们通过添加它应该从哪里开始和到哪里，以及我们的动画应该采取的弧形路径来构造我们的动画。当动画开始时，属性<strong class="ka ir">pathmotionarcar</strong>被设置为通过垂直弧过渡。此外，我们描述了我们的视图应该如何在定义的帧中动画化它们的属性。例如，在<strong class="ka ir">关键帧</strong>对象下，我们有一个<strong class="ka ir">关键帧属性</strong>对象<strong class="ka ir"> </strong>的列表，在那里我们为每个关键帧指定属性值。</p><p id="5bd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先讨论第一个，把事情说清楚。首先，第一个对象以user_image视图为目标，在那里我们设置了两个帧0(动画的开始)和100(动画的结束)，然后遵循rotationZ属性，在那里我们传递了0和360度。就是这样，你不必再做什么工作，运动布局将负责动画在z轴从0到360旋转。对于其余的对象，事情是相同的，只是要确保您为您设置的每个帧传递一个对应的属性值。</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lo li l"/></div></figure><p id="a23d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的最终结果，这是完整的<a class="ae lj" href="https://github.com/Astroa7m/collapsible-app-bar" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">源代码</strong> </a>。我希望你喜欢它，如果你喜欢，不要忘记给👏。</p></div></div>    
</body>
</html>