<html>
<head>
<title>Migrating a Spring Boot service to Kubernetes in 5 steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过5个步骤将Spring Boot服务迁移到Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/migrating-a-spring-boot-service-to-kubernetes-in-5-steps-7c1702da81b6?source=collection_archive---------0-----------------------#2018-02-15">https://itnext.io/migrating-a-spring-boot-service-to-kubernetes-in-5-steps-7c1702da81b6?source=collection_archive---------0-----------------------#2018-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09c8340bbd4f3dc6dfc207ca87006b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQiHSyT6yLhgFXnYwzHq8Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">您想要的微服务组合</figcaption></figure><p id="1f92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">许多java开发人员使用Spring框架来创建web服务。但是，保持它在生产中运行可能是一个相当大的挑战，有太多的方式来运行它，太多的云提供商。当然，你可以使用像<em class="la"> aws elastic beanstalk </em>这样的服务，通过自动伸缩、零停机部署、部署新版本所需的基础设施经验少等来保持它的运行。然而，这些服务对预算低的人来说成本很高，同时也失去了对服务基础设施的大量控制。</p><p id="dfdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们在GoBots的问题，我们的预算很低，我想以低成本获得弹性豆茎的所有好处。那时我发现了Kubernetes。它做了我想要的一切，而且它是开源的！完美的权利？首先要做的是。</p><h2 id="e972" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">1 —生成Docker图像</h2><p id="178e" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">我不会在这篇文章中详细介绍Kubernetes是如何工作的，你可以访问他们的<a class="ae lz" href="https://kubernetes.io/docs/home/" rel="noopener ugc nofollow" target="_blank">文档</a>来了解更多。但是让我总结一下它是如何工作的。您从应用程序中创建一个Docker图像，并“告诉”Kubernetes启动您创建的图像的一个或多个实例。因此，我们的第一步是从我们的Spring Boot服务创建一个图像。</p><p id="e542" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Spring在这个<a class="ae lz" href="https://spring.io/guides/gs/spring-boot-docker/" rel="noopener ugc nofollow" target="_blank">教程</a>中提到了这一点，这一步非常简单，也非常容易执行。下面是我们现在使用的Dockerfile文件的一个例子。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们当前的docker文件</figcaption></figure><p id="1614" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了这个和docker构建插件，我们可以运行<code class="fe mg mh mi mj b">gradle clean buildDocker</code>(或者使用<a class="ae lz" href="https://github.com/spotify/docker-maven-plugin" rel="noopener ugc nofollow" target="_blank"> maven docker插件</a>)并构建我们的docker映像。请注意，它将为您在<code class="fe mg mh mi mj b">gradle.properties</code>或<code class="fe mg mh mi mj b">build.gradle</code>上配置的版本创建一个带有版本标签的映像。我们目前正在使用gradle发布插件来创建发布任务的图像。</p><h2 id="73db" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">2 —创建部署和我们的pod</h2><p id="d29a" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">好吧！我们创建了or图像，现在要把它放到Kubernetes上，我们需要把它上传到一个<em class="la">注册表上。</em>我们可以上传到公共docker注册表(更简单的方法)，但是每个人都可以访问该图像！由于我们的服务是私人的，我们需要上传到一个私人注册。幸运的是，Gcloud为您的帐户提供了私人注册。本<a class="ae lz" href="https://cloud.google.com/container-registry/docs/pushing-and-pulling" rel="noopener ugc nofollow" target="_blank">教程</a>中介绍了如何上传图片。</p><p id="7152" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这样一来，我们终于可以在Kubernetes集群上部署或服务了！因为我们使用Gcloud，所以用GKE创建集群非常容易，按照这个<a class="ae lz" href="https://cloud.google.com/kubernetes-engine/docs/quickstart" rel="noopener ugc nofollow" target="_blank">教程</a>来做(或者<a class="ae lz" href="https://kubernetes.io/docs/setup/pick-right-solution/" rel="noopener ugc nofollow" target="_blank">这个</a>在AWS、Azure、Bluemix等上设置集群)。在创建了集群并配置了连接到它的命令行之后，我们需要创建一个<a class="ae lz" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment" rel="noopener ugc nofollow" target="_blank">部署</a>(或者一个<a class="ae lz" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" rel="noopener ugc nofollow" target="_blank">复制控制器</a>)来使我们的应用程序可伸缩。我们使用以下配置作为我们的临床配置。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="be9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">考虑到我们在上一步中配置了Kubernetes命令行界面(kubectl ),我们可以使用<code class="fe mg mh mi mj b">kubectl apply -f Deployment.yml</code>为Kubernetes集群创建一个具有这种配置的新部署。过一会儿，你可以用<code class="fe mg mh mi mj b">kubectl get deployment spring-boot-deployment</code>检查部署的状态，用<code class="fe mg mh mi mj b">kubectl get pods spring-boot-app</code>检查pod，如果你想检查pod的日志，你可以使用<code class="fe mg mh mi mj b">kubectl log</code>命令。</p><h2 id="15b6" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">3 —通过服务公开我们的pod</h2><p id="4970" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">现在，随着我们的pod的运行，我们需要创建一个<a class="ae lz" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>来向世界展示我们的pod。以下配置用于创建我们的服务。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="037c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，服务配置非常简单。然而，这种配置是不公开的。我们可以将服务类型设置为<strong class="ke ir">负载平衡器</strong>，因为gcloud会自动为我们的服务创建一个真正的负载平衡器和一个外部ip。我们实际上尝试过这样做，但是在这种配置下，我们无法正确设置TLS和HTTPS。我们希望我们的服务只能被HTTPS协议访问。但是我们怎么做呢？</p><h2 id="2927" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">4 —入口路由</h2><p id="d2c6" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">所以我挖得更深，找到了Kubernetes入口。这是一个较新的功能，但它工作得很好。它几乎像一个使用类型<strong class="ke ir"> LoadBalancer </strong>的服务一样工作，但是您可以设置定制的路由规则。以下是我们的入口配置。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="755a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如您所见，我们将入口设置为仅允许与<code class="fe mg mh mi mj b">kubernetes.io/ingress.allow-http: "false"</code>的HTTPS连接。但是，如果您注意的话，可以看到这个文件上有一个TLS配置。我们需要首先创建一个<em class="la"> Secret </em>来保存我们的ssl证书数据，以供入口访问。使用下面的配置就可以做到这一点。</p><h2 id="928d" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">5 —秘密</h2><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="42b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">应用所有配置后，我们可以使用<code class="fe mg mh mi mj b">kubectl get ingress spring-boot-ingress</code>命令检查我们应用程序的外部ip。通过HTTPS和<em class="la"> voulá，</em>我们的Spring Boot应用程序运行在Kubernetes集群上！</p><h2 id="86f9" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">重要！Kubernetes服务在默认的pod端口和端点“/”上执行健康检查。如果您没有映射该端点或者它是安全的，您需要包括<code class="fe mg mh mi mj b"><strong class="ak">livenessProbe</strong></code> <strong class="ak">和</strong> <code class="fe mg mh mi mj b"><strong class="ak">readinessProbe</strong></code> <strong class="ak"> </strong> <code class="fe mg mh mi mj b"><strong class="ak">configuration. </strong><a class="ae lz" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank"><strong class="ak">Here</strong></a><strong class="ak"> is how to do that.</strong></code></h2><p id="d14d" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">我建议在部署到生产环境之前用<em class="la"> minikube </em>测试这些设置，这样您可以熟悉Kubernetes环境。文档页有非常好的<a class="ae lz" href="https://kubernetes.io/docs/tutorials/" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><p id="2a00" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe mg mh mi mj b"><strong class="ke ir">kubectl set image deployment/spring-boot-deployment spring-boot-app=your-new-image</strong></code> <strong class="ke ir"> </strong>部署新版本，或者使用<code class="fe mg mh mi mj b"><strong class="ke ir">kubectl edit deployment spring-boot-deployment</strong></code> <strong class="ke ir"> </strong>简单编辑配置。使用第二个命令，您可以同时更新图像和pod的数量。如果你只想缩放应用程序，运行<code class="fe mg mh mi mj b"><strong class="ke ir">kubectl scale deployment spring-boot-deployment --replicas=10</strong></code> <strong class="ke ir"> </strong>或创建一个<a class="ae lz" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment" rel="noopener ugc nofollow" target="_blank">自动缩放</a>配置。</p><p id="45c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更新部署导致Kubernetes以零停机时间推出更新，因为它会处理一切，您可以高枕无忧。在将基础设施转移到GKE后，我们可以更少地担心应用程序的健康，而更多地关注它的开发。Kubernetes与Jenkins、GitLab CI、BitBucket Pipelines等CI工具配合使用确实很简单。我们目前正在与GitLab CI集成，git lab CI为Kubernetes提供了强大的支持，并将为我们部署应用程序提供更大的灵活性。</p><p id="cbe2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望我关于将Spring Boot服务迁移到Kubernetes集群的研究能在将来帮助你(和我自己:)。</p></div></div>    
</body>
</html>