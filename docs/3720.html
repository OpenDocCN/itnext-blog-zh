<html>
<head>
<title>How To Make Your Website Work Offline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的网站离线工作</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-your-website-work-offline-b5be47b92adc?source=collection_archive---------1-----------------------#2020-02-10">https://itnext.io/how-to-make-your-website-work-offline-b5be47b92adc?source=collection_archive---------1-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6876" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需一个简单的步骤即可获得更好的性能和用户体验</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/5091695ce95b147dfa07477d799b6d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJ9aL0QzUbxzCTGz"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">乔纳森·肯珀在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5e31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是两部分系列的第一部分，<a class="ae le" href="https://medium.com/itnext/how-to-make-your-website-work-offline-part-2-6923b9038dd6" rel="noopener">第二部分</a></p><p id="020e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你是否曾经在手机上打开一个原生应用程序，看到一个恐龙的图片，告诉你需要连接到互联网才能使用该应用程序？</p><p id="bf10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不会。大多数原生应用会给你更好的用户体验，至少会向你展示一些东西，直到你再次连接。</p><p id="19db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果你断开互联网，访问一个随机的网站，那么通常你得到的是:什么也没有。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lg"><img src="../Images/f72ddddb54c722d5e6b9462db618fcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFaaqJkltQVkGpfIrV-v9g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">恐龙在那里是有原因的</figcaption></figure><p id="349d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种耻辱，因为没有理由提供如此糟糕的体验，而有许多理由提供更好的体验。如果用户在重新上线之前，至少可以用有限的功能使用你的网站，你就提供了更好的用户体验。</p><p id="b15d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是完全离线对用户来说并不会发生太多。更常见的情况是，用户的连接速度慢且不稳定。当这种情况发生时，你的网站将永远无法加载，用户也不会再烦了，也不会离开了。</p><p id="11a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://www.machmetrics.com/speed-blog/how-does-page-load-time-affect-your-site-revenue/" rel="noopener ugc nofollow" target="_blank"> 74%的人会离开一个需要5秒以上才能加载的移动网站</a>。</p><blockquote class="lh li lj"><p id="3b23" class="jq jr lf js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">但是，如果你至少在屏幕上显示最低限度所需的一切都已经存在，而你只需要互联网来获取新数据，那该怎么办呢？</p></blockquote><p id="ef80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是原生应用的工作方式。UI会立即加载，并从互联网上获取新数据。如果用户离线，陈旧数据会一直显示，直到用户重新在线。</p><p id="2a12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你已经确保你的网站的资产(CSS，图片，JavaScript)可以从本地缓存提供，那么这些将会立即可用，而不需要通过网络获取。如果你已经确保你最常访问的页面也在本地缓存，那么这些页面也会立即可用。</p><p id="eb93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这确保了您的网站将提供更好的用户体验和更好的性能。</p><p id="525e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是所有网站应该如何工作的方式，幸运的是，你今天就可以做到。</p><h1 id="ed71" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">如何让你的网站离线工作</h1><p id="a149" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">第一步:添加服务人员<br/>第二步:享受！</p><p id="dfb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务工作者是一个网络工作者，就像你的网站、浏览器和网络之间的代理服务器。它使您能够拦截所有的请求和响应发生在您的网站上。</p><p id="0d0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让这一点沉淀一分钟:通过在你的网站上增加一个服务人员，你现在必须拦截任何传出的请求和传入的响应。仅此一点就足以成为今天在你的网站上添加一个的理由。</p><p id="0594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这实际上意味着您可以拦截任何请求，并基本上提供您想要的任何服务。您可以直接从本地缓存提供静态资产，甚至从<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>提供API响应和BLOBs。</p><p id="ba9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务人员受到所有现代浏览器的支持，并通过<em class="lf">渐进增强</em>工作，这意味着当用户使用不支持服务人员的旧浏览器访问您的网站时，不会出现任何问题。在这种情况下，它在离线状态下是行不通的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/b22052589575bf14a0ed1ef1dedbe932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7avln3n4pH-hil8cPdeuRg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">所有现代浏览器现在支持服务工作者(数据来自caniuse.com)</figcaption></figure><p id="7379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要向您的网站添加服务人员，只需创建一个名为<code class="fe mr ms mt mu b">service-worker.js</code>(任何名称都可以)的文件，并将其放在您的应用程序的根目录下。然后我们调用<code class="fe mr ms mt mu b">navigator.serviceWorker.register</code>来注册服务人员。</p><p id="ab8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用支票把它包起来，确保旧浏览器不会坏:</p><pre class="kp kq kr ks gt mv mu mw mx aw my bi"><span id="b3c8" class="mz lo it mu b gy na nb l nc nd">if('serviceWorker' in navigator) {<br/>  let registration;<br/><br/>  const registerServiceWorker = async () =&gt; {<br/>    registration = await          navigator.serviceWorker.register('./service-worker.js');<br/>  };<br/><br/>  registerServiceWorker();<br/>}</span></pre><p id="4c3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！您的站点现在由一个服务人员控制，但是由于文件仍然是空的，它实际上不会做任何事情。服务工作者是事件驱动的Web工作者，因此我们需要添加代码来响应这些事件，从生命周期事件开始。</p><h1 id="0f46" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">服务人员生命周期</h1><p id="d647" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">为了确保服务人员不会破坏任何东西，他们有一个严格定义的生命周期。这可以确保只有一个服务人员控制网站的某个部分(因此只有一个版本的网站存在)。</p><p id="b7ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上，你可以让多个服务人员控制你的网站，但前提是他们控制不同的范围。现在，知道只有一个服务人员可以控制某个范围就足够了。</p><p id="0dd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要了解服务人员，了解服务人员的生命周期至关重要。</p><h2 id="663c" class="mz lo it bd lp ne nf dn lt ng nh dp lx kb ni nj mb kf nk nl mf kj nm nn mj no bi translated">安装事件</h2><p id="c90c" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">第一个被激发的事件是<code class="fe mr ms mt mu b">install</code>事件。当服务工作程序被成功下载、解析和执行时，它被触发。如果在此阶段出现任何错误，从<code class="fe mr ms mt mu b">navigator.serviceWorker.register</code>返回的承诺被拒绝，<code class="fe mr ms mt mu b">install</code>事件将<em class="lf">而不是</em>触发，服务人员将被丢弃。如果已经有一个服务工作程序在运行，它将继续运行。</p><p id="a267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果成功安装了服务工作器，将触发<code class="fe mr ms mt mu b">install</code>事件，在事件处理程序中，您应该缓存您的静态资产。缓存是使用位于<code class="fe mr ms mt mu b">window.caches</code>的<code class="fe mr ms mt mu b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" rel="noopener ugc nofollow" target="_blank">CacheStorage</a></code>对象完成的。</p><p id="c726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们缓存所有需要的HTML、CSS、JavaScript、图像、字体等的部分。显示网站的最小用户界面。当用户再次访问该站点或刷新页面时，所有内容都将从本地缓存中提供，这意味着它将被立即提供。</p><blockquote class="lh li lj"><p id="f7ca" class="jq jr lf js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">不需要从网络上获取任何东西，它已经在那里了。</p></blockquote><p id="429d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了缓存所有资产，我们首先打开一个缓存，然后将一个指向我们想要缓存的资产的路径数组传递给<code class="fe mr ms mt mu b">addAll</code>方法。<code class="fe mr ms mt mu b">open</code>方法返回一个承诺，我们将这个承诺传递给安装事件的<code class="fe mr ms mt mu b">waitUntil</code>方法，以便在安装完成时向浏览器发出信号，如果安装成功:</p><pre class="kp kq kr ks gt mv mu mw mx aw my bi"><span id="bcdc" class="mz lo it mu b gy na nb l nc nd">const cacheName = 'my-cache';<br/>const filestoCache = [<br/>  '/',<br/>  '/about',<br/>  '/index.html',<br/>  '/about.html',<br/>  '/css/styles.css',<br/>  '/js/app.js',<br/>  '/img/logo.png'<br/>]; </span><span id="d289" class="mz lo it mu b gy np nb l nc nd">self.addEventListener('install', e =&gt; {<br/>  e.waitUntil(<br/>    caches.open(cacheName)<br/>    .then(cache =&gt; cache.addAll(filesToCache))<br/>  );<br/>});</span></pre><p id="ca46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，如果传递给<code class="fe mr ms mt mu b">e.waitUntil</code>的承诺被拒绝，它将向浏览器发出安装失败的信号，新的服务工作者将被丢弃，留下现有的(如果存在)服务工作者运行。</p><p id="7ecb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果您有不指向特定文件(如<code class="fe mr ms mt mu b">/about.html</code>)而只是指向<code class="fe mr ms mt mu b">/about</code>的路径，您可能也需要缓存这些路径。例如，当你的网站是一个单页应用程序，并且每个请求都被路由到<code class="fe mr ms mt mu b">/index.html</code>时，就是这种情况。</p><p id="10ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您应该缓存路径，以便您的应用程序仍然可以工作并提供正确的视图。</p><h2 id="aca4" class="mz lo it bd lp ne nf dn lt ng nh dp lx kb ni nj mb kf nk nl mf kj nm nn mj no bi translated">激活事件</h2><p id="ee43" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">当成功安装(新的)服务工作者时，将触发<code class="fe mr ms mt mu b">activate</code>事件。服务人员现在准备好控制您的网站，<em class="lf">但它还不会控制它。</em></p><p id="251c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有当你在后刷新页面<em class="lf">时，服务人员才被激活，并控制你的网站。这也是为了确保没有任何损坏。</em></p><p id="ddbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务人员控制的网站窗口称为其<code class="fe mr ms mt mu b">clients</code>。在<code class="fe mr ms mt mu b">install</code>事件的事件处理程序中，可以通过调用<code class="fe mr ms mt mu b">self.clients.claim()</code>来控制不受控制的<code class="fe mr ms mt mu b">clients</code>。</p><p id="d605" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">服务人员将立即控制网站，尽管这仅在服务人员第一次被激活时有效。当激活新版本的服务人员时，它不起作用:</p><pre class="kp kq kr ks gt mv mu mw mx aw my bi"><span id="f378" class="mz lo it mu b gy na nb l nc nd">self.addEventListener('activate', e =&gt; self.clients.claim());</span></pre><h2 id="271f" class="mz lo it bd lp ne nf dn lt ng nh dp lx kb ni nj mb kf nk nl mf kj nm nn mj no bi translated">拦截请求和响应</h2><p id="0ed2" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">现在是您一直在等待的事情:拦截请求和响应。</p><p id="7a1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每当网站请求服务人员控制时，就会触发一个<code class="fe mr ms mt mu b">fetch</code>事件。<code class="fe mr ms mt mu b">FetchEvent</code>的<code class="fe mr ms mt mu b">request</code>属性提供了对请求的访问。在事件处理程序中，我们可以为之前在<code class="fe mr ms mt mu b">install</code>事件处理程序中添加到缓存中的静态资产提供服务:</p><pre class="kp kq kr ks gt mv mu mw mx aw my bi"><span id="f986" class="mz lo it mu b gy na nb l nc nd">self.addEventListener('fetch', e =&gt; {<br/>  e.respondWith(<br/>    caches.match(e.request)<br/>    .then(response =&gt; response ? response : fetch(e.request))<br/>  )<br/>});</span></pre><p id="99a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过调用<code class="fe mr ms mt mu b">FetchEvent</code>的<code class="fe mr ms mt mu b">respondWith</code>方法，浏览器的默认获取处理被阻止。我们称之为承诺，承诺解决了一个<code class="fe mr ms mt mu b">Response</code>然后服务。</p><p id="ba03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对<code class="fe mr ms mt mu b">caches.match()</code>的调用检查缓存以查看资产是否被缓存。如果是，它将作为缓存中的一个<code class="fe mr ms mt mu b">Response</code>，但是如果不是，我们通过调用<code class="fe mr ms mt mu b">fetch(e.request)</code>从网络中获取它。</p><p id="b612" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这确保了静态资产将<em class="lf">总是</em>被缓存，只要它们以前被缓存过。现在，无论您网站的用户何时处于糟糕的移动连接甚至完全离线状态，缓存的资产仍将提供服务，您能够为您的用户提供良好的用户体验。</p><p id="7c4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您已经确保缓存所有静态资产和所有可能的路线，任何访问您网站的任何页面至少一次的用户现在都可以离线使用您的网站。</p><p id="bb52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是服务人员的完整代码，他们会处理好这一切。将它放在网站根目录下的一个文件中，并给它一个名字，例如<code class="fe mr ms mt mu b">service-worker.js</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="958d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后在代码的早期，注册服务工作者:</p><pre class="kp kq kr ks gt mv mu mw mx aw my bi"><span id="9d2f" class="mz lo it mu b gy na nb l nc nd">if('serviceWorker' in navigator) {<br/>  let registration;<br/><br/>  const registerServiceWorker = async () =&gt; {<br/>    registration = await          navigator.serviceWorker.register('./service-worker.js');<br/>  };<br/><br/>  registerServiceWorker();<br/>}</span></pre><p id="2c28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">恭喜你！您的网站现在脱机工作，您为您的用户提供了更好的体验和更好的性能！</p><h1 id="d25f" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">接下来去哪里</h1><p id="9ff1" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">为了进一步增强网站的离线能力和性能，我将在下一篇文章中展示如何缓存API调用，这样动态内容也可以立即可用。</p></div></div>    
</body>
</html>