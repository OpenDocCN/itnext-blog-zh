<html>
<head>
<title>Unleash the power of MicroK8s: your own production-like Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">释放MicroK8s的力量:您自己的生产式Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/unleash-the-power-of-microk8s-your-own-production-like-kubernetes-cf356ccb75f7?source=collection_archive---------0-----------------------#2019-06-03">https://itnext.io/unleash-the-power-of-microk8s-your-own-production-like-kubernetes-cf356ccb75f7?source=collection_archive---------0-----------------------#2019-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Microk8s是一个令人兴奋的强大解决方案，可以轻松地在本地运行一个配备齐全的kubernetes基础设施(T2、T3、T4、T5)。直接在本地集群上部署和测试，就像在典型的生产环境中一样，没有太多麻烦。您可以在一个命令中启动并运行<strong class="js iu"> <em class="kp">。随着一些<a class="ae ko" href="https://blog.ubuntu.com/2019/03/28/microk8s-in-the-wild" rel="noopener ugc nofollow" target="_blank">应用程序已经在野外</a>和更多可能的应用程序，它的受欢迎程度正在理所当然地增长。在这个简短的介绍中，我们将看看MicroK8s的一个最典型的用例。</em></strong></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/a1b258b5c92dd33361f0a36aa4b57df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H2oGhhMAhPgTM92o6QUBBw.png"/></div></div></figure><p id="b260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们以一个Docker(微)服务环境为例，生产工作负载运行在Kubernetes上。一个高效的开发团队(或单个开发人员)最想要的需求是一个一致的、可靠的、类似生产的本地环境，例如，在部署到一个公共的阶段环境之前，在这个环境中测试和集成他们的代码与一个平台的所有必要的组件，全部启动并运行。</p><p id="0310" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，对于日常的集成工作，每个团队成员都带来了他/她自己定制的本地设置:有些人更喜欢<em class="kp">普通docker </em>和容器的手动启动/停止，有些人喜欢<em class="kp"> docker-compose </em>，其他人使用<em class="kp"> minikube、vagger、virtualbox </em>，以上所有这些的组合或者另一个深奥的解决方案。有些人喜欢模仿某些服务，有些人则喜欢挑战在自己的笔记本电脑上运行整个堆栈。许多人无可挽回地花费数小时来设置和修复他们自己不断变化的本地设置。但是他们只需要测试他们编码到一(1)个服务中的新端点！我见过有人花了几天的时间去追踪一个bug，结果发现这完全是因为他们的本地环境需要修复，这当然是一种浪费时间的愚蠢方式。</p><p id="13f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">团队成员在本地环境中缺乏一致性将导致低估生产力的缺乏，稍后反映在交付的服务的最终质量中。相反，如果整个团队设法同意使用，比方说，一个公共的<em class="kp"> docker compose </em>定义来产生一个本地测试环境，这可以保证一个流畅的体验和共享项目上更可预测的结果。关键是团队有能力找到并接受一个共同共享的解决方案，然后利用它。现在，特别是如果你的平台不是平凡的，并且使用一个真正的、互连的微服务网格(而不仅仅是通过队列通信的独立的dockerized monolithic服务)<em class="kp">对于本地环境，有一些比docker compose更好的解决方案。</em></p><p id="d1ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于那些在Linux上工作的幸运的人或其他在Mac或Windows上能够负担得起庞大的Linux虚拟机的人来说，Canonical在2018年12月发布的<strong class="js iu"> MicroK8s </strong> snap提供了很大的帮助。<a class="ae ko" href="https://snapcraft.io/" rel="noopener ugc nofollow" target="_blank"> Snaps </a>，最初是Ubuntu的东西，现在可以在大量的Linux发行版中得到支持，MicroK8s似乎是使用它们的一个很好的激励。这篇文章不会解释什么是快照或者如何在你的发行版中支持它们。</p><p id="dd71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> MicroK8s </strong>可以非常容易地安装在你的Linux系统<a class="ae ko" href="https://tutorials.ubuntu.com/tutorial/install-a-local-kubernetes-with-microk8s#0" rel="noopener ugc nofollow" target="_blank">上</a>并且成为snap将与系统资源紧密集成，因此运行平稳快速，同时与其他应用程序保持分离。集成是这样的，您将看到在您的系统中与MicroK8s组件一起运行的<em class="kp"> systemd </em>服务。同样令人惊讶的是它带来的<em class="kp">插件</em>的数量，以及它的普遍兼容性(它是经过<em class="kp">认证的Kubernetes </em>)使它成为一个<em class="kp">完整的平台</em>。</p><p id="a67a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Minikube </strong> </a>是另一种在本地运行K8S的强大方法，可以相对容易地安装<a class="ae ko" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank"/>，并具有适用于所有平台的设置脚本，但它也运行在Linux上的大型虚拟化虚拟机中(需要安装虚拟机管理程序)，具有相对有限的插件数量，并且可能需要大量工作来适应高级需求或由多个团队成员一致部署。当然:每个人都有坚持自己喜好的自由。</p><p id="af0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，在一个典型的Kubernetes生产平台中，你会在MicroK8s中找到什么样的<em class="kp"/><em class="kp">或者作为插件</em>(更多信息<a class="ae ko" href="https://microk8s.io/docs/" rel="noopener ugc nofollow" target="_blank">在这里</a> ) <em class="kp">？</em></p><ul class=""><li id="6195" class="lc ld it js b jt ju jx jy kb le kf lf kj lg kn lh li lj lk bi translated">K8S仪表板</li><li id="79a7" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">Kube DNS</li><li id="8796" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><em class="kp">注册表</em></li><li id="33ec" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">存储类添加到本地主机上的文件夹中</li><li id="d81c" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated">Ingress (MicroK8s没有<em class="kp">负载均衡器</em>，但是必要时可以使用Ingress插件<a class="ae ko" href="https://kndrck.co/posts/microk8s_ingress_example/" rel="noopener ugc nofollow" target="_blank">在外部IP上发布)</a></li><li id="4a74" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> RBAC </em> </a></li><li id="232a" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><a class="ae ko" href="https://kubernetes.io/docs/tasks/debug-application-cluster/logging-elasticsearch-kibana/" rel="noopener ugc nofollow" target="_blank"> efk堆栈</a> ( <em class="kp"> Elasticsearch，Fluentd ans Kibana </em>)用于汇总日志</li></ul><pre class="kr ks kt ku gt lq lr ls lt aw lu bi"><span id="42a4" class="lv lw it lr b gy lx ly l lz ma">$ microk8s.kubectl cluster-info<br/>Kubernetes master is running at <a class="ae ko" href="https://127.0.0.1:16443" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443</a><br/>Elasticsearch is running at <a class="ae ko" href="https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy</a><br/>Heapster is running at <a class="ae ko" href="https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/heapster/proxy" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/heapster/proxy</a><br/>Kibana is running at <a class="ae ko" href="https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/kibana-logging/proxy" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/kibana-logging/proxy</a><br/>KubeDNS is running at <a class="ae ko" href="https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</a><br/>Grafana is running at <a class="ae ko" href="https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy</a><br/>InfluxDB is running at <a class="ae ko" href="https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/monitoring-influxdb:http/proxy" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:16443/api/v1/namespaces/kube-system/services/monitoring-influxdb:http/proxy</a></span></pre><p id="a3da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上大部分你也会发现作为<em class="kp"> Minikube </em>的插件。但是在MicroK8s中，有更多面向微服务和更复杂的有状态设置的功能:</p><ul class=""><li id="7311" class="lc ld it js b jt ju jx jy kb le kf lf kj lg kn lh li lj lk bi translated"><a class="ae ko" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/metrics-server.md" rel="noopener ugc nofollow" target="_blank">指标-服务器</a>以及<a class="ae ko" href="https://github.com/coreos/prometheus-operator" rel="noopener ugc nofollow" target="_blank"> <em class="kp">普罗米修斯</em> </a>在<em class="kp"> Grafana </em>中可见的指标</li><li id="5226" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><em class="kp"/><a class="ae ko" href="https://istio.io" rel="noopener ugc nofollow" target="_blank"><em class="kp">istio</em></a><a class="ae ko" href="https://glasnostic.com/blog/kubernetes-service-mesh-what-is-istio" rel="noopener ugc nofollow" target="_blank">服务网</a>(更多信息<a class="ae ko" href="https://cloud.google.com/istio/#documentation" rel="noopener ugc nofollow" target="_blank">此处</a>)</li><li id="31d3" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><a class="ae ko" href="https://linkerd.io/2/overview/" rel="noopener ugc nofollow" target="_blank"> <em class="kp"> linkerd </em> </a>，另一个服务网格</li><li id="8a49" class="lc ld it js b jt ll jx lm kb ln kf lo kj lp kn lh li lj lk bi translated"><em class="kp"> </em> <a class="ae ko" href="https://www.jaegertracing.io/" rel="noopener ugc nofollow" target="_blank"> <em class="kp">耶格</em> </a> <em class="kp"> </em> <a class="ae ko" href="https://enterprisersproject.com/article/2019/2/kubernetes-operators-plain-english" rel="noopener ugc nofollow" target="_blank">运算符</a></li></ul><p id="79c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">MicroK8s在snap ( <code class="fe mb mc md lr b">microk8s.kubectl</code> <em class="kp"> ) </em>中有自己内置的<em class="kp"> kubectl </em>工具，并且可以很容易地生成完整的<em class="kp"> kubeconfig </em>配置文件，以便在本地使用，如果您已经安装了自己的<em class="kp">kube CTL</em>(<code class="fe mb mc md lr b">microk8s.config &gt; kube/config</code>)。你也可以在<code class="fe mb mc md lr b"> /etc/hosts</code>中为最常用的网址添加别名，比如Dashboard、Grafana和Kibana。</p><p id="e144" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://kubeless.io/" rel="noopener ugc nofollow" target="_blank"><em class="kp">kubesless</em></a>在MicroK8s上轻松运行，对于无服务器设置(谁需要Lambda？);为什么不在它上面放一个<em class="kp"> Jenkins </em>(也许以不同于示例中的另一种方式)，如果您想知道的话，也可以轻松地支持<em class="kp"/><a class="ae ko" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"><em class="kp">Helm</em></a><em class="kp"/><a class="ae ko" href="https://github.com/helm/charts/tree/master/stable" rel="noopener ugc nofollow" target="_blank"><em class="kp">Charts</em></a>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi me"><img src="../Images/31011b312c92fa8b04995a0dc1bc84cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*8IZ2ZIXfwH-EJ6rfl1LKVg.jpeg"/></div></figure><p id="0233" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要安装<em class="kp">舵柄</em>作为功能性<em class="kp">舵柄</em>海图支撑(假设你的<em class="kp"> kubeconfig </em>已经就位)，通常的<code class="fe mb mc md lr b">helm init</code>将完成这个任务，打开所有可用<a class="ae ko" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank">海图</a>的世界。而这仅仅是开始！</p><p id="5274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">MicroK8s的定制或扩展可以从它的<a class="ae ko" href="https://github.com/ubuntu/microk8s" rel="noopener ugc nofollow" target="_blank">源repo、</a>进行，这样你就可以定制设置并与你的团队共享，比如选择默认启用的插件，这样<em class="kp">就有了你的团队共享的本地平台。</em></p><p id="290c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后回到老式的整体服务，作为一个实验，我花了大约<strong class="js iu"><em class="kp"/></strong>10分钟就有了一个成熟的K8S集群，并且运行了<em class="kp"> Wordpress </em>本地博客(<code class="fe mb mc md lr b">helm install stable/wordpress</code>)，就这样我安装了主题并写了文章。你能用Minikube做到吗(包括创建一个VM需要的时间)？否则，请询问您友好的开发人员，他们花了多长时间在一个普通集群中正确设置稳定的dns、监控、日志记录和RBAC..</p></div></div>    
</body>
</html>