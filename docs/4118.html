<html>
<head>
<title>Introducing Consistent Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引入一致散列</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-consistent-hashing-9a289769052e?source=collection_archive---------1-----------------------#2020-04-30">https://itnext.io/introducing-consistent-hashing-9a289769052e?source=collection_archive---------1-----------------------#2020-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dc04d961e1f48198c34737a7f3c2b812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_WfL6G4EAMjbKoqA0hOnw.png"/></div></div></figure><p id="4b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着分布式架构的兴起，<strong class="ka ir">一致哈希</strong>成为主流。但是它到底是什么，它与标准散列算法有什么不同？背后的确切动机是什么？</p><p id="e759" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将描述主要概念。然后，我们将深入研究现有的算法，以了解与一致性哈希相关的挑战。</p><h1 id="c6f6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">主要概念</h1><h2 id="f838" class="lu kx iq bd ky lv lw dn lc lx ly dp lg kj lz ma lk kn mb mc lo kr md me ls mf bi translated">散列法</h2><p id="40b9" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">哈希是<strong class="ka ir">将任意大小的数据</strong>映射到<strong class="ka ir">固定大小的值</strong>的过程。每个现有算法都有自己的规范:</p><ul class=""><li id="29b3" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">MD5生成128位哈希值。</li><li id="b3b5" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">SHA-1产生160位散列值。</li><li id="1f16" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">等等。</li></ul><p id="72a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">散列在计算机科学中有许多应用。例如，其中一个应用程序称为校验和。为了验证数据集的完整性，可以使用哈希算法。服务器对数据集进行哈希运算，并向客户端指示哈希值。然后，客户端对其版本的数据集进行哈希处理，并比较哈希值。如果它们相等，完整性<strong class="ka ir">应该</strong>被验证。</p><p id="a362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的“应该”很重要。最坏的情况是当<strong class="ka ir">碰撞</strong>发生时。冲突是指两个不同的数据片段具有相同的哈希值。让我们通过定义下面的散列函数来举一个现实生活中的例子:给定一个人，它返回他的生日(出生月份的第&amp;天)。<a class="ae mz" href="https://en.wikipedia.org/wiki/Birthday_problem" rel="noopener ugc nofollow" target="_blank">生日悖论</a>告诉我们，如果一个房间里只有23个人，两个人同一天生日的概率(因此发生冲突)超过50%。所以生日函数很可能不是一个好的哈希函数。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/727ea10c4a389635ae7b8ec122352edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*o0e0cgUEt0Z3C1M_aIVF6g.jpeg"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">糟糕的散列函数</figcaption></figure><p id="be62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为散列法的快速介绍，理解其主要思想是关于在<strong class="ka ir">域</strong>中传播值是很重要的。例如:</p><ul class=""><li id="d9dc" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">MD5将值分布在128位的空间域中</li><li id="9399" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">一个由32个元素组成的数组支持的哈希表(或hashmap)有一个内部哈希函数，可以将值分布到任何索引(从0到31)。</li></ul><h2 id="a83e" class="lu kx iq bd ky lv lw dn lc lx ly dp lg kj lz ma lk kn mb mc lo kr md me ls mf bi translated">负载分布</h2><p id="f268" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">负载分布可以定义为在节点间分配负载的过程。这里的术语节点可以与服务器或实例互换。这是一个计算单元。</p><p id="e9e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">负载平衡</strong>是负载分配的一个例子。它是关于在一组资源上分配一组任务。例如，我们使用负载平衡在web服务器实例之间分配API请求。</p><p id="f265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说到数据，我们更愿意使用术语<strong class="ka ir">分片</strong>。数据库碎片是数据库中数据的水平分区。一个典型的例子是一个分成三个碎片的数据库，其中每个碎片都有全部数据的一个子集。</p><p id="248a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">负载平衡和分片面临一些共同的挑战。例如，均匀地分布数据<strong class="ka ir"/>以保证一个节点与其他节点相比不会过载。在某些情况下，负载平衡和分片还需要将任务或数据关联到同一个节点:</p><ul class=""><li id="ffbf" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">如果我们需要序列化、逐个处理给定消费者的操作，我们必须将请求路由到同一个节点。</li><li id="8eba" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">如果我们需要分发数据，我们必须知道哪个碎片是特定键的所有者。</li></ul><p id="cb93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">听起来耳熟吗？在这两个例子中，我们将值分布在一个域中。无论是分散到服务器节点的任务还是分散到数据库碎片的数据，我们都可以找到与散列相关的思想。这就是为什么散列可以与负载分布结合使用的原因。让我们看看怎么做。</p><h2 id="393e" class="lu kx iq bd ky lv lw dn lc lx ly dp lg kj lz ma lk kn mb mc lo kr md me ls mf bi translated">Mod-n散列</h2><p id="bafc" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">mod-n哈希的原理如下。使用哈希函数对每个键进行哈希运算，将输入转换为整数。然后，我们基于节点的数量执行模运算。</p><p id="f53e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个有3个节点的具体例子。这里，我们需要根据一个密钥标识符在这些节点之间分配负载。对每个密钥进行哈希运算，然后我们执行模运算:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/6bf7a37d7d62b5bf1d2f93ec0349fe0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSV8OUgphkkZuNkKAdGwtA.png"/></div></div></figure><p id="def0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的好处是它的无状态性。我们不必保持任何状态来提醒我们<code class="fe nk nl nm nn b">foo</code>被路由到节点2。然而，我们需要知道有多少节点被配置为应用模运算。</p><p id="7ca0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，在向外扩展或向内扩展(添加或删除节点)的情况下，该机制是如何工作的呢？如果我们添加另一个节点，模运算现在基于4而不是3:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/a8ea955eb2427d5de0cc18ab41647143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxKP2eO3qMT3eFKZ4X3hEw.png"/></div></div></figure><p id="87eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，键<code class="fe nk nl nm nn b">foo</code>和<code class="fe nk nl nm nn b">baz</code>不再与同一个节点相关联。使用mod-n散列，不能保证在键/节点关联中保持任何一致性。这是个问题吗？有可能。</p><p id="7366" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们实现一个使用分片并基于mod-n策略来分发数据的数据存储库会怎么样？如果我们扩展节点的数量，我们需要执行一个<strong class="ka ir">再平衡</strong>操作。在前面的示例中，重新平衡意味着:</p><ul class=""><li id="7e39" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">将<code class="fe nk nl nm nn b">foo</code>从节点2移动到节点0。</li><li id="f629" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">将<code class="fe nk nl nm nn b">baz</code>从节点2移动到节点3。</li></ul><p id="1a36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们存储了数百万甚至数十亿的数据，并且我们需要重新平衡几乎所有数据，会发生什么？我们可以想象，这将是一个沉重的过程。因此，我们必须改变我们的负载分配技术，以确保在重新平衡时:</p><ul class=""><li id="101b" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">基于新的节点数量，分布尽可能保持一致。</li><li id="9392" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们必须迁移的密钥数量应该是有限的。理想情况下，它将只占键的1/n，其中<em class="np"> n </em>是节点的数量。</li></ul><p id="37c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是<strong class="ka ir">一致散列</strong>算法的目的。</p><p id="5aed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“一致”这个词可能会让人有些困惑。我遇到过一些工程师，他们认为即使在面临可伸缩性的情况下，这种算法也会将一个给定的键与同一个节点关联起来。事实并非如此。它必须保持一致，直到某一点，以保持分布均匀。</p><p id="d156" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，是时候探究一些解决方案了。</p><h1 id="bb36" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">会合点</h1><p id="38b8" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">Rendezvous是解决我们问题的第一个算法。尽管发表于1996年的<a class="ae mz" href="http://www.eecs.umich.edu/techreports/cse/96/CSE-TR-316-96.pdf" rel="noopener ugc nofollow" target="_blank">原始研究</a>没有提到术语一致散列，但它确实为我们描述的挑战提供了一个解决方案。让我们看看Go中一个可能的实现:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a8ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是如何工作的？我们遍历每个节点并计算它的哈希值。哈希值由一个<code class="fe nk nl nm nn b">hash</code>函数返回，该函数根据一个键(我们的输入)和一个节点标识符产生一个整数(最简单的方法是对两个字符串的连接进行哈希运算)。然后，我们返回具有最高散列值的节点。这就是该算法也被称为最高随机权重哈希算法的原因。</p><p id="f058" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">rendezvous的主要缺点是它的O( <em class="np"> n </em>)时间复杂度，其中<em class="np"> n </em>是节点的数量。如果我们需要有限数量的节点，这是非常有效的。然而，如果我们开始维护数千个节点，可能会导致性能问题。</p><h1 id="d9a1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">环形一致散列</h1><p id="a312" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">下一个算法是1997年由Karger等人在这篇<a class="ae mz" href="https://dl.acm.org/doi/10.1145/258533.258660" rel="noopener ugc nofollow" target="_blank">论文</a>中发布的。这项研究第一次提到了一致性哈希这个术语。</p><p id="ead3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它基于环(端到端连接的阵列)。尽管这是最流行的一致性哈希算法(或者至少是最广为人知的)，但其原理并不总是被很好地理解。让我们深入研究一下。</p><p id="2a7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个操作是创建环。戒指的长度是固定的。在我们的示例中，我们将其划分为12个部分:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/56cc03fd35d23b4c7b082b10d212c095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*clie_RSelJk5Ek08mJ_7GA.png"/></div></figure><p id="64f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们定位我们的节点。在我们的例子中，我们将定义<code class="fe nk nl nm nn b">N0</code>、<code class="fe nk nl nm nn b">N1</code>和<code class="fe nk nl nm nn b">N2</code>。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7363a868c072440053e39d8d9d17d98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*NeAd1WWqiKppKzygVf--IQ.png"/></div></figure><p id="1e09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">节点暂时均匀分布。我们稍后将回到这一点。</p><p id="b38e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，是时候看看如何表示键了。首先，我们需要一个函数<code class="fe nk nl nm nn b">f</code>，它根据一个键返回一个环索引(从0到11)。我们可以使用mod-n散列法。因为环的长度是恒定的，所以不会给我们带来任何问题。</p><p id="55a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们将定义3个键:<code class="fe nk nl nm nn b">a</code>、<code class="fe nk nl nm nn b">b</code>和<code class="fe nk nl nm nn b">c</code>。我们对每一个应用<code class="fe nk nl nm nn b">f</code>。假设我们有以下结果:</p><ul class=""><li id="a976" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">f(a) = 1</code></li><li id="5c67" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">f(a) = 5</code></li><li id="611f" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">f(a) = 7</code></li></ul><p id="638d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们可以这样在戒指上放置钥匙:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/6bbdb35dcc7c4aa3686589fa35268078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fmdBPJmVLN4QvJfWJfTz5g.png"/></div></figure><p id="9319" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何将给定的键关联到一个节点？主要逻辑是<strong class="ka ir">向前进</strong>。从一个给定的键，我们返回前进时找到的第一个节点:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d9e82593999157140332a682a6c8a2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*w8QZYA3UpM7dHJo2o8Nyng.png"/></div></figure><p id="bae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们将<code class="fe nk nl nm nn b">a</code>关联到<code class="fe nk nl nm nn b">N1</code>、<code class="fe nk nl nm nn b">b</code>和<code class="fe nk nl nm nn b">c</code>关联到<code class="fe nk nl nm nn b">N2</code>。</p><p id="dd3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看<strong class="ka ir">再平衡</strong>是如何管理的。我们定义另一个节点<code class="fe nk nl nm nn b">N3</code>。我们应该把它定位在哪里？整体分布不再有均匀的空间。是否应该重组节点？不，否则我们就不会一致了，不是吗？为了定位一个节点，我们重用我们介绍过的同一个散列函数<code class="fe nk nl nm nn b">f</code>。它可以用节点标识符调用，而不是用键调用。所以新节点的位置是随机决定的。</p><p id="9fb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">于是出现了一个问题:当下一个节点不再是<code class="fe nk nl nm nn b">N1</code>时，我们应该如何处理<code class="fe nk nl nm nn b">a</code>:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/926f7085c2a8654b261567abb6ddb0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*yGaCxax71buSVQHOrF_6xQ.png"/></div></figure><p id="6e21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决方案如下:我们必须改变它的关联，并使<code class="fe nk nl nm nn b">a</code>与<code class="fe nk nl nm nn b">N3</code>相关联:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7c9ac5d9606e60eb1c5c68a971a12b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*uZJzQb5JbvKjKMVSDBB-Qg.png"/></div></figure><p id="1526" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们之前讨论的，一个理想的算法应该平均重新平衡1/n的键。在我们的例子中，当我们添加第四个节点时，我们应该将25%的可能键重新关联到<code class="fe nk nl nm nn b">N3</code>。是这样吗？</p><ul class=""><li id="6651" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N0</code>从索引8到12:占总键的33.3%</li><li id="28c2" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N1</code>从索引2到4:占总键的16.6%</li><li id="3304" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N2</code>从索引4到8:占总键的33.3%</li><li id="3742" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N3</code>从索引0到2:占总键的16.6%</li></ul><p id="8c5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的分布是不均匀的。我们如何改善这种情况？解决方法是使用<strong class="ka ir">虚拟节点</strong>。</p><p id="76e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们不是在每个节点上放置一个点，而是放置三个点。此外，我们需要定义三个不同的散列函数。每个节点被散列三次，因此我们得到三个不同的索引:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/86098fe15fbf4c3f82795187c3f7ff32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gv2_IQFJjMbanWS8ZSNAgw.png"/></div></div></figure><p id="a5a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过向前移动来应用相同的算法。然而，一个关键字将与一个节点相关联，而不管它遇到的是哪个虚拟节点。</p><p id="2f2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，分布如下:</p><ul class=""><li id="6e4b" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N0</code> : 33.3%</li><li id="b136" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N1</code> : 25%</li><li id="b272" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><code class="fe nk nl nm nn b">N2</code> : 41.6%</li></ul><p id="b92f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为每个节点定义的虚拟节点越多，分布就应该越均匀。平均而言，每台服务器有100个虚拟节点，标准分布约为10%。以1000计，大概是3.2%。</p><p id="4ec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有不同大小的节点，这种机制也很有用。例如，如果一个节点被配置为理论上处理两倍于其他节点的负载，我们可以启动两倍的虚拟节点。</p><p id="50fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，虚拟节点的主要缺点是内存占用。如果我们必须处理成千上万台服务器，那就需要数兆字节的内存。</p><p id="e7fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在继续之前，有趣的是，有时一个算法可以通过改变一小部分而得到实质性的改进。例如，谷歌在2017年发布的一种名为<a class="ae mz" href="https://ai.googleblog.com/2017/04/consistent-hashing-with-bounded-loads.html" rel="noopener ugc nofollow" target="_blank">的算法就是这种情况，该算法具有有界负载</a>。这个版本是基于我们描述的相同的环的想法。然而，他们的方法是在<strong class="ka ir">任何更新</strong>(添加/删除新的键或节点)时执行一个小的重新平衡。该版本在标准差方面优于原始版本，但代价是最坏的时间复杂度。</p><h1 id="6062" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">跳转一致散列</h1><p id="dbaa" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">2007年，谷歌的两位工程师发表了<a class="ae mz" href="https://arxiv.org/pdf/1406.2294.pdf" rel="noopener ugc nofollow" target="_blank">跳转一致哈希</a>。与基于环的算法相比，这种实现<em class="np">“不需要存储，速度更快，并且在桶之间均匀划分密钥空间以及在桶的数量变化时均匀划分工作负载方面做得更好”</em>。换句话说，它改善了工作负载在节点之间的分布(存储桶与节点是相同的概念),而没有任何内存开销。</p><p id="5ec8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是C++中的算法(7行代码🤯):</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="953a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在环一致散列中，对于1000个虚拟节点，标准偏差约为3.2%。在跳转一致散列中，我们不再需要虚拟节点的概念。然而，标准偏差仍然小于0.0000001%。</p><p id="4350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是有一个限制。节点必须按顺序编号<strong class="ka ir"/>。例如，如果我们有一个服务器列表<code class="fe nk nl nm nn b">foo</code>、<code class="fe nk nl nm nn b">bar</code>和<code class="fe nk nl nm nn b">baz</code>，我们就不能删除<code class="fe nk nl nm nn b">bar</code>。然而，如果我们配置一个数据存储，我们可以应用算法来获得基于碎片总数的碎片索引。因此，跳转一致性哈希在分片的上下文中很有用，但在负载平衡的上下文中却没有用。</p><h1 id="0c6c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是完美一致的哈希算法？</h1><p id="9400" class="pw-post-body-paragraph jy jz iq ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">现在我们已经有了一些一致散列的经验，让我们后退一步，看看什么是最完美的算法:</p><ul class=""><li id="5448" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">平均而言，只有1/n %的键会被重新映射，其中<em class="np"> n </em>是节点数。</li><li id="49ca" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">O( <em class="np"> n </em>)空间复杂度，其中<em class="np"> n </em>是节点的数量。</li><li id="fd27" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">每次节点插入/移除和每次关键字查找的时间复杂度为O(1)。</li><li id="ec3c" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">确保一个节点与另一个节点相比不会过载的最小标准偏差。</li><li id="9299" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">它允许将权重与节点相关联，以应对不同的节点大小。</li><li id="9393" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">它将允许任意节点名称(不按顺序编号)支持负载平衡和分片。</li></ul><p id="48b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可惜这个算法不存在。基于我们所看到的:</p><ul class=""><li id="6387" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">每次查找，Rendezvous具有线性时间复杂度。</li><li id="0591" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">环一致散列在没有虚拟节点概念的情况下具有较差的最小标准偏差。有了虚拟节点，is空间复杂度为O( <em class="np"> n*v </em>)，其中<em class="np"> n </em>为节点数，<em class="np"> v </em>为每个节点的虚拟节点数。</li><li id="f0d1" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">跳转一致散列不具有恒定的时间复杂度，并且不支持任意的节点名称。</li></ul><p id="6566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个话题仍然是开放的，最近有一些研究值得一看。比如2005年发布的<a class="ae mz" href="https://arxiv.org/pdf/1505.00062.pdf" rel="noopener ugc nofollow" target="_blank">多探针一致哈希</a>。它支持O(1)空间复杂度。然而，为了实现ε的标准偏差，每次查找需要O(1/ε)时间。例如，如果我们想要实现小于0.5%的标准偏差，则需要散列密钥大约20次。因此，我们可以得到一个最小的标准偏差，但需要付出更高的查找时间复杂度。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><a href="https://twitter.com/teivah"><div class="gh gi nx"><img src="../Images/b7ca1b7c5545bd67fdc0e70ee7ad06b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*KfZOEQxbsbjbmqZJBj9g2A.png"/></div></a></figure><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5ab63de55c546f6729358284c9bdd193.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*zVEY8Pbpg0ZHKL4VvlreDA.png"/></div></figure><p id="2231" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们在引言中所说，一致的散列算法成为主流。现在在MongoDB、Cassandra、Riak、Akka等无数系统中使用。无论是在平衡负载还是分发数据的环境中。然而，在计算机科学中，每个解决方案都有权衡。</p><p id="e856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说到权衡，如果你需要跟进，你可能想看看Damian gry ski<a class="nz oa ep" href="https://medium.com/u/3783299b75c8?source=post_page-----9a289769052e--------------------------------" rel="noopener" target="_blank">写的精彩帖子:</a></p><div class="ob oc gp gr od oe"><a href="https://medium.com/@dgryski/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">一致散列:算法权衡</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">喜欢这篇文章？给我买杯咖啡。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os jw oe"/></div></div></a></div><p id="3c54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他一些值得一看的资源:</p><div class="ob oc gp gr od oe"><a href="https://medium.com/i0exception/rendezvous-hashing-8c00e2fb58b0" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">会合散列法</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">在任何类型的有状态分布式系统中，将一个键映射到一组机器的问题都很常见。即使…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">使用新的一致性哈希算法改善负载平衡</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">在Vimeo的动态视频打包器中改进HAProxy负载平衡以获得更好的缓存局部性</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="ot l op oq or on os jw oe"/></div></div></a></div></div></div>    
</body>
</html>