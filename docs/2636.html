<html>
<head>
<title>React hooks useState and useReducer are equivalent in theoretical expressiveness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React钩子useState和useReducer在理论表达上是等价的</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-usestate-and-usereducer-are-equivalent-in-theoretical-expressiveness-a7d1c109770?source=collection_archive---------1-----------------------#2019-06-30">https://itnext.io/react-hooks-usestate-and-usereducer-are-equivalent-in-theoretical-expressiveness-a7d1c109770?source=collection_archive---------1-----------------------#2019-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7166" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你喜欢哪一个？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/845682981f3b59719bd0e0b7c7591de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NO4IN5qu9lfmUL8PxTrxJQ.jpeg"/></div></div></figure><h1 id="c967" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="a729" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mi mj mk ml b">useReducer</code>是一个强有力的钩子。已知<code class="fe mi mj mk ml b">useState</code>是用<code class="fe mi mj mk ml b">useReducer</code>实现的。</p><p id="ec0c" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">在React hooks <a class="ae mr" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> docs </a>中，这样注明:</p><blockquote class="ms mt mu"><p id="4cfb" class="lm ln mv lo b lp mm ju lr ls mn jx lu mw mo lx ly mx mp mb mc my mq mf mg mh im bi translated">当你有涉及多个子值的复杂状态逻辑或者下一个状态依赖于前一个状态时，useReducer通常比useState更好。useReducer还允许您优化触发深度更新的组件的性能，因为您可以向下传递分派而不是回调。</p></blockquote><p id="e822" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">很长一段时间，我误解了useReducer比useState更强大，并且有一些优化是useState无法实现的。</p><p id="7d88" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">事实证明，useState在表现力上和useReducder一样强大。这是因为使用状态允许<a class="ae mr" href="https://reactjs.org/docs/hooks-reference.html#functional-updates" rel="noopener ugc nofollow" target="_blank">功能更新</a>。即使深度更新，您也可以传递自定义回调。</p><p id="de11" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">因此，您是使用State还是useReducer只是您的偏好。当我在JSX使用<code class="fe mi mj mk ml b">dispatch</code>的时候，我会使用Reducer。在JSX之外进行逻辑分析对我来说似乎是干净的。</p><h1 id="0ab5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">例子</h1><p id="e274" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你创建了一个自定义钩子，无论你使用的是useState还是useReducer都只是一个内部实现的问题。让我们看一个例子。我们用两个钩子实现了一个简单的反例。对于这两种情况，钩子都返回动作回调，这对于在比较中隐藏实现细节很重要。</p><h2 id="077b" class="mz kv it bd kw na nb dn la nc nd dp le lv ne nf lg lz ng nh li md ni nj lk nk bi translated"><strong class="ak"> useReducer </strong></h2><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="dd2b" class="mz kv it ml b gy np nq l nr ns">const initialState = { count1: 0, count2: 0 };</span><span id="b9af" class="mz kv it ml b gy nt nq l nr ns">const reducer = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'setCount1':<br/>      if (state.count1 === action.value) return state; // to bail out<br/>      return { ...state, count1: action.value };<br/>    case 'setCount2':<br/>      if (state.count2 === action.value) return state; // to bail out<br/>      return { ...state, count2: action.value };<br/>    default:<br/>      throw new Error('unknown action type');<br/>  }<br/>};</span><span id="1ca2" class="mz kv it ml b gy nt nq l nr ns">const useCounter = () =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialState);<br/>  const setCount1 = useCallback(value =&gt; {<br/>    dispatch({ type: 'setCount1', value });<br/>  }, []);<br/>  const setCount2 = useCallback(value =&gt; {<br/>    dispatch({ type: 'setCount2', value });<br/>  }, []);<br/>  return { ...state, setCount1, setCount2 };<br/>};</span></pre><h2 id="0996" class="mz kv it bd kw na nb dn la nc nd dp le lv ne nf lg lz ng nh li md ni nj lk nk bi translated"><strong class="ak">使用状态</strong></h2><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="08b7" class="mz kv it ml b gy np nq l nr ns">const initialState = { count1: 0, count2: 0 };</span><span id="5e63" class="mz kv it ml b gy nt nq l nr ns">const useCounter = () =&gt; {<br/>  const [state, setState] = useState(initialState);<br/>  const setCount1 = useCallback(value =&gt; {<br/>    setState(prevState =&gt; {<br/>      if (prevState.count1 === value) return prevState; // to bail out<br/>      return { ...state, count1: value };<br/>    });<br/>  }, []);<br/>  const setCount2 = useCallback(value =&gt; {<br/>    setState(prevState =&gt; {<br/>      if (prevState.count2 === value) return prevState; // to bail out<br/>      return { ...state, count2: value };<br/>    });<br/>  }, []);<br/>  return { ...state, setCount1, setCount2 };<br/>};</span></pre><p id="9402" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">你觉得哪个舒服？</p><h1 id="833d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">奖金</h1><p id="e0ba" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果useState和useReducer一样强大，那么useReducer应该可以和userland中的useState一起实现。</p><pre class="kj kk kl km gt nl ml nm nn aw no bi"><span id="16dd" class="mz kv it ml b gy np nq l nr ns">const useReducer = (reducer, initialArg, init) =&gt; {<br/>  const [state, setState] = useState(<br/>    init ? () =&gt; init(initialArg) : initialArg,<br/>  );<br/>  const dispatch = useCallback(<br/>    action =&gt; setState(prev =&gt; reducer(prev, action)),<br/>    [reducer],<br/>  );<br/>  return useMemo(() =&gt; [state, dispatch], [state, dispatch]);<br/>};</span></pre><h1 id="1371" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最终注释</h1><p id="787d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我的大多数库都是用useReducer编写的，但是我可能会改变我的想法，在更合适的时候考虑使用useState。</p><p id="4a5c" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我确实改变了我的实验图书馆。这里的差异是<a class="ae mr" href="https://github.com/dai-shi/react-hooks-fetch/commit/b20ff29acab2ad2040a5bd6b547d39a43366a868" rel="noopener ugc nofollow" target="_blank"/>。</p><div class="nu nv gp gr nw nx"><a href="https://github.com/dai-shi/react-hooks-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">戴式/反应钩取</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">用于获取API的React自定义挂钩。通过在…上创建一个帐户，为dai-shi/react-hooks-fetch开发做出贡献</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><p id="b1ba" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">最后一点，至于单元测试，我确信分离的<code class="fe mi mj mk ml b">reducer</code>更容易测试。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="8d81" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><em class="mv">原载于2019年6月30日</em><a class="ae mr" href="https://blog.axlight.com/posts/react-hooks-usestate-and-usereducer-are-equivalent-in-theoretical-expressiveness/" rel="noopener ugc nofollow" target="_blank"><em class="mv">https://blog.axlight.com</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>