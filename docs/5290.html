<html>
<head>
<title>Redis as a Pub/Sub Engine in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis作为Go中的发布/订阅引擎</h1>
<blockquote>原文：<a href="https://itnext.io/redis-as-a-pub-sub-engine-in-go-10eb5e6699cc?source=collection_archive---------2-----------------------#2021-02-03">https://itnext.io/redis-as-a-pub-sub-engine-in-go-10eb5e6699cc?source=collection_archive---------2-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2032" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在多个应用程序之间共享信息和工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9e34931b5c435f0b53105658ea4d24b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*GIn5-wiZ-UHuAECSWn0lyg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">发布/订阅架构的示例</figcaption></figure><h2 id="7cb2" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">什么是Redis</h2><p id="8858" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">Redis是一个<strong class="ls iu">内存</strong>数据库，这意味着它将数据直接存储在内存中，而不是保存在磁盘上。这是使用Redis时需要记住的一个重要因素。如果运行Redis的系统断电，存储在内存中的数据将会丢失。<strong class="ls iu"> Redis通过</strong>通过快照保存数据，因此只有自上次快照以来的新数据会丢失。这就是为什么很多人经常说应该利用Redis作为存储数据的缓存。尽管Redis有一些持久化机制，所以并不是所有的数据都丢失了，在这里<a class="ae mj" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank">阅读更多信息</a>。</p><blockquote class="mk"><p id="7579" class="ml mm it bd mn mo mp mq mr ms mt mi dk translated">Redis是一个开源的(BSD许可的)、内存中的数据结构存储，用作数据库、缓存和消息代理。Redis网站</p></blockquote><p id="4ad1" class="pw-post-body-paragraph lq lr it ls b lt mu ju lv lw mv jx ly ld mw ma mb lh mx md me ll my mg mh mi im bi translated">Redis是一个键值存储。这意味着我们可以通过指定一个键和包含什么值来存储数据。实际上，密钥可以是任何二进制blob，所以即使是密钥也可以非常高级。</p><p id="9b61" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">Redis还支持发布/订阅架构。这意味着我们可以使用Redis发布数据和订阅数据。如果你以前没有使用过Pub/Sub，它通常用于在应用程序之间共享数据。我在我的一个项目中使用它在某些应用程序之间分配工作。<br/>值得一提的是，在某个频道/主题上发布的任何消息都会被发送给<strong class="ls iu">每个订阅者。</strong>还有，用Pub/Sub发送的消息，一发布就会被遗忘。如果你想使用Redis作为一个工作队列，不要把目标放在Pub/Sub上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9e34931b5c435f0b53105658ea4d24b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*GIn5-wiZ-UHuAECSWn0lyg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">多个发布者发布新用户的发布/订阅架构</figcaption></figure><p id="e52c" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">那么，我们为什么需要内存缓存呢？速度是一回事。因为在SQL等中保存数据没有任何大的延迟，而且内存往往非常快。</p><p id="dd84" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">在上面的图片中，我们看到了一个例子，来自多个网站的用户帐户存储在一个中央数据库中。新用户应该收到电子邮件，这是用来减少重复代码和应用程序运行的数量。这是一个如何使用Redis作为发布/订阅引擎或工作分发器的例子。</p><p id="6c5e" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">更好的是，想象一个中央日志记录应用程序，它从Redis中获取错误，并将其记录在中央存储中。这样，许多应用程序可以直接在Redis中抛出错误，而不必担心每个应用程序中的可靠日志逻辑。</p><p id="3658" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">它还可以帮助扩展应用程序，我见过的一个很酷的场景是工作分发平台。它由许多微服务组成，每当一个微服务需要另一个服务完成工作时，它们会将自己的工作推到Redis中的一个工作队列中。很酷的一点是，当开发人员注意到一个服务滞后时，他们可以很容易地添加一个具有同类服务的服务器，从同一个队列中读取工作。这使得他们可以在不停止或改变任何其他服务的情况下添加员工。</p><p id="2c52" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">我遇到的一些人会说这样的话，</p><blockquote class="ne nf ng"><p id="1beb" class="lq lr nh ls b lt mz ju lv lw na jx ly ni nb ma mb nj nc md me nk nd mg mh mi im bi translated">如果我想要内存缓存，我使用map[string]接口{}</p></blockquote><p id="1b20" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">这很好。但是Redis不仅给你一个非常可扩展的缓存，它还帮助你持久化它，排序它，分类它，以及许多许多内置的东西。它也是网络连接的，因此比使用常规地图更容易缩放。</p><h2 id="0056" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">安装依赖项</h2><p id="efa5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">首先，我们将使用<strong class="ls iu"> Docker来运行Redis </strong>。<br/>安装docker如果没有得到<a class="ae mj" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">的说明，这里</a>。如果你对Docker不熟悉，可以在<a class="ae mj" rel="noopener ugc nofollow" target="_blank" href="/docker-skyrocketed-my-teams-productivity-e19cd89a23ea?sk=4dbf55e89ab3899d147c67d96b3ec6f9">我的另一篇文章</a>中了解一下。</p><p id="25fc" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">如果你在离线环境中，你需要下载Redis镜像，我们将使用<a class="ae mj" href="https://hub.docker.com/_/redis/" rel="noopener ugc nofollow" target="_blank">这个</a>。如果你连上了互联网，就不需要拿任何东西。Docker会自动为我们提取图像。</p><p id="2fe3" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">我们还在构建一个Go应用程序来与Redis对话。如果你没有Go，不要担心安装它，我们也将使用Docker。但是你真的应该安装go……它太棒了！</p><h2 id="9469" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">设置docker编写</h2><p id="6342" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们将首先创建一个docker-compose文件，该文件将包含一个Redis和两个Go应用程序的项目架构。<br/>我还想说<strong class="ls iu">对不起，设置步骤相当长，</strong>比我想的要长。但是如果docker上有新人的话，我不想急着设置作曲。如果你想作弊，并且对docker感到舒适，<a class="ae mj" href="https://github.com/percybolmer/redisInGo" rel="noopener ugc nofollow" target="_blank">这里是资源库</a>。</p><p id="279c" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">Redis将被用作发布/订阅引擎，一个go应用程序将发布数据，而另一个应用程序将订阅数据。</p><p id="2bf7" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">我们将首先添加Redis，开始构建docker-compose的基础。我们还需要创建一些Redis希望我们挂载的文件夹。我们将挂载一个名为redis/data的文件夹来保存数据，redis将在这里存储内存快照。我们还会有redis/conf，我们将有一个redis.conf文件，其中包含所需的配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/fb6eeb9d674e2eac418e7f7a0aec12c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*7xWpV9PRZuo95YY4WfvnDw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">当前项目设置</figcaption></figure><p id="255f" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">创建文件夹，然后创建docker-compose.yaml。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fb77" class="ku kv it nn b gy nr ns l nt nu">mkdir -p redisInGo/redis/conf<br/>mkdir redisInGo/redis/data<br/>touch docker-compose.yaml</span></pre><p id="e63e" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">Redis配置可以从Redis网站<a class="ae mj" href="https://download.redis.io/redis-stable/redis.conf" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Docker-compose只运行Redis。</figcaption></figure><p id="88a2" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">当前的docker-compose只会启动Redis。但是我们将在此基础上继续努力，并在前进的过程中添加更多的内容。我们需要做的第一件事是打开<strong class="ls iu"> redis.conf </strong>并设置redis的密码。</p><p id="5bb5" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">在配置中搜索<strong class="ls iu"> requirepass </strong>，用你的密钥替换密码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/64c327180b6c74e2732c4f1e824bc027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*ISL2YttmR53Pg2-TK77jmA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">我的Redis配置使用密码。</figcaption></figure><p id="0afe" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">此外，搜索绑定IP地址的绑定配置，这通常是localhost (127.0.0.1)。在我们的例子中，我们将在一个容器环境中运行，所以将bind改为“redis”。这就是我们将给予Redis容器的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/0d26814960b0865a62a272a4802d6f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*W6oR6NtvMmitCdqAo0Rp4w.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">将bind命令更改为redis，即合成中容器的名称</figcaption></figure><p id="01bc" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">保存文件并尝试运行docker-compose以确保一切正常。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="ee8a" class="ku kv it nn b gy nr ns l nt nu">sudo docker-compose up</span></pre><p id="1f3e" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">您应该会看到一个类似于<strong class="ls iu"> Redis *准备好接受连接的输出。</strong></p><p id="2e89" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">一旦完成，就该开始处理发布者和订阅者应用程序了。<br/>我们将从向docker-compose添加所需的内核开始，只是为了让一切正常运行。一旦布局完成，我们将开始使用Redis。</p><p id="fe87" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">创建一个名为publisher的文件夹和一个名为subscriber的文件夹。这两个文件夹都应该包含两个文件，<strong class="ls iu"> main.go和dockerfile。</strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="322f" class="ku kv it nn b gy nr ns l nt nu">mkdir publisher &amp;&amp; mkdir subscriber</span></pre><p id="5b00" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">我将显示驻留在发布者中的代码，我希望您将该代码复制到发布者和订阅者中，但是用<strong class="ls iu">替换订阅者文件夹</strong>中出现的每个发布者。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">打招呼的小应用。</figcaption></figure><p id="2b8b" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">docker文件也是如此，用subscriber替换publisher，并在每个文件夹中都有一个副本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">构建我们的应用程序的docker文件</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/01b836217b046dc3a47f3a8a137c4180.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*LfimB2xauIU3Vbqu5ulPMg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">这是我当前项目设置的样子</figcaption></figure><p id="e44b" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">我们希望将这两个新应用程序添加到docker-compose中，然后我们就可以开始使用Redis了。我已经更新了docker-compose来构建和运行这两个应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">运行整个项目设置的完整docker-compose。</figcaption></figure><p id="b519" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">关闭旧的compose，打开新的compose，您应该会看到所有三个应用程序的输出。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="66ab" class="ku kv it nn b gy nr ns l nt nu">sudo docker-compose down &amp;&amp; sudo docker-compose up --build <br/># I use the --build flag to force build the images</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/506532a1e030ea922145911d8226d3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aSGyGT_elIMY4HtBbQItw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">验证设置工作正常的输出。</figcaption></figure><h2 id="4688" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">最后，Redis时间</h2><p id="7a79" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">所以，祝贺你通过了漫长的准备阶段。但是现在我们有了一个坚实的开发环境。时间花得值。</p><p id="d1d0" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">让我们从使用Redis作为发布者开始。我们将希望连接到Redis并发布数据。我们将构建的应用程序将是一个用户注册应用程序或类似的应用程序。它将随机生成新用户，并将其发布到一个主题/频道上。另一个应用程序将订阅新用户，并将他们记录到stdout。</p><p id="d6a7" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">不是最好的例子，它不会进入你的超级酷软件工具箱。但是它可以作为实际应用的起点。请记住，我们想要关注Redis如何像发布/订阅引擎一样工作。</p><p id="15bc" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">让我们从查看Redis客户机的发布方法开始</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f26a" class="ku kv it nn b gy nr ns l nt nu">func (c Client) Publish(ctx <a class="ae mj" href="https://godoc.org/context" rel="noopener ugc nofollow" target="_blank">context</a>.<a class="ae mj" href="https://godoc.org/context#Context" rel="noopener ugc nofollow" target="_blank">Context</a>, channel <a class="ae mj" href="https://godoc.org/builtin#string" rel="noopener ugc nofollow" target="_blank">string</a>, message interface{}) *<a class="ae mj" href="https://godoc.org/github.com/go-redis/redis#IntCmd" rel="noopener ugc nofollow" target="_blank">IntCmd</a></span></pre><p id="c756" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">它需要上下文、通道和消息。频道是发布消息的主题名称。该消息是一个空接口，因此它可以是任何类型的数据。重要的是，我们使用的go-redis包希望这个消息成为<strong class="ls iu">编码的一部分。BinaryMarshaler </strong>接口。这是因为它需要能够以[]字节的形式传输数据。</p><p id="bbee" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">发布者将由一个可以编码成[]字节的<strong class="ls iu">用户</strong>结构组成。应用程序将启动并连接到Redis，然后开始生成随机用户并发布他们。我已经尽可能多地对代码进行了注释。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">publisher应用程序的完整代码。</figcaption></figure><p id="a23a" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">接下来，我们需要查看正在发送的内容。为此，我们将修改subscriber/main.go. <br/>这将是一个非常简单的应用程序，很像出版商。它将连接到Redis，订阅该频道，并打印在其上找到的任何项目。<br/>它将包含相同的用户结构，在一个真实的例子中，我将把它分解到在两个应用程序中导入的包中。但是对于这个简短的演示来说，复制粘贴是有效的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">打印任何新用户的订户的完整代码</figcaption></figure><p id="9b22" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">如果您在填写发布者和订阅者之后运行docker-compose，您应该会看到如下图所示的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi of"><img src="../Images/925a82692975e5565dd5df5d0018f365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JG62_hh4QyUud3VfY_DqQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">订阅者的输出。</figcaption></figure><p id="5b7e" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">太好了！我们现在有两个(3个带Redis的)应用程序在一个发布/订阅中一起工作。如你所见，go-redis很容易使用。只需要两种方法就可以让它启动并运行(发布和订阅)。</p><p id="46f8" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">您可以尝试自己添加另一个publisher，这只是复制docker-compose中的publisher服务并对其进行重命名。</p><p id="895f" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">使用Redis，您可以做更多的事情，例如将工作推送到由许多工作人员聚集的通道。本文只是展示了如何在Go环境中启动和运行Pub/Sub。你能做的深度是巨大的。</p><p id="5394" class="pw-post-body-paragraph lq lr it ls b lt mz ju lv lw na jx ly ld nb ma mb lh nc md me ll nd mg mh mi im bi translated">今天到此为止。<br/> <strong class="ls iu">现在，去那里和Pub/Sub！</strong></p><div class="og oh gp gr oi oj"><a href="https://percybolmer.medium.com/membership" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">阅读珀西·博尔默(以及媒体上成千上万的其他作家)的每一个故事</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">percybolmer.medium.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ko oj"/></div></div></a></div></div></div>    
</body>
</html>