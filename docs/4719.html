<html>
<head>
<title>Logging Script Output with DbUp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DbUp记录脚本输出</h1>
<blockquote>原文：<a href="https://itnext.io/logging-script-output-with-dbup-4edba367c313?source=collection_archive---------3-----------------------#2020-08-31">https://itnext.io/logging-script-output-with-dbup-4edba367c313?source=collection_archive---------3-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在今天的帖子中，我们将讨论如何在DbUp运行期间记录脚本输出。如果你是第一次接触这个系列的文章或者DbUp，你可能会发现下面的文章很有帮助。</p><p id="ff6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://elanderson.net/2020/08/database-migrations-with-dbup/" rel="noopener ugc nofollow" target="_blank">使用DbUp进行数据库迁移</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/08/code-based-database-migrations-with-dbup/" rel="noopener ugc nofollow" target="_blank">使用DbUp进行基于代码的数据库迁移</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/08/always-run-migrations-with-dbup/" rel="noopener ugc nofollow" target="_blank">始终使用DbUp进行迁移</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/557dcb46b7968b5c3440d106e7cc896d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JaG00A7X9ZPZSSAO.jpg"/></div></div></figure><h2 id="c6c3" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">启用脚本输出日志记录</h2><p id="75be" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我将使用我们上周末讨论过的始终运行的迁移来简化测试，但是概念对于普通的迁移是相同的。启用脚本输出日志记录的更改是添加到我们的升级程序设置中的一行，您可以在下面的代码中看到突出显示的行。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="140b" class="ky kz iq lx b gy mb mc l md me">var alwaysRunUpgrader =<br/>    DeployChanges.To<br/>                 .SqlDatabase(connectionString)<br/>                 .WithScriptsAndCodeEmbeddedInAssembly(Assembly.GetExecutingAssembly(), <br/>                                                       f =&gt; f.Contains(".AlwaysRun."))<br/>                 .JournalTo(new NullJournal())<br/>                 .LogToConsole()<br/>                 .LogScriptOutput()<br/>                 .Build();</span></pre><p id="e25c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行该应用程序将会产生如下结果。注意受影响的记录行，这是我们迁移的输出。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="f3a6" class="ky kz iq lx b gy mb mc l md me">Beginning database upgrade<br/>Checking whether journal table exists..<br/>Fetching list of already executed scripts.<br/>No new scripts need to be executed - completing.<br/>Beginning database upgrade<br/>Executing Database Server script 'DbupTest.Scripts.AlwaysRun.Everytime.sql'<br/>RecordsAffected: 0<br/><br/>Upgrade successful<br/>Success!</span></pre><h2 id="564e" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">提高脚本输出</h2><p id="207a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">因此，以上对于只有一条语句的简单迁移来说非常好，但是对于更复杂的迁移，使用<strong class="jp ir"> PRINT </strong>语句来提供更多信息可能会有所帮助。让我们调整我们的脚本来打印执行的开始和结束时间。以下是示例脚本(是的，我知道它实际上永远不会更新任何东西)。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="920c" class="ky kz iq lx b gy mb mc l md me">PRINT CONVERT(VarChar, GETDATE(), 121)  + ' Start every time';<br/><br/>UPDATE Application.Cities SET CityName = 'Nothing' WHERE 1 = 0;<br/><br/>PRINT CONVERT(VarChar, GETDATE(), 121)  +  + ' End every time';</span></pre><p id="39b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述迁移会产生以下输出。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="35ad" class="ky kz iq lx b gy mb mc l md me">Beginning database upgrade<br/>Checking whether journal table exists..<br/>Fetching list of already executed scripts.<br/>No new scripts need to be executed - completing.<br/>Beginning database upgrade<br/>Executing Database Server script 'DbupTest.Scripts.AlwaysRun.Everytime.sql'<br/>2020-08-05 06:15:21.877 Start every time<br/><br/>2020-08-05 06:15:21.877 End every time<br/><br/>RecordsAffected: 0<br/><br/>Upgrade successful<br/>Success!</span></pre><p id="0db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打印是有帮助的，但是在这种情况下，受影响的记录是干扰，特别是因为它是受最后一条语句影响的记录，并且确实按照SQL语句打印。为了抑制受消息影响的记录，我们在脚本中使用<strong class="jp ir"> SET NOCOUNT ON </strong>，如下所示。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="d1e2" class="ky kz iq lx b gy mb mc l md me">SET NOCOUNT ON;<br/><br/>PRINT CONVERT(VarChar, GETDATE(), 121)  + ' Start every time with NoCount ON';<br/><br/>UPDATE Application.Cities SET CityName = 'Nothing' WHERE 1 = 0;<br/><br/>PRINT CONVERT(VarChar, GETDATE(), 121)  +  + ' End every time with NoCount ON';<br/><br/>SET NOCOUNT OFF;</span></pre><p id="d445" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在下面看到的，我们得到了更清晰的输出。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="8cf8" class="ky kz iq lx b gy mb mc l md me">Beginning database upgrade<br/>Checking whether journal table exists..<br/>Fetching list of already executed scripts.<br/>No new scripts need to be executed - completing.<br/>Beginning database upgrade<br/>Executing Database Server script 'DbupTest.Scripts.AlwaysRun.Everytime.sql'<br/>2020-08-05 06:38:18.863 Start every time<br/><br/>2020-08-05 06:38:18.863 End every time<br/><br/>Upgrade successful<br/>Success!</span></pre><h2 id="718a" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">包扎</h2><p id="9e7f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">记录脚本的输出有时真的很有帮助，但是如果你要像我们上面看到的那样使用它，确保和计划输出是什么样子是很重要的。有500个受影响的记录实例并不一定有帮助。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="3658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mm">最初发表于</em> <a class="ae kl" href="https://elanderson.net/2020/08/logging-script-output-with-dbup/" rel="noopener ugc nofollow" target="_blank"> <em class="mm">埃里克·安德森</em> </a> <em class="mm">。</em></p></div></div>    
</body>
</html>