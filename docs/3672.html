<html>
<head>
<title>Designing the Shortening URL system like Bit.ly, loading 6 billion clicks a month</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像Bit.ly一样设计缩短网址系统，一个月加载60亿次点击</h1>
<blockquote>原文：<a href="https://itnext.io/designing-the-shortening-url-system-like-bit-ly-loading-6-billion-clicks-a-month-78b3e48eee8c?source=collection_archive---------2-----------------------#2020-01-28">https://itnext.io/designing-the-shortening-url-system-like-bit-ly-loading-6-billion-clicks-a-month-78b3e48eee8c?source=collection_archive---------2-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b58adc20d71b2978fc252e1bb2eab2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*xBbxi0U2SD40anxuO4s3Fw.jpeg"/></div></figure><p id="9277" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们肯定都用过一些URL缩短服务(缩短链接),比如Bitly或TinyURL。</p><p id="edf7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于工程师来说，使用是一回事，但如何设计一个每月加载数十亿次点击的系统肯定也是许多人感兴趣的。</p><p id="d24c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">今天我写这篇文章是为了深入挖掘这些系统，看看它们是如何设计的。</p><p id="3c1f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本条的目的:</p><ul class=""><li id="6a5c" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">给你一个如何设计百万用户，每月数十亿次点击的系统的概述。从思考到解决问题。</li><li id="6ef7" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">可以像Bitly，TinyURL一样自己搭建一个URL缩短系统。</li><li id="c137" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">帮你积累系统设计职位面试的经验。</li></ul><h1 id="16dc" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">什么是网址缩短系统？</h1><p id="4d74" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">当然，有一些人从来没有使用过链接缩短服务。所以让我简单解释一下什么是网址缩短。</p><p id="fe58" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">URL缩短是一项我们可以缩短原始链接的服务。</p><p id="395b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">比如我们的原文链接是:<a class="ae mm" href="https://medium.com/jp-tech/docker-image-in-production-1gb-or-100mb-a455ed5eb461?source=your_stories_page--------- - - - - - - - - -" rel="noopener">https://medium . com/jp-tech/docker-image-in-production-1gb-or-100 MB-a 455 ed 5 EB 461？source = your _ stories _ page-————</a></p><p id="de67" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用缩短后的链接后，会变成这样:【shorturl.at/bvzO3<a class="ae mm" href="http://shorturl.at/bvzO3" rel="noopener ugc nofollow" target="_blank">T3】</a></p><p id="b1b5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，如果我们在浏览器中打开shorturl.at/bvzO3的<a class="ae mm" href="http://shorturl.at/bvzO3" rel="noopener ugc nofollow" target="_blank">链接，它会重定向到原来的链接。</a></p><h1 id="956e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">为什么我们需要缩短链接？</h1><p id="528e" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">这大概是很多人关心的问题。比如只需要把原链接发给查看者，而不需要缩短链接那么费时间？而现在，有人要再手动输入链接吗？…</p><p id="ff1c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">问那些问题并没有错。</p><p id="2f01" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">使用缩短链接的主要目的是:</strong></p><ul class=""><li id="5843" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">看短链接更好看。</li><li id="882e" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">可以统计点击链接的人数，分析评估结果。用于营销。</li><li id="58c3" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">可以隐藏一些以赚钱为目的的联盟营销链接。</li></ul><h1 id="6c9a" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">系统功能需求</h1><p id="e461" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">大多数链节缩短系统必须满足以下要求:</p><p id="0f09" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">功能需求:</strong></p><ul class=""><li id="e209" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">输入的是一个原始链接，系统会将原始链接缩短成一个更短且唯一的链接格式</li><li id="fb6b" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">当用户访问缩短的链接时，系统会将其重定向到原始链接</li><li id="e4cd" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">用户可以随意选择定制自己的缩短链接。</li><li id="4448" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">缩短的链接将在一定的默认时间后过期。但是，用户可以调整这个时间段。</li></ul><p id="3f35" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">非功能性需求:</strong></p><ul class=""><li id="24c8" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">高可用性系统。我们为什么需要这个？因为如果系统死了，那么到时候所有缩短的链接都会死。</li><li id="af62" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">当点击缩短的链接以切换到原始链接时，重定向时间必须是最小的(最小延迟)。</li><li id="d186" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">缩短的链接是无法猜测的。</li></ul><p id="b6ff" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">扩展请求:</strong></p><ul class=""><li id="22cc" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">我可以分析点击一个缩短的链接多少次？</li><li id="9ceb" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">提供第三方可以使用的API。</li></ul><h1 id="9920" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">系统分析</h1><p id="be7b" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">在这一节中，我将向您展示如何估计每月请求的数量、磁盘空间、内存使用、网络带宽消耗…</p><p id="d59e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大多数链路缩短系统将具有相当高的访问量。</p><p id="7814" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设我们设计的系统的读写比为100: 1。(记住这个比率，因为它在整篇文章中都被使用。)</p><ul class=""><li id="89be" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">这里的阅读率是点击缩短链接的人数</li><li id="815a" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">写比率是创建缩短链接的人数。</li></ul><h1 id="dd35" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">交通量估计</h1><p id="c54e" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">假设我们的系统一个月有5亿个缩短的链接。</p><p id="860c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用一个<strong class="jz iu">读:写</strong>比是<strong class="jz iu"> 100:1 </strong>那么读的数量将是:500M * 100 = 50B (M是百万，B是十亿)</p><p id="1a45" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">1秒钟写多少？</p><p id="78e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">500米/ (30天* 24小时* 3600秒)= 200 URL /秒</p><p id="5a86" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">1秒钟阅读的次数是多少？</p><p id="fd01" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">200 * 100 = 20K URL /秒(因为读写比为100: 1)</p><h1 id="ff4d" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">存储估计</strong></h1><p id="eb3e" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">假设我们要将所有缩短的链接保存5年。因为我们在1个月内缩短了5亿个链接，所以5年后我们将拥有:</p><p id="49d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">5亿* 12个月* 5年= 300万个网址</p><p id="6eaa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设每个缩短的链接，我们将使用500字节来保存它在存储器中。5年内节省的5亿个URL的驱动器空间将为:</p><p id="24cb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">30B * 500字节= 15TB</p><h1 id="301e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">带宽估计(网络带宽)</h1><p id="4c8b" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">首先，我来解释一下什么是带宽(网络带宽)<br/>网络带宽是一个术语，表示1秒钟内的数据传输量(数据大小)。</p><p id="4841" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">其中数据传输会包括两种类型的传入数据与传出数据:传入数据是传输到服务器的数据量(与上传类型相同)，传出数据是从服务器返回给用户的数据量(像下载)。因为我们的系统在1秒钟内有200个新的URL，那么:</p><p id="a3c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">总传入数据= 200 * 500字节= 100 KB /秒</p><p id="5f0a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于读取请求，我们的系统有20K URL / s，那么:</p><p id="265f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">总传出数据= 20K * 500字节= 10MB /秒</p><h1 id="5ef5" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">记忆估计</h1><p id="5f64" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">为了让系统运行得更快，最好的解决方案是缓存很多用户点击的短链接。那么我们需要多少内存呢？</p><p id="2090" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们遵循80:20规则，20%的缩短链路会产生80%的系统流量。(简单来说，只有20%的缩短链接是供很多用户访问的，其余80%根本没有访问权限。因此，20%的缩短链接会产生80%的流量。)</p><p id="a62e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为我们总共有20K个URLs秒(或20K个请求/秒)，所以1天将有:</p><p id="f20e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">20K * 3600秒* 24小时= 1.7亿次请求/天</p><p id="9d59" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要缓存20%的请求，我们需要:</p><p id="facd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">0.2 * 1.7 * 500字节= 170GB内存</p><h1 id="81c0" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">系统规模汇总</h1><p id="832c" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我们的系统一个月有5亿个网址，读写比为100:1。那么我们的系统规格将如下:</p><ul class=""><li id="0331" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">每秒生成200个URL</li><li id="9132" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">访问数量:20K请求/秒</li><li id="cfc5" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">传入数据(与上传相同):100KB / s</li><li id="8975" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">传出数据(与下载相同):10MB / s</li><li id="b42f" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">5年后的驱动器容量:15TB</li><li id="7c2b" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">高速缓存的内存容量:170GB</li></ul><h1 id="c4d2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">API设计</h1><p id="522d" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我们可以使用SOAP或REST APIs来设计系统API。通过以上需求，我们看到我们的系统至少需要以下两个API:</p><p id="a650" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，我们需要一个API来创建一个缩短的链接:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="fcc8" class="mw lk it ms b gy mx my l mz na">createURL(api_dev_key,<br/>          original_url,<br/>          custom_alias=None,<br/>          expire_date=None)</span></pre><ul class=""><li id="1cd3" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">api_dev_key (string):是注册用户帐户的api开发者密钥。这个键用于识别用户，限制用户请求的数量(也称为速率限制)original_url (string):原始链接</li><li id="b9ee" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">custom _ alias(string-可选):自定义URL的关键字</li><li id="87f1" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">expire_date(字符串-可选):缩短链接的到期日期</li></ul><p id="7695" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">返回值(字符串):</p><ul class=""><li id="0100" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">如果成功，它将插入数据库，并返回缩短的链接</li><li id="05f4" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">如果失败，返回一个错误代码。</li></ul><p id="298f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">删除网址</strong></p><p id="840a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">第二个API也很有必要删除注册的缩短链接。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="3f83" class="mw lk it ms b gy mx my l mz na">deleteURL(api_dev_key, url_key)</span></pre><ul class=""><li id="2c53" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">api_dev_key (string)是注册用户帐户的api开发者密钥</li><li id="f190" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">url_key (string):是一个缩短的链接。</li></ul><p id="1157" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">返回值(字符串):</p><ul class=""><li id="d57b" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">如果成功，缩短的链接将被删除。</li><li id="e68e" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">如果失败，它将返回一个错误代码。</li></ul><h1 id="b974" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">如何防范黑客？</h1><p id="3f05" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">黑客可以使用api创建许多超过当前系统设计的缩短链接。为了让我们的系统安息。</p><p id="e743" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，我们当前的系统正在设计一个对每月生成的5亿个URL的响应。</p><p id="16d4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">黑客攻击将创建100倍于目前的大约50万亿个URL，因此系统将消耗更多的资源，使用更多的内存，消耗更多的驱动器。那么系统肯定会崩溃。并且整个缩短的链接将被解散。</p><p id="a475" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么如何解决这个问题呢？最简单的方法是通过api_dev_key限制api调用的数量(这种技术被称为Grab正在使用的速率限制)。例如，每个api_dev_key在1天内只会创建大约100个缩短的链接。</p><p id="8629" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不是100%完美的方式，但也限制了一些问题。</p><h1 id="ac97" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">数据库设计</h1><p id="5d66" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated"><strong class="jz iu">我们的数据库要求如下:</strong></p><ul class=""><li id="ee21" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">数十亿条记录需要保存</li><li id="8df8" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">每个1对象将尽可能小地保存(范围小于1KB)</li><li id="5946" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">记录之间不需要数据关系。</li><li id="5c30" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">该系统具有高读取速率</li></ul><p id="bc22" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">数据库模式:<br/> </strong>我们将需要2个主表:1个存储用户信息，1个存储URL信息。</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/4d70385883e15f37bc108e9b75b9a912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nm0a2zsD6GUUIzpXsu1EqA.png"/></div></div></figure><p id="d784" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">应该使用什么样的数据库？<br/> </strong>因为我们预计要保存数十亿条记录，而且，表之间没有关系，所以使用NoSQL键值可能是最好的选择。比如DynamoDB和Cassandra我觉得还可以。</p><h1 id="57bd" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">算法和基本系统设计</h1><p id="0561" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">这里要解决的问题是如何创建一个缩短的链接，而且只能从原始链接创建。</p><p id="df6e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在第一部分中，我举了一个缩短链接的例子:<a class="ae mm" href="http://shorturl.at/bvzO3" rel="noopener ugc nofollow" target="_blank">shorturl.at/bvzO3</a></p><p id="2f61" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后这部分我们就去设计创造缩短的部分，就是<em class="ng"> bvzO3 </em>。</p><h1 id="3e9e" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">编码URL</h1><p id="7f9d" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我们可以使用一些散列函数(如MD5或SHA256)来散列URL输入值。然后会用一些编码函数来显示。例如，base36 ([a-z，0–9])，或base62 ([a-z，a-z，0–9])和base64 ([a-z，A-A，0–9，-，)。]).</p><p id="f8bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">问题是，我们用什么密钥长度？6.8还是10？</p><p id="1e86" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果base64用于6个字符，那么我们有64个^ 6 = 68.7 b URL<br/>如果base64用于8个字符，那么我们有64个^ 8 = 281万亿URL</p><p id="d24a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为我们的系统每月生成5亿个URL，所以该系统在5年内将总共有:</p><p id="c085" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">500万* 12个月* 5 = 300万个网址/ 5年。</p><p id="90e5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，68.7亿个网址(6个字符)可以使用5年。</p><p id="1bcf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们使用MD5算法作为散列函数，那么它将生成包含128位的散列值。然后base64编码哈希值，它将生成至少21个字符(因为每个base64字符将编码6位哈希值)。</p><p id="6310" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同时，我们的密钥空间只需要6个字符。那么如何选择一把钥匙呢？我们可以选择前6个字符。虽然也有重叠的情况。但是概率只有1 / (64 ^ 6)左右。它非常小。应该可以接受。</p><p id="0895" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果它是安全的，我们每次生成它时，都会在数据库中检查它是否安全。如果不是，那么ok，如果是，那么在URL前添加任意随机字符串，重复直到生成唯一的字符串。</p><p id="79fd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="27d5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">我们的解决方案有什么问题？</strong></p><ul class=""><li id="cf18" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">许多用户可以共享相同的原始链接，因此缩短的链接将被复制。这是不可接受的。</li><li id="3db4" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">如果URL中的某些内容被编码了怎么办？例如，<a class="ae mm" href="http://example.com/index.php?id=design" rel="noopener ugc nofollow" target="_blank">http://example.com/index.php?id=design</a>和<a class="ae mm" href="http://example.com/index.php%3Fid%3Ddesign" rel="noopener ugc nofollow" target="_blank">http://example.com/index.php%3Fid%3Ddesign</a>是两个完全相同的URL，但是URL的一部分已经被编码。</li></ul><p id="90a9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">解决方案<br/> </strong>有两种方法可以解决这个问题。</p><ul class=""><li id="eccb" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">我们可以使用一个增量整数并附加到每个根链接的开头。然后它会一直确保我们的原始链接是唯一的，即使有很多人填写单个链接，缩短的链接也会一直不一样。并且在创建了缩短的链接之后，这个整数将增加1。但有一个问题是，如果数字永远增加，这个整数就会溢出。此外，这种增量处理也会影响系统的性能。</li><li id="625e" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">或者，我们可以将user_id添加到每个URL的开头。然而，如果用户没有登录，并希望创建一个缩短的链接，那么我们必须要求另一个密钥。并且这个键必须是唯一的(如果唯一的非唯一输入键需要重新输入，直到唯一)。</li></ul><p id="656d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是系统的流程:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nj"><img src="../Images/74632f86ce30b4f896c5bbe62fb5dc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYHwFI0DLrkZ60l0KlbTLg.jpeg"/></div></div></figure><p id="ee07" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，输入要缩短的链接，然后按enter键。然后，请求将被发送到服务器。</p><p id="6fc8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">服务器将接收请求，并将其传送到缩短链接的专用部分。让我们称之为编码服务。</p><p id="5ce0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">编码服务将执行短URL处理:</p><ul class=""><li id="345d" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">如果URL在系统中尚不存在，它会将缩短的链接保存到数据库中，并将结果返回给服务器。</li><li id="622c" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">如果该网址已经存在于系统中(即有人已经使用了这个网址)。然后，它会在URL的开头添加一个序列(增量整数),并执行缩短链接。然后将缩短的链接保存到数据库，并将结果返回给服务器。</li></ul><p id="6bd5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">服务器接收结果并返回给用户。</p><h1 id="86e2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">数据分区和复制</h1><p id="259e" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">如果我们在数据库中存储所有300亿个URL，并且在数据库中有高达20K个请求/秒的调用。那么数据库可能会负载过大，导致停机。要解决这个问题，有两种解决方案:</p><ul class=""><li id="4764" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">对数据库中的数据进行分区(数据分区)。这意味着我们将把数据库分成许多不同的数据库。每个孩子将包含1条数据。</li><li id="52f6" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">缓存URL或调用以最小化对数据库的查询(我将在下一节解释这一点)</li></ul><p id="1534" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于数据分区，有两种类型:</p><p id="e806" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">基于范围的分区<br/> </strong>这种类型的分区将依靠URL中的第一个字母或散列键来划分数据。</p><p id="ab54" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，以单词“a”开头的URL(跳过https: //或http: //)将在DB类型“a”中。任何以字母“b”开头的URL都将进入数据库“b”。如果分区是基于第一个字母，我们将需要26个不同的数据库(从a -&gt; z)</p><p id="447d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但这种解决方案可能会有问题，假设我们把所有以字母“f”开头的URL放入“f”类型的数据库中。但不幸的是，所有以字母“f”开头的网址都是访问量最大的。在当时，这种类型的“f”DB是相当大的负载。</p><p id="94b7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意:这种基于首字母的分区只是一个例子，您可以设计自己的算法来正确有效地对数据进行分区。没有必要选择第一个字母来划分。</p><p id="66d2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">基于散列的分区<br/> </strong>在这种类型中，我们将获得被存储对象的散列值。然后，它将根据哈希函数计算将使用哪个分区。我们可以采用主键或根链接的哈希值来确定哪个分区将存储数据。</p><h1 id="c491" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">隐藏物</h1><p id="d21c" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">对于一个月几十亿次点击的系统来说，缓存服务器是必不可少的。</p><p id="63c4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为什么我们需要缓存服务器？</p><p id="f21c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">标准流程将是:</strong></p><ul class=""><li id="fdbf" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">步骤1:用户访问缩短的链接</li><li id="94ea" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">步骤2:我们必须去数据库从缩短的链接中获取原始链接</li><li id="29c1" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">步骤3:将用户重定向到原始链接。</li></ul><p id="1d63" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果没有缓存服务器，那么每次都必须进入数据库以获取结果。并且产生的DB将承受相当大的负载。为了最小化对数据库的查询，我们将缓存以前的查询结果。下一次，如果用户可以访问缩短的链接，现在我们只需要转到检索到的缓存来完成，而不必再次查询DB来获得结果。</p><p id="0206" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为缓存服务器总是将数据存储在内存中。因此，与从数据库获取结果相比，从内存获取结果要快得多。</p><p id="9fa2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要使用哪个缓存服务器？</p><p id="94a0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目前，有许多缓存服务器，如Redis、Memcache。我发现它非常有名，并且在世界各地的大型系统中被广泛使用。</p><p id="eb1c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以前我在一家游戏公司工作，当时我的系统使用Redis，我发现它非常好，支持很多功能。例如，自动排序结果，可以同步内存和存储之间的数据，以防止数据丢失…</p><p id="b0c2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以如果你不知道使用哪一个，我推荐你学习并实现<strong class="jz iu"> Redis </strong>。</p><p id="fd3e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">我们需要多少内存？<br/> </strong>和上一部分一样，我计算出这个系统将使用高达170GB的内存来缓存20%的URL。但是现在服务器有256GB的内存，解决这个问题绰绰有余。</p><p id="9b2f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，我们可以组合许多小型服务器(例如，每个服务器有8GB的内存)来缓存那些URL。</p><p id="7c1d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">如果缓存满了，那怎么办？</strong></p><p id="53e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大多数缓存系统遵循许多机制，如LRU(最近最少使用)或LFU(最少使用)。</p><ul class=""><li id="9c48" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">LRU(最近最少使用):丢弃最近使用的缓存项。</li><li id="73a0" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">LFU(最少使用):删除最少使用的缓存项。</li></ul><p id="ce90" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于这些机制，缓存将总是被刷新以避免完全使用。</p><p id="59b6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">负载平衡器<br/> 对于像这样的多个访问系统，web服务器可能还不能处理它。为了解决这个问题，我将使用许多网络服务器。每个web服务器将接受用户的部分请求。</p><p id="680c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">问题是如何自动请求分发到每个不同的web服务器？</p><p id="998d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">负载均衡器就是为了解决这个问题而诞生的。</p><p id="3ad5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，在负载平衡器下有几个web服务器。第一次，从客户端到负载平衡器的请求将被转发到web服务器1。第二次将被发送到网络服务器2 …</p><p id="9e9c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">目前，一些服务器提供商如AWS、Google或Azure支持负载平衡器。因此，您不需要担心必须构建负载平衡器。只要安装使用就完成了。</p><h1 id="a4a5" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="8d2b" class="pw-post-body-paragraph jx jy it jz b ka mh kc kd ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">通读这篇文章，你一定会对设计一个服务于数百万用户的大型系统有所思考，这是怎么回事？</p><p id="b170" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我想如果你遇到类似那样的系统，那么你有足够的知识和技能去解决。</p><p id="5e61" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为很多刚毕业或者没有在大系统工作过的人，很可能不知道从哪里入手，用什么技术。那么通过这篇文章希望能帮助你回答那些问题。</p></div></div>    
</body>
</html>