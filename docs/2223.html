<html>
<head>
<title>Room persistence library — Using MutableLiveData observable to update the UI after a database operation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间持久性库——在数据库操作后，使用可变数据观察来更新UI</h1>
<blockquote>原文：<a href="https://itnext.io/room-persistence-library-using-mutablelivedata-observable-to-update-the-ui-after-a-database-6836d25e8267?source=collection_archive---------3-----------------------#2019-04-18">https://itnext.io/room-persistence-library-using-mutablelivedata-observable-to-update-the-ui-after-a-database-6836d25e8267?source=collection_archive---------3-----------------------#2019-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/90136464f9d413c0f73752c07298c2e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFiJenS3MWyUQ6zElDdv9Q.jpeg"/></div></div></figure><p id="ad49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几个月前，我写了一篇关于如何使用delegate在房间后台数据库任务之后更新UI的文章。然而，尽管这种方法可行，但它可能会导致一些与活动生命周期和内存管理相关的问题。因此，在收到一些反馈后，我决定写一篇使用ViewModel和MutableLiveData实现相同结果的更好的方法。还有其他选项，如使用rxjava和新的alpha和beta room版本功能，但在这个示例中，我将只使用核心Android功能和room稳定版本。</p><p id="e146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在使用room persistence库来处理android应用程序上的Sqlite数据库操作，您应该知道该库强制开发人员在后台线程中执行所有的db调用。因此，如果您正在使用DAO模式，并且希望保留数据库逻辑，包括封装在DAO类中的异步执行，那么您需要以一种方式设计它们，使它们能够在后台进程完成后通知调用活动。之后，UI更新可以在主线程上进行。</p><p id="5085" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我将向您展示如何通过使用ViewModel和MutableLiveData来实现这一点。对于这个例子，我们需要编写5个类和1个接口，我会试着解释最重要部分的代码。解释基本的房间概念不是本文的目的，我们将在这里集中讨论主题。在我们继续之前，我想澄清一下，我并不是想重新发明轮子。这个例子中使用的一些概念是众所周知的，我只是把我们需要的东西放在一起。所以，我们走吧。</p><p id="2b70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们为我们在这个例子中使用的模型创建一个简单的类。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="22e6" class="lf lg iq lb b gy lh li l lj lk">import android.arch.persistence.room.Entity;<br/>import android.arch.persistence.room.PrimaryKey;</span><span id="535c" class="lf lg iq lb b gy ll li l lj lk"><a class="ae lm" href="http://twitter.com/Entity" rel="noopener ugc nofollow" target="_blank">@Entity</a><br/>public class Person {</span><span id="bee4" class="lf lg iq lb b gy ll li l lj lk"><a class="ae lm" href="http://twitter.com/PrimaryKey" rel="noopener ugc nofollow" target="_blank">@PrimaryKey</a>(autoGenerate = true)<br/>    private int id;<br/>    private String name;</span><span id="36a4" class="lf lg iq lb b gy ll li l lj lk">public int getId() {<br/>        return id;<br/>    }</span><span id="fa3e" class="lf lg iq lb b gy ll li l lj lk">public void setId(int id) {<br/>        this.id = id;<br/>    }</span><span id="9b9c" class="lf lg iq lb b gy ll li l lj lk">public String getName() {<br/>        return name;<br/>    }</span><span id="0741" class="lf lg iq lb b gy ll li l lj lk">public void setName(String name) {<br/>        this.name = name;<br/>    }</span><span id="3153" class="lf lg iq lb b gy ll li l lj lk">}</span></pre><p id="7c94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要一个Dao接口来定义DB基本操作。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5c58" class="lf lg iq lb b gy lh li l lj lk">import android.arch.lifecycle.LiveData;<br/>import android.arch.persistence.room.Dao;<br/>import android.arch.persistence.room.Insert;<br/>import android.arch.persistence.room.Query;<br/><br/>import java.util.List;<br/><br/>@Dao<br/>public interface PersonDao {<br/><br/>    @Insert<br/>    void insert(Person person);<br/><br/>    @Query("select * from Person order by name")<br/>    LiveData&lt;List&lt;Person&gt;&gt; getAllPersons();<br/><br/>}</span></pre><p id="7ae9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们来写数据库类。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6703" class="lf lg iq lb b gy lh li l lj lk">import android.arch.persistence.room.Room;<br/>import android.arch.persistence.room.RoomDatabase;<br/>import android.arch.persistence.room.Database;<br/>import android.content.Context;</span><span id="2f16" class="lf lg iq lb b gy ll li l lj lk"><a class="ae lm" href="http://twitter.com/Database" rel="noopener ugc nofollow" target="_blank">@Database</a>(entities = {Person.class}, version = 1)<br/>public abstract class AppDatabase extends RoomDatabase {</span><span id="0943" class="lf lg iq lb b gy ll li l lj lk">private static volatile AppDatabase INSTANCE;</span><span id="863f" class="lf lg iq lb b gy ll li l lj lk">private static final String DATABASE_NAME = "PersonDB";</span><span id="8417" class="lf lg iq lb b gy ll li l lj lk">public abstract PersonDao personDao();</span><span id="88c9" class="lf lg iq lb b gy ll li l lj lk">public static synchronized AppDatabase getInstance(Context context) {<br/>         if (INSTANCE == null) {<br/>             //Create database object<br/>             INSTANCE = Room.databaseBuilder(context,       AppDatabase.class, DATABASE_NAME).build();</span><span id="08b8" class="lf lg iq lb b gy ll li l lj lk">}</span><span id="8ab3" class="lf lg iq lb b gy ll li l lj lk">return INSTANCE;<br/>     }<br/>}</span></pre><p id="4d1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，我们对房间数据库使用了单例模式，通过这样做，我们可以对整个应用程序使用单个数据库实例。</p><p id="12f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是编写一个存储库类来处理UI持久性调用。除了提供一种方法来处理应用程序中的多个数据源之外，这种设计类型对于让DAO只执行数据库操作非常有用。为了澄清这个概念，假设您的应用程序需要在本地数据库和后端API上进行持久化操作。repository类将负责管理对这两层的调用。也就是说，我们可以继续存储库编码。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8ec4" class="lf lg iq lb b gy lh li l lj lk">import android.arch.lifecycle.MutableLiveData;<br/>import android.content.Context;<br/><br/>public class PersonRepository {<br/><br/>    private final PersonDao personDao;<br/>    private MutableLiveData&lt;Integer&gt; insertResult = new MutableLiveData&lt;&gt;();<br/><br/>    public PersonRepository(Context context) {<br/>        AppDatabase db = AppDatabase.<em class="ln">getInstance</em>(context);<br/>        personDao = db.personDao();<br/>    }<br/><br/>    public void insert(Person person) {<br/>        insertAsync(person);<br/>    }<br/><br/>    public MutableLiveData&lt;Integer&gt; getInsertResult() {<br/>        return insertResult;<br/>    }<br/><br/>    private void insertAsync(final Person person) {<br/><br/>        new Thread(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                try {<br/>                    personDao.insert(person);<br/>                    insertResult.postValue(1);<br/>                } catch (Exception e) {<br/>                    insertResult.postValue(0);<br/>                }<br/>            }<br/>        }).start();<br/><br/>    }<br/><br/>}</span></pre><p id="fdeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过解释部分代码来理解我们在这里做了什么。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a410" class="lf lg iq lb b gy lh li l lj lk">private final PersonDao personDao;<br/>    private MutableLiveData&lt;Integer&gt; insertResult = new MutableLiveData&lt;&gt;();<br/><br/>    public PersonRepository(Context context) {<br/>        AppDatabase db = AppDatabase.<em class="ln">getInstance</em>(context);<br/>        personDao = db.personDao();<br/>    }<br/><br/>    public void insert(Person person) {<br/>        insertAsync(person);<br/>    }<br/><br/>    public MutableLiveData&lt;Integer&gt; getInsertResult() {<br/>        return insertResult;<br/>    }</span></pre><p id="0b03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码片段中，我们有两个成员变量，一个用于DAO实例(personDAO ),另一个用于将要观察的MutableLiveData。之后，我们有一个构造函数，它接收一个应用程序上下文并实例化一个数据库类，从中获取所需的DAO以存储在personDAO变量中。然后，我们有insert方法，它接收一个模型对象(person)并调用私有方法insertAsync传递person对象。结束上面的代码片段，有一个用于MutableLiveData成员变量的getter。</p><p id="f3eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从现在开始，我将尝试解释repository类的最后一部分，它包含一个私有方法，用于通过线程执行房间库所需的后台数据库操作。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5f2d" class="lf lg iq lb b gy lh li l lj lk">private void insertAsync(final Person person) {<br/><br/>    new Thread(new Runnable() {<br/>        @Override<br/>        public void run() {<br/>            try {<br/>                personDao.insert(person);<br/>                insertResult.postValue(1);<br/>            } catch (Exception e) {<br/>                insertResult.postValue(0);<br/>            }<br/>        }<br/>    }).start();<br/><br/>}</span></pre><p id="a441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我们这里有一个后台线程，它在Try-Catch中调用Dao insert方法。如果插入没有错误，则使用postValue方法将MutableLiveData值设置为1。如果出现错误，该值将被设置为0。请注意，我们使用的是MutableLiveData postValue方法，因为我们在后台线程中设置值。如果要从主线程中为MutableLiveData对象设置一个值，应该使用setValue。</p><p id="2325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我将在下面的代码中展示ViewModel类。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="75e0" class="lf lg iq lb b gy lh li l lj lk">import android.app.Application;<br/>import android.arch.lifecycle.AndroidViewModel;<br/>import android.arch.lifecycle.LiveData;<br/>import android.support.annotation.NonNull;<br/><br/>public class PersonViewModel extends AndroidViewModel {<br/><br/>    private PersonRepository personRepository;<br/>    private LiveData&lt;Integer&gt; insertResult;<br/><br/>    public PersonViewModel(@NonNull Application application) {<br/>        super(application);<br/>        personRepository = new PersonRepository(application);<br/>        insertResult = personRepository.getInsertResult();<br/>    }<br/><br/>    public void insert(Person person) {<br/>        personRepository.insert(person);<br/>    }<br/><br/>    public LiveData&lt;Integer&gt; getInsertResult() {<br/>        return insertResult;<br/>    }<br/>}</span></pre><p id="f258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，ViewModel类有什么大不了的呢？嗯，除了使用它的设计模式优势之外，ViewModel类能够轻松处理活动生命周期。因此，当引用ViewModel的活动被销毁或重新创建时，ViewModel可以自动重新连接到它，并传递任何未决的通知。</p><p id="2f94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的ViewModel类将负责调用存储库任务并将结果发送给活动。在构造函数中，我们得到一个存储库实例和一个存储在成员变量中的MutableLiveData对象实例。除此之外，我们有一个insert方法，它被暴露给活动并调用存储库insert。最后，我们有一个LiveData observable的getter。</p><p id="e832" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们编写Activity类，这是所有过程开始的地方。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3564" class="lf lg iq lb b gy lh li l lj lk">import android.arch.lifecycle.Observer;<br/>import android.arch.lifecycle.ViewModelProviders;<br/>import android.support.annotation.Nullable;<br/>import android.support.v7.app.AppCompatActivity;<br/>import android.os.Bundle;<br/>import android.widget.Toast;<br/><br/>public class MainActivity extends AppCompatActivity {<br/><br/>    private PersonViewModel personViewModel;<br/><br/>    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        setContentView(R.layout.<em class="ln">activity_main</em>);<br/><br/>        personViewModel = ViewModelProviders.<em class="ln">of</em>(this).get(PersonViewModel.class);<br/><br/>        Person person = new Person();</span><span id="1808" class="lf lg iq lb b gy ll li l lj lk">        person.setName("Someone");</span><span id="0279" class="lf lg iq lb b gy ll li l lj lk">        personViewModel.getInsertResult().observe(this, new Observer&lt;Integer&gt;() {<br/>            @Override<br/>            public void onChanged(@Nullable Integer result) {<br/>                if (result == 1) {<br/>                    Toast.<em class="ln">makeText</em>(MainActivity.this, "Person successfully saved", Toast.<em class="ln">LENGTH_SHORT</em>).show();<br/>                } else {<br/>                    Toast.<em class="ln">makeText</em>(MainActivity.this, "Error saving person", Toast.<em class="ln">LENGTH_SHORT</em>).show();<br/>                }<br/>            }<br/>        });<br/><br/>        personViewModel.insert(person);<br/>    }<br/>}</span></pre><p id="bde1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的活动非常简单，它所做的唯一一件事就是通过ViewModel实例在数据库中插入一条person记录。正如我们所看到的，个人数据是硬编码的，没有供用户输入数据的表单。对于这个例子来说，这已经足够了。这里我们需要实现的就是在执行一个辅助线程之后，使用主线程更新用户界面。这是通过观察我们从视图模型中获得的实时数据来完成的。也就是说，下面是最重要的代码部分:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1cd7" class="lf lg iq lb b gy lh li l lj lk">personViewModel = ViewModelProviders.<em class="ln">of</em>(this).get(PersonViewModel.class);</span></pre><p id="1927" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">初始化ViewModel并将其连接到acitivity，如上面的代码片段所示。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c9e2" class="lf lg iq lb b gy lh li l lj lk">personViewModel.getInsertResult().observe(this, new Observer&lt;Integer&gt;() {<br/>            @Override<br/>            public void onChanged(@Nullable Integer result) {<br/>                if (result == 1) {<br/>                    Toast.<em class="ln">makeText</em>(MainActivity.this, "Person successfully saved", Toast.<em class="ln">LENGTH_SHORT</em>).show();<br/>                } else {<br/>                    Toast.<em class="ln">makeText</em>(MainActivity.this, "Error saving person", Toast.<em class="ln">LENGTH_SHORT</em>).show();<br/>                }<br/>            }<br/>        });</span></pre><p id="6e8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">观察LiveData的价值。这样，我们可以从后台线程接收通知，并在数据库操作后按照我们的要求正确地更新UI。</p><p id="1f21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，我们到了这篇文章的结尾。我希望我说得很清楚，你可以利用这个例子。感谢阅读。</p></div></div>    
</body>
</html>