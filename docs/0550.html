<html>
<head>
<title>Clean Code with React, ExpressJS, and MongoDB — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React、ExpressJS和MongoDB清理代码—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/clean-code-with-react-expressjs-and-mongodb-part-2-89d20e684820?source=collection_archive---------5-----------------------#2018-03-29">https://itnext.io/clean-code-with-react-expressjs-and-mongodb-part-2-89d20e684820?source=collection_archive---------5-----------------------#2018-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/188317d984598b0ab1a480cd7db92057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9cTch3fVL9AwXFgpF8ZuA.jpeg"/></div></div></figure><blockquote class="jy jz ka"><p id="a2ee" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fclean-code-with-react-expressjs-and-mongodb-part-2–89d20e684820%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="433e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是一个简短系列文章的第二部分，重点是使用ES6+ Javascript、React、Redux、ExpressJS和MongoDB创建和部署一个准系统的全栈博客站点。</p><p id="a288" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这些文章中，我真的试图把重点放在我发现的使用ES6+ JavaScript和我称之为“Redux风格”的项目结构来设置和组织我的代码的一些方法上。目标是编写可读、可扩展且易于测试的代码。</p><p id="85c8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这个系列将分为几个部分:</p><ol class=""><li id="15a7" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/clean-code-with-react-expressjs-and-mongodb-part-1-aa6b1a4aef82">设置ExpressJS使用ES6+语法</a></li><li id="0f56" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">Redux风格的文件结构👈🏽<em class="kd">你在这里</em></li><li id="b117" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/clean-code-with-es6-expressjs-reactjs-part-3-2306b1f62c26">创建简单快速服务器</a></li><li id="44ab" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">用我们的博客设置Mongoose(即将推出！)</li><li id="c098" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">用CMS创建一个React博客(即将推出！)</li><li id="9170" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">将Redux添加到您的前端(即将推出！)</li><li id="9544" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">包装您的应用:部署(即将推出！)</li></ol><h1 id="f2b9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">第2部分:Redux风格的文件结构</h1><p id="6c93" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">现在我们已经设置好了ES6+，让我们来讨论一下如何使用一种我称之为“Redux-Style”的技术来组织我们的服务器，以确保代码准确且有意义。该方法<em class="kd">不是</em>专用于Redux，而是<em class="kd">与</em> Redux共同使用。</p><p id="754a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">使用ES6+语法，如果一个目录被引用(并且<em class="kd">不是</em>一个特定的文件)，节点在那个目录中寻找一个<code class="fe mv mw mx my b">index.js</code>文件来告诉它做什么。目标是从同一个目录<em class="kd">到</em>到<code class="fe mv mw mx my b">index.js</code>中的其他文件导出函数和常量。我们可以使用这个特性来收集我们所有的函数和常量，并通过<code class="fe mv mw mx my b">index.js</code>导出它们。</p><p id="1828" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">让我们来看看实际情况:我们将在我们的<code class="fe mv mw mx my b">📂configs/</code>目录中创建一个名为<code class="fe mv mw mx my b">server.js</code>的文件和另一个名为 <code class="fe mv mw mx my b">index.js</code>的文件。我们的文件结构现在应该是这样的:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5659" class="nh lt iq my b gy ni nj l nk nl">📁/<br/> 📂configs/<br/>  📄index.js<br/>  📄server.js<br/> 📂database/<br/> 📂routes/<br/> 📄index.js<br/> 📄.babelrc<br/> 📄package.json<br/> 📄yarn.lock</span></pre><p id="57db" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">将以下代码添加到各自的文件中:</p><p id="3561" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd">。/configs/server.js </em></p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="c5c6" class="nh lt iq my b gy ni nj l nk nl">export const configureServer = () =&gt; { console.log('Server Configs!') }</span></pre><p id="3edc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd">。/configs/index.js </em></p><p id="3a9c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，将下面的代码添加到<strong class="ke ir">根目录</strong>中的<code class="fe mv mw mx my b">index.js</code>中。注<code class="fe mv mw mx my b">import</code>语句带空<code class="fe mv mw mx my b">{}</code>:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="819b" class="nh lt iq my b gy ni nj l nk nl">import {} from './configs'</span></pre><p id="034f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在大多数像VS Code和Atom这样的ide中，如果你开始在import语句<code class="fe mv mw mx my b">configureServer()</code>的<code class="fe mv mw mx my b">{}</code>中输入我们的函数名，你会看到它会自动建议这个函数。哦哦！但这不仅仅是神奇的🧙🏽‍♀️.这是一个很好的方法来验证我们的常量和函数有正确的名字！</p><p id="c24f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">目前，我们只是在命名我们的函数之前使用<code class="fe mv mw mx my b">export</code>从<code class="fe mv mw mx my b">server.js</code>中导出<code class="fe mv mw mx my b">configureServer()</code>函数，但是我们也将创建其他具有常量的文件，并将它们收集在同一个<code class="fe mv mw mx my b">index.js</code>中，以便在其他文件中导出和使用。</p><p id="66e0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是Redux中组织代码的一种流行方式，我觉得它很棒，原因有二:</p><ol class=""><li id="7af1" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">它使我们的代码模块化。这使得测试更加容易。</li><li id="cd75" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">它允许验证函数和常数的名称是否正确。大多数文本编辑器，如VS Code和Atom，会自动填充目录中的可用导出。</li></ol><p id="093c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果你使用过React，你可能很熟悉将<code class="fe mv mw mx my b">import</code>和<code class="fe mv mw mx my b">{}</code>一起使用。语法类似于ES6中的<em class="kd">析构</em>，工作方式也类似，尽管它们是不同的东西。我喜欢这样想:</p><ul class=""><li id="331a" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz nm lk ll lm bi translated"><strong class="ke ir">如果没有</strong> <code class="fe mv mw mx my b">{}</code>，我们将收集一个模块的所有导出，并在一个名称下导入一个。当然，我们仍然可以使用点符号来分别调用它们:</li></ul><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="6899" class="nh lt iq my b gy ni nj l nk nl">import React from 'react' class App extends React.Component{...</span></pre><ul class=""><li id="1537" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz nm lk ll lm bi translated"><strong class="ke ir">有了</strong><code class="fe mv mw mx my b">{}</code>，我们只抢我们需要的出口。</li></ul><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="25bc" class="nh lt iq my b gy ni nj l nk nl">import React, {Component} from 'react' class App extends Component{...</span></pre><p id="ed32" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">请记住，您不能对这个方法使用<code class="fe mv mw mx my b">export default</code>,因为您需要明确您要导出的内容。例如，对于React，我们应该写:</p><p id="66c1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">export class Login extends React.Component{...</code></p><p id="4d4d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">而<em class="kd">不是:</em></p><p id="2d54" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><code class="fe mv mw mx my b">export default class Login extends React.Component{...</code></p><p id="e84b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">有关“Redux-style”导入/导出技术的更多信息，请阅读这里:<a class="ae la" href="https://alligator.io/react/index-js-public-interfaces/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae la" href="https://medium.com/lexical-labs-engineering/redux-best-practices-64d59775802e" rel="noopener">这里</a>。</p><h1 id="678a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">下一步是什么？</h1><p id="b1a8" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">在本文中，我们学习了“Redux风格”的导出/导入技术，这种技术可以确保更准确的代码和更少的麻烦。在下一篇文章中，我们将使用我们在这两篇文章中学到的知识建立一个准系统Express服务器！敬请期待！</p></div></div>    
</body>
</html>