<html>
<head>
<title>Google Carbon vs. Apple Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌碳与苹果斯威夫特</h1>
<blockquote>原文：<a href="https://itnext.io/google-carbon-vs-apple-swift-9df8262342c8?source=collection_archive---------0-----------------------#2022-07-22">https://itnext.io/google-carbon-vs-apple-swift-9df8262342c8?source=collection_archive---------0-----------------------#2022-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b4f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Carbon能像Swift取代Objective-C那样取代C++吗？</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/69a6ce9827439a85a5e578dd21fc7643.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ormi10tgy5IxCL0YOKA2yg.jpeg"/></div></figure><p id="ed69" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated">碳编程语言实际上是一些非常酷的消息！一个早期的实验版本刚刚在2022年7月19日被丢弃。我不会重复典型的新闻发布的东西，而是集中在我对谷歌的这种新语言的看法。</p><p id="e190" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Carbon正在遵循一种我们已经多次看到的编程趋势，即采用一种成熟的行业语言，并以最小的阻抗失配来制作它的现代版本。基本上，这意味着新语言保留了遗留语言的重要语义，因此您可以轻松地重用所有现有代码。以下是这种方法的一些语言组合示例:</p><ul class=""><li id="71ed" class="lv lw it ks b kt ku kw kx kz lx ld ly lh lz ll ma mb mc md bi translated"><a class="ae me" href="https://developer.apple.com/swift/" rel="noopener ugc nofollow" target="_blank"> Swift </a> —一种在Objective-C运行时之上实现的语言，具有现代类型安全和函数式编程支持。</li><li id="b5e7" class="lv lw it ks b kt mf kw mg kz mh ld mi lh mj ll ma mb mc md bi translated"><a class="ae me" href="https://kotlinlang.org" rel="noopener ugc nofollow" target="_blank"> Kotlin </a> —一种与Java平滑集成的JVM语言。与Swift惊人的语法相似性。</li><li id="9b49" class="lv lw it ks b kt mf kw mg kz mh ld mi lh mj ll ma mb mc md bi translated"><a class="ae me" href="https://elixir-lang.org" rel="noopener ugc nofollow" target="_blank">Elixir</a>—Erlang虚拟机之上的Ruby语法语言，允许您毫不费力地重用Erlang代码。</li><li id="fdcd" class="lv lw it ks b kt mf kw mg kz mh ld mi lh mj ll ma mb mc md bi translated"><a class="ae me" href="https://ziglang.org" rel="noopener ugc nofollow" target="_blank">Zig</a>—c的替代产品。与c相同的数据布局。相似的内存管理模型和二进制接口。c可以调用Zig代码。</li></ul><p id="470e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们还可以添加大量针对JavaScript的transpilers(源代码到源代码的编译器)，比如<a class="ae me" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>。</p><p id="a523" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所有这些语言都是为了与另一种语言紧密集成而设计的，而不仅仅是一些基本的外部函数接口。例如，Java和Python可以调用C代码，但这并不意味着它们可以直接替代C。有相当多的粘合代码需要编写。更进一步，你不希望C调用Python或者Java代码。那将会令人作呕。</p><p id="9214" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">苹果曾试图让人们从Objective-C迁移到Java和Ruby，但这两种方法都不奏效。大量的投资存在于高质量的Objective-C库上，这些库不能在Java和Ruby中使用，否则会很笨拙。原因很简单，因为这两种语言在设计时都没有考虑到Objective-C。有一个光荣的尝试叫做<a class="ae me" href="http://www.rubymotion.com/developers/guides/manuals/cocoa/runtime/" rel="noopener ugc nofollow" target="_blank"> Ruby Motion </a>，它在Objective-C运行时之上构建了Ruby，以便更好地集成。</p><p id="b071" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，真正起作用的是从头开始创建一种现代语言，专门设计来与Objective-C运行时紧密集成。这种方法造就了Swift。</p><p id="6d3c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为一名长期的Objective-C开发人员，我不得不说这真的有了回报。事实上，这种经历非常美妙。我可以在Objective-C类上分离出单独的方法，将它们重写为Swift代码，重新编译，运行，然后看到一切都像以前一样工作。通常情况下，重写是一个大的，精心策划的项目，有很多痛苦。</p><p id="63d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有了Swift，你几乎可以随心所欲地移动。你甚至不需要做全端口。您可以保留一半很少单独编辑的代码，不进行移植。</p><p id="def7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在经历了将几个iOS应用程序移植到Swift的过程后，我对移植到更现代的语言的好处做了许多积极的观察。我已经看过了Carbon 的<a class="ae me" href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design#hello-carbon" rel="noopener ugc nofollow" target="_blank">语言规范，这让我得出结论，任何人将他们的C++代码移植到Carbon都会体验到很多我在从Objective-C移植到Swift时所体验到的好处。</a></p><p id="ea71" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们回顾一下这些好处。</p><h2 id="488c" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">在C++项目中引入碳元素的好处</h2><p id="2204" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">根据我对Swift的体验和我看到的Carbon相对于C++提供的特性，你应该把这理解为<em class="ni">有根据的推测</em>。当我阅读Carbon的功能集时，很难不注意到它与Swift惊人的相似之处:</p><ul class=""><li id="0008" class="lv lw it ks b kt ku kw kx kz lx ld ly lh lz ll ma mb mc md bi translated">不再有空指针。请改用可选类型。</li><li id="131e" class="lv lw it ks b kt mf kw mg kz mh ld mi lh mj ll ma mb mc md bi translated">模式匹配</li><li id="1e61" class="lv lw it ks b kt mf kw mg kz mh ld mi lh mj ll ma mb mc md bi translated">可卡因上的标记结合或替代枚举，也称为总和类型。</li><li id="232d" class="lv lw it ks b kt mf kw mg kz mh ld mi lh mj ll ma mb mc md bi translated">数据必须正确初始化</li></ul><p id="4157" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还有许多句法上的相似之处。这里有一个碳代码的例子:</p><pre class="ki kj kk kl gt nj nk nl nm aw nn bi"><span id="0198" class="mk ml it nk b gy no np l nq nr">// Carbon code<br/><strong class="nk iu">import</strong> Console;<br/><br/>// Prints the Fibonacci numbers less than `limit`.<br/><strong class="nk iu">fn</strong> Fibonacci(limit: i64) {<br/>  <strong class="nk iu">var</strong> (a: i64, b: i64) = (0, 1);<br/>  <strong class="nk iu">while</strong> (a &lt; limit) {<br/>    Console.Print(a, " ");<br/>    <strong class="nk iu">let</strong> next: i64 = a + b;<br/>    a = b;<br/>    b = next;<br/>  }<br/>  Console.Print("\n");<br/>}</span></pre><p id="2a12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">请注意它与Swift代码有多么相似，后者做同样的事情:</p><pre class="ki kj kk kl gt nj nk nl nm aw nn bi"><span id="80dd" class="mk ml it nk b gy no np l nq nr">// Swift code<br/><strong class="nk iu">import</strong> Foundation<br/><br/>// Prints the Fibonacci numbers less than `limit`.<br/><strong class="nk iu">func</strong> fibonacci(limit: Int64) {<br/>  <strong class="nk iu">var</strong> (a, b) : (Int64, Int64) = (0, 1)<br/>  <strong class="nk iu">while</strong> a &lt; limit {<br/>    print(a, " ")<br/>    <strong class="nk iu">let</strong> next: Int64 = a + b<br/>    a = b<br/>    b = next<br/>  }<br/>  print("\n");<br/>}</span></pre><p id="7ca4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Carbon和Swift都使用关键字<code class="fe ns nt nu nk b">var</code>和<code class="fe ns nt nu nk b">let</code>来开始声明一个变量，并使用冒号<code class="fe ns nt nu nk b">:</code>来分隔变量名和类型。</p><pre class="ki kj kk kl gt nj nk nl nm aw nn bi"><span id="d202" class="mk ml it nk b gy no np l nq nr">// Carbon variable<br/><strong class="nk iu">var</strong> x: i64 = 42;<br/><br/>// Carbon constant<br/><strong class="nk iu">let</strong> y: f64 = 13.31;<br/><br/>// Swift variable<br/><strong class="nk iu">var</strong> x: Int64 = 42;<br/><br/>// Swift constant<br/><strong class="nk iu">let</strong> y: Float64 = 13.31;</span></pre><p id="a02b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">底线是有很多相似之处，这意味着它帮助我衡量相对于C++编程Carbon的感觉。我已经知道Swift相对于C++和Objective-C的感受了。</p><h2 id="4484" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">通过移植到Carbon来捕获bug</h2><p id="8628" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">当我将Objective-C代码移植到Swift时，我得到了严格的Swift类型检查器的大量帮助。有时，我觉得Swift类型检查器就像一个纳粹营指挥官，但它在发现更骑士的Objective-C类型检查器忽略的偷偷摸摸的错误方面很出色。这不仅仅是使用错误类型的问题。更多的是捕获没有初始化或者初始化顺序错误的变量。它可能是很少采用代码路径的代码，类型系统会警告这些代码路径会导致失败。</p><p id="8040" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一旦您开始看到这些好处，您就会迷上移植。我怀疑许多C++开发人员一旦尝试Carbon，就会被类似的经历所吸引。通过了解一门新语言如何帮助发现错误并提高代码质量，他们将会被说服。</p><h2 id="4f53" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">扩大开发人员基础</h2><p id="6262" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">我从移植到Swift中注意到的另一个因素是，它扩大了对代码库感兴趣并有能力做出贡献的人群。Swift对许多开发人员来说更有趣，也更容易理解。它也更容易学习。这意味着更多的人加入了这个项目，并且变得更有动力。</p><p id="5d57" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们面对现实吧:C++并没有真正出现在今天人们的议事日程上。它已经成为一种古怪的专业语言，需要多年的训练才能完全掌握。像Carbon这样的语言可以给开发者一直回避的停滞不前的项目注入活力。</p><h2 id="4ae1" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">为什么不用Rust，Go或者Swift？</h2><p id="7bcf" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">开发人员一直在绑定流行的C/C++库。然而，这与直接替代完全不同。通常，当您让两种语言互操作时，我们只支持每种语言的一个子集。对于其他任何东西，你都必须编写粘合代码或者自动生成代码。Rust、Go和Swift不容易重用高阶C++类型，C++也不容易利用这些其他语言的高阶抽象。</p><p id="48f3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Rust和C++之间的关系可能有点像Scala和Java。尽管Scala运行在JVM上，但它并不能与Java顺畅地互操作。据我所知，Java开发人员不容易访问和使用Scala功能。Kotlin特别受欢迎，因为匹配Java的语义并使集成更紧密是一个明确的目标。因此，科特林更接近碳的目标。事实上，Carbon的设计者对互操作性的目标做了一些澄清。例如，他们希望我们能够无缝地使用常见的C++类型:</p><blockquote class="nv nw nx"><p id="b2b5" class="kq kr ni ks b kt ku ju kv kw kx jx ky ny la lb lc nz le lf lg oa li lj lk ll im bi translated">像std::vector <t>这样的C++类模板应该可以在没有包装器代码或运行时开销的情况下使用，并且可以将Carbon类型作为t来传递。用Carbon接口包装std::vector <t>也应该很容易，以便在惯用的Carbon代码中透明地使用。</t></t></p></blockquote><p id="b8ab" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">他们希望实现我在将Objective-C代码迁移到Swift时所做的事情，即在移植的所有阶段保持功能完整的软件正常运行。</p><blockquote class="nv nw nx"><p id="092d" class="kq kr ni ks b kt ku ju kv kw kx jx ky ny la lb lc nz le lf lg oa li lj lk ll im bi translated">与C++的互操作性将在Carbon中频繁使用，无论是C++开发人员尝试Carbon，增量迁移大型C++代码库，还是继续长期使用C++库。在所有情况下，必须能够编写零开销的可互操作代码；不得要求复印件。</p></blockquote><h2 id="b1c8" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">如果这是个好主意，为什么不早点实现呢？</h2><p id="5bfb" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">我觉得这是一个很棒的问题。碳之类的东西早就应该出现了。我认为这需要时间的原因有几个。早在20世纪90年代，我们就设想像Java和C#这样的语言会取代C++。垃圾收集和托管运行时风靡一时。人们认为像C++这样的手动内存管理的语言没有前途。</p><p id="3ce2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">几年过去了，我们意识到关于垃圾收集的想法是错误的。现代语言，如Go、Julia、Swift、Rust和Nim，采用了完全不同的内存管理方法。Rust基本上是在做C++的类型安全版本。从技术上讲，Swift有一个GC，但它都是在编译时战略性地放置的自动引用计数(ARC)。去和朱莉娅有什么我们更通常认为有垃圾收集器。然而，他们并不使用它们，任何类似Java的东西。两者都更积极地使用堆栈分配。这些语言还被设计成推动代码对大型连续内存块进行更少和更多的分配。Go和Julia通常会分配一个数组，比如说一次分配一百万个对象。Java将进行一百万次分配，数组中的每个对象一次。</p><p id="da00" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，C++替代品的概念需要时间来发展。早期的尝试是D，但它是垃圾收集语言。C++是一种非常复杂的语言，直到LLVM和clang等可靠的基础设施出现，开发某种新的C++才是一件疯狂的事情。尝试这种方法的第一种语言会更简单，这是有道理的。Objective-C是比C++简单得多的语言。制造Swift的任务因此变得更加容易。</p><p id="a837" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Zig、Odin和V等语言的另一个典型目标是C语言，因为它简单得多。</p><p id="f239" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">制作Elixir也是可行的，因为Erlang是一种动态语言。动态语言往往更容易接口，因为它们是基于消息传递的。这意味着你不需要处理复杂的二进制应用程序接口。</p><p id="4e3f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了让Carbon发生，我们必须首先从Swift、Kotlin、Rust和其他语言中吸取教训。这些语言让人们确信，这种项目是有意义的，是可以成功的。</p><h2 id="9dd9" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">这个项目让我兴奋的是什么</h2><p id="c4ea" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">我刻意避免接触C++代码。然而，我仍然知道有很多真正高质量的C++库，它们具有大量的强大功能。作为跨平台GUI库，还是很难打败<a class="ae me" href="https://www.qt.io" rel="noopener ugc nofollow" target="_blank"> Qt </a>的。像碳这样的东西会让Qt更实用。我还预测,<a class="ae me" href="https://www.qt.io" rel="noopener ugc nofollow" target="_blank"> Qt公司</a>将会看到将他们的代码库的重要部分迁移到Carbon的好处。</p><p id="2f1c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还有一些知名的项目如<a class="ae me" href="https://vtk.org" rel="noopener ugc nofollow" target="_blank">可视化工具包</a>和游戏引擎如<a class="ae me" href="https://godotengine.org" rel="noopener ugc nofollow" target="_blank"> Godot </a>都是用C++写的。有了Carbon，向Godot添加插件和扩展就变得可能，而不必受C++的影响。</p><p id="05d4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">还要记住，Carbon团队正在开发能够自动将C++代码翻译成Carbon代码的工具。通常，这样的翻译会很难看。但是，如果语言语义相似，比如翻译可能不会太难看。</p><h2 id="74e3" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">为什么碳会失效</h2><p id="eda5" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">苹果控制了Objective-C，并主导了使用它的平台。当苹果说Swift是未来时，开发者很容易就能加入进来。他们知道这将会发生，因为苹果在Mac世界发号施令。没有人控制C++，因此也没有大公司来告诉开发人员未来会怎样，他们需要加入进来。</p><p id="0509" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">因此，碳排放有可能导致鸡生蛋还是蛋生鸡的问题。没有足够的人迁移。如果没有一个足够大的社区，其他人就看不到它值得追求。</p><h2 id="388b" class="mk ml it bd mm mn mo dn mp mq mr dp ms kz mt mu mv ld mw mx my lh mz na nb nc bi translated">你的想法？</h2><p id="08a2" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">让我听听你的想法？你认为碳会对C++世界有益吗？碳有成功的机会，还是注定要失败？你认为这种语言怎么样？这是一个好的设计吗？</p></div></div>    
</body>
</html>