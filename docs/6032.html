<html>
<head>
<title>Modern Node Part 1 — Architecting and Scaffolding a TypeScript &amp; Express API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代节点第1部分——架构和搭建TypeScript &amp; Express API</h1>
<blockquote>原文：<a href="https://itnext.io/modern-node-part-1-architecting-and-scaffolding-a-typescript-express-api-22e87fee054c?source=collection_archive---------0-----------------------#2021-07-28">https://itnext.io/modern-node-part-1-architecting-and-scaffolding-a-typescript-express-api-22e87fee054c?source=collection_archive---------0-----------------------#2021-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5b7e8c91006ef9e73aff13b4e2bbfe36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MskduOJrdYKaks3PPlSaVQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">纽约的船</figcaption></figure><h1 id="f679" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="af03" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在过去一年左右的时间里，我已经从主要从事应用程序代码和较低级别的业务逻辑转向从事架构、基础设施和所有有助于架构、创建、部署和保持生产级应用程序运行的不同部分。而且，作为一个自学成才的软件工程师，我完全知道从头到尾搜索一个真正完整的教程是什么样的，这个教程将在生产中实际工作，并且没有结果。</p><p id="d362" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">既然我自己也经历过这种情况，并且必须在短时间内吸收大量知识，那么在本系列中，我想举一个完整的例子，这是我在学习诀窍时所希望的。从开发我自己的应用程序，到一家中型公司改造他们的技术堆栈，到一家企业公司上市，再到现在一家从零定制基础设施起步的创业公司，我注意到了我所开发的每一个应用程序或平台的趋势和共同点。</p><p id="ef6c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我一直致力于改进构建生产就绪型应用程序的过程，同时在整个过程中从事辅助项目，并使用我将在本文中描述的过程来创建使用行业最佳实践部署在云中的全功能、多环境应用程序。</p><p id="56cb" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在，我想把这些趣闻积累成一些有用的东西，并把它们传递给所有全新的，甚至是有经验的软件工程师，他们可能正在寻找自己应用程序的最佳实践，在工作中帮助一个项目，或者真的要如何处理任何全栈应用程序。</p><p id="d8b5" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">TL；DR:这将是一个关于构建生产就绪、完全部署的应用程序的系列，该应用程序具有用于API层的Next.js前端和Node.js微服务。我们将从零代码一直到在AWS上部署到多个环境。</strong></p><h2 id="5c11" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">我们将建造什么？</h2><p id="7976" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们将为最近的一类应用开发一个新版本，用它们糟糕的UX或缺乏功能来挫败我:个人理财应用！对我来说，这是否是一个单用户应用程序并不重要，因为它将完全按照我的要求跟踪我自己的财务状况，并将很好地说明构建任何生产就绪应用程序的过程。</p><p id="c417" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">对于语言和框架，我们将使用一种我见过的模式，这种模式可以用于生产中的大多数应用程序，并且只需要较新的工程师学习一种语言:一个面向应用的API和作业运行服务的<a class="ae mp" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js，一个用</a><a class="ae mp" href="https://chakra-ui.com/" rel="noopener ugc nofollow" target="_blank"> Chakra UI </a>和<a class="ae mp" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> React Query </a>、面向用户的搜索的<a class="ae mp" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="noopener ugc nofollow" target="_blank"> ElasticSearch </a>、会话管理的<a class="ae mp" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>和Docker<a class="ae mp" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">构建的Next.js React应用</a></p><p id="9c80" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">然后，我们将把这个堆栈部署到两个独立的服务中，这既符合我作为开发人员的偏好，也为读者提供了一个部署到多个特定云提供商的示例。我们将在亚马逊网络服务<a class="ae mp" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">上托管除</a><a class="ae mp" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>应用之外的所有应用，并在Vercel的<a class="ae mp" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank">平台</a>上托管Next.js应用，这在最近的过去被证明非常有用且易于使用(我最喜欢的他们的功能是branch preview deploy，它使在紧密的反馈循环中与产品经理和设计师合作变得绝对容易)。总的来说，这就是我如何设计一个处于项目阶段的应用程序，但我们希望在没有重大模式转变的情况下，随时准备无限扩大规模。我们还将使用<a class="ae mp" href="https://www.terraform.io/docs/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform </a>完成所有这些AWS基础设施管理，我也强烈推荐这款产品。我工作过的所有公司要么已经有了它，要么因为它的有用性我已经把它纳入了技术堆栈。</p><p id="bb9a" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir">TL；DR:我们将构建一个个人金融应用程序，与用户的银行账户同步，通过sessions和Redis完全认证，从头开始使用ElasticSearch，Docker用于本地开发和不可知部署，Terraform用于基础设施管理</strong></p><h2 id="b8b6" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">我们的应用程序会做什么？</h2><p id="459d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在使用了各种不同的个人财务和预算应用程序后，我发现电子表格对我来说更简单了。然而，有很多事情你不能用应用程序中的电子表格来做，比如自动与你的银行账户同步，自动对费用进行分类，制作有用的可视化工具来检查你的预算或储蓄目标，当看着面前的用户界面时不会呕吐，等等。</p><p id="c227" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">本质上，我们将为核心功能构建这个:</p><ul class=""><li id="9119" class="mu mv iq lc b ld ly lh lz ll mw lp mx lt my lx mz na nb nc bi translated">一个仪表板，在这里你可以找到关于你的花费、预算使用、储蓄目标等你需要的大部分东西。</li><li id="d884" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">一个预算页面，实际上建立你自己的每个类别的预算</li><li id="49fe" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">搜索费用</li><li id="4e70" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">一个费用页面来记录你的支出</li><li id="43ac" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">净值和储蓄目标/财务规划页面</li><li id="0c32" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">添加或管理您的已连接帐户的页面</li><li id="d2cc" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">费用、预算类别等的详细页面。</li></ul><h2 id="2780" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">我们的技术堆栈将使用什么？</h2><p id="f0c2" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">最后，在这个项目中我们将主要使用什么工具和库？请记住，我们不会在本文中使用所有这些，而是在整个系列中使用一小部分。</p><ul class=""><li id="8f5b" class="mu mv iq lc b ld ly lh lz ll mw lp mx lt my lx mz na nb nc bi translated">Next.js</li><li id="6307" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">节点. js</li><li id="b737" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">表达</li><li id="bfcd" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">雷迪斯</li><li id="6978" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">弹性搜索</li><li id="063e" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">码头工人</li><li id="33a1" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">docker-撰写</li><li id="a436" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">库伯内特斯</li><li id="80f5" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">种类</li><li id="b2f9" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">格子图案</li><li id="e0e2" class="mu mv iq lc b ld nd lh ne ll nf lp ng lt nh lx mz na nb nc bi translated">自动警报系统</li></ul><p id="652c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><em class="ni">注意:在本系列中，我不打算深入研究这些工具。本内容将假设您至少对这些工具有初步的了解！如果没有，我将链接到他们的文档，这样您可以在我们开始使用它们之前获得一些上下文。</em></p><p id="9fa0" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">事不宜迟，让我们开始构建任何生产应用程序的第一部分:</p><h1 id="5fc8" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">体系结构</h1><h2 id="f627" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">架构设计的过程是什么，我们为什么需要它？</h2><p id="9dcc" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">老实说，在个人项目上，我跳过了这个阶段，因为我只想开始建设。有时会成功，但有时会让我难堪。但是，如果你想走得快，还能走得远，你需要在考虑距离的情况下进行建设。</p><p id="ea68" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">架构对于像这样的生产级应用程序非常重要，因为它将保护您在流量突然增加时不会突然崩溃，并将保持您的低成本，因为您没有悬空的基础架构，您要么在降速时忘记，要么让您向我们的托管平台所有者支付额外费用(不客气，Jeff)。</p><p id="156f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">具体来说，我们这里要使用的是Terraform，这是我最喜欢的，也是我见过的使用最广泛的基础设施即代码框架。</p><p id="77f0" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们正在构建的非常简单，但这是我在各种规模的公司中见过的可扩展模式:在任何容器编排系统上的微服务，但在这种情况下，我们将使用Docker Compose和Kubernetes。我们将能够轻松地在本地运行，并相对无限地扩大规模，如果需要的话，只需对基础架构进行微小的更改。</p><p id="4d1a" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">Vercel本身在自动缩放方面做得非常好，但如果我们想坚持使用所有AWS并将Next.js应用程序放在另一个容器中，我们可能也不会有问题。</p><h2 id="c7d0" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">那么，这个app会是什么样子呢？</h2><p id="541f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">概括地说，它将如下图所示。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/ead883f162ef630254229b30eca414d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuAweYC9OiwI7vmRm8UCJA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用架构</figcaption></figure><p id="e63b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们将有两个API级别的服务:一个是用户服务(作为一个整体，只是为了简单起见，因为它可以在以后相对容易地分解成服务)，另一个是数学服务。在这种情况下，我们将需要一个单独的进程来处理更多的阻塞功能(CPU密集型任务，如运行复杂的运行时计算或作业)，因为<a class="ae mp" href="https://medium.com/swlh/is-node-js-single-threaded-the-architecture-of-node-js-69f8c0d59b00" rel="noopener">节点是单线程的</a>。</p><p id="3bca" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们将使用PostgreSQL数据库和作为ORM的<a class="ae mp" href="https://vincit.github.io/objection.js/" rel="noopener ugc nofollow" target="_blank"> Objection.js </a>,因为Objection.js在过去已经被证明非常适合使用。如果您需要优化或者不能使用API进行查询，那么允许原始SQL就足够了，但是我过去从未使用过原始SQL。我们管理建模、迁移和it整体灵活性的方式非常适合我们的用例。</p><p id="33e9" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">好了，我们开始吧。</p><h1 id="d530" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">脚手架</h1><p id="baf3" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">为了便于组织，我们将从一开始就启动所有目录，因为这是一个针对所有目录的以CLI为中心的过程。</p><p id="7be2" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">让我们用<code class="fe mq mr ms mt b">create-next-app</code>启动我们的<code class="fe mq mr ms mt b">app</code>，也就是Next.js前端，用<code class="fe mq mr ms mt b">yarn init</code>启动我们的后端服务</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="b769" class="md kd iq mt b gy ns nt l nu nv">&gt; yarn create next-app app --ts<br/>&gt; mkdir services &amp;&amp; cd services<br/>&gt; mkdir users-service &amp;&amp; mkdir math-service<br/>&gt; cd users-service<br/>&gt; yarn init -y<br/>&gt; cd ../math-service<br/>&gt; yarn init -y</span></pre><p id="6189" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">您最终应该得到这样的文件结构:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/240e9785b67a66d673b2e6a43dc6741b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PN68s4AbLvAPhf_7qQlZ1w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我在用<code class="fe mq mr ms mt b"><a class="ae mp" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">homebrew</a> library's <a class="ae mp" href="https://formulae.brew.sh/formula/tree" rel="noopener ugc nofollow" target="_blank">tree</a></code></figcaption></figure><p id="3c23" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">在设置基本Express服务器时，让我们为我们的两个服务执行相同的过程。我将只讨论其中一个(用户服务)，但是继续在两个中创建相同的结构。</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="9056" class="md kd iq mt b gy ns nt l nu nv">yarn add -D typescript ts-node @types/node @types/express nodemon tslint dotenv</span><span id="e8de" class="md kd iq mt b gy nx nt l nu nv">yarn add express</span><span id="0de2" class="md kd iq mt b gy nx nt l nu nv">mkdir src</span><span id="c949" class="md kd iq mt b gy nx nt l nu nv">touch .env .env.sample tslint.json tsconfig.json nodemon.json .gitignore .editorconfig src/server.ts src/index.ts</span></pre><p id="8001" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">让我们把无聊的东西拿出来:就实际配置而言，配置文件确实取决于个人偏好。我将用一些我喜欢使用的常见配置来引导这些，但不会深入讨论任何特定的配置。如果你觉得合适，可以随意调整。</p><p id="b2e6" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">也就是说，我指的是<code class="fe mq mr ms mt b">.gitignore</code>，</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="b709" class="md kd iq mt b gy ns nt l nu nv">node_modules/<br/>build/<br/>lib/<br/>docs/</span><span id="1bca" class="md kd iq mt b gy nx nt l nu nv">.DS_Store<br/>coverage<br/>*.log<br/>.env</span></pre><p id="08fa" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><code class="fe mq mr ms mt b">tslint.json</code>，</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="28d8" class="md kd iq mt b gy ns nt l nu nv">{<br/> "extends": "tslint:recommended",<br/> "rules": {<br/>   "max-line-length": {<br/>     "options": [120]<br/>   },<br/>   "new-parens": true,<br/>   "no-arg": true,<br/>   "no-bitwise": true,<br/>   "no-conditional-assignment": true,<br/>   "no-consecutive-blank-lines": false,<br/>   "no-console": {<br/>     "severity": "warning",<br/>     "options": ["debug", "info", "log", "time", "timeEnd", "trace"]<br/>   }<br/> },<br/> "jsRules": {<br/>   "max-line-length": {<br/>     "options": [120]<br/>   }<br/> }<br/>}</span></pre><p id="9c83" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><code class="fe mq mr ms mt b">.editorconfig</code>(用于标准化自动套用格式，很像Prettier和<code class="fe mq mr ms mt b">.prettierrc</code>，但更不可知)</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="570c" class="md kd iq mt b gy ns nt l nu nv">root = true</span><span id="e2f2" class="md kd iq mt b gy nx nt l nu nv">[*]<br/>charset = utf-8<br/>end_of_line = lf<br/>indent_size = 2<br/>indent_style = tab<br/>insert_final_newline = true<br/>trim_trailing_whitespace = true</span><span id="ad3c" class="md kd iq mt b gy nx nt l nu nv">[*.md]<br/>max_line_length = 0<br/>trim_trailing_whitespace = true</span></pre><p id="fca4" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">并为<code class="fe mq mr ms mt b">tsconfig.json</code>插入以下内容。这可能看起来有些过分，但是请记住，我们在这里要做的是一个生产级的应用。不要在小事上吝啬。</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="eff7" class="md kd iq mt b gy ns nt l nu nv">{<br/>  "compilerOptions": {<br/>    "target": "es6",<br/>    "module": "commonjs",<br/>    "moduleResolution": "node",<br/>    "declaration": true,<br/>    "strict": true,<br/>    "noImplicitAny": true /* Raise error on expressions and declarations with an implied 'any' type. */,<br/>    "strictNullChecks": true /* Enable strict null checks. */,<br/>    "strictFunctionTypes": true /* Enable strict checking of function types. */,<br/>    "noUnusedLocals": true /* Report errors on unused locals. */,<br/>    "noUnusedParameters": true /* Report errors on unused parameters. */,<br/>    "noImplicitReturns": true /* Report error when not all code paths in function return a value. */,<br/>    "noFallthroughCasesInSwitch": true /* Report errors for fallthrough cases in switch statement. */,<br/>    "importHelpers": true,<br/>    "skipLibCheck": true,<br/>    "esModuleInterop": true,<br/>    "allowSyntheticDefaultImports": true,<br/>    "experimentalDecorators": true,<br/>    "sourceMap": true,<br/>    "outDir": "./dist/tsc/",<br/>    "types": [<br/>      "node",<br/>      "jest"<br/>    ],<br/>    "lib": [<br/>      "ES6",<br/>      "DOM"<br/>    ]<br/>  },<br/>  "include": [<br/>    "src/**/*.ts"<br/>  ],<br/>  "exclude": [<br/>    "node_modules",<br/>    "**/*.test.ts"<br/>  ]<br/>}</span></pre><p id="2f84" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">以及一个<a class="ae mp" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> nodemon </a>配置文件<code class="fe mq mr ms mt b">nodemon.json</code>。我过去使用过这种配置，它被证明非常有用。</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="a63e" class="md kd iq mt b gy ns nt l nu nv">{<br/>  "restartable": "rs",<br/>  "ignore": [".git", "node_modules/", "build/", "coverage/"],<br/>  "watch": ["src/"],<br/>  "execMap": {<br/>    "ts": "node -r ts-node/register"<br/>  },<br/>  "env": {<br/>    "NODE_ENV": "development"<br/>  },<br/>  "ext": "js,json,ts"<br/>}</span></pre><p id="f340" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">让我们也给我们的<code class="fe mq mr ms mt b">package.json</code>添加脚本。在添加了基本的依赖项和这些脚本之后，我们应该会看到:</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="5b65" class="md kd iq mt b gy ns nt l nu nv">{<br/>  "name": "users-service",<br/>  "version": "1.0.0",<br/>  "main": "index.ts",<br/>  "repository": "<a class="ae mp" href="https://github.com/ryanoillataguerre/pfapp/tree/master/services/users-service" rel="noopener ugc nofollow" target="_blank">&lt;https://github.com/ryanoillataguerre/pfapp/tree/master/services/users-service&gt;</a>",<br/>  "author": "Ryan Oillataguerre",<br/>  "license": "MIT",<br/>  "scripts": {<br/>    "start": "node build/src/index.ts",<br/>    "build": "tsc",<br/>    "dev": "nodemon --config nodemon.json src/index.ts"<br/>  },<br/>  "devDependencies": {<br/>    "@types/express": "^4.17.13",<br/>    "@types/node": "^16.0.0",<br/>    "dotenv": "^10.0.0",<br/>    "nodemon": "^2.0.7",<br/>    "ts-node": "^10.0.0",<br/>    "typescript": "^4.3.5",<br/>    "tslint": "^6.1.3"<br/>  },<br/>  "dependencies": {<br/>    "express": "^4.17.1"<br/>  }<br/>}</span></pre><p id="b3fa" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">一旦我们想把我们的应用分发给云提供商，<code class="fe mq mr ms mt b">build</code>和<code class="fe mq mr ms mt b">start</code>将会很有帮助，而<code class="fe mq mr ms mt b">dev</code>将允许我们有效地使用<code class="fe mq mr ms mt b">nodemon</code>并在开发中保持我们的应用热重装。</p><p id="99e9" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在，让我们进入实际的代码。在<code class="fe mq mr ms mt b">src/server.ts</code>和<code class="fe mq mr ms mt b">src/index.ts</code>创建我们的服务器</p><p id="1a44" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><code class="fe mq mr ms mt b">index.ts</code></p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="d0fc" class="md kd iq mt b gy ns nt l nu nv">import dotenv from 'dotenv';<br/>import server from './server';</span><span id="5fca" class="md kd iq mt b gy nx nt l nu nv">dotenv.config();<br/>const port = process.env.PORT || 8080;<br/>server().listen(port);</span></pre><p id="682e" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我喜欢这种模式，因为它为阅读代码的人标记了一个清晰的入口点，并且不会立即用最终将进入这个<code class="fe mq mr ms mt b">server.ts</code>的所有中间件和配置淹没他们。</p><p id="4ba2" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><code class="fe mq mr ms mt b">server.ts</code></p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="4b5e" class="md kd iq mt b gy ns nt l nu nv">import express, { Request, Response } from 'express';<br/>import http from 'http';</span><span id="ad53" class="md kd iq mt b gy nx nt l nu nv">const app = () =&gt; {<br/>  const app = express();</span><span id="3eb0" class="md kd iq mt b gy nx nt l nu nv">  app.use((_: Request, res: Response, next) =&gt; {<br/>    res.header(<br/>      'Access-Control-Allow-Headers',<br/>      'Origin, X-Requested-With, Content-Type, Accept, Credentials, Set-Cookie',<br/>    );<br/>    res.header('Access-Control-Allow-Credentials', 'true');<br/>    res.header(<br/>      'Access-Control-Allow-Headers',<br/>      'Content-Type, Accept, Access-Control-Allow-Credentials, Cross-Origin',<br/>    );<br/>    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');<br/>    next();<br/>  });</span><span id="b984" class="md kd iq mt b gy nx nt l nu nv">  app.use(express.json());</span><span id="8f10" class="md kd iq mt b gy nx nt l nu nv">  // Routes<br/>  app.get('/health', (_, res) =&gt; res.status(200).send({ success: true }));<br/>  // All non-specified routes return 404<br/>  app.get('*', (_, res) =&gt; res.status(404).send('Not Found'));</span><span id="fbae" class="md kd iq mt b gy nx nt l nu nv">  const server = http.createServer(app);</span><span id="fae4" class="md kd iq mt b gy nx nt l nu nv">  server.on('listening', () =&gt; {<br/>    console.info(`Users service listening on port ${process.env.PORT}...`);<br/>  });</span><span id="05a8" class="md kd iq mt b gy nx nt l nu nv">  return server;<br/>};</span><span id="b6fd" class="md kd iq mt b gy nx nt l nu nv">export default app;</span></pre><p id="4257" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">好了，在这里打开包装还真不容易。</p><p id="f65f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">上面的headers部分是我们在响应中设置它们的地方，它将帮助我们以后在服务器和客户端之间来回发送会话cookies时不必处理这么多问题。</p><p id="2198" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们使用<code class="fe mq mr ms mt b">express.json()</code> API来代替以前用于解析JSON POST请求的<code class="fe mq mr ms mt b">bodyParser()</code>。然后，我们声明我们希望Express应用程序使用的路线。这将很快包括我们定制的基于模块的路由，我们将在本系列的下一篇文章中看到如何构建这些路由。</p><p id="df51" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">然后我们为我们的<code class="fe mq mr ms mt b">http</code>服务器创建一个事件监听器并返回它，这样我们就可以在<code class="fe mq mr ms mt b">index.js</code>中<code class="fe mq mr ms mt b">listen</code>它。</p><p id="e560" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在，让我们创建一个<code class="fe mq mr ms mt b">.env</code>文件，由上面的<code class="fe mq mr ms mt b">dotenv.config()</code>命令读取。这将具体地反馈到我们的服务环境中。</p><pre class="nk nl nm nn gt no mt np nq aw nr bi"><span id="723a" class="md kd iq mt b gy ns nt l nu nv">PORT=8080</span></pre><p id="0224" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">最后，让我们启动服务器:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/9b8373a335e4b2c93b6f7b379d010c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XF99mAfK5Fk_DzFYm_iHw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">启动并运行！🎉🎉🎉</figcaption></figure><p id="0335" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">如果有些东西不能正常工作，它可能是一个丢失的文件或一些不匹配的复制粘贴。前往本章分支的<a class="ae mp" href="https://github.com/ryanoillataguerre/pfapp/tree/Chapter_1-Scaffolding" rel="noopener ugc nofollow" target="_blank"> Github repo查看源代码！</a></p><p id="b695" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">在本文中，我们刚刚将一个应用从零代码升级到一个正常工作的节点服务，这将在本系列接下来的章节中构建。我们将在下一篇文章中添加路由、服务、一些实用程序等等。</p><p id="3a52" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><strong class="lc ir"> <em class="ni">将所有代码修改打包成一章后，我需要一些时间来写下一篇文章，所以如果你想在我发布它时保持更新，请在媒体上关注我</em> </strong> <a class="ae mp" href="https://medium.com/@ryanoillataguerre" rel="noopener"> <strong class="lc ir"> <em class="ni">这里</em> </strong> </a>，<strong class="lc ir"> <em class="ni">或者在Twitter上</em> </strong> <a class="ae mp" href="https://twitter.com/roillataguerre" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> <em class="ni">这里</em> </strong> </a> <strong class="lc ir"> <em class="ni">！</em> </strong></p><p id="c0d3" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">这是我的第一篇文章，所以如果你喜欢它，我真的很感谢鼓掌，如果你有这里提到的任何喜欢的工具，一般评论，烘烤，或建议，请在下面评论！</p></div></div>    
</body>
</html>