<html>
<head>
<title>Laravel API Authentication for Social Networks — OAuth2 Social Grant</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向社交网络的Laravel API认证— OAuth2社交授权</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-api-authentication-for-social-networks-oauth2-social-grant-3ec1085b58b6?source=collection_archive---------2-----------------------#2019-04-11">https://itnext.io/laravel-api-authentication-for-social-networks-oauth2-social-grant-3ec1085b58b6?source=collection_archive---------2-----------------------#2019-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6686" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Laravel Passport对您的第一方应用进行社交网络认证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df46ad26e5d2337bb84d701e8c010b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOSjVa1yL9mkSyIWtiksJg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自Pixabay的Gerd Altmann提供</figcaption></figure><p id="989c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">社交网络已经成为我们在线存在的重要组成部分，越来越多的应用程序正在与谷歌和Twitter等流行的社交网络提供商集成，以验证其用户并授权访问资源。社交提供商的名单在不断增长，将他们集成到我们的应用程序中的需求也在不断增加。在本文中，我们将探讨如何在Laravel Passport中构建OAuth2社交网络授权。这将使用户能够使用他们的社交网络帐户在您的API上进行身份验证。</p><p id="3e95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在开始之前，本文假设您熟悉OAuth2，并且了解Laravel Passport的工作原理。如果您没有使用过Passport，Laravel文档是一个很好的起点。</p><div class="lu lv gp gr lw lx"><a href="https://laravel.com/docs/5.8/passport" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">面向网络工匠的PHP框架</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">面向web工匠的PHP框架。</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">laravel.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><h2 id="0770" class="mm mn it bd mo mp mq dn mr ms mt dp mu lh mv mw mx ll my mz na lp nb nc nd ne bi translated">OAuth术语的快速复习</h2><ul class=""><li id="873e" class="nf ng it la b lb nh le ni lh nj ll nk lp nl lt nm nn no np bi translated">资源所有者:可以授权访问受保护资源的实体。通常这是最终用户。</li><li id="d6fb" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">客户端:代表资源所有者请求访问受保护资源的应用程序。</li><li id="a8ea" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">资源服务器:托管受保护资源的服务器。这是API服务器</li><li id="a3c8" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">授权服务器:认证资源所有者并在获得适当授权后发布访问令牌的服务器</li><li id="19d4" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">访问令牌:用于访问资源服务器上受保护资源的令牌。</li></ul></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="5b6c" class="oc mn it bd mo od oe of mr og oh oi mu jz oj ka mx kc ok kd na kf ol kg nd om bi translated">语境</h1><p id="7078" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh on lj lk ll oo ln lo lp op lr ls lt im bi translated"><a class="ae oq" href="http://tools.ietf.org/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> OAuth2规范</a>定义并描述了客户端应用获取访问令牌的多种方式。这个令牌本质上标识了用户访问受保护资源的权限。这些由规范定义的获取访问令牌的方法被称为<strong class="la iu">授权</strong>。</p><p id="a248" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些授权中的每一个都有特定的用例，并且只适合在它们被定义的上下文中使用。该规范没有准确定义社交网络上下文，但它定义了一个与我们的用例足够接近的上下文，即<strong class="la iu">受信任的第一方客户端的资源所有者凭证授权</strong>。<em class="or">展望未来，术语</em> <strong class="la iu"> <em class="or">资源所有者</em> </strong> <em class="or">和</em> <strong class="la iu"> <em class="or">用户</em> </strong> <em class="or">可以互换使用。</em></p><p id="d234" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">传统上，要为第一方客户机验证API上的用户，您需要使用资源所有者凭证授权。这允许您的用户通过提供凭据(通常是用户名和密码)来获得令牌，从而进行身份验证。让我们看看使用这个授权获得令牌的请求格式。</p><p id="4962" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">客户端向授权服务器发送包含以下主体参数的POST请求:</p><ul class=""><li id="f990" class="nf ng it la b lb lc le lf lh os ll ot lp ou lt nm nn no np bi translated">值为<code class="fe ov ow ox oy b">password</code>的<code class="fe ov ow ox oy b">grant_type</code></li><li id="2b02" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">client_id</code>用客户的ID</li><li id="ffea" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">client_secret</code>与客户的秘密</li><li id="bf87" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">username</code>用用户的用户名</li><li id="5e33" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">password</code>用用户的密码</li><li id="8027" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">带有由空格分隔的范围列表。</li></ul><blockquote class="oz pa pb"><p id="6be4" class="ky kz or la b lb lc ju ld le lf jx lg pc li lj lk pd lm ln lo pe lq lr ls lt im bi translated">你会注意到这个授权接受了一个<code class="fe ov ow ox oy b">client_secret</code>，但是有一个关于第一方客户端的安全问题，比如不能安全存储这个的本地应用和spa。这一点的安全含义超出了本文的范围，但是有一些方法可以减轻这一点，比如使用代理后端与授权服务器进行交互。然而，为了演示本文背后的思想，我们将假设第一方客户能够保守秘密。</p></blockquote><p id="ab8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于社交网络来说，使用用户名和密码作为凭证是违反直觉的，并且违背了整合社交认证的初衷。如前所述，规范没有定义社交网络授权，所以我们将自己实现一个。</p><h1 id="f4e1" class="oc mn it bd mo od pf of mr og pg oi mu jz ph ka mx kc pi kd na kf pj kg nd om bi translated">社交网络资助</h1><p id="9407" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh on lj lk ll oo ln lo lp op lr ls lt im bi translated">为了创建我们的社交网络授权，我们可以定制资源所有者凭证授权以适应我们的用例，并根据其结构构建授权。让我们定义使用社交网络身份验证时的典型身份验证流程，这将告诉我们如何定制授权许可并识别可能成为凭据候选的元素。</p><h2 id="b53b" class="mm mn it bd mo mp mq dn mr ms mt dp mu lh mv mw mx ll my mz na lp nb nc nd ne bi translated">流动</h2><ul class=""><li id="5974" class="nf ng it la b lb nh le ni lh nj ll nk lp nl lt nm nn no np bi translated">客户端向社交网络提供商(例如Google)发出请求</li><li id="e9e5" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">用户在提供者上进行身份验证，并获得一个用于获取令牌的临时访问代码</li><li id="2517" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">客户端将该代码交换为访问令牌，并且现在可以使用该访问令牌在所请求的范围内访问社交网络提供商上的受保护资源。</li></ul><p id="c9e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，上一步获得的访问令牌仅对社交网络提供商有效，它不能用于访问我们的资源服务器上受保护的资源。因为我们现在有效地充当了授权服务器，所以我们需要一种方法来认证用户并向他们颁发在我们的资源服务器上有效的访问令牌。在上面的认证流程的最后，我们得到了一个访问令牌，它本质上代表了试图访问我们的API的用户。这个访问令牌现在可以成为用户凭证的一部分。</p><p id="3b38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是访问令牌本身是没有用的，我们知道它是授权给哪个社交网络提供商的。网络<strong class="la iu">提供商</strong>和从该提供商获得的<strong class="la iu"> </strong>接入令牌<strong class="la iu">是用户凭证的两个很好的候选。</strong></p><p id="f167" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经确定了哪些元素应该构成社交网络上下文中的凭证，我们现在可以继续定义请求结构，以便使用我们的定制授权从我们的授权服务器获取访问令牌:</p><ul class=""><li id="51e4" class="nf ng it la b lb lc le lf lh os ll ot lp ou lt nm nn no np bi translated">值为<code class="fe ov ow ox oy b">social</code>的<code class="fe ov ow ox oy b">grant_type</code></li><li id="c918" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">client_id</code>用客户的ID</li><li id="d110" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">client_secret</code>与客户的秘密</li><li id="77d9" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">provider</code>用社会提供者的名字</li><li id="1b36" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated"><code class="fe ov ow ox oy b">access_token</code>使用来自社交提供商的访问令牌</li><li id="b198" class="nf ng it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">带有由空格分隔的范围列表。</li></ul><p id="6ff8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是身份验证过程的图示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/9f58d2d851b7defc4321bdf39efbc5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AV-bWuIec301bDw8UOcPgg.png"/></div></div></figure><h1 id="ac27" class="oc mn it bd mo od pf of mr og pg oi mu jz ph ka mx kc pi kd na kf pj kg nd om bi translated">履行</h1><p id="8f79" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh on lj lk ll oo ln lo lp op lr ls lt im bi translated">现在，我们已经为从授权服务器获取访问令牌的身份验证请求定义了某种可接受的结构，我们可以继续执行这个授权了。首先，我们将安装Laravel passport包。Passport将作为一座桥梁，帮助我们管理我们的客户，生成访问令牌并授权对我们的API的请求。(参见<a class="ae oq" href="https://laravel.com/docs/5.8/passport" rel="noopener ugc nofollow" target="_blank">安装</a>获取说明)我们还需要Laravel<a class="ae oq" href="https://laravel.com/docs/5.8/socialite" rel="noopener ugc nofollow" target="_blank">sociate</a>包来帮助我们在各种社交网络上验证用户。</p><p id="9723" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们安装并配置了Laravel passport和socialite，下一个合乎逻辑的步骤就是创建我们的Social Grant并在授权服务器上启用它，以便它能够响应访问令牌请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="b235" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">授权服务器中的授权实现了<code class="fe ov ow ox oy b">respondToAccessTokenRequest</code> <em class="or"> </em>方法，该方法处理对指定授权的访问令牌的请求。对于我们的目的来说，<code class="fe ov ow ox oy b">validateUser</code>方法是最重要的。</p><p id="705a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个授权中，我们需要一种方法通过用户的访问令牌来检索用户，这意味着验证他们的凭证。该授权依赖于<code class="fe ov ow ox oy b">SocialUserProvider</code>,该<code class="fe ov ow ox oy b">SocialUserProvider</code>针对社交网络提供商验证来自社交网络提供商的给定访问令牌。如果访问令牌无效，<code class="fe ov ow ox oy b">validateUser</code>方法返回一个<code class="fe ov ow ox oy b">UserEntityInterface</code>的实例或者抛出一个<code class="fe ov ow ox oy b">OAuthServerException</code>。SocialUserProvider实现了一个SocialUserProvider接口。该接口声明了一个方法<code class="fe ov ow ox oy b">getUserEntityByAccessToken</code>,用于从提供者那里检索社交用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="9687" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SocialUserProvider实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="8e94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们尝试使用Laravel Socialite通过用户的访问令牌从社交网络提供商那里检索用户。如果操作成功，我们将把社交网络提供商的用户转换成资源服务器上的资源所有者，并将实体返回给授权服务器。如果操作不成功，我们抛出一个<code class="fe ov ow ox oy b">OAuthServerException</code>异常。</p><p id="6d1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们在我们的资源服务器上定义了<code class="fe ov ow ox oy b">UserRepository</code>实现，以从一个社交用户检索或创建一个资源所有者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="f211" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将在服务提供商的授权服务器上启用这种授权，以便它能够响应访问令牌请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="d424" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">授权服务器现在可以向资源所有者发布新的访问和刷新令牌，身份验证流程完成。</p><h1 id="b08f" class="oc mn it bd mo od pf of mr og pg oi mu jz ph ka mx kc pi kd na kf pj kg nd om bi translated">请求所有范围</h1><p id="6806" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh on lj lk ll oo ln lo lp op lr ls lt im bi translated">当您在第一方客户端上对用户进行身份验证时，您可能希望为应用程序支持的所有范围授权访问令牌。对于资源所有者凭证和客户端凭证授权来说尤其如此。因为我们的社会授权是一种资源所有者凭证授权，所以我们可以在授权服务器上启用这种行为，以便它可以根据请求将所有范围授予这种授权类型。为此，我们将在授权服务器上扩展由Laravel passport实现的<code class="fe ov ow ox oy b">ScopeRepository</code>，覆盖<code class="fe ov ow ox oy b">finalizeScopes</code>方法并在授权上注入修改后的<code class="fe ov ow ox oy b">ScopeRepository</code>。<code class="fe ov ow ox oy b">ScopeRepository</code>上的<code class="fe ov ow ox oy b">finalizeScopes</code>方法根据应用程序支持的范围和授权类型过滤范围:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="edc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们本质上只是让所有范围的请求都传递给Passport，并让它处理范围检查。如果范围是星号<code class="fe ov ow ox oy b">*</code>，Passport将允许所有范围。对于此范围，资源服务器上令牌实例的<code class="fe ov ow ox oy b">can</code>方法将始终返回true。由于我们不希望在授权服务器上的所有授权类型上都允许这种行为，而是在社交授权上，所以当我们在服务提供者中启用授权时，我们将只在该授权上设置它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn pm l"/></div></figure><p id="2011" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您感兴趣，可以在Github上找到代码。</p><div class="lu lv gp gr lw lx"><a href="https://github.com/orobogenius/laravel-oauth2-social-grant-demo" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">orobogenius/laravel-oauth 2-social-grant-demo</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">使用Laravel Passport-orobogenius/Laravel-OAuth2-Social-grant-demo验证您的oauth 2服务器上的社交用户</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="po l mi mj mk mg ml ks lx"/></div></div></a></div><h1 id="c59c" class="oc mn it bd mo od pf of mr og pg oi mu jz ph ka mx kc pi kd na kf pj kg nd om bi translated">结论</h1><p id="1238" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh on lj lk ll oo ln lo lp op lr ls lt im bi translated">我们已经讨论了如何在您的OAuth服务器上从第三方应用程序认证社交网络用户。这是通过在授权服务器上创建和启用社会授权类型来实现的。在实践中，这个解决方案并不局限于OAuth，它还可以在OAuth的上下文之外使用，来验证API上的社交网络用户。关键元素是来自提供商的<strong class="la iu">社交网络提供商</strong>和<strong class="la iu">访问令牌</strong>，它们将用于在向用户发放访问令牌(和刷新令牌)之前验证提供商上的用户。</p><p id="85a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读，我希望这篇文章是有帮助的。</p></div></div>    
</body>
</html>