<html>
<head>
<title>Practical guide to securing gRPC connections with Go and TLS — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护gRPC与Go和TLS连接的实用指南—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-2-994ef93b8ea9?source=collection_archive---------3-----------------------#2019-07-22">https://itnext.io/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-2-994ef93b8ea9?source=collection_archive---------3-----------------------#2019-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8cfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@nleiva/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1" rel="noopener">之前的文章</a>中，我们研究了不同的(SSL/TLS)证书组合来保护gRPC通道。随着端点数量的增长，这个过程很快变得过于复杂，无法手动执行。是时候看看如何自动生成我们的gRPC端点可以使用的签名证书，而无需我们的干预。我们将探索私有和公共领域的替代方案。如果你想直接进入代码，查看一下<a class="ae kl" href="https://github.com/nleiva/grpc-tls" rel="noopener ugc nofollow" target="_blank">库</a>。</p><p id="fc67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是三篇系列文章的第二部分。在<a class="ae kl" href="https://medium.com/@nleiva/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1" rel="noopener">第1部分</a>中，我们介绍了手动设置gRPC TLS连接。相互认证将在第3部分讨论。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6e2a6e88bd5d035e7412df3cd0f54ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kyJA1LIxQmCULRdE.jpg"/></div></div></figure><h1 id="b0de" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="ac64" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们将需要一个证书颁发机构(CA ),我们可以从我们的Go gRPC端点进行交互。</p><p id="80e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于私有域，我们选择的CA是<a class="ae kl" href="https://www.vaultproject.io/docs/secrets/pki/index.html" rel="noopener ugc nofollow" target="_blank"> Vault PKI Secrets Engine </a>。为了从我们的gRPC端点生成证书签名请求(CSR)和续订，我们将使用<a class="ae kl" href="https://github.com/johanbrandhorst/certify" rel="noopener ugc nofollow" target="_blank"> Certify </a>。</p><p id="930f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于公共证书的生成和分发，我们将使用<a class="ae kl" href="https://letsencrypt.org/about/" rel="noopener ugc nofollow" target="_blank">来加密</a>；一个免费的、自动化的、开放的认证中心 …这多酷啊！？。他们要求您做的唯一一件事就是用自动证书管理环境(<a class="ae kl" href="https://tools.ietf.org/html/rfc8555" rel="noopener ugc nofollow" target="_blank"> ACME </a>)协议演示对域的控制。这意味着我们需要一个<a class="ae kl" href="https://tools.ietf.org/html/rfc8555" rel="noopener ugc nofollow" target="_blank"> ACME </a>客户端，幸运的是有一个Go <a class="ae kl" href="https://letsencrypt.org/docs/client-options/" rel="noopener ugc nofollow" target="_blank">库列表，我们可以从中选择。在这个机会中，我们将使用</a><a class="ae kl" href="https://godoc.org/golang.org/x/crypto/acme/autocert" rel="noopener ugc nofollow" target="_blank">自动认证</a>的易用性和对<a class="ae kl" href="https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05" rel="noopener ugc nofollow" target="_blank"> TLS-ALPN-01 </a>挑战的支持。</p><h1 id="ef95" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">私有域:保管和认证</strong></h1><h2 id="1f9d" class="mc kz iq bd la md me dn le mf mg dp li jy mh mi lm kc mj mk lq kg ml mm lu mn bi translated"><strong class="ak">跳马</strong></h2><p id="7b0d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Vault是一个秘密管理和数据保护开源项目，它可以存储和控制对证书的访问，以及密码和令牌等其他秘密。它以二进制的形式发布，你可以把它放在你的<code class="fe mo mp mq mr b">$PATH</code>中的任何地方。如果你想了解更多关于Vault的知识，它的<a class="ae kl" href="https://learn.hashicorp.com/vault/" rel="noopener ugc nofollow" target="_blank">入门</a>指南是一个很好的起点。本文使用的所有设置细节都记录在<a class="ae kl" href="https://github.com/nleiva/grpc-tls/blob/master/vault-cert.md#vault" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2cd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们用<code class="fe mo mp mq mr b">vault server -config=vault_config.hcl</code>运行跳马。配置文件(<code class="fe mo mp mq mr b">vault_config.hcl</code>)提供了存储库数据的<code class="fe mo mp mq mr b">storage</code>后端。为了简单起见，我们只使用一个本地文件。您也可以选择将它存储在内存中、云提供商或其他地方。参见<a class="ae kl" href="https://www.vaultproject.io/docs/configuration/storage/index.html" rel="noopener ugc nofollow" target="_blank">存储章节</a>中的所有选项。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="20c2" class="mc kz iq mr b gy mw mx l my mz">storage "file" {<br/>  path = ".../data"<br/>}</span></pre><p id="d264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们指定Vault将绑定到的地址。TLS是默认启用的，所以我们需要提供一个证书和私钥对。如果您选择自签名这些证书(参见<a class="ae kl" href="https://github.com/nleiva/grpc-tls#generating-tsl-certificates" rel="noopener ugc nofollow" target="_blank">这些说明</a>中的一个示例)，请确保您将根证书(<code class="fe mo mp mq mr b">ca.cert</code>)放在手边，稍后您将需要它来请求Vault (*)。其他TCP配置选项记录在<a class="ae kl" href="https://www.vaultproject.io/docs/configuration/listener/tcp.html#tcp-listener-parameters" rel="noopener ugc nofollow" target="_blank"> tcp监听器参数</a>中。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="3c67" class="mc kz iq mr b gy mw mx l my mz">listener "tcp" {<br/>  address     = "localhost:8200"<br/>  tls_cert_file = ".../vault.pem"<br/>  tls_key_file = ".../vault.key"<br/>}</span></pre><p id="3b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://github.com/nleiva/grpc-tls/blob/master/vault-cert.md#initialize-the-server" rel="noopener ugc nofollow" target="_blank">初始化保险库的服务器</a>和<a class="ae kl" href="https://github.com/nleiva/grpc-tls/blob/master/vault-cert.md#unseal-the-vault" rel="noopener ugc nofollow" target="_blank">解封保险库</a>后，你可以验证正在使用API调用。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="bd99" class="mc kz iq mr b gy mw mx l my mz">$ <strong class="mr ir">curl \<br/>    --cacert ca.cert \<br/>    -i </strong><a class="ae kl" href="https://localhost:8200/v1/sys/health" rel="noopener ugc nofollow" target="_blank"><strong class="mr ir">https://localhost:8200/v1/sys/health</strong></a></span><span id="a0ec" class="mc kz iq mr b gy na mx l my mz">HTTP/1.1 200 OK<br/>...</span><span id="d15e" class="mc kz iq mr b gy na mx l my mz">{"initialized":true,"sealed":false,"standby":false, ...}</span></pre><p id="aa8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是用<code class="fe mo mp mq mr b">vault secrets enable pki</code>启用Vault PKI Secrets Engine后端，生成一个CA证书和Vault将用来签署证书的私钥，并创建一个可以对我们的域(<code class="fe mo mp mq mr b">localhost</code>)发出请求的角色(<code class="fe mo mp mq mr b">my-role</code>)。在这里看到所有的<a class="ae kl" href="https://github.com/nleiva/grpc-tls/blob/master/vault-cert.md#enable-vault-pki-secrets-engine-backend" rel="noopener ugc nofollow" target="_blank">细节</a>。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="f7cf" class="mc kz iq mr b gy mw mx l my mz">vault write pki/roles/my-role \<br/>    allowed_domains=localhost \<br/>    allow_subdomains=true \<br/>    max_ttl=72h</span></pre><h2 id="5071" class="mc kz iq bd la md me dn le mf mg dp li jy mh mi lm kc mj mk lq kg ml mm lu mn bi translated"><strong class="ak">认证</strong></h2><p id="e872" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">既然我们的证书颁发机构(CA)已经准备就绪，我们可以向它发出请求，对我们的证书进行签名。如果我们还没有证书，您可能会问哪些证书，以及如何自动告诉我们的gRPC端点使用它们？。进入<a class="ae kl" href="https://github.com/johanbrandhorst/certify" rel="noopener ugc nofollow" target="_blank"> Certify </a>，一个Go库<em class="mb">随时执行证书分发和更新，自动</em>。它不仅可以与作为CA后端的Vault配合使用，还可以与<a class="ae kl" href="https://blog.cloudflare.com/introducing-cfssl/" rel="noopener ugc nofollow" target="_blank"> Cloudflare CFSSL </a>和<a class="ae kl" href="https://aws.amazon.com/certificate-manager/private-certificate-authority/" rel="noopener ugc nofollow" target="_blank"> AWS ACM </a>配合使用。</p><p id="edbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置Certify的第一步是指定后端<code class="fe mo mp mq mr b">issuer</code>，在本例中是Vault。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="cdb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们通过提供以下信息来标识我们的Vault实例和访问凭据:</p><ul class=""><li id="85c8" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">我们为Vault ( <code class="fe mo mp mq mr b">localhost:8200</code>)配置的监听器地址。</li><li id="1df0" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">初始化金库服务器后得到的<code class="fe mo mp mq mr b">TOKEN</code>。</li><li id="6711" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">我们创建的角色(<code class="fe mo mp mq mr b">my-role</code>)。</li><li id="7fad" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">我们在Vault配置中提供的证书颁发者的CA证书。<code class="fe mo mp mq mr b">cp</code>是包含<code class="fe mo mp mq mr b">ca.cert</code>的<code class="fe mo mp mq mr b">x509.CertPool</code>，如(*)所示。</li></ul><p id="8eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以选择通过<code class="fe mo mp mq mr b">CertConfig</code>提供证书细节。在这种情况下，我们使用<code class="fe mo mp mq mr b">RSA</code>算法而不是Certify的默认算法<code class="fe mo mp mq mr b">ECDSA P256</code>为我们的证书签名请求(CSR)生成私钥。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1249" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Certify通过<a class="ae kl" href="https://godoc.org/github.com/johanbrandhorst/certbot#Certify" rel="noopener ugc nofollow" target="_blank"> Certify </a>类型挂钩到<code class="fe mo mp mq mr b">tls.Config</code>的<code class="fe mo mp mq mr b">GetCertificate</code>和<code class="fe mo mp mq mr b">GetClientCertificate</code>方法，我们现在用它来构建；先前收集的信息，防止为每个传入连接请求新证书的<code class="fe mo mp mq mr b">Cache</code> <em class="mb">方法</em>，以及登录插件(本例中为<code class="fe mo mp mq mr b">go-kit/log</code>)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是创建一个指向我们刚刚创建的<code class="fe mo mp mq mr b">Certify</code>的<code class="fe mo mp mq mr b">GetCertificate</code>方法的<code class="fe mo mp mq mr b">tls.Config</code>。然后，在我们的gRPC服务器中使用这个配置。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在将环境变量<code class="fe mo mp mq mr b">CAFILE</code>指向Vault的证书文件(<code class="fe mo mp mq mr b">ca-vault.cert</code>)后，您可以通过在一个选项卡中运行<code class="fe mo mp mq mr b">make run-server-vault</code>并在另一个选项卡中运行<code class="fe mo mp mq mr b">make run-client-ca</code>来重现这一点，您可以如下获得:</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="f3f0" class="mc kz iq mr b gy mw mx l my mz">$ curl \<br/>    --cacert ca.cert \<br/>    <a class="ae kl" href="https://localhost:8200/v1/pki/ca/pem" rel="noopener ugc nofollow" target="_blank">https://localhost:8200/v1/pki/ca/pem</a> \<br/>    -o ca-vault.cert</span></pre><p id="13a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器:</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="fe36" class="mc kz iq mr b gy mw mx l my mz">$ <strong class="mr ir">make run-server-vault</strong><br/>...<br/>level=debug time=<strong class="mr ir">2019-07-15</strong>T19:37:12.694833Z caller=logger.go:36 server_name=localhost remote_addr=[::1]:64103 msg="<strong class="mr ir">Getting server certificate</strong>"<br/>level=debug time=2019-07-15T19:37:12.694936Z caller=logger.go:36 msg="<strong class="mr ir">Requesting new certificate from issuer</strong>"<br/>level=debug time=2019-07-15T19:37:12.815081Z caller=logger.go:36 serial=451331845556263599050597627925015657462097174315 expiry=2019-07-18T19:37:12Z msg="<strong class="mr ir">New certificate issued</strong>"<br/>level=debug time=2019-07-15T<strong class="mr ir">19:37:12</strong>.815115Z caller=logger.go:36 serial=451331845556263599050597627925015657462097174315 took=120.284897ms msg="<strong class="mr ir">Certificate found</strong>"</span></pre><p id="1e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户:</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="0e8f" class="mc kz iq mr b gy mw mx l my mz">$ <strong class="mr ir">export CAFILE="ca-vault.cert"</strong><br/>$ <strong class="mr ir">make run-client-ca</strong><br/>...<br/>User found:  Nicolas</span></pre><p id="5771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查我们生成并自动签名的证书，将揭示我们刚刚配置的一些细节。</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="70cb" class="mc kz iq mr b gy mw mx l my mz">$ <strong class="mr ir">openssl x509 -in grpc-cert.pem -text -noout</strong><br/>Certificate:<br/>    Data:<br/>    ...<br/>        Validity<br/>            Not Before: <strong class="mr ir">Jul 15</strong> 19:36:42 2019 GMT<br/>            Not After : Jul 18 <strong class="mr ir">19:37:12</strong> 2019 GMT<br/>        Subject: CN=<strong class="mr ir">localhost</strong><br/>        Subject Public Key Info:<br/>            Public Key Algorithm: <strong class="mr ir">rsaEncryption</strong><br/>                Public-Key: (<strong class="mr ir">2048 bit</strong>)<br/>                Modulus:<br/>                    00:bf:3c:a3:d8:8c:d8:3c:d0:bd:0c:e0:4c:9d:4d:<br/>                    ...<br/>        X509v3 extensions:<br/>            ...<br/>            Authority Information Access:<br/>                <strong class="mr ir">CA Issuers - URI:</strong><a class="ae kl" href="https://localhost:8200/v1/pki/ca" rel="noopener ugc nofollow" target="_blank"><strong class="mr ir">https://localhost:8200/v1/pki/ca</strong></a></span><span id="8283" class="mc kz iq mr b gy na mx l my mz">X509v3 Subject Alternative Name:<br/>                DNS:localhost, DNS:<strong class="mr ir">localhost</strong>, IP Address:<strong class="mr ir">127.0.0.1</strong>, IP Address:<strong class="mr ir">0:0:0:0:0:0:0:1</strong></span></pre><h1 id="4a43" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">公共领域:让我们加密并自动插入</strong></h1><h2 id="a881" class="mc kz iq bd la md me dn le mf mg dp li jy mh mi lm kc mj mk lq kg ml mm lu mn bi translated">让我们加密</h2><p id="f680" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以用<a class="ae kl" href="https://letsencrypt.org/about/" rel="noopener ugc nofollow" target="_blank">让我们为gRPC加密</a>吗？。嗯，对我来说确实有用。问题可能是面向公众的gRPC API是否是一个好主意。Google Cloud好像在做，见<a class="ae kl" href="https://github.com/googleapis/googleapis" rel="noopener ugc nofollow" target="_blank">Google API</a>。然而，这并不是很常见的做法。无论如何，这里是我如何能够公开一个带有证书的公共gRPC API，我们自动从Let's Encrypt中获得证书。</p><p id="0e6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要强调的是，此示例并不是要复制给内部/私有服务。在与《让我们加密》的雅各布·霍夫曼-安德鲁斯交谈时，他提到:</p><blockquote class="nr ns nt"><p id="1379" class="jn jo mb jp b jq jr js jt ju jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj kk ij bi translated"><em class="iq">总的来说，我建议大家不要对gRPC或者其他内部RPC服务使用Let's加密证书。在我看来，使用类似于</em><a class="ae kl" href="https://github.com/jsha/minica/" rel="noopener ugc nofollow" target="_blank"><em class="iq">minica</em></a><em class="iq">的东西来生成一个单一用途的内部CA，并用它来生成服务器和客户端证书，既容易又安全。这样，您就不必向外部互联网开放您的RPC服务器，另外，您将信任范围限制在内部RPC所需的范围内，另外，您可以拥有更长的证书生命周期，另外，您还可以获得有效的撤销。</em></p></blockquote><p id="a661" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb"> Let's Encrypt使用ACME协议来验证证书申请人合法地代表证书中的域名。它还为其他证书管理功能(如证书吊销)提供了便利。ACME描述了一个可扩展的框架，用于自动化颁发和域验证过程，从而允许服务器和基础设施软件在没有用户交互的情况下获得证书</em>。[ <a class="ae kl" href="https://tools.ietf.org/html/rfc8555" rel="noopener ugc nofollow" target="_blank"> RFC 8555 </a></p><p id="cf5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，为了利用Let's Encrypt，我们需要做的就是运行一个<a class="ae kl" href="https://letsencrypt.org/docs/client-options/" rel="noopener ugc nofollow" target="_blank"> ACME客户端</a>。在本例中，我们将使用<a class="ae kl" href="https://godoc.org/golang.org/x/crypto/acme" rel="noopener ugc nofollow" target="_blank">自动插入</a>。</p><h2 id="276e" class="mc kz iq bd la md me dn le mf mg dp li jy mh mi lm kc mj mk lq kg ml mm lu mn bi translated">自动认证</h2><p id="ea8d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">autocert包<em class="mb">提供了对来自Let's Encrypt和任何其他基于ACME的CA </em>的证书的自动访问。然而，请记住<em class="mb">这个包还在开发中，并没有做出API稳定性的承诺</em>。[ <a class="ae kl" href="https://godoc.org/golang.org/x/crypto/acme/autocert" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="a8a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就代码需求而言，第一步是声明一个带有<code class="fe mo mp mq mr b">Prompt</code>的<code class="fe mo mp mq mr b">Manager</code>，表明<em class="mb">在帐户注册</em>期间接受CA的服务条款；一个<code class="fe mo mp mq mr b">Cache</code>方法<em class="mb">，用于存储和检索以前获得的证书</em>(在本例中为本地文件系统上的目录)；一个<code class="fe mo mp mq mr b">HostPolicy</code>，其中包含我们可以响应的域列表；以及可选的<code class="fe mo mp mq mr b">Email</code> <em class="mb">地址，用于通知所颁发证书的问题</em>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a29b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个<code class="fe mo mp mq mr b">Manager</code>将自动为我们创建一个TLS配置，负责与Let's Encrypt的交互。另一方面，客户端只需要一个指向空的<code class="fe mo mp mq mr b">tls</code>配置(<code class="fe mo mp mq mr b">&amp;tls.Config{}</code>)的指针，默认情况下，它将加载系统CA证书，因此信任我们的CA(让我们加密)。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8ce3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在密切关注，您可能已经注意到我们在这个例子中没有包括侦听器部分。原因在于ACME基于TLS的挑战TLS-ALPN-01是如何工作的。<em class="mb">带应用层协议协商的TLS(TLS ALPN)验证方法通过要求客户端配置TLS服务器来响应特定的连接尝试，利用带有识别信息的ALPN扩展来证明对域名的控制</em>。【<a class="ae kl" href="https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05#page-3" rel="noopener ugc nofollow" target="_blank">draft-IETF-acme-TLS-alpn-05</a>】。</p><blockquote class="nr ns nt"><p id="2a5f" class="jn jo mb jp b jq jr js jt ju jv jw jx nu jz ka kb nv kd ke kf nw kh ki kj kk ij bi translated">顺便提一下，在Let's Encrypt宣布所有TLS-SNI-01验证支持终止后，autocert <a class="ae kl" href="https://github.com/golang/crypto/commit/c126467f60eb25f8f27e5a981f32a87e3965053f" rel="noopener ugc nofollow" target="_blank">增加了对TLS-ALPN-01 </a>的支持。</p></blockquote><p id="75d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，我们需要倾听HTTPS的请求。好消息是<a class="ae kl" href="https://godoc.org/golang.org/x/crypto/acme/autocert#NewListener" rel="noopener ugc nofollow" target="_blank"> autocert </a>覆盖了你，可以用<code class="fe mo mp mq mr b">manager.Listener()</code>创建这个特殊的<a class="ae kl" href="https://godoc.org/golang.org/x/crypto/acme/autocert#NewListener" rel="noopener ugc nofollow" target="_blank">监听器</a>。现在，问题是HTTPS和gRPC是否应该监听同一个端口？。长话短说，我无法让它与独立端口一起工作，但是如果两个服务都监听443，它就可以完美地工作。</p><p id="be5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC和HTTPS在同一个端口…说什么！？。我知道，你能做并不意味着你应该做。然而，Go gRPC库提供了<code class="fe mo mp mq mr b">ServeHTTP</code>方法，可以帮助我们将传入的请求路由到相应的服务。<em class="mb">注意</em> <code class="fe mo mp mq mr b"><em class="mb">ServeHTTP</em></code> <em class="mb">使用Go的</em> <code class="fe mo mp mq mr b"><em class="mb">HTTP/2</em></code> <em class="mb">服务器实现，与grpc-go的</em> <code class="fe mo mp mq mr b"><em class="mb">HTTP/2</em></code> <em class="mb">服务器完全分开。两种路径的性能和特性可能有所不同</em>。[ <a class="ae kl" href="https://godoc.org/google.golang.org/grpc#Server.ServeHTTP" rel="noopener ugc nofollow" target="_blank"> go-grpc </a> ]。您可以在<a class="ae kl" href="https://github.com/grpc/grpc-go/issues/586" rel="noopener ugc nofollow" target="_blank"> gRPC serveHTTP性能损失</a>中看到一些基准测试。话虽如此，路由将如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9f03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以按如下方式监听请求，请注意，我们将刚刚创建的处理程序<code class="fe mo mp mq mr b">grpcHandlerFunc</code>提供给了<code class="fe mo mp mq mr b">http.Serve</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d2b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过在一个选项卡中运行<code class="fe mo mp mq mr b">make run-server-public</code>并在另一个选项卡中运行<code class="fe mo mp mq mr b">make run-client-default</code>来重现这种情况。为此，您需要拥有一个域(<code class="fe mo mp mq mr b">HOST</code>)。在我的案例中，我使用了:</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="02a3" class="mc kz iq mr b gy mw mx l my mz">export HOST=grpc.nleiva.com<br/>export PORT=443<br/>make run-server-public</span></pre><p id="a2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我可以通过互联网从世界任何地方发出gRPC请求:</p><pre class="kn ko kp kq gt ms mr mt mu aw mv bi"><span id="79a4" class="mc kz iq mr b gy mw mx l my mz">$ export HOST=grpc.nleiva.com<br/>$ export PORT=443<br/>$ make run-client-default<br/>User found:  Nicolas</span></pre><p id="05e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以看看通过HTTPS请求生成的证书。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/14f2dc953e45f9cb3e5730b9ff81de7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxVurHGrQSrNRwV6RkMaWg.png"/></div></div></figure><h1 id="a0c6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="71ef" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果您利用了本文中讨论的一些资源，为gRPC端点管理和分发证书应该不是一件麻烦的事情。</p><p id="e97a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，虽然连接已经加密，并且客户端已经验证了服务器的完整性，但是服务器还没有对客户端进行身份验证。对于一些微服务场景，这可能是必需的，我们将在本博客系列的下一部分讨论Mutual TLS。敬请期待！</p><p id="989b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="dc7f" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated"><a class="ae kl" href="https://learn.hashicorp.com/vault/secrets-management/sm-pki-engine" rel="noopener ugc nofollow" target="_blank">使用Vault建立您自己的认证中心</a></li><li id="7c84" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><a class="ae kl" href="https://jbrandhorst.com/post/certify/" rel="noopener ugc nofollow" target="_blank">通过保险库自动分发TLS证书</a></li><li id="8342" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><a class="ae kl" href="https://letsencrypt.org/2019/03/11/acme-protocol-ietf-standard.html" rel="noopener ugc nofollow" target="_blank">ACME协议是IETF标准</a></li><li id="4f72" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><a class="ae kl" href="https://medium.com/@nleiva/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1" rel="noopener">保护gRPC与Go和TLS连接的实用指南—第1部分</a></li><li id="fbf1" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">保护gRPC与Go和TLS连接的实用指南—第3部分</li></ul><p id="2715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我要感谢<a class="ae kl" href="https://twitter.com/x1ddos" rel="noopener ugc nofollow" target="_blank">亚历克斯</a>、<a class="ae kl" href="https://twitter.com/j4cob" rel="noopener ugc nofollow" target="_blank">雅各布</a>和<a class="ae kl" href="https://twitter.com/JohanBrandhorst" rel="noopener ugc nofollow" target="_blank">约翰</a>对这篇文章的帮助，并让我保持诚实。</p></div></div>    
</body>
</html>