<html>
<head>
<title>Node.js CI with Tekton Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Tekton管道的Node.js CI</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-ci-with-tekton-pipelines-15381e7034c6?source=collection_archive---------2-----------------------#2019-11-25">https://itnext.io/node-js-ci-with-tekton-pipelines-15381e7034c6?source=collection_archive---------2-----------------------#2019-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/81a37f58f8ba8c085180af58849a2d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bkpy1eJ7PXqNaOdT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Andrea Jaime 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9a76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天，Kubernetes是一个了不起的管弦乐队，而Tekton是最新的本地CI/CD集群解决方案之一，而且，依我看，这种组合是惊人的。</p><p id="fc5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的职业生涯中，多年来我一直在逐步接受DevOps实践，使用不同的工具和应用不同的方法。</p><p id="f963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我突然检查了Tekton Pipelines，嘣，它解决了我过去遇到的所有问题(我可以说出几十个)，从管道中的重复到任务的依赖性。</p><p id="224f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这几行代码并不关注Tekton是什么，而是关注如何使用它来实现与Node.js代码库的持续集成(当然，它可以扩展到您使用的任何堆栈)。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="8fa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的案例是一个简单的Nuxt应用程序，它需要为我们的CI执行以下步骤:</p><ul class=""><li id="c777" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">依赖项安装</li><li id="de6b" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">潜在漏洞的审计</li><li id="f112" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">林挺</li><li id="5e4f" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">单元测试</li><li id="b376" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">建筑物</li></ul><p id="576b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们设置指向Git存储库的Tekton资源，在本例中是<a class="ae kc" href="https://github.com/cdbkr/nuxt" rel="noopener ugc nofollow" target="_blank">https://github.com/cdbkr/nuxt</a>。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">资源. yaml</figcaption></figure><p id="233a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的文件中，我们声明了将在任务/管道中使用的资源(git repo)。</p><p id="a92f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们在Tekton任务中使用这个资源:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Task.yaml</figcaption></figure><p id="705f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我解释一下Tekton任务规范的结构。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><ul class=""><li id="1fa9" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">在<code class="fe mc md me mf b">Inputs</code>中，我们用声明的Git repo指定连接；</li><li id="13ea" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">在<code class="fe mc md me mf b">Steps</code>中，我们指定了一组需要执行的连续步骤；</li></ul><p id="5048" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们来看一下与常见Node.js应用程序紧密相关的步骤:</p><ul class=""><li id="9c91" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated"><code class="fe mc md me mf b">npm install</code>安装依赖项；</li><li id="fbf2" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><code class="fe mc md me mf b">npm audit</code>用已安装的依赖项检查漏洞；</li><li id="88dc" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><code class="fe mc md me mf b">npm run lint</code>运行皮棉检查；</li><li id="8ae0" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><code class="fe mc md me mf b">npm run test</code>运行单元测试；</li><li id="f800" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><code class="fe mc md me mf b">npm run build</code>构建我们的应用程序包；</li></ul><p id="5094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当这些步骤中的一个将失败时，执行将被终止(例如，如果NPM在已安装的依赖项中发现了一些漏洞，我们不想继续进行)。</p><p id="4667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我们只需要执行任务，为此，我们有几个选项:</p><ul class=""><li id="a196" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">它允许我们执行单个任务；</li><li id="9479" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated"><code class="fe mc md me mf b">PipelineRun</code>:它允许我们执行一组定义好的任务，并在<code class="fe mc md me mf b">Pipeline</code>资源定义中指定；</li></ul><p id="17a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这个例子非常简单，所以我们将使用TaskRun，它触发一个包含容器/步骤的Pod来执行。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦执行并正确验证，我们就可以检查用</p><pre class="lw lx ly lz gt mg mf mh mi aw mj bi"><span id="a4d9" class="mk ml iq mf b gy mm mn l mo mp">+ kubectl get pods<br/>NAME                        READY   STATUS            RESTARTS   AGE<br/>nodejs-taskrun-pod-67caed   6/6     Running           0          11s</span></pre><p id="fa72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后:</p><pre class="lw lx ly lz gt mg mf mh mi aw mj bi"><span id="517d" class="mk ml iq mf b gy mm mn l mo mp">+ kubectl get pods -w<br/>NAME                        READY   STATUS    RESTARTS   AGE<br/>nodejs-taskrun-pod-67caed   6/6     Running   0          11s<br/>nodejs-taskrun-pod-67caed   5/6     Running   0          52s<br/>nodejs-taskrun-pod-67caed   4/6     Running   0          53s<br/>nodejs-taskrun-pod-67caed   3/6     Running   0          55s<br/>nodejs-taskrun-pod-67caed   2/6     Running   0          58s<br/>nodejs-taskrun-pod-67caed   1/6     Running   0          64s<br/>nodejs-taskrun-pod-67caed   0/6     Completed   0          81s</span><span id="96c0" class="mk ml iq mf b gy mq mn l mo mp">----</span><span id="a170" class="mk ml iq mf b gy mq mn l mo mp">+ kubectl get taskruns<br/>NAME             SUCCEEDED   REASON      STARTTIME   COMPLETIONTIME<br/>nodejs-taskrun   True        Succeeded   2m4s        43s</span></pre><p id="331f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不错！因此，每个步骤都作为一个单独的容器执行，TaskRun资源用执行的状态标记，在本例中为Success:)。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="1f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常简单的例子，说明了如何用一个公共Node.js项目运行CI。通过这种方式，你可以想象有多少事情可以实现:</p><ul class=""><li id="8902" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">跨运行重用声明的任务和管道</li><li id="f10d" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">隔离步骤/容器之间的依赖关系(是的，可以为每个步骤使用不同的图像)。例如，在特定环境下运行E2E测试(在Docker映像中进行沙箱化)，在依赖于不同技术堆栈的给定库上进行安全测试，执行需要特殊映像的脚本等…</li></ul><p id="35e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能让您了解如何使用Tekton Pipelines完成这项常见任务，在下一篇文章中，我将展示如何在这项工作的基础上实现连续部署。如果您感兴趣并想了解更多，请查看以下两个资源:</p><div class="mr ms gp gr mt mu"><a href="https://github.com/tektoncd/catalog" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">tektoncd/目录</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">这个存储库包含一个任务资源(将来还有管道和资源)的目录，它被设计成…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jw mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a href="https://github.com/jenkins-x" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">詹金斯X</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">Kubernetes - Jenkins X上现代云应用的CI/CD解决方案</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni jw mu"/></div></div></a></div><p id="150f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！:)</p></div></div>    
</body>
</html>