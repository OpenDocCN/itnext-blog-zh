<html>
<head>
<title>Enhanced Object Literal Value Shorthand: JavaScript ES6 Feature Series (Pt 6)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强的对象文字值速记:JavaScript ES6特性系列(Pt 6)</h1>
<blockquote>原文：<a href="https://itnext.io/enhanced-object-literal-value-shorthand-javascript-es6-feature-series-pt-6-e00dfdc24f64?source=collection_archive---------1-----------------------#2019-09-29">https://itnext.io/enhanced-object-literal-value-shorthand-javascript-es6-feature-series-pt-6-e00dfdc24f64?source=collection_archive---------1-----------------------#2019-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="35fc" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">因为在一个对象中输入同样的东西两次是疯狂的</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4640210c7263bff19126a58b9efe4b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPN1TMIK_kHoVBcQLKErYA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">凯文·Ku在<a class="ae lb" href="https://unsplash.com/s/photos/focus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6a8b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="afc9" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi ma translated">这些帖子背后的灵感很简单:对于很多开发人员来说，JavaScript并没有太大的意义——或者至少有时令人困惑。</p><p id="67a7" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">根据维基百科的数据，截至2017年5月，JavaScript为1000万个最受欢迎的网页中的近95%提供了支持。</p><p id="67cc" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">由于JS对web的贡献如此之大，我想提供一些我经常使用的ES6+特性的文章和例子，供其他开发人员参考。</p><p id="7d43" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我们的目标是让这些文章简短、深入地解释该语言的各种改进，我希望这些文章能启发您使用JS编写一些真正酷的东西。谁知道呢，在这个过程中你可能会学到一些新东西。😄</p><blockquote class="mo"><p id="292a" class="mp mq iq bd mr ms mt mu mv mw mx lz dk translated"><em class="my">我在这个系列中的第六篇帖子将是关于ES2015引入的新的对象属性和方法值简写，这是迄今为止从变量初始化对象属性和定义函数的最简洁的方法。</em></p></blockquote></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="4270" class="jn jo iq bd jp jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk bi translated">对象:JavaScript中的一切都是一体的</h1><p id="df9d" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">谈到JavaScript，您可能听说过这样一句话:“JavaScript中的一切都是对象。”函数、字符串、数组、对象——它们都是对象。也可以是别的，但是除了原语，其他的也都是JS里的对象。</p><p id="097c" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">然而，这篇文章关注的是对象对象；通常使用<code class="fe nl nm nn no b">new Object()</code>、<code class="fe nl nm nn no b">Object.create()</code>或文字符号初始化器进行初始化。</p><p id="93bd" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在了解ES2015带来的新变化之前，让我们先来看看这些变化。</p><p id="7b7e" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">对象初始化器示例:</strong> <code class="fe nl nm nn no b"><strong class="le ir">new Object()</strong></code></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="40e4" class="nt jo iq no b gy nu nv l nw nx">// object initialization options</span><span id="154e" class="nt jo iq no b gy ny nv l nw nx">// object constructor<br/>function Pet(type, name, age, greeting) {<br/>  this.breed = type;<br/>  this.name = name;<br/>  this.age = age;<br/>  this.greeting = greeting;<br/>  this.sayHello = function () {<br/>    return `${this.name} says 'hello' as ${this.greeting}`;<br/>  }<br/>}</span><span id="cbd2" class="nt jo iq no b gy ny nv l nw nx">// new Object()<br/>const pet1 = new Pet("cat", "Felina", 3, "meow");<br/>console.log(pet1);</span><span id="86a1" class="nt jo iq no b gy ny nv l nw nx">/* prints: Pet {<br/>breed: 'cat',<br/>name: 'Felina',<br/>age: 3,<br/>greeting: 'meow',<br/>sayHello: [Function] } */</span><span id="0a74" class="nt jo iq no b gy ny nv l nw nx">console.log(pet1.sayHello());<br/>// prints: Felina says 'hello' as meow</span></pre><p id="840e" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">第一个例子展示了如何使用<code class="fe nl nm nn no b">new Object()</code>关键字创建一个对象。首先，定义一个名为<code class="fe nl nm nn no b">Pet</code>的对象构造函数，它接受许多参数，甚至有自己的方法<code class="fe nl nm nn no b">sayHello()</code>。</p><p id="c8c1" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">然后，声明变量<code class="fe nl nm nn no b">pet1</code>,调用<code class="fe nl nm nn no b">new Pet()</code>,并向其传递适当的参数。瞧——当您调用它或它的方法<code class="fe nl nm nn no b">pet1.sayHello()</code>时，一个名为<code class="fe nl nm nn no b">pet1</code>的新对象就存在了。</p><p id="b08e" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">对象初始化器示例:</strong> <code class="fe nl nm nn no b"><strong class="le ir">Object.create()</strong></code></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="bf12" class="nt jo iq no b gy nu nv l nw nx">// Object.create()<br/>const pet2 = Object.create(pet1);<br/>pet2.breed = "dog";<br/>pet2.name = "Rufus";<br/>pet2.age = 4;<br/>pet2.greeting = "woof";</span><span id="0bde" class="nt jo iq no b gy ny nv l nw nx">console.log(pet2);<br/>/* prints: Pet {<br/>breed: 'dog',<br/>name: 'Rufus',<br/>age: 4,<br/>greeting: 'woof' } */</span><span id="ec54" class="nt jo iq no b gy ny nv l nw nx">console.log(pet2.sayHello());<br/>// prints: Rufus says 'hello' as woof</span></pre><p id="d190" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">上面的第二个例子演示了如何使用<code class="fe nl nm nn no b">Object.create()</code>初始化器。此选项要求已存在的对象作为新创建对象的原型。</p><p id="36c0" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在这个例子中，<code class="fe nl nm nn no b">pet2</code>以第一个例子中的<code class="fe nl nm nn no b">pet1</code>为原型。然后，<code class="fe nl nm nn no b">pet2</code>给来自<code class="fe nl nm nn no b">pet1</code>的所有属性赋予新的值，它也从<code class="fe nl nm nn no b">pet1</code>继承了方法<code class="fe nl nm nn no b">sayHello()</code>。</p><p id="a3b1" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">所以当<code class="fe nl nm nn no b">pet2.sayHello()</code>被调用时，它打印出<code class="fe nl nm nn no b">"Rufus says 'hello' as woof"</code>。就这么简单。</p><p id="554a" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">对象初始化器示例:对象文字</strong> <code class="fe nl nm nn no b"><strong class="le ir">{}</strong></code></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="e159" class="nt jo iq no b gy nu nv l nw nx">// object literal initialization<br/>const pet3 = {<br/>  type: "guinea pig",<br/>  name: "Holly",<br/>  age: 6,<br/>  greeting: "snuffle",<br/>  sayHello: function() {<br/>    return `${this.name} says 'hello' as ${this.greeting}`<br/>  }<br/>}</span><span id="8949" class="nt jo iq no b gy ny nv l nw nx">console.log(pet3);<br/>/* prints: { type: 'guinea pig',<br/>name: 'Holly',<br/>age: 6,<br/>greeting: 'snuffle',<br/>sayHello: [Function] } */</span><span id="465b" class="nt jo iq no b gy ny nv l nw nx">console.log(pet3.sayHello());<br/>// prints: Holly says 'hello' as snuffle</span><span id="fecf" class="nt jo iq no b gy ny nv l nw nx">// object literal property and method assignment by variables<br/>const type = "fish";<br/>const name = "Nemo";<br/>const age = 2;<br/>const greeting = "bloop";<br/>function sayHello() {<br/>  return `${this.name} says 'hello' as ${this.greeting}`;<br/>}</span><span id="06a6" class="nt jo iq no b gy ny nv l nw nx">const pet4 = {<br/>  type: type,<br/>  name: name,<br/>  age: age,<br/>  greeting: greeting,<br/>  sayHello: sayHello<br/>}</span><span id="fbe7" class="nt jo iq no b gy ny nv l nw nx">console.log(pet4);<br/>/* prints: { type: 'fish',<br/>name: 'Nemo',<br/>age: 2,<br/>greeting: 'bloop',<br/>sayHello: [Function: sayHello] } */</span><span id="7e73" class="nt jo iq no b gy ny nv l nw nx">console.log(pet4.sayHello()); <br/>// prints: Nemo says 'hello' as bloop</span></pre><p id="1d67" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">到目前为止，这个最终的对象初始化是日常编码中最常用的:对象文字初始化。</p><p id="8b93" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">有两种方法可以做到:</p><ol class=""><li id="f69c" class="nz oa iq le b lf mj lj mk ln ob lr oc lv od lz oe of og oh bi translated">通过声明对象并同时分配它的所有属性和方法来初始化它:就像<code class="fe nl nm nn no b">pet3</code>。</li><li id="140a" class="nz oa iq le b lf oi lj oj ln ok lr ol lv om lz oe of og oh bi translated">通过提前声明任何变量和函数，然后将它们分配给一个新的对象，比如<code class="fe nl nm nn no b">pet4</code>。</li></ol><p id="ec70" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">无论你选择怎样做，这两种方法都是完全可以接受的，并且经常使用。</p><blockquote class="mo"><p id="bdbd" class="mp mq iq bd mr ms mt mu mv mw mx lz dk translated">特别是对象文字，这是ECMAScript 2015显著改进的地方，让我们看看如何改进。</p></blockquote><h2 id="f041" class="nt jo iq bd jp on oo dn jt op oq dp jx ln or os kb lr ot ou kf lv ov ow kj ox bi translated">速记属性名</h2><p id="e04a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">ES2015在对象文字方面改进的第一件事是对象内属性的缩写初始化，前提是属性键与现有变量名匹配。这被大多数人称为:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Property_definitions" rel="noopener ugc nofollow" target="_blank">简写属性名</a>。</p><p id="d783" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">为对象属性分配变量的传统语法</strong></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="484f" class="nt jo iq no b gy nu nv l nw nx">// traditional object property assignment<br/>const breed = "chinchilla";<br/>const howOld = 1;<br/>const nickname = "Chi Chi";<br/>const activities = "dust baths";<br/>function funFact() {<br/>  return `${this.nickname}'s fun fact is she likes ${this.activities}`;<br/>}</span><span id="84d2" class="nt jo iq no b gy ny nv l nw nx">const exoticPet = {<br/>  breed: breed,<br/>  nickname: nickname,<br/>  howOld: howOld,<br/>  activities: activities,<br/>  funFact: funFact<br/>};</span><span id="71d6" class="nt jo iq no b gy ny nv l nw nx">console.log(exoticPet);<br/>/* { breed: 'chinchilla',<br/>nickname: 'Chi Chi',<br/>howOld: 1,<br/>activities: 'dust baths',<br/>funFact: [Function: funFact] } */</span><span id="67ea" class="nt jo iq no b gy ny nv l nw nx">console.log(exoticPet.funFact()); <br/>// prints: Chi Chi's fun fact is she likes dust baths</span></pre><p id="3a31" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">以上是将变量赋给对象属性的传统方式。当属性已经与变量名匹配时，创建<code class="fe nl nm nn no b">exoticPet</code>似乎需要很多额外的输入，不是吗？</p><p id="9a53" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">让我们在下一个例子中修复冗余。</p><p id="c0f5" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir"> ES2015将同名变量分配给对象属性的简写示例</strong></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="38fa" class="nt jo iq no b gy nu nv l nw nx">// es2015 shorthand object property assignment<br/>const otherBreed = "alpaca";<br/>const firstName = "Alfie";<br/>const likes = "frolicking";<br/>function timeSpent() {<br/>  return `${this.firstName} enjoys ${this.likes} whenever he can.`;<br/>}</span><span id="d86e" class="nt jo iq no b gy ny nv l nw nx">const exoticPet2 = {<br/>  otherBreed,<br/>  firstName,<br/>  likes,<br/>  timeSpent<br/>};</span><span id="e373" class="nt jo iq no b gy ny nv l nw nx">console.log(exoticPet2);<br/>/* { otherBreed: 'alpaca',<br/>firstName: 'Alfie',<br/>likes: 'frolicking',<br/>timeSpent: [Function: timeSpent] } */</span><span id="c2bb" class="nt jo iq no b gy ny nv l nw nx">console.log(exoticPet2.timeSpent());<br/>// prints: Alfie enjoys frolicking whenever he can.</span></pre><p id="7eeb" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">如您所见，<code class="fe nl nm nn no b">exoticPet2</code>的语法比前一个例子清晰得多。由于<code class="fe nl nm nn no b">exoticPet2</code>的属性名与上面声明的变量相匹配:<code class="fe nl nm nn no b">otherBreed</code>、<code class="fe nl nm nn no b">firstName</code>等等，你可以简单地声明一次属性名，ES2015就知道如何将同名的变量插入到对象中。</p><p id="09ae" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">很巧妙的把戏，是吧？我真的很欣赏ES6改进的这个特别的细节。我经常使用它。</p><p id="9c60" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><em class="oy">注意:</em>注意不要为你的属性使用相同的名字，第二个属性会覆盖第一个属性。</p><p id="f625" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">注意:重复的属性采用最后的赋值</strong></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="79c8" class="nt jo iq no b gy nu nv l nw nx">// duplicate properties assume the last value assigned</span><span id="034a" class="nt jo iq no b gy ny nv l nw nx">const exoticPet3 = { type: "parrot", type: "cockatoo"};<br/>console.log(exoticPet3.type); // prints: cockatoo</span></pre><h2 id="c84c" class="nt jo iq bd jp on oz dn jt op pa dp jx ln pb os kb lr pc ou kf lv pd ow kj ox bi translated">速记方法定义</h2><p id="35b1" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">接下来我们对ES2015的对象文字的改进:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Method_definitions" rel="noopener ugc nofollow" target="_blank">方法速记定义</a>。方法定义速记语法省略了<code class="fe nl nm nn no b">function</code>关键字和冒号，就像属性赋值一样。</p><p id="7bfd" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">在对象中创建方法(函数)的传统语法</strong></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="efa5" class="nt jo iq no b gy nu nv l nw nx">// traditional method definitions<br/>const person = {<br/>  play: function() {<br/>    return "I like to play board games with my friends.";<br/>  },<br/>  swim: function() {<br/>    return "When I exercise, I like to swim laps in the pool.";<br/>  }<br/>};</span><span id="beaf" class="nt jo iq no b gy ny nv l nw nx">console.log(person.play()); // prints: I like to play board games with my friends.</span><span id="795a" class="nt jo iq no b gy ny nv l nw nx">console.log(person.swim()); // prints: When I exercise, I like to swim laps in the pool.</span></pre><p id="a7a4" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在传统的JavaScript中，方法(附加到对象上的函数)类似于普通的对象属性，在对象上用类似于<code class="fe nl nm nn no b">play</code>或<code class="fe nl nm nn no b">swim</code>的属性名声明，然后用传统的匿名函数声明语法<code class="fe nl nm nn no b">function() { /* ...do something here */ };</code>赋值。</p><p id="7b51" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">然后，对象的方法可以像它的属性一样被调用:<code class="fe nl nm nn no b">person.play()</code>或<code class="fe nl nm nn no b">person.swim()</code>。那里没有什么惊天动地的事情。</p><p id="d504" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">但是真的有人很喜欢匿名函数吗？那鸿除了不必要的代码之外，它似乎没有增加太多，如果我们现在对传统函数有简洁的箭头函数表达式，为什么不对对象方法也做一些类似的事情呢？</p><p id="574c" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir"> ES2015在对象中创建方法(函数)的简写</strong></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="1419" class="nt jo iq no b gy nu nv l nw nx">// es2015 shorthand method definitions<br/>const person2 = {<br/>  play() {<br/>    return "I like to play the violin in my free time.";<br/>  },<br/>  swim() {<br/>    return "Swimming in the ocean is my favorite thing to do at the beach.";<br/>  }<br/>};</span><span id="51ce" class="nt jo iq no b gy ny nv l nw nx">console.log(person2.play()); // prints: I like to play the violin in my free time.</span><span id="0723" class="nt jo iq no b gy ny nv l nw nx">console.log(person2.swim()); // prints: Swimming in the ocean is my favorite thing to do at the beach</span></pre><p id="1e4f" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">介绍用于对象文字符号的ES2015方法简写。<code class="fe nl nm nn no b">person2</code>对象有两个类似于<code class="fe nl nm nn no b">person1</code>、<code class="fe nl nm nn no b">play()</code>和<code class="fe nl nm nn no b">swim()</code>的方法，正如您所看到的，对象本身的声明缺少<code class="fe nl nm nn no b">function</code>关键字，取而代之的是属性名和函数名。</p><p id="05da" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">更干净，更简洁，老实说，当我阅读这样编写的代码时，它对我来说比旧的匿名函数更有意义。</p><p id="e894" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">好了，到了最后一个ES2015对象文字改进的时候了:计算属性名。</p><h2 id="455e" class="nt jo iq bd jp on oz dn jt op pa dp jx ln pb os kb lr pc ou kf lv pd ow kj ox bi translated">计算属性名</h2><p id="976a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从ECMAScript 2015开始，对象初始值设定项语法支持计算属性名。该特性允许您将表达式放在括号<code class="fe nl nm nn no b">[]</code>中，该表达式将被计算并用作属性名。</p><p id="2c41" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir"> ES2015通过括号符号计算属性键/名称的简写</strong></p><pre class="km kn ko kp gt np no nq nr aw ns bi"><span id="9c36" class="nt jo iq no b gy nu nv l nw nx">// computed property names / keys<br/>let i = 1;<br/>const items = {<br/>  ['item' + i++] : i,<br/>  ['otherItem' + i++] : i,<br/>  ['aThirdItem' + i++] : i<br/>}</span><span id="3652" class="nt jo iq no b gy ny nv l nw nx">console.log(items); // prints: { item1: 2, otherItem2: 3, aThirdItem3: 4 }</span></pre><p id="18d7" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">老实说，我在日常生活中从未使用过这种计算属性名功能，但是如果情况需要，知道它的存在是很好的，对吗？</p><p id="0262" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">仅此而已。这就是从ES2015开始你需要了解的JavaScript中的对象字面量。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="fb77" class="jn jo iq bd jp jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk bi translated">结论</h1><p id="8677" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">随着时间的推移，所有JS开发人员都已经熟悉了这种语言的许多怪癖和缺陷，但是最近，ECMAScript委员会每年都会发布JavaScript语言的新更新，旨在使我们的生活更加轻松。一些更新的语法变化看起来比其他的更奇怪，但我很高兴地说，我们如何处理对象文字的改进比大多数更类似于旧的语法。</p><p id="6e9c" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">令人高兴的是，这些变化产生了简洁的对象，可以更容易地为它们分配变量、方法甚至新的计算属性名。非常棒。</p><p id="cbf5" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我写这个博客系列的目的是深入到目前使用的JavaScript和ES6语法中我最喜欢的部分，并向您展示如何使用最好的部分来获得最大的效果。</p><p id="da39" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西。</p><p id="4f84" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">感谢您的阅读，我希望您能够使用这种新的对象文字速记来使您自己的JavaScript对象在未来变得更加紧凑和易于管理。</p><p id="b5cb" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</strong></p><ul class=""><li id="1921" class="nz oa iq le b lf mj lj mk ln ob lr oc lv od lz pe of og oh bi translated"><a class="ae lb" href="https://medium.com/better-programming/string-template-literals-javascript-es6-feature-series-pt-5-a40e55a5485b" rel="noopener">字符串模板文字:JavaScript ES6特性系列(Pt 5) </a></li><li id="537c" class="nz oa iq le b lf oi lj oj ln ok lr ol lv om lz pe of og oh bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f"> Spread &amp; Rest参数:JavaScript ES6特性系列(Pt 4) </a></li><li id="0569" class="nz oa iq le b lf oi lj oj ln ok lr ol lv om lz pe of og oh bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12">默认函数参数值:JavaScript ES6特性系列(Pt 3) </a></li></ul></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="bf85" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">参考资料和更多资源:</strong></p><ul class=""><li id="8426" class="nz oa iq le b lf mj lj mk ln ob lr oc lv od lz pe of og oh bi translated">对象文字符号，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Operators/Object _ initializer</a></li><li id="643b" class="nz oa iq le b lf oi lj oj ln ok lr ol lv om lz pe of og oh bi translated">对象属性定义速记，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Property_definitions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Operators/Object _ initializer # Property _ definitions</a></li><li id="37a4" class="nz oa iq le b lf oi lj oj ln ok lr ol lv om lz pe of og oh bi translated">对象方法定义速记，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Method_definitions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Operators/Object _ initializer # Method _ definitions</a></li></ul></div></div>    
</body>
</html>