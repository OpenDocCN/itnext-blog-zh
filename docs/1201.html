<html>
<head>
<title>Ultimate Localization of React (Mobx) App with i18next</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用i18next实现React (Mobx)应用程序的最终本地化</h1>
<blockquote>原文：<a href="https://itnext.io/ultimate-localization-of-react-mobx-app-with-i18next-efab77712149?source=collection_archive---------1-----------------------#2018-08-10">https://itnext.io/ultimate-localization-of-react-mobx-app-with-i18next-efab77712149?source=collection_archive---------1-----------------------#2018-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0b7fbc965bf6fb0f8d6f5d45002de868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QHHSf3WoVbwuQ29jKxKgA@2x.png"/></div></div></figure><h1 id="c5b8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么？</h1><p id="956c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最近，我不得不为我的React Mobx web应用程序添加一个本地化版本。我想要避免的是从头开始编写区域解析机制的代码(在我的生活中又一次)。</p><p id="4eb4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我真的很累，因为:</p><ul class=""><li id="a32c" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">龙<code class="fe mi mj mk ml b">.json</code>文件</li><li id="a244" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated">检查<code class="fe mi mj mk ml b">navigator.language</code></li><li id="7b85" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated">将<code class="fe mi mj mk ml b">en-US</code>转换为<code class="fe mi mj mk ml b">en</code></li><li id="9c62" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated">做类似乏味的事情</li></ul><p id="282c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我一直在寻找一个解决方案，可以让我专注于我的代码——但似乎我已经找到了一个，实际上超出了我的预期。</p><p id="4f27" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">向<a class="ae mr" href="https://www.i18next.com/" rel="noopener ugc nofollow" target="_blank">i18下一个</a>问好！</p><h1 id="03d4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">i18下一步</h1><p id="3e17" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">它不仅仅是一个翻译和多元化价值的图书馆，还有更多的功能。它是完成所有这些工作的框架，为您提供完整的本地化解决方案。</p><p id="a22b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在阅读它的文档时，我对它的功能印象深刻。从其他方面来看，文档对我来说似乎很复杂，而且我不得不检查一些设置在实际应用中意味着什么。所以我决定写这篇文章作为一个小知识库。</p><p id="b105" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在开始之前，我想提一下i18next是纯JavaScript解决方案。所以你可以用它搭配任何你喜欢的框架(<a class="ae mr" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>、<a class="ae mr" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>、<a class="ae mr" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>)。</p><h1 id="880d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">反应和i18下一步</h1><p id="e513" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">i18next有一个强大的插件和连接器系统，可以连接到你正在使用的框架。当我们谈论React app时，我们将不得不使用两个主要库:</p><ul class=""><li id="1e1d" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><a class="ae mr" href="https://www.i18next.com/" rel="noopener ugc nofollow" target="_blank">i18下一个</a>实际上是本地化框架</li><li id="be42" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated"><a class="ae mr" href="https://react.i18next.com/" rel="noopener ugc nofollow" target="_blank">React-i18下一个</a>为您的<a class="ae mr" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>应用程序设置绑定</li></ul><p id="8729" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就像<a class="ae mr" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"> mobx </a>和<a class="ae mr" href="https://github.com/mobxjs/mobx-react" rel="noopener ugc nofollow" target="_blank"> mobx-react </a>或者<a class="ae mr" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> redux </a>和<a class="ae mr" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a>一样。</p><h1 id="de06" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我们开始吧</h1><p id="4127" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，您必须将这两个依赖项添加到您的应用程序中。</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="aa9b" class="na jz iq ml b gy nb nc l nd ne">npm install i18next react-i18next</span></pre><p id="84be" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我建议创建一个名为<code class="fe mi mj mk ml b">i18n.js</code>的单独文件，我们将为您的本地化过程保存配置。它将在开始时很小，但会随着你添加越来越多的配置选项和插件而增长。所以我们从这样的东西开始。</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="7674" class="na jz iq ml b gy nb nc l nd ne">/<br/> - i18n.js<br/> - index.jsx</span></pre><p id="9099" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">文件的内容看起来像:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="3d51" class="na jz iq ml b gy nb nc l nd ne">// i18n.js</span><span id="2552" class="na jz iq ml b gy nf nc l nd ne">import i18n from 'i18next';</span><span id="cddd" class="na jz iq ml b gy nf nc l nd ne">i18n.init({<br/>  debug: true,<br/>  <br/>  lng: 'en-US',</span><span id="7a42" class="na jz iq ml b gy nf nc l nd ne">  resources: {<br/>    'en-US':{<br/>      'translation': {<br/>        intro: 'Hello my name is'<br/>      }<br/>    }<br/>  },</span><span id="b3ec" class="na jz iq ml b gy nf nc l nd ne">  react: {<br/>    wait: false,<br/>    bindI18n: 'languageChanged loaded',<br/>    bindStore: 'added removed',<br/>    nsMode: 'default'<br/>  }<br/>});</span><span id="6a1f" class="na jz iq ml b gy nf nc l nd ne">export default i18n;</span><span id="fcdb" class="na jz iq ml b gy nf nc l nd ne">// index.jsx</span><span id="0c32" class="na jz iq ml b gy nf nc l nd ne">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import { I18nextProvider, withNamespaces } from 'react-i18next';</span><span id="54d3" class="na jz iq ml b gy nf nc l nd ne">import i18n from './i18n.js';</span><span id="fd05" class="na jz iq ml b gy nf nc l nd ne">@withNamespaces()<br/>class App extends React.Component {<br/>  render() {<br/>    const { t } = this.props;</span><span id="c989" class="na jz iq ml b gy nf nc l nd ne">    return (<br/>      &lt;span&gt;{t('intro')} Viktor&lt;/span&gt;<br/>    );<br/>  }<br/>}</span><span id="85be" class="na jz iq ml b gy nf nc l nd ne">ReactDOM.render((<br/>  &lt;I18nextProvider i18n={i18n}&gt;<br/>    &lt;App /&gt;<br/>  &lt;/I18nextProvider&gt;<br/>  ), document.getElementById('mount')<br/>);</span></pre><p id="b64d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="ng">执行后，我们会看到一个网页，上面写着“你好，我叫维克多”</em></p><p id="1501" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我解释一下刚刚发生的事情🤷🏻‍♂️</p><p id="96ba" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了在你的应用中使用i18next，它需要被初始化。<code class="fe mi mj mk ml b">i18n.init()</code>用于此。方法接受大量不同的属性。但是我们将在这里集中讨论我们擅长开始更标准的方法。</p><ul class=""><li id="d15d" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">debug: true</code> —在开发过程中非常有用，它记录控制台关于i18next状态的所有信息。比如初始化的时候，设置了什么语言，如果某些翻译丢失了就发出通知。<em class="ng">生产中考虑切换为</em> <code class="fe mi mj mk ml b"><em class="ng">false</em></code> <em class="ng">。如果使用webpack设置</em> <code class="fe mi mj mk ml b"><em class="ng">NODE_ENV</em></code> <em class="ng">变量并像使用</em> <code class="fe mi mj mk ml b"><em class="ng">debug: process.env.NODE_ENV === 'development'</em></code> <em class="ng">一样使用它。</em></li><li id="3ff3" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">lng: 'en-US'</code> —要使用的初始语言。稍后我们将看到如何动态地识别语言，避免在init上硬编码。</li><li id="481e" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">resources</code> —翻译的捆绑称为资源。可以在<code class="fe mi mj mk ml b">init</code>方法中定义它们，在运行时用<code class="fe mi mj mk ml b">i18n.addResourceBundle</code>方法加载它们，或者让它们(我喜欢这一部分)基于所选语言异步获取。你应该传递一个下一个结构的对象<code class="fe mi mj mk ml b">{localeName: {namespaceName: {key: 'value'}}</code>默认名称空间是<code class="fe mi mj mk ml b">translation</code>，所以我在例子中传递了它。</li></ul><blockquote class="nh ni nj"><p id="9ec3" class="kw kx ng ky b kz lu lb lc ld lv lf lg nk lw lj lk nl lx ln lo nm ly lr ls lt ij bi translated">名称空间是i18next的一个非常酷的特性。它允许您将翻译转移到单独的文件中。因此，您可以按页面加载翻译，而不是一次下载巨大的<code class="fe mi mj mk ml b">.json</code>文件并阻止您的web应用程序内容出现。因为本文的目标只是给出本地化的鸟瞰图——我们将只使用默认名称空间(<code class="fe mi mj mk ml b">translation</code>)。</p></blockquote><ul class=""><li id="adb2" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">react</code> —是一个具有react-18next插件配置属性的对象。我相信没有人能比<a class="ae mr" href="https://react.i18next.com/components/i18next-instance" rel="noopener ugc nofollow" target="_blank">官方文件</a>解释得更好了。在上面的例子中，它使用默认值。如果您不打算更改它们，只需省略i18next init的<code class="fe mi mj mk ml b">react</code>属性。</li></ul><p id="f4b3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在<code class="fe mi mj mk ml b">index.jsx</code>你也可以看到一些不同之处:</p><ul class=""><li id="0594" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">I18nextProvider</code> —这是<code class="fe mi mj mk ml b">react-i18next</code>库暴露的组件。它接受一个属性<code class="fe mi mj mk ml b">i18n</code>和你的实例<code class="fe mi mj mk ml b">i18n</code>。检查我们是否在开始时导入了它。<code class="fe mi mj mk ml b">I18nextProvider</code>是一个<a class="ae mr" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文提供者</a>。允许上下文消费者通过React上下文接收一些附加参数。</li><li id="2bcc" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">@withNamespaces()</code> —我可爱的部分。装饰器<code class="fe mi mj mk ml b">withNamespaces</code>也是从<code class="fe mi mj mk ml b">react-i18next</code>库中导入的。基本上这是一个<a class="ae mr" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">反应高阶组件</a>。传递给组件2的附加属性。<code class="fe mi mj mk ml b">t</code>功能和<code class="fe mi mj mk ml b">i18n</code>实例。</li><li id="92e0" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">t</code> —调用函数<code class="fe mi mj mk ml b">t('intro')</code>将检查<code class="fe mi mj mk ml b">intro</code>键的翻译是否存在于所选语言中(在我们的例子中为<code class="fe mi mj mk ml b">en-US</code>)，以及<em class="ng">默认的</em>名称空间(<code class="fe mi mj mk ml b">translation</code>)。如果找到资源，这将输出一个翻译，或者将返回一个键。<em class="ng">注:如果您处于调试模式，您将在浏览器控制台中看到一条消息，说明未找到翻译</em>。</li></ul><h1 id="fd8c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">动态获取用户语言</h1><p id="cd2a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当然我们不想在<code class="fe mi mj mk ml b">i18n</code>的<code class="fe mi mj mk ml b">init</code>方法中硬编码用户区域设置。更重要的是，我们不想写代码来解决这个问题。图书馆可以帮助我们。所以…</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="89f9" class="na jz iq ml b gy nb nc l nd ne">npm install i18next-browser-languagedetector</span></pre><p id="fe85" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们对<code class="fe mi mj mk ml b">i18n.js</code>文件做一些修改</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="bbd1" class="na jz iq ml b gy nb nc l nd ne">// i18n.js</span><span id="5213" class="na jz iq ml b gy nf nc l nd ne">import i18n from 'i18next';<br/>import LanguageDetector from 'i18next-browser-languagedetector';</span><span id="f716" class="na jz iq ml b gy nf nc l nd ne">i18n.use(LanguageDetector)<br/>.init({<br/>  debug: true,</span><span id="4847" class="na jz iq ml b gy nf nc l nd ne">  resources: <br/>    'en-US':{<br/>      'translation': {<br/>        intro: 'Hello my name is'<br/>      }<br/>    }<br/>  }<br/>});</span><span id="dee1" class="na jz iq ml b gy nf nc l nd ne">export default i18n;</span></pre><p id="9d0a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们已经删除了<code class="fe mi mj mk ml b">lng: 'en-US'</code>并添加了一个调用特殊<code class="fe mi mj mk ml b">i18n</code>方法<code class="fe mi mj mk ml b">use</code>。这个函数用于为<code class="fe mi mj mk ml b">i18n.</code>加载额外的插件，所以在这种情况下，我们受益于<a class="ae mr" href="https://github.com/i18next/i18next-browser-languageDetector" rel="noopener ugc nofollow" target="_blank"> LanguageDetector </a>插件。它检查多个地方，并为您解析用户区域设置。</p><blockquote class="nh ni nj"><p id="45f5" class="kw kx ng ky b kz lu lb lc ld lv lf lg nk lw lj lk nl lx ln lo nm ly lr ls lt ij bi translated">我们还删除了依赖默认值的<code class="fe mi mj mk ml b">react</code>属性</p></blockquote><h1 id="e8d7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从外部位置加载翻译文件</h1><p id="47e7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">没有人在项目源代码中保存长的<code class="fe mi mj mk ml b">.json</code>翻译文件。大多数情况下，它们都是独立的文件(可能会放在CDN上，所以不会和你的源代码放在一起)。让我们看看如何上传一个正确的。</p><p id="7cc3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将再次受益于<code class="fe mi mj mk ml b">i18next</code>可插拔架构。</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="2ce5" class="na jz iq ml b gy nb nc l nd ne">npm install i18next-xhr-backend;</span></pre><p id="457b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">并做一些代码修改</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="3bfa" class="na jz iq ml b gy nb nc l nd ne">// i18n.js</span><span id="cb38" class="na jz iq ml b gy nf nc l nd ne">import i18n from 'i18next';<br/>import XHR from 'i18next-xhr-backend';<br/>import LanguageDetector from 'i18next-browser-languagedetector';</span><span id="442d" class="na jz iq ml b gy nf nc l nd ne">i18n<em class="ng">.use(XHR)<br/></em>.use(LanguageDetector)<br/>.init({<br/>  debug: true<br/>});</span><span id="951e" class="na jz iq ml b gy nf nc l nd ne">export default i18n;</span></pre><p id="4843" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">应用<code class="fe mi mj mk ml b">XHR</code>插件后。我们可以在开发工具的网络选项卡中看到3个额外的请求。</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="b6cb" class="na jz iq ml b gy nb nc l nd ne">http://app.com/locales/en-US/translation.json<br/>http://app.com/locales/en/translation.json<br/>http://app.com/locales/dev/translation.json</span><span id="b2ed" class="na jz iq ml b gy nf nc l nd ne">// pattern looks like<br/>/locales/{language}/{namespace}.json</span></pre><p id="d358" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我问自己的第一个问题是“什么是<code class="fe mi mj mk ml b">dev</code>语言？”。但在小范围阅读后，它碰巧是i18next的一个未被发现的酷功能。</p><ul class=""><li id="4799" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">保存缺失— i18n可以将缺失的翻译保存为<code class="fe mi mj mk ml b">dev</code>语言，稍后您的翻译人员可以使用它来编写正确的英语短语和其他翻译。</li><li id="69a2" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated">语言(和名称空间)回退—如果在<code class="fe mi mj mk ml b">en-US</code>语言中找不到您的翻译，将在<code class="fe mi mj mk ml b">en</code>语言中进行检查。(以及之后的<code class="fe mi mj mk ml b">dev</code>)。</li></ul><blockquote class="nh ni nj"><p id="ff48" class="kw kx ng ky b kz lu lb lc ld lv lf lg nk lw lj lk nl lx ln lo nm ly lr ls lt ij bi translated">对于生产来说，最好不要使用<code class="fe mi mj mk ml b">dev</code>语言。您可以通过向<code class="fe mi mj mk ml b">i18n.init({ fallbackLng: 'en' })</code>传递附加参数来控制这一点。这也将把对语言文件的请求量减少到2。</p></blockquote><p id="7bfd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">甚至还有更大的调整潜力。许多应用程序只运行少数语言环境，并且只使用语言代码，如<code class="fe mi mj mk ml b">en</code>跳过区域代码<code class="fe mi mj mk ml b">US</code>。如果这适用于你的情况。使用<code class="fe mi mj mk ml b">i18n.init({ load: 'languageOnly' })</code>。您将只看到一个对本地文件的http请求。</p><p id="2304" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然，您可以更改加载翻译文件的路径</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="9060" class="na jz iq ml b gy nb nc l nd ne">// i18n.js</span><span id="fab4" class="na jz iq ml b gy nf nc l nd ne">const backendOpts = {<br/>  loadPath: `myCusomPathToLocales/{{lng}}/{{ns}}.json`<br/>}</span><span id="9a3e" class="na jz iq ml b gy nf nc l nd ne">i18n.init({<br/>  backend: backendOpts<br/>})</span></pre><blockquote class="nh ni nj"><p id="9575" class="kw kx ng ky b kz lu lb lc ld lv lf lg nk lw lj lk nl lx ln lo nm ly lr ls lt ij bi translated">提示:您可以使用webpack 中的<code class="fe mi mj mk ml b"><a class="ae mr" href="https://webpack.js.org/guides/public-path/" rel="noopener ugc nofollow" target="_blank">publicPath</a></code>T21来构建本地文件的正确路径。例如cdn。</p></blockquote><h1 id="c807" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">编写翻译文件</h1><p id="c1c4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你的翻译文件是纯<code class="fe mi mj mk ml b">.json</code>文件。最酷的是i18next支持开箱即用的嵌套。因此，您可以在翻译文件中创建有意义的结构，而不是纯粹的1级深度列表</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="c4a0" class="na jz iq ml b gy nb nc l nd ne">// locales/en-US/translation.json</span><span id="338d" class="na jz iq ml b gy nf nc l nd ne">{<br/>  "common": {<br/>    "confirm": "Confirm",<br/>    "cancel": "Cancel"<br/>  },<br/>  "question": "Use i18next?"<br/>}<br/></span><span id="f856" class="na jz iq ml b gy nf nc l nd ne">// App.jsx</span><span id="2f50" class="na jz iq ml b gy nf nc l nd ne">@withNamespaces()<br/>class App extends React.Component {<br/>  render() {<br/>    const { t } = this.props;</span><span id="dbb4" class="na jz iq ml b gy nf nc l nd ne">    return (<br/>      &lt;span&gt;{t('question')}&lt;/span&gt;<br/>      &lt;button&gt;{t('common.confirm')}&lt;/button&gt;<br/>      &lt;button&gt;{t('common.cancel')}&lt;/button&gt;    <br/>    );<br/>  }<br/>}</span></pre><h1 id="186b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用Mobx更改区域设置</h1><p id="60dd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Mobx提供了一种奇妙的可能性，可以在一些可观察的属性发生变化后，在应用程序中产生副作用。我们将用它们来转换语言。假设我们在<code class="fe mi mj mk ml b">appStore.locale</code>属性中保存了用户选择的区域设置。</p><p id="0c7e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那么反应会是这样的:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="db61" class="na jz iq ml b gy nb nc l nd ne">// index.jsx</span><span id="46d0" class="na jz iq ml b gy nf nc l nd ne">reaction(<br/>  () =&gt; appStore.locale,<br/>  locale =&gt; {<br/>    i18n.changeLanguage(locale);<br/>  }<br/>);</span></pre><p id="8f9a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">令人惊叹的是，新的翻译将被异步加载。所有React组件都将重新呈现，以新语言显示文本。没有更多丑陋的整页重新加载🎉！</p><h1 id="4d82" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">真实的例子</h1><p id="4aec" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">点击查看真实用例示例<a class="ae mr" href="https://codesandbox.io/s/n5jmk0q69j" rel="noopener ugc nofollow" target="_blank">。不要忘记打开控制台来跟踪正在发生的事情。</a></p><h1 id="ee09" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">准备好上钩了吗？</h1><blockquote class="nh ni nj"><p id="177b" class="kw kx ng ky b kz lu lb lc ld lv lf lg nk lw lj lk nl lx ln lo nm ly lr ls lt ij bi translated">注意:该功能还处于试验阶段，因此API可能会发生变化，您可能会遇到意想不到的行为。在遵循这个方法之前，验证您的React版本是<code class="fe mi mj mk ml b">16.7.0-alpha</code>和react-i18next <code class="fe mi mj mk ml b">8.2.0</code>或更高版本。</p></blockquote><p id="6a84" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如你所知，从<code class="fe mi mj mk ml b">v 16.7.0-alpha</code>开始，React团队引入了一个叫做<a class="ae mr" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>的新概念，旨在简化你如何在组件间重用有状态逻辑的方法。以及惊人的快速反馈(不到24小时😲)来自i18next战队。因此，如果你准备尝试一些真正前沿的东西，你可以用react-i18next钩子来本地化你的应用程序:</p><pre class="ms mt mu mv gt mw ml mx my aw mz bi"><span id="a239" class="na jz iq ml b gy nb nc l nd ne"><em class="ng">// i18n.js</em></span><span id="cd4f" class="na jz iq ml b gy nf nc l nd ne">import i18n from 'i18next';<br/>import XHR from 'i18next-xhr-backend';<br/>import LanguageDetector from 'i18next-browser-languagedetector';<br/><strong class="ml ir">import { initReactI18n } from 'react-i18next/hooks';</strong></span><span id="b9f7" class="na jz iq ml b gy nf nc l nd ne">i18n<em class="ng">.use(XHR)<br/></em>.use(LanguageDetector)<br/><strong class="ml ir">.use(initReactI18n)</strong><br/>.init({<br/>  debug: true<br/>});</span><span id="07fa" class="na jz iq ml b gy nf nc l nd ne">export default i18n;</span><span id="9608" class="na jz iq ml b gy nf nc l nd ne"><em class="ng">// index.jsx</em></span><span id="2ab4" class="na jz iq ml b gy nf nc l nd ne">import React from 'react';<br/>import ReactDOM from 'react-dom';<strong class="ml ir"><br/>import { useTranslation } from 'react-i18next/hooks';</strong></span><span id="2892" class="na jz iq ml b gy nf nc l nd ne">import './i18n.js'; // you still need it in bundle</span><span id="0b9b" class="na jz iq ml b gy nf nc l nd ne">function App() {<br/>  <strong class="ml ir">const [t, i18next] = useTranslation();</strong></span><span id="443b" class="na jz iq ml b gy nf nc l nd ne">  return &lt;span&gt;{t('intro')} Viktor&lt;/span&gt;;<br/>}</span><span id="f771" class="na jz iq ml b gy nf nc l nd ne">ReactDOM.render((<br/>    &lt;App /&gt;<br/>  ), document.getElementById('mount')<br/>);</span></pre><ul class=""><li id="972e" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">use(initReactI18n)</code>——通过调用这个插件，在初始化阶段——我们使i18next实例可用于<code class="fe mi mj mk ml b">useTranslation</code>挂接任何React组件</li><li id="3487" class="lz ma iq ky b kz mm ld mn lh mo ll mp lp mq lt me mf mg mh bi translated"><code class="fe mi mj mk ml b">useTranslation()</code> — i18next React Hook，一个为你的功能组件提供<code class="fe mi mj mk ml b">t</code>函数(我们已经很熟悉了)和i18next实例的函数</li></ul><p id="c0ba" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您不会不同意使用这种方法代码看起来更干净。此外，它给你更多的好处。在这一点上，我们的<code class="fe mi mj mk ml b">App</code>功能组件不再用<code class="fe mi mj mk ml b">@withNamespaces</code> HOC包装——所以当你为了测试对它进行浅层渲染时，可以很容易地观察到它的结构。你可以去看看。</p><h1 id="5bc8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">包扎</h1><p id="de8e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">i18next是一个非常有趣和强大的本地化应用程序的解决方案。它允许大量的定制和调整。用一系列插件和工具使基础设施饱和。</p><p id="b85f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本指南仅涵盖i18next广泛功能中的小部分基本功能。因此，请查看它的<a class="ae mr" href="https://www.i18next.com/" rel="noopener ugc nofollow" target="_blank">文档</a>以获得更深入的信息。</p><h1 id="0a3c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">感谢阅读！如果你喜欢这篇文章，我会真诚地感谢你点击鼓掌👏按钮或分享这个故事。您的反馈非常重要！</h1></div></div>    
</body>
</html>