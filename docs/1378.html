<html>
<head>
<title>Redux-Observable will solve your state problems.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux-Observable会解决你的状态问题。</h1>
<blockquote>原文：<a href="https://itnext.io/redux-observable-can-solve-your-state-problems-15b23a9649d7?source=collection_archive---------1-----------------------#2018-09-30">https://itnext.io/redux-observable-can-solve-your-state-problems-15b23a9649d7?source=collection_archive---------1-----------------------#2018-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0c3564055976fffcf39757ee7c29f4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_TpLRw1UrAjjBEAh"/></div></div></figure><div class=""/><div class=""><h2 id="6ef1" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">解决常见的异步状态问题</h2></div><p id="618d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每个使用Redux的人最终都会发现自己需要一种方法来处理异步动作。有很多选择，最大的名字是<a class="ae lm" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux-Thunk </a>，其次是<a class="ae lm" href="https://www.npmjs.com/package/redux-saga" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>和<a class="ae lm" href="https://www.npmjs.com/package/redux-observable" rel="noopener ugc nofollow" target="_blank"> Redux-Observable </a>。</p><p id="19cf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Redux-Observable是一个非常强大的使用RxJS的Redux中间件。使用<strong class="ks jc"> Redux-Observable需要知道或学习RxJS </strong>，这本身就是一个大麻烦。当我第一次开始使用这些工具时，花了相当多的时间和大量的实验来找出一个好的过程。</p><p id="8427" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我没有强迫其他人经历同样的事情，而是创造了一堆有用的入门史诗，你可以用在你的项目中。虽然这些将是<strong class="ks jc">更简单的例子</strong>(相对陈述)，但是你应该能够<strong class="ks jc">弄清楚RxJS的基础</strong>以及它如何与Redux-Observable联系起来供你自己使用。</p><h1 id="832c" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">什么是可重复观测的</h1><p id="d520" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">Redux-Observable抽象出与Redux store的连接，并为您处理订阅，因此您不必担心监听动作或自己调度它们。</p><p id="b71f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在一个非常基本的层面上，当它同时订阅你所有的史诗(可观察的管道)时，它调用Redux的<code class="fe mk ml mm mn b">dispatch</code>函数，就像这样:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="e52b" class="mw lo jb mn b gy mx my l mz na">allYourObservablesTogether<br/>.subscribe(store.dispatch)</span></pre><p id="8163" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为Redux-Observable只调度动作，所以如何处理副作用可能不是很明显。</p><h1 id="794d" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">副作用</h1><p id="4fa1" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">先说副作用。有时你需要连接到第三方库，比如聊天客户端、登录平台或分析服务。为此，您几乎总是要调用他们的非Redux库。由于Redux默认情况下只调用通过reducers影响状态的动作，您可能想知道如何将第三方库与Redux结合起来。这就是Redux-Observable及其史诗的用武之地。</p><p id="16ed" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于这个例子，我将与第三方服务通信，并告诉它只有在我存储了用户信息之后才开始登录；例如，在成功登录后。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3290" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们从通过Redux-Observable赋予我们史诗的<code class="fe mk ml mm mn b">action$</code>可观测性开始。我们想使用<code class="fe mk ml mm mn b">ofType</code>来检查进来的动作是否有匹配的类型。</p><p id="c63a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">ofType</code>引擎盖下，真的是:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1b72" class="mw lo jb mn b gy mx my l mz na">filter(({ type }) =&gt; (<br/>  type === 'USER::UPDATE_USER_INFO'<br/>))</span></pre><p id="b3ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">ofType</code>就像在状态减速器中检查<code class="fe mk ml mm mn b">action.type</code>。发生的任何行为都将通过这个<code class="fe mk ml mm mn b">ofType</code>检查，要么继续，要么停止。</p><p id="79aa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为日志服务需要我们的用户数据以某种方式格式化，我们将它映射到一个新的对象，然后使用<code class="fe mk ml mm mn b">tap</code>将它传递给日志服务。</p><p id="a850" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">tap</code>是在你想做副作用比如<code class="fe mk ml mm mn b">console.log</code>或者挂钩第三方工具比如<code class="fe mk ml mm mn b">updateLoggingService</code>的时候使用的。它与Promise的<code class="fe mk ml mm mn b">.then()</code>完全相同，只是它不会改变管道的状态。</p><p id="b802" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是一个相当于<code class="fe mk ml mm mn b">tap</code>的承诺:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="26ff" class="mw lo jb mn b gy mx my l mz na">Promise<br/>.resolve(value)<br/>.then(value =&gt; {<br/>  updateLoggingService(value)<br/> <br/>  return value<br/>})</span></pre><p id="a131" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当你想调试你的管道时，它也是很棒的。在创作一部新的史诗时，这是无价的。</p><p id="c5ee" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为所有史诗都必须发出一个动作，而我们没有这样做，所以我们用<code class="fe mk ml mm mn b">ignoreElements</code>结束我们的管道。我们已经把<code class="fe mk ml mm mn b">ignoreElements</code>放在了我们的可观察对象的末端，这样它一通过<code class="fe mk ml mm mn b">tap</code>就会停止管道。不会发出任何动作。</p><h1 id="83c2" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">执行一次</h1><p id="18be" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">除了副作用之外，有时您可能希望一个操作只执行一次。在本例中，这将是您想要开始现场聊天的时间。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a2e2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个epic看起来和我们之前的非常相似，除了它只使用<code class="fe mk ml mm mn b">take(1)</code>启动一次聊天客户端。这意味着，无论这个动作被调用多少次，它只执行第一次。</p><p id="e54c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">可能有一个单独的动作用用户信息更新聊天客户机，就像我们在前面的例子中一样，但是这个epic只关心启动聊天客户机。因为我们正在调用第三方服务的函数，所以我们真的只想调用一次。再次调用它会导致第三方库出错。</p><h1 id="c722" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">立即执行行动</h1><p id="db5b" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">当你的应用程序启动时，你可能想要立即执行一个动作，而不是等待一个动作的到来。将epic与Redux-Observable的初始化紧密耦合很可能是个坏主意，但是它消除了调用一个动作来执行epic的需要。</p><p id="2bb3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个简单的例子是将应用程序的当前版本记录到控制台，这样您就可以确保应用程序的部署版本与您预期的版本相匹配。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0b46" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我提供了3个单独的例子，但是您可能只想在您的应用程序中使用一个。</p><p id="2fa1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意我们没有使用<code class="fe mk ml mm mn b">ofType</code>。没有发出Redux操作来触发应用程序版本日志记录。虽然这一开始看起来是个好主意，但这也意味着我们无法控制它的执行。我建议不要像这样立即行动，除非你真的有需要。不管怎样，我们可以用这个例子来学习更多的RxJS模式。</p><p id="0ec2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在版本1之前，Redux-Observable没有正确处理立即执行，需要使用<code class="fe mk ml mm mn b">timer(0)</code>。<code class="fe mk ml mm mn b">timer</code>功能需要一段时间，并一直等到这段时间过去后，才通过管道发出一次<code class="fe mk ml mm mn b">0</code>。明确地说，不管你向<code class="fe mk ml mm mn b">timer</code>函数传递了什么，它都会通过管道传递<code class="fe mk ml mm mn b">0</code>。</p><p id="9a58" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在引擎盖下，它看起来像这样:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="094d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在另外两个例子中，我使用了<code class="fe mk ml mm mn b">of</code>和<code class="fe mk ml mm mn b">EMPTY</code>。<code class="fe mk ml mm mn b">of</code>会散发出它所赋予的任何东西。如果你给它传递更多的参数，这些参数将会一个接一个地发出。在这种情况下，我们不在乎我们发出什么，只要我们发出什么。我们甚至可以发出<code class="fe mk ml mm mn b">null</code>，但是我们选择发出<code class="fe mk ml mm mn b">appVersion</code>是为了让我们的代码更干净一点。</p><p id="86fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">EMPTY</code>是一个常量可观测值，订阅后立即完成。这就是为什么我们可以使用<code class="fe mk ml mm mn b">defaultIfEmpty</code>。所发生的是空调用<code class="fe mk ml mm mn b">observer.complete()</code>，然后<code class="fe mk ml mm mn b">defaultIfEmpty</code>中的值沿着管道向下传递，只要它在你的管道中。这就是为什么我们不直接调用<code class="fe mk ml mm mn b">console.info(appVersion)</code>的原因。</p><h1 id="bb53" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">更新状态</h1><p id="ea40" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">可能你会遇到的Redux-Observable的最基本的例子是更新状态。这并不完全显而易见，但是用epic更新Redux的状态需要监听一个动作并执行另一个动作。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4851" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个例子中，当用户登录时，我们有一个认证平台分派一个<code class="fe mk ml mm mn b">UPDATE_USER_INFO</code>动作。有几种方法可以处理这个问题，比如直接在我们的reducer中进行所有的转换，但是我们可以让我们的epic来处理它。</p><p id="d63b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，我们<code class="fe mk ml mm mn b">map</code>(转换)我们的数据以匹配我们将如何存储它，然后我们<code class="fe mk ml mm mn b">map</code>我们的reducer监听存储的动作。</p><p id="8117" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在，我们的<code class="fe mk ml mm mn b">userInfoReducer</code>可以这么简单:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5b72" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为在epics中使用可观察的管道比使用reducer可以做更多的事情，所以使用超级简单、可重用的reducer并利用epics进行所有数据转换和业务逻辑是一个很好的过程。这样，你可以专注于Redux-Observable中的复杂逻辑，而不是复杂化你的reducers。</p><h1 id="5223" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">用行动利用商店</h1><p id="dbe8" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">很多时候，您会希望利用状态中的某些东西来执行其他操作。这就是我们得到Redux-Observable的真正力量的地方。监听动作是一回事，将应用程序的全部状态放在一个地方并使用它来执行其他动作是另一回事。</p><p id="3c72" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我有过不少这样的情况，我真的想要一些州外的东西，但也许它还不在那里。也许我想等到商店里有东西的时候再继续我的史诗。有几种方法可以解决这个问题。我将回顾几个简单的例子并解释为什么你会使用它们，但是我将把复杂的留到本文的最后。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0f39" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在第一个例子中，我们在做任何事情之前等待<code class="fe mk ml mm mn b">UPDATE_AUTH_INFO</code>动作被分派。我们的最终目标是在我们通过身份验证后发送<code class="fe mk ml mm mn b">closeModal</code>动作。</p><p id="11bc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">像我们其他的观察对象一样，我们在倾听一个动作，然后进行映射。在这种情况下，我们甚至不关心<code class="fe mk ml mm mn b">UPDATE_AUTH_INFO</code>的有效载荷是什么，因为我们映射到封闭的<code class="fe mk ml mm mn b">state$.value</code>。<code class="fe mk ml mm mn b">.value</code>道具并不存在于大多数可观测物体上，但是<code class="fe mk ml mm mn b">state$</code>是一个<code class="fe mk ml mm mn b">BehaviorSubject</code>，这意味着你可以在任何时候抓取当前值。</p><p id="53f3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">接下来，我们从我们的状态中获取当前的<code class="fe mk ml mm mn b">authInfo</code>对象，并从<code class="fe mk ml mm mn b">pluck</code>中取出<code class="fe mk ml mm mn b">isAuthenticated</code>道具。这与做以下事情是一样的:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1878" class="mw lo jb mn b gy mx my l mz na">map(authInfo =&gt; (<br/>  authInfo<br/>  .isAuthenticated<br/>))</span></pre><p id="baa8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">接下来是我使用的一个技巧，用更少的代码来验证值。通过将<code class="fe mk ml mm mn b">Boolean</code>构造函数传递给<code class="fe mk ml mm mn b">filter</code>，只有真值才会继续。注意<code class="fe mk ml mm mn b">0</code>和<code class="fe mk ml mm mn b">''</code>是假的。</p><p id="1c73" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦我们从我们的状态中确定用户通过了身份验证，我们就可以执行一个新的操作符:<code class="fe mk ml mm mn b">mapTo</code>。这就像一个map，但是它存储它在运行时接收的值，而不是像map一样在管道中执行一个函数。</p><p id="d832" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从这里，我们像往常一样继续，将我们的管道值映射到一个将由Redux-Observable调度的动作。</p><h1 id="ae9a" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">直接监听状态更新</h1><p id="dd49" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">有时候你会想直接听state$的。这可能非常有效，并且解耦了您需要知道哪个动作更新状态的哪个部分的epics。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a82f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个例子中，我们通过<code class="fe mk ml mm mn b">distinctUntilChanged</code>操作符依赖Redux存储的不变性。该操作符保留以前的状态，并将其与管道中的当前值进行比较。如果它们匹配，它就在那里停止管道。如果值已更改，则继续通过管道。</p><h1 id="5d28" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">JavaScript事件</h1><p id="be55" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">有时您需要挂钩JavaScript事件，比如监听对<code class="fe mk ml mm mn b">localStorage</code>的更改、来自<code class="fe mk ml mm mn b">iframe</code>的通信或者与第三方库交互。这个问题经常出现，因为第三方几乎从不使用observables。</p><p id="df47" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将监听<code class="fe mk ml mm mn b">window</code>大小的变化，因为我们将创建一个<code class="fe mk ml mm mn b">@media</code>查询的定制实现。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a840" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们使用<code class="fe mk ml mm mn b">window</code>创建一个<code class="fe mk ml mm mn b">fromEvent</code>可观察对象，以及我们正在监听的事件类型:<code class="fe mk ml mm mn b">resize</code>。这和做一个<code class="fe mk ml mm mn b">window.addEventListener</code>是一样的，除了它被很好地包装成一个可观察对象。</p><p id="e100" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您甚至可以收听其他类型的事件，如<code class="fe mk ml mm mn b">on</code>:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="d25d" class="mw lo jb mn b gy mx my l mz na">someThirdPartyLibrary<br/>.on('ready', () =&gt; {})</span></pre><p id="b1d7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<code class="fe mk ml mm mn b">fromEvent</code>时，看起来是这样的:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="7ef7" class="mw lo jb mn b gy mx my l mz na">fromEvent(<br/>  someThirdPartyLibrary,<br/>  ‘ready’,<br/>)<br/>.pipe(<br/>  // This is your callback pipeline<br/>)</span></pre><p id="55f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦这些响应来自我们的<code class="fe mk ml mm mn b">resize</code>事件，我们将把它们限制在每秒60帧。这意味着调整大小通知只有在每秒60帧的时间段内才会出现。这也意味着我们每秒最多只有60个调整大小事件。</p><p id="5324" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">作为澄清，我们确实应该在RxJS中使用<code class="fe mk ml mm mn b">requestAnimationFrame</code>调度程序，但是我们在这个例子中使用了我们自己的调度程序，因为解释起来要简单得多。</p><h1 id="46ea" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">AJAX调用</h1><p id="f4e9" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">如果您直接挂钩到API端点，而不是通过GraphQL服务器，那么您可能希望通过Redux-Observable来管理来自AJAX调用的状态更新。</p><p id="7dac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是依赖的由来。与其直接拉入<code class="fe mk ml mm mn b">ajax</code>，不如通过中间件函数注入到你的epic中。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="10e9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这使得调试更加容易。如果你像我一样渲染服务器端，你会想知道RxJS的<code class="fe mk ml mm mn b">ajax</code>函数只在你有DOM时才起作用，因为它在幕后做了一个<code class="fe mk ml mm mn b">XMLHttpRequest</code>。你也可以把它换成类似<code class="fe mk ml mm mn b">axios</code>或<code class="fe mk ml mm mn b">fetch</code>的东西。</p><p id="f870" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">RxJS中有一个操作员将与<code class="fe mk ml mm mn b">ajax</code>协同工作，那就是<code class="fe mk ml mm mn b">switchMap</code>。当使用<code class="fe mk ml mm mn b">switchMap</code>时，它完成先前的<code class="fe mk ml mm mn b">ajax</code>可观察，取消请求。这对于异步操作来说非常好，因为这意味着您可以轻松地最小化竞争条件。</p><p id="5ed9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它看起来有点像这样:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f424" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">依赖性是我们史诗创造者的第三个论点。您的访问令牌或id令牌中应该存储有权限；但是，您可能需要使用相关的API来检查您的用户能够做什么，以确保UI不允许他们拥有比平时更多的权限。在这种情况下，我们向API请求所有用户权限。</p><p id="d757" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有了这部史诗，还有更多的事情要做。在我们进行AJAX调用之前，我们需要使用<code class="fe mk ml mm mn b">state$.value</code>从商店中获取<code class="fe mk ml mm mn b">accessToken</code>。</p><p id="8fdb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们看到一个新的操作符:<code class="fe mk ml mm mn b">switchMap</code>。这个操作符，以及其他一些类似的操作符，是迄今为止最重要的操作符，因为它们允许您在一个管道中将可观察对象链接在一起。在我们的例子中，当您调用<code class="fe mk ml mm mn b">ajax</code>函数时，它将返回一个可观察值。</p><p id="29a7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通常，我们可以在调用<code class="fe mk ml mm mn b">ajax</code>后立即返回，并将我们的操作符添加到主管道中。相反，我们将直接从<code class="fe mk ml mm mn b">ajax</code>中分离出来。虽然它在这个例子中没有意义，但它与我们最终如何处理错误有关。</p><p id="6fb2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我们成功的AJAX调用之后，我们将包含权限列表的属性映射到动作。</p><h1 id="4557" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated"><code class="fe mk ml mm mn b">Cancelling AJAX Calls When Using mergeMap</code></h1><p id="032c" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">当一次获取所有权限时，你可能只需要一个史诗就可以了。基于您的架构，您可能正在使用React，并且每个组件可能知道它需要哪些权限。在这种情况下，特别是如果你的应用程序有大量的权限，你可以在需要的时候获取一个权限，而不是获取整个列表。</p><p id="d502" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你不想为每一个可能的许可创建一个单独的史诗。相反，你会想要创造一个利用<code class="fe mk ml mm mn b">mergeMap</code>的通用史诗。为了避免这些情况下的竞争条件，您将需要<code class="fe mk ml mm mn b">takeUntil</code>操作符。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c3de" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们从头开始。我添加了一个助手函数，根据给定的<code class="fe mk ml mm mn b">permissionType</code>过滤出权限动作。这将在史诗的后期派上用场。</p><p id="b36e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这部史诗的大部分内容都是一样的，除了我们现在用我们的动作传入一个<code class="fe mk ml mm mn b">permissionType</code>,并需要将它与状态外的一个值相结合。我使用了之前的一个可观察对象:<code class="fe mk ml mm mn b">of</code>，它接受传递的值并通过管道传递。这样就可以<code class="fe mk ml mm mn b">pipe</code>掉<code class="fe mk ml mm mn b">of</code>可观察，抢接入令牌，像以前一样<code class="fe mk ml mm mn b">switchMap</code>到<code class="fe mk ml mm mn b">ajax</code>。</p><p id="19a0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当您使用<code class="fe mk ml mm mn b">mergeMap</code>而不是<code class="fe mk ml mm mn b">switchMap</code>时，它将创建一个新的可观察对象并订阅它。如果不小心的话，这个操作符可以单独造成内存泄漏。幸运的是，<code class="fe mk ml mm mn b">ajax</code>只触发一次并在之后完成，但是如果你想要和我们之前使用<code class="fe mk ml mm mn b">switchMap</code>时一样的取消行为，我们将会使用<code class="fe mk ml mm mn b">takeUntil</code>。</p><p id="af67" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">takeUntil</code>给定一个可观察值，从不通过管道推送任何东西。当给定的可观察对象发射时，它以与<code class="fe mk ml mm mn b">take</code>相同的方式完成当前的可观察对象。</p><p id="3ba8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我们的<code class="fe mk ml mm mn b">takeUntil</code>中，我们正在监听另一个<code class="fe mk ml mm mn b">FETCH_PERMISSION</code>动作，它有一个匹配的<code class="fe mk ml mm mn b">permissionType</code>。如果是这样，我们将完成取消AJAX调用的observable。这允许另一个开始，而不会导致可能的竞争情况。</p><h1 id="ac96" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">延迟AJAX请求</h1><p id="352f" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">您可能希望限制一次发出的AJAX请求的数量。例如，您可能正在上传文件，并且希望两个一组地上传，而不是一次上传十个文件。</p><p id="12a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<code class="fe mk ml mm mn b">mergeMap</code>，它几乎肯定会一次发送所有十个文件。另一方面，使用<code class="fe mk ml mm mn b">concatMap</code>会将其限制为一次一个项目。如果您想将它限制为一次两个项目，请使用带有第二个参数<code class="fe mk ml mm mn b">2</code>的<code class="fe mk ml mm mn b">mergeMap</code>。如果你把所有东西都放在同一个史诗中，这真的很难理解。</p><p id="6f6d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">更好的方法是像这样使用<code class="fe mk ml mm mn b">map</code>和<code class="fe mk ml mm mn b">mergeAll</code>:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ae4f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个例子非常复杂，它包含了很多我们还没有看到的概念。例如，将<code class="fe mk ml mm mn b">permissionTypes</code>包装在<code class="fe mk ml mm mn b">from</code>中实际上是通过管道将每个<code class="fe mk ml mm mn b">permissionType</code>作为管道中的一个单独的值。我们将这些映射到一个全新的可观察对象中，我们<code class="fe mk ml mm mn b">mergeAll(2)</code>将它保持为一次两个项目被合并映射。这限制了我们在API上的负载，并确保我们的应用程序可以轻松地处理越来越多的权限。除了这些变化，它几乎和以前一样的史诗。</p><p id="c1d8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个主要的区别是我们如何处理<code class="fe mk ml mm mn b">takeUntil</code>。当<code class="fe mk ml mm mn b">FETCH_PERMISSIONS</code>被执行时，我们现在需要遍历每个<code class="fe mk ml mm mn b">permissionType</code>并在取消之前查看是否有与我们的动作调用匹配的。</p><h1 id="7f0a" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">等待合并映射的可观测量</h1><p id="ebbd" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">现在，如果您想等到所有这些合并映射的可观测量完成，但同时启动<code class="fe mk ml mm mn b">storePermission</code>动作，会怎么样呢？为此，我们将使用<code class="fe mk ml mm mn b">toArray</code>和<code class="fe mk ml mm mn b">multicast</code>。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0b71" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我实际上已经在一个实际的epic应用程序中使用了这个功能，它控制文件上传，所以它有它的用处。</p><p id="fe00" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个<code class="fe mk ml mm mn b">multicast</code>解决方案相当神奇，但也很难理解。如果你想改变它的行为，你真的需要意识到它在做什么，但是在这篇文章中，我将只在一个高层次上介绍当前的实现。</p><p id="ab23" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">Subject</code>有一些特殊之处，它既是一个可观察对象，又是一个观察者。因此，我们正在创建一个单独的<code class="fe mk ml mm mn b">Subject</code>可观察对象，它将在管道中的这一点接收相同的输出，并连接到源可观察对象(在本例中为<code class="fe mk ml mm mn b">from(permissionTypes)</code>)。我们将把源可观察对象与其自身合并，并把合并后的可观察对象分离出来。</p><p id="bf08" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将这个<code class="fe mk ml mm mn b">multicast</code>操作符放在了<code class="fe mk ml mm mn b">mergeAll</code>之后，因此它将接收每个<code class="fe mk ml mm mn b">permissionType</code>发出的响应。一旦所有权限类型都通过了管道的这个区域，<code class="fe mk ml mm mn b">toArray</code>将发出它收集的AJAX响应数组。因为我们不关心这些响应，因为我们已经单独处理了它们，所以我们映射到<code class="fe mk ml mm mn b">finishedStoringPermissions</code>动作。</p><p id="12e8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里有一个简单得多的例子，您可以将它复制粘贴到任何JavaScript领域:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a757" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注:<code class="fe mk ml mm mn b">range(1, 4)</code>与<code class="fe mk ml mm mn b">from([1, 2, 3, 4])</code>相同。</p><h1 id="d791" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">捕捉AJAX错误</h1><p id="a92c" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">我们如何处理Redux-Observable中的错误？就像我们对待RxJS一样…有点。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="750c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们使用<code class="fe mk ml mm mn b">catchError</code>来捕捉任何不成功的AJAX响应。否则，它们会被Redux-Observable吞噬，你永远也不会知道。RxJS v6解决了吞咽错误，但是您可能还是想处理这个错误。</p><p id="5fbb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个例子中，我们打开了错误模式，并将错误和堆栈跟踪一起传递给它。再次注意<code class="fe mk ml mm mn b">of</code>可观察值的使用。<code class="fe mk ml mm mn b">catchError</code>采用返回可观察值的函数。不这样做将导致另一个错误，所以如果你使用<code class="fe mk ml mm mn b">catchError</code>，请确保你将启动一个动作。</p><p id="7890" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们还必须把<code class="fe mk ml mm mn b">catchError</code>放在<code class="fe mk ml mm mn b">ajax</code>上，因为否则它不会被捕捉到。这就是我们为什么直接关闭<code class="fe mk ml mm mn b">ajax</code>的原因，因为<code class="fe mk ml mm mn b">catchError</code>返回的动作仍然通过管道，就好像<code class="fe mk ml mm mn b">catchError</code>从未被调用过一样。</p><h1 id="5fc3" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">一般错误捕获</h1><p id="2e0b" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">像AJAX错误一样，您会希望将<code class="fe mk ml mm mn b">catchError</code>放在相当多的史诗中。在本例中，我们将通过调用一个错误操作将它们发送到我们的日志记录软件。这样，这些错误也可以在Redux Devtools中找到。我们还可以在代码库中的其他地方创建一个epic，简单地监听这个错误动作，并使用副作用处理与第三方日志服务的集成。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5297" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果这个例子是在服务器端执行的，<code class="fe mk ml mm mn b">window</code>就是<code class="fe mk ml mm mn b">undefined</code>；因此，你通常会中断你的应用程序，但是使用Redux-Observable，你只需点击<code class="fe mk ml mm mn b">catchError</code>并继续运行，就像什么都没发生一样。</p><p id="3cab" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个例子中，我们有目的地确保仍然调用<code class="fe mk ml mm mn b">storeCurrentUrl</code>，但是因为我们没有<code class="fe mk ml mm mn b">window</code>，所以我们将传递一个空字符串。</p><p id="9d3c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不仅如此，我们还同时调用<code class="fe mk ml mm mn b">logError</code>来通知我们的日志记录服务，因为这个有用的可观察对象<code class="fe mk ml mm mn b">merge</code>。正如您可能已经收集到的，<code class="fe mk ml mm mn b">merge</code>允许我们同时执行多个动作，当我们把它们作为单独的参数传入时。</p><p id="fba2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为它将要出现，你应该知道还有一个<code class="fe mk ml mm mn b">merge</code>操作符。我会说你可能会完全避免使用操作符版本，但是由于RxJS的<code class="fe mk ml mm mn b">finalize</code>操作符在处理Redux-Observable时存在缺陷，你最终会需要它。</p><p id="16e3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在一般的<code class="fe mk ml mm mn b">catchError</code>例子中，我简单地看了一下<code class="fe mk ml mm mn b">merge</code>，但是它有更多的用途。通常，在进行AJAX调用之前，我会启动一个加载指示器。AJAX调用完成后，我将触发更多的动作，比如存储数据和停止加载指示器。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="48c7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们的例子越来越复杂，所以我们保持同样的权限史诗。</p><p id="fa64" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<code class="fe mk ml mm mn b">merge</code>，我们能够在AJAX调用之前启动加载指示器，并在调用之后立即停止。遗憾的是，使用Redux-Observable没有真正的方法来听出成功和不成功。这是因为RxJS中的<code class="fe mk ml mm mn b">finalize</code>方法像<code class="fe mk ml mm mn b">tap</code>。当可观察对象完成或出错时，它调用一个动作，实际上它不执行任何事情。所以当你需要一个副作用的时候你可以用它，但是当你想在场景一或场景二中调用一个动作的时候就不用了。</p><p id="3edd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了解决这个问题，我添加了操作员版本的<code class="fe mk ml mm mn b">merge</code>，我将把它别名为<code class="fe mk ml mm mn b">mergeOperator</code>，这样就很清楚了:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="da68" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个例子中，<code class="fe mk ml mm mn b">mergeOperator</code>的工作方式类似于<code class="fe mk ml mm mn b">finalize</code>函数，我们不必复制我们的<code class="fe mk ml mm mn b">loaded</code>动作。</p><h1 id="f541" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">听两个观察</h1><p id="5eb6" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">我们的应用程序有一个错误通知，在10秒钟后自动删除，但也允许用户在计时器超时前手动隐藏错误。不知何故，我们必须找到一种方法来同时倾听两个可观察的声音，并让它们<code class="fe mk ml mm mn b">race</code>来看看哪一个先发生。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="93b6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们使用和以前一样的概念，但是现在有了一个新的可观察的东西:<code class="fe mk ml mm mn b">race</code>。这个可观测值发出两个可观测值之间的第一个值。</p><p id="0344" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">令人厌倦的事情，并不是比赛一开始就停止。虽然类似于<code class="fe mk ml mm mn b">Promise.race()</code>，但它实际上一直在监听。当一个可观测物体发射时，它让该可观测物体的发射通过，并等待直到另一个也发射。一旦它发出信号，它就返回监听，看两者中哪一个会赢得下一场比赛。只要<code class="fe mk ml mm mn b">race</code>仍处于活动状态，这种情况就会持续。</p><p id="9932" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了缓解无限等待的问题，我将<code class="fe mk ml mm mn b">take(1)</code>放在了<code class="fe mk ml mm mn b">HIDE_ERROR_NOTIFICATION</code>动作监听器上。<code class="fe mk ml mm mn b">timer(10000)</code>完成后它会放出，这样我就不用上<code class="fe mk ml mm mn b">take(1)</code>了。</p><p id="6a7f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后一个非常奇怪的部分是<code class="fe mk ml mm mn b">filter</code>。这是为了确保我们只调用一次<code class="fe mk ml mm mn b">hideErrorNotification</code>动作。如果定时器先用完，将调用<code class="fe mk ml mm mn b">hideErrorNotification</code>。既然在一个<code class="fe mk ml mm mn b">race</code>里面，就不会发出什么东西。但是如果用户隐藏了通知，那么<code class="fe mk ml mm mn b">hideErrorNotification</code>已经被调用过了，我们不想再调用第二次。这就是它被过滤掉的原因。</p><h1 id="f347" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">奔向美国</h1><p id="984c" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">如果我们正在加载需要一个<code class="fe mk ml mm mn b">accessToken</code>来分派动作的组件，那么很有可能这些组件会在状态中的访问令牌可用之前加载。在这个特殊的例子中，我们不想在没有<code class="fe mk ml mm mn b">accessToken</code>的情况下进行AJAX调用。</p><p id="42ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是<strong class="ks jc">易错</strong>的例子:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f048" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个特定的可观察对象可能使用<code class="fe mk ml mm mn b">undefined</code>作为<code class="fe mk ml mm mn b">accessToken</code>进行AJAX调用。你可能会想我们可以用种族来解决这个问题；我们可以，但没有必要。</p><p id="45b9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了确保您的状态中有一个<code class="fe mk ml mm mn b">accessToken</code>，您需要<strong class="ks jc">听</strong> <code class="fe mk ml mm mn b"><strong class="ks jc">state$</strong></code>:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="42a2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过监听<code class="fe mk ml mm mn b">state$</code>并检查来自<code class="fe mk ml mm mn b">accessTokenSelector</code>的真值，我们确保只有在有<code class="fe mk ml mm mn b">accessToken</code>时才进行这个AJAX调用。</p><p id="70b0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这只起作用，因为<code class="fe mk ml mm mn b">state$</code>是一种特殊的被称为<code class="fe mk ml mm mn b">BehaviorSubject</code>的可观察对象，这意味着<code class="fe mk ml mm mn b">state$</code>总是有一个值，而<code class="fe mk ml mm mn b">action$</code>是无状态的，只能监听动作。这就是为什么<code class="fe mk ml mm mn b">state$.value</code>存在，也是为什么听<code class="fe mk ml mm mn b">state$</code>给你最新的值。</p><p id="e94c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在另一种情况下，您可能不想等待<code class="fe mk ml mm mn b">accessToken</code>可用。相反，如果没有可用的<code class="fe mk ml mm mn b">accessToken</code>，你可以在<code class="fe mk ml mm mn b">accessTokenSelector</code>之后写一些逻辑来显示错误。</p><h1 id="d6fe" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">结论</h1><p id="5f77" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">我希望你从阅读这篇文章中有所收获。我将它视为Redux-Observable文档的扩展，以及我自己在生产应用程序中使用Redux-Observable和RxJS的9个月经验的积累。</p><p id="6a14" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我所有使用Redux-Observable的应用程序都是用这些相同的构件构建的。我用Redux-Observable实现了很多解决方案，但这几个应该足够开始了！</p><h1 id="f8ff" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">如果您对更多与Redux和RxJS相关的主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="81b6" class="nd ne jb ks b kt ku kw kx kz nf ld ng lh nh ll ni nj nk nl bi translated">使用Redux的秘密:createNamespaceReducer </li><li id="85c4" class="nd ne jb ks b kt nm kw nn kz no ld np lh nq ll ni nj nk nl bi translated"><a class="ae lm" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="nd ne jb ks b kt nm kw nn kz no ld np lh nq ll ni nj nk nl bi translated"><a class="ae lm" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener">为什么你不需要React-Redux的“连接”</a></li><li id="c881" class="nd ne jb ks b kt nm kw nn kz no ld np lh nq ll ni nj nk nl bi translated"><a class="ae lm" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="b18e" class="nd ne jb ks b kt nm kw nn kz no ld np lh nq ll ni nj nk nl bi translated">函数式编程的表情爱好者指南:第一部分</li></ul></div></div>    
</body>
</html>