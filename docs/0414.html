<html>
<head>
<title>Lessons learned using JSX without React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有反应的情况下使用JSX的经验</h1>
<blockquote>原文：<a href="https://itnext.io/lessons-learned-using-jsx-without-react-bbddb6c28561?source=collection_archive---------6-----------------------#2018-03-06">https://itnext.io/lessons-learned-using-jsx-without-react-bbddb6c28561?source=collection_archive---------6-----------------------#2018-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="0fc1" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae kp" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Flessons-learned-using-jsx-without-react-bbddb6c28561%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="0246" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">启动项目是容易的部分，因为每个节点项目<code class="fe kt ku kv kw b">yarn init -y</code>都将创建准系统，对于JS爱好者来说几乎是每周一次的任务，所以我们不要深究这个命令；现在，依赖性非常小，就个人而言，我喜欢使用webpack，但是，为了简单起见，我们只使用babel:</p><p id="45d3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><code class="fe kt ku kv kw b">yarn add -D @babel/cli @babel/core @babel/plugin-syntax-jsx @babel-plugin-transform-react</code></p><p id="4d8a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">下一步也很简单，在根目录下定义一个<code class="fe kt ku kv kw b">.babelrc</code>文件并使用以下内容:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="3a8c" class="lf lg iq kw b gy lh li l lj lk">{<br/>  “plugins”: [<br/>    “@babel/plugin-syntax-jsx”,<br/>    [“@babel/plugin-transform-react-jsx”, { “pragma”: “dom” }]<br/>  ]<br/>}</span></pre><p id="c74d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在这一点上有必要做一点解释；有了这些步骤，我们可以通过两件事将<code class="fe kt ku kv kw b">&lt;h1&gt;Hi&lt;/h1&gt;</code>转变成<code class="fe kt ku kv kw b">dom(“h1”, null, “Hi”)</code>，</p><ul class=""><li id="a1e8" class="ll lm iq jt b ju jv jy jz kq ln kr lo ks lp ko lq lr ls lt bi translated">上定义编译指示。babelrc将命名fn，否则默认情况下将执行<code class="fe kt ku kv kw b">React.createElement</code></li><li id="11ab" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">运行一个<code class="fe kt ku kv kw b">@babel/cli</code>命令，但是让我们使用来自<code class="fe kt ku kv kw b">package.json</code>的npm脚本来保持它的有用性:</li></ul><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="67e6" class="lf lg iq kw b gy lh li l lj lk">"scripts": {<br/>  "build": "babel example.js --out-dir lib"<br/>}</span></pre><p id="226c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你正在阅读这篇文章，你可能已经知道JSX是什么了。这样一来，当我被要求再次实现一个以前用React编写但用普通JS编写的组件时，我就有些纠结了。原因是该组件太简单了，以至于让组织中的每个团队都使用它是一种过度的尝试，因为他们必须包含许多与React几乎没有任何关系的项目的依赖关系，这并不是说这不可能，而是一个已经包含angular 1.x或backbone的项目只是举几个例子，如果没有一个很好的理由，几乎不想添加React 16。</p><h2 id="394f" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">开始旅程(研究)</h2><p id="fedc" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb kq ms ke kf kr mt ki kj ks mu km kn ko ij bi translated">那么JSX是如何运作的呢？长话短说将js中的HTML语法转换成一个带有多个参数的函数，这些参数替换标签、属性和内容，比如:<code class="fe kt ku kv kw b">&lt;h1 className=”headline”&gt;Hi&lt;/h1&gt;</code>转换成<code class="fe kt ku kv kw b">dom(“h1”, { className: “headline” }, “Hi”)</code>，所以我当时的想法是，如果我能重新实现dom()应该做的事情，就可以了。</p><h2 id="1bac" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">基本步骤</h2><p id="cfd3" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb kq ms ke kf kr mt ki kj ks mu km kn ko ij bi translated">dom()必须读取3个参数，第一个参数会给我它应该被创建的元素的名称，然后<br/> <code class="fe kt ku kv kw b">const element = document.createElement(arg1)</code>，看起来是可行的，除非arg1不是一个字符串，在这种情况下将是一个来自组件的函数，其中<code class="fe kt ku kv kw b">&lt;CustomComponent /&gt;</code>将是<code class="fe kt ku kv kw b">dom(CustomComponent, null, null)</code>，我将执行该函数而不是创建一个新元素。<br/>另一方面，第二个参数是一个对象，因此至少启动一个基本的合并应该就可以了。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6512" class="lf lg iq kw b gy lh li l lj lk">function dom(tag, attrs, ...children) {<br/>  // Custom Components will be functions<br/>  if (typeof tag === 'function') { return tag() }</span><span id="6794" class="lf lg iq kw b gy mv li l lj lk">  // regular html tags will be strings to create the elements<br/>  if (typeof tag === 'string') {<br/>    <br/>    // fragments to append multiple children to the initial node<br/>    const fragments = document.createDocumentFragment()<br/>    const element = document.createElement(tag)</span><span id="87ba" class="lf lg iq kw b gy mv li l lj lk">    children.forEach(child =&gt; {<br/>       if (child instanceof HTMLElement) { <br/>         fragments.appendChild(child)<br/>       } else if (typeof child === 'string'){<br/>         const textnode = document.createTextNode(child)<br/>         fragments.appendChild(textnode)<br/>       } else {<br/>         // later other things could not be HTMLElement not strings<br/>         console.log('not appendable', child);<br/>       }<br/>    })</span><span id="63cf" class="lf lg iq kw b gy mv li l lj lk">    element.appendChild(fragments)</span><span id="81cd" class="lf lg iq kw b gy mv li l lj lk">    // Merge element with attributes<br/>    Object.assign(element, attrs)</span><span id="f0e3" class="lf lg iq kw b gy mv li l lj lk">    return element<br/>  }<br/>}</span></pre><p id="2b74" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">对于第二个论证来说仅仅是<code class="fe kt ku kv kw b">Object.assign(element, arg2)</code>并且在很大程度上，它做到了；最后，对于第三个参数，如果是一个字符串，应该添加一个节点文本，这是定义部分，因为如果第三个参数是一个函数，就让循环重新开始，所以我们在这里:</p><ul class=""><li id="1700" class="ll lm iq jt b ju jv jy jz kq ln kr lo ks lp ko lq lr ls lt bi translated">我们可以创建新的HTML元素</li><li id="297d" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">我们也可以使用定制组件</li><li id="3559" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">我们可以添加类和其他简单的字符串参数</li><li id="a910" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">我们可以添加文本或其他元素作为子元素</li><li id="9e75" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">我们可以呈现列表(兄弟姐妹)</li></ul><p id="d141" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">对于基础知识来说还不错，这里有一个在那个阶段兼容的例子，以及<a class="ae kp" href="https://github.com/alecsgone/jsx-files/commit/e20f3ae964b3af5e20d6c7e1a8b4d94934436868" rel="noopener ugc nofollow" target="_blank">提交</a>:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="be68" class="lf lg iq kw b gy lh li l lj lk">function Headline() {<br/>  return (<br/>    &lt;h1 className="headline"&gt;Inital Line<br/>      &lt;br /&gt;<br/>      new line<br/>    &lt;/h1&gt;<br/>  )<br/>}</span><span id="a34d" class="lf lg iq kw b gy mv li l lj lk">function Main() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Headline /&gt;<br/>      &lt;p&gt;Lorem ipsum&lt;/p&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;&lt;a href=""&gt;anchor&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li&gt;2&lt;/li&gt;<br/>        &lt;li&gt;&lt;a href=""&gt;anchor2&lt;/a&gt; More&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="4336" class="lf lg iq kw b gy mv li l lj lk">const app = document.querySelector('.app')<br/>app.appendChild(Main())</span></pre><p id="eae0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">让我们列举一下我们遗漏了什么，至少对于alpha版本来说是“必须实现”的:</p><ul class=""><li id="e80e" class="ll lm iq jt b ju jv jy jz kq ln kr lo ks lp ko lq lr ls lt bi translated"><code class="fe kt ku kv kw b">Array.map( item =&gt; &lt;tag&gt;{item}&lt;/tag&gt;)</code></li><li id="4175" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">Refs实现事件监听器或任何需要访问<code class="fe kt ku kv kw b">HTMLNodeElement</code>的东西</li><li id="2945" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">片段(当前的react组件有它们，我不想重写到div中)</li></ul><h2 id="1faa" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">体面的实现(alpha)</h2><p id="7823" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb kq ms ke kf kr mt ki kj ks mu km kn ko ij bi translated">从map开始，因为它是最常用的，检查arg3是否是一个数组，我们应该能够将这些函数的结果附加到文档片段上，然后附加到根上，就像，例如，在多个LI的情况下，根将是UL/OL，这很清楚，现在，兄弟是dom函数的额外参数，而不仅仅是作为最后一个参数的数组， 我很高兴我们通过第一手资料知道了前两个参数是什么，也感谢巴别塔，我们可以<code class="fe kt ku kv kw b">fn(arg1, arg2, …arg3){}</code>和arg3将永远是一个数组，即使只有一个项目，所以我们已经有了一个函数，让我们只是重复使用它。 <a class="ae kp" href="https://github.com/alecsgone/jsx-files/commit/1ec5ad125cbcd4fc4c3ed30d7d9302a45048235f" rel="noopener ugc nofollow" target="_blank">提交</a></p><h2 id="453c" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">还有两个功能</h2><p id="b5c2" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb kq ms ke kf kr mt ki kj ks mu km kn ko ij bi translated">引用和片段是唯一缺少的东西，所以引用就像询问第二个参数中的一个属性是否名为ref一样简单，并向同一个节点传递一个回调。在这一点上，a对React如何工作有了一个粗略的想法，这是一个很好的练习，只是缺少片段，许多版本的React都缺少的功能，最初我创建了一个函数来导出并能够使用它，当时我不知道函数应该是什么样的，我只是返回了单词Fragment用于日志记录，有趣的是， 在我尝试记录那个单词后，我意识到如果函数返回<a class="ae kp" href="https://github.com/alecsgone/jsx-files/commit/5c011ba221760f468baa1b609eef2a8d9773dfb5" rel="noopener ugc nofollow" target="_blank">片段</a>，我应该只返回孩子😋(仍然对根app不起作用但是谁把片段导出来作为主要功能？ 我希望没有很多人😉有了这个基本的、不到50行的例子，你就能完成所有的事情。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="0108" class="lf lg iq kw b gy lh li l lj lk">import dom, { Fragment } from 'jsx-render'</span><span id="29e4" class="lf lg iq kw b gy mv li l lj lk">function Headline() {<br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;h1 className="headline"&gt;Hello this in an h1<br/>        &lt;br /&gt;<br/>        new line<br/>      &lt;/h1&gt;<br/>      &lt;h2&gt;Second Headline&lt;/h2&gt;<br/>    &lt;/Fragment&gt;<br/>  )<br/>}</span><span id="542c" class="lf lg iq kw b gy mv li l lj lk">function Main() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Headline /&gt;<br/>      &lt;p&gt;Lorem ipsum&lt;/p&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;&lt;a href=""&gt;anchor&lt;/a&gt;&lt;/li&gt;<br/>        &lt;li&gt;More&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>      &lt;ol&gt; {items.map(item =&gt; &lt;li&gt;{item}&lt;/li&gt;)} &lt;/ol&gt;<br/>      &lt;button ref={node =&gt; { <br/>        node.addEventListener('click', console.log) <br/>      }}&gt;<br/>        Click Me!<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="f9cc" class="lf lg iq kw b gy mv li l lj lk">const app = document.querySelector('.app')<br/>app.appendChild(Main())</span></pre><h2 id="1e44" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">结论/提示/问题/问答</h2><ul class=""><li id="dace" class="ll lm iq jt b ju mq jy mr kq mw kr mx ks my ko lq lr ls lt bi translated">JSX很好地给了你实现自己的pragma fn的可能性，而且并不复杂。</li><li id="f668" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">从React组件的移植只是一个复制粘贴，因为组件是无状态的，只有一个点击函数来打开一个模态，但是打开/关闭类的切换不会伤害任何人，到目前为止一切都很好。</li><li id="8b7c" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">"如果你实现了这样的事件，僵尸怎么办？"—就公司目前的结构而言，这些组件将用于静态和非常简单的页面，没有关于SPA的故事，正因为如此，我并不太担心。</li><li id="22f0" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">当交互非常简单，只需点击切换时，您不需要反应/还原，有时1小时的重新实现可以为您每次加载节省30kb。</li><li id="3c16" class="ll lm iq jt b ju lu jy lv kq lw kr lx ks ly ko lq lr ls lt bi translated">如何实现片段让我大开眼界。</li></ul><h2 id="e192" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">其他方法</h2><p id="0169" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb kq ms ke kf kr mt ki kj ks mu km kn ko ij bi translated">经过额外的研究，我还发现了一个库，它可以转换到JSX，但不是为每个组件创建一个fn()来在运行时执行，而是将每个组件直接转换为document.createElement，有几个小的缺失功能不用担心，除非您需要SVG支持，我们将在后面讨论/实现。</p><h2 id="85cc" class="lf lg iq bd lz ma mb dn mc md me dp mf kq mg mh mi kr mj mk ml ks mm mn mo mp bi translated">笔记</h2><p id="aa38" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb kq ms ke kf kr mt ki kj ks mu km kn ko ij bi translated">示例repo使用了lerna，以防您想尝试一下。<a class="ae kp" href="https://github.com/alecsgone/jsx-files/tree/master/packages/blueprint" rel="noopener ugc nofollow" target="_blank">jsx-文件/蓝图</a></p></div></div>    
</body>
</html>