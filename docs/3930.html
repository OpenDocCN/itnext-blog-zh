<html>
<head>
<title>Utilize Jenkins in an Auto-Scaling Kubernetes Deployment on Amazon EKS with Spot instances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Spot实例，在亚马逊EKS上的自动扩展Kubernetes部署中利用Jenkins</h1>
<blockquote>原文：<a href="https://itnext.io/utilize-jenkins-in-an-auto-scaling-kubernetes-deployment-on-amazon-eks-with-spot-instances-f9159df00aee?source=collection_archive---------1-----------------------#2020-03-27">https://itnext.io/utilize-jenkins-in-an-auto-scaling-kubernetes-deployment-on-amazon-eks-with-spot-instances-f9159df00aee?source=collection_archive---------1-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d071" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何使用自定义Docker图像执行器在自动缩放环境中使用亚马逊EKS上的Kubernetes与现货实例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e91011dca89d0a8e6cdeb5a0294184f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nGygIC2r4M7t0-Xu"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片由Pixabay提供</figcaption></figure><h1 id="aa32" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">目录</h1><p id="f625" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">——<a class="ae me" href="#eebe" rel="noopener ugc nofollow"><strong class="jp ir">简介</strong></a><br/>——<a class="ae me" href="#1958" rel="noopener ugc nofollow"><strong class="jp ir">需求</strong></a><br/>——<a class="ae me" href="#f6ca" rel="noopener ugc nofollow"><strong class="jp ir">设置EKS集群</strong></a><br/>——<a class="ae me" href="#0778" rel="noopener ugc nofollow"><strong class="jp ir">设置Jenkins部署</strong> </a> <br/> — — <a class="ae me" href="#61fb" rel="noopener ugc nofollow">创建持久卷</a> <br/> — — <a class="ae me" href="#c748" rel="noopener ugc nofollow">创建Jenkins容器</a> <br/> — — <a class="ae me" href="#ff78" rel="noopener ugc nofollow">创建Jenkins部署</a> <br/> <a class="ae me" href="#5cc7" rel="noopener ugc nofollow"> <strong class="jp ir">设置集群自动缩放器</strong> </a> <br/> — — <a class="ae me" href="#32a5" rel="noopener ugc nofollow">设置自动缩放策略</a> <br/> — — <a class="ae me" href="#b725" rel="noopener ugc nofollow">部署集群自动缩放器</a><br/>——<a class="ae me" href="#3ac5" rel="noopener ugc nofollow">——<strong class="jp ir">创建Jenkins代理Docker映像</strong></a><br/>——<a class="ae me" href="#4308" rel="noopener ugc nofollow"><strong class="jp ir">在Jenkins上配置Kubernetes</strong></a><br/>——<a class="ae me" href="#808d" rel="noopener ugc nofollow">添加Kubernetes集群权限</a></p><h1 id="eebe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="ce9f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">随着我们的生产负载已经在使用亚马逊EKS的自动伸缩Kubernetes集群上运行，感觉我们正处于技术的巅峰。但事实是，在许多情况下，生产环境远没有内部环境那么大或复杂。</p><p id="a24e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多组织正在运行复杂的测试和分析环境，其中没有一个是面向客户的，但两者都比生产环境更难实施，维护成本也更高。</p><p id="f2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我着手容器化我们的内部环境时，我意识到我需要处理比以前多得多的流，同时始终牢记成本，并避免为我们不使用的资源付费。</p><p id="6588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AWS Spot实例是一个很好的起点。使用Spot实例，您可以按需获得一组EC2实例，使用您选择的映像进行引导，而价格只是以标准方式使用相同EC2实例的一小部分。</p><p id="4758" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的文章中，我演示了如何使用自定义的Docker图像来设置自动缩放的EKS环境。现在，我们将添加Spot实例，让所有东西都在Jenkins上运行，以创建一个完整的容器化自动扩展CI/CD环境。</p><h1 id="1958" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">要求</h1><p id="a1b4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">本文假设您将AWS作为云提供商，并且您可以访问EKS和ECR管理控制台，以及AWS CLI。</p><p id="35e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还假设您已经安装并配置了<em class="mf"> eksctl </em>和<em class="mf"> kubectl </em>。关于这些设置的更多信息，请查看我以前在<a class="ae me" href="https://medium.com/@hawkseye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-amazon-eks-bd2ab8ef56cc?source=friends_link&amp;sk=5035b1196cc98cf2a5858e736d64bf51" rel="noopener">的帖子https://medium . com/@ hawks eye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-Amazon-eks-BD 2 ab 8 ef 56 cc？source = friends _ link&amp;sk = 5035 b 1196 cc 98 cf 2 a 5858 e 736d 64 BF 51</a>。</p><p id="0694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我再次尝试对以前的知识做最少的假设，并尽我所能进行解释，但是我确实假设对Kubernetes和Docker的概念有一些熟悉。</p><p id="63d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后请注意，本文中所有的代码片段和引用文件都可以在这里找到:<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/ohanetz/a 17149 e 8 a 55 ef 380970 EDF 5 e 8 bfe 66 a</a></p><h1 id="f6ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">建立EKS集群</h1><p id="ffca" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们需要做的第一件事是设置一个EKS集群来托管我们的Jenkins安装和我们的worker节点。</p><p id="75dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的集群将由两个节点组组成:</p><ul class=""><li id="6a31" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">一个节点组，包括一个相对较小的静态节点，用于保存Jenkins安装以及所有必要的Kubernetes服务和持久部署。</li><li id="9532" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">我们将用于工作节点的Spot实例的节点组。一旦Jenkins请求执行一个作业，这个节点组的规模可以缩小到0，并且可以按需增长。</li></ul><p id="3027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在gist中，您会发现一个名为<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-eks-test-jenkins-yaml" rel="noopener ugc nofollow" target="_blank"><em class="mf">eks-test-Jenkins . YAML</em></a>的<em class="mf"> eksctl </em>示例配置文件。如上所述，这个示例配置文件可以用来在您的VPC中设置一个具有两个节点组的EKS集群。</p><p id="1e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记用集群AWS区域和子网id替换占位符。</p><p id="1dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们添加到Spot实例节点组的标签(<em class="mf"> lifecycle: Ec2Spot，intent: apps </em>)。我们将使用这些标签来将这个节点组标识为我们想要用来在Jenkins中执行构建的节点组。</p><p id="21f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保存配置文件运行以下命令:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="0939" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">eksctl create cluster -f eks-test-jenkins.yaml</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7fc178961d48b029901dbfa9f804f750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fGIBmfLWnnzpgact"/></div></div></figure><p id="403e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦eksctl完成，运行下面的命令来检查您的集群，注意您的集群配置了两个节点组，但是只有一个节点真正启动并运行，这正是我们此时想要的。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="e581" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">eksctl get nodegroups --cluster=eks-test-jenkins</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5933e45ccee695ab94e9344505820f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0EjrjH_lrYCcCQmy"/></div></div></figure><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="da4b" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl get nodes</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/3094f126868bca36394d05834909bc60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B7JeeR7FzvmKSmeL"/></div></div></figure><h1 id="0778" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置Jenkins部署</h1><p id="5de8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">一旦我们的集群启动并运行，我们首先需要安装Jenkins。因为我们需要Jenkins访问集群资源以控制我们的工作节点，所以最简单的方法是在Kubernetes上设置Jenkins，这意味着将Jenkins安装在我们的EKS集群的静态节点上。</p><h2 id="61fb" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">创建永久卷</h2><p id="fdf2" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在创建Jenkins部署之前，我们需要一个持久卷，即Kubernetes集群中的一个独立存储卷，以确保我们存储在Jenkins上的配置和数据不会在我们重新部署Jenkins或重新启动节点时丢失。</p><p id="4b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要一个持久卷声明，这是对持久卷存储的请求。<br/>关于持久卷的其他信息可以在这里找到:<a class="ae me" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/storage/persistent-volumes/</a></p><p id="4a6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从gist中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-pv-volume-yaml" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> pv-volume.yaml </em> </a>示例文件。此示例将在主机节点上的<em class="mf"> /mnt/data </em>文件夹中创建一个10GB的永久卷，具有一次读/写权限，这意味着只能从集群中的单个节点访问它。</p><p id="8ae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令来部署永久卷:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="dce3" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl apply -f pv-volume.yaml</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/32b7bc807b38c3ad489a51f7eb784f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P7qU0nozwKVBfSUR"/></div></div></figure><p id="3e64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，从gist中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-pv-claim-yaml" rel="noopener ugc nofollow" target="_blank"><em class="mf">PV-claim . YAML</em></a>示例文件。此示例将创建一个5GB存储声明，同样使用相同的访问模式。</p><p id="87d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令来部署永久卷声明:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="af82" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl apply -f pv-claim.yaml</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/14c0c9340816a11903f42fdb70a710e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rmkq7Hb24_e4vA9e"/></div></div></figure><p id="ae8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令测试您的部署:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="0292" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl get pvc</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/5d35cfc7d283a15c1653031e2366b7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PkEH_5abqL-NDiyu"/></div></div></figure><h2 id="c748" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">创建Jenkins容器</h2><p id="83e5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了创建一个Jenkins部署，我们首先需要一个Jenkins容器(例如，我们可以使用默认容器并使用helm安装它，或者我们可以使用一些预安装的定制，如我们知道需要的插件，来创建我们自己的容器)。</p><p id="541e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从要点中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-dockerfile-jenkins" rel="noopener ugc nofollow" target="_blank"><em class="mf">Dockerfile-Jenkins</em></a>示例docker file。这个docker文件将基于最新的Jenkins版本(在我写这篇文章的时候)创建一个容器，其中预装了几个必要的插件kubernetes插件和ssh-slaves插件，它们允许连接到远程代理来执行构建。</p><p id="83a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令来构建Docker映像:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="5fb2" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">docker build -f Dockerfile-jenkins -t "YOUR_DOCKER_IMAGE_FILE_NAME"</em></span></pre><p id="db9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于在亚马逊ECR上发布图片的其他信息，可以查看我之前的帖子:<a class="ae me" href="https://medium.com/@hawkseye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-amazon-eks-bd2ab8ef56cc?source=friends_link&amp;sk=5035b1196cc98cf2a5858e736d64bf51" rel="noopener">https://medium . com/@ hawks eye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-Amazon-eks-BD 2 ab 8 ef 56 cc？source = friends _ link&amp;sk = 5035 b 1196 cc 98 cf 2 a 5858 e 736d 64 BF 51</a>。</p><h2 id="ff78" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">创建Jenkins部署</h2><p id="bb17" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在创建部署时，我们需要确保将其附加到我们刚刚创建的持久卷声明，以确保Jenkins数据和配置是持久的，并且我们不会在每次节点重启时都获得干净的副本。</p><p id="abbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从gist中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-jenkins-deployment-yaml" rel="noopener ugc nofollow" target="_blank"><em class="mf">Jenkins-deployment . YAML</em></a>文件。本例将创建一个Jenkins部署，其中我们的持久卷声明挂载为<em class="mf"> jenkins_home </em>文件夹。</p><p id="119b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署基于指定的Jenkins Docker映像(不要忘记替换Docker映像URL占位符。您也可以使用jenkins/jenkins:lts作为默认图像)。</p><p id="7010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们需要确保可以使用jenkins用户访问该卷。对此有几种选择，但我发现最常见的解决方案(使用Kubernetes SecurityContext并设置fsGroup，如下所述:<a class="ae me" href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/tasks/configure-pod-container/security-context/</a>)在EKS集群上无法工作。我能找到的最好的解决方案是我在上面的例子中使用的那个——在创建部署时创建一个init容器，它将手动修复卷权限以匹配jenkins用户和组id，默认为1000。</p><p id="ec5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令来部署Jenkins:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="e53b" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl apply -f jenkins-deployment.yaml</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0cb55773c333570e33e7c52624dc83c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/0*5v_1YY7Wt28zBEyr"/></div></figure><p id="fa75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令测试您的部署:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="b852" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl get pods</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/121cd406ecdcbc4f9ebe89b4df965baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e1oO92B88Fw_bJBu"/></div></div></figure><h2 id="2e9d" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">创建Jenkins外部服务</h2><p id="2b68" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">接下来，我们需要公开我们的Jenkins部署，这样它将有一个外部端点以便于访问。请注意，如果您的节点在VPC内部运行，并且不接受来自互联网的传入流量，则只能在VPC内部访问外部端点。</p><p id="a607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="4085" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl expose deployment jenkins --type=LoadBalancer --name=jenkins-external</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1e3a690a9c62a51743dcdf12ec9c5774.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*DnXfi9x34Z4W8jQ3"/></div></figure><p id="3904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令测试您的服务:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="93d4" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl get services</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/77a35c32b168be83a5a08e6f19a40d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7PBRUpfhFnESlkKV"/></div></div></figure><p id="7603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的服务外部IP卡在<em class="mf">等待</em>或者你在这里面临另一个问题，查看我以前的帖子获得更详细的解释:</p><p id="8c76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae me" href="https://medium.com/@hawkseye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-amazon-eks-bd2ab8ef56cc?source=friends_link&amp;sk=5035b1196cc98cf2a5858e736d64bf51" rel="noopener">https://medium . com/@ hawks eye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-Amazon-eks-BD 2 ab 8 ef 56 cc？source = friends _ link&amp;sk = 5035 b 1196 cc 98 cf 2 a 5858 e 736d 64 BF 51</a>。</p><h2 id="9f4f" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">连接到詹金斯</h2><p id="4fcc" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在我们已经准备好了外部服务，我们可以使用服务地址连接到Jenkins。</p><p id="43ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令获取地址:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="439d" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl get services | grep jenkins-external | awk '{print $4}'</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/31a918c2bc3e4949c7cad0ad014c61ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*7vYTlwQdiW0p6rYA"/></div></figure><p id="9770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制URL并将其粘贴到浏览器中。不要忘记添加外部服务的端口(默认端口是8080)。</p><p id="25f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到Jenkins欢迎屏幕:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/112bde092f3bb750c63cb49ffbb00610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rq94wNrJNTYzYdAX"/></div></div></figure><h1 id="5cc7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置集群自动缩放器</h1><p id="21a3" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在，我们希望配置我们的EKS集群，以便Spot实例节点组可以按需从0自动扩展。</p><h2 id="32a5" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">设置自动缩放策略</h2><p id="d1c1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们需要为静态节点组分配一个自动伸缩策略，授予它访问Spot实例自动伸缩组和修改其大小的权限。</p><p id="3ade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要找到静态节点组堆栈的确切名称。运行以下命令:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="8157" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">aws cloudformation list-stacks</em></span></pre><p id="4584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查<em class="mf"> StackName </em>字段，并查找包含集群名称和节点组名称的堆栈。例如，如果您的集群名称是eks-test-jenkins，节点组名称是ng-test-jenkins，那么您的堆栈名称应该是<em class="mf">eks CTL-eks-test-Jenkins-node group-ng-test-Jenkins</em>。</p><p id="a527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，运行以下命令来查找该堆栈的IAM角色名称:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="7a1e" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">aws cloudformation describe-stack-resources --stack-name YOUR_STACK_NAME | jq -r '.StackResources[] | select(.ResourceType=="AWS::IAM::Role") | .PhysicalResourceId'</em></span></pre><p id="c845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，从gist中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-k8s-asg-policy-json" rel="noopener ugc nofollow" target="_blank"><em class="mf">k8s-ASG-policy . JSON</em></a>文件，并运行以下命令对该角色应用IAM策略:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="566a" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">aws iam put-role-policy --role-name YOUR_ROLE_NAME --policy-name ASG-Policy-For-Worker --policy-document file://./k8s-asg-policy.json</em></span></pre><h2 id="b725" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">部署集群自动缩放器</h2><p id="aba0" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">集群自动缩放器是负责自动调整Spot实例节点组大小的组件。</p><p id="f323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要获得为该节点组创建的自动伸缩组的名称。运行以下命令(用eksctl配置文件中定义的Spot实例节点组名称替换占位符(在我的例子中为<em class="mf"> ng-test-jenkins-spot </em>):</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="a43a" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">aws autoscaling describe-auto-scaling-groups | grep AutoScalingGroupName | grep YOUR_SPOT_NODEGROUP | awk 'NR==1{print substr($2, 2, length($2) — 3)}'</em></span></pre><p id="7cbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从gist中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-cluster-autoscaler-yaml" rel="noopener ugc nofollow" target="_blank"><em class="mf">cluster-auto scaler . YAML</em></a>文件，将<em class="mf"> YOUR_SPOT_ASG_NODEGROUP </em>占位符替换为您刚刚收集的自动缩放组名称，将YOUR_SPOT_ASG_REGION替换为您正在处理的AWS区域。</p><p id="c29a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里提供的cluster-autoscaler.yaml适用于使用单个自动伸缩组在EKS集群上部署集群自动伸缩程序。您可以在这里找到不同EKS配置的其他示例:<a class="ae me" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider/aws/examples" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/auto scaler/tree/master/cluster-auto scaler/cloud provider/AWS/examples</a></p><p id="79f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令在集群上部署集群自动缩放器:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="7710" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl apply -f cluster-autoscaler.yaml</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/4ec2f76b41e05d1620c034e1e6e470f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JpMjBd1Q_02Ucy7W"/></div></div></figure><h1 id="3ac5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建Jenkins代理Docker映像</h1><p id="77b1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们最不需要的是一个Docker映像，它将用于执行我们的Jenkins构建的容器。</p><p id="9dec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在这里使用标准的jenkins/jnlp-slave:latest Docker映像，但是创建包含Jenkins代理所需的任何其他先决条件的定制映像也很简单，比如配置和包。</p><p id="a86b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从gist中获取<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-dockerfile-jenkins-agent" rel="noopener ugc nofollow" target="_blank"><em class="mf">docker file-Jenkins-agent</em></a>和<a class="ae me" href="https://gist.github.com/ohanetz/a17149e8a55ef380970dedf5e8bfe66a#file-jenkins-slave" rel="noopener ugc nofollow" target="_blank"><em class="mf">Jenkins-slave</em></a>文件。这个例子用Jenkins JNLP代理创建了一个简单的Ubuntu容器，我们的Jenkins master将使用它进行通信。</p><p id="e96d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令为Jenkins代理构建Docker映像:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="3799" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">docker build -f Dockerfile-jenkins-agent -t "YOUR_DOCKER_IMAGE_FILE_NAME"</em></span></pre><h1 id="4308" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Jenkins上配置Kubernetes</h1><p id="8e69" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们已经完成了环境设置和Docker映像准备工作，现在我们已经做好了在EKS集群上使用Jenkins的一切准备。</p><p id="06cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要做的最后一件事是配置Jenkins与Kubernetes集群通信，以便它能够启动容器和执行构建。</p><h2 id="808d" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">添加Kubernetes集群权限</h2><p id="d295" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在容器中运行的任何应用程序都能够使用集群服务帐户与Kubernetes集群通信。通过绑定到群集角色，可以授予服务帐户某些群集权限。</p><p id="c9d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以将Jenkins设置为在一个单独的集群命名空间中运行，使用一个具有独特权限的专用服务帐户，但是让我们将深入的安全性讨论留到以后的文章中。目前，Jenkins部署将自动使用默认服务帐户，我们将创建一个许可绑定，为所有服务帐户提供集群管理权限，这对于我们的目的来说已经足够了。</p><p id="b4a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行以下命令:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="3757" class="mz lc iq mv b gy na nb l nc nd"><em class="mf">kubectl create clusterrolebinding permissive-binding --clusterrole=cluster-admin --user=admin --user=kubelet --group=system:serviceaccounts</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c1a48deac107ddbae0ac24b5fa5aea23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/0*UFUXgTEfaiJ8FyZn"/></div></figure><p id="e5f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关服务帐户权限和集群角色绑定的其他信息，请查看Kubernetes文档中的以下页面:<a class="ae me" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/reference/access-authn-authz/RBAC/</a></p><h2 id="6be4" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">获取Kubernetes主URL</h2><p id="20c4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Jenkins需要的另一件事是Kubernetes主服务的URL，它将用于Jenkins与集群的通信。</p><p id="2a83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行以下命令:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="a99a" class="mz lc iq mv b gy na nb l nc nd">kubectl cluster-info | grep master</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/3a027ed8176fcf22054833361c1c7e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6XEjzVApeSF24tC4"/></div></div></figure><h2 id="8f3c" class="mz lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">配置Jenkins</h2><p id="0665" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir"> <em class="mf">詹金斯将军配置</em> </strong></p><p id="ff2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Jenkins欢迎屏幕中，点击左侧菜单中的<em class="mf">管理Jenkins </em>，然后点击<em class="mf">配置系统</em>。</p><p id="948b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<em class="mf"> # of executors </em>字段设置为0，在<em class="mf"> Usage </em>字段中选择<em class="mf">Only build jobs with label expressions match this node</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/71f8db450756284cbcbe51f0ee226e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QVxgaAXYwNZHFeVA"/></div></div></figure><p id="b87e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个设置将确保我们不会在主Jenkins节点上执行构建。</p><p id="6074" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mf"> Kubernetes云配置</em> </strong></p><p id="fa67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf">云</em>部分，点击<em class="mf">添加新云</em>并选择<em class="mf"> Kubernetes </em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2a9fe9a6bb6c3f9f768d1c1d5976ea8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/0*iXKv5qkdtRF7Z3E6"/></div></figure><p id="fff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf"> Kubernetes URL </em>框中输入我们之前提取的Kubernetes主URL，然后点击<em class="mf">测试连接</em>按钮。您应该得到一条<em class="mf">连接测试成功</em>消息，表明Jenkins能够成功地与Kubernetes集群通信。</p><p id="0586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在这里得到一条错误消息，请回顾前面的部分，确保一切都配置顺利。</p><p id="eb87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf"> Jenkins URL </em>框中，输入Jenkins外部服务的URL，或您映射用于访问Jenkins的内部VPC地址。请注意，您可以通过执行以下命令来获取詹金斯VPC公司的内部IP地址:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="fd73" class="mz lc iq mv b gy na nb l nc nd">kubectl describe service jenkins-external | grep Endpoints | awk 'NR==1{print $2}'</span></pre><p id="6925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mf"> Kubernetes Pod模板配置</em> </strong></p><p id="f793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf"> Pod模板</em>部分，点击<em class="mf">添加Pod模板</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d58765b6cefb6cf196a112df8684c439.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*dl6RYfLF8glSXOST"/></div></figure><p id="caa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">键入一个名称，并在<em class="mf">用法</em>字段中选择<em class="mf">尽可能使用该节点</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/8ae602875aac5db1fa581c19ed386bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CcLaotieySclXXuR"/></div></div></figure><p id="8891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向下滚动到<em class="mf">节点选择器</em>字段，并键入我们在配置Spot实例节点组时添加的标签。这将确保Kubernetes使用这个节点组(点实例)中的节点来执行我们的构建。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/afa2449d09137cdd2055b8141ca5ac75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4N3ErC2bM6aBd2ZJ"/></div></div></figure><p id="6c6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向上滚动，点击<em class="mf">添加容器</em>按钮，然后选择<em class="mf">容器模板</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5b9bf9e6cd35f26fdb58f74357890f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/0*e99bw2oymM56eV5B"/></div></figure><p id="f250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mf">名称</em>字段中键入<em class="mf"> jnlp </em>(这是我们正在使用的Jenkins代理连接的类型)，并在<em class="mf"> Docker映像</em>字段中键入您之前创建的Jenkins代理Docker映像的名称。</p><p id="ffda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">清除运行的<em class="mf">命令和传递给命令</em>字段的<em class="mf">参数。</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/534264d31761076cf588ff17f899b569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zxzs2IpXxDVudC7o"/></div></div></figure><p id="ac27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以点击<em class="mf">高级… </em>按钮，更新Kubernetes pod执行设置，如CPU和内存请求:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7b136fac0349e30e472975cc36346db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/0*LydnvnaEZ959XlUS"/></div></figure><p id="1642" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，您可以使用这些高级执行设置来创建几种具有不同资源分配(甚至是完全不同的pod模板)的容器类型，以维护具有完全不同需求的不同流。</p><p id="c6dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后点击<em class="mf">保存</em>按钮。</p><h1 id="ba4b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建一个Jenkins测试项目</h1><p id="7476" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们终于准备好测试我们的Jenkins部署，以确保我们可以在Spot机器上按需执行构建。</p><p id="e45d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Jenkins欢迎界面中，点击左侧菜单中的<em class="mf">新项目</em>，在下一个窗口中键入名称并选择<em class="mf">自由式项目</em>。然后点击<em class="mf">确定</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oi"><img src="../Images/3a69eed021f8cb992078382d9f45ac58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mrBKlEYmjfEuBtQG"/></div></div></figure><p id="cb8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，转到<em class="mf">构建</em>部分，点击<em class="mf">添加构建步骤</em>按钮并选择<em class="mf">执行shell </em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oj"><img src="../Images/86f7f54a3078300f6ba0ad6e2a7ba319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T_3FT0Q3qLJKYymc"/></div></div></figure><p id="1231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在命令框中输入<em class="mf">睡眠300 </em>。然后点击<em class="mf">保存</em>。</p><p id="1f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚刚创建的这个项目只有一个构建步骤，即执行<em class="mf"> sleep 300 </em>命令。这意味着构建将等待5分钟，给我们足够的时间来观察发生了什么。</p><p id="e370" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择<em class="mf">立即构建</em>触发构建。您会立即注意到构建是挂起的，正在等待一个执行程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a2945055e47989752c89206a0b312ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*mvn2vcXzfbslMTM9"/></div></figure><p id="e99b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转到Jenkins主窗口，您会看到为这个构建分配了一个pod，但是它仍然是离线的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a376b09608d70d8b78ad569dcc9eda64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*sazZzz2rqdJCEVjs"/></div></figure><p id="570a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转到终端，运行以下命令:</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="ea5c" class="mz lc iq mv b gy na nb l nc nd">kubectl get pods</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi om"><img src="../Images/28331009bd70852c8bc9740f1aed806a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oxU5csyhY6mSRjRe"/></div></div></figure><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="9e54" class="mz lc iq mv b gy na nb l nc nd">kubectl get nodes</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/94a81cd54892234b68b1125165a7d469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lx_jl3lJklf1uXb9"/></div></div></figure><p id="db37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，已经创建了一个新的pod，但它仍处于<em class="mf">待定</em>状态。另外，注意已经创建了一个新节点(这可能需要几秒钟，我们需要提供一个Spot实例)，并且它仍然处于<em class="mf"> NotReady </em>状态。</p><p id="f167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等一下，再检查一下詹金斯的主窗口。您会注意到，在某个时候，构建在分配的pod上开始。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/2f4519df74c2cc81aa00e0e38c5c4094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/0*9I9cCoMzswDmGTyt"/></div></figure><p id="b293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查控制台，注意构建当前正忙于我们的<em class="mf"> sleep 300 </em>命令。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/39de38241f6425a108cc53b6c669f61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*789sQUIklrPadxrb"/></div></div></figure><p id="59d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到终端，运行相同的命令。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="4fde" class="mz lc iq mv b gy na nb l nc nd">kubectl get pods</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi op"><img src="../Images/4bef88e70de783922df33e27af95f2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IPZJLa6o6-h3qlsG"/></div></div></figure><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="bae3" class="mz lc iq mv b gy na nb l nc nd">kubectl get nodes</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/8b1878f597355f66becc27d60fe90a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nu9l2TH2aZ6IPtZK"/></div></div></figure><p id="cde8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，现在pod处于<em class="mf">运行</em>状态，节点处于<em class="mf">就绪</em>状态。</p><p id="ff3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待构建完成，然后再次执行命令。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="c1e9" class="mz lc iq mv b gy na nb l nc nd">kubectl get pods</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/63ad83f0080842a4d691b2e22f389202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cEt9JnprteHFVaHM"/></div></div></figure><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="d6d6" class="mz lc iq mv b gy na nb l nc nd">kubectl get nodes</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/cef5bde09096010eede17e4e39a71b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U0YZ48n2zIpUC25J"/></div></div></figure><p id="97b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，pod现在已经消失了，但是节点还在。如果您现在执行另一个Jenkins构建，将会在这个节点上立即创建一个新的pod。</p><p id="edad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们部署的集群autoscaler服务正在等待节点空闲几分钟，然后再进行缩减。</p><p id="eb89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待几分钟，然后再次运行该命令。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="50fe" class="mz lc iq mv b gy na nb l nc nd">kubectl get nodes</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/f3d5723c36c6b328d606b7f7a6f42e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9isp4FKb9K2WDxuM"/></div></div></figure><p id="8054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，该节点现在已经消失了。</p><h1 id="79f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="2788" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">维护具有许多不同流程和需求的CI/CD环境不是一件容易的事情，转向容器化实现是一种受欢迎的方法，但也是许多组织一再推迟的巨大变化。</p><p id="54ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在这里展示了一个基本的用例来解释这种实现的概念和功能。我相信根据您的特定需求进行调整并添加不同的项目会相对容易，每个项目都运行在一个具有预定义资源的独特映像上。</p><p id="eb08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将Jenkins与AWS Spot实例一起直接使用是一个很好的解决方案，但是即使我们将远非完美的集成放在一边，当涉及到具有不同需求的不同流程时，维护起来也是困难和昂贵的。我认为简单地添加新的pod模板更有意义。</p><p id="3879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要了解更多关于EKS及其功能的信息，请访问https://docs.aws.amazon.com/eks/index.html的EKS AWS文档。</p><p id="54e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你还应该参考亚马逊提供的这个EKS在线研讨会，它也可以帮助你入门，并向你介绍https://eksworkshop.com/<a class="ae me" href="https://eksworkshop.com/" rel="noopener ugc nofollow" target="_blank">的所有EKS特色。</a></p><p id="210c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有，看看我之前在EKS发的帖子，可能也有帮助:<a class="ae me" href="https://medium.com/@hawkseye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-amazon-eks-bd2ab8ef56cc?source=friends_link&amp;sk=5035b1196cc98cf2a5858e736d64bf51" rel="noopener">https://medium . com/@ hawks eye/turn-your-own-docker-image-into-an-auto-scaling-kubernetes-deployment-using-Amazon-eks-BD 2 ab 8 ef 56 cc？source = friends _ link&amp;sk = 5035 b 1196 cc 98 cf 2 a 5858 e 736d 64 BF 51</a>。</p></div></div>    
</body>
</html>