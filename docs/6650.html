<html>
<head>
<title>TypeScript schema validation with Zod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Zod进行TypeScript模式验证</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-schema-validation-with-zod-220734559284?source=collection_archive---------2-----------------------#2022-01-17">https://itnext.io/typescript-schema-validation-with-zod-220734559284?source=collection_archive---------2-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b4b2f778379c08d3a5abc87d63b0657f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9ay0JyHm1p1uQhyoE1g4w.png"/></div></div></figure><p id="cadc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将描述使用<a class="ae kz" href="https://github.com/colinhacks/zod" rel="noopener ugc nofollow" target="_blank"> Zod </a>为你的项目设置模式验证。</p><p id="86e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Zod是一个用于模式声明和验证的开源类型脚本库。我们将研究为什么使用Zod进行模式验证，提供如何使用它的示例，并将其与其他库进行比较。</p><h1 id="7bb3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是模式验证，为什么需要它？</h1><p id="0a4b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">模式验证是验证数据结构符合特定模式的过程。您可以使用它来确保输入数据的有效性，以及记录和实施您的应用程序的数据结构。</p><p id="84f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用模式验证有两个主要好处:</p><ul class=""><li id="422f" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">运行时的数据完整性:确保数据以正确的格式输入到系统中有助于避免错误并保持数据的一致性。虽然TypeScript可以帮助您确保编译时的类型安全，但当您处理来自未知(如服务器或用户输入)的数据时，模式验证在运行时会大放异彩。</li><li id="c8bf" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">文档:一个好的模式验证库将为您使用的数据结构提供准确的类型定义。类型定义可用于为项目生成静态文档。</li></ul><h1 id="de5b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么要用佐德？</h1><p id="afd5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然有许多类型脚本模式验证库，但Zod是最好的一个。在为您的项目选择库时，除了它的特性集之外，您还应该考虑它的实现细节。</p><p id="8110" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Zod没有依赖性，这意味着您可以安装和使用Zod，而不需要任何其他库，这将有助于您保持较小的软件包大小。</p><p id="8406" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Zod可以在Node.js和所有主流浏览器(包括IE 11)中运行。这对于需要支持广泛平台的项目来说是一个很好的选择。</p><p id="5d8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Zod被设计成是类型脚本优先的，这意味着库将自动为您的数据结构推断静态类型脚本类型。这消除了两次声明类型的需要——一次在Zod中，另一次在TypeScript中。这将为您节省大量的输入时间，并帮助您保持代码变更的同步。</p><p id="3600" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Zod的API简洁且可链接。这使得创建复杂的数据模式变得容易。您还可以轻松地将简单的模式组合成更复杂的数据模式。</p><h1 id="557d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Zod进行模式验证的示例</h1><h2 id="5d92" class="mr lb it bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">基元</h2><p id="5592" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们从最简单的例子开始——原语。Zod使得创建简单的模式来验证原语变得极其容易。</p><p id="89e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如何验证一个字符串。假设我们想要验证用户输入的密码。我们希望密码为非空字符串，长度至少为8个字符，最多为32个字符:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3491" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您运行上面的代码时，您会看到parse方法抛出了一个异常。该异常将包含一个包含错误详细描述的<code class="fe nj nk nl nm b">ZodError</code>对象数组:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9d6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您试图解析一个有效的字符串时，zorse将简单地返回它的值。</p><h2 id="8a91" class="mr lb it bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">目标</h2><p id="a2f5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在让我们来看看物体。Zod对验证嵌套对象结构有强大的支持。</p><p id="1e18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个模式来验证用户对象。它将包含以下字段:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e3bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了声明模式，我们使用了<code class="fe nj nk nl nm b">z.object</code>()方法:</p><p id="83a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们尝试根据刚刚创建的模式验证一个示例对象:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="76d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl nm b">parse</code>方法将返回一个包含解析结果的对象。由于我们忘记在示例中提供<code class="fe nj nk nl nm b">phoneNumber</code>字段，Zod将抛出一个异常，包含以下一系列错误:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="30d3" class="mr lb it bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">类型推理</h2><p id="495a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们还可以从模式对象中推断出类型。在这一部分，您可以免费获得模式的类型定义，并在您的应用程序中使用它们:</p><p id="faf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl nm b">type UserType = z.infer&lt;typeof User&gt;;</code></p><h2 id="f9ee" class="mr lb it bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">构成模式</h2><p id="1e17" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Zod使得在一个模式的基础上构建复杂的模式变得容易，就像构建乐高积木一样。</p><p id="d8b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了演示这一点，让我们使用上面的<code class="fe nj nk nl nm b">User</code>模式，构建一个更详细的用户对象，它有一个爱好:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="da7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过合并我们的两个模式，我们创建了一个新的模式，您可以用它来验证用户对象是否有合适的爱好字段。</p><p id="19bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Zod还有许多其他有用的方法，可以在这里找到。</p><p id="c959" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在现有模式的基础上构建新模式是一个很好的方法，因为它可以帮助您保持数据结构中的所有变化同步。</p><h2 id="97eb" class="mr lb it bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">警告</h2><p id="20b9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在使用Zod进行验证时，有几件事情需要记住。</p><p id="6ed5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">安全解析</strong></p><p id="01b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果不想让Zod抛出异常，解析失败时，可以用<code class="fe nj nk nl nm b">safeParse</code>方法代替。这将返回一个包含解析结果的对象:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3ca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">未识别的密钥被剥离</strong></p><p id="dd69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，Zod模式在解析过程中去掉无法识别的键。这意味着任何未知的键都将被忽略。</p><p id="f38f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果想传递未识别的键而不丢失它们，可以使用<code class="fe nj nk nl nm b">.passthrough()</code>方法。</p><p id="f26d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">订单事项</strong></p><p id="a650" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">的。array()方法返回一个新的ZodArray实例，这意味着调用方法的顺序很重要。通过改变链中调用的顺序，您可以获得完全不同的模式结果:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="cdec" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Zod与其他库的比较</h1><p id="18d8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">其他广泛使用的模式验证库也是不错的选择，比如yup和io-ts。</p><p id="6b0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是Zod可能是您的项目的更好选择的一些原因:</p><ul class=""><li id="2b13" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">TypeScript优先支持。Zod是在考虑到TypeScript的情况下构建的，并且拥有一流的支持。这意味着您可以获得自动补全和出色的VsCode支持。</li><li id="5679" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">免费的类型推断—无需额外工作即可获得模式的类型。</li><li id="4d86" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">易于组合的模式—通过组合不同的模式来构建复杂的验证规则。</li><li id="4a17" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">强大的错误处理。Zod内置了出色的错误处理功能，提供了丰富的API来配置您的错误处理流程。</li><li id="1511" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">支持承诺和函数模式。如果你需要验证一个功能或承诺，Zod可以满足你。</li></ul><h1 id="eae8" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="7523" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这篇文章中，我们介绍了如何使用Zod库进行TypeScript模式验证。我们研究了如何创建模式并使用模式来验证数据结构。我们还看到了使用Zod时需要注意的一些事情，以及它相对于其他库的优势。</p><p id="521a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解关于Zod的更多信息，请务必查看Github页面上的<a class="ae kz" href="https://github.com/colinhacks/zod" rel="noopener ugc nofollow" target="_blank">优秀文档</a>。在那里，您可以找到如何使用Zod提供的所有功能的详细示例。</p><p id="c881" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae kz" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter </a>上关注我，在那里我分享我学到的东西。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="deff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nu">原载于2022年1月17日https://isamatov.com</em><a class="ae kz" href="https://isamatov.com/typescript-schema-validation-with-zod/" rel="noopener ugc nofollow" target="_blank"><em class="nu"/></a><em class="nu">。</em></p></div></div>    
</body>
</html>