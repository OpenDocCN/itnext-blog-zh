<html>
<head>
<title>PostgreSQL Docker image with SSL certificate signed by a custom Certificate Authority (CA)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL Docker映像，带有由自定义证书颁发机构(CA)签名的SSL证书</h1>
<blockquote>原文：<a href="https://itnext.io/postgresql-docker-image-with-ssl-certificate-signed-by-a-custom-certificate-authority-ca-3df41b5b53?source=collection_archive---------2-----------------------#2018-10-09">https://itnext.io/postgresql-docker-image-with-ssl-certificate-signed-by-a-custom-certificate-authority-ca-3df41b5b53?source=collection_archive---------2-----------------------#2018-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最近需要使用PostgreSQL的一个实例作为我们开发环境的一部分，这引发了许多问题——我们在IBM Cloud中提供一个实例吗？还是我们使用自己的(虚拟化)硬件托管一个实例？或者我们采用预构建的Docker映像并在本地运行它？</p><p id="2899" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们已经使用Docker作为我们开发环境的一部分，所以选择并不困难(更不用说没有人愿意因为在IBM Cloud中提供一个实例而产生交叉收费)。那是码头工人的形象。到目前为止，一切顺利。我们从<a class="ae ko" href="https://hub.docker.com/_/postgres/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/_/postgres/</a>获得官方的9.6图像，然后我们开始运行。</p><p id="a4b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要确保我们所有的PostgreSQL客户端代码都需要到PostgreSQL服务器的SSL连接——因此我们需要修改Docker映像以开始使用SSL连接。这说起来容易做起来难。</p><h1 id="0f91" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">简单自签名证书</h1><p id="5f6d" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们的第一个尝试是为PostgreSQL服务器生成一个自签名证书，并基于引用我们生成的证书的官方PostgreSQL映像创建我们自己的Docker映像。</p><p id="979e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在找出正确的<em class="ls"> openssl </em>命令序列后，当从Python客户端(【https://pypi.org/project/psycopg2】)连接到PostgreSQL时，我们有了一些工作。Python客户端允许我们指定PostgreSQL服务器的自签名证书，这意味着客户端将信任该证书，即使它不是由证书颁发机构(CA)签名的。</p><p id="73f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这不足以允许来自Node.js客户端(<a class="ae ko" href="https://node-postgres.com/" rel="noopener ugc nofollow" target="_blank">https://node-postgres.com</a>)的SSL连接，因为Node.js客户端使用的底层SSL连接不允许信任自签名证书，除非它已经由另一个证书签名(其中<em class="ls">可以是</em>自签名)。如果不这样做，它会产生错误<em class="ls">DEPTH _ ZERO _ SELF _ SIGNED _ CERT</em>。有很多关于通过设置<em class="ls">NODE _ TLS _ REJECT _ UNAUTHORIZED</em>来解决这个问题的讨论，但这不是我们想要做的事情，因为它会关闭所有的SSL验证。</p><h1 id="5ab6" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">作为自定义证书颁发机构(CA)的签名证书</h1><p id="86fd" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">为了克服这个问题，我们意识到我们必须创建一个证书，并使用我们自己的自定义证书颁发机构(CA)进行签名。<em class="ls"> openssl </em>命令的序列现在变得足够复杂，我们创建了一个脚本来生成所需的证书工件，如图所示。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="dd2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个脚本生成了几个文件，但是下面描述了感兴趣的主要文件。对于感兴趣的人，可以在这里看到脚本的完整输出。</p><ul class=""><li id="e552" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated"><em class="ls"> rootCA.crt </em>我们自定义CA的公共证书。这是应该添加到客户端信任存储中的证书(通常通过对证书文件进行base64编码来完成)。</li><li id="1fa5" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><em class="ls"> rootCA.key </em>自定义CA的私钥，需要使用自定义CA签署PostgreSQL服务器的证书。</li><li id="b92d" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">PostgreSQL服务器的公共证书，已经由我们的自定义CA签名，PostgreSQL Docker映像需要该证书。</li><li id="748e" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><em class="ls">server . key</em>PostgreSQL Docker映像所需的PostgreSQL证书的私钥。</li></ul><p id="ee81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还有一个开发环境需求，允许使用3个不同的主机名来寻址PostgreSQL服务器实例:<em class="ls"> localhost </em>、<em class="ls"> aios-localhost </em>和<em class="ls"> postgres_ssl </em>。在SSL握手级别，这是通过在生成PostgreSQL服务器证书<em class="ls">和由我们的自定义CA签名时指定主题备用名称(SAN)扩展来实现的。</em></p><h1 id="0235" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">PostgreSQL Dockerfile文件</h1><p id="0e84" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">现在，SSL证书已经生成并签名，提取它的Dockerfile文件实际上非常简单，如下所示:</p><pre class="lt lu lv lw gt mo mp mq mr aw ms bi"><span id="836e" class="mt kq it mp b gy mu mv l mw mx">FROM postgres:9.6<br/>LABEL "Product"="PostgreSQL (SSL enabled)"</span><span id="a496" class="mt kq it mp b gy my mv l mw mx">COPY ssl/server.key /var/lib/postgresql/server.key<br/>COPY ssl/server.crt /var/lib/postgresql/server.crt<br/>RUN chown postgres /var/lib/postgresql/server.key &amp;&amp; \<br/>    chmod 600 /var/lib/postgresql/server.key</span></pre><p id="6976" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<em class="ls"> pgAdmin </em>验证连接显示该连接是基于SSL的，并且我可以使用SSL模式<em class="ls"> Verify-Full </em>指定我的自定义CA公共证书的路径。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/a100a9d68a2cce5687118f99542ad5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inLHu8z81772bbf6oUjJgQ.png"/></div></div></figure></div></div>    
</body>
</html>