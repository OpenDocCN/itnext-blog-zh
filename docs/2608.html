<html>
<head>
<title>Thinking of BEM as a UI Philosophy Instead of a CSS Naming Convention</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将BEM视为一种UI理念，而不是CSS命名惯例</h1>
<blockquote>原文：<a href="https://itnext.io/thinking-of-bem-as-a-ui-philosophy-instead-of-a-css-naming-convention-9727e2cf9328?source=collection_archive---------4-----------------------#2019-06-23">https://itnext.io/thinking-of-bem-as-a-ui-philosophy-instead-of-a-css-naming-convention-9727e2cf9328?source=collection_archive---------4-----------------------#2019-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0a1e044b9be593965edc70b7e6b1317b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Q5xEgE9COyn83mLyMNX8w.png"/></div></div></figure><p id="1dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">边界元法是一个非常好的概念，因为它以一种非常可行的方式解决了一个非常现实的问题。它有很好的个性，只是很不幸很丑。作为一种CSS命名惯例，你可以从BEM学到很多关于如何构造你的ui，即使你不使用CSS来设计样式。这就是我喜欢它的地方，因为它帮助塑造了我的思维方式，它可以帮助塑造我们整体开发的方式，而不仅仅是在造型方面。</p><p id="13cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑一个折叠式UI元素。让我们考虑像XML/HTML/JSX这样的标记语言。标记形式的手风琴的理想表现形式是什么？它肯定是这样的:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f062" class="lf lg iq lb b gy lh li l lj lk">&lt;Accordion&gt;<br/>  &lt;Panel active&gt;<br/>    &lt;Title /&gt;<br/>    &lt;Content /&gt;<br/>  &lt;/Panel&gt;</span><span id="6230" class="lf lg iq lb b gy ll li l lj lk">  &lt;Panel&gt;<br/>    &lt;Title /&gt;<br/>    &lt;Content /&gt;<br/>  &lt;/Panel&gt;<br/>&lt;/Accordion&gt;</span></pre><p id="b271" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，没有BEM的暗示，我们已经可以提出这个例子有一个外部父代<code class="fe lm ln lo lb b">Block</code> ( <code class="fe lm ln lo lb b">Accordion</code>)，子代<code class="fe lm ln lo lb b">Elements</code> ( <code class="fe lm ln lo lb b">Panel</code>，<code class="fe lm ln lo lb b">Title</code>和<code class="fe lm ln lo lb b">Content</code>)，我们可以把<code class="fe lm ln lo lb b">active</code>属性看作一个修饰符。这是一个本宾果。我应该能够以这种方式考虑任何UI元素。BEM作为一种CSS命名惯例如此有效的原因不是因为一些很酷的CSS东西，而是因为它迫使HTML以一种明智的方式构造，这允许你以一种新的眼光来看待ui。现在，您只有块、元素和修饰符，而不是父div和嵌套的子div以及各种类名。</p><p id="8f2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用BEM命名约定将上面的伪代码写成HTML时，它看起来类似于:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0d68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果遵循得当，使用BEM创建一个干净且结构良好的DOM树是非常容易的。作为一种哲学，它有如此大的潜力，以至于我真的不能相信它表现为一个CSS命名约定而不是一个成熟的框架，或者类似于类似于<a class="ae ls" href="http://bradfrost.com/blog/post/atomic-web-design/" rel="noopener ugc nofollow" target="_blank">原子设计</a>的某种高级约定(尽管我猜它是相似的)。</p><p id="495a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过用BEM术语考虑UI，不管使用什么技术，我们都可以开发具有更友好的API的工具，使我们能够更容易地渲染、设计UI组件并与之交互。</p><h1 id="6997" class="lt lg iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">渲染组件</h1><p id="b15a" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如果我使用React之类的东西来呈现我的ui，这些都不会改变。我仍然应该创建ui，同时考虑块、元素和修饰符，而不是父React组件和嵌套子组件。同样，我在构建HTML UIs时不应该考虑div，我在构建React UIs时也不应该考虑React组件(至少在创建<a class="ae ls" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表示组件</a>；容器组件不适用，因为它们不呈现标记)。</p><p id="f9cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们当然可以使用React来创建BEM HTML类似于:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="b47e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…这真的很好，只是不太理想。如果我们知道我们考虑的是块和元素，而不是div，为什么不努力做到这样呢:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对人类来说可读性更强(这就是为什么我认为边界元法的概念如此有效；它帮助人类更容易地解释DOMs)。</p><h2 id="efe4" class="lf lg iq bd lu mv mw dn ly mx my dp mc kj mz na mg kn nb nc mk kr nd ne mo nf bi translated">输入:Lucid</h2><blockquote class="ng nh ni"><p id="534a" class="jy jz lp ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><a class="ae ls" href="https://github.com/One-Nexus/Lucid" rel="noopener ugc nofollow" target="_blank"> Lucid </a>是一套用于渲染BEM DOM元素的高阶React组件</p></blockquote><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/37c0c7c416fa284517f0f639260c3592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BR8FA2_MGDzLxjOQL-uK3w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><a class="ae ls" href="http://---      ---  Twitter | Github" rel="noopener ugc nofollow" target="_blank">在Github上查看Lucid</a></figcaption></figure><p id="0258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的例子是使用Lucid时的有效代码。查看这些文章以及<a class="ae ls" href="https://github.com/One-Nexus/Lucid" rel="noopener ugc nofollow" target="_blank"> Lucid Github页面</a>了解更多信息:</p><ul class=""><li id="3991" class="nq nr iq ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/using-react-lucid-to-create-a-bem-accordion-c7f8475d38a4" rel="noopener">使用React + Lucid创建BEM手风琴</a></li><li id="ce5e" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/polymorph-react-react-bem-javascript-styles-8f28a77a43b6" rel="noopener">多态&amp;反应(反应+ JavaScript样式)</a></li></ul><h1 id="9e5b" class="lt lg iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">与组件交互</h1><p id="f550" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如果没有任何工具公开BEM like API来与DOM元素交互，要使上面HTML示例中的accordion工作，下面的JavaScript就足够了:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="2e17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…同样，这段代码并没有什么问题，但是因为我们是用边界元法来思考的，所以更好的改写应该是这样的:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="6a20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…如果你把它分解开来，它会做完全相同的事情，只不过使用了一个与BEM一致的更加人性化的API。</p><h2 id="ba27" class="lf lg iq bd lu mv mw dn ly mx my dp mc kj mz na mg kn nb nc mk kr nd ne mo nf bi translated">输入:sQuery</h2><blockquote class="ng nh ni"><p id="fc03" class="jy jz lp ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">sQuery是一个用于与BEM DOM元素交互的库</p></blockquote><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/69ea26c8afcad7eeac9154339626e525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmyNZXvUk1E-U4Cb6sda8g.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><a class="ae ls" href="https://github.com/One-Nexus/sQuery" rel="noopener ugc nofollow" target="_blank">查看Github上的查询</a></figcaption></figure><p id="f8eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码可以用sQuery实现。查看这些文章以及<a class="ae ls" href="https://github.com/One-Nexus/sQuery" rel="noopener ugc nofollow" target="_blank"> sQuery Github页面</a>了解更多信息:</p><ul class=""><li id="a039" class="nq nr iq ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/using-squery-to-create-an-accordion-with-bem-markup-93340c4c676e" rel="noopener">使用sQuery创建一个带有BEM标记的手风琴</a></li><li id="5b6d" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/creating-an-accordion-with-squery-polymorph-a7991a8f5e3c" rel="noopener">用sQuery+polymer form创建手风琴</a></li></ul><h1 id="9946" class="lt lg iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">样式组件</h1><h2 id="1202" class="lf lg iq bd lu mv mw dn ly mx my dp mc kj mz na mg kn nb nc mk kr nd ne mo nf bi translated">使用Sass</h2><p id="7e80" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在没有任何预处理器的情况下，用CSS来设计BEM标记就像在HTML中使用它一样难看。使用普通的Sass，您可以通过使用&amp;符号获得相当好的结果:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="813e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本样式很好，但是当我们开始需要更多的逻辑时(比如根据父<code class="fe lm ln lo lb b">panel</code>元素上的修饰符来设计<code class="fe lm ln lo lb b">content</code>元素的样式),它会变得不那么漂亮:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="4c17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe lm ln lo lb b">&amp;</code>的目的是避免重复关键字，保持代码干燥。在没有引入任何复杂需求的情况下，我们已经不得不打破这个规则。你可以做一些事情来处理这个问题，但是从长远来看，这样做只会增加代码的冗长。更好的方法可能是使用mixins来处理您需要的行为，留给我们一个API，类似于:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="f1b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它仍然是常规的Sass，没有引入任何新的范例，并且与BEM保持一致。实现相同目标的一种更简单的方法是:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3f11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从遵循级联规则的Sass的角度来看，这可能是从DX的角度来看可能得到的最好结果。</p><p id="ec14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">回车:单元格</strong></p><blockquote class="ng nh ni"><p id="affb" class="jy jz lp ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><a class="ae ls" href="https://github.com/One-Nexus/Cell" rel="noopener ugc nofollow" target="_blank">单元格</a>是一个Sass库，用于样式化BEM DOM元素</p></blockquote><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6ffedc384d10ec42f42df2f9acc84a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRSgOfWSZ7bg4G4IHuFqDg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><a class="ae ls" href="https://github.com/One-Nexus/Cell" rel="noopener ugc nofollow" target="_blank">查看Github上的单元格</a></figcaption></figure><p id="41f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面使用的两个例子都可以使用Cell。查看<a class="ae ls" href="https://github.com/One-Nexus/Cell" rel="noopener ugc nofollow" target="_blank"> Cell Github页面</a>了解更多信息。</p><h2 id="e151" class="lf lg iq bd lu mv mw dn ly mx my dp mc kj mz na mg kn nb nc mk kr nd ne mo nf bi translated">使用JavaScript</h2><p id="e9b8" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">使用JavaScript以符合BEM的方式处理样式并不需要与Sass中的方式有太大的不同(至少后一个例子是这样的):</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="67bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…您可以看到它与前面的Sass示例是多么相似——一行一行都是一致的。这不是巧合，只是当你把你的需求简化成像BEM这样的哲学时，不管你使用什么技术，你做事情的方式最终都是相似的。由于Sass映射实际上与JavaScript对象相同(出于所有意图和目的)，所以它们看起来完全相同是有道理的。</p><p id="ac6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个对象可以被提供给一个函数，这个函数也接受一个BEM DOM元素或者元素的节点列表，瞧；DX-delight…</p><p id="2621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">输入:多形态</strong></p><blockquote class="ng nh ni"><p id="c044" class="jy jz lp ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">是一个JavaScript工具，用于设计BEM DOM元素的样式</p></blockquote><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f9ed007ca00ca9eef1d2d9fab65e038d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_ia1qOztAD3BsRymSBC_w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><a class="ae ls" href="https://github.com/One-Nexus/Polymorph" rel="noopener ugc nofollow" target="_blank">在Github上查看变形</a></figcaption></figure><p id="361e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">polymer是一个很好的工具，用于设计遵循Synergy/BEM命名约定的DOM元素，查看<a class="ae ls" href="https://github.com/One-Nexus/Polymorph" rel="noopener ugc nofollow" target="_blank">polymer Github页面</a>和以下文章了解更多信息:</p><ul class=""><li id="39c3" class="nq nr iq ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/using-polymorph-to-style-a-bem-accordion-javascript-styles-2fd4ca1898b3" rel="noopener">使用多形字设计BEM手风琴样式(JavaScript样式)</a></li><li id="2534" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/creating-an-accordion-with-squery-polymorph-a7991a8f5e3c" rel="noopener">用sQuery+polymer form创建手风琴</a></li><li id="a2cd" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated"><a class="ae ls" href="https://medium.com/@ESR360/polymorph-react-react-bem-javascript-styles-8f28a77a43b6" rel="noopener">多态&amp;反应(反应+ JavaScript样式)</a></li></ul><h1 id="3f36" class="lt lg iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="5c1a" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们已经研究了处理UI组件的渲染、交互和样式的工具，同时沿着BEM的思路进行思考。当你考虑到UI组件中的所有东西时，差不多就是这样了。还记得我以前说过，我不相信BEM范式仅仅表现为CSS命名约定，而不是成熟的框架吗？这就是我决定实现它的原因(<a class="ae ls" href="https://medium.com/@ESR360/today-i-finished-a-side-project-i-started-4-years-ago-and-all-i-have-to-show-for-it-is-this-shitty-dd573099f7dc" rel="noopener">而我只花了4年</a>就走到了这一步)。</p><h2 id="1702" class="lf lg iq bd lu mv mw dn ly mx my dp mc kj mz na mg kn nb nc mk kr nd ne mo nf bi translated">引入协同效应</h2><blockquote class="ng nh ni"><p id="f14b" class="jy jz lp ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">Synergy是一个为React-DOM项目构建模块化、可配置和可伸缩的UI组件的框架</p></blockquote><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b050d19d18376ace57d318ef0f09b533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4yQuJ6XZDdVBfg_mI80nQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><a class="ae ls" href="https://github.com/One-Nexus/Synergy" rel="noopener ugc nofollow" target="_blank">在Github上查看Synergy</a></figcaption></figure><p id="d866" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ls" href="https://github.com/One-Nexus/Synergy" rel="noopener ugc nofollow" target="_blank"> Synergy </a>本质上是一个工具箱，由我们在本文中看到的工具组成。使用Synergy，您可以创建Synergy模块，用技术术语来说，这些模块实际上就是React组件(用Lucid创建),用于绑定样式(使用Polymorph/sQuery)。Synergy模块被设计为单一导入/导出，一切都是现成的，正如我制作的这张很酷的图形所强调的:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/f0d59ec351c46f1d343879d0cba91a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiTOBOI-R7sIjwN8txlT2w.png"/></div></div></figure><p id="e46b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Synergy，我们可以将上面使用的所有想法结合起来，从头开始创建一个实用的、有风格的手风琴:</p><blockquote class="ng nh ni"><p id="a9f5" class="jy jz lp ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">除了<em class="iq">块</em>被称为“模块”和<em class="iq">元素</em>被称为“组件”(即<a class="ae ls" href="https://github.com/One-Nexus/Synergy-Front-End-Guides/wiki/Synergy-Values#3-naming-convention" rel="noopener ugc nofollow" target="_blank">协同命名约定</a>)之外，下面使用的约定与BEM相同</p></blockquote><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="04cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在没有任何其他工具的情况下，导入这个手风琴并用<code class="fe lm ln lo lb b">&lt;Accordion {...props} /&gt;</code>渲染，将会输出一个具有风格和功能的手风琴。尽管BEM是一种CSS命名约定，并且从技术上讲没有在上面的例子中使用，我仍然认为上面的例子是BEM哲学的结果。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/0f4eaa82f76695a20f09ba4fa9fd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbifSkjSDCs7zGgIwXMiwg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><a class="ae ls" href="https://twitter.com/esr360" rel="noopener ugc nofollow" target="_blank"> Twitter </a> | <a class="ae ls" href="https://github.com/esr360" rel="noopener ugc nofollow" target="_blank"> Github </a></figcaption></figure></div></div>    
</body>
</html>