<html>
<head>
<title>Client-Side Rendering vs. Server-Side Rendering vs. Pre-rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">客户端渲染与服务器端渲染与预渲染</h1>
<blockquote>原文：<a href="https://itnext.io/client-side-rendering-vs-server-side-rendering-vs-pre-rendering-5d5962221925?source=collection_archive---------3-----------------------#2020-09-21">https://itnext.io/client-side-rendering-vs-server-side-rendering-vs-pre-rendering-5d5962221925?source=collection_archive---------3-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/95cd5128e50493a032412ef5eeee7f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2b30iIbFVGxbEij_WUrnQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.blog.duomly.com/client-side-rendering-vs-server-side-rendering-vs-prerendering/" rel="noopener ugc nofollow" target="_blank">客户端渲染对比服务器端渲染对比预渲染</a></figcaption></figure><p id="6bb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文原载于<a class="ae kf" href="https://www.blog.duomly.com/client-side-rendering-vs-server-side-rendering-vs-prerendering/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/client-side-rendering-vs-server-side-rendering-vs-pre rendering/</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0e93" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">客户端渲染与服务器端渲染简介</h1><p id="b1d2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们可以用现有的技术创建令人惊叹的web应用程序和网站，但是仍然需要考虑性能。开发人员互相超越，以在他们的项目中实现加载速度和用户体验的最佳结果。在这一点上，有许多关于应用程序呈现方式的讨论。</p><p id="e7aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在现代前端框架开始如此普遍地使用之前，网站已经呈现在服务器上，并且准备就绪。html文件被发送到浏览器。</p><p id="e1f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当开发人员开始使用ReactJS或Angular时，网页开始在浏览器中呈现。话说回来，为了加快加载速度和改善用户体验，像Next.js这样的服务器端渲染框架开始变得更加流行。</p><p id="ecbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一种预渲染，这是渲染web应用程序的另一种方法。但是哪一个最适合你的下一个项目呢？</p><p id="328e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将详细介绍这三个概念，客户端渲染、服务器端渲染和预渲染，逐一解释并进行比较。</p><p id="1218" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢看，然后阅读，请随时加入我们的YouTube频道。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4461" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看可用解决方案之间的区别是什么！</p><h1 id="0095" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">什么是客户端渲染(CSR)？</h1><p id="ce80" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">客户端呈现是在浏览器端呈现网页的一种方式。自从现代前端框架普及了这种解决方案，这种方法就变得普遍使用。因为现在大多数应用程序都是用ReactJS或Angular创建的，所以它们也使用客户端渲染。</p><p id="e522" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我根据下图来解释客户端渲染是如何工作的。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ec88fb29d63518f5c928b26b466ac441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wBv8-CIMCjZhdo4c2lIZng.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">什么是客户端渲染？</figcaption></figure><p id="9a5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户在浏览器中输入一个地址时，服务器用一个空的HTML文件响应，Javascript负责呈现所有内容。</p><p id="df17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下载完所有的Javascript之前，用户可以看到一个空页面或加载屏幕，这取决于开发人员。Javascript下载的时候需要把所有的东西都编译好，接下来的内容才能展示给用户。</p><p id="c2a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果需要任何额外的数据来显示屏幕并使网页完全交互，Javascript可能会执行一些API调用。</p><p id="0d7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在客户端渲染的情况下，初始加载稍微慢一点，但是之后，每次加载都非常快。此外，不需要重新呈现整个UI，只需要改变单个元素。</p><p id="6ce8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您了解客户端渲染是如何工作的，那么是时候来看看服务器端渲染了。</p><h1 id="d4fb" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">什么是服务器端渲染？</h1><p id="a6c5" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">服务器端呈现是呈现网页的另一种方式，但是这种方式在服务器中呈现内容并发送就绪。html文件到浏览器。让我们看一下说明流程的图形。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0b64ec788f3e2e57f3969cf58bc7af9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfWcvvaK6fO_HpjEq4mGGQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">什么是服务器端渲染？</figcaption></figure><p id="89a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户在浏览器中输入地址时，请求会发送到服务器。接下来，服务器准备特定的HTML文件，获取特定视图所需的数据。服务器将这个文件发送到浏览器，它将内容呈现在屏幕上，这样用户就可以看到了。<br/>整个过程完全发生在服务器上，每次用户触发任何动作时都会重复。</p><p id="5f26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们关注第三种可能性，即预渲染。</p><h2 id="568d" class="na lm it bd ln nb nc dn lr nd ne dp lv kr nf ng lz kv nh ni md kz nj nk mh nl bi translated">服务器端渲染框架</h2><p id="608d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><strong class="ki iu">Angular</strong>:Angular Universal<br/>T5】ReactJS:自定义设置react js，next . js<br/>T8】vue js:nuxt . js</p><h1 id="b2d4" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">什么是预渲染？</h1><p id="6abe" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">虽然在一些项目中，服务器端渲染在其他项目中可能很棒，但这可能是一场噩梦。为了结合两种解决方案的优点，这是另一种可以用来渲染项目的方法，即预渲染。</p><p id="81be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预渲染是服务器端渲染和客户端渲染之间的权衡。当用户输入浏览器的地址时，服务器发回静态的。带Javascript的html，在后台加载。用户可以看到静态网站，但是在Javascript完全下载之前没有交互性。然后Javascript获取特定视图的必要数据，并将用户重定向到正确的文件，但它是不可见的。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/f95eb521a17bf72b7941c77e40658bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFjOC0LlInuqIAMPFaoJ0A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">什么是预渲染？</figcaption></figure><p id="1d64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预渲染是一个很好的想法，特别是如果你关心你的页面的搜索引擎优化，因为机器人可以读取预渲染的内容。</p><h1 id="29f4" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">比较</h1><p id="7e0c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当我们知道每种渲染方式的工作原理以及它们之间的区别时，我们就可以考虑它们的优缺点，这样我们就能够总结出在不同的项目中使用任何一种解决方案。</p><h2 id="8aea" class="na lm it bd ln nb nc dn lr nd ne dp lv kr nf ng lz kv nh ni md kz nj nk mh nl bi translated">客户端渲染</h2><p id="af07" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><strong class="ki iu">优点:</strong></p><ul class=""><li id="9494" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">初始加载后快速渲染</li><li id="152b" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">适用于具有大量逻辑的web应用程序，以及需要授权的大部分</li><li id="60eb" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">许多支持CSR的Javascript框架和库</li></ul><p id="51fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">缺点:</strong></p><ul class=""><li id="da4b" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">低搜索引擎优化</li><li id="6f3e" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">初始加载可能需要一些时间</li></ul><p id="7093" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">何时使用客户端渲染？</strong></p><ul class=""><li id="adbb" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">如果您的应用程序有大量动态数据</li><li id="f170" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序有一个非常复杂的UI</li><li id="ed01" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序关注大量用户</li><li id="490d" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序需要授权才能被访问</li><li id="e59d" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序没有很多用于SEO的内容</li></ul><h2 id="7075" class="na lm it bd ln nb nc dn lr nd ne dp lv kr nf ng lz kv nh ni md kz nj nk mh nl bi translated">服务器端渲染</h2><p id="d797" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><strong class="ki iu">优点:</strong></p><ul class=""><li id="9b5c" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">搜索引擎机器人可以抓取更好的搜索引擎优化</li><li id="04a2" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">初始加载更快</li></ul><p id="2ac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">缺点:</strong></p><ul class=""><li id="0513" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">大量的服务器请求</li><li id="3244" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">整页重新加载</li><li id="6a47" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">当应用程序具有大量交互性时，渲染速度较慢</li></ul><p id="a1b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">什么时候使用服务器端渲染？</strong></p><ul class=""><li id="cb5f" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">如果您的应用程序UI很复杂，但是交互性很少</li><li id="abf7" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序是一个更加静态的页面</li><li id="b88b" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果用户数量不大</li></ul><h2 id="ad8f" class="na lm it bd ln nb nc dn lr nd ne dp lv kr nf ng lz kv nh ni md kz nj nk mh nl bi translated">预退保</h2><p id="1adf" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><strong class="ki iu">优点:</strong></p><ul class=""><li id="3259" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">更好的首次加载用户体验</li><li id="c70d" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">更好的搜索引擎优化</li><li id="9492" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">比SSR的请求更少</li></ul><p id="4258" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">缺点:</strong></p><ul class=""><li id="4904" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">需要等待交互性，直到加载Javascript</li><li id="529e" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果需要数据，需要为首次装载提供用户友好的设计</li></ul><p id="bde7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">什么时候使用预渲染？</strong></p><ul class=""><li id="d758" class="nm nn it ki b kj kk kn ko kr no kv np kz nq ld nr ns nt nu bi translated">如果你的应用程序有一个包含搜索引擎优化内容的用户界面</li><li id="1b83" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序的一部分可供未经身份验证的用户使用</li><li id="8916" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果你不想使用SSR，但你需要改善加载时间和SEO</li><li id="9b67" class="nm nn it ki b kj nv kn nw kr nx kv ny kz nz ld nr ns nt nu bi translated">如果您的应用程序在第一页有更多的静态内容</li></ul><h1 id="005d" class="ll lm it bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">结论</h1><p id="3919" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">本文介绍了应用程序的三种呈现方式，客户端呈现、服务器端呈现和预呈现。我解释了每种渲染方式的工作原理，以便您能够为您的应用程序选择最佳解决方案。</p><p id="3814" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，我们仔细研究了每种方法的优缺点，并总结了何时使用某个解决方案是好的。</p><p id="1705" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有一种完美的渲染方式，很大程度上取决于你创建的应用程序和你想要达到的效果。如果你有一个静态的应用程序，并关心搜索引擎优化和加载时间，你会选择不同的方式，然后如果你的应用程序是动态的，需要大量的服务器内容。</p><p id="d5de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望当你计划下一个应用程序时，这篇文章会对你有用。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/569b5629b61c6fc38ef667df4b6cb018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmTcuUeaGsAJSDedBMBgTA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank"> Duomly —编程在线课程</a></figcaption></figure><p id="81b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，<br/>安娜</p></div></div>    
</body>
</html>