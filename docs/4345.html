<html>
<head>
<title>Create Iconic Text Avatars using skiasharp and xamarin forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用skiasharp和xamarin表单创建图标文本头像</h1>
<blockquote>原文：<a href="https://itnext.io/create-iconic-text-avatars-using-skiasharp-and-xamarin-forms-e1334ae263d8?source=collection_archive---------2-----------------------#2020-06-12">https://itnext.io/create-iconic-text-avatars-using-skiasharp-and-xamarin-forms-e1334ae263d8?source=collection_archive---------2-----------------------#2020-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/65c3074b019625f852356c753958fb04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eW-5oLly0r-NrOXDbzjBcg.png"/></div></div></figure><p id="6ad2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在现代设计中，文字头像是个人资料图片最优雅的替代品，它们的使用不仅仅限于个人资料图片丢失或未加载的情况，而且在一些系统和移动应用程序中，它们被用作个人资料图片的完全替代。</p><p id="5485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇短文将向您展示如何使用skiasharp在xamarin表单中实现可重用的AvatarImageSource。</p><h1 id="972a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤1:创建AvatarImageSource类</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="cdd4" class="md kx iq lz b gy me mf l mg mh">public class AvatarImageSource : StreamImageSource<br/>{<br/>}</span></pre><h1 id="37de" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤2:添加可绑定属性</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c883" class="md kx iq lz b gy me mf l mg mh">public string Name<br/>        {<br/>            get =&gt; (string) GetValue(NameProperty);<br/>            set =&gt; SetValue(NameProperty, value);<br/>        }<br/>        <br/>public Color Background<br/>        {<br/>            get =&gt; (Color) GetValue(BackgroundProperty);<br/>            set =&gt; SetValue(BackgroundProperty, value);<br/>        }</span><span id="6e10" class="md kx iq lz b gy mi mf l mg mh">public Color Foreground<br/>        {<br/>            get =&gt; (Color)GetValue(ForegroundProperty);<br/>            set =&gt; SetValue(ForegroundProperty, value);<br/>        }</span><span id="e7c5" class="md kx iq lz b gy mi mf l mg mh">public int Size<br/>        {<br/>            get =&gt; (int) GetValue(SizeProperty);<br/>            set =&gt; SetValue(SizeProperty, value);<br/>        }</span></pre><p id="84e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将需要这些属性是用户定义的，所以我们可以在以后重用我们的AvatarImageSource。</p><h1 id="c18a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第三步:用SkiaShap绘制文本</h1><p id="decf" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在执行这一步之前，请确保skiasharp NuGet包已经安装在您的所有项目中</p><div class="mo mp gp gr mq mr"><a href="https://www.nuget.org/packages/SkiaSharp/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">SkiaSharp 1.68.3</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">SkiaSharp是一个跨平台的2D图形API。NET平台基于Google的Skia图形库。它提供了一个…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.nuget.org</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jw mr"/></div></div></a></div><p id="2b4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要创建一个新的方法绘制</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8966" class="md kx iq lz b gy me mf l mg mh">private Stream Draw()<br/>        {<br/>            var bitmap = new SKBitmap(Size * 2, Size * 2,   <br/>                         SKImageInfo.PlatformColorType,  <br/>                         SKAlphaType.Premul);</span><span id="061c" class="md kx iq lz b gy mi mf l mg mh">            var canvas = new SKCanvas(bitmap);<br/>            canvas.Clear(SKColors.Transparent);<br/>            <br/>            var midy = canvas.LocalClipBounds.Size.ToSizeI().Height / 2;<br/>            var midx = canvas.LocalClipBounds.Size.ToSizeI().Width / 2;<br/>            var radius = midx-midx/5;</span><span id="30b8" class="md kx iq lz b gy mi mf l mg mh">            var circleFill = new SKPaint<br/>            {<br/>                IsAntialias = true,<br/>                Style = SKPaintStyle.Fill,<br/>                StrokeJoin = SKStrokeJoin.Miter,<br/>                Color = SKColor.Parse(Background.ToHex())<br/>            };<br/>            canvas.DrawCircle(midx, midy, radius, circleFill);</span><span id="cbf2" class="md kx iq lz b gy mi mf l mg mh">           var family = SKTypeface.FromFamilyName("Arial",   <br/>                SKFontStyleWeight.Normal, SKFontStyleWidth.Normal,<br/>                SKFontStyleSlant.Upright);</span><span id="02aa" class="md kx iq lz b gy mi mf l mg mh">            var textSize = midx/1.5f;<br/>            var paint = new SKPaint<br/>            {<br/>                IsAntialias = true,<br/>                Style = SKPaintStyle.Fill, <br/>                Color = SKColor.Parse(Foreground.ToHex()),<br/>                TextSize = textSize,<br/>                TextAlign = SKTextAlign.Center,<br/>                Typeface = family<br/>            };<br/>            var rect=new SKRect();<br/>            paint.MeasureText(Name,ref rect);<br/>            <br/>            canvas.DrawText(Name, radius + rect.Height / 2,  <br/>                                  radius+rect.Width/2, paint);<br/>            var skImage = SKImage.FromBitmap(bitmap);<br/>            <br/>           var result = <br/>                     (skImage.Encode(SKEncodedImageFormat.Png,100))<br/>                       .AsStream();<br/>            return result;<br/>        }</span></pre><p id="2c6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，这个方法创建一个具有规定大小的画布，然后在中间画一个圆。</p><p id="4b61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">midy和midx是垂直和水平的中点，半径按midx-5%(边距)计算。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="1346" class="md kx iq lz b gy me mf l mg mh">           var midy = canvas.LocalClipBounds.Size.ToSizeI().Height / 2;<br/>            var midx = canvas.LocalClipBounds.Size.ToSizeI().Width / 2;<br/>            var radius = midx-midx/5;</span><span id="106c" class="md kx iq lz b gy mi mf l mg mh">            var circleFill = new SKPaint<br/>            {<br/>                IsAntialias = true,<br/>                Style = SKPaintStyle.Fill,<br/>                StrokeJoin = SKStrokeJoin.Miter,<br/>                Color = SKColor.Parse(Background.ToHex())<br/>            };<br/>            canvas.DrawCircle(midx, midy, radius, circleFill);</span></pre><p id="579a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们在圆圈中间画出文字</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="34b8" class="md kx iq lz b gy me mf l mg mh">var textSize = midx/1.5f;<br/>            var paint = new SKPaint<br/>            {<br/>                IsAntialias = true,<br/>                Style = SKPaintStyle.Fill, <br/>                Color = SKColor.Parse(Foreground.ToHex()),<br/>                TextSize = textSize,<br/>                TextAlign = SKTextAlign.Center,<br/>                Typeface = family<br/>            };<br/>            var rect=new SKRect();<br/>            paint.MeasureText(Name,ref rect);<br/>            canvas.DrawText(Name, radius + rect.Height / 2, radius+rect.Width/2, paint);</span></pre><p id="ae03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文本大小是半径的75%,您可以将其更改为任何百分比，或者您可以使用静态字体大小。</p><p id="589b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在渲染之前测量文本，以了解它在垂直和水平方向需要多少空间，然后我们通过将一半的空间添加到圆半径来计算文本位置。</p><p id="7313" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是完整的方法</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8eda" class="md kx iq lz b gy me mf l mg mh">private Stream Draw()<br/>        {<br/>            var bitmap = new SKBitmap(Size * 2, Size * 2, SKImageInfo.PlatformColorType, SKAlphaType.Premul);<br/>            var canvas = new SKCanvas(bitmap);<br/>            canvas.Clear(SKColors.Transparent);<br/>            <br/>            var midy = canvas.LocalClipBounds.Size.ToSizeI().Height / 2;<br/>            var midx = canvas.LocalClipBounds.Size.ToSizeI().Width / 2;<br/>            var radius = midx-midx/5;</span><span id="1841" class="md kx iq lz b gy mi mf l mg mh">var circleFill = new SKPaint<br/>            {<br/>                IsAntialias = true,<br/>                Style = SKPaintStyle.Fill,<br/>                StrokeJoin = SKStrokeJoin.Miter,<br/>                Color = SKColor.Parse(Background.ToHex())<br/>            };<br/>            canvas.DrawCircle(midx, midy, radius, circleFill);</span><span id="3d13" class="md kx iq lz b gy mi mf l mg mh">              var family = SKTypeface.FromFamilyName("Arial",      <br/>                                    SKFontStyleWeight.Normal,  <br/>                                    SKFontStyleWidth.Normal,<br/>                                    SKFontStyleSlant.Upright);<br/>            var textSize = midx/1.5f;<br/>            var paint = new SKPaint<br/>            {<br/>                IsAntialias = true,<br/>                Style = SKPaintStyle.Fill, <br/>                Color = SKColor.Parse(Foreground.ToHex()),<br/>                TextSize = textSize,<br/>                TextAlign = SKTextAlign.Center,<br/>                Typeface = family<br/>            };<br/>            var rect=new SKRect();<br/>            paint.MeasureText(Name,ref rect);<br/>            canvas.DrawText(Name, radius + rect.Height / 2, <br/>                                  radius+rect.Width/2, paint);<br/>            var skImage = SKImage.FromBitmap(bitmap);<br/>            var result = (skImage.Encode(SKEncodedImageFormat.Png,100)).AsStream();<br/>            return result;<br/>        }</span></pre><p id="d42c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不明白，考虑读几遍，然后试着从头开始写。</p><h1 id="ea5a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤4:当需要图像数据时，调用draw方法</h1><p id="7118" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这一步是最简单的，我们需要做的就是覆盖基类StreamImageSource的stream属性</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="68f7" class="md kx iq lz b gy me mf l mg mh">public override Func&lt;CancellationToken, Task&lt;Stream&gt;&gt; Stream =&gt; GetStreamAsync;</span><span id="c573" class="md kx iq lz b gy mi mf l mg mh">public Task&lt;Stream&gt; GetStreamAsync(CancellationToken userToken = new CancellationToken())<br/>        {<br/>            base.OnLoadingStarted();<br/>            userToken.Register(CancellationTokenSource.Cancel);<br/>            var result = Draw();<br/>OnLoadingCompleted(CancellationTokenSource.IsCancellationRequested);<br/>            return Task.FromResult(result);</span><span id="6e1c" class="md kx iq lz b gy mi mf l mg mh">}</span></pre><p id="8475" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并重写OnPropertyChanged方法</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7ad8" class="md kx iq lz b gy me mf l mg mh">protected override void OnPropertyChanged(string propertyName)<br/>        {<br/>            if (propertyName == NameProperty.PropertyName ||<br/>                propertyName == BackgroundProperty.PropertyName ||<br/>                propertyName == SizeProperty.PropertyName ||<br/>                propertyName == ForegroundProperty.PropertyName)<br/>            {<br/>                OnSourceChanged();<br/>            }<br/>        }</span></pre><p id="5a5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们的任何属性改变时，我们将需要触发源改变，Onsourcechanged是基类中触发重绘的方法。</p><p id="7b89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终覆盖IsEmpty</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="96e9" class="md kx iq lz b gy me mf l mg mh">public override bool IsEmpty =&gt; string.IsNullOrEmpty(Name);</span></pre><h1 id="18de" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第五步:把所有东西放在一起</h1><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="2f9d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第七步:测试和消费</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ccaf" class="md kx iq lz b gy me mf l mg mh">&lt;ListView x:Name="UsersListView"&gt;<br/>            &lt;ListView.ItemTemplate&gt;<br/>                &lt;DataTemplate&gt;<br/>                    &lt;ImageCell Text="{Binding Name}" Detail="software engineer"&gt;<br/>                        &lt;ImageCell.ImageSource&gt;<br/>                            &lt;avatar:AvatarImageSource  <br/>                                       Background="DarkSlateBlue" <br/>                                       Foreground="White" Size="48"  <br/>                                       Name="{Binding Initials}"/&gt;<br/>                        &lt;/ImageCell.ImageSource&gt;<br/>                    &lt;/ImageCell&gt;<br/>                &lt;/DataTemplate&gt;<br/>            &lt;/ListView.ItemTemplate&gt;<br/>        &lt;/ListView&gt;</span></pre><p id="cfc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Csharp的消费者呢</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a2ba" class="md kx iq lz b gy me mf l mg mh">public class User<br/>    {<br/>        public string Name { get; set; }</span><span id="c797" class="md kx iq lz b gy mi mf l mg mh">public string Initials =&gt; new string(Name.Split(new[] {" "}, StringSplitOptions.RemoveEmptyEntries)<br/>            .Select(item =&gt; item.FirstOrDefault()).ToArray());</span><span id="42ef" class="md kx iq lz b gy mi mf l mg mh">}<br/>    [XamlCompilation(XamlCompilationOptions.Compile)]<br/>    public partial class UsersPage : ContentPage<br/>    {<br/>        public UsersPage()<br/>        {<br/>            InitializeComponent();<br/>            UsersListView.ItemsSource = new List&lt;User&gt;()<br/>            {<br/>                new User() {Name = "Ahmed Fouad"},<br/>                new User() {Name = "Elif Vo"},<br/>                new User() {Name = "Nur Byers"}<br/>            };<br/>        }<br/>    }</span></pre><h1 id="b0d5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第八步:关注我，分享文章</h1><p id="f866" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在twitter和medium上关注我，了解更多技术和科学内容</p><p id="2a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">https://twitter.com/MCC_Ahmed</p><p id="4ecd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想支持我更多的技术和科学内容，你可以在</p><div class="mo mp gp gr mq mr"><a href="https://ko-fi.com/ahmedfouad" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">给艾哈迈德·福阿德买杯咖啡。ko-fi.com/ahmedfouad</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">给我买杯咖啡</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">ko-fi.com</p></div></div><div class="na l"><div class="nj l nc nd ne na nf jw mr"/></div></div></a></div><p id="ea74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和往常一样，书籍推荐请阅读<a class="ae ni" href="https://amzn.to/3dSGTlN" rel="noopener ugc nofollow" target="_blank">丹尼尔·希夫曼</a>的《Cod的性质 e无论你的编码水平如何，这本书都会帮助你用非常简单的方法解决复杂的编码问题。</p></div></div>    
</body>
</html>