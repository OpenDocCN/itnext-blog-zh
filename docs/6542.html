<html>
<head>
<title>Event Driven Autoscaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动的自动缩放</h1>
<blockquote>原文：<a href="https://itnext.io/event-driven-autoscaling-503b5cefaa49?source=collection_archive---------4-----------------------#2021-12-13">https://itnext.io/event-driven-autoscaling-503b5cefaa49?source=collection_archive---------4-----------------------#2021-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f55db14bf75edc0e24d74fe425303729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbWtCNey9LHUzc64Mk8WJQ.png"/></div></div></figure><p id="ac6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据是宝贵的资产。收集、管理和使用信息的能力给企业带来了竞争优势。当一家公司采用“数据驱动”方法时，这意味着<strong class="kd iu">它根据数据分析和解释做出战略决策</strong>。数据驱动的方法使公司能够检查和使用他们的数据，以更好地服务于他们的成员和消费者的需求。</p><h1 id="845a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">自动缩放服务</h1><p id="f9f4" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated"><strong class="kd iu">事件</strong>已经成为一个微服务需要向另一个传递信息时的常用方法。根据生成事件的性质，一天中的交易量可能持平，也可能非常不规则。拥有独立扩展生产者/消费者以适应这些变化的能力至关重要。</p><p id="687a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes提供了一种水平自动缩放服务的方式，即<strong class="kd iu">水平Pod自动缩放器。</strong>水平Pod自动缩放器根据观察到的CPU或内存利用率，自动缩放部署、副本集或有状态集中的Pod数量。或者，在<a class="ae mc" href="https://git.k8s.io/community/contributors/design-proposals/instrumentation/custom-metrics-api.md" rel="noopener ugc nofollow" target="_blank">自定义指标</a>的支持下，您可以基于其他一些应用程序提供的指标进行扩展。</p><p id="1221" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然HPA是一个很好的起点，并且它在CPU和内存指标方面都非常好，但是如果您想要基于自定义或外部指标进行扩展，它有其局限性。或者像我们一样需要基于时间的缩放。HPA也不允许将部署规模缩减到零。</p><p id="6d52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于HTTP工作负载，CPU /内存使用自动伸缩通常就足够了。对于非HTTP工作负载，您可能希望基于其他指标进行自动伸缩，例如，队列中挂起的工作量。</p><h1 id="f5c2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">介绍KEDA</h1><p id="90fe" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">KEDA是一个基于Kubernetes的事件驱动自动缩放器。使用KEDA，您可以根据需要处理的事件数量来扩展Kubernetes中的任何容器。KEDA与标准Kubernetes组件一起工作，如<a class="ae mc" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>，可以扩展功能而无需覆盖或复制。</p><p id="8a42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将KEDA视为各种系统的度量适配器。这很重要，因为Kubernetes只允许您在集群中运行这些适配器中的一个。所以，如果你想使用普罗米修斯和另一个没有KEDA的系统，你需要2个适配器，这是不可能的。</p><p id="036f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以从一系列<a class="ae mc" href="https://keda.sh/#scalers" rel="noopener ugc nofollow" target="_blank">预定义触发器</a>(也称为<strong class="kd iu">缩放器</strong>)中进行选择，这些触发器充当自动缩放部署(或<code class="fe md me mf mg b">Job</code>)的事件和指标的来源。这些可以被认为是适配器，包含连接到外部源(例如Kafka、Redis、ActiveMQ)的必要逻辑，并获取驱动自动缩放操作所需的指标。</p><p id="3d34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<a class="ae mc" href="https://keda.sh/docs/deploy/#helm" rel="noopener ugc nofollow" target="_blank">舵</a>或通过<a class="ae mc" href="https://keda.sh/docs/deploy/#operatorhub" rel="noopener ugc nofollow" target="_blank">操纵器毂</a>可以很容易地部署KEDA。</p><h2 id="44fa" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">KEDA是如何运作的</h2><p id="1644" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">KEDA在Kubernetes担任两个关键角色:</p><ol class=""><li id="426c" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><strong class="kd iu">代理</strong> — KEDA激活和停用Kubernetes <a class="ae mc" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment" rel="noopener ugc nofollow" target="_blank">部署</a>以在无事件时从零扩展到零。这是安装KEDA时运行的<code class="fe md me mf mg b">keda-operator</code>容器的主要角色之一。</li><li id="4e4d" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><strong class="kd iu">指标</strong> — KEDA充当<a class="ae mc" href="https://github.com/kubernetes-sigs/metrics-server" rel="noopener ugc nofollow" target="_blank"> Kubernetes指标服务器</a>，向水平Pod自动缩放器公开丰富的事件数据，如队列长度或流延迟，以推动横向扩展。度量服务是安装KEDA时运行的<code class="fe md me mf mg b">keda-operator-metrics-apiserver</code>容器的主要角色。</li></ol><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/bcc340d72f6317376045b1df4b33bb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bM-JU5dWWpfKj5vQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">KEDA建筑。keda.sh摄</figcaption></figure><p id="e2a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">KEDA与多个<a class="ae mc" href="https://keda.sh/docs/scalers/" rel="noopener ugc nofollow" target="_blank">缩放器</a>(事件源)集成，并使用自定义资源定义(CRD)来定义所需/期望的缩放行为和参数。这些自定义资源使您能够将事件源映射到部署、状态集、自定义资源或作业，以便进行扩展。</p><p id="bed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装KEDA时，会创建四个自定义资源:</p><ul class=""><li id="284a" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated"><code class="fe md me mf mg b">scaledobjects.keda.sh</code></li><li id="0452" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">scaledjobs.keda.sh</code></li><li id="4b5d" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">triggerauthentications.keda.sh</code></li><li id="581b" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">clustertriggerauthentications.keda.sh</code></li></ul><p id="6703" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些自定义资源使您能够将事件源(即SQS、ActiveMQ)映射到部署、状态集、自定义资源或作业以进行扩展。</p><ul class=""><li id="f4f0" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated"><code class="fe md me mf mg b">ScaledObjects</code>表示事件源和Kubernetes部署、StatefulSet或任何定制资源之间的期望映射。<code class="fe md me mf mg b">ScaledObject</code>定义了您想要自动缩放的内容，以及您想要自动缩放的方式或时间。</li><li id="64f0" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">ScaledJobs</code>表示事件源和Kubernetes作业之间的映射。</li><li id="f272" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">ScaledObject</code> / <code class="fe md me mf mg b">ScaledJob</code>也可以引用一个<code class="fe md me mf mg b">TriggerAuthentication</code>或<code class="fe md me mf mg b">ClusterTriggerAuthentication</code>来监控事件源，其中包含认证配置或秘密。</li></ul><p id="6004" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">KEDA监控<code class="fe md me mf mg b">ScaledObjects</code> / <code class="fe md me mf mg b">ScaledJobs</code>中定义的事件源，并将信息反馈给HPA，以便HPA根据源中的事件按需扩展对象/作业。</p><p id="0f19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">KEDA还具有将<strong class="kd iu">扩展到零</strong>的能力，这对于HPA是不可能的(至少需要1个吊舱)。KEDA通过删除HPA对象并将工作负载缩减为零来实现这一点。一旦我们从0到1，KEDA就会反其道而行之，即将工作负载调整回1，并重新创建HPA，HPA会接管并决定1是否足够，或者是否应该增加到一个更高的数字，直至达到定义的最大值。这是构建经济高效的应用程序的好方法。</p><h1 id="3a0c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">监测KEDA</h1><p id="d709" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">可以通过Kubernetes事件、HPA指标以及Prometheus指标对KEDA进行<strong class="kd iu">监控</strong>，以便可以监控和调整自动扩展活动，从而找到成本、时间和性能之间的最佳平衡点。</p><h1 id="2c51" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">KEDA用例</h1><h2 id="3e2d" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">用例1:普罗米修斯定标器</h2><p id="3c34" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">该规范描述了基于普罗米修斯指标扩展的<code class="fe md me mf mg b">prometheus</code>触发器:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="70f7" class="mh la it mg b gy nv nw l nx ny">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: my-app-scaledobject<br/>  namespace: my-namespace<br/>spec:<br/>  scaleTargetRef:<br/>    name: my-app<br/>    kind: Deployment<br/> <!-- --> pollingInterval: 15<br/>  minReplicaCount: 2<br/>  maxReplicaCount: 8<br/> <!-- --> triggers:<br/>  - type: prometheus<br/>    metadata:<br/>      serverAddress: http://&lt;prometheus-host&gt;:9090<br/>      metricName: istio_requests_total<br/>      threshold: '3'<br/>      query: sum(rate(istio_requests_total{reporter="source", destination_service_name="my-app"}[1m]))</span></pre><p id="b7da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分解配置:</p><ul class=""><li id="a852" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated">它通过my-app的<code class="fe md me mf mg b">name</code>瞄准了一个<code class="fe md me mf mg b">Deployment</code>。</li><li id="fdfd" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">它实现了类型为<code class="fe md me mf mg b">prometheus</code>的触发器。Prometheus <code class="fe md me mf mg b">serverAddress</code>用于使用<code class="fe md me mf mg b">query</code>中指定的PromQL表达式查询Prometheus，频率由<code class="fe md me mf mg b">pollingInterval</code>指定。</li><li id="0fff" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">minReplicaCount</code>指定Kubernetes将运行的pod的最小数量，而<code class="fe md me mf mg b">maxReplicaCount</code>指定最大数量。</li><li id="ab6c" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">threshold</code>值用作向上或向下扩展部署的触发器。</li></ul><p id="bd3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">KEDA将查询结果与阈值进行比较，并将采取适当的措施(扩大、缩小或保持相同数量的副本)。</p><p id="8098" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重要的是要理解，在根据<code class="fe md me mf mg b">threshold. </code>进行评估之前，查询的结果除以当前副本的数量。例如，在上面的示例中，在查询的结果超过6之前，<code class="fe md me mf mg b">Deployment</code>不会扩大到3个副本。另一方面，部署永远不会缩减到低于<code class="fe md me mf mg b">minReplicaCount</code>值。</p><h2 id="32ad" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">用例2: Cron Scaler</h2><p id="4a96" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">下面的规范展示了一个带有<code class="fe md me mf mg b">cron</code>触发器的<code class="fe md me mf mg b">ScaledObject</code>，它基于Cron调度进行伸缩。</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="b8da" class="mh la it mg b gy nv nw l nx ny">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: <!-- -->my-app-scaledobject<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    kind: Deployment<br/>    name: my-app<br/>  pollingInterval: 30<br/>  triggers:  <br/>  - type: cron<br/>    metadata:<br/>      desiredReplicas: "8"<br/>      end: 0 6 * * *<br/>      start: 0 0 * * *<br/>      timezone: Europe/London</span></pre><p id="71ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分解配置:</p><ul class=""><li id="d7e3" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated">它的目标是一个名为my-app的<code class="fe md me mf mg b">Deployment</code>。</li><li id="0525" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">部署将在<code class="fe md me mf mg b">start</code>时间缩放到<code class="fe md me mf mg b">desiredReplicas</code>，并将在<code class="fe md me mf mg b">end</code>时间缩放回<code class="fe md me mf mg b">Deployment</code>资源中指定的副本数量。</li><li id="d0f7" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">时间基于欧洲/伦敦<code class="fe md me mf mg b">timezone</code>。</li></ul><blockquote class="nz oa ob"><p id="7d32" class="kb kc oc kd b ke kf kg kh ki kj kk kl od kn ko kp oe kr ks kt of kv kw kx ky im bi translated">有效时区列表可在<a class="ae mc" href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><h2 id="8ba1" class="mh la it bd lb mi mj dn lf mk ml dp lj km mm mn ln kq mo mp lr ku mq mr lv ms bi translated">用例3: CPU /内存缩放器</h2><p id="13cb" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">虽然您可以直接使用HPA实现CPU/内存自动缩放，但是KEDA允许您设置一个<code class="fe md me mf mg b">cpu</code> / <code class="fe md me mf mg b">memory</code>触发器，例如使用<code class="fe md me mf mg b">cron</code>触发器。</p><p id="d27f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下示例实现了两个触发器:<code class="fe md me mf mg b">cpu</code>和<code class="fe md me mf mg b">memory</code>。</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="8bcd" class="mh la it mg b gy nv nw l nx ny">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: my-app-scaledobject<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    name: my-app<br/>  triggers:<br/>  - type: cpu<br/>    metadata:<br/>      type: Utilization<br/>      value: "90"<br/>  - type: memory<br/>    metadata:<br/>      type: AverageValue<br/>      value: "1500Mi"</span></pre><p id="5c44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每个触发器中:</p><ul class=""><li id="b51c" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated"><code class="fe md me mf mg b">type</code>设置要使用的度量类型。选项有<code class="fe md me mf mg b">Utilization</code>或<code class="fe md me mf mg b">AverageValue</code>。</li><li id="86f8" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated"><code class="fe md me mf mg b">value</code>为:<br/><strong class="kd iu">–</strong>设置触发缩放操作的值，当使用<code class="fe md me mf mg b">Utilization</code>时，目标值是所有相关pod的资源指标的平均值，<strong class="kd iu">表示为pod的<strong class="kd iu">请求的</strong>资源值的百分比</strong>。<br/><strong class="kd iu">–</strong>使用<code class="fe md me mf mg b">AverageValue</code>时，目标值是所有相关pod(数量)的指标平均值的目标值。</li></ul><blockquote class="nz oa ob"><p id="3e86" class="kb kc oc kd b ke kf kg kh ki kj kk kl od kn ko kp oe kr ks kt of kv kw kx ky im bi translated">理解<code class="fe md me mf mg b">Utilization</code>使用<strong class="kd iu">请求的</strong>CPU/内存值，而不是<strong class="kd iu">限制</strong>很重要。</p></blockquote><p id="a095" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用于计算所需副本数量的算法如下:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="5dfc" class="mh la it mg b gy nv nw l nx ny">desiredReplicas = ceil[currentReplicas * ( currentMetricValue / desiredMetricValue )]</span></pre><p id="0aa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果<code class="fe md me mf mg b">cpu</code>触发器的当前度量值是<code class="fe md me mf mg b">80</code>，阈值是<code class="fe md me mf mg b">40</code>，副本的数量将加倍:<code class="fe md me mf mg b">80 / 40 == 2.0</code></p><p id="517a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，如果当前值改为<code class="fe md me mf mg b">20</code>，我们将副本的数量减半:<code class="fe md me mf mg b">20 / 40 == 0.5</code>。</p><p id="673a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果比率足够接近1.0(在全局可配置的容差范围内，来自<code class="fe md me mf mg b">--horizontal-pod-autoscaler-tolerance</code>标志，默认为0.1)，我们将跳过缩放。理解这种行为以避免混淆是很重要的。考虑下面的例子:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="4823" class="mh la it mg b gy nv nw l nx ny">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: my-app-scaledobject<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    name: my-app<br/>  maxReplicaCount: 35<br/>  minReplicaCount: 25<br/>  pollingInterval: 30<br/>  triggers:<br/>  - type: memory<br/>    metadata:<br/>      type: AverageValue<br/>      value: "90"</span></pre><p id="ea97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其中:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="f35e" class="mh la it mg b gy nv nw l nx ny"><strong class="mg iu">apiVersion</strong>: v1<br/><strong class="mg iu">kind</strong>: Pod<br/><strong class="mg iu">metadata</strong>:<br/>  <strong class="mg iu">name</strong>: my-app<br/>  <strong class="mg iu">namespace</strong>: default<br/><strong class="mg iu">spec</strong>:<br/>  <strong class="mg iu">containers</strong>:<br/>    ...<br/>    <strong class="mg iu">resources</strong>:<br/>      <strong class="mg iu">limits</strong>:<br/>        <strong class="mg iu">memory</strong>: "1500Mi"<br/>      <strong class="mg iu">requests</strong>:<br/>        <strong class="mg iu">memory</strong>: "1500Mi"</span></pre><p id="c31f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">currentMetricValue</code>是通过对HorizontalPodAutoscaler的缩放目标中的所有窗格取给定指标的平均值来计算的。让我们想象一下<code class="fe md me mf mg b">currentMetricValue</code>是<code class="fe md me mf mg b">1250Mi</code>而<code class="fe md me mf mg b">currentReplicas</code>是<code class="fe md me mf mg b">30</code>。</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="4715" class="mh la it mg b gy nv nw l nx ny">desiredReplicas = ceil[30 * ( 1250 / 1500*0.9 )] = ceil[30 * (0.92)] = ceil[27.6] = 28</span></pre><p id="b5db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使公式给出的<code class="fe md me mf mg b">desiredReplicas</code>值为28，而<code class="fe md me mf mg b">currentReplicas</code>值为30，也不会有任何缩放活动，因为比率非常接近1 (0.92)，并且在前面讨论的0.1默认容差范围内。</p><p id="560a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">用例4:组合定标器</strong></p><p id="de48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如<strong class="kd iu">用例3 </strong>所述，KEDA允许您将CPU/内存触发器与任何其他可用的触发器相结合。以下<code class="fe md me mf mg b">ScaledObject</code>结合了一个<code class="fe md me mf mg b">cron</code>触发器和两个<code class="fe md me mf mg b">cpu</code>和<code class="fe md me mf mg b">memory</code>触发器:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="7b7a" class="mh la it mg b gy nv nw l nx ny">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: my-app-scaledobject<br/>  namespace: default<br/>spec:<br/>  maxReplicaCount: 35<br/>  minReplicaCount: 25<br/>  pollingInterval: 30<br/>  scaleTargetRef:<br/>    apiVersion: apps/v1<br/>    kind: Deployment<br/>    name: my-app<br/>  triggers:<br/>  - type: cron<br/>    metadata:<br/>      desiredReplicas: "30"<br/>      end: 0 6 * * *<br/>      start: 0 0 * * *<br/>      timezone: Europe/London<br/>  - type: cpu<br/>    metadata:<br/>      type: Utilization<br/>      value: "90"<br/>  - type: memory<br/>    metadata:<br/>      type: Utilization<br/>      value: "90"</span></pre><p id="5719" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们再一次分解配置:</p><ul class=""><li id="4686" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated">它的目标是一个名为my-app的<code class="fe md me mf mg b">Deployment</code>。</li><li id="f058" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">它实现了三个触发器:<code class="fe md me mf mg b">cron</code>、<code class="fe md me mf mg b">cpu</code>、<code class="fe md me mf mg b">memory</code>(这三个我们在前面的例子中都已经讲过了，所以不再解释了)。</li><li id="e472" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">在任何时间点，部署扩展到的副本数量都是任何触发器所需的最高副本数量。例如，午夜和早上6点之间的副本数量将是30，除非根据<code class="fe md me mf mg b">cpu</code> / <code class="fe md me mf mg b">memory</code>值需要更多。</li></ul><h1 id="fd2a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">KEDA实例</h1><p id="a381" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们看看KEDA的行动吧！下面的<code class="fe md me mf mg b">ScaledObject</code>以名为my-app的<code class="fe md me mf mg b">Deployment</code>为目标，结合了一个<code class="fe md me mf mg b">prometheus</code>和一个<code class="fe md me mf mg b">cron</code>触发器:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="d76c" class="mh la it mg b gy nv nw l nx ny">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: my-app<br/>  namespace: sre<br/>spec:<br/>  maxReplicaCount: 7<br/>  minReplicaCount: 2<br/>  pollingInterval: 15<br/>  scaleTargetRef:<br/>    apiVersion: apps/v1<br/>    kind: Deployment<br/>    name: my-app<br/>  triggers:<br/>  - type: prometheus<br/>    metadata:<br/>      metricName: http_requests_total<br/>      query: sum(rate(http_requests_total{app="my-app"}[1m]))<br/>      serverAddress: http://po-prometheus.monitoring:9090<br/>      threshold: "3"<br/>  - type: cron<br/>    metadata:<br/>      desiredReplicas: "3"<br/>      start: 30 * * * *<br/>      end: 35 * * * *<br/>      timezone: Europe/London</span></pre><p id="9c51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据每秒收到的请求数，部署将在2到7个副本之间扩展。根据<code class="fe md me mf mg b">cron</code>触发器，从第30分钟到第35分钟，部署还将扩展到每小时3个副本。</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/1fced81800f6d8b18f493587042a5419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_7QXhZPd2Bz29LSm.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">显示cron触发器运行的Grafana仪表板</figcaption></figure><p id="24ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您仔细观察前面的图像，您会看到部署在第40分钟而不是第35分钟缩小。这是HPA的默认行为:逐步缩小规模，消除快速波动的指标值的影响。<code class="fe md me mf mg b">--horizontal-pod-autoscaler-downscale-stabilization</code>标志控制这种行为，默认为5分钟。</p><p id="7ee3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">描述HPA对象将向您展示正在发生的自动缩放事件:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="008a" class="mh la it mg b gy nv nw l nx ny">Type    Reason             Age    From           Message                                                                                                                                                      <br/>----    ------             ----   ----           -------                                                                                                                                                      <br/>Normal  SuccessfulRescale  16m (x47 over 46h)    horizontal-pod-autoscaler  New size: 3; reason: external metric cron-Europe-London-30xxxx-35xxxx(&amp;LabelSelector{MatchLabels:map[string]string{scaledobject.keda.sh/name: my-app,},MatchExpressions:[]LabelSelectorRequirement{},}) above target                                                                                                                                                                                </span><span id="1bb7" class="mh la it mg b gy oh nw l nx ny">Normal  SuccessfulRescale  7m3s (x263 over 10d)  horizontal-pod-autoscaler  New size: 2; reason: All metrics below target</span></pre><p id="556b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们发送一些流量来测试<code class="fe md me mf mg b">prometheus</code>触发器。我们将运行一个负载测试，在我们的应用程序中生成一些流量，我们将逐渐增加<strong class="kd iu"> req/s </strong>来观察KEDA的行为:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/6ad6da6638092300979f753c2edb4735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z3KrnkUo37jOXPnQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">我的应用程序接收的流量</figcaption></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/5941c60950e8a58815fb67049337bc2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YPIoxCBu3cvWbQN-.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">在我的应用中扩展活动</figcaption></figure><p id="efa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在图表中看到的是:</p><ul class=""><li id="e65c" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky nq mz na nb bi translated">在开始负载测试之前，副本的数量等于<code class="fe md me mf mg b">minReplicaCount</code>，即2。</li><li id="87ab" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">每秒发送3个请求不会触发任何扩展活动。</li><li id="6957" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">第一次扩展活动是在12:02左右触发的，当时我们达到了6.5 req/s。由于我们的<code class="fe md me mf mg b">threshold</code>设置为3，<code class="fe md me mf mg b">6.5 / 3 = 2.1 ~ 3</code>。</li><li id="5a90" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">12:09左右，我们将负载增加到17 req/s:，部署扩展到6个pod:<code class="fe md me mf mg b">17 / 3 = 5.6 ~ 6</code>。</li><li id="b29a" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">12点18分，我们将负载增加到33.5 req/s。在这种情况下，我们需要<code class="fe md me mf mg b">33.5 / 3 = 11.1 ~ 12</code>吊舱。然而，我们将<code class="fe md me mf mg b">maxReplicaCount</code>设置为7，因此部署扩展到7个副本。</li><li id="3bc2" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">12:32我们停止了负载测试，req/s下降到0.9。由于前面解释过的<code class="fe md me mf mg b">--horizontal-pod-autoscaler-downscale-stabilization</code>标志，副本的数量直到5分钟后才减少。</li><li id="d9d7" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky nq mz na nb bi translated">部署最终缩减到<code class="fe md me mf mg b">minReplicaCount</code>，因为没有一个触发器是活动的。</li></ul><p id="d0f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Kubernetes为上述所有扩展活动生成事件，如果您描述这个特定部署的HPA对象，就可以找到这些事件:</p><pre class="ni nj nk nl gt nr mg ns nt aw nu bi"><span id="d0e8" class="mh la it mg b gy nv nw l nx ny">Type     Reason      Age      From            Message<br/>----     ------      ----     ----            -------<br/>Normal   SuccessfulRescale    38m (x3 over 7d)    horizontal-pod-autoscaler  New size: 3; reason: external metric prometheus-http---po-prometheus-monitoring-9090-http_requests_total(&amp;LabelSelector{MatchLabels:map[string]string{scaledobject.keda.sh/name: my-app,},MatchExpressions:[]LabelSelectorRequirement{},}) above target</span><span id="084d" class="mh la it mg b gy oh nw l nx ny">Normal   SuccessfulRescale             30m (x2 over 2d)    horizontal-pod-autoscaler  New size: 5; reason: external metric prometheus-http---po-prometheus-monitoring-9090-http_requests_total(&amp;LabelSelector{MatchLabels:map[string]string{scaledobject.keda.sh/name: my-app,},MatchExpressions:[]LabelSelectorRequirement{},}) above target</span><span id="3fcc" class="mh la it mg b gy oh nw l nx ny">Normal   SuccessfulRescale             28m (x2 over 2d)    horizontal-pod-autoscaler  New size: 6; reason: external metric prometheus-http---po-prometheus-monitoring-9090-http_requests_total(&amp;LabelSelector{MatchLabels:map[string]string{scaledobject.keda.sh/name: my-app,},MatchExpressions:[]LabelSelectorRequirement{},}) above target</span><span id="1227" class="mh la it mg b gy oh nw l nx ny">Normal   SuccessfulRescale             23m                 horizontal-pod-autoscaler  New size: 7; reason: external metric prometheus-http---po-prometheus-monitoring-9090-http_requests_total(&amp;LabelSelector{MatchLabels:map[string]string{scaledobject.keda.sh/name: my-app,},MatchExpressions:[]LabelSelectorRequirement{},}) above target</span><span id="6b2b" class="mh la it mg b gy oh nw l nx ny">Normal   SuccessfulRescale             2m30s               horizontal-pod-autoscaler  New size: 4; reason: All metrics below target                                                                                                      </span><span id="7ea6" class="mh la it mg b gy oh nw l nx ny">Normal   SuccessfulRescale             2m15s (x2 over 7d)  horizontal-pod-autoscaler  New size: 3; reason: All metrics below target                                                                                                      </span><span id="419d" class="mh la it mg b gy oh nw l nx ny">Normal   SuccessfulRescale             9s (x264 over 10d)  horizontal-pod-autoscaler  New size: 2; reason: All metrics below target</span></pre><h1 id="f281" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="9e89" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">正如我们所看到的，KEDA通过管理与外部资源的集成扩展了Kubernetes的功能，允许您基于来自内部和外部指标的数据自动扩展您的Kubernetes部署。KEDA消除了不能在一个集群中运行多个适配器的限制。如果需要，它还允许您将工作负载扩展到零。</p></div></div>    
</body>
</html>