<html>
<head>
<title>Angular Tutorial — Implement Refresh Token with HttpInterceptor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular教程—使用HttpInterceptor实现刷新令牌</h1>
<blockquote>原文：<a href="https://itnext.io/angular-tutorial-implement-refresh-token-with-httpinterceptor-bfa27b966f57?source=collection_archive---------0-----------------------#2018-06-16">https://itnext.io/angular-tutorial-implement-refresh-token-with-httpinterceptor-bfa27b966f57?source=collection_archive---------0-----------------------#2018-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/87ccc284e046afbb31aa0a960cb90f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*nbJ41jD1-r2Oe6FsLjKaOg.png"/></div></figure><blockquote class="ju"><p id="82e7" class="jv jw iq bd jx jy jz ka kb kc kd ke dk translated">本文解释了如何在新的Angular 框架中使用HttpInterceptor <strong class="ak">实现刷新令牌。</strong></p></blockquote></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="5c82" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ke ij bi translated">Angular版本引入了最期待的功能:<code class="fe lj lk ll lm b">HttpInterceptor</code>界面。在这个版本之前，没有办法全局修改或拦截http请求。</p><p id="9926" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ke ij bi translated">HTTP拦截器为什么有用？HTTP拦截器用于为日志记录、修改响应、错误处理添加自定义逻辑，但一个常见的情况是自动将身份验证信息附加到请求并刷新令牌，以便保持用户会话活动。</p><h1 id="d18e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">创建一个拦截器</h1><blockquote class="ml mm mn"><p id="dc7d" class="km kn mo ko b kp kq kr ks kt ku kv kw mp ky kz la mq lc ld le mr lg lh li ke ij bi translated">本教程假设您的应用程序中已经有一个认证服务，并且您正在本地存储中存储JWT令牌。</p></blockquote><p id="b2c7" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ke ij bi translated">第一步是创建一个拦截器。为此，让我们创建一个实现<code class="fe lj lk ll lm b"><em class="mo">HttpInterceptor</em></code>的<code class="fe lj lk ll lm b"><em class="mo">Injectable</em></code>类，并捕捉可能发生的错误。</p><pre class="ms mt mu mv gt mw lm mx my aw mz bi"><span id="f980" class="na lo iq lm b gy nb nc l nd ne">// src/app/services/token-interceptor.service.ts<br/><br/>import { Injectable } from '@angular/core';<br/>import { HttpRequest, HttpHandler,HttpEvent, HttpInterceptor } from '@angular/common/http';<br/>import { AuthenticationService } from '../authentication.service';<br/>import { Observable } from 'rxjs/Observable';<br/><br/>@Injectable()<br/>export class RefreshTokenInterceptor implements HttpInterceptor {<br/><br/>  constructor(public auth: AuthenticationService) {}<br/><br/>  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler):                   <br/>  Observable&lt;HttpEvent&lt;any&gt;&gt; {<br/><br/>    return next.handle(request)<br/>       <!-- -->.catch(error =&gt; {<br/>           <em class="mo">return </em>Observable.<em class="mo">throw</em>(error);<br/>       });</span><span id="57b7" class="na lo iq lm b gy nf nc l nd ne">    }<br/>}</span></pre><p id="f2d6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ke ij bi translated">我想提一下，你必须使用从<strong class="ko ir"> @angular/common/http </strong>导入的新HttpClient，因为旧的http客户端不会触发HttpInterceptor。</p><h1 id="7606" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">寻找未授权的响应</h1><p id="2598" class="pw-post-body-paragraph km kn iq ko b kp ng kr ks kt nh kv kw kx ni kz la lb nj ld le lf nk lh li ke ij bi translated">当访问令牌到期时，服务器通常会发送一个<code class="fe lj lk ll lm b">401 Unauthorized</code>响应。在这种情况下，我们需要再次登录用户，以便使用新的访问令牌继续使用应用程序。</p><p id="bba6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ke ij bi translated">重要的是检查失败的请求是否不是刷新令牌请求本身，以避免递归。此外，我们需要检查刷新令牌请求是否正在进行，因为我们不希望其他调用进来并再次调用refresh token。代码中注释了另一个重要步骤:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="f870" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="52cc" class="pw-post-body-paragraph km kn iq ko b kp ng kr ks kt nh kv kw kx ni kz la lb nj ld le lf nk lh li ke ij bi translated">新的HttpInterceptor是一个强大而有用的特性，它是我们可以拦截和/或改变传出请求或传入响应的更好的地方。</p></div></div>    
</body>
</html>