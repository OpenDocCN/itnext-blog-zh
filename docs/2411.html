<html>
<head>
<title>A Practical kubernetes Operator using Ansible — an example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ansible实现kubernetes算子——一个例子</h1>
<blockquote>原文：<a href="https://itnext.io/a-practical-kubernetes-operator-using-ansible-an-example-d3a9d3674d5b?source=collection_archive---------1-----------------------#2019-05-20">https://itnext.io/a-practical-kubernetes-operator-using-ansible-an-example-d3a9d3674d5b?source=collection_archive---------1-----------------------#2019-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2aef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注:这是我和</em> <a class="kp kq ep" href="https://medium.com/u/30a356c1c9a2?source=post_page-----d3a9d3674d5b--------------------------------" rel="noopener" target="_blank"> <em class="ko">贾里德·霍科特</em> </a> <em class="ko">共同努力的学习经历。</em></p><p id="5fad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就在<a class="ae kr" href="https://www.redhat.com" rel="noopener ugc nofollow" target="_blank"> Red Hat </a>收购它们的时候，<a class="ae kr" href="https://www.coreos.com" rel="noopener ugc nofollow" target="_blank"> CoreOS </a>宣布发布一个新的框架和开发包，围绕一个叫做“<a class="ae kr" href="https://coreos.com/operators/" rel="noopener ugc nofollow" target="_blank"> Operators </a>的概念。从那时起，运营商已经发展成为有效管理kubernetes集群以及其中部署的应用程序的最佳方式之一。但是定义什么是操作者以及他们如何改进你的集群可能有点困难。他们在抽象出用于完成工作的kubernetes对象方面做得很好。但是这些对象之间的联系和交互可能有点难以理解。这篇文章(可能不止一篇)将采用我在互联网上用过的多个例子，把它们粘在一起，让这些基础知识变得更加清晰。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/f5a677f8499c0c10b39af09bcc4bf17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*LuUnyoZuZeXtRANP"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">kubernetes运营商logo…哈利波特v. Shazam？</figcaption></figure><p id="9182" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们要解决的问题是一个完全自私的问题。我们将编写一个kubernetes操作器，它将部署定制的客户研讨会，这样当研讨会参与者破坏了他们的环境时，我可以花更少的时间来部署和修复它们。在我们找到解决方案之前，让我们先快速地分析一下这个问题。</p><h1 id="4c33" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们需要什么</h1><p id="f3c7" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我想建立一个能够:</p><ul class=""><li id="27d3" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">在kubernetes中创建一个<code class="fe mq mr ms mt b">Workshop</code>资源，它将为一个研讨会部署和维护所有的共享资源。这些可能包括容器注册、共享实验室内容等。这些共享资源需要能够为每个独特的部署车间指定。</li><li id="84cb" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated">workshop对象需要接受一定数量的学生，并使用这个数量来部署为workshop中的每个学生创建定制内容的<code class="fe mq mr ms mt b">Student</code>资源。学生的内容可以是要使用的应用程序、实验指南、数据库等。</li></ul><p id="0eea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，研讨会将更容易部署，更有活力，自我修复，并为与会者提供更好的体验。</p><p id="0b34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">这不是一个真实的用户故事。我知道。但你明白要点了，对吧？</em></p><h1 id="7512" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">操作员如何工作</h1><p id="83c5" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">像许多新技术一样，构成运营商的kubernetes组件并不新鲜。但是它们的构建、管理和实现方式是革命性的。最基本的，操作符是一个kubernetes定制资源定义(CRD)和一个定制控制器。</p><p id="b996" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控制器本质上是将CRD集成到kubernetes API和数据库中的大脑。它们控制用户和定制资源之间的交互。出于时间的原因，我们不打算再深入了。如果你感兴趣，托马斯·斯金格写的关于控制器的很棒的初级读本就在Medium上。</p><div class="mz na gp gr nb nc"><a href="https://medium.com/@trstringer/create-kubernetes-controllers-for-core-and-custom-resources-62fc35ad64a3" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">扩展Kubernetes:为核心和定制资源创建控制器</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Kubernetes功能强大，附带了许多开箱即用的功能。但是当我们开始考虑新的方法来…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ky nc"/></div></div></a></div><p id="0a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运营商最大的好处之一就是他们可以抽象出你自己管理的大部分需求。</p><p id="5fb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CRD是为您的定制工作做繁重工作的实际资源。我们将进入一个示例，我们需要在页面的下面创建一个CRD。如果你想深入了解CRD，它们在<a class="ae kr" href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions" rel="noopener ugc nofollow" target="_blank">文档</a>中有很好的介绍。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/2a464e85ac108e9719727eae965320d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfdbJhFshtCTcw01_AbEzg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">难以置信的简单，逻辑，可能在36个方面不准确，控制器和CRD如何集成到kubernetes的观点。</figcaption></figure><p id="8d19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在定制控制器和CRDS之间，您可以任意扩展kubernetes数据库，以处理与您的应用程序和应用程序平台生命周期的各个方面相关的各种数据。运营商使这成为几乎任何IT专业人员或团队的能力，而不仅仅是精英。</p><p id="e886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这样的背景，让我们做一些决定并开始吧。</p><h1 id="801f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运营商SDK</h1><p id="9974" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">建筑运营商使用<a class="ae kr" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank">软件开发套件(SDK) </a>。由于我在Mac上(说来话长)，我可以很容易地用<code class="fe mq mr ms mt b">brew</code>安装它。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="0b02" class="oa lf it mt b gy ob oc l od oe">$ brew install operator-sdk</span></pre><p id="2ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有几种类型的运算符可以与SDK一起使用。</p><h2 id="e356" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">运算符的类型</h2><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/334bf1f4ead308403723fb3f4ffa46e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*0DsWGJMeEwUDNGib.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">戈朗地鼠</figcaption></figure><p id="da59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae kr" href="https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md" rel="noopener ugc nofollow" target="_blank"> Golang操作符</a> —这是所有SDK选项中最灵活的。这是用纯戈兰语写的。它提供了对所创建的CRD和控制器的最大程度的暴露(从而控制)。权力越大，责任越大。这个对我们来说有点过了。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="ab gu cl or"><img src="../Images/b6e4986e3e8c247ad7653056444e900f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*C9_DRETsaoPtMde_w71I_A.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">头盔标志</figcaption></figure><p id="94ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae kr" href="https://github.com/operator-framework/operator-sdk/blob/master/doc/helm/user-guide.md" rel="noopener ugc nofollow" target="_blank">舵操作符</a> —这个操作符抽象出控制器，CRD嵌入你选择的舵图表。我不是舵手专家，但是舵手图表被输入到CRD并且在里面被执行。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi os"><img src="../Images/a5d81f9831bca3b838b35d4cfe0321eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*F4HmnQlTIzTC4MZX"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Ansible标志</figcaption></figure><p id="90ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可变运算符——这才是我们要说的！我的两个极客最爱。OpenShift和Ansible。我们稍后将深入研究细节(铺垫—这是我们为我们的操作符选择的)，但是这个操作符在CRD中使用了<code class="fe mq mr ms mt b"><a class="ae kr" href="https://github.com/ansible/ansible-runner" rel="noopener ugc nofollow" target="_blank">ansible-runner</a></code>。它在无限循环中执行指定的剧本和角色。这个操作符不如Golang操作符灵活，但是对于许多目标来说，它有足够的马力。</p><p id="cf7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些信息，让我们选择一个解决方案并开始编码。</p><h1 id="0e63" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用哪个运算符</h1><p id="7bc6" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">对于这个项目，Ansible操作员的进入门槛最低(我既不是Golang也不是Helm专家)，我们设想的工作流可以轻松集成到Ansible剧本和角色中。</p><p id="41bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">已经决定了。我们开始吧！</p><h1 id="824c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建操作员</h1><p id="418a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当您安装Operator SDK时，它会在您的系统上添加一个名为<code class="fe mq mr ms mt b">operator-sdk</code>的二进制文件。要创建新的操作员，您需要设置以下选项:</p><ul class=""><li id="92fc" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">名称:在<code class="fe mq mr ms mt b">new</code>参数之后，您为您的操作符指定名称</li><li id="5a0d" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated"><a class="ae kr" href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups" rel="noopener ugc nofollow" target="_blank"> api-version (API组)</a>:API组在REST路径和序列化对象<em class="ko">(引用自链接)</em>的<code class="fe mq mr ms mt b">apiVersion</code>字段中指定</li><li id="d2f6" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated"><a class="ae kr" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#types-kinds" rel="noopener ugc nofollow" target="_blank"> kind </a> : Kind是一个字符串值，代表这个对象所代表的REST资源。服务器可以从客户端向其提交请求的端点推断出这一点。无法更新。在骆驼案。(<a class="ae kr" href="https://kubernetes.io/docs/reference/federation/v1/definitions/" rel="noopener ugc nofollow" target="_blank">来源</a>)</li><li id="45dc" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated">类型:要构建的运算符的类型。在我们的例子中，我们使用Ansible操作符。</li><li id="07a2" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated">集群范围:这个操作符将创建新的项目(类似于kubernetes名称空间的OpenShift)和这些项目中的资源。这意味着我们需要它访问整个集群，而不仅仅是单个名称空间。</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="fbb6" class="oa lf it mt b gy ob oc l od oe">$ operator-sdk new workshop-operator \<br/>--api-version=workshops.operator.redhatgov.io/v1 \<br/>--kind=Workshop \<br/>--type=ansible \<br/>--cluster-scoped</span></pre><p id="21bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会看到一堆输出。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="5a2f" class="oa lf it mt b gy ob oc l od oe">INFO[0000] Creating new Ansible operator 'workshop-operator'.<br/>INFO[0000] Created deploy/service_account.yaml<br/>INFO[0000] Created deploy/role.yaml<br/>INFO[0000] Created deploy/role_binding.yaml<br/>INFO[0000] Created deploy/crds/workshops_v1_workshop_crd.yaml<br/>INFO[0000] Created deploy/crds/workshops_v1_workshop_cr.yaml<br/>INFO[0000] Created build/Dockerfile<br/>INFO[0000] Created roles/workshop/README.md<br/>INFO[0000] Created roles/workshop/meta/main.yml<br/>INFO[0000] Created roles/workshop/files/.placeholder<br/>INFO[0000] Created roles/workshop/templates/.placeholder<br/>INFO[0000] Created roles/workshop/vars/main.yml<br/>INFO[0000] Created molecule/test-local/playbook.yml<br/>INFO[0000] Created roles/workshop/defaults/main.yml<br/>INFO[0000] Created roles/workshop/tasks/main.yml<br/>INFO[0000] Created molecule/default/molecule.yml<br/>INFO[0000] Created build/test-framework/Dockerfile<br/>INFO[0000] Created molecule/test-cluster/molecule.yml<br/>INFO[0000] Created molecule/default/prepare.yml<br/>INFO[0000] Created molecule/default/playbook.yml<br/>INFO[0000] Created build/test-framework/ansible-test.sh<br/>INFO[0000] Created molecule/default/asserts.yml<br/>INFO[0000] Created molecule/test-cluster/playbook.yml<br/>INFO[0000] Created roles/workshop/handlers/main.yml<br/>INFO[0000] Created watches.yaml<br/>INFO[0000] Created deploy/operator.yaml<br/>INFO[0000] Created .travis.yml<br/>INFO[0000] Created molecule/test-local/molecule.yml<br/>INFO[0000] Created molecule/test-local/prepare.yml<br/>INFO[0000] Run git init ...<br/>Initialized empty Git repository in /Users/jduncan/Code/workshop-operator2/workshop-operator/.git/<br/>INFO[0000] Run git init done<br/>INFO[0000] Project creation complete.</span></pre><p id="1cc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转到新创建的目录，您会看到几个文件:</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="b459" class="oa lf it mt b gy ob oc l od oe">$ tree<br/>.<br/>├── build<br/>│   ├── Dockerfile<br/>│   └── test-framework<br/>│       ├── Dockerfile<br/>│       └── ansible-test.sh<br/>├── deploy<br/>│   ├── crds<br/>│   │   ├── workshops_v1_workshop_cr.yaml<br/>│   │   └── workshops_v1_workshop_crd.yaml<br/>│   ├── operator.yaml<br/>│   ├── role.yaml<br/>│   ├── role_binding.yaml<br/>│   └── service_account.yaml<br/>├── molecule<br/>│   ├── default<br/>│   │   ├── asserts.yml<br/>│   │   ├── molecule.yml<br/>│   │   ├── playbook.yml<br/>│   │   └── prepare.yml<br/>│   ├── test-cluster<br/>│   │   ├── molecule.yml<br/>│   │   └── playbook.yml<br/>│   └── test-local<br/>│       ├── molecule.yml<br/>│       ├── playbook.yml<br/>│       └── prepare.yml<br/>├── roles<br/>│   └── workshop<br/>│       ├── README.md<br/>│       ├── defaults<br/>│       │   └── main.yml<br/>│       ├── files<br/>│       ├── handlers<br/>│       │   └── main.yml<br/>│       ├── meta<br/>│       │   └── main.yml<br/>│       ├── tasks<br/>│       │   └── main.yml<br/>│       ├── templates<br/>│       └── vars<br/>│           └── main.yml<br/>└── watches.yaml</span><span id="240f" class="oa lf it mt b gy ot oc l od oe">17 directories, 25 files</span></pre><p id="5175" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是您的运营商的基本模型。现在它做的不多，但是你的基础都在那里。更详细地看一下目录结构:</p><ul class=""><li id="4bc6" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated"><code class="fe mq mr ms mt b">build</code> —这个目录包含一个docker文件和一些测试，当您通过SDK触发一个构建时，这些测试就会运行。</li><li id="f3f3" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated"><code class="fe mq mr ms mt b">deploy</code> —构建完成后部署的对象。我们将在这篇文章的后面处理这些问题。</li><li id="8f19" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated"><code class="fe mq mr ms mt b">molecule</code> — <a class="ae kr" href="https://pypi.org/project/molecule/" rel="noopener ugc nofollow" target="_blank">分子</a>是对可承担角色的测试框架。这超出了本文的范围，主要是因为我还没有做到这一步。</li><li id="8c22" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated"><code class="fe mq mr ms mt b">roles</code>—SDK在创建您的工作环境时，为您创建了一个空的可负责角色。</li><li id="de61" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated"><code class="fe mq mr ms mt b">watches.yaml</code> —该文件告诉SDK在构建CRD容器时要将哪些角色和剧本插入其中。本质上，这是您告诉Operator SDK关于Ansible您想作为您的操作员运行的地方。</li></ul><h2 id="155d" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">手表. yaml</h2><p id="68b7" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">一开始的<code class="fe mq mr ms mt b">watches.yaml</code>的内容实质上就是你在创建环境时提供的<code class="fe mq mr ms mt b">operator-sdk</code>的信息。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="a654" class="oa lf it mt b gy ob oc l od oe">$ cat watches.yaml<br/>---<br/>- version: v1<br/>  group: workshops.operator.redhatgov.io<br/>  kind: Workshop<br/>  role: /opt/ansible/roles/workshop</span></pre><p id="041f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SDK使用它来确保正确的Ansible内容与正确版本的kubernetes对象相关联，创建这些对象是为了使您的操作符。按照这个顺序，正确的kubernetes事件将与相应的Ansible内容相关联。</p><p id="e59c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从技术上来说，你现在就可以建立你的运营商。它不会做任何事，但它会建造。接下来，让它做点什么。</p><h1 id="1a62" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们的操作员做点什么</h1><p id="96fa" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们的第一个任务是让我们的操作员创建一个命名空间来保存我们车间的任何共享资源。这将为我们提供一个简单的角色，我们可以在部署操作符时确认正在发生的事情。</p><p id="8135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将以下任务添加到<code class="fe mq mr ms mt b">roles/workshop/tasks/main.yml</code>。运行时，变量<code class="fe mq mr ms mt b">meta.name</code>在容器内由配置容器内<code class="fe mq mr ms mt b">ansible-runner</code>的代码<a class="ae kr" href="https://github.com/operator-framework/operator-sdk/blob/master/pkg/ansible/runner/runner.go#L417" rel="noopener ugc nofollow" target="_blank">设置。</a></p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="e178" class="oa lf it mt b gy ob oc l od oe">---</span><span id="2926" class="oa lf it mt b gy ot oc l od oe">- name: Create project for global workshop content<br/>  k8s:<br/>    api_version: v1<br/>    kind: Namespace<br/>    name: "{{ meta.name }}"</span></pre><p id="af50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着最初的任务添加到我们的角色中，让我们第一次构建我们的操作符，看看这个过程是如何工作的。</p><h1 id="f83b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构建车间操作员</h1><p id="f1e9" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当构建Ansible操作符时，<code class="fe mq mr ms mt b">watches.yaml</code>中引用的剧本和/或角色使用包含<code class="fe mq mr ms mt b">ansible-runner</code>的专用基础映像进行合并。从外部看，该过程与<a class="ae kr" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank">源到图像</a>非常相似。该过程由<code class="fe mq mr ms mt b">build/Dockerfile</code>控制。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="4361" class="oa lf it mt b gy ob oc l od oe">$ cat build/Dockerfile<br/>FROM quay.io/operator-framework/ansible-operator:v0.6.0</span><span id="77a6" class="oa lf it mt b gy ot oc l od oe">COPY roles/ ${HOME}/roles/<br/>COPY watches.yaml ${HOME}/watches.yaml</span></pre><p id="9b19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe mq mr ms mt b">operator-sdk</code>命令构建车间操作员。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="6928" class="oa lf it mt b gy ob oc l od oe">$ operator-sdk build quay.io/jduncan/workshop-operator:v1<br/>Step 1/3 : FROM quay.io/operator-framework/ansible-operator:v0.6.0<br/>...<br/>Step 2/3 : COPY roles/ ${HOME}/roles/<br/> ---&gt; 1a0094e3c710<br/>Step 3/3 : COPY watches.yaml ${HOME}/watches.yaml<br/> ---&gt; 44a4573f0e00<br/>Successfully built 44a4573f0e00<br/>Successfully tagged quay.io/jduncan/workshop-operator:v1</span></pre><p id="6333" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该能够在本地容器图像缓存中看到新的容器图像。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="7090" class="oa lf it mt b gy ob oc l od oe">$ docker images<br/>REPOSITORY                                                       TAG                 IMAGE ID            CREATED              SIZE<br/>quay.io/jduncan/workshop-operator                                v1                  0fd27b9c9905        6 seconds ago       611MB</span></pre><p id="9099" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，将新创建的映像推送到容器注册表中。在这个例子中，我们使用的是<a class="ae kr" href="https://quay.io" rel="noopener ugc nofollow" target="_blank"> quay.io </a>。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="a573" class="oa lf it mt b gy ob oc l od oe">$ docker push quay.io/jduncan/workshop-operator<br/>The push refers to repository [quay.io/jduncan/workshop-operator]<br/>...<br/>v1: digest: sha256:97180d40822007bc81628bdd459077bd6c9301f516c5354f178260e2fbe173d0 size: 19642</span></pre><p id="15ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是构建过程。您的新操作员的图像已经创建。接下来，我们需要调整一两个文件，这样我们就可以将操作符部署到OpenShift集群中。</p><h1 id="e93c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">部署车间操作员</h1><p id="f15c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当我们创建新的操作符时，它创建了<code class="fe mq mr ms mt b">deploy/operator.yaml</code>。我们需要更改一些默认值来指定上传的映像和重启策略。</p><p id="dd70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在<a class="ae kr" href="https://github.com/operator-framework/operator-sdk/blob/master/doc/ansible/user-guide.md#1-run-as-a-pod-inside-a-kubernetes-cluster" rel="noopener ugc nofollow" target="_blank">文档</a>中有所涉及，但看起来确实有点过时。因为我是在MacOS上做这个的，所以我将运行一些快速的<code class="fe mq mr ms mt b">sed</code>语句来处理这一切。注意，<code class="fe mq mr ms mt b">opererator.yaml</code>正在创建一个kubernetes <a class="ae kr" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>对象。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="3add" class="oa lf it mt b gy ob oc l od oe">$ sed -i "" 's|{{ REPLACE_IMAGE }}|quay.io/jduncan/workshop-operator:v1|g' deploy/operator.yaml</span><span id="df86" class="oa lf it mt b gy ot oc l od oe">$ sed -i "s|REPLACE_NAMESPACE|workshop-operator|g" deploy/role_binding.yaml</span><span id="5683" class="oa lf it mt b gy ot oc l od oe">$ sed -i "" 's|{{ pull_policy\|default('\''Always'\'') }}|Always|g' deploy/operator.yaml</span></pre><p id="5009" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成这些更改后，就该部署我们操作符的初始版本了。这是通过运行<code class="fe mq mr ms mt b">deploy/</code>中的几个yaml文件来完成的。因为我们要将它部署到OpenShift集群中，所以我们使用了<code class="fe mq mr ms mt b">oc</code>命令。</p><ul class=""><li id="0f25" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">首先，创建一个项目来容纳我们的新操作员</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="cb4e" class="oa lf it mt b gy ob oc l od oe">$ oc new-project workshop-operator<br/>Now using project "workshop-operator" on server "<a class="ae kr" href="https://api.test.kuberati.com:6443" rel="noopener ugc nofollow" target="_blank">https://api.test.kuberati.com:6443</a>".</span><span id="b3a5" class="oa lf it mt b gy ot oc l od oe">You can add applications to this project with the 'new-app' command. For example, try:</span><span id="0679" class="oa lf it mt b gy ot oc l od oe">oc new-app centos/ruby-25-centos7~<a class="ae kr" href="https://github.com/sclorg/ruby-ex.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sclorg/ruby-ex.git</a></span><span id="7b14" class="oa lf it mt b gy ot oc l od oe">to build a new example application in Ruby.</span></pre><ul class=""><li id="21b5" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">然后，创建一个服务帐户供操作员使用</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="22e7" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/service_account.yaml<br/>serviceaccount/workshop-operator created</span></pre><ul class=""><li id="a78c" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">接下来，为操作员创建一个角色。我们需要对创建操作符时生成的版本<code class="fe mq mr ms mt b">deploy/role.yaml</code>进行一些编辑。因为我们使用serviceaccount在其默认名称空间之外创建资源，所以我们需要赋予它更多的权力。这里的配置<strong class="js iu">不是</strong>生产就绪。但我们不是在生产，我们是在创造一个原型！它应该看起来像下面的例子。</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="0684" class="oa lf it mt b gy ob oc l od oe">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRole<br/>metadata:<br/>  creationTimestamp: null<br/>  name: workshop-operator<br/>rules:<br/>- apiGroups:<br/>  - '*'<br/>  resources:<br/>  - '*'<br/>  verbs:<br/>  - '*'</span></pre><ul class=""><li id="ed98" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">完成后，我们创建我们的角色。</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="db69" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/role.yaml<br/>role.rbac.authorization.k8s.io/workshop-operator created</span></pre><ul class=""><li id="9d88" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">接下来，将角色绑定到服务帐户</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="7d99" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/role_binding.yaml<br/>clusterrolebinding.rbac.authorization.k8s.io/workshop-operator created</span></pre><ul class=""><li id="be3d" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">接下来，部署操作员将使用的CRD。</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="e5f1" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/crds/workshops_v1_workshop_crd.yaml<br/>customresourcedefinition.apiextensions.k8s.io/workshops.workshops.operator.redhatgov.io created</span></pre><ul class=""><li id="6f31" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">最后，部署操作符本身，它引用了上面的角色绑定。</li></ul><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="9b21" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/operator.yaml<br/>deployment.apps/workshop-operator created</span></pre><p id="66df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成这些步骤后，我们就部署了一个操作员！要进行确认，请检查以确保部署已启动并正在运行。</p><p id="9f4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">注意:为了更好地解释，我们将它分成了几个单独的步骤。但是我们也已经把这一切都放到了这个项目的Github repo </em>  <em class="ko">中的少数</em> <a class="ae kr" href="https://github.com/jduncan-rva/workshop-operator/tree/master/hack" rel="noopener ugc nofollow" target="_blank"> <em class="ko">方便脚本中。</em></a></p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="b285" class="oa lf it mt b gy ob oc l od oe">$ oc get deployment<br/>NAME                READY   UP-TO-DATE   AVAILABLE   AGE<br/>workshop-operator   1/1     1            1           6m14s</span></pre><p id="d3d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果运行<code class="fe mq mr ms mt b">oc get workshops</code>，将不会返回任何资源(我们还没有部署workshop，只是由操作员来控制它们)。但它不会出错。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="a38c" class="oa lf it mt b gy ob oc l od oe">$ oc get workshops<br/>No resources found.</span></pre><p id="9dde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了得到有趣的东西，我们有一个文件<code class="fe mq mr ms mt b">deploy/workshops_v1_workshop_cr.yaml</code>，它为我们提供了一个部署研讨会的模板。因为我们还没有修改Ansible代码来创建惟一的名称空间名称，所以将这个模板的<code class="fe mq mr ms mt b">size</code>参数改为1。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="0be6" class="oa lf it mt b gy ob oc l od oe">$ cat deploy/crds/workshops_v1_workshop_cr.yaml<br/>apiVersion: workshops.operator.redhatgov.io/v1<br/>kind: Workshop<br/>metadata:<br/>  name: example-workshop<br/>spec:<br/>  # Add fields here<br/>  size: 1</span></pre><p id="5532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">做出更改后，让我们部署一个研讨会吧！部署完成后，我们将再次运行<code class="fe mq mr ms mt b">oc get workshops</code>来确认它是否成功。然后，为了确保Ansible被正确执行，我们将寻找一个名为<code class="fe mq mr ms mt b">workshop-operator</code>的新创建的项目。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="6a6a" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/crds/workshops_v1_workshop_cr.yaml<br/>workshop.workshops.operator.redhatgov.io/example-workshop created</span><span id="c37e" class="oa lf it mt b gy ot oc l od oe">$ oc get workshops<br/>NAME               AGE<br/>example-workshop   15s</span><span id="911b" class="oa lf it mt b gy ot oc l od oe">$ oc get projects | grep workshop<br/>example-workshop                                         Active<br/>workshop-operator                                        Active</span></pre><p id="8d13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成功！我们部署了一个<code class="fe mq mr ms mt b">Workshop</code>资源，这个资源的创建创建了一个新项目，就像我们使用Ansible告诉它的那样。这项工作完成后，唯一需要重复的部分就是创建新的定制资源。例如，如果我将<code class="fe mq mr ms mt b">workshops_v1_workshop_cr.yaml</code>中的名称更改为其他名称，我可以重新运行它，并获得一个带有新关联项目的新车间。在这个例子中，我将<code class="fe mq mr ms mt b">deploy/crds/workshops_v1_workshop_cr.yaml</code>复制到另一个文件，并将名称改为<code class="fe mq mr ms mt b">another-workshop</code>。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="b107" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/crds/workshops_v1_workshop2_cr.yaml<br/>workshop.workshops.operator.redhatgov.io/another-workshop created</span><span id="8e81" class="oa lf it mt b gy ot oc l od oe">$ oc get workshops<br/>NAME               AGE<br/>another-workshop   62s<br/>example-workshop   26m</span><span id="fb13" class="oa lf it mt b gy ot oc l od oe">$ oc get projects | grep workshop<br/>another-workshop                                         Active<br/>example-workshop                                         Active<br/>workshop-operator                                        Active</span></pre><p id="7d43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在已经创建了第一个函数运算符。它创建了一个名为<code class="fe mq mr ms mt b">Workshop</code>的资源，每个workshop资源又创建了一个项目，最终将包含所有共享的内容。</p><p id="7592" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一部分中，我们将为我们的操作员创建一些额外的工作来处理，以便我们可以完成我们在开始时概述的成功标准。</p><h1 id="57d2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">扩展车间操作员</h1><h2 id="66dd" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">观看剧本而不是角色</h2><p id="2200" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">默认情况下，Ansible运算符监视特定的角色。但是，使用多个较小的角色并将它们整合到一个剧本中是可行的最佳实践。为此，我们必须:</p><ul class=""><li id="7998" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">创建一个参考我们角色的行动手册</li><li id="c291" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated">指示<code class="fe mq mr ms mt b">watches.yaml</code>寻找那些剧本，而不是默认的可负责角色。</li><li id="013b" class="mh mi it js b jt mu jx mv kb mw kf mx kj my kn mm mn mo mp bi translated">将<code class="fe mq mr ms mt b">playbooks</code>目录添加到<code class="fe mq mr ms mt b">build/Dockerfile</code>中。</li></ul><p id="33c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要创建行动手册，请在操作员目录的顶层创建一个<code class="fe mq mr ms mt b">playbooks</code>目录。在该目录中，创建一个名为<code class="fe mq mr ms mt b">workshop.yml</code>的文件，内容如下。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="f763" class="oa lf it mt b gy ob oc l od oe">---</span><span id="69ea" class="oa lf it mt b gy ot oc l od oe">- hosts: localhost  <br/>  roles:    <br/>    - workshop</span></pre><p id="b541" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">行动手册将在<code class="fe mq mr ms mt b">roles</code>目录中查找我们已经创建的车间角色。接下来，编辑<code class="fe mq mr ms mt b">watches.yaml</code>以引用剧本而不是角色。对于角色和剧本，父目录<code class="fe mq mr ms mt b">/opt/ansible</code>是您用SDK构建的操作员容器映像中的位置。请确保使用该路径，而不是开发系统上的路径。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="90b1" class="oa lf it mt b gy ob oc l od oe">$ cat watches.yaml<br/>---<br/>- version: v1<br/>  group: workshops.operator.redhatgov.io<br/>  kind: Workshop<br/>  playbook: /opt/ansible/playbooks/workshop.yml</span></pre><p id="6c58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一项任务是确保<code class="fe mq mr ms mt b">build/Dockerfile</code>在构建我们的操作员映像时将包含<code class="fe mq mr ms mt b">playbooks</code>目录。编辑您的文件，如下例所示。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="dfe5" class="oa lf it mt b gy ob oc l od oe">$ cat build/Dockerfile<br/>FROM quay.io/operator-framework/ansible-operator:v0.6.0</span><span id="aa45" class="oa lf it mt b gy ot oc l od oe">COPY roles/ ${HOME}/roles/<br/>COPY playbooks/ ${HOME}/playbooks/<br/>COPY watches.yaml ${HOME}/watches.yaml</span></pre><p id="c877" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅此而已。车间操作员现在可以观看我们刚刚创建的车间行动手册。接下来，我们将向操作符添加一个学生对象。</p><h2 id="67ac" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">添加附加资源</h2><p id="8861" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当我们在开始定义我们的成功标准时，我们声明我们想要创建工作室(完成)和学生。现在让我们向操作符添加一个学生对象。我们可以使用<code class="fe mq mr ms mt b">operator-sdk</code>工具来完成这项工作。我们需要为它提供一个API值，包括一个版本和一个<code class="fe mq mr ms mt b">Kind</code>值。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="eddb" class="oa lf it mt b gy ob oc l od oe">$ operator-sdk add crd \<br/>--api-version students.operator.redhatgov.io/v1 \<br/>--kind Student<br/>INFO[0000] Generating Custom Resource Definition (CRD) version student.operator.redhatgov.io/v1 for kind Student.<br/>INFO[0000] Created deploy/crds/student_v1_student_crd.yaml<br/>INFO[0000] Created deploy/crds/student_v1_student_cr.yaml</span></pre><p id="6f43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程为我们的新对象创建CRD和CR文件。当我们将新的对象部署到操作符中时，我们将使用它们。接下来，让我们向我们的操作符添加一个可转换的代码来创建我们的学生对象。</p><h2 id="553a" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">观看多个行动手册</h2><p id="7557" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们希望我们的学生对象尽可能真实地反映我们的车间对象。我们将从使用<code class="fe mq mr ms mt b">ansible-galaxy</code>创建一个新的学生角色开始。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="b240" class="oa lf it mt b gy ob oc l od oe">$ cd roles/<br/>$ ansible-galaxy init student<br/>- student was created successfully</span><span id="bdc3" class="oa lf it mt b gy ot oc l od oe">$ tree student<br/>students<br/>├── README.md<br/>├── defaults<br/>│   └── main.yml<br/>├── files<br/>├── handlers<br/>│   └── main.yml<br/>├── meta<br/>│   └── main.yml<br/>├── tasks<br/>│   └── main.yml<br/>├── templates<br/>├── tests<br/>│   ├── inventory<br/>│   └── test.yml<br/>└── vars<br/>    └── main.yml</span></pre><p id="d20a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将以下内容添加到<code class="fe mq mr ms mt b">roles/students/tasks/main.yml</code>。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="9111" class="oa lf it mt b gy ob oc l od oe">- name: Create project for student <br/>  k8s:    <br/>    api_version: v1    <br/>    kind: Namespace<br/>    name: "{{ meta.name }}"</span></pre><p id="12db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，用下面的内容创建<code class="fe mq mr ms mt b">playbooks/student.yml</code>。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="e3ac" class="oa lf it mt b gy ob oc l od oe">---<br/>- hosts: localhost<br/>  roles:<br/>    - student</span></pre><p id="846f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着我们新的学生角色和剧本的创建，我们需要告诉<code class="fe mq mr ms mt b">watches.yaml</code>观看我们新的学生内容。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="691a" class="oa lf it mt b gy ob oc l od oe">$ cat watches.yaml<br/>---<br/>- version: v1<br/>  group: workshops.operator.redhatgov.io<br/>  kind: Workshop<br/>  playbook: /opt/ansible/playbooks/workshop.yml</span><span id="2984" class="oa lf it mt b gy ot oc l od oe">- version: v1<br/>  group: operator.redhatgov.io<br/>  kind: Student<br/>  playbook: /opt/ansible/playbooks/student.yml</span></pre><p id="4aad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成这项工作后，我们就可以构建新版本的操作符容器映像了！一定要增加版本号，这样我们就不会混淆。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="0202" class="oa lf it mt b gy ob oc l od oe">$ operator-sdk build quay.io/jduncan/workshop-operator:v1<br/>INFO[0000] Building Docker image quay.io/jduncan/workshop-operator:v2<br/>Sending build context to Docker daemon  189.4kB<br/>Step 1/3 : FROM quay.io/operator-framework/ansible-operator:v0.5.0<br/> ---&gt; 1e857f3522b5<br/>Step 2/3 : COPY roles/ ${HOME}/roles/<br/> ---&gt; 2d415bae1bf4<br/>Step 3/3 : COPY watches.yaml ${HOME}/watches.yaml<br/> ---&gt; 0a45095442ba<br/>Successfully built 0a45095442ba<br/>Successfully tagged quay.io/jduncan/workshop-operator:v2<br/>INFO[0001] Operator build complete.</span></pre><p id="58ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建完成后，将容器映像推送到存储库。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="c56b" class="oa lf it mt b gy ob oc l od oe">$ docker push quay.io/jduncan/workshop-operator:v1<br/>...<br/>v2: digest: sha256:96e40f62a49b96e7a068a3858afc4f65ab11d71cfeeac1fd825f1a32dba73b1f size: 19172</span></pre><p id="cfb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了部署我们的新操作员，我们删除以前的部署并创建新的部署。此外，一定要创建新的学生CRD。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="3c68" class="oa lf it mt b gy ob oc l od oe">$ oc delete deployment workshop-operator<br/>deployment.extensions "workshop-operator" deleted</span><span id="13a6" class="oa lf it mt b gy ot oc l od oe">$ oc create -f deploy/operator.yaml<br/>deployment.apps/workshop-operator created</span><span id="c54a" class="oa lf it mt b gy ot oc l od oe">$ oc create -f deploy/crds/student_v1_student_crd.yaml<br/>customresourcedefinition.apiextensions.k8s.io/students.student.operator.redhatgov.io created</span></pre><p id="6352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了测试我们的新操作符，编辑<code class="fe mq mr ms mt b">deploy/crds/student_v1_student_cr.yaml</code>如下图所示。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="55a9" class="oa lf it mt b gy ob oc l od oe">$ cat deploy/crds/student_v1_student_cr.yaml<br/>apiVersion: student.operator.redhatgov.io/v1<br/>kind: Student<br/>metadata:<br/>  name: example-student<br/>spec:<br/>  # Add fields here<br/>  size: 1</span></pre><p id="a0f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部署一名测试学生。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="48ad" class="oa lf it mt b gy ob oc l od oe">$ oc get students<br/>No resources found.</span><span id="3fd8" class="oa lf it mt b gy ot oc l od oe">$ oc create -f deploy/crds/student_v1_student_cr.yaml<br/>student.student.operator.redhatgov.io/example-student created</span><span id="7328" class="oa lf it mt b gy ot oc l od oe">$ oc get students<br/>NAME              AGE<br/>example-student   5s</span><span id="4354" class="oa lf it mt b gy ot oc l od oe">$ oc get projects | grep student<br/>example-student                          Active</span></pre><p id="f2cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的车间操作员为车间和学生创建和管理我们的定制资源。但是有点硬编码，比较脆。当你有50个学生时，你不希望在一个车间里为每个学生写yaml。在我们的最后一部分，我们将把workshop和student对象更紧密地联系在一起，让它们做一些更有效的工作。</p><h2 id="8e51" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">集成更复杂的工作流程</h2><p id="5739" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">现在我们已经有了车间操作员的基本知识，让我们来做一点更实际的事情。首先，让我们解决让车间自己部署它们自己的学生对象的任务。</p><p id="04ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，编辑<code class="fe mq mr ms mt b">roles/workshop/tasks/main.yml</code>以包含以下代码。这个新任务将接受一个变量<code class="fe mq mr ms mt b">num_students</code>，并创建相应数量的学生对象。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="a3c4" class="oa lf it mt b gy ob oc l od oe">--- </span><span id="bc1e" class="oa lf it mt b gy ot oc l od oe">- name: Create project for global workshop content<br/>  k8s:<br/>    api_version: v1<br/>    kind: Namespace<br/>    name: "{{ meta.name }}"<br/><br/>- name: Create students for workshop<br/>  k8s:<br/>    definition: "{{ lookup('template', 'student.yaml.j2') | from_yaml }}"<br/>  vars:<br/>    student_number: "{{ item }}"<br/>  loop: "{{ range(1, num_students + 1) | list }}"<br/>  when: num_students is defined</span></pre><p id="a171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个新任务使用了一个<a class="ae kr" href="https://docs.ansible.com/ansible/latest/modules/template_module.html" rel="noopener ugc nofollow" target="_blank"> Ansible模板</a>，并使用这个呈现的信息来创建新的kubernetes对象。模板位于<code class="fe mq mr ms mt b">roles/workshop/templates/student.yaml.j2</code>，如下图所示。<code class="fe mq mr ms mt b">meta.name</code>与我们在车间角色中使用的值相同。名称是动态格式，为每个学生的每个项目选择一个唯一的名称。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="3fad" class="oa lf it mt b gy ob oc l od oe">apiVersion: students.operator.redhatgov.io/v1<br/>kind: Student<br/>metadata:<br/>  name: "{{ 'student%02d' | format(student_number) }}"<br/>  namespace: "{{ meta.name }}"<br/>spec:<br/>  workshopName: "{{ meta.name }}"</span></pre><p id="35fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些文件，重新构建容器映像并上传它。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="c985" class="oa lf it mt b gy ob oc l od oe">$ operator-sdk build quay.io/jduncan/workshop-operator:v1<br/>INFO[0000] Building Docker image quay.io/jduncan/workshop-operator:v1<br/>Sending build context to Docker daemon  190.5kB<br/>Step 1/4 : FROM quay.io/operator-framework/ansible-operator:v0.6.0<br/> ---&gt; 5c51606d3f0e<br/>Step 2/4 : COPY roles/ ${HOME}/roles/<br/> ---&gt; 54b5a0bef4a7<br/>Step 3/4 : COPY playbooks/ ${HOME}/playbooks/<br/> ---&gt; 445da9f5faaa<br/>Step 4/4 : COPY watches.yaml ${HOME}/watches.yaml<br/> ---&gt; 481899806b43<br/>Successfully built 481899806b43<br/>Successfully tagged quay.io/jduncan/workshop-operator:v1<br/>INFO[0002] Operator build complete.</span><span id="8850" class="oa lf it mt b gy ot oc l od oe">$ docker push quay.io/jduncan/workshop-operator:v1<br/>The push refers to repository [quay.io/jduncan/workshop-operator]<br/>c080bf655ca4: Pushed<br/>0741b9b522c4: Pushed<br/>a28abf610d57: Pushed<br/>...<br/>v1: digest: sha256:3ac111f13b305408f742b42e7d2f0c8d5125250a77762ab8ba1633cfe52a4f3a size: 20158</span></pre><p id="aa0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们重新部署之前，让我们清理一下以前的研讨会和学生，以确保新配置自动为我们部署学生。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="26f0" class="oa lf it mt b gy ob oc l od oe">$ oc delete deployment workshop-operator<br/>deployment.extensions "workshop-operator" deleted</span><span id="13fc" class="oa lf it mt b gy ot oc l od oe">$ oc delete workshop example-workshop<br/>workshop.workshops.operator.redhatgov.io "example-workshop" deleted</span><span id="5de3" class="oa lf it mt b gy ot oc l od oe">$ oc delete workshop another-workshop<br/>workshop.workshops.operator.redhatgov.io "another-workshop" deleted</span><span id="f9f1" class="oa lf it mt b gy ot oc l od oe">$ oc delete student example-student<br/>student.students.operator.redhatgov.io "example-student" deleted</span></pre><p id="8362" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">清理完这些对象后，使用包含新Ansible代码的新映像重新部署workshop操作员。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="ee64" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/operator.yaml<br/>deployment.apps/workshop-operator created</span><span id="3bb2" class="oa lf it mt b gy ot oc l od oe">$ oc get pods<br/>NAME                                 READY   STATUS    RESTARTS   AGE<br/>workshop-operator-6759b6cf87-cc9xf   2/2     Running   0          54s</span></pre><p id="770c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新操作员运行后，部署一个车间。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="d2ae" class="oa lf it mt b gy ob oc l od oe">$ oc create -f deploy/crds/workshops_v1_workshop_cr.yaml<br/>workshop.workshops.operator.redhatgov.io/example-workshop created</span></pre><p id="9e21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正在部署相同的定制资源，但是因为我们已经更新了操作符，所以<code class="fe mq mr ms mt b">Student</code>资源也随着他们的项目一起被部署。</p><pre class="kt ku kv kw gt nw mt nx ny aw nz bi"><span id="3f8f" class="oa lf it mt b gy ob oc l od oe">$ oc get projects | grep student<br/>example-workshop-student01                               Active<br/>example-workshop-student02                               Active<br/>example-workshop-student03                               Active</span></pre><p id="fa21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当创建一个<code class="fe mq mr ms mt b">Workshop</code>资源时，它会创建<code class="fe mq mr ms mt b">numStudents</code>个相应的<code class="fe mq mr ms mt b">Student</code>资源。这些资源的创建触发相应的Ansible剧本从<code class="fe mq mr ms mt b">watches.yaml</code>运行。</p><p id="2ccc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们决定让我们的运营商为这个项目所做的。在您的OpenShift或kubernetes集群中，看到Ansible操作符的成千上万个潜在用例并不需要很大的飞跃。</p><h1 id="7de7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">总结和后续步骤</h1><h2 id="a83b" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">摘要</h2><p id="3ac4" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">几个人花了几天时间，在谷歌上搜索了数千次文档，才开始制作这个项目。和大多数文章一样，我们希望花时间阅读这篇文章能为你节省一些时间和研究。</p><p id="aa65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运营商为kubernetes集群的软件定义世界注入了强大的力量。这是一个用例的例子，其中我们能够将相对手动的流程转移到完全包含在我们的OpenShift集群中的完全自动化的流程中。操作员的目标是将应用程序的操作任务转移到集群本身。</p><h2 id="7994" class="oa lf it bd lg of og dn lk oh oi dp lo kb oj ok ls kf ol om lw kj on oo ma op bi translated">后续步骤</h2><p id="c94d" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们在这篇文章中使用的例子是一个积极开发的项目。我们的目标是将我们的Red Hat workshop内容推广到这种交付形式中。我们将所有这些工作保留在Github上。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ou"><img src="../Images/344e86a1ae56054b370b341f6f953770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3zoIXkX_gH_tU54K8xmRg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">https://github.com/jduncan-rva/workshop-operator<a class="ae kr" href="https://github.com/jduncan-rva/workshop-operator" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="2100" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的步骤包括<a class="ae kr" href="https://github.com/jduncan-rva/workshop-operator-lab-guide" rel="noopener ugc nofollow" target="_blank">使用Sphinx自动创建实验指南内容</a>(这是一篇即将发表的博客文章的主题)，以及继续为我们的项目构建资源以继续自动化过程。</p><p id="fd36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随时欢迎评论和问题/公关/明星！</p></div></div>    
</body>
</html>