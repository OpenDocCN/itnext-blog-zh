<html>
<head>
<title>Operator Metering with Look Back: Kubernetes Reports</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运营商计量与回顾:Kubernetes报告</h1>
<blockquote>原文：<a href="https://itnext.io/operator-metering-with-look-back-kubernetes-reports-85d6b86b1e3c?source=collection_archive---------0-----------------------#2018-12-16">https://itnext.io/operator-metering-with-look-back-kubernetes-reports-85d6b86b1e3c?source=collection_archive---------0-----------------------#2018-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7b293f077ccea86a796c5d15bf7e545e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z1JXJi73QhTAs63N"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯·利维拉尼在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7690" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于<a class="ae kc" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的新<a class="ae kc" href="https://www.redhat.com/en/blog/introducing-operator-framework-building-apps-kubernetes" rel="noopener ugc nofollow" target="_blank">操作符框架</a>的一个伟大特性是<a class="ae kc" href="https://github.com/operator-framework/operator-metering" rel="noopener ugc nofollow" target="_blank">操作符计量</a>，该技术在<a class="ae kc" href="https://docs.openshift.com/container-platform/3.11/release_notes/ocp_3_11_release_notes.html#ocp-311-operators" rel="noopener ugc nofollow" target="_blank"> OpenShift 3.11 </a>中进行了预览。<em class="lb">操作员计量</em>为<a class="ae kc" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>收集的数据带来了YAML和SQL风格的访问。<em class="lb"> Prometheus </em>因其在集装箱运营管理的度量、监控和警报方面的应用而闻名。从运营角度收集的数据通常集中在当前时间窗口；过去一小时、过去24小时和/或过去7天。然而，这种丰富的数据可用于各种其他情况，这些情况可能需要更长时间的回顾，如预测、异常检测、容量规划或比较(季度与季度、月/年、基于标签)。<em class="lb">操作员计量</em>能够以简单易用的方式访问这些数据，允许按需和按计划报告。这些报告本质上是将数据存储在<a class="ae kc" href="https://hadoop.apache.org/" rel="noopener ugc nofollow" target="_blank"> Hadoop </a>中，并可以通过API端点访问，该端点可以返回不同格式的数据，如CSV或JSON。<em class="lb">操作员计量</em>的特性为<em class="lb"> Kubernetes </em>的<em class="lb"> Prometheus </em>数据空间带来了类似于<a class="ae kc" href="https://aws.amazon.com/athena/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务(AWS) Athena </a>的力量。如果您对利用此功能的前景感兴趣，那么您可以继续阅读此报告的应用，它有助于为窗口数据提供“操作方法”和有用的提示。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="68cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，我的开发团队专注于混合云的成本管理。我们正在利用使用指标和定义的费率来呈现一段时间内的成本数据视图。对于<em class="lb"> Kubernetes </em>，成本数据在项目、节点、集群和标签之间被分割。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/5f32815167b21f8bdbc45774e20db862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGMiF5vsvzGNWFhPnebaLg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">分解轮班成本</figcaption></figure><p id="adf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得这些信息，我们正在利用<em class="lb">操作员计量</em>报告每小时收集pod的CPU和内存使用情况(存储即将推出)。然后，每天和每月汇总提取的使用数据以及定义的相关费率。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="0d66" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">操作员计量报告的基础</h1><p id="e01f" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">让我们从描述<em class="lb">操作员计量</em>报告的一些基础知识开始，从数据源到报告生成和计划报告。这些对象都使用YAML来表达，并使用<em class="lb"> Kubernetes </em>命令行存储为定义。从数据源开始，把它们想象成基于<em class="lb"> Prometheus </em>查询定义的表。<em class="lb">操作员计量</em>附带一些<a class="ae kc" href="https://github.com/operator-framework/operator-metering/blob/master/Documentation/report.md#generationquery" rel="noopener ugc nofollow" target="_blank">预定义的报告生成</a>，例如“名称空间-CPU-请求”，也可用作数据源。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5a21b8286229b6dd7f6f234822ef25e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*Ul_NgF9TIJ9KJyQasDX3pg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">定义kube-pod-labels数据源</figcaption></figure><p id="c24d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果数据源不存在，您可以定义一个，如我们在示例中看到的，我们正在创建一个<a class="ae kc" href="https://github.com/project-koku/korekuta/blob/master/roles/setup/files/kube-pod-labels_report_data_source.yaml" rel="noopener ugc nofollow" target="_blank"> pod标签数据源</a>，它为我们提供对在<em class="lb"> Prometheus </em>中找到的pod标签的访问。</p><p id="1b7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">报告生成本质上是SQL SELECT语句，它们将填充您的CSV或JSON输出。在报告生成中，您定义名称、数据源、具有类型和单位的列，最后是针对已定义数据源的查询，该查询获取具有已定义列的记录。在下面的<a class="ae kc" href="https://github.com/project-koku/korekuta/blob/master/roles/setup/files/pod-limit-cpu-cores_report_generation_query.yaml" rel="noopener ugc nofollow" target="_blank">示例中，您可以看到报告生成的定义及其名称、列和查询；在这里，您可以看到它如何收集当前时间间隔的pod、名称空间(或项目)、节点和CPU核心限制。</a></p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/07adbf4c74d9b371c2c40f9b076c22aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBy6Vvg-u0F0_YVqk92MTA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“pod-cpu-limit-raw”的报告生成</figcaption></figure><p id="b53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们已经浏览了数据源和报告生成，您可以看到它们是如何相互构建的，但是，我们还没有一个可执行的报告。<em class="lb">操作员计量</em>支持一次性(或按需)报告和计划报告的概念。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/236c2ab50ef1b77bafbb6a5f26e4e879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*GHy7HxN4dOAZahQzMT03-g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">定义每小时计划报告</figcaption></figure><p id="5f79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些报告可以有一个定义的开始和结束周期，如果您正在定义一个<a class="ae kc" href="https://github.com/operator-framework/operator-metering/blob/master/Documentation/using-metering.md#creating-a-report" rel="noopener ugc nofollow" target="_blank">一次性报告</a>，您可以指定<em class="lb">" run immediate:true "</em>，对于<a class="ae kc" href="https://github.com/project-koku/korekuta/blob/master/roles/setup/files/hccm_openshift_usage_lookback_scheduled_report.yaml" rel="noopener ugc nofollow" target="_blank">计划报告</a>，您可以指定一个<a class="ae kc" href="https://github.com/operator-framework/operator-metering/blob/master/Documentation/report.md#period" rel="noopener ugc nofollow" target="_blank">周期</a>，如每小时、每天等。在左侧的示例中，您可以看到没有提供开始或结束期间，这意味着该报告将无限期运行。无限期运行报告的概念很有吸引力，但是，不指定开始和结束时间段的缺点是，当<a class="ae kc" href="https://github.com/operator-framework/operator-metering/blob/master/Documentation/using-metering.md#viewing-reports" rel="noopener ugc nofollow" target="_blank">请求报告</a>的结果时，随着请求的数据大小不断增长，您可能会达到性能极限。</p><h1 id="2c73" class="lo lp iq bd lq lr mu lt lu lv mv lx ly lz mw mb mc md mx mf mg mh my mj mk ml bi translated">合并报表中的数据</h1><p id="3480" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">如上所述，<em class="lb">操作员计量</em>简单易用。如果您熟悉SQL，您可能会直觉地知道如何组合数据。我在上一节中简要提到，一个报告生成可以用作另一个报告生成的数据源；您还可以提供在报告生成中使用的多个数据源。继续从数据源只是一个表的角度来看，那么您可以正确地推断出您可以连接这些表中的数据，这可以在<a class="ae kc" href="https://github.com/project-koku/korekuta/blob/master/roles/setup/files/hccm_openshift_usage_report_generation_query.yaml" rel="noopener ugc nofollow" target="_blank">这个示例报告生成</a>中看到，它是使用九个先前定义的报告查询构建的。</p><h1 id="1555" class="lo lp iq bd lq lr mu lt lu lv mv lx ly lz mw mb mc md mx mf mg mh my mj mk ml bi translated">聚合和窗口</h1><p id="aeed" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">有了组合数据的能力，我们可以看到，如果需要每小时收集一次，报告的大小会增长得非常快。数据的增长最终会导致性能问题，对于某些视图，您可能不需要细粒度的每小时数据，但更感兴趣的是平均值或最大值，<em class="lb">操作员计量</em>支持<a class="ae kc" href="https://github.com/operator-framework/operator-metering/blob/master/Documentation/rollup-reports.md" rel="noopener ugc nofollow" target="_blank">汇总报告</a>来提供这种功能。</p><p id="792e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您确实需要更细粒度的细节，您最初的方法可能是创建具有定义的开始和结束时间段的报告块，以限制将为报告返回的数据量。使用报告块的方法是可行的，但是，为了访问数据，需要一些命名方案，此外，随着时间的推移，您需要继续创建报告块，这可以是自动化的，但也为错误和丢失数据留下了机会。对于我们的用例，开发团队想到了带有回顾的窗口数据的概念，这带来了额外的性能优势，实质上是在现有的表上构造一个视图。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/0a2e5ae612e2de69d61077d0c2a47e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vg-wZ_9qreE3wxCFHRKrqA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有10天回顾的查询</figcaption></figure><p id="f469" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面的例子中所看到的，您可以<a class="ae kc" href="https://github.com/project-koku/korekuta/blob/master/roles/setup/files/hccm_openshift_usage_lookback_report_generation_query.yaml" rel="noopener ugc nofollow" target="_blank">构建一个报告生成</a>窗口来显示返回的数据。链接的报告生成从讨论合并数据的部分获取报告生成，该部分具有<a class="ae kc" href="https://github.com/project-koku/korekuta/blob/master/roles/setup/files/hccm_openshift_usage_scheduled_report.yaml" rel="noopener ugc nofollow" target="_blank">不确定的每小时计划报告</a>，并选择最近10天的数据。根据数据量和查看数据请求所需的响应能力，您可以调整回看的天数。如果需要恢复数据或用于其他用途，您也可以使用相同的技术来提供开始和结束周期，而不是窗口数据。</p><h1 id="4373" class="lo lp iq bd lq lr mu lt lu lv mv lx ly lz mw mb mc md mx mf mg mh my mj mk ml bi translated">摘要</h1><p id="7739" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">希望这个故事已经告诉了你一个有用的新工具，<em class="lb">操作员计量，</em>，并给了你许多潜在用途的想法或你感兴趣收集的报告。我们讨论了<em class="lb">操作计量</em>及其组件的基础:数据源、报告生成和报告。接下来，我们看了如何组合来自多个数据源的数据，以及与大量数据和计划报告相关的一些缺点。最后，我们讨论了如何使用聚合和窗口数据来提取所需的数据，并限制从无限期计划的报告中访问细粒度数据。</p></div></div>    
</body>
</html>