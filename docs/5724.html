<html>
<head>
<title>Writing a Blockchain in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中编写区块链</h1>
<blockquote>原文：<a href="https://itnext.io/writing-a-blockchain-in-node-js-cd3e903226cf?source=collection_archive---------0-----------------------#2021-05-11">https://itnext.io/writing-a-blockchain-in-node-js-cd3e903226cf?source=collection_archive---------0-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e9e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始编写功能性区块链从未如此容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4fe3fabcb192e026b841cd1de8ae86fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASuBphIEauqwWpWFmY_6nA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thoughtcatalog" rel="noopener ugc nofollow" target="_blank">思想目录</a>上的<a class="ae ky" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="ec90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">区块链是目前计算机科学领域的热门话题。它在2008年因比特币加密货币而闻名，比特币加密货币(你可能知道)使用区块链将每笔交易记录到公共分布式账本中。但是……我们对区块链了解多少？我的意思是，如果我们想了解区块链是如何工作的，是什么让它如此强大？应该如何开始？让我们从基础开始吧！</p><h1 id="f740" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是区块链？</h1><p id="3c49" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">区块链的字面意思是区块链，其中区块是存储在公共数据库链中的一条信息。在JavaScript中，我们可以将块视为一个对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="439a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来分析上面的块:</p><ul class=""><li id="f911" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">时间戳:块创建的时间戳。</li><li id="1214" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">数据:包含在块中的数据。它可以是任何东西:对象、字符串、数字……我们通常将事务数据存储在块的这一部分中。</li><li id="db99" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">哈希:当前块哈希。表示块中包含的数据。如果我们编辑这个块中的任何内容，我们的散列将会改变。</li><li id="935a" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">previousHash:表示前一个块的哈希。</li></ul><p id="cc55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，等等，等等！上一个街区？是啊！事实上，区块链的关键特征是，链中的每个区块都必须包含代表前一个区块的数据。这样，如果您想要修改一个块，您必须重新计算整个链，这(我们将在后面看到)可能非常困难(如果不是不可能的话)。出于这个原因，我们可以说区块链是一个不可改变的结构。</p><blockquote class="ni nj nk"><p id="ec25" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">以后想看这个故事吗？将它保存在日志中。</p></blockquote><h1 id="c720" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建极简区块链</h1><p id="8eaa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">那么，我们如何开始写我们的区块链呢？首先，让我们定义一下区块链最重要的功能:计算区块散列的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="890c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，为了计算我们块的hash，我们需要四个参数:<code class="fe np nq nr ns b">previousHash</code>、<code class="fe np nq nr ns b">timestamp</code>、<code class="fe np nq nr ns b">data</code>和<code class="fe np nq nr ns b">nonce</code>。我们已经看到了前三个参数是什么，但是为什么我们需要一个nonce？出于安全考虑。我们不想让潜在的恶意开发者改变一个块的内容，然后重新计算整个链使其有效。出于这个原因，我们需要定义一些关于如何将散列格式化为有效的约束。</p><p id="879e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有以下块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="490c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的散列将在几毫秒内计算出来，看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，这有什么错呢？想象一下，我们有一台每秒钟能够执行数千次散列计算的超级计算机。重新计算整个链条需要多长时间？我们可以通过设置一些约束，让他的日子更难过。例如，我们可以决定一个散列只有在以四个0和四个9开始时才有效:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是散列依赖于块的内容…我们如何尊重这个约束呢？随机数来了！nonce是在我们的哈希计算过程中插入的一个随机值，它使我们更有可能得到一个格式良好的哈希。我们的哈希不尊重强加的规则？让我们用不同的随机数再计算一次。</p><p id="8dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们测试一些不同的约束，看看计算散列需要多长时间:</p><ul class=""><li id="54cf" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">哈希必须以两个零开头:<code class="fe np nq nr ns b">211ms</code></li><li id="ccea" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">哈希必须以三个零开头:<code class="fe np nq nr ns b">297ms</code></li><li id="8c51" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">哈希必须以五个零开头:<code class="fe np nq nr ns b">5966ms</code></li><li id="8004" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">哈希必须以<code class="fe np nq nr ns b">f5</code> : <code class="fe np nq nr ns b">174ms</code>开头</li><li id="d9e6" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">哈希必须以<code class="fe np nq nr ns b">0990</code> : <code class="fe np nq nr ns b">196ms</code>结尾</li><li id="bca6" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">哈希必须以<code class="fe np nq nr ns b">f918</code>结尾:<code class="fe np nq nr ns b">4436ms</code></li></ul><p id="28de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下，如果我们定义一个非常耗时的规则…如果计算一个块需要大约四个小时，那么计算(或“挖掘”)整个链需要多少时间？</p><h1 id="fdee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创世街区</h1><p id="4289" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">区块链的第一块被称为“创世块”。它不能有“前一个散列”值，所以编写一个生成它的函数非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！所以现在我们可以尝试运行<code class="fe np nq nr ns b">generateGenesisBlock</code>函数，让我们看看会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！</p><h1 id="026c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开采新区块</h1><p id="3fdf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们需要一个为区块链计算新区块的函数。但是首先，我们需要定义我们的散列约束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="61d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的函数(<code class="fe np nq nr ns b">checkDifficulty</code>)中，我们可以传递两个参数:<code class="fe np nq nr ns b">difficulty</code>和<code class="fe np nq nr ns b">hash</code>。我们希望事情超级简单，所以(对于那个实现)，我们决定我们的散列必须以4个零开始。如果传递的散列符合约束条件，则该函数返回<code class="fe np nq nr ns b">true</code>。否则将返回<code class="fe np nq nr ns b">false</code>，所以我们需要改变nonce再次计算它(如前所述)。</p><p id="0676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到了，为了保证更易测试和模块化的代码库，我们采用了函数式范例。因此，为了计算下一个nonce，我们需要一个函数来获取这个块并返回它的修改版本，包含一个新的nonce。我们想避免副作用，所以我们不会直接编辑我们的<code class="fe np nq nr ns b">nonce</code>值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="dd64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们正在返回<code class="fe np nq nr ns b">updateHash</code>的结果，它基本上接受了这个块，并返回一个带有新散列的新版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="821c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，我们需要一个递归函数来计算我们的块的散列，直到它遵守强加的约束。但这里就出现了一个问题:如何让JavaScript中的递归变得安全？谢天谢地，我写了一篇关于JavaScript中递归以及如何使其内存安全的文章。让我们实现一个蹦床(<a class="ae ky" href="https://medium.com/openmindonline/js-monday-06-adopting-memory-safe-recursion-d26dcee409c9" rel="noopener">在这里了解更多</a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是我们代码库中唯一不纯的部分，但是为了防止一些<a class="ae ky" href="https://medium.com/openmindonline/js-monday-06-adopting-memory-safe-recursion-d26dcee409c9" rel="noopener">内存相关的错误</a>，这是绝对必要的。</p><p id="35df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们把它们放在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bd9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要害怕！我们来分析一下上面的代码:</p><ul class=""><li id="413c" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">我们定义了一个新的函数，它将<code class="fe np nq nr ns b">difficulty</code>和<code class="fe np nq nr ns b">block</code>作为参数。<code class="fe np nq nr ns b">difficulty</code>只是一个数字，表示我们的哈希应该从多少个零开始，<code class="fe np nq nr ns b">block</code>只是我们想要挖掘的块。</li><li id="c3c2" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">我们定义一个函数<code class="fe np nq nr ns b">mine</code>，它将<code class="fe np nq nr ns b">block</code>作为参数。</li><li id="8888" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">在这个函数中，我们用一个新的nonce创建了一个新的块。</li><li id="e502" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">然后我们需要检查散列是否遵守我们的规则。如果是，让我们返回我们的<code class="fe np nq nr ns b">newBlock</code>块作为结果。否则，我们需要改变它的nonce并再次挖掘它。</li><li id="c3c8" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">现在我们有了<code class="fe np nq nr ns b">mine</code>函数，我们将它包装在<code class="fe np nq nr ns b">trampoline</code>中。它将递归地运行这个函数，直到我们为我们的块得到一个正确的散列。</li></ul><p id="399d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在需要最后一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe np nq nr ns b">addBlock</code>函数将整个链作为它的第一个参数，新的块数据作为它的第二个参数。然后，它挖掘新的块，并返回包含新创建的块的新链。</p><h1 id="e1cc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">验证链</h1><p id="9d3b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，我们已经做了很多工作！我们现在需要实现一个函数，在插入新块后验证整个链:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数非常简单明了:</p><ul class=""><li id="632a" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">我们创建一个新的函数，将整个链作为它的参数。</li><li id="d3db" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">我们定义了一个名为<code class="fe np nq nr ns b">tce</code>(代表<a class="ae ky" href="https://www.jsmonday.dev/articles/6/adopting-memory-safe-recursion" rel="noopener ugc nofollow" target="_blank">尾调用消除</a>)的新函数，它将链和块索引作为其参数。</li><li id="3401" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">如果我们正在查看我们的链的第一个索引(Genesis块)，我们将返回<code class="fe np nq nr ns b">true</code>。</li><li id="8c4b" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">否则，我们需要检查一些条件:当前块的散列是否有效？前一个块的哈希是否有效？那么链条有效吗(直到现在)？</li></ul><p id="fca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常简单，但却非常强大！</p><h1 id="f651" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">把所有东西放在一起</h1><p id="d691" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们终于准备好测试我们的区块链了！首先，我们来初始化一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="29e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建一个新的块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备开采这个新区块！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="da80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们记录新创建的链:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以向区块链添加任意多的块了！</p><h1 id="329a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一些考虑</h1><p id="3c41" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们刚刚建立了一个功能性的区块链，完全没有副作用。我们可以轻松地编写测试并获得100%的覆盖率，当我们想要编写一个可以处理大量数据的应用程序时，这是一件需要记住的重要事情。</p><p id="b39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用类而不是纯函数，使用for循环而不是递归可以带来更简单和更高的性能…但是我们并不太关心性能(我的意思是，我们花了几天时间来挖掘块，这些毫秒级的for循环性能真的很重要吗？)而且我们不希望它太简单:我们希望它是坚实的。函数式编程可以帮助你编写更可靠的代码，具有可重用的函数和优秀的测试。</p><h1 id="bcf2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">后续步骤</h1><p id="496e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们只是触及了区块链如何工作以及如何构建区块链的表面，还有很多工作要做！</p><ul class=""><li id="5398" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">尝试改进哈希约束。试着找到一个规则，使得挖掘一个新的区块变得困难。</li><li id="0010" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">Node.js和浏览器上没有实现尾调用递归(即使EcmaScript语言规范中有描述)。试着把<code class="fe np nq nr ns b">validateChain</code>里面的<code class="fe np nq nr ns b">tce</code>功能转换成蹦床！</li><li id="2a3d" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">我们说过，我们不希望我们的区块链中有可变的值。那么我们如何处理更新现有链的新块创建呢？</li></ul><h1 id="51c2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">「矿工」是怎么拿到钱的？</h1><p id="fdfe" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如你所见，开采新区块需要大量的时间，这可以转化为电能成本。出于这个原因，开采新区块的人可以在开采后获得“奖励”。钱就是这么来的！</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="72d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">📝把这个故事保存在<a class="ae ky" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank">杂志</a>上。</p></div></div>    
</body>
</html>