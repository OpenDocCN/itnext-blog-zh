<html>
<head>
<title>Goodbye Docker Desktop, Hello Minikube!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">再见Docker桌面，你好Minikube！</h1>
<blockquote>原文：<a href="https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469?source=collection_archive---------0-----------------------#2021-09-06">https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469?source=collection_archive---------0-----------------------#2021-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a85bd5cf643113cadee33fca281790e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWP9sVNTNn01xDlvGKNY0g.png"/></div></div></figure><p id="14d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用Docker桌面在Mac上启用Docker和Kubernetes已经有一段时间了。即使它疯狂的吞噬CPU和内存，让粉丝疯狂。随着“在你的脸上”弹出来迫使升级Docker和软件许可证的变化，是时候去别处寻找本地Kubernetes开发需求了。</p><p id="c6f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章只关注Mac。如果你已经在Linux上试过了，让我知道效果如何。</p><blockquote class="kw"><p id="62a5" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">你在苹果M1硅(ARM64)吗？跳转到帖子末尾，获取M1的具体说明。</p></blockquote><h1 id="2ccf" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">卸载Docker桌面</h1><p id="7676" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们先从移除Docker桌面开始。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9d4c" class="ms lh iq mo b gy mt mu l mv mw">brew uninstall docker</span></pre><p id="8a16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将不仅淘汰Docker，还会淘汰Hyperkit、Docker守护进程(允许构建映像)、Docker CLI(与守护进程交互)、Kubernetes集群和kubectl二进制文件(除非您单独部署了它们)。如果你没有使用家酿，然后卸载相应的工具。</p><p id="e194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把这些工具一件一件拿回来。</p><h1 id="4773" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">安装Hyperkit</h1><p id="f915" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">对于Mac上的本地Kubernetes集群，Hyperkit仍然是一个可行的选择。让我们安装它。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bad0" class="ms lh iq mo b gy mt mu l mv mw">brew install hyperkit</span></pre><p id="3162" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保它安装正确。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5ca0" class="ms lh iq mo b gy mt mu l mv mw">❯ hyperkit -v<br/>hyperkit: 0.20200908</span><span id="7e12" class="ms lh iq mo b gy na mu l mv mw">Homepage: <a class="ae nb" href="https://github.com/docker/hyperkit" rel="noopener ugc nofollow" target="_blank">https://github.com/docker/hyperkit</a><br/>License: BSD</span></pre><h1 id="1d54" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">安装Docker CLI</h1><p id="2c3c" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们想摆脱Docker桌面，但不是Docker本身。Docker仍然是一个有用的开源容器管理工具，如果你有一堆Docker文件要处理，Docker CLI会很有用。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c953" class="ms lh iq mo b gy mt mu l mv mw">brew install docker</span></pre><blockquote class="nc nd ne"><p id="e466" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated">注意:不要运行<code class="fe nj nk nl mo b">brew install --cask docker</code>。这将安装Docker桌面，我们将回到我们开始的地方！</p></blockquote><p id="8539" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将安装Docker CLI，但不会安装Docker守护程序(<code class="fe nj nk nl mo b">dockerd</code>)。你可以通过运行<code class="fe nj nk nl mo b">docker info</code>看到这一点。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c621" class="ms lh iq mo b gy mt mu l mv mw">❯ docker info<br/>Client:<br/> Context:    default<br/> Debug Mode: false</span><span id="04ed" class="ms lh iq mo b gy na mu l mv mw">Server:<br/>ERROR: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span></pre><h1 id="1eb2" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">安装Kubectl</h1><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="da82" class="ms lh iq mo b gy mt mu l mv mw">brew install kubectl</span></pre><p id="c088" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里没什么好说的。</p><h1 id="f554" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">安装Minikube(和Docker守护进程)</h1><p id="fe53" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">随着Hyperkit的部署，我们已经准备好部署Kubernetes集群，并在这个过程中获得一个Docker守护进程。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d286" class="ms lh iq mo b gy mt mu l mv mw">brew install minikube</span></pre><p id="eb03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们开始使用Kubernetes集群之前，需要了解一些有用的信息:</p><h2 id="eb23" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">使用什么驱动程序？</h2><p id="ca47" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">换句话说，我们是在虚拟机、容器中部署Kubernetes，还是直接部署裸机？根据操作系统的不同，这里有各种选项<a class="ae nb" href="https://minikube.sigs.k8s.io/docs/drivers/" rel="noopener ugc nofollow" target="_blank"/>。我们将使用Mac版的Hyperkit驱动程序(AMD64)和M1版的Podman驱动程序(见本文末尾)。</p><h2 id="14ae" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">使用什么容器运行时？</h2><p id="743e" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">可用选项——docker、containerd和CRI-o。Containerd是一个不错的选择，因为Kubernetes本身正在放弃Docker，转而支持container d。但是因为我们希望docker守护进程能够构建Docker映像，所以让我们使用Docker。</p><h2 id="48e5" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">设置CPU、内存限制</h2><p id="2925" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">就像Docker Desktop一样，设置正确的CPU和内存限制是明智的，尤其是如果您打算运行许多pods的话。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6259" class="ms lh iq mo b gy mt mu l mv mw">minikube config set cpus 6<br/>minikube config set memory 12g</span></pre><p id="d585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们开始Kubernetes集群。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="8f51" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube start --kubernetes-version=v1.19.14 --driver=hyperkit --container-runtime=docker</span></pre><p id="f03b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用标志<code class="fe nj nk nl mo b">--kubernetes-version</code>来部署特定的Kubernetes版本。放下标记，简单地部署最新版本。我根据需要部署了一个旧版本。</p><p id="0d41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是上述命令的输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4e8e" class="ms lh iq mo b gy mt mu l mv mw">😄  minikube v1.23.0 on Darwin 11.5.2<br/>    ▪ MINIKUBE_ACTIVE_DOCKERD=minikube<br/>✨  Using the hyperkit driver based on user configuration<br/>👍  Starting control plane node minikube in cluster minikube<br/>💾  Downloading Kubernetes v1.19.14 preload ...     <br/>    &gt; preloaded-images-k8s-v12-v1...: 470.78 MiB / 470.78 MiB  100.00% 6.17 MiB<br/>🔥  Creating hyperkit VM (CPUs=6, Memory=12288MB, Disk=20000MB) ...<br/>❗  This VM is having trouble accessing <a class="ae nb" href="https://k8s.gcr.io" rel="noopener ugc nofollow" target="_blank">https://k8s.gcr.io</a><br/>💡  To pull new external images, you may need to configure a proxy: <a class="ae nb" href="https://minikube.sigs.k8s.io/docs/reference/networking/proxy/" rel="noopener ugc nofollow" target="_blank">https://minikube.sigs.k8s.io/docs/reference/networking/proxy/</a><br/>🐳  Preparing Kubernetes v1.19.14 on Docker 20.10.8 ...<br/>    ▪ Generating certificates and keys ...<br/>    ▪ Booting up control plane ...<br/>    ▪ Configuring RBAC rules ...<br/>🔎  Verifying Kubernetes components...<br/>    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5<br/>🌟  Enabled addons: storage-provisioner, default-storageclass</span><span id="bd1f" class="ms lh iq mo b gy na mu l mv mw">❗  /usr/local/bin/kubectl is version 1.22.1, which may have incompatibilites with Kubernetes 1.19.14.<br/>    ▪ Want kubectl v1.19.14? Try 'minikube kubectl -- get pods -A'<br/>🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</span></pre><blockquote class="nc nd ne"><p id="8d31" class="jy jz nf ka b kb kc kd ke kf kg kh ki ng kk kl km nh ko kp kq ni ks kt ku kv ij bi translated">如果您在本地运行<code class="fe nj nk nl mo b">dnsmasq</code>,集群内的DNS解析可能会出现故障。你可以卸载它，也可以将<code class="fe nj nk nl mo b">listen-address=192.168.64.1</code>添加到<code class="fe nj nk nl mo b">dnsmasq.conf</code>中。更多信息可以在<a class="ae nb" href="https://minikube.sigs.k8s.io/docs/drivers/hyperkit/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><p id="f2ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">已经设置了上下文。我们可以用<code class="fe nj nk nl mo b">kubectl</code>检查集群，如下所示:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="95f9" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube kubectl get nodes<br/>NAME       STATUS   ROLES    AGE    VERSION<br/>minikube   Ready    master   7m6s   v1.19.14</span></pre><p id="b638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们已经部署了kubectl二进制文件，所以我们可以直接使用它。</p><p id="559a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们有了一个Kubernetes集群，当我们使用Docker驱动程序时，Docker守护进程也在运行。在使用守护进程之前，让我们设置环境变量。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9dad" class="ms lh iq mo b gy mt mu l mv mw">eval $(minikube docker-env)</span></pre><p id="ba1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们确认docker守护进程是可访问的。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bce7" class="ms lh iq mo b gy mt mu l mv mw">❯ docker info<br/>Client:<br/> Context:    default<br/> Debug Mode: false</span><span id="213e" class="ms lh iq mo b gy na mu l mv mw">Server:<br/> Containers: 14<br/>  Running: 14<br/>  Paused: 0<br/>  Stopped: 0<br/> Images: 10<br/> Server Version: 20.10.8<br/> Storage Driver: overlay2<br/>  Backing Filesystem: extfs<br/> ...</span></pre><p id="45b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是K9S的Minikube集群的样子。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/efd70a6ab05c87997ef542da7e750af2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4FCX7goEtekfksg9ZOGdA.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">新安装的Minikube集群的K9S快照</figcaption></figure><h1 id="a076" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">需要Docker作曲吗？</h1><p id="bbc1" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">使用以下命令安装Docker Compose:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ec88" class="ms lh iq mo b gy mt mu l mv mw">brew install docker-compose</span></pre><h1 id="250f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">在Minikube外部公开服务</h1><p id="dcea" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">对于本地开发，通常通过浏览器或CLI从笔记本电脑访问服务。端口转发始终是一个选项，但有时入口或负载平衡器是有用的。让我们看看他们如何与Minikube一起工作。</p><h2 id="760b" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">处理入口资源</h2><p id="76c2" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们有一个Kubernetes集群，可以在其中部署我们的应用程序。但是我们如何访问入口资源呢？Minikube有一个带插件的回答。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dbc1" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube addons enable ingress<br/>    ▪ Using image k8s.gcr.io/ingress-nginx/controller:v1.0.0-beta.3<br/>    ▪ Using image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0<br/>    ▪ Using image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0<br/>🔎  Verifying ingress addon...</span></pre><p id="a170" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将部署Nginx入口控制器。更重要的是，它会将Nginx服务部署为<code class="fe nj nk nl mo b">NodePort</code>，并将Minikube IP直接指向Ingress。先找到IP再说。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1f90" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube ip<br/>192.168.64.12</span></pre><p id="fde0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在端口80上调用上面的IP，应该会得到Nginx的响应。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ec29" class="ms lh iq mo b gy mt mu l mv mw">❯ curl <a class="ae nb" href="http://192.168.64.12" rel="noopener ugc nofollow" target="_blank">http://192.168.64.12</a><br/>&lt;html&gt;<br/>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br/>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="fd2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，Ingress在DNS上工作，它应该解析为Minikube IP。如果其中一个后端服务调用该DNS，除非明确配置，否则它将失败。又一个救星！</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9d8e" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube addons enable ingress-dns<br/>    ▪ Using image cryptexlabs/minikube-ingress-dns:0.3.0</span></pre><p id="0937" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在Kubernetes集群内的Minikube IP上启动一个DNS服务器。还需要自定义解析器来强制自定义TLD的DNS解析(如。测试，不要使用。本地)被重定向到上面启动的DNS服务器。Minikube Ingress DNS文档很好地解释了这一点。按照这里的步骤，您将拥有一个带有自定义DNS的工作入口设置。</p><h2 id="bd64" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">负载平衡器服务</h2><p id="f5f8" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">部署负载平衡器类型的服务并从主机访问它，就像在云中部署一样，这不是很好吗？多亏了<code class="fe nj nk nl mo b">metallb</code>插件，这很简单。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c7fa" class="ms lh iq mo b gy mt mu l mv mw">minikube addons enable metallb</span></pre><p id="ba6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将部署另外两个pod，它们负责为负载平衡器服务分配外部IP。否则，服务将永远拥有<code class="fe nj nk nl mo b">pending</code>外部IP。</p><p id="a321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用<code class="fe nj nk nl mo b">metallb</code>之前还有一个步骤。默认情况下，<code class="fe nj nk nl mo b">metallb</code>无法知道哪些IP范围可分配给负载平衡器服务。运行以下命令以提供一个范围。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="0e41" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube addons configure metallb<br/>-- Enter Load Balancer Start IP: 192.168.64.5<br/>-- Enter Load Balancer End IP: 192.168.64.15<br/>    ▪ Using image metallb/speaker:v0.9.6<br/>    ▪ Using image metallb/controller:v0.9.6<br/>✅  metallb was successfully configured</span></pre><p id="28e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据您的Minikube IP，分配包含Minikube IP的小范围IP。现在，每当您部署负载平衡器服务时，将分配此范围内的一个IP。</p><h1 id="3eb0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">其他问题</h1><h2 id="ee1a" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">登录到远程注册表</h2><p id="cc5c" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">你可能仍然有旧的<code class="fe nj nk nl mo b">~/.docker/config.json</code>，将<code class="fe nj nk nl mo b">credsStore</code>设置为<code class="fe nj nk nl mo b">osxkeychain</code>或<code class="fe nj nk nl mo b">desktop</code>。这在新的设置中不起作用。要解决这个问题，让我们安装Docker凭证助手。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="717a" class="ms lh iq mo b gy mt mu l mv mw">brew install docker-credential-helper</span></pre><p id="b9d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">凭证将像以前一样储存在MacOS钥匙串中。如果这不起作用，一个快速的解决方法是删除<code class="fe nj nk nl mo b">~/.docker/config.json</code>文件并再次登录注册中心。</p><h2 id="24f2" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">保留Docker映像和永久卷声明</h2><p id="e7b3" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><em class="nf">增加了2021年9月7日</em></p><p id="f167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker Desktop的一个优点是，您可以关闭Kubernetes集群，稍后再启动它，并使用相同的Docker映像和持久卷运行您的pods。例如，在Kubernetes中运行本地数据库时，这很有用。让持久卷在重启时可用是很方便的。</p><p id="15e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Minikube，如果我用<code class="fe nj nk nl mo b">minikube stop</code>关闭集群(和Hyperkit VM ),它会删除Docker映像和所有持久卷。真烦人。幸运的是，Minikube提供了一种防止删除的方法。我们可以<em class="nf">暂停</em>它，而不是停止Kubernetes集群和Hyperkit虚拟机。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="492a" class="ms lh iq mo b gy mt mu l mv mw">minikube pause</span></pre><p id="36ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令终止Kubernetes集群，但不删除Hyperkit虚拟机。这释放了更多的CPU，同时仍然保留所有Docker映像和持久卷。但是等等，还有更好的！它不会停止docker守护程序。所以你可以继续使用Docker CLI，只是别忘了用<code class="fe nj nk nl mo b">eval $(minikube docker-env)</code>设置Docker环境。</p><p id="7d9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您想继续在Kubernetes集群上工作时，运行以下命令:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="5130" class="ms lh iq mo b gy mt mu l mv mw">minikube unpause</span></pre><p id="b988" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你将会得到所有的系统舱，包括插件。这甚至适用于笔记本电脑重启！</p><h2 id="7d92" class="ms lh iq bd li nm nn dn lm no np dp lq kj nq nr lu kn ns nt ly kr nu nv mc nw bi translated">码头集装箱装订线</h2><p id="c665" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><em class="nf">增加了2021年9月7日</em></p><p id="065e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Reddit 的好朋友指出，Docker容器中的绑定挂载<code class="fe nj nk nl mo b">(-v)</code>在Minikube和Docker设置中不能开箱即用。这是Docker容器的常见操作，应该可以正常工作。</p><p id="47b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于使用了中间Hyperkit虚拟机，因此安装卷需要两步操作。首先，让我们将笔记本电脑上的磁盘挂载到Hyperkit VM。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="241f" class="ms lh iq mo b gy mt mu l mv mw">minikube mount /myvolume:/test</span></pre><p id="2935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在Hyperkit VM中的路径<code class="fe nj nk nl mo b">/test</code>处挂载本地文件夹<code class="fe nj nk nl mo b">/myvolume</code>。该进程仍处于活动状态，因此您应该不去管这个终端。</p><p id="b4fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个终端中，运行Docker容器并将<code class="fe nj nk nl mo b">/test</code>卷绑定到容器中的一个路径。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7fff" class="ms lh iq mo b gy mt mu l mv mw">docker run --rm -it -v /test:/inside busybox /bin/sh</span></pre><p id="2c00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将把<code class="fe nj nk nl mo b">/test</code>卷挂载到Hyperkit VM容器内的路径<code class="fe nj nk nl mo b">/inside</code>上。实际上，这使得容器内笔记本电脑上<code class="fe nj nk nl mo b">/myvolume</code>下的所有文件和文件夹都处于读写模式。太棒了。</p><h1 id="d742" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">苹果硅M1怎么样？</h1><p id="9cf1" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><em class="nf">增加了2022年2月5日</em></p><p id="780c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上个月，我终于买到了苹果M1！从那时起，我一直试图找出一种不使用Docker桌面运行Minikube的方法…直到现在:)</p><p id="2e22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于ARM64的苹果M1面临一些挑战。出乎意料的是，Hyperkit对M1不起作用，而且<a class="ae nb" href="https://github.com/moby/hyperkit/issues/310#issuecomment-1003707160" rel="noopener ugc nofollow" target="_blank">可能永远也不会对</a>起作用。我们需要一个替代工具来创建虚拟机。波德曼出场。</p><p id="650e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据他们的<a class="ae nb" href="https://podman.io" rel="noopener ugc nofollow" target="_blank">网站</a>，波德曼是Docker的直接替代者。字面<code class="fe nj nk nl mo b">alias docker=podman</code>。令人兴奋的消息是，波德曼增加了对苹果M1公司的支持！我们将使用Podman machine(与docker machine相似)特性使我们自己成为一个虚拟机。在引擎盖下，波德曼和Docker Desktop都使用QEMU施展他们的魔法。</p><p id="fd53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先装波德曼。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="87e0" class="ms lh iq mo b gy mt mu l mv mw">brew install podman</span></pre><p id="4cc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建具有所需规格的虚拟机。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e8af" class="ms lh iq mo b gy mt mu l mv mw">❯ podman machine init --cpus 6 --memory 12288 --disk-size 50 --image-path next<br/>Downloading VM image: fedora-coreos-35.20220131.1.0-qemu.aarch64.qcow2.xz: done<br/>Extracting compressed file</span><span id="30ba" class="ms lh iq mo b gy na mu l mv mw">❯ podman machine start<br/>INFO[0000] waiting for clients...<br/>INFO[0000] listening tcp://127.0.0.1:7777<br/>INFO[0000] new connection from  to /var/folders/2x/wz0vrff903q0p3lpn959b8zw0000gn/T/podman/qemu_podman-machine-default.sock<br/>Waiting for VM ...<br/>Machine "podman-machine-default" started successfully</span></pre><p id="ed1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Podman服务的根目的地需要一个小的调整，以使其与Minikube一起工作。如果没有这个调整，Minikube将失败，并显示“错误:请求的cgroup控制器“cpu”不可用:OCI运行时错误”。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4823" class="ms lh iq mo b gy mt mu l mv mw">❯ podman system connection default podman-machine-default-root</span><span id="7e30" class="ms lh iq mo b gy na mu l mv mw">❯ podman system connection list<br/>Name                          Identity                                          URI<br/>podman-machine-default        /Users/x/.ssh/podman-machine-default  ssh://core@localhost:57623/run/user/1000/podman/podman.sock<br/>podman-machine-default-root*  /Users/x/.ssh/podman-machine-default  ssh://root@localhost:57623/run/podman/podman.sock</span></pre><p id="9822" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">波德曼准备好了。下一步是使用Podman驱动程序启动Minikube集群。只需运行下面的命令。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="bcb3" class="ms lh iq mo b gy mt mu l mv mw">❯ minikube start --kubernetes-version=v1.22.5 --driver=podman --container-runtime=cri-o -p minipod<br/>😄  minikube v1.28.0 on Darwin 12.6.1 (arm64)<br/>🆕  Kubernetes 1.25.3 is now available. If you would like to upgrade, specify: --kubernetes-version=v1.25.3<br/>✨  Using the podman (experimental) driver based on existing profile<br/>👍  Starting control plane node minikube in cluster minikube<br/>🚜  Pulling base image ...<br/>E1218 00:06:49.506418   69295 cache.go:203] Error downloading kic artifacts:  not yet implemented, see issue #8426<br/>🔄  Restarting existing podman container for "minikube" ...<br/>🎁  Preparing Kubernetes v1.22.5 on CRI-O 1.24.3 ...<br/>E1218 00:06:57.412980   69295 start.go:130] Unable to get host IP: RoutableHostIPFromInside is currently only implemented for linux<br/>🔗  Configuring CNI (Container Networking Interface) ...<br/>🔎  Verifying Kubernetes components...<br/>    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5<br/>🌟  Enabled addons: storage-provisioner, default-storageclass</span><span id="8a82" class="ms lh iq mo b gy na mu l mv mw">🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</span></pre><p id="3f3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们就有了一个运行在苹果M1上的Minikube集群，而不需要Docker桌面！</p><h1 id="b763" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">结论</h1><p id="b6b8" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在一个周日下午花了几个小时后，我对这里的布置很满意。我们去掉了Docker Desktop，代之以Hyperkit(M1的Podman)和Minikube。我们仍然可以使用Docker API在本地Kubernetes集群中管理Docker文件和部署应用程序。最重要的是，笔记本电脑正在愉快地运行，额外的资源可以被Slack、Notion和其他电子应用程序使用；-)</p><h1 id="fdda" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr mx lt lu lv my lx ly lz mz mb mc md bi translated">资源</h1><ol class=""><li id="8d2d" class="oc od iq ka b kb me kf mf kj oe kn of kr og kv oh oi oj ok bi translated"><a class="ae nb" href="https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r" rel="noopener ugc nofollow" target="_blank">容器运行时简介</a></li><li id="797f" class="oc od iq ka b kb ol kf om kj on kn oo kr op kv oh oi oj ok bi translated"><a class="ae nb" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> Minikube文档</a></li><li id="45f1" class="oc od iq ka b kb ol kf om kj on kn oo kr op kv oh oi oj ok bi translated"><a class="ae nb" href="https://docs.podman.io/en/latest/" rel="noopener ugc nofollow" target="_blank">波德曼文档</a></li></ol></div></div>    
</body>
</html>