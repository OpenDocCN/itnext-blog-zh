<html>
<head>
<title>Azure Container Apps: Review and Practical Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure容器应用:回顾和实例</h1>
<blockquote>原文：<a href="https://itnext.io/azure-container-apps-review-and-practical-examples-cd58757bac34?source=collection_archive---------0-----------------------#2021-11-29">https://itnext.io/azure-container-apps-review-and-practical-examples-cd58757bac34?source=collection_archive---------0-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/186a336f7bf6e6b3f2fdfe64dad4dc59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebZDQ3Ad_8WgDfh-QjivRA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@carrier_lost?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="a94f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无服务器微服务</p><h2 id="5a8c" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">介绍</h2><p id="6f95" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Container Apps是Azure新推出的无服务器产品。截至本文发表时，它仍在预览中。</p><p id="2e0a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个产品之所以有趣，是因为它填补了无服务器和成熟的Kubernetes设置之间的空白。传统上，对于微服务类型的工作负载，可以使用无服务器或Kubernetes。</p><p id="7056" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不理想，因为无服务器更适合事件驱动的架构，而Kubernetes很复杂，需要专业知识来运行生产级工作负载。</p><p id="604a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">微服务架构将复杂性从程序内部转移到周围的基础设施。</p><p id="bc5b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个解决方案是使用<a class="ae jd" href="https://azure.microsoft.com/en-us/services/container-instances/" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>。这是一个很好的服务，但是它的级别相对较低，在使用多个容器组的情况下不能很好地工作，尤其是当它们需要相互通信的时候。</p><blockquote class="lz ma mb"><p id="4e7b" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="jg">你可以阅读更多关于Azure容器实例我的其他博客，</em> <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/easily-deploy-containers-to-azure-directly-from-your-desktop-16efebc87b21"> <em class="jg">轻松从你的桌面直接部署容器到Azure</em></a><em class="jg">【Azure解释够深:容器】(Azure解释够深:容器)。</em></p></blockquote><p id="9392" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探索Azure Container Apps如何帮助基于微服务的架构。如果你是在Azure上设计软件的开发人员或软件架构师，这应该是一篇有趣的文章。</p><h2 id="66a3" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">有什么好处？</h2><p id="884e" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对于基于微服务的架构，容器应用是无服务器和AKS之间缺少的环节。</p><p id="d7c5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是通过利用开源项目来提供微服务中常见的标准化功能来实现的，例如:</p><ul class=""><li id="65bd" class="mg mh jg kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">自动缩放</li><li id="29bc" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">机密和配置管理</li><li id="5cb1" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">版本控制</li><li id="093f" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">高级部署功能，例如蓝绿色部署或A/B测试</li><li id="94fb" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">修订版之间的流量分割</li><li id="14c5" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">背景，长期运行的服务</li></ul><p id="e2a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是支持容器应用的开源项目:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/9fb9aa167a368219aaea997efc8699fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ta_euagZNqaKbtSX"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">容器应用程序开源组件</figcaption></figure><p id="6fc7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在引擎盖下，容器应用程序运行在AKS集群上，具有自以为是的设置。该产品遵循利用Kubernetes的最佳实践之一:</p><blockquote class="lz ma mb"><p id="405f" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="jg"> Kubernetes是一个搭建平台的平台</em></p></blockquote><p id="5150" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://dapr.io/" rel="noopener ugc nofollow" target="_blank"> DAPR </a>为基于微服务的架构提供平台和语言无关的构建模块。</p><p id="4062" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank"> KEDA </a>提供无缝的事件驱动自动缩放功能。</p><p id="4333" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<a class="ae jd" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>负责隐藏Kubernetes复杂性的入口和路由。</p><h2 id="e220" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">何时使用容器应用程序</h2><p id="2561" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这种服务最适合已经装箱的微型服务。一个不太复杂的系统，不需要直接访问Kubernetes原语，也不需要纯粹由事件驱动的业务逻辑。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="97a0" class="ng lc jg bd ld nh ni nj lg nk nl nm lj nn no np lm nq nr ns lp nt nu nv ls nw bi translated">演示场景</h1><p id="4c1a" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果你想一起练习，我已经用devcontainer 创建了一个repo，涵盖了两个不同的场景。位于文件夹<code class="fe nx ny nz oa b">1.Hello-World</code>中的第一个场景将部署一个示例“hello world”web应用程序，并将端点公开为内部入口。第二个场景使用<a class="ae jd" href="https://docs.microsoft.com/EN-US/azure/azure-resource-manager/bicep/" rel="noopener ugc nofollow" target="_blank"> bicep </a>来部署额外的配置，并展示容器应用程序中秘密的使用。</p><h2 id="0bd2" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">先决条件</h2><p id="349d" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有几个先决条件:</p><ul class=""><li id="a623" class="mg mh jg kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">VS代码</li><li id="13d2" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">Azure订阅</li><li id="19fc" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">在您的机器上运行的Docker主机</li></ul><ol class=""><li id="3424" class="mg mh jg kf b kg kh kk kl ko mi ks mj kw mk la ob mm mn mo bi translated">克隆存储库:<a class="ae jd" href="https://github.com/Piotr1215/azure-container-apps" rel="noopener ugc nofollow" target="_blank">https://github.com/Piotr1215/azure-container-apps</a></li><li id="e698" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ob mm mn mo bi translated">VS代码应该提示您在devcontainer中重新打开repo</li></ol><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/9d19313dacf735adf331bbeaa34b9948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z7GCH0A03cxH2gP7.png"/></div></div></figure><p id="721e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果提示没有出现，您可以使用F1或Ctrl+Shift+P并选择<em class="mc">在容器中重新打开</em>。</p><p id="d632" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要执行<a class="ae jd" href="https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli" rel="noopener ugc nofollow" target="_blank"> az登录</a>。默认情况下，az登录命令将打开一个浏览器，通过Azure订阅进行安全认证。</p><h1 id="6944" class="ng lc jg bd ld nh od nj lg nk oe nm lj nn of np lm nq og ns lp nt oh nv ls nw bi translated">你好世界</h1><p id="72f5" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">从这个例子开始，导航到<code class="fe nx ny nz oa b">1.Hello-World</code>目录并运行<code class="fe nx ny nz oa b">setup.sh</code>。</p><p id="3488" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">系统将提示您为脚本提供一些变量。默认值是预先填充的。如果你想使用默认值，只需点击回车。</p><blockquote class="lz ma mb"><p id="2d55" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="jg">目前，Container Apps服务仅在</em>北欧<em class="jg">和</em>加拿大中部<em class="jg">地区可用。</em></p></blockquote><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/17374f805700bcd7fc95a5f73f780f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P5ZBlXQU8K2beTdD.png"/></div></div></figure><p id="8d53" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本将执行以下操作:</p><ul class=""><li id="7680" class="mg mh jg kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">安装容器应用az扩展</li><li id="e85c" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">创建资源组</li><li id="ac09" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">创建容器应用程序环境</li><li id="4a1d" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">创建容器应用程序</li><li id="b3e2" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">将hello world容器部署到容器应用程序</li><li id="6a56" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">显示您可以实时查看web应用程序的URL</li><li id="526c" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">提供清理资源的说明</li></ul><p id="2c83" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脚本完成后，将显示一个运行web应用程序的URL，以及一个删除环境的命令。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/12eb7d3967bf5f2e3d64396378724b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fgio7Legz1_211Io.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">脚本输出</figcaption></figure><p id="c2e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">URL应该显示一个正在运行的hello world应用程序:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/83c747d47186ed9d6529bed1d62e317c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*idayAKqpJcz4NKPV.png"/></div></div></figure><p id="b98f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">容器应用与Azure Monitor observability完全集成。导航到Azure门户并找到资源组</p><blockquote class="lz ma mb"><p id="72d4" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="jg">如果您接受默认值，将会是</em> rg-app-container-test</p></blockquote><p id="2863" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们可以执行一个简单的查询，从示例应用程序中读取stdin日志:</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/b672c5ff379ce1abe5bf7f4687c1a85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aGp2Szo7dmSdVWwu.png"/></div></div></figure><pre class="mv mw mx my gt om oa on oo aw op bi"><span id="a4c8" class="lb lc jg oa b gy oq or l os ot">ContainerAppConsoleLogs_CL<br/>| where ContainerAppName_s == 'my-container-app'<br/>| project ContainerAppName_s, ContainerImage_s, format_datetime(TimeGenerated, "hh:mm:ss"), RevisionName_s, EnvironmentName_s, Log_s</span></pre><h1 id="e3b7" class="ng lc jg bd ld nh od nj lg nk oe nm lj nn of np lm nq og ns lp nt oh nv ls nw bi translated">带二头肌的国营商店</h1><p id="617c" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">从这个例子开始，导航到<code class="fe nx ny nz oa b">2.Bicep-Deploy</code>目录并运行<code class="fe nx ny nz oa b">setup.sh</code>。</p><blockquote class="lz ma mb"><p id="cb5b" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="jg"> Bicep超出了本文的范围，但是如果您感兴趣，值得指出的是，它与az CLI一起创建了IaC的</em>命令式<em class="jg">和</em>声明式<em class="jg">风格的良好组合。</em></p></blockquote><p id="6101" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本将把以下基础设施部署到Azure:</p><ul class=""><li id="a527" class="mg mh jg kf b kg kh kk kl ko mi ks mj kw mk la ml mm mn mo bi translated">创建资源组</li><li id="fb33" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">创建容器应用程序环境</li><li id="53bb" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">创建容器应用程序</li><li id="c781" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">使用名为“测试容器”的默认容器创建一个存储帐户</li><li id="8327" class="mg mh jg kf b kg mp kk mq ko mr ks ms kw mt la ml mm mn mo bi translated">部署一个简单的Go API容器(<a class="ae jd" href="https://github.com/Piotr1215/go-sample-azure-storage" rel="noopener ugc nofollow" target="_blank"> Github </a>，<a class="ae jd" href="https://hub.docker.com/repository/docker/piotrzan/go-sample-azure-storage" rel="noopener ugc nofollow" target="_blank"> Docker </a>)来与存储帐户进行交互</li></ul><p id="c6ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出容器应用程序的URL的脚本。您可以使用Ctrl +单击导航到它。过一会儿，您应该会看到一条消息，提示示例blob文件已创建。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/65ba9a8afeba76ec3ead9223da604f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*hDN3uOljPKTODila.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">API消息</figcaption></figure><p id="a21e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转到Azure资源组(默认为rg-test-containerapps)并检查测试容器中的blobs。您应该看到至少两个文件。刷新URL将生成额外的文件。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ov"><img src="../Images/dd337e5b23997d6296ac30d15677998b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_ZTqMIhm0OAFYwvJ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">API创建的Blobs</figcaption></figure><p id="9d70" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试API使用Go fmt库将日志写入stdout，您可以在Azure Monitor工作区中看到自定义日志。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ow"><img src="../Images/145ccae7e612c6619a82655e6a453bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zy0FxO8FoVNy_kp2.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">API自定义日志</figcaption></figure><pre class="mv mw mx my gt om oa on oo aw op bi"><span id="c45d" class="lb lc jg oa b gy oq or l os ot">ContainerAppConsoleLogs_CL<br/>| where ContainerAppName_s == 'sample-app'<br/>| project ContainerAppName_s, ContainerImage_s, format_datetime(TimeGenerated, "hh:mm:ss"), RevisionName_s, EnvironmentName_s, Log_s</span></pre><h2 id="276b" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">那么它是如何工作的呢？</h2><p id="e838" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果仔细观察bicep模板，可以看到它定义了一个带有配置和秘密引用的envVar数组。如果你熟悉Kubernetes，这就是在pod规范中引用秘密的方式。记住bicep只是ARM JSON的超集，所以它拥有容器App API公开的所有字段。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ox"><img src="../Images/32559a5aef636eb9ff372ff806f166ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0eVKQP2VuyRaS9S2.png"/></div></div></figure><p id="13cd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个秘密在运行时向容器公开，所以只要您在API中使用相同的环境变量，您就应该能够以相同的方式与存储帐户进行交互。</p><p id="ab1b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的好处是，存储帐户密钥永远不会被共享、存储在源代码存储库中或嵌入到映像中。</p><h2 id="46f3" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">清除</h2><p id="9281" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">要销毁资源组和其中的所有服务，运行<code class="fe nx ny nz oa b">destroy.sh</code></p><h1 id="f4ba" class="ng lc jg bd ld nh od nj lg nk oe nm lj nn of np lm nq og ns lp nt oh nv ls nw bi translated">摘要</h1><p id="42a1" class="pw-post-body-paragraph kd ke jg kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">容器应用程序提供了更多的功能，但是我想把重点放在一个相对简单的用例上，希望有助于演示一个非常常见的开发任务，比如在运行时注入连接字符串。</p><p id="1ca7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就我个人而言，这是我一直在等待的一项服务。对我来说，它对于中等复杂的微服务设置来说足够强大，并提供足够的旋钮和开关来配置甚至要求非常高的工作流。</p><p id="f9bf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还没有谈到DAPR、KEDA或其他更高级的用例。如果你有兴趣查看文档。</p></div></div>    
</body>
</html>