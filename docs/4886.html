<html>
<head>
<title>The Ultimate Guide To Java 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 15终极指南</h1>
<blockquote>原文：<a href="https://itnext.io/the-definitive-guide-to-java-15-d976a4111f00?source=collection_archive---------1-----------------------#2020-10-16">https://itnext.io/the-definitive-guide-to-java-15-d976a4111f00?source=collection_archive---------1-----------------------#2020-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d98f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">全面介绍Java 14和Java 15中最有效的更新</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6fb043dd7969404125b902b6811f6a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HpL6ELMbjmHPU-R8"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">米歇尔·勒恩斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="8839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着Java SE 8于2014年3月18日发布，Java成为当今世界上应用最广泛的编程语言之一，在主要应用程序中占了60%的使用量。</p><p id="fbdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java 14和Java 15分别于2020年3月17日和9月15日发布，为开发者增加了更多功能。</p><p id="177f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们对每个版本的主要JEP (Java增强建议)有一个概述。</p><p id="8145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Java 14 </strong>:实例的模式匹配<em class="ls"> </em> ( <a class="ae kv" href="https://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank"> JEP 305 </a>)、有用的NullPointerExceptions(<a class="ae kv" href="https://openjdk.java.net/jeps/358" rel="noopener ugc nofollow" target="_blank">JEP 358</a>)、记录(<a class="ae kv" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank"> JEP 359 </a>)、开关表达式(<a class="ae kv" href="https://openjdk.java.net/jeps/361" rel="noopener ugc nofollow" target="_blank"> JEP 361 </a>)、文本块(<a class="ae kv" href="https://openjdk.java.net/jeps/368" rel="noopener ugc nofollow" target="_blank"> JEP 368 【T17)</a></p><p id="2f02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Java 15: </strong>密封类或接口(<a class="ae kv" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank"> JEP 360 </a>)</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c0ab" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Java 14</h1><h2 id="a205" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">实例的模式匹配</h2><p id="e796" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">每个Java程序员都应该知道用来定义块的<em class="ls">实例的旧语法。它预见了三个主要步骤:测试、新变量声明和转换(将obj转换为String)</em></p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7632" class="ms mb iq nk b gy no np l nq nr">if (obj instanceof String) {<br/>    String s = (String) obj;<br/>    // use s<br/>}</span></pre><p id="860a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">istanceof操作符现在扩展为接受类型测试模式，而不仅仅是类型。在下面的例子中，<em class="ls"> YourClass y </em>是类型测试模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4161" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所注意到的，新的instanceof操作符允许您在一个步骤中测试、声明和转换变量。显然，您可以马上使用新声明的变量！</p><p id="e13a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种语法也简化了方法的实现。仔细看看上面代码片段中的<em class="ls"> equals() </em>和<em class="ls"> multiply() </em>方法。</p><h2 id="4b1d" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">有用的NullPointerExceptions</h2><p id="f133" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">当程序试图取消引用一个空引用时，JVM抛出一个NPE。基本上，这个增强希望通过精确描述哪个变量为空来提高JVM生成的NPE的可用性。现在，考虑我们有下面的赋值表达式:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="2f01" class="ms mb iq nk b gy no np l nq nr">a.i = 99</span></pre><p id="eab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…并认为<em class="ls"> a </em>为空。该执行将导致JVM打印出导致NPE的方法、文件名和行号。</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="bca3" class="ms mb iq nk b gy no np l nq nr">Exception in thread "main" java.lang.NullPointerException<br/>    at Program.main(Program.java:5)</span></pre><p id="d0c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着Java 14和JEP 358的发布，消息将是:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="618d" class="ms mb iq nk b gy no np l nq nr">Exception in thread "main" java.lang.NullPointerException: <br/>        Cannot assign field "i" because "a" is null<br/>    at Program.main(Program.java:5)</span></pre><p id="cfc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在更复杂的陈述中:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="f4ed" class="ms mb iq nk b gy no np l nq nr">a.b.c.i = 99</span><span id="944c" class="ms mb iq nk b gy nu np l nq nr">Exception in thread "main" java.lang.NullPointerException: <br/>        Cannot read field "c" because "a.b" is null<br/>    at Program.main(Program.java:5)</span></pre><h2 id="8850" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">记录</h2><p id="c50a" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">大家都知道Java真的太啰嗦了。在我看来，记录是有史以来最好的增强之一，特别是对于那些仅仅是数据集合者或载体的类，它们获得了仅仅由名称和状态表示的极端简洁的级别。国家宣布记录的组成部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7059" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记录将隐含地定义:</p><ul class=""><li id="2d6a" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">状态描述的每个组成部分的私有最终字段</li><li id="2ae0" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">状态描述的每个组件的公共读取访问器方法</li><li id="9fcc" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">具有状态描述的相同签名的公共构造函数</li><li id="7102" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">equals()、hashCode()和toString()方法的实现</li></ul><p id="f360" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哪些是对记录的限制？</p><ul class=""><li id="2be3" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">记录不能扩展任何其他类</li><li id="916c" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">除了状态描述中的最终字段，记录不能声明实例字段</li><li id="cbac" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">任何其他声明的字段必须是静态的</li><li id="8028" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">记录是最终的(它不能被其他类或记录扩展)并且不能是抽象的</li></ul><p id="66ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，谈到注释:如果它们适用于记录组件、参数、字段或方法，那么它们可以用在记录组件上。</p><h2 id="35e2" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">切换表达式</h2><p id="cce6" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">一般来说，switch块允许应用程序根据运行时表达式的结果拥有多个可能的执行路径。</p><p id="254a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Java 14中，switch表达式得到了扩展，引入了许多有趣的新特性。</p><p id="3290" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们只记下用来定义块表达式的旧方法:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="ecb0" class="ms mb iq nk b gy no np l nq nr">switch(<strong class="nk ir"><em class="ls">expression</em></strong>) {<br/>  case <strong class="nk ir">a</strong>:<br/>    <em class="ls">// code block</em><br/>    break;<br/>  case <strong class="nk ir">b</strong>:<br/>    <em class="ls">// code block</em><br/>    break;<br/>  default:<br/>    <em class="ls">// code block</em><br/>}</span></pre><p id="3cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JEP 361中，引入了一种新形式的交换机标签:“case a -&gt;”。这意味着如果标签匹配，则只执行标签右边的代码。</p><p id="884f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先前代码片段的新版本变成了</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="8df5" class="ms mb iq nk b gy no np l nq nr">switch(<strong class="nk ir"><em class="ls">expression</em></strong>) {<br/>  case <strong class="nk ir">a </strong>-&gt; // code<br/>  case <strong class="nk ir">b </strong>-&gt; // code<br/>  default -&gt; // code<br/>}</span></pre><p id="031d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，switch语句已被扩展，因此可以用作表达式。在最普通的形式中，开关表达式看起来像:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="b6a2" class="ms mb iq nk b gy no np l nq nr">T result = switch(expression) {<br/>  case label1 -&gt; expression1;<br/>  case label2 -&gt; expression2;<br/>  default -&gt; expression3;<br/>}</span></pre><p id="3d6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">产生一个值</strong></p><p id="809d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当需要一个完整的块而不是单行表达式时，就会引入一个新的关键字<strong class="ky ir"> yield </strong>来产生一个值。前面的语句变成了:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="e234" class="ms mb iq nk b gy no np l nq nr">T result = switch(<strong class="nk ir"><em class="ls">expr</em></strong>) {<br/>  case label1 -&gt; expression1;<br/>  case label2 -&gt; expression2;<br/>  default -&gt; {<br/>    expression3;<br/>    expression4;<br/>    <strong class="nk ir"><em class="ls">yield </em></strong>result;</span><span id="4f46" class="ms mb iq nk b gy nu np l nq nr">}</span></pre><p id="b0ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">牢记以下条款非常重要:</p><blockquote class="oj ok ol"><p id="f36b" class="kw kx ls ky b kz la jr lb lc ld ju le om lg lh li on lk ll lm oo lo lp lq lr ij bi translated"><em class="iq">这两个语句中，</em> <code class="fe op oq or nk b"><em class="iq">break</em></code> <em class="iq">(带或不带标签)和</em> <code class="fe op oq or nk b"><em class="iq">yield</em></code> <em class="iq">，便于</em> <code class="fe op oq or nk b"><em class="iq">switch</em></code> <em class="iq">语句和</em> <code class="fe op oq or nk b"><em class="iq">switch</em></code> <em class="iq">表达式之间容易产生歧义:一个</em> <code class="fe op oq or nk b"><em class="iq">switch</em></code> <em class="iq">语句而不是一个</em> <code class="fe op oq or nk b"><em class="iq">switch</em></code> <em class="iq">表达式可以是一个</em> <code class="fe op oq or nk b"><em class="iq">break</em></code> <em class="iq">语句的目标；并且一个</em> <code class="fe op oq or nk b"><em class="iq">switch</em></code> <em class="iq">表达式而不是一个</em> <code class="fe op oq or nk b"><em class="iq">switch</em></code> <em class="iq">语句可以成为一个</em> <code class="fe op oq or nk b"><em class="iq">yield</em></code> <em class="iq">语句的目标。</em></p></blockquote><p id="1126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着yield关键字仅用于从完整的块代码中返回值；必须赋给变量的结果。</p><p id="9dfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，在最后，我想报告另一个新特性switch语句的例子，它被用作<code class="fe op oq or nk b">syso call</code>中的表达式:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="f42b" class="ms mb iq nk b gy no np l nq nr">static void isEven(int k) {<br/>    int e = k % 2;<br/>    System.out.println(<br/>        switch (e) {<br/>            case  0 -&gt; true;<br/>            case  1 -&gt; false;<br/>            default -&gt; "WTF";<br/>        }<br/>    );<br/>}</span></pre><h2 id="5feb" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">文本块</h2><p id="a14b" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">欢迎，文字块！从现在开始，开发人员可以定义跨越几行源代码(例如HTML、SQL查询)的字符串，避免转义序列，从而增强可读性，比如Python中的。下面是一个例子:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="1eca" class="ms mb iq nk b gy no np l nq nr">String query = """<br/>               SELECT `PERSON_ID`, `NAME` FROM `PERSONS`<br/>               WHERE `AGE` &gt; 35<br/>               ORDER BY `PERSON_ID`, `NAME`;<br/>               """;</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3d37" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Java 15</h1><h2 id="4588" class="ms mb iq bd mc mt mu dn mg mv mw dp mk lf mx my mm lj mz na mo ln nb nc mq nd bi translated">密封的类或接口</h2><p id="f892" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">密封类(或接口)是JEP 360在Java 15中引入的一个有趣特性。显然，继承的目的不仅仅是重用代码，甚至是对领域中存在的各种可能性进行建模。</p><p id="3812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">密封的类或接口通过关键字<em class="ls">permit</em>限制了其他类或接口可以扩展或实现它们的集合。</p><p id="8cc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，我们可以决定定义一个抽象类<em class="ls">动物</em>，并用<em class="ls">爬行动物</em>和<em class="ls">两栖动物</em>来对领域建模，如下面的代码片段<em class="ls">。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="678e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢阅读这篇文章！</p><p id="f97b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你，❤</p><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/springboot-liquibase-and-mariadb-b3f943c29370"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">SpringBoot，Liquibase和MariaDB</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">用SpringBoot中的Liquibase管理MariaDB数据库</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">itnext.io</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/dockerize-a-springboot-app-1755e49fe3d9"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">将SpringBoot应用程序归档</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">让我们从docker图像和容器开始，让我们展示如何将SpringBoot应用程序Docker化并上传到docker…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">itnext.io</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj kp ov"/></div></div></a></div></div></div>    
</body>
</html>