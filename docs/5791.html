<html>
<head>
<title>Animated List Reordering in React Native — Secrets Revealed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native中的动画列表重新排序——揭秘</h1>
<blockquote>原文：<a href="https://itnext.io/animated-list-reordering-in-react-native-secrets-revealed-3192cc33fe4f?source=collection_archive---------3-----------------------#2021-05-26">https://itnext.io/animated-list-reordering-in-react-native-secrets-revealed-3192cc33fe4f?source=collection_archive---------3-----------------------#2021-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="882e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在谷歌搜索了两个小时后，很明显React Native中的列表动画重新排序是一个未知领域。很自然，我想到的是，这是一个开源贡献的好机会！虽然，最后多亏了开源，它才得以实现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f5ebb592d37400875ff671e4f615ba02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fzg1lADJTWaHG4DbMRrb6w.jpeg"/></div></div></figure><p id="52ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我遇到问题时，我首先搜索的是通用的解决方案，所以在这种情况下，我们试图在React Native中建立一个动画重排，所以让我们从React开始。有一个名为<a class="ae kx" href="https://github.com/joshwcomeau/react-flip-move" rel="noopener ugc nofollow" target="_blank"> react-flip-move </a>的react库，但是经过检查，React原生支持似乎并不存在。</p><p id="df03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定要构建这个，我需要创建一个自定义的钩子，允许在React Native中对列表进行排序，由<a class="ae kx" href="https://reactnative.dev/docs/animated" rel="noopener ugc nofollow" target="_blank">动画</a> API提供支持。解决方案分为三个部分:</p><ul class=""><li id="1484" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">计算列表中每个项目的高度和y位置</li><li id="09f4" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">找出交换了位置的项目</li><li id="01b2" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">使用动画API对项目重新排序</li></ul><p id="71f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致了一些非常复杂的代码，我计划稍后将其抽象成一个定制的钩子。(<strong class="jp ir">放心吧！你不需要复制这个，它只是作为参考</strong></p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="3bbc" class="lr ls iq ln b gy lt lu l lv lw">async function swapItems(index1, index2){<br/>     setIsAnimating(true);<br/>    <br/>     const item1 = await measure(listRefs[index1].current);<br/>     const item2 = await measure(listRefs[index2].current);<br/>     const animated1 = animatedRefs[index1];<br/>     const animated2 = animatedRefs[index2];</span><span id="18cb" class="lr ls iq ln b gy lx lu l lv lw">     const animations = animatedRefs.slice(index1, animatedRefs.length).map((ref, index) =&gt; (</span><span id="1ee6" class="lr ls iq ln b gy lx lu l lv lw">    Animated.spring(animatedRefs[index], { toValue: 175 * (index + 1) , duration: 400 }, { useNativeDriver: false })));<br/>    <br/>   Animated.parallel([<br/>      ...animations,<br/>      Animated.spring(animated2, {<br/>        toValue: (item2.pageY - item1.pageY) - 8,<br/>        duration: 400<br/>      }, { useNativeDriver: false }),<br/>   ]).start(() =&gt; {<br/>      animatedEdges.current = edges;<br/>      setIsAnimating(false);<br/>   });<br/>}</span></pre><p id="fe37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在这个定制解决方案上花了几个小时，但毫无效果。排序有几个奇怪的问题，性能很差，我放弃了自定义实现，但我知道一定有更好的方法。</p><p id="cda3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那天晚上…我在梦中想到，要实现这一点，我需要利用<a class="ae kx" href="https://react-spring.io/" rel="noopener ugc nofollow" target="_blank"> react-spring </a>动画库，瞧，当我早上登录时，我在<a class="ae kx" href="https://react-spring.io/" rel="noopener ugc nofollow" target="_blank"> react-spring </a>网站的代码沙箱中找到了一个react动画重排的例子，我的潜意识是对的。</p><p id="b30b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<a class="ae kx" href="https://codesandbox.io/s/eloquent-meninsky-rzmc0?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank"> CodeSandbox，用于重新排序列表项</a>。下一个挑战是将其转换为React本机代码，需要注意的是，在react-spring v9中，<code class="fe ly lz ma ln b">useTransform</code>钩子<a class="ae kx" href="https://aleclarson.github.io/react-spring/v9/breaking-changes/#The-useTransition-hook" rel="noopener ugc nofollow" target="_blank">有重大改变</a>，不幸的是，这使得它与<a class="ae kx" href="https://reactnative.dev/docs/flatlist" rel="noopener ugc nofollow" target="_blank"> FlatList </a>不兼容，因此下面的解决方案将只适用于小列表。在我们的例子中，这种重新排序功能只适用于专门的重新排序屏幕上的一小部分项目。</p><h2 id="cc72" class="lr ls iq bd mb mc md dn me mf mg dp mh jy mi mj mk kc ml mm mn kg mo mp mq mr bi translated">从React转换为React本机</h2><p id="4647" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">您必须安装<code class="fe ly lz ma ln b">@react-spring/native</code>库，它是React Native的react-spring端口。安装完成后，您需要导入以下内容:</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="f949" class="lr ls iq ln b gy lt lu l lv lw">import { useTransition, animated } from "@react-spring/native";</span></pre><p id="d466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将一个React Native <a class="ae kx" href="https://reactnative.dev/docs/view" rel="noopener ugc nofollow" target="_blank">视图</a>封装成动画，这样我们就可以在以后制作视图组件的动画了:</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="50dc" class="lr ls iq ln b gy lt lu l lv lw">const AnimatedView = animated(View);</span></pre><p id="e49e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">沙盒中的大部分代码在React Native中实现时都非常相似。首先，我们将数据提供给<code class="fe ly lz ma ln b">useTransform</code>钩子:</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="9cfc" class="lr ls iq ln b gy lt lu l lv lw">const ListItemHeight = 190;<br/>const edges = [...];<br/>const transitions = useTransition(<br/>    edges.map((data, i) =&gt; ({ ...data, y: -(i * ListItemHeight) })),<br/>    {<br/>       key: (item) =&gt; item.id, // &lt;- Update this with uid of item<br/>       from: { height: 0, opacity: 0 },<br/>       leave: { height: 0, opacity: 0 },<br/>       enter: ({ y, height }) =&gt; ({ y, height, opacity: 1 }),<br/>       update: ({ y, height }) =&gt; ({ y, height }),<br/>    }<br/>);</span></pre><p id="f6e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，我们使用<code class="fe ly lz ma ln b">transitions</code>函数在<a class="ae kx" href="https://reactnative.dev/docs/using-a-scrollview" rel="noopener ugc nofollow" target="_blank"> ScrollView </a>中呈现我们的项目。因为我们所有的项目都是使用<code class="fe ly lz ma ln b">absolute</code>定位的，所以我们必须计算滚动视图的高度。</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="5cab" class="lr ls iq ln b gy lt lu l lv lw">&lt;ScrollView <br/>  contentContainerStyle={{ <br/>     minHeight: edges.length * ListItemHeight <br/>  }}<br/>&gt;<br/>   ...<br/>&lt;/ScrollView&gt;</span></pre><p id="d69c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在ScrollView中，我们添加了transitions函数来渲染我们的项目，并应用react-spring动画和样式。</p><pre class="km kn ko kp gt lm ln lo lp aw lq bi"><span id="97b6" class="lr ls iq ln b gy lt lu l lv lw">{transitions((style, item, t, index) =&gt; (<br/>   &lt;AnimatedView <br/>     style={{<br/>       zIndex: data.length - index,<br/>       bottom: style.y,<br/>       height: style.height,<br/>       opacity: style.opacity<br/>     }} <br/>     key={item.id}<br/>   &gt;<br/>     &lt;MyListItem ... /&gt;<br/>    &lt;/AnimatedView&gt;<br/>))}</span></pre><p id="34d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你有了它，你应该能够使用React Native实现列表的动画重新排序，无论何时数据发生变化，react-spring都会动画显示列表的重新排序！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/08387c47fc7c1a862b1ad0b90605d213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NGItinpaGgnkhmlQbdRJYQ.gif"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">Qeepsake条目重新排序</figcaption></figure><p id="17c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，以下是该代码的要点:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以通过下载<a class="ae kx" href="https://www.qeepsake.com/" rel="noopener ugc nofollow" target="_blank">qee sake</a>来检查这个特性。保存记忆最简单的方法，就像在《鲨鱼池》里看到的。</p></div></div>    
</body>
</html>