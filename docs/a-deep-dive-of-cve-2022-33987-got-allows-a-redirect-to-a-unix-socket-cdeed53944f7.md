# CVE-2022–33987 的深度剖析(Got 允许重定向到 UNIX 套接字)

> 原文：<https://itnext.io/a-deep-dive-of-cve-2022-33987-got-allows-a-redirect-to-a-unix-socket-cdeed53944f7?source=collection_archive---------1----------------------->

每个星期，几乎毫无例外，我都会遇到一件让我困惑、娱乐或者最常见的激怒我的事情。我决定记录我的冒险经历。

我订阅了几个 PHP 项目的安全版本。我这样做并不是因为 PHP 项目有很多弱点(好吧，它们可能有)，而是因为它们是最受审查的代码之一。所以上周当我看到 [MediaWiki](https://www.mediawiki.org/wiki/MediaWiki) 发布了一个新的安全版本时，我想更深入地了解一下。

# **背景**

在正常环境下，使用 [Github 的分支/标签比较功能](http://invalid:/)，可以快速识别版本之间的安全补丁。MediaWiki [在他们的 Phabricator](https://phabricator.wikimedia.org/T311360) 上保存了大量的项目信息，这有助于这项工作。浏览 2.81.4 版本中的提交，我注意到变化大致分为三个阵营:

1)准备好 PHP 9 对传递给内置函数的空类型的弃用，这些内置函数需要字符串(更多细节参见[本博客](https://phpandmysql.com/updates/passing-null-to-string-functions/))

2)依赖性更新(其中一些是安全更新，这是我们所关心的)

3)通过最近的更改修复一些性能问题

像任何好的项目一样，更新易受攻击的依赖关系对安全故事来说是至关重要的，MediaWiki 似乎在这方面做得很好(尽管在此版本中修补的漏洞已在 2022 年 5 月 25 日上游修补)。通过查看提交，我们在一些上看到以下消息:

```
Updating got to 11.8.5* GHSA-pfrx-2q88-qq97
```

有趣的是，MediaWiki 皮肤和扩展正在运行易受攻击的版本' *got* '，一个节点 HTTP 请求库。当我意识到一个 PHP 项目的安全发布是由于一个节点安全问题时，我有一种复杂的感觉，但我继续前进。以下是带有凸起的子模块*得到了*版本。

```
skins/MinervaNeueextensions/Mathextensions/AbuseFilter
```

# **问题**

那么，*让*做的事情有什么不好呢？事实证明，在一个有点令人想起的问题中，问题是对一个有点模糊的方案的方案处理。

回到 2015 年 9 月的[版本 4.1.1](http://invalid:/) , *获得了*对[通过 Unix 域套接字](https://github.com/sindresorhus/got/pull/96)发出请求的支持。概述的目的很简单，用户可能希望向运行在本地服务器上的套接字发出请求。这与向 localhost 发出请求没有太大区别，但是， [Unix sockets](https://en.wikipedia.org/wiki/Unix_domain_socket) *倾向于*运行更强大的 IPC 工具，提供的用例是“docker”和“fleet”，这给了你一些思路。

结果是他们最终增加了对 Unix 模式:“unix:/”和 HTTP Unix 模式:“http://unix:/”的支持。他们从现在已被否决的请求框架中借用了[后一种格式(稍后会详细介绍)。有趣的是，使用直接的“unix:/”方案实际上并不可行，至少在 11.8.3 中是这样的，其中的依赖项 *http-timer* 无法解析这种 URL 格式(哎呀):](https://github.com/request/request/pull/516)

```
at origin.emit (node_modules/@szmarczak/http-timer/dist/source/index.js:43:20)code: ‘ERR_INVALID_PROTOCOL’
```

问题的关键不是发出 Unix 套接字请求，而是重定向如何发生的本质。**如果恶意用户能够向易受攻击的应用程序提供 URL，他们可以提供解析为 30x 重定向的 URL，该 URL 最终位于 unix:// socket 位置。**向本地主机或本地网络发出请求很大程度上就是[服务器站点请求伪造](https://en.wikipedia.org/wiki/Server-side_request_forgery) ( **#SSRF** )。通常，我们期望开发者过滤这样的请求，这里的问题是标准开发者没有办法阻止这种方案被使用，因为**即使他们最初验证了 URL，*得到*正在自动处理重定向**。

有趣的是， *got* 建议不同的库添加 SSRF 保护， [got-ssrf](https://github.com/hanover-computing/got-ssrf) 。这将最终防止问题，因为 URL 的“unix”部分将最终成为 URL 的主机名，got-ssrf 将尝试解决这个问题，但失败了，因此它返回:

```
RequestError: getaddrinfo ENOTFOUND unix
```

在这一点上，我们想看看用户可以用 Unix 套接字做什么。最明显的例子是 Docker 之类的服务，但有时你也可以检查文件是否存在。本地用户通常能够使用类似下面的内容直接与 Docker 套接字通信:

```
curl — silent -XGET — unix-socket /var/run/docker.sock [http://localhost/version](http://localhost/version)
```

这相当于下面的*中得了*:

```
got(‘http://unix:/var/run/docker.sock:/version')
```

前一个例子很做作，但是 [Docker 管理 API](https://docs.docker.com/engine/api/v1.41/) 更强大，给出了请求方法(GET、POST 等)。)，它支持类似于[创建容器](https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerCreate)(POST)[杀死容器](https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerKill)(POST)[检查授权配置](https://docs.docker.com/engine/api/v1.41/#tag/System/operation/SystemAuth)(POST)[在运行的容器中执行命令](https://docs.docker.com/engine/api/v1.41/#tag/Exec/operation/ContainerExec)(POST)[获取容器日志](https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerLogs)(GET)[导出容器或图像](https://docs.docker.com/engine/api/v1.41/#tag/Container/operation/ContainerExport) (GET)等等。

更糟糕的是，在*GET*中，许多 HTTP 状态代码都遵循重定向，因此攻击者可以使用 307 或 308 将 POST 请求及其内容传递给 Unix 套接字[，而无需将其重写为 GET](https://github.com/sindresorhus/got/blob/623229fad64b89a58c68c9f47fc36a4883cc994a/documentation/2-options.md#methodrewriting) 请求，如果易受攻击的应用程序正在编制 POST 请求。

我前面提到过，*得到了* [从现在已经弃用的](https://github.com/request/request/pull/516) [*请求*框架](https://github.com/request/request)中借用了 http://unix/ formatting 。如果我没有查看' *request* '框架，看看是否会出现同样的漏洞，那我就失职了。如你所料，是的，它也很脆弱。严格来说，这也应该是一个独特的 CVE，但因为*请求*已被否决，他们不太可能响应。有趣的是，有一个[已知的问题](https://github.com/request/request/issues/2327)，要求设置主机头，这在更多情况下无法工作。我想是小小的胜利。

```
import request from 'request'

// http://127.0.0.1:81 redirects with a 307 to http://unix:/var/run/docker.sock:/version
request({
    uri: 'http://127.0.0.1:81',
    headers: {
    'host' : "anything"
    },
  },
  function (error, response, body) {
    console.log('body:', body);
});
```

**解决方案**

**对于大多数人来说，解决方案是将*升级到版本 11.8.4 或更高版本。***此外，如果接受不可信的 URL 进行解析，**开发人员需要了解 SSRF，** [**执行 URL 净化/验证**](https://github.com/sindresorhus/got/blame/main/documentation/2-options.md#L952) **以确保他们没有解析敏感的 URL**。

从*的人们那里得到的*的解决方案是相当[直接](https://github.com/sindresorhus/got/pull/2047)的。开发人员简单地[检查以确保具有 Unix 套接字的重定向 URL 被阻止，除非初始化的 URL 也是 Unix 套接字](https://github.com/sindresorhus/got/blob/d54cd3f85a2763f73084327a6e7690caa6472c5f/source/core/index.ts#L731)。[他们还提议](https://github.com/sindresorhus/got/issues/2046)将选项 [EnableUnixSockets](https://github.com/sindresorhus/got/blob/main/documentation/2-options.md#enableunixsockets) 默认为 false，以在默认情况下完全禁用 Unix 域。

**至于 MediaWiki，事实证明他们只是使用了 *got* 作为他们测试套件**的一部分，所以大部分情况下他们没有受到影响，但不管怎样，他们更新了他们的依赖项，这很好。**不幸的是，他们更新的一些模块** [**也依赖**](https://github.com/wikimedia/mediawiki-extensions-AbuseFilter/blob/master/package-lock.json#L8436) **对*的请求，*既被弃用，又如我所展示的，易受攻击**。哇，为了这个结论走了很长一段路，是吧？