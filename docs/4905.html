<html>
<head>
<title>Get The Most Out of Your Laravel Models With These 7 Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据以下7条建议，充分利用你的Laravel模型</h1>
<blockquote>原文：<a href="https://itnext.io/get-the-most-out-of-your-laravel-models-with-these-7-tips-804f0cf863e4?source=collection_archive---------0-----------------------#2020-10-21">https://itnext.io/get-the-most-out-of-your-laravel-models-with-these-7-tips-804f0cf863e4?source=collection_archive---------0-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0d256a48d53fa9c06188f555402fe2f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u-iZ5pvGAkd_dvIM"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@kaitlynbaker?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯特琳·贝克</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="4cd9" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">优化您使用模型的方式</h2></div><p id="8bbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你开始钻研Laravel文档，你会发现很多在文档中很少提到的特性。其他功能使用频率较低，您可能不知道这些功能。</p><p id="e7c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模特也没什么不同。如果您查看Laravel API文档，您将会惊讶，并且可能会被模型可用的所有属性和方法所淹没。</p><p id="4a3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多功能强大且易于使用的特性，但并不是每个人都知道。这就是为什么我们要回顾这7个技巧，每个使用Laravel的开发人员都应该知道，以充分利用他们的模型。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c047" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">1.自定义转换类型</h1><p id="094b" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Laravel 7中引入了自定义造型类型。在Laravel的早期版本中，当涉及到属性的转换时，您会受到很大的限制。你只能转换成Laravel提供的默认设置。</p><p id="03fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管有一些实现定制造型的软件包，但是它们有一个主要的缺点。这些包覆盖了<em class="my"> getAttribute </em>和<em class="my"> setAttribute </em>方法，这意味着它们不能与覆盖这些方法的其他包组合。</p><p id="f792" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Laravel 7之前，您是这样使用casts属性的:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="de40" class="ni mc jj ne b gy nj nk l nl nm">protected $casts = [<br/>    'is_admin' =&gt; 'boolean',<br/>    'date_of_birth' =&gt; 'date'<br/>];</span></pre><p id="7815" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Laravel 7中，您可以选择添加一个定制的造型类型。您可以通过创建一个实现<em class="my"> CastsAttributes </em>接口的定制cast类来实现这一点。这个接口强制您实现一个<em class="my"> get </em>和一个<em class="my"> set </em>方法。</p><p id="f686" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="my"> get </em>方法负责将数据库中的原始值转换为转换值。<em class="my"> set </em>方法处理将转换值转换成可以存储在数据库中的原始值。</p><p id="5d0b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">处理JSON的自定义转换类型可能是这样的:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0871" class="ni mc jj ne b gy nj nk l nl nm">&lt;?php<br/><br/>namespace App\Casts;<br/><br/>use Illuminate\Contracts\Database\Eloquent\CastsAttributes;<br/><br/>class Json implements CastsAttributes<br/>{<br/>    public function get($model, $key, $value, $attributes)<br/>    {<br/>        return json_decode($value, true);<br/>    }<br/><br/>    public function set($model, $key, $value, $attributes)<br/>    {<br/>        return json_encode($value);<br/>    }<br/>}</span></pre><p id="6684" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用自定义转换类型的类名，可以将自定义转换类型附加到模型属性。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d9b0" class="ni mc jj ne b gy nj nk l nl nm">use App\Casts\Json;</span><span id="3690" class="ni mc jj ne b gy nn nk l nl nm">// More code</span><span id="f555" class="ni mc jj ne b gy nn nk l nl nm">protected $casts = [<br/>    'is_admin' =&gt; 'boolean',<br/>    'date_of_birth' =&gt; 'date',<br/>    'settings' =&gt; Json::class,<br/>];</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="afa1" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">2.自定义时间戳列名</h1><p id="2f6c" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">默认情况下，一个模型有一个<code class="fe no np nq ne b">created_at</code>和一个<code class="fe no np nq ne b">updated_at</code>列，它们被自动添加到数据库中。如果您在命令行上使用<code class="fe no np nq ne b">-m</code>标志创建一个模型，那么也会为这个模型创建一个迁移。</p><p id="8ba3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个迁移伴随着将这些列添加到数据库的<em class="my"> timestamps() </em>方法。这种方法的缺点是不能自定义列名。</p><p id="4c8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，有一种非常简单的方法可以使用常量<code class="fe no np nq ne b">CREATED_AT</code>和<code class="fe no np nq ne b">UPDATED_AT</code>来更改这些列名。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="eb40" class="ni mc jj ne b gy nj nk l nl nm">&lt;?php<br/><br/>class Blog extends Model<br/>{<br/>    const CREATED_AT = 'created_date';<br/>    const UPDATED_AT = 'last_update';<br/>}</span></pre><p id="7901" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使这个工作，你必须删除<code class="fe no np nq ne b">$table-&gt;timestamps()</code>，并用这两行代码替换它:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5844" class="ni mc jj ne b gy nj nk l nl nm">$table-&gt;timestamp('<!-- -->created_date<!-- -->')-&gt;nullable();<br/>$table-&gt;timestamp('<!-- -->last_update<!-- -->')-&gt;nullable();</span></pre><p id="9acc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在为您的模型使用软删除，那么您可以使用常量<code class="fe no np nq ne b">DELETED_AT</code>来定制deleted at列名，如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="fb4f" class="ni mc jj ne b gy nj nk l nl nm">const DELETED_AT = 'deleted_date';</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0f5a" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">3.保存而不触发事件</h1><p id="b3da" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在某些情况下，您可能希望在不触发任何事件的情况下保存模型。使用这个简单而强大的函数，您可以保存任何模型，而无需触发事件。你所要做的就是将下面的函数添加到你的模型类中。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3f49" class="ni mc jj ne b gy nj nk l nl nm">public function saveWithoutEvents()<br/>{<br/>    return static::withoutEvents(function() {<br/>        return $this-&gt;save();<br/>    });<br/>}</span></pre><p id="4505" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是在不触发事件的情况下保存模型的方式:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="fc0d" class="ni mc jj ne b gy nj nk l nl nm">$blog = Blog::find($id);<br/>$blog-&gt;title = "The updated title";<br/>$blog-&gt;saveWithoutEvents();</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="ed17" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">4.触摸所有权关系</h1><p id="afa9" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">您可能已经在您的模型上使用过<em class="my">触摸</em>方法。该方法更新模型的更新时间戳。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="cc8a" class="ni mc jj ne b gy nj nk l nl nm">$blog = Blog::find($id);<br/>$blog-&gt;touch();</span></pre><p id="7ec2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是您知道也可以更新模型拥有关系的更新时间戳吗？</p><p id="871e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以在模型上调用<em class="my"> touchOwners </em>方法来更新模型的所有权关系。让我告诉你这是如何工作的。</p><p id="d24a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个可以有多个评论的博客模型。我们可以在注释模型中定义一个如下所示的关系:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="a2ce" class="ni mc jj ne b gy nj nk l nl nm">public function blog()<br/>{<br/>    return $this-&gt;belongsTo(Blog::class);<br/>}</span></pre><p id="04ca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们在评论模型上定义了关系，现在我们可以使用<em class="my"> touchOwners </em>方法来更新博客的更新时间戳。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="509e" class="ni mc jj ne b gy nj nk l nl nm">$comment = Comment::create([<br/>    // Some data<br/>]);<br/>$comment-&gt;touchOwners();</span></pre><p id="3ce1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们想在添加新评论时更新博客的更新时间戳，这可能会很有用。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="cf6d" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">5.增加</h1><p id="0fba" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><em class="my"> increment </em>方法提供了一种增加字段值的简单方法。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="bcce" class="ni mc jj ne b gy nj nk l nl nm">CouponCode::find($id)-&gt;increment('times_used');</span></pre><p id="3448" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，该值递增1。您可以使用<em class="my"> increment </em>方法的第二个参数来更改值的增量。</p><p id="a0ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码将把<em class="my"> times_used </em>的值增加10。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b5a5" class="ni mc jj ne b gy nj nk l nl nm">CouponCode::find($id)-&gt;increment('times_used', 10);</span></pre><p id="a0b2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了递增指定的列之外，increment方法还将更新在记录的时间戳更新的<em class="my">。</em></p><p id="9ebd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很高兴知道还有一种<em class="my">递减</em>方法，其工作方式与<em class="my">递增</em>方法完全相同。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="362d" class="ni mc jj ne b gy nj nk l nl nm">CouponCode::find($id)-&gt;decrement('times_used');</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e937" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">6.默认关系值</h1><p id="4795" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们把前面一个例子的注释模型也用于这个例子。假设用户可以在博客上发表评论。如果允许客人对博客文章发表评论，那么评论模型中的<em class="my">用户</em>关系将返回<em class="my"> null </em>。</p><p id="7947" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止用户关系返回空值，我们可以使用带有默认值的方法。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5f8b" class="ni mc jj ne b gy nj nk l nl nm"><br/>public function user()<br/>{<br/>    return $this-&gt;belongsTo(User::class)-&gt;withDefault([<br/>        'name' =&gt; 'Guest',<br/>    ]);<br/>}</span></pre><p id="9d57" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，<em class="my">用户</em>关系返回一个名为<em class="my">客人</em>的用户模型。通过为关系设置默认值，可以帮助移除代码中的条件检查。</p><p id="4c59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着您可以在您的刀片模板文件中执行<code class="fe no np nq ne b">{{ $comment-&gt;user-&gt;name }}</code>,因为关系总是返回一个模型。如果您没有使用带有默认的方法的<em class="my">，您将不得不检查注释是否有用户——这将更加冗长。</em></p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f8c0" class="ni mc jj ne b gy nj nk l nl nm">@if ($comment-&gt;user)<br/>    {{ $comment-&gt;user-&gt;name }}<br/>@else<br/>    Guest<br/>@end</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6797" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">7.有</h1><p id="2b68" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><em class="my">有</em>的方法大概不需要过多解释。你可能经常使用它。<em class="my">有</em>方法检查关系是否存在。继续前面的例子，我们可以使用下面的代码行来检索所有发布了博客的用户:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f3ce" class="ni mc jj ne b gy nj nk l nl nm">$users = User::has('blog')-&gt;get();</span></pre><p id="5aaf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们甚至可以扩大这张支票。假设我们只想得到至少有5个博客的用户。我们可以通过向<em class="my"> has </em>方法添加一些参数来做到这一点。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7302" class="ni mc jj ne b gy nj nk l nl nm">$users = User::has('blog', '&gt;=', 5)-&gt;get();</span></pre><p id="caba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你也知道你可以得到所有至少有一个博客和一个评论的用户吗？</p><p id="d208" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用点符号嵌套<em class="my"> has </em>语句。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0ebf" class="ni mc jj ne b gy nj nk l nl nm">$users = User::has('blog.comment')-&gt;get();</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="55db" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">一点额外的小费</h1><p id="d1b7" class="pw-post-body-paragraph ky kz jj la b lb mt kk ld le mu kn lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">好了，结束这篇文章的最后一个小技巧。我相信你知道<em class="my">找</em>的方法。这是一个经常使用的非常基本的方法。<em class="my"> find </em>方法试图返回一个匹配主键的模型。大多数情况下，您会这样使用它:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="54d5" class="ni mc jj ne b gy nj nk l nl nm">$blog = Blog::find(1);</span></pre><p id="1520" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你也知道有可能传入一个有多个id的数组吗？</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1828" class="ni mc jj ne b gy nj nk l nl nm">$blogs = Blog::find([1,2,3]);</span></pre></div></div>    
</body>
</html>