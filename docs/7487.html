<html>
<head>
<title>Tutorial: Polymorphism in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:C语言中的多态性</h1>
<blockquote>原文：<a href="https://itnext.io/polymorphism-in-c-tutorial-bd95197ddbf9?source=collection_archive---------0-----------------------#2022-10-08">https://itnext.io/polymorphism-in-c-tutorial-bd95197ddbf9?source=collection_archive---------0-----------------------#2022-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f3795a9c3765b69e4298f21faa06daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WglScF6NB-YfJBfYOT31LA@2x.jpeg"/></div></div></figure><h1 id="1890" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="3185" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我在我的观点文章中引用了一些子类型多态性的例子，'<a class="ae lu" href="https://medium.com/p/201b3f07a94f" rel="noopener"> C对C++:战斗！本教程将这些例子发展成一个完整的程序，展示了这些技术为什么有用以及如何实现它们。</a></p><p id="03c5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">多态这个词来自古希腊语，简单的意思是“许多形状”。这个词的字典定义通常是“以几种不同的形式存在”。</p><p id="3069" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">维基百科为程序员提供了一个更实用的定义:</p><blockquote class="ma mb mc"><p id="34fa" class="kw kx md ky b kz lv lb lc ld lw lf lg me lx lj lk mf ly ln lo mg lz lr ls lt ij bi translated">多态性是向不同类型的实体提供单一接口</p></blockquote><p id="4f9b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">希望本教程对学习C编程的人有用，或者对那些不确定这样一个理论概念如何应用于C之类的低级语言的人有用。</p><h1 id="3e63" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题陈述</h1><p id="a118" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设我们要编写一个命令行工具，将未知长度的文件中每个字节的值相加。结果可以用作校验和来检测文件中的错误，尽管所提出的算法不能检测字节的重新排序。</p><p id="4441" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这里有一个简单的C程序实现了这个想法:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="8798" class="mq jz iq mm b be mr ms l mt mu">#include &lt;stdio.h&gt;<br/><br/>unsigned char sum_bytes(FILE *f)<br/>{<br/>    unsigned char sum = 0;<br/><br/>    for (int c = fgetc(f); c != EOF; c = fgetc(f)) {<br/>        sum += c;<br/>    }<br/><br/>    return sum;<br/>}<br/><br/>int main(int argc, char const *argv[])<br/>{<br/>    return sum_bytes(stdin);<br/>}</span></pre><p id="cf36" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，我们需要测试我们的程序，以确保它不包含编码错误。为此，我们可以创建一个包含已知字节序列的文件，通过管道将输入输入到程序中，然后检查程序的返回值是否是我们所期望的。</p><p id="8407" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">例如，这样的测试可以实现为以下Bash脚本:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="4932" class="mq jz iq mm b be mr ms l mt mu">echo -en '\x1\x2\x3\x4' | checksum<br/><br/>if [ $? -eq 10 ]; then<br/>    echo "Test passed"<br/>else<br/>    echo "Test failed"<br/>fi</span></pre><p id="583b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这个解决方案并不理想，因为测试脚本的功能有限，并且不能移植到其他平台。相反，我们可能希望单独测试<code class="fe mv mw mx mm b">sum_bytes()</code>函数，以帮助定位任何错误的原因。</p><p id="10e8" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以编写一个测试程序，在一个文件上调用<code class="fe mv mw mx mm b">sum_bytes()</code>而不是标准的输入流，但是它需要首先创建那个文件:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="ddc1" class="mq jz iq mm b be mr ms l mt mu">#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>int main(int argc, char const *argv[])<br/>{<br/>    FILE *f = fopen("testdata", "w+b");<br/><br/>    if (!f) {<br/>        fputs("Can't create file\n", stderr);<br/>        return EXIT_FAILURE;<br/>    }<br/><br/>    static unsigned char const testdata[] = {1, 2, 3, 4};<br/>    int err = EXIT_SUCCESS;<br/><br/>    if (fwrite(testdata, sizeof(testdata), 1, f) != 1) {<br/>        fputs("Can't write to file\n", stderr);<br/>        err = EXIT_FAILURE;<br/>    } else {<br/>        rewind(f);<br/><br/>        if (sum_bytes(f) == 10) {<br/>            puts("Test passed");<br/>        } else {<br/>            fputs("Test failed\n", stderr);<br/>            err = EXIT_FAILURE;<br/>        }<br/>    }<br/><br/>    fclose(f);<br/>    return err;<br/>}</span></pre><p id="c341" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">上述解决方案要求测试对存储临时文件的文件系统具有写访问权。我们可以通过将测试与读取测试向量的<code class="fe mv mw mx mm b">fgetc()</code>的模拟定义联系起来，或者通过使用宏将<code class="fe mv mw mx mm b">fgetc()</code>重新定义为不同名称的模拟函数的别名来解决这个问题。</p><p id="24fd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">两者都是单元测试的有效方法，但是都属于链接时间多态性和通用编程的范畴。本教程关注的是运行时多态，它允许一个<code class="fe mv mw mx mm b">sum_bytes()</code>实例从一个静态链接的程序中读取不同类型的数据源。</p><p id="7d04" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><code class="fe mv mw mx mm b">sum_bytes()</code>函数的基本问题是它只对来自<code class="fe mv mw mx mm b">&lt;stdio.h&gt;</code>的类型<code class="fe mv mw mx mm b">FILE *</code>进行操作。相反，我们可能希望为存储在只读存储器中的数据、从网络中读取的数据或者由诸如ZLib之类的解压缩库输出的数据计算校验和。C标准库的流是一个有用的抽象，但是太有限了，不能支持所有的用例。</p><h1 id="ddb0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">天真的解决方案</h1><p id="89e6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">允许<code class="fe mv mw mx mm b">sum_bytes()</code>函数从不同数据源读取数据的一个简单解决方案是使用条件逻辑。例如，我们可以传递一个<code class="fe mv mw mx mm b">FILE</code>的地址和一个数组的地址，并使用一个布尔参数来决定使用哪个数据源。</p><p id="9c30" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">下面是一个经过适当修改的测试程序:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="5085" class="mq jz iq mm b be mr ms l mt mu">#include &lt;stdbool.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/><br/>unsigned char sum_bytes(bool read_file, FILE *f,<br/>                        int const *buffer)<br/>{<br/>    unsigned char sum = 0;<br/>    size_t i = 0;<br/><br/>    for (int c = read_file ? fgetc(f) : buffer[i++];<br/>         c != EOF;<br/>         c = read_file ? fgetc(f) : buffer[i++])<br/>    {<br/>        sum += c;<br/>    }<br/><br/>    return sum;<br/>}<br/><br/>int main(int argc, char const *argv[])<br/>{<br/>    static int const testdata[] = {1, 2, 3, 4, EOF};<br/><br/>    if (sum_bytes(false, NULL, testdata) == 10) {<br/>      puts("Test passed");<br/>      return EXIT_SUCCESS;<br/>    } else {<br/>      fputs("Test failed\n", stderr);<br/>      return EXIT_FAILURE;<br/>    }<br/>}</span></pre><p id="32ae" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因为调用者必须传递三个参数而不是一个，所以<code class="fe mv mw mx mm b">sum_bytes()</code>函数变得难以使用并且容易出错。很容易错过<code class="fe mv mw mx mm b">true</code>而不是<code class="fe mv mw mx mm b">false</code>，或者反过来。这种解决方案的可扩展性也很差，因为<code class="fe mv mw mx mm b">sum_bytes()</code>的复杂性随着支持的输入数据类型的数量而线性增加。</p><h1 id="4e98" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">多态性的拯救</h1><p id="cea4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一个更具可伸缩性的解决方案是让<code class="fe mv mw mx mm b">sum_bytes()</code>的调用者传递要调用的函数的地址来代替<code class="fe mv mw mx mm b">fgetc()</code>，并且在调用该函数时传递一个<code class="fe mv mw mx mm b">void *</code>指针:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="09e1" class="mq jz iq mm b be mr ms l mt mu">unsigned char sum_bytes(int (*getc_fn)(void *), void *getc_arg)<br/>{<br/>    unsigned char sum = 0;<br/><br/>    for (int c = getc_fn(getc_arg);<br/>         c != EOF;<br/>         c = getc_fn(getc_arg))<br/>    {<br/>        sum += c;<br/>    }<br/><br/>    return sum;<br/>}</span></pre><p id="1d03" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我刚刚描述了不同类型实体的单个接口，因此这个解决方案可以称为多态。</p><p id="9e4c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这个接口仍然有些笨拙，因为<code class="fe mv mw mx mm b">sum_bytes()</code>的调用者必须传递两个参数，而不是一个。它的类型安全性也不如前面的接口:调用者必须注意传递一个与指定的<code class="fe mv mw mx mm b">getc_fn</code>兼容的<code class="fe mv mw mx mm b">getc_arg</code>值。编译器无法强制执行，因为任何(非限定的)指针类型都会隐式转换为<code class="fe mv mw mx mm b">void *</code>。</p><p id="41bb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">最后，所需的类型<code class="fe mv mw mx mm b">getc_fn</code>与标准的<code class="fe mv mw mx mm b">fgetc()</code>函数不兼容，该函数需要类型<code class="fe mv mw mx mm b">FILE *</code>而不是<code class="fe mv mw mx mm b">void *</code>的参数，因此<code class="fe mv mw mx mm b">sum_bytes()</code>的调用者必须使用适配器函数:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="ecbc" class="mq jz iq mm b be mr ms l mt mu">static int stream_reader_getc(void *cb_arg)<br/>{<br/>    return fgetc(cb_arg); // implicit conversion to FILE *<br/>}<br/><br/>int main(int argc, char const *argv[])<br/>{<br/>    return sum_bytes(stream_reader_getc, stdin);<br/>}</span></pre><p id="1790" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们真正想要的是<code class="fe mv mw mx mm b">sum_bytes()</code>呈现一个简单且类型安全的接口，消除出错的可能性。</p><p id="afed" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们首先将回调函数地址和相关的数据指针封装到一个<code class="fe mv mw mx mm b">struct</code>中，以避免它们与其他变量分离或混淆:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="c64b" class="mq jz iq mm b be mr ms l mt mu">struct reader {<br/>  int (*getc_fn)(void *);<br/>  void *getc_arg;<br/>};</span></pre><p id="b5e1" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">上面的定义创建了一个独特的类型，<code class="fe mv mw mx mm b">struct reader</code>，它不能与任何其他类型互换使用(甚至不能是碰巧有相同成员的另一个<code class="fe mv mw mx mm b">struct</code>)。在面向对象编程中，<code class="fe mv mw mx mm b">struct reader</code>被称为“抽象基类”,它的<code class="fe mv mw mx mm b">getc_fn</code>指针被称为“虚方法”。</p><p id="ac58" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">先前版本的<code class="fe mv mw mx mm b">sum_bytes()</code>可以接受任何具有兼容签名(参数和返回类型)的<em class="md">回调函数的地址，而新版本只接受一个<code class="fe mv mw mx mm b">struct reader</code>对象的地址:</em></p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="3db3" class="mq jz iq mm b be mr ms l mt mu">unsigned char sum_bytes(struct reader *r)<br/>{<br/>    unsigned char sum = 0;<br/><br/>    for (int c = r-&gt;getc_fn(r-&gt;getc_arg);<br/>         c != EOF;<br/>         c = r-&gt;getc_fn(r-&gt;getc_arg))<br/>    {<br/>        sum += c;<br/>    }<br/><br/>    return sum;<br/>}<br/><br/>int main(int argc, char const *argv[])<br/>{<br/>    struct reader r = {stream_reader_getc, stdin};<br/>    return sum_bytes(&amp;r);<br/>}</span></pre><p id="fdf8" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">为了避免在实例化类型为<code class="fe mv mw mx mm b">struct reader</code>的对象时出错，让我们创建一些函数来为不同类型的数据源初始化一个对象。在面向对象编程中，这些被称为“子类构造函数”:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="fcf8" class="mq jz iq mm b be mr ms l mt mu">void stream_reader_init(struct reader *r, FILE *stream)<br/>{<br/>    *r = (struct reader){stream_reader_getc, stream};<br/>}<br/><br/>void buf_reader_init(struct reader *r, int *buffer)<br/>{<br/>    *r = (struct reader){buf_reader_getc, buffer};<br/>}</span></pre><p id="a427" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这看起来已经安全多了，但是我还没有提供读取测试向量的<code class="fe mv mw mx mm b">buf_reader_getc()</code>函数的定义。编写这个函数是有问题的:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="e922" class="mq jz iq mm b be mr ms l mt mu">static int buf_reader_getc(void *cb_arg)<br/>{<br/>    static size_t bytes_read;<br/>    int const *const buffer = cb_arg; // implicit conv. to int *<br/>    return buffer[bytes_read++];<br/>}</span></pre><p id="e509" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">虽然这对于一次性测试来说是可以接受的，但是对于真正的程序来说却是不可接受的！<code class="fe mv mw mx mm b">bytes_read</code>计数器的<code class="fe mv mw mx mm b">static</code>存储类别意味着使用该功能只能读取一个缓冲区，并且该缓冲区只能读取一次。</p><p id="bb48" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们真正需要的是面向对象编程中的“实例变量”:每个由<code class="fe mv mw mx mm b">buf_reader_init</code>初始化的<code class="fe mv mw mx mm b">struct reader</code>实例都必须有自己的<code class="fe mv mw mx mm b">bytes_read</code>副本，从0开始计数。这只能通过为从缓冲区而不是从文件读取的<code class="fe mv mw mx mm b">struct reader</code>实例分配额外的内存来实现。</p><p id="c25e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在可能是考虑子类型的好时机。</p><h1 id="dd74" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">亚型多态性</h1><p id="a35b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">C不支持子类型，因为子类型可以和它们的父类型互换使用，因为类型系统没有层次结构。</p><p id="511a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，类似于子类型的东西可以通过将表示超类型的<code class="fe mv mw mx mm b">struct</code>嵌套在表示其子类型的<code class="fe mv mw mx mm b">struct</code>中来实现。这是应用于<code class="fe mv mw mx mm b">struct reader</code>的方法，它被一个名为<code class="fe mv mw mx mm b">struct buf_reader</code>的新子类型所扩展:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="015f" class="mq jz iq mm b be mr ms l mt mu">struct buf_reader {<br/>  struct reader super;<br/>  int const *buffer;<br/>  size_t bytes_read;<br/>};<br/><br/>static int buf_reader_getc(void *cb_arg)<br/>{<br/>    struct buf_reader *br = cb_arg;<br/>    return br-&gt;buffer[br-&gt;bytes_read++];<br/>}<br/><br/>void buf_reader_init(struct buf_reader *br, int const *buffer)<br/>{<br/>    *br = (struct buf_reader){<br/>      .super = {buf_reader_getc, br},<br/>      .buffer = buffer,<br/>      .bytes_read = 0<br/>    };<br/>}</span></pre><p id="088a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">测试程序现在声明了一个新子类型的对象，它包含了实例变量<code class="fe mv mw mx mm b">buffer</code>和<code class="fe mv mw mx mm b">bytes_read</code>的额外空间。和以前一样，它调用<code class="fe mv mw mx mm b">buf_reader_init()</code>来初始化对象:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="e4b7" class="mq jz iq mm b be mr ms l mt mu">int main(int argc, char const *argv[])<br/>{<br/>    struct buf_reader br;<br/>    static int const testdata[] = {1, 2, 3, 4, EOF};<br/>    buf_reader_init(&amp;br, testdata);<br/><br/>    if (sum_bytes(&amp;br.super) == 10) {<br/>      puts("Test passed");<br/>      return EXIT_SUCCESS;<br/>    } else {<br/>      fputs("Test failed\n", stderr);<br/>      return EXIT_FAILURE;<br/>    }<br/>}</span></pre><p id="8e53" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">测试向量现在可以被限定为<code class="fe mv mw mx mm b">const</code>(也许存储在只读存储器中)，因为这个数组的地址不再被转换为<code class="fe mv mw mx mm b">buf_reader_init</code>构造函数中的非限定<code class="fe mv mw mx mm b">void *</code>指针。</p><p id="3e0e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">注意，在调用<code class="fe mv mw mx mm b">sum_bytes()</code>时，测试必须显式传递嵌入式<code class="fe mv mw mx mm b">struct reader</code>的地址，因为从编译器的角度来看<code class="fe mv mw mx mm b">struct reader</code>和<code class="fe mv mw mx mm b">struct buf_reader</code>是截然不同的。在面向对象编程中，这被称为“向上转换”，通常是隐式的。</p><h1 id="2536" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">丰富</h1><p id="190e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个设计仍然有一些问题:</p><ul class=""><li id="fc2c" class="my mz iq ky b kz lv ld lw lh na ll nb lp nc lt nd ne nf ng bi translated">要求测试提供一个由宏值<code class="fe mv mw mx mm b">EOF</code>终止的<code class="fe mv mw mx mm b">int</code>类型的数组，而不是一个无符号字节的数组，这是很笨拙的。</li><li id="6418" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">在<code class="fe mv mw mx mm b">struct reader</code>中存储<code class="fe mv mw mx mm b">struct buf_reader</code>的地址似乎是多余的；两个对象有相同的地址。在任何情况下，都可以使用<code class="fe mv mw mx mm b">offsetof()</code>从另一个对象计算出另一个对象的地址。</li></ul><p id="af09" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">第一点可以通过添加一个新的实例变量<code class="fe mv mw mx mm b">buf_size</code>来解决，以存储<code class="fe mv mw mx mm b">buf_reader_getc()</code>返回的最大字节数:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="216c" class="mq jz iq mm b be mr ms l mt mu">struct buf_reader {<br/>  struct reader super;<br/>  unsigned char const *buffer;<br/>  size_t bytes_read, buf_size;<br/>};<br/><br/>static int buf_reader_getc(void *cb_arg)<br/>{<br/>    struct buf_reader *br = cb_arg;<br/><br/>    if (br-&gt;bytes_read &gt;= br-&gt;buf_size) {<br/>      return EOF;<br/>    }<br/><br/>    return br-&gt;buffer[br-&gt;bytes_read++];<br/>}<br/><br/>void buf_reader_init(struct buf_reader *br,<br/>                     unsigned char const *buffer,<br/>                     size_t buf_size)<br/>{<br/>    *br = (struct buf_reader){<br/>      .super = {buf_reader_getc, br},<br/>      .buffer = buffer,<br/>      .bytes_read = 0,<br/>      .buf_size = buf_size,<br/>    };<br/>}<br/><br/>int main(int argc, char const *argv[])<br/>{<br/>    struct buf_reader br;<br/>    static unsigned char const testdata[] = {1, 2, 3, 4};<br/>    buf_reader_init(&amp;br, testdata, sizeof(testdata));<br/><br/>    if (sum_bytes(&amp;br.super) == 10) {<br/>      puts("Test passed");<br/>      return EXIT_SUCCESS;<br/>    } else {<br/>      fputs("Test failed\n", stderr);<br/>      return EXIT_FAILURE;<br/>    }<br/>}</span></pre><p id="92ab" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">寻址第二个点需要一个接口变化:不是在调用虚拟方法获取一个字节时传递一个<code class="fe mv mw mx mm b">void *</code>指针，<code class="fe mv mw mx mm b">sum_bytes()</code>可以传递<code class="fe mv mw mx mm b">struct reader</code>实例的地址。这个指向当前对象的指针在面向对象的编程中被称为“自我”或“这个”。</p><p id="5bc9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">以下是修改后的<code class="fe mv mw mx mm b">struct reader</code>和<code class="fe mv mw mx mm b">sum_bytes()</code>定义:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="2bef" class="mq jz iq mm b be mr ms l mt mu">struct reader {<br/>  int (*getc_fn)(struct reader *);<br/>};<br/><br/>unsigned char sum_bytes(struct reader *r)<br/>{<br/>    unsigned char sum = 0;<br/><br/>    for (int c = r-&gt;getc_fn(r);<br/>         c != EOF;<br/>         c = r-&gt;getc_fn(r))<br/>    {<br/>        sum += c;<br/>    }<br/><br/>    return sum;<br/>}</span></pre><p id="09a9" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">删除<code class="fe mv mw mx mm b">struct reader</code>的<code class="fe mv mw mx mm b">cb_arg</code>成员意味着<code class="fe mv mw mx mm b">fgetc()</code>从中读取数据的<code class="fe mv mw mx mm b">FILE *</code>必须存储在一个实例变量中。这需要定义第二个子类型，我已经命名为<code class="fe mv mw mx mm b">stream_reader</code>:</p><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="3b61" class="mq jz iq mm b be mr ms l mt mu">#include &lt;stddef.h&gt;<br/><br/>#define container_of(addr, type, member) \<br/>  ((type *)(((char *)(addr)) - offsetof(type, member)))<br/><br/>struct stream_reader {<br/>  struct reader super;<br/>  FILE *stream;<br/>};<br/><br/>static int stream_reader_getc(struct reader *r)<br/>{<br/>    struct stream_reader *sr =<br/>      container_of(r, struct stream_reader, super);<br/><br/>    return fgetc(sr-&gt;stream);<br/>}<br/><br/>void stream_reader_init(struct stream_reader *sr, FILE *stream)<br/>{<br/>    *sr = (struct stream_reader){<br/>      .super = {stream_reader_getc},<br/>      .stream = stream<br/>    };<br/>}</span></pre><p id="9310" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">更新与第一个子类型(<code class="fe mv mw mx mm b">buf_reader_init()</code>和<code class="fe mv mw mx mm b">buf_reader_getc()</code>)相关的函数以符合这个新的接口是留给读者的练习。</p><h1 id="04a0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">遗传还是作文？</h1><p id="66c1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我使用了一个事实上的标准宏<code class="fe mv mw mx mm b">container_of()</code>，从<code class="fe mv mw mx mm b">struct reader</code>成员的地址计算出<code class="fe mv mw mx mm b">struct stream_reader</code>的地址。这在面向对象编程中被称为“向下转换”。它本质上是不安全的，因为编译器不能确定给定的对象实际上是指定子类型的实例。</p><p id="286b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我之前写过“两个对象有相同的地址”，所以你可能会奇怪为什么我使用了<code class="fe mv mw mx mm b">container_of()</code>，而不是简单地转换成所需的子类型<code class="fe mv mw mx mm b">struct stream_reader *</code>。</p><p id="e121" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在某种程度上，这种选择归结于你是否认同继承的概念。如果你相信<code class="fe mv mw mx mm b">stream_reader</code> <em class="md">是</em>一个<code class="fe mv mw mx mm b">reader</code>(继承)，那么一个简单的造型就很有意义；如果你反而相信<code class="fe mv mw mx mm b">stream_reader</code> <em class="md">有</em>有<code class="fe mv mw mx mm b">reader</code>(构图)，那么<code class="fe mv mw mx mm b">container_of()</code>更有意义。</p><p id="0670" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">使用<code class="fe mv mw mx mm b">container_of()</code>确实有一些实际优势:</p><ul class=""><li id="d9b1" class="my mz iq ky b kz lv ld lw lh na ll nb lp nc lt nd ne nf ng bi translated">编译器检查<code class="fe mv mw mx mm b">struct stream_reader</code>是否有一个名为<code class="fe mv mw mx mm b">super</code>的成员；<code class="fe mv mw mx mm b">container_of()</code>更聪明的定义也迫使编译器检查<code class="fe mv mw mx mm b">super</code>的类型是否为<code class="fe mv mw mx mm b">struct reader</code>。</li><li id="3dfd" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">如果<code class="fe mv mw mx mm b">super</code>成员意外地从其在<code class="fe mv mw mx mm b">struct stream_reader</code>定义开始时的位置移开，那么程序仍然可能工作。</li><li id="c8b8" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">您以后可能会决定让类型为<code class="fe mv mw mx mm b">struct stream_reader</code>的对象实现多个接口(“多重继承”)。</li></ul><p id="e2bd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，<code class="fe mv mw mx mm b">container_of()</code>也有一个很大的缺点，如果你关心编写严格符合标准的代码:</p><blockquote class="ma mb mc"><p id="387b" class="kw kx md ky b kz lv lb lc ld lw lf lg me lx lj lk mf ly ln lo mg lz lr ls lt ij bi translated">当具有整数类型的表达式被添加到指针或从指针中减去时…如果指针操作数和结果都指向同一个数组对象的元素，或者都超过数组对象的最后一个元素，则求值不应产生溢出；否则，行为是未定义的。</p></blockquote><p id="da81" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">(6.5.6“加法运算符”，ISO/IEC 9899:1999“编程语言— C”)</p><p id="9b03" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">宏定义中的<code class="fe mv mw mx mm b">char *</code>强制转换允许将指定成员重新解释为数组，但它不是数组对象，减去<code class="fe mv mw mx mm b">offsetof(type, member)</code>的结果可能指向它之外。实际上，给定的定义适用于所有已知的编译器和目标体系结构。</p><p id="02cb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">大多数程序员只是忽略了<code class="fe mv mw mx mm b">container_of()</code>可能有未定义的行为这一事实。你要不要跟着他们，你自己看着办。相反，您可以继续在超类型的每个实例中存储一个<code class="fe mv mw mx mm b">void *</code>指针，或者(如果您不需要多重继承)确保<code class="fe mv mw mx mm b">super</code>总是子类型<code class="fe mv mw mx mm b">struct</code>的第一个成员。在后一种情况下，<code class="fe mv mw mx mm b">container_of()</code>定义了等同于简单造型的行为。</p><h1 id="d137" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">封装向何处去？</h1><p id="5c9d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在大多数情况下，我会对我上面提出的解决方案感到满意。它简单、高效、类型安全(除了我在虚方法定义中使用的<code class="fe mv mw mx mm b">container_of()</code>)。</p><p id="fbf3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">当处理较大的项目时，或者当设计需要保持二进制兼容性的接口时，您可能希望隐藏一些实现细节。在C程序中，这样做的方法是使用不完整的<code class="fe mv mw mx mm b">struct</code>类型。这些可以用在任何不需要一个<code class="fe mv mw mx mm b">struct</code>的大小并且它的成员不能被直接访问的情况下。</p><p id="b183" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">以下是一些需要考虑补救的封装失败:</p><ul class=""><li id="6fcb" class="my mz iq ky b kz lv ld lw lh na ll nb lp nc lt nd ne nf ng bi translated"><code class="fe mv mw mx mm b">sum_bytes()</code>函数要求<code class="fe mv mw mx mm b">struct reader</code>是一个完整的类型，以便调用它用来获取数据的虚拟方法。这将公开属于超类型的任何实例变量。</li><li id="64d2" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><code class="fe mv mw mx mm b">checksum</code>程序要求<code class="fe mv mw mx mm b">struct stream_reader</code>是一个完整的类型，以便声明该类型的对象，并允许它获得嵌入的<code class="fe mv mw mx mm b">struct reader</code>的地址。这将暴露属于父类型和子类型的任何实例变量。</li><li id="1fbf" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">测试要求<code class="fe mv mw mx mm b">struct buf_reader</code>是一个完整的类型，以便声明该类型的对象，并允许它获得嵌入的<code class="fe mv mw mx mm b">struct reader</code>的地址。</li></ul><p id="67fc" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">第一点可以通过创建一个头文件来解决，该头文件声明一个不完整的<code class="fe mv mw mx mm b">struct reader</code>类型和包装函数来调用它提供的任何虚拟方法(在本例中，只有一个)。</p><p id="31e0" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">实现子类型所需的<code class="fe mv mw mx mm b">struct reader</code>的完整定义必须放在一个单独的私有头文件中。如果私有头文件只包含在需要完整类型的源文件中，那么<code class="fe mv mw mx mm b">struct</code>成员将被隐藏。</p><h2 id="cf60" class="nm jz iq bd ka nn no dn ke np nq dp ki lh nr ns km ll nt nu kq lp nv nw ku nx bi translated">reader.h —公共接口</h2><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="dfe7" class="mq jz iq mm b be mr ms l mt mu">struct reader;<br/>int reader_getc(struct reader *);</span></pre><h2 id="0235" class="nm jz iq bd ka nn no dn ke np nq dp ki lh nr ns km ll nt nu kq lp nv nw ku nx bi translated">reader_struct.h —私有接口</h2><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="1324" class="mq jz iq mm b be mr ms l mt mu">struct reader {<br/>  int (*getc_fn)(struct reader *);<br/>};</span></pre><h2 id="53b4" class="nm jz iq bd ka nn no dn ke np nq dp ki lh nr ns km ll nt nu kq lp nv nw ku nx bi translated">reader.c —私有实现</h2><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="a0cc" class="mq jz iq mm b be mr ms l mt mu">#include "reader.h"<br/>#include "reader_struct.h"<br/><br/>int reader_getc(struct reader *r)<br/>{<br/>  return r-&gt;getc_fn(r);<br/>}</span></pre><p id="53be" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">第二点可以通过为<code class="fe mv mw mx mm b">struct stream_reader</code>编写一个可选的构造函数来解决，该构造函数为新的对象实例动态分配内存，并编写一个函数来获取嵌入在<code class="fe mv mw mx mm b">struct stream_reader</code>实例中的<code class="fe mv mw mx mm b">struct reader</code>的地址。</p><p id="ac84" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">同样，实现子类型或分配其实例所需的<code class="fe mv mw mx mm b">struct stream_reader</code>的完整定义必须放在私有头文件中。</p><h2 id="af9f" class="nm jz iq bd ka nn no dn ke np nq dp ki lh nr ns km ll nt nu kq lp nv nw ku nx bi translated">stream_reader.h —公共接口</h2><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="fecf" class="mq jz iq mm b be mr ms l mt mu">#include &lt;stdio.h&gt;<br/>#include "reader.h"<br/><br/>struct stream_reader;<br/>void stream_reader_init(struct stream_reader *sr, FILE *stream);<br/>struct stream_reader *stream_reader_new(FILE *stream);<br/>struct reader *stream_reader_get_reader(struct stream_reader *);</span></pre><h2 id="f574" class="nm jz iq bd ka nn no dn ke np nq dp ki lh nr ns km ll nt nu kq lp nv nw ku nx bi translated">stream_reader_struct.h —私有接口</h2><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="5ad8" class="mq jz iq mm b be mr ms l mt mu">#include &lt;stdio.h&gt;<br/>#include "reader_struct.h"<br/><br/>struct stream_reader {<br/>  struct reader super;<br/>  FILE *stream;<br/>};</span></pre><h2 id="a0d7" class="nm jz iq bd ka nn no dn ke np nq dp ki lh nr ns km ll nt nu kq lp nv nw ku nx bi translated">stream_reader.c —私有实现</h2><pre class="mh mi mj mk gt ml mm mn bn mo mp bi"><span id="0787" class="mq jz iq mm b be mr ms l mt mu">#include "stream_reader.h"<br/>#include "stream_reader_struct.h"<br/><br/>static int stream_reader_getc(struct reader *r)<br/>{<br/>    struct stream_reader *sr =<br/>      container_of(r, struct stream_reader, super);<br/><br/>    return fgetc(sr-&gt;stream);<br/>}<br/><br/>void stream_reader_init(struct stream_reader *sr, FILE *stream)<br/>{<br/>    *sr = (struct stream_reader){<br/>      .super = {stream_reader_getc},<br/>      .stream = stream<br/>    };<br/>}<br/><br/>struct stream_reader *stream_reader_new(FILE *stream)<br/>{<br/>  struct stream_reader *sr = malloc(sizeof(*sr));<br/><br/>  if (sr) {<br/>    stream_reader_init(sr, stream);<br/>  }<br/><br/>  return sr;<br/>}<br/><br/>struct reader *stream_reader_get_reader(struct stream_reader *sr)<br/>{<br/>  return &amp;sr-&gt;super;<br/>}</span></pre><p id="86d5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">为另一个子类型定义单独的公共和私有接口留给读者做练习。</p><h1 id="dee3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">引人深思的事</h1><ul class=""><li id="4774" class="my mz iq ky b kz la ld le lh ny ll nz lp oa lt nd ne nf ng bi translated">如果子类型的实例被分配在堆上，并且不提供额外的(即非虚拟的)方法，那么这些类型需要成为公共接口的一部分吗？</li><li id="1ad0" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">如果子类型不是公共接口的一部分，那么程序如何销毁子类型的实例呢？</li><li id="ab00" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">你能按照提供一个稳定的接口对每一个头文件的重要性来排列推荐的头文件吗？</li><li id="da15" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">如果一个子类型的构造函数没有初始化一个函数指针，那么调用相应的方法就会有不确定的行为。对于“getc”来说，什么是有用的默认行为，你将如何实现它？</li></ul><h1 id="a77b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">天色已晚</h1><p id="760b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我希望你觉得这个教程有用；我写得很开心。如果没有，为什么不发表评论，让我知道你还想阅读哪些C编程主题？</p><p id="5ea3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>