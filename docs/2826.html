<html>
<head>
<title>Is Symbol really useful in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的符号真的有用吗？</h1>
<blockquote>原文：<a href="https://itnext.io/is-symbol-really-useful-6ada04ca858f?source=collection_archive---------6-----------------------#2019-08-09">https://itnext.io/is-symbol-really-useful-6ada04ca858f?source=collection_archive---------6-----------------------#2019-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/314f99978b03f7048ef979402e3c0d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbEy5jXvauVb08xLA4JtFA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="8aa6" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">符号，ES2015中引入的被低估的功能。除了面试问题还有其他目的吗？</h2></div><h1 id="0793" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">快速回顾一下，那些“符号”到底是什么？</h1><blockquote class="li lj lk"><p id="a013" class="ll lm ln lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated"><em class="jb">代表唯一的非字符串对象属性关键字的原始值</em></p></blockquote><p id="ea0b" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">这是当前<a class="ae ml" href="http://www.ecma-international.org/ecma-262/#sec-symbol-value" rel="noopener ugc nofollow" target="_blank">规范</a>中的符号定义。但这意味着什么呢？你大概知道JS里其他的原语类型(<code class="fe mm mn mo mp b">Undefined</code>、<code class="fe mm mn mo mp b">Null</code>、<code class="fe mm mn mo mp b">Boolean</code>、<code class="fe mm mn mo mp b">Number</code>、<code class="fe mm mn mo mp b">BigInt</code>或者<code class="fe mm mn mo mp b">String</code>)。符号是另一个。我知道这并不多，听起来像是定义递归:</p><blockquote class="li lj lk"><p id="4da2" class="ll lm ln lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated">为了理解递归，你必须首先理解递归</p></blockquote><p id="21d8" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">在编程语言中，所有的基本类型都只是存储在内存中的一堆字节。不管它是字符串还是数字，从数据的角度来看，它仍然只是字节。在符号的情况下，它们是用作唯一id的<code class="fe mm mn mo mp b">tokens</code>。</p><h2 id="c87f" class="mq kr jb bd ks mr ms dn kw mt mu dp la mi mv mw lc mj mx my le mk mz na lg nb bi translated">如何使用符号</h2><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="5667" class="mq kr jb mp b gy nk nl l nm nn">// string "id" is a Symbol's description<br/>const id = Symbol('id');<br/><br/>// you can also create Symbol without description<br/>const noDescriptionId = Symbol();</span></pre><p id="6076" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">我们刚刚创建了一个符号<code class="fe mm mn mo mp b">id</code>。但重要的是<code class="fe mm mn mo mp b">id !== Symbol('id')</code>。就像我说过的，早期的符号是独一无二的。</p><h2 id="7879" class="mq kr jb bd ks mr ms dn kw mt mu dp la mi mv mw lc mj mx my le mk mz na lg nb bi translated">除非他们不是…</h2><p id="0f0a" class="pw-post-body-paragraph ll lm jb lo b lp no kc lr ls np kf lu mi nq lx ly mj nr mb mc mk ns mf mg mh ij bi translated">还有另一种创造符号的方法，叫做</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="0f7b" class="mq kr jb mp b gy nk nl l nm nn">Symbol.for('id');<br/><br/>assert(Symbol.for('id') === Symbol.for('id')); // true</span></pre><p id="9cee" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">好吧，这里发生了什么？我们刚刚使用了<code class="fe mm mn mo mp b">global Symbol registry</code>来存储我们的符号。顾名思义，它是一个<code class="fe mm mn mo mp b">global</code>注册表，在这种情况下，global也是跨领域的(在JS中，这意味着在iframe中创建的符号，与当前执行上下文中的符号相同)。</p><p id="84d7" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">旁注:你可以检查符号是否唯一。为此，您可以使用<code class="fe mm mn mo mp b">Symbol.keyFor(yourSymbol)</code>。如果<code class="fe mm mn mo mp b">yourSymbol</code>是全局的，那么它返回符号的描述(<code class="fe mm mn mo mp b">id</code>)作为字符串，否则它返回<code class="fe mm mn mo mp b">undefined</code>。</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="75bf" class="mq kr jb mp b gy nk nl l nm nn">assert(Symbol.keyFor(Symbol.for('id')) === 'id');<br/>assert(Symbol.keyFor(Symbol('id')) === undefined);</span></pre><h2 id="0519" class="mq kr jb bd ks mr ms dn kw mt mu dp la mi mv mw lc mj mx my le mk mz na lg nb bi translated">你需要知道的属性</h2><ul class=""><li id="1038" class="nt nu jb lo b lp no ls np mi nv mj nw mk nx mh ny nz oa ob bi translated">符号永远不会与对象键冲突。您可以使用符号作为对象键<code class="fe mm mn mo mp b">store[Symbol.for('id')] = 42</code>。</li><li id="bc7c" class="nt nu jb lo b lp oc ls od mi oe mj of mk og mh ny nz oa ob bi translated">使用符号创建的密钥是不可迭代的。所以当你调用<code class="fe mm mn mo mp b">Object.values(store)</code>时，你不会得到<code class="fe mm mn mo mp b">42</code>，除非有另一个键(不是符号键)有那个值。这是一个非常有用的属性，因为当你添加另一个属性时，它不会改变库的行为。</li><li id="4c7a" class="nt nu jb lo b lp oc ls od mi oe mj of mk og mh ny nz oa ob bi translated">要从对象中提取符号，可以使用<code class="fe mm mn mo mp b">Object.getOwnPropertySymbols()</code>。</li><li id="11b5" class="nt nu jb lo b lp oc ls od mi oe mj of mk og mh ny nz oa ob bi translated">符号被复制到其他对象。当<code class="fe mm mn mo mp b">Object.assign(a, b)</code>被调用时，每个可枚举的符号都从obj <code class="fe mm mn mo mp b">a</code>复制到obj <code class="fe mm mn mo mp b">b</code>中。</li></ul><h1 id="6561" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">符号的有用性</h1><p id="a711" class="pw-post-body-paragraph ll lm jb lo b lp no kc lr ls np kf lu mi nq lx ly mj nr mb mc mk ns mf mg mh ij bi translated">现在当你知道什么是符号，我们可以讨论为什么你应该认为符号有用？让我们假设您正在创建一个库，并想让您的用户有可能扩展您的库。</p><p id="a170" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">你的库叫做<code class="fe mm mn mo mp b">stateOfTheArtValidation</code>(简称<code class="fe mm mn mo mp b">stav</code>)。它导出您可以分配给对象的可用扩展列表。</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="e6ff" class="mq kr jb mp b gy nk nl l nm nn">export const extensibleSymbols = {<br/>  VALIDATION: Symbol('validationFun'),<br/>  REQUIRED: Symbol('required'),<br/>};</span></pre><p id="8c18" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">现在我们可以在我们的对象中使用任何这些符号。</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="fd45" class="mq kr jb mp b gy nk nl l nm nn">const myObj = {<br/>  someProp: 'anyValue',<br/>  [stav.Symbols.VALIDATION]: element =&gt; element.hasOwnProperty('someProp'),<br/>};</span></pre><p id="9415" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">在我们讨论它之前，让我先向您展示一下您的库是如何处理它的。</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="94b5" class="mq kr jb mp b gy nk nl l nm nn">// somewhere in our library<br/>validate: (...objectsToValidate) =&gt; {<br/>  const validations = [];<br/><br/>  for (const objToValidate of objectsToValidate) {<br/>    if (typeof objToValidate[this.Symbols.VALIDATION] === 'function') {<br/>      validations.push({<br/>        result: objToValidate[this.Symbols.VALIDATION](objToValidate),<br/>      });<br/>    } else {<br/>      validations.push({<br/>        result: this.standardValidation(objToValidate),<br/>      });<br/>    }<br/>  }<br/><br/>  return validations;<br/>};</span></pre><p id="19b8" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated"><code class="fe mm mn mo mp b">validate</code>是您库中的一个方法。但是在某些情况下，您想让用户选择应用他们的验证，而不是您的<code class="fe mm mn mo mp b">standardValidation</code>方法。您没有定义用户可以用来附加验证方法的字符串属性列表，而是为它定义了Symbol。这样，与该对象上的任何现有键发生冲突的可能性为0%,因此用户不会意外地覆盖您想要使用的属性。</p><p id="f10f" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">那个例子并不是很有用，但是你可以得到一个想法。</p><h1 id="fee4" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated"><a class="ae ml" href="https://tc39.es/ecma262/#sec-well-known-symbols" rel="noopener ugc nofollow" target="_blank">知名符号</a></h1><blockquote class="li lj lk"><p id="5770" class="ll lm ln lo b lp lq kc lr ls lt kf lu lv lw lx ly lz ma mb mc md me mf mg mh ij bi translated"><em class="jb">公知符号是本规范的算法明确引用的内置符号值。</em></p></blockquote><p id="a15f" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">已经有人通过在JS中创建内置符号来考虑这个问题了。这些符号对于覆盖对象或向对象添加功能非常有用。例如，您可以使用<code class="fe mm mn mo mp b">Symbol.iterator</code>来定义迭代器，并使您的对象以您想要的方式可迭代。</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="a764" class="mq kr jb mp b gy nk nl l nm nn">const myObj = {<br/>  test: 'test',<br/>};<br/><br/>myObj[Symbol.iterator] = function* myGenerator() {<br/>  yield this.test;<br/>  yield 'See ya!';<br/>};<br/><br/>for (const val of myObj) {<br/>  console.log(val);<br/>}</span></pre><p id="5d53" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated">印刷品:</p><pre class="nc nd ne nf gt ng mp nh ni aw nj bi"><span id="ce87" class="mq kr jb mp b gy nk nl l nm nn">test<br/>See ya!</span></pre><h1 id="40d6" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">结论</h1><p id="7074" class="pw-post-body-paragraph ll lm jb lo b lp no kc lr ls np kf lu mi nq lx ly mj nr mb mc mk ns mf mg mh ij bi translated">现在你明白符号是多么强大和有用了。也许你会更多地使用内置符号，而不是定义自己的符号。但是库的创建者(像你:P)有另一种方法让用户扩展库的功能。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="3074" class="pw-post-body-paragraph ll lm jb lo b lp lq kc lr ls lt kf lu mi lw lx ly mj ma mb mc mk me mf mg mh ij bi translated"><em class="ln">最初发布于</em><a class="ae ml" href="https://erdem.pl/2019/07/is-symbol-really-useful" rel="noopener ugc nofollow" target="_blank"><em class="ln">https://erdem . pl</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>