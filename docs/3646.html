<html>
<head>
<title>Controlling the Bash Terminal Screen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">控制Bash终端屏幕</h1>
<blockquote>原文：<a href="https://itnext.io/controlling-the-bash-terminal-screen-a50aa6121fdc?source=collection_archive---------2-----------------------#2020-01-23">https://itnext.io/controlling-the-bash-terminal-screen-a50aa6121fdc?source=collection_archive---------2-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="95a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何控制CLI终端创建基于文本的GUI</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3088faf57290761b76145b5f1bef170d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rVRrBSiz3uKrBeEWpoymbw.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在MacOS上运行的示例项目的屏幕记录</figcaption></figure><h2 id="e353" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="dfbc" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi mn translated">在图形用户界面广泛使用之前，开发人员依靠直接在终端上绘制ASCII字符来为系统工具、游戏和其他应用程序创建可视界面。</p><p id="cf1e" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">在本文中，我们将探索一些概念和技术，这些概念和技术可用于在纯Bash中直接对终端屏幕进行随机访问，而无需使用任何其他编程语言。</p><p id="308a" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">本文中示例项目的源代码可以在GitHub 上的<a class="ae nb" href="https://github.com/kenreilly/bash-terminal-control-demo" rel="noopener ugc nofollow" target="_blank">处获得。</a></p><p id="78ba" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">运行该示例需要一个标准的Bash或兼容的环境。有关创建强大而高效的Bash脚本的介绍，请参阅本文，<a class="ae nb" rel="noopener ugc nofollow" target="_blank" href="/intro-to-bash-scripting-95c5fbc2dcef">Bash脚本简介</a>。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="1731" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">概观</h2><p id="7d55" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">为了演示如何直接控制终端来构建定制界面，将使用以下关键概念:</p><ul class=""><li id="a05d" class="nj nk it lw b lx mw ma mx lh nl ll nm lp nn mm no np nq nr bi translated">将<code class="fe ns nt nu nv b">.sh</code>资源组织成一个结构良好的项目</li><li id="b1ad" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm no np nq nr bi translated">将顶层逻辑置于主程序无限循环中</li><li id="222e" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm no np nq nr bi translated">定义输入键、输出颜色和其他变量</li><li id="32d4" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm no np nq nr bi translated">构建一个简单的渲染时钟和事件系统</li><li id="d7dc" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm no np nq nr bi translated">从终端输入中读取并处理单个字符</li><li id="d50f" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm no np nq nr bi translated">在屏幕上特定的x/y坐标处书写字符</li></ul><p id="78af" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">实际上，示例项目的操作如下:</p><ol class=""><li id="327a" class="nj nk it lw b lx mw ma mx lh nl ll nm lp nn mm ob np nq nr bi translated">使用<code class="fe ns nt nu nv b">source </code>命令导入所需文件</li><li id="926c" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm ob np nq nr bi translated">初始化输入和屏幕输出控制器</li><li id="c377" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm ob np nq nr bi translated">从终端检索输入(作为方向键)</li><li id="91ad" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm ob np nq nr bi translated">根据输入移动光标字符的位置</li><li id="de7e" class="nj nk it lw b lx nw ma nx lh ny ll nz lp oa mm ob np nq nr bi translated">将光标(和调试信息)呈现到屏幕上</li></ol><p id="865a" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">让我们来看看这个项目的源代码:</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="a086" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">程序入口点</h2><p id="41ec" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">这个项目中的主文件是<strong class="lw iu"> main.sh </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="cbc1" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">首先，将一个<code class="fe ns nt nu nv b">DEBUG</code>标志设置为<code class="fe ns nt nu nv b">1</code>，稍后将使用它来决定是否在屏幕顶部打印一些调试信息。接下来，定义<code class="fe ns nt nu nv b">_DIR</code>和<code class="fe ns nt nu nv b">_ROOT</code>变量，将当前目录设置为项目根目录，然后使用<code class="fe ns nt nu nv b">source </code>命令导入程序库文件。我们将很快检查这些文件中的函数，但首先让我们看看它们在这个文件中是如何使用的:</p><p id="8cf1" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">在<code class="fe ns nt nu nv b">main</code>函数中，调用<code class="fe ns nt nu nv b">input_init</code>和<code class="fe ns nt nu nv b">screen_init</code>函数分别初始化输入和屏幕控制器，然后主程序循环开始。</p><p id="115c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">在主循环中，首先执行检查以确定屏幕是否已调整大小，如果是，则通过调用<code class="fe ns nt nu nv b">screen_reset </code>命令进行重置。接下来，<code class="fe ns nt nu nv b">process_input</code>被调用来检索和处理来自终端的输入，<code class="fe ns nt nu nv b">render_init</code>被调用来为绘图准备屏幕，而<code class="fe ns nt nu nv b">render_cursor</code>被调用来在屏幕上绘制光标。</p><p id="fee8" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">检查<code class="fe ns nt nu nv b">DEBUG</code>变量，如果它已经被设置为<code class="fe ns nt nu nv b">1</code>(在本程序中是默认的)，那么调用<code class="fe ns nt nu nv b">print_debug</code>来获取调试信息。最后，调用<code class="fe ns nt nu nv b">clock_cycle</code>函数，这将触发我们简单的内部计时器上的一个循环事件，我们稍后将对此进行检查。</p><p id="1c27" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">现在让我们来看看代码库中的文件，这些文件定义了处理这个程序操作的函数和变量。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="0e1d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">配置/助手功能</h2><p id="0025" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">下一个要检查的文件是<strong class="lw iu"> lib/base.sh </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="23a2" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这个简单的文件定义了一个带有<code class="fe ns nt nu nv b">delay</code>的_config变量，用于设置时钟暂停的时间长度(以秒为单位)。默认情况下，它被设置为0.1秒，这将导致主程序循环每秒运行(和屏幕刷新)10次。</p><p id="30b9" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这里还定义了一个助手函数<code class="fe ns nt nu nv b">str_length</code>，它使用内置的shell命令<code class="fe ns nt nu nv b">sed</code>从传递给该函数的字符串中去除任何不可打印的字符，然后使用字符串操作语法<code class="fe ns nt nu nv b">${#str}</code>计算并返回<code class="fe ns nt nu nv b">str</code>中可打印字符的数量。</p><blockquote class="oe of og"><p id="6262" class="lu lv oh lw b lx mw ju lz ma mx jx mc oi my me mf oj mz mh mi ok na mk ml mm im bi translated">注:有关<code class="fe ns nt nu nv b">sed</code>的更多信息，只需运行<code class="fe ns nt nu nv b">man sed</code>或查看<a class="ae nb" href="https://www.gnu.org/software/sed/manual/sed.txt" rel="noopener ugc nofollow" target="_blank">手册页</a>。要了解更多关于字符串操作的信息，请参见<a class="ae nb" href="https://www.tldp.org/LDP/abs/html/string-manipulation.html" rel="noopener ugc nofollow" target="_blank">这本优秀的指南</a>。</p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="6692" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义控制台颜色</h2><p id="7e34" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">如果不在终端输出中添加一些颜色，这个例子是不完整的，这是通过使用转义序列指示终端以彩色打印下一个字符来实现的。</p><p id="78b2" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">颜色定义以及用于设置颜色的函数都在文件<strong class="lw iu"> lib/types/colors.sh </strong>中定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5e64" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">关联数组<code class="fe ns nt nu nv b">color_map_16</code>用简单易用的名称为16色终端调色板的每种标准颜色定义了相应的转义序列。</p><p id="359f" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">颜色可以由程序的其他部分使用<code class="fe ns nt nu nv b">set_color</code>函数来设置，它将为传递给函数的颜色名称打印所需的转义序列系列。如果没有提供颜色，则默认设置为白色。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="f160" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义输入键</h2><p id="15ba" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">接下来，让我们看看处理键输入的定义和辅助函数，它们可以在<strong class="lw iu"> lib/types/keys.sh </strong>中找到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6971" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这个示例项目只是在屏幕上画了一个可移动的光标，所以这里我们只关心方向键，它们被映射到带有<code class="fe ns nt nu nv b">key_map</code>的转义序列，并在一个基本数组<code class="fe ns nt nu nv b">_direction_keys</code>中定义(用于验证键输入)。</p><p id="507f" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">函数<code class="fe ns nt nu nv b">get_key_name</code>获取由输入控制器检索的字符串(我们稍后将对此进行检查),并检查输入是否对应于<code class="fe ns nt nu nv b">key_map </code>中定义的键之一，如果是，则返回被按下的键的名称。类似地，<code class="fe ns nt nu nv b">is_direction</code>函数接受一个键名，并根据键名是否是方向返回一个<code class="fe ns nt nu nv b">1</code>或<code class="fe ns nt nu nv b">0</code>。</p><blockquote class="oe of og"><p id="d3a5" class="lu lv oh lw b lx mw ju lz ma mx jx mc oi my me mf oj mz mh mi ok na mk ml mm im bi translated">注意:在这个例子中，所有可用的键名都是方向，但是在一个更复杂的项目中，这可以扩展到检查一个键是字母数字、圆括号、方括号，还是任何其他的一组键。</p></blockquote></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="22df" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">简单的时钟/事件系统</h2><p id="0532" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">为了驱动UI呈现屏幕和闪烁光标的时间，需要一个简单的时钟/事件系统。这是在<strong class="lw iu"> lib/services/clock.sh </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3bf2" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated"><code class="fe ns nt nu nv b">_clock_listeners</code>数组将存储一个对订阅了时钟事件的侦听器的引用。<code class="fe ns nt nu nv b">_tick</code>变量是一个计数器，它将在每个周期递增，并在达到值10时复位。</p><p id="6ef9" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">程序的另一部分使用函数<code class="fe ns nt nu nv b">clock_listen</code>来订阅时钟事件。这是通过传入一个函数名来实现的，这个函数名将存储在上面的<code class="fe ns nt nu nv b">_clock_listeners</code>数组中。</p><p id="79c5" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">在主程序循环的每次迭代中，都会调用<code class="fe ns nt nu nv b">clock_cycle</code>函数，该函数会将<code class="fe ns nt nu nv b">_tick</code>递增1，然后在值为10时触发<code class="fe ns nt nu nv b">_on_trigger</code>。这将把<code class="fe ns nt nu nv b">_tick</code>的值重置为零，并调用作为监听器传递给<code class="fe ns nt nu nv b">clock_listen</code>的每个函数。</p><p id="8914" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这创建了一个非常基本的时钟和事件系统，用于驱动程序其余部分的计时。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="9ec6" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">处理输入</h2><p id="40cb" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">接下来，我们将检查用于检索和处理键盘输入的方法，这些方法位于文件<strong class="lw iu"> lib/services/input.sh </strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9d9c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">这里我们有一个变量<code class="fe ns nt nu nv b">_key_input</code>，它用来存储从终端的标准输入接收到的最后一个键，以及一个方便的转义符引用，它将用来从输入中过滤掉这些键。</p><p id="1cb8" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated"><code class="fe ns nt nu nv b">input_init</code>功能使用<code class="fe ns nt nu nv b">stty</code>命令配置终端，以接收原始输入、回显输入字符、启用信号中断和控制流、将读取超时设置为<code class="fe ns nt nu nv b">0</code>并将管道错误设置为<code class="fe ns nt nu nv b">/dev/null</code>。</p><blockquote class="oe of og"><p id="d528" class="lu lv oh lw b lx mw ju lz ma mx jx mc oi my me mf oj mz mh mi ok na mk ml mm im bi translated">有关<code class="fe ns nt nu nv b">stty</code>命令的更多信息，请参见<a class="ae nb" href="https://www.computerhope.com/unix/ustty.htm" rel="noopener ugc nofollow" target="_blank">该资源</a>。</p></blockquote><p id="fe21" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated"><code class="fe ns nt nu nv b">get_last_key</code>功能只是返回最后一次按下的键，而<code class="fe ns nt nu nv b">process_input</code>则完全如此，并处理键盘输入，从终端读取按键，并确定它是否是用于移动光标的有效方向键。这是通过使用<code class="fe ns nt nu nv b">read</code>命令从终端读取单个字符的<code class="fe ns nt nu nv b">_read_key</code>函数和过滤掉空字符串和转义序列的<code class="fe ns nt nu nv b">_parse_key</code>函数实现的，然后存储程序中其他控制器使用的最后一个按键press _key_input，例如驱动光标方向，我们接下来将对此进行研究。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="6a7d" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">光标处理</h2><p id="f592" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">用于管理屏幕光标的变量和函数可在文件<strong class="lw iu"> lib/services/cursor.sh </strong>中找到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9a03" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">首先，我们有两个变量用于存储光标的当前和先前位置，以及<code class="fe ns nt nu nv b">visible</code>变量，该变量将在时钟周期内切换，以将光标从完全可见变为有些“透明”。</p><blockquote class="oe of og"><p id="fdb9" class="lu lv oh lw b lx mw ju lz ma mx jx mc oi my me mf oj mz mh mi ok na mk ml mm im bi translated">光标的位置已被放置在<code class="fe ns nt nu nv b">5,5</code>的<code class="fe ns nt nu nv b">x/y</code>坐标处，这将使其靠近屏幕的左上方(如果需要，可以更改)。</p></blockquote><p id="52d6" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated"><code class="fe ns nt nu nv b">cursor_init</code>函数(程序初始化时调用)将本地函数<code class="fe ns nt nu nv b">_on_clock_tick</code>注册为程序时钟上的事件监听器。在每个时钟周期，光标将在两种可见性状态之间切换，产生标准的闪烁光标效果。</p><p id="0404" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">函数<code class="fe ns nt nu nv b">render_cursor</code>从主程序循环中被调用，它将使用<code class="fe ns nt nu nv b">_get_cursor_char</code>抓取光标的当前字符，并通过将字符传递到<code class="fe ns nt nu nv b">_draw_cursor</code>而将其绘制在屏幕上，T6又通过<code class="fe ns nt nu nv b">_color_cursor</code>添加颜色，然后将彩色光标传递到<code class="fe ns nt nu nv b">_draw_chars</code>，我们将在下一个文件中对其进行检查。</p><p id="65f8" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">我们检查的程序的最后一部分(输入控制器)调用了函数<code class="fe ns nt nu nv b">parse_direction </code>,以确定光标移动的方向，并更新光标的本地x/y坐标。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="2651" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">屏幕控制器</h2><p id="2ccf" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">示例项目中的最后一个文件是屏幕控制器，位于文件<strong class="lw iu">lib/services/screen . sh:</strong>中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="98f3" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">该文件管理终端屏幕本身的各个方面，并包含几个用于跟踪屏幕当前状态的变量。变量<code class="fe ns nt nu nv b">_screen_updated</code>是一个用来设置和检查屏幕是否已经更新的标志，而<code class="fe ns nt nu nv b">_screen</code>是以行和列的形式存储屏幕的大小，将用来打印屏幕大小给用户。</p><p id="ac94" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">第一次运行程序时调用<code class="fe ns nt nu nv b">screen_init</code>函数，通过清除屏幕、存储当前屏幕尺寸的参考、初始化项目中使用的自定义光标，然后打印隐藏默认终端光标的转义序列<code class="fe ns nt nu nv b">\033[?25l</code>来初始化屏幕。</p><p id="1ffe" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">使用<code class="fe ns nt nu nv b">screen_resized</code>检查确定屏幕是否已调整大小，该检查将检查屏幕的当前行和列是否等于先前存储的值。<code class="fe ns nt nu nv b">render_init</code>函数检查屏幕是否已经更新，并调用<code class="fe ns nt nu nv b">clear</code>以便用新内容再次渲染。</p><p id="cc15" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">函数<code class="fe ns nt nu nv b">_draw_chars</code>由希望绘制到屏幕上的程序的其他部分使用(如本例中的光标)，通过打印一个带有直接写入转义序列<code class="fe ns nt nu nv b">\033</code>的字符串，后跟所需的x/y坐标和要打印的字符。</p><p id="81c1" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">如果设置了全局<code class="fe ns nt nu nv b">DEBUG</code>标志，则在主程序循环中的每个渲染周期调用<code class="fe ns nt nu nv b">print_debug</code>函数，并依次调用函数在右上角打印屏幕尺寸，在左上角打印程序PID，在顶部中间打印最后一次按下的键。这些函数依靠助手<code class="fe ns nt nu nv b">str_length</code>对屏幕大小和要打印的字符串长度进行计算，这样它们就会呈现在正确的位置。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="a1c7" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h2><p id="f438" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">这个项目演示了如何使用简单的Bash脚本在终端中创建一个简单的类似GUI的界面，消除了在系统上安装额外的编译器或解释器的需要，并且是Bash脚本编写中的一个有趣的练习，演示了Bash脚本编写环境是多么强大。更多只使用Bash就能完成的任务示例，请参见<a class="ae nb" rel="noopener ugc nofollow" target="_blank" href="/intro-to-bash-scripting-95c5fbc2dcef">Bash脚本简介</a>。</p><p id="b65c" class="pw-post-body-paragraph lu lv it lw b lx mw ju lz ma mx jx mc lh my me mf ll mz mh mi lp na mk ml mm im bi translated">感谢您的阅读，祝您的下一个项目好运！</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><blockquote class="ol"><p id="e856" class="om on it bd oo op oq or os ot ou mm dk translated">肯尼斯·雷利(<a class="ae nb" href="https://twitter.com/8_bit_hacker" rel="noopener ugc nofollow" target="_blank"> 8_bit_hacker </a>)是<a class="ae nb" href="https://lvl-up.tech" rel="noopener ugc nofollow" target="_blank"> LevelUP </a>的CTO</p></blockquote></div></div>    
</body>
</html>