<html>
<head>
<title>JavaScript Fundamentals: Fetching Data from a server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:从服务器获取数据</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-fundamentals-fetching-data-from-a-server-100ee464231c?source=collection_archive---------2-----------------------#2019-07-29">https://itnext.io/javascript-fundamentals-fetching-data-from-a-server-100ee464231c?source=collection_archive---------2-----------------------#2019-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/588148c439ae04b270595dc75672c830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzgCX8b5olt1Wb8pLbjyWg.png"/></div></div></figure><p id="9a28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将了解如何从服务器检索数据。现代网站和应用程序需要能够无缝地做到这一点——也就是说，更新网页的各个部分，而不需要重新加载整个页面。我们将着眼于使这成为可能的两种技术:<strong class="kd iu"> XMLHttpRequest </strong>和<strong class="kd iu"> Fetch API </strong>。</p><p id="fb27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章是上一篇文章的继续:<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/javascript-fundamentals-understanding-apis-3552c822c3e8">理解API</a>。如果您是使用API的新手，一定要先检查一下！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="6824" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓想要了解最新的web开发吗？T11】🚀<em class="lh">想要将最新消息直接发送到您的收件箱吗？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</em></p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae kz" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a4ef" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">老办法..</h1><p id="e8c0" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">使用旧方法在web上加载页面非常简单——您可以向服务器发送一个网站请求，如果没有任何问题，组成页面的任何资源都会被下载并显示在您的计算机或设备上。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/13167aa146c918bca75989c1f90eceae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Ezh9mg-b1KrlBtQO9HAkUA.png"/></div></figure><p id="3942" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是多年来网站的工作方式。然而，它有许多缺陷..每当您想要更新页面的任何部分时，例如，显示一组新的产品或提交一个表单，整个页面都必须重新加载。这种做法非常耗费资源，导致UX很差，尤其是当页面变得越来越复杂的时候。</p><h1 id="6e79" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">解决方案:AJAX</h1><p id="608b" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">随着允许网页请求小块数据(如HTML、XML、JSON或纯文本)并仅在需要时显示它们的技术的出现，这个问题得到了解决。</p><p id="3766" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是通过使用像<code class="fe mv mw mx my b">XMLHttpRequest</code>或Fetch API这样的API来实现的。这些技术允许网页直接处理对服务器上可用的特定资源的HTTP请求，并在显示结果数据之前根据需要格式化结果数据。</p><p id="5325" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个技巧就是所谓的<strong class="kd iu">【Ajax】</strong>，或者说<strong class="kd iu"> A </strong>同步<strong class="kd iu">J</strong>avaScript<strong class="kd iu">A</strong>nd<strong class="kd iu">X</strong>ML。最初它主要使用<code class="fe mv mw mx my b">XMLHttpRequest</code>来请求XML数据(因此有了“and XML”)。然而，现在你更有可能使用<code class="fe mv mw mx my b">XMLHttpRequest</code>或Fetch来请求JSON——但是结果还是一样，所以术语“Ajax”被保留了下来。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5c9dc3e97669f8fe251436fc96aa0032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2Hb5CkV952pY03E1vAbVw.png"/></div></div></figure><p id="5d70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从概念上讲，Ajax涉及使用web API作为代理来更智能地请求数据，而不仅仅是让浏览器重新加载整个页面。</p><p id="406b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在几乎每一个主要网站上看到它的运行。例如，当你在YouTube上播放一个新视频时，你会看到导航、页眉和页脚部分并没有刷新——只有包含视频的部分。</p><p id="0b7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">为什么这很重要？</strong></p><ul class=""><li id="f959" class="na nb it kd b ke kf ki kj km nc kq nd ku ne ky nf ng nh ni bi translated">页面更新要快得多&amp;你等待页面刷新的时间会更少，所以网站感觉更快，响应更快(页面速度对Google排名和SEO也很重要！).</li><li id="6fd8" class="na nb it kd b ke nj ki nk km nl kq nm ku nn ky nf ng nh ni bi translated">每次更新下载的数据更少，意味着浪费的带宽更少。虽然这在台式机上不是一个大问题，但在移动设备上却是一个大问题，尤其是在没有高速互联网的发展中国家。</li></ul><h1 id="48ad" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">创建Ajax请求</h1><p id="59a9" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在这一节中，我们将首先使用一个<code class="fe mv mw mx my b">XMLHttpRequest</code>然后获取来执行一个Ajax请求。</p><h1 id="4ca8" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">XMLHttpRequest</h1><p id="3116" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">一个<code class="fe mv mw mx my b">XMLHttpRequest</code>(通常缩写为<strong class="kd iu"> XHR </strong>)现在实际上是一项相当古老的技术——它是由微软在90年代发明的，并且一直沿用至今。</p><p id="03fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要创建一个XHR请求，首先需要使用<code class="fe mv mw mx my b">XMLHttpRequest()</code>构造函数创建一个新的请求对象。您可以随意称呼这个对象，在我们的演示中，我们称它为<code class="fe mv mw mx my b">xhr</code>。像这样:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="6513" class="ns lj it my b gy nt nu l nv nw">let xhr = new XMLHttpRequest(); </span></pre><p id="f48f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是使用<code class="fe mv mw mx my b">open()</code>方法初始化它。这里我们指定使用什么HTTP请求方法从网络请求资源，以及它所在的URL。这里我们将使用<code class="fe mv mw mx my b">GET </code>方法，并将URL设置为一个<code class="fe mv mw mx my b">url</code>变量(它应该将地址存储为字符串)。</p><p id="a646" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将它添加到上一行的下方:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="a230" class="ns lj it my b gy nt nu l nv nw">xhr.open('GET', url);</span></pre><p id="cbe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将预期的响应类型设置为<code class="fe mv mw mx my b">text</code>。这并不是绝对必要的，因为默认情况下XHR会返回文本——但是养成这个习惯是个好主意，因为将来你肯定会获取其他类型的数据！现在我们补充一下:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="1c13" class="ns lj it my b gy nt nu l nv nw">xhr.responseType = 'text';</span></pre><p id="85ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当我们从网络获取资源时，我们都在执行异步操作。这意味着您必须等待该操作完成(当资源从网络返回时)，然后才能对该响应做任何事情，否则将会抛出一个错误。有了XHR，我们可以使用<code class="fe mv mw mx my b">onload</code>事件处理程序来处理这个问题——它在<code class="fe mv mw mx my b">load</code>事件触发时运行(在响应返回后)。响应数据将在XHR请求对象的<code class="fe mv mw mx my b">response</code>属性中可用。</p><p id="be25" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来我们创建我们的函数来处理<code class="fe mv mw mx my b">onload</code>事件&amp;(在本例中)显示我们的<code class="fe mv mw mx my b">xhr.status </code> &amp; <code class="fe mv mw mx my b">xhr.response</code>值:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="e89d" class="ns lj it my b gy nt nu l nv nw">xhr.onload = function() {<br/>  alert(`Loaded: ${xhr.status} ${xhr.response}`);<br/>};</span></pre><p id="97cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要一个<code class="fe mv mw mx my b">send()</code>方法来运行请求:</p><p id="a54e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mv mw mx my b">xhr.send();</code></p><h1 id="6459" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">取得</h1><p id="b7bf" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">Fetch API是一个现代的替代品，可以作为XHR的替代品。它使异步HTTP请求在JavaScript中变得容易。</p><p id="bb2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看一个语法的基本例子:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="6d91" class="ns lj it my b gy nt nu l nv nw">fetch(url) // Call the fetch function passing the url of the API as a parameter<br/>.then(function() {<br/>    // Your code for handling the data you get from the API<br/>})<br/>.catch(function() {<br/>    // This is where you run code if the server returns any errors<br/>});</span></pre><p id="1ee3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里所做的就是获取我们想要的URL，默认情况下fetch使用GET方法——这就是我们在本例中想要的！</p><p id="f314" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看更多的样本代码:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="a4f2" class="ns lj it my b gy nt nu l nv nw">fetch('http://example.com/songs.json')<br/>  .then(function(response) {<br/>    return response.json();<br/>  })<br/>  .then(function(myJson) {<br/>    console.log(JSON.stringify(myJson));<br/>  });</span></pre><p id="af8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们从URL获取一个JSON文件，然后将其打印到控制台。<code class="fe mv mw mx my b">fetch()</code>最简单的用法是接受一个参数——您想要获取的资源的路径——并返回一个包含响应的承诺(以JavaScript对象的形式)。</p><p id="b322" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了从响应中提取JSON主体内容，我们使用了<code class="fe mv mw mx my b">JSON.stringify(myJson) </code>方法。然后，我们可以将响应对象转换为可以与之交互的对象。</p><h1 id="cb8b" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">履行承诺</h1><p id="50cb" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">像许多现代JavaScript APIs一样，Fetch使用承诺。虽然一开始他们有点困惑，但现在不要太担心。你会习惯的！</p><p id="9f54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看与我们的获取请求相关的承诺结构:</p><pre class="mm mn mo mp gt no my np nq aw nr bi"><span id="3c53" class="ns lj it my b gy nt nu l nv nw">fetch('http://example.com/songs.json')<br/>  .then(function(response) {<br/>    return response.json();<br/>  })<br/>  .then(function(myJson) {<br/>    console.log(JSON.stringify(myJson));<br/>});</span></pre><p id="bad2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一行是“获取位于我们的URL的资源”(<code class="fe mv mw mx my b">fetch('http://example.com/songs.json')</code>)和“然后在承诺完成时运行指定的函数”(<code class="fe mv mw mx my b">.then(function() { ... })</code>)。“解决”是指“在未来的某个时间点完成执行指定的操作”。</p><p id="d660" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，指定的操作是从我们指定的URL获取资源(使用HTTP请求)，并返回响应让我们做一些事情。</p><p id="5cc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，传递给<code class="fe mv mw mx my b">then()</code>的函数是一段不会立即运行的代码。相反，当响应被返回时，它将在将来的某个时间点运行。</p><h2 id="2f46" class="ns lj it bd lk nx ny dn lo nz oa dp ls km ob oc lw kq od oe ma ku of og me oh bi translated">那么应该使用哪种技术呢？</h2><p id="e544" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">XHR已经存在很长时间了，并且有很好的跨浏览器支持。另一方面，Fetch和Promises是web平台的新成员，尽管它们在除Internet Explorer之外的所有浏览器中都得到了很好的支持。</p><p id="c399" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要支持旧的浏览器，那么XHR解决方案可能更好。然而，如果你正在做一个更进步的项目，并且不担心旧的浏览器，那么Fetch将是一个不错的选择。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="387c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lh">你准备好让你的JavaScript技能更上一层楼了吗？</em> </strong> <em class="lh">今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae kz" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lh">JavaScript掌握完全指南</em> </a> <em class="lh">带你从零到英雄！</em></p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated"><em class="on">现已上市！👉</em><a class="ae kz" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="5e5b" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">结论</h1><p id="2f55" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">就是这样！我们研究了如何开始使用AJAX，使用XHR和Fetch等技术从服务器检索数据。我们看了每一个的基本例子！希望现在您已经掌握了每一项，可以开始将异步操作合并到您的代码中了！</p><p id="3969" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以在Medium上<a class="ae kz" href="https://medium.com/@timothyrobards?source=post_page---------------------------" rel="noopener">关注我</a>。我也在<a class="ae kz" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="9192" class="li lj it bd lk ll mq ln lo lp mr lr ls lt ms lv lw lx mt lz ma mb mu md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在我的个人博客上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在撰写我的<a class="ae kz" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业完整指南</a>。坏消息是它还不可用！但是如果这是你可能感兴趣的东西，你可以<a class="ae kz" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用的时候会通知你👍</a></p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>