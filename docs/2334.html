<html>
<head>
<title>KEDA — Kubernetes Based Event Driven Autoscaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KEDA —基于Kubernetes的事件驱动自动缩放</h1>
<blockquote>原文：<a href="https://itnext.io/keda-kubernetes-based-event-driven-autoscaling-48491c79ec74?source=collection_archive---------7-----------------------#2019-05-07">https://itnext.io/keda-kubernetes-based-event-driven-autoscaling-48491c79ec74?source=collection_archive---------7-----------------------#2019-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7bdfd1fcf75aa3cfa2e7d2acc0fbc1f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Az4ljaRuQg6Y0edi-hy8yQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">KEDA Kubernetes上的事件驱动自动缩放</figcaption></figure><div class=""/><p id="b4a0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">事件驱动的计算并不是一个新想法；数据库领域的人们已经使用数据库触发器很多年了。概念很简单:无论何时添加、更改或删除数据，都会触发一个事件来执行各种功能。新的特点是这些类型的事件和触发器在自动扩展、自动补救、容量规划等其他领域的应用程序中激增。事件驱动架构的核心是对系统上的各种事件做出反应，并相应地采取行动。</p><p id="6603" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">自动伸缩(在某种程度上是一种自动化)已经成为几乎所有云平台中不可或缺的组件，微服务<em class="la">又名</em>容器也不例外。事实上，以灵活和解耦设计著称的容器最适合自动伸缩，因为它们比虚拟机更容易创建。</p><blockquote class="lb lc ld"><p id="c477" class="kc kd la ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="jf">为什么要自动缩放？？？？</em></p></blockquote><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lh"><img src="../Images/b179ca8f433683f892e6421fbd7affc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2nH6SJPjF5Mp-HEF"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">容量扩展—自动扩展</figcaption></figure><p id="5f22" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可伸缩性是现代基于容器的应用程序部署要考虑的最重要的方面之一。随着容器编排平台的进步，设计可伸缩性解决方案变得前所未有的简单。该工具被称为基于Kubernetes的事件驱动自动缩放，或KEDA(用操作框架构建)，允许用户在Kubernetes上构建自己的事件驱动应用程序。KEDA处理触发器以响应其他服务中发生的事件，并根据需要扩展工作负载。KEDA使容器能够直接使用来自源的事件，而不是通过HTTP路由。</p><p id="a2e6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">KEDA可以在任何公共或私有云和本地环境中工作，包括Azure Kubernetes服务和Red Hat的OpenShift。有了这个，开发者现在也可以使用微软的无服务器平台Azure Functions，并将其作为一个容器部署在Kubernetes集群中，包括在OpenShift上。</p><p id="ad39" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这看起来很简单，但是假设每天都有大量事务处理，真的有可能像下面这样手动管理应用程序(Kubernetes部署)的数量吗？？？</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lm"><img src="../Images/3a1cb5db8bea416b671c4a28c492a365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2XDszqqamBKyuiHh"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在生产中管理自动缩放</figcaption></figure><p id="5ec4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">KEDA将自动检测新部署并开始监控事件源，利用实时指标来推动扩展决策。</p><h1 id="c5cb" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">KEDA</h1><p id="9759" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">作为Kubernetes上的一个组件，KEDA提供了两个关键角色:</p><ol class=""><li id="71e0" class="mq mr jf ke b kf kg kj kk kn ms kr mt kv mu kz mv mw mx my bi translated">Scaling Agent:激活和停用部署的代理，用于扩展到已配置的副本，并在无事件时将副本缩减为零。</li><li id="7d22" class="mq mr jf ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">Kubernetes Metrics Server:一个Metrics Server，公开了大量与事件相关的数据，如队列长度或流延迟，允许基于事件的伸缩，使用特定类型的事件数据。</li></ol><p id="0245" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Kubernetes Metrics Server与Kubernetes HPA(水平pod自动缩放器)通信，以推动Kubernetes部署副本的横向扩展。然后由部署直接从源中消费事件。这保留了丰富的事件集成，并使完成或放弃队列消息等手势能够开箱即用。</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/9fb7bbfc79194243539af4dd8dbfee04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BMj4z_nTnPRWDBW4"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">KEDA建筑</figcaption></figure><h1 id="7db3" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">攀登者</h1><p id="fc6f" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">KEDA使用“定标器”来检测是否应该激活或停用部署(定标),然后将其输入特定的事件源。今天支持多个带有特定支持触发器的“缩放器”，如Kafka (trigger: Kafka Topics)、rabbit MQ(trigger:rabbit MQ Queues)以及更多。</p><p id="bd45" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除此之外，KEDA与Azure Functions工具集成，本机扩展Azure特定的缩放器，如Azure存储队列、Azure服务总线队列、Azure服务总线主题。</p><h1 id="fd7a" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">ScaledObject</h1><p id="aa24" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">ScaledObject被部署为Kubernetes CRD(自定义资源定义),它提供了将部署与事件源同步的功能。</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/fdd31c24937c4d32b4b65815aeedf7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L2z86cZNQOvtE-Vy"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">ScaledObject自定义资源定义</figcaption></figure><p id="28fb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">部署为CRD后，ScaledObject可以采用如下配置:</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/f78c1661cbb7205852ce59047058efba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d5Iv5n7Cw_1dgNna"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">ScaledObject规格</figcaption></figure><p id="a3f8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如上所述，支持不同的触发器，下面显示了一些示例:</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/59faecc8e5cc0219279aa34d966e3cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eilcG_3ScnBqcaFs"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">ScaledObject的触发器配置</figcaption></figure><h1 id="8f00" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">活动中的事件驱动自动扩展—内部Kubernetes集群</h1><h1 id="da57" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">KEDA部署在库伯内特斯</h1><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/3b7dbeaaeff7314388dee0b287d5c10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rHZJuZrmOTemGfyL"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">KEDA控制器— Kubernetes部署</figcaption></figure><h1 id="e19d" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">带KEDA的RabbitMQ队列缩放器</h1><p id="6a86" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">RabbitMQ是一个消息排队软件，称为消息代理或队列管理器。简单说；这是一个可以定义队列的软件，应用程序可以连接到队列，并在其上传输消息。</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/f21c809ad16222114e593c1096c5c489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FHptioTr5M3swgOb"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RabbitMQ架构</figcaption></figure><p id="0037" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下面的例子中，RabbitMQ服务器/发布者被部署为Kubernetes上的“statefulset ”:</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/4f2b0147a5cbffc91407bd32e70f4512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vauwLnXWguRW-a4E"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">兔子q</figcaption></figure><p id="5935" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RabbitMQ消费者被部署为接受由RabbitMQ服务器生成的队列并模拟执行的部署。</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/9ebbc105cb11674ee9735afe3b9236dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y9dbYcgDkuL73fz-"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RabbitMQ消费者部署</figcaption></figure><h1 id="32bc" class="ln lo jf bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用RabbitMQ触发器创建ScaledObject</h1><p id="f70c" class="pw-post-body-paragraph kc kd jf ke b kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz ij bi translated">除了上面的部署，还提供了一个ScaledObject配置，该配置将由上面创建的KEDA CRD通过在Kubernetes上安装KEDA进行翻译。</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/cd14a2640b0b52e4bce4004bb587ba01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wGUAkyF8ie0-sBtt"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">带有RabbitMQ触发器的ScaledObject配置</figcaption></figure><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/f5fb1f52a0013a4b9f90f14d9f321210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cTg8gTtSsJLPL-oM"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Kubernetes上的ScaledObject</figcaption></figure><p id="3b7c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦创建了ScaledObject，KEDA控制器就会自动同步配置，并开始监视上面创建的rabbitmq-consumer。KEDA无缝创建具有所需配置的HPA(水平机架自动缩放器)对象，并根据ScaledObject提供的触发规则横向扩展副本(在本例中，队列长度为“5”)。因为还没有队列，所以rabbitmq-consumer部署副本被设置为零，如下所示。</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/39b10d66e26daba701645df657e217ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_VL30D4U_sPuWug5"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Kubernetes上的KEDA控制器</figcaption></figure><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/969e9a5c6fdc3ae6f7027a34a02afd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T_h5EC_isImHcRzD"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">KEDA发明的水平吊舱自动定标器</figcaption></figure><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/107cffe364ddaf76779b768b9057a367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CO-NO82WCtcKMftN"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">RabbitMQ使用者-副本:0</figcaption></figure><p id="a40d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用上述ScaledObject和HPA配置，KEDA将根据从事件源收到的信息驱动容器向外扩展。使用下面的“Kubernetes-Job”配置发布一些队列，这会产生10个队列:</p><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/1a71f9178e164f14a2ee3c9c3e2b41b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YvKevu7hqz6APcaC"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">kubernetes-发布队列的作业</figcaption></figure><p id="fee4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">KEDA自动将当前设置为“零”个副本的“rabbitmq-consumer”扩展为“两个”副本，以满足队列需求。</p><h2 id="8454" class="nr lo jf bd lp ns nt dn lt nu nv dp lx kn nw nx mb kr ny nz mf kv oa ob mj oc bi translated"><em class="od">发布10个队列— RabbitMQ消费者扩展到两个副本</em>:</h2><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/a2690bdf1c8b2e19f6333d5f794db0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ec3cPLVxKFQHcjGH"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">10个队列— 2个副本</figcaption></figure><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi of"><img src="../Images/7660ca64c9ff8a0978f127e30edbf7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SRl6wVv7iE76MGus"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">缩放至:2-向下缩放:0</figcaption></figure><h2 id="4b0d" class="nr lo jf bd lp ns nt dn lt nu nv dp lx kn nw nx mb kr ny nz mf kv oa ob mj oc bi translated"><em class="od">发布200个队列— RabbitMQ消费者扩展到四十(40)个副本:</em></h2><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/dd1f9e336cf36a277ec3d6987421e804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nTD0mLz9HXIlsZeB"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">200个队列— 40个副本</figcaption></figure><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/3acb311705b1e3270b7413f0dec848b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IzVao-e3fYpyPz9W"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">缩放至:40-向下缩放:0</figcaption></figure><h2 id="3910" class="nr lo jf bd lp ns nt dn lt nu nv dp lx kn nw nx mb kr ny nz mf kv oa ob mj oc bi translated"><em class="od">发布1000个队列— RabbitMQ消费者扩展到100个副本，最大副本数设置为100个</em>:</h2><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/aba6ec18a250280d4cfd72444d1b44e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wTyxivw5RSgDmjOZ"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">1000个队列— 100个副本</figcaption></figure><figure class="li lj lk ll gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/9e1c44aefc1d88ee4f005bbe2e46e536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TX2aAi5xmpdeGgQYsRsDew.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">缩放至:100-向下缩放:0</figcaption></figure></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="4acc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">KEDA提供了一个类似FaaS的事件感知扩展模型，其中Kubernetes部署可以根据需求和智能动态扩展到零，而不会丢失数据和上下文。KEDA还为Azure Functions提供了一个新的托管选项，可以作为一个容器部署在Kubernetes集群中，将Azure Functions编程模型和规模控制器带到任何Kubernetes实现中，无论是在云中还是在内部。</p><p id="4b98" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">KEDA也为Kubernetes带来了更多的活动来源。KEDA有很大的潜力成为生产级Kubernetes部署中的必需品，因为未来会继续添加更多的触发器，或者为应用程序开发人员提供框架，以根据应用程序的性质设计触发器，从而使自动伸缩成为应用程序开发中的嵌入式组件。</p></div></div>    
</body>
</html>