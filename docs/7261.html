<html>
<head>
<title>Inspecting and Understanding k8s Service Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检查和了解k8s服务网络</h1>
<blockquote>原文：<a href="https://itnext.io/inspecting-and-understanding-service-network-dfd8c16ff2c5?source=collection_archive---------0-----------------------#2022-08-03">https://itnext.io/inspecting-and-understanding-service-network-dfd8c16ff2c5?source=collection_archive---------0-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="778c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">服务带来稳定</h1><p id="9417" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个<strong class="kn ir"> <em class="lj"> Kubernetes服务对象</em> </strong>创建了一个稳定的网络端点，它位于一组pod的前面，并对它们之间的流量进行负载平衡。</p><p id="c070" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">您总是将一个<a class="ae lp" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> <em class="lj">服务</em> </a>放在一组做相同工作的pod前面(它们运行相同的容器映像)。例如，您可以将一个服务放在web前端组件的前面，将另一个放在身份验证组件的前面。你永远不要把一个服务放在做不同工作的pod前面(有不同的容器映像在其中运行)。</p><p id="7cfb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">客户端与服务对话，服务负载平衡到pod的流量。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/2c4b8f13c0ccc0e1c97df63aa00238e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w4m59yqMW5td32Tf"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图一</figcaption></figure><p id="0598" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在上图中，<strong class="kn ir">底部的窗格可以随着<em class="lj">缩放</em>、<em class="lj">更新</em>、<em class="lj">故障</em>以及其他事件的发生而来去，并且服务保持跟踪。但是，服务的名称、IP和端口永远不会改变。</strong></p><h2 id="8090" class="mg jo iq bd jp mh mi dn jt mj mk dp jx kw ml mm kb la mn mo kf le mp mq kj mr bi translated">剖析Kubernetes服务</h2><p id="3ddd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将Kubernetes服务想象成具有前端和后端是很有用的:</p><ul class=""><li id="9f3c" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li mx my mz na bi translated">前端:名称、IP、永不改变的端口</li><li id="7169" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">后端:与标签选择器匹配的窗格</li></ul><p id="6e57" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">前端<strong class="kn ir">稳定</strong>和<strong class="kn ir">可靠</strong>。这意味着<em class="lj">名称</em>、<em class="lj"> IP、</em>和<em class="lj">端口号</em>保证在服务的整个生命周期内不会改变。服务前端的稳定特性也意味着您无需担心客户端上的陈旧条目，这些条目缓存DNS结果的时间超过了标准建议的时间。</p><p id="8ae4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">后端是高度动态的，它将对集群中与服务被配置为寻找的一组<em class="lj">标签</em>相匹配的所有pod进行流量负载平衡。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ng"><img src="../Images/fa4382a9efd8d1e2896b6b7a8b18c1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uFG3mMUBlpoKIhJJ"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图2</figcaption></figure><p id="dda1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">负载平衡</em>在这种情况下是简单的L4循环负载平衡。这在“连接”级别起作用，在此级别，通过同一<em class="lj">连接</em>的所有请求都发送到同一个Pod。这意味着两件事:</p><ol class=""><li id="dfce" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li nh my mz na bi translated">来自同一个浏览器的多个请求将总是命中同一个<em class="lj">窗格</em>。这是因为浏览器通过单个<em class="lj">连接</em>发送所有请求，该连接使用keepalives保持打开。通过像<strong class="kn ir"> curl </strong>这样的工具发出的请求会为每个请求打开一个新的<em class="lj">连接</em>，因此会命中不同的pod。</li><li id="dc0a" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li nh my mz na bi translated">负载平衡不知道<em class="lj">应用层</em> (L7)概念，如HTTP头和基于cookie的会话相似性。</li></ol><h2 id="9d76" class="mg jo iq bd jp mh mi dn jt mj mk dp jx kw ml mm kb la mn mo kf le mp mq kj mr bi translated">概述介绍</h2><p id="a3fa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">应用程序在<em class="lj">容器</em>中运行，容器又在<em class="lj">容器</em>中运行。Kubernetes集群中的所有Pod都有自己的IP地址，并连接到同一个平面<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/steps-to-emulate-pod-network-1c34209d0f53"> <em class="lj"> Pod网络</em> </a>。这意味着所有的pod可以直接与所有其他的pod对话。但是，pod是不可靠的，会随着扩展操作、滚动更新、回滚、故障和其他事件的发生而变化。幸运的是，Kubernetes提供了一个稳定的网络端点，称为<strong class="kn ir"> <em class="lj">服务</em> </strong>，它位于一组相似的<em class="lj"> Pods </em>的前面，并提供一个稳定的名称、IP和端口。客户端连接到<em class="lj">服务</em>并且服务负载平衡到pod的流量。</p><h1 id="5832" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">服务注册和发现</h1><p id="d9f7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当一个新的<strong class="kn ir">服务</strong>被创建时，它被分配一个虚拟IP地址，称为<em class="lj">集群IP </em>。这是根据集群内部DNS中的服务名称自动注册的，并且会创建相关的端点对象(或端点片)来保存健康pod的列表，服务将对这些健康pod进行负载平衡。</p><p id="6575" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">同时，集群中的所有节点都配置有<a class="ae lp" href="https://phoenixnap.com/kb/iptables-tutorial-linux-firewall" rel="noopener ugc nofollow" target="_blank">iptables</a>/<a class="ae lp" href="https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/" rel="noopener ugc nofollow" target="_blank">IPVS</a>规则，这些规则侦听到该集群IP的流量，并将其重定向到真正的Pod IPs。下图总结了该流程，尽管某些事件的顺序可能略有不同。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/ad53f24ae7e6cc9279fff5f49eef2576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iPxP8YHIlUVvFrBv"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图3</figcaption></figure><p id="745f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当一个单元需要连接到另一个单元时，它通过服务来完成。它向群集DNS发送查询以将服务名称解析为其ClusterIP，然后向ClusterIP发送流量。这个集群IP位于一个叫做<em class="lj">服务网络的特殊网络上。</em>然而，没有到<em class="lj">服务网络</em>的路由，因此Pod将流量发送到其默认网关。这被转发到Pod正在运行的节点上的接口，并最终转发到该节点的默认网关。作为此操作的一部分，节点的内核捕获地址并重写数据包报头中的目的IP字段(使用iptables/ipv ),以便它现在转到健康Pod的IP。</p><p id="ec08" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下图对此进行了总结。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/f6a0d96278b78c3996ae4ed40df87cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VU8H84N4YttOzUH"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图4</figcaption></figure><h1 id="2501" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">测试配置</h1><p id="9352" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们学习了很多理论来理解服务网络，现在让我们检查一个Kubernetes集群的实际服务网络。</p><p id="d551" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为此，请配置一个3节点GKE集群。Pod和服务网络配置:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ni"><img src="../Images/2ba862e60c684089cbf36ea09b6d302a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vURGxlodRd4w36J4IRtKow.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图5</figcaption></figure><p id="2938" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后使用cloud shell上的<em class="lj"> kubectl </em>连接到集群。授权并检查集群配置。</p><pre class="lr ls lt lu gt nj nk nl nm aw nn bi"><span id="e13c" class="mg jo iq nk b gy no np l nq nr">kubectl get pods -A<br/>kubectl get nodes<br/>kubectl get node -o custom-columns=NAME:'{.metadata.name}',\<br/>PrivateIP:'{.status.addresses[?(@.type == "InternalIP")].address}'</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ns"><img src="../Images/98651420d90debd696ead07f3d890d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRg5KbZyhufSrdhZShhBeg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图6</figcaption></figure><p id="a2b4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们将通过ssh连接到GKE的worker节点，并查看当创建服务或扩展与服务相关的部署时，kube-proxy如何更新iptables/ipvs规则。</p><p id="7f9e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先，我们必须创建一个部署和一个服务来公开部署的容器。</p><p id="5953" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们创建一个包含3个副本的部署</p><pre class="lr ls lt lu gt nj nk nl nm aw nn bi"><span id="825d" class="mg jo iq nk b gy no np l nq nr">#on cloudshell with kubectl access<br/>kubectl apply -f <a class="ae lp" href="https://k8s.io/examples/controllers/nginx-deployment.yaml" rel="noopener ugc nofollow" target="_blank">https://k8s.io/examples/controllers/nginx-deployment.yaml</a></span><span id="f8c6" class="mg jo iq nk b gy nt np l nq nr">kubectl get deployment -o wide<br/>kubectl get pods -o wide<br/>kubectl get pods -o custom-columns=NAME:'{.metadata.name}',\<br/>HOSTIP:'{.status.hostIP}',PODIP:'{.status.podIP}'</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nu"><img src="../Images/4f3a4022e12e87ab5358354d38237058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2zsKYX67A4JiZ1xPpchkQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图7</figcaption></figure><p id="b13a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">pod由IP 192 . 168 . 0 . 6、192.168.1.6和192.168.2.5的所有3个不同工作节点创建</p><p id="35b6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">现在让我们创建一个集群IP类型的服务</strong></p><pre class="lr ls lt lu gt nj nk nl nm aw nn bi"><span id="f74b" class="mg jo iq nk b gy no np l nq nr">kubectl expose deployment nginx-deployment  --name=nginx-svc  --port=80 --target-port=80 --selector='app=nginx'<br/>kubectl get service</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nv"><img src="../Images/d5c4ab32764f24e1aaabb8cd9c0fb0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IK_ERuGWYjEWua89mdlV4A.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图8</figcaption></figure><p id="d53c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">使用集群IP 192.168.251.24创建的服务</p><h2 id="d812" class="mg jo iq bd jp mh mi dn jt mj mk dp jx kw ml mm kb la mn mo kf le mp mq kj mr bi translated"><strong class="ak">查看Kube-proxy配置</strong></h2><p id="b694" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kube-Proxy在<a class="ae lp" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GKE </a>中作为<a class="ae lp" href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/" rel="noopener ugc nofollow" target="_blank">静态吊舱</a>运行。</p><p id="187f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">到任何工作节点的ssh(连接到IP为10.128.0.4的节点)。部署nginx-deployment的pod是否在该节点上运行并不重要。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nw"><img src="../Images/f7261bc1de8ae6d2880855bf0d39f53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9TB_uQN4OVv36MFPs064g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图9</figcaption></figure><p id="8a5e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在查看kube-proxy日志时，我们看到由于kube-proxy启动命令中没有提到代理模式，因此默认(iptables)被认为是代理模式。</p><pre class="lr ls lt lu gt nj nk nl nm aw nn bi"><span id="99a9" class="mg jo iq nk b gy no np l nq nr"># grep "proxy mode"  /var/log/kube-proxy.log<br/>W0802 20:09:49.428959       1 server_others.go:565] Unknown proxy mode "", assuming iptables proxy</span></pre><p id="1ade" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">所以我们将研究iptables规则</strong>，因为这是kube-proxy使用的默认模式。</p><h1 id="8b5b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">通过</strong>查看<strong class="ak">iptables规则</strong>了解服务网络<strong class="ak"/></h1><h2 id="0b34" class="mg jo iq bd jp mh mi dn jt mj mk dp jx kw ml mm kb la mn mo kf le mp mq kj mr bi translated">普通集群IP服务</h2><blockquote class="nx ny nz"><p id="9f90" class="kl km lj kn b ko lk kq kr ks ll ku kv oa lm ky kz ob ln lc ld oc lo lg lh li ij bi translated">在群集内部IP上公开服务。选择该值将使服务只能从集群内部访问。这是默认的<code class="fe od oe of nk b">ServiceType</code>。</p></blockquote><p id="b298" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在一个worker节点(对于我来说是IP 10.128.0.4)上，尝试下面的命令来搜索与我们创建的服务相关的规则。让我们检查iptables“NAT”表并搜索“nginx-svc”(服务名)。</p><pre class="lr ls lt lu gt nj nk nl nm aw nn bi"><span id="1989" class="mg jo iq nk b gy no np l nq nr">iptables -t nat -L | grep -i nginx-svc</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi og"><img src="../Images/82918a40ff4719a902587441e50facd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19M1pHEDvra6fcjWY0JUsQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图10</figcaption></figure><p id="e16c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们看到很多信息，但是很难理解它们(尤其是当你不熟悉iptables的时候)</p><p id="44c7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">从<strong class="kn ir">预路由和输出</strong>的链中我们可以看到，所有进入或离开Pods的数据包进入链<strong class="kn ir">KUBE-服务</strong>作为起点。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oh"><img src="../Images/1d9aa37327d12cbe0861a6e0f53a1a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BH3g4mtdSpVhKHlmMX767g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图11.1</figcaption></figure><p id="554d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们首先看一下<strong class="kn ir"> KUBE服务链</strong>，因为它是服务包的入口点，匹配目的IP:端口并将包分派到相应的KUBE-SVC-*链。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oi"><img src="../Images/addbddeb219d209574417fe90356a32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L51Ho4iw_3DxAFHi3RY9Zw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图11.2</figcaption></figure><p id="1c67" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">由于<strong class="kn ir">KUBE-SVC-HL 5 lmxd 5 jfhqz 6 ln</strong>是下一个链条，我们将对其进行检查。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oj"><img src="../Images/9e70f22ed909323b3be9c109eba9f542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uMNeXgLmHKhLRmDXWCgvw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图12</figcaption></figure><p id="92a6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这个特殊的<strong class="kn ir">KUBE-SVC-HL 5 lmxd 5 jfhqz 6 ln</strong>链条中我们看到有四条规则:</p><ul class=""><li id="0d60" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li mx my mz na bi translated">第一种方法是，如果<strong class="kn ir">任何流量来自与“this”节点相关联的podCIDR外部，并且目的地是端口80 (http) </strong>处的nginx服务，则在数据包中添加一个Netfilter标记，带有此标记的数据包将在KUBE-邮政路由链的规则中被更改，以使用源网络地址转换(SNAT)，将节点的IP地址作为其源IP地址。考虑图12和图13。</li></ul><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ok"><img src="../Images/211fedabbcfeeb11cb34102236d96f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1amvBUde8SitYKDAKBFjQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图13</figcaption></figure><ul class=""><li id="21b0" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li mx my mz na bi translated"><strong class="kn ir"> KUBE-SVC-* </strong>充当负载平衡器，将数据包分发到KUBE-SEP-*链。<strong class="kn ir">KUBE-SEP-*的数量等于服务背后的端点数量(即运行pod的数量)，即三个</strong>。选择哪个KUBE-SEP-*是随机确定的。我们可以在图12中看到同样的情况。KUBE-SEP*规则是相似的，所以我们将只讨论一个。我们将在本文后面讨论“<strong class="kn ir">统计模式随机概率</strong>”。</li></ul><p id="514f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">KUBE-SVC-HL 5 lmxd 5 jfhqz 6 ln</strong>会随机向<strong class="kn ir"/>KUBE-SEP-7 ex 3 ym 24 af 6 H4 a 3和另外2条链调度数据包。</p><p id="60ae" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">每个KUBE-SEP-*链分别代表一个荚或终点。</strong></p><p id="5550" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">KUBE-SEP-7 ex 3 ym 24 af 6 H4 a 3有两条规则:</p><ol class=""><li id="e6b9" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li nh my mz na bi translated">向数据包添加网络过滤器标记，带有此标记的数据包将在KUBE-后路由链的规则中被更改。KUBE-马克-MASQ将数据包标记为稍后伪装(SNAT，因此该数据包看起来来自节点IP) <strong class="kn ir">用于离开在同一节点上调度的pod的数据包。</strong></li><li id="2a88" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li nh my mz na bi translated">第二个规则将所有数据包重定向到在目标端口(本例中为80)的同一节点上调度的pod的podIP</li></ol><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi ol"><img src="../Images/2b7d4833a49c5239f4ae1cd3e8b01cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CijDu4l8dgcyFmn6KeWO6g.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图14</figcaption></figure><p id="c788" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">类似的规则也适用于其他两个<strong class="kn ir"> KUBE-SEP-*链(图15) </strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi om"><img src="../Images/5ad389a4017dc48ca16870ee5e26ffa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9A7FaTqXypJtYhpDTBCIPw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图15</figcaption></figure><p id="d301" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">如果我们扩展部署并使副本计数从3变为4，将创建另一个KUBE-SEP-*链，并且对应于该链的规则将被添加到KUBE-SVC-HL5LMXD5JFHQZ6LN。</strong></p><h2 id="f512" class="mg jo iq bd jp mh mi dn jt mj mk dp jx kw ml mm kb la mn mo kf le mp mq kj mr bi translated">节点端口服务</h2><blockquote class="nx ny nz"><p id="806b" class="kl km lj kn b ko lk kq kr ks ll ku kv oa lm ky kz ob ln lc ld oc lo lg lh li ij bi translated">在一个静态端口上公开每个节点的IP上的服务(<code class="fe od oe of nk b">NodePort</code>)。一个<code class="fe od oe of nk b">ClusterIP</code>服务，<code class="fe od oe of nk b">NodePort</code>服务路由被自动创建。您将能够通过请求<code class="fe od oe of nk b">&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部联系<code class="fe od oe of nk b">NodePort</code>服务。</p></blockquote><p id="ec18" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">有两种类型的节点端口服务:</p><ul class=""><li id="1702" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li mx my mz na bi translated">默认服务(externalTrafficPolicy: Cluster)</li><li id="7bc9" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated">外部流量策略:本地</li></ul><p id="1a7e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们将讨论默认的节点端口服务(externalTrafficPolicy: Cluster)</p><p id="2709" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了进行测试，我更新了现有的服务，并使它的类型为“node port ”, node port为30010。</p><pre class="lr ls lt lu gt nj nk nl nm aw nn bi"><span id="c7ca" class="mg jo iq nk b gy no np l nq nr">kubectl edit service nginx-svc</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi on"><img src="../Images/77a037098ccba1299eec5a7851d249a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-CvuPQNsxYNlDAViCzWww.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图16</figcaption></figure><p id="ee1b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">从iptables的角度来看，两组链和规则分别添加到链rules服务和rules节点端口:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oo"><img src="../Images/69aeae70c69e6c41a4efac0dab2ac509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdmyZ7VQEtWATRD81IXOaw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图17</figcaption></figure><p id="5e5a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">关于KUBE服务链，如果在该链中没有类似KUBE-SVC*的匹配规则用于分组，则它退回到链中的最后一个规则，即KUBE节点端口。</p><p id="7f2b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">KUBE-节点端口表示所有访问端口30010的数据包进入KUBE-SVC-HL5LMXD5JFHQZ6LN链，在那里它们首先被SNAT-ed(目标KUBE-马克-MASQ ),然后被转发到KUBE-SEP*链以选择要路由到的pod。</strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi op"><img src="../Images/50cdac0c9a4612f4b11dd75f5e23d99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NYML7Bih1mEPs4IRKfSxg.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图18</figcaption></figure><h2 id="8dc1" class="mg jo iq bd jp mh mi dn jt mj mk dp jx kw ml mm kb la mn mo kf le mp mq kj mr bi translated">负载平衡器服务</h2><blockquote class="nx ny nz"><p id="f7b7" class="kl km lj kn b ko lk kq kr ks ll ku kv oa lm ky kz ob ln lc ld oc lo lg lh li ij bi translated">使用云提供商的(GCP)负载平衡器对外公开服务。外部负载平衡器路由到的<code class="fe od oe of nk b">NodePort</code>和<code class="fe od oe of nk b">ClusterIP</code>服务是自动创建的。</p></blockquote><p id="50a0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果我们将服务类型从NodePort更改为LoadBalancer，则iptables级别没有变化。<strong class="kn ir">它使用相同的iptables链，只是在“节点端口”前添加了一个OSI第4层(TCP)负载平衡器。</strong></p><h1 id="6eec" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">统计模式随机概率</h1><p id="0854" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了平衡可用端点之间的流量负载，iptables为KUBE-SVC*链中的每个KUBE-SEP*规则包含一个“统计模式随机概率xx.xxx”条款。</p><p id="0cf1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">iptables引擎是确定性的，将始终使用第一个匹配规则。在本例中，KUBE-SEP-7 ex 3 ym 24 af 6 H4 a 3(图18)将获得所有连接，但我们希望在可用端点之间实现负载平衡。</p><p id="d8f4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了解决这个问题，iptables包含了一个名为<strong class="kn ir"> statistic </strong>的模块，它可以根据一些统计条件跳过或接受一个规则。统计模块支持两种不同的模式:</p><ul class=""><li id="f1bf" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li mx my mz na bi translated"><code class="fe od oe of nk b">random</code>:根据概率跳过规则</li><li id="0e45" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li mx my mz na bi translated"><code class="fe od oe of nk b">nth</code>:基于循环算法跳过规则</li></ul><p id="1751" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">随机平衡</strong></p><p id="fd92" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">查看图18，<strong class="kn ir">请注意，定义了3种不同的概率，并非处处都是0.33。原因是规则是按顺序执行的。</strong></p><p id="3cb3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在概率为0.33的情况下，第一个KUBE-SEP*规则将在33%的时间里被执行，而在66%的时间里被跳过。</p><p id="3a7c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">概率为0.5时，第二个规则将有50%的时间被执行，50%的时间被跳过。但是，由于这个规则被放在第一个规则之后，所以它只在剩余的66%的时间里被执行。因此，该规则将仅应用于(剩余66%=33%中的50%)请求。</p><p id="d415" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">由于只有33%的流量达到最后一条规则，因此必须始终应用该规则。</p><p id="e941" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">如果我们将此部署的副本从3个扩展到4个，iptables层的服务配置端会有什么变化？</strong></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi oq"><img src="../Images/fa6217b20acd5f7adb5ff02da9116457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRPVN8PHx95lNb2hB6gCuw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图19</figcaption></figure><p id="24d9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">pod的数量增加意味着端点对象的数量增加。因此，KUBE-SVC*链中KUBE-SEP*规则的数量也将增加。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi or"><img src="../Images/fb7c3dc2f743e5c6e0f5549d1cf877e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8eDBzHAIZbOAtv8tmLS3Mw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">图20</figcaption></figure><p id="81c6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">比较图20和图18，现在第一KUBE-SEP*规则将在所有分组的25%上执行，第二规则将在剩余的75%时间的33%上执行，这也是总时间的25%。第三个将执行剩余50%次数的50%,最后一个将执行总次数的25%。</p><h1 id="daea" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们没有涵盖的事情</h1><p id="5c19" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本文中没有讨论某些服务配置:</p><ol class=""><li id="0068" class="ms mt iq kn b ko lk ks ll kw mu la mv le mw li nh my mz na bi translated">外部IP服务- <em class="lj">如果有路由到一个或多个集群节点的外部IP，Kubernetes服务可以在这些外部IP上公开。通过服务端口上的外部IP(作为目标IP)进入集群的流量将被路由到其中一个服务端点。</em></li><li id="6220" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li nh my mz na bi translated">会话相似性服务- <em class="lj"> Kubernetes支持基于客户端的会话相似性，会话相似性使得来自同一个客户端的请求总是被路由回同一个pod。</em></li><li id="c360" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li nh my mz na bi translated">没有端点服务-<em class="lj">cluster IP服务总是与后端pod相关联，它使用一个"</em> <strong class="kn ir"> <em class="lj">选择器</em> </strong> <em class="lj">"来选择后端pod，如果基于一个</em> <strong class="kn ir"> <em class="lj">选择器</em> </strong> <em class="lj">找到后端pod，Kubernetes将创建一个端点对象来映射到pod的IP: Port，否则，该服务将没有任何端点。</em></li><li id="12b5" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li nh my mz na bi translated">无头服务— <em class="lj">有时您不需要或不想要负载平衡和单个服务IP。在这种情况下，您可以通过为集群IP指定</em><code class="fe od oe of nk b"><em class="lj">"None"</em></code><em class="lj">(</em><code class="fe od oe of nk b"><em class="lj">.spec.clusterIP</em></code><em class="lj">)来创建“无头”服务。</em></li><li id="b353" class="ms mt iq kn b ko nb ks nc kw nd la ne le nf li nh my mz na bi translated">使用“externalTrafficPolicy: Local”的节点端口服务将保留源IP，并丢弃来自没有本地端点的工作节点的数据包。</li></ol></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="77ec" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">请阅读我的其他文章，并分享您的反馈。如果你喜欢分享的内容，请点赞、评论并订阅新文章。</p></div></div>    
</body>
</html>