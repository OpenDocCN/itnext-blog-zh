<html>
<head>
<title>Smart Developers Don’t Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聪明的开发人员不编码</h1>
<blockquote>原文：<a href="https://itnext.io/smart-developers-dont-code-2bf882568c37?source=collection_archive---------0-----------------------#2021-01-07">https://itnext.io/smart-developers-dont-code-2bf882568c37?source=collection_archive---------0-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="82e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，停止重新发明东西！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9d5acfc05fec400d36470724e9df72e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QQ5EvzlrlWThG_8W"/></div></div></figure><p id="4100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kx translated">很久以前，当我还是一名年轻的初级开发人员时，有些事情就一直萦绕在我的脑海里。我当时正在开发一个应用程序的一部分，试图加快web应用程序中数据的访问速度。每次用户翻阅数据时调用数据库的第一次代码迭代。为了优化，我决定缓存最初返回的数据，这样就不会不断地返回数据库。明智之举。</p><p id="3eff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我花了几天时间想出了一个别人见过的最好的缓存Java代码的东西！我想出了复杂的算法来调用、存储、分页和驱逐这个用例的数据。</p><p id="e368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过5天5夜的编码工作，我骄傲地见到了我的首席开发人员，并和他一起看了我的代码。我用算法的智慧迷惑了他。</p><p id="61d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人困惑的是，我遇到的不是看到革命性的数据分页技术的祝贺，而是一声长叹和一个回顾的承诺。</p><p id="45dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二天，领头的戴夫打电话给我说。"<em class="lg">我不知道你做了什么，但我已经删除了你所有的代码，只是将数据存储在一个列表中，这个列表会在每次新的搜索中刷新</em>"</p><p id="9262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他首先告诉我，我的代码被大规模过度设计，其次，他只是在做一些有模式和工具来解决相同问题的事情。</p><p id="ef1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">夹着尾巴，我接受了这一点，并上了我作为初级开发人员最大的一课，就像对后脑勺的重击！</p><p id="ace4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我在软件工程中最早学到的一课是——不要马上通过编码来解决问题！</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/323cd183a0183a922b239dcaee3b9ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YcZGRyKTrBdUsm5P"/></div></div></figure><p id="c1ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这让我想起了我最近与一位年轻开发人员的对话，他向我提出了他在<a class="ae lh" href="https://www.openshift.com/" rel="noopener ugc nofollow" target="_blank"> Red Hat OpenShift </a>中使用代码的问题(声明:我在Red Hat工作)。在获得完整的细节后，他解释说，他已经编写了许多微服务，放在一堆API前面，这些API从各种来源读取数据，并根据来源对数据进行处理，然后发送到各个端点。他为自己为解决这个问题而构建的一套微服务感到非常自豪。有聚合器、翻译器和其他模式。</p><p id="d845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我听着，叹了口气。</strong></p><p id="d363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我告诉他，这个解决方案真的很复杂，似乎有点过于复杂了！以一种礼貌的方式，我告诉他，人们已经解决了所有这些问题，而且解决了很多次。在这种情况下，我将他指向Apache Camel，并告诉他，仅仅因为您正在构建微服务，并不意味着您需要构建微服务！</p><blockquote class="li lj lk"><p id="e92d" class="jn jo lg jp b jq jr js jt ju jv jw jx ll jz ka kb lm kd ke kf ln kh ki kj kk ij bi translated"><strong class="jp ir">您正在构建微服务并不意味着您需要构建微服务！</strong></p></blockquote><p id="79d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这本书里，我们似乎总是认为我们需要重新发明一切。我完全支持改变我们使用技术方式的令人兴奋的新范例，但不是以扔掉东西为代价。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/219a10ae02d3b0514afe155a52fec9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*ZD1F5YJkks23y_E-.png"/></div></figure><p id="25e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阿帕奇骆驼是许多不重复发明的例子之一！</p><p id="7477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是Apache Camel的超级粉丝，无论是从集成者的角度还是从开源社区的成功角度来看。《骆驼》的故事是基于Gregor Hophe和James Strachan之间的对话。Gregor写了集成圣经<a class="ae lh" href="https://www.enterpriseintegrationpatterns.com/gregor.html" rel="noopener ugc nofollow" target="_blank">企业集成模式</a>，这本书给了你作为一组模式的通用集成任务的设计… <strong class="jp ir">你知道，所以你不需要重新发明相同的架构模式。</strong></p><p id="e1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">James是一名开源开发人员，也是Groovy(该语言)的创始人，他和Gregor在一次会议上交谈，James认为构建这些模式的可重用Java实现是一个不错的主意… <strong class="jp ir">你知道，这样你就不必在需要做事情的时候写同样的代码</strong>！Apache Camel就是从这种对话中诞生的，它是一组实现集成模式的库。</p><h1 id="a307" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">回到我最近的对话！</strong></h1><p id="9091" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">所以，我们看了一下Red Hat Integration，它是Apache Camel加上一堆其他东西来部署和运行集成服务。我告诉他，他不仅可以做他需要的一切，而且这也符合他的微服务架构，看看Camel K等一些闪亮的新产品，他还可以让他的微服务得到服务…呃，无服务器！</p><blockquote class="li lj lk"><p id="631b" class="jn jo lg jp b jq jr js jt ju jv jw jx ll jz ka kb lm kd ke kf ln kh ki kj kk ij bi translated"><strong class="jp ir">无服务器集成微服务！！</strong></p></blockquote><p id="9615" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Camel K是目前集成中最令人兴奋的东西。集成专家面临的一些最大挑战总是围绕着如何利用集成解决方案架构实现可伸缩性和可用性。像CamelK和OpenShift这样的工具正在处理这个问题的整个部署、运行和扩展方面。</p><p id="c62b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apache Camel提供了模式和数百个适配器的实现。需要专业知识的事情是确定使用哪些连接器和模式，重要的是如何在可伸缩和可用的架构中部署组件以支持需求。</p><p id="7a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像CamelK这样的项目是一种新型的“kubernetes本地”工具，它们希望利用Kubernetes的能力来利用Kubernetes平台的巨大规模和可用性。通过使用Kubernetes平台的强大功能，已经完成了定义和设计规模和可用性方面的一些困难工作…这样我就不需要重新发明规模和可用性了！</p><p id="f2d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是阿帕奇骆驼？</strong></p><p id="9edf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，就一个简单的问题，如果你以前没有看过<a class="ae lh" href="https://camel.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇骆驼</a>，那么它是一个令人敬畏的美丽的东西，它使连接和集成数百种不同的东西变得非常简单。</p><p id="78dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是对阿帕奇骆驼的快速浏览。</p><ol class=""><li id="51b9" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">它提供了60多种集成模式的实现</li><li id="952e" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">它有超过350个连接器</li><li id="8e17" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">太棒了</li></ol><p id="e374" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是所有camel集成的基本前提。数据或调用来自某个地方的源，流入处理器执行某项操作，然后流向目的地。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/324ff20327456f2a874af542aaf492ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCaNhzY48Hpkg-F_8uHteA.png"/></div></div></figure><p id="de5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FROM和TO是Camel组件或适配器，用于连接从AWS本地服务到CSV文件到SAP到反应流再到Kafka连接器的各种技术…有350多个这样的组件！</p><p id="939f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">就这么简单！</strong></p><p id="a4c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我要讲的一个故事是，Camel components是展示开源软件社区和项目力量的绝佳方式。多年来，我一直是Camel的忠实粉丝，并且看到每个版本的组件数量都在增长。</p><p id="c90b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这就是开源的力量！</strong></p><p id="398c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发生的情况是，一个开发人员使用了Camel，但是这个开发人员需要的组件在Camel中还不存在。因此，开发人员构建组件来解决他们的需求。作为一名优秀的开源公民，开发人员通过将该组件贡献回Camel源代码并包含在下一个Camel版本中来取悦Camel社区。现在，当您需要那个组件时，您不必构建它，因为它已经完成了…太棒了！</p><p id="1c49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lg">有大量的资源可以帮助你了解骆驼，其中最好的一本是克劳斯·伊布松和乔纳森·安斯提的书，</em> <a class="ae lh" href="https://www.manning.com/books/camel-in-action" rel="noopener ugc nofollow" target="_blank"> <em class="lg">骆驼在行动</em> </a> <em class="lg">这是骆驼的圣经。詹姆斯·斯特拉坎经常说他发明了骆驼，但是克劳斯让它工作了！也看看</em> <a class="ae lh" href="https://tomd.xyz/camel-tutorial/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">汤姆·多诺霍的精彩文章</em> </a> <em class="lg">关于骆驼的</em></p><h1 id="bbc8" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">但是骆驼K呢！</strong></h1><p id="d3ad" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">好的，我将很快向您展示一些很棒的东西(对像我这样的老集成黑客来说，这太棒了！).</p><p id="574c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将用几行代码完成一个相当简单的集成任务。</p><p id="f161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将创建一个<a class="ae lh" href="https://telegram.org/" rel="noopener ugc nofollow" target="_blank">电报</a>机器人，向电报通道发送补充信息。现在Telegram有一个API的负载，我可以用它来调用和发送消息到我可以使用的频道。</p><p id="c589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在https://complimentr.com/<a class="ae lh" href="https://complimentr.com/" rel="noopener ugc nofollow" target="_blank">还有一项</a><a class="ae lh" href="https://github.com/grantcodes" rel="noopener ugc nofollow" target="_blank">授权码</a>的赞美服务，它会回复赞美让你感觉良好:)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/5ced36e9726e1c2e9cf035dc91fe09cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MQyNoSq9EOIpNQtG"/></div></div></figure><p id="4cfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lg">哇，惊人的配色方案格兰特！</em></p><p id="737f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我想将这两种服务整合在一起，向我的电报朋友传递美好的问候。</p><p id="7742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我要深入研究代码吗？</p><p id="c1f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然不是。快速浏览一下<a class="ae lh" href="https://camel.apache.org/camel-kafka-connector/latest/connectors.html" rel="noopener ugc nofollow" target="_blank"> Apache Camel连接器</a>就可以发现，在我可以连接的大约350个不同组件中，我找到了<a class="ae lh" href="https://camel.apache.org/components/latest/telegram-component.html" rel="noopener ugc nofollow" target="_blank"> Camel Telegram </a>，某个想要与Telegram通话的人已经写好了要连接的东西，这样我就不必再连接了<strong class="jp ir">！</strong></p><p id="8e1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些常用的Camel组件将有助于对恭维服务的普通HTTP调用，我以一种轻率的方式说常用，因为实际上有一个HTTP组件可以处理我可能已经编码的所有事情，但是我不需要这样做！</p><p id="a031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我将使用<a class="ae lh" href="https://camel.apache.org/components/latest/telegram-component.html" rel="noopener ugc nofollow" target="_blank"> Camel Telegram </a>组件，接收来自机器人的消息，调用外部服务以获得称赞，然后将其发送回电报机器人。好吧，这不是最令人兴奋的事情，但也有一点乐趣</p><p id="144b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我想让机器人做的，发送一个名字，然后收到一个赞美。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/6b6ae638be3246f30b306a03271fbf75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Dnghg8eBaITQoTh"/></div></div></figure><p id="0b46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有一个可用的kubernetes集群，所以我将与CamelK一起使用。我正在使用Red Hat OpenShift和CamelK操作器进行设置。</p><p id="edda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我需要做的。</p><p id="bb19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1 —下载CamelK CLI。</p><p id="1b33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2 —安装CamelK操作器</p><p id="2c03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3 —运行我的代码</p><h1 id="26ce" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">下载CamelK CLI </h1><p id="5396" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">因此，有大量的文章和文档在解释这一点，所以我不会进入大量的细节，但CamelK CLI(或kamel)本质上是您如何与Kubernetes平台(或更准确地说，平台上的CamelK自定义资源)进行交互，以部署集成(也有针对VSCode的IDE插件)。</p><p id="8d5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CLI使您能够安装Camel K操作符，以交互开发模式运行集成(运行集成代码的实时更新)等。</p><h1 id="5b28" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">安装CamelK操作器</strong></h1><p id="3c76" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">CamelK有许多Kubernetes运营商来构建、部署和运行集成。Kubernetes操作符的全部意义在于抽象平台上运行的事物的复杂性，CamelK在这方面做得非常好！因此，只需从CLI安装操作器</p><p id="6a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令行使用:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6f30214e366c3a863251dc03dd239a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/0*DG26XYd4SuKHZ6sA"/></div></figure><p id="2167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，如果您正在Openshift中运行，那么您可以使用Operators选项卡来安装。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/f6559c9ef8259baf04b0339603dae871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7u4cxoEpnHdIc-Wp"/></div></div></figure><h1 id="1c51" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">运行我的代码</strong></h1><p id="6266" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">安装后，我现在可以从IDE或CLI将集成代码推送到我正在运行的OpenShift平台。</p><p id="4193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们看看代码。请记住，我使用的是电报组件。查看组件，我只需要获取电报授权令牌并将其传递给组件，组件将读取来自机器人的消息。</p><pre class="km kn ko kp gt nl nm nn no aw np bi"><span id="a8bd" class="nq lq iq nm b gy nr ns l nt nu">from(“telegram:bots?authorizationToken=[YOUR TOKEN]”)</span></pre><p id="faaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我添加一个简单的日志来查看路由的工作情况</p><pre class="km kn ko kp gt nl nm nn no aw np bi"><span id="dc8e" class="nq lq iq nm b gy nr ns l nt nu">from(“telegram:bots?authorizationToken=[YOUR TOKEN]”)</span><span id="6430" class="nq lq iq nm b gy nv ns l nt nu">.to(“log:bots”)</span></pre><p id="0235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有两行代码。如果我将这些保存在一个名为hello.groovy的文件中，那么我就有了一个groovy脚本，它可以用作CamelK集成，将连接到我的telegram bot，并将记录我键入的任何内容！</p><h1 id="4010" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">运行hello.groovy </strong></h1><p id="1db4" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这是最棒的部分。我希望我的两行groovy脚本作为可伸缩的集成组件部署和运行。这就是骆驼K！从我的命令行，我只需运行:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0ac3bf0657d89e743603b00c14eb788a.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/0*urER8fY9rVxlaIlS"/></div></figure><p id="e6ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用run命令，我已经将我的两行groovy脚本转换成一个容器，在我的OpenShift集群上作为Apache Camel route部署和运行。</p><p id="0619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是— dev标志？</strong></p><p id="911a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加— dev标志后，我进入了一个奇怪的世界，在这里我可以对hello.groovy文件进行更改，这将自动反映在OpenShift集群中！让我的开发体验更加轻松。</p><h1 id="5158" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">完整的机器人</strong></h1><p id="e3b3" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">您已经看到了CamelK有多棒，下面是我的“避免代码”groovy脚本的其余部分。</p><pre class="km kn ko kp gt nl nm nn no aw np bi"><span id="a7a7" class="nq lq iq nm b gy nr ns l nt nu">from(“telegram:bots?authorizationToken=[YOUR TOKEN]”)</span><span id="f1c4" class="nq lq iq nm b gy nv ns l nt nu">.setHeader(“USER”, body())</span><span id="3f43" class="nq lq iq nm b gy nv ns l nt nu">.to(“https://complimentr.com/api?asGET=true “)</span><span id="a551" class="nq lq iq nm b gy nv ns l nt nu">.transform().jsonpath(“\$.compliment”)</span><span id="7998" class="nq lq iq nm b gy nv ns l nt nu">.setBody(simple("\${body} \${in.header.USER}”))</span><span id="382f" class="nq lq iq nm b gy nv ns l nt nu">.to(“telegram:bots?authorizationToken=[YOUR TOKEN]”)</span></pre><ul class=""><li id="3ace" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk nx my mz na bi translated">我使用骆驼电报组件从电报通道接收消息</li><li id="fdcd" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nx my mz na bi translated">将名称作为标题隐藏在电报消息正文中发送</li><li id="0229" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nx my mz na bi translated">呼唤赞美api</li><li id="084a" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nx my mz na bi translated">把原来的名字加到赞美词里</li><li id="4bb4" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk nx my mz na bi translated">把赞美推回电报频道。</li></ul><p id="4197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是六行代码，通过重用组件来完成集成工作。</p><p id="9c66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些非常出色的Camel集成模式，如聚合器、代理、动态路由，甚至更棒的CamelK东西，如无服务器、按需扩展到零的能力，这些都将帮助您不用编码！</p><p id="a85a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">聪明的开发人员不编码并不新鲜，它已经存在很久了。我们构建框架和工具的原因是为了将平凡的事情抽象化，从而更有效率。有时候，这是一个了解什么样的框架和工具可以帮助你不编码的案例。希望我已经给你们展示了另一个！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/10cc4464d1c171a0eef2f3713c767d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*23oGWWQ5-UZ4sxSJfdHrag.png"/></div></figure><p id="2f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看其他红帽人在<a class="ae lh" href="https://ukidevelopers.co.uk/" rel="noopener ugc nofollow" target="_blank">英国和爱尔兰社区网站</a>谈论什么</p></div></div>    
</body>
</html>