# 在 JavaScript(ES6)中实现封装的不同方法

> 原文：<https://itnext.io/different-ways-to-achieve-encapsulation-in-javascript-es6-7cb938e83f2d?source=collection_archive---------1----------------------->

![](img/ff1be2dedfe80aa5c6561da1da1fc492.png)

JavaScript 是一种强大的语言，充满了不同的范例，可以让您编写有趣而灵活的代码。然而，与此同时，它缺少其他语言所具有的一些基本结构特征。到目前为止，JavaScript 最大的异常之一是它不能本地支持封装。

范围系统是由 TypeScript 引入的，TypeScript 是 JavaScript 的超集。但不幸的是，这还不是一个明显的胜利，因为，虽然它给你一个警告，TypeScript 代码仍然编译和运行，即使当你访问私有变量。

然而，人们想出了使用语言的其他特性来实现封装的方法。在这篇文章中，我将讨论最广泛使用的方法。

# 休闲小站

实现伪封装最简单的方法是在私有成员前加上一个特殊的符号，向客户端指示私有范围。使用`_`符号作为前缀是一种常见的惯例。当然，这实际上不会阻止任何人访问你的私有变量，所以我们在这里不做过多的描述。

# 工厂功能和关闭

简单地说，工厂函数是用来创建对象的新实例的函数。工厂函数通常是使用`new`关键字直接创建对象的首选。原因是因为使用工厂函数给了你自由和灵活性来改变对象的实例化过程，而不需要客户知道这种改变。

与[闭包](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)一起使用的工厂函数通常是实现封装的首选方法，因为它很简单。让我们来看看这个例子:

上面的代码是通过工厂函数和闭包实现封装的典型例子。虽然实现非常简单，但它确实带来了内存使用损失。原因是，对于`Hedgehog`函数的每个新实例，都将重新创建方法`zoom`。下面是一个使用 ES6 语法的相同实现:

如你所见，为了让`zoom`方法访问`speed`和`name`，我们必须把它放在构造函数中。在某些情况下，这种惩罚是可以接受的，你可以使用它。同样，为了减少过热，你可以定义不在构造函数之外使用私有变量的方法，就像我们对`jump`方法所做的那样。

# 弱映射和名称空间

通过使用`[WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)`对象存储私有成员，可以避免使用工厂函数和闭包带来的内存损失。因为一个`WeakMap`可以用来存储该类的多个实例的私有成员，所以避免了代价。让我们看看这个例子，以便更好地理解这个概念:

事情是这样的:

*   我们将`Hedgehog`类包装在自调用函数中并返回它。通过这种方式，我们可以确保我们的私有数据只被创建一次，并且我们的类对于客户端来说是即时可用的。
*   在自调用函数内，但在`Hedgehog`类之外，我们存储我们的`WeakMap`。这个映射用于存储每个`Hedgehog`类实例的私有变量。地图中的每个值都是一个对象，我们称之为`namespace`。本质上，`namespace`是一个私有对象，具有键-值对，只对持有对它的引用的`Hedgehog`类的特定实例可用。
*   如前所述，由于我们只为`Hedgehog`类的多个实例存储一个映射，过热大大减少了。

我们选择`WeakMap`进行存储，而不是使用常规的`Map`或普通的 JavaScript 对象，这是有原因的:

*   弱映射允许您使用 JavaScript 对象作为键。其他种类的字典集合只允许您使用原语。
*   因为`WeakMap`持有对其项目的弱引用，所以避免了内存泄漏。这允许这些项在丢失所有其他引用时被垃圾回收。
*   弱映射保证对象只能使用`get`方法访问。`WeakMap`没有任何其他访问其项目的方法(*循环，* `*Object.keys()*` *等*)。

# 使用符号(某种封装)

最后一种方法是使用新的 ES6 特性——符号。符号是一种保证唯一的原语。它的主要用途之一是用作字典集合的关键字。

这里的技巧是使用闭包来定义私有符号。让我们看看这个例子:

使用这个方法，`Hedgehog`类的每个实例都有自己的`this[speed]`变量实例，由于在顶部定义了`speed`符号，这个变量仍然可以被类中的其他方法访问。当使用点符号和迭代对象集合或使用`Object.keys()`时，符号是不可访问的。所以它确实提供了某种程度的封装。

虽然在大多数情况下，符号确实提供了足够的封装级别，但是仍然可以使用`Object.getOwnPropertySymbols`来破解。虽然，大多数时候客户端应该得到提示，不会试图使用那些私有属性。

这就是这篇文章的全部内容。希望您学到了一些用 JavaScript 实现封装的新方法。感谢阅读！

*原载于 2019 年 5 月 18 日*[*https://isamatov.com*](https://isamatov.com/encapsulation-in-javascript-es6/)*。*