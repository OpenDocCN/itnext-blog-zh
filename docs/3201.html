<html>
<head>
<title>Autoscaling Kubernetes apps with Prometheus and KEDA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普罗米修斯和KEDA自动缩放Kubernetes应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/tutorial-auto-scale-your-kubernetes-apps-with-prometheus-and-keda-c6ea460e4642?source=collection_archive---------0-----------------------#2019-10-23">https://itnext.io/tutorial-auto-scale-your-kubernetes-apps-with-prometheus-and-keda-c6ea460e4642?source=collection_archive---------0-----------------------#2019-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7a4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可伸缩性是云原生应用的关键要求。使用<a class="ae ko" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>，扩展您的应用程序就像增加相应<code class="fe kp kq kr ks b">Deployment</code>或<code class="fe kp kq kr ks b">ReplicaSet</code>的副本数量一样简单——但是，这是一个手动过程。Kubernetes使用<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#horizontalpodautoscaler-v1-autoscaling" rel="noopener ugc nofollow" target="_blank">水平窗格自动缩放器</a>规范，以声明的方式自动缩放您的应用程序(即<code class="fe kp kq kr ks b">Deployment</code>或<code class="fe kp kq kr ks b">ReplicaSet</code>中的<code class="fe kp kq kr ks b">Pod</code>)。默认情况下，支持使用CPU利用率(<code class="fe kp kq kr ks b">Resource</code>指标)作为自动伸缩的标准，但是也可以集成自定义和外部提供的指标。</p><p id="6330" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇博客将展示如何使用外部指标来自动调整Kubernetes应用程序。出于演示目的，我们将使用通过<a class="ae ko" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>公开的HTTP访问请求度量。我们不直接使用<code class="fe kp kq kr ks b">Horizontal Pod Autoscaler</code>，而是利用<a class="ae ko" href="https://github.com/kedacore/keda" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Kubernetes事件驱动的自动伸缩</strong>又名<strong class="js iu">KEDA</strong></a>——一个开源的Kubernetes操作器，它与<code class="fe kp kq kr ks b">Horizontal Pod Autoscaler</code>本机集成，为事件驱动的工作负载提供细粒度的自动伸缩(包括从零到零)。</p><p id="8f33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码可在<a class="ae ko" href="https://github.com/abhirockzz/kubernetes-keda-prometheus" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得</p><blockquote class="kt ku kv"><p id="1094" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated">我希望得到您的反馈和建议！欢迎随意发表 <a class="ae ko" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> <em class="it">推文</em> </a> <em class="it">或发表评论😃</em></p></blockquote><h1 id="5c05" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">概观</h1><p id="3b4e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这里总结了端到端的工作方式——这一部分将详细讨论每一种方式</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/9002d8fa88549f3d395a858a8b9c7031.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*LWFL6Vy1qZRQ-j36qnSFIg.jpeg"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">事物如何在高层次上运作</figcaption></figure><ul class=""><li id="41fe" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">该应用程序以Prometheus格式公开HTTP访问计数指标</li><li id="2843" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">普罗米修斯被配置为收集这些指标</li><li id="b27f" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">KEDA的Prometheus scaler经过配置和部署，可根据HTTP访问计数指标自动扩展应用</li></ul><h1 id="3135" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">KEDA和普罗米修斯</h1><p id="70e3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Prometheus是一个开源系统监控和警报工具包，是<a class="ae ko" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a>的一部分。Prometheus从各种来源收集指标，并将它们存储为时间序列数据，并且可以使用像<a class="ae ko" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>或其他API消费者这样的工具来可视化收集的数据。</p><p id="7040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">KEDA支持在KEDA和外部系统之间充当桥梁的概念。一个<code class="fe kp kq kr ks b">Scaler</code>实现特定于一个目标系统，并从中获取相关数据，然后被KEDA用来帮助驱动自动扩展。支持<a class="ae ko" href="https://github.com/kedacore/keda#event-sources-and-scalers" rel="noopener ugc nofollow" target="_blank">多种缩放器</a>(包括Kafka，Redis等。)包括普罗米修斯。这意味着你可以使用普罗米修斯指标作为标准，利用KEDA来自动调整你的T2。</p><h1 id="ba56" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">示例应用程序</h1><p id="8824" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">示例<a class="ae ko" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>应用程序公开了一个HTTP端点，并做了两件重要的事情:</p><ul class=""><li id="fc02" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">使用<a class="ae ko" href="https://github.com/prometheus/client_golang/" rel="noopener ugc nofollow" target="_blank"> Prometheus Go客户端库</a>来检测应用程序，并公开由<code class="fe kp kq kr ks b"><a class="ae ko" href="https://godoc.org/github.com/prometheus/client_golang/prometheus#Counter" rel="noopener ugc nofollow" target="_blank">Counter</a></code>支持的<code class="fe kp kq kr ks b">http_requests</code>指标。普罗米修斯指标终点在<code class="fe kp kq kr ks b">/metrics</code>可用。</li></ul><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="5e06" class="nh lb it ks b gy ni nj l nk nl">var httpRequestsCounter = promauto.NewCounter(prometheus.CounterOpts{<br/>        Name: "http_requests",<br/>        Help: "number of http requests",<br/>    })</span></pre><ul class=""><li id="ff26" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">为了响应一个<code class="fe kp kq kr ks b">GET</code>请求，它还在Redis中增加了一个键(<code class="fe kp kq kr ks b">access_count</code>)——这是作为HTTP处理程序的一部分完成一些“工作”的简单方法，也有助于验证Prometheus指标(应该与Redis中的<code class="fe kp kq kr ks b">access_count</code>的值相同)</li></ul><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="6011" class="nh lb it ks b gy ni nj l nk nl">func main() {<br/>        http.Handle("/metrics", promhttp.Handler())<br/>        http.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {<br/>            defer httpRequestsCounter.Inc()<br/>            count, err := client.Incr(redisCounterName).Result()<br/>            if err != nil {<br/>                fmt.Println("Unable to increment redis counter", err)<br/>                os.Exit(1)<br/>            }<br/>            resp := "Accessed on " + time.Now().String() + "\nAccess count " + strconv.Itoa(int(count))<br/>            w.Write([]byte(resp))<br/>        })<br/>        http.ListenAndServe(":8080", nil)<br/>    }</span></pre><p id="49fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序作为<code class="fe kp kq kr ks b">Deployment</code>部署到Kubernetes，并且还创建了一个<code class="fe kp kq kr ks b">ClusterIP</code>服务，以允许Prometheus服务器抓取应用程序<code class="fe kp kq kr ks b">/metrics</code>端点。</p><blockquote class="kt ku kv"><p id="172e" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/abhirockzz/kubernetes-keda-prometheus/blob/master/go-app.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="it">这里是</em> </a> <em class="it">为申请</em></p></blockquote><h1 id="44a9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">普罗米修斯服务器</h1><p id="e3d1" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">普罗米修斯部署清单包括:</p><ul class=""><li id="54c4" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated"><code class="fe kp kq kr ks b">ConfigMap</code>捕捉普罗米修斯配置</li><li id="9b3f" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><code class="fe kp kq kr ks b">Deployment</code>对于普罗米修斯服务器本身</li><li id="d5a0" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><code class="fe kp kq kr ks b">ClusterIP</code>用于访问Prometheus UI的服务</li><li id="1e16" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated"><code class="fe kp kq kr ks b">ClusterRole</code>、<code class="fe kp kq kr ks b">ClusterRoleBinding</code>和<code class="fe kp kq kr ks b">ServiceAccount</code>允许Kubernetes服务发现工作</li></ul><blockquote class="kt ku kv"><p id="166b" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/abhirockzz/kubernetes-keda-prometheus/blob/master/prometheus.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="it">这里是普罗米修斯设置</em>的清单 </a> <em class="it"/></p></blockquote><h1 id="1b29" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">KEDA·普罗米修斯</h1><p id="0dee" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如前所述，<code class="fe kp kq kr ks b">Scaler</code>实现充当KEDA和外部系统之间的桥梁，需要从外部系统获取指标。<code class="fe kp kq kr ks b">ScaledObject</code>是一个定制资源，为了将<code class="fe kp kq kr ks b">Deployment</code>与事件源(本例中为Prometheus)同步，需要部署该资源。它包含关于要扩展哪个<code class="fe kp kq kr ks b">Deployment</code>的信息、事件源的元数据(例如连接字符串机密、队列名称)、轮询间隔、冷却时间等。<code class="fe kp kq kr ks b">ScaledObject</code>将导致相应的自动缩放资源(HPA定义)来缩放<code class="fe kp kq kr ks b">Deployment</code></p><blockquote class="kt ku kv"><p id="284d" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">当</em> <code class="fe kp kq kr ks b"><em class="it">ScaledObject</em></code> <em class="it">被删除时，相应的HPA定义被清除。</em></p></blockquote><p id="5823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我们的示例中使用<code class="fe kp kq kr ks b">Prometheus</code>缩放器的ScaledObject定义</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="3a4e" class="nh lb it ks b gy ni nj l nk nl">apiVersion: keda.k8s.io/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: prometheus-scaledobject<br/>  namespace: default<br/>  labels:<br/>    deploymentName: go-prom-app<br/>spec:<br/>  scaleTargetRef:<br/>    deploymentName: go-prom-app<br/>  pollingInterval: 15<br/>  cooldownPeriod:  30<br/>  minReplicaCount: 1<br/>  maxReplicaCount: 10<br/>  triggers:<br/>  - type: prometheus<br/>    metadata:<br/>      serverAddress: http://prometheus-service.default.svc.cluster.local:9090<br/>      metricName: access_frequency<br/>      threshold: '3'<br/>      query: sum(rate(http_requests[2m]))</span></pre><p id="ff59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意以下事项:</p><ul class=""><li id="03d3" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">它的目标是名为<code class="fe kp kq kr ks b">go-prom-app</code>的<code class="fe kp kq kr ks b">Deployment</code></li><li id="5d03" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">触发类型为<code class="fe kp kq kr ks b">prometheus</code>。普罗米修斯<code class="fe kp kq kr ks b">serverAddress</code>与<code class="fe kp kq kr ks b">metricName</code>、阈值和<a class="ae ko" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> PromQL查询</a> ( <code class="fe kp kq kr ks b">sum(rate(http_requests[2m]))</code>)一起被提及</li><li id="f2f7" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">根据<code class="fe kp kq kr ks b">pollingInterval</code>，KEDA将每<code class="fe kp kq kr ks b">fifteen</code>秒轮询一次普罗米修斯目标。最少保留一个<code class="fe kp kq kr ks b">Pod</code>(<code class="fe kp kq kr ks b">minReplicaCount</code>)，最大数量的<code class="fe kp kq kr ks b">Pod</code>不会超过<code class="fe kp kq kr ks b">maxReplicaCount</code>(本例中为<code class="fe kp kq kr ks b">ten</code>)</li></ul><blockquote class="kt ku kv"><p id="dc51" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">可以将</em> <code class="fe kp kq kr ks b"><em class="it">minReplicaCount</em></code> <em class="it">设置为</em> <code class="fe kp kq kr ks b"><em class="it">zero</em></code> <em class="it">。在这种情况下，KEDA将从零到一“激活”部署，然后让HPA进一步自动扩展(反过来也是如此，即从一扩展到零)。我们没有选择zero，因为这是一个HTTP服务，而不是一个随需应变的系统，比如消息队列/主题消费者</em></p></blockquote><h2 id="3ef6" class="nh lb it bd lc nm nn dn lg no np dp lk kb nq nr lo kf ns nt ls kj nu nv lw nw bi translated">自动秤背后的魔力</h2><p id="bc7d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe kp kq kr ks b">threshold</code>计数用于触发扩展部署。在本例中，PromQL查询<code class="fe kp kq kr ks b">sum(rate(http_requests[2m]))</code>返回在过去两分钟内测量的每秒HTTP请求率的聚合值。由于<code class="fe kp kq kr ks b">threshold</code>计数是<code class="fe kp kq kr ks b">three</code>，这意味着如果<code class="fe kp kq kr ks b">sum(rate(http_requests[2m]))</code>的值保持小于3，将有一个Pod。如果该值上升，则每次<code class="fe kp kq kr ks b">sum(rate(http_requests[2m]))</code>增加<code class="fe kp kq kr ks b">three</code>就会有一个额外的<code class="fe kp kq kr ks b">Pod</code>，例如，如果该值在<code class="fe kp kq kr ks b">12</code>到<code class="fe kp kq kr ks b">14</code>之间，则<code class="fe kp kq kr ks b">Pod</code>的数量将为<code class="fe kp kq kr ks b">4</code></p><p id="56d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，是时候动手试试了！</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/09043b87b1d5ebe3296415d26cca1339.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*0OYxeGcQpy6XNDWX.gif"/></div></figure><h1 id="69e1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><p id="4e81" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">你所需要的只是一个Kubernetes集群和<code class="fe kp kq kr ks b">kubectl</code></p><p id="794d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes集群——这个例子使用了<code class="fe kp kq kr ks b">minikube</code>,但是也可以随意使用其他的。您可以使用此导轨安装它<a class="ae ko" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4c66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在Mac上安装最新版本:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="a98d" class="nh lb it ks b gy ni nj l nk nl">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \<br/>&amp;&amp; chmod +x minikube<br/>sudo mkdir -p /usr/local/bin/<br/>sudo install minikube /usr/local/bin/</span></pre><p id="e0be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请<a class="ae ko" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">安装</a> <code class="fe kp kq kr ks b"><a class="ae ko" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>来访问您的Kubernetes集群。</p><p id="e610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在Mac上安装最新版本:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="6c7a" class="nh lb it ks b gy ni nj l nk nl">curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl"<br/>chmod +x ./kubectl<br/>sudo mv ./kubectl /usr/local/bin/kubectl<br/>kubectl version</span></pre><h1 id="63a0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置</h1><h1 id="7296" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">安装KEDA</h1><p id="46b6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">根据文档，您可以通过多种方式<a class="ae ko" href="https://github.com/kedacore/keda#setup" rel="noopener ugc nofollow" target="_blank">部署KEDA。我只是用一个整体YAML来完成这项工作</a></p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="8df6" class="nh lb it ks b gy ni nj l nk nl">kubectl apply -f <a class="ae ko" href="https://raw.githubusercontent.com/kedacore/keda/master/deploy/KedaScaleController.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kedacore/keda/master/deploy/KedaScaleController.yaml</a></span></pre><blockquote class="kt ku kv"><p id="4127" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it"> KEDA及其组件安装在</em> <code class="fe kp kq kr ks b"><em class="it">keda</em></code> <em class="it">命名空间</em>中</p></blockquote><p id="a27f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了证实，</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="bc77" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods -n keda</span></pre><blockquote class="kt ku kv"><p id="9759" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">等待KEDA操作符</em> <code class="fe kp kq kr ks b"><em class="it">Pod</em></code> <em class="it">启动(</em> <code class="fe kp kq kr ks b"><em class="it">Running</em></code> <em class="it">状态)后再进行</em></p></blockquote><h1 id="f707" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Helm设置Redis</h1><p id="13d7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果您没有安装头盔，只需使用本指南。在苹果电脑上，你可以使用</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="5cdc" class="nh lb it ks b gy ni nj l nk nl">brew install kubernetes-helm<br/>helm init --history-max 200</span></pre><blockquote class="kt ku kv"><p id="6bb6" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><code class="fe kp kq kr ks b"><em class="it">helm init</em></code> <em class="it">是初始化本地CLI，同时将</em> <code class="fe kp kq kr ks b"><em class="it">Tiller</em></code> <em class="it">安装到您的Kubernetes集群</em></p></blockquote><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="3a9d" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods -n kube-system | grep tiller</span></pre><p id="f5a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等待手柄<code class="fe kp kq kr ks b">Pod</code>切换到<code class="fe kp kq kr ks b">Running</code>状态</p><p id="54a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置好一个舵，获得Redis服务器就像运行:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="7175" class="nh lb it ks b gy ni nj l nk nl">helm install --name redis-server --set cluster.enabled=false --set usePassword=false stable/redis</span></pre><p id="43bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要确认Redis是否准备好:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="f669" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods/redis-server-master-0</span></pre><blockquote class="kt ku kv"><p id="473a" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">等待Redis服务器</em> <code class="fe kp kq kr ks b"><em class="it">Pod</em></code> <em class="it">启动(</em> <code class="fe kp kq kr ks b"><em class="it">Running</em></code> <em class="it">状态)后再继续</em></p></blockquote><h1 id="4789" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署应用程序</h1><p id="9094" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">要部署:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="f990" class="nh lb it ks b gy ni nj l nk nl">kubectl apply -f go-app.yaml</span><span id="4f1e" class="nh lb it ks b gy ny nj l nk nl">//output<br/>deployment.apps/go-prom-app created<br/>service/go-prom-app-service created</span></pre><p id="a082" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确认它是否在运行</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="cdac" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods -l=app=go-prom-app</span></pre><blockquote class="kt ku kv"><p id="bb3b" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">等待应用程序</em> <code class="fe kp kq kr ks b"><em class="it">Pod</em></code> <em class="it">启动(</em> <code class="fe kp kq kr ks b"><em class="it">Running</em></code> <em class="it">状态)，然后继续</em></p></blockquote><h1 id="7614" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署普罗米修斯服务器</h1><p id="4fde" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">普罗米修斯清单使用针对普罗米修斯的<a class="ae ko" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务发现</a>来基于服务标签动态检测应用程序</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="02bd" class="nh lb it ks b gy ni nj l nk nl">kubernetes_sd_configs:<br/>    - role: service<br/>    relabel_configs:<br/>    - source_labels: [__meta_kubernetes_service_label_run]<br/>      regex: go-prom-app-service<br/>      action: keep</span></pre><p id="24db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要部署:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="b42e" class="nh lb it ks b gy ni nj l nk nl">kubectl apply -f prometheus.yaml</span><span id="95e2" class="nh lb it ks b gy ny nj l nk nl">//output<br/>clusterrole.rbac.authorization.k8s.io/prometheus created<br/>serviceaccount/default configured<br/>clusterrolebinding.rbac.authorization.k8s.io/prometheus created<br/>configmap/prom-conf created<br/>deployment.extensions/prometheus-deployment created<br/>service/prometheus-service created</span></pre><p id="7573" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确认它是否在运行</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="ffb0" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods -l=app=prometheus-server</span></pre><blockquote class="kt ku kv"><p id="2511" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">等待普罗米修斯服务器</em> <code class="fe kp kq kr ks b"><em class="it">Pod</em></code> <em class="it">启动(</em> <code class="fe kp kq kr ks b"><em class="it">Running</em></code> <em class="it">状态)后再继续</em></p></blockquote><p id="f586" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe kp kq kr ks b">kubectl port-forward</code>访问Prometheus UI——您可以在<a class="ae ko" href="http://localhost:9090/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9090 </a>访问Prometheus UI(或API服务器)</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="7382" class="nh lb it ks b gy ni nj l nk nl">kubectl port-forward service/prometheus-service 9090</span></pre><h1 id="7f3c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署KEDA自动缩放配置</h1><p id="4a2b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">你需要创建<code class="fe kp kq kr ks b">ScaledObject</code></p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="8a7b" class="nh lb it ks b gy ni nj l nk nl">kubectl apply -f keda-prometheus-scaledobject.yaml</span></pre><p id="0e9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查KEDA操作员日志</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="d4f0" class="nh lb it ks b gy ni nj l nk nl">KEDA_POD_NAME=$(kubectl get pods -n keda -o=jsonpath='{.items[0].metadata.name}')<br/>kubectl logs $KEDA_POD_NAME -n keda</span></pre><p id="5006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你应该看看</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="80ee" class="nh lb it ks b gy ni nj l nk nl">time="2019-10-15T09:38:28Z" level=info msg="Watching ScaledObject: default/prometheus-scaledobject"<br/>time="2019-10-15T09:38:28Z" level=info msg="Created HPA with namespace default and name keda-hpa-go-prom-app"</span></pre><p id="c776" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查应用程序<code class="fe kp kq kr ks b">Pod</code> -应该有一个实例正在运行，因为<code class="fe kp kq kr ks b">minReplicaCount</code>是<code class="fe kp kq kr ks b">1</code></p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="0d56" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods -l=app=go-prom-app</span></pre><p id="70c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确认HPA资源也已创建</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="387d" class="nh lb it ks b gy ni nj l nk nl">kubectl get hpa</span></pre><p id="e794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会看到类似这样的内容:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="f55a" class="nh lb it ks b gy ni nj l nk nl">NAME                   REFERENCE                TARGETS     MINPODS   MAXPODS   REPLICAS   AGE<br/>keda-hpa-go-prom-app   Deployment/go-prom-app   0/3 (avg)   1         10        1          45s</span></pre><h1 id="b4a8" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">自动缩放正在进行中…</h1><h1 id="7f2f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">健全测试:访问应用程序</h1><p id="9f68" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">要访问我们应用程序的REST端点，只需运行:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="a338" class="nh lb it ks b gy ni nj l nk nl">kubectl port-forward service/go-prom-app-service 8080</span></pre><p id="8f54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您应该能够使用<a class="ae ko" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>访问Go应用程序</p><p id="7ff1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要访问端点:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="b0a4" class="nh lb it ks b gy ni nj l nk nl">curl <a class="ae ko" href="http://localhost:8080/test" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/test</a></span></pre><p id="ac51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会看到类似以下内容的响应:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="32d9" class="nh lb it ks b gy ni nj l nk nl">Accessed on 2019-10-21 11:29:10.560385986 +0000 UTC m=+406004.817901246<br/>Access count 1</span></pre><p id="2459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，也要检查Redis。您会看到<code class="fe kp kq kr ks b">access_count</code>键已经增加到1</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="190f" class="nh lb it ks b gy ni nj l nk nl">kubectl exec -it redis-server-master-0 -- redis-cli get access_count<br/>//output<br/>"1"</span></pre><p id="b5a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确认<code class="fe kp kq kr ks b">http_requests</code>度量计数也相同</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="1979" class="nh lb it ks b gy ni nj l nk nl">curl http://localhost:8080/metrics | grep http_requests<br/>//output<br/># HELP http_requests number of http requests<br/># TYPE http_requests counter<br/>http_requests 1</span></pre><h1 id="144d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">生成负载</h1><p id="ae6b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将使用<a class="ae ko" href="https://github.com/rakyll/hey" rel="noopener ugc nofollow" target="_blank"> hey </a>，一个实用程序来生成负载</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="08e5" class="nh lb it ks b gy ni nj l nk nl">curl -o hey https://storage.googleapis.com/hey-release/hey_darwin_amd64 &amp;&amp; chmod a+x hey</span></pre><blockquote class="kt ku kv"><p id="9903" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated"><em class="it">也可以下载给</em><a class="ae ko" href="https://storage.googleapis.com/hey-release/hey_linux_amd64" rel="noopener ugc nofollow" target="_blank"><em class="it">Linux</em></a><em class="it">或者</em> <a class="ae ko" href="https://storage.googleapis.com/hey-release/hey_windows_amd64" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Windows </em> </a></p></blockquote><p id="8022" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像这样调用它</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="4c24" class="nh lb it ks b gy ni nj l nk nl">./hey <a class="ae ko" href="http://localhost:8080/test" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/test</a></span></pre><p id="5337" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，实用程序发送<code class="fe kp kq kr ks b">200</code>请求。您应该能够使用普罗米修斯指标和Redis来确认它</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="8a3d" class="nh lb it ks b gy ni nj l nk nl">curl http://localhost:8080/metrics | grep http_requests<br/>//output<br/># HELP http_requests number of http requests<br/># TYPE http_requests counter<br/>http_requests 201</span><span id="2a46" class="nh lb it ks b gy ny nj l nk nl">kubectl exec -it redis-server-master-0 -- redis-cli get access_count<br/>//output<br/>201</span></pre><p id="7700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确认实际指标(由PromQL查询返回)</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="8bc4" class="nh lb it ks b gy ni nj l nk nl">curl -g 'http://localhost:9090/api/v1/query?query=sum(rate(http_requests[2m]))'</span><span id="b80b" class="nh lb it ks b gy ny nj l nk nl">//output<br/>{"status":"success","data":{"resultType":"vector","result":[{"metric":{},"value":[1571734214.228,"1.686057971014493"]}]}}</span></pre><p id="f619" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，实际结果是<code class="fe kp kq kr ks b">1.686057971014493</code>(在<code class="fe kp kq kr ks b">value</code>)。这不足以触发横向扩展，因为我们设置的阈值是<code class="fe kp kq kr ks b">3</code></p><h1 id="946c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摩尔负荷！</h1><p id="9104" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在新的终端中，跟踪应用程序</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="352f" class="nh lb it ks b gy ni nj l nk nl">kubectl get pods -l=app=go-prom-app -w</span></pre><p id="ceef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们模拟一个重载:</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="a5e1" class="nh lb it ks b gy ni nj l nk nl">./hey -n 2000 <a class="ae ko" href="http://localhost:8080/test" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/test</a></span></pre><p id="c7e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某个时候，你会看到<code class="fe kp kq kr ks b">Deployment</code>将被HPA扩展，新的<code class="fe kp kq kr ks b">Pod</code>将被加速。</p><p id="1202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查HPA以确认相同，</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="bd56" class="nh lb it ks b gy ni nj l nk nl">kubectl get hpa</span><span id="15ec" class="nh lb it ks b gy ny nj l nk nl">NAME                   REFERENCE                TARGETS         MINPODS   MAXPODS   REPLICAS   AGE<br/>keda-hpa-go-prom-app   Deployment/go-prom-app   1830m/3 (avg)   1         10        6          4m22s</span></pre><p id="8774" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果负载不持续，则<code class="fe kp kq kr ks b">Deployment</code>将按比例缩小到只有一个<code class="fe kp kq kr ks b">Pod</code>运行的程度</p><p id="85df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用以下命令检查实际指标(由PromQL查询返回)</p><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="c516" class="nh lb it ks b gy ni nj l nk nl">curl -g 'http://localhost:9090/api/v1/query?query=sum(rate(http_requests[2m]))'</span></pre><h1 id="eff0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">打扫卫生</h1><pre class="me mf mg mh gt nd ks ne nf aw ng bi"><span id="7dc1" class="nh lb it ks b gy ni nj l nk nl">//Delete KEDA<br/>kubectl delete namespace keda</span><span id="badb" class="nh lb it ks b gy ny nj l nk nl">//Delete the app, Prometheus server and KEDA scaled object<br/>kubectl delete -f .</span><span id="c26b" class="nh lb it ks b gy ny nj l nk nl">//Delete Redis<br/>helm del --purge redis-server</span></pre><h1 id="77c1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="e116" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">KEDA允许您根据外部指标(如普罗米修斯指标、Redis中的队列长度、Kafka主题的消费者延迟等)的数据自动扩展您的Kubernetes部署(从零扩展到零)。它完成了与外部资源集成的所有繁重工作，并通过度量服务器公开其度量，以便水平Pod自动缩放器发挥其魔力！</p><p id="390f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个博客到此为止。此外，如果你觉得这篇文章有用，请喜欢并关注😃😃</p></div></div>    
</body>
</html>