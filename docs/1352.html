<html>
<head>
<title>Level up your NgRx game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级你的NgRx游戏</h1>
<blockquote>原文：<a href="https://itnext.io/level-up-your-ngrx-game-42652afc25bd?source=collection_archive---------1-----------------------#2018-09-21">https://itnext.io/level-up-your-ngrx-game-42652afc25bd?source=collection_archive---------1-----------------------#2018-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6f07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然你在这里，很可能你已经在你的Angular应用中使用了NgRx。无论如何，我想引用它的官方网站来简单介绍一下。</p><blockquote class="kl km kn"><p id="cd61" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">@ngrx为Angular应用中的反应式编程提供了一套干净的、经过充分测试的库。—<a class="ae ks" href="http://ngrx.github.io/" rel="noopener ugc nofollow" target="_blank">http://ngrx.github.io/</a></p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/18d3bc9c7cc1a6447840e80914e134a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zpbjCn8betvlI3FN5fiyQ.png"/></div></div></figure><p id="8eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从去年开始，我一直在使用NgRx为我们的一个企业客户构建相当复杂的应用程序。</p><p id="56f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的NgRx之旅包括使用最新版本的NgRx构建一个全新的应用程序，将一个有状态的Angular应用程序迁移到一个反应式应用程序，以及将一个旧的NgRx应用程序迁移到最新版本。</p><blockquote class="lf"><p id="6304" class="lg lh iq bd li lj lk ll lm ln lo kk dk translated">我想通过给NgRx的现有用户和完全初学者一些提示和技巧来分享我迄今为止的经验。</p></blockquote></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="0893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文中的例子基于NgRx v6，它使用动作类，而不是创建类。要查看这篇博文的最新版本— v8最佳实践示例，您可以观看我在2019年5月在维罗纳举行的<a class="ae ks" href="https://2019.angularday.it/" rel="noopener ugc nofollow" target="_blank"> angularday会议</a>上的演讲:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="c050" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用示意图</h1><p id="321b" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">如果你不熟悉《角度世界》里的原理图是什么，请先看看<a class="ae ks" href="https://blog.angular.io/schematics-an-introduction-dc1dfbc2a2b2" rel="noopener ugc nofollow" target="_blank">这个帖子</a>。</p><p id="b227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NgRx团队在版本5中引入了@ngrx/schematics。如果你想减少<strong class="jp ir">样板</strong>，你肯定会喜欢这个。它也将帮助你与非官方现有的风格指南保持一致。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nb"><img src="../Images/85f1206a6b56cd51c2d658af3c301dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUTKaZwLFTOu6N_esrzXEQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">NgRx团队喜欢样板文件上的抱怨。布兰登别挡着我，兄弟。说真的。</figcaption></figure><p id="0bf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NgRx schematics的一个好方法是将其设置为角度应用的默认集合。安装@ngrx/schematics后，执行以下操作，将其设置为Angular应用程序的默认集合。</p><pre class="ku kv kw kx gt ni nj nk nl aw nm bi"><span id="f187" class="nn lz iq nj b gy no np l nq nr">ng config cli.defaultCollection @ngrx/schematics</span></pre><p id="41c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用3个简单的CLI命令，您可以为新的反应式特性生成样板代码，包括测试床配置。它的结构与<a class="ae ks" href="https://github.com/ngrx/platform/tree/master/projects/example-app" rel="noopener ugc nofollow" target="_blank"> NgRx example-app </a>中的完全一样。</p><pre class="ku kv kw kx gt ni nj nk nl aw nm bi"><span id="9414" class="nn lz iq nj b gy no np l nq nr">ng g module user --flat false<br/>ng g feature user/store/user --module ./user/user.module.ts --group<br/>ng g container user/containers/UsersPage</span></pre><blockquote class="lf"><p id="6ce2" class="lg lh iq bd li lj ns nt nu nv nw kk dk translated">实际上这是一件大事！</p></blockquote><figure class="ny nz oa ob oc ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nx"><img src="../Images/eef55e9a7cfb6c390b1c03109448df35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkUuvUhjyXN41tz6ecS_Nw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">与示例应用中相同的文件夹结构—<a class="ae ks" href="https://github.com/ngrx/platform/tree/master/projects/example-app" rel="noopener ugc nofollow" target="_blank">https://github . com/ngrx/platform/tree/master/projects/example-app</a></figcaption></figure><p id="9b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进一步的使用说明可以看一下文档—<a class="ae ks" href="https://github.com/ngrx/platform/tree/master/docs/schematics" rel="noopener ugc nofollow" target="_blank">https://github . com/ngrx/platform/tree/master/docs/schematics</a>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5f69" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">保持良好的行动卫生</h1><p id="5e38" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">动作是NgRx应用程序的基础。良好的行为卫生能够同时帮助业务开发和软件工程师，这一点非常重要。</p><blockquote class="lf"><p id="700c" class="lg lh iq bd li lj lk ll lm ln lo kk dk translated">好的行动是一年后你可以阅读的行动，并告诉你他们被派遣到哪里。—迈克·瑞安</p></blockquote><p id="ee5b" class="pw-post-body-paragraph jn jo iq jp b jq od js jt ju oe jw jx jy of ka kb kc og ke kf kg oh ki kj kk ij bi translated">正如<a class="ng nh ep" href="https://medium.com/u/d6ba4dcb6838?source=post_page-----42652afc25bd--------------------------------" rel="noopener" target="_blank"> Mike Ryan </a>在他的<a class="ae ks" href="https://www.youtube.com/watch?v=JmnsEvoy-gY" rel="noopener ugc nofollow" target="_blank">T5】良好行动卫生与NgRx 谈话</a>中所说，糟糕的流程导致糟糕的应用程序质量。我想从他的演讲中强调一些常见的陷阱作为参考，希望它能帮助更多的人避免它们。</p><h2 id="9a0b" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">不要重复使用动作</h2><blockquote class="lf"><p id="c314" class="lg lh iq bd li lj lk ll lm ln lo kk dk translated">动作应该捕捉事件，而不是命令。</p></blockquote><p id="a060" class="pw-post-body-paragraph jn jo iq jp b jq od js jt ju oe jw jx jy of ka kb kc og ke kf kg oh ki kj kk ij bi translated">试着在你的系统中将你的行为建模为独特的事件，这样一年后你就可以很容易地理解它从何而来。</p><blockquote class="lf"><p id="0c80" class="lg lh iq bd li lj lk ll lm ln lo kk dk translated">决策者应该是减少者和影响者</p></blockquote><p id="b5b0" class="pw-post-body-paragraph jn jo iq jp b jq od js jt ju oe jw jx jy of ka kb kc og ke kf kg oh ki kj kk ij bi translated">在你的应用中，将事件的描述和处理方式分开。把决定权留给你的还原器和效果，你的组件不应该决定状态如何改变。</p><h2 id="7416" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">避免使用通用操作类型</h2><p id="3c32" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">当你查看你的代码或者你存储的devtools日志时，每个人都应该清楚你的应用程序是如何运行的，以及事件的来源是什么。</p><p id="7286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特别是对于开发团队来说，在一个大的应用程序中精确定位任何一个动作对每个人的帮助都是超乎你想象的。</p><p id="55a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现这一点的一个好方法是使用<strong class="jp ir">【源】事件</strong>格式。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ot"><img src="../Images/426c8af80e2f9523384700f9964713eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADAIkM4nl5cXt-rNQ8WNbg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">通用操作与专用操作Mike演示中的一个例子</figcaption></figure><h2 id="a4c1" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">不要做动作打字</h2><p id="51d6" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">这个缺陷与动作重用密切相关。如果你避免了第一个陷阱，你就不会陷入其中。不要强迫它用子类型来构建通用的动作，并且尽可能地让你的动作具有独特性。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ou"><img src="../Images/be7162fc6d9db6c415dbae40ebf83ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPKkCU2TcXq4JzTNtsda4g.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">reducer中的嵌套条件Mike演示中的一个例子</figcaption></figure><p id="a7bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">落入这个陷阱可能会在整个应用程序中引入条件分支。当它们随着应用程序规模的扩大而增加时，维护它们将是一件痛苦的事情。在reducers和effects中避免嵌套条件！</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="47fc" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">用@ngrx/entity简化您的减速器</h1><p id="6aca" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">NgRx团队努力减少样板文件。这是建立这样一个图书馆的原因之一。但是还有更多！</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ov"><img src="../Images/11cdd42db70c09fe6993bb2730357df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DbLGpELLE-GzELkqP0Ultg.png"/></div></div></figure><p id="09d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能要处理存储中的集合，用庞大而复杂的实体集合维护存储数据可能会让您头疼，更不用说它会给您的reducers带来样板代码了。</p><p id="b970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">@ngrx/entity是来拯救简化你的reducers和域模型的。</p><h2 id="bf44" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">实体状态</h2><p id="d002" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">设置实体适配器后，实体状态在存储中将如下所示。</p><pre class="ku kv kw kx gt ni nj nk nl aw nm bi"><span id="a408" class="nn lz iq nj b gy no np l nq nr">interface EntityState&lt;T&gt; {<br/>  ids: string[];<br/>  entities: { [id: string]: T };<br/>}</span></pre><p id="1ab0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在实体状态中维护实体字典和id列表有几个原因:</p><ol class=""><li id="9b3f" class="ow ox iq jp b jq jr ju jv jy oy kc oz kg pa kk pb pc pd pe bi translated">为了让你的收藏和字典一样有序，你需要一个有序列表。这就是为什么ids数组是实体状态的一部分。</li><li id="463d" class="ow ox iq jp b jq pf ju pg jy ph kc pi kg pj kk pb pc pd pe bi translated">如果您以列表形式维护数据，查找操作在大多数情况下都是开销很大的操作。与通过数组搜索相比，对实体使用字典要快得多。</li></ol><h2 id="c10c" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">CUD操作(创建、更新、删除)</h2><p id="5029" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">实体适配器为商店中的CUD需求带来了许多有用的方法。</p><p id="ea81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看下面我的应用内事件例子，看看可用的操作，以及部分改变对象的不同用例。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="pk lx l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">实体适配器和一些CUD操作— reducer</figcaption></figure><h2 id="d3d9" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">默认选择器</h2><p id="c706" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">您的实体适配器实例为您导出了4个有用的选择器。您可以将它们导出到您的选择器文件中，如果需要的话，还可以导出您的自定义文件。</p><pre class="ku kv kw kx gt ni nj nk nl aw nm bi"><span id="f492" class="nn lz iq nj b gy no np l nq nr">export const {<br/>  selectIds,<br/>  selectEntities,<br/>  selectAll,<br/>  selectTotal,<br/>} = yourEntityAdapter.getSelectors();</span></pre><h2 id="d6db" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">如果您有太多的领域模型，请使用ngrx-data</h2><p id="2675" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">如果你想把领域模型的样板代码减少到另一个水平，你可能想看看T2的ngrx数据库。它还不是官方@ngrx/platform的一部分，但他们宣布很快就会是了。</p><p id="9e41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它不是ngrx的替代方案，而是It扩展管理域模型的一个额外特色。正如他们的文件所述:</p><blockquote class="kl km kn"><p id="dc38" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">许多应用程序都有大量的<em class="iq">域模型</em>，其中有10或100个<a class="ae ks" href="https://github.com/johnpapa/angular-ngrx-data/blob/master/docs/faq.md/#entity" rel="noopener ugc nofollow" target="_blank">实体类型</a>，如<em class="iq">客户</em>、<em class="iq">订单</em>、<em class="iq">行项目</em>、<em class="iq">产品</em>和<em class="iq">用户</em>。</p><p id="c8c6" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">简单地说，为每个实体类型创建、检索、更新和删除(CRUD)数据是一项艰巨的任务。您正在编写<em class="iq">动作</em>、<em class="iq">动作创建者</em>、<em class="iq">减少者</em>、<em class="iq">效果</em>、<em class="iq">分派者</em>和<em class="iq">选择器</em>，以及每个实体类型的HTTP GET、PUT、POST和DELETE方法<em class="iq">。</em></p><p id="ac8e" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">即使在一个小模型中，这也是大量重复的代码来创建、维护和测试。</p><p id="b7ef" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq"> ngrx-data </em>库是<em class="iq">保持在<em class="iq"> ngrx </em>路径上的一种</em>方式，同时从根本上减少了使用<em class="iq"> ngrx </em>管理实体所必需的“样板文件”。</p></blockquote><blockquote class="lf"><p id="20b8" class="lg lh iq bd li lj ns nt nu nv nw kk dk translated">如果您还没有在ngrx应用程序中使用@ngrx/entity，我强烈建议您这样做。你可以在下面的介绍文章中了解更多。</p></blockquote><div class="ny nz oa ob oc pl"><a href="https://medium.com/ngrx/introducing-ngrx-entity-598176456e15" rel="noopener follow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ir gy z fp pq fr fs pr fu fw ip bi translated">@ngrx/entity简介</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">关于用NgRx构建应用程序，最常见的抱怨之一是开发人员不得不…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">medium.com</p></div></div></div></a></div></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="8ca7" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">认真使用选择器</h1><p id="edbe" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">选择器是一个纯粹的函数，它将你的状态分割成一部分。它们是过滤掉状态对象的小查询函数。除了在视图层中使用选择器之外，还可以在其他选择器上组合选择器函数。</p><p id="10e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你应该开始使用选择器，既要符合<a class="ae ks" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则</a>又要考虑性能。纯选择器函数将帮助您避免在每次需要状态时对其进行切片，最终避免您重复自己。对于它带来的性能优势，让我们来看看NgRx选择器文档中的以下引文:</p><blockquote class="kl km kn"><p id="a741" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">因为选择器是<a class="ae ks" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>，所以当参数匹配时可以返回最后的结果，而不需要重新调用选择器函数。这可以提供性能优势，特别是对于执行昂贵计算的选择器。这种做法被称为<a class="ae ks" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆</a>。</p><p id="0d4a" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">— NgRx选择器文档</p></blockquote><p id="1717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是选择器的一个用法示例，包括从不同的特性组合选择器:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="pk lx l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">撰写选择器—选择器</figcaption></figure><p id="b66e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看选择器高级用例的官方文档，它一定会帮助你解决你的app中的复杂问题:<a class="ae ks" href="https://github.com/ngrx/platform/blob/master/docs/store/selectors.md" rel="noopener ugc nofollow" target="_blank">https://github . com/ngrx/platform/blob/master/docs/store/selectors . MD</a></p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="f29a" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">保持你的店铺整洁</h1><p id="4400" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">NgRx store上的一个常见争论是哪个状态实际上属于该存储。当我在youtube 上看到<a class="ng nh ep" href="https://medium.com/u/d6ba4dcb6838?source=post_page-----42652afc25bd--------------------------------" rel="noopener" target="_blank">迈克·瑞安</a>和<a class="ng nh ep" href="https://medium.com/u/637b8a3ce256?source=post_page-----42652afc25bd--------------------------------" rel="noopener" target="_blank">布兰登</a>的<a class="ae ks" href="https://www.youtube.com/watch?v=t3jx0EC-Y3c" rel="noopener ugc nofollow" target="_blank">和<em class="ko">用NgRx </em> talk减少样板文件时，我的脑海里立刻产生了这个想法。我已经在思考这个问题，并在没有他们在演讲中清楚介绍的结构的情况下评估我的应用程序的状态。</a></p><p id="f267" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们提出的结构无疑有助于决定哪个州属于商店。</p><p id="2683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是<strong class="jp ir"> SHARI </strong>！如果您的状态符合以下任何类别，您应该将其保留在商店中。</p><p id="5592" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi pu translated"><span class="l pv pw px bm py pz qa qb qc di"> S </span>共享<br/> — <em class="ko">共享状态被许多组件和服务访问</em></p><p id="f974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi pu translated"><span class="l pv pw px bm py pz qa qb qc di"> H </span>水化<br/> — <em class="ko">储存后持续水化的状态</em></p><p id="e7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi pu translated"><span class="l pv pw px bm py pz qa qb qc di">一个</span>可用<br/>——重新输入路线时需要可用的状态</p><p id="b2d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi pu translated"><span class="l pv pw px bm py pz qa qb qc di"> R </span> etrieved <br/> —需要恢复的有副作用的状态</p><p id="e31e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi pu translated"><span class="l pv pw px bm py pz qa qb qc di"> I </span>受影响<br/>——受其他来源的行动影响的状态</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="e70d" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated"><strong class="ak">序列化和水合</strong></h1><p id="e1d0" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">如果你像我一样，你可能更喜欢在用户的浏览器存储中为你的应用程序商店的一部分持久化数据——比如应用程序设置，并水合它。这可以通过meta减速器来实现。</p><h2 id="edae" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">序列化</h2><p id="57f8" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">只是在存储数据时要小心序列化。您的数据必须是可序列化的，这意味着您不能将Map()或Set()对象实例放在存储中。</p><p id="06c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查对象是否可序列化的一个简单方法是，简单地将原始对象与以下输出进行比较:</p><pre class="ku kv kw kx gt ni nj nk nl aw nm bi"><span id="0167" class="nn lz iq nj b gy no np l nq nr">JSON.parse(JSON.stringify(obj))</span></pre><h2 id="742b" class="nn lz iq bd ma oi oj dn me ok ol dp mi jy om on mm kc oo op mq kg oq or mu os bi translated">持久储存和水合作用</h2><p id="fba6" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">我使用<a class="ae ks" href="https://www.npmjs.com/package/ngrx-store-localstorage" rel="noopener ugc nofollow" target="_blank"> ngrx-store-localstorage包</a>将存储数据持久化到localstorage中。下面是一个使用meta reducer实现的示例:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="pk lx l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">您商店的持久存储— reducer</figcaption></figure><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="pk lx l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">商店的持久存储—功能模块</figcaption></figure><p id="1499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，NgRx团队已经宣布，下一个版本7将内置对水合和序列化的支持。</p><p id="7699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，很期待！查看下面的公告，了解更多新闻。</p><div class="qd qe gp gr qf pl"><a href="https://medium.com/ngrx/announcing-the-release-of-ngrx-6-new-projects-and-looking-ahead-5fc30bed260b" rel="noopener follow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ir gy z fp pq fr fs pr fu fw ip bi translated">宣布NgRx 6的发布、新项目和展望</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">今天，我们很兴奋地宣布NgRx框架的v6正式发布。这个版本充满了错误…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">medium.com</p></div></div><div class="qg l"><div class="qh l qi qj qk qg ql ld pl"/></div></div></a></div></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="c97c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关注我的<a class="ae ks" href="https://twitter.com/onderceylan" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Twitter </strong> </a>以获得更多类似本文中的提示。</p><p id="7a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得这篇文章有用，请不要忘记<strong class="jp ir">鼓掌</strong>和<strong class="jp ir">关注</strong>。<em class="ko">愿纯净与您的功能和部件同在！</em></p></div></div>    
</body>
</html>