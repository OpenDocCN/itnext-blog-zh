<html>
<head>
<title>Build an Enterprise Scalable Dashboard using Angular — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular构建企业级可扩展仪表板—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/build-an-enterprise-scalable-dashboard-using-angular-part-2-104acc38bea3?source=collection_archive---------3-----------------------#2019-07-30">https://itnext.io/build-an-enterprise-scalable-dashboard-using-angular-part-2-104acc38bea3?source=collection_archive---------3-----------------------#2019-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e0cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@buttars/build-an-enterprise-scalable-dashboard-using-angular-155aa4280a74" rel="noopener">第1部分</a>中，我们讨论了如何利用动态组件呈现将仪表板内容与仪表板本身分开。在这一部分中，我们将讨论如何在轨道中添加/删除项目，如何为仪表板上的各个卡片进行服务调用，以及如何在维护状态的同时实现拖放。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="8681" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">添加和删除项目</h1><h2 id="d6c0" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jy lw lx lh kc ly lz ll kg ma mb lp mc bi translated">在开始之前</h2><p id="95e6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">Angular的最佳实践是将共享状态转移到可以在应用程序的多个组件间使用的服务中。因为我们在dashboard.component.ts中声明了我们的跟踪，所以任何其他组件都无法直接访问它，包括仪表板内容。为了能够从仪表板组件本身之外的任何地方添加或删除卡片，我们需要将tracks变量移动到服务中。</p><p id="dfab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，理解可观察服务的概念是很重要的。可观察服务是以可观察的形式返回数据(通常是状态)的常规服务。如果你不熟悉可观察服务的概念以及它们的优缺点，我推荐你阅读<a class="ae kl" href="https://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，它更深入地讨论了这个主题。现在，这将允许我们共享仪表板状态，这将很快有用。</p><p id="7707" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，生成仪表板服务。然后将tracks数组从dashboard.component.ts复制到您的服务中。我还将变量重命名为<em class="mi"> defaultState </em>。</p><p id="51f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/4fe5bc80c7b166e744602e220188f06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1s7NlolJt5fAFx26g39Rg.png"/></div></div></figure><p id="d38f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，创造一个我们可以给出数据的主体。一个<a class="ae kl" href="http://reactivex.io/rxjs/manual/overview.html" rel="noopener ugc nofollow" target="_blank">主题</a>就像一个EventEmitter，能够拥有多个观察者。在我们的例子中，我们想用一个行为主体。BehaviorSubject将向新的侦听器发出最后一个给定值。我们可以通过调用this.subject.asObservable()从我们的主题创建一个可观察对象，我将该变量命名为tracks$。</p><p id="1434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/c28464a46a2ba299cb8d935927945d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoD-CrC94v19sVV5OJPoPA.png"/></div></div></figure><p id="9434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，从仪表板组件的服务中检索曲目。</p><p id="34f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.component.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mw"><img src="../Images/d4fdd1b7a218bbe246f8f3417e819c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbOejMH7Bt7aUxQcyjTHoQ.png"/></div></div></figure><p id="081d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以开始在仪表板上添加和删除曲目。</p><h2 id="66f8" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jy lw lx lh kc ly lz ll kg ma mb lp mc bi translated">移除项目</h2><p id="0fd1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了移除项目，在仪表板服务上创建一个方法，我将其命名为removeItem。Removed item将某个项目作为参数，并尝试从tracks状态中删除该项目，并将更改推送到主题。</p><p id="1b5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要从主题获取状态，请调用subject.getValue()。这将给我们一个主题在那个时间点的快照。现在我们有了快照，可以开始操作它了。</p><p id="5ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mx"><img src="../Images/5a129833628adebc4b30f6d42a5d18b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OP_IY9Hn_iRjCaOc6dcgiQ.png"/></div></div></figure><p id="ea07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过循环状态数组中的每个轨迹来移除项目。然后，对于每个轨道，在轨道中的项目上循环。如果循环中的项目与作为参数提供的项目相匹配，那么我们希望将它从轨道中拼接出来。完成后，我们希望通过调用this.subject.next()将新状态再次传递给主题。</p><p id="6d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mx"><img src="../Images/d535371ca7cbde869fcb2f850a6e50fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zii-APSjAi4q6c24MnV3vA.png"/></div></div></figure><h2 id="3ae5" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jy lw lx lh kc ly lz ll kg ma mb lp mc bi translated">添加项目</h2><p id="cc73" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">创建一个名为addItem的方法，该方法将获取一个项目并将其添加到其中一个轨道。我选择将新物品推到物品最少的赛道。可选:在添加项目之前，您可能希望验证项目不存在于任何一个轨道上，以防止重复。</p><p id="1336" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi my"><img src="../Images/78f420615ffeb5d4a259a68398547cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgrcRPv-5zrvFcfuw8TO7g.png"/></div></div></figure><p id="3218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们可以使用addItem/removeItem方法之前，我们必须了解如何从仪表板内容中进行单独的服务调用，这将在下一节中介绍。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="f8ba" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">调用服务并将状态传递到仪表板内容中</h1><p id="186d" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">将内容状态从仪表板中分离出来是非常强大的。它允许我们独立地创建仪表板内容，表示为卡片，而在仪表板组件中没有任何特定于内容的逻辑。如果您在企业环境中工作，将仪表板与内容的状态分离允许多个组织创建、管理和维护他们负责的仪表板内容，而无需接触仪表板组件本身。例如，财务部门可能想要创建一个金融卡来显示财务事项。当他们这样做时，除了dashboard-cards.enum.ts和dashboard-cards.ts之外，他们不需要接触任何东西。</p><p id="bf6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个示例，继续创建另一个名为HelloService的服务。该服务将保存一个姓名列表，可以通过仪表板内容检索到该列表。同样，在HelloWorldComponent上添加Input() <em class="mi"> name </em>，并在组件模板中显示它。</p><p id="30ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> hello-world.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/c9c9b43e736447c042de9a8997c21713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DkkF9DA6qFXuQUfIEYBsaQ.png"/></div></div></figure><p id="6232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">hello-world . component . ts</em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/821c50aaba69e9b74424b5cbf4516348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPCogoClyyCQs6w8_yf7WA.png"/></div></div></figure><p id="f630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">hello-world.component.html</em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/47d79618adce0df435656150404125c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjQcIlTRdtbazwqLJ4JNaw.png"/></div></div></figure><p id="a5dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您按照教程进行操作，您将在第一部分创建了一个HelloWorldContainer组件。容器应该调用服务，检索它需要的信息，并通过子组件的Input()属性将其传递给内容。</p><p id="306b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们将容器映射到跟踪项目的方式，仪表板上的每个唯一项目都必须有一个容器。这是因为容器必须调用服务来检索数据，并且根据您构建组件的方式，这可能会限制任何特定容器的可重用性。</p><p id="b7eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了检索不同的数据，我将生成第二个容器hello-world-two.container.ts，并将其添加到entryComponents，这与我们用于hello-world.container.ts的过程相同。</p><p id="cdb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个容器将从HelloService中检索一个名称，并将其传递给HelloWorldComponent。唯一的区别是每个容器检索的名称。</p><p id="77e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> hello-world.container.ts </em>和<em class="mi">hello-world-two . container . ts</em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mz"><img src="../Images/db30a67144c910d904cf673d0dcd68c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUjpbwXvUNZD-g6gwR7WjQ.png"/></div></div></figure><p id="a8fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在进入dashboard-cards.ts和dashboard-cards.enum.ts并添加另一个条目HELLO_WORLD_TWO。</p><p id="8aa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">仪表板-卡片. ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/c4455fc3d669d0edf5e6450fa8626852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMBAEf6wnpyTNqcrbM6MDA.png"/></div></div></figure><p id="f18c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">仪表盘-cards.enum.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mv"><img src="../Images/a64382f8d5177f37bca872b651b780f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmYwMnU3gyuLV0AbVCnXFg.png"/></div></div></figure><p id="67d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在dashboard.service.ts中，将第二个项目的组件更改为“HELLO_WORLD_TWO”。</p><p id="9b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">保存更改，您可以看到仪表板上现在有两张内容不同的卡片。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1e61ee5eea6c628f7a7d6cb8316d647e.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*9lI1Yknl53RLDZwmL-ydOQ.png"/></div></figure><p id="e0f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">万岁！！！现在我们已经构建了一个解耦的静态仪表板。在下一节中，我们将使内容可拖动。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="a288" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实现拖放</h1><p id="236a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">拖放通常是一项非常困难而又平凡的任务。幸运的是ng2-dragula让这变得非常容易。继续安装它。纱线添加ng2-dragula。在<a class="ae kl" href="https://github.com/valor-software/ng2-dragula#Setup" rel="noopener ugc nofollow" target="_blank"> dragula repo </a>中有一个您需要遵循的安装说明列表。Dragula也需要导入仪表板模块。</p><p id="8a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要实现拖放，我们只需添加dragula和dragulaModel指令以及dragulaModelChanged事件。dragula指令简单地标识了给定轨道应该属于哪个组。在我们的例子中，它们都属于<em class="mi">仪表板</em>组。dragulaModel指令指定dragula轨道应该包含哪些项目。这将与我们的曲目数据同步。我们还需要一些css来确保当轨道为空时，轨道不会缩小到0大小，这样我们就可以把东西拖回来。</p><p id="9547" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">dashboard.component.html</em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nb"><img src="../Images/83f547fb98544857e0d5cdb3edef8cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcTbkeMhhb7IIjB4M4Q1Ng.png"/></div></div></figure><p id="53f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">dashboard . component . scss</em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nc"><img src="../Images/d4629403b12d1b22ff1c31f3c63b568f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3-YDHP5fOOfzEF11ghgGw.png"/></div></div></figure><p id="ccb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些补充，卡片现在是可拖动的了。厉害！现在开始存储一些状态。</p><h2 id="bbf5" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jy lw lx lh kc ly lz ll kg ma mb lp mc bi translated">存储状态</h2><p id="197f" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了在拖放时保持变化，我们必须做一些事情。</p><p id="319f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须获取由dragulaModelChanged事件发出的已更改状态，并在服务中设置它。我们将需要一种方法来获取轨迹的整个状态，并将它们推入主题中。将名为setState的方法添加到DashboardService中。setState需要一个轨道数组，并相应地设置状态。</p><p id="d0aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nc"><img src="../Images/9629a2b2744a6b36c071d954df7da213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3DrBUK7zX1Ib1hDGcS-Kg.png"/></div></div></figure><p id="0f69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当轨道发生变化时，我们将在仪表板组件中调用它。</p><p id="06d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dragulaModelChanged将发出一个事件，该事件在拖放后返回传递给dragulaModel的数组以及相应的更改。问题是它只返回特定轨道的单个项目，而不是轨道的数组。这意味着我们必须知道哪个轨道的项目被改变了。为此，我们可以在仪表板模板中轻松添加对tracks ngFor循环索引的引用。这将为我们提供dragulaModelChanged所指的轨道的参考。</p><p id="37ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在仪表板组件上创建一个名为changed的方法。更改后的方法将接受track和trackIndex。一旦调用changed，它将检索当前状态并应用从事件中给我们的更改。一旦有了对修改状态的引用，就将其传递给setState来更新服务。</p><p id="11de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.component.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nc"><img src="../Images/a7739cc5d3ed1c29c6c539869fef0ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVET7kUd3_YPvXIL1S7uzA.png"/></div></div></figure><p id="d724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以将dragulaModelChanged事件添加到我们的div并调用Changed。</p><p id="ee3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dashboard.component.html<em class="mi"/></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nd"><img src="../Images/a944bffa0d83612021d8582fe7d9ef93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSQP0ke4M7wY4QCWQ82tXg.png"/></div></div></figure><p id="25f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在事情变得奇怪了。因为我们正在更新指示需要呈现什么的对象，所以我们必须告诉变更检测来检查变更，只有这样我们才重新加载内容。如果您按错误的顺序操作，loadContents方法将没有正确的ng模板来呈现组件。添加detectChanges调用的最佳位置是tracks订阅中。每当dashboard服务中的subject获得一个新值时，就会调用这个订阅，在我们的例子中，就是当卡片被拖放时。</p><p id="b6c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.component.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nc"><img src="../Images/0e6c3f67798f7911a16ec7f6329dc8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50eQWQXq2wm4RRVhgQaiQQ.png"/></div></div></figure><p id="7b9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">耶，当我们拖动时状态是一致的！！剩下要做的就是拯救这个国家。</p><h2 id="072c" class="lr ku iq bd kv ls lt dn kz lu lv dp ld jy lw lx lh kc ly lz ll kg ma mb lp mc bi translated">保存仪表板状态</h2><p id="d499" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">保存仪表板状态非常简单。我们所要做的就是将仪表板轨道存储在本地存储中(或者任何你想要的地方),并在启动时加载它。我们还将实现一个默认配置，以防用户第一次访问仪表板。</p><p id="4d1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在仪表板服务上创建一个名为loadFromLocalStorage的方法。这将获取仪表板状态并更新服务。</p><p id="6ca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ne"><img src="../Images/065d077281d1f37d8450c8c31f21eb19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqAJEWWfe5u64htql5Wi2g.png"/></div></div></figure><p id="21a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建另一种方法；saveTracksToStorage。顾名思义，它将曲目作为字符串保存到localstorage。</p><p id="dff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ne"><img src="../Images/1b85bc0543e0a732a39cf706001840e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvr7OfmEf-gFYHS_DNG98A.png"/></div></div></figure><p id="99ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要保存对跟踪的未来更新，请订阅仪表板服务构造函数中的tracks$。在此之前，我们需要确保并调用this.loadTracksFromStorage，以便获得最近保存的状态。</p><p id="2989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"> dashboard.service.ts </em></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ne"><img src="../Images/5b2287a5888a064d07a1c9a073c96f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aH9FXN5GlGoPRBa8xaa81w.png"/></div></div></figure><p id="e39f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后嘣！</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/225e309ce1841ab2ebfb6e50d72497d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*2HnpRxMb3Ie16AymkcaX-g.png"/></div></figure><p id="f24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有一个动态的可拖动仪表板，它的状态完全独立于内容！</p><p id="1874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">源代码:<a class="ae kl" href="https://stackblitz.com/github/buttars/enterprise-dynamic-dashboard/tree/part-2" rel="noopener ugc nofollow" target="_blank">https://stack blitz . com/github/but tars/enterprise-dynamic-dashboard/tree/part-2</a></p><p id="5c27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这两部分系列。如果你做到了，我会很感激你给它一些掌声。(如果你觉得特别慷慨，最多50英镑)。</p><p id="acca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会在下面的评论中回答尽可能多的问题，所以请随意提问。</p></div></div>    
</body>
</html>