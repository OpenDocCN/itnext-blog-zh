<html>
<head>
<title>Comparing freezed to built_value</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将冻结值与构建值进行比较</h1>
<blockquote>原文：<a href="https://itnext.io/comparing-freezed-to-built-value-3ff978c8647?source=collection_archive---------2-----------------------#2020-02-15">https://itnext.io/comparing-freezed-to-built-value-3ff978c8647?source=collection_archive---------2-----------------------#2020-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2ee7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[更新，2020年3月20日:我在freezed发布后不久写了这篇文章。这篇文章的许多观点不再有效]</p><p id="5975" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Remi Rousselet最近发布了<a class="ae kl" href="https://pub.dev/packages/freezed" rel="noopener ugc nofollow" target="_blank"> freezed </a>，这是一个用于生成不可变数据类和联合类型的库。</p><p id="4019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很自然，我很好奇。我们使用built _ value来创建不可变的模型对象，使用JSON序列化和反序列化来与API通信，我们对此非常满意。</p><p id="4424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们对一些具有内置价值的东西感到恼火:</p><ul class=""><li id="4989" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">这需要大量的样板文件</li><li id="6f9f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">它是为Dart 1编写的，这一点仍然值得注意。例如，它进行手动类型检查，而不是依赖编译器、泛型和类型推断。built _ value引入了一些新的方法和构造函数来解决这个问题，但在某些情况下它仍然存在。</li><li id="083a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">代码生成非常慢。对于一个大约24k行代码的项目(不包括生成的代码、空白和注释)，代码生成大约需要1分钟。也就是创建一个build.yaml文件，这样built _ value generator只在模型对象上运行。结果应该被缓存，但是根据我的经验，即使是很小的改变也会触发一次完整的重建。</li></ul><p id="c504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我决定看看冷冻是否更适合我们。以下是我的发现:</p><h2 id="333c" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">简单的不可变模型对象</h2><p id="95f5" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">这是冻结价值和构建价值的主要来源。冰封真的在这里大放异彩。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用冻结的简单不可变对象</figcaption></figure><p id="62c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内置值:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用built _ value的简单不可变对象</figcaption></figure><p id="fda3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">冷冻版要短得多，没有重复。对于built _ value，如果希望拥有一个接受对象所有变量的工厂，需要两次输入所有变量。</p><p id="8fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以使用代码模板来生成新模型:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="mj me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">从模板生成新的数据类</figcaption></figure><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Android Studio +冻结的实时模板</figcaption></figure><p id="1654" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> JSON序列化/反序列化</strong></p><p id="47c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">freezed根本不处理这个问题，但是它将所有工作委托给json_serializable。对于简单对象，我们所要做的就是添加另一个名为fromJson的工厂:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用冻结的JSON(反)序列化</figcaption></figure><p id="c900" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样，a .托吉森()和。fromJson()方法将被创建。</p><p id="071f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于built _ value，需要做更多的工作:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用built _ value的JSON(反)序列化</figcaption></figure><p id="b0c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您必须创建一个序列化程序，并且需要创建自己使用该序列化程序的toJson()和from()方法。此外，您必须创建一个全局serializer对象，其中您需要注册所有想要序列化的根类型(此处省略)</p><h2 id="4023" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">枚举</h2><p id="ca43" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">我不喜欢“字符串型”的应用程序或神奇的常数，我喜欢对只能包含少量可能值的字段使用枚举。</p><p id="b6e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">built _ value和freezed+json_serializable是如何处理这些的？</p><p id="9652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">冻结:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用freezed(带有json_serializable)的枚举(反)序列化</figcaption></figure><p id="34d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内置值:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用built _ value的枚举(反)序列化</figcaption></figure><p id="f057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">freezed with json_serializable支持dart枚举，这需要更少的样板文件。<br/>然而，built _ value提供了一个json_serializable没有的好特性:</p><p id="b641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以指定一个后备值，以防服务器添加应用程序尚不支持的新字段。在json_serializable中，如何在拥有枚举的对象上处理这个问题，使用类似于:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用freezed进行回退的枚举反序列化</figcaption></figure><p id="246a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果在多个对象中有相同的枚举，就需要在每个对象中指定回退。</p><h2 id="79a0" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">联合</h2><p id="6b5d" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">冻结:</p><p id="698a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Unions是freezed的一流特性，使用起来很容易:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">冻结的工会</figcaption></figure><p id="6683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！您可以在不检查具体类型的情况下访问sharedValue，freezed为您生成了处理所有可能类型的好方法:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0ad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">built _ value并不真正支持联合类型。<br/>你能做的最接近的事情是:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="2f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是您仍然必须使用<strong class="jp ir"> is </strong>操作符来获取联合的具体类型。</p><h2 id="698f" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">更新</h2><p id="3d6c" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">当然，即使你使用不可变的对象，我们也想更新它们。</p><p id="db28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">freezed为每个对象提供了一个简单的copyWith方法:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">用冻结更新字段</figcaption></figure><p id="3993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">built _ value使用一个可变的builder-object来创建一个新模型:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用built _ value更新字段</figcaption></figure><p id="4213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">样板文件稍微多一点，但是如果您想要更改嵌套在几个对象中的值，built _ value具有更好的语法:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">使用built _ value更新嵌套对象</figcaption></figure><p id="b203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在freezed中，语法应该是:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果更新对象，默认情况下，built _ value会为所有字段创建可变的构建器，这使得语法更加简洁。对于大的嵌套对象来说，这会带来性能损失。不过，可以禁用这个特性(代价是更新的语法更加冗长)。</p><h2 id="ba94" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated"><strong class="ak">处理收款</strong></h2><p id="fca8" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">当使用不可变数据类时，您通常不希望使用标准库中的可变集合，否则，您会失去许多好处，并且不再保证对象的不变性。如果您确实使用标准库的集合，您有以下选择:</p><ul class=""><li id="5dba" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">让它们变异，而不是依赖于不变性</li><li id="5858" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">不要改变它们，而是确保每次都复制它们，也许用不可修改的视图包装它们。但是这需要纪律，并且容易出错。</li></ul><p id="5261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原则上冷冻并不限制你在这里的选择。它既支持来自标准库的集合(并使用DeepCollectionEquality对它们进行比较)，也支持像built _ collection或kt.dart这样的自定义不可变集合。</p><p id="86ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，json_serializable在这里更受限制。开箱即用，json_serializable只支持标准列表。您可以指定转换器，但是您必须为您想要序列化的每个类型编写一个新的转换器(例如<code class="fe mk ml mm mn b">ImmutableList&lt;MyModel&gt;</code>和<code class="fe mk ml mm mn b">ImmutableList&lt;MyOtherModel&gt;</code>)。此外，您必须用这个转换器注释每个列表字段:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8c27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在带有需要可序列化的定制集合的模型上使用freezed会给代码添加一大块样板文件，不幸的是，这会否定大多数(如果不是全部)从built _ value保存的样板文件。</p><p id="beb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过为json_serializable创建一个定制的<code class="fe mk ml mm mn b">TypeHelper</code>也许可以避免这种样板文件——但是，没有关于如何做的文档，并且似乎涉及到编写一个运行代码生成的定制构建器——从长远来看，这可能是值得做的，但是似乎不那么容易设置。</p><p id="d57e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑:我为json_serializable编写了一个支持不可变集合的实验性构建器。<a class="ae kl" href="https://pub.dev/packages/json_serializable_immutable_collections#-readme-tab-" rel="noopener ugc nofollow" target="_blank">看看吧！</a></p><h2 id="081d" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">小绳索</h2><p id="55f8" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">i̶t̶'̶s̶̶u̶s̶e̶f̶u̶l̶̶t̶o̶̶s̶e̶t̶̶d̶e̶f̶a̶u̶l̶t̶̶v̶a̶l̶u̶e̶s̶̶o̶n̶̶o̶b̶j̶e̶c̶t̶s̶.̶̶f̶r̶e̶e̶z̶e̶d̶̶d̶o̶e̶s̶̶n̶o̶t̶̶s̶u̶p̶p̶o̶r̶t̶̶t̶h̶i̶s̶̶a̶t̶̶t̶h̶e̶̶m̶o̶m̶e̶n̶t̶,̶̶b̶u̶i̶l̶t̶_̶v̶a̶l̶u̶e̶̶d̶o̶e̶s̶.̶</p><p id="f466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b̶u̶i̶l̶t̶_̶v̶a̶l̶u̶e̶̶s̶u̶p̶p̶o̶r̶t̶s̶̶c̶o̶m̶p̶u̶t̶e̶d̶̶p̶r̶o̶p̶e̶r̶t̶i̶e̶s̶̶t̶h̶a̶t̶̶c̶a̶n̶̶b̶e̶̶m̶e̶m̶o̶i̶z̶e̶d̶；̶̶f̶r̶e̶e̶z̶e̶d̶̶d̶o̶e̶s̶̶n̶o̶t̶̶s̶u̶p̶p̶o̶r̶t̶̶c̶o̶m̶p̶u̶t̶e̶d̶̶p̶r̶o̶p̶e̶r̶t̶i̶e̶s̶̶d̶i̶r̶e̶c̶t̶l̶y̶,̶̶b̶u̶t̶̶y̶o̶u̶̶c̶a̶n̶̶w̶r̶i̶t̶e̶̶a̶n̶̶e̶x̶t̶e̶n̶s̶i̶o̶n̶̶o̶n̶̶y̶o̶u̶r̶̶m̶o̶d̶e̶l̶̶o̶b̶j̶e̶c̶t̶.̶</p><p id="4398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑:Remi给freezed添加新功能几乎比我写这篇文章还要快！freezed现在也支持计算的、缓存的属性和默认值！</p><p id="4635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">built _ value允许您定制在生成<code class="fe mk ml mm mn b">==</code>方法时应该比较哪些字段，freezed当前总是比较所有实例字段。</p><h2 id="99c8" class="la lb iq bd lc ld le dn lf lg lh dp li jy lj lk ll kc lm ln lo kg lp lq lr ls bi translated">代码生成性能</h2><p id="3fd1" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在将我们的项目转换为freezed后，代码生成在我的开发机器上需要大约40秒，这比之前的60秒有了很好的改进。此外，似乎缓存与freezed一起工作得更好，经过一些更改后，build_runner通常只需要几秒钟。</p><h1 id="8a11" class="mo lb iq bd lc mp mq mr lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne bi translated">结论</h1><p id="d46e" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">freezed是一个令人惊叹的库，它使用巧妙的技巧来提供几乎没有样板文件的数据类和联合。<br/>然而，仍然有一些功能缺失，特别是在使用json_serializable时对不可变集合的支持的缺失对我们来说是一个很大的缺点(虽然技术上不是freezed的错)。</p><p id="813e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">freezed几天前才发布，我相信它会很快赶上来。对于新项目，我肯定会选择freezed而不是built _ value在我看来，freezed的长期前景更好。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="c3e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我错过了什么重要的事情或者有什么不正确的吗？请让我知道！</p></div></div>    
</body>
</html>