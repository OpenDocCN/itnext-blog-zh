<html>
<head>
<title>How to create Serverless REST API with Node.js, MongoDB, and AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js、MongoDB和AWS Lambda创建无服务器REST API</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-serverless-rest-api-with-node-js-mongodb-and-aws-lambda-18167fbc4b54?source=collection_archive---------3-----------------------#2020-09-14">https://itnext.io/how-to-create-serverless-rest-api-with-node-js-mongodb-and-aws-lambda-18167fbc4b54?source=collection_archive---------3-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7610dff2645fde2b9dac37a073725434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-Qb7Oz9f7-Kr78Jv1qW9Q.png"/></div></div></figure><div class=""/><h1 id="7098" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">无服务器课程简介第3课</h1><p id="4ddb" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">今天您将学习如何在Node.js中创建MongoDB REST API。</p><p id="3ab4" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在无服务器课程的前几期中，您已经学习了如何设置AWS Lambda无服务器项目。<br/>网址如下:</p><p id="77ee" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae mc" href="https://www.blog.duomly.com/lesson-1-serverless-how-to-get-started-tutorial/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/lesson-1-无服务器-入门指南/ </a></p><p id="a880" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在第二课中，您已经学习了如何使用Node.js和MongoDB创建AWS Lambda无服务器身份验证，URL如下:</p><p id="5f4c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae mc" href="https://www.blog.duomly.com/lesson-2-serverless-authentication/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/lesson-2-server less-authentic ation/</a></p><p id="d385" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我对我们将要构建的内容感到非常兴奋，因为我们将在今天的课程中继续学习，开发更多功能。</p><p id="7c45" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">SaaS应用程序最重要的部分之一是下订单，这也是我们今天要做的。</p><p id="9f11" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将学习如何创建订单，如何更新订单，如何在无服务器框架中处理API端点，以及如何保护它们。</p><p id="ef6e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">开始吧！</p><p id="e7da" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你喜欢视频，这是youtube的版本:</p><h1 id="efd4" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将AuthenticationHelpers.js中的signJWT更改为module.exports.signJWT</h1><p id="240e" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因为在上一课中我忘记了更改它，所以现在我们应该进入AuthenticationHelpers.js文件，将“this”更改为“module.exports”。</p><p id="8019" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们看看整个函数“verifyPassword”应该是什么样子:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="847f" class="mm kc je mi b gy mn mo l mp mq">module.exports.verifyPassword = (sentPassword, realPassword, userId) =&gt; {<br/>  return bcrypt.compare(sentPassword, realPassword)<br/>    .then(valid =&gt; !valid ? Promise.reject(new Error('Incorrect password or username')) : module.exports.signJWT(userId)<br/>  );<br/>}</span></pre><h1 id="c569" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将createdAt添加到User.js并注册函数</h1><p id="a465" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了使所有数据透明，我们应该知道用户是何时创建的。</p><p id="17e0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们需要将“createdAt”字段添加到User.js文件中的用户模型中。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8bc0" class="mm kc je mi b gy mn mo l mp mq">const mongoose = require('mongoose');</span><span id="2750" class="mm kc je mi b gy mr mo l mp mq">const UserSchema = new mongoose.Schema({  <br/>  name: String,<br/>  email: String,<br/>  password: String,<br/>  premium: Boolean,<br/>  premiumEnds: Date,<br/>  createdAt: Date,<br/>});<br/>mongoose.model('User', UserSchema);</span><span id="a4dc" class="mm kc je mi b gy mr mo l mp mq">module.exports = mongoose.model('User');</span></pre><p id="db00" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">接下来，我们应该进入AuthenticationHandler.js文件，进入register函数，并添加该字段。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="67a5" class="mm kc je mi b gy mn mo l mp mq">function register(body) {<br/>  return validRegistration(body)<br/>    .then(() =&gt; User.findOne({ email: body.email }))<br/>    .then(exists =&gt; exists ? Promise.reject(new Error('User exists')) : bcrypt.hash(body.password, 8))<br/>    .then(hashedPass =&gt; User.create({ name: body.name, email: body.email, password: hashedPass, premium: false, createdAt: new Date()}))<br/>    .then(user =&gt; ({ auth: true, token: signJWT(user._id) })); <br/>}</span></pre><h1 id="93b0" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何创建MongoDB模型</h1><p id="75c7" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">好了，现在我们可以开始开发新功能了。</p><p id="3f94" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们应该做的第一步是在名为“Order”的目录中创建Order.js文件。</p><p id="3e47" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">接下来，我们应该为订单创建一个MongoDB模型。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4762" class="mm kc je mi b gy mn mo l mp mq">const mongoose = require('mongoose');</span><span id="643a" class="mm kc je mi b gy mr mo l mp mq">const OrderSchema = new mongoose.Schema({  <br/>  userId: String,<br/>  status: String,<br/>  amount: Number,<br/>  createdAt: Date,<br/>});<br/>mongoose.model('Order', OrderSchema);</span><span id="746f" class="mm kc je mi b gy mr mo l mp mq">module.exports = mongoose.model('Order');</span></pre><h1 id="4e0a" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将createOrder处理程序添加到serverless.yml中</h1><p id="729c" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下一步，我们应该进入serverless.yml并在其中定义第一个AWS Lambda函数。</p><p id="f7c8" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">定义名为“createOrder”的AWS Lambda函数，并传递“order/OrderHandler.create”作为处理程序。</p><p id="54b2" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">接下来，使用“verify-jwt”授权器保护该功能。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3b42" class="mm kc je mi b gy mn mo l mp mq">createOrder:<br/>  handler: order/OrderHandler.create<br/>  events:<br/>    - http:<br/>        path: order/create<br/>        method: post<br/>        cors: true<br/>        authorizer: verify-jwt</span></pre><h1 id="a3f3" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将myOrders添加到serverless.yml中</h1><p id="3d10" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们应该在serverless.yml文件中再添加一个东西。</p><p id="7a57" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">事情是“myOrders”函数，用“myOrders”作为处理程序的名称。</p><p id="d25a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">JWT仍然是那里的验证者。</p><p id="5242" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">无论如何，记住改变端点的路径。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="4348" class="mm kc je mi b gy mn mo l mp mq">myOrders:<br/>  handler: order/OrderHandler.myOrders<br/>  events:<br/>    - http:<br/>        path: order/my<br/>        method: get<br/>        cors: true<br/>        authorizer: verify-jwt</span></pre><h1 id="7cd4" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">创建订单处理程序</h1><p id="56c2" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">太好了！现在，我们可以进入处理程序，通过AWS Lambda函数和API端点来处理Node.js逻辑。</p><p id="40fa" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">作为第一步，您应该在“order”目录中创建一个文件“OrderHandler.js”。</p><p id="e09a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">创建文件后，我们应该导入数据库、订单、成功和errResponse函数。</p><p id="4113" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">看看下面的例子:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="50f1" class="mm kc je mi b gy mn mo l mp mq">const db = require('../database');<br/>const Order = require('./Order');<br/>const { success, errResponse } = require('../authentication/AuthenticationHelpers');</span></pre><h1 id="28bf" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">创建要创建的处理程序和函数</h1><p id="6122" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在下一步中，我们处理创建订单端点。</p><p id="5b65" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以通过创建函数处理程序来做到这一点，这一点非常重要，因为node.js导出了. module，所以serverless将能够导入功能并推入AWS Lambda函数。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="d68a" class="mm kc je mi b gy mn mo l mp mq">module.exports.create = (r, cb) =&gt; {<br/>  cb.callbackWaitsForEmptyEventLoop = false;<br/>  return db()<br/>    .then(() =&gt; create(JSON.parse(r.body), r.requestContext.authorizer.principalId))<br/>    .then(res =&gt; success(res))<br/>    .catch(err =&gt; errResponse(err));<br/>};</span></pre><p id="9ddb" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">接下来，我们需要创建一个函数，该函数包含负责在MongoDB数据库中创建订单的逻辑:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="beee" class="mm kc je mi b gy mn mo l mp mq">function create(body, id) {<br/>  return Order.create({userId: id, status: 'pending', amount: body.amount, createdAt: new Date()});<br/>}</span></pre><h1 id="375a" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为更新创建处理程序和函数</h1><p id="e233" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在这一步中，我们应该为“更新”特性创建一个导出的模块。</p><p id="61b0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们没有将它添加为AWS Lambda函数和端点，因为我们不想将其公开。</p><p id="7512" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">只有我们的应用程序能够调用该逻辑，并且只有在通过一些条件之后，比如支付是否成功执行。</p><p id="903f" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们看看我们应该创建的Node.js模块:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b790" class="mm kc je mi b gy mn mo l mp mq">module.exports.update = (r, cb) =&gt; {<br/>  cb.callbackWaitsForEmptyEventLoop = false;<br/>  return db()<br/>    .then(() =&gt; update(JSON.parse(r.body)))<br/>    .then(res =&gt; success(res))<br/>    .catch(err =&gt; errResponse(err));<br/>};</span></pre><p id="2b8c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们现在应该创建包含“更新”模块逻辑的函数:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="958a" class="mm kc je mi b gy mn mo l mp mq">function update(body) {<br/>  return Order.findByIdAndUpdate(body.id, body, { new: true })<br/>}</span></pre><h1 id="e844" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为myOrders创建处理程序和函数</h1><p id="d496" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">好了，我们几乎完成了无服务器节点。JS REST API。</p><p id="c661" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们应该创建的最后一个逻辑是与我的订单相关的逻辑。</p><p id="24e9" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">该逻辑将通过查看用户Id字段与从JWT令牌编码的用户id字段相同的订单来搜索我们的订单。</p><p id="c919" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为此，我们需要两部分。第一个是导出的模块:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="46bc" class="mm kc je mi b gy mn mo l mp mq">module.exports.myOrders = (r, cb) =&gt; {<br/>  cb.callbackWaitsForEmptyEventLoop = false;<br/>  return db()<br/>    .then(() =&gt; myOrders(r.requestContext.authorizer.principalId))<br/>    .then(res =&gt; success(res))<br/>    .catch(err =&gt; errResponse(err));<br/>};</span></pre><p id="eb88" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">第二部分是与数据库相关的逻辑:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7da6" class="mm kc je mi b gy mn mo l mp mq">function myOrders(id) {<br/>  return Order.find({userId: id})<br/>    .then(orders =&gt; !orders.length ? Promise.reject('Orders not found.') : orders)<br/>    .catch(err =&gt; Promise.reject(new Error(err)));<br/>}</span></pre><h1 id="3718" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何在Node.js中测试MongoDB REST API</h1><p id="55c4" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">呜哇！您已经创建了下一个SaaS应用程序功能，您的订单已经准备好了！</p><p id="ebcf" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，我们可以进入测试阶段。</p><p id="dc88" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">有两种方法来测试我们的无服务器应用程序。</p><p id="bb19" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">第一个是将应用程序部署到AWS基础设施中，并在live API上进行测试，这对您来说是一个很好的体验。</p><p id="1ce4" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您想将所有应用程序部署到AWS云中，您需要配置AWS CLI，这将创建整个AWS基础架构，所以记得仔细检查您的设置、区域等。</p><p id="1c8e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为此，您只需打开终端并键入:</p><p id="1d33" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe ms mt mu mi b">sls deploy</code></p><p id="6e35" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">还有我喜欢的第二种方法，它提高了我的开发时间，因为我可以在本地启动应用程序。</p><p id="8bf9" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这非常好，尤其是当您计划调试您的应用程序时，因为您可以放置console.logs，它将在您触发一些端点时显示消息。</p><p id="a05a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">当你想知道数据是如何进入我们的应用程序，或者是如何出去的时候，这是非常方便的。</p><p id="81f1" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如何在本地启动应用程序我在之前的课程中已经告诉过你如何使用代码。</p><h1 id="0cf0" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">关于如何在Node.js中创建MongoDB REST API的总结</h1><p id="7925" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">恭喜你！你的AWS Lambda SaaS应用程序现在看起来更先进了！</p><p id="5e88" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您已经学习了如何创建订单，如何创建MongoDB模型，如何在MongoDB和Node.js中更新项目，以及如何在Node.js中创建AWS Lambda函数。</p><p id="79a7" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我为你所建立的一切感到非常自豪，希望你能从今天的课程中获益良多。</p><p id="a3ac" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">记得订阅我们的频道，以立即获得有关新课的通知！</p><p id="07e9" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果你想检查你的代码是否正确，这里是今天课程的网址:</p><p id="2573" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae mc" href="https://github.com/Duomly/aws-serverlesss-nodejs/tree/serverless-course-lesson-3" rel="noopener ugc nofollow" target="_blank">https://github . com/Duomly/AWS-server lesss-nodejs/tree/server less-course-less-lesson-3</a></p><figure class="md me mf mg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/569b5629b61c6fc38ef667df4b6cb018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmTcuUeaGsAJSDedBMBgTA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated"><a class="ae mc" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">二进制编程课程</a></figcaption></figure><p id="a2f1" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">感谢您的阅读，<br/>来自Duomly的Radek</p></div></div>    
</body>
</html>