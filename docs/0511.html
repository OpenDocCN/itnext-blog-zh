<html>
<head>
<title>React Router DOM v4 Tutorial (with Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器DOM v4教程(带示例)</h1>
<blockquote>原文：<a href="https://itnext.io/react-router-dom-v4-tutorial-with-examples-d9f6413066e7?source=collection_archive---------3-----------------------#2018-03-22">https://itnext.io/react-router-dom-v4-tutorial-with-examples-d9f6413066e7?source=collection_archive---------3-----------------------#2018-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2785f60bf1061f315d19031e4c954f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yz3hkO3ynHV2qYGARynJg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Artem Sapegin 在<a class="ae kc" href="https://unsplash.com/search/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将使用一个react应用程序示例，让您从<strong class="kf ir"> react-router-dom </strong>开始，向您展示如何使用不同的概念，如<strong class="kf ir"> Link </strong>和<strong class="kf ir"> NavLink </strong>以React方式创建链接(而不是锚点)<strong class="kf ir"> Switch </strong>和<strong class="kf ir"> exact </strong>以启用独占路由和<strong class="kf ir">浏览器路由历史</strong>。</p><p id="4964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许了解<strong class="kf ir"> React Router v4 </strong>如何工作的最合适的方式是使用新的路由器概念编写一个简单的多页React应用程序。我们的示例应用程序将有到主页，关于，联系，登录，注册和配置文件组件/页面的路线。但是首先让我们来看一下React路由器v4的概念以及它们与React路由器v3的区别。</p><h1 id="b328" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应路由器v4与反应路由器v3</h1><p id="3ca6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在v4之前有<strong class="kf ir"> React路由器v3 </strong>，<strong class="kf ir"> React路由器v4 </strong>是完全重写的，那么这两款React路由器有什么区别呢？以下是最大差异的汇总列表:</p><ul class=""><li id="525e" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">有了<strong class="kf ir"> React router v4 </strong>，路由不再是集中的，而是成为应用布局和UI其余部分的一部分。</li><li id="e95d" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">特定于浏览器的路由组件位于<strong class="kf ir"> react-router-dom </strong>中，而不是<strong class="kf ir"> react-router </strong>中，因此需要从<strong class="kf ir"> react-router-dom </strong>包中导入。</li><li id="8615" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">引入新组件，如<strong class="kf ir"> BrowserRouter </strong>和<strong class="kf ir">hashrooter</strong>用于特定用例(见下文)。</li><li id="e71f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">v4 React路由器中不再使用<strong class="kf ir"> {props.children} </strong>嵌套组件。</li><li id="f68f" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">React Router v3路由规则是排他的，这意味着一次只能匹配一条路由。对于v4，路由规则是包含性的，这意味着可以匹配多条路由，然后进行渲染。</li></ul><p id="4e99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> React-router-dom </strong>是React Router v4专为web应用设计的版本，React Router v4分为三个包:</p><ul class=""><li id="005f" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><strong class="kf ir">react-router</strong>:DOM和原生版本之间的通用核心组件。</li><li id="fa2a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kf ir"> react-router-dom </strong>:为浏览器或web apps设计的dom版本。</li><li id="99d4" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><strong class="kf ir"> react-router-native </strong>:为react-native移动应用设计的原生版本。</li></ul><h1 id="5dec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">react路由器vs react路由器dom vs react路由器native</h1><p id="9864" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">react-router托管react应用程序路由的核心组件，react-router-dom提供路由web应用程序的浏览器特定组件，react-router-native提供react-native或使用React Native创建的移动应用程序的特定组件。所以你应该要么安装<strong class="kf ir"> react-router-dom </strong>要么安装<strong class="kf ir"> react-router-native </strong>，因为两者都导出它们相应的环境组件以及<strong class="kf ir"> react-router </strong>导出的内容。</p><h1 id="5bac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">装置</h1><p id="7bbc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因为我们正在构建一个web应用程序，而不是一个本地移动应用程序，所以我们需要安装<strong class="kf ir"> react-router-dom </strong>包，所以在react项目中使用您的终端(Linux或MAC)或命令提示符(Windows)运行以下命令:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2135" class="nb lc iq mx b gy nc nd l ne nf">npm install --save react-router-dom</span></pre><h1 id="b6ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">了解和使用路由器</h1><ul class=""><li id="66e1" class="me mf iq kf b kg lz kk ma ko ng ks nh kw ni la mj mk ml mm bi translated">BrowserRouter:这是路由器接口的一个子类或具体实现，它利用HTML5历史API将你的用户界面与当前浏览器的url同步，或者实际上是url的路径，即window.location</li><li id="731a" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">HashRouter:就像前面的路由器一样，但是只使用URL的散列部分，即window.location.hash。</li><li id="4cc7" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">内存路由器</li><li id="d4ca" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">NativeRouter:用于在react-native移动应用程序内部进行路由。</li><li id="ac72" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">StaticRouter:用于静态路由，就像React Router v3。</li></ul><h1 id="1fb0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浏览器路由器vs哈希路由器</h1><p id="4c69" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">路由器组件有很多种，其中<strong class="kf ir"> &lt; BrowserRouter &gt; </strong>和<strong class="kf ir"> &lt; HashRouter &gt; </strong>用于客户端的React应用。如果您使用的是可以处理动态URL的动态服务器，那么您需要使用<strong class="kf ir"> BrowserRouter </strong>组件，但是如果您使用的是只提供静态文件的服务器，那么在这种情况下就需要使用<strong class="kf ir"> HashRouter </strong>组件。</p><h1 id="c098" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">了解和使用路线</h1><p id="7529" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir"> &lt; Route &gt; </strong>组件是React Router v4最有用的组件之一，其背后的思想很简单，只要你想渲染某个东西，只要它与位置的路径匹配，你就可以使用Route组件。</p><p id="b79d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">路由</strong>组件具有许多属性，例如:</p><ul class=""><li id="1eee" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">path属性:字符串类型，保存要匹配的路径的名称。</li><li id="a9e1" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">component属性:如果匹配，它保存要呈现的组件的名称。</li><li id="7b01" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">精确属性:该属性告诉Route精确匹配路径(请参见包含和排除路由)</li><li id="1b9d" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">strict属性:这个属性告诉Route只匹配一个带有斜杠的路径。</li></ul><p id="dfc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个其他属性可以代替component属性，告诉Route组件在匹配时需要呈现什么:</p><ul class=""><li id="7380" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">render属性:返回React元素函数。对于内联呈现或包装呈现的组件更有用。</li><li id="b31d" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">children:也是一个呈现React元素的函数。除了这个即使没有匹配的路径也会一直渲染。</li></ul><p id="a994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数情况下，您会使用组件属性，但也有许多情况下，您必须使用渲染或子属性。这三个方法将通过这三个道具:</p><p id="b8d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><p id="979b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用组件:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="af4b" class="nb lc iq mx b gy nc nd l ne nf">&lt;Route exact path="/" component={HomePage} /&gt;</span></pre><p id="4da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当浏览器的位置路径与<code class="fe nj nk nl mx b">/</code>完全匹配时，将呈现<code class="fe nj nk nl mx b">HomePage</code>组件。</p><p id="5835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用渲染:</p><p id="750f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于内嵌渲染:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7822" class="nb lc iq mx b gy nc nd l ne nf">&lt;Route path="/home" render={() =&gt; &lt;div&gt;Home&lt;/div&gt;}/&gt;</span></pre><p id="a909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于包装:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e5ed" class="nb lc iq mx b gy nc nd l ne nf">const FadingRoute = ({ component: Component, ...rest }) =&gt; (<br/>  &lt;Route {...rest} render={props =&gt; (<br/>    &lt;FadeIn&gt;<br/>      &lt;Component {...props}/&gt;<br/>    &lt;/FadeIn&gt;<br/>  )}/&gt;<br/>)<br/><br/>&lt;FadingRoute path="/cool" component={Something}/&gt;</span></pre><p id="ef4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用儿童:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="82b2" class="nb lc iq mx b gy nc nd l ne nf">&lt;ul&gt;<br/>  &lt;ListItemLink to="/somewhere"/&gt;<br/>  &lt;ListItemLink to="/somewhere-else"/&gt;<br/>&lt;/ul&gt;<br/><br/>const ListItemLink = ({ to, ...rest }) =&gt; (<br/>  &lt;Route path={to} children={({ match }) =&gt; (<br/>    &lt;li className={match ? 'active' : ''}&gt;<br/>      &lt;Link to={to} {...rest}/&gt;<br/>    &lt;/li&gt;<br/>  )}/&gt;<br/>)</span></pre><p id="a506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有关React路由器v4如何匹配路径的更多信息，请参见<a class="ae kc" href="https://github.com/pillarjs/path-to-regexp" rel="noopener ugc nofollow" target="_blank"> path-to-regexp </a>用于匹配路径的模块。</p><h1 id="80e2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">URL/路径/路由参数</h1><p id="116b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通常，路径名中有一些可变部分用于在应用程序的不同路径之间传递信息，那么我们如何捕获这些变量并将它们传递给组件呢？我们可以将变量的名称加上冒号<strong class="kf ir"> : </strong>附加到路线路径的末尾，例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b9ac" class="nb lc iq mx b gy nc nd l ne nf">&lt;Route path="/:param1" component={Home}/&gt;<br/>const Home = ({ match }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt; Parameter 1 : {match.params.param1}&lt;/h1&gt;<br/>  &lt;/div&gt;<br/>)</span></pre><p id="b8b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当存在路径匹配时，将创建具有以下属性的对象并将其传递给组件:</p><ul class=""><li id="377b" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">URL:URL的匹配部分。</li><li id="6de2" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">路径:简单来说就是路径。</li><li id="8089" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">如果path完全等于当前位置的路径名，isExact: equals <strong class="kf ir"> True </strong>。</li><li id="459d" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">params:包含URL参数的对象。</li></ul><h1 id="0808" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">理解和使用链接</h1><p id="af63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">链接是React路由器v4组件，旨在替代锚链接，以创建导航元素，使用户能够在React应用程序的不同页面之间导航。与重新加载整个页面的锚不同，链接只重新加载UI中与浏览器位置路径匹配的部分。</p><p id="b57d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kf ir">链接</strong>组件接受一个<strong class="kf ir">到</strong>属性，该属性告诉React路由器要导航到的目的地。例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0e96" class="nb lc iq mx b gy nc nd l ne nf">import { Link } from 'react-router-dom'<br/>const Nav = () =&gt; (<br/>    &lt;Link to='/'&gt;Home&lt;/Link&gt;<br/>)</span></pre><p id="2311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单击后将带我们到路径为的位置:/</p><p id="a6cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">到</strong>属性可以采用字符串或位置(路径名、散列、搜索和状态)对象，例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="60e7" class="nb lc iq mx b gy nc nd l ne nf">&lt;Link to={ {<br/>  pathname: '/me',<br/>  search: '?sort=asc',<br/>  hash: '#hash',<br/>  state: { fromHome: true }<br/>} } /&gt;</span></pre><p id="986b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">链接</strong>也可以带另一个属性:<strong class="kf ir">替换</strong>如果<strong class="kf ir">为真</strong>，当点击时，历史中的链接条目将被替换。</p><h1 id="a559" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">&lt; Link &gt; vs &lt; NavLink &gt;</h1><p id="ae97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir"> NavLink </strong>是<strong class="kf ir"> Link </strong>的子类，它为渲染元素添加样式信息，例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cee3" class="nb lc iq mx b gy nc nd l ne nf">import { NavLink } from 'react-router-dom'<br/><br/>&lt;NavLink<br/>  to="/me"<br/>  activeStyle=<br/>   activeClassName="selected"&gt;My Profile&lt;/NavLink&gt;</span></pre><h1 id="7828" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用React路由器DOM编写我们的第一个例子</h1><p id="6482" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在让我们编写一个React应用程序示例，向您展示如何使用<strong class="kf ir"> BrowserRouter </strong>来实现路由。</p><p id="ea79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们导入必要的路由组件，如<strong class="kf ir"> Route </strong>和<strong class="kf ir"> BrowserRouter </strong></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1453" class="nb lc iq mx b gy nc nd l ne nf">import { BrowserRouter } from 'react-router-dom'<br/>import { Route } from 'react-router-dom'</span></pre><p id="ff74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建基本布局组件，除了常见的HTML标签，我们还使用React Router v4组件<strong class="kf ir"> Link </strong>和<strong class="kf ir"> Route </strong>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c0c5" class="nb lc iq mx b gy nc nd l ne nf">const BaseLayout = () =&gt; (<br/>  &lt;div className="base"&gt;<br/>    &lt;header&gt;<br/>      &lt;p&gt;React Router v4 Browser Example&lt;/p&gt;<br/>        &lt;nav&gt;<br/>          &lt;ul&gt;<br/>            &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to='/about'&gt;About&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to='/me'&gt;Profile&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to='/login'&gt;Login&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to='/register'&gt;Register&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to='/contact'&gt;Contact&lt;/Link&gt;&lt;/li&gt;<br/><br/>          &lt;/ul&gt;<br/>        &lt;/nav&gt;<br/>    &lt;/header&gt;<br/>    &lt;div className="container"&gt;<br/>      &lt;Route path="/" exact component={HomePage} /&gt;<br/>      &lt;Route path="/about" component={AboutPage} /&gt;<br/>      &lt;Route path="/contact" component={ContactPage} /&gt;<br/>      &lt;Route path="/login" component={LoginPage} /&gt;<br/>      &lt;Route path="/register" component="{RegisterPage}" /&gt;<br/>      &lt;Route path="/me" component={ProfilePage} /&gt;<br/>    &lt;/div&gt;<br/>    &lt;footer&gt;<br/>        React Router v4 Browser Example (c) 2017<br/>    &lt;/footer&gt;<br/>  &lt;/div&gt;<br/>)</span></pre><p id="2d65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建页面:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5e8f" class="nb lc iq mx b gy nc nd l ne nf">const HomePage = () =&gt; &lt;div&gt;This is a Home Page&lt;/div&gt;<br/>const LoginPage = () =&gt; &lt;div&gt;This is a Login Page&lt;/div&gt;<br/>const RegisterPage = () =&gt; &lt;div&gt;This is a Register Page&lt;/div&gt;<br/>const ProfilePage = () =&gt; &lt;div&gt;This is the Profile Page&lt;/div&gt;<br/>const AboutPage = () =&gt; &lt;div&gt;This is an About Page&lt;/div&gt;<br/>const ContactPage = () =&gt; &lt;div&gt;This is a Contact Page&lt;/div&gt;</span></pre><p id="c64c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们创建一个应用程序组件，这个组件用来保存我们的基本布局组件，然后呈现这个应用程序。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="33db" class="nb lc iq mx b gy nc nd l ne nf">const App = () =&gt; (<br/>  &lt;BrowserRouter&gt;<br/>    &lt;BaseLayout /&gt;<br/>  &lt;/BrowserRouter&gt;<br/>)<br/>render(&lt;App /&gt;, document.getElementById('root'))</span></pre><p id="1ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，使用React路由器v4组件创建带路由的应用程序非常容易。</p><h1 id="328f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">了解包容性路由</h1><p id="b0ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们的示例应用程序中，我们在组件主页的Route中使用了prop <strong class="kf ir"> exact </strong></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f055" class="nb lc iq mx b gy nc nd l ne nf">&lt;Route path="/" exact component={HomePage} /&gt;</span></pre><p id="bd61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为React路由器v4使用包含路由而不是React路由器v3使用的排他路由，因此如果没有确切的属性，home组件将与所有其他组件一起呈现，例如，当用户访问<code class="fe nj nk nl mx b">/login</code>路径时，<code class="fe nj nk nl mx b">/</code>和<code class="fe nj nk nl mx b">/login</code>路径都将匹配，并且它们对应的组件<code class="fe nj nk nl mx b">LoginPage</code>和<code class="fe nj nk nl mx b">HomePage</code>将被呈现。但这不是我们要寻找的行为，这就是为什么我们需要添加确切的属性来告诉路由组件精确匹配<code class="fe nj nk nl mx b">/</code>路径。</p><p id="fea0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们看看如何利用包含路由的优势，假设我们有一个子菜单组件，仅当我们在配置文件页面上时才需要它，我们可以轻松地更改基本布局来添加以下要求:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7f87" class="nb lc iq mx b gy nc nd l ne nf">const BaseLayout = () =&gt; (<br/>  &lt;div className="base"&gt;<br/>    &lt;header&gt;<br/>      &lt;p&gt;React Router v4 Browser Example&lt;/p&gt;<br/>        &lt;nav&gt;<br/>          &lt;ul&gt;<br/>            &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;&lt;Link to='/about'&gt;About&lt;/Link&gt;&lt;/li&gt;<br/>            &lt;li&gt;<br/>                &lt;Link to='/me'&gt;Profile&lt;/Link&gt;<br/>                &lt;Route path="/me" component={ProfileMenu} /&gt;<br/>            &lt;/li&gt;<br/>            ...<br/>)</span></pre><p id="9d72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如您所见，当我们访问“/me”路径时，所有带有路径“/me”的路由都将被呈现，而不仅仅是第一个匹配，也就是<strong class="kf ir">包含路由</strong>。</p><h1 id="257a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">了解独占路由</h1><p id="6780" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">独占路由与包含路由相反，它是React Router v3中的默认路由，其中只呈现第一个匹配，那么如果您想要独占路由呢？这也可以通过v4路由器使用<strong class="kf ir">开关</strong>组件来完成。在一个<strong class="kf ir">开关</strong>组件中，只有第一个子<strong class="kf ir"> &lt;路由&gt; </strong>或<strong class="kf ir"> &lt;重定向&gt; </strong>，与位置匹配，才会被渲染。例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="aae3" class="nb lc iq mx b gy nc nd l ne nf">import { Switch, Route } from 'react-router'    <br/><br/>&lt;Switch&gt;<br/>  &lt;Route exact path="/" component={HomePage}/&gt;<br/>  &lt;Route path="/about" component={AboutPage}/&gt;<br/>  &lt;Route path="/me" component={ProfilePage}/&gt;<br/>  &lt;Route component={NotFound}/&gt;<br/>&lt;/Switch&gt;</span></pre><h1 id="94e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浏览器历史记录</h1><p id="ffeb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir"> React Router v4 </strong>提供了一个<strong class="kf ir"> history </strong>对象，该对象公开了一个具有不同实现的简单API(dom的HTML5历史API、DOM的传统哈希历史、react-native的内存历史)来管理/操作浏览器历史。</p><p id="8562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以使用来自<strong class="kf ir"> history </strong>对象的方法在React应用程序中导航，例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="6a49" class="nb lc iq mx b gy nc nd l ne nf">history.push("/my-path")<br/>history.replace("/my-path")</span></pre><p id="c4fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这相当于:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="17a2" class="nb lc iq mx b gy nc nd l ne nf">&lt;Link to="/my-path"/&gt;<br/>&lt;Redirect to="/my-path"/&gt;</span></pre><h1 id="cd03" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何用&lt; Redirect &gt;组件重定向</h1><p id="332f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每当你想重定向到另一个位置时，你可以放置组件，该组件在渲染时将重定向到在<strong class="kf ir">到</strong> prop中指定的位置，它可以是一个字符串或一个位置对象，例如:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1f6e" class="nb lc iq mx b gy nc nd l ne nf">&lt;Redirect to={ {<br/>  pathname: '/register',<br/>  search: '?utm=techiediaries',<br/>  state: { referrer: <a class="ae kc" href="http://techiediaries.com" rel="noopener ugc nofollow" target="_blank">techiediaries.com</a> }<br/>} }/&gt;</span></pre><p id="7d8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者简单地说:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a62c" class="nb lc iq mx b gy nc nd l ne nf">&lt;Redirect to="/register"/&gt;</span></pre><h1 id="0371" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e31f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir"> React Router v4 </strong>使得创建具有复杂ui的React应用程序变得非常容易，这些ui在不同部分之间具有路由，您可以简单地声明一个<strong class="kf ir">路由器</strong>组件，如<strong class="kf ir">浏览器路由器</strong>或<strong class="kf ir">散列路由器</strong>，并在其中放置一组子<strong class="kf ir">路由</strong>组件，这些组件具有指示要匹配的<strong class="kf ir">路径</strong>和每当有匹配时要包含地呈现的<strong class="kf ir">组件</strong>的属性(即如果你需要进行独占渲染(就像React Router v3:即只有第一个匹配的<strong class="kf ir"> Route </strong>将被渲染)，那么你可以简单地使用一个<strong class="kf ir"> Switch </strong>组件，其中只有一个孩子(第一个找到的)将被渲染。您还可以使用参数在路径之间传递不同的信息，这些参数可以从<strong class="kf ir"> match </strong>对象中捕获和检索，一旦建立了匹配，该对象就会被创建，然后被传递给当前的渲染组件。最后，<strong class="kf ir"> React Router v4 </strong>中为web应用程序路由设计的所有构建模块或组件都可用，并且可以从<strong class="kf ir"> react-router-dom </strong>中导入。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="8625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nt">原载于</em><a class="ae kc" href="https://www.techiediaries.com/react-router-dom-v4/" rel="noopener ugc nofollow" target="_blank"><em class="nt">www.techiediaries.com</em></a><em class="nt">。</em></p></div></div>    
</body>
</html>