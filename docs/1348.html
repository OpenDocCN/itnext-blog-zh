<html>
<head>
<title>How we boosted the performance of our React Native app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何提升React原生应用的性能</h1>
<blockquote>原文：<a href="https://itnext.io/how-we-boosted-the-performance-of-our-react-native-app-191b8d338347?source=collection_archive---------0-----------------------#2018-09-20">https://itnext.io/how-we-boosted-the-performance-of-our-react-native-app-191b8d338347?source=collection_archive---------0-----------------------#2018-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/3f61a06ae36bac6d4e9103afc7d31fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*-xi9Q2kQuSP0leGdKNGi7w.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="http://www.cuentosyfabulas.es/2016/10/la-liebre-y-la-tortuga.html" rel="noopener ugc nofollow" target="_blank"> Cuentos y Fábulas </a></figcaption></figure><p id="5938" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这篇文章讨论了React原生应用程序为提高UI响应性所做的工作。它的目的不是列出你应该遵循的最佳实践，以提高你自己的应用程序的性能，但我们的一些改进确实来自于遵循这些实践。</p><p id="9cb2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们是一个由三名开发人员组成的团队，他们都有很强的iOS背景，但只有一个人有之前的React本地经验。我们继续现有的React本地应用程序的工作，用户可以在该应用程序中看到以瞬间为特色的实时视频。</p><p id="b9a6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在我们开始开发这个应用程序后不久，我们就注意到有些地方不太对劲。该应用的性能明显比我们之前在原生项目中看到的要差。我们特别注意到:</p><ol class=""><li id="79a0" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">在点击任何UI控件和执行该动作之间有一个明显的延迟(0.5s+)。</li><li id="35ac" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">相对于视频会话的长度和时刻的数量，这种滞后经历了线性增长。</li></ol><p id="8db2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">准确地说，在使用20多分钟后，Hudl的精英支持负责人会对该应用的响应能力进行评分:</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ll"><img src="../Images/bf8ec74df370cf34650a61753125e292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPigfAg1DR8ZmiYZs8icJg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://lacomiquera.com/creador-de-this-is-fine-actualiza-su-famosa-tira-esto-no-esta-bien/" rel="noopener ugc nofollow" target="_blank">喜剧城</a></figcaption></figure><p id="3604" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="lu">时刻是视频中感兴趣的区域，例如，如果视频对应于篮球比赛，则某个时刻可能是提示。</em></p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="892c" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">评估UI响应性的指标</h1><p id="8d59" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">我们必须让我们的产品负责人明白，应用程序的响应能力已经提高了。更重要的是，我们必须证明它不会随着时间的推移而退化。</p><p id="d9ac" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在解决这个问题时，我们只关注Windows。React Native没有正式支持这个平台，这一事实本身就很复杂。最大的一个问题是性能监视器不能在UWP上工作(至少不能在React Native 0.47.2中工作，这是我们使用的版本)。</p><p id="e833" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们的第一次尝试使用了Visual Studio分析工具。他们提供了一些有用的数据，如应用程序中出现新时刻时的CPU峰值，但我们找不到任何可靠的、可量化的指标来很好地关联性能和响应。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nf"><img src="../Images/2f34c2d7469438f8b22212dba3f2e49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvaBFTMUaDKOgMp5l-xV8Q.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Visual Studio诊断工具的快照</figcaption></figure><p id="11e3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">幸运的是，Hudl有相当多的React和React本地专家可以依靠，他们建议查看每个组件的渲染计数。我们最终采用了以下流程:</p><ol class=""><li id="8998" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">使用不同的工作流和每个组件的预期渲染数量创建文档。</li><li id="e774" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">创建一个脚本，在组件中每次调用<em class="lu"> render() </em>时进行计数，并将这些计数写入本地html文件。</li><li id="d6cb" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">比较1和2。</li></ol><p id="a2b6" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们还要求我们的产品负责人和我们支持团队的一名成员在我们工作之前和之后对应用程序的响应性进行评估。虽然这个度量标准不能确保响应性不会随着时间的推移而降低，但是它确实验证了这个可量化的度量标准与响应性有很好的相关性。</p><p id="b541" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">所以我们最终得到了<strong class="kb ir">两个关键指标</strong>:</p><ol class=""><li id="51e9" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">每个组件的<em class="lu"> render() </em>计数，检查实际值是否与一组预定义工作流的预期值相匹配。</li><li id="44a4" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">由一名精英支持成员和我们的产品负责人进行的工作前和工作后评估。</li></ol><p id="a55e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="lu"> </em> <a class="ae jy" href="https://twitter.com/MCirlanaru" rel="noopener ugc nofollow" target="_blank"> <em class="lu">米哈伊·凯勒纳鲁</em> </a> <em class="lu">是Hudl的React专家之一。查看他关于React性能优化的</em> <a class="ae jy" href="https://speakerdeck.com/mcirlanaru/react-performance-optimizations-best-practices-hudl-engineering-internal-talk" rel="noopener ugc nofollow" target="_blank"> <em class="lu">演讲</em> </a> <em class="lu">。</em></p><h1 id="e2e9" class="mc md iq bd me mf ng mh mi mj nh ml mm mn ni mp mq mr nj mt mu mv nk mx my mz bi translated">提高用户界面响应能力</h1><p id="3b00" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">如前所述，当我们加入项目时，React Native的体验并不好。我们首先必须用关于组件生命周期和行为的知识武装自己。</p><p id="a87f" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">1.当<em class="lu">道具</em>或<em class="lu">状态</em>改变时，React组件重新渲染。</p><p id="4a15" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">2.在一个<em class="lu"> PureComponent </em>中，在先前和当前<em class="lu">道具</em>和<em class="lu">状态</em>的浅层比较中发现一个“变化”。</p><p id="541a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">3.在<em class="lu">组件</em>中，“改变”是指先前和当前<em class="lu">道具</em>和<em class="lu">状态</em>之间的任何参考值或数值差异。</p><p id="7dc5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">4.实现<em class="lu">shouldcomponentdupdate()</em>提供了对组件是否应该重新呈现的精细控制。</p><p id="b206" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">5.<em class="lu">shouldComponentUpdate()</em>只能在<em class="lu">组件</em>中被覆盖，<strong class="kb ir">不能在<em class="lu"> PureComponent中</em></strong>被覆盖。</p><p id="43cc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">有了这些信息，我们做了不同的迭代来删除代码中不必要的渲染。</p><h2 id="e92b" class="nl md iq bd me nm nn dn mi no np dp mm kk nq nr mq ko ns nt mu ks nu nv my nw bi translated">迭代1:避免将内联函数作为道具传递</h2><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nx"><img src="../Images/4f18c9716c37c9b92e7af84c7bf94756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJCz9vDF65jKkxX1Z_lYcQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">以前</figcaption></figure><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nx"><img src="../Images/bfda8a73255d816caadfc3421dd7d53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrbRoZqD_CEMOBcJcW6b5w.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在...之后</figcaption></figure><p id="24d2" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">快速阅读可能会忽略一个小差异:如何传递<em class="lu"> onPress </em> prop。</p><p id="20d4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在第一个例子中，在<em class="lu"> DrawerTitle的每次渲染中都声明了对该内联函数的新引用。</em>因此，<em class="lu"> DrawerComponent </em>将始终重新呈现自身，因为它的一个道具将始终改变。</p><p id="286c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在第二个例子中，对该函数的引用总是相同的，因此<em class="lu"> DrawerComponent </em>不会重新呈现(除非其他任何道具发生变化)。</p><p id="6a50" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我的同事Jon Reynolds <a class="ae jy" href="https://medium.com/in-the-hudl/blip-day-1-9e5e19dd9e4e" rel="noopener">几个月前发表了</a>关于这个问题更详细的解释。</p><h2 id="788f" class="nl md iq bd me nm nn dn mi no np dp mm kk nq nr mq ko ns nt mu ks nu nv my nw bi translated">迭代2:使用pure component &amp; shouldComponentUpdate()</h2><p id="5fa4" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">一旦应用，我们确实看到了一些性能提升。许多组件的预期和实际渲染周期开始匹配。然而，仍然存在一些问题。</p><ol class=""><li id="8cf0" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">我们将这些功能作为银弹。</li><li id="febc" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">对于某些组件，给定工作流的预期和实际渲染数量仍然相差甚远。</li><li id="0a90" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们运行应用程序的时间越长，性能就越差(渲染的次数也越多)。大约20分钟后，我们就像这样:</li></ol><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/542bc3ad02b9ee1f4acecd3affd7992e.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*dZC5chnZ5MJufTuX-mumJw.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://tenor.com/view/late-night-seth-lnsm-lnsmgifs-seth-meyers-this-is-not-good-gif-9200958" rel="noopener ugc nofollow" target="_blank">tenor.com</a></figcaption></figure><p id="9d77" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">很明显，问题出在别的地方。那些<em class="lu">纯组件</em>仍在重新渲染，所以问题变成了<em class="lu">为什么父母首先要重新渲染？</em>我们后退一步来分析全貌，并转向最后一次迭代。</p><h2 id="f53b" class="nl md iq bd me nm nn dn mi no np dp mm kk nq nr mq ko ns nt mu ks nu nv my nw bi translated">迭代3:重构代码</h2><p id="a76d" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">这是我们的应用程序中组件的层次结构图。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nz"><img src="../Images/20d24d74b4592d3aeff4d4e1b3ba0539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZkrOA0ow4GVIzDGO_yjtg.jpeg"/></div></div></figure><p id="f7d3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们的应用程序正遭受我们称之为<strong class="kb ir"> <em class="lu">的道具感染。</em> </strong>有一个<em class="lu"> prop </em>值每秒都在变化，传播到图中几乎所有组件。</p><p id="e33e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">最大的影响来自右边的<em class="lu">时刻表</em>——它可能包含200到1000个<em class="lu">时刻表</em>。如果你记得:会话越长，响应性越差。并且会话越长，列表上的<em class="lu">momentl listitem</em>就越多，使得每个<em class="lu"> render() </em>都更加昂贵。</p><p id="ec0a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这个“病毒道具”表达了本地视频播放器的视频时长。因为该应用程序播放实时视频，所以该值大约每秒都会改变。</p><p id="a14e" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这个迭代中的工作很简单:</p><ol class=""><li id="1cea" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">从任何不使用持续时间道具组件中移除<em class="lu">持续时间道具【】(有几个)。</em></li><li id="1d16" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">重构一些组件，只接收它们自己呈现时需要的道具，例如，一个<em class="lu">momentl listitem</em>不需要<em class="lu"> duration </em>来呈现自己。</li></ol></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="103c" class="mc md iq bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">结果:前后指标</h1><h2 id="12ff" class="nl md iq bd me nm nn dn mi no np dp mm kk nq nr mq ko ns nt mu ks nu nv my nw bi translated">对render()调用进行计数</h2><p id="cc71" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">在所有的重构工作之后，对感兴趣的组件的预期的和实际的<em class="lu"> render() </em>调用确实匹配。</p><h2 id="097f" class="nl md iq bd me nm nn dn mi no np dp mm kk nq nr mq ko ns nt mu ks nu nv my nw bi translated">由精英支持和产品负责人衡量绩效</h2><p id="f0a4" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">在这个项目之前，他们分别给这个应用程序的性能打了1/5和2/5分。我们做完后，两人都给了5/5分。</p><h1 id="f284" class="mc md iq bd me mf ng mh mi mj nh ml mm mn ni mp mq mr nj mt mu mv nk mx my mz bi translated">结论</h1><p id="dd5e" class="pw-post-body-paragraph jz ka iq kb b kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw ij bi translated">在提高应用程序性能的同时，我们学到了很多经验。</p><ol class=""><li id="3b8c" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><em class="lu"> PureComponent </em>和<em class="lu">shouldComponentUpdate()</em>是任何工具集的好工具。知道何时使用它们。</li><li id="65cd" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">确保只传递组件需要的<em class="lu">道具</em>。特别是，如果它是一个表示组件，确保它只接收自己需要呈现的<em class="lu">道具</em>。</li><li id="3525" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">在适当的时候利用redux store或其他类似的机制，例如，当孩子可以直接从redux store获得某个<em class="lu">道具</em>时，不要通过三个组件将该道具传递给孩子。</li><li id="eb48" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如果您发现自己过于频繁地使用<em class="lu">Component+shouldComponentUpdate()</em>，这可能是一种代码味道。问问你自己，父组件首先要求这个组件呈现是否有意义。</li><li id="7348" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">没有经验法则。权力大责任大<em class="lu">组件</em>、<em class="lu">纯组件</em>、<em class="lu">功能组件</em>、、<em class="lu">、</em>给你权力大。默认使用PureComponent可能是事实上的标准，但是一定要权衡你的选择。可能有更适合你的情况。</li></ol><h2 id="4580" class="nl md iq bd me nm nn dn mi no np dp mm kk nq nr mq ko ns nt mu ks nu nv my nw bi translated">一些警告</h2><ul class=""><li id="cc7e" class="kx ky iq kb b kc na kg nb kk oa ko ob ks oc kw od ld le lf bi translated">当你的对象包含复杂的数据结构时，<em class="lu">shouldComponentUpdate()</em>的内部实现可能会导致误判。来自<a class="ae jy" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank"> React的文档</a>:</li></ul><blockquote class="oe of og"><p id="dd1d" class="jz ka lu kb b kc kd ke kf kg kh ki kj oh kl km kn oi kp kq kr oj kt ku kv kw ij bi translated">如果这些包含复杂的数据结构，可能会对更深层次的差异产生假阴性。只有当您期望有简单的属性和状态时，才扩展PureComponent，或者当您知道深层数据结构已经改变时，才使用forceUpdate()。或者，考虑使用不可变对象来促进嵌套数据的快速比较。</p></blockquote><ul class=""><li id="06e2" class="kx ky iq kb b kc kd kg kh kk kz ko la ks lb kw od ld le lf bi translated"><em class="lu">shouldcomponentdupdate()</em>实现应该很简单。您可能会遇到这样的情况，执行函数的成本比重新渲染组件的成本还要高。</li><li id="3eaf" class="kx ky iq kb b kc lg kg lh kk li ko lj ks lk kw od ld le lf bi translated">如果父组件更新，<em class="lu">功能组件</em>将始终更新。</li></ul><p id="49ec" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">评论？请吧。<a class="ae jy" href="https://twitter.com/JuanjoRamos82" rel="noopener ugc nofollow" target="_blank"> @JuanjoRamos82 </a></p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="b89d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="lu">本文原贴于Hudl </em> 中的 <a class="ae jy" href="https://medium.com/in-the-hudl/this-is-the-story-of-how-we-boost-the-performance-of-our-react-native-app-28578eef0f02" rel="noopener"> <em class="lu"/></a></p></div></div>    
</body>
</html>