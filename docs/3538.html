<html>
<head>
<title>Biometrics (fingerprint) auth in your web apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">web应用中的生物识别(指纹)认证</h1>
<blockquote>原文：<a href="https://itnext.io/biometrics-fingerprint-auth-in-your-web-apps-d5599522d0b3?source=collection_archive---------0-----------------------#2020-01-06">https://itnext.io/biometrics-fingerprint-auth-in-your-web-apps-d5599522d0b3?source=collection_archive---------0-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a799" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是在您的Web应用程序(又名网站)中实现指纹(重新)登录、又名(重新)登录、又名(重新)身份验证功能所需的最基本信息和所有代码。</p><p id="cc87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> UPD </strong>:参见最底部的<strong class="jp ir">更新</strong>。最后更新<strong class="jp ir">2020–08–02</strong>。</p><p id="30fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的视频中，您将看到生物识别登录体验。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="bea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下所有内容都经过测试，并确认在Chrome浏览器中完全正常。</p><p id="dd41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在深入研究代码之前，您需要学习一些理论知识。否则，您可能会将您的web应用程序暴露给黑客。</p><h1 id="e998" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">理论</h1><h2 id="3c9b" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">每个设备设置</h2><p id="ecdf" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">你需要跟踪用户的每一个设备(浏览器)。为了达到这个目标，我建议你的web应用程序拥有一个长期存在的cookie(一个随机生成的字符串ID，例如UUID ),来唯一地识别用户拥有的每一个设备(和浏览器)。您的后端需要为登录用户使用的每个cookie创建一个数据库记录。</p><p id="0e0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，单个用户在您的<code class="fe mh mi mj mk b">devices</code>表中会有多个数据库记录(集合、名称空间等)。一个典型的用户会有1或2个设备记录。我建议将cookie字符串作为表中的惟一键或主键本身。</p><h2 id="e829" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">WebAuthn</h2><p id="52ac" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">WebAuthn(又名Web Authentication)是浏览器标准和<strong class="jp ir"> API </strong> <strong class="jp ir">，用于</strong> <strong class="jp ir">使用公钥加密向基于Web的应用程序和服务认证</strong> <strong class="jp ir">用户</strong>。</p><h2 id="a7a9" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">公钥密码学</h2><p id="5f01" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">公钥加密是指您可以使用之前发布的公钥(也是一个字符串)来验证由私钥(也是一个字符串)创建的签名(只是一个长字符串)。简而言之:私钥对数据进行编码，公钥验证其身份和一致性。</p><h2 id="f7f1" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">授权码</h2><p id="b4a9" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">浏览器、操作系统或其他硬件设备(USB、蓝牙、NFC等)充当私钥存储器。它们通过上述API发布公钥，并在设备/操作系统本身上安全地存储相应的私钥。这些存储器被称为<strong class="jp ir">授权码</strong>。</p><p id="a6c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将忽略所谓的“漫游”认证器(通常是USB、NFC、蓝牙可拆卸设备)，因为它们使代码变得非常复杂，并且不是本文的主题。我们将只使用所谓的“平台”认证器，它通常是内置在您的手机/笔记本电脑中的生物扫描仪。</p><h2 id="fdfe" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">安全性如何？</h2><p id="cd59" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我不是专家，但据我所知，这种指纹重新登录与您最喜欢的银行本地应用指纹重新登录一样安全。</p><p id="f8cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它肯定比标准的登录+密码方法更安全，此外，它对用户更友好(不需要每次都重新输入登录+密码)。</p><p id="5495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果与登录+密码+2FA令牌方法相比，那么指纹重新登录同样安全(甚至更安全)。</p><h2 id="9d57" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">硬件和软件支持</h2><p id="d086" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">如果浏览器有这个功能<code class="fe mh mi mj mk b"><a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isUserVerifyingPlatformAuthenticatorAvailable" rel="noopener ugc nofollow" target="_blank">PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable</a></code>并且它解析为<code class="fe mh mi mj mk b">true</code>，那么你的浏览器、操作系统和设备可以进行生物特征认证。在撰写本文时，只有Chrome和Edge浏览器拥有该功能。</p><p id="3491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在这里监控功能可用性:<a class="ae mm" href="https://caniuse.com/#search=isUserVerifyingPlatformAuthenticatorAvailable" rel="noopener ugc nofollow" target="_blank">https://can use . com/# search = isuseserverifyingplatformauthenticatoravailable</a></p><h1 id="f12e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">数据流</h1><p id="fead" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">整个业务逻辑由两个主要部分组成:</p><ul class=""><li id="fad8" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">设置指纹</li><li id="3024" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">验证指纹</li></ul><p id="d21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图解释了如何组织浏览器和服务器之间的授权数据流。实际上还有更多细节。但是这些流程让您对代码需要执行的操作以及需要来回传递的数据有了大致的了解。</p><h2 id="09f5" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">设置指纹</h2><p id="ddc4" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这个流程假设你的用户已经<em class="ml">登录</em>到你的网络系统、网络平台、网络应用、网站等。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/6dc8e13d062b283f6a2dfb8b1c420fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf2ys9W8GXhF5OQlJlENLA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">设置指纹重新登录功能时浏览器和服务器之间的数据流。</figcaption></figure><ol class=""><li id="0575" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">GET get-challenge</code> —浏览器发送包含长期cookie(设备ID)的空请求。</li><li id="e4e7" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">generate-and-store-challenge</code> —服务器为该cookie(设备ID)生成一个新的<code class="fe mh mi mj mk b">challenge</code>字符串，并将其保存到<code class="fe mh mi mj mk b">devices</code>表中。</li><li id="a80f" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">create-public-key</code> —浏览器调用WebAuth API创建新的公钥。用户用手指。</li><li id="20f1" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">POST save-public-key</code> —新的公钥数据被发送到服务器进行验证和存储。注意<code class="fe mh mi mj mk b">attestationObject</code>，这很重要。</li><li id="b497" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">validate-and-store-public-key</code> —在同一<code class="fe mh mi mj mk b">devices</code>记录中验证并存储公钥数据。</li></ol><h2 id="0103" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">验证指纹</h2><p id="5940" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">该流程假设您的用户<em class="ml">没有登录</em>。这就是我们迫切需要的惟一的长时间cookie(设备ID)以及与之相关的<code class="fe mh mi mj mk b">challenge</code>和<code class="fe mh mi mj mk b">publicKey</code>值。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nn"><img src="../Images/ab33e9cea833c0f4cca73cbef7fac128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKMeeoz22HulULjkAqgfSQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">验证指纹和用户登录时浏览器和服务器之间的数据流。</figcaption></figure><ol class=""><li id="e85c" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">GET get-challenge-and-publicKey</code> —浏览器发送包含长期cookie(设备ID)的空请求。</li><li id="bae0" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated">服务器为该cookie(设备ID)生成一个新的<strong class="jp ir">字符串</strong> <code class="fe mh mi mj mk b">challenge</code>并保存它，而不是现有的对<code class="fe mh mi mj mk b">devices</code>表的挑战。返回新的<strong class="jp ir"> </strong> <code class="fe mh mi mj mk b">challenge</code>和<code class="fe mh mi mj mk b">publicKey</code>。</li><li id="9f68" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">verify-public-key</code> —浏览器调用WebAuth API创建公钥验证数据。用户用手指。</li><li id="7f24" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">POST sign-in</code> —断言数据被发送到服务器进行验证。</li><li id="0bc8" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated"><code class="fe mh mi mj mk b">verify-signature</code> —服务器使用先前存储的<code class="fe mh mi mj mk b">attestationObject</code>验证签名，并发放授权令牌。</li></ol><p id="627f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们深入研究每一个步骤。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="b09f" class="ks kt iq bd ku kv nv kx ky kz nw lb lc ld nx lf lg lh ny lj lk ll nz ln lo lp bi translated">设置指纹流</h1><h2 id="07f0" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">获得挑战</h2><p id="638f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">首先，您的服务器需要一个API端点(GraphQL query、gRPC method等)来返回一个随机生成的名为“challenge”的字符串。服务器必须将数据库中的挑战值存储到相应的<code class="fe mh mi mj mk b">devices</code>记录中。假设该记录是在用户第一次登录时创建的。</p><p id="2ac2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一段服务器端伪代码:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="6d64" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">const</strong> deviceId = req.cookies["my-long-live-cookie"];<br/><strong class="mk ir">const</strong> device = <strong class="mk ir">await</strong> devices.findById(deviceId);<br/><strong class="mk ir">if</strong> (!device) <strong class="mk ir">return</strong> {};<br/>device.challenge = require("crypto").randomBytes(16).toString("hex")<br/><strong class="mk ir">await</strong> device.save();<br/><strong class="mk ir">return</strong> { challenge: device.challenge };</span></pre><p id="fd09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">devices</code>表的最小模式如下所示:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="ae75" class="lq kt iq mk b gy oe of l og oh">_id: <strong class="mk ir">String</strong>, <em class="ml">// long lived cookie<br/></em>challenge: <strong class="mk ir">String</strong>, <em class="ml">// server side random generated string<br/></em>counter: <strong class="mk ir">Number</strong>, <em class="ml">// protects from the so called replay attacks<br/></em>publicKey: <strong class="mk ir">String</strong>, <em class="ml">// public key created by the fingerprint scanner<br/></em>attestationObject: <strong class="mk ir">String</strong>, <em class="ml">// low level device data (BASE64 binary)<br/></em>clientDataJSON: <strong class="mk ir">String</strong>, <em class="ml">// BASE64 encoded JSON info of the website<br/></em>userAgent: <strong class="mk ir">String</strong>, <em class="ml">// last seen user-agent HTTP header<br/></em>user: <strong class="mk ir">ObjectId</strong>, <em class="ml">// the link back to the user, aka the foreign key</em></span></pre><h2 id="bca1" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">创建公钥</h2><p id="24de" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这是你的浏览器第一次调用WebAuthn API扫描用户手指的时候。(参见下面的解释。)</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="9be1" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">import</strong> { decode: base64urlDecode<em class="ml"> }</em> <strong class="mk ir">from</strong> <em class="ml">"base64url"</em>;</span><span id="7de0" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">const </strong>attestation = <strong class="mk ir">await </strong><em class="ml">navigator.credentials.create</em>({<br/>    <strong class="mk ir">publicKey</strong>: {<br/>        <strong class="mk ir">authenticatorSelection</strong>: {<br/>            <strong class="mk ir">authenticatorAttachment</strong>: <em class="ml">"platform"</em>,<br/>            <strong class="mk ir">userVerification</strong>: <em class="ml">"required"</em><strong class="mk ir"><br/>        </strong>},<br/>        <strong class="mk ir">challenge</strong>: base64urlDecode(challenge),<br/>        <strong class="mk ir">rp</strong>: { <strong class="mk ir">id</strong>: <em class="ml">document.domain</em>, <strong class="mk ir">name</strong>: <em class="ml">"My Acme Inc"</em><strong class="mk ir"> </strong>},<br/>        <strong class="mk ir">user</strong>: {<br/>            <strong class="mk ir">id</strong>: base64urlDecode(user.id),<br/>            <strong class="mk ir">name</strong>: user.email,<br/>            <strong class="mk ir">displayName</strong>: user.fullName<br/>        },<br/>        <strong class="mk ir">pubKeyCredParams</strong>: [<br/>            { <strong class="mk ir">type</strong>: <em class="ml">"public-key"</em>, <strong class="mk ir">alg</strong>: -7 },<br/>            { <strong class="mk ir">type</strong>: <em class="ml">"public-key"</em>, <strong class="mk ir">alg</strong>: -257 }<br/>        ]<br/>    }<br/>});</span><span id="c9e8" class="lq kt iq mk b gy oi of l og oh"><em class="ml">navigator.credentials.preventSilentAccess</em>();</span><span id="f300" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">import</strong> { encode: base64urlEncode<em class="ml"> }</em> <strong class="mk ir">from</strong> <em class="ml">"base64url"</em>;</span><span id="aedd" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">function </strong>publicKeyCredentialToJSON(pubKeyCred) {<br/>    <strong class="mk ir">if </strong>(pubKeyCred <strong class="mk ir">instanceof </strong><em class="ml">ArrayBuffer</em>) {<br/>        <strong class="mk ir">return </strong><em class="ml">base64urlEncode</em>(pubKeyCred);<br/>    } <strong class="mk ir">else if </strong>(pubKeyCred <strong class="mk ir">instanceof </strong><em class="ml">Array</em>) {<br/>        <strong class="mk ir">return </strong>pubKeyCred.map(publicKeyCredentialToJSON);<br/>    } <strong class="mk ir">else if </strong>(pubKeyCred <strong class="mk ir">instanceof </strong><em class="ml">Object</em>) {<br/>        <strong class="mk ir">const </strong>obj = {};<br/>        <strong class="mk ir">for </strong>(<strong class="mk ir">let </strong>key <strong class="mk ir">in </strong>pubKeyCred) {<br/>            obj[key] = publicKeyCredentialToJSON(pubKeyCred[key]);<br/>        }<br/>        <strong class="mk ir">return </strong>obj;<br/>    } <strong class="mk ir">else return </strong>pubKeyCred;<br/>}</span><span id="c81a" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">const </strong>webAuthnAttestation = publicKeyCredentialToJSON(attestation);</span><span id="c176" class="lq kt iq mk b gy oi of l og oh">fetch(<em class="ml">"example.com/save-public-key"</em>, {<br/>    <strong class="mk ir">method:</strong> <em class="ml">"POST"</em>,<br/>    <strong class="mk ir">headers:</strong> { <em class="ml">"Content-Type"</em>: <em class="ml">"application/json"</em> },<br/>    <strong class="mk ir">body:</strong> webAuthnAttestation<br/>});</span></pre><p id="adca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><em class="ml">navigator.credentials.create</em></code>可以接受更多不同的选项。尽管如此，我还是向您展示了我认为最适合指纹重新登录的列表。</p><p id="de86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">authenticatorAttachment:</strong> <em class="ml">“platform”</em></code>意味着你不希望人们使用他们所谓的<em class="ml">漫游</em>授权码。这些不是内置在您的设备中，而是连接到它的独立设备(USB、NFC等)。“平台”意味着您只想使用内置在您的计算机/手机中的授权码。这些大多是各种生物扫描仪，如指纹，FaceID等。</p><p id="1363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要<code class="fe mh mi mj mk b"><strong class="jp ir">userVerification</strong>: <em class="ml">“required”</em></code>来确保当你调用API时指纹扫描仪总是弹出。否则，在某些情况下，浏览器可能会跳过扫描。虽然，我不知道它被跳过的真实生活场景是什么。</p><p id="5ea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">challenge</strong>: <em class="ml">base64urlDecode</em>(challenge)</code>是您刚刚从服务器读取的<code class="fe mh mi mj mk b">challenge</code>值。</p><p id="0861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">rp</strong>: { <strong class="jp ir">id</strong>: <em class="ml">document.domain</em>, <strong class="jp ir">name</strong>: <em class="ml">“My Acme Inc”</em><strong class="jp ir"> </strong>}</code>代表<strong class="jp ir">艺术。长话短说——这是你的网站。<code class="fe mh mi mj mk b">name</code>可以在指纹验证阶段显示给用户。顺便说一句，提供除了<code class="fe mh mi mj mk b">document.domain</code>之外的任何东西都会抛出异常。</strong></p><p id="c335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信<code class="fe mh mi mj mk b"><strong class="jp ir">user:</strong></code>是自我描述的。这些大多是可选值。但是为了更好的UX和安全性，我建议通过它们。</p><p id="3c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">pubKeyCredParams:</strong></code>总是一样的。我不知道这些影响有多大。</p><p id="4225" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><em class="ml">navigator.credentials.preventSilentAccess</em>()</code>确保自动登录永远不会发生。然而，我不知道这一呼吁是否有必要。参见<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/preventSilentAccess" rel="noopener ugc nofollow" target="_blank"> MDN </a>文档。</p><p id="638b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">返回的<code class="fe mh mi mj mk b">webAuthnAttestation</code>如下所示:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="334d" class="lq kt iq mk b gy oe of l og oh">{<br/>    id: <em class="ml">"a_very_very_log_string"</em>,<br/>    type: <em class="ml">"public-key"</em>,<br/>    response: {<br/>        attestationObject: <em class="ml">"even_longer_string"</em>,<br/>        clientDataJSON: <em class="ml">"another_very_long_string"</em><br/>    }<br/>}</span></pre><p id="11fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<code class="fe mh mi mj mk b">id</code>是公钥。</p><p id="caf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">attestationObject</code>需要在服务器端以特殊的方式解码。它包含一个重要的身份验证数据，将在指纹验证过程中使用。我们以后再讨论。</p><p id="0f1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">clientDataJSON</code>只是一个base64编码的JSON(在下面找到解码源代码)。至少包含3样东西:</p><ul class=""><li id="9902" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">服务器生成的<code class="fe mh mi mj mk b">challenge</code>你已经熟悉了。</li><li id="b915" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">origin</code> —你的网站主机名。</li><li id="05eb" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">type</code> —必须是以下字符串:“webauthn.create”。</li></ul><h2 id="be71" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">验证并存储公钥</h2><p id="e3ff" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这是服务器端代码。首先，您需要验证传入的数据。</p><p id="4a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">type</code>必须是“公钥”字符串。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="b3a0" class="lq kt iq mk b gy oe of l og oh">assert(type === <em class="ml">"public-key"</em>);</span></pre><p id="5e84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解码<code class="fe mh mi mj mk b">clientDataJSON</code>字符串。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="adfd" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">const </strong>base64url = <em class="ml">require</em>(<strong class="mk ir"><em class="ml">"base64url"</em></strong>);<br/>clientDataJSON = <strong class="mk ir"><em class="ml">JSON</em></strong>.parse(base64url.decode(clientDataJSON));</span></pre><p id="b099" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">clientDataJSON</code>检查:<code class="fe mh mi mj mk b">challenge</code>必须与我们发送给浏览器的相同。<code class="fe mh mi mj mk b">origin</code>必须是我们网站的主机名。<code class="fe mh mi mj mk b">type</code>必须是“webauthn.create”。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="cd7a" class="lq kt iq mk b gy oe of l og oh">assert(<!-- -->clientDataJSON<!-- -->.<!-- -->challenge<!-- --> === device.challenge)</span><span id="ad32" class="lq kt iq mk b gy oi of l og oh">assert(<!-- -->clientDataJSON<!-- -->.<!-- -->origin<!-- --> === <em class="ml">"example.com"</em>);</span><span id="d310" class="lq kt iq mk b gy oi of l og oh">assert(<!-- -->clientDataJSON<!-- -->.<!-- -->type<!-- --> === <em class="ml">"webauthn.create"</em>);</span></pre><p id="9d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而<code class="fe mh mi mj mk b">attestationObject</code>有点复杂。</p><p id="710d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您需要解析它。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="fa0b" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">const </strong>base64url = <em class="ml">require</em>(<strong class="mk ir"><em class="ml">"base64url"</em></strong>);<br/><strong class="mk ir">const </strong>cbor = <em class="ml">require</em>(<strong class="mk ir"><em class="ml">"cbor"</em></strong>);</span><span id="863f" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">function</strong> parseAttestationObject(attestationObject) {<br/>    <strong class="mk ir">const </strong>buffer = base64url.toBuffer(attestationObject);<br/>    <strong class="mk ir">return </strong>cbor.decodeAllSync(buffer)[0];<br/>}</span><span id="3bbc" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">const </strong>makeCredsReponse = parseAttestationObject(attestationObject);</span></pre><p id="d77d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对象包含很少的属性，但是我们只对其中的两个感兴趣:<code class="fe mh mi mj mk b">fmt</code>和<code class="fe mh mi mj mk b">authData</code>。我不会深入探讨这个问题，但是你可以在阿克曼·塞维多夫的这篇优秀文章中了解更多。</p><p id="f210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">makeCredsReponse.fmt</code>必须是<code class="fe mh mi mj mk b">"none"</code>。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="3c24" class="lq kt iq mk b gy oe of l og oh">assert(makeCredsReponse.fmt === <em class="ml">"none"</em>);</span></pre><p id="7eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长话短说，这意味着你不想跟踪你的用户的硬件。此外，这大大简化了公钥验证码。另外，我发现如果你试图在这里使用不同的东西，浏览器会问一些令人害怕的问题。比如:</p><blockquote class="ol om on"><p id="2f89" class="jn jo ml jp b jq jr js jt ju jv jw jx oo jz ka kb op kd ke kf oq kh ki kj kk ij bi translated"><em class="iq">您想让此网站访问您手机的私钥吗？</em></p></blockquote><p id="623a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的直觉告诉我点击“否”,当我第一次看到它时，我就这样做了。</p><p id="1730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">makeCredsReponse.authData</code>将用于指纹验证阶段。确保它存在就行了。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="e0e4" class="lq kt iq mk b gy oe of l og oh">assert(<!-- -->makeCredsReponse.authData);</span></pre><p id="3f8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，<strong class="jp ir">您需要将</strong> <code class="fe mh mi mj mk b">publicKey</code>、<code class="fe mh mi mj mk b">type</code>、<code class="fe mh mi mj mk b">attestationObject</code>和<code class="fe mh mi mj mk b">clientDataJSON</code>保存到您最安全的数据库中相应的<code class="fe mh mi mj mk b">devices</code>记录中。</p><p id="ef23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伪代码:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="3260" class="lq kt iq mk b gy oe of l og oh">device.counter = 0; <em class="ml">// we must reset the counter</em></span><span id="762b" class="lq kt iq mk b gy oi of l og oh">device.publicKey = publicKey;<br/>device.type = type;<br/>device.attestationObject = attestationObject;<em class="ml"><br/></em>device.clientDataJSON = clientDataJSON;</span><span id="b9f9" class="lq kt iq mk b gy oi of l og oh">device.userAgent = req.headers["user-agent"];</span><span id="248f" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">await</strong> device.save();</span></pre><p id="12e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。您的用户刚刚设置了指纹扫描仪，请重新登录。</p><h1 id="7061" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">验证指纹流</h1><h2 id="8b2a" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">获取挑战公开密钥</h2><p id="1a9e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这是一个服务器端端点(GraphQL查询、gRPC方法等)。类似于上面的<code class="fe mh mi mj mk b">get-challenge</code>请求，您的web应用程序需要执行一个空的<code class="fe mh mi mj mk b">get-challenge-and-publicKey</code>请求。服务器将获取长期存在的cookie，通过它查找数据库，生成并保存一个新的<code class="fe mh mi mj mk b">challenge</code>，并返回<code class="fe mh mi mj mk b">challenge</code>和<code class="fe mh mi mj mk b">publicKey</code>。</p><p id="e498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伪代码:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="b805" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">const</strong> deviceId = req.cookies["my-long-live-cookie"];<br/><strong class="mk ir">const</strong> device = <strong class="mk ir">await</strong> devices.findById(deviceId);<br/><strong class="mk ir">if</strong> (!device) <strong class="mk ir">return</strong> {};<br/>device.challenge = require("crypto").randomBytes(16).toString("hex")<br/><strong class="mk ir">await</strong> device.save();<br/><strong class="mk ir">return</strong> { challenge: device.challenge, publicKey: device.publicKey };</span></pre><h2 id="3891" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">验证公钥</h2><p id="bc8d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">您的浏览器调用WebAuthn API来扫描用户的手指，以验证密钥和服务器质询。</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="eb71" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">const </strong>assertionObj = <strong class="mk ir">await </strong><em class="ml">navigator.credentials.get</em>({<br/>    <strong class="mk ir">publicKey</strong>: {<br/>        <strong class="mk ir">challenge</strong>: <em class="ml">base64urlDecode</em>(challenge),<br/>        <strong class="mk ir">rpId</strong>: <em class="ml">document.domain</em>,<br/>        <strong class="mk ir">allowCredentials</strong>: [<br/>            {<br/>                <strong class="mk ir">type</strong>: <em class="ml">"public-key"</em>,<br/>                <strong class="mk ir">id</strong>: <em class="ml">base64urlDecode</em>(publicKey)<br/>            }<br/>        ],<br/>        <strong class="mk ir">userVerification</strong>: <em class="ml">"required"</em><strong class="mk ir"><br/>    </strong>}<br/>});</span><span id="ae97" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">const </strong>webAuthnAssertion = publicKeyCredentialToJSON(assertionObj);</span><span id="abd1" class="lq kt iq mk b gy oi of l og oh">fetch(<em class="ml">"example.com/sign-in"</em>, {<br/>    <strong class="mk ir">method:</strong> <em class="ml">"POST"</em>,<br/>    <strong class="mk ir">headers:</strong> { <em class="ml">"Content-Type"</em>: <em class="ml">"application/json"</em> },<br/>    <strong class="mk ir">body:</strong> webAuthnAssertion<br/>});</span></pre><p id="49ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><em class="ml">navigator.credentials.get</em></code>将要求我们的用户扫描他们的手指。</p><p id="8dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">challenge</strong>:</code>是我们刚刚从服务器收到的值。</p><p id="31dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">rpId</strong>:</code>必须与之前相同。同样，网站域名之外的值在我的测试中不起作用。</p><p id="d387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">allowCredentials</strong>:</code>是用户正在验证的公钥列表。是的，可以有很多。出于简单的原因，我不会在这里推荐一个以上的。</p><p id="86b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">type</strong>: <em class="ml">“public-key”</em></code>是必须的。</p><p id="47fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">id</strong>: <em class="ml">base64urlDecode</em>(publicKey)</code>是我们刚刚从服务器收到的<code class="fe mh mi mj mk b">publicKey</code>值。</p><p id="15d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b"><strong class="jp ir">userVerification</strong>: <em class="ml">“required”</em></code>与之前的相同。它确保用户总是参与其中(应用他们的手指)。</p><p id="3476" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">返回的<code class="fe mh mi mj mk b">webAuthnAssertion</code>如下所示:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="087c" class="lq kt iq mk b gy oe of l og oh">{<br/>    id: <em class="ml">"same_very_very_log_string"</em>,<br/>    type: <em class="ml">"public-key"</em>,<br/>    response: {<br/>        authenticatorData: <em class="ml">"long_string"</em>,<br/>        clientDataJSON: <em class="ml">"similar_long_string",<br/>        </em>signature: "<em class="ml">not_long_but_still_string</em>",<br/>        userHandle: "<em class="ml">your_user_id</em>"<em class="ml"><br/></em>    }<br/>}</span></pre><p id="fe0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<code class="fe mh mi mj mk b">id</code>是同一个公钥。</p><p id="7968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">authenticatorData</code>需要在服务器端以特殊的方式解码。它包含一个重要的身份验证数据，该数据将在服务器上的指纹验证过程中使用。</p><p id="055c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">clientDataJSON</code>与上面的<code class="fe mh mi mj mk b">clientDataJSON</code>相同，是一个base64编码的JSON:</p><ul class=""><li id="fe8b" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">好的旧服务器生成了<code class="fe mh mi mj mk b">challenge</code>字符串。</li><li id="4442" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">origin</code> —你的网站主机名。</li><li id="6bc8" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">type</code> —必须是以下字符串:“webauthn.get”。</li></ul><p id="393e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">signature</code>是我们的服务器将要验证的主要加密值。</p><p id="0168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">userHandle</code>应该是我们在设置阶段提供的<code class="fe mh mi mj mk b">user.id</code>值。虽然，说明书上说<code class="fe mh mi mj mk b">userHandle</code>是<strong class="jp ir">可选</strong>，可以省略。</p><h2 id="c817" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">验证签名</h2><p id="e0e1" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">整件事最重要的部分来了。请在您的服务器端实现它，不要使用快捷方式。</p><p id="0d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是您的服务器需要逐一执行的检查列表。</p><ol class=""><li id="57b1" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk nm mt mu mv bi translated">确保<code class="fe mh mi mj mk b">sign-in</code>请求的<code class="fe mh mi mj mk b">user-agent</code>(浏览器)与<strong class="jp ir">验证并存储公钥</strong>服务器调用(设置)期间的相同。确保你迎合了版本的变化。例如，Chrome浏览器每6周更新一次版本。</li><li id="6a9f" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated">确保<code class="fe mh mi mj mk b">id</code>(又名<code class="fe mh mi mj mk b">publicKey</code>)和<code class="fe mh mi mj mk b">type</code>与设置期间完全相同。这些应该存储在您的<code class="fe mh mi mj mk b">devices</code>表中。<br/> <code class="fe mh mi mj mk b">assert(publicKey === device.publicKey);</code></li><li id="344d" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated">如果提供了<code class="fe mh mi mj mk b">userHandle</code>，那么也进行比较。<br/> <code class="fe mh mi mj mk b"><strong class="jp ir">if</strong> (userHandle) assert(userHandle === device.user);</code></li><li id="4ea5" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated">解析<code class="fe mh mi mj mk b">clientDataJSON</code>(与之前相同)并检查:<br/> * <code class="fe mh mi mj mk b">challenge</code>是否与设置期间完全相同(存储在您的<code class="fe mh mi mj mk b">devices</code>表中)。<br/> <code class="fe mh mi mj mk b">assert(clientDataJSON.challenge === device.challenge);</code> <br/> * <code class="fe mh mi mj mk b">origin</code>正好作为你网站的域名。<br/> <code class="fe mh mi mj mk b">assert(clientDataJSON.origin === <em class="ml">"example.com"</em>);</code> <br/> * <code class="fe mh mi mj mk b">type</code>正是这个字符串—“<em class="ml">web authn . get</em>”。<br/> <code class="fe mh mi mj mk b">assert(clientDataJSON.type === <em class="ml">"webauthn.get"</em>);</code></li><li id="2613" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk nm mt mu mv bi translated">加密签名验证。这是拼图中最难的部分。代码很长，可能会令人困惑。我从Express.js 项目的<a class="ae mm" href="https://github.com/strangerlabs/webauthn/blob/9959cb2b5f87692b8b1fecd799dd4029a3bf61b1/src/Webauthn.js#L501" rel="noopener ugc nofollow" target="_blank"> webauthn中复制(并修改)了逻辑。</a></li></ol><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="or kr l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">服务器端签名验证的完整源代码</figcaption></figure><p id="c3ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">verifyAssertion</code>功能需要稍微解释一下。它使用接收到的签名和先前存储的公钥来验证接收到的数据。</p><p id="a1e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些论点是:</p><ul class=""><li id="2585" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">counter</code> —存储在<code class="fe mh mi mj mk b">device.counter</code>中的前一次重新登录期间断言的<code class="fe mh mi mj mk b">counter</code>值(如果是第一次重新登录，则为<code class="fe mh mi mj mk b">0</code>)。每次调用<code class="fe mh mi mj mk b"><em class="ml">navigator.credentials.get</em></code>时，浏览器都会增加一个随机值。<strong class="jp ir">这个</strong> <code class="fe mh mi mj mk b"><strong class="jp ir">counter</strong></code> <strong class="jp ir">就是指纹重新登录功能和传统2FA方案一样安全的原因之一。<br/> </strong>它用来避免所谓的“重放攻击”。当身份验证数据(如使用密码登录，或者在我们的例子中是<code class="fe mh mi mj mk b">assertionObject</code>)被坏人捕获，然后一遍又一遍地重新发送到我们的服务器，以便从任何设备随意重新登录时。多亏了这个<code class="fe mh mi mj mk b">counter</code>，<code class="fe mh mi mj mk b">signature</code>值永远不会相同！</li><li id="cf9c" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">attestationObject</code> —先前提供的存储在<code class="fe mh mi mj mk b">device.attestationObject</code>中的字符串。参见上面的<strong class="jp ir">设置指纹流程</strong>。(如果你仔细观察代码，你可能不需要存储整个字符串，可能只需要存储其中的<code class="fe mh mi mj mk b">COSEPublicKey</code>部分。)</li><li id="c1a6" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated"><code class="fe mh mi mj mk b">clientDataJSON</code>、<code class="fe mh mi mj mk b">authenticatorData</code>、<code class="fe mh mi mj mk b">signature</code> —是从浏览器发送的值。</li></ul><p id="2ef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果成功，<code class="fe mh mi mj mk b">verifyAssertion</code>函数返回新的<code class="fe mh mi mj mk b">counter</code>值。您必须将其保存到数据库中的<code class="fe mh mi mj mk b">attestationObject</code>值旁边。然后您需要发出new <code class="fe mh mi mj mk b">authToken</code>(也就是为链接到这个设备的用户创建一个新的登录会话)并将其返回给浏览器。</p><p id="b2e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出错，该函数将抛出。我建议发送安全警报(电子邮件？)每次这个函数抛出。这很可能意味着你被黑了。</p><p id="ef00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器伪代码:</p><pre class="kl km kn ko gt oa mk ob oc aw od bi"><span id="a60d" class="lq kt iq mk b gy oe of l og oh"><strong class="mk ir">const</strong> base64url = require(<em class="ml">"base64url"</em>);</span><span id="b8ca" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">const</strong> deviceId = req.cookies["<em class="ml">my-long-live-cookie"</em>];<br/><strong class="mk ir">const</strong> device = <strong class="mk ir">await</strong> devices.findById(deviceId);<br/><strong class="mk ir">try</strong> {<br/>    <strong class="mk ir">const</strong> { publicKey, type, <!-- -->authenticatorData, clientDataJSON, signature, userHandle } = req.body;</span><span id="e2fb" class="lq kt iq mk b gy oi of l og oh">    assert(type === "public-key");<br/>    assert(publicKey === device.publicKey);<br/>    <strong class="mk ir">if</strong> (userHandle) assert(userHandle === device.user);</span><span id="1b5b" class="lq kt iq mk b gy oi of l og oh"><strong class="mk ir">    const</strong> clientData = <strong class="mk ir">JSON</strong>.parse(base64url.decode(clientDataJSON));</span><span id="0546" class="lq kt iq mk b gy oi of l og oh">    assert(clientData.challenge === device.challenge);<br/>    assert(clientData.origin === <em class="ml">"example.com"</em>);<br/>    assert(clientData.type === <em class="ml">"webauthn.get"</em>);</span><span id="2ec6" class="lq kt iq mk b gy oi of l og oh">    <strong class="mk ir">const</strong> newCounter = verifyAssertion({<br/>        counter: device.counter,<br/>        <!-- -->attestationObject<!-- -->: device.<!-- -->attestationObject,<br/>        clientDataJSON,<br/>        authenticatorData,<br/>        <!-- -->signature<br/>    });<br/>    device.counter = newCounter;<br/>    <strong class="mk ir">await</strong> device.save();</span><span id="3a53" class="lq kt iq mk b gy oi of l og oh">    res.status(200).send({ <br/>        authToken: <strong class="mk ir"><em class="ml">CREATE_NEW_AUTH_TOKEN(device.user)<br/>    </em></strong>});<br/>} <strong class="mk ir">catch</strong> (err) {<br/>    <!-- -->res.sendStatus(400);<br/>    <!-- -->console.error(err);<br/><strong class="mk ir"><em class="ml">    NOTIFY_SECURITY_OF_A_HACK_ATTEMPT();<br/></em></strong>}</span></pre><p id="a27c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那都是乡亲们！</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="e553" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">放弃</h2><p id="18ff" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">据我所知，即使有一天有人窃取了<code class="fe mh mi mj mk b">devices</code>数据库表(它包含了<code class="fe mh mi mj mk b">challenge</code>、<code class="fe mh mi mj mk b">publicKey</code>和<code class="fe mh mi mj mk b">attestationObject</code>安全值)，您的用户也会受到保护！因为私钥仍然存储在用户的设备上。换句话说，任何人都不能用窃取的数据登录。</p><blockquote class="ol om on"><p id="b43a" class="jn jo ml jp b jq jr js jt ju jv jw jx oo jz ka kb op kd ke kf oq kh ki kj kk ij bi translated">请注意，我不是高级加密和安全专家。请你找出这篇文章的缺点。非常感谢。</p></blockquote><p id="46c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有意让这篇博文尽可能简洁。我不会深入研究WebAuthn API和密码学的太多细节。目的是为非专业开发人员提供足够的信息，以安全的方式快速实现指纹(或其他生物特征)重新登录功能。</p><p id="2463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">展示的应用程序是<a class="ae mm" href="https://flash-fx.com" rel="noopener ugc nofollow" target="_blank">https://flash-fx.com</a>，我们是一家澳大利亚公司，使用区块链技术(Ripple)进行国际货币转移。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="84cb" class="lq kt iq bd ku lr ls dn ky lt lu dp lc jy lv lw lg kc lx ly lk kg lz ma lo mb bi translated">更新</h2><p id="04bf" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi">2020–08–02:</p><blockquote class="ol om on"><p id="5288" class="jn jo ml jp b jq jr js jt ju jv jw jx oo jz ka kb op kd ke kf oq kh ki kj kk ij bi translated">1.每次浏览器请求时，都必须生成一个新的<code class="fe mh mi mj mk b"><em class="iq">challenge</em></code>。<br/>之前，文章表明挑战永远不会重现。</p><p id="d9ed" class="jn jo ml jp b jq jr js jt ju jv jw jx oo jz ka kb op kd ke kf oq kh ki kj kk ij bi translated">2.使用<code class="fe mh mi mj mk b"><em class="iq">Buffer.randomBytes</em></code>生成<code class="fe mh mi mj mk b"><em class="iq">challenge</em></code> s。<br/>之前，本文使用UUID作为挑战生成器，这在信息安全领域被认为不够随机。</p></blockquote></div></div>    
</body>
</html>