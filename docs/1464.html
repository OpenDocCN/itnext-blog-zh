<html>
<head>
<title>Streams For the Win: A Performance Comparison of Node.js Methods for Reading Large Datasets (Pt 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成功的流:读取大型数据集的Node.js方法的性能比较(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/streams-for-the-win-a-performance-comparison-of-nodejs-methods-for-reading-large-datasets-pt-2-bcfa732fa40e?source=collection_archive---------0-----------------------#2018-10-24">https://itnext.io/streams-for-the-win-a-performance-comparison-of-nodejs-methods-for-reading-large-datasets-pt-2-bcfa732fa40e?source=collection_archive---------0-----------------------#2018-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="a40d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">readFile()、createReadStream()和事件流如何相互叠加</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/aebc4c150d9cec4dfd62fe2d1cc6ed0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsseXIPGEhwmg6kfgXyIjA.jpeg"/></div></div></figure><p id="8608" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi ly translated"><span class="l lz ma mb bm mc md me mf mg di">如果</span>你一直在关注我的写作，几周前，我发表了一篇<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">博客</a>，谈论使用Node.js读取真正大型数据集的各种方法。</p><p id="b2f0" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">令我惊讶的是，它在读者中表现得非常好——这似乎(对我来说)像是一个许多人已经在帖子、博客和论坛中涉及的主题，但不管出于什么原因，它得到了许多人的关注。所以，感谢所有花时间阅读它的人！我真的很感激。</p><p id="7f8e" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">一位特别精明的读者(<a class="mi mj ep" href="https://medium.com/u/8405c208bb0a?source=post_page-----bcfa732fa40e--------------------------------" rel="noopener" target="_blank">马丁·科克</a>)甚至问解析这些文件需要多长时间。他似乎已经读懂了我的心思，因为我关于使用Node.js读取非常非常大的文件和数据集的系列文章的第二部分就涉及到了这一点。</p><blockquote class="mk"><p id="bcae" class="ml mm it bd mn mo mp mq mr ms mt lx dk translated">在这里，我将评估我用来读取文件的Node.js中的三种不同方法，以确定哪种方法的性能最好。</p></blockquote><h2 id="5fe1" class="mu jr it bd js mv mw dn jw mx my dp ka ll mz na ke lp nb nc ki lt nd ne km nf bi translated">来自第1部分的挑战</h2><p id="ac53" class="pw-post-body-paragraph la lb it lc b ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">我不会深入探讨挑战和解决方案的细节，因为你可以在这里阅读我的第一篇文章了解所有细节<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">，但我会给你一个高层次的概述。</a></p><p id="4c97" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我所在的Slack频道的一个人发布了他收到的一个编码挑战，其中涉及读取一个非常大的数据集(总共超过2.5GB)，解析数据并提取各种信息。</p><p id="34a0" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">它要求程序员打印:</p><ul class=""><li id="403a" class="nl nm it lc b ld le lh li ll nn lp no lt np lx nq nr ns nt bi translated">文件中的总行数，</li><li id="f50f" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">第432号和第43243号索引中的名称，</li><li id="d552" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">统计每月捐赠总数，</li><li id="145f" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">以及文件中最常见的名字和它出现的频率。</li></ul><p id="2feb" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">数据链接:<a class="ae mh" href="https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip" rel="noopener ugc nofollow" target="_blank">https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip</a></p><h2 id="f460" class="mu jr it bd js mv nz dn jw mx oa dp ka ll ob na ke lp oc nc ki lt od ne km nf bi translated">适用于较小数据集的三种不同解决方案</h2><p id="1112" class="pw-post-body-paragraph la lb it lc b ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">当我朝着处理大型数据集的最终目标努力时，我在Node.js中提出了三个解决方案。</p><p id="dd3f" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案一:</strong> <code class="fe oe of og oh b"><a class="ae mh" href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">fs.readFile()</strong></a></code></p><p id="80f5" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">第一个涉及Node.js的本地方法<code class="fe oe of og oh b">fs.readFile()</code>，包括读入整个文件，将其保存在内存中，对整个文件执行操作，然后返回结果。至少对于较小的文件来说，它是有效的，但是当我达到最大文件大小时，我的服务器崩溃了，出现了一个JavaScript <code class="fe oe of og oh b">heap out of memory</code>错误。</p><p id="fb20" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案二:</strong> <code class="fe oe of og oh b"><a class="ae mh" href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">fs.createReadStream()</strong></a><strong class="lc iu"> &amp; </strong><a class="ae mh" href="https://nodejs.org/api/readline.html#readline_event_line" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">rl.readLine()</strong></a></code></p><p id="8615" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我的第二个解决方案还涉及Node.js固有的另外两个方法:<code class="fe oe of og oh b">fs.createReadStream()</code>和<code class="fe oe of og oh b">rl.readLine()</code>。在这个迭代中，文件通过Node.js以一个<code class="fe oe of og oh b">input</code>流传输，我能够在每一行上执行单独的操作，然后将所有这些结果汇集在<code class="fe oe of og oh b">output</code>流中。同样，这在较小的文件上工作得很好，但是当我到达最大的文件时，同样的错误发生了。尽管Node.js对输入和输出进行了流式处理，但在执行操作时，它仍然试图将整个文件保存在内存中(并且无法处理整个文件)。</p><p id="4117" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案三:</strong> <code class="fe oe of og oh b"><a class="ae mh" href="https://www.npmjs.com/package/event-stream" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">event-stream</strong></a></code></p><p id="4dfa" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">最终，我在Node.js中找到了唯一一个能够一次性处理我想要解析的2.55GB文件的解决方案。</p><blockquote class="mk"><p id="484e" class="ml mm it bd mn mo mp mq mr ms mt lx dk translated">有趣的事实:Node.js在任何时候都只能容纳1.67GB的内存，在此之后，它会抛出JavaScript <code class="fe oe of og oh b">heap out of memory</code>错误。</p></blockquote><p id="10e4" class="pw-post-body-paragraph la lb it lc b ld oi lf lg lh oj lj lk ll ok ln lo lp ol lr ls lt om lv lw lx im bi translated">我的解决方案涉及一个流行的NPM包，名为<a class="ae mh" href="https://www.npmjs.com/package/event-stream" rel="noopener ugc nofollow" target="_blank"> event-stream </a>，它实际上让我对数据的<em class="on">吞吐量流</em>执行操作，而不仅仅是输入和输出流，这是Node.js的本机功能所允许的。</p><p id="fa54" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">你可以在Github的这里看到我所有的三个解决方案<a class="ae mh" href="https://github.com/paigen11/file-read-challenge" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="db6d" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我解决了这个问题，这是我最初的目标，但它让我思考:我的解决方案真的是三个选项中最有效的吗？</p><h2 id="ec5c" class="mu jr it bd js mv nz dn jw mx oa dp ka ll ob na ke lp oc nc ki lt od ne km nf bi translated">比较它们以找到最佳解决方案</h2><p id="a581" class="pw-post-body-paragraph la lb it lc b ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">现在，我有了一个新的目标:确定我的解决方案中哪一个是最好的。</p><p id="b8f1" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">由于我无法在Node.js本地解决方案中使用完整的2.55GB文件，所以我选择使用一个较小的文件，大约400MB的数据，这是我在开发解决方案时用于测试的。</p><p id="27c3" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">对于性能测试Node.js，我遇到了两种跟踪文件和单个函数处理时间的方法，我决定将这两种方法结合起来，看看这两种方法之间的差异有多大(并确保我没有完全偏离我的计时)。</p><p id="1a3d" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe oe of og oh b"><a class="ae mh" href="https://nodejs.org/api/console.html#console_console_time_label" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">console.time()</strong></a></code>T11】T13)T12)T1)</p><p id="4667" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">Node.js有一些方便的内置方法可用于计时和性能测试，分别称为<code class="fe oe of og oh b">console.time()</code>和<code class="fe oe of og oh b">console.timeEnd()</code>。要使用这些方法，我只需为<code class="fe oe of og oh b">time()</code>和<code class="fe oe of og oh b">timeEnd()</code>传递相同的标签参数，就像这样，Node足够聪明，可以在函数完成后输出它们之间的时间。</p><pre class="kp kq kr ks gt oo oh op oq aw or bi"><span id="45be" class="mu jr it oh b gy os ot l ou ov">// timer start<br/>console.time('label1');</span><span id="76ff" class="mu jr it oh b gy ow ot l ou ov">// run function doing something in the code<br/>doSomething();</span><span id="f1cd" class="mu jr it oh b gy ow ot l ou ov">// timer end, where the difference between the timer start and timer end is printed out<br/>console.timeEnd('label1');</span><span id="5844" class="mu jr it oh b gy ow ot l ou ov">// output in console looks like: label1 0.002ms</span></pre><p id="baf3" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是我用来计算处理数据集所需时间的一种方法。</p><p id="68ca" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe oe of og oh b"><a class="ae mh" href="https://www.npmjs.com/package/performance-now" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">performance-now</strong></a></code></p><p id="bc60" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">另一个，我遇到的Node.js的经过测试的、很受欢迎的性能测试模块是作为<code class="fe oe of og oh b"><a class="ae mh" href="https://www.npmjs.com/package/performance-now" rel="noopener ugc nofollow" target="_blank">performance-now</a></code>托管在NPM上的。</p><p id="7e2d" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">每周从NPM下载700多万次，不会太离谱吧？？</p><p id="c97b" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">将<code class="fe oe of og oh b">performance-now</code>模块实现到我的文件中也几乎和原生Node.js方法一样简单。导入模块，为方法实例化的开始和结束设置一个变量，计算两者之间的时间差。</p><pre class="kp kq kr ks gt oo oh op oq aw or bi"><span id="e221" class="mu jr it oh b gy os ot l ou ov">// import the performance-now module at the top of the file<br/>const now = require('performance-now');</span><span id="7270" class="mu jr it oh b gy ow ot l ou ov">// set the start of the timer as a variable<br/>const start = now();</span><span id="1719" class="mu jr it oh b gy ow ot l ou ov">// run function doing something in the code<br/>doSomething();</span><span id="5629" class="mu jr it oh b gy ow ot l ou ov">// set the end of the timer as a variable<br/>const end = now();</span><span id="9c8b" class="mu jr it oh b gy ow ot l ou ov">// Compute the duration between the start and end<br/>console.log('Performance for timing for label:' + (end — start).toFixed(3) + 'ms';</span><span id="beb0" class="mu jr it oh b gy ow ot l ou ov">// console output looks like: Performance for timing label: 0.002ms</span></pre><p id="1f66" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我认为，通过同时使用节点的<code class="fe oe of og oh b">console.time()</code>和<code class="fe oe of og oh b">performance-now</code>，我可以拆分差异，并获得关于我的文件解析函数实际花费了多长时间的非常准确的读数。</p><p id="6ed9" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">下面是在我的每个脚本中实现<code class="fe oe of og oh b">console.time()</code>和<code class="fe oe of og oh b">performance-now</code>的代码片段。这些只是每个函数的片段——完整的代码，你可以在这里看到我的报告<a class="ae mh" href="https://github.com/paigen11/file-read-challenge" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5671" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu"> Fs.readFile()代码实现示例</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/6a04f040bce7bafe0229b2978836ed07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n48UZ77lvktwjN6IDR0x1g.png"/></div></div></figure><p id="4c7a" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">因为这个脚本使用了<code class="fe oe of og oh b">fs.readFile()</code>实现，在执行任何函数之前，整个文件都被读入内存，所以这是看起来最同步的代码。它实际上不是同步的，那是一个完全独立的叫做<code class="fe oe of og oh b">fs.readFileSync()</code>的节点方法，它只是类似于它。</p><p id="ed41" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">但是很容易看到文件的总行数和两个计时方法来确定执行行数需要多长时间。</p><p id="e9c8" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu"> Fs.createReadStream()代码实现示例</strong></p><p id="f9d8" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">输入流(逐行):</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/9aa7fd3116097ecb99540985d9b956c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwIXtNCMSmCJBu7DX4zxGA.png"/></div></div></figure><p id="d7bc" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">输出流(在输入期间读取完整文件后):</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/d19611b67a27830a2e34ba1402a95ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhhHpFIS5b-UdluXYgLaIg.png"/></div></div></figure><p id="d4f6" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">由于使用<code class="fe oe of og oh b">fs.createReadStream()</code>的第二个解决方案涉及为文件创建输入和输出流，我将代码片段分成两个单独的截图，第一个来自输入流(逐行运行代码)，第二个来自输出流(编译所有结果数据)。</p><p id="da61" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">事件流代码实现示例</strong></p><p id="4be8" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">直通流(也是逐行的):</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/e1b0c0deeb1b5d460efebd99a56e884e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzzXjaStCYMgUHHE_qBiqw.png"/></div></div></figure><p id="6559" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">在流末端:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/12a567385b1d4e7ebee490feb985b926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgZQKTXROxXn6T9Gmqc0oA.png"/></div></div></figure><p id="5d09" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><code class="fe oe of og oh b">event-stream</code>解决方案看起来与<code class="fe oe of og oh b">fs.createReadStream()</code>非常相似，除了代替<em class="on">输入流</em>，数据在<em class="on">吞吐流</em>中处理。然后，一旦整个文件被读取，并且文件上的所有功能都已完成，流就结束了，所需的信息被打印出来。</p><h2 id="6a2e" class="mu jr it bd js mv nz dn jw mx oa dp ka ll ob na ke lp oc nc ki lt od ne km nf bi translated">结果</h2><p id="72f6" class="pw-post-body-paragraph la lb it lc b ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">现在到了我们期待已久的时刻:结果！</p><p id="e304" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">我在同一个400MB的数据集上运行了我的三个解决方案，该数据集包含了近200万条要解析的记录。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/9f9abd00bff6df3feb73d20c217cf293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3fMjpvkyTMccexwsa3gjw.png"/></div></div><figcaption class="oz pa gj gh gi pb pc bd b be z dk translated">为胜利而战！</figcaption></figure><p id="ce14" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">从表中可以看出，<code class="fe oe of og oh b">fs.createReadStream()</code>和<code class="fe oe of og oh b">event-stream</code>都表现不错，但总的来说，<code class="fe oe of og oh b">event-stream</code>在我看来是最大的赢家，因为它可以处理比<code class="fe oe of og oh b">fs.readFile()</code>或<code class="fe oe of og oh b">fs.createReadStream()</code>大得多的文件。</p><p id="5d5d" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">上表末尾也列出了改进的百分比，以供参考。</p><p id="4ee9" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">刚刚被竞争对手打得落花流水。通过流式传输数据，文件的处理时间缩短了至少78% —有时接近100%，这是相当惊人的。</p><p id="f257" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">以下是我的每个解决方案在终端上的原始截图。</p><p id="638b" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案一:</strong> <code class="fe oe of og oh b"><a class="ae mh" href="https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">fs.readFile()</strong></a></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/9f8e817cc4e3412e6c84b1ffad63b222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luMWmrPikShHXtu6yScO9g.png"/></div></div><figcaption class="oz pa gj gh gi pb pc bd b be z dk translated">仅使用fs.readFile()的解决方案</figcaption></figure><p id="9a44" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案二:</strong> <code class="fe oe of og oh b"><a class="ae mh" href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">fs.createReadStream()</strong></a><strong class="lc iu"> &amp; </strong><a class="ae mh" href="https://nodejs.org/api/readline.html#readline_event_line" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">rl.readLine()</strong></a></code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/478634c89413177b714cb4cf6f0cf81f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhF6hIxI7aE3VsMubmVUOQ.png"/></div></div><figcaption class="oz pa gj gh gi pb pc bd b be z dk translated">使用fs.createReadStream()和rl.readLine()的解决方案</figcaption></figure><p id="f8a4" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案三:</strong>T3】</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/3578dfc9bc8e494179483ec538a1cd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzQIXZKNvGfrZzXtEP_31g.png"/></div></div><figcaption class="oz pa gj gh gi pb pc bd b be z dk translated">使用事件流的解决方案</figcaption></figure><p id="04be" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">奖金</strong></p><p id="d60f" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">这是我的<code class="fe oe of og oh b">event-stream</code>解决方案在2.55GB的怪物文件中翻腾的截图。这是400MB文件和2.55GB文件之间的时差。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/799290be3d1012dc04485a048b682232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zxbn3FCHM59DrDvY7P6bXg.png"/></div></div><figcaption class="oz pa gj gh gi pb pc bd b be z dk translated">看看这些超快的速度，尽管文件大小增加了近6倍。</figcaption></figure><p id="1239" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">方案三:</strong> <code class="fe oe of og oh b"><a class="ae mh" href="https://www.npmjs.com/package/event-stream" rel="noopener ugc nofollow" target="_blank"><strong class="lc iu">event-stream</strong></a></code> <strong class="lc iu">(在2.55GB文件上)</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ph"><img src="../Images/271d5199718b62a03ad6516a1417784e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-7OzvyTjFTjrxnO0rXYiA.png"/></div></div></figure><h2 id="661f" class="mu jr it bd js mv nz dn jw mx oa dp ka ll ob na ke lp oc nc ki lt od ne km nf bi translated">结论</h2><p id="2b06" class="pw-post-body-paragraph la lb it lc b ld ng lf lg lh nh lj lk ll ni ln lo lp nj lr ls lt nk lv lw lx im bi translated">最后，无论是Node.js本地的流还是非本地的流，在处理大型数据集时都要高效得多。</p><p id="95c1" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">感谢回到我的使用Node.js读取非常非常大的文件系列的第2部分。如果你想再次阅读第一篇博客，你可以在这里得到它。</p><p id="251f" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">几周后我会带着一个新的JavaScript主题回来——可能是在Node中调试，或者是用Puppeteer和headless Chrome进行端到端测试，所以请关注我以获取更多内容。</p><p id="09f4" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">感谢您的阅读，我希望这能让您了解如何使用Node.js高效地处理大量数据，并对您的解决方案进行性能测试。非常感谢鼓掌和分享！</p><p id="043f" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他博客:</p><ul class=""><li id="d6b9" class="nl nm it lc b ld le lh li ll nn lp no lt np lx nq nr ns nt bi translated"><a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/using-node-js-to-read-really-really-large-files-pt-1-d2057fe76b33">使用Node.js读取非常非常大的数据集&amp;文件(Pt 1) </a></li><li id="0216" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><a class="ae mh" href="https://medium.com/@paigen11/sequelize-the-orm-for-sql-databases-with-nodejs-daa7c6d5aca3" rel="noopener"> Sequelize:用Node.js实现Sequel数据库的ORM</a></li><li id="1b5a" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated"><a class="ae mh" href="https://medium.com/@paigen11/why-a-cloud-config-server-is-crucial-to-a-good-ci-cd-pipeline-and-how-to-set-it-up-pt-1-fa628a125776" rel="noopener">为什么Spring Cloud配置服务器对一个好的CI/CD管道至关重要，以及如何设置它(第1部分)</a></li></ul></div><div class="ab cl pi pj hx pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="im in io ip iq"><p id="8702" class="pw-post-body-paragraph la lb it lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="lc iu">参考资料和更多资源:</strong></p><ul class=""><li id="0e19" class="nl nm it lc b ld le lh li ll nn lp no lt np lx nq nr ns nt bi translated">Github，读取文件回购:<a class="ae mh" href="https://github.com/paigen11/file-read-challenge" rel="noopener ugc nofollow" target="_blank">https://github.com/paigen11/file-read-challenge</a></li><li id="42db" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">Node.js文档，文件系统:<a class="ae mh" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/fs.html</a></li><li id="ce08" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">Node.js文档，控制台。时间:<a class="ae mh" href="https://nodejs.org/api/console.html#console_console_time_label" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/API/console . html # console _ console _ time _ label</a></li><li id="b9b3" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">现在的表现:<a class="ae mh" href="https://www.npmjs.com/package/performance-now" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/performance-now</a></li><li id="a687" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">https://www.npmjs.com/package/event-stream</li><li id="dce6" class="nl nm it lc b ld nu lh nv ll nw lp nx lt ny lx nq nr ns nt bi translated">外汇券数据链接:<a class="ae mh" href="https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip" rel="noopener ugc nofollow" target="_blank">https://www.fec.gov/files/bulk-downloads/2018/indiv18.zip</a></li></ul></div></div>    
</body>
</html>