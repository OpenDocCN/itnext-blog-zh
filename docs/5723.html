<html>
<head>
<title>Rate limiting with MARIN3R Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MARIN3R算子的速率限制</h1>
<blockquote>原文：<a href="https://itnext.io/rate-limiting-with-marin3r-operator-5112858871be?source=collection_archive---------7-----------------------#2021-05-10">https://itnext.io/rate-limiting-with-marin3r-operator-5112858871be?source=collection_archive---------7-----------------------#2021-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/73029142d3abc7af48cfb5fd03df2f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COkyB0OPb8FnxNGkFP8q-w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.dw.com/en/germans-at-loggerheads-over-autobahn-speed-limits/a-47253578" rel="noopener ugc nofollow" target="_blank">https://www . dw . com/en/Germans-at-logger-over-autobahn-speed-limits/a-47253578</a></figcaption></figure><p id="9644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我在做一个项目，其中一个需求是对传入请求的数量进行更多的控制，以保护服务免受攻击，并防止资源过载并最终崩溃。对此的解决方案是对系统中的关键服务进行速率限制，以保护应用程序免受不必要的请求。</p><p id="39b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博客中，我将解释速率限制负责什么，为什么我们在应用程序中需要它，并讨论我们用来添加在OpenShift集群上运行的集中式速率限制服务的方法。</p><h2 id="9fbc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么是限速？</h2><p id="b157" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">速率限制是一种用于控制来自和来自网络的请求速率的技术，例如，如果您使用的API允许每分钟一定数量的请求，并且如果超过此限制，则一分钟内的任何其他请求都将被拒绝，并且会返回一个<em class="lz">429-太多请求错误</em>以响应请求。</p><p id="51a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于防止服务器达到其最大容量或防止像<a class="ae kc" href="https://www.paloaltonetworks.com/cyberpedia/what-is-a-denial-of-service-attack-dos" rel="noopener ugc nofollow" target="_blank"> DDoS </a>或任何恶意机器人活动的攻击是很重要的。因此，通过实施速率限制，我们可以确保服务不会因不需要的请求而过载，也不会消耗服务器上所有可用的资源。</p><p id="67ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以定义指标来监控当前正在处理或被阻塞的请求的数量，并调查是否需要扩展服务器中的资源，以便能够处理更多的请求。实现速率限制有几种方法，可以通过应用程序、web服务器、缓存等。我们将介绍如何通过代理请求并将其计入允许的请求总数来实现速率限制。</p><p id="ac6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">用MARIN3R运算符实现速率限制</strong></p><p id="1dce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让速率限制服务工作，我们首先需要控制来自网络的每个请求，为此，我们可以使用<a class="ae kc" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>作为代理服务器，在传入的请求到达应用程序服务之前拦截和响应它们。</p><p id="c6bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<a class="ae kc" href="https://github.com/3scale/marin3r" rel="noopener ugc nofollow" target="_blank"> MARIN3R操作符</a>来促进sidecar容器的部署，使Envoy运行并配置为首先接收请求，然后将它们转发到我们的应用程序容器，这听起来可能有点混乱，但我将在稍后演示它是如何工作的。MARIN3R允许我们通过向应用程序的部署对象添加注释和标签来定义哪些服务将具有注入的代理容器，并且我们可以通过创建EnvoyConfig CRDs来动态配置这些代理。</p><p id="8bec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了MARIN3R操作符，一个带有Redis数据库的envoy <a class="ae kc" href="https://github.com/envoyproxy/ratelimit" rel="noopener ugc nofollow" target="_blank">全局速率限制服务</a>将被部署到我们的集群，以控制和存储处理和拒绝的请求总量。</p><p id="6d97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">总结</strong></p><p id="95d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用这些服务为我们的应用程序添加速率限制:</p><ul class=""><li id="4083" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">特使代理</li><li id="29e9" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">全球限速服务</li><li id="26e4" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">Redis数据库</li><li id="09ac" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">MARIN3R运算符</li></ul><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/4b63b648bb3f38bcb0394d3f2236e5c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*bYav9ERaMZw8xApu"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">显示服务将如何集成的图表</figcaption></figure><h2 id="53f5" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">演示</h2><p id="ce4e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在开始进行演示之前，请确保您可以访问以下内容:</p><ul class=""><li id="5be8" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">OpenShift或Kubernetes集群</li><li id="bcf5" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">开源代码库</li><li id="32ee" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><a class="ae kc" href="https://docs.openshift.com/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html#installing-openshift-cli" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> oc </em> </a>或<a class="ae kc" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> kubectl </em> </a> CLI</li></ul><p id="25cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个演示中，我将使用一个OpenShift集群，但是在Kubernetes集群上也可以这样做。</p><ul class=""><li id="455c" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">我们要做的第一件事是部署一个小的rest应用程序，它将与envoy代理容器一起运行，以限制传入请求的速率。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4d81" class="lb lc iq mu b gy my mz l na nb">## Create application namespace<br/>oc new-project rest-application<br/><br/>## Deploy the application<br/>cat &lt;&lt;'EOF' | kubectl apply -f -<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: httpbin<br/>  namespace: rest-application<br/>  labels:<br/>    app: httpbin<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: httpbin<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: httpbin<br/>    spec:<br/>      containers:<br/>        - name: httpbin<br/>          image: jsmadis/httpbin<br/>          ports:<br/>            - containerPort: 8080<br/>              protocol: TCP<br/>---<br/>kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: httpbin<br/>  namespace: rest-application<br/>  labels:<br/>    app: httpbin<br/>spec:<br/>  ports:<br/>    - name: 8080-tcp<br/>      protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080-tcp<br/>  selector:<br/>    app: httpbin<br/>EOF<br/><br/>## expose service<br/>oc expose svc/httpbin<br/><br/>## verify if application is running<br/>oc get pods<br/>NAME               READY   STATUS      RESTARTS   AGE<br/>httpbin-1-8tpdh    1/1     Running     0          53s<br/>httpbin-1-deploy   0/1     Completed   0          55s</span></pre><p id="8a8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的命令在集群上部署了一个REST API应用程序，您应该能够通过从其route对象获取主机来访问该应用程序:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b4fc" class="lb lc iq mu b gy my mz l na nb">$ oc get route httpbin -o json | jq .spec.host</span></pre><ul class=""><li id="7ce5" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">应用程序启动并运行后，将MARIN3R Operator克隆到本地计算机的一个文件夹中:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e0e5" class="lb lc iq mu b gy my mz l na nb">$ git clone https://github.com/3scale/marin3r.git</span></pre><ul class=""><li id="46a8" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">在集群上安装MARIN3R操作器，我将使用<a class="ae kc" href="https://github.com/operator-framework/operator-lifecycle-manager" rel="noopener ugc nofollow" target="_blank"> OLM </a>来安装操作器，但是如果OLM没有安装在您的集群上，同样可以使用<a class="ae kc" href="https://github.com/3scale-ops/marin3r#install-using-kustomize" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>来完成:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2c1d" class="lb lc iq mu b gy my mz l na nb">$ oc apply -f examples/quickstart/olm-install.yaml</span></pre><p id="782b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在集群<code class="fe nc nd ne mu b">Namespace</code>、<code class="fe nc nd ne mu b">CatalogSource</code>、<code class="fe nc nd ne mu b">OperatorGroup</code>和<code class="fe nc nd ne mu b">Subscription</code>上创建4个资源，以通过OLM触发MARIN3R的安装。</p><ul class=""><li id="03fe" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">等到所有MARIN3R服务都处于运行状态:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="38f5" class="lb lc iq mu b gy my mz l na nb">$ oc -n marin3r-system get pods | grep Running</span></pre><ul class=""><li id="93ec" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">我们将需要修补<code class="fe nc nd ne mu b">operatorgroup</code>资源，以将我们的REST API应用程序的名称空间添加到<code class="fe nc nd ne mu b">targedNamespace</code>列表中，这将允许MARIN3R监视我们的REST API名称空间中的资源:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="21c3" class="lb lc iq mu b gy my mz l na nb">$ oc patch operatorgroup marin3r-system -n marin3r-system --type json -p='[{"op": "add", "path": "/spec/targetNamespaces", "value": ["rest-application"]}]'</span></pre><ul class=""><li id="e835" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">为了动态注入Envoy sidecar容器，我们需要在运行应用程序的名称空间上部署发现服务，对于我们的示例，我们将在rest-application名称空间上创建发现服务:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f068" class="lb lc iq mu b gy my mz l na nb">cat &lt;&lt;'EOF' | kubectl apply -f -<br/>apiVersion: operator.marin3r.3scale.net/v1alpha1<br/>kind: DiscoveryService<br/>metadata:<br/>  name: discoveryservice<br/>  namespace: rest-application<br/>EOF</span></pre><ul class=""><li id="144e" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">将MARIN3R标签和注释添加到应用程序DeploymentConfig对象，这将激活特使边车容器到Pod规范的注入:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="698b" class="lb lc iq mu b gy my mz l na nb">$ oc patch deployment httpbin -n rest-application -p '{"spec":{"template":{"metadata":{"labels":{"marin3r.3scale.net/status":"enabled"}, "annotations": {"marin3r.3scale.net/node-id": "httpbin","marin3r.3scale.net/ports": "8080-tcp:8443"}}}}}'</span></pre><p id="0e1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该看到两个容器在我们的应用程序的pod中运行</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0c33" class="lb lc iq mu b gy my mz l na nb">oc get pods -l app=httpbin<br/>NAME              READY   STATUS    RESTARTS   AGE<br/>httpbin-3-c4mpz   2/2     Running   0          3m31s</span></pre><ul class=""><li id="04fb" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">我们需要配置envoy代理将任何传入的请求重定向到我们的应用程序，当我们将标签<code class="fe nc nd ne mu b">marin3r.3scale.net/ports</code>添加到<code class="fe nc nd ne mu b">8080-tcp:8443</code>时，我们说来自服务端口<code class="fe nc nd ne mu b">8080-tcp</code>的任何请求都将被重定向到端口<code class="fe nc nd ne mu b">8443</code>，Envoy配置将监听<code class="fe nc nd ne mu b">8443</code>端口，如下所示:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a47f" class="lb lc iq mu b gy my mz l na nb">cat &lt;&lt;'EOF' | kubectl apply -f -<br/>apiVersion: marin3r.3scale.net/v1alpha1<br/>kind: EnvoyConfig<br/>metadata:<br/>  name: httpbin<br/>spec:<br/>  nodeID: httpbin<br/>  serialization: yaml<br/>  envoyResources:<br/>    clusters:<br/>      - name: httpbin<br/>        value: |<br/>          name: httpbin<br/>          connect_timeout: 2s<br/>          type: STRICT_DNS<br/>          lb_policy: ROUND_ROBIN<br/>          load_assignment:<br/>            cluster_name: httpbin<br/>            endpoints:<br/>              - lb_endpoints:<br/>                  - endpoint:<br/>                      address:<br/>                        socket_address:<br/>                          address: 127.0.0.1<br/>                          port_value: 8080<br/>    listeners:<br/>      - name: http<br/>        value: |<br/>          name: http<br/>          address:<br/>            socket_address:<br/>              address: 0.0.0.0<br/>              port_value: 8443<br/>          filter_chains:<br/>            - filters:<br/>              - name: envoy.http_connection_manager<br/>                typed_config:<br/>                  "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager<br/>                  stat_prefix: ingress_http<br/>                  route_config:<br/>                    name: local_route<br/>                    virtual_hosts:<br/>                      - name: httpbin<br/>                        domains: ["*"]<br/>                        routes:<br/>                          - match:<br/>                              prefix: "/"<br/>                            route:<br/>                              cluster: httpbin<br/>                  http_filters:<br/>                    - name: envoy.router<br/>EOF</span></pre><p id="dc09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们卷曲我们的应用程序端点，我们将看到一个特使头被添加到响应中，这意味着请求被代理:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4ced" class="lb lc iq mu b gy my mz l na nb">$ curl -I "http://$(oc get route httpbin -o json | jq -r .spec.host)"</span></pre><ul class=""><li id="3d60" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">创建一个配置图来定义我们将如何限制请求，您可以在此处了解更多信息<a class="ae kc" href="https://github.com/envoyproxy/ratelimit#configuration" rel="noopener ugc nofollow" target="_blank"/>:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4077" class="lb lc iq mu b gy my mz l na nb">cat &lt;&lt;'EOF' | oc apply -f -<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: ratelimit-config<br/>  namespace: marin3r-system<br/>  labels:<br/>    app: ratelimit<br/>data:<br/>  kuard.yaml: |<br/>    domain: httpbin<br/>    descriptors:<br/>      - key: generic_key<br/>        value: slowpath<br/>        rate_limit:<br/>          unit: minute<br/>          requests_per_unit: 1<br/>EOF</span></pre><p id="54f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lz">在这个例子中，我们定义每分钟只允许一个请求发送到我们的应用程序的路由</em></p><ul class=""><li id="c416" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">部署Redis数据库，您可以在这里找到更多关于如何配置Redis的信息:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="5af1" class="lb lc iq mu b gy my mz l na nb">cat &lt;&lt;'EOF' | oc apply -f -<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: redis<br/>  namespace: marin3r-system<br/>  labels:<br/>    app: redis<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: redis<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: redis<br/>    spec:<br/>      containers:<br/>        - name: redis<br/>          image: redis:alpine<br/>          ports:<br/>            - containerPort: 6379<br/>              name: redis<br/>              protocol: TCP<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: redis-service<br/>    namespace: marin3r-system<br/>  labels:<br/>    app: redis<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>    - name: envoy-https<br/>      port: 6379<br/>      targetPort: 6379<br/>  selector:<br/>    app: redis<br/>EOF</span></pre><ul class=""><li id="ed35" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">将速率限制应用程序部署到群集上:</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="e532" class="lb lc iq mu b gy my mz l na nb">cat &lt;&lt;'EOF' | oc apply -f -<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: ratelimit<br/>  name: ratelimit<br/>  namespace: marin3r-system<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: ratelimit<br/>  strategy:<br/>    type: Recreate<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: ratelimit<br/>    spec:<br/>      containers:<br/>        - name: ratelimit<br/>          image: envoyproxy/ratelimit:v1.4.0<br/>          command: ["ratelimit"]<br/>          env:<br/>            # - name: LOG_LEVEL<br/>            #   value: debug<br/>            - name: REDIS_SOCKET_TYPE<br/>              value: tcp<br/>            - name: REDIS_URL<br/>              value: redis-service.marin3r-system.svc.cluster.local:6379<br/>            - name: USE_STATSD<br/>              value: "false"<br/>            - name: RUNIME_ROOT<br/>              value: /srv/runtime_data/current<br/>            - name: RUNTIME_SUBDIRECTORY<br/>              value: "/"<br/>            - name: RUNTIME_IGNOREDOTFILES<br/>              value: "true"<br/>          ports:<br/>            - name: http<br/>              containerPort: 8080<br/>            - name: grpc<br/>              containerPort: 8081<br/>            - name: debug<br/>              containerPort: 6070<br/>          resources: {}<br/>          volumeMounts:<br/>            - mountPath: /srv/runtime_data/current/config<br/>              name: runtime-config<br/>      volumes:<br/>        - name: runtime-config<br/>          configMap:<br/>            name: ratelimit-config<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: ratilimit-service<br/>  namespace: marin3r-system<br/>  labels:<br/>    app: ratelimit<br/>spec:<br/>  type: ClusterIP<br/>  ports:<br/>    - name: ratelimit-8080<br/>      port: 8080<br/>      targetPort: 8080<br/>    - name: ratelimit-8081<br/>      port: 8081<br/>      targetPort: 8081<br/>    - name: ratelimit-6070<br/>      port: 6070<br/>      targetPort: 6070<br/>  selector:<br/>    app: ratelimit<br/>EOF</span></pre><p id="8a59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lz">注意，</em> <code class="fe nc nd ne mu b">REDIS_URL</code> <em class="lz"> env变量接收Redis服务地址，以允许速率限制应用程序连接到数据库。</em></p><ul class=""><li id="c6c9" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">我们需要编辑EnvoyConfig CR来定义速率限制配置，这里我们对REST API应用程序的任何传入请求进行速率限制。</li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2867" class="lb lc iq mu b gy my mz l na nb">cat &lt;&lt;'EOF' | kubectl apply -f -<br/>apiVersion: marin3r.3scale.net/v1alpha1<br/>kind: EnvoyConfig<br/>metadata:<br/>  name: httpbin<br/>  namespace: rest-application<br/>spec:<br/>  nodeID: httpbin<br/>  serialization: yaml<br/>  envoyResources:<br/>    clusters:<br/>      - name: httpbin<br/>        value: |<br/>          name: httpbin<br/>          connect_timeout: 2s<br/>          type: STRICT_DNS<br/>          lb_policy: ROUND_ROBIN<br/>          load_assignment:<br/>            cluster_name: httpbin<br/>            endpoints:<br/>              - lb_endpoints:<br/>                  - endpoint:<br/>                      address:<br/>                        socket_address:<br/>                          address: 127.0.0.1<br/>                          port_value: 8080<br/>      - name: ratelimit<br/>        value: |<br/>          name: ratelimit<br/>          type: STRICT_DNS<br/>          connect_timeout: 2s<br/>          lb_policy: ROUND_ROBIN<br/>          http2_protocol_options: {}<br/>          load_assignment:<br/>            cluster_name: ratelimit<br/>            endpoints:<br/>              - lb_endpoints:<br/>                - endpoint:<br/>                    address:<br/>                      socket_address: { address: ratilimit-service.marin3r-system.svc.cluster.local, port_value: 8081 }<br/>    listeners:<br/>      - name: http<br/>        value: |<br/>          name: http<br/>          address:<br/>            socket_address:<br/>              address: 0.0.0.0<br/>              port_value: 8443<br/>          filter_chains:<br/>            - filters:<br/>              - name: envoy.http_connection_manager<br/>                typed_config:<br/>                  "@type": type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager<br/>                  stat_prefix: ingress_http<br/>                  route_config:<br/>                    name: local_route<br/>                    virtual_hosts:<br/>                      - name: httpbin<br/>                        domains: ["*"]<br/>                        routes:<br/>                          - match:<br/>                              prefix: "/"<br/>                            route:<br/>                              cluster: httpbin<br/>                              rate_limits:<br/>                                - stage: 0<br/>                                  actions:<br/>                                    - {generic_key: {"descriptor_value": "slowpath"}}<br/>                  http_filters:<br/>                    - name: envoy.rate_limit<br/>                      config:<br/>                        domain: httpbin<br/>                        stage: 0<br/>                        rate_limit_service:<br/>                          grpc_service:<br/>                            envoy_grpc:<br/>                              cluster_name: ratelimit<br/>                            timeout: 2s<br/>                    - name: envoy.router<br/>EOF</span></pre><ul class=""><li id="b093" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">如果我们在一分钟的时间间隔内多次卷曲REST API应用程序主机，我们将得到一个响应<code class="fe nc nd ne mu b">429 - Too many request</code></li></ul><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4b3a" class="lb lc iq mu b gy my mz l na nb">for i in {1..3}; do curl -I "http://$(oc get route httpbin -o json | jq  -r .spec.host)"; done;</span></pre><h1 id="8c24" class="nf lc iq bd ld ng nh ni lg nj nk nl lj nm nn no lm np nq nr lp ns nt nu ls nv bi translated">结论</h1><p id="570c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">最后，我想提一下给应用程序添加速率限制的重要性，这不仅是为了保护它们免受攻击，也是为了防止资源因不需要的请求而过载。</p><p id="c85c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Envoy是一个真正强大的可定制代理服务，允许您满足您的应用程序可能需要的任何潜在要求，包括对其路由的速率限制，并利用MARIN3R Operator部署和动态设置任何定义的配置，将消除维护您的服务保护所需的任何额外工作。</p></div></div>    
</body>
</html>