<html>
<head>
<title>Introducing Spin, a universal feedback loop system in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift的通用反馈回路系统Spin简介</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-spin-9a48de9680d6?source=collection_archive---------1-----------------------#2020-03-26">https://itnext.io/introducing-spin-9a48de9680d6?source=collection_archive---------1-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/12377a852248baaf736c3712fc72c0d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R54mKscpxQI3wwR9LI4vjQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">杰里米·帕金斯在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="b9a4" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">swift应用中对架构模式的需求</h1><p id="3123" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">随着最近<a class="ae kf" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">联合</a>和<a class="ae kf" href="https://developer.apple.com/tutorials/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>的引入，我们的代码库将面临一些过渡期。我们的应用程序将同时使用Combine和第三方反应式框架，或者同时使用UIKit/AppKit和SwiftUI。这使得随着时间的推移很难保证一致的架构。很难知道这些新技术何时会被纳入我们的项目。从一开始就选择正确的架构可能会极大地简化未来的过渡。</p><p id="3ba8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">像<a class="ae kf" href="https://en.wikipedia.org/wiki/Model–view–controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Model–view–presenter" rel="noopener ugc nofollow" target="_blank"> MVP </a>或<a class="ae kf" href="https://en.wikipedia.org/wiki/Model–view–viewmodel" rel="noopener ugc nofollow" target="_blank"> MVVM </a>这样的传统架构模式主要负责UI层。当要在你的应用中以统一的方式混合上述技术时，它们不会有很大的帮助。例如，UIKit应用程序中的MVVM将在很大程度上依赖于带有反应式扩展的双向绑定技术，如RxCocoa或ReactiveCocoa。随着您逐渐引入SwiftUI和Combine，这将变得不那么真实。很有可能你的应用程序中会有几个架构范例。</p><p id="eacc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://www.objc.io/issues/13-architecture/viper/" rel="noopener ugc nofollow" target="_blank"> VIPER </a>稍微完整一点，因为它描述了场景之间的路由机制以及模型(实体)和管理它们的业务规则(交互器)之间的分离。这种模式加强了<a class="ae kf" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净架构</a>关于关注点分离和依赖性管理的原则。但是，和MVxx模式一样，当逐渐采用Combine或SwiftUI时，它不能保证语法和范式的一致性。</p><p id="fa93" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">SwiftUI是关于状态作为真理的单一来源，并对状态突变做出反应。这允许以声明的方式编写视图，而不是以冗长且容易出错的命令式方式。</p><p id="e824" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">近年来，出现了几种围绕状态概念的架构模式:如<a class="ae kf" href="https://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Redux </a>或MVI，以及更普遍的单向数据流架构。有时他们提出以中央方式管理国家，有时以地方方式。这些都是很好的模式，它们非常符合国家是真理的唯一来源的观点。我很确定他们对SwiftUI的制作有很大的影响。</p><p id="2b60" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我自己已经在生产应用程序中实现了其中的一些模式。他们向我介绍了函数式编程，因为它们依赖于诸如不变性、纯函数、函数组合等概念。函数式编程和状态管理非常契合。函数式编程与数据不变性相关联，状态也应该如此。</p><p id="7178" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然而，我经历了这种架构的一些缺点，这使我发现了反馈回路系统。</p><h1 id="aeef" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是反馈回路系统？</h1><p id="4043" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">反馈回路是一个系统，它能够通过使用其计算的结果值作为自身的下一个输入来进行自我调节，根据给定的规则不断调整该值(反馈回路用于电子等领域，例如自动调整信号的电平)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/ddd9bec778b923f708efce6fd674d36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5TQ6S6aXqv8JnUHoL5hmQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">反馈回路图</figcaption></figure><p id="ef97" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">以这种方式陈述可能听起来晦涩难懂，与软件工程无关，<strong class="lg iu">但是</strong>“根据某些规则调整一个值”正是一个程序，进而一个应用程序，所要做的！应用程序是我们想要管理的各种状态的总和，以便提供遵循精确规则的一致行为。</p><p id="0035" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">描述从一个值到另一个值的允许转换的规则由状态机描述。</p><h2 id="1085" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated"><strong class="ak">什么是国家机器？</strong></h2><blockquote class="my mz na"><p id="6062" class="le lf nb lg b lh mc lj lk ll md ln lo nc me lr ls nd mf lv lw ne mg lz ma mb im bi translated">它是一台抽象的机器，在任何给定的时间都可以处于有限数量的状态中的一种。状态机可以响应一些外部输入从一种状态改变到另一种状态。从一种状态到另一种状态的变化称为过渡。状态机由其状态列表、初始状态和每次转换的条件来定义。</p></blockquote><p id="e874" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因为应用程序是一个状态机，所以它可以由一个反馈回路系统来驱动。</p><p id="0709" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">反馈回路基于三个组件:初始状态、反馈和缩减器。为了说明它们中的每一个，我们将依靠一个基本的例子:一个从0数到10的系统。</p><ul class=""><li id="f7b2" class="nf ng it lg b lh mc ll md lp nh lt ni lx nj mb nk nl nm nn bi translated"><strong class="lg iu">初始状态</strong>:这是我们计数器的初始值，0。</li><li id="02c1" class="nf ng it lg b lh no ll np lp nq lt nr lx ns mb nk nl nm nn bi translated"><strong class="lg iu"> A feedback </strong>:这是我们应用于计数器的规则，以达到我们的目的。反馈的输出是改变计数器的请求。如果0 &lt; =计数器&lt; 10，那么我们要求增加它，否则我们要求停止它。</li><li id="9758" class="nf ng it lg b lh no ll np lp nq lt nr lx ns mb nk nl nm nn bi translated"><strong class="lg iu">一个减速器</strong>:这是我们系统的状态机。它描述了在给定计数器先前的值和反馈计算出的请求的情况下，计数器所有可能的转换。例如:如果先前的值是0，并且请求增加它，那么新的值是1；如果先前的值是1，并且请求增加它，那么新值是2；诸如此类。当来自反馈的请求是停止时，则先前的值作为新值返回。</li></ul><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/9c856eeb5b51f7124ee3f8ab6406ae44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qvRBFGNoDJJMbtmpq_nKg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从0数到10的反馈回路</figcaption></figure><p id="3721" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">反馈是<strong class="lg iu">唯一可以产生副作用的地方</strong>(联网、本地I/O、UI渲染，无论你做什么都可以访问或改变循环本地范围之外的状态)。相反，reducer是一个纯粹的函数，它只能在给定前一个值和转换请求的情况下产生一个新值。禁止在还原剂中产生副作用，因为这会影响其重现性。</p><h1 id="3f17" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">传统单向数据流架构的缺点</h1><p id="1ee2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如你所看到的，反馈循环范式的特殊性在于状态既是输入又是输出，两者连接成一个整体形成一个单向循环。只要循环还在运行，我们就可以使用状态作为本地缓存来保存数据。</p><p id="df02" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">典型的用例是浏览分页API。这种类型的系统允许使用当前状态来总是使前一页面URL和下一页面URL可访问，这使得将它存储在其他地方的需要变得无关紧要。</p><p id="a966" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在更传统的单向数据流架构中，状态只是系统的输出。输入是“用户意图”,它触发副作用和状态突变。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/13bac85dd980c5ead19cabdbbf6cc20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQbn8G3MdH4RwT4HdWoZYw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">单向数据流</figcaption></figure><p id="5ad4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我经历过这种架构的几个版本(Redux和MVI ),发现自己陷入了两个主要问题:</p><ul class=""><li id="b0ce" class="nf ng it lg b lh mc ll md lp nh lt ni lx nj mb nk nl nm nn bi translated">不将状态作为输入会导致在UI层或缓存存储库中维护本地状态。</li><li id="38cd" class="nf ng it lg b lh no ll np lp nq lt nr lx ns mb nk nl nm nn bi translated">依赖于输入，如意图或动作，这通常是枚举，迫使我们用“切换”语句来解析它们，以确定要执行的副作用。当我们添加新的意图或新的动作时，我们必须改变我们解析它们的方式，违背了固定规则的开/关原则。</li></ul><p id="9041" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我并不是说这些问题是使用这些架构的“禁忌”,也不是说我已经以最好的方式使用了它们。例如，我曾经做过MVI的一个变种，其中意图被“命令模式”所取代。每个命令负责自己的副作用执行。没有解析，命令是独立的。这种方法符合打开/关闭原则，因为添加新功能就是添加要执行的新命令；并且不修改解析意图或动作的方式。</p><p id="23bb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但是，与其扭曲这些架构来满足我的需求，我更倾向于自然解决这些问题的方法:反馈循环系统。</p><h1 id="9443" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是旋转？</h1><p id="738c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们回到我们的主要关注点:提供一个架构模式，它可以吸收我们在应用程序中可以预期的技术差异。</p><p id="e6c3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">正如我们所见，反馈循环是一种非常通用的模式。这将有助于我们缓解混合技术带来的问题。但是我们需要一种方法来以统一的方式声明反馈循环，而不管底层的反应式框架或选择的UI技术。这就是旋转发挥作用的地方。</p><p id="8d27" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/Spinners/Spin.Swift" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Spin </strong> </a> <strong class="lg iu">是一个在基于Swift的应用程序中构建反馈循环的工具，允许您使用统一的语法，而不管底层反应式编程框架和您使用的任何Apple UI技术(RxSwift、ReactiveSwift、Combine和UIKit、AppKit、SwiftUI)。</strong></p><p id="8bb7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们通过构建一个调节两个整数使它们收敛到它们的平均值的系统来尝试<strong class="lg iu">旋转</strong>(就像某种系统会调节立体声扬声器上的左右声道使它们收敛到相同的水平)。</p><p id="667a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们需要州的数据类型:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="573b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们还需要一种数据类型来描述要在级别上执行的转换:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7f37" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">为了描述控制转换的状态机，我们需要一个reducer函数:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="2d00" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">到目前为止，代码没有与特定的反应式框架相关，这很好。</p><p id="188c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们写下将对每个级别产生影响的两个反馈。</p><p id="88b6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用RxSwift:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d314" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">带电抗Swift:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9e17" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">使用联合收割机:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1922" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">无论您选择哪种反应式技术，编写反馈回路(也称为<strong class="lg iu">旋转</strong>)就这么简单:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c7fa" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">就是这样。你可以在应用的一部分使用RxSwift，在另一部分结合使用，所有的反馈循环将使用相同的语法。</p><p id="3a71" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">对于“类似DSL”的语法爱好者来说，有一种更具声明性的方式:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1956" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如何开始循环？</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="af0a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">混合反应式框架不再是一个问题👍。</p><h2 id="bf15" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">在UI透视图中使用Spin</h2><p id="cfdc" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">虽然反馈循环可以独立存在，没有任何可视化，但在我们的开发人员的世界中，将它作为一种产生将在屏幕上呈现的状态的方式和一种处理用户发出的事件的方式更有意义。</p><p id="505b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">幸运的是，将状态作为输入来呈现和返回来自用户交互的事件流看起来很像反馈的定义，我们知道如何处理反馈😁当然是旋转的。</p><p id="1249" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一旦<strong class="lg iu"> Spin </strong> /feedback循环建立起来，我们就可以用一个专门用于UI渲染/交互的新反馈来“装饰”它。存在一种特殊旋转类型来执行装饰:UISpin。</p><p id="d816" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">从全局来看，我们可以用下图说明UI环境中的反馈循环:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/1fb39a8945cbc325313b7893e1f31e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6andCCdHHFAY6tewijy8g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">UI使用环境中的旋转</figcaption></figure><p id="b856" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在ViewController中，假设您有一个呈现函数，如下所示:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1ce2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们需要用UISpin来修饰“业务”旋转(例如在“viewDidLoad”函数中)。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="72bb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在循环中发送事件非常简单；只需使用发射功能:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="d9d2" class="mm kh it bd ki mn mo dn km mp mq dp kq lp mr ms ku lt mt mu ky lx mv mw lc mx bi translated">SwiftUI呢？</h2><p id="ae2e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因为SwiftUI依赖于状态和视图之间绑定的思想，并负责呈现，所以连接SwiftUI Spin的方式略有不同，甚至更简单。</p><p id="b8f9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在您看来，您必须用“@ObservedObject”来注释SwiftUI Spin变量:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e0db" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">然后，您可以在视图中使用“uiSpin.state”属性来显示数据，并使用uiSpin.emit()来发送事件。由于SwiftUISpin也是一个“ObservableObject ”,每个状态突变都会触发视图渲染。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="44de" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">UIKit (AppKit)和SwiftUI使用UISpin的方式非常相似，允许您将以前为UIKit屏幕编写的反馈循环集成到新的SwiftUI组件中。</p><p id="5dd5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">混合UI范例不再是一个问题👍。</p><h1 id="14b4" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="c5bd" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们已经达到了我们的目标:提出一个架构模式实现，它可以简化即将到来的技术之间的转换。</p><p id="6b8c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在Spinners组织中，您可以找到两个演示应用程序，它们演示了Spin与RxSwift、ReactiveSwift和Combine的用法。</p><ul class=""><li id="9c3b" class="nf ng it lg b lh mc ll md lp nh lt ni lx nj mb nk nl nm nn bi translated">一个基本的柜台应用:<a class="ae kf" href="https://github.com/Spinners/Spin.UIKit.Demo.Basic" rel="noopener ugc nofollow" target="_blank"> UIKit版本</a>和<a class="ae kf" href="https://github.com/Spinners/Spin.SwiftUI.Demo.Basic" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>版本</li><li id="54c2" class="nf ng it lg b lh no ll np lp nq lt nr lx ns mb nk nl nm nn bi translated">使用依赖注入和协调器模式(UIKit)的更高级的“基于网络的”应用程序:<a class="ae kf" href="https://github.com/Spinners/Spin.UIKit.Demo" rel="noopener ugc nofollow" target="_blank"> UIKit版本</a>和<a class="ae kf" href="https://github.com/Spinners/Spin.SwiftUI.Demo" rel="noopener ugc nofollow" target="_blank"> SwiftUI版本</a></li></ul><p id="9ab1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/Spinners/Spin.Swift" rel="noopener ugc nofollow" target="_blank">还有旋转。快速回购</a>。公关当然是受欢迎的(⭐️也是😏).</p><p id="f418" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我计划开发一个Kotlin实现，兼容RxJava和Flow(任何帮助将不胜感激)。</p><p id="0cb1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我希望你喜欢这篇文章。请随意留下评论，这样我们就可以交流了。</p></div></div>    
</body>
</html>