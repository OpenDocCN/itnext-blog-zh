<html>
<head>
<title>C++20 Ranges — Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20系列—完整指南</h1>
<blockquote>原文：<a href="https://itnext.io/c-20-ranges-complete-guide-4d26e3511db0?source=collection_archive---------0-----------------------#2021-11-03">https://itnext.io/c-20-ranges-complete-guide-4d26e3511db0?source=collection_archive---------0-----------------------#2021-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C++20 Ranges，也称为STL v2，有效地取代了现有的STL算法和工具。在本文中，我将引导您了解范围引入的变化，讨论视图，这是一种新的可组合算法方法，并展示使用三种不同方法的FizzBuzz示例，所有方法都利用了范围的某些方面。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f01350c0da9b54c5ca04927c0c76ec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGGu_byOwewmRK2oBnXBnA.png"/></div></div></figure><p id="3c0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，请注意，范围是C++20中尚未成熟的特性之一。C++23应该让我们更接近全面的支持。因此，一些示例将使用<a class="ae kx" href="https://github.com/ericniebler/range-v3" rel="noopener ugc nofollow" target="_blank"> range v3库</a>。</p><h1 id="7962" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">范围与旧STL</h1><p id="b6a3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如前所述，范围是STL的替代物。然而，它们引入了内部和面向用户的变化，总体上提高了它们的有用性。</p><h2 id="2b1d" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">概念</h2><p id="ef32" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">范围依赖于概念来指定什么类型的参数可以参与每个重载。因此，在使用范围时出错会导致更短、更切题的错误消息。</p><p id="61ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个典型的例子是尝试对std::list进行排序。不幸的是，如果你是C++新手，这是一个容易犯的错误。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="853f" class="mb kz iq mo b gy ms mt l mu mv">#include &lt;iostream&gt;<br/>#include &lt;ranges&gt;<br/>#include &lt;list&gt;<br/>#include &lt;algorithm&gt;</span><span id="6f3f" class="mb kz iq mo b gy mw mt l mu mv">int main() {<br/>    std::list&lt;int&gt; dt = {1, 4, 2, 3};<br/>    std::ranges::sort(dt.begin(), dt.end());<br/>    std::ranges::copy(dt.begin(), dt.end(), <br/>        std::ostream_iterator&lt;int&gt;(std::cout, ","));<br/>}</span></pre><p id="d0e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在得到的是第一个错误，而不是关于减号运算符的令人困惑的错误:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="2c01" class="mb kz iq mo b gy ms mt l mu mv">include/c++/12.0.0/bits/ranges_algo.h:1810:14: <strong class="mo ir">note: because 'std::_List_iterator&lt;int&gt;' does not satisfy 'random_access_iterator'</strong></span></pre><p id="1ff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以检查范围库定义的概念，因为这些是标准的一部分。例如，范围的<a class="ae kx" href="https://en.cppreference.com/w/cpp/ranges/range" rel="noopener ugc nofollow" target="_blank">概念非常简单，它仅仅要求表达式<code class="fe mx my mz mo b">std::ranges::begin(rng)</code>和<code class="fe mx my mz mo b">std::ranges::end(rng)</code>有效。如果你想了解概念，请查看我的概念指南。</a></p><p id="931f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的根本变化是<code class="fe mx my mz mo b">end()</code>不再需要返回与<code class="fe mx my mz mo b">begin()</code>相同的类型。返回的sentinel只需要和<code class="fe mx my mz mo b">begin()</code>返回的迭代器类型相当即可。</p><p id="894a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了简化某些用例，它还允许无限的范围和潜在的性能改进。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="d4d5" class="mb kz iq mo b gy ms mt l mu mv">std::vector&lt;int&gt; dt = { 1, 2, 3, 4, 5, 6, 7, 8, 9};<br/>std::ranges::shuffle(dt, std::mt19937(std::random_device()()));<br/>auto pos = std::ranges::find(dt.begin(), <br/>                             std::unreachable_sentinel,<br/>                             7);<br/>std::ranges::copy(dt.begin(), ++pos, <br/>                  std::ostream_iterator&lt;int&gt;(std::cout, ","));</span></pre><p id="4194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与迭代器相比，<code class="fe mx my mz mo b">std::unreachable_sentinel</code>总是返回false。编译器因此将优化掉边界检查<code class="fe mx my mz mo b">it != end</code>,因为该表达式始终为真。</p><p id="df4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当我们有上下文保证算法将终止而不越界时，我们才能使用这种技巧，但它使算法与手写代码不相上下。</p><p id="3c86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，随着范围概念的引入，我们也可以节省编写和使用接受算法变体的范围。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="11fe" class="mb kz iq mo b gy ms mt l mu mv">std::vector&lt;int&gt; dt = {1, 4, 2, 3};<br/>std::ranges::sort(dt);</span></pre><h2 id="0650" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">预测</h2><p id="e891" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一个表面上看起来微不足道的巨大新特性是对投影的支持。投影是应用于每个元素的一元可调用对象。</p><p id="8a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这通常完全消除了编写复杂的lambdas的需要，如果不这样做，就会大大简化它们。invocable是callable的扩展，也接受成员指针。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="65ed" class="mb kz iq mo b gy ms mt l mu mv">struct Account {<br/>    std::string owner;<br/>    double value();<br/>    double base();<br/>};</span><span id="0a43" class="mb kz iq mo b gy mw mt l mu mv">std::vector&lt;Account&gt; acc = get_accounts();<br/>// member<br/>std::ranges::sort(acc,{},&amp;Account::owner);<br/>// member function<br/>std::ranges::sort(acc,{},&amp;Account::value);<br/>// lambda<br/>std::ranges::sort(acc,{},[](const auto&amp; a) { <br/>    return a.value()+a.base(); <br/>});</span></pre><p id="8cbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有投影，我们将不得不把这个逻辑作为定制比较器的一部分。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="3f32" class="mb kz iq mo b gy ms mt l mu mv">std::vector&lt;int&gt; dt = { 1, 2, 3, 4, 5, 6, 7, 8, 9};<br/>std::vector&lt;int&gt; result;</span><span id="3f71" class="mb kz iq mo b gy mw mt l mu mv">std::ranges::transform(dt, <br/>                       dt | std::views::reverse,<br/>                       std::back_inserter(result),<br/>                       std::minus&lt;void&gt;(),<br/>                       [](int v) { return v*v; },<br/>                       [](int v) { return v*v; });</span><span id="e5cc" class="mb kz iq mo b gy mw mt l mu mv">std::ranges::copy(result, <br/>                  std::ostream_iterator&lt;int&gt;(std::cout, ","));</span></pre><p id="b933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于视图来说是一个小小的铺垫，但是我想包含另一个使用两个范围作为输入的例子。在这种情况下，我们得到两个独立的投影。注意，这些投影也可以返回不同的返回类型，只要它们与操作匹配(这里是<code class="fe mx my mz mo b">std::minus</code>)。</p><h2 id="472c" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">小事情</h2><p id="e016" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我想在这里提到的最后一个“小”特性是防止悬空迭代器。主要是因为即使你不在乎，你也可能在你的代码库中找到这种特殊模式的用例。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="1b8f" class="mb kz iq mo b gy ms mt l mu mv">auto good = "1234567890";<br/>auto sep1 = std::ranges::find(std::string_view(good), '0');<br/>std::cout &lt;&lt; *sep1 &lt;&lt; "\n";</span><span id="6bf1" class="mb kz iq mo b gy mw mt l mu mv">auto bad = 1234567890;<br/>auto sep2 = std::ranges::find(std::to_string(bad), '0');<br/>std::cout &lt;&lt; *sep2 &lt;&lt; "\n";</span></pre><p id="b0eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会意识到这里的问题。如果我们不使用算法的范围变体,“坏的”变体会在运行时崩溃。但是，对于范围，此代码将无法编译。当使用拥有其元素的临时范围调用基于范围的算法时，该算法将返回一个特殊的迭代器<code class="fe mx my mz mo b">std::ranges::dangling</code>。</p><p id="bb34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，带有<code class="fe mx my mz mo b">std::string_view</code>的第一个变体仍然可以正常工作。String view是一种不拥有其元素的范围，它的迭代器是独立的(它们不依赖于<code class="fe mx my mz mo b">string_view</code>的实例)，所以将这样的临时变量传递给基于范围的算法是完全有效的。</p><p id="693e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要选择你的范围作为临时变量，你需要专门化<code class="fe mx my mz mo b">enable_borrowed_range</code>常量:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="e6c5" class="mb kz iq mo b gy ms mt l mu mv">template&lt;typename T&gt;<br/>inline constexpr bool <br/>    std::ranges::enable_borrowed_range&lt;MyView&lt;T&gt;&gt; = true;</span></pre><h1 id="8827" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">可组合视图</h1><p id="f1c8" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">旧的STL算法的一个核心问题是它们不容易组合。因此，使用算法的代码通常非常冗长，并且在处理不可变数据时，需要额外的副本。</p><p id="fe47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Views正试图解决这个问题，使依赖于标准算法的代码不那么冗长，更加明确。</p><h2 id="88fd" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">视图</h2><p id="94cc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">视图仅仅是复制和移动(在恒定时间内)成本低廉的范围。因此，视图不能拥有它正在查看的元素。一个例外是<code class="fe mx my mz mo b">std::views::single</code>，它拥有正在查看的单个元素。</p><p id="d54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视图在编译时组成，期望编译器将内联代码。</p><p id="a518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，下面的代码将打印出该范围的最后三个元素。我们首先反转范围，然后取前三个元素，最后再次反转范围(注意有<code class="fe mx my mz mo b">std::views::drop</code>直接做这个)。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="1e22" class="mb kz iq mo b gy ms mt l mu mv">namespace rv = std::ranges::views;<br/>std::vector&lt;int&gt; dt = {1, 2, 3, 4, 5, 6, 7};<br/>for (int v : rv::reverse(rv::take(rv::reverse(dt),3))) {<br/>    std::cout &lt;&lt; v &lt;&lt; ", ";<br/>}<br/>std::cout &lt;&lt; "\n";</span></pre><h2 id="a732" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">查看闭包对象</h2><p id="8645" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">由于嵌套通常很深，编写和阅读组合视图的函数语法可能会很麻烦。</p><p id="fade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，范围给我们带来了另一种合成视图的方法。名称空间中的视图实际上是视图闭包对象。这些是内联constexpr常量，每个<code class="fe mx my mz mo b">std::ranges::xxx_view</code>映射到一个<code class="fe mx my mz mo b">std::views::xxx</code>对象。这些对象重载了函数语法的<code class="fe mx my mz mo b">operator()</code>，重载了管道风格合成的<code class="fe mx my mz mo b">operator|</code>。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="f0df" class="mb kz iq mo b gy ms mt l mu mv">namespace rv = std::ranges::views;<br/>std::vector&lt;int&gt; dt = {1, 2, 3, 4, 5, 6, 7};</span><span id="dad2" class="mb kz iq mo b gy mw mt l mu mv">for (int v : dt | rv::reverse | rv::take(3) | rv::reverse) {<br/>    std::cout &lt;&lt; v &lt;&lt; ", ";<br/>}<br/>std::cout &lt;&lt; "\n";</span></pre><p id="069c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，虽然视图不拥有它们的元素，但是它们不会改变底层数据的可变性。在这里，我们迭代数组的奇数元素，并将它们乘以2。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="d5ed" class="mb kz iq mo b gy ms mt l mu mv">namespace rv = std::ranges::views;<br/>std::vector&lt;int&gt; dt = {1, 2, 3, 4, 5, 6, 7};</span><span id="8ef1" class="mb kz iq mo b gy mw mt l mu mv">auto odd = [](std::integral auto v) { return v % 2 == 1; };<br/>for (auto&amp; v : dt | rv::filter(odd)) {<br/>    v *= 2;<br/>}</span></pre><h1 id="77f1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">FizzBuzz三种方式</h1><p id="f056" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们来看一些具体的例子。我们将编写FizzBuzz的三个版本:</p><ul class=""><li id="7a0b" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">一种范围化协同程序生成器</li><li id="11cc" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">使用算法的生成方法</li><li id="5f48" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">使用视图的合成方法</li></ul><p id="3c70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如文章开头提到的，目前C++20中的支持有点欠缺。所以我会依赖<a class="ae kx" href="https://github.com/ericniebler/range-v3" rel="noopener ugc nofollow" target="_blank"> range v3库</a>。</p><h2 id="a563" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">协同程序生成器</h2><p id="01dc" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">编写一个协程FizzBuzz生成器与典型的实现几乎相同:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="7c61" class="mb kz iq mo b gy ms mt l mu mv">ranges::experimental::generator&lt;std::string&gt; fizzbuzz() {<br/>    for (int i = 1; ; i++) {<br/>        std::string result;<br/>        if (i % 3 == 0) result += "Fizz";<br/>        if (i % 5 == 0) result += "Buzz";<br/>        if (result.empty()) co_yield std::to_string(i);<br/>        else co_yield result;<br/>    }<br/>}</span></pre><p id="7333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我们使用来自range v3库的<code class="fe mx my mz mo b">generator&lt;&gt;</code>，我们也可以使用调用的协程作为范围。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="183c" class="mb kz iq mo b gy ms mt l mu mv">for (auto s : fizzbuzz() | ranges::views::take(20)) {<br/>    std::cout &lt;&lt; s &lt;&lt; "\n";<br/>}</span></pre><p id="a0f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的主要魔力在于迭代器类型的实现(注意<a class="ae kx" href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle#Example" rel="noopener ugc nofollow" target="_blank">这段代码</a>不是来自range v3库)。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="eade" class="mb kz iq mo b gy ms mt l mu mv">// Resume coroutine to generate new value.<br/>void operator++() { <br/>    coro_.resume(); <br/>}</span><span id="2370" class="mb kz iq mo b gy mw mt l mu mv">// Grab current value from coroutine.<br/>const T&amp; operator*() const {<br/>    return *coro_.promise().current_value;<br/>}</span><span id="7a5c" class="mb kz iq mo b gy mw mt l mu mv">// We are at the end if the coroutine is finished.<br/>bool operator==(std::default_sentinel_t) const { <br/>    return !coro_ || coro_.done(); <br/>}</span></pre><p id="65aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz mo b">std::default_sentinel_t</code>是标准提供的一种便利类型，旨在用于区别与<code class="fe mx my mz mo b">end()</code>的比较。这样，我们只需要从<code class="fe mx my mz mo b">generator&lt;&gt;</code>返回类型中返回这个迭代器:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="c9c5" class="mb kz iq mo b gy ms mt l mu mv">Iter begin() {<br/>    if (coro_) {<br/>        coro_.resume();<br/>    } <br/>    return Iter{cor_};<br/>}</span><span id="54de" class="mb kz iq mo b gy mw mt l mu mv">std::default_sentinel_t end() { <br/>    return {}; <br/>}</span></pre><h2 id="a1bc" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">使用算法生成</h2><p id="23a6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于生成方法，我们有相当多的选择，最明显的是<code class="fe mx my mz mo b">generate_n</code>，它将允许我们直接生成输出。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="9ea1" class="mb kz iq mo b gy ms mt l mu mv">ranges::generate_n(<br/>    std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"), <br/>    20,<br/>    [i = 0]() mutable {<br/>        i++;<br/>        std::string result;<br/>        if (i % 3 == 0) result += "Fizz";<br/>        if (i % 5 == 0) result += "Buzz";<br/>        if (result.empty()) return std::to_string(i);<br/>        return result;<br/>});</span></pre><h2 id="50ab" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">使用视图合成</h2><p id="a8de" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">前面的两种方法非常相似。他们都在程序上实现了FizzBuzz。然而，我们也可以用完全不同的方式实现FizzBuzz。</p><p id="2d0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FizzBuzz包括两个周期。周期为3的嘶嘶声和周期为5的嗡嗡声。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="870a" class="mb kz iq mo b gy ms mt l mu mv">std::array&lt;std::string, 3&gt; fizz{"", "", "Fizz"};<br/>std::array&lt;std::string, 5&gt; buzz{"", "", "", "", "Buzz"};</span></pre><p id="2b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要将这些循环转化为无限的范围。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="3b12" class="mb kz iq mo b gy ms mt l mu mv">const auto inf_fizz = fizz | ranges::views::cycle;<br/>const auto inf_buzz = buzz | ranges::views::cycle;</span></pre><p id="9bf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以使用<code class="fe mx my mz mo b">zip_with</code>将它们组合起来:</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="1497" class="mb kz iq mo b gy ms mt l mu mv">const auto inf_fizzbuzz = ranges::views::zip_with(<br/>    std::plus&lt;&gt;(), <br/>    inf_fizz, <br/>    inf_buzz);</span></pre><p id="a64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个无限的范围，其中每个第三元素是“Fizz”，每个第五元素是“Buzz”，每个第十五元素是“FizzBuzz”，其余的是空字符串。</p><p id="ffe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们错过了既不是嗡嗡作响的元素的简单数字。因此，让我们构建一个无限范围的指数(从1开始):</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="96ee" class="mb kz iq mo b gy ms mt l mu mv">const auto indices = ranges::views::indices<br/>    | ranges::views::drop(1);</span></pre><p id="ef08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要将这两个范围放在一起并输出最终结果。</p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="eba0" class="mb kz iq mo b gy ms mt l mu mv">const auto final_range = ranges::views::zip_with(<br/>    [](auto i, auto s) { <br/>        if (s.empty()) return std::to_string(i); <br/>        return s;<br/>    },<br/>    indices,<br/>    inf_fizzbuzz<br/>);</span><span id="336a" class="mb kz iq mo b gy mw mt l mu mv">ranges::copy_n(ranges::begin(final_range), 20,<br/>    std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"));</span></pre><h1 id="b88a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="8b66" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">所有代码示例和脚本都可以在:<a class="ae kx" href="https://github.com/HappyCerberus/article-cpp20-ranges" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/article-cpp20-ranges</a>获得。</p><p id="afa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于FizzBuzz示例的range v3库可从https://github.com/ericniebler/range-v3<a class="ae kx" href="https://github.com/ericniebler/range-v3" rel="noopener ugc nofollow" target="_blank">的</a>获得。</p><h1 id="e716" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="52ea" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="e363" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在T4的YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>