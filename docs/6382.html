<html>
<head>
<title>ISBN Stacks — A look at a possible Spring Application implementation without annotations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ISBN栈——看看一个可能的不带注释的Spring应用程序实现</h1>
<blockquote>原文：<a href="https://itnext.io/isbn-stacks-a-look-at-a-possible-spring-application-implementation-without-annotations-ca1528591fe?source=collection_archive---------3-----------------------#2021-11-02">https://itnext.io/isbn-stacks-a-look-at-a-possible-spring-application-implementation-without-annotations-ca1528591fe?source=collection_archive---------3-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/00dd30b66d6e93447ce5548706e12b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0l8xhJTPtrmfElaziXEUg.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="0e8e" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi lg translated"><span class="l lh li lj bm lk ll lm ln lo di">如果</span>你是一个Spring框架的超级粉丝，我是说像我一样是Spring框架的超级粉丝，并且从来没有读过本文标题所描述的内容，那么你很可能仅仅是因为读了它就退缩了。没有注释？这听起来可能有点疯狂。当我取得春季认证时，它给了我成就感。我在那里通过了春季认证。但是认证路径的很大一部分恰恰是关于注释的使用。我必须学习各种注释。退一步说，还有不少。现在整个Spring框架是作为注释驱动的框架给我们的。我们可以用它做任何事情，从以编程方式改变bean启动的方式，如何创建bean，我们可以创建组件，服务，存储库，应用装饰器，IoC，适配器，MVC模式，我们可以为特定的异常创建触发器，事件处理程序，健康端点，我们可以以无缝的方式实现观察者模式，使用面向对象的AOP，实现批处理作业，使用WebSockets的STOMP模式，条件bean，使用反应式编程，我可以永远继续下去。我想说的是，多年来，我们一直受到教育和压力，要离开XML驱动的框架，直到Spring 2.5。从<a class="ae lp" href="https://www.dineshonjava.com/whats-new-in-spring-framework-4x/" rel="noopener ugc nofollow" target="_blank"> Spring 4 </a>开始，向一个完整的注释驱动的框架转移。最后，在<a class="ae lp" href="https://howtodoinjava.com/spring-5-tutorial/" rel="noopener ugc nofollow" target="_blank"> Spring 5 </a>中，我们通过<a class="ae lp" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目reactor </a>获得了对反应式实现的支持。</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lq"><img src="../Images/c853b422b259a831563ae2ff18e302d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yr5_4-92yDz1aO19oqdnQg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">闪电般的速度潜入Spring框架历史</figcaption></figure><p id="f91b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们已经了解了所有这些，同时我们有了Spring 5和Spring Boot 2.5.6。接下来，<a class="ae lp" href="https://github.com/spring-projects-experimental" rel="noopener ugc nofollow" target="_blank"> Spring实验项目</a>的一个团队正在开发一个全新版本的Spring，叫做Spring-Fu。福，就是功能性的意思。他们已经开发了两个分版本:甲府和甲府。Spring KoFu是基于Kotlin的DSL，Spring JaFu是基于Java的DSL。该项目已于2018年5月31日在GitHub上启动。鉴于Spring-Fu团队显然已经实现了更好的服务启动和更快的处理，目前有一些关于它的讨论。这篇文章是我对此事的研究，以寻找这些说法的迹象。所有结果和实现都可以在<a class="ae lp" href="https://github.com/jesperancinha/isbn-stacks" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="d817" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">1.我们试图寻找的是</h1><p id="82a2" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">我们将探索三个简单服务的响应。两个是反应性的，一个是非反应性的。一个是用春赋来实现的，也叫做春赋。另外两个以传统的MVC方式实现。一个是反应性的，另一个不是。</p><p id="532c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">反应式编程的最终目标是让服务更具弹性，并以最有效的方式使用资源，以便处理尽可能多的请求。它这样做的方式是将处理我们请求的责任交付给发布者。在Spring中，它们被称为Mono <t>和Flux <t>。对于快速处理，这导致服务高度可用，这意味着非反应式服务比反应式服务更快不可用。这是因为前一种情况下的响应是直接返回的，所以客户端必须等到请求被处理后，才能执行新的请求。然而，对于长时间处理请求，情况可能会有所不同。因为无论之前的请求是否被处理，响应式服务都会继续接受请求，这也意味着它需要比传统的非响应式服务更有弹性。因此，如果一个请求的处理时间太长，反应式服务的响应速度会更快。</t></t></p><p id="b43c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">最后，我们想要证明的是，一方面，所描述的理论是成立的。另一方面，通过比较这两个反应式服务，我们希望了解在处理多个快速处理请求时，一个服务是否比另一个服务更快。我们也想证明春福的服务起步更快。我们可能也不想证明什么，而只想看到春福团队有所发现的迹象。</p><p id="12b8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">请记住，非反应性、反应性和KoFu等术语在本文中与Spring Web、Spring WebFlux和Spring KoFu等术语互换使用。</p><h1 id="e3d8" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">2.偏见</h1><p id="7643" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">在本地机器上证明和测试这样的东西是非常困难和不确定的。MacBook Pro或Chrome机器或任何Linux机器，甚至在Windows上，都可以有自己的处理、解释和执行方式。当我们看待新技术时，我们也可能会把自己的一些个人感觉投射到它上面。这就是为什么我在整篇文章中展示的所有测试结果都已经做了多次，我只展示那些给出一致结果的结果。所有其他的测试，也包括这些，都可以在<a class="ae lp" href="https://github.com/jesperancinha/isbn-stacks" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的repo的<a class="ae lp" href="https://github.com/jesperancinha/isbn-stacks/tree/main/docs/reports" rel="noopener ugc nofollow" target="_blank">报告</a>文件夹中获得。</p><h1 id="b9da" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">3.情况</h1><p id="2e83" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">本文的案例本质上只是一个随机生成的ISBN 13号列表。ISBN 13代码有两个静态来源。一个是50万个ISBN的大列表，另一个是50个ISBN的源。第一种情况将模拟持久和大量数据请求的情况。后者将模拟快速处理请求。我们可以说实际上不涉及任何加工过程。想法是不要阻塞正在运行的应用程序的任何部分，并模拟快速请求。这个处理确实会在de服务器上花费一些时间，这就是我们想要探索的。如下图所示，我们将实现前面讨论过的三个服务。</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/b7604793055e748086a54cc2250fe8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLQzBbvlUsGotA0XG9g9OA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">本地绩效请求设置</figcaption></figure><p id="bfc8" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于这类事情，我认为从序列图的角度理解这一点也很重要。</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/491ee4148545bf0f55d8bd4d5bacab5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-v8Yc6xl6OzL7T8u5WjiA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">简化序列图</figcaption></figure><p id="6b20" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">基本上对于每个服务，我们从指定的端点请求ISBNS，然后等待回复。我们感兴趣的是从实际的角度来看，服务如何表现，需要多长时间来获得请求，它们可以接受多少请求，以及它们的响应能力和弹性如何。</p><p id="70d1" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">既然我们已经了解了设计，现在让我们来看看下一步，也就是实现。</p><h1 id="0de2" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">4.履行</h1><p id="2847" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">假设您已经知道如何在Spring/Spring boot中实现服务，我只想在任何情况下快速浏览一下所有不同的实现，以及我为最小化功能级别上的差异所做的努力。此外，在这种情况下，仍然有很小的机会出现偏差或读数不准确。我们实现最简单的REST响应的方式可以决定我们的测试有多可靠。在这些实现中，服务层和数据层不存在。数据直接从启动时初始化的两个列表的内存中取出。</p><h1 id="0ecf" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak"> 4.1。传统的Spring Web MVC阻塞REST服务</strong></h1><p id="032b" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">现在人们普遍认为，旧的Spring Web MVC正在慢慢被更好的软件设计模式或其扩展所取代。然而，在这个实现中，我们只想确定两个重要的方面。第一，我们有一个非常基本的实现。第二，回答是相同或相似的。在我们需要的所有依赖项中，我们实际研究的是这个:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="15c7" class="nj ma it nf b gy nk nl l nm nn">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring-boot.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="de17" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">关于实施，让我们看看它是如何实现的:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="fcc0" class="nj ma it nf b gy nk nl l nm nn">@RestController<br/>@RequestMapping("/api/traditional/non")<br/>class ISBNController {<br/>    var mapper = ObjectMapper()<br/><br/>    @GetMapping("hello")<br/>    fun getMessage(): String {<br/>        return MESSAGE<br/>    }<br/><br/><br/>    @GetMapping<br/>    fun getJsonMessage(): ObjectNode? {<br/>        val createObjectNode = mapper.createObjectNode()<br/>        createObjectNode.put("message", MESSAGE)<br/>        return createObjectNode<br/>    }<br/><br/>    @GetMapping("isbns")<br/>    fun getIsbns(): List&lt;IsbnDto&gt; {<br/>        return <em class="no">ISBNS<br/>    </em>}<br/><br/>    @GetMapping("small/isbns")<br/>    fun getSmallIsbns(): List&lt;IsbnDto&gt; {<br/>        return <em class="no">SMALL_ISBNS<br/>    </em>}<br/><br/>    companion object {<br/>        const val MESSAGE = "I will now give you 1.000.000 ISBN numbers in a Spring MVC Non-Reactive way"<br/>    }<br/>}</span></pre><p id="ce94" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对于这个实现和下面的实现，我们需要记住,<strong class="kk iu">ISBN</strong>是我们的50万个<strong class="kk iu"> ISBN 13 </strong>记录的列表，而<strong class="kk iu">SMALL _ ISBN</strong>是我们的50个记录的列表。由于KoFu 代码是声明性的，我也希望所有其他代码在合理的情况下尽可能声明性。对于这些测试，不需要在<strong class="kk iu"> application.properties </strong>中配置<strong class="kk iu">应用程序上下文</strong>(<strong class="kk iu">web service</strong>的根路径)。不仅没有必要，而且可能对有效结果不利。这就是我不使用它的原因。对于实现的其余部分，我们只需要记住两个端点:<a class="ae lp" href="http://localhost:8080/api/traditional/non/isbns" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/traditional/non/isbns</a>和<a class="ae lp" href="http://localhost:8080/api/traditional/non/small/isbns." rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/traditional/non/small/isbns。</a></p><h1 id="d68d" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">4.2.传统Spring WebFlux MVC反应式REST服务</h1><p id="0449" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">反应式编程和Spring提供的可能性实际上可以很快减少到使用<strong class="kk iu">通量</strong>和<strong class="kk iu">单声道</strong>。如前所述，这些是负责处理数据的发布者。他们可能有额外的订户与之相关联。我们在这种情况下研究的依赖关系是:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="a6ca" class="nj ma it nf b gy nk nl l nm nn">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring-boot.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring-boot.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8682" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">REST控制器的实现可以用非常相似的方式完成:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="1e3c" class="nj ma it nf b gy nk nl l nm nn">@RestController<br/>@RequestMapping("/api/traditional")<br/>class ISBNController {<br/>    var mapper = ObjectMapper()<br/><br/>    @GetMapping("hello")<br/>    fun getMessage(): Mono&lt;String&gt; {<br/>        return Mono.just(MESSAGE)<br/>    }<br/><br/><br/>    @GetMapping<br/>    fun getJsonMessage(): Mono&lt;JsonNode&gt; {<br/>        return Mono.fromCallable <strong class="nf iu">{<br/>            </strong>val createObjectNode = mapper.createObjectNode()<br/>            createObjectNode.put("message", MESSAGE)<br/>            createObjectNode<br/>        <strong class="nf iu">}<br/>    </strong>}<br/><br/>    @GetMapping("isbns")<br/>    fun getIsbns(): Flux&lt;IsbnDto&gt; {<br/>        return Flux.fromIterable(ISBNS)<br/>    }<br/><br/>    @GetMapping("small/isbns")<br/>    fun getSmallIsbns(): Flux&lt;IsbnDto&gt; {<br/>        return Flux.fromIterable(SMALL_ISBNS)<br/>    }<br/><br/>    companion object {<br/>        const val MESSAGE = "I will now give you 1.000.000 ISBN numbers in a Spring MVC Reactive way"<br/>    }<br/>}</span></pre><p id="8cbc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我们在这里看到的，我们将只使用<strong class="kk iu">焊剂</strong>。简单来说，这就是我们如何以一种被动的方式发布元素列表。因此，这是实现中的唯一差异，它允许我们检查第一个和第二个实现之间的行为差异，知道这些差异应该仅来自于第二个是反应性的而第一个不是。正如我们从实现中看到的，该服务将在<a class="ae lp" href="http://localhost:8081/api/traditional/isbns" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/API/traditional/isbns</a>和<a class="ae lp" href="http://localhost:8081/api/traditional/small/isbns" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/API/traditional/small/isbns</a>上提供。</p><h1 id="b51e" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">4.3.Spring KoFu实现</h1><p id="c97e" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">这个实现是我们案例的中心。这里我们使用一种完全不同的方法。正如我们之前所说的，我们将以声明的方式实现所有东西，而不是注释。在我看来，它看起来相当不错。为此，我们需要一些非常重要的依赖项。在将它们添加到我们的repo之前，我们需要确保我们能够到达spring实验图书馆repo。我们需要将它添加到我们的pom文件中:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="ee93" class="nj ma it nf b gy nk nl l nm nn">&lt;repositories&gt;<br/>    &lt;repository&gt;<br/>        &lt;id&gt;spring-milestone&lt;/id&gt;<br/>        &lt;name&gt;Spring Milestone Repository&lt;/name&gt;<br/>        &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;<br/>    &lt;/repository&gt;<br/>&lt;/repositories&gt;</span></pre><p id="0544" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后，我们可以添加必要的依赖项:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="1348" class="nj ma it nf b gy nk nl l nm nn">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.fu&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-fu-kofu&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring-fu-kofu.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>    &lt;version&gt;${spring-boot.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="cf01" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们可以非常清楚地看到，我们也在Spring KoFu后面使用web-flux。</p><p id="7102" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">有了这个，我们就可以实现其余的了:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="5c9d" class="nj ma it nf b gy nk nl l nm nn">val <em class="no">app </em>= <em class="no">reactiveWebApplication </em><strong class="nf iu">{<br/>    </strong>beans <strong class="nf iu">{<br/>        </strong>bean&lt;ISBNSampleService&gt;()<br/>        bean&lt;ISBNSampleHandler&gt;()<br/>    <strong class="nf iu">}<br/>    </strong><em class="no">webFlux </em><strong class="nf iu">{<br/>        </strong>port = if (profiles.<em class="no">contains</em>("test")) 8181 else 8080<br/>        router <strong class="nf iu">{<br/>            </strong>val handler = <em class="no">ref</em>&lt;ISBNSampleHandler&gt;()<br/>            GET("/api/kofu/hello", handler::hello)<br/>            GET("/api/kofu", handler::json)<br/>            GET("/api/kofu/isbns", handler::isbns)<br/>            GET("/api/kofu/small/isbns", handler::smallIsbns)<br/>        <strong class="nf iu">}<br/>        </strong>codecs <strong class="nf iu">{<br/>            </strong>string()<br/>            jackson()<br/>        <strong class="nf iu">}<br/>    }<br/>}<br/><br/></strong>data class ISBNMessage(val message: String)<br/><br/>class ISBNSampleService {<br/>    fun generateMessage() = "I will now give you 1.000.000 ISBN numbers in a Spring KoFu Reactive way"<br/>}<br/><br/>class ISBNSampleHandler(private val isbnSampleService: ISBNSampleService) {<br/>    fun hello(request: ServerRequest) = ServerResponse.ok().bodyValue(isbnSampleService.generateMessage())<br/>    fun json(request: ServerRequest) = ServerResponse.ok().bodyValue(ISBNMessage(isbnSampleService.generateMessage()))<br/>    fun isbns(request: ServerRequest) = ServerResponse.ok().bodyValue(<em class="no">ISBNS</em>)<br/>    fun smallIsbns(request: ServerRequest) = ServerResponse.ok().bodyValue(<em class="no">SMALL_ISBNS</em>)<br/>}<br/><br/>class ISBNStacksKoFuReactiveLauncher{<br/>    companion object{<br/>        @JvmStatic<br/>        fun main(args: Array&lt;String&gt;) {<br/>            <em class="no">app</em>.run()<br/>        }<br/>    }<br/>}</span></pre><p id="359d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您熟悉NodeJS，我敢肯定，您会对这与在NodeJS中创建类似的服务之间的相似性感到非常惊讶。在他们的<a class="ae lp" href="https://github.com/spring-projects-experimental/spring-fu" rel="noopener ugc nofollow" target="_blank"> GitHub </a>回购上可以找到与此非常相似的例子。我们已经可以看到无注释的优势之一。像这样简单的web服务只需要几行代码。我们也可以看到所有的add make插件，像<strong class="kk iu"> string() </strong>和<strong class="kk iu"> jackson() </strong>代码都是以完全声明的方式。实现是不言自明的，我们可以清楚地看到，这个服务和不同的数据列表将在<a class="ae lp" href="http://localhost:8080/api/kofu/isbns" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/kofu/isbns</a>和<a class="ae lp" href="http://localhost:8080/api/kofu/small/isbns" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/kofu/small/isbns</a>上提供。</p><h1 id="afc4" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">5.启动服务</h1><p id="db69" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">为了便于执行我们的测试，我创建了一个<strong class="kk iu"> docker-compose.yml </strong>文件，它允许我们一次构建并启动所有三个服务。我还创建了一个<strong class="kk iu"> Makefile </strong>，其中有几个帮助我们执行性能测试的命令。在我们开始测试或对我们的环境做任何事情之前，我们需要运行这个命令:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="d234" class="nj ma it nf b gy nk nl l nm nn">make docker-clean-build-start</span></pre><p id="82d2" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">一旦命令运行完毕，我们应该会看到三个正在运行的容器。然而，我们将单独进行测试。如果我们在三个容器同时运行时执行测试，它们可能会相互影响，它们可能会消耗太多的CPU或内存，导致不可靠或误导的结果。</p><p id="6c39" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我以前在当地做过这样的测试，但没有得出任何结论性的结果。如前所述，我们将进行测试，我知道这些测试会指出一些重要的结论。我所有测试的所有报告都放在项目根文件夹的文件夹<strong class="kk iu"> docs/reports </strong>中。</p><p id="7e31" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们将使用蝗虫性能工具进行测试。所有locust python脚本都位于项目的根<strong class="kk iu"> locust </strong>文件夹中。</p><p id="0027" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">为了避免我们测试中的偏差，我们还将运行<strong class="kk iu">蝗虫</strong>的<strong class="kk iu">无头</strong>版本。这意味着我们将从生成的CSV文件中看到生成图形的结果。</p><h1 id="9725" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak"> 5.1。蝗虫序列启动测试</strong></h1><p id="989a" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">在这个测试中，我们将使用位于项目的<strong class="kk iu"> Makefile </strong>中的这个脚本，一个接一个地对服务执行加载请求:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="6fdd" class="nj ma it nf b gy nk nl l nm nn">locust-sequence-start:<br/>   docker stop jofisaes_isbn_stacks_reactive<br/>   docker stop jofisaes_isbn_stacks_mvc<br/>   docker restart jofisaes_isbn_stacks_kofu<br/>   sleep 5<br/>   cd locust/kofu &amp;&amp; locust --host=localhost --headless -u 2000 -r 1 --run-time 5m --csv kofu --exit-code-on-error 0<br/>   docker stop jofisaes_isbn_stacks_reactive<br/>   docker restart jofisaes_isbn_stacks_mvc<br/>   docker stop jofisaes_isbn_stacks_kofu<br/>   sleep 5<br/>   cd locust/web &amp;&amp; locust --host=localhost --headless -u 2000 -r 1 --run-time 5m --csv web --exit-code-on-error 0<br/>   docker restart jofisaes_isbn_stacks_reactive<br/>   docker stop jofisaes_isbn_stacks_mvc<br/>   docker stop jofisaes_isbn_stacks_kofu<br/>   sleep 5<br/>   cd locust/webflux &amp;&amp; locust --host=localhost --headless -u 2000 -r 1 --run-time 5m --csv webflux --exit-code-on-error 0</span></pre><p id="a517" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">locust根文件夹包含几个子文件夹。kofu、web和webflux子文件夹包含负责连接大型内容端点的脚本，它们分别代表Spring Kofu、Spring Web(非反应式)和Spring WebFlux。从脚本中我们看到，我们为每个测试停止了<strong class="kk iu">不需要的</strong>容器，并且我们<strong class="kk iu">重启了</strong>目标容器。我们给它5秒钟的延迟，以确保我们的服务已经开始。平均而言，在当前的机器上，所有这些实现都需要不到5秒的时间来启动。Locust从1个用户开始，以每秒1个用户的速度增加到每秒2000个用户发出请求。这确保我们将达到所有服务的阈值。然而，我们不会达到2000个用户，纯粹是因为我们每次测试也只限于5分钟。整个测试总共需要大约15分钟才能完成，结果如下图所示。</p><div class="lr ls lt lu gt ab cb"><figure class="np ju nq nr ns nt nu paragraph-image"><img src="../Images/dad596ff5b60d2e24a543abe3ee6b56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*iU0EOswHnAwnTZ_sm4KJBQ.png"/></figure><figure class="np ju nv nr ns nt nu paragraph-image"><img src="../Images/18ec00fa27a184206bedd38722b3534d.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*M-pSUtWQKadYokDyXIM3Bw.png"/><figcaption class="lv lw gj gh gi lx ly bd b be z dk nw di nx ny translated">左-每秒请求数|右-每秒失败数</figcaption></figure></div><p id="645f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们必须首先正确解释这些图表。在这两张图上，我们看到一个从0到300的轴。这些是衍生用户的数量。我们最初希望从0增加到2000。然而，由于机器的限制，我发现对于我的情况，300是最好的数字。这不是一个很大的数字，但足以衡量对于<strong class="kk iu">长时间处理请求</strong>，哪个服务首先被中断。如图所示，第一个开始失败的服务是<strong class="kk iu"> KoFu </strong>，大约在<strong class="kk iu"> 60产生用户</strong>。接下来是WebFlux服务，它在大约170个衍生用户时开始失败。对于这种加速，Web服务根本不会失败。在这一点上，这可能意味着坏消息或好消息。对于KoFu和WebFlux来说，坏的可能意味着这些架构并不好。但我们已经知道，因此已经有点偏见，WebFlux只是在弹性方面比非反应式服务更好。从好的方面来看，这可能意味着他们接受了太多的请求，因为他们需要更长的时间来处理，他们陷入了被动的状态。如果是这样的话，那么我们实际上得到了一个积极的结果。反应式编程并不是为长期请求而设计的。它实际上坚决反对处理持久的请求。如果我们有持久的请求，并且想要遵从反应式编程，那么首先我们在处理请求的方式上有问题，其次，我们需要解决这个问题。</p><p id="972c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">就目前而言，从这个测试以及我所做的其他一致性测试中得出的结论是，当处理长期请求时，<strong class="kk iu"> Spring KoFu </strong>首先快速失败，然后是使用<strong class="kk iu"> Spring WebFlux </strong>的响应式服务，最后我们看到非响应式<strong class="kk iu"> Spring Web </strong>服务在我们的测试中从未失败。我们也知道这些可能意味着坏的或好的结果。这就是为什么我们现在要进行快速处理请求测试。</p><h1 id="bffd" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">5.2.蝗虫-小负荷-顺序-启动</h1><p id="cbcf" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">在使用我自己的计算机进行的本地测试中，我意识到测试这三个服务行为方式的最好方法就是让它们长时间运行。如果我们要重复这样的测试，那么大约需要30分钟才能完成:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="5bc8" class="nj ma it nf b gy nk nl l nm nn">locust-small-load-sequence-start:<br/>   docker stop jofisaes_isbn_stacks_reactive<br/>   docker stop jofisaes_isbn_stacks_mvc<br/>   docker restart jofisaes_isbn_stacks_kofu<br/>   sleep 5<br/>   cd locust/small/kofu &amp;&amp; locust --host=localhost --headless -u 2000 -r 2000 --run-time 10m --csv kofu --exit-code-on-error 0<br/>   docker stop jofisaes_isbn_stacks_reactive<br/>   docker restart jofisaes_isbn_stacks_mvc<br/>   docker stop jofisaes_isbn_stacks_kofu<br/>   sleep 5<br/>   cd locust/small/web &amp;&amp; locust --host=localhost --headless -u 2000 -r 2000 --run-time 10m --csv web --exit-code-on-error 0<br/>   docker restart jofisaes_isbn_stacks_reactive<br/>   docker stop jofisaes_isbn_stacks_mvc<br/>   docker stop jofisaes_isbn_stacks_kofu<br/>   sleep 5<br/>   cd locust/small/webflux &amp;&amp; locust --host=localhost --headless -u 2000 -r 2000 --run-time 10m --csv webflux --exit-code-on-error 0</span></pre><p id="048d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这意味着我们将立即以每秒2000个用户的速度开始测试。这将持续10分钟，每次服务在不同的场合。使用生成的CSV文件，我能够构建以下图表:</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/bfed76aec980d6fed7ac647158af509b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opquRq1X8pdKmcy-FN1qSg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">在同样的30分钟时间跨度内，所有服务上每秒完成的请求数</figcaption></figure><p id="2519" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在上图中，很难区分不同服务的性能。这与服务的启动以及重启后请求第一次到达服务时的处理方式有关。这与记录在CSV文件中的放置方式相结合，产生了第一个类似斜坡上升的曲线，这对我们的测试没有用。如果我们去掉启动部分，然后只看到稳定的数据，我们会看到更有说服力的东西。</p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/99208be5e2b92b4964017bdc2d21c978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIOlvxjUjxVFXT2URlePeg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">在大约30分钟的同一时间段内，放大所有服务每秒完成的请求数</figcaption></figure><p id="315d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们查看不同的数据，我们会发现，总的来说，我们的Spring KoFu服务比其他两个服务能够处理更多的请求。我们也看到我们的Spring Web和Spring WebFlux服务似乎在互相决斗。如果我们更仔细地观察，我们还会发现，平均而言，WebFlux确实比普通Web处理了更多的请求。我们观察到的另一件事也令我非常惊讶，那就是Spring KoFu请求/秒曲线与其他服务有点类似。Spring Kofu似乎没有出现低性能峰值，而是出现了高性能峰值。</p><p id="bfa7" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">所以现在看起来Spring KoFu可以比其他Spring服务一次处理更多的请求。</p><p id="eb95" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">蝗虫性能测试还为我们提供了一个平均响应时间表。在这里，我们可以看到使用不同实现处理请求的速度:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a308" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从表中读取数据，我们可以再次看到，Spring KoFu似乎比其他Spring服务提供了更好的性能。就请求数量而言，Spring非响应服务处理了<strong class="kk iu"> 459502 </strong>个请求。接下来是Spring Reactive WebFlux，它处理了<strong class="kk iu"> 462978 </strong>个请求。这已经是<strong class="kk iu"> 3476 </strong>要求的显著差异了。Spring KoFu使这一点变得更好，它能够处理<strong class="kk iu"> 488189 </strong>请求。这是对<strong class="kk iu"> 25211 </strong>请求的进一步增加！这也反映在平均响应时间上。我们可以看到我们在任何测试中都没有错误，这意味着我们的服务在测试期间总是可用的。我们感兴趣的另一个有趣的度量是所有请求中最长的请求。显然，最长的时间来自非反应式服务，潜在用户必须等待<strong class="kk iu"> 76 </strong>秒。这通过等待时间为<strong class="kk iu"> 46 </strong>秒的普通反应服务以及等待时间为<strong class="kk iu"> 28 </strong>秒的Kofu服务得到了改善。如果你觉得这些数字很长，那是因为它们确实很长。但这也是因为这些测试是在本地机器上运行的，在本地机器上，时间、故障和延迟的规模与真实的服务器非常不同。最后，我们还看到这与每秒请求数完全匹配，我们还看到从非反应式到KoFu的改进。</p><p id="d86b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">从这个测试和之前的测试中得出的结论是，现在看起来Spring KoFu对快速处理请求的反应要快得多，它将能够同时处理更多的请求，并将自己推向性能峰值。</p><h1 id="3d3d" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">5.3.服务启动</h1><p id="2073" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">这是我们对Spring KoFu框架的最后一次测试。在这种情况下，我们将测试服务启动需要多长时间。在本例中，我还在<strong class="kk iu"> Makefile </strong>中创建了一个命令来帮助我们进行测试:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="4ca6" class="nj ma it nf b gy nk nl l nm nn">local: no-test<br/>   mkdir -p bin<br/>   cp isbn-stacks-rest-kofu-mvc-reactive/target/isbn-stacks-rest-kofu-mvc-reactive-*.jar bin/isbn-stacks-rest-kofu-mvc-reactive.jar<br/>   cp isbn-stacks-rest-traditional-mvc-non-reactive/target/isbn-stacks-rest-traditional-mvc-non-reactive-*.jar bin/isbn-stacks-rest-traditional-mvc-non-reactive.jar<br/>   cp isbn-stacks-rest-traditional-mvc-reactive/target/isbn-stacks-rest-traditional-mvc-reactive-*.jar bin/isbn-stacks-rest-traditional-mvc-reactive.jar<br/>   cp isbn-stacks-rest-kofu-plain/target/isbn-stacks-rest-kofu-plain-*.jar bin/isbn-stacks-rest-kofu-plain.jar</span></pre><p id="1264" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这个命令的作用是将所有jar文件复制到根目录下的bin文件夹中。</p><p id="eb7a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">这样我们可以简单地运行<strong class="kk iu"> java -jar &lt;服务&gt; </strong>来启动它们，注册它们的启动时间，然后用<strong class="kk iu"> Ctrl-C </strong>来停止它们。</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">10次启动时间和计算的平均启动时间</figcaption></figure><p id="33fa" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们还可以在这里看到一个迹象，春季KoFu似乎开始得更快。如果我们将这些结果与WebFlux或Web进行比较，我们会看到显著的改进。</p><h1 id="119b" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">6.结论</h1><p id="dc8f" class="pw-post-body-paragraph ki kj it kk b kl mx kn ko kp my kr ks kt mz kv kw kx na kz la lb nb ld le lf im bi translated">我们通过制作3种服务开始了这一旅程，并使它们尽可能简单，只有两个端点。一个快速端点仅支持50个ISBN号，一个慢速端点支持50万个ISBN号。我们对他们进行了测试，虽然我们不能做出明确的结论，但是我们可以观察到一些行为，作为证实Spring-Fu团队在GitHub上的声明的迹象:</p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="e3a0" class="nj ma it nf b gy nk nl l nm nn"><em class="no">Spring Fu is an incubator for </em><a class="ae lp" href="https://github.com/spring-projects-experimental/spring-fu/tree/main/jafu" rel="noopener ugc nofollow" target="_blank"><em class="no">JaFu</em></a><em class="no"> (Java DSL) and </em><a class="ae lp" href="https://github.com/spring-projects-experimental/spring-fu/tree/main/kofu" rel="noopener ugc nofollow" target="_blank"><em class="no">KoFu</em></a><em class="no"> (Kotlin DSL) designed to configure Spring Boot explicitly with code in a declarative way with great discoverability thanks to auto-complete. It provides fast startup (40% faster than regular auto-configuration on a minimal Spring MVC app), low memory consumption and is a good fit with </em><a class="ae lp" href="https://www.graalvm.org/docs/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"><em class="no">GraalVM native</em></a><em class="no"> thanks to its (almost) reflection-less approach.</em></span></pre><p id="fba9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们确实看到，在编码时，IntelliJ似乎提供了很好的自动完成支持。虽然这都是真的，但这可能不是春赋最有趣的一面。我们还观察到服务启动似乎更快了，尽管我们无法确切地看到启动时间减少了40%。尽管表现在春赋的任何一个来源中都不是显而易见的，但由于其无反射的性质，它在某种程度上是隐含的。他们还提到，JVM   中的<a class="ae lp" href="https://spring.io/blog/2020/05/28/spring-fu-0-3-0-and-beyond" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="no">函数式方法要高效得多。这至少是理论上的，我们在测试中确实观察到了与<strong class="kk iu"> Spring-KoFu </strong>的显著改进差异。我们已经在响应时间和负载能力方面看到了这一点。</em></strong></a></p><p id="cdf4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">进行这些测试是相当费力的，但是看到非常令人信服的迹象表明，采用完全声明式的工作方式而不使用注释是非常值得的，这是非常值得的。</p><p id="f97f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">正如我在介绍中提到的，我参加了Spring认证，其中很多都是关于注释的。我仍然觉得，我也一直认为，参加认证是值得的。尽管如此，技术确实在快速发展，向前发展，我们似乎实现的是在我们丰富技术知识的道路上不断改进。我们今天所知道的高效和神奇的东西，明天可能会在技术世界中改变，这没关系。老实说，我对此很失望。如果你觉得过去学习注释的那些年不知何故受到了这些新发展的威胁，我给你的最好建议是，让它过去，继续前进。我在过去学到的东西很棒，我可以把它拿来修改，以适应这种新的工作方式。如果我们在未来看到一个Spring功能性的生产就绪版本，可能是Spring-Fu，那么一切都会变得更好，努力工作以跟上变化会给我们所有人带来更多的魔力，无论我们做什么，这都是我们需要继续做的。</p><p id="2c08" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我已经把这个应用程序的所有源代码放在了GitHub上</p><p id="c00b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我希望你能像我喜欢写这篇文章一样喜欢它。我尽量让它简洁明了，并省略了许多小细节。</p><p id="14ce" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我很想听听你的想法，所以请在下面留下你的评论。</p><p id="4cbc" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">提前感谢阅读！</p><h1 id="4c9e" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">7.参考</h1><div class="od oe gp gr of og"><a href="https://spring.io/blog/2020/05/28/spring-fu-0-3-0-and-beyond" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Spring Fu 0.3.0及更高版本</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">我很高兴地宣布，春天福0.3.0已经上市。提醒一下，春福是Spring Boot的孵化器…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">spring.io</p></div></div><div class="op l"><div class="oq l or os ot op ou jz og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://blog.jetbrains.com/kotlin/2020/08/the-state-of-kotlin-support-in-spring/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Kotlin支持的春天| kot Lin博客</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这是一份来自科特林科夫的塞巴斯蒂安·德勒兹的“科特林支持春天的状态”谈话的抄本:你发现…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">blog.jetbrains.com</p></div></div><div class="op l"><div class="ov l or os ot op ou jz og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://spring.io/blog/2018/10/02/the-evolution-of-spring-fu" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">春赋的演变</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">我利用在SpringOne讲台上做第一次关于Spring Fu的演讲的机会做了一个短暂的停留…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">spring.io</p></div></div><div class="op l"><div class="ow l or os ot op ou jz og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://nfrankel.medium.com/annotation-free-spring-dcdbefd57fe8" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">无注释弹簧</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">我们对技术堆栈的一些(如果不是大部分)判断要么来自第三方意见，要么来自以前的…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">nfrankel.medium.com</p></div></div><div class="op l"><div class="ox l or os ot op ou jz og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://www.dineshonjava.com/whats-new-in-spring-framework-4x/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Java上的Spring Framework 4.x - Dinesh有什么新特性</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">经过近四年的时间，流行的Spring框架正在从版本3升级到版本4。春天3.0是…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.dineshonjava.com</p></div></div><div class="op l"><div class="oy l or os ot op ou jz og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://dzone.com/articles/a-guide-to-spring-framework-annotations" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Spring框架注释指南- DZone Java</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">从Java 5.0开始，Java编程语言提供了对注释的支持。领先的Java框架速度很快…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">dzone.com</p></div></div><div class="op l"><div class="oz l or os ot op ou jz og"/></div></div></a></div></div></div>    
</body>
</html>