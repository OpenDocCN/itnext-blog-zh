<html>
<head>
<title>How to automate versioning and publication of an npm package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何自动化npm包的版本控制和发布</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-automate-versioning-and-publication-of-an-npm-package-233e8757a526?source=collection_archive---------0-----------------------#2019-05-21">https://itnext.io/how-to-automate-versioning-and-publication-of-an-npm-package-233e8757a526?source=collection_archive---------0-----------------------#2019-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用npm脚本和外部包来自动化版本管理和包发布过程的指南、提示和技巧。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6e9353444b4e987100fc7d7ebc33389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HG5PTqPptU4IKFhrLu2j9w.jpeg"/></div></div></figure><p id="144a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">TL；你可以在文章的最后部分看到我们自动化发布过程的方法。</strong></p><p id="d4e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<a class="ae lq" href="https://twitter.com/xing_esp" rel="noopener ugc nofollow" target="_blank"> Xing Spain </a>我们几个月前开始了一个新项目，一个React组件库，几个产品将使用它，所以共享这个库的自然方式是通过一个npm包。</p><p id="b797" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了共享一个npm包，以一致的方式发布版本是很重要的，我们从一开始就知道我们想尽可能地自动化这个过程。</p><p id="ba39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">这篇文章描述了我们如何自动化版本控制和发布的过程</strong>。如果你想要最简单的方法，我会推荐<a class="ae lq" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>，它是一个完全自动化的版本管理和软件包发布工具。</p><p id="11ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，不使用语义发布的主要原因是因为我们不想为master中的每一次推送发布一个新版本，我们希望完全控制每一步。不使用语义发布的另一个原因可能是您需要对CI设置进行太多的调整。在任何情况下，这两种方法都基于结构化提交消息的相同基础。</p><p id="62e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我假设你已经知道如何发布一个npm包，但是你想改进所有涉及的手工过程。如果您不熟悉发布流程，<a class="ae lq" href="https://docs.npmjs.com/cli/publish" rel="noopener ugc nofollow" target="_blank">您可以开始阅读文档</a>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bf06" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">工作流程亮点</h1><p id="7860" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><strong class="kw iu">能够自动化一个包的版本和发布的唯一要求是每次提交都应该遵循一个消息约定</strong>，我们遵循<a class="ae lq" href="https://www.conventionalcommits.org" rel="noopener ugc nofollow" target="_blank">常规提交规范</a>。</p><p id="7878" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们的提交看起来像这样:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6128" class="na lz it mw b gy nb nc l nd ne">6f88099 - (tag: v1.8.0, master) chore(release): 1.8.0<br/>333dce9 - feat: add composable Avatar component<br/>ffb2263 - fix: add correct styles to Label component<br/>7d34334 - chore: update Jest to 24.7.1</span></pre><p id="21d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在他们的文档站点中查看<a class="ae lq" href="https://www.conventionalcommits.org/en/v1.0.0-beta.4/#examples" rel="noopener ugc nofollow" target="_blank">不同的常规提交示例。</a></p><h2 id="6e19" class="na lz it bd ma nf ng dn me nh ni dp mi ld nj nk mk lh nl nm mm ll nn no mo np bi translated">实施常规提交</h2><p id="07c5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">很容易忘记提交约定，所以为了保持一致，我们使用<a class="ae lq" href="https://github.com/commitizen/cz-cli" rel="noopener ugc nofollow" target="_blank"> commitzen </a>来生成提交，使用<a class="ae lq" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank"> husky </a>来管理Git <em class="nq"> commit-msg </em>钩子来验证提交消息。</p><p id="f119" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以轻松安装husky和commitzen:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="4441" class="na lz it mw b gy nb nc l nd ne">npm i -D husky @commitlint/{config-conventional,cli}</span></pre><p id="f47e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此设置需要添加到您的<code class="fe nr ns nt mw b">package.json</code>:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="9aff" class="na lz it mw b gy nb nc l nd ne">"config": {<br/>  "commitizen": {<br/>    "path": "cz-conventional-changelog"<br/>  }<br/>},<br/>"husky": {<br/>  "hooks": {<br/>    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"<br/>  }<br/>}</span></pre><p id="66b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要测试它，只需尝试用不遵循提交约定的消息提交更改，它将抛出一个错误。</p><p id="6bf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，我们还使用了一个预提交钩子触发<a class="ae lq" href="https://github.com/okonet/lint-staged" rel="noopener ugc nofollow" target="_blank"> lint-staged </a>来lint，并在提交之前格式化更改，在最后一节中，您可以从我们的<code class="fe nr ns nt mw b">package.json</code>中看到一个例子。</p><h2 id="4061" class="na lz it bd ma nf ng dn me nh ni dp mi ld nj nk mk lh nl nm mm ll nn no mo np bi translated">基于提交更新包版本</h2><p id="6a44" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们使用<a class="ae lq" href="https://github.com/conventional-changelog/standard-version" rel="noopener ugc nofollow" target="_blank">标准版本</a>根据提交历史自动更改版本。</p><p id="feb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要安装标准版，只需运行:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="67ee" class="na lz it mw b gy nb nc l nd ne">npm i -D standard-version</span></pre><p id="5645" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后您可以在您的<code class="fe nr ns nt mw b">package.json</code>中创建发布脚本:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b038" class="na lz it mw b gy nb nc l nd ne">{<br/>  "scripts": {<br/>    "release": "standard-version"<br/>  }<br/>}</span></pre><p id="a86e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您可以运行<code class="fe nr ns nt mw b">npm run release</code>来触发版本更新。</p><p id="d401" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，标准版将按照以下指南更改您的版本号:</p><ul class=""><li id="e92d" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">一个<code class="fe nr ns nt mw b">git commit -m “fix: …”</code>提交将触发一个<strong class="kw iu">补丁更新</strong> (1.0.0 → 1.0.1)</li><li id="3a67" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">一个<code class="fe nr ns nt mw b">git commit -m “feat: …”</code>提交将触发一个<strong class="kw iu">小更新</strong> (1.0.0 → 1.1.0)</li><li id="c289" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">提交主体中的<code class="fe nr ns nt mw b">BREAKING CHANGE: …</code>和任何类型的提交都会触发<strong class="kw iu">重大更新</strong> (1.0.0 → 2.0.0)</li></ul><p id="d9ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，标准版将完成以下任务:</p><ul class=""><li id="5599" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated"><code class="fe nr ns nt mw b">package.json</code>撞版</li><li id="4d00" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">更新<code class="fe nr ns nt mw b">CHANGELOG.md</code></li><li id="20ac" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">提交两个文件</li><li id="e6ba" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">标记新版本</li></ul><p id="f047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">标准版本没有做的是将提交推送到您的远程存储库</strong>，所以在运行<code class="fe nr ns nt mw b">npm run release</code>之后，您需要执行<br/> <code class="fe nr ns nt mw b">git push --follow-tags origin master</code>并发布包。</p><h2 id="2b50" class="na lz it bd ma nf ng dn me nh ni dp mi ld nj nk mk lh nl nm mm ll nn no mo np bi translated">你可以在发布过程中做一些很酷的额外工作</h2><p id="439d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在发布过程中，有几个额外的任务可以自动完成，例如:</p><ul class=""><li id="4e37" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">使用<a class="ae lq" href="https://github.com/conventional-changelog/releaser-tools/tree/master/packages/conventional-github-releaser" rel="noopener ugc nofollow" target="_blank">传统-github-releaser </a>的github版本(在Github中创建一个更好的版本，列出新的特性、修复或突破性变化)</li><li id="2b4e" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">使用<a class="ae lq" href="https://github.com/Kikobeats/git-authors-cli" rel="noopener ugc nofollow" target="_blank"> git-authors-cli </a>自动更新<code class="fe nr ns nt mw b">package.json</code>中的贡献者</li><li id="1fc8" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">生成styleguide的静态版本(可能是Storybook、Styleguidist、Docz…)</li><li id="165a" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">使用<a class="ae lq" href="https://github.com/ai/size-limit" rel="noopener ugc nofollow" target="_blank">尺寸限制</a>检查你的包裹没有达到预先设定的最大尺寸</li></ul><p id="1301" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在本文的最后一节看到如何使用这些额外功能的示例。</p><h2 id="a708" class="na lz it bd ma nf ng dn me nh ni dp mi ld nj nk mk lh nl nm mm ll nn no mo np bi translated">触发释放</h2><p id="2640" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦提交到达主机，执行释放只需要一个命令:<code class="fe nr ns nt mw b">npm run release</code></p><p id="f27e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来会发生什么？幕后可能会发生很多事情，<strong class="kw iu">所有的魔法都是使用一些npm包和npm脚本</strong>完成的。</p><p id="3a33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能是使用标准版本的正常工作流程，但可能性是无限的:</p><ol class=""><li id="0658" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp oi oa ob oc bi translated">验证更改(运行测试，检查更改是否满足ESLint或更漂亮，或者检查包的最大大小)</li><li id="d81f" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated">如果前面的检查都成功了，那么就可以构建甚至部署任何Styleguide的静态构建了</li><li id="ab12" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated">此后，更新<code class="fe nr ns nt mw b">CHANGELOG.md</code>和包版本，并生成新的提交</li><li id="7f06" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated">下一步是将标签和发布版本推送到Github(这一步需要一个Github auth令牌)</li><li id="c965" class="nu nv it kw b kx od la oe ld of lh og ll oh lp oi oa ob oc bi translated">最后一步是将新版本发布到npm，这通常在CI服务器中完成，但也可以在本地完成</li></ol><p id="8963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想看我们用来执行类似工作流程的包和设置，请继续阅读。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4d0e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">自动版本化和发布的真实例子</h1><p id="9085" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果您想应用类似的方法，首先需要安装一些依赖项:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7837" class="na lz it mw b gy nb nc l nd ne">npm i -D standard-version husky lint-staged @commitlint/{config-conventional,cli} commitizen conventional-github-releaser git-authors-cli conventional-github-releaser npm-run-all eslint prettier</span></pre><p id="623b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后您可以用一些脚本和配置来更新您的<code class="fe nr ns nt mw b">package.json</code>:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e7a2" class="na lz it mw b gy nb nc l nd ne">"scripts": {<br/>  "commit": "git-cz",<br/>  "test": "...",<br/>  "build": "...",<br/>  "lint": "eslint src/**",<br/>  "styleguide:build": "...",<br/>  "prettier:check": "prettier --check 'src/**/*.{js,mdx}'",<br/>  "validate": "run-s test lint prettier:check",<br/>  "prerelease": "git checkout master &amp;&amp; git pull origin master &amp;&amp; npm i &amp;&amp; run-s validate styleguide:build &amp;&amp; git-authors-cli &amp;&amp; git add .",<br/>  "release": "standard-version -a",<br/>  "postrelease": "run-s release:*",<br/>  "release:tags": "git push --follow-tags origin master",<br/>  "release:github": "conventional-github-releaser -p angular",<br/>  "ci:validate": "rm -rf node_modules &amp;&amp; npm ci &amp;&amp; npm run validate",<br/>  "prepublishOnly": "npm run ci:validate &amp;&amp; npm run build",<br/>},<br/>"config": {<br/>  "commitizen": {<br/>    "path": "cz-conventional-changelog"<br/>  }<br/>},<br/>"husky": {<br/>  "hooks": {<br/>    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS",<br/>    "pre-commit": "lint-staged"<br/>  }<br/>},<br/>"lint-staged": {<br/>  "src/**/*.mdx": [<br/>    "prettier --write",<br/>    "git add"<br/>  ],<br/>  "src/**/*.js": [<br/>    "prettier --write",<br/>    "eslint --fix",<br/>    "git add"<br/>  ]<br/>}</span></pre><p id="667c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这直接取自我们的<code class="fe nr ns nt mw b">package.json</code>，但是我删除了一些与自动化过程无关的脚本，还清空了一些将根据您的需求设置的其他脚本。</p><p id="12b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了正确理解这个例子，你需要知道一些npm脚本的特性和技巧:</p><ul class=""><li id="a0eb" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated">有几个npm脚本会被自动触发，例如在安装软件包之前或之后，或者在发布软件包之前，<a class="ae lq" href="https://docs.npmjs.com/misc/scripts" rel="noopener ugc nofollow" target="_blank">查看npm文档</a>，它们非常有用</li><li id="992d" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">此外，任何自定义脚本都可以通过运行名称匹配的<code class="fe nr ns nt mw b">npm run &lt;script_name&gt;</code>和<em class="nq"> pre </em>和<em class="nq"> post </em>命令来执行(例如，prevalidate、validate、postvalidate)</li><li id="b417" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe nr ns nt mw b">prePublishOnly</code>是在包准备和打包之前触发的，只针对一个<code class="fe nr ns nt mw b">npm publish</code>(所以这是一个验证您的包并执行构建的完美地方)</li><li id="765f" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">使用<a class="ae lq" href="https://github.com/mysticatea/npm-run-all" rel="noopener ugc nofollow" target="_blank"> npm-run-all </a>包，您可以并行或顺序运行几个脚本(因此<code class="fe nr ns nt mw b">npm run-s release:*</code>与<code class="fe nr ns nt mw b">npm run release:tags &amp;&amp; npm run release:github</code>相同)</li><li id="fe24" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe nr ns nt mw b">npm ci</code>与<code class="fe nr ns nt mw b">npm install</code>相似，但被调整为在自动化环境中使用，<a class="ae lq" href="https://docs.npmjs.com/cli/ci" rel="noopener ugc nofollow" target="_blank">你可以在npm文档中阅读更多关于npm-ci的内容</a></li></ul><p id="75d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在简单解释了npm脚本之后，让我来解释一下<strong class="kw iu">我们为任何开发者</strong>准备的<em class="nq">真实</em>工作流程:</p><ul class=""><li id="c13d" class="nu nv it kw b kx ky la lb ld nw lh nx ll ny lp nz oa ob oc bi translated"><code class="fe nr ns nt mw b">npm run commit</code>而不是<code class="fe nr ns nt mw b">git commit</code>能够轻松地创建一个提交你的更改的消息</li><li id="f014" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated"><code class="fe nr ns nt mw b">npm run release</code>触发自动版本变更，得益于npm脚本在运行发布之前会触发<code class="fe nr ns nt mw b">prerelease</code>脚本(验证、styleguide静态构建和自动github贡献者)，而在发布之后会触发<code class="fe nr ns nt mw b">postrelease</code>脚本(它会将<code class="fe nr ns nt mw b">CHANGELOG.md</code>和<code class="fe nr ns nt mw b">package.json</code>变更推送到远程存储库并在Github中执行新的发布)</li><li id="b7d1" class="nu nv it kw b kx od la oe ld of lh og ll oh lp nz oa ob oc bi translated">在我们的例子中，最后一步是在我们的CI环境(Jenkins)中完成的，我们解析每一个推送到master的提交，如果是发布提交(例如<code class="fe nr ns nt mw b">chore(release): 1.8.0</code>，则执行<code class="fe nr ns nt mw b">npm publish</code>(在此之前<code class="fe nr ns nt mw b">prePublishOnly</code>将被自动触发以验证和构建代码)</li></ul><p id="b1b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">老实说，在一个持续集成的环境中，我们不应该在本地触发发布。我们希望手动触发每个版本，但更好的地方可能是从詹金斯乔布斯的例子。</p><p id="3dc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅此而已，我希望我们的一些工作流程对您的项目有所帮助，或者至少理解您可以通过一些npm魔法实现的所有自动化可能性。这个过程甚至可以更复杂，向Slack发送发布通知或发布新的tweet。</p><p id="7dac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在任何情况下，正如我在本文开头向您推荐的，对于大多数项目来说，使用<a class="ae lq" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>并轻松地自动化整个过程可能更有意义。</p></div></div>    
</body>
</html>