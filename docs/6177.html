<html>
<head>
<title>[BUILD] BFF Pattern with Go Microservices using REST &amp; gRPC.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用REST和gRPC通过Go微服务[构建] BFF模式。</h1>
<blockquote>原文：<a href="https://itnext.io/bff-pattern-with-go-microservices-using-rest-grpc-87d269bc2434?source=collection_archive---------0-----------------------#2021-09-08">https://itnext.io/bff-pattern-with-go-microservices-using-rest-grpc-87d269bc2434?source=collection_archive---------0-----------------------#2021-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/41fc50e997eae46dc3c2049c163a7d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGyfx5FGNH9Tmv-3jBOebA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">高级图表</figcaption></figure><h2 id="1542" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">让我们用REST和gRPC构建dockerized Go微服务来演示BFF模式。将其绑定到UI，并在AWS EC2上部署所有内容。(也有Kotlin和Java版本)</h2><p id="6593" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">TL；DR: <a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc" rel="noopener ugc nofollow" target="_blank"> Github Go </a>，<a class="ae lt" href="https://github.com/uid4oe/microservices-kotlin-grpc" rel="noopener ugc nofollow" target="_blank"> Github Kotlin </a>，<a class="ae lt" href="https://github.com/uid4oe/microservices-java-grpc" rel="noopener ugc nofollow" target="_blank"> Github Java </a>，<a class="ae lt" href="https://github.com/uid4oe/microservices-grpc-ui" rel="noopener ugc nofollow" target="_blank"> Github UI </a></p><p id="b60f" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">BFF，也就是所谓的“永远最好的朋友”<em class="lz"/>模式是一个已经建立的架构…玩笑归玩笑，当我们的系统有<strong class="la ir">多个</strong>前端，而这些前端又有很大<strong class="la ir">不同的需求</strong>时，<a class="ae lt" href="https://medium.com/frontend-at-scale/frontend-architectural-patterns-backend-for-frontend-29679aba886c" rel="noopener"> BFF </a> —后端对前端模式是有意义的。我们的目标不是根据不同的前端特定需求来改变我们的核心服务，而是在前端和核心服务之间的一个层中实现这些需求。因此，我们为前端添加了一个<strong class="la ir"> <em class="lz">后端服务。这也允许我们在一个结构化和有界的上下文中处理这样的需求。</em></strong></p><p id="ebd7" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">理想情况下，我们的业务/领域相关逻辑应该放在不对外公开的微服务中。这种设置支持SoC、模块化和灵活性。在这个例子中，<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a>和<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/advice" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">建议服务</strong> </a>将持有我们的域逻辑。<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/bff" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> BFF服务</strong> </a>将执行<a class="ae lt" href="https://medium.com/swlh/grpc-in-the-life-of-microservices-309933945d6" rel="noopener"> gRPC </a>对域服务的调用。此外，如果需要，它将负责汇总/定制收到的域响应。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/baff29b0bee685daf62dd95d7a699ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KB7Rc7PIJmDmBhvJJy6DPA.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用户界面(带有语义UI的React.js)</figcaption></figure><p id="4dd6" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">以上，我们有我们的<a class="ae lt" href="https://github.com/uid4oe/microservices-grpc-ui" rel="noopener ugc nofollow" target="_blank"> UI </a>。我们将为<a class="ae lt" href="https://robohash.org/" rel="noopener ugc nofollow" target="_blank">机器人</a>用户实现CRUD操作，并将<a class="ae lt" href="https://api.adviceslip.com/" rel="noopener ugc nofollow" target="_blank">随机建议</a>与他们的<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/af856b536b03bee25a5e157b021bb4d26c4ed48e/advice/advicedb/postgres.go#L14" rel="noopener ugc nofollow" target="_blank">user_id</a></code>链接起来。嗯，但是基于<em class="lz">高级图表</em>我们将数据的一些部分存储在不同的存储库中。这是否意味着我们将需要在前端执行多个网络调用？<strong class="la ir">没有！BFF服务将为我们处理此类情况。下面有一个很酷的gif，突出显示了在我们的例子中处理不同请求类型所涉及的部分。</strong></p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f870899a1085721e40b7ce58b07c8328.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/1*YCFbNsJ5njf88b4a0ZoCIg.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">很酷的gif</figcaption></figure><p id="5a61" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">因此，我们现在有了这个<strong class="la ir"> <em class="lz">额外的</em> </strong>服务来解决上述问题。但是性能呢。房间里的大象。为了减少新引入的开销，我们将在服务之间使用<a class="ae lt" href="https://medium.com/swlh/grpc-in-the-life-of-microservices-309933945d6" rel="noopener"> <strong class="la ir"> gRPC </strong> </a>。让我们从定义<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> <strong class="la ir">的契约开始。</strong></p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="bc64" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/user/userpb/user.proto" rel="noopener ugc nofollow" target="_blank">user.proto</a></code>用于定义我们服务中需要的一切。我们在这里添加所有需要的<code class="fe mf mg mh mi b">message</code>、<code class="fe mf mg mh mi b">service</code>、<code class="fe mf mg mh mi b">rpc</code>、<code class="fe mf mg mh mi b">enum</code>类型。它们将在代码生成期间由<code class="fe mf mg mh mi b">protoc</code>使用。</p><p id="1dd3" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">为了生成相关代码，我们可以使用<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/genarate-pb.sh" rel="noopener ugc nofollow" target="_blank">generate-pb.sh</a></code>，它基本上是执行<code class="fe mf mg mh mi b">protoc</code>命令。</p><p id="b9dd" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">太好了！<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> <strong class="la ir"> </strong>和任何其他服务之间的桥梁现在准备好了。我们可以开始在<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> (gRPC服务器)上实现<code class="fe mf mg mh mi b">rpc <strong class="la ir">GetUsers</strong></code>。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a7ba" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">上面，<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> (gRPC服务器)通过将请求委托给<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user/userdb" rel="noopener ugc nofollow" target="_blank"><strong class="la ir">userdb</strong></a></code> <strong class="la ir"> </strong>包中的一个方法来实现<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/af856b536b03bee25a5e157b021bb4d26c4ed48e/user/main.go#L74" rel="noopener ugc nofollow" target="_blank">rpc <strong class="la ir">GetUsers</strong></a></code>，该方法通过<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/af856b536b03bee25a5e157b021bb4d26c4ed48e/user/userdb/mongo.go#L77" rel="noopener ugc nofollow" target="_blank"><strong class="la ir">mongo_client</strong></a></code>执行DB操作。</p><p id="1d64" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们已经完成了<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> (gRPC服务器)，并准备开始构建<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/bff" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> BFF服务</strong> </a> <strong class="la ir"> </strong> (gRPC客户端)。由于<code class="fe mf mg mh mi b">protoc</code>，所需的<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/af856b536b03bee25a5e157b021bb4d26c4ed48e/user/userpb/user_grpc.pb.go#L30" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> <em class="lz">存根</em></strong></a><strong class="la ir"><em class="lz">(</em></strong>gRPC客户端对于<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a>、<strong class="la ir"> </strong>或任何其他<strong class="la ir"> ) </strong>已经生成。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="07d7" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">在<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/bff" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> BFF服务</strong> </a>中设置好我们的HTTP/2连接后，我们将使用<code class="fe mf mg mh mi b"><strong class="la ir">userGrpcServiceClient</strong></code> <strong class="la ir"> </strong>进行通信，这是我们的存根(您可以随意命名)。当我们的存根调用它的<code class="fe mf mg mh mi b">rpc <strong class="la ir">GetUsers</strong></code> <strong class="la ir"> </strong>方法时，请求将到达我们gRPC服务器在<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> <strong class="la ir">中的实现。</strong>就这样！我们现在可以通过gRPC使用MongoDB，并将响应返回给<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/bff" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> BFF服务</strong> </a>。</p><p id="e1f5" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们几乎完成了，只剩下两件事来为我们的前端服务。准备处理函数并运行一个将端点绑定到我们的处理函数的HTTP服务器。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7e35" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">上面，处理函数<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/af856b536b03bee25a5e157b021bb4d26c4ed48e/bff/main.go#L33" rel="noopener ugc nofollow" target="_blank"><strong class="la ir">GetUsers</strong></a></code> <em class="lz"> </em>将请求委托给<code class="fe mf mg mh mi b"><strong class="la ir">user_client</strong></code> <strong class="la ir"> </strong>，其中包含一个<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a>的<a class="ae lt" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"><em class="lz">存根</em> ，命名为<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/af856b536b03bee25a5e157b021bb4d26c4ed48e/bff/client/user_client.go#L56" rel="noopener ugc nofollow" target="_blank"><strong class="la ir">userGrpcServiceClient</strong></a></code> <strong class="la ir"> </strong>正如我们之前讨论的。</a></p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="362f" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">最后，我们将设置HTTP服务器，在本例中我们将使用<a class="ae lt" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin </a>。<code class="fe mf mg mh mi b">gin.Default()</code>连接记录器和恢复中间件。<code class="fe mf mg mh mi b">cors.Default()</code>允许我们接受来自任何地方的流量。我们用它们的处理函数注册我们的端点/路由。现在，一旦发出请求，Gin将调用注册的处理函数。</p><p id="0ae8" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated"><strong class="la ir">万岁！我们完了！！！</strong>此时，我们可以通过gRPC使用<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/user" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">用户服务</strong> </a> <strong class="la ir"> </strong>的repository (MongoDB)，将响应返回给<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/bff" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> BFF服务</strong> </a>，按照我们想要的方式定制它，然后返回前端。</p><p id="48ba" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">其余的实现可以在<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。如果您对使用SQL存储库的服务感兴趣，请检查<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/tree/main/advice" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">建议服务</strong> </a> <strong class="la ir"> ( </strong> PostgreSQL)。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="1a0e" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">是时候结束我们的工作了！首先，我们需要一个<code class="fe mf mg mh mi b">Dockerfile</code></p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="865b" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">我们应该用需要暴露的端口值来改变<code class="fe mf mg mh mi b">"PORT"</code>。例如，<code class="fe mf mg mh mi b">8080</code>。然后，我们可以使用<code class="fe mf mg mh mi b">docker build -t uid4oe/go-ms-bff:latest</code>构建应用程序并创建图像</p><p id="6f97" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">此外，我更喜欢使用<code class="fe mf mg mh mi b">scratch</code>，因为它可以缩小最终图像的尺寸。我们应该对其余的服务应用相同的步骤，并将图像推送到<a class="ae lt" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。<code class="fe mf mg mh mi b">docker push uid4oe/go-ms-bff:latest</code></p><p id="1167" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">最后，我们需要一个<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/docker-compose.yml" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>文件来收集所有信息。默认情况下，我们可以使用链接中的文件。使用<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/docker-compose.yml" rel="noopener ugc nofollow" target="_blank">docker-compose.yml</a></code>，我们还应该将<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/mongo-init.js" rel="noopener ugc nofollow" target="_blank">mongo-init.js</a></code>、<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/advice.sql" rel="noopener ugc nofollow" target="_blank">advice.sql</a></code>、<code class="fe mf mg mh mi b"><a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc/blob/main/.env" rel="noopener ugc nofollow" target="_blank">.env</a></code>复制到我们的EC2实例中。</p><p id="eb75" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">到最后，我们可以按照<a class="ae lt" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/docker-basics.html" rel="noopener ugc nofollow" target="_blank">亚马逊指南</a>在EC2中设置Docker。之后，我们需要使用这个<a class="ae lt" href="https://gist.github.com/npearce/6f3c7826c7499587f00957fee62f8ee9#docker-compose-install" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">要点</strong> </a>将<code class="fe mf mg mh mi b">docker-compose</code>添加到我们的实例中，现在我们都准备好了！哦，确保<strong class="la ir">入站规则</strong>配置正确。默认情况下，端口<code class="fe mf mg mh mi b">80</code>和<code class="fe mf mg mh mi b">8080</code>应该接受流量。</p><p id="242e" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">一旦我们运行下面的命令，所有的服务都将启动并运行。</p><pre class="mb mc md me gt mt mi mu mv aw mw bi"><span id="ecc5" class="kc kd iq mi b gy mx my l mz na">docker network create uid4oe<br/>docker-compose up -d</span></pre><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0c4451e06648125ff9fab969fd51e2b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*AX9bnAA4oZ3sbRe-6lr_Eg.png"/></div></figure><p id="d0a4" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">哇！那是一段相当长的旅程。非常感谢您抽出时间。所有必要的文件都在<a class="ae lt" href="https://github.com/uid4oe/microservices-go-grpc" rel="noopener ugc nofollow" target="_blank"> Github </a>中。我还添加了<a class="ae lt" href="https://github.com/uid4oe/microservices-kotlin-grpc" rel="noopener ugc nofollow" target="_blank"> Kotlin Spring </a>、<a class="ae lt" href="https://github.com/uid4oe/microservices-java-grpc" rel="noopener ugc nofollow" target="_blank"> Java Spring </a>版本。就功能而言，它们与Go版本相同。特别感谢珀西·博尔默回顾了这个故事。</p><p id="7c44" class="pw-post-body-paragraph ky kz iq la b lb lu ld le lf lv lh li kl lw lk ll kp lx ln lo kt ly lq lr ls ij bi translated">祝您愉快！</p></div></div>    
</body>
</html>