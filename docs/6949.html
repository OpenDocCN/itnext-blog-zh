<html>
<head>
<title>SwiftUI Case Study: Data modelling of Brotherhood Alchemist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI案例研究:兄弟会炼金术士的数据建模</h1>
<blockquote>原文：<a href="https://itnext.io/swiftui-case-study-brotherhood-alchemist-ed72bf8969ee?source=collection_archive---------0-----------------------#2022-04-22">https://itnext.io/swiftui-case-study-brotherhood-alchemist-ed72bf8969ee?source=collection_archive---------0-----------------------#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f0dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SwiftUI相对较新，我们iOS开发社区中的许多人仍在适应这种声明性语言。在SwiftUI中有很多简单的如何管理“状态”的例子，但是很少有实际的完全工作的应用程序例子。</p><p id="5ea8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将讲述我在使用SwiftUI &amp; Combine从零开始重写兄弟会炼金术士时学到的经验。我如何学会不对数据建模，以及它如何影响这个相对简单的应用程序的性能。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/03e5b2529a54abbd4eafcfeefba3d905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2H9TAvYn-180tPUdHPrZw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">黑暗兄弟会手形符号(用作应用程序图标)</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="0740" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">基本要求</h1><p id="12b9" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">Brotherhood Alchemist是一个iPhone/iPad应用程序，用户可以在其中选择想要的成分和效果，应用程序会列出所有可用的匹配炼金术配方。这是一款Skyrim(电脑游戏)的配套应用。</p><p id="db0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了达到这个效果，每种成分有四种效果；比如回复生命值，伤害耐力等等。兄弟会炼金术士的1.2版本捆绑了110种独特的成分，结合了55种独特效果中的4种。</p><p id="6337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每种效果或成分，用户能够指定结果屏幕中显示的食谱是否“必须具有”、“可能具有”或“不能具有”成分或效果。</p><p id="9e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，用户在其当前库存中可能没有任何“Nirnroot ”,因此他们可以将该成分设置为“不能有”。他们可能有多余的主根，或者只是在寻找包含主根的食谱，所以他们将其设置为“必须有”。其他允许但非绝对必要的成分设置为“可能有”。类似地，一个用户可能只寻找治疗药剂，所以他们设置“再生生命值”为“必须拥有”，设置“伤害生命值”为“不能拥有”。</p><p id="b513" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当所有的成分和效果都设置为“可能有”时，该应用程序会生成超过25，000种食谱。一个有效的配方是通过将两种或两种以上具有共同功效的配料相匹配而产生的。一些组合创造了多达5种效果的有效药剂。</p><h1 id="2e72" class="li lj iq bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">用户界面设计</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/13b369082431fc455cceba4d4d50dd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8RIYw3_gYCo2fuqVAtYNA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">风景版iPad上的兄弟会炼金术士</figcaption></figure><p id="9fa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在iPad上，设计相对简单。我们将屏幕分成三列:左边包含配料，右边包含效果，中间包含匹配的食谱。</p><p id="b3c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这个设计，我们有一个ContentView，它为每一列定义了一个带有自定义SwiftUI视图的HStack。</p><p id="4a83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个视图都由一个位于其根的VStack和一个ScrollView组成，VStack包含标题，scroll view本身包含LazyVStack和ForEach循环。</p><h1 id="feec" class="li lj iq bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">挑战</h1><p id="fb02" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们必须对数据建模并管理状态，以便可以在不影响效果列表的情况下切换成分(而不是重新绘制效果列表)。同样，我们希望能够切换效果，而不会导致成分列表被重新绘制。每当成分或效果被切换时，食谱列表应该被刷新。</p><p id="3d8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然SwiftUI有一些内置的状态比较逻辑来避免刷新，但我们将回顾可用于避免不必要的视图刷新的技术，以及在应用程序中管理和共享状态的不同方式。</p><p id="16a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将介绍我确定的将视图更新减少到最低限度的方法之一。</p><h1 id="2aa7" class="li lj iq bd lk ll ml ln lo lp mm lr ls lt mn lv lw lx mo lz ma mb mp md me mf bi translated">示例的来源</h1><div class="mr ms gp gr mt mu"><a href="https://github.com/ekscrypto/SwiftUI-Case-Study-Brotherhood-Alchemist" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">GitHub-ekscrypto/swift ui-案例研究-兄弟会-炼金术士:Medium.com的配套资源库…</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kv mu"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5e05" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第1部分—入门</h1><p id="25e6" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">首先，我们将创建我们的成分和效果基本类型。现在我们可以忽略成分和效果之间的联系。</p><p id="c883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们遵循一些“基本的”SwiftUI教程，我们可能会倾向于从ContentView中的@State变量开始。让我们从这一点开始，看看它会把我们引向何方。</p><p id="7b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将限制自己，现在只讨论IngredientsList和ContentView，看看它们是如何交互的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/610427a64e42e3bcbb8d3d6a57f45042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-M3ZJ4yMTiy0vp5SlhkCA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第1至第3部分测试应用的iPad预览</figcaption></figure><h2 id="45df" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">基本数据类型</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第1部分的DataTypes.swift</figcaption></figure><h2 id="1e96" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">内容视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第1部分的ContentView.swift</figcaption></figure><h2 id="a7e0" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料明细视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="71fc" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第1部分的IngredientsList.swift</figcaption></figure><h2 id="e708" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="fd60" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">点击配料时，ingredients列表中定义的按钮被触发，toggle(ingredient:)功能更新所选配料的数组。这又会导致重新处理IngredientsList和IngredientInfo视图之一。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第1部分的Xcode控制台日志</figcaption></figure><p id="b5cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，我们希望只对IngredientInfo进行重新处理，但是因为“selected”参数是从IngredientsList接收的，所以这是不可能的。</p><blockquote class="ny nz oa"><p id="de5c" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong> : SwiftUI足够智能，能够通过比较以前发送的参数和更新的参数，知道子视图是否需要处理。只有当参数不同时，才会重新处理子视图。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a8b4" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第2部分—将“选定”绑定到IngredientInfo</h1><p id="ef7f" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我想探索的一个解决方案是，是否有可能将IngredientsList中使用的@Binding“转发”到IngredientInfo，并让IngredientInfo执行切换和自我更新。</p><p id="f0a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然需要ContentView来保存@State变量，因为它需要能够在以后与Recipes列表共享该状态。让我们试一试，看看会发生什么。</p><h2 id="d5ea" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料明细视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第2部分的IngredientInfo.swift</figcaption></figure><p id="3948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="99de" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第5行:我们定义了@Binding。</li><li id="a676" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第9行:现在有了来自IngredientsList列表的按钮</li><li id="6f7f" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第13行:我们更新了如何检测成分是否被选中</li><li id="b904" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第19–25行:增加了切换(成分:)功能</li></ul><h2 id="6383" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第2部分的IngredientsList.swift</figcaption></figure><p id="fece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="674c" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">切换选择的按钮和代码不再存在</li><li id="05f2" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第16行:我们将@Binding转发给子视图。我们可以在这里使用Binding(projectedValue: …)或$selected，实现相同的行为。如果有人对最理想的语法有详细的了解，请随时发表评论！</li></ul><h2 id="4844" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="ac90" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">当点击其中一种配料时，现在在IngredientInfo中定义的按钮被触发，toggle(ingredient:)更新所选配料列表。</p><p id="6b4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次更新时不再处理IngredientList，而是刷新每个IngredientInfo视图。随着更多的成分和效果有待添加，这是不可取的。控制台清楚地显示了三个IngredientInfo，每当我们切换其中任何一个时，它们都会被更新。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第2部分的Xcode控制台日志</figcaption></figure><p id="b876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，多亏了LazyVStack，只有当前屏幕上的成分会被更新，即使我们有了110种成分。但理想情况下，我们希望更新单个IngredientInfo视图。</p><blockquote class="ny nz oa"><p id="cc5d" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:如果视图实际上从绑定中提取了任何数据，那么将@Binding转发给每个视图将导致当绑定的数据改变时，这些视图中的每一个都被处理。</p><p id="3f5d" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">额外的经验教训</strong>:当数据改变时，接收@Binding并简单地转发它不会导致视图被处理。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="cf8c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第3部分—在IngredientInfo中使用闭包</h1><p id="2b95" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">由于@Binding导致每个IngredientInfo视图在对所选成分的任何更改时被处理，因此我们可以为IngredientInfo提供一个闭包，让它更新自己的状态。</p><h2 id="a7d7" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料明细视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第3部分的IngredientInfo.swift</figcaption></figure><p id="fb2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="4bd8" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第5行:接收按钮被按下时要执行的动作</li><li id="6599" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第6行:定义@State变量来跟踪UI更新的选择状态</li><li id="8493" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第11行:用切换操作的结果更新我们的@State</li><li id="861a" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第14行:使用@State变量更新UI</li></ul><h2 id="9e60" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第3部分的IngredientsList.swift</figcaption></figure><p id="6427" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="1877" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第16行:向IngredientInfo提供按钮被按下时要执行的操作</li><li id="dd83" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第23–31行:实现切换选择的代码</li><li id="12c9" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">选择状态不再转发给IngredientInfo</li></ul><h2 id="adc0" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="7341" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">当点击一个成分时，IngredientInfo中的按钮执行它从IngredientsList收到的闭包。这反过来更新所选的配料，然后返回更新的选择状态。有了更新的状态，按钮的动作闭包中的代码现在可以更新它的状态了。</p><p id="30df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看日志，我们可能认为我们有一个可行的解决方案，因为只有IngredientInfo得到更新。因此，在下面的第4部分中，我们将添加更多的成分来巩固我们的解决方案。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第3部分的Xcode控制台日志</figcaption></figure><blockquote class="ny nz oa"><p id="9dca" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:我们可以为子视图提供一个闭包，而不是提供@Binding，在某些情况下，这可能足以阻止所有视图的刷新。</p><p id="2896" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">额外的经验教训</strong>:即使一个视图接收到一个@Binding并修改了它的内容值，如果该视图没有在它的视图构建器中使用一个值，当该值改变时，该视图将不会被重新处理。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="d375" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第4部分—更多成分</h1><p id="6d0a" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">基于我们在第3部分中的成功经验，让我们看看是否可以添加更多的成分并保持预期的行为。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/8d8c6236c567016322ded08071908a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udAiznn9HWpN5OdsHL_x_A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第4部分测试应用的iPad预览</figcaption></figure><h2 id="c80d" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">包含更多成分的内容视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第4部分的ContentView.swift</figcaption></figure><p id="00ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="fddc" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第4行:用100个动态生成的成分替换了3个成分</li></ul><h2 id="ab98" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="f43f" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">令人惊讶的是一切正常！老实说，当视图被滚动到屏幕之外时，我期望视图被释放。然而，一旦在LazyVStack中启动了一个视图，即使该视图不再可见，它的状态也会保持不变。</p><blockquote class="ny nz oa"><p id="6c59" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong> : LazyVStack只会实例化足够的视图来填充屏幕，但是会保持之前实例化的视图的状态，即使它们不再可见。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="4d8e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第5部分—过滤</h1><p id="0f51" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">现在我们已经解决了视图刷新问题，让我们看看是否可以实现成分过滤，以便用户可以快速找到所需的成分。</p><p id="3617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要通过添加一个文本字段来修改IngredientsList视图。在文本字段中输入的值将用于成分名称的部分匹配。为了使我们的生活更容易，我们将回到我们最初在第1、2和3部分中的3种成分的列表。</p><h2 id="5056" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第5部分的IngredientsList.swift</figcaption></figure><p id="550e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="e357" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第6行:一个新的@State变量，包含用户输入的过滤器</li><li id="b7df" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第8–14行:计算属性，用于轻松检索与过滤器匹配的成分</li><li id="7230" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第20行:添加Textfield来捕获用户的过滤器</li><li id="5a1c" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第23行:迭代过滤后的成分而不是配料</li></ul><h2 id="72f5" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="6eaa" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">我们的配料清单和预期的一样有效。每种成分都可以保持其状态，无论是过滤掉的还是可见的。</p><p id="6b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的原因是<strong class="jp ir">状态是基于每个id维护的</strong>。由于我们的配料的id(UUID)对于每种配料都是唯一的和永久的，因此LazyVStack/ForEach和SwiftUI能够跟踪每种配料的状态，并在过滤器更新时重新绘制视图。</p><blockquote class="ny nz oa"><p id="7d73" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:一旦一个视图被实例化，这个视图的状态就以每个Id为基础被保存。如果视图在将来的某个时候以相同的Id重新出现，那么在调用视图构建器之前，该视图的状态将被恢复。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="0a95" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第6部分—重置</h1><p id="71d8" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">兄弟会炼金术士应用程序提供了一些重置选项，但为了我们的案例研究，让我们假设重置按钮会将所有效果重置回未选中状态。</p><p id="dc89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这是在IngredientsList中定义的按钮，所以让我们看看是否可以简单地更新我们收到的@Binding，类似于我们如何切换配料。</p><h2 id="d27d" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第6部分的IngredientsList.swift</figcaption></figure><p id="811b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="8f3d" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第19–27行:用带有标题和重置按钮的HStack替换只包含“配料”标题的简单文本。</li><li id="139f" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第51–53行:将所有成分的状态重置为未选择的功能</li></ul><h2 id="2583" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="3b49" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">当列表出现时，如果我们切换成分，一切似乎都像预期的那样工作。然而，当我们按下重置按钮时，我们会注意到配料没有被重置。</p><p id="5034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为每个IngredientInfo都维护自己的@State，因此即使修改了@Binding，IngredientInfo视图上的可视指示器也不会重置。</p><p id="3d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以确认@Binding已被正确修改，方法是首先打开一个成分，点击reset按钮，然后尝试关闭该成分。因为当我们再次点击重置以切换配料时，已经通过点击重置取消选择了配料，所以在@Binding中，配料将从未选择变为已选择，并且IngredientInfo将再次显示为已选择。</p><p id="05d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，用户感到困惑，应用程序不再显示我们想要的状态。</p><blockquote class="ny nz oa"><p id="507f" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:当一个视图保持它自己的@状态时，它会与应用程序中发生的其他状态变化断开连接。</p></blockquote><p id="f376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在有效地尝试同时从两个不同的地方维护相同的状态。我们可以使用NotificationCenter通知或@Environment变量来通知每个视图应用程序的主状态已经改变。然而，如果可能的话，应该避免<strong class="jp ir">试图在多个地方同步状态</strong>。</p><p id="1788" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经知道，对每个IngredientInfo使用@Binding将导致在切换任何成分时处理每个IngredientInfo视图(参见第2部分)。</p><p id="45eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还知道，如果我们手动将选定的状态传递给IngredientInfo，将会重新处理IngredientList和受影响的IngredientInfo视图。</p><p id="a434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许我们可以调整我们的数据模型来跟踪所选择的状态。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="00fc" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第7部分—可观察物体</h1><p id="acfe" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">SwiftUI允许我们观察对象的变化。理论上，这应该允许一个对象实例被转发给所有视图，然后每个视图观察对象的状态。根据我们如何组织我们的数据模型，这可能是有用的，但它可能不会为我们选择的成分列表工作。</p><p id="8ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，让我们看看当我们试图将成分列表包装成一个可观察的对象时会发生什么</p><h2 id="e2f6" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">数据类型</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第7部分的DataTypes.swift</figcaption></figure><p id="f786" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="4e72" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第13–15行:添加了声明为ObservableObject的选定类</li><li id="7420" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第14行:@Published变量，以确保对象将正确地传播。成分更新时的objectWillChange()通知</li></ul><h2 id="73b5" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">内容视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第7部分的ContentView.swift</figcaption></figure><p id="fe17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><p id="8fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第10行:对于新选择的类，我们将@State变量替换为“let”。</p><h2 id="2da9" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">成分详细信息</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第7部分的IngredientInfo.swift</figcaption></figure><p id="b78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="00db" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第5行:用新选择的类定义了@ObservedObject</li><li id="e832" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第7–9行:正确计算生活质量，以方便检查当前是否选择了配料</li><li id="bb87" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第17行:使用computed属性更新UI</li><li id="1ff7" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第24–28行:更新了切换函数以更新所选的类对象</li></ul><h2 id="04de" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第7部分的IngredientsList.swift</figcaption></figure><p id="1a49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="449d" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第5行:我们不再收到所选成分的@ Binding替换为对我们选择类的简单“字母”引用</li><li id="09bb" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第35行:我们将选定的对象引用传递给IngredientInfo视图</li></ul><h2 id="eb65" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="e88d" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">复位功能最终按预期工作。成分的状态既可以由IngredientInfo切换，也可以由IngredientsList重置。但是，由于所选的类会在所选的成分发生变化时发布. objectWillChange()通知，并且每个IngredientInfo视图都使用@ObservedObject，因此我们会遇到刷新问题，即每当切换任何成分时，每个IngredientInfo视图都会更新。</p><blockquote class="ny nz oa"><p id="772c" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:如果我们的视图只对被观察对象的特定元素感兴趣，使用@ObservedObject可能会导致不必要的视图刷新。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="bcb0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第8部分—@发布时没有可观察对象</h1><p id="5c9a" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">SwiftUI视图可以为@Published属性定义onReceive observers，这允许视图定义一些自定义代码，这些代码可能更新也可能不更新视图的@State。</p><h2 id="5f0e" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">数据类型</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="1363" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第13行:我们的类不再需要符合ObservableObject</li></ul><h2 id="99d0" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">成分详细信息</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fa70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="9e5b" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第5行:删除了@ObservedObject修饰符</li><li id="6e74" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第7行:用@State变量替换了computed属性，用于UI更新</li><li id="97ce" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第19–24行:添加了一个接收观察器，用于检测所选成分的变化何时会产生@State变化。</li></ul><h2 id="4f5b" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="5b18" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">一切都像魔咒一样管用。IngredientInfo视图能够切换配料选择；IngredientList能够正确重置选择；并且仅更新受影响的视图。</p><blockquote class="ny nz oa"><p id="8cae" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:通过定义自定义观察器并实现您自己的逻辑来决定何时以及如何更改将影响视图的@State，可以避免ObservedObject的过度刷新</p><p id="0f36" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">学到的额外经验</strong>:您可以监视@Published属性，而不需要父类符合ObservableObject</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5fab" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第9部分—有状态成分</h1><p id="69e0" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">因为我们现在可以使用@Published只公开一个类的属性，所以让我们看看是否可以对我们的数据建模，以便向我们的组件公开一个. selected属性。</p><h2 id="e353" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">数据类型</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第9部分的DataTypes.swift</figcaption></figure><p id="289a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="8b4f" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">第3行:将struct更改为类</li><li id="998b" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第5行:添加@Published变量来保存选中的状态</li><li id="161e" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第8–10行:定义初始化器来设置name属性</li></ul><h2 id="591a" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">内容视图</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第9部分的ContentView.swift</figcaption></figure><p id="dfd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="98ed" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">删除了“让选择”,因为状态现在存储为配料对象的一部分</li><li id="f5d4" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">不再将“选定的”转发到成分列表</li></ul><h2 id="8aec" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">成分详细信息</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第9部分的IngredientInfo.swift</figcaption></figure><p id="a916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="4bb6" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">移除了isSelected @State变量</li><li id="3cb7" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第5行:添加了@State变量来指示SwiftUI何时更新视图</li><li id="8e4a" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第9行:从视图构建器中访问@State变量，否则它会被SwiftUI忽略，视图永远不会更新</li><li id="0951" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第14行:UI现在直接根据配料属性进行更新</li><li id="78c6" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第18行:。onReceive更新以观察成分的@Published属性，并在状态改变时简单地改变@State变量的值</li><li id="d1b7" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第24行:将切换逻辑简化为简单地翻转布尔值</li></ul><h2 id="9104" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">配料清单</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">第9部分的IngredientsList.swift</figcaption></figure><p id="8746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显著变化:</p><ul class=""><li id="1dc4" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">不再需要“让选定的”作为成分对象保持状态</li><li id="2592" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">不再需要将选定的配料转发给IngredientInfo</li><li id="7f1e" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">第41行:更新了重置函数来重置配料对象的状态</li></ul><h2 id="d2a5" class="nk lj iq bd lk nl nm dn lo nn no dp ls jy np nq lw kc nr ns ma kg nt nu me nv bi translated">观察到的行为</h2><p id="e91e" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">一切又一次如预期的那样工作。视图仅在需要时刷新。只要我们有配料的参考，就可以很容易地访问配料状态，并且可以很容易地从任何地方切换或重置。</p><blockquote class="ny nz oa"><p id="58bf" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">经验教训</strong>:仔细规划您的界面需要如何与您的数据交互，将允许您更新您的数据模型，使其更容易访问和观察。</p><p id="c024" class="jn jo ob jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated"><strong class="jp ir">额外的经验教训</strong> : SwiftUI通常与class一起使用比与struct一起使用更好，因为它允许在需要时单独观察@Published变量。而@Binding可能会触发不必要的视图刷新。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c5f7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="ad88" class="pw-post-body-paragraph jn jo iq jp b jq mg js jt ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ij bi translated">虽然在本文中我们没有重新实现Brotherhood Alchemist应用程序的整个逻辑，但我们确实学到了一些有价值的经验，希望能够帮助您创建更适合SwiftUI的数据模型。</p><p id="ee12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">必须小心使用ObservableObject，并且应该避免@Binding，因为它可能经常是糟糕的数据建模的标志。</p><p id="f312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在许多情况下，使用类而不是结构可以通过定义@Published属性来减少视图刷新的次数。</p><p id="50f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果因为不再使用@State变量而导致视图无法刷新，那么引入某种@State变量就相对容易了，您可以将它用作SwiftUI的更新触发器。</p><p id="fa98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇文章，并祝你编码的日子快乐！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="8a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好奇自己尝试兄弟会炼金术士？请登录苹果应用商店查看，网址为<a class="ae ot" href="https://apps.apple.com/app/brotherhood-alchemist/id1292251831" rel="noopener ugc nofollow" target="_blank">https://apps . Apple . com/App/brotherhood-alchemist/id 1292251831</a></p></div></div>    
</body>
</html>