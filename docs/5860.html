<html>
<head>
<title>My experiences with concurrency while writing an NPM package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在编写NPM包时的并发体验</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-every-core-on-your-machine-using-nodejs-c8083e498f9d?source=collection_archive---------1-----------------------#2021-06-13">https://itnext.io/how-to-use-every-core-on-your-machine-using-nodejs-c8083e498f9d?source=collection_archive---------1-----------------------#2021-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4a38" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用NodeJS来使用机器上的每个内核</h2></div><p id="4e09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每项工作都需要几秒钟才能完成，从长远来看，这是非常昂贵的。现在3000份工作不到一分钟！这是最后的结果。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/bcd2e932f675f056f4c675cee93a8b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*nIOjyp7FMFhnVn6oFISO7w.gif"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">决赛成绩</figcaption></figure><h1 id="1983" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">背景</h1><p id="bbdd" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">您可能使用过其他语言，这些语言具有开发人员友好的方式来多任务处理复杂的任务。不幸的是，用JavaScript实现这一点总是很复杂。</p><p id="aea3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在很长一段时间里，JavaScript和NodeJS都受到事件循环的限制。代码异步执行，但不是真正的并行方式。然而，随着NodeJS中工作线程的发布，这种情况发生了变化。</p><p id="71f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发现这个概念后，我立即想测试它的全部能力。不幸的是，现有的库过于复杂和/或缺乏真正的并行能力。</p><h1 id="d0f3" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">目标</h1><p id="6fbe" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">我想要一个非常适合小项目的包。它提供了一个不依赖于数据库或文件系统的作业队列，同时证明了明显的性能优势。</p><h1 id="5239" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">问题</h1><p id="a19e" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">许多包是并发的半生不熟的实现。例如，一些包的代码看起来像这样。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">并发但有致命缺陷</figcaption></figure><p id="31d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码是不正确的，因为它忽略了一些常见的边缘情况:</p><ul class=""><li id="390d" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld mu mv mw mx bi translated">如果池必须终止会发生什么？</li><li id="c3b7" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">如果作业数量少于线程数量，会发生什么情况？</li><li id="7a47" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">如果一项工作比另一项工作花费的时间长得多，该怎么办？</li></ul><p id="9d11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个问题是棺材上的钉子。如果大多数作业需要2秒钟来处理，但一个需要3小时，那么整个池必须等待3小时，直到所有工作线程都被释放。</p><p id="dd12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些库通过产生额外的工人来解决这个问题，但这意味着开发人员缺乏对工人数量的完全控制。该池应该是确定的。</p><h1 id="b09f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">初始解决方案</h1><p id="9548" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">既然<code class="fe nd ne nf ng b">Promise.all</code>是阻塞的，我立刻想到<code class="fe nd ne nf ng b">Promise.any</code>或者<code class="fe nd ne nf ng b">Promise.race</code>一定是真并行的答案，但是我错了。实际上，对于多任务处理来说，没有一个<code class="fe nd ne nf ng b">Promise</code>方法是足够的。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">没有你想的那么简单</figcaption></figure><p id="8c5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这么定了，<code class="fe nd ne nf ng b">Promise.race</code>很可能是解决方案，而<code class="fe nd ne nf ng b">Promise.any</code>是有缺陷的，因为<code class="fe nd ne nf ng b">Promise.any</code>必须成功完成至少一个承诺，否则就等着全部失败。</p><p id="61db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果除了一个耗时3小时的作业以外，所有作业都失败了，会发生什么？同样，在作业完成或导致<code class="fe nd ne nf ng b">Aggregate Error</code>之前，整个池必须等待3个小时。</p><p id="152a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，<code class="fe nd ne nf ng b">Promise.race</code>也不是正确的解决方案。当然，它解决了悬挂工人的问题，但还有另一个边缘情况。如果最快的承诺是唯一得到处理的，那么如何从多个工作人员那里检索结果呢？毕竟，快速并不总是正确的。</p><h1 id="3cbd" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">作业控制着线程</h1><p id="8dd3" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">解决<code class="fe nd ne nf ng b">Promise.race</code>问题的办法是工人自己。承诺何时解决并不重要，因为工人在后台运行。</p><p id="4c69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的解决方案是，每个工人从池中取一个线程id。当工作者完成执行时，它返回id。这允许池动态分配线程。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">控制一次允许多少工人</figcaption></figure><h1 id="3a3d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">跛的</h1><p id="3d50" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">最后一个目标是停止所有的池执行。即使有一个长达3小时的作业正在运行，它也会立即停止。老实说，这比承诺的其他问题更难解决。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">如何创造僵尸</figcaption></figure><p id="7e08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的第一直觉是拒绝承诺，但这是有问题的。我注意到通过<code class="fe nd ne nf ng b">reject</code>调用传递<code class="fe nd ne nf ng b">reasons</code>意味着<code class="fe nd ne nf ng b">Promise.race</code>只能解决<strong class="kk iu">一个</strong>T5】。然而，承诺所有的理由让我回到了绘图板。</p><p id="42a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更糟糕的是，拒绝承诺会使主事件循环终止，但工人会变成僵尸！3个小时后——工作人员的输出仍然堵塞着您的终端！</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">承诺终止以解决主事件循环</figcaption></figure><p id="2f1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢天谢地，我有了这个发现。线程必须显式终止工作线程。这使得终止过程完全确定，因此不会损害数据。承诺在工作承诺竞赛结束后解决。</p><h1 id="a7b7" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">项目成功！</h1><p id="cb35" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">所有的测试都通过了，我达到了我的目标！工人池在没有任何外部工具的情况下异步执行作业。它在NPM。如果你对如何使用图书馆感兴趣，请继续阅读！</p><pre class="lf lg lh li gt nh ng ni nj aw nk bi"><span id="8049" class="nl lr it ng b gy nm nn l no np">npm install jpool</span></pre><h1 id="a75a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">特征</h1><p id="7a5a" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">线程的数量是可变的，所有的状态都是确定的。作业要么通过，要么失败，要么停止。这允许池在没有僵尸或失控进程的情况下优雅地关闭或突然退出。</p><h1 id="f1e7" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">基本示例(Main.js)</h1><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">创建30个作业，一次运行8个</figcaption></figure><h1 id="d2a9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">续示例(Job.js)</h1><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">查找随机数的效率很低，但是异步作业的一个很好的例子</figcaption></figure><h1 id="7eda" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">看出区别了吧！</h1><p id="9ea8" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">每个终端窗口都在处理同一组作业。从左到右，程序分别使用1、8和256个工作线程。线程增加了内存使用，但是好处是值得的！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/26c11a99c45012bf44f0f258e36609e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*97R2xORE-gEiGSYi.gif"/></div></div></figure><h1 id="6c98" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结束了</h1><p id="571d" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">文档需要工作，否则，该软件包似乎对1.0.0版稳定。如果你想帮助，我接受PRs。感谢您的阅读！</p><div class="nv nw gp gr nx ny"><a href="https://github.com/wadez/jpool" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">瓦德兹/jpool</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">所有好的软件包名称都被采用。这个软件包允许你通过指定…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om lk ny"/></div></div></a></div></div></div>    
</body>
</html>