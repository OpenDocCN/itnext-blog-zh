<html>
<head>
<title>React: Class Component vs Functional Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:类组件与功能组件</h1>
<blockquote>原文：<a href="https://itnext.io/react-component-class-vs-stateless-component-e3797c7d23ab?source=collection_archive---------0-----------------------#2018-03-14">https://itnext.io/react-component-class-vs-stateless-component-e3797c7d23ab?source=collection_archive---------0-----------------------#2018-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a497f79055cc916230a4a0354bf5ec31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHPqOp2yWWJNZkEZAgKT8A.png"/></div></div></figure><p id="358a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Freact-component-class-vs-stateless-component-e3797c7d23ab" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="29ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大多数新的react开发人员通常会问这个问题:有什么不同，我应该使用哪一个？在本文中，我们将尝试了解基本的区别以及您应该使用哪一种。我们开始吧。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="7ddf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要了解这两个组件是什么:</p><p id="b0ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">功能性</strong>(又名<strong class="ka ir">无状态</strong>)组件只是一个普通的javascript函数，它将props作为一个参数并返回一个react元素。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b532" class="lo lp iq lk b gy lq lr l ls lt">const MyStatelessComponent = props =&gt; &lt;div&gt;{props.name}&lt;/div&gt;;<br/>// without JSX<br/>const MyStatelessComponent = props =&gt; React.createElement('div', null, props.name);</span></pre><p id="380f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无状态组件没有状态(很明显，不是吗？)，意思是你够不到里面的‘this . state’。它也没有生命周期，所以你不能使用componentDidMount和其他<a class="ae kw" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">钩子</a>。</p><p id="bc90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我说它应该返回一个react元素时，你可能还不清楚。React元素是一个有两个属性的对象(实际上更多，但是我们现在只对两个属性感兴趣):类型(字符串)，属性(对象)。我们的无状态组件的元素如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2df7" class="lo lp iq lk b gy lq lr l ls lt">{<br/>   type: 'div',<br/>   props: {<br/>     children: props.name,<br/>   }<br/>}</span></pre><p id="2466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当react渲染我们的无状态组件时，它所需要做的只是调用MyStatelessComponent函数并在那里传递属性。就是这样。</p><p id="7632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件类稍微复杂一点。它有一个状态，生命周期挂钩，它是一个javascript类，这意味着React创建它的实例。React应该初始化组件类，以便调用生命周期挂钩、调用构造函数、初始化状态等等。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0c25" class="lo lp iq lk b gy lq lr l ls lt">class MyComponentClass extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;{this.props.name}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="1bb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的无状态组件看起来的样子，如果它被写成一个组件类的话。React希望它从其呈现函数中返回一个react元素。如果我们比较render函数返回的内容和无状态组件函数返回的内容，我们会发现这两个元素是相同的。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="1dcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道有什么区别了，那么我们应该用哪个呢？</p><p id="9c3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道创建一个类的实例比调用一个函数花费更多的时间，对吗？如果我们渲染10000个无状态组件和类组件的元素会怎么样？哪一个会更快？我很惊讶，因为这两个渲染的渲染时间没有区别。其实是有的，只是微不足道，总是不一样。</p><p id="149f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://jsfiddle.net/69z2wepo/136096/" rel="noopener ugc nofollow" target="_blank">测试</a>。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/28d74f892b33e49a63fbf54e5fdbbf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*-lZQFWlGNcwCrAVILHbMhA.jpeg"/></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="69ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它没有我们预期的那么快，但是还有另一个区别——代码量。如果对于一个无状态组件代码，在将其转换为<a class="ae kw" href="https://babeljs.io/repl/" rel="noopener ugc nofollow" target="_blank"> ES5 </a>后看起来是这样的:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="90b1" class="lo lp iq lk b gy lq lr l ls lt">var MyStatelessComponent = function MyStatelessComponent(props) {<br/>  return React.createElement(<br/>    "div",<br/>    null,<br/>    props.name<br/>  );<br/>}</span></pre><p id="32b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件类应该是这样的:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="ee06" class="lo lp iq lk b gy lq lr l ls lt">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span id="fe17" class="lo lp iq lk b gy lv lr l ls lt">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }</span><span id="1aa0" class="lo lp iq lk b gy lv lr l ls lt">function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self; }</span><span id="6805" class="lo lp iq lk b gy lv lr l ls lt">function _inherits(subClass, superClass) { if (typeof superClass !== "function" &amp;&amp; superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }</span><span id="7494" class="lo lp iq lk b gy lv lr l ls lt">var MyComponentClass = function (_React$Component) {<br/>  _inherits(MyComponentClass, _React$Component);</span><span id="5918" class="lo lp iq lk b gy lv lr l ls lt">function MyComponentClass() {<br/>    _classCallCheck(this, MyComponentClass);</span><span id="93c9" class="lo lp iq lk b gy lv lr l ls lt">return _possibleConstructorReturn(this, (MyComponentClass.__proto__ || Object.getPrototypeOf(MyComponentClass)).apply(this, arguments));<br/>  }</span><span id="cc55" class="lo lp iq lk b gy lv lr l ls lt">_createClass(MyComponentClass, [{<br/>    key: "render",<br/>    value: function render() {<br/>      return React.createElement(<br/>        "div",<br/>        null,<br/>        this.props.name<br/>      );<br/>    }<br/>  }]);</span><span id="5ffd" class="lo lp iq lk b gy lv lr l ls lt">return MyComponentClass;<br/>}(React.Component);</span></pre><p id="6d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">差别挺大的吧？当然，在通过任何构建器(webpack，gulp，grunt)运行后，它会被缩小，但即使这样，差异仍然很大:1.2kb对97字节。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="c2b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道了性能方面的差异，但是我们还需要知道其他的差异吗？为什么有两种React组件类型而不是一种？现在让我们试着回答这个问题:</p><p id="3519" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么时候应该使用无状态组件:</p><p id="b36f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无状态组件(或哑组件)只是状态的表示(道具)。它只能渲染道具，它应该只做这个。一个很好的例子是一个按钮组件:假设我们有一个按钮需要特别设计，所以我们创建一个按钮无状态组件，如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e614" class="lo lp iq lk b gy lq lr l ls lt">const Button = props =&gt; (<br/>   &lt;button className="our_button" onClick={props.onClick}&gt;</span><span id="264c" class="lo lp iq lk b gy lv lr l ls lt">      {props.label}<br/>   &lt;/button&gt;<br/>);</span></pre><p id="10d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要在一个按钮组件中有一个状态、生命周期挂钩或任何内部变量，你只需要简单地呈现它们。</p><p id="3a36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么时候应该使用类组件:</p><p id="96c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你需要处理状态时，应该使用一个类组件，它可能是redux、relay或内部react状态。每当您需要在呈现组件之前获取数据时，您都应该在componentDidMount中调用一个fetch data函数，以确保您的数据会尽快被获取。你不能在渲染函数中使用任何副作用，所以你应该在生命周期钩子中使用副作用。所以规则应该是:如果你的组件需要一些数据，而这些数据不能作为一个属性传递，那么使用类组件来获取这些数据。如果您需要在组件(可扩展块)中保存UI状态，那么在组件状态中保存该信息是一个好地方。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="95e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结论。简单回顾一下:一个功能组件没有状态，没有生命周期方法，很容易编写(普通函数)，一个类组件有状态，生命周期方法，React每次渲染时都会创建一个类组件的实例。如果你不需要使用状态或生命周期，我会推荐你使用函数组件，但是如果你需要其中的一个(状态，生命周期方法)，我会建议你使用类组件。</p><p id="2991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请鼓掌并分享:)</p></div></div>    
</body>
</html>