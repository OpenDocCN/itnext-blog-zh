<html>
<head>
<title>Terragrunt — Using credentials dynamically and Azure multi-subscription support</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terragrunt —动态使用凭证和Azure多订阅支持</h1>
<blockquote>原文：<a href="https://itnext.io/terragrunt-using-credentials-dynamically-and-azure-multi-subscription-support-fa770506c913?source=collection_archive---------3-----------------------#2020-12-21">https://itnext.io/terragrunt-using-credentials-dynamically-and-azure-multi-subscription-support-fa770506c913?source=collection_archive---------3-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="69da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博客中，我将结合几个相关的主题:</p><ul class=""><li id="2360" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">多帐户/多订阅支持—将部分环境部署到不同的订阅</li><li id="2e31" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">对基础架构的各个部分使用不同的凭据—允许在部署环境的各个部分时遵循最低权限方法</li></ul><p id="7888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博客扩展了之前讨论依赖性管理的内容。</p><h1 id="42af" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">多帐户/多订阅支持</h1><p id="2fa9" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在管理企业规模的云环境时，将它划分为功能块非常重要，这样可以实现职责分离并最大限度地减小爆炸半径。因此，平台管理、网络、身份、审计等核心组件应在单独的订阅中进行管理。</p><p id="76d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将资源部署到不同的Azure订阅，可以将环境变量传递给Terraform，并让它进行相应的身份验证。在下面的代码片段中，有3个感兴趣的地方:</p><ul class=""><li id="e0c3" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">凭证检索的依赖性(将在本文后面讨论)</li><li id="d518" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">凭据的环境变量(ARM_TENANT_ID、ARM_CLIENT_ID、ARM_CLIENT_SECRET)</li><li id="5fc6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">用于固定部署的订阅。设置ARM_SUBSCRIPTION_ID的值</li></ul><p id="88c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">extra_arguments部分需要特别注意。基本上，这个配置要求在调用下面的Terragrunt命令(init、apply、destroy等)时注入4个环境变量。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3122" class="ml la iq mh b gy mm mn l mo mp"># Snippet Area #1 - Required to switch to appropriate identity<br/>dependency "credentials" {<br/>  config_path = "../credentials"<br/>}</span><span id="df4a" class="ml la iq mh b gy mq mn l mo mp">terraform {<br/>  source = "git::ssh://<a class="ae mr" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>/xxxxxxx/terraform-azurerm-core-iam.git"</span><span id="491c" class="ml la iq mh b gy mq mn l mo mp">extra_arguments "force_subscription" {<br/>    commands = [<br/>      "init",<br/>      "apply",<br/>      "destroy",<br/>      "refresh",<br/>      "import",<br/>      "plan",<br/>      "taint",<br/>      "untaint"<br/>    ]</span><span id="3c1e" class="ml la iq mh b gy mq mn l mo mp"># Snippet Area #2 - Passing environment variables to Terraform<br/>env_vars = {<br/>      ARM_TENANT_ID     = dependency.credentials.outputs.tenant_id<br/>      ARM_CLIENT_ID     = dependency.credentials.outputs.client_id<br/>      ARM_CLIENT_SECRET = dependency.credentials.outputs.client_secret</span><span id="8ef2" class="ml la iq mh b gy mq mn l mo mp"># Snippet Area #3 - Passing the subscription ID to deploy resources</span><span id="37f3" class="ml la iq mh b gy mq mn l mo mp">ARM_SUBSCRIPTION_ID = local.config.management.subscription_id<br/>    }<br/>  }<br/>}</span></pre><p id="f080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要错过命令数组中的任何重要操作，这一点很重要。我最初从列表中省略了“destroy ”,这意味着Terraform正在使用我的登录凭证和固定订阅。因此，如果我将我的默认订阅设置为不同于terraform状态的订阅，它将刷新状态，并意识到所有资源都已被“删除”,并将它们从状态中删除……因此在订阅中留下了混乱，我必须手动清理。我的伤疤是你的警告！</p><h1 id="1678" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">动态凭证检索</h1><p id="1ec4" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">当您将各种组件部署到多个订阅时，您可以使用一个具有完全权限的服务主体，也可以将其分解为多个具有更严格访问权限的服务主体。后者是优选的，以遵循最小特权原则，并在凭证被泄露或操作员失误的情况下减小爆炸半径。</p><p id="b0c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我必须设计一种从Azure DevOps动态检索凭证的方法。因为我正在使用Terraform和Terragrunt，所以我选择了一个感觉像Terraform本地的解决方案。我还想避免将此任务委托给带有DevOps marketplace插件的Azure DevOps，以防我们的一些客户使用另一个CICD工具。</p><p id="e611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我构建了一个凭证获取器，它将从Azure密钥库中检索3个秘密，以表示租户id、客户端id和客户端秘密。这个地形模块接受2个变量并输出3个值。</p><figure class="mc md me mf gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/1a651aa844f15ab446af95e663f59f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZfUESg4Td3qLyGVINa84Q.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">凭证提取器输入和输出</figcaption></figure><p id="368c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是Terraform模块设计的示意图。可能是你能建造的最简单的地形模块之一！</p><figure class="mc md me mf gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/4d861c2c1cb03cf5bbc837090e5dc0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbmJZMAlyh5p4bHWVicaRg.png"/></div></div></figure><p id="99b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用凭据获取器，部署必须设置对凭据获取器的依赖关系。然后它的输出可以作为环境变量传递。如果您参考上面的代码片段，请参见<em class="nf">片段区域#2 </em>。</p><h1 id="c37f" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">含义和安全性</h1><p id="98a7" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">Terraform部署使用状态文件来捕获模块的实时状态，包括输入、所有受管理对象的详细信息以及模块输出的值。由于来自Azure Key Vault的值是敏感的，所以通过状态文件将它们放在文件系统上并不理想。因此，应该对文件系统进行加密，启用传输加密，并且从RBAC的角度来看，非常严格地限制访问。此外，每次运行后，应该清理本地临时文件，以防止留下敏感内容。</p><p id="8059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我希望每个部署只在内存中保存这些值，但是这将增加每个模块获取凭证的复杂性。</p><p id="53b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们本可以将凭证检索转移到Azure DevOps并传递它们。但这将使代码特定于Azure DevOps，并且不容易为不同的组件检索不同的凭证。我们最终会在整个基础设施的每个区域设置一条管道……我可能会在某个时候回到这个问题，避免地形状态问题。</p></div></div>    
</body>
</html>