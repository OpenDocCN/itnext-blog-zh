<html>
<head>
<title>An illustrated guide to Kubernetes Networking [Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes网络图解指南[第2部分]</h1>
<blockquote>原文：<a href="https://itnext.io/an-illustrated-guide-to-kubernetes-networking-part-2-13fdc6c4e24c?source=collection_archive---------0-----------------------#2017-11-29">https://itnext.io/an-illustrated-guide-to-kubernetes-networking-part-2-13fdc6c4e24c?source=collection_archive---------0-----------------------#2017-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fe47" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我所知道的关于Kubernetes网络的一切</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81e59b7eb15f5fa97cbecb11d137ff45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBYlyYsz0NsWHvh1lpUbzw.png"/></div></div></figure><p id="a5b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">这是Kubernetes网络系列的第二部分。如果你还没有阅读第一部分</em><a class="ae lo" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727" rel="noopener"><em class="ln"/></a><em class="ln">，我建议你先看看。</em></p><p id="d454" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae lo" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727" rel="noopener">在本系列的前一集</a>中，我们介绍了Kubernetes网络模型。我们观察了数据包如何在同一个节点上的pod中流动，以及如何在节点之间流动。我们还注意到linux网桥和路由表在这个过程中扮演的角色。</p><p id="d27e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我们将扩展这些想法，看看覆盖网络是如何工作的。我们还将了解不断变化的pod是如何从Kubernetes中运行的应用程序中抽象出来并在幕后处理的。</p><h1 id="b5e2" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">覆盖网络</h1><p id="3f98" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">默认情况下，覆盖网络不是必需的，但是，它们在特定情况下会有所帮助。比如当我们没有足够的IP空间，或者网络无法处理额外的路由。或者当我们需要叠加层提供的一些额外的管理功能时。一个常见的情况是云提供商路由表能够处理的路由数量有限。例如，AWS路由表支持多达50条路由，而不会影响网络性能。所以如果我们有超过50个Kubernetes节点，AWS路由表就不够用了。在这种情况下，使用覆盖网络会有所帮助。</p><p id="5512" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它实质上是封装了一个包中包，该包在节点间遍历本地网络。您可能不希望使用覆盖网络，因为它可能会由于所有数据包的封装-解封装而导致一些延迟和复杂性开销。它经常是不需要的，所以我们应该在知道为什么需要它的时候才使用它。</p><p id="72f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了理解流量如何在覆盖网络中流动，让我们考虑一个<a class="ae lo" href="http://github.com/coreos/flannel" rel="noopener ugc nofollow" target="_blank">法兰绒</a>的例子，这是CoreOS的一个开源项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/ce40c698a209743d5d98d2576f354516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fWJXnaM4m2dnYUPtMtpMiw.gif"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">带有路由表的Kubernetes节点<br/>(带有法兰绒覆盖网络的跨节点pod-to-pop流量)<br/>【点击放大可获得更清晰的图像】</figcaption></figure><p id="ef02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们看到它与之前的设置相同，但是在根网络中添加了一个名为flannel0的新虚拟以太网设备。它是虚拟可扩展局域网(VXLAN)的一个实现，但对于linux来说，它只是另一个网络接口。</p><p id="33b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数据包从<code class="fe mr ms mt mu b">pod1</code>到<code class="fe mr ms mt mu b">pod4</code>(在不同的节点上)的流程如下:</p><p id="1ed5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.数据包在<code class="fe mr ms mt mu b">eth0</code>离开<code class="fe mr ms mt mu b">pod1</code>的网络，在<code class="fe mr ms mt mu b">vethxxx</code>进入根网络。</p><p id="f899" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.它被传递给<code class="fe mr ms mt mu b">cbr0</code>，使ARP请求找到目的地。</p><p id="58a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3a。由于该节点上没有人拥有<code class="fe mr ms mt mu b">pod4</code>的IP地址，网桥将其发送到<code class="fe mr ms mt mu b">flannel0</code>，因为该节点的路由表被配置为将<code class="fe mr ms mt mu b">flannel0</code>作为pod网络范围的目标。</p><p id="ee0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3b。当flanneld守护进程与Kubernetes apiserver或底层etcd对话时，它知道所有的pod IPs，以及它们在什么节点上。所以法兰绒创建了pods IPs到node IPs的映射(在用户空间中)。</p><p id="51c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mr ms mt mu b">flannel0</code>获取此数据包，并将其封装在UDP数据包中，其中额外的报头将源和目的IP更改为相应的节点，然后将其发送到一个特殊的vxlan端口(通常为8472)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/2120106b6bdf87da66a2081e30ca5d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85eyU_ZNZbJXTBrqklRyLg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">包中包封装<br/>(注意，在上图中，包是从3c封装到6b的)</figcaption></figure><p id="44d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使映射是在用户空间，实际的封装和数据流发生在内核空间。所以它发生得很快。</p><p id="2d16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3c。封装后的数据包通过<code class="fe mr ms mt mu b">eth0</code>发送出去，因为它参与了节点流量的路由。</p><p id="e1bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">4.数据包离开以节点IP为源和目的地的节点。</p><p id="c402" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">5.云提供商路由表已经知道如何在节点之间路由流量，因此它将数据包发送到目的地<code class="fe mr ms mt mu b">node2</code>。</p><p id="593d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6a。数据包到达节点2的<code class="fe mr ms mt mu b">eth0</code>。由于端口是特殊的vxlan端口，内核将数据包发送到<code class="fe mr ms mt mu b">flannel0</code>。</p><p id="d9ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6b。<code class="fe mr ms mt mu b">flannel0</code>解封装并将其发送回根网络名称空间。</p><p id="f127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从这里开始，路径与我们在<a class="ae lo" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727" rel="noopener">第1部分</a>中看到的非覆盖网络的情况相同。</p><p id="a790" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">6c。由于启用了IP转发，内核根据路由表将其转发给<code class="fe mr ms mt mu b">cbr0</code>。</p><p id="ddd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">7.网桥接收数据包，发出ARP请求，并发现该IP属于<code class="fe mr ms mt mu b">vethyyy</code>。</p><p id="9555" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">8.数据包穿过管道对到达<code class="fe mr ms mt mu b">pod4</code>🏠</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="1b7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不同的实现之间可能会有细微的差别，但这就是Kubernetes中覆盖网络的工作方式。有一种常见的误解，认为我们在使用Kubernetes时需要使用覆盖。事实是，这完全取决于具体的场景。所以确保你只在绝对需要的时候使用它。</p><p id="e40c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前就这些。在<a class="ae lo" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727" rel="noopener">前一部分</a>中，我们学习了Kubernetes网络的基础。现在我们知道了覆盖网络是如何工作的。在接下来的部分中，我们将看到<a class="ae lo" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-3-f35957784c8e" rel="noopener">随着pod的出现和消失，网络会发生什么变化，以及出站和入站流量是如何流动的</a>。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="ff9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，我对网络概念还很陌生，所以我希望得到反馈，尤其是当有不清楚或错误的地方🙂</p><blockquote class="nd"><p id="693f" class="ne nf iq bd ng nh ni nj nk nl nm lm dk translated">我将在<a class="ae lo" href="http://events.linuxfoundation.org/events/kubecon-and-cloudnativecon-north-america" rel="noopener ugc nofollow" target="_blank"> KubeCon North America 2017 </a>上发表演讲，讲述我在Kubernetes生产中遇到的其他<a class="ae lo" href="http://sched.co/CU8P" rel="noopener ugc nofollow" target="_blank">网络概念和UDP故障</a>，以及我是如何调查和修复它们的。</p><p id="1990" class="ne nf iq bd ng nh ni nj nk nl nm lm dk translated">如果你参加了，来打个招呼或者在推特上打电话给我</p></blockquote></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="f114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi">-</p></div></div>    
</body>
</html>