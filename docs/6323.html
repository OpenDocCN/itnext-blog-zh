<html>
<head>
<title>FaaS-like Spring microservices with autoscaling in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中具有自动缩放功能的类似FaaS的Spring微服务</h1>
<blockquote>原文：<a href="https://itnext.io/faas-like-spring-microservices-with-autoscaling-in-kubernetes-1dcd21c5d06f?source=collection_archive---------4-----------------------#2021-10-17">https://itnext.io/faas-like-spring-microservices-with-autoscaling-in-kubernetes-1dcd21c5d06f?source=collection_archive---------4-----------------------#2021-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e2c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程展示了如何创建一个基本的应用程序，演示了编写简单的“基于功能的微服务”的方法。它解释了如何创建这样的微服务，以及如何部署它们、设置自动伸缩、收集指标和跟踪。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/0e196272aad41cf60c7880fbf59360d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*LyOLYsfI_5IjNt0IxiDV2A.png"/></div></figure><p id="c639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法对于进行大规模事件处理可能非常强大，同时在基础架构的所有权和部署的复杂性之间提供了很好的平衡。</p><p id="a96a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目代码:</p><p id="6a72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example" rel="noopener ugc nofollow" target="_blank">https://github.com/oleksiyp/faas-like-services-example</a></p><h1 id="5fe8" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Java函数</h1><p id="a89b" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">为了运行事件流微服务，我们将使用Spring Cloud Stream框架。</p><p id="719d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring Cloud Stream基于Spring Cloud Function framework——一种将业务逻辑构建为Java“函数”并在无服务器平台上独立运行或使用PaaS运行的框架统一方式。</p><p id="e155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring Cloud Stream通过增加将功能绑定到消息代理的能力，扩展了Spring Cloud的功能。支持以下消息代理:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/17bb32cf307be3ffe460cf104d465880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*JC4saqZ_VBYCStwSMXcaVg.png"/></div></figure><p id="3fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，Spring Cloud Stream可以作为Spring Cloud数据流的一部分。但是这篇文章的目的是要表明，在Kubernetes中建立基础设施来运行这样的微服务<strong class="jp ir">是很容易的，而不需要像Spring Cloud Data Flow这样的数据处理框架，这大大增加了部署的复杂性，并将Kubernetes的功能隐藏在它自己的部署适配器之后。</strong></p><h1 id="9b17" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">技术选择</h1><p id="ef2d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">要构建演示解决方案，将使用以下堆栈:</p><ul class=""><li id="915c" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><a class="ae kt" href="https://pop.system76.com/" rel="noopener ugc nofollow" target="_blank">流行！_OS </a>基于Linux的机器</li><li id="335f" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> k3s </a> —易于设置Kubernetes集群(可以使用任何其他Kubernetes)</li><li id="5319" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://www.rabbitmq.com/kubernetes/operator/operator-overview.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ集群操作员</a>—部署RabbitMQ消息代理的操作员</li><li id="d57a" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://spring.io/projects/spring-cloud-stream" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Stream </a> —一个将函数绑定到RabbitMQ的框架</li><li id="3ecd" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://spring.io/projects/spring-cloud-sleuth" rel="noopener ugc nofollow" target="_blank"> Spring Cloud Sleuth </a> —追踪消息的框架</li><li id="9ca0" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot执行器</a> —一种提供指标和活性&amp;就绪信息的方式</li><li id="7928" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank">KEDA</a>—Kubernetes auto scaler基于各种现成的指标</li><li id="233c" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank"> Gradle </a> — Java构建工具</li><li id="a437" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank">ska fold</a>—一个向Kubernetes集群执行快速本地部署的工具</li><li id="3c54" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/roboll/helmfile" rel="noopener ugc nofollow" target="_blank"> Helmfile </a> —定制和部署舵图的工具</li><li id="8cf3" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://tanzu.vmware.com/observability" rel="noopener ugc nofollow" target="_blank"> Wavefront </a> —收集指标和跟踪信息的商业监控工具</li></ul><h1 id="af42" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">演示应用程序的概念</h1><p id="6380" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example" rel="noopener ugc nofollow" target="_blank">演示应用</a>由4个微服务组成:</p><ul class=""><li id="e88e" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><code class="fe mm mn mo mp b">streaming-producer</code> —每秒发出一次消息的微服务</li><li id="1fb8" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">streaming-processor1</code> —微服务，增加2秒的延迟，同时稍微修改消息</li><li id="c3b0" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">streaming-processor2</code> —微服务，增加3秒的延迟，同时稍微修改消息</li><li id="e454" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">streaming-consumer</code> —使用消息并将它们转储到标准输出，不应用延迟。</li></ul><p id="f489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法是处理器比生产者慢，而且慢的速度不同。这为自动缩放设置创造了一个很好的测试。</p><p id="3951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将看到，自动伸缩将根据处理速率和生产率自动调整处理负载的处理器实例数量。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/069b324e59327fb55fb7a9a8fd6608ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iAnK78wcqX9BgWl9mkmB7Q.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">生产者、加工者和消费者</figcaption></figure><p id="bc8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生产者微服务代码如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/420d48dd48ee3fee25d2aa1e7b4b781a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*YeC7RXhSPT7XEGv0gQQFlw.png"/></div></figure><p id="4424" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，这创建了一个微服务，该微服务产生一个消息，该消息的名称字段包含递增的计数器。消息速率可通过Spring Cloud Stream属性进行配置，默认情况下等于每秒一条消息。</p><p id="b30b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理器#1微服务代码如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1ee961fbef2cc6da502cc6b56be290a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*DZMJkTP-LO2b5nYFQ_BXug.png"/></div></figure><p id="e9ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它在“name”字段前面加上“processor1:”字符串，并增加了2秒的延迟。</p><p id="a737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理器#2微服务的代码与处理器#1微服务的代码相同，但使用3秒延迟和其他前置字符串“处理器2:”。</p><p id="8d9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">消费者微服务代码如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/120a4c467557fad454d6866daaa1ae57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*tTXEQusLF_zsCwQ1FELP4g.png"/></div></figure><p id="569c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它唯一做的事情是将收到的每条消息发布到标准输出。</p><p id="3f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring stack将处理将基于lambdas的“函数”、“供应商”和“消费者”绑定到消息队列、数据格式转换(JSON)、重试逻辑、死信队列处理等所有复杂问题。唯一需要的是正确配置这种微服务。</p><p id="71c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">演示应用程序存储库包含:</p><ul class=""><li id="ffae" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><code class="fe mm mn mo mp b">build.gradle</code> — Gradle项目文件，打造Spring微服务</li><li id="4d11" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">helmfile.yaml</code> —用于部署整个应用程序的文件</li><li id="2606" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">skaffold.yaml</code>—ska fold工具在手表环路中部署的配置</li><li id="71ca" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">helm/rabbitmq-cluster</code> —通过RabbitMQ集群操作员部署RabbitMQ集群的舵图</li><li id="be8f" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mm mn mo mp b">helm/streaming-service</code> —部署Spring微服务的舵图</li></ul><h1 id="051b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用KEDA自动缩放</h1><p id="d5d5" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">KEDA允许根据收集的指标扩展微服务实例。</p><p id="cdc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于RabbitMQ，Kubernetes的定义如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/6f14302474d6a3768725db450fac3d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*1AoiBNxNPO3QVaUvVF5mFw.png"/></div></figure><p id="2458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为RabbitMQ中的队列建立了一个缩放对象。凭证和群集地址存储在关联的机密文件中。KEDA将从RabbitMQ中获取队列的大小，将其除以threshold( <code class="fe mm mn mo mp b">value</code>字段)，并推断出要创建多少个实例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/5684538760959fa557b0a934f05dfdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yqM--8ddlh66apTnCcr2Q.png"/></div></div></figure><p id="f67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为实例的数量取决于队列大小，这意味着自动缩放将适应输入速率与处理速率的比率。如果处理速度比输入速度快，那么队列将会增长，从而产生更多的实例。如果输入速率下降，队列被处理，实例被自动缩放器删除。</p><p id="7fd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许为两个不同速度的流独立地调整处理速率。此外，如果队列为空一分钟，KEDA会将所有实例的数量缩减为零。</p><h1 id="f604" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">测试自动缩放</h1><p id="e9f4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">让我们用这个设置做一点实验。</p><p id="fb5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将只改变一个数字——一个生产者的复制品的数量，一个<code class="fe mm mn mo mp b">helmfile.yaml</code>中的<code class="fe mm mn mo mp b">replicaCount</code>值</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/57a5c2496082e0cd420a2d77cbf996d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*L4suJ9fkObwEVdvVJDNvww.png"/></div></figure><p id="76be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们将其设置为<code class="fe mm mn mo mp b">0</code>并部署<code class="fe mm mn mo mp b">skaffold dev</code></p><p id="0d6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将看到初始部署将不会部署任何生产者，而是非常快速地终止处理器:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nf"><img src="../Images/c6258861832b183c87fc20fc5101e373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hl8ffXVT6uqyBx2AiuryzQ.png"/></div></div></figure><p id="6b1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将<code class="fe mm mn mo mp b">replicaCount</code>设置为<code class="fe mm mn mo mp b">1</code>:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ng"><img src="../Images/c438c00562672b88ba46158da9944664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FaD6RMXbrpmf6cWzx_QvmQ.png"/></div></div></figure><p id="ba32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始时，生产者将在生产者启动后几乎立即运行到处理器<code class="fe mm mn mo mp b">10 </code>秒，但是由于处理器的消耗率小于生产者的生产，队列将开始累积消息，最后，系统将随着更少的pod而稳定下来:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nh"><img src="../Images/b45c17d9135333bdd704643b252f2ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgJuK5bixYUzuFS0oZ2j0g.png"/></div></div></figure><p id="27e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，由于不同的利率，更多的豆荚发行。总共两个处理器组以<code class="fe mm mn mo mp b">0.5 RPS</code>的速率运行，三个处理器组以<code class="fe mm mn mo mp b">0.333 RPS</code>的速率运行，这允许以<code class="fe mm mn mo mp b">2 RPS</code>的汇总速率处理最初产生的流。</p><p id="e4fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到队列中充满了一定数量的消息:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ni"><img src="../Images/14ffc7dca5dac4e0420207af9e37f6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1bZoagDWK3aPZF7AbqBtg.png"/></div></div></figure><p id="db8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过将ScaleObject改为与<code class="fe mm mn mo mp b">queue length</code>一起使用<code class="fe mm mn mo mp b">message rate</code>来清空队列。队列长度是一个非常灵活的度量标准，但总是使队列大小随着消息速率线性增长。将<code class="fe mm mn mo mp b">messages rate</code>配置为扩展触发器需要对每个微服务的速率阈值进行更复杂的调整。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nj"><img src="../Images/d9e7fc87b0a6bb902d1cd99d5a06218f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDPMat5SL2RHt4FxwWRH_Q.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">从<code class="fe mm mn mo mp b">0</code>副本计数切换到副本计数1时的呼叫率</figcaption></figure><p id="77fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们向生产者容器中再添加一个副本。一段时间后，pod将扩展到稳定状态:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nk"><img src="../Images/642e29f75f3ca76e160ca9c5e9ce0342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xOlXEUj8F5Qcw0sc0Lueg.png"/></div></div></figure><p id="2c02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到费率得到了适当的调整:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nl"><img src="../Images/6a89ef103480a541703d276fea093c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*854h7uf0D3PRloSjsvanDw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">副本计数转换1到2</figcaption></figure><p id="2979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再添加一个生产者的复制品:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nm"><img src="../Images/99282b84fcacf014d8e611022151f836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KMFdzzW5J1HIgUAGNq9rxw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">副本数量从2变为3</figcaption></figure><p id="8979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们按比例缩小生产者:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nj"><img src="../Images/5d80bb5ac8fbbbd04593b38292913330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KVIqmB0E5Ar5ETCChLFrOA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">将副本从2扩展到1再扩展到0</figcaption></figure><p id="211b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，您可以看到生产者和两个处理器被拆除:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nn"><img src="../Images/fad177b02b568eb048d73253a1a6d2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGRmDnK3_t-eNuIQGTIk8g.png"/></div></div></figure><p id="4a2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着当不存在输入消息时，不分配任何资源。</p><h1 id="bee2" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">源代码</h1><p id="602d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">关键文件:</p><ul class=""><li id="81d6" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/helmfile.yaml" rel="noopener ugc nofollow" target="_blank">helm file . YAML</a>—helm file将解决方案部署到Kubernetes的配置</li><li id="44b3" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/skaffold.yaml" rel="noopener ugc nofollow" target="_blank"> skaffold.yaml </a> —快速开发循环的配置skaffold观察器</li><li id="3a93" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/streaming-lib/build.gradle" rel="noopener ugc nofollow" target="_blank">build . gradle</a>——所有微服务使用的公共库的构建文件，由于Spring的依赖性，它非常有价值</li><li id="46cc" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/helm/rabbitmq-cluster/templates/cluster.yaml" rel="noopener ugc nofollow" target="_blank"> cluster.yaml </a> —简单RabbitMQ集群部署的配置</li><li id="3c0d" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/helm/streaming-service/templates/scaling.yaml" rel="noopener ugc nofollow" target="_blank">scaling . YAML</a>—Kubernetes自动声明的配置</li><li id="0fab" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/streaming-producer/src/main/java/app/StreamingProducerApp.java" rel="noopener ugc nofollow" target="_blank">StreamingProducerApp.java</a>—生产商代码</li><li id="06de" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/streaming-processor1/src/main/java/app/StreamingProcessor1Application.java" rel="noopener ugc nofollow" target="_blank">StreamingProcessor1App.java</a>—处理器#1代码</li><li id="2405" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/streaming-processor2/src/main/java/app/StreamingProcessor2Application.java" rel="noopener ugc nofollow" target="_blank">StreamingProcessor2App.java</a>—处理器#2代码</li><li id="473e" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><a class="ae kt" href="https://github.com/oleksiyp/faas-like-services-example/blob/master/streaming-consumer/src/main/java/app/StreamingConsumerApplication.java" rel="noopener ugc nofollow" target="_blank">StreamingConsumerApp.java</a>—消费者代码</li></ul><h1 id="8503" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="d304" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">您可能有很多理由想要创建这样一个基于消息代理、函数和自动缩放器的事件驱动系统。</p><p id="262b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个是在PaaS级别上运行，您在构建复杂系统时有很大的灵活性。您可以使用大量适合您需求的现成解决方案来增强系统，并将它们紧密集成。</p><p id="e48f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RabbitMQ、KEDA和Spring Cloud Stream都是久经考验的产品，拥有良好的声誉。这使得它们非常适合系统的核心组件。</p><p id="c508" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结合Kubernetes丰富的Helm部署机会，这可能会产生一个非常敏捷和灵活的FaaS式系统。</p></div></div>    
</body>
</html>