<html>
<head>
<title>Mini Video Encoder part 1, the engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迷你视频编码器第1部分，引擎</h1>
<blockquote>原文：<a href="https://itnext.io/mini-video-encoder-implementation-part-1-1fce5fb081c1?source=collection_archive---------7-----------------------#2020-01-12">https://itnext.io/mini-video-encoder-implementation-part-1-1fce5fb081c1?source=collection_archive---------7-----------------------#2020-01-12</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/351ac3482337013494f211cae22a2524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VczNSJH_2AQkXAQhLpsJow.jpeg"/></div></div></figure><p id="3e94" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在本文中，我使用了<strong class="ke iv"> Docker、</strong> <strong class="ke iv"> Node.js、<strong class="ke iv"> Fastify、MongoDB、</strong>和<strong class="ke iv">mongose</strong>来实现迷你视频编码器的工作流引擎和工作流数据库。工作流引擎是迷你视频编码器(MVE)的心脏；它负责管理所有与视频编码相关的任务。MVE是我今年开始的新的副业项目，让我探索新的令人兴奋的技术。如果你对我为什么开始这个项目及其细节感兴趣，我邀请你阅读这篇文章:</strong></p><div class="la lb gq gs lc ld"><a href="https://medium.com/@pkalkman/new-year-new-side-project-e69991252bf4" rel="noopener follow" target="_blank"><div class="le ab fp"><div class="lf ab lg cl cj lh"><h2 class="bd iv gz z fq li fs ft lj fv fx it bi translated">新的一年，新的副业？</h2><div class="lk l"><h3 class="bd b gz z fq li fs ft lj fv fx dk translated">我喜欢做副业，你呢？他们让我尝试新技术，研究新框架…</h3></div><div class="ll l"><p class="bd b dl z fq li fs ft lj fv fx dk translated">medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr ka ld"/></div></div></a></div></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="bbdd" class="lz ma iu bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">迷你视频编码器平台</h1><p id="680a" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">本文重点研究了小型视频编码器平台的工作流引擎和工作流数据库。</p><figure class="nd ne nf ng gu jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj nc"><img src="../Images/9a17179ed5aa892529116710d447abbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*743F0H-r_OcS9SHBE5ulow.png"/></div></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">小型视频编码器架构图</figcaption></figure><h2 id="423e" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">源代码结构</h2><p id="5497" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">迷你视频编码器平台的源代码可以在<a class="ae nx" href="https://github.com/PatrickKalkman/MiniVideoEncoder" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。该项目包含六个文件夹，每个文件夹包含该特定服务的源代码。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">迷你视频编码器平台的文件夹结构</figcaption></figure><p id="2d5e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">每个文件夹都包含一个Docker文件，用于构建特定服务的Docker映像。根目录中的docker-compose.yml文件用于启动所有docker容器。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="7c11" class="lz ma iu bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Docker容器中的MongoDB</h1><p id="ed36" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">工作流引擎将编码平台的状态存储在MongoDB数据库中。MongoDB运行在一个<strong class="ke iv"> Docker </strong>容器中，数据库本身安装在主机的文件系统上。关于工作流数据库的所有信息可以在<a class="ae nx" href="https://github.com/PatrickKalkman/MiniVideoEncoder/tree/master/WorkflowDatabase" rel="noopener ugc nofollow" target="_blank">工作流数据库文件夹</a>中找到。</p><h2 id="4fb8" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">创建数据库用户</h2><p id="6889" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">在开发过程中，我使用Docker Compose来启动MVE平台的所有服务。Docker Compose使安装和启动MVE变得容易。如果工作流数据库和用户不存在，则在容器启动时创建。</p><p id="e44a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我用的是最新的官方<a class="ae nx" href="https://hub.docker.com/_/mongo?tab=tags" rel="noopener ugc nofollow" target="_blank"> MongoDB Docker镜像</a>，这个时候是<code class="fe oa ob oc od b">Mongo:4.0.14</code>。MongoDB Docker映像支持在启动时通过环境变量创建根用户。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">用于启动MongoDB的docker-compose.yml</figcaption></figure><p id="acd2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">环境变量<code class="fe oa ob oc od b">MONGO_INITDB_USERNAME</code>和<code class="fe oa ob oc od b">MONGO_INITDB_ROOT_PASSWORD</code>创建一个新的用户和密码。Dockerfile在<code class="fe oa ob oc od b">admin</code>认证数据库中创建这个用户，该用户具有root角色，即超级用户角色。<code class="fe oa ob oc od b">MONGO_INITDB_DATABASE</code>环境变量指定了在<code class="fe oa ob oc od b">/docker-entrypoint-initdb.d/</code>文件夹中执行javascript创建脚本时使用的数据库名称。</p><p id="2df4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我使用javascript文件<code class="fe oa ob oc od b">init-mongo.js</code>来创建工作流引擎用来连接数据库的用户。Docker Compose使用Docker容器中的卷来映射<code class="fe oa ob oc od b">init-mongo.js</code>文件。MongoDB在启动时执行脚本并创建<code class="fe oa ob oc od b">mve-workflowengine</code>用户。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">在数据库启动期间创建数据库用户</figcaption></figure><h2 id="9d32" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">验证创建的用户</h2><p id="87ae" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">用<code class="fe oa ob oc od b">docker-compose up</code>启动MongoDB服务器后。用户<code class="fe oa ob oc od b">mveroot</code>和<code class="fe oa ob oc od b">mve-workflowengine</code>都被创建。<code class="fe oa ob oc od b">mveroot</code>用户拥有对MongoDB服务器所有数据库的超级用户访问权限，而<code class="fe oa ob oc od b">mve-workflowengine</code>用户拥有对<code class="fe oa ob oc od b">workflow-db</code>数据库的读/写访问权限。</p><p id="18d9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">您可以通过使用MongoDB GUI来验证是否可以访问数据库。我用的是<a class="ae nx" href="https://www.mongodb.com/download-center/compass" rel="noopener ugc nofollow" target="_blank"> MongoDB Compass </a>的社区版。您可以使用下面的连接字符串通过<code class="fe oa ob oc od b">mve-workflowengine</code>用户连接到<code class="fe oa ob oc od b">workflow-db</code>数据库。</p><pre class="nd ne nf ng gu oe od of og aw oh bi"><span id="1fb3" class="nl ma iu od b gz oi oj l ok ol">mongodb://mve-workflowengine:mve-workflowengine-password@localhost:27017/?authSource=workflow-db&amp;readPreference=primary&amp;authMechanism=DEFAULT&amp;appname=MongoDB%20Compass%20Community&amp;ssl=false</span></pre></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="eb05" class="lz ma iu bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">工作流引擎REST API</h1><figure class="nd ne nf ng gu jv gi gj paragraph-image"><div class="gi gj om"><img src="../Images/638d96d48f421b185d73a1bd90bbef91.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*slr0wJE8owMYsf5V-W314g.png"/></div></figure><p id="7d55" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">工作流引擎是一个Node.js应用程序，它使用<a class="ae nx" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>提供REST API。Fastify 是一个用于Node.js的快速、低开销的web框架。MVE平台的服务使用其REST API连接到工作流引擎。</p><p id="00e8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我使用Fastify插件<a class="ae nx" href="https://github.com/israeleriston/fastify-register-routes" rel="noopener ugc nofollow" target="_blank"><strong class="ke iv">Fastify-register-routes</strong></a>来注册路线。Fastify-register-routes让我在单独的路由文件中定义路由，并用一条语句读取它们。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">自动注册route文件夹中的所有*Routes.js文件</figcaption></figure><p id="cae6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe oa ob oc od b">routes</code>文件夹中包含路线的每个文件都被自动注册。这有助于我保持项目的组织性和可维护性。见下面的文件<code class="fe oa ob oc od b">jobRoutes.js</code>，它定义了所有与工作相关的路线。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">jobRoute.js定义了所有与工作相关的路线</figcaption></figure><p id="0003" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe oa ob oc od b">jobRoutes.js</code>中，我定义了一个包含<code class="fe oa ob oc od b">api/job</code>端点上所有路由的数组。在单条路线的下面，带有解释路线的每个字段的注释。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">带解释的单条路线</figcaption></figure><p id="b1d3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe oa ob oc od b">jobController.js,</code>中，我实现了<code class="fe oa ob oc od b">getJobs()</code>方法，该方法包含从数据库中检索所有工作流作业的逻辑。但是在我解释<code class="fe oa ob oc od b">jobController</code>中的<code class="fe oa ob oc od b">getJobs()</code>之前，我们必须深入了解一下我们将如何与MongoDB数据库进行交互。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="48e1" class="lz ma iu bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">Mongoose vs mongodb驱动程序</h1><p id="0d11" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">当你想从Node.js与MongoDB交互时，你有两个选择:使用<strong class="ke iv"> mongodb </strong>驱动或者使用<strong class="ke iv">mongose</strong>。当然，选择取决于您的用例；Mongoose构建在mongodb驱动程序之上，帮助您对数据建模，从而编写更少的代码。另一方面，mongodb驱动程序更容易上手，并且提供了最好的<a class="ae nx" href="https://medium.com/@bugwheels94/performance-difference-in-mongoose-vs-mongodb-60be831c69ad" rel="noopener">性能</a>。</p><p id="2833" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于MVE，我使用Mongoose，因为此时数据库性能不是问题，我发现验证很重要。</p><h2 id="5111" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">猫鼬</h2><p id="5c7f" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">从Mongoose开始，使用<code class="fe oa ob oc od b">Schema()</code>命令描述模型的模式。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">job.js定义了作业文档的模式</figcaption></figure><p id="c3de" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在模式中，定义文档的属性。对于每个属性，您可以定义类型以及它是否是必需的。这使得Mongoose能够在插入新文档时执行验证。<code class="fe oa ob oc od b">{ timestamps: true }</code>是Mongoose的一个选项，它自动向文档添加和填充<code class="fe oa ob oc od b">createdAt</code>和<code class="fe oa ob oc od b">updateAt</code>属性。我创建了两个索引，一个在status字段，另一个在name字段。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><h1 id="4577" class="lz ma iu bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">在控制器中结合Fastify和Mongoose</h1><p id="258a" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">定义了路由和模式后，我们现在可以创建<code class="fe oa ob oc od b">JobController</code>。<code class="fe oa ob oc od b">JobController</code>由<code class="fe oa ob oc od b">JobRoutes</code>引用，并使用作业模式执行数据库操作。</p><h2 id="a7d0" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">添加新作业</h2><p id="c3bc" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated"><code class="fe oa ob oc od b">JobController</code>上的<code class="fe oa ob oc od b">addJob()</code>方法负责在数据库中存储一个新任务。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">addJob()在数据库中添加一个新作业</figcaption></figure><p id="083e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在第二行，我直接从请求体创建了一个作业。我不验证传入的请求，因为Mongoose在<code class="fe oa ob oc od b">save()</code>期间执行验证。如果缺少一个必需的字段，API将返回一个BadRequest，指出缺少哪个字段。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">缺少必填字段时API的响应</figcaption></figure><p id="16fb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe oa ob oc od b">JobController</code>的<code class="fe oa ob oc od b">getJob()</code>方法用猫鼬的<code class="fe oa ob oc od b">findById()</code>方法找工作。通过id搜索是可能的，因为MongoDB为每个插入的文档添加了一个名为<code class="fe oa ob oc od b">_id</code>的惟一id字段。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">getJob()从数据库中返回一个特定的作业</figcaption></figure><p id="4ea1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我总是试图通过返回正确的HTTP响应代码来处理错误。如果<code class="fe oa ob oc od b">findById()</code>没有找到工作，我通过调用第八行的<code class="fe oa ob oc od b">reply.notFound()</code>返回一个HTTP 404状态代码。</p><h2 id="2a12" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">更新作业</h2><p id="efa5" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated"><code class="fe oa ob oc od b">JobController</code>的<code class="fe oa ob oc od b">updateJob()</code>方法使用Mongoose的<code class="fe oa ob oc od b">findByIdAndUpdate()</code>在一条语句中搜索、更新并返回更新后的作业。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">updateJob()更新数据库中的作业文档</figcaption></figure><p id="ea17" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">默认情况下，<code class="fe oa ob oc od b">findByIdAndUpdate()</code>返回更新前的文档。通过发送选项<code class="fe oa ob oc od b">{ new: true }</code>，它返回更新的作业。在第四行，我使用<a class="ae nx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>来创建对象的副本。</p><p id="7a01" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果您对其余两个方法<code class="fe oa ob oc od b">deleteJob()</code>和<code class="fe oa ob oc od b">getJobs()</code>的实现感兴趣，请查看<a class="ae nx" href="https://github.com/PatrickKalkman/MiniVideoEncoder/blob/master/WorkflowEngine/lib/controllers/jobController.js" rel="noopener ugc nofollow" target="_blank"> Github </a>上的<code class="fe oa ob oc od b">jobController.js</code>。</p><h1 id="7b40" class="lz ma iu bd mb mc on me mf mg oo mi mj mk op mm mn mo oq mq mr ms or mu mv mw bi translated">将工作流引擎和工作流数据库归档</h1><p id="8cfa" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">在继续实现工作流引擎和工作流数据库之前，我想确保它们都运行在Docker容器中，并且可以相互通信。这意味着用工作流引擎扩展<code class="fe oa ob oc od b">docker-compose.yml </code>文件，并为工作流引擎项目添加Dockerfile。</p><h2 id="5a42" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">工作流引擎的Dockerfile</h2><p id="0621" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated"><a class="ae nx" href="https://medium.com/better-programming/docker-for-node-js-in-production-b9dc0e9e48e0" rel="noopener">使用我在生产</a>中运行Node.js应用程序的清单，我为工作流引擎创建了以下docker文件。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div></figure><p id="a678" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有了这个docker文件，你可以用<code class="fe oa ob oc od b">docker build -t workflowengine:0.6.0 .</code>构建Docker映像。我们现在有两个Docker映像，可以使用Docker Compose启动。</p><h2 id="cc3b" class="nl ma iu bd mb nm nn dn mf no np dp mj kn nq nr mn kr ns nt mr kv nu nv mv nw bi translated">扩展docker-compose文件</h2><p id="a7f5" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">我已经展示了工作流数据库的一个<code class="fe oa ob oc od b">docker-compose.yml</code>文件。我添加了工作流引擎，这样两者都可以使用Docker Compose启动。</p><figure class="nd ne nf ng gu jv"><div class="bz fq l di"><div class="ny nz l"/></div><figcaption class="nh ni gk gi gj nj nk bd b be z dk translated">docker-编写用于启动工作流数据库和工作流引擎的文件</figcaption></figure><p id="cfec" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">Docker Compose创建了两个服务，第3行的<code class="fe oa ob oc od b">workflowdb</code>和第17行的<code class="fe oa ob oc od b">workflowengine</code>。我用正确的连接字符串设置了环境变量<code class="fe oa ob oc od b">STORAGE_HOST</code>，以便工作流引擎能够连接到数据库。我用服务名<code class="fe oa ob oc od b">workflowdb</code>来表示主机。这样我就不必在Docker容器中找到MongoDB服务器的IP地址。</p><p id="9941" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe oa ob oc od b">- STORAGE_HOST=mongodb://mve-workflowengine:mve-workflowengine-password@<strong class="ke iv">workflowdb</strong>:27017/workflow-db?authMechanism=DEFAULT&amp;authSource=workflow-db</code></p><p id="8449" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">两个服务都连接到网络<code class="fe oa ob oc od b">mve-network</code>以确保它们可以相互通信。</p><p id="90b9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="os">当Fastify服务器在Docker容器中运行时，我在从主机连接到它时遇到了一些问题。似乎默认Fastify监听127.0.0.1地址，这在Docker容器中不起作用。在将其更改为</em><strong class="ke iv"><em class="os">0 . 0 . 0 . 0</em></strong><em class="os">后，我可以从主机访问它。</em></p><h1 id="09b4" class="lz ma iu bd mb mc on me mf mg oo mi mj mk op mm mn mo oq mq mr ms or mu mv mw bi translated">下一步做什么？</h1><p id="21ff" class="pw-post-body-paragraph kc kd iu ke b kf mx kh ki kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz in bi translated">好吧，我们现在在哪里？我们在Docker中运行了工作流引擎和工作流数据库，它们能够相互通信。我们可以使用REST API插入、更新或删除视频编码作业。这两个容器都可以使用Docker Compose启动。</p><p id="e096" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来，我将使用管理编码任务的附加端点来扩展工作流引擎，添加身份验证，并开始处理视频编码器。</p></div></div>    
</body>
</html>