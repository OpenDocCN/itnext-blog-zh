<html>
<head>
<title>Blog App Using MERN Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MERN堆栈的博客应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/blog-app-using-mern-stack-b0b4d69d7ea1?source=collection_archive---------0-----------------------#2020-10-13">https://itnext.io/blog-app-using-mern-stack-b0b4d69d7ea1?source=collection_archive---------0-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="104e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">博客应用程序使用mern栈技术与完整的认证系统。</h2></div><h2 id="53cc" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">github:【https://github.com/mehulk05/Blogapp-using-MERN T4】</h2><h2 id="2d95" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">现场演示:<a class="ae lb" href="https://mehulk05.github.io/Blogapp-using-MERN/#/" rel="noopener ugc nofollow" target="_blank">https://mehulk05.github.io/Blogapp-using-MERN/</a></h2><h2 id="264c" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">博客:<a class="ae lb" href="https://blogs-by-mehul.blogspot.com/2021/01/blog-app-using-mern-stack.html" rel="noopener ugc nofollow" target="_blank">https://blogs-by-mehul . blogspot . com/2021/01/blog-app-using-mern-stack . html</a></h2><h2 id="aefd" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我们正在创造的演示</h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/00eb40f20cbc1eeeec163e030f627ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*gu59iIhvTATGg46n.gif"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">完整的应用程序演示</figcaption></figure><h1 id="b8bf" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">让我们理解means斯塔克是什么意思。</h1><ul class=""><li id="a5d9" class="lz ma iq mb b mc md me mf ko mg ks mh kw mi mj mk ml mm mn bi translated">这是一个开源的NoSQL跨平台面向文档的数据库。</li><li id="a4a0" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><code class="fe mo mp mq mr b">Express JS</code>–这是一个基于web的应用程序框架，与Node JS一起工作，它有助于构建web应用程序和RESTful APIs。</li><li id="21c6" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><code class="fe mo mp mq mr b">React</code>–React是由<strong class="mb ir">脸书创建的<strong class="mb ir"> JavaScript </strong>库。</strong> React是一个<strong class="mb ir">用户界面</strong> (UI)库。React是一个构建<strong class="mb ir"> UI组件</strong>的工具</li><li id="ba72" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><code class="fe mo mp mq mr b">Node JS</code>–这是一个免费的JavaScript运行时环境，它在浏览器之外执行JavaScript代码。它适用于macOS、Windows、Linux和Unix。</li></ul><h1 id="d9e0" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">我将使用以下插件和工具来创建MERN堆栈应用程序。</h1><ul class=""><li id="b592" class="lz ma iq mb b mc md me mf ko mg ks mh kw mi mj mk ml mm mn bi translated"><a class="ae lb" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点JS </a></li><li id="e4f3" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><a class="ae lb" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a></li><li id="cd43" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><a class="ae lb" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">猫鼬JS </a></li><li id="6f91" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><a class="ae lb" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">快递JS </a></li><li id="f2c4" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><a class="ae lb" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应堆</a></li><li id="f109" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><a class="ae lb" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a></li></ul><h1 id="f5ae" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#1设置节点JS开发环境</h1><p id="737a" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">跟随此链接到<a class="ae lb" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">在您的系统中设置节点JS。</a>只需根据您的系统位(即32位和64位以及操作系统)下载并安装节点</p><h1 id="1a22" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#2建立一个节点。JS后端</h1><p id="f48d" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">为了编写易于管理的代码，我们应该将MERN堆栈后端文件夹分开。在React的根目录下用后端的名字或者任何你喜欢的名字创建一个文件夹。这个文件夹将处理我们的应用程序的后端代码，记住它将有来自React的单独的node_modules文件夹。</p><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="81bf" class="kf kg iq mr b gy no np l nq nr">mkdir backend<br/>cd backend<br/>npm init -y</span></pre><p id="6775" class="pw-post-body-paragraph mx my iq mb b mc ns jr mz me nt ju na ko nu nc nd ks nv nf ng kw nw ni nj mj ij bi translated">以上命令将带您进入后端文件夹，然后使用所有默认配置生成package.json。</p><h2 id="e19d" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">–安装和配置MERN堆栈应用程序开发所需的NPM软件包</h2><p id="a4ab" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">使用以下命令安装以下节点模块。</p><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="637d" class="kf kg iq mr b gy no np l nq nr">npm install --save body-parser cors express mongoose</span></pre><ul class=""><li id="fff2" class="lz ma iq mb b mc ns me nt ko nx ks ny kw nz mj mk ml mm mn bi translated"><strong class="mb ir">body-parser:</strong>body-parser NPM模块是一个JSON解析中间件。它有助于解析JSON数据、纯文本或整个对象。</li><li id="c0d8" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><strong class="mb ir"> CORS </strong>:这是一个Node JS包，也叫express js中间件。它允许启用具有多个选项的CORS。可通过国家预防机制登记处获取。</li><li id="ad1f" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><strong class="mb ir"> Express.js </strong> : Express js是一个免费开源的Node js web应用框架。它帮助创建web应用程序和RESTful APIs，并充当中间件</li><li id="0e7a" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj mk ml mm mn bi translated"><strong class="mb ir">mongose</strong>:mongose是节点的MongoDB ODM。它允许您与MongoDB数据库进行交互。</li></ul><p id="912b" class="pw-post-body-paragraph mx my iq mb b mc ns jr mz me nt ju na ko nu nc nd ks nv nf ng kw nw ni nj mj ij bi translated">每次进行更改时启动和停止服务器是一项耗时的任务。为了解决这个问题，我们使用了<code class="fe mo mp mq mr b">nodemon</code>NPM模块。每次我们做出更改时，该软件包都会自动重启服务器。我们将使用下面给出的命令在本地安装它。</p><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="c33f" class="kf kg iq mr b gy no np l nq nr">npm install nodemon --save-dev</span></pre><p id="5a46" class="pw-post-body-paragraph mx my iq mb b mc ns jr mz me nt ju na ko nu nc nd ks nv nf ng kw nw ni nj mj ij bi translated">此外，确保将package.json更改为启动nodemon</p><h1 id="5c0e" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#3后端的文件夹结构</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a73ead6e84c841966d4bcc9a4dcb4a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/0*tOzUTHJ6cQ7GiDQE.png"/></div></figure><h1 id="3d70" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#4编写App.js</h1><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="3b2d" class="kf kg iq mr b gy no np l nq nr">const path = require("path");<br/>const express = require("express")<br/>const mongoose = require("mongoose")const db = require("./db/db")<br/>const postRouter = require("./Routes/post");const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({<br/>   extended: false<br/>}));<br/>app.use(cors());const PORT = process.env.PORT || 3000app.use("/api/posts", postRouter)app.listen(PORT, (req, res) =&gt; {<br/>console.log(`app is listening to PORT ${PORT}`)<br/>})</span></pre><h1 id="a1e6" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#5编写db.js</h1><p id="104b" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">要创建数据库，您可以到<a class="ae lb" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank">这里</a>注册并创建一个新的数据库。此外，您将获得我将在代码中使用的连接URL</p><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="9893" class="kf kg iq mr b gy no np l nq nr">const mongoose = require('mongoose');mongoose.Promise = global.Promise;const url = "mongodb://testuser:&lt;password&gt;<a class="ae lb" href="mailto:9eVH8YT0rVZ0X1uj@cluster0-shard-00-00.ecaql.mongodb.net" rel="noopener ugc nofollow" target="_blank">@cluster0-shard-00-00.ecaql.mongodb.net</a>:27017?ssl=true&amp;replicaSet=atlas-ceza4t-shard-0&amp;authSource=admin&amp;retryWrites=true&amp;w=majority"// Connect MongoDB at default port 27017.let mong = mongoose.connect(url, {<br/>    useNewUrlParser: true,<br/>    useCreateIndex: true,<br/>    useUnifiedTopology: true<br/>}, (err) =&gt; {<br/>    if (!err) {<br/>        console.log('MongoDB Connection Succeeded.')<br/>    } else {<br/>        console.log('Error in DB connection: ' + err)<br/>    }<br/>});</span></pre><h1 id="b78e" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#6用Mongoose JS创建模型</h1><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="c0e6" class="kf kg iq mr b gy no np l nq nr">const mongoose = require('mongoose');const Post = mongoose.model('Post', {<br/>    title: {<br/>        type: String,<br/>        required: true<br/>    },content: {<br/>        type: String,<br/>        required: true<br/>    },<br/>    <br/>});module.exports = Post</span></pre><h1 id="ed30" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#7使用快速JS路线创建RESTful APIs</h1><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="eafe" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated"><strong class="ak"> # 8创建前端</strong></h1><p id="eba5" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">现在，我们将创建一个全新的react项目，我们将设置react项目与我们在上述步骤中创建的后端进行交互。</p><ol class=""><li id="473a" class="lz ma iq mb b mc ns me nt ko nx ks ny kw nz mj od ml mm mn bi translated"><strong class="mb ir">创建React应用</strong></li></ol><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="2ffa" class="kf kg iq mr b gy no np l nq nr">npx create-react-app Blogapp-using-mern<br/>cd Blogapp-using-mern<br/>npm start</span></pre><p id="48a2" class="pw-post-body-paragraph mx my iq mb b mc ns jr mz me nt ju na ko nu nc nd ks nv nf ng kw nw ni nj mj ij bi translated"><strong class="mb ir"> 2。在Index.js中设置Axios</strong></p><pre class="ld le lf lg gt nk mr nl nm aw nn bi"><span id="52b9" class="kf kg iq mr b gy no np l nq nr">axios.defaults.baseURL = '<a class="ae lb" href="https://zany-periodic-fisherman.glitch.me/api'" rel="noopener ugc nofollow" target="_blank">https://zany-periodic-fisherman.glitch.me/api'</a>;</span><span id="fa48" class="kf kg iq mr b gy oe np l nq nr">let userData = JSON.parse(localStorage.getItem("userData"))<br/>let token<br/>if (userData) {<br/>  token = userData.token<br/>}</span><span id="8085" class="kf kg iq mr b gy oe np l nq nr">axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;<br/>axios.defaults.headers.post['Content-Type'] = 'application/json';</span><span id="d1ec" class="kf kg iq mr b gy oe np l nq nr">axios.interceptors.request.use(request =&gt; {<br/>  return request;<br/>}, error =&gt; {<br/>  //  console.log(error);<br/>  return Promise.reject(error);<br/>});</span><span id="e7a5" class="kf kg iq mr b gy oe np l nq nr">axios.interceptors.response.use(response =&gt; {<br/>  return response;<br/>}, error =&gt; {<br/>  console.log(error.response);<br/>  return Promise.reject(error);<br/>});</span></pre><h1 id="9428" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#9创建组件</h1><p id="802c" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">我们将创建3个组件</p><ol class=""><li id="0bdc" class="lz ma iq mb b mc ns me nt ko nx ks ny kw nz mj od ml mm mn bi translated">后列表组件(用于读取)</li><li id="0aab" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj od ml mm mn bi translated">创建帖子组件(用于创建和更新帖子)</li><li id="d939" class="lz ma iq mb b mc ms me mt ko mu ks mv kw mw mj od ml mm mn bi translated">PostDetail组件(用于阅读完整帖子和执行删除操作)</li></ol><h1 id="6665" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#10后置列表组件</h1><p id="cab8" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">在这个组件中，我们将从我们创建的后端获取数据。为此，我们将在<strong class="mb ir">componentidmount(</strong>)生命周期钩子中进行Http调用。一旦我们得到数据，我们将使用setState()更新我们的状态</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="ee48" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#11创建后组件</h1><p id="c8c4" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">在这个组件中，我们将创建一个表单，并在changeHandler上处理输入。一旦我们完成输入，我们将在表单的提交方法上发送Http请求。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="02b6" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#12使用创建后组件的更新操作</h1><p id="a2d3" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">这里我们将使用componentDidMount()生命周期挂钩来获取数据，然后使用setState()设置状态。然后我们将使用这个状态来填充表单输入值。然后根据网址，我们将更新帖子或创建一个全新的帖子</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="9f5c" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#13删除帖子的帖子详细信息组件</h1><p id="923a" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">在这里，我们将使用帖子的id来查看详细的帖子。此外，我们将使用相同的id删除帖子，方法是将其作为参数传递给URL，并在后端使用相同的参数，我们将通过Id识别帖子，然后我们将删除它。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="12db" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#演示图像</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/e28326aef5ca6cefb137113076bff1d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xeObKer_CTKaTg7P.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">创建帖子</figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi ok"><img src="../Images/2eef4c3f1a6251c4a096c9d1de53fe79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CKSP9Pbl8vM7Z_ap.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">发布列表</figcaption></figure><h1 id="5ac3" class="lo kg iq bd kh lp lq lr kk ls lt lu kn jw lv jx kr jz lw ka kv kc lx kd kz ly bi translated">#结论</h1><p id="2078" class="pw-post-body-paragraph mx my iq mb b mc md jr mz me mf ju na ko nb nc nd ks ne nf ng kw nh ni nj mj ij bi translated">最后，我们使用React和Bootstrap 4完成了MERN堆栈教程。我试图在本教程中强调每个重要的主题。然而，如果你跳过了什么，你可以看看我的<a class="ae lb" href="https://github.com/mehulk05/Blogapp-using-MERN" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>。</p><h2 id="2d5b" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">另外，请阅读我的博客</h2><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/authentication-using-jwt-in-mean-stack-6b425247b7d8"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">在均值堆栈中使用JWT的认证</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">从头开始在一个平均堆栈应用程序中使用JWT进行身份验证</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">itnext.io</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc li oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/crud-operation-using-mean-stack-7dfa2f51ec8c"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">使用平均堆栈的CRUD操作</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">github:https://github . com/me hulk 05/Blog-using-mean</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">itnext.io</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc li oo"/></div></div></a></div></div></div>    
</body>
</html>