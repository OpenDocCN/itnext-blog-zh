<html>
<head>
<title>How I developed a Concurrent Mode friendly library for React Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何为React Redux开发一个并发模式友好库</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-developed-a-concurrent-mode-friendly-library-for-react-redux-8643ac63d290?source=collection_archive---------3-----------------------#2019-07-27">https://itnext.io/how-i-developed-a-concurrent-mode-friendly-library-for-react-redux-8643ac63d290?source=collection_archive---------3-----------------------#2019-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3826" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为并发模式做好准备</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3e2493dcb3f441a369e3d21b467aeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrVRA0sWjNlpllkAsA7cDg.jpeg"/></div></div></figure><h1 id="a51f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="361b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">几个月来，我一直在开发几个React hooks库。在这篇文章中，我将解释为什么以及如何用React钩子开发React Redux绑定库。该库实现为并发模式友好的。我们来讨论一下为什么它很重要，背后的技术是什么。</p><p id="b1df" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">React并发模式还没来，所有讨论都是基于目前的不稳定行为。请注意，当并发模式发布和研究最佳实践时，事情可能会发生变化。</p><h1 id="20dd" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是并发模式</h1><p id="b351" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我对并发模式的理解是一种React渲染模式，它可以将一些渲染优先于其他渲染。在并发模式下，React可以在组件树中间暂停渲染，并丢弃部分渲染的结果。</p><p id="fd84" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们举一个简单的例子代码。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="9118" class="ms kv it mo b gy mt mu l mv mw">const ParentA = () =&gt; (<br/>  &lt;div&gt;<br/>    Hello<br/>    &lt;ChildA /&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="1d17" class="ms kv it mo b gy mx mu l mv mw">const ChildA = () =&gt; (<br/>  &lt;span&gt;World&lt;/span&gt;<br/>);</span><span id="27cf" class="ms kv it mo b gy mx mu l mv mw">const ParentB = () =&gt; (<br/>  &lt;div&gt;<br/>    Hello<br/>    {renderChildB()}<br/>  &lt;/div&gt;<br/>)</span><span id="551c" class="ms kv it mo b gy mx mu l mv mw">const renderChildB = () =&gt; (<br/>  &lt;span&gt;World&lt;/span&gt;<br/>);</span></pre><p id="128c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">两个组件<code class="fe my mz na mo b">ParentA</code>和<code class="fe my mz na mo b">ParentB</code>会产生相同的结果。在同步模式下可能没有区别。但是，在并发模式下，React可以在ParentA渲染后暂停ChildA渲染。这对于<code class="fe my mz na mo b">ParentB</code>是不可能的，因为它会立即调用<code class="fe my mz na mo b">renderChildB</code>。</p><p id="de95" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果React检测到更高优先级的任务，它将暂停渲染并将其丢弃。然后，它将执行该任务，并再次重新开始渲染。(还是继续？)</p><p id="2509" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要暂停渲染，组件必须像<code class="fe my mz na mo b">ParentA</code>一样定义。问题不大，因为开发者已经习惯了。但是，在其他情况下，开发人员必须关注并发模式。如果一个组件不期望暂停，它可能会表现不正确。我将在下一节描述react-redux的一个具体问题。在深入讨论之前，让我指出一个解决方案至少有两个层次。</p><p id="0152" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第一层是，如果在并发模式下出现问题，它会退回到同步模式。这是像<code class="fe my mz na mo b">renderChildB</code>一样假设完成的，或者我们可以用同步运行效果的<code class="fe my mz na mo b">useLayoutEffect</code>做回退。如果这种回退的频率非常低，我们将能够在大多数情况下获得并发模式的好处。但是，如果频率非常高，即使我们启用了并发模式，我们也会看到与同步模式下相同的行为。</p><p id="ceb1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第二个层次是让它完全在并发模式下工作，没有同步模式回退。这将使我们一直受益。</p><h1 id="635c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">问题</h1><p id="01df" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们来讨论一下react-redux v7.1.0中的一个问题，下面是使用<code class="fe my mz na mo b">useSelector</code>的示例代码。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="77f9" class="ms kv it mo b gy mt mu l mv mw">const App = () =&gt; (<br/>  &lt;Provider store={store}&gt;<br/>    &lt;Parent /&gt;<br/>  &lt;/Provider&gt;<br/>  );</span><span id="6ea0" class="ms kv it mo b gy mx mu l mv mw">const Parent = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;Child /&gt;<br/>    &lt;Child /&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="19ef" class="ms kv it mo b gy mx mu l mv mw">const Child = () =&gt; {<br/>  const count = useSelector(state =&gt; state.count);<br/>  return &lt;span&gt;{count}&lt;/span&gt;<br/>};</span></pre><p id="a172" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">即使是这个小例子，在并发模式下也有一个问题。更准确地说，这可能是也可能不是一个问题，取决于一个应用程序的要求。</p><p id="06c2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">问题是第一个<code class="fe my mz na mo b">Child</code>和第二个<code class="fe my mz na mo b">Child</code>可能会渲染出不同的<code class="fe my mz na mo b">count</code>。这可能发生在以下步骤中。</p><ol class=""><li id="09ad" class="nb nc it lo b lp mi ls mj lv nd lz ne md nf mh ng nh ni nj bi translated">最初，<code class="fe my mz na mo b">state = { count: 1 }</code></li><li id="eedf" class="nb nc it lo b lp nk ls nl lv nm lz nn md no mh ng nh ni nj bi translated"><code class="fe my mz na mo b">Parent</code>渲染</li><li id="95ad" class="nb nc it lo b lp nk ls nl lv nm lz nn md no mh ng nh ni nj bi translated">第一个<code class="fe my mz na mo b">Child</code>渲染计数=1</li><li id="d26d" class="nb nc it lo b lp nk ls nl lv nm lz nn md no mh ng nh ni nj bi translated">更新<code class="fe my mz na mo b">state = { count: 2 }</code>的中断任务到来</li><li id="def2" class="nb nc it lo b lp nk ls nl lv nm lz nn md no mh ng nh ni nj bi translated">第二个<code class="fe my mz na mo b">Child</code>渲染计数=2</li><li id="ebd1" class="nb nc it lo b lp nk ls nl lv nm lz nn md no mh ng nh ni nj bi translated">状态更新触发<code class="fe my mz na mo b">Child</code>组件重新渲染</li><li id="bafd" class="nb nc it lo b lp nk ls nl lv nm lz nn md no mh ng nh ni nj bi translated">两个<code class="fe my mz na mo b">Child</code>组件都以count=2进行渲染</li></ol><p id="0bac" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以，不一致的<code class="fe my mz na mo b">count</code>出现在某个点上。更糟糕的是，在某种情况下，当组件在第6步之前重新渲染时，<code class="fe my mz na mo b">Child</code>组件不会在第6步使用更新的计数重新渲染。(我希望可以通过删除源代码中的一行来解决这个问题。)</p><p id="7010" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">之所以会这样，是因为<code class="fe my mz na mo b">useSelector</code>在render中调用了<code class="fe my mz na mo b">store.getState()</code>。在Redux中，state是不可变的，但是store只能有一个最新版本。因此，<code class="fe my mz na mo b">store.getState()</code>的结果不稳定。</p><p id="8184" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面的截屏显示了50个子组件的不一致性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/75b92c7621dd42b59a25f8d05c3a5fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mEuP98LpB-rW-gRF.gif"/></div></div></figure><h1 id="e000" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">反应-反应-还原4.1.0中的溶液</h1><p id="3555" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我一直在开发一个名为reactive-react-redux的库，它是react-redux的替代品。仅支持挂钩API。</p><div class="nq nr gp gr ns nt"><a href="https://github.com/dai-shi/reactive-react-redux" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">代时/反应-反应-还原</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">如果你正在寻找一个非Redux库，请访问react-tracked…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><p id="0dc0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个库解决了我在上一节中描述的问题。让我注意一下，react-redux最初试图在v6中解决这个问题。我认为它在某种意义上解决了。然而，没有办法用useContext来摆脱渲染，react-redux v6不支持hooks API。像v5一样，react-redux v7使用存储上下文和订阅来支持hooks API。</p><p id="60c9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">react-redux v6的工作方式是将存储状态放在一个上下文中，并且不在子组件中使用<code class="fe my mz na mo b">store.getState()</code>。上下文可以有状态和问题解决的多个版本(快照)。</p><p id="cf62" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我的库reactive-react-redux v4通过在状态上下文中加入订阅机制解决了这个问题。换句话说，它是react-redux v6和v7的混合体。我的库使用<a class="ae oi" href="https://github.com/dai-shi/reactive-react-redux/issues/29" rel="noopener ugc nofollow" target="_blank">calculateChangedBits的一个未记录的特性</a>来混合状态上下文和订阅，这允许优化渲染性能。</p><p id="5401" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">react-redux v6中有一个性能问题，可能是因为它让上下文传播到所有子组件。reactive-react-redux v4停止传播，性能非常好。<a class="ae oi" href="https://github.com/dai-shi/reactive-react-redux/issues/32#issuecomment-513507770" rel="noopener ugc nofollow" target="_blank">一项基准测试结果</a>显示，它的性能与react-redux v7相当或略好。</p><h1 id="8b6e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">测试库的工具</h1><p id="8818" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">起初，我不太确定我的库是否真的可以在并发模式下工作而不会出现这个问题。所以，我开发了一个测试工具。(前一部分的截屏由工具提供。)</p><div class="nq nr gp gr ns nt"><a href="https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-mode" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">Dai-Shi/will-this-react-global-state-work in-concurrent-mode</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">检查React并发模式中的撕裂在react-redux中，有一个称为“撕裂”的理论问题可能会发生…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="oj l oe of og oc oh ks nt"/></div></div></a></div><p id="3526" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这个工具有一个小应用程序来显示许多计数并检查不一致性。这是开玩笑的结果。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="4c47" class="ms kv it mo b gy mt mu l mv mw">react-redux<br/>    ✓ check1: updated properly (975ms)<br/>    ✕ check2: no tearing during update (18ms)<br/>    ✓ check3: ability to interrupt render (1ms)<br/>    ✕ check4: proper update after interrupt (5083ms)<br/>  reactive-react-redux<br/>    ✓ check1: updated properly (1448ms)<br/>    ✓ check2: no tearing during update (3ms)<br/>    ✓ check3: ability to interrupt render<br/>    ✓ check4: proper update after interrupt (751ms)</span></pre><p id="d067" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果一个库通过了所有四项检查，它很可能以并发模式工作，并从中受益。check3测试任务是否会中断渲染。如果它退回到同步模式，此检查将失败。</p><p id="57a5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我在react vee-react-redux v 4 . 0 . 0中的最初实现存在这个问题，check3失败了。那是因为我用了同步运行特效的<code class="fe my mz na mo b">useLayoutEffect</code>。reactive-react-redux v4.1.0消除了它，并通过了所有检查。</p><p id="2306" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">截至发稿，关于并发模式的文档并不多，一切都是基于观察。这意味着，任何事情都可能出错。请注意。</p><h1 id="2a73" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="eaf6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">并发模式尚未发布。所以，某种意义上，一切都是假设。然而，我发现构建一个测试工具是有价值的，因为我们可以讨论行为，即使它是不稳定的。行为可以在以后更改，但是我们可以更新工具来跟随更改。</p><p id="129e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以，这篇文章的主要目的是鼓励人们尝试这个工具并给出反馈。</p><p id="c66f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">第二个目标是告知我在reactive-react-redux中使用的技术。仍有更多改进和修正的空间。所以，也欢迎反馈。</p><p id="523d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，我用同样的技术开发了一些其他的库。</p><div class="nq nr gp gr ns nt"><a href="https://github.com/dai-shi/react-tracked" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">戴式/反应跟踪式</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">如果你正在寻找一个基于Redux的库，请访问…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="ok l oe of og oc oh ks nt"/></div></div></a></div><p id="1ac7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">react-tracked提供了与reactive-react-redux中相同的钩子API，但没有redux。</p><div class="nq nr gp gr ns nt"><a href="https://github.com/dai-shi/use-context-selector" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">代时/使用上下文选择器</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">React useContextSelector钩子在userland React Context和useContext中经常被用来避免正确的钻取，然而…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="ol l oe of og oc oh ks nt"/></div></div></a></div><p id="b42c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">use-context-selector在userland中提供了<code class="fe my mz na mo b">useContextSelector</code>钩子。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="f628" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">希望你喜欢这篇文章。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="f30a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="ot">原载于2019年7月27日</em><a class="ae oi" href="https://blog.axlight.com/posts/how-i-developed-a-concurrent-mode-friendly-library-for-react-redux/" rel="noopener ugc nofollow" target="_blank"><em class="ot">【https://blog.axlight.com】</em></a><em class="ot">。</em></p></div></div>    
</body>
</html>