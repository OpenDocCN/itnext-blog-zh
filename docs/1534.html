<html>
<head>
<title>Creating a custom form field control compatible with Reactive Forms and Angular Material</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建与反应式表单和角度材料兼容的自定义表单字段控件</h1>
<blockquote>原文：<a href="https://itnext.io/creating-a-custom-form-field-control-compatible-with-reactive-forms-and-angular-material-cf195905b451?source=collection_archive---------0-----------------------#2018-11-18">https://itnext.io/creating-a-custom-form-field-control-compatible-with-reactive-forms-and-angular-material-cf195905b451?source=collection_archive---------0-----------------------#2018-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/2a07b893b58e59a7b04811dfa37524c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*35-FRwt72mAyTa-Y53YJ5Q.png"/></div></figure><p id="5340" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">角材和角材提供了各种基本的html表单控件。但是，当我们想使用更复杂的工具，如富编辑器、文件上传器、标签、国际电话等时，会发生什么呢？</p><p id="6441" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">遗憾的是，棱角分明的材料无法覆盖所有的项目需求，所以我们必须自己创造。</p><p id="8007" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在花了大量时间搜索示例、阅读教程和测试技术后，我设法创建了各种各样的自定义表单字段，它们与<strong class="jz iu">反应式表单</strong>和<strong class="jz iu">角形材料</strong>表单设计兼容。</p><p id="1e1d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本教程中，我将向你展示我如何用<strong class="jz iu"> Quill </strong>创建一个富编辑器表单控件，实现<strong class="jz iu"> ControlValueAccessor </strong>和<strong class="jz iu"> MatFormFieldControl </strong>。</p><h1 id="908a" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">先决条件</h1><ul class=""><li id="ad99" class="lt lu it jz b ka lv ke lw ki lx km ly kq lz ku ma mb mc md bi translated">角度5°或更高</li><li id="272a" class="lt lu it jz b ka me ke mf ki mg km mh kq mi ku ma mb mc md bi translated">角形材料5或更高</li></ul><p id="ae20" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">(这种方法已经在角度5和角度7上进行了测试)</p><h1 id="fad4" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">装置</h1><p id="0599" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我假设您已经创建了一个角度项目，并且已经在项目中安装了角度材质。</p><p id="6626" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你必须首先安装Quill编辑器及其类型的打字稿。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2560" class="mv kw it mr b gy mw mx l my mz">npm install --save quill<br/>npm install --save @types/quill</span></pre><blockquote class="na nb nc"><p id="ee58" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated">Quill有一个简洁的用户界面，它提供了一个广泛的API来处理丰富的编辑器及其数据。</p></blockquote><p id="d29f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">开始之前的一些最终配置:将css文件导入到项目中。</p><p id="fb0e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要么在index.html</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="49ec" class="mv kw it mr b gy mw mx l my mz">&lt;link href="PATH_TO_QUILL_CSS/quill.snow.css" rel="stylesheet"&gt;</span></pre><p id="7e3f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">或者在angular.json的样式部分</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2c78" class="mv kw it mr b gy mw mx l my mz">...<br/>"styles": [<br/>...<br/>"PATH_TO_QUILL_CSS/quill.snow.css",<br/>...<br/>]</span></pre><p id="e3c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就是这样！您终于准备好开始编码了！</p><h1 id="17aa" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">创建组件</h1><p id="a17d" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">我们将从创建组件开始，就像angular中的任何其他组件一样。还没有反应形态和角状物质的联系。我们将使用标准输入/输出与父组件通信。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="31f6" class="mv kw it mr b gy mw mx l my mz">import { Component, Input, OnInit, OnChanges, ElementRef, ViewChild, Output, EventEmitter } from '@angular/core';<br/>import Quill from 'quill';</span><span id="f10e" class="mv kw it mr b gy nh mx l my mz">const SELECTOR = 'rich-editor';</span><span id="a014" class="mv kw it mr b gy nh mx l my mz">@Component({</span><span id="c8c0" class="mv kw it mr b gy nh mx l my mz">   selector: SELECTOR,</span><span id="19cc" class="mv kw it mr b gy nh mx l my mz">   template: `&lt;div class="text-editor-container" #container&gt;         <br/>     &lt;div id="editor" (click)="onTouched()" [ngStyle]="{'height': <br/>      '200px'}"&gt;&lt;/div&gt;<br/>   &lt;/div&gt;`,</span><span id="6cdd" class="mv kw it mr b gy nh mx l my mz">  styles: [`img {<br/>      position: relative;<br/>    }`]<br/>})</span><span id="73eb" class="mv kw it mr b gy nh mx l my mz">export class FormRichEditorComponent implements OnInit, OnChanges{</span><span id="aede" class="mv kw it mr b gy nh mx l my mz">@ViewChild('container', { read: ElementRef }) container: ElementRef;<br/>@Input() value: any;</span><span id="0791" class="mv kw it mr b gy nh mx l my mz">@Output() changed: EventEmitter&lt;any&gt; = new EventEmitter();</span><span id="17d6" class="mv kw it mr b gy nh mx l my mz">//this one is important, otherwise 'Quill' is undefined<br/>quill : any = Quill; </span><span id="21c9" class="mv kw it mr b gy nh mx l my mz">editor: any;</span><span id="1369" class="mv kw it mr b gy nh mx l my mz">constructor(public elementRef: ElementRef) {}</span><span id="6a3c" class="mv kw it mr b gy nh mx l my mz">ngOnInit(): void {<br/>   let editor = this.container.nativeElement.<br/>                 querySelector('#editor')</span><span id="8a5f" class="mv kw it mr b gy nh mx l my mz">   this.editor = new Quill(editor, {theme: 'snow'});</span><span id="a0d1" class="mv kw it mr b gy nh mx l my mz">   this.editor.on('editor-change', (eventName, ...args) =&gt; {<br/><strong class="mr iu">      this.changed.emit(this.editor.getContents());<br/></strong>   })<br/>}</span><span id="6d00" class="mv kw it mr b gy nh mx l my mz">ngOnChanges() {<br/>    if (this.editor) {<br/><strong class="mr iu">      this.editor.setContents(this.value);<br/></strong>    }<br/>  }</span><span id="cb24" class="mv kw it mr b gy nh mx l my mz">}</span></pre><p id="a773" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦编辑器被创建，我们使用<code class="fe ni nj nk mr b">editor-change</code>事件订阅它的值变化。当事件被触发时，我们使用<code class="fe ni nj nk mr b">changed</code>输出事件发射器通知父组件。我们还使用<code class="fe ni nj nk mr b">ngOnChanges</code>生命周期钩子跟踪输入<code class="fe ni nj nk mr b">value</code>绑定的变化，当值更新时，我们将它设置到富编辑器中。</p><p id="71f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们的组件可以在父组件中使用了！</p><p id="b1b9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为此，请使用以下代码片段:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="de0f" class="mv kw it mr b gy mw mx l my mz">&lt;rich-editor [value]="editorValue" (changed)="editorValueChanged($event)"&gt;<br/>&lt;/rich-editor&gt;</span></pre><p id="d210" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，正如我在本文开头所说的，我们希望将我们的富编辑器作为表单的一部分，并使用反应式表单指令与它进行通信。为此，我们需要实现一个值访问器。并且我们不会使用标准的输入/输出通信机制，我们将在实现ValueAccessor时删除它。</p><h1 id="2c27" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">实现自定义ValueAccessor</h1><p id="d227" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">实现自定义值访问器需要两个简单的步骤:</p><ol class=""><li id="1a5e" class="lt lu it jz b ka kb ke kf ki nl km nm kq nn ku no mb mc md bi translated">注册一个<code class="fe ni nj nk mr b">NG_VALUE_ACCESSOR</code>提供商</li><li id="c13c" class="lt lu it jz b ka me ke mf ki mg km mh kq mi ku no mb mc md bi translated">实现<code class="fe ni nj nk mr b">ControlValueAccessor</code>接口方法</li></ol><p id="303a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b">NG_VALUE_ACCESSOR</code> provider指定了一个实现<code class="fe ni nj nk mr b">ControlValueAccessor</code>接口的类，Angular使用它来设置与<code class="fe ni nj nk mr b">formControl</code>的同步。通常是注册提供者的组件(或指令)的类。</p><p id="04d2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有表单指令都使用标记<code class="fe ni nj nk mr b">NG_VALUE_ACCESSOR</code>和一个合适的访问器注入值访问器:</p><ul class=""><li id="c41b" class="lt lu it jz b ka kb ke kf ki nl km nm kq nn ku ma mb mc md bi translated">一个非内置的访问器(就像我们将要实现的)</li><li id="62c3" class="lt lu it jz b ka me ke mf ki mg km mh kq mi ku ma mb mc md bi translated"><code class="fe ni nj nk mr b">DefaultValueAccessor</code></li></ul><p id="8156" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们只能为每个元素定义一个自定义访问器。</p><p id="d8a1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么，让我们来定义提供者:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="c824" class="mv kw it mr b gy mw mx l my mz">@Component({<br/>...<br/>providers: [{<br/>   <strong class="mr iu">provide</strong>: <strong class="mr iu">NG_VALUE_ACCESSOR</strong>,<br/>   <strong class="mr iu">useExisting</strong>: <strong class="mr iu">forwardRef</strong>(() =&gt; <strong class="mr iu">FormRichEditorComponent</strong>),<br/>   multi: true<br/>}]</span></pre><p id="8fcd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">什么是forwardRef，为什么我们在这里使用它？</p><p id="92a4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在官方的角度文档中，我们可以看到以下关于<code class="fe ni nj nk mr b"><em class="nd">forwardRef</em></code>的定义:</p><blockquote class="na nb nc"><p id="8e72" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated">允许引用尚未定义的引用。</p><p id="d3ba" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated">例如，<code class="fe ni nj nk mr b"><em class="it">forwardRef</em></code>被用在为了DI的目的我们需要引用的<code class="fe ni nj nk mr b"><em class="it">token</em></code>被声明，但是还没有被定义的时候。当我们在创建查询时使用的<code class="fe ni nj nk mr b"><em class="it">token</em></code>尚未定义时，也会用到它。</p></blockquote><p id="4b2e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此需要<code class="fe ni nj nk mr b"><em class="nd">forwardRef</em></code>,因为当提供者注册时我们的类还没有被定义，我们需要告诉<strong class="jz iu">提供者构造函数</strong>,这样它可以等待类被定义。</p><p id="7b30" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们已经定义了我们的<code class="fe ni nj nk mr b">NG_VALUE_ACCESSOR</code>提供者，所以让我们实现<code class="fe ni nj nk mr b">ControlValueAccessor</code>接口:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3531" class="mv kw it mr b gy mw mx l my mz">export class FormRichEditorComponent <strong class="mr iu">implements</strong> OnInit, OnChanges, <strong class="mr iu">ControlValueAccessor</strong> {<br/>   ...<br/>   ngOnInit(): void {<br/>      ...<br/>      this.editor.on('editor-change', (eventName, ...args) =&gt; {<br/><strong class="mr iu">         this.onChange(this.editor.getContents());<br/></strong>      })<br/>   }</span><span id="41d6" class="mv kw it mr b gy nh mx l my mz"><strong class="mr iu">   onChange = (delta: any) =&gt; {};<br/>   <br/>   onTouched = () =&gt; {<br/>      this.touched = true;<br/>   };</strong></span><span id="1501" class="mv kw it mr b gy nh mx l my mz"><strong class="mr iu">   writeValue(delta: any): void {</strong><br/>      this.editor.setContents(delta);<br/>      this._value = delta;<br/><strong class="mr iu">   }</strong></span><span id="e361" class="mv kw it mr b gy nh mx l my mz">   <strong class="mr iu">registerOnChange(fn: (v: any) =&gt; void): void {<br/>      this.onChange = fn;<br/>   }</strong></span><span id="b72c" class="mv kw it mr b gy nh mx l my mz">   <strong class="mr iu">registerOnTouched(fn: () =&gt; void): void {<br/>     this.onTouched = fn;<br/>   }</strong></span></pre><p id="2942" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">根据官方角度文件:</p><ul class=""><li id="d131" class="lt lu it jz b ka kb ke kf ki nl km nm kq nn ku ma mb mc md bi translated"><code class="fe ni nj nk mr b">writeValue</code>:向元素写入一个新值。</li><li id="4cd3" class="lt lu it jz b ka me ke mf ki mg km mh kq mi ku ma mb mc md bi translated"><code class="fe ni nj nk mr b">registerOnChange</code>:注册一个回调函数，当UI中控件的值改变时调用该函数。</li><li id="4172" class="lt lu it jz b ka me ke mf ki mg km mh kq mi ku ma mb mc md bi translated"><code class="fe ni nj nk mr b">registerOnTouched</code>:注册表单API在初始化时调用的回调函数，在模糊时更新表单模型。</li></ul><p id="9715" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，在<code class="fe ni nj nk mr b">registerOnChange</code>中，我们简单地保存对由<code class="fe ni nj nk mr b">formControl</code>传递的回调<code class="fe ni nj nk mr b">fn</code>函数的引用。我们将在每次编辑器内容改变时触发它。在<code class="fe ni nj nk mr b">writeValue</code>方法中，我们将内容设置为富编辑器。最后，在<code class="fe ni nj nk mr b">registerOnTouched</code>中，我们保存了对由<code class="fe ni nj nk mr b">formControl</code>传递的回调<code class="fe ni nj nk mr b">fn</code>函数的引用。</p><p id="ff21" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以上面的功能交互看起来像这样:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/c5c5ed041bc4cf791f27c6ab08ba1289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXBRKWr5R0a1kkA6kG6vKg.png"/></div></div></figure><p id="5c7f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过比较我们在开始时创建的简单包装器和controlValueAccessor，我们可以看到与父组件的交互有点不同，而与Quill编辑器的交互是相同的。<br/>我们用<code class="fe ni nj nk mr b">writeValue</code>替换了<code class="fe ni nj nk mr b">ngOnChanges</code>，这里我们想要改变视图值，我们用<code class="fe ni nj nk mr b">this.onChange(this.editor.getContents())</code>替换了<code class="fe ni nj nk mr b">this.changed.emit(this.editor.getContents())</code>，这里我们想要通知表单一个改变。</p><p id="5e7d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们唯一要做的事情，就是调用父组件中的组件。让我们开始吧。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9b93" class="mv kw it mr b gy mw mx l my mz">@Component({<br/>  selector: 'my-app',<br/>  template: `<br/>      &lt;span&gt;Current Editor's value: {{ctrl.value}}&lt;/span&gt;<br/>     <strong class="mr iu"> &lt;rich-editor [formControl]="ctrl"&gt;&lt;/rich-editor&gt;</strong><br/>  `<br/>})<br/>export class AppComponent {<br/>  <strong class="mr iu">ctrl = new FormControl();</strong><br/>}</span></pre><p id="6339" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们的自定义形式与角反应形式相连接！</p><p id="9415" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的下一步是连接我们的形式领域与角材料。</p><p id="318c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您试图将我们刚刚创建的表单字段包装在一个<code class="fe ni nj nk mr b">mat-form-field</code>标签中，您将会得到一个如下所示的错误:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2250" class="mv kw it mr b gy mw mx l my mz">mat-form-field must contain a MatFormFieldControl</span></pre><p id="7302" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那是因为我们的组件没有实现<code class="fe ni nj nk mr b">MatFormFieldControl</code>。</p><h1 id="7fdf" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">实现MatFormFieldControl</h1><p id="1585" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">第一步是提供我们的新组件作为<code class="fe ni nj nk mr b">MatFormFieldControl.</code>的实现</p><blockquote class="na nb nc"><p id="760c" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated"><code class="fe ni nj nk mr b">MatFormFieldControl</code>是一个<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>知道如何使用的接口。</p></blockquote><p id="d65e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后，我们向我们的组件添加一个提供者，这样表单域将能够将其作为<code class="fe ni nj nk mr b">MatFormFieldControl</code>注入(就像我们之前对<code class="fe ni nj nk mr b">ControlValueAccessor</code>所做的那样)。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="47eb" class="mv kw it mr b gy mw mx l my mz">@Component({<br/>...<br/>providers: [<br/> {<br/>   provide: NG_VALUE_ACCESSOR,<br/>   useExisting: forwardRef(() =&gt; FormRichEditorComponent),<br/>   multi: true<br/> },<br/> <strong class="mr iu">{<br/>   provide: MatFormFieldControl,<br/>   useExisting: FormRichEditorComponent<br/> }</strong><br/>]</span><span id="7711" class="mv kw it mr b gy nh mx l my mz">export class FormRichEditorComponent implements OnInit, ControlValueAccessor, <strong class="mr iu">MatFormFieldControl&lt;any&gt;</strong>) {</span><span id="ce27" class="mv kw it mr b gy nh mx l my mz">...</span></pre><p id="9fc8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这设置了我们的组件，所以它可以与<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;.</code>一起工作。现在我们需要实现接口声明的方法和属性。</p><h1 id="106b" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak"> MatFormFieldControl属性</strong></h1><p id="eebe" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">stateChanges</strong></code></p><p id="61a4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>使用<code class="fe ni nj nk mr b">OnPush</code>变更检测策略，所以我们需要让它知道表单域控件中发生了什么事情，可能需要表单域运行变更检测。我们可以通过<code class="fe ni nj nk mr b">stateChanges</code>属性做到这一点。</p><p id="fd48" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当我们的组件被破坏时，我们应该确保完成<code class="fe ni nj nk mr b">stateChanges</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ef61" class="mv kw it mr b gy mw mx l my mz"><strong class="mr iu">stateChanges = new Subject&lt;void&gt;();</strong></span><span id="28c5" class="mv kw it mr b gy nh mx l my mz">ngOnDestroy() {<br/><strong class="mr iu">  this.stateChanges.complete();</strong><br/>}</span></pre><p id="f848" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们这样做是因为当值、焦点、触摸状态、禁用和错误状态改变时，我们需要在<code class="fe ni nj nk mr b">stateChanges</code>上发出信号。我稍后会解释。</p><p id="042f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">ngControl</strong></code></p><p id="7f58" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该属性允许表单域控件指定绑定到该组件的<code class="fe ni nj nk mr b">@angular/forms</code>控件。因为我们已经将组件设置为充当<code class="fe ni nj nk mr b">ControlValueAccessor</code>，所以我们将在组件中将它设置为<code class="fe ni nj nk mr b">this</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="69ee" class="mv kw it mr b gy mw mx l my mz">constructor(public elRef: ElementRef, <strong class="mr iu">public injector: Injector</strong>) {}</span><span id="64fe" class="mv kw it mr b gy nh mx l my mz">ngOnInit() {<br/>   <strong class="mr iu">this.ngControl = this.injector.get(NgControl);<br/>   if (this.ngControl != null) { this.ngControl.valueAccessor = this; }</strong><br/>...<br/>}</span></pre><blockquote class="na nb nc"><p id="9cd2" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated">注意，我们没有在<code class="fe ni nj nk mr b"><em class="it">constructor</em></code>注入<code class="fe ni nj nk mr b"><em class="it">ngControl</em></code>，因为它导致<code class="fe ni nj nk mr b"><em class="it">Cyclic Dependency</em></code>。</p><p id="4b19" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated">我们可以通过<code class="fe ni nj nk mr b"><em class="it">Injector</em></code>注入它来避免错误。</p></blockquote><p id="01c7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要导入<code class="fe ni nj nk mr b">Injector.</code></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0226" class="mv kw it mr b gy mw mx l my mz">import { Component, Input, OnInit, ElementRef, ViewChild, Output, forwardRef, <strong class="mr iu">Injector </strong>} from '@angular/core';</span></pre><p id="6d02" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">controlType</strong></code></p><p id="a2f3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个属性允许我们为表单域中的控件类型指定一个唯一的字符串。<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>将在此类型的基础上添加一个额外的类，该类可用于轻松地将特殊样式应用于包含特定类型控件的<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>。在我们的组件中，我们将使用<code class="fe ni nj nk mr b">richeditor</code>作为我们的控件类型，这将导致表单字段添加类<code class="fe ni nj nk mr b">mat-form-field-richeditor</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7a27" class="mv kw it mr b gy mw mx l my mz">controlType = 'richeditor';</span></pre><p id="f769" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">errorState</strong></code></p><p id="f1aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该属性指示关联的<code class="fe ni nj nk mr b">NgControl</code>是否处于错误状态。最初我们将它设置为false，但是我们在<strong class="jz iu"> ngDoCheck </strong>检查变化，并根据控件的有效性更改它的值。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="7a2a" class="mv kw it mr b gy mw mx l my mz"><strong class="mr iu">errorState = false;</strong></span><span id="769b" class="mv kw it mr b gy nh mx l my mz">...</span><span id="133f" class="mv kw it mr b gy nh mx l my mz"><strong class="mr iu">ngDoCheck(): void {<br/>   if(this.ngControl) {<br/>      this.errorState = this.ngControl.invalid &amp;&amp; this.ngControl.touched;<br/>     this.stateChanges.next();<br/>   }</strong><br/><strong class="mr iu">}</strong></span></pre><p id="853e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你在上面的代码片段中注意到了，我们使用了<code class="fe ni nj nk mr b">ngDoCheck</code>生命周期钩子，所以我们需要导入它并通知类我们将要实现它。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a848" class="mv kw it mr b gy mw mx l my mz">import { Component, Input, OnInit, ElementRef, ViewChild, Output,  forwardRef, Injector,  <strong class="mr iu">DoCheck </strong>} from '@angular/core';</span><span id="36e6" class="mv kw it mr b gy nh mx l my mz">...</span><span id="4421" class="mv kw it mr b gy nh mx l my mz">export class FormRichEditorComponent implements OnInit, <strong class="mr iu">DoCheck</strong>, ControlValueAccessor, MatFormFieldControl&lt;any&gt; {</span></pre><p id="e90f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">value</strong></code></p><p id="6d89" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个属性允许我们设置或获取控件的值。我们应该用实现<code class="fe ni nj nk mr b">MatFormFieldControl</code>时用于类型参数的相同类型来定义它。我们将使用的类型是<code class="fe ni nj nk mr b">any,</code>，因为鹅毛笔编辑器的值是一个增量。正如您在下面看到的，当值发生变化时，我们运行变化检测器。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a2aa" class="mv kw it mr b gy mw mx l my mz">_value: any;<strong class="mr iu"><br/></strong><br/><strong class="mr iu">get value(): any {<br/>   return this._value;<br/>}</strong></span><span id="0cd3" class="mv kw it mr b gy nh mx l my mz"><strong class="mr iu">set value(value) {<br/>   this._value = value;<br/>   this.editor.setContents(this._value);<br/>   this.onChange(value);<br/>   this.stateChanges.next();<br/>}</strong></span></pre><p id="f93a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">placeholder</strong></code></p><p id="b5be" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们让用户可以通过<code class="fe ni nj nk mr b">@Input()</code>指定定制表单域的<code class="fe ni nj nk mr b">placeholder</code>(就像matInput和mat-select做的那样)。由于占位符的值可能会随着时间而改变，我们需要确保在占位符改变时通过在<code class="fe ni nj nk mr b">stateChanges</code>流上发出来触发父表单字段中的改变检测。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="270f" class="mv kw it mr b gy mw mx l my mz">@Input()<br/>get placeholder() {<br/>   return this._placeholder;<br/>}</span><span id="7f51" class="mv kw it mr b gy nh mx l my mz">set placeholder(plh) {<br/>   this._placeholder = plh;<br/>   this.stateChanges.next();<br/>}</span><span id="9d1f" class="mv kw it mr b gy nh mx l my mz">public _placeholder: string;</span></pre><p id="2f97" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">focused</strong></code></p><p id="ba2b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此属性指示表单域控件是否应被视为处于焦点状态。</p><blockquote class="na nb nc"><p id="6f59" class="jx jy nd jz b ka kb kc kd ke kf kg kh ne kj kk kl nf kn ko kp ng kr ks kt ku im bi translated">当表单域处于焦点状态时，它会以纯色下划线显示。</p></blockquote><p id="7e8e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以使用来自<code class="fe ni nj nk mr b">@angular/cdk</code>的<code class="fe ni nj nk mr b">FocusMonitor</code>来轻松检查这一点。我们还需要记住在<code class="fe ni nj nk mr b">stateChanges</code>流上发出，这样就可以进行变更检测。</p><p id="e3fb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当组件被销毁时，我们还希望停止监视焦点变化。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9501" class="mv kw it mr b gy mw mx l my mz">constructor(public elRef: ElementRef, public injector: Injector, fm: FocusMonitor) {<br/>...</span><span id="9655" class="mv kw it mr b gy nh mx l my mz"><strong class="mr iu">   fm.monitor(elRef.nativeElement, true).subscribe(origin =&gt; {<br/>     this.focused = !!origin;<br/>     this.stateChanges.next();<br/>   });<br/>   <br/>   </strong>ngOnDestroy() {<br/>     ...<br/><strong class="mr iu">     this.fm.stopMonitoring(this.elRef.nativeElement);<br/></strong>   }<br/>}</span></pre><p id="9d7f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">required</strong></code></p><p id="cba2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此属性用于指示是否需要输入。<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>使用此信息向占位符添加所需的指示器。如果所需的状态发生变化，不要忘记运行变化检测。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5376" class="mv kw it mr b gy mw mx l my mz">@Input()<br/>get required() {<br/>   return this._required;<br/>}</span><span id="184a" class="mv kw it mr b gy nh mx l my mz">set required(req) {<br/>   this._required = coerceBooleanProperty(req);<br/>   this.stateChanges.next();<br/>}</span><span id="a49b" class="mv kw it mr b gy nh mx l my mz">public _required = false;</span></pre><p id="743c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们还必须导入<code class="fe ni nj nk mr b">coerceBooleanProperty.</code></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="dd7d" class="mv kw it mr b gy mw mx l my mz">import { coerceBooleanProperty } from '@angular/cdk/coercion';</span></pre><p id="4574" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">disabled</strong></code></p><p id="5670" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该属性通知表单域何时应处于禁用状态。同样，如果禁用状态发生变化，不要忘记运行变化检测。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="cf3e" class="mv kw it mr b gy mw mx l my mz">@Input()<br/>get disabled() {<br/>   return this._disabled;<br/>}</span><span id="731f" class="mv kw it mr b gy nh mx l my mz">set disabled(dis) {<br/>   this._disabled = coerceBooleanProperty(dis);<br/>   this.stateChanges.next();<br/>}</span><span id="94d3" class="mv kw it mr b gy nh mx l my mz">public _disabled = false;</span></pre><p id="70f5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">id</strong></code></p><p id="ca93" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该属性返回组件模板中一个元素的ID，我们希望<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>将它的所有标签和提示与该元素相关联。在这种情况下，我们将使用host元素，并为它生成一个惟一的ID。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0964" class="mv kw it mr b gy mw mx l my mz">static nextId = 0;</span><span id="5b3b" class="mv kw it mr b gy nh mx l my mz">@HostBinding() id = `rich-editor-input-${<!-- -->FormRichEditorComponent<!-- -->.nextId++}`;</span></pre><p id="b20d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如我们之前所做的，我们必须导入<code class="fe ni nj nk mr b">HostBinding</code></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e864" class="mv kw it mr b gy mw mx l my mz">import { Component, Input, OnInit, ElementRef, ViewChild, Output, forwardRef, Injector,  DoCheck, <strong class="mr iu">HostBinding </strong>} from '@angular/core';</span></pre><p id="ea4b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">empty</strong></code></p><p id="a39a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此属性指示表单域控件是否为空。对于我们的控件，如果它没有任何字符，我们就认为它是空的。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0cee" class="mv kw it mr b gy mw mx l my mz">get empty() {<br/>   const commentText = this.editor.getText().trim();<br/>   return commentText ? false : true;<br/>}</span></pre><p id="8d49" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">shouldLabelFloat</strong></code></p><p id="6d92" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此属性用于指示标签是否应处于浮动位置。我们将使用与<code class="fe ni nj nk mr b">matInput</code>相同的逻辑，并在输入被聚焦或非空时浮动占位符。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b31d" class="mv kw it mr b gy mw mx l my mz">@HostBinding('class.floating')<br/>get shouldLabelFloat() {<br/>  return this.focused || !this.empty;<br/>}</span></pre><p id="63aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为占位符在不浮动的时候会和我们的控件重叠，所以我们应该稍微改变一下它的位置。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a7ae" class="mv kw it mr b gy mw mx l my mz">.mat-form-field-type-richeditor.mat-form-field-can-float .mat-form-field-label-wrapper, .mat-form-field-type-file.mat-form-field-can-float .mat-form-field-label-wrapper {<br/>   top: -22px;<br/>}</span><span id="c887" class="mv kw it mr b gy nh mx l my mz">.mat-form-field-type-richeditor.mat-form-field-should-float .mat-form-field-label-wrapper, .mat-form-field-type-file.mat-form-field-should-float .mat-form-field-label-wrapper {<br/>   top: -8px;<br/>}</span></pre><p id="cb90" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b">setDescribedByIds(ids: string[])</code></p><p id="29c0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个方法被<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>用来指定应该用于组件的<code class="fe ni nj nk mr b">aria-describedby</code>属性的id。该方法有一个参数，id列表，我们只需要将给定的id应用到我们的主机元素。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d450" class="mv kw it mr b gy mw mx l my mz">@HostBinding('attr.aria-describedby') describedBy = '';</span><span id="fb99" class="mv kw it mr b gy nh mx l my mz">setDescribedByIds(ids: string[]) {<br/>   this.describedBy = ids.join(' ');<br/>}</span></pre><p id="6ac0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们必须将这些id应用于我们的主机元素。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3bae" class="mv kw it mr b gy mw mx l my mz">@Component({<br/>...<br/>   <strong class="mr iu">host: {<br/>      '[id]': 'id',<br/>      '[attr.aria-describedby]': 'describedBy'<br/>   }</strong><br/>...<br/>})</span></pre><p id="b2e1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ni nj nk mr b"><strong class="jz iu">onContainerClick(event: MouseEvent)</strong></code></p><p id="0837" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当单击表单域时，将调用此方法。它允许我们的组件挂接并处理点击。该方法有一个参数，即点击的<code class="fe ni nj nk mr b">MouseEvent</code>。在我们的例子中，如果用户无论如何都不打算点击<code class="fe ni nj nk mr b">&lt;div&gt;</code>，我们将只关注<code class="fe ni nj nk mr b">&lt;div&gt;</code>。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2232" class="mv kw it mr b gy mw mx l my mz">onContainerClick(event: MouseEvent) {<br/>   if ((event.target as Element).tagName.toLowerCase() != 'div') {<br/>      this.container.nativeElement.querySelector('div').focus();<br/>   }<br/>}</span></pre><h1 id="00e6" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">尝试</h1><p id="f3e8" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki mj kk kl km mk ko kp kq ml ks kt ku im bi translated">现在我们已经完全实现了<code class="fe ni nj nk mr b">ControlValueAccessor</code>和<code class="fe ni nj nk mr b">MatFormFieldControl</code>接口，我们准备好测试我们的组件了！我们需要做的就是把它放在一个<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>里面</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0d64" class="mv kw it mr b gy mw mx l my mz">&lt;mat-form-field&gt;<br/>   <strong class="mr iu">&lt;rich-editor [formControl]="ctrl"&gt;&lt;/rich-editor&gt;</strong><br/>&lt;/mat-form-field&gt;</span></pre><p id="b974" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们还获得了<code class="fe ni nj nk mr b">&lt;mat-form-field&gt;</code>的所有特性，比如浮动占位符、前缀、后缀、提示和错误。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4000" class="mv kw it mr b gy mw mx l my mz">&lt;mat-form-field&gt;<br/>  <strong class="mr iu">&lt;rich-editor [formControl]="ctrl"&gt;&lt;/rich-editor&gt;<br/></strong>  &lt;mat-hint&gt;Include your formatted text&lt;/mat-hint&gt;<br/>  &lt;mat-error&gt;This field cannot be empty!&lt;/mat-error&gt;<br/>&lt;/mat-form-field&gt;</span></pre><p id="acd7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">仅此而已！感谢您的阅读！</p></div></div>    
</body>
</html>