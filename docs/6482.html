<html>
<head>
<title>Interfaces vs Types in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的接口与类型</h1>
<blockquote>原文：<a href="https://itnext.io/interfaces-vs-types-in-typescript-cf5758211910?source=collection_archive---------1-----------------------#2021-11-30">https://itnext.io/interfaces-vs-types-in-typescript-cf5758211910?source=collection_archive---------1-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ddc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有什么区别</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/50954fd598f1ad853c9013d3d3287498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAxmxaUqrpy5Jzj2zr0OeA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@davidpisnoy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> David Pisnoy </a>在<a class="ae kv" href="https://unsplash.com/s/photos/paint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在做Typescript项目的时候，有的开发者用<code class="fe ls lt lu lv b">interfaces</code>，有的开发者用<code class="fe ls lt lu lv b">types</code>。尽管如此，我还是尝试使用接口和类型。第一次我很困惑，因为他们很像。那么，我应该使用什么接口或类型呢？</p><p id="ca24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你很困惑或者不确定区别在哪里，我们来谈谈不同情况下的最佳实践。</p><h1 id="2364" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">类型与接口</h1><p id="ef3c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在开始之前，我们先来看看什么是接口和类型。</p><p id="1bf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/objects.html" rel="noopener ugc nofollow" target="_blank">在开发阶段是一个有用的工具，它就像你的应用程序中的一个契约，或者类要遵循的语法。该接口也被称为鸭打印，或子类型。如果你有兴趣，你可以在我的另一篇文章</a><a class="ae kv" href="https://blog.logrocket.com/when-how-use-interfaces-classes-typescript/" rel="noopener ugc nofollow" target="_blank">中阅读更多关于何时以及如何在TypeScript </a>中使用接口和类的内容。</p><p id="6ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases" rel="noopener ugc nofollow" target="_blank">类型或类型别名</a>类似于一个接口，为任何类型创建一个新名称。注意，它没有定义新的类型。</p><p id="0df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将使用<a class="ae kv" href="https://www.typescriptlang.org/play/index.html#" rel="noopener ugc nofollow" target="_blank"> Typescript Playground </a>进行编码，而不是创建一个新项目。让我们比较一下如何使用不同类型的类型和接口。</p><h2 id="aedd" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">基元</h2><p id="c750" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">原语只能由<code class="fe ls lt lu lv b">types</code>使用。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="918e" class="mt lx iq lv b gy nj nk l nl nm">type AppName = string<br/>type AppType = string<br/>type AppSize = number</span></pre><p id="2d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">我们不能通过</em> <code class="fe ls lt lu lv b"><em class="nn">interfaces</em></code>创建它们。所以这是他们的第一个区别<em class="nn">。</em></p><h2 id="3e13" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">联合</h2><p id="1497" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" rel="noopener ugc nofollow" target="_blank"> Unions </a>是一个可以存储多种类型值的变量。我们可以通过<code class="fe ls lt lu lv b">types</code>建立工会。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="23cb" class="mt lx iq lv b gy nj nk l nl nm">// AppName - string or undefined<br/>type AppName = string | undefined<br/>type AppType = 'mobile' | 'web' | 'desktop'<br/>type AppSize = number | bigint</span></pre><p id="f724" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们可以通过两种类型创建一个新的union <code class="fe ls lt lu lv b">Employee</code>:</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="f088" class="mt lx iq lv b gy nj nk l nl nm">type Developer = {<br/>  devName: string<br/>}</span><span id="449d" class="mt lx iq lv b gy no nk l nl nm">type Tester = {<br/>  testerName: string<br/>}</span><span id="8f9d" class="mt lx iq lv b gy no nk l nl nm">type Employee = Developer | Tester</span></pre><p id="fbf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们定义一个结合了两个接口的类型:</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="7036" class="mt lx iq lv b gy nj nk l nl nm">interface Developer {<br/>  devName: string<br/>}</span><span id="f0c2" class="mt lx iq lv b gy no nk l nl nm">interface Tester {<br/>  testerName: string<br/>}</span><span id="d786" class="mt lx iq lv b gy no nk l nl nm">type Employee = Developer | Tester</span></pre><p id="3c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该接口不支持联合。</p><h2 id="1d62" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">元组类型</h2><p id="d265" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types" rel="noopener ugc nofollow" target="_blank">元组</a>是一对具有不同类型值的元素。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="5bd4" class="mt lx iq lv b gy nj nk l nl nm">type App = [name: string, type: 'mobile' | 'web' | 'desktop']</span></pre><p id="2a6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe ls lt lu lv b">interface</code>声明一个元组。但是相比<code class="fe ls lt lu lv b">type</code>就不清楚了。我更喜欢使用类型。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="b03e" class="mt lx iq lv b gy nj nk l nl nm">interface AppInfo {<br/>  value: [name: string, type: 'mobile' | 'web' | 'desktop']<br/>}</span></pre><h2 id="cc73" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">功能</h2><p id="8a7c" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们可以使用<code class="fe ls lt lu lv b">types</code>和<code class="fe ls lt lu lv b">interfaces</code>来定义函数:</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="ee7a" class="mt lx iq lv b gy nj nk l nl nm">type runApp = () =&gt; void</span></pre><p id="fe23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，使用<code class="fe ls lt lu lv b">interface</code>似乎有些棘手:</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="f840" class="mt lx iq lv b gy nj nk l nl nm">interface runApp {<br/>  (): void<br/>}</span></pre><h2 id="9751" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">声明合并</h2><p id="bdaa" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" rel="noopener ugc nofollow" target="_blank">声明合并</a>是指TypeScript将两个或两个以上同名的接口编译合并成一个声明。让我们定义两个<code class="fe ls lt lu lv b">App</code>接口:</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="a726" class="mt lx iq lv b gy nj nk l nl nm">interface App {<br/>  name: string<br/>}</span><span id="9862" class="mt lx iq lv b gy no nk l nl nm">interface App {<br/>  type: 'mobile' | 'web' | 'desktop'<br/>}</span><span id="a221" class="mt lx iq lv b gy no nk l nl nm">// TypeScript will automatically merge both App declarations into one<br/>const app: App = {<br/>  name: 'facebook',<br/>  type: 'mobile'<br/>}</span></pre><p id="3bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">如果我们试图声明两个</em> <code class="fe ls lt lu lv b"><em class="nn">App</em></code> <em class="nn"> via类型，就会抛出错误。</em>因为和<code class="fe ls lt lu lv b">types</code>不配合。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="4116" class="mt lx iq lv b gy nj nk l nl nm">// error - Duplicate identifier 'App'.<br/>type App {<br/>  name: string<br/>}</span><span id="e92d" class="mt lx iq lv b gy no nk l nl nm">// error - Duplicate identifier 'App'.<br/>type App {<br/>  type: 'mobile' | 'web' | 'desktop'<br/>}</span></pre><h2 id="9dde" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">交集</h2><p id="2cce" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types" rel="noopener ugc nofollow" target="_blank">交集</a>通过<code class="fe ls lt lu lv b">&amp;</code>关键字将多个类型合并为一个类型。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="8770" class="mt lx iq lv b gy nj nk l nl nm">interface Developer {<br/>  devName: string<br/>}</span><span id="defa" class="mt lx iq lv b gy no nk l nl nm">interface Tester {<br/>  testerName: string<br/>}</span><span id="a161" class="mt lx iq lv b gy no nk l nl nm">type Employee = Developer &amp; Tester</span></pre><p id="a4a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">但是它没有将多种类型合并到一个接口中。</em></p><h2 id="bd32" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">遗产</h2><p id="877a" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">继承</a>是从父代继承属性和方法的能力。这只能使用<code class="fe ls lt lu lv b">interfaces</code>来实现。T <em class="nn">他的不可能跟</em> <code class="fe ls lt lu lv b"><em class="nn">types</em></code> <em class="nn">。</em></p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="5711" class="mt lx iq lv b gy nj nk l nl nm">interface Developer {<br/>  devName: string<br/>}</span><span id="ab1d" class="mt lx iq lv b gy no nk l nl nm">interface Tester {<br/>  testerName: string<br/>}</span><span id="5552" class="mt lx iq lv b gy no nk l nl nm">interface Employee extends Developer, Tester {}</span><span id="ee6c" class="mt lx iq lv b gy no nk l nl nm">class User implements Employee {<br/>  devName = "Dev Name"<br/>  testerName = "Tester Name"<br/>}</span></pre><h1 id="136f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="5110" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在本文中，我们讨论了类型和接口之间的主要区别。它们非常相似，但是您应该使用什么取决于您的用例。</p><p id="2041" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读——我希望这篇文章对你有用。编码快乐！</p><h1 id="44a9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">资源</h1><div class="np nq gp gr nr ns"><a href="https://ultimatecourses.com/blog/typescript-interfaces-vs-types" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">类型脚本接口与类型-终极课程</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">许多开发人员在选择TypeScript接口还是类型时感到困惑。这可能是因为他们…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">ultimatecourses.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kp ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://blog.logrocket.com/types-vs-interfaces-in-typescript/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">TypeScript - LogRocket博客中的类型与接口</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在JavaScript中进行静态类型检查的想法真的很棒，而且TypeScript的采用正在增长…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">blog.logrocket.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og kp ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://dev.to/saadsharfuddin/type-vs-interface-in-typescript-35i6" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">TypeScript中的类型与接口</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">当我第一次开始使用TypeScript时，我很快发现自己在质疑类型和接口在…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">开发到</p></div></div><div class="ob l"><div class="oi l od oe of ob og kp ns"/></div></div></a></div></div></div>    
</body>
</html>