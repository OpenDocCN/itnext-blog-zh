<html>
<head>
<title>How to Unit Test Angular CanDeactivate Guards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何单元测试角形CanDeactivate防护装置</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-unit-test-angular-candeactivate-guards-82dd51e4cccd?source=collection_archive---------4-----------------------#2018-08-09">https://itnext.io/how-to-unit-test-angular-candeactivate-guards-82dd51e4cccd?source=collection_archive---------4-----------------------#2018-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42e8c78880c3c22ae9ceb3ba1b996daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2g6G4AfQNak6qi4p4oFuyw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">纽约洛克菲勒中心的保安。2018贾里德·尤塞</figcaption></figure><p id="0aa1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">CanDeactivate guards通常用于防止用户离开肮脏的表单，即编辑内容未保存的表单。我今天在工作中发现自己处于这种情况，并且无法在web上找到如何对防护进行单元测试的解决方案。问题在于，防护是依赖于组件的服务，而不是相反。这和我迄今为止看到的所有模式完全相反。因此，我深入研究并开始试验，对角度依赖注入的内部工作方式有了更好的理解。最后，如果你使用一个接口而不是一个硬组件依赖，那就更有意义了。</p><p id="35f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我建议先把<a class="ae la" href="https://github.com/fivedice/ngx-candeactivate-test" rel="noopener ugc nofollow" target="_blank">回购</a>分出来，玩一玩，了解一下它是如何运作的。我们不会详细讨论组件和UI，只讨论测试的防护和实现。你会想看看GuardedComponent并理解它的canDeactivate方法，但是为了测试，我们只需要理解它，因为它完全被模仿掉了。</p><p id="cc28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们从一个接口开始，这个接口允许我们以抽象的方式处理任何需要这种保护的组件。这将使嘲笑变得容易得多。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="9a3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">警卫本身就很直白。它实现了<code class="fe lh li lj lk b">CanDeactivate&lt;T&gt;</code>，其中T是我们的接口。它验证实现该接口的组件是否正确执行了该操作(第11行)(<em class="ll">注意:这似乎是一种常见的模式，以防你设法欺骗编译器？</em>)然后调用接口方法。就是这样。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="0c6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在单元测试中，我们想要模拟实现接口的实际组件。我们不希望在测试中必须导入并提供所有组件的依赖项。在我们的spec文件中，我们将添加一个实现接口的MockComponent。(<em class="ll">注意:我们还没有用</em> <code class="fe lh li lj lk b">@Component</code> <em class="ll">来装饰它，但是我们可以，而且它仍然可以工作。</em>)在第3行，我们添加了一个<code class="fe lh li lj lk b">returnValue: boolean</code>，我们可以在测试中设置它，这样我们就可以模拟真实组件的canDeactivate响应。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="3641" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们看看我们的测试设置:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="5b57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意第9行。我们提供我们的模拟就像一项服务！对，这个真的管用！即使没有所有常见的装饰。</p><p id="c0c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们要做的就是为不同的场景设置mockComponent的returnValue。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f73c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第一个测试中，我们从组件中的canActivate返回一个布尔值。例如，当表单不脏时，真正的组件会这样做。如果你试图从原始形态航行，警卫不会阻止你。在这种情况下，我们只是根据用户是否在UI中打开了保护来决定。</p><p id="08e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第二个和第三个测试中，我们返回了一个可观察的结果，就像用户打开了UI中的防护。这将导致显示灌注确认对话框。它有<code class="fe lh li lj lk b">accept()</code>和<code class="fe lh li lj lk b">reject()</code>方法，在支持可观察对象的主题上分别调用<code class="fe lh li lj lk b">next(true)</code>和<code class="fe lh li lj lk b">next(false)</code>。</p><p id="7ec2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不可否认，我一开始是在没有接口的情况下构建所有这些的。因此，我的模拟扩展GuardedComponent。它是一个组件。因此，我必须导入我所有的依赖项。将组件视为提供者是一件非常落后的事情！但它确实起作用了！这个界面清理了很多东西，并且更加符合官方的Angular文档。</p><p id="3b3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我对“记录你所学到的东西”这种事情还很陌生。我希望这能对你有所帮助，我很好奇你是否以不同的方式处理了这个问题。</p><p id="6290" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读，如果你喜欢这篇文章，请给我一些掌声。</p></div></div>    
</body>
</html>