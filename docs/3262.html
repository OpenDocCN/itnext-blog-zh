<html>
<head>
<title>React Router transitions with Lazy Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过延迟加载对路由器转换做出反应</h1>
<blockquote>原文：<a href="https://itnext.io/react-router-transitions-with-lazy-loading-2faa7a1d24a?source=collection_archive---------1-----------------------#2019-11-08">https://itnext.io/react-router-transitions-with-lazy-loading-2faa7a1d24a?source=collection_archive---------1-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7dad631239b85609a436bf91f815d7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6-OAmCy_W_ppiyxw.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://ticotimes.net/2015/10/17/11-little-known-sloth-facts" rel="noopener ugc nofollow" target="_blank">https://tico times . net/2015/10/17/11-鲜为人知-树懒-事实</a></figcaption></figure><p id="5e56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本指南建立在我之前的指南之上，在那里我解释了如何用react-router-dom和react-pose获得路线转换/动画。</p><div class="le lf gp gr lg lh"><a href="https://medium.com/capgemini-norway/the-holy-grail-of-react-router-transitions-on-the-web-a1293591e34f" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">React路由器在网络上过渡的圣杯</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">去年我一直在用react-router-dom和react-pose完善路由转换。本周我能够…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><p id="b6e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个相当简单的设置。当您开始扩展您的应用程序，并且您的代码库开始增长时，您可能希望向组件添加一些延迟加载。有了Create React App，这真的很简单。您只需添加一个暂记包装器，并以异步方法导入组件:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4127" class="mf mg it mb b gy mh mi l mj mk"><em class="ml">const Lazy</em>Component = React.lazy(() =&gt; <em class="ml">import</em>("./Component"));</span><span id="0a46" class="mf mg it mb b gy mm mi l mj mk">return (<br/>  &lt;React.Suspense <em class="ml">fallback</em>={&lt;div /&gt;}&gt;<br/>    &lt;LazyComponent /&gt;<br/>  &lt;/React.Suspense&gt;<br/>)</span></pre><p id="1731" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当您刷新页面时，这会破坏初始的路由动画，因为异步操作占用了JavaScript中的单线程运行时间。</p><p id="2701" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们能做些什么来解决这个问题呢？解决方案是在早期预加载组件。这实际上是我找到的处理这个问题的唯一解决方案，所以请耐心等待，因为这可能看起来像一个黑客。</p><h1 id="e289" class="mn mg it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">在添加预加载之前</h1><p id="5c7d" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">单击“Two”页面，看看它是如何跳过动画的，因为组件需要在实际动画之前预加载。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="e4a0" class="mn mg it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">添加预加载后</h1><p id="4816" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">我们仍然得到懒惰加载的组件，动画是完整的。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="441f" class="mn mg it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">履行</h1><p id="b3e6" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">本质上，您需要在渲染优先级的早期将所有惰性加载的组件加载到一个隐藏的div中。在这种情况下，明智的做法是将路由路径和组件放在一个数组的对象中。这样，您可以将它们导出到实际的React路由器<switch>组件和PreloadLazyComponents.js文件中。</switch></p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="nr nq l"/></div></figure><p id="8d89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个实现的超时是为了在我们知道所有组件都已经实现时从DOM中删除它们。此外，我们将把<em class="ml">预载</em>道具传递给所有被预载的组件。这是为了控制它不在子组件(如页面1)中执行任何API请求。</p><p id="f754" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设Page1有一个调用API的useEffect。您不希望过早地这样做，所以useEffect必须重写为</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="01c5" class="mf mg it mb b gy mh mi l mj mk">!preload &amp;&amp; useAsyncFetch("/api")</span></pre><p id="1123" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您的组件可能依赖于Redux中尚未使用的数据。因此，您必须确保组件不会在没有数据的情况下崩溃。我建议您在渲染任何其他组件之前先渲染PreloadLazyComponents。然而，这可能意味着您没有在预加载的组件中准备好数据。我通过检查变量是否存在来解决这个问题。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1340" class="mf mg it mb b gy mh mi l mj mk">const Page1 = () =&gt; {<br/>  const user = useSelector(state =&gt; state.user);</span><span id="effd" class="mf mg it mb b gy mm mi l mj mk">if (!user) return null;<br/>  else return &lt;div&gt; page 1 says hi to { user.name }! &lt;/div&gt;<br/>}</span></pre><p id="ab18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a515" class="mf mg it mb b gy mh mi l mj mk">const Page1 = () =&gt; {</span><span id="0c2e" class="mf mg it mb b gy mm mi l mj mk">const [ data, setData ] = React.useState(null)<br/>  const user = useSelector(state =&gt; state.user)</span><span id="00c6" class="mf mg it mb b gy mm mi l mj mk">React.useEffect( () =&gt; {<br/>    setData( user ? fetchDataByUserId(user.id) : null )</span><span id="0747" class="mf mg it mb b gy mm mi l mj mk">}</span><span id="c3f0" class="mf mg it mb b gy mm mi l mj mk">return &lt;div&gt;{data}&lt;/div&gt;</span><span id="101e" class="mf mg it mb b gy mm mi l mj mk">}</span></pre><p id="e0dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，您需要确保您的组件可以在没有数据的情况下呈现。我通过使用react-testing-library为我的所有组件添加测试来解决这个问题，在我的所有reducers中都有一个空状态。当然，您可以使用Enzyme或您喜欢的库来测试这一点。只需呈现没有任何预期状态的组件，并断言它不会崩溃。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a2ab" class="mf mg it mb b gy mh mi l mj mk">test(`&lt;Overview/&gt; renders without data`, <em class="ml">async </em>() =&gt; {<br/>    <em class="ml">// All reducer states are initial and empty<br/>    const </em>store = mockStore(mockInitialReducer); </span><span id="24a6" class="mf mg it mb b gy mm mi l mj mk">    <em class="ml">const </em>{ container } = render(<br/>        &lt;ReduxProvider <em class="ml">store</em>={store}&gt;<br/>            &lt;Router <em class="ml">history</em>={history}&gt;<br/>                &lt;React.Suspense <em class="ml">fallback</em>={&lt;div /&gt;}&gt;<br/>                   &lt;Overview /&gt;<br/>                &lt;/React.Suspense&gt;<br/>            &lt;/Router&gt;<br/>        &lt;/ReduxProvider&gt;<br/>    );<br/>    expect(container).toBeInTheDocument();<br/>});</span></pre><h1 id="70f8" class="mn mg it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">结论</h1><p id="9cdb" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">我知道很多人认为这是过度设计了。不得不检查懒惰加载的组件上的所有变量只是混乱的代码。在应用程序的早期加载大量的组件，只是为了移除它们，这似乎是一件麻烦的事情。然而，如果你想延迟加载组件，并在每次导航时保持你的漂亮动画，这是我通过询问这些库的维护者找到的唯一解决方案。如果你有更好的解决方案，我很乐意看到或听到他们。</p></div></div>    
</body>
</html>