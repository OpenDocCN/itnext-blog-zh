<html>
<head>
<title>Run ASP.NET Core 3 on Kubernetes with Helm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Helm在Kubernetes上运行ASP.NET核心3</h1>
<blockquote>原文：<a href="https://itnext.io/run-asp-net-core-3-on-kubernetes-with-helm-df4c2932acc3?source=collection_archive---------4-----------------------#2019-12-01">https://itnext.io/run-asp-net-core-3-on-kubernetes-with-helm-df4c2932acc3?source=collection_archive---------4-----------------------#2019-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a6bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将一步步向你展示如何在Helm 3的帮助下，在Kubernetes上创建、构建和托管ASP.NET Core 3 web API。</p><p id="3ef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个样本可以在GitHub上找到:<a class="ae kl" href="https://github.com/Crokus/aspnet-core-helm-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/Crokus/aspnet-core-helm-sample</a></p><p id="0d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我一直在使用Windows 10 Pro，但你应该可以在Linux或MacOS上运行它。</p><p id="cb2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续之前，您必须安装一些东西:</p><ul class=""><li id="2a4e" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><a class="ae kl" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> Git </a></li><li id="258a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://hub.docker.com/?overlay=onboarding" rel="noopener ugc nofollow" target="_blank"> Docker桌面</a>—2.1.0.5或更高版本</li><li id="727d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://dotnet.microsoft.com/download/dotnet-core/3.0" rel="noopener ugc nofollow" target="_blank">。网芯3.0 </a></li><li id="f637" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><a class="ae kl" href="https://v3.helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">舵</a> —版本3.0.0或更高</li></ul><p id="201e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是必须的，但是使用<a class="ae kl" href="https://code.visualstudio.com/Download" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>会对整个例子有很大帮助。</p><h1 id="f016" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">目标</h1><blockquote class="ly lz ma"><p id="ed48" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">在“负载平衡器”后面创建三个ASP.NET Core 3 web API实例，这些实例将路由到Kubernetes本地集群上的任何一个。</p></blockquote><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/6c72ba79d32d2607e5c6975b6cc43db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*Wz1KsHkuJHvVL1NZ.gif"/></div></figure><h1 id="5c7c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建ASP.NET核心3 Web API</h1><p id="2e43" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">让我们从使用<code class="fe ms mt mu mv b">dotnet new</code>命令创建一个新的Web API开始。以管理员身份打开Git Bash并输入命令，该命令将在<code class="fe ms mt mu mv b">app</code>目录中创建一个项目模板。</p><p id="bb68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ms mt mu mv b">dotnet new webapi -o app</code></p><p id="0625" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，打开<code class="fe ms mt mu mv b">app</code>目录并启动web API</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="d495" class="na lb iq mv b gy nb nc l nd ne">cd app/<br/>dotnet run watch</span></pre><p id="0e00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到<code class="fe ms mt mu mv b">localhost:5000/weatherforecast</code>以确保应用程序正在运行。</p><h1 id="f331" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">向本地主机添加环境变量</h1><p id="cdd5" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">天气数据很有趣，但是让我们尝试输出环境变量，这些变量将在以后证明我们在不同的主机中。</p><p id="452d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本地主机，我们将使用以下变量:</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="955a" class="na lb iq mv b gy nb nc l nd ne">export APPENVIRONMENT="development"<br/>export APPHOST="local"</span></pre><p id="41f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">停止应用程序并添加一个新的控制器InfoController，它将输出这些变量。请注意设置为根路径的路由属性。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="1840" class="na lb iq mv b gy nb nc l nd ne">namespace app.Controllers<br/>{<br/>    [ApiController]<br/>    [Route("")]<br/>    public class InfoController : ControllerBase<br/>    {<br/>        private readonly ILogger&lt;InfoController&gt; _logger;<br/><br/>        public InfoController(ILogger&lt;InfoController&gt; logger)<br/>        {<br/>            _logger = logger;<br/>        }<br/><br/>        [HttpGet]<br/>        public InfoModel GetInfo()<br/>        {<br/>            return new InfoModel { AppEnvironment = GetEnvironmentVariable("APPENVIRONMENT"), AppHost = GetEnvironmentVariable("APPHOST") };<br/>        }<br/><br/>        private string GetEnvironmentVariable(string name)<br/>        {<br/>            _logger.LogInformation($"Getting environment variable '{name}'.");<br/>            return Environment.GetEnvironmentVariable(name.ToLower()) ?? Environment.GetEnvironmentVariable(name.ToUpper());<br/>        }<br/>    }<br/>}</span></pre><p id="0d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行应用程序，检查<code class="fe ms mt mu mv b">localhost:{port}</code>上的响应。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="e490" class="na lb iq mv b gy nb nc l nd ne">{"appEnvironment":"development","appHost":"local"}</span></pre><p id="d46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经准备好将web API发布到另一台主机上。为此，我们需要为它创建一个docker映像。</p><h1 id="dfc0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建docker图像</h1><p id="c947" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">集装箱化的第一步是创建一个Dockerfile文件。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="f290" class="na lb iq mv b gy nb nc l nd ne">touch Dockerfile</span></pre><p id="ab77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包含以下内容:</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="3a50" class="na lb iq mv b gy nb nc l nd ne">FROM mcr.microsoft.com/dotnet/core/sdk:3.0-alpine as build<br/>WORKDIR /app<br/><br/># copy csproj and restore<br/>COPY app/*.csproj ./aspnetapp/<br/>RUN cd ./aspnetapp/ &amp;&amp; dotnet restore <br/><br/># copy all files and build<br/>COPY app/. ./aspnetapp/<br/>WORKDIR /app/aspnetapp<br/>RUN dotnet publish -c Release -o out<br/><br/><br/>FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine as runtime<br/>WORKDIR /app<br/>COPY --from=build /app/aspnetapp/out ./<br/>ENTRYPOINT [ "dotnet", "app.dll" ]</span></pre><p id="b801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备好Dockerfile后，我们就可以构建我们的图像了，它将被命名为<code class="fe ms mt mu mv b">aspnet3k8s</code>，标记为<code class="fe ms mt mu mv b">v1</code>。我们需要从<code class="fe ms mt mu mv b">app</code>目录向上导航一级，并运行下面的命令。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="9606" class="na lb iq mv b gy nb nc l nd ne">docker image build --pull -t aspnet3k8s:v1 .</span></pre><p id="686c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建立了图像后，我们可以运行它。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="6396" class="na lb iq mv b gy nb nc l nd ne">docker run --rm -it -p 9000:80 aspnet3k8s:v1</span></pre><p id="6154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">浏览<code class="fe ms mt mu mv b">localhost:9000</code>，您应该会看到两个变量的<code class="fe ms mt mu mv b">null</code>值。</p><p id="cfec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是个好兆头。毕竟，我们现在是在一个运行在docker主机上的不同环境中。</p><p id="d8d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">停止该命令，并尝试为新主机传递一对新的环境变量。</p><p id="47b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在<code class="fe ms mt mu mv b">localhost:9000</code>上再次检查响应</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="7e6a" class="na lb iq mv b gy nb nc l nd ne">{"appEnvironment":null,"appHost":null}</span></pre><p id="2698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好！</p><h1 id="1135" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建舵图</h1><p id="a64f" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">最后，我们谈到了问题的实质。我们将ASP.NET应用程序容器化，并可以将其部署在Kubernetes集群上。我们不会直接这样做，而是使用一个流行的Kubernetes的“包管理器”——Helm。</p><p id="0585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，我们的目标是在一个“负载平衡器”后面创建我们的ASP.NET Core 3 web API的三个实例，负载平衡器将路由到它们中的任何一个。</p><blockquote class="ly lz ma"><p id="f04b" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">将其转换为Kubernetes命名法，我们将创建一个部署，该部署将依次创建一个由3个pod(实例)和一个服务组成的复制集，该服务将充当“负载平衡器”,将来自外部世界的请求转发给它们中的任何一个。</p></blockquote><p id="f8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有这样做，现在是时候安装Docker桌面和头盔了。</p><p id="c7b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续之前，最好先阅读一下<a class="ae kl" href="https://v3.helm.sh/docs/intro/using_helm/" rel="noopener ugc nofollow" target="_blank"> Helm的三大概念</a>。</p><h1 id="3aac" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">初始化图表</h1><p id="ae85" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们可以使用<code class="fe ms mt mu mv b">helm create NAME</code>命令来完成，但是它会创建很多我们在本指南中不需要的文件。</p><p id="6873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们在根文件夹上创建以下结构。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="56ef" class="na lb iq mv b gy nb nc l nd ne">chart/ <br/>  Chart.yaml <br/>  values.yaml <br/>  templates/ <br/>    deployment.yaml <br/>    service.yaml</span></pre><p id="5de3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看<code class="fe ms mt mu mv b">Chart.yaml</code>，它指定了图表的名称和版本。您还可以添加其他字段，但只有这些字段是必需的。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="3760" class="na lb iq mv b gy nb nc l nd ne">name: aspnet3-demo<br/>version: 1.0.0</span></pre><h1 id="7634" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">图表值</h1><p id="b2bb" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">然后是<code class="fe ms mt mu mv b">values.yaml</code>，它指定了我们的默认设置，这些设置将被解析并注入到<code class="fe ms mt mu mv b">/templates</code>目录中的模板中。</p><p id="02be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在那里定义我们的环境名。您还可以看到我们的图像名称<code class="fe ms mt mu mv b">aspnet3k8s</code>和<code class="fe ms mt mu mv b">replicas: 3</code>字段，它们指定了我们想要多少个web API实例。<br/>请注意，我已经添加了一个字段<code class="fe ms mt mu mv b">pullPolicy: IfNotPresent</code>，因为我们的图像只在本地机器上。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="3048" class="na lb iq mv b gy nb nc l nd ne">environment: development<br/><br/>apphost: k8s<br/><br/>label:<br/>  name: aspnet3core<br/><br/>container:<br/>  name: aspnet3<br/>  pullPolicy: IfNotPresent<br/>  image: aspnet3k8s<br/>  tag: v1<br/>  port: 80<br/>replicas: 3<br/><br/>service:<br/>  port: 8888<br/>  type: ClusterIP</span></pre><p id="6f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止还不错，但是你可能会问自己这些<code class="fe ms mt mu mv b">values</code>YAML如何使我们的目标更接近？答案是，这些值在我们的模板中被引用。现在让我们来检查一下。</p><h1 id="6f62" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">图表模板</h1><p id="f592" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们从<code class="fe ms mt mu mv b">deployment.yaml</code>开始。该模板将创建一个部署对象，该对象将依次创建由3个pods组成的ReplicaSet，每个pods运行我们的web API容器映像。看看我们在<code class="fe ms mt mu mv b">values.yaml</code>中定义的所有引用值。注意一个头盔的内置对象<code class="fe ms mt mu mv b">.Release</code>，我们将使用它来命名我们的部署。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="a362" class="na lb iq mv b gy nb nc l nd ne">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: {{ .Release.Name }}-deployment<br/>  labels:<br/>    app: {{ .Values.label.name }}<br/>spec:<br/>  replicas: {{ .Values.replicas }}<br/>  selector:<br/>    matchLabels:<br/>      app: {{ .Values.label.name }}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: {{ .Values.label.name }}<br/>        environment: {{ .Values.environment }}<br/>    spec:<br/>      containers:<br/>        - name: {{ .Values.container.name }}<br/>          image: {{ .Values.container.image }}:{{ .Values.container.tag }}<br/>          imagePullPolicy: {{ .Values.container.pullPolicy }}<br/>          ports:<br/>            - containerPort: {{ .Values.container.port }}<br/>          env:<br/>            - name: apphost<br/>              value: {{ .Values.apphost }}<br/>            - name: appenvironment<br/>              value: {{ .Values.environment}}</span></pre><p id="cbd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将确保我们的web API的3个实例将在我们的本地集群上运行。但是，如果没有“负载平衡器”，我们将无法访问其中任何一个。为此，我们需要一个模板在<code class="fe ms mt mu mv b">service.yaml</code>中定义的服务。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="e5f5" class="na lb iq mv b gy nb nc l nd ne">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: {{ .Release.Name }}-service<br/>  labels:<br/>    app: {{ .Values.label.name }}<br/>spec:<br/>  ports:<br/>  - port: {{ .Values.service.port}}<br/>    protocol: TCP<br/>    targetPort: {{ .Values.container.port }}<br/>  selector:<br/>    app: {{ .Values.label.name }}<br/>  type: {{ .Values.service.type }}</span></pre><p id="20e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们一切就绪，终于可以在本地集群上部署图表了！</p><h1 id="9544" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">压轴戏</h1><p id="549a" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">运行下面的命令将我们的图表安装为名为<code class="fe ms mt mu mv b">aspnet3release</code>的版本。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="3b82" class="na lb iq mv b gy nb nc l nd ne">helm install aspnet3release ./chart/</span></pre><p id="3dc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到一个成功的响应</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="0587" class="na lb iq mv b gy nb nc l nd ne">NAME: aspnet3release <br/>LAST DEPLOYED: Sun Dec 1 12:07:53 2019 <br/>NAMESPACE: default <br/>STATUS: deployed <br/>REVISION: 1 <br/>TEST SUITE: None</span></pre><p id="7bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用<code class="fe ms mt mu mv b">kubectl</code>命令来看看Kubernetes集群上到底部署了什么。注意，我们使用一个选择器来匹配那些带有标签<code class="fe ms mt mu mv b">app=aspnet3core</code>的资源。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="d88e" class="na lb iq mv b gy nb nc l nd ne">kubectl get all --selector app=aspnet3core</span></pre><p id="9bd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它应该输出以下内容。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="4439" class="na lb iq mv b gy nb nc l nd ne">NAME READY STATUS RESTARTS AGE <br/>pod/aspnet3release-deployment-77686884b-fq5lq 1/1 Running 0 3m43s pod/aspnet3release-deployment-77686884b-llcsv 1/1 Running 0 3m43s pod/aspnet3release-deployment-77686884b-qswsj 1/1 Running 0 3m43s</span><span id="3797" class="na lb iq mv b gy nf nc l nd ne">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE <br/>service/aspnet3release-service ClusterIP 10.107.172.66 &lt;none&gt; 8888/TCP 3m43s </span><span id="37b6" class="na lb iq mv b gy nf nc l nd ne">NAME READY UP-TO-DATE AVAILABLE AGE <br/>deployment.apps/aspnet3release-deployment 3/3 3 3 3m43s </span><span id="7781" class="na lb iq mv b gy nf nc l nd ne">NAME DESIRED CURRENT READY AGE <br/>replicaset.apps/aspnet3release-deployment-77686884b 3 3 3 3m43s</span></pre><p id="7e85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在所拥有的。运行我们的web API的三个pod一个ReplicaSet和一个监听<code class="fe ms mt mu mv b">8888</code>端口的服务。太好了，让我们接着浏览<code class="fe ms mt mu mv b">localhost:8888</code>来看看我们的API在起作用！</p><p id="970d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么都没发生。为什么？因为服务的端口不在本地机器上，而是在集群内部。因此，我们必须使用<code class="fe ms mt mu mv b">kubectl port-forward</code>命令将本地机器上的一个端口转发到服务的端口。我们可以重用8888端口，但是让我们使用9999来清楚地区分什么在哪里。</p><p id="5c5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从前面的命令<code class="fe ms mt mu mv b">kubectl get all</code>我们知道我们的服务可以被标识为<code class="fe ms mt mu mv b">service/aspnet3release-service</code>。让我们试试。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="cada" class="na lb iq mv b gy nb nc l nd ne">kubectl port-forward service/aspnet3release-service 9999:8888</span></pre><p id="20df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">浏览<code class="fe ms mt mu mv b">localhost:9999</code>并...成功！</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="5799" class="na lb iq mv b gy nb nc l nd ne">{"appEnvironment":"development","appHost":"k8s"}</span></pre><h1 id="d9a0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更新我们的部署</h1><p id="01e6" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">您可能会想，为什么我使用Helm而不是为部署和服务对象创建标准的Kuberentes定义。很方便的是，有些值不是按值复制的，而是被引用的——为什么要大惊小怪呢？</p><p id="8bf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，我们想要使用我们的应用程序。我们可以复制我们的开发YAMLs，并在这里和那里更改值，但这将非常容易出错，并且很难维护。相反，通过使用Helm，我们可以简单地为生产创建一组新值，并将其存储在一个新文件<code class="fe ms mt mu mv b">production-values.yaml</code>中。类似于:</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="282f" class="na lb iq mv b gy nb nc l nd ne">environment: production<br/>replicas: 5</span></pre><p id="1697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，我们将只使用<code class="fe ms mt mu mv b">helm upgrade</code>命令和传递<code class="fe ms mt mu mv b">production-values.yaml</code>来升级我们的开发。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="4f3b" class="na lb iq mv b gy nb nc l nd ne">helm upgrade aspnet3release ./chart --values ./chart/production-values.yaml</span></pre><p id="b5e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回应是:</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="f5de" class="na lb iq mv b gy nb nc l nd ne">Release "aspnet3release" has been upgraded. Happy Helming!<br/>NAME: aspnet3release<br/>LAST DEPLOYED: Sun Dec  1 12:40:00 2019<br/>NAMESPACE: default<br/>STATUS: deployed<br/>REVISION: 2<br/>TEST SUITE: None</span></pre><p id="d894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，让我们验证它在群集上的样子:</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="5c94" class="na lb iq mv b gy nb nc l nd ne">kubectl get all --selector app=aspnet3core</span></pre><p id="4892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到我们应用程序的5个实例。那很容易，不是吗？</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="6c76" class="na lb iq mv b gy nb nc l nd ne">NAME READY STATUS RESTARTS AGE <br/>pod/aspnet3release-deployment-774c478b4-64jgp 1/1 Running 0 12m pod/aspnet3release-deployment-774c478b4-fx8bs 1/1 Running 0 12m pod/aspnet3release-deployment-774c478b4-mkplm 1/1 Running 0 12m pod/aspnet3release-deployment-774c478b4-mnwgb 1/1 Running 0 12m pod/aspnet3release-deployment-774c478b4-xnd9b 1/1 Running 0 12m </span><span id="9112" class="na lb iq mv b gy nf nc l nd ne">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE <br/>service/aspnet3release-service ClusterIP 10.107.172.66 &lt;none&gt; 8888/TCP 44m </span><span id="45e0" class="na lb iq mv b gy nf nc l nd ne">NAME READY UP-TO-DATE AVAILABLE AGE <br/>deployment.apps/aspnet3release-deployment 5/5 5 5 44m </span><span id="87a3" class="na lb iq mv b gy nf nc l nd ne">NAME DESIRED CURRENT READY AGE replicaset.apps/aspnet3release-deployment-774c478b4 5 5 5 12m replicaset.apps/aspnet3release-deployment-77686884b 0 0 0 44m</span></pre><p id="30ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还更改了环境变量，让我们也验证一下。我们必须再次左舷前进。</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="2e22" class="na lb iq mv b gy nb nc l nd ne">kubectl port-forward service/aspnet3release-service 9999:8888</span></pre><p id="fdfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且浏览<code class="fe ms mt mu mv b">localhost:9999</code>看到环境已经改成了<code class="fe ms mt mu mv b">production</code>。酷！</p><p id="688a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那是一段相当长的旅程。我们已经创建了一个新的ASP.NET核心应用程序，将其容器化，创建Helm's chart，在Kubernetes集群上部署它，最后更新它。</p><p id="17be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，差点忘了。要清理群集，请使用以下命令:</p><pre class="mg mh mi mj gt mw mv mx my aw mz bi"><span id="32be" class="na lb iq mv b gy nb nc l nd ne">helm uninstall aspnet3release</span></pre><h1 id="41ce" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">信用</h1><p id="2c5b" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">创建该指南的想法受到了John Arundel和Justin Domingus写的一本伟大的书的启发:<a class="ae kl" href="http://shop.oreilly.com/product/0636920175131.do" rel="noopener ugc nofollow" target="_blank">云本地DevOps with Kubernetes </a></p><p id="e034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。我希望你喜欢它。</p></div></div>    
</body>
</html>