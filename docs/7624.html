<html>
<head>
<title>When is software correct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候软件是正确的</h1>
<blockquote>原文：<a href="https://itnext.io/when-is-software-correct-ceed968fdab6?source=collection_archive---------2-----------------------#2022-11-28">https://itnext.io/when-is-software-correct-ceed968fdab6?source=collection_archive---------2-----------------------#2022-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5434f21e941458f537fa3fb4eaec6ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXEGM4PJEK-bZhCauLRblQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@possessedphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="0707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发软件应该总是与测试软件携手并进。通过测试，我们可以证明我们的软件工作正常。有很多方法可以证明这一点，但所有的方法都需要我们定义什么是“正确工作”。在这篇文章中，我将探索如何在软件测试的环境中定义正确的<em class="lb"/>。</p><h1 id="d999" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">需要<em class="ma">纠正</em></h1><p id="20cc" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">测试软件时，我们有一堆必须通过的测试。一次失败的测试意味着我们必须改变我们的应用程序。当它的一个断言被拒绝时，测试失败。不会失败的测试是没有用的。这些都是我们想当然的事情。这是我们使用公认术语的方式。然而，我注意到我们没有停下来思考什么定义了我们的断言，即使它们是测试中最重要的部分。</p><p id="e7ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读到这里，你可能会想:“显然，正确是由需求定义的。你在暗示什么，你这个装腔作势的人。”你是对的，但只是在完美的世界里。在现实世界中，需求永远不会完整到足以定义测试中的每一个断言。我们必须填补空白，以获得<em class="lb">正确</em>的完整定义。</p><p id="e839" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建<em class="lb">正确</em>的完整定义，我们从使用需求开始。但是我们也利用我们的经验、知识和技能。</p><p id="291a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们利用我们的经验来预防常见问题，并有效地利用我们的知识。</p><p id="5bf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们利用我们的知识找出最大的风险在哪里。更大的风险应该有更彻底的定义<em class="lb">正确的</em>。为此，我们使用我们的基本人类心理学知识(例如，我可能会忽略这个按钮)、软件开发过程(例如，一个仓促的功能)、业务领域(例如，银行)、组织(例如，这会中断某人的工作流程)和其他主题。</p><p id="0d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当需要时，我们利用我们的技能来收集数据或知识。我们还用它将所有东西结合成一个紧密的、可用的整体。</p><p id="5c77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们定义了<em class="lb">正确的</em>，我们就使用这个定义为我们的测试做断言。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/9bd79dc605dbd7199ceca13e6656c08a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*ZxaTAy_eJY85lN__8mnCGg.png"/></div></figure><h2 id="9240" class="ml ld iq bd le mm mn dn li mo mp dp lm ko mq mr lq ks ms mt lu kw mu mv ly mw bi translated"><em class="ma">的隐含定义正确</em></h2><p id="ac4f" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">自动化测试迫使我们以代码断言的形式写下正确的。每个自动化测试都需要一个或多个断言。这些书面断言是对正确的T21的明确定义。</p><p id="3c2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">手动测试时，测试人员写下<em class="lb">正确</em>的定义是不太常见的。他们往往止步于要求，不完全是<em class="lb">正确</em>的水平。但是，这并不意味着没有这样的定义。相反，测试人员使用了<em class="lb">正确</em>的隐含定义。隐式定义应该写下来，使它们显式，更重要的是，可重用。不过，我承认这并不总是可行的。</p><p id="7229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每一个可能失败的测试都有一个<em class="lb">正确、</em>隐式或显式的定义。不会失败的测试是没有用的。</p><h1 id="2fc2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如何定义正确</h1><p id="7460" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">定义<em class="lb">正确</em>有两种基本方法:例子和规则。它们是基本的，因为你不能把它们描述成除了它们自己以外的东西。它们是我所知道的定义<em class="lb">正确</em>的最基本形式。</p><p id="e599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的描述不是很详细，但应该足以给你一个大致的概念。</p><h2 id="67a8" class="ml ld iq bd le mm mn dn li mo mp dp lm ko mq mr lq ks ms mt lu kw mu mv ly mw bi translated">例子</h2><p id="3880" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">一个例子需要一个特定的情况(=状态和输入)和<em class="lb">正确的</em>结果(=输出或副作用)给一个特定的被测对象(SUT)。<em class="lb">正确的</em>结果仅适用于这种情况和这种SUT。如果<em class="lb">正确的</em>结果不等于实际结果，则测试失败。您可以通过在不同的情况下对同一个SUT多次这样做来证明SUT工作正常。</p><p id="d871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举例是目前为止定义<em class="lb">正确</em>最常用的方法。为了用这种类型的<em class="lb">正确的</em>编写一个测试，我们必须做以下事情:</p><ol class=""><li id="0cd6" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">设置一个示例状态</li><li id="3b3a" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">使用示例输入执行测试中的主题</li><li id="fb56" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">断言实际结果是否与正确的结果相同</li></ol><p id="d958" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能认为这些步骤是AAA模式(安排、行动、断言)。</p><p id="938a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">正确</em>在第三步中被定义为一个或多个断言，仅适用于本例。另一个例子可能对正确的有不同的定义，因此有不同的断言。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/bc98a264f75a8c9751b5c7258f0a7b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPfaTs2FhHwhjzlsOzMrIg.png"/></div></div></figure><h2 id="1451" class="ml ld iq bd le mm mn dn li mo mp dp lm ko mq mr lq ks ms mt lu kw mu mv ly mw bi translated">规则</h2><p id="5a65" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">规则是一个可重用的逻辑包，通常有一个人类可读的名称。根据规则逻辑，如果规则输入<em class="lb">不正确</em>，则认为规则被破坏。无论状态、输入或测试对象是什么，都不能破坏规则(SUT)。一个被破坏的规则不能通过测试。您可以通过应用多条规则来证明SUT正常工作。</p><p id="cea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">规则永远不能被打破，这意味着规则有时会自行失效。例如，当规则与给定输入不相关时。例如，禁用自身是不可接受的，但对于规则来说是可以的。</p><p id="5a68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了用这种类型的<em class="lb">正确的</em>编写一个测试，我们必须做以下事情:</p><ol class=""><li id="2c76" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">写一条规则</li><li id="1b30" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">使用示例情况(=状态和输入)和受测对象执行规则</li><li id="c880" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">断言规则是否被破坏</li></ol><p id="354a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">规则的优势在于它们的可重用性。因此，我们可以使用生成的输入多次运行步骤二(例如<a class="ae kc" href="https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237" rel="noopener">基于属性的测试</a>)。它还允许我们创建可以在应用程序和团队之间共享的规则集(例如<a class="ae kc" href="https://www.wikiwand.com/en/Lint_(software)" rel="noopener ugc nofollow" target="_blank"> Linters </a>)。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/b8c56318fde8d78afbbdce407d4ca027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFsdgtzhQZrANR6ydkHPig.png"/></div></div></figure><h1 id="5e73" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">用<em class="ma">不同的方式纠正</em></strong></h1><p id="454b" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">使用<em class="lb">纠正</em>的基本方法，我们可以更好地理解其他测试方法。我还没有遇到过我不能定义为例子和/或规则的测试方法。</p><p id="e86d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数非基础方法将<em class="lb">正确的</em>与软件开发的其他方面结合起来。例如，<a class="ae kc" href="https://lakitna.medium.com/contract-based-testing-part-1-introduction-b42e6236720a" rel="noopener">基于契约的测试</a>用从契约派生的规则定义<em class="lb">正确的</em>。最重要的是，它为团队合作和保持同步增加了一种结构化的方式。</p><p id="539d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他方法结合了这两种基本方法来创建对<em class="lb">正确</em>的更好定义。例如，<a class="ae kc" href="https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237" rel="noopener">基于属性的测试</a>通过在规则中包装一个例子来定义<em class="lb">正确的</em>。这导致了许多规则生成的例子，它们一起创建了一个可靠的定义。</p><p id="cefe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有更多的方法可以发现。我正在做一个以规则和例子为中心的测试方法概述。然而，那要等到另一天，另一篇文章。</p><h1 id="0aec" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="86c1" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">为了证明我们的软件工作正常，我们首先定义什么是正确的。<em class="lb">正确的</em>是根据需求、经验、知识和技能定义的。有时我们含蓄地定义<em class="lb">正确的</em>，但我们应该努力使其明确化。</p><p id="f1dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用两种基本方法来定义正确的:例子和规则。示例需要特定的情况，并且<em class="lb">为受测对象纠正</em>结果。规则是可重复使用的，无论测试的情况或主题是什么，都不能被打破。</p><p id="8e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以根据例子和规则定义许多有趣的测试方法。在以后的文章中，我将进一步探讨这个问题。</p></div></div>    
</body>
</html>