<html>
<head>
<title>Feature flaggable NPM dependency upgrades</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能可标记的NPM依赖升级</h1>
<blockquote>原文：<a href="https://itnext.io/feature-flaggable-npm-dependency-upgrades-a505c0d34cf7?source=collection_archive---------8-----------------------#2018-06-13">https://itnext.io/feature-flaggable-npm-dependency-upgrades-a505c0d34cf7?source=collection_archive---------8-----------------------#2018-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2210516a34722c0c90beadbb5111253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAYSyMe_PkKWTuW8zOFg0w.png"/></div></div></figure><p id="fa92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Atlassian正在采用他们自己的名为<a class="ae kw" href="https://atlaskit.atlassian.com/" rel="noopener ugc nofollow" target="_blank"> Atlaskit </a>的设计系统。这意味着我们越来越多地将产品功能从Atlaskit repo“外包”给npm模块。</p><p id="ba5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这是一个很大的进步，但是有些依赖项包含了太多的功能。我们觉得有必要在给大众升级之前先给一部分用户升级。优选地通过特征标志。</p><p id="e7c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最初认为这是不可能的，因为你怎么可能安装同一个依赖项的两个版本呢？！但是在尝试之后，使用package.json别名&amp;代码分割变得相对简单。</p><h1 id="14cc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">怎么</h1><p id="a635" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在package.json中添加一个依赖项的别名，然后运行yarn，这样锁就会得到更新。这是我添加到package.json中的内容:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5819" class="mj ky iq mf b gy mk ml l mm mn">"@atlaskit/editor-core": "^70.2.18",<br/>"@atlaskit/editor-core-latest": "npm:@atlaskit/editor-core@71.0.22",</span></pre><p id="6568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后确保使用代码分割来加载依赖项。在Confluence中，我们使用<a class="ae kw" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">react-loable</a>对组件进行代码拆分。为npm别名添加第二个加载程序:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a876" class="mj ky iq mf b gy mk ml l mm mn">const getEditorLoader = () =&gt;<br/>  isDarkFeatureEnabled("fabric.editor.next") ? latestEditorLoader : defaultEditorLoader;</span><span id="6b8a" class="mj ky iq mf b gy mo ml l mm mn">const defaultEditorLoader = () =&gt; import(/* webpackChunkName: "@atlaskit_editor-core" */ "@atlaskit/editor-core")</span><span id="86a1" class="mj ky iq mf b gy mo ml l mm mn">const latestEditorLoader = () =&gt; import(/* webpackChunkName: "@atlaskit_editor-core-latest" */ "@atlaskit/editor-core-latest")<br/></span><span id="e9e6" class="mj ky iq mf b gy mo ml l mm mn">const LoadableEditor = Loadable({<br/>  loader: getEditorLoader(),<br/>  loading() {<br/>    return &lt;div&gt;Loading...&lt;/div&gt;<br/>  }<br/>});</span></pre><p id="ec43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重要提示:确保webpackChunkName的不同</strong></p><p id="fbb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是你需要做的，简单吧？</p><h1 id="9ae0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">警告</h1><p id="0349" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在像@atlaskit/editor-core这样的大型依赖项的情况下，由于现在有两个版本需要捆绑，我们会受到相当大的webpack构建时间的影响。</p><p id="1269" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">yarn tooling不喜欢package.json别名，所以像upgrade &amp; upgrade-interactive这样的工具不能用于升级最新版本。相反，您必须手动升级package.json + run yarn中的版本来更新锁文件</p><p id="fa17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法不支持FF在运行时改变，并且在FF改变之前需要刷新。这可以通过在redux容器中创建加载器来解决，但是对于我们的特定用例，我觉得不值得增加额外的复杂性。</p><h1 id="7dd9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有用的脚本</h1><p id="edcd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们添加了一些脚本来自动完成这个过程，这些脚本对于想要重用这种方法的人来说很方便。</p><p id="14db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">升级特征标记版本的脚本:<a class="ae kw" href="https://gist.github.com/marcodejongh/8cc8d16fbc451838581014098dc0fb71" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/marcodejongh/8 cc 8d 16 FBC 451838581014098 DC 0 FB 71</a></p><p id="0eb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接受特征标记版本并重新碰撞隐藏版本的脚本:<a class="ae kw" href="https://gist.github.com/marcodejongh/fa2bc1ebb7845af0119c6748d8c26750" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/marcodejongh/fa 2 BC 1 ebb 7845 af 0119 c 6748 d8c 26750</a></p></div></div>    
</body>
</html>