<html>
<head>
<title>Iterating Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中迭代对象</h1>
<blockquote>原文：<a href="https://itnext.io/iterating-objects-in-javascript-6fe63b5495c4?source=collection_archive---------4-----------------------#2020-11-16">https://itnext.io/iterating-objects-in-javascript-6fe63b5495c4?source=collection_archive---------4-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d8621302d7515082000594c645bffee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONuCFZvMb4x54qcKOmTJvA.png"/></div></figure><p id="53ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你有没有想过如何在JS对象(不是数组)中迭代属性？嗯，我有。</p><p id="9fd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这可能不是最常见的情况，但有时您将数据结构保存为对象而不是数组，并且需要遍历该结构的每个属性。第一次遇到这种情况，我上网搜了一下，结果犯了一个错误。在帮助人们学习JS和构建他们的代码时，我已经看到这个错误很多次了；因此，我决定写这篇文章。</p><h1 id="4378" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">不仅仅是一个“for … in ”?</h1><p id="c46f" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">虽然使用一个<code class="fe lv lw lx ly b">for … in</code>确实会遍历你的对象属性，但问题是它实际上会比你预期的多做一点。你的目标可能是这样的:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8aec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然这可能经常正确工作，但事实是这种方法存在隐患。<code class="fe lv lw lx ly b">for … in</code>将遍历你的对象和它的原型。你不知道什么是原型吗？这也是了解JS特别有意思的地方。使用来自<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank"> MDN </a>的词语:</p><blockquote class="mg mh mi"><p id="5157" class="ju jv mj jw b jx jy jz ka kb kc kd ke mk kg kh ki ml kk kl km mm ko kp kq kr ij bi translated"><em class="iq">原型是JavaScript对象相互继承特性的机制</em></p></blockquote><p id="3298" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所发生的是，如果你使用<code class="fe lv lw lx ly b">for ... in</code>，你也从你的对象(“父对象”)迭代通过原型链的属性。</p><p id="91d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使当你创建和开发你自己的数据结构时，这可能不是问题，但是当使用插件和维护大的存储库时，这可能会变得更加复杂。</p><p id="f910" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想象一下这样一个场景，你有一个带有原型的物体。你从某处得到它。你可以检查，但不一定看到它包含这两个属性。你只会在<code class="fe lv lw lx ly b">for … in</code>遍历你没有预料到的属性时看到这一点！</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4abd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可以看出，尽管我们从未为<code class="fe lv lw lx ly b">objectFromSomewhere</code>定义过<code class="fe lv lw lx ly b">a</code>、<code class="fe lv lw lx ly b">b</code>和<code class="fe lv lw lx ly b">c</code>，但它拥有来自<code class="fe lv lw lx ly b">firstObject</code>的这些，这实际上是它的原型。你甚至可以看到它先是迭代了<code class="fe lv lw lx ly b">d</code>和<code class="fe lv lw lx ly b">e</code>(它自己的属性)，后来又去了原型的属性。所以，如果你正在使用<code class="fe lv lw lx ly b">for … in</code>并且只想遍历你的对象的属性，那就有问题了。</p><p id="7359" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有一些方法可以防止这种情况发生，但是当你处理第三方库和大代码库时，用<code class="fe lv lw lx ly b">for … in</code>进行迭代是有风险的。</p><h1 id="7d91" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">如何防止这种情况？</h1><p id="fd39" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">嗯，其实很简单。解决这个问题的方法也不止一种。但是让我们为您提供一个快速安全的解决方案。在这里我给你介绍<code class="fe lv lw lx ly b"><a class="ae mf" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" rel="noopener ugc nofollow" target="_blank">Object.keys()</a></code>和<code class="fe lv lw lx ly b"><a class="ae mf" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object/values" rel="noopener ugc nofollow" target="_blank">Object.values()</a></code>。顾名思义，第一个函数将以数组的形式为您提供对象的键(您可以按照自己的意愿进行迭代)。请记住，这些方法也会迭代函数(您必须手动检查这一点)。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1df6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">后一个将为您提供对象的值，也是以数组的形式。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e02a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要同时迭代键和值，还可以使用<code class="fe lv lw lx ly b"><a class="ae mf" href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" rel="noopener ugc nofollow" target="_blank">Object.entries()</a></code>，它返回一个用<code class="fe lv lw lx ly b">[key, value]</code>数组填充的数组。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="92d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就这么简单！这样你就保证了对迭代的控制。</p><h1 id="592b" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">如果我被困在“for … in”中怎么办？</h1><p id="afe6" class="pw-post-body-paragraph ju jv iq jw b jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr ij bi translated">出于任何原因，如果您需要坚持<code class="fe lv lw lx ly b">for … in</code>，您将需要在每个循环中添加一个新的检查。你可以用<code class="fe lv lw lx ly b">hasOwnProperty</code>问一个对象这个属性是自己的还是来自他的原型。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="d0ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">今天就到这里了，伙计们！尽管很简单，但这种知识可以让你在开发过程中省去一些麻烦。</p><p id="1c4c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">附注:如果你想更深入一点，我真的推荐阅读《你不知道的JS》第五章(实际上是整本书)</p></div></div>    
</body>
</html>