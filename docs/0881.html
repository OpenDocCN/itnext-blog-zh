<html>
<head>
<title>React To Typescript Part 2: Converting React Components to TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React To Typescript第2部分:将React组件转换为Typescript</h1>
<blockquote>原文：<a href="https://itnext.io/react-to-typescript-part-2-converting-react-components-to-typescript-bfe716c8e07c?source=collection_archive---------5-----------------------#2018-06-12">https://itnext.io/react-to-typescript-part-2-converting-react-components-to-typescript-bfe716c8e07c?source=collection_archive---------5-----------------------#2018-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="911e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这是一系列博客文章中的第二篇，将讨论如何将现有的React代码库Flatris由</em><a class="ae km" href="https://twitter.com/skidding" rel="noopener ugc nofollow" target="_blank"><em class="kl">@ skying</em></a><em class="kl">转换为Typescript。我们将最终得到一个完全经过类型检查的代码库。这一次，我们将着眼于向简单的React组件添加类型注释。</em></p><h1 id="b915" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><a class="ae km" href="https://medium.com/@geewee/tinkerer-converting-a-react-codebase-to-typescript-part-1-getting-it-to-compile-e53567db25" rel="noopener">我们上次停止的地方</a></h1><p id="7941" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们现在可以并行运行Javascript和Typescript。这意味着我们可以逐步转换事物。让我们首先转换React组件——它们很容易转换，因为它们已经有了一个通过PropTypes附加的类型系统。由于Flatris没有测试套件，我们无法自动测试我们的重构。但是，它只有一个屏幕，所以手动测试很容易。我们要做的是一次重写一个组件，运行游戏以确保一切正常。</p><p id="41cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我以前写过从哪里开始向一个<a class="ae km" href="https://medium.com/@geewee/tinkerer-in-what-order-should-i-start-adding-types-f1c3fdd6d0f4" rel="noopener">非类型化代码库</a>添加类型，但是TL；dr is:我们应该从具有尽可能少的非类型依赖的组件开始。我称之为自下而上。</p><p id="526f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看要重构的一些不同类型的组件。</p><h1 id="5e74" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">不需要修改的组件</h1><p id="852b" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">Javascript和TypeScript之间的一些组件是相同的。这些组件的类型要么是由第三方库提供的，要么是不接受任何支持的组件。</p><p id="4762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单的例子:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="25b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了文件扩展名之外，这些TypeScript组件与它们的JS组件完全相同。</p><p id="ea2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Flatris中，我们也有一些这样的组件。有一个用<a class="ae km" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>创建的按钮，看起来如下:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ec51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要库的类型来完成这项工作。</p><p id="3388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些库附带了typescript定义，在这种情况下，我们不需要做任何额外的工作。没有附带类型定义的流行库在npm上的@types名称空间下有它们。</p><p id="4502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于styled-components自带了自己的typescript定义，我们不需要做任何额外的事情——我们所需要做的就是将<strong class="jp ir"> button.jsx </strong>重命名为<strong class="jp ir"> button.tsx </strong>，这样我们就可以开始了。</p><h1 id="4542" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">带道具的无状态组件</h1><p id="c22e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">自底向上添加类型意味着从一个组件开始是有意义的，比如SquareBlock，它是一个彩色的正方形块。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们要做的第一件事是将其重命名为tsx。</p><p id="accb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将得到以下错误:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="5de5" class="mc ko iq ly b gy md me l mf mg">C:/…/flatris-ts/src/components/SquareBlock.tsx<br/>(15,13): Property 'propTypes' does not exist on type '({ color }: { color: any; }) =&gt; Element'.</span></pre><p id="fdb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Typescript在这里正确地推断了我们函数的类型，作为一个函数，它接受一个颜色对象，并返回一个JSX元素。然而，typescript并不热衷于向函数中随机添加属性。这意味着当我们试图添加propTypes时，typescript会停止并告诉我们这个函数没有propType属性——这是怎么回事？</p><p id="5be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想要做的不是像在上面的常规Javascript中那样简单地定义函数，而是我们想要添加一个类型注释，以确保Typescript认为它是一个正确的React组件— propTypes等等。</p><p id="d52c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在反应类型中，功能组件称为反应。SFC —其中SFC是无状态功能组件。让我们尝试将这种类型注释添加到组件中:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这成功地消除了propTypes错误——但是另一场风暴正在酝酿之中..</p><h1 id="508c" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">打字道具</h1><p id="d3f1" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">这里我们得到一个新的错误:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="2163" class="mc ko iq ly b gy md me l mf mg">(11,36): Type '{ children?: ReactNode; }' has no property 'color' and no string index signature.</span></pre><p id="fe6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，TypeScript似乎在抱怨我们在组件中传入了<code class="fe mh mi mj ly b">color</code>。奇怪。让我们试着看看反应的类型。去证监会看看是怎么回事。虽然这不是类型定义中最复杂的例子(对于复杂的情况，它们可能会变得非常<em class="kl">和</em>令人毛骨悚然),但它仍然足够复杂，值得仔细研究。</p><p id="b244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将一次查看一个类型注释，并试图弄清楚发生了什么。这将是对一些打字稿打字的更深入的探究——等等。</p><p id="cd91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次打字是这样的:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="a322" class="mc ko iq ly b gy md me l mf mg">type SFC&lt;P = {}&gt; = StatelessComponent&lt;P&gt;;</span></pre><p id="31e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们正在使用的SFC类型。</p><p id="e6b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是所谓的类型别名，由“type”关键字表示。它的基本意思是“这是那种类型的简写”,所以例如</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="7922" class="mc ko iq ly b gy md me l mf mg">type StringOrNumber = string | number</span></pre><p id="d139" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是字符串和数字并集的类型别名。完全等同于每次看到StringOrNumber都用string | number代替。</p><p id="d05c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，字体的下一部分:尖括号。尖括号&lt;&gt;内的部分表示通用类型。</p><p id="e5f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的一般类型被称为P——我猜是道具。这是我们告诉Typescript我们愿意接受什么样的道具的部分。它说<code class="fe mh mi mj ly b">&lt;P = {}&gt;</code>——这意味着；如果没有提供类型，默认为空对象<code class="fe mh mi mj ly b">{}</code>——意味着没有额外的道具</p><p id="ae90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，整行的意思是:</p><p id="b079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您使用SFC时，我将引用StatelessComponent类型。我想要一个带道具的通用参数，但是如果你不给我，我就认为没有道具</p><p id="1c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们来看看StatelessComponent的类型——我们将快速查看实际代码，然后将其分解。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8bd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，界面的第一部分是有趣的部分，让我们来看看:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="fb58" class="mc ko iq ly b gy md me l mf mg">(props: P &amp; { children?: ReactNode }, context?: any): ReactElement&lt;any&gt; | null;</span></pre><p id="a2ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们有一个可调用的签名——这意味着任何符合这个接口的东西都可以用下面的签名来调用。让我们试着把它拆开一点，看看它意味着什么</p><p id="92f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一部分</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="0b75" class="mc ko iq ly b gy md me l mf mg">(props : P &amp; (children?: ReactNode)</span></pre><p id="7c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是交集类型，用<code class="fe mh mi mj ly b">&amp;</code>表示。<code class="fe mh mi mj ly b">&amp;</code>的意思是“组合这两种类型”,所以这个语句的意思是:“接受一个props参数，这是通用参数props的组合，但也可以有一个名为children的额外的props。”</p><p id="bb0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那个？在儿童之后表示它是可选的。这使得我们可以通过JSX，在我们想通过的时候通过孩子们。例如</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="1ed8" class="mc ko iq ly b gy md me l mf mg">&lt;Foo&gt;&lt;Bar/&gt;&lt;/Foo&gt;</span></pre><p id="9e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相当于通过了一个<code class="fe mh mi mj ly b">Bar</code>作为<code class="fe mh mi mj ly b">Foo</code>的儿童道具。</p><p id="9a54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，类型签名的第二部分:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="4f0a" class="mc ko iq ly b gy md me l mf mg">context?: any</span></pre><p id="1d0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着该函数也可以接受第二个参数，但它是非类型化的。它用于访问遗留的React上下文API。现在我们来看看返回类型:</p><p id="c2f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种返回类型意味着该函数要么返回一个接受任何类型的道具的React组件，要么不返回任何东西</p><p id="d828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以总结一下。这个:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="0341" class="mc ko iq ly b gy md me l mf mg">(props: P &amp; { children?: ReactNode }, context?: any): ReactElement&lt;any&gt; | null;</span></pre><p id="e44e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">意思是:</p><p id="b01a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以用Props调用StatelessComponent，如泛型参数P所指定的，并且可以选择使用children。如果它需要道具之外的另一个论证，那就是语境。这可以是任何东西。该函数要么返回一个ReactElement，要么不返回任何内容。</p><p id="a306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">咻！解释我们最初的错误消息绕了很长一段路。为了唤起您的记忆，错误消息是:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="576a" class="mc ko iq ly b gy md me l mf mg">(11,36): Type '{ children?: ReactNode; }' has no property 'color' and no string index signature.</span></pre><p id="9b90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，TypeScript在这里抱怨的是React.SFC中的泛型参数。由于它默认为{}，即空对象，这意味着如果我们不指定泛型部分——它唯一接受的是子对象——例如，没有props。</p><p id="80b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以错误信息说:<em class="kl">嘿——你告诉我你没有收到任何道具，但是紧接着你又说这个颜色变量——这是怎么回事？</em></p><p id="03a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保我们对泛型的理解是正确的，让我们试着说我们接受任何类型的道具:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="1865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得它编译起来没有任何问题——然而TypeScript现在允许我们将任何属性传递给SquareBlock。现在我们不一定希望这样——我们越多地使用任何类型，我们从Typescript中获得的价值就越少。</p><p id="7e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以从PropTypes中判断出color对象应该是一个字符串，所以让我们在typescript接口中捕获它。</p><p id="f50a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些prop类型:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="1ca2" class="mc ko iq ly b gy md me l mf mg">SquareBlock.propTypes = {<br/> color: PropTypes.string.isRequired<br/>};</span></pre><p id="58e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对应于此界面:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="d696" class="mc ko iq ly b gy md me l mf mg">interface Props {<br/>   color: string;<br/>}</span></pre><p id="d41b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然有了编译器的支持，我们就可以直接删除propTypes了。虽然在typescript代码库中很少保留propTypes，但是当我们仍然处于过渡过程中时，为了一些额外的运行时安全性，或者如果您正在构建非TypeScript使用的东西，例如库，您可能希望保留它们。</p><p id="1d86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有proptypes的最终组件如下所示:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="86a9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">基于类的组件</h1><p id="39bc" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">让我们来看一个稍微复杂一点的组件——俄罗斯蚱蜢。一个方块是四个方块的集合。我想它们就是大多数人所说的“俄罗斯方块”。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/5299ddd38cfb4e53e2c0dfa7dbdf6f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsc2X5gmXEwseXeCpR5uaw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">我甚至不知道这些有名字</figcaption></figure><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="efad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Tetromino在这里是一个基于类的组件，所以我们必须做一些不同的事情。这里我们不需要添加任何显式类型。当延伸反应时。component-TypeScript自动选取类型。</p><p id="b277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们看看React的类定义。组件它看起来像这样:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="bbc2" class="mc ko iq ly b gy md me l mf mg">// Note that this is not the actual typings - the react typings are // reasonably complex, so I've edited them a bit down to communicate // the gist of it<br/>class Component&lt;P={}, S={}&gt; {<br/>    constructor(props: P, context?: any);<br/>    // ...Stuff removed for brevity<br/>}</span></pre><p id="104e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意默认为空对象的两个泛型参数。我们可以编写这样的代码:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="e507" class="mc ko iq ly b gy md me l mf mg">class Tetromino extends React.Component {}</span></pre><p id="b1fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将是完全有效的类型脚本代码。然而，与函数组件一样，如果我们想使用状态或属性，它会给我们带来错误。我们需要定义泛型类型来获得适当的类型安全。</p><p id="30cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为编译的第一步，我们当然可以将它们指定为任意:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="ff11" class="mc ko iq ly b gy md me l mf mg">class Tetromino extends React.Component&lt;any, any&gt; {}</span></pre><p id="f93c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们可以做得更好。查看Tetromino，我们可以看到它不包含任何状态，因此让我们将第二个参数更改为void:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="b752" class="mc ko iq ly b gy md me l mf mg">class Tetromino extends React.Component&lt;any, void&gt; {}</span></pre><p id="5a0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者更好——我们可以不考虑它！</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="259d" class="mc ko iq ly b gy md me l mf mg">class Tetromino extends React.Component&lt;any&gt; {}</span></pre><p id="88d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来处理道具！我们将再次把propTypes重写到一个接口中。propTypes看起来像这样:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c0d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们有一个字符串，和一个数字数组。这可以用如下的类型脚本来表示:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="da1b" class="mc ko iq ly b gy md me l mf mg">interface Props {<br/>    color : string,<br/>    // Note the double square brackets - that's a twice nested array<br/>    grid: number[][] <br/>}</span></pre><p id="e46e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们把它加入到反应中。组件，所以我们的新类定义现在是:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="a2e3" class="mc ko iq ly b gy md me l mf mg">class Tetromino extends React.Component&lt;Props&gt; {</span></pre><p id="cb9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在——我们还没有完成。我们将得到另一个propTypes错误:</p><pre class="lq lr ls lt gt lx ly lz ma aw mb bi"><span id="b14b" class="mc ko iq ly b gy md me l mf mg">Property 'propTypes' does not exist on type 'typeof Tetromino'.</span></pre><p id="85ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，Typescript并不热衷于我们在已经存在的类上声明新的属性——将propTypes声明为基于类的属性的最佳方式是使用静态块。所以与其说:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="fc13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们可以完全省略propTypes。总的来说，我们将以下面的课程结束。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来差不多，对吧？如果已经通过propTypes指定了类型，通常可以简单地用typescript接口替换propTypes。通常，您根本不需要向组件的主体添加任何类型注释——typescript可以为您推断出来。</p><p id="5891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一部分中，我们将看看如何使用简单的运行时分析来对组件进行类型化，我们无法通过简单地查看属性类型来弄清楚如何进行类型化。我们还将看看类型化减少器和动作。如有任何意见或问题，可通过<a class="ae km" href="https://twitter.com/GeeWengel" rel="noopener ugc nofollow" target="_blank"><em class="kl">@ GeeWengel</em></a><em class="kl">联系我。</em></p><p id="ab4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您只想在下一部分上线时得到通知，请订阅我的时事通讯。我很少发电子邮件，因为我很懒。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><a href="http://eepurl.com/dwbCH1"><div class="gh gi mv"><img src="../Images/1c672073d1e090a979191856ee021f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*DlPaVEPFYUZc0KIIdrAB_g.png"/></div></a></figure></div></div>    
</body>
</html>