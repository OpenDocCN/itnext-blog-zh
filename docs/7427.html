<html>
<head>
<title>C versus C++: fight!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C对C++:战斗！</h1>
<blockquote>原文：<a href="https://itnext.io/c-versus-c-fight-201b3f07a94f?source=collection_archive---------1-----------------------#2022-09-20">https://itnext.io/c-versus-c-fight-201b3f07a94f?source=collection_archive---------1-----------------------#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/301b49c455bbd2608bccce195727430d.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*Jw0IuWzl8hystyOG.jpeg"/></div></div></figure><h1 id="87dc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我非常喜欢C语言</h1><p id="5532" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">用C写代码是我从编程中获得的最解放的体验。我不会浪费几个小时浏览文档，或者阅读解释为什么深奥的概念是完全必要和酷的博客。我不会盯着别人的代码，试图找出在一堆乱七八糟的符号后面隐藏着什么功能(如果有的话)，以及他们为什么这样做。我只是想一些东西，然后在几分钟内编码。</p><p id="5ee6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我认为这种态度并非出于无知或偏见:我写过Java和JavaScript，我在工作中同时使用Python和C++，但我仍然更喜欢C。用《星球大战》的话来说，我认为C++是“技术恐怖”，其核心有一个缺陷，而C是“更文明时代的更文明武器”。十有八九，C对你和对我来说并不代表同样的东西:自由、掌握和K&amp;R(第二版)。)那是我十几岁的时候姐姐给我的。</p><p id="556e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">C的发明者在《C编程语言》(1978年)的序言中正确地指出了它的优势:它令人愉快、富于表现力、用途广泛，但不太大、不太专业、也不太受限制。在我看来，人们对C的许多抱怨都可以通过使用更好的编码技术或创建库来解决其可察觉的缺陷来解决。</p><p id="71fa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">c正如我所需要的那样是类型安全的，不会强迫我去经历毫无意义的束缚。它在我需要的程度上支持面向对象编程，不需要强迫所有东西都是一个类，也不需要我写几百行样板代码。总之，C就像一件肘部打了补丁的旧夹克一样适合我。我越来越意识到这让我成了少数派:尽管C语言标准的新版本仍在发布(例如C23)，但世界的大部分地区都已经向前迈进了。</p><p id="ba1a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我最近很惊讶地听到吉多·范·罗苏姆说他最喜欢的语言(除了Python)是C。当然，Python是用C写的，并且借鉴了C的思想，但是我仍然很惊讶，因为现在很少听到关于C的任何正面的东西。许多开发人员自豪地站出来宣称“C是一种糟糕的语言”，尽管它在创造他们周围的现代世界中起着至关重要的作用。同一批开发人员坐下来，不假思索地继续使用C语言编写的软件(git、Python、Linux等)。)做好自己的本职工作！</p><p id="3d06" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在C编程上投入了我生命中的这么多，这种不屑一顾的态度让我感到悲伤和有点生气，就好像有人侮辱了我的家庭成员一样。比雅尼·斯特劳斯特鲁普曾经说过“世界上只有两种语言:人们抱怨的语言和没人使用的语言”。或许这意味着我不应该对人们抱怨我最喜欢的语言过于敏感。我正在努力提高自己的这方面。</p><h1 id="9f41" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">可怕的语法呢？</h1><p id="15cc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">批评C的语法很容易；甚至有一个网站可以在“C胡言乱语”和英语之间进行翻译，这很有趣。此外，我们不要忘记国际模糊C代码竞赛，它从1984年开始“庆祝C语言的语法不透明性”。</p><p id="caf9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我发现对C语法最有效(但相对罕见)的批评是它的冗长。当结合没有类型推断和方法定义中没有隐式的<code class="fe ma mb mc md b">this</code>或<code class="fe ma mb mc md b">self</code>指针的事实时，结果通常是大量重复和冗长的声明。</p><p id="94e5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是一个常量指针的声明，它指向一个常量无符号整数，必须至少64位宽(即<code class="fe ma mb mc md b">x</code>必须始终指向<code class="fe ma mb mc md b">y</code>，而<code class="fe ma mb mc md b">y</code>不能通过解引用<code class="fe ma mb mc md b">x</code>来改变):</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="1d43" class="mm jz iq md b be mn mo l mp mq">unsigned long long int const *const x = &amp;y;</span></pre><p id="ee36" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">实际上，这可能是使用类型别名编写的:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="38db" class="mm jz iq md b be mn mo l mp mq">uint64_t const *const x = &amp;y;</span></pre><p id="c3e1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我曾经开玩笑说，我们正在接近一个“常数奇点”:一个假设的时刻，每个C程序中的每个符号都是类型限定符<code class="fe ma mb mc md b">const</code>。默认情况下，对象是可变的，但是大多数对象都可以在声明时初始化，之后就不应该修改了。如果一个程序是以现代风格编写的，其中声明可以与其他语句混合，这一点尤其正确。</p><p id="b76b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">声明不能从左到右(或从右到左)直接读取，因为<code class="fe ma mb mc md b">*</code>具有右结合性(对于它的操作数，一个指针)，而<code class="fe ma mb mc md b">[</code>和<code class="fe ma mb mc md b">(</code>具有左结合性。我承认，当我看到程序员新手面对声明被从里到外、从后到前解析的可怕现实时，我有一种反常的快乐。</p><p id="cc59" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Kernighan &amp; Ritchie在《C编程语言》(1988)中解释了这种语法背后的推理:</p><blockquote class="mr ms mt"><p id="abef" class="kw kx mu ky b kz lu lb lc ld lv lf lg mv lw lj lk mw lx ln lo mx ly lr ls lt ij bi translated"><em class="iq">指针的声明</em><code class="fe ma mb mc md b"><em class="iq">ip</em></code><em class="iq"/></p><p id="9b2f" class="kw kx mu ky b kz lu lb lc ld lv lf lg mv lw lj lk mw lx ln lo mx ly lr ls lt ij bi translated"><code class="fe ma mb mc md b"><em class="iq">int *ip;</em></code></p><p id="89ff" class="kw kx mu ky b kz lu lb lc ld lv lf lg mv lw lj lk mw lx ln lo mx ly lr ls lt ij bi translated"><em class="iq">意为助记符；上面说</em> <code class="fe ma mb mc md b"><em class="iq">*ip</em></code> <em class="iq">这个表达式是一个</em> <code class="fe ma mb mc md b"><em class="iq">int</em></code> <em class="iq">。变量声明的语法模拟了变量可能出现的表达式的语法。</em></p></blockquote><p id="1318" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是一个指向函数的指针(名为<code class="fe ma mb mc md b">roundf</code>)的声明，该函数将浮点数作为其参数，并返回一个至少16位宽的整数:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="ae1e" class="mm jz iq md b be mn mo l mp mq">int (*roundf)(float);</span></pre><p id="e193" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">K&amp;R(第二版)附录A中使用的语法。)指定一个<em class="mu">声明符</em>是一个形式为<em class="mu">指针(opt)直接声明符</em>的表达式，其中<em class="mu">指针</em>是<code class="fe ma mb mc md b">*</code>，而<em class="mu">直接声明符</em>要么是一个<em class="mu">标识符</em>，一个带括号的<em class="mu">声明符</em>，要么是另一个<em class="mu">直接声明符</em>，后跟一个带括号的<em class="mu">常量表达式(opt) </em>或<em class="mu">后两种选择分别代表一个数组和一个函数。</em></p><p id="8ed3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">解析上面的声明时，<em class="mu">指针(opt) </em>不能匹配任何东西，直到<em class="mu">直接声明符</em>的递归规则将<code class="fe ma mb mc md b">"(*roundf)(float)"</code>分解为<em class="mu">参数类型列表</em>、<code class="fe ma mb mc md b">"float"</code>和另一个<em class="mu">声明符</em>、<code class="fe ma mb mc md b">"*roundf"</code>:</p><ol class=""><li id="cf72" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nd ne nf ng bi translated">声明:<code class="fe ma mb mc md b">"int (*roundf)(float)"</code> <code class="fe ma mb mc md b">;</code></li><li id="7749" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">声明说明符:<code class="fe ma mb mc md b">"int"</code>，<br/>初始化声明符列表:<code class="fe ma mb mc md b">"(*roundf)(float)"</code></li><li id="64f1" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">类型说明符:<code class="fe ma mb mc md b">int</code>，<br/>初始化声明符:<code class="fe ma mb mc md b">"(*roundf)(float)"</code></li><li id="2c9b" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="ky ir">声明符</strong>:<code class="fe ma mb mc md b">""</code>T12】</li><li id="81a8" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">直接宣告者:<code class="fe ma mb mc md b">"(*roundf)"</code> <code class="fe ma mb mc md b">(</code> <code class="fe ma mb mc md b">"float"</code> <code class="fe ma mb mc md b">)</code></li><li id="5d21" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">直接声明符:<code class="fe ma mb mc md b">(</code> <code class="fe ma mb mc md b">"*roundf"</code> <code class="fe ma mb mc md b">)</code>，<br/>参数类型列表:<code class="fe ma mb mc md b">"float"</code></li><li id="3f74" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="ky ir">声明符</strong> : <code class="fe ma mb mc md b">"*"</code> <code class="fe ma mb mc md b">"roundf"</code>，<br/>参数表:<code class="fe ma mb mc md b">"float"</code></li><li id="1832" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">指针(opt): <code class="fe ma mb mc md b">*</code>，<br/>直接声明:<code class="fe ma mb mc md b">"roundf"</code>，<br/>参数声明:<code class="fe ma mb mc md b">"float"</code></li><li id="1ad4" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">标识符:<code class="fe ma mb mc md b">"roundf"</code>，<br/>声明-说明符:<code class="fe ma mb mc md b">"float"</code></li><li id="ffd7" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">类型说明符:<code class="fe ma mb mc md b">float</code></li></ol><p id="cdae" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">换句话说，顶层的<em class="mu">声明符</em> <code class="fe ma mb mc md b">(*roundf)(float)</code>的类型是<code class="fe ma mb mc md b">int</code>，嵌套的<em class="mu">声明符</em> <code class="fe ma mb mc md b">*roundf</code>的类型是<code class="fe ma mb mc md b">int ()(float)</code>。</p><p id="9d2a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">没有方括号来覆盖<code class="fe ma mb mc md b">*</code>的贪婪性，下面的语句声明了一个函数(名为<code class="fe ma mb mc md b">roundf</code>)，它返回一个指向整数的指针:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="00af" class="mm jz iq md b be mn mo l mp mq">int *roundf(float);</span></pre><p id="42fa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是因为<em class="mu">声明符</em>规则的<em class="mu">指针(opt) </em>部分直接匹配，不像前面的例子:</p><ol class=""><li id="b799" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nd ne nf ng bi translated">声明:<code class="fe ma mb mc md b">"int *roundf(float)"</code> <code class="fe ma mb mc md b">;</code></li><li id="b977" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">声明说明符:<code class="fe ma mb mc md b">"int"</code>，<br/>初始化声明符列表:<code class="fe ma mb mc md b">"*roundf(float)"</code></li><li id="03dd" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">类型说明符:<code class="fe ma mb mc md b">int</code>，<br/>初始化声明符:<code class="fe ma mb mc md b">"*roundf(float)"</code></li><li id="1c76" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated"><strong class="ky ir">声明者</strong>:<code class="fe ma mb mc md b">"*"</code>T13】</li><li id="9008" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">指针(opt): <code class="fe ma mb mc md b">*</code>，<br/>直接声明:<code class="fe ma mb mc md b">"roundf"</code> <code class="fe ma mb mc md b">(</code> <code class="fe ma mb mc md b">"float"</code> <code class="fe ma mb mc md b">)</code></li><li id="ce76" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">直接声明符:<code class="fe ma mb mc md b">"roundf"</code>，<br/>参数类型列表:<code class="fe ma mb mc md b">"float"</code></li><li id="358b" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nd ne nf ng bi translated">等等。</li></ol><p id="0fc5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">换句话说，<em class="mu">声明符</em> <code class="fe ma mb mc md b">*roundf(float)</code>的类型是<code class="fe ma mb mc md b">int</code>。</p><p id="400f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是一个函数(名为<code class="fe ma mb mc md b">get_roundf</code>)的声明，它接受一个布尔参数，并返回一个指向返回整数的函数的指针:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="3bcf" class="mm jz iq md b be mn mo l mp mq">int (*get_roundf(_Bool to_nearest))(float);</span></pre><p id="157e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">顶层<em class="mu">声明符</em> <code class="fe ma mb mc md b">(*get_roundf(_Bool to_nearest))(float)</code>的类型为<code class="fe ma mb mc md b">int</code>，嵌套<em class="mu">声明符</em> <code class="fe ma mb mc md b">*get_roundf(_Bool to_nearest)</code>的类型为<code class="fe ma mb mc md b">int ()(float)</code>。</p><p id="6df6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">实际上，大多数程序员使用<code class="fe ma mb mc md b">typedef</code>来定义类型的别名，然后从这些别名组成更复杂的声明。上述声明可以简化如下:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="2ffc" class="mm jz iq md b be mn mo l mp mq">typedef int roundf_t(float);<br/>roundf_t *get_roundf(_Bool to_nearest);</span></pre><h1 id="6635" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如果呢？</h1><p id="7af0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可能想知道如果取值操作符是左关联的，上面的声明会是什么样子:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="f1b7" class="mm jz iq md b be mn mo l mp mq">int roundf*(float); // pointer to a function returning int<br/>int roundf(float)*; // function returning a pointer to int<br/>int get_roundf(_Bool to_nearest)*(float); // function returning a pointer to a function returning int</span></pre><p id="a5d8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Stroustrup在《c++(1994)的设计和发展》中提出了类似的后缀声明语法，但是使用了<code class="fe ma mb mc md b">-&gt;</code>而不是<code class="fe ma mb mc md b">*</code>。</p><p id="f71d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个讨论中的改变并没有增加他写<code class="fe ma mb mc md b">int*</code>而不是<code class="fe ma mb mc md b">int *</code>的习惯的份量:<em class="mu">指针(opt) </em>仍然不是<em class="mu">声明说明符</em>之一，因为它只是用来描述<em class="mu">声明符</em>的各个部分之间的关系。</p><p id="34af" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">除了将整个类型规范(除了标识符<em class="mu">之外的所有内容)移到左边，他的风格是不连贯的。</em></p><h1 id="fdce" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">但是C不支持现代范例</h1><p id="2313" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">很容易批评C缺乏对面向对象编程(类)、<a class="ae lz" href="https://medium.com/itnext/tutorial-generics-in-c-b3362b3376a3" rel="noopener">泛型编程</a>(模板)、函数式编程(lambdas、闭包、懒求值)的语言级支持。然而，这预先假定语言<em class="mu">应该</em>明确支持每一个已经出现或可能出现的编程范例。</p><h1 id="11b5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">面向对象编程</h1><p id="de98" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我知道面向对象编程有四个支柱:</p><ul class=""><li id="bd94" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nm ne nf ng bi translated">抽象</li><li id="c91a" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">包装</li><li id="e6d7" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">遗产</li><li id="c97c" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">多态性</li></ul><p id="0141" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些其实不是很新颖。在Smalltalk、Java和C++之前，封装和抽象并不是不存在的。我猜想所有的意识形态都适合(或者合并，不那么贬义)自己的共同利益。这很好，但它确实会产生逻辑谬误，如“如果上帝不存在，我们就不会有道德”，“没有人民代表的苏维埃，我们就不会有分享”或“没有阶级，我们就无法隐藏实施细节”。</p><p id="5b97" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">OOP的核心思想是将数据和代码捆绑到对象中。c的类型系统确保函数只能在参数列表指定的自定义类型(<code class="fe ma mb mc md b">struct</code>或<code class="fe ma mb mc md b">union</code>)上运行。程序员可以通过把在给定类型上操作的函数的定义放在与该类型的定义相同的位置来增加额外的组织层。我敢肯定，在宣传OOP特性的语言发明之前，程序员们早就这么做了。</p><p id="f4ed" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">c当然支持抽象(函数、输入/输出流)和封装(不完整的<code class="fe ma mb mc md b">struct</code>或<code class="fe ma mb mc md b">union</code>类型)。不完整类型可用于任何不需要对象大小且不直接访问其成员的上下文中:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="5c9e" class="mm jz iq md b be mn mo l mp mq">struct encapsulated;<br/>struct encapsulated *get_encapsulated(void);<br/>struct encapsulated *e = get_encapsulated(); // Okay<br/>e-&gt;x = 0; // error: incomplete definition of type 'struct encapsulated'</span></pre><p id="d775" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">即使没有这个安全网，当你破坏封装时，通常也是显而易见的，例如，直接访问一个没有实现该数据类型的方法的函数中的<code class="fe ma mb mc md b">struct</code>成员。</p><p id="8857" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对继承的支持是C最弱的地方(有些人可能会说不存在)。无论如何，继承似乎已经不流行了，取而代之的是组合(“有a”而不是“是a”关系)。</p><p id="11b6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">通过将包含超类成员变量的<code class="fe ma mb mc md b">struct</code>嵌套在代表子类的<code class="fe ma mb mc md b">struct</code>中，可以在C中实现类似继承的东西，尽管子类的对象(显然)不能与超类的对象互换使用:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="584d" class="mm jz iq md b be mn mo l mp mq">struct superclass {<br/>  int (*getc)(struct superclass *);<br/>  size_t count;<br/>};<br/><br/>struct subclass {<br/>  struct superclass super;<br/>  FILE *f;<br/>};</span></pre><p id="63d9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要么两种类型都必须是完整的，以便可以直接访问子类的<code class="fe ma mb mc md b">struct</code>的相关(超类)成员，要么程序员必须提供一个子类方法(即函数)来返回嵌入超类对象的地址:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="6597" class="mm jz iq md b be mn mo l mp mq">struct superclass *subclass_get_superclass(struct subclass *s)<br/>{<br/>  return &amp;s-&gt;super;<br/>}</span></pre><p id="3dcd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在OOP术语中，多态性通常意味着虚方法。虚方法允许类覆盖它们的超类的某些功能的实现。这可以使用函数指针在C中实现(比如上面的<code class="fe ma mb mc md b">struct superclass</code>定义的<code class="fe ma mb mc md b">getc</code>成员)。</p><p id="e5a5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我通常将这种指针的解引用隐藏在传递了超类实例地址的普通函数后面，以避免暴露机制并要求调用者拥有包含函数指针的完整类型的<code class="fe ma mb mc md b">struct</code>:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="4c94" class="mm jz iq md b be mn mo l mp mq">int superclass_getc(struct superclass *s)<br/>{<br/>  return s-&gt;getc(s);<br/>}</span></pre><p id="bfa9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用函数指针实现<a class="ae lz" href="https://medium.com/itnext/polymorphism-in-c-tutorial-bd95197ddbf9" rel="noopener">多态性的主要缺点是缺乏类型安全性。虚方法的替代实现不能使用指向相应子类实例的类型化指针来访问成员变量；相反，它们接收超类对象的地址，和/或一个指向子类特定数据的<code class="fe ma mb mc md b">void *</code>指针(取决于机制)。</a></p><p id="69c2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">子类对象的地址通常是使用事实上的标准宏<code class="fe ma mb mc md b">container_of()</code>从超类对象的地址计算出来的:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="3ca2" class="mm jz iq md b be mn mo l mp mq">static int subclass_getc(struct superclass *s)<br/>{<br/>  struct subclass *sub =<br/>    container_of(s, struct subclass, super);<br/><br/>  int c = fgetc(sub-&gt;f);<br/><br/>  if (c != EOF) {<br/>    s-&gt;count++;<br/>  }<br/><br/>  return c;<br/>}</span></pre><p id="9a4b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我很少注意到这种类型安全的缺乏，因为C无缝地将<code class="fe ma mb mc md b">void *</code>转换成指向子类类型的指针(赋值时)，或者<code class="fe ma mb mc md b">container_of()</code>隐藏了所需的类型转换。这个问题至少局限于虚方法实现。</p><h1 id="57a2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通用编程</h1><p id="4967" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">c一直通过其预处理器对<a class="ae lz" href="https://medium.com/itnext/tutorial-generics-in-c-b3362b3376a3" rel="noopener">泛型编程</a>提供一些支持，该预处理器可用于<code class="fe ma mb mc md b">#define</code>命名标记和类似函数的宏，连接宏参数以创建新标记，以及<code class="fe ma mb mc md b">#include</code>使用宏和/或<code class="fe ma mb mc md b">typedef</code>泛型化的代码块。C11通过<code class="fe ma mb mc md b">_Generic()</code>关键字增加了对特殊多态性(根据参数类型选择表达式)的支持。</p><p id="98de" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我倾向于使用一种类型来实现算法，而不是尝试泛型编程，这种类型可能能够表示任何值(例如，<code class="fe ma mb mc md b">long</code>而不是<code class="fe ma mb mc md b">int</code>)，将用户数据地址存储在<code class="fe ma mb mc md b">void *</code>指针中(gasp！)，将一个泛型<code class="fe ma mb mc md b">struct</code>(例如一个链表节点)包装在一个特定类型的中，或者简单地复制并修改同一算法的一个现有实现(boo！).如果结果代码是可读的、安全的和正确的，那么代码复制并不总是最糟糕的解决方案。</p><h1 id="29a8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">函数式编程</h1><p id="7dae" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Lambdas是匿名嵌套函数定义，它可以访问在其父范围内声明的对象。这使得“回调函数”的常见模式是类型安全和方便的。在C语言中，这样的函数必须被命名，用文件范围声明，并且只能通过一个<code class="fe ma mb mc md b">void *</code>指针访问其父范围内的对象。回调要访问的多个对象必须捆绑在一个<code class="fe ma mb mc md b">struct</code>中。</p><p id="6345" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最近我更喜欢迭代器，而不是回调函数。通过不离开父函数，这些方法避开了在父函数范围内访问对象的问题:控制迭代的<code class="fe ma mb mc md b">for</code>语句(或等效语句)是父函数的一部分，循环体包含了原本在回调函数中的代码。</p><h1 id="75d3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么不直接用C++？</h1><p id="fbcf" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">阅读C++代码让我产生一种既陌生又熟悉的不安感觉，就像恐怖谷效应一样。也许这就像看到一个被毁容的老朋友的脸——幸运的是我从未有过这种经历。有时我认为C与C++过于相似的事实会煽动对立阵营的支持者之间的敌意，就像同一宗教的不同教派之间的分裂。当然，C和Java程序员之间没有兼容性之争。</p><p id="bfed" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我强烈推荐Stroustrup的书《C++的设计和进化》(1994)。它对他的思想提供了有价值的见解，也证实了我长期以来的怀疑。这本书的大部分内容都是关于他想改变却不能改变的事情，以及他对C语言及其用户的感受。</p><ul class=""><li id="04a0" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nm ne nf ng bi translated">他声称发明C++的原因是将BCPL的可移植性和效率与“Simula对程序组织的支持”结合起来——而不是改进C</li><li id="e392" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">他的目标是“在运行时间、代码紧凑性和数据紧凑性方面与C语言相匹配。”他明确表示为了生存需要与C竞争。</li><li id="b871" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">当他开始用类创建C时，他“不是C专家”。</li><li id="c3f8" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">他当时并不了解他的设计选择的所有后果。</li><li id="2498" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">他不喜欢C语言的语法和语义，形容它们是“有缺陷的”和“已知的混乱”,它们的“反常”给他带来了“痛苦”。</li><li id="d03b" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">他发现与“顽固的老C用户”和“准C专家”(比如我？)“艰难又沮丧”。</li><li id="652d" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">他缺乏C和UNIX专业知识，这导致他意外地对语法进行了不兼容的修改。</li></ul><p id="9158" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我发现令人吃惊的是，当Stroustrup第一次在他的书中引入一个<code class="fe ma mb mc md b">class</code>定义时，他没有努力解释为什么这种表示优于等价的<code class="fe ma mb mc md b">struct</code>和函数声明。</p><p id="9eb9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">c与类的例子(来自Stroustrup，1994):</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="e6b0" class="mm jz iq md b be mn mo l mp mq">class stack {<br/>  char  s[SIZE]; /* array of characters */<br/>  char* min;    /* pointer to bottom of stack */<br/>  char* top;    /* pointer to top of stack */<br/>  char* max;    /* pointer to top of allocated space */<br/>  void  new();  /* initialize function (constructor) */<br/>public:<br/>  void  push(char);<br/>  char  pop();<br/>};</span></pre><p id="5aed" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">C语言中的等效代码:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="ab6c" class="mm jz iq md b be mn mo l mp mq">struct stack {<br/>  char  s[SIZE]; /* array of characters */<br/>  char *min;    /* pointer to bottom of stack */<br/>  char *top;    /* pointer to top of stack */<br/>  char *max;    /* pointer to top of allocated space */<br/>};<br/><br/>void stack_new(struct stack *); /* initialize function (constructor) */<br/>void stack_push(struct stack *, char);<br/>char stack_pop(struct stack *);</span></pre><p id="70ee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然，<code class="fe ma mb mc md b">class</code>的定义更简洁，但是我认为如果方法定义可以用简单的工具(或肉眼)搜索到，我对C++的厌恶至少会减少80%。试图在定义了数百个同名方法的代码库中找到正确的定义是非常糟糕的——尤其是在涉及继承的情况下。</p><p id="9d57" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Stroustrup给出的在C上构建的理由与欣赏C无关，而是与利用C的成功有关:他宣称C++“必须像C一样杂草化”，并列举了C的优点，如“灵活”、“高效”、“可用”和“可移植”。其中最后两个只是反映了C语言在当时越来越受欢迎。“高效”(正如Stroustrup所描述的)隐含在K&amp;R对“低级”语言的描述中，“灵活”与K&amp;R对C语言一般性的描述一致。</p><p id="f752" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那么，我们剩下的就是声称与C接近兼容的意图，以便取代它作为通用低级语言的选择。但是他不喜欢C，也不喜欢那些不接受他的想法的用户。值得注意的是，Stroustrup没有<em class="mu">而</em>认为令人愉快、富于表现力或者不太大是C的优势。这可能在一定程度上解释了C++。</p><p id="6c64" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">c已经和平相处很久了。当《K&amp;R》的第一版在1978年出版时，它的作者安慰地写道，C“随着一个人经验的增长而经久不衰”</p><p id="6b1b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">相比之下，C++似乎在与自己进行永恒的战争，因为它讨厌它的始祖。从Stroustrup在指针声明的左边写星号的方式来看，这一点对我来说很明显。他想把他的语言从K&amp;R的句法中分离出来，但是他做不到，所以他在一种否认的状态中运作。现在他有了一大群追随者，不仅仅是抄袭他，还会提出一些奇怪的理由，比如“类型在C++中非常重要”(但在C？)，或者指称“C程序员的思维方式不同”(他们没有)。</p><p id="e928" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在《C++的设计和进化》(1994)中，Stroustrup写道:</p><blockquote class="mr ms mt"><p id="9834" class="kw kx mu ky b kz lu lb lc ld lv lf lg mv lw lj lk mw lx ln lo mx ly lr ls lt ij bi translated">让一个名字的声明模仿它的使用的C技巧导致声明难以阅读和书写，并且最大化了混淆声明和表达式的机会。</p></blockquote><p id="3dfc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你是否同意Stroustrup或K&amp;R的观点几乎无关紧要。后者根据自己的原则创造了一种他们喜欢的语言，而前者抨击他自己语言的语法，他复制了这种语法，而且无法改变。你觉得哪种姿势更有吸引力？</p><p id="3a16" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">阅读Herb Sutter的文章，很难不得出他也讨厌C的结论，因为他对C语法基础(例如左边的返回类型、显式类型、多词类型说明符)和他喜欢的编写C++的方式(右边的返回类型、类型推理、多词类型的不兼容语法)之间的不兼容性不屑一顾。我经常在想，在C语言崩溃之前，你能把它的语法变化堆到多高；直到最近我才意识到这已经发生了。</p><p id="07fe" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">不幸的是，C程序员无法忽视C++的存在，就像C++程序员无法忽视C一样。有一段时间，我几乎每天都要键入“new”作为标识符(通常与“old”成对)，然后回去删除我键入的内容，然后试图想出一个愚蠢的同义词，如“fresh”或“replacement”。</p><p id="8221" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我不能忽视C++的另一个原因是，我专业从事混合代码库的工作，而C++未能实现其与C兼容的声明。C99的一些最强大和令人愉快的功能(即复合文字和指定初始值设定项)不被C++支持，尽管C++20最终采用了与C微妙不兼容的不完整形式的指定初始值设定项。更糟糕的是，数组声明中的指定初始值设定项不可能在C++中得到正确支持，因为C++11标准化了lambdas的冲突语法。</p><h1 id="c0c1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">哦…推荐信</h1><p id="8209" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我和一些同事上了一个C++培训课程后，主要的效果不是我们开始写C++，而是我们开始在指针声明中更多地使用<code class="fe ma mb mc md b">const</code>。C++有一个独立的“引用”概念，它类似于指针，但有三个主要区别:</p><ul class=""><li id="cb91" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nm ne nf ng bi translated">初始化后，引用不能引用不同的对象。</li><li id="c11f" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">引用不能是空指针。</li><li id="bb80" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">引用与表达式中的真实对象具有相同的语法。</li></ul><p id="7efd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用<code class="fe ma mb mc md b">const</code>限定符，第一个属性可以很容易地在C中实现:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="a458" class="mm jz iq md b be mn mo l mp mq">int *const x = &amp;y; // x can only point to y</span></pre><p id="c33f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">C的类型系统不能强制第二个(非空)属性。向C添加可空性信息而不破坏其语法或语义的逻辑方法是一个新的指针<em class="mu">目标</em>类型限定符:</p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="d5d6" class="mm jz iq md b be mn mo l mp mq">_Optional int *z = malloc(10); // z can be null</span></pre><p id="d558" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可能想知道为什么我写了<code class="fe ma mb mc md b">_Optional</code>而不是<code class="fe ma mb mc md b">nonnull</code>或类似的。那是另外一天的一个<a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/why-c-needs-a-new-type-qualifier-61ad553cbe71">长故事</a>！</p><p id="d624" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在表达式中，一元运算符<code class="fe ma mb mc md b">&amp;</code>获取对象的地址；它与解引用操作符<code class="fe ma mb mc md b">*</code>相反，后者从地址获取对象。如果在C声明中允许使用<code class="fe ma mb mc md b">&amp;</code>,那么你可能会合理地期望它以同样的方式取消<code class="fe ma mb mc md b">*</code>。</p><p id="4e69" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在C++声明中，<code class="fe ma mb mc md b">&amp;</code>改为声明一个引用，并且与它在表达式中的用法相比，具有与相反的<em class="mu">含义。这是荒谬的:</em></p><pre class="me mf mg mh gt mi md mj bn mk ml bi"><span id="a743" class="mm jz iq md b be mn mo l mp mq">int a, // 'a' has type 'int'<br/>    *b, // dereferencing pointer 'b' yields 'int'<br/>    c[3], // elements of array 'c' have type 'int'<br/>    d(float), // value returned by function 'd' has type 'int'<br/>    *e(float), // dereferencing return value of 'e' yields 'int'<br/>    &amp;f = a, // address of 'f' has type 'int' ?!<br/>    *&amp;g = b; // 'g' has type 'int' ?!</span></pre><p id="8f0a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe ma mb mc md b">*</code>作为指针声明的一部分出现的唯一原因是允许声明语法模仿表达式的语法。然而，当C++引用(使用<code class="fe ma mb mc md b">&amp;</code>声明)出现在表达式中时，<code class="fe ma mb mc md b">&amp;</code>并不是必需的！</p><h1 id="0807" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">当然也不全是坏事吧？</h1><p id="c2c3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">C和C++作为竞争对手一起成长，互相借鉴。正如竞争通常所做的那样，这改善了两种语言。以下是我很高兴在C中看到的一些C++特性:</p><ul class=""><li id="c840" class="my mz iq ky b kz lu ld lv lh na ll nb lp nc lt nm ne nf ng bi translated">BCPL式的评论。</li><li id="e831" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">内嵌函数。</li><li id="a76a" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">布尔数据类型。</li><li id="0be9" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated"><code class="fe ma mb mc md b">for</code>语句中的声明。</li><li id="a8e8" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">使用前强制声明函数。</li><li id="8419" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">函数调用的类型检查。</li><li id="93d6" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">声明中没有隐含的<code class="fe ma mb mc md b">int</code>。</li><li id="68e0" class="my mz iq ky b kz nh ld ni lh nj ll nk lp nl lt nm ne nf ng bi translated">能够将声明与其他语句混合使用。</li></ul><p id="359d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">谢谢C++！你让C变得更好。</p></div></div>    
</body>
</html>