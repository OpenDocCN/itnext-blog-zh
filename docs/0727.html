<html>
<head>
<title>Module Oriented Architecture — Part 4: Non-conforming Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向模块的体系结构第4部分:非一致性模块</h1>
<blockquote>原文：<a href="https://itnext.io/module-oriented-architecture-part-4-non-conforming-modules-9c18ec2d2180?source=collection_archive---------9-----------------------#2018-05-15">https://itnext.io/module-oriented-architecture-part-4-non-conforming-modules-9c18ec2d2180?source=collection_archive---------9-----------------------#2018-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新你的记忆:</p><div class="kl km gp gr kn ko"><a href="https://medium.com/@poksi/module-oriented-architecture-part-3-modules-and-routing-241b06439a9f" rel="noopener follow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">面向模块的体系结构第3部分:模块和路由</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">刷新你的记忆:</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">medium.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><p id="52d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能会发生这样的情况，我们将不得不在我们的项目中包含代码，它不符合我们在本系列中介绍的架构。原因可能是多种多样的:我们可能有遗留代码，被关注点严重分离，也许我们有<strong class="jp ir"> <em class="le"> React Native </em> </strong>与许多已经编写的<strong class="jp ir"> <em class="le"> Javascript </em> </strong>代码桥接，我们不可能改变与原生端的接口，等等。</p><p id="2833" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本章将展示，我们将如何使用<code class="fe lf lg lh li b">URLProtocol</code>和iOS的简单URL加载系统将我们的模块转换成经典的HTTP API，从而使我们的模块开放并兼容任何代码，就像我们为应用程序外部的深层链接所做的一样。</p><h1 id="f268" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">简单的网络服务</h1><p id="364a" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我们创建了一个简单的<code class="fe lf lg lh li b">NetworkService</code>类，它为我们提供了两个公开的函数<code class="fe lf lg lh li b">get</code>和<code class="fe lf lg lh li b">post</code>。除此之外，我们还有两个私有函数。首先，<code class="fe lf lg lh li b">request</code>非常明显。唯一看起来有点猫腻的是<code class="fe lf lg lh li b">scheme</code>参数。它的处理非常简单:如果没有将<code class="fe lf lg lh li b">scheme</code>作为参数传递，那么它将默认设置为‘http’。我们现在对此很满意。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4f70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们有了<code class="fe lf lg lh li b">service</code>函数，因为我们在HTTP方法<code class="fe lf lg lh li b">get</code>和<code class="fe lf lg lh li b">post</code>中重用了这段代码。但是有一行代码让这一切变得非常有趣:<code class="fe lf lg lh li b">configuration.protocolClasses?.append(URLRouter.self)</code>。<code class="fe lf lg lh li b">URLSessionConfiguration</code>的这个方法提供了注册我们自己的类<code class="fe lf lg lh li b">URLRouter</code>的可能性，该类继承自<code class="fe lf lg lh li b">URLProtocol</code>抽象类。让我们看看为什么需要这样做。</p><h1 id="0e43" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">URL路由器</h1><p id="0561" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这是我们对2个协议的实现:<code class="fe lf lg lh li b">URLSessionDataDelegate</code>、<code class="fe lf lg lh li b">URLSessionTaskDelegate</code>以及最重要的，子类化抽象类<code class="fe lf lg lh li b">URLProtocol</code>(可能没有最好的名字)。对于曾经使用旧的mocking框架测试URL连接的所有人来说，<code class="fe lf lg lh li b">URLProtocol</code>通常用于它。我们中的许多人自己直接使用它来创建我们自己的网络存根基础结构。我不会讲太多细节，因为已经有很多关于它的文章了，但是让我解释一下这个协议在我们的例子中的作用。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c9fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们用<code class="fe lf lg lh li b">URLRouter</code>做的事情非常简单:</p><ul class=""><li id="9250" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">如果任务中的<code class="fe lf lg lh li b">URLRequest</code>具有<code class="fe lf lg lh li b">schema</code>，则签入<code class="fe lf lg lh li b">override class func canInit(with task: URLSessionTask) -&gt; Bool</code>，这与我们在前一章中定义的内部模式相匹配</li><li id="e684" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">然后我们检查URL是否包含与我们的<code class="fe lf lg lh li b">ApplicationRouter</code>匹配的<code class="fe lf lg lh li b">host</code>和<code class="fe lf lg lh li b">path</code></li><li id="e358" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">如果检查结果是肯定的，那么URL加载系统调用我们的<code class="fe lf lg lh li b">override func startLoading()</code>函数，我们只需通过are <code class="fe lf lg lh li b">ApplicationRouter</code>调用一个适当的模块，工作就完成了！</li></ul><p id="062e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，不完全是，我们还没有在这里创建返回响应样板，但这不是现在最重要的。那么，下一步是什么？嗯，我猜是“淘气”模块！</p><h1 id="fee3" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">不一致模块</h1><p id="8d2d" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我们已经创建了一个非常简单的类，叫做<code class="fe lf lg lh li b">NonConformingModule</code>，它没有实现我们从第一章开始讨论的任何架构。它唯一做的事情是用<code class="fe lf lg lh li b">login</code>来获取<code class="fe lf lg lh li b">bearerToken</code>，这就是使用<code class="fe lf lg lh li b">LoginModuleRouter</code>中的<code class="fe lf lg lh li b">login</code>函数的地方，我们之前提到过。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们唯一需要做的就是实例化这个模块并调用<code class="fe lf lg lh li b">login</code>函数，下面将会发生:</p><ul class=""><li id="4f0c" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><code class="fe lf lg lh li b">NonConformingModule</code>直接调用<code class="fe lf lg lh li b">NetworkService</code>作为普通的HTTP请求，但是它将“<code class="fe lf lg lh li b">tandem</code>”作为<code class="fe lf lg lh li b">schema</code>和<code class="fe lf lg lh li b">/login</code>方法的参数传递给<code class="fe lf lg lh li b">LoginModule</code></li><li id="6232" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><code class="fe lf lg lh li b">NetworkService</code>调用iOS的URL加载系统，就像调用任何其他HTTP请求一样。</li><li id="9eca" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">注册的<code class="fe lf lg lh li b">URLRouter</code>类拦截<code class="fe lf lg lh li b">URLSessionTask</code>，发现来自URL的<code class="fe lf lg lh li b">scheme</code>与内部的匹配，确认拦截并创建自身的实例</li><li id="6ab4" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><code class="fe lf lg lh li b">URLRouter</code>用URL调用<code class="fe lf lg lh li b">ApplicationRouter</code>打开<code class="fe lf lg lh li b">LoginModule</code>后者调用<code class="fe lf lg lh li b">LogineModuleRouter</code>剩下的你已经知道了…</li></ul><p id="945e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个展示，如何将URL作为一个通用访问对象，可以通过URL加载系统直接访问我们的模块架构基础设施。</p><h1 id="ff7f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">演示项目</h1><p id="180b" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">检查tag 1.0上的演示项目，并查看我们在前4章中已经讨论过的代码。</p><div class="kl km gp gr kn ko"><a href="https://github.com/poksi592/module-architecture-demo/tree/1.0" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">poksi 592/模块-架构-演示</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">在GitHub上创建一个帐户，为模块架构演示开发做贡献。</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">github.com</p></div></div><div class="kx l"><div class="nh l kz la lb kx lc ld ko"/></div></div></a></div><p id="3aaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将继续讲述如何消除对显式路由器类的需求，并隐式实现路由。在<a class="ae ni" href="https://medium.com/@poksi/module-oriented-architecture-part-5-implicit-routing-655b468ca1b4" rel="noopener">第5部分</a>中阅读相关内容。</p></div></div>    
</body>
</html>