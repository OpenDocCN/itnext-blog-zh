<html>
<head>
<title>Vue.js and Webpack 4 From Scratch, Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js和Webpack 4从头开始，第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/vue-js-and-webpack-4-from-scratch-part-3-3f68d2a3c127?source=collection_archive---------0-----------------------#2018-03-26">https://itnext.io/vue-js-and-webpack-4-from-scratch-part-3-3f68d2a3c127?source=collection_archive---------0-----------------------#2018-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/840d1adbc0d7af85f232277ade65f18c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-4FrGyvSUi7TwDV_."/></div></div></figure><h1 id="7a13" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">包装</h1><p id="3b78" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是使用Webpack 4从头开始配置Vue项目的系列文章的最后一部分，第1部分在这里<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/vuejs-and-webpack-4-from-scratch-part-1-94c9c28a534a">提供</a>，第2部分在这里<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/vue-js-and-webpack-4-from-scratch-part-2-5038cc9deffb">提供</a>。下面我将介绍:</p><ol class=""><li id="f703" class="lv lw iq ky b kz lx ld ly lh lz ll ma lp mb lt mc md me mf bi translated">林挺。</li><li id="e0fe" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">测试。</li><li id="26c4" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">静态资产的处理。</li></ol><p id="79f5" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">并且，基于前一篇文章中的一个问题，我还将提到css提取。</p><p id="04b8" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">最终代码可在<a class="ae lu" href="https://github.com/dfcook/vue-webpack4-template" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="d9dd" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">在对第1部分的评论中，<a class="ae lu" href="http://twitter.com/blacksonic86" rel="noopener ugc nofollow" target="_blank"> @blacksonic86 </a>建议我们的应用程序的入口点应该被称为index.js，而不是app.js。这很有意义，因为它是webpack 4中的默认入口，这意味着我们可以将其从webpack.config.dev.js中删除。</p><p id="13ba" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">在实践中，我经常有多个入口点，因为我使用这种配置来添加polyfills以支持旧的浏览器，如Internet Explorer，但在这种情况下，这是我应该想到的一个变化。更改文件名意味着当前的webpack配置如下。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="eae2" class="ne jz iq na b gy nf ng l nh ni">'use strict'</span><span id="d488" class="ne jz iq na b gy nj ng l nh ni">const webpack = require('webpack')<br/><em class="nk">const</em> { VueLoaderPlugin } = require('vue-loader')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')</span><span id="5ee6" class="ne jz iq na b gy nj ng l nh ni">module.exports = {<br/>  mode: 'development',<br/>  <br/>  devServer: {<br/>    hot: true,<br/>    watchOptions: {<br/>      poll: true<br/>    }<br/>  },  module: {<br/>    rules: [<br/>      {<br/>        test: /\.vue$/,<br/>        use: 'vue-loader'<br/>      }, {<br/>        test: /\.js$/,<br/>        use: 'babel-loader'<br/>      }, {<br/>        test: /\.styl(us)?$/,<br/>        use: [ 'vue-style-loader', 'css-loader', 'stylus-loader' ]<br/>      }<br/>    ]<br/>  },</span><span id="a97b" class="ne jz iq na b gy nj ng l nh ni">plugins: [<br/>    new webpack.HotModuleReplacementPlugin(),<br/>    new VueLoaderPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      template: 'index.html',<br/>      inject: true<br/>    }) <br/>  ]<br/>}</span></pre></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="468b" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">林挺</h1><p id="0789" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">林挺是将静态分析应用到您的代码库以检测问题或实施风格指南的过程。在使用动态类型的语言(如javascript)时，这非常有用。ESLint是标准的linter，它允许你定义规则集来运行你的代码库，或者使用插件来使用预定义的规则集。我们将使用Vue eslint插件来执行Vue应用程序的推荐规则。</p><p id="5940" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们需要安装相当多的npm软件包来启用林挺:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="4735" class="ne jz iq na b gy nf ng l nh ni">npm install --save-dev eslint eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard eslint-config-standard babel-eslint eslint-loader eslint-plugin-vue</span></pre><p id="b2e6" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">完成后，我们需要告诉eslint我们想要使用哪些规则，在项目根目录下创建一个名为. eslintrc.js的文件，并添加这些设置:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="06aa" class="ne jz iq na b gy nf ng l nh ni">module.exports = {<br/>  parserOptions: {<br/>    parser: 'babel-eslint'<br/>  },<br/>  extends: [<br/>    'plugin:vue/recommended',<br/>    'standard'<br/>  ],<br/>  plugins: [<br/>    'vue'<br/>  ]<br/>}</span></pre><p id="051a" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这里我们告诉eslint，我们想用babel解析我们的javascript，然后应用标准的林挺规则和vue插件推荐的规则。</p><p id="6885" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">运行ESLint最简单的方法是通过npm脚本。将它添加到脚本部分的package.json中:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1f0e" class="ne jz iq na b gy nf ng l nh ni">"lint": "eslint --ext .js,.vue src"</span></pre><p id="b07a" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们正在对src文件夹中带有文件扩展名的所有内容运行ESLint。现在运行这个，你应该已经得到一个错误了。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/28efe1fcf51694dde0f1471dc006d5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_GRZIzRzeuiqviHZ3DfdQ.png"/></div></div></figure><p id="3538" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这指向我们index.js中的这些行，我已经安装了VSCode的eslint扩展，所以如果我现在打开这个文件，我可以看到另一个视觉线索，表明有问题。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1db32a1a3b389bfd6be8e7dc1c24022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*8yC-DK5fI0aeCJAUTOFCpQ.png"/></div></figure><p id="04b4" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">有各种方法可以解决这个问题，例如，我们可以导出新的Vue对象，但是让我们告诉ESLint，这一行实际上是可以的，我们希望它忽略它。在有问题的代码前添加以下注释:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1504" class="ne jz iq na b gy nf ng l nh ni">/* eslint-disable-next-line no-new */</span></pre><p id="2457" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">现在，当您重新运行lint脚本时，它应该不会报告任何错误。</p><p id="5f21" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">ESLint还支持自动修复某些类别的错误，我喜欢在我的npm配置中添加一个快捷脚本，以便在需要时运行自动修复:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1690" class="ne jz iq na b gy nf ng l nh ni">"lint:fix": "eslint --ext .js,.vue src --fix"</span></pre><p id="8bf6" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">一旦我们的林挺配置为按需运行，我们希望更改我们的webpack构建，使其自动运行。为此，我们需要安装webpack加载器:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2018" class="ne jz iq na b gy nf ng l nh ni">npm install --save-dev eslint-loader</span></pre><p id="211d" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">并更改我们的webpack配置以添加一个规则来关联我们的。js和。使用ESLint加载程序加载vue文件:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2abc" class="ne jz iq na b gy nf ng l nh ni">{<br/>  test: /\.(js|vue)$/,<br/>  use: 'eslint-loader',<br/>  enforce: 'pre'<br/>}</span></pre><p id="5cab" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这个规则与我们的其他规则相比有一个变化，enforce:“pre”。这意味着ESLint加载程序是一个预加载程序，它将在其他加载程序之前运行，并在babel-loader启动并开始处理javascript之前应用林挺规则。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="c0eb" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">静态资产</h1><p id="30bd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">静态资产是像图像和视频这样的东西，它们不会被Webpack处理，但我们需要将它们复制到我们的dist文件夹中，以便它们可以用于构建的应用程序。</p><p id="287c" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">为此，我们使用copy-webpack-plugin。按照现在已经熟悉的路径，我们需要安装软件包:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cf68" class="ne jz iq na b gy nf ng l nh ni">npm install --save-dev copy-webpack-plugin</span></pre><p id="e965" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">然后在我们的webpack配置中，我们把插件拉进来，并把它添加到我们的插件部分。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="50ac" class="ne jz iq na b gy nf ng l nh ni">const CopyWebpackPlugin = require('copy-webpack-plugin')<br/><em class="nk">const</em> path = require('path')</span><span id="28ca" class="ne jz iq na b gy nj ng l nh ni">function resolve (dir) {<br/>  return path.join(__dirname, '..', dir)<br/>}</span><span id="ee76" class="ne jz iq na b gy nj ng l nh ni">plugins: [<br/>  new CopyWebpackPlugin([{<br/>    from: resolve('static/img'),<br/>    to: resolve('dist/static/img'),<br/>    toType: 'dir'<br/>  }])<br/>]</span></pre><p id="4ded" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这非常简单，我们放在static/img文件夹中的所有图像都将被复制到dist build文件夹中的相应文件夹中。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="86b6" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">测试</h1><p id="f135" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">作为Vue生态系统的一部分，vue-test-utils是Vue.js的官方单元测试库，它支持多个测试运行器、浅层渲染、模拟用户交互、模仿vuex和vue-router以及同步更新(无需调用nextTick来触发dom更新)。</p><p id="e032" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">在这个例子中，我将使用<a class="ae lu" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> jest </a>来运行测试。Jest来自facebook，与React密切相关，但它可以适应任何Javascript库或框架，并且有一个特定于vue的生态系统，允许我们毫无困难地运行我们的测试。</p><p id="352a" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">让我们安装jest:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bb11" class="ne jz iq na b gy nf ng l nh ni">npm install --save-dev jest babel-jest vue-jest jest-serializer-vue @vue/test-utils</span></pre><p id="d3e2" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">Jest是测试程序，vue-jest是一个将vue组件转换成jest的正确格式的包，jest-serializer-vue是一个支持拍摄vue组件快照的包。快照测试允许呈现完整的DOM，然后执行比较以确保它没有改变。</p><p id="9c90" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">Jest不是一个独立的配置文件，而是从我们的package.json配置的。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="fb7d" class="ne jz iq na b gy nf ng l nh ni">"jest": {<br/>  "moduleFileExtensions": [<br/>    "js",<br/>    "vue"<br/>  ],<br/>  "moduleNameMapper": {<br/>    "^@/(.*)$": "&lt;rootDir&gt;/src/$1"<br/>  },<br/>  "transform": {<br/>    "^.+\\.js$": "&lt;rootDir&gt;/node_modules/babel-jest",<br/>    ".*\\.(vue)$": "&lt;rootDir&gt;/node_modules/vue-jest"<br/>  },<br/>  "snapshotSerializers": [<br/>    "&lt;rootDir&gt;/node_modules/jest-serializer-vue"<br/>  ]<br/>}</span></pre><p id="9167" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">当我们在package.json中时，让我们添加一个脚本来实际运行我们的测试:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6808" class="ne jz iq na b gy nf ng l nh ni">"test": "jest"</span></pre><p id="3512" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们需要配置babel来传输我们的测试。babelrc文件:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5a0c" class="ne jz iq na b gy nf ng l nh ni">"env": {<br/>  "test": {<br/>    "presets": [<br/>      ["env", { "targets": { "node": "current" }}]<br/>    ]<br/>  }<br/>}</span></pre><p id="63a4" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">并告诉ESLint我们的测试环境，将它添加到. eslintrc.js文件中:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="328f" class="ne jz iq na b gy nf ng l nh ni">env: {<br/>  browser: true,<br/>  node: true,<br/>  mocha: true<br/>},<br/>globals: {<br/>  expect: true<br/>}</span></pre><p id="f012" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">现在jest已经配置好了，我们可以实际编写一个测试了。为了简单起见，我们将只挂载我们的应用程序组件，并验证它是否具有。中心内容”类。默认情况下，Jest会在名为__tests__的文件夹中查找测试，因此在src文件夹下创建它，并添加一个名为App.spec.js的文件。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/1dfcf7f23422a7cbfd5cbe0c0dca3566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRn28jttdn-Mhq_OgBwuTA.png"/></div></div></figure><p id="d4b6" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们使用Vue test-utils来安装应用程序，然后对返回的包装器运行一个简单的expect。</p><p id="e884" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">要运行该测试，非常简单:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e97c" class="ne jz iq na b gy nf ng l nh ni">npm run test</span></pre><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/1455c4dd5fb394017077495ce0beb162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hA2RnAOXSV1tBYmWANIGCA.png"/></div></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="03f2" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">提取CSS</h1><p id="e737" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是第二部分的评论中提到的问题。这证明了webpack领域的变化速度，在我发表文章后的一周里，将CSS提取到一个单独的文件中的方法已经完全改变了。随着vue-loader 15的发布，MiniCssExtractPlugin是从你的vue单文件组件中提取CSS的标准方式。</p><p id="d886" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">从npm安装插件:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b036" class="ne jz iq na b gy nf ng l nh ni">npm install --save-dev mini-css-extract-plugin</span></pre><p id="d0a2" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">将它添加到我们的webpack配置文件中的插件:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b418" class="ne jz iq na b gy nf ng l nh ni">const MiniCssExtractPlugin  = require('mini-css-extract-plugin')</span><span id="86da" class="ne jz iq na b gy nj ng l nh ni">.<br/>.<br/>plugins: [<br/>  new MiniCssExtractPlugin({<br/>    filename: 'main.css'<br/>  })<br/>]</span></pre><p id="5cce" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">最后，配置我们的手写笔加载器来使用这个插件提取css，配置vue加载器来从我们的单个文件组件中提取CSS:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b05d" class="ne jz iq na b gy nf ng l nh ni">module: {<br/>  rules: [<br/>    {<br/>      test: /\.vue$/,<br/>      use: 'vue-loader'<br/>    }, {<br/>      test: /\.styl(us)?$/,<br/>      use: [<br/>        MiniCssExtractPlugin.loader,<br/>        'css-loader',<br/>        'stylus-loader'<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="386e" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">现在，当我们的应用程序构建时，所有的手写笔都将被提取并放在dist文件夹下的一个css文件(main.css)中。我们的单个文件组件中的作用域CSS也将包括在内，例如:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4687d673dd607c16718959a2761ade84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*N2r3Ro8Z0wDO56ExKem8yQ.png"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="dbe7" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">这是所有的乡亲</h1><p id="0508" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">希望这些文章有所帮助。随着vue-cli 3的即将到来，它们已经有过时的成分，使用webpack的方法将经历重大变化。然而，了解这些东西是如何配置的总是很重要的，没有比从头开始更好的方法了。</p></div></div>    
</body>
</html>