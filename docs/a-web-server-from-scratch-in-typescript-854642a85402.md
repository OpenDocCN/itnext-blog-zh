# 在 TypeScript 和 Node 中从头开始创建 Web 服务器

> 原文：<https://itnext.io/a-web-server-from-scratch-in-typescript-854642a85402?source=collection_archive---------1----------------------->

![](img/4362ed0949841972df18e2a87959eb93.png)

照片由[克里斯蒂娜@ wocintechchat.com](https://unsplash.com/@wocintechchat?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

虽然许多开发人员每天都在编写 web 应用程序，但 HTTP、TCP 和 web 服务器的实际内部工作是许多将`fetch`和您的端点连接在一起的魔胶。在本文中，我将打开黑匣子，向您展示如何在您的 OS*中的套接字上构建一个真正的 web 服务器。

> *从 UNIX 的角度进行推理。

# 套接字和 TCP

套接字允许计算机上的进程通过文件系统相互通信。它们是一种特殊的文件，进程通过使用普通的文件系统 api 在其中进行读写操作。TCP 是通过网络使用套接字实现多台机器之间通信的附加标准。这个标准为 HTTP 和互联网提供了动力。

套接字与客户机-服务器系统一起工作。运行服务器时发生的第一件事是创建一个监听套接字。这个套接字配置了一个 IP 和一个端口。监听套接字是一种特殊的套接字，它用于操作系统和服务器之间的通信，而不是服务器和客户端之间的通信。创建监听套接字后，服务器向该套接字发送一个`accept`命令。现在，操作系统将回复下一次尝试连接到我们的 IP 和端口回到服务器。

发生这种情况时，将为传入的连接创建一个新的套接字。这个套接字是一个客户端套接字，将用于在服务器和客户端之间传输实际数据。服务器完成客户端连接后，它将再次发送`accept`命令，下一个连接将返回到服务器*。

> *稍后，我们将着眼于同时处理多个连接的多线程服务器。

这就是`backlog`概念的由来。`backlog`是操作系统为我们管理的一个队列，它包含了我们仍然需要处理的所有客户端。当创建一个列表套接字时，我们定义在系统拒绝连接更多客户端之前，这个队列中可以有多少个客户端。这个数字是在不花费很多资源对客户端进行排队和在有峰值负载时不拒绝客户端之间的折衷。

# 插座、节点和网络

在 Node 中，我们可以通过使用 Node 标准库中的`net`包来使用套接字。这个包允许我们与套接字连接，向套接字写入，从套接字读取，并启动服务器。我们将从创建服务器套接字并监听 IP 和端口开始。`listen`将继续向套接字发送`accept`命令，并读取它返回的所有内容。

下一步是当客户端连接到我们的套接字时做一些事情。`net`库强烈依赖于所有 JavaScript 开发人员都知道并喜爱的事件监听器模式。因此，监听传入的连接将通过监听`connection`事件来完成:

每次客户端连接时，回调将被调用，并将该连接的客户端套接字作为参数。通过这个套接字，我们可以读取客户端发送给我们的数据，并发回一个响应。为此，我们在连接套接字上使用`data`事件，并给它一个回调，该回调接受客户端发送的带有数据的`Buffer`。这个缓冲区可以作为一个字符串读取，我们可以调用套接字上的`write`来发送数据。

最后一个非常重要的任务是在我们完成后关闭(`end`)连接。否则，如果客户端不关闭它们，我们可能会以打开的连接溢出而告终。这个逻辑还没有处理多部分主体和`Keep-Alive`标题。对于我们编写一个简单易懂的服务器的目标来说，这些并不是必需的，它们也可以在以后添加。

这就是我们在节点中处理 TCP 连接所需的全部内容。如果您调用带有`curl`的地址，您将看到显示的响应。在你的浏览器中打开`localhost:3000`还不行，因为我们首先需要实现 HTTP 标准。

# 超文本传送协议

HTTP 是通过 TCP 套接字进行通信的标准。它描述了如何格式化消息以及服务器应该如何管理连接。从客户端到服务器的 HTTP 消息(请求)如下所示:

在这里，我们看到了更多您在进行 API 调用时使用的熟悉概念，例如`fetch`。消息以动词(方法)开始:`GET`。在这之后，我们找到了 URI，在这种情况下是主页`/`。如果我们在我们的服务器后面写一个框架，我们将使用它进行路由，并找到正确的控制器和操作。第一行最后一个是 HTTP 版本。这是为了与旧客户端兼容。为了简单起见，我们将在本文中忽略它。

从第二行开始，我们找到标题。头是伴随请求的键值对。都写在自己的行上，用`:` 把键和值分开。在最后一个标题后有一个空行。在此之下，请求主体开始。这里它是空的，因为我们正在寻找一个 get 请求，但是这里可能有一个表单或 JSON。我刚才列出的所有信息都可以用下面的界面来描述:

将请求字符串解析为上述接口的对象可以通过下面展示的一些字符串魔术来完成(我不会深入研究解析字符串的有效方法，因为这不是本文的主题)。有了这个函数，我们可以开始用一个看起来很像在你最喜欢的后端框架中编写端点的系统来调用控制器。

HTTP 响应遵循与 HTTP 请求相同的原则。主要区别在于第一行，我们看到的是请求的结果，而不是我们正在请求的资源。在这之后，我们找到了熟悉的标题和正文。

根据这些信息，我们可以创建`Response`接口，并编写一个函数，在通过套接字发回之前将它转换成一个字符串:

如果我们将它合并到服务器代码中，我们会得到下面的代码，它允许我们在浏览器中查看一个网站，这个网站是由我们自己的服务器提供服务的！HTTP 还有更多的东西，例如[cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)。它们是从`Cookie`头中获取的，这在我们的实现中是可能的。设置 cookies 是通过`Set-Cookie`头完成的，这可能在一个响应中出现多次。这是你必须添加到`Response`接口中的东西，因为 ATM 不允许多个标题具有相同的名称。

![](img/a672032a17ca3384054bf2577a21da4a.png)

现在是真正的服务器了！

# 多线程服务器

在文章的开始，我提到了与我们的列表套接字相关的 backlog。此时，我们的服务器只运行在一个进程上，这意味着当它处理一个请求时，所有传入的连接都堆积在 backlog 上。如果我们更新代码，在发送响应之前先计算 100 的斐波那契数列，我们就可以看到这一点。如果您在浏览器中打开多个选项卡并查看控制台输出，您将看到只有第一个选项卡实际连接，其他选项卡将保留在 backlog 中，直到服务器完成第一个选项卡的计算结果。

如果我们有一个某些端点非常慢的应用程序(例如导出函数)，这可能会成为一个严重的问题。它们将阻塞整个服务器，实际上，在导出完成之前，您将有停机时间。有许多方法可以解决这个问题，但它们都是围绕着某种并发模型来解决的，这种模型允许服务器在您的大量导出端点仍在运行时仍然接受传入的连接。许多“生产级”服务器会将客户端套接字放在一个队列中，让其他线程处理它们。

为了使这篇文章简短，我将满足于使用一个[工人池](https://www.npmjs.com/package/workerpool)来完成繁重的计算，并保持所有的连接内容就像在主进程中一样。workerpool 使我们能够在 Node 中保存一个后台工作者池，我们可以将任务分配给后台进程。该池将找到并分配一个工人来做这项工作。pool 的`exec`函数返回一个承诺，该承诺将在任务完成时随结果一起解决。这样，在我们计算斐波纳契数列 100:

如果您现在在多个选项卡中打开站点，您将看到所有连接都在终端中被接受。他们现在都在自己的工作线程上运行计算，这意味着繁重的任务不会再阻塞请求。在这里，我们确实直接发送了`fibonacci`的结果，通常你会将整个后端框架放在一个 worker 上，让它完成所有的查询和处理，而不会妨碍你的服务器完成它的工作。

# 结论

在这篇文章中，我们已经从查看一些低级操作系统概念，到构建一个多线程服务器，可以为您的浏览器提供完整的网站服务。当然，还有很多东西有待探索。我们的服务器的并发模型可以很容易地填充它自己的文章。在服务器后面实现一个处理路由、重定向、文件等的框架也是如此。这篇文章的目的是向你展示你的浏览器是如何连接到你的终端的，我希望你能从中学到一些东西。