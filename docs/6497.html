<html>
<head>
<title>Kubernetes for dummies: deployments and services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚拟的Kubernetes:部署和服务</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-for-dummies-deployments-and-services-7403f30d30ba?source=collection_archive---------0-----------------------#2021-12-04">https://itnext.io/kubernetes-for-dummies-deployments-and-services-7403f30d30ba?source=collection_archive---------0-----------------------#2021-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6dbf" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">KUBERNETES |云概念</h2><div class=""/><div class=""><h2 id="2828" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">第4部分—让pod更有用</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f25dfbb2fdfbba0d96e09897f3da25d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*29KQ5Si1w9Z90uKa"/></div></div></figure><p id="db34" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">欢迎回来，年轻的学徒！现在您已经对集群的内部工作方式和Pod的工作方式有了很好的了解，让我们来看看如何更有效地使用这些东西。</p><p id="2ca1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">正如我们在<a class="ae lw" href="https://bit.ly/fawix-k8s-p3" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中看到的，Pod提供了我们的基本构建模块，但它不一定有利于生产。我们只能从舱内进入应用程序。这样把它暴露在互联网上真的很不方便，也很冒险。另外，这不是永久的。如果一个豆荚死了，它就一直死着。解决这两个问题有不同的方法。我们将介绍基础知识，并在过程中不断添加。</p><p id="d0b3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们来发现服务和部署对象😎</p><h1 id="8e88" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">部署#WTF</h1><p id="a0c1" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">部署为pod增加了几个好处，并支持几个重要的相邻用例。本质上，部署允许k8s在一个或一组Pod上拥有<strong class="lc ja">期望的状态规则</strong>。这些是基本级别的版本展示、回滚和暂停。</p><p id="f5f9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">Kubernetes部署还利用其他k8s对象来进一步增强功能。一个非常常见的构造是“ReplicaSet ”,它定义了这个部署应该创建同一个Pod的多少个副本。Pod的副本称为副本。如果我们说一个部署包含3个副本，这意味着它将运行同一Pod的3个副本。这意味着，在任何给定的时间，k8s将确保期望数量的pod作为部署的一部分运行！如果一个pod死了，k8s会启动一个新的替换它，匹配我们想要的状态。</p><p id="1ff3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">还记得我们的<a class="ae lw" href="https://gist.github.com/fawix/d50d9bb3510f41e2c3f347a1e44ccba9#file-k8s_pod_example-yaml" rel="noopener ugc nofollow" target="_blank"> nginx Pod </a>吗？如果我们想让它成为一个部署，这样万一我们的Pod死了，k8s会自动重启它？</p><p id="2e02" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个物体看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="40c6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">请注意，对象类型现在是Deployment。还有，看<code class="fe mw mx my mz b">spec.template</code>？它包含实际Pod的定义。如果您将它与我们在第3部分中创建的Pod进行比较，您会发现它是相同的。另外，请特别注意<code class="fe mw mx my mz b">spec.replicas</code>字段。这是副本集的一部分，定义了我们需要多少副本。</p><p id="05f8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">还记得我们在第3部分讨论过标签吗？这是它的应用之一。复制集控制器选择所有与<code class="fe mw mx my mz b">spec.selector.matchLabels</code>匹配的容器，并将其与所需状态进行比较。这些标签应与<code class="fe mw mx my mz b">spec.template.metadata.labels</code>中实际Pod标签上的信息相匹配。这个概念在k8s中的几个地方被使用，并且将相关的对象分组以围绕它们构建功能。</p><p id="c534" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">标签是组织大型部署的基础。您还可以通过标签执行<code class="fe mw mx my mz b">kubectl</code>操作过滤，使这个构造非常强大。这些也称为选择器标签，有时也称为过滤器(虽然不太常见)。</p><p id="7e6c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们来看看实际情况:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/0b10b8ea6649bed0aee6c16ccb8c6300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7uCUI_aSIO0k0XDw"/></div></div></figure><p id="0a18" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好了，现在我们解决了永久性问题，让我们来谈谈访问应用程序。</p><h1 id="fc34" class="lx ly iq bd lz ma mb mc md me mf mg mh kf mi kg mj ki mk kj ml kl mm km mn mo bi translated">服务#WTF</h1><p id="3c26" class="pw-post-body-paragraph la lb iq lc b ld mp ka lf lg mq kd li lj mr ll lm ln ms lp lq lr mt lt lu lv ij bi translated">使用k8s有多种方法来公开您的应用程序。服务是我们可以做到的简单方法之一。</p><p id="90d9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">将服务对象视为一个网络抽象。它提供了一种通过单个IP公开在一个或多个pods中运行的应用程序的方法。记住豆荚有自己的IP。例如，如果您的部署有3个副本，您不希望在应用程序中管理它；您需要一种统一的方式来访问它。服务对象将负责处理该位。</p><p id="96f3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">服务对象看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="63f9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">服务的一个便利特性是，它可以将任何传入端口映射到容器上的目标端口，正如您在上面的示例中所看到的。传入流量(进入服务)在<code class="fe mw mx my mz b">spec.ports.port</code>上，从服务到容器的流量在<code class="fe mw mx my mz b">spec.ports.targetPort</code>中映射。</p><p id="650d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在较低的级别，服务包含端点的集合。端点是具有Pod IP的简单对象。记得标签吗？这就是k8s用来将端点作为服务的一部分进行分组的方法。通常，您不需要担心创建端点，因为这是在幕后完成的，但是您可以实际看到它的运行:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/055bbf6522f0aa2f0f203b41bc6b7475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mft6ghT0Ooum5V6-"/></div></div></figure><p id="f0ab" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有了标签，k8s将自动创建端点。端点对象还允许您将服务指向群集外的IP；通过手动设置端点对象。这对于测试未部署在集群中但需要由pod访问的环境或外部依赖项尤其有用。</p><p id="8171" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">服务对象将在集群DNS服务器上为我们提供一个IP和一个DNS条目，以便于服务到服务的通信。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="03cb" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">说到DNS… kube-dns是一个经常部署在集群中的组件。虽然不是强制的也不是核心的组件，但是它对于运行多种服务的集群来说是必不可少的。如果需要，可以用其他DNS服务替换它。一个流行的选择是coreDNS。它在群集内提供名称解析，包括服务域名。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/a445848749a7372a5ecf03a61eccce85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nPornwI1zYG606ud"/></div></div></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="71e4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有许多类型的服务，每一种都有自己擅长的事情:</p><ul class=""><li id="59ad" class="nk nl iq lc b ld le lg lh lj nm ln nn lr no lv np nq nr ns bi translated"><strong class="lc ja">节点端口:</strong>这实际上阻塞了节点中的一个特定端口，让流量直接通过节点IP到达服务。</li><li id="1308" class="nk nl iq lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated"><strong class="lc ja"> ClusterIP: </strong>这让集群从它的服务IP池中为服务分配一个IP(在以后的文章中会详细介绍)</li><li id="9d20" class="nk nl iq lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated"><strong class="lc ja">负载平衡器:</strong>这实际上将使用云控制器管理器在云提供商提供的基础设施上创建一个负载平衡器(假设您正在超大规模环境中运行)。</li></ul><p id="7689" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我们把它们放在一起！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/818a4d057b5715baa29a25baf78f56a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q8lHHL5uefaae-Pk"/></div></div></figure><p id="c846" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如您所见，我们可以从集群外部访问工作负载。服务对象非常简单，不支持复杂的流量规则。我们可以用其他物品来达到这个目的。一个流行的选项是入口对象。顾名思义，它提供了关于入站流量的期望状态规则，并将入站流量路由到部署/服务中。我们将在以后的文章中详细讨论。</p><p id="7013" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们只是触及了表面！还有很多东西需要探索；从这篇博客文章中获取示例部署和服务对象，启动您的Kubernetes集群！如果你还没有安装，可以随意使用<a class="ae lw" href="https://www.katacoda.com/courses/kubernetes/playground" rel="noopener ugc nofollow" target="_blank">奥赖利的Katacoda互动游乐场</a>。好奇！更改服务类型。它表现如何？更改现有部署的所需复制副本数量。修改NGINX欢迎页面，看看是否可以路由到应用程序的两个不同版本。使用原力，我的绝地学徒伙伴！</p><p id="38de" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，我们的工作负载更加强大，但我们还可以做得更好！在<a class="ae lw" href="https://bit.ly/fawix-k8s-pt5" rel="noopener ugc nofollow" target="_blank">的下一篇文章</a>中，我们将看看这种技术带来的一些关键用例。我们将看看相邻的概念，如自动愈合，自动伸缩；以及它们如何在kubernetes中创建弹性工作负载。</p><p id="7c42" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在<a class="ae lw" href="https://twitter.com/fawix" rel="noopener ugc nofollow" target="_blank"> Twitter (@fawix) </a>或<a class="ae lw" href="https://www.linkedin.com/in/fatimasilv/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，这样你就不会错过更新了！愿集装箱与你同在！</p></div></div>    
</body>
</html>