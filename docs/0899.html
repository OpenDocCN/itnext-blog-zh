<html>
<head>
<title>FASTEn your State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扣紧你的状态</h1>
<blockquote>原文：<a href="https://itnext.io/fasten-your-state-9fb9f9b44f30?source=collection_archive---------5-----------------------#2018-06-14">https://itnext.io/fasten-your-state-9fb9f9b44f30?source=collection_archive---------5-----------------------#2018-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="26a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很久很久以前的一天，我去了大学。我很兴奋。我对计算机科学课程期望很高。像C++，或Java，宇宙飞船和3D游戏。但是我们没有给我们一些真正的T4的东西，而是开始学习“离散数学”。</p><blockquote class="km kn ko"><p id="7ee1" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">嘿，<em class="iq">我在这里做什么，这不是我要找的那种“编程”！！！让我出去！！！！</em></p></blockquote><p id="dcb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而第一件事，<strong class="jp ir">我完全没有得到，</strong>是有限状态机(FSM)，或者说<a class="ae ks" href="https://en.wikipedia.org/wiki/Automata_theory" rel="noopener ugc nofollow" target="_blank">自动化</a>。我不明白为什么一个人需要它，为什么我需要它。我不会让你重蹈我的覆辙。</p><p id="4270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是关于<strong class="jp ir">有限状态机</strong>的状态。之所以你不得不<code class="fe kt ku kv kw b">click</code>一个<em class="kl">禁用</em>一个<code class="fe kt ku kv kw b">button</code>，或者不得不<code class="fe kt ku kv kw b">open</code>一个<em class="kl">关闭</em>一个<code class="fe kt ku kv kw b">door</code>。关于某个东西，叫<strong class="jp ir"> CS-in-JS </strong>(不是css)，对前端采用经典编程。以及XState和<a class="ae ks" href="https://github.com/theKashey/faste" rel="noopener ugc nofollow" target="_blank"> Faste </a> —一个js库，用于处理<em class="kl">状态</em>。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/61af1098d9bed8dd780e6c063e67a3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJhM_gMQbFfpfIV7895Cng.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">月球国家</figcaption></figure><h1 id="20fd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">让我们从图表开始</h1><p id="28d3" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">FSM 的主要目标是描述一个更加声明性的工作流程，描述一些事情应该如何工作。除了“正常程序”，它可以做任何事情，甚至是你不想要的和不可预测的事情——由状态机驱动的程序只会做你编程让它们做的事情，仅此而已，因此是完全可预测的。和“安全”。</p><p id="ccb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让事情变得可预测是一个流行的FSM库的目标— <a class="ae ks" href="https://github.com/davidkpiano/xstate" rel="noopener ugc nofollow" target="_blank"> xstate </a></p><div class="mq mr gp gr ms mt"><a href="http://slides.com/davidkhourshid/finite-state-machines#/7" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">有限自动机无限好的用户界面</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">用幻灯片创建的演示文稿。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">slides.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lh mt"/></div></div></a></div><p id="7e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会阅读一篇关于它的文章，或者只是漫步一些幻灯片，或者查看JSConf冰岛2018 的一个<a class="ae ks" href="https://www.youtube.com/watch?v=RqTxtOXcv8Y&amp;feature=youtu.be&amp;t=1607" rel="noopener ugc nofollow" target="_blank">视频，以获得更清晰的观点。这里背后的主要思想简而言之:</a></p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ni"><img src="../Images/64d1f234ce5d2d6c9942243b34abd80e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HLuAZfw4gOM-8Wiqn5WYg.png"/></div></div></figure><blockquote class="km kn ko"><p id="d245" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">(这里的关键词是<strong class="jp ir">确定性</strong>和<strong class="jp ir">有限性</strong>，以及<strong class="jp ir">自动机</strong>和<strong class="jp ir">始终)</strong>。</p></blockquote><p id="8cfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个状态<em class="kl">加上<em class="kl">的某个动作</em>就是一个<em class="kl">的新状态</em>。或者，让我稍微换个说法，FSM定义了<strong class="jp ir">系统</strong>应该如何在<strong class="jp ir">特定状态</strong>下<strong class="jp ir">对</strong>特定动作<strong class="jp ir">做出反应。</strong></em></p><blockquote class="km kn ko"><p id="6ab2" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这里的状态不同于React或Redux状态。你正在读这篇文章——那是你的状态。状态是关于阶段的东西，是定义整个“系统”行为的东西。是的——更像是一个阶段。</p></blockquote><p id="897f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来很简单，但是它允许你创建(1)容易出错的东西，(2)不费力，(3)零维护成本，(4)自动测试，以及(5)容易更改。</p><blockquote class="nj"><p id="3388" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">5合1，如上所示📺。</p></blockquote><p id="ae49" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">你可能会说“<strong class="jp ir">不可能！那些东西不会聚集在一起</strong>！”，但最好问“如何？!"，和FSM，有限状态机就是答案。或者，在这种情况下更准确地说是“状态图”(在xstate中描述FSM的方式)。</p><blockquote class="nj"><p id="a64f" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">出于好奇——美国宇航局使用🔥状态图表🔥去探索🙀火星🙀</p></blockquote><p id="9ba7" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">XState库提供了一个很好且容易理解的例子——交通灯。这<strong class="jp ir">只是一张图纸</strong>和解释<strong class="jp ir">交通灯</strong>如何工作。</p><blockquote class="nj"><p id="cfb4" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">那些图(状态图)可能会有用！您<a class="ae ks" href="https://musing-rosalind-2ce8e7.netlify.com/?machine=%7B%22key%22%3A%22light%22%2C%22initial%22%3A%22green%22%2C%22states%22%3A%7B%22green%22%3A%7B%22on%22%3A%7B%22TIMER%22%3A%22yellow%22%7D%7D%2C%22yellow%22%3A%7B%22on%22%3A%7B%22TIMER%22%3A%22red%22%7D%7D%2C%22red%22%3A%7B%22on%22%3A%7B%22TIMER%22%3A%22green%22%7D%7D%7D%7D" rel="noopener ugc nofollow" target="_blank">可以运行它们</a>！</p></blockquote><figure class="nz oa ob oc od lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ny"><img src="../Images/522344c961f26eedc8127fec945eea84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_TLV1PxL_Cd6uK36rTggw.png"/></div></div></figure><blockquote class="km kn ko"><p id="907c" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">Chat定义定时器事件接收时的状态变化。绿色-黄色-红色-绿色。</p></blockquote><p id="1838" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而且绝对<strong class="jp ir">没有办法搞乱这个代码</strong>。它永远不会从绿色变成红色，而只会按照你的设计去做。它<strong class="jp ir">牢不可破，</strong>和<strong class="jp ir"> </strong>它<strong class="jp ir"> </strong>是“确定性的”。</p><p id="c0a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态图是向你解释交通灯如何工作的简单方法，也是向计算机解释交通灯工作的简单方法。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oe of l"/></div></figure><blockquote class="km kn ko"><p id="47e4" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">当 <strong class="jp ir">事件</strong>被<strong class="jp ir"> </strong>接收时，总是知道<strong class="jp ir">将会发生什么</strong><strong class="jp ir">。</strong></p></blockquote><p id="76ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">甚至在被分派后，xstate会将其状态更改为您所说的状态，甚至是相同的状态，然后触发“<code class="fe kt ku kv kw b">onEnter</code>”事件，该事件会告诉您“接下来您必须做什么”。在这个例子中，每个<code class="fe kt ku kv kw b">light state</code>可以有<code class="fe kt ku kv kw b">onEnter</code>动作，这将告诉硬件实际上改变光的颜色。</p><blockquote class="km kn ko"><p id="b16a" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">“OnEnter”是State与真实代码通信的唯一方式——执行搜索，当有人点击搜索按钮时，加载图像，当有人选择图像时，反之亦然——您必须执行的所有操作才能使应用程序做一些真实的事情。</p></blockquote><p id="d877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记，不是所有的事件都是可以接受的。例如，只有警察才能改变灯的颜色，所以你必须在机器收到事件时做<em class="kl"> "AuthN/AuthZ" </em>。简而言之——x state可以决定是应该传递事件，还是应该忽略事件。这种机制称为<code class="fe kt ku kv kw b">guards</code>，或者简称为“事件过滤条件”。</p><blockquote class="nj"><p id="5482" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">所以状态+(事件+测试)=新状态。</p></blockquote><blockquote class="km kn ko"><p id="a356" class="jn jo kl jp b jq nt js jt ju nu jw jx kp nv ka kb kq nw ke kf kr nx ki kj kk ij bi translated">Guard不是一个“逻辑”，它只是一个接受或不接受一个事件的条件。只要它只是图表上的一个“标签”，就很容易“形象化”和“解释”状态。</p></blockquote><p id="4a74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XState只是一个<strong class="jp ir"> JSON </strong>结构，而不是代码——你可以从它创建一个<strong class="jp ir">可视化图表</strong>，并仔细检查它是如何工作的。在编写任何代码之前，您可以模拟任何情况、任何工作流。接下来，您可以创建一个“xstate-machine ”,并将第一个事件放入其中，等待外部事件的到来。</p><blockquote class="nj"><p id="6f17" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">首先将动作“放”入xstate，然后xstate将动作“放”回给你。</p></blockquote><p id="5df1" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">XState只不过是一种“运动”——它必须从一种状态转换到另一种状态才能存在。无尽的可控运动。</p><p id="6cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与此同时，您可能想知道— <strong class="jp ir">我真的需要FSM吗</strong>？我有一个很好的例子，“为什么你到处都需要FSM”——REDUX<strong class="jp ir"/>。</p><blockquote class="nj"><p id="6aaa" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">有限状态机和Redux是死党！</p></blockquote><p id="5779" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">让我们假设你要取东西，那么你调用FETCH，<code class="fe kt ku kv kw b">reducer</code>把状态改成<em class="kl"> {loading: true} </em>。</p><p id="5095" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，您取消获取，<code class="fe kt ku kv kw b">reducer</code>将状态更改为<em class="kl">{加载:假} </em></p><p id="aba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，fetch完成它的工作(你没有取消一个真正的API调用)，并把数据放入状态，<strong class="jp ir">数据没人需要</strong>了，只要你有<strong class="jp ir">取消</strong>请求，但没有取消一个fetch请求。(<code class="fe kt ku kv kw b">fetch</code> API不包括<code class="fe kt ku kv kw b">.cancel</code>)。但是redux reducer总是做出反应来接受和减少您可能分派的动作。<strong class="jp ir">随时准备将数据</strong>放入存储，当放行动急件时。这是规矩。</p><blockquote class="km kn ko"><p id="4a83" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这是redux最大的问题——reducer通常很简单，它等待你执行“正确的”动作，从不考虑它是否应该接受你分派的东西。</p></blockquote><p id="8553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">redux自动机，可以更好地处理这个问题，让你定义Redux应该“如何”减少每个状态的事件。例如，当您不在提取状态时，不减少数据，并且不响应错误，同样不在提取状态。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi og"><img src="../Images/2332c5ff7a7f779d3d8e4dd5d63d4394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nV8bDYR3iesfuETUWloB8Q.png"/></div></div></figure><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c2a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需添加几行逻辑，你的获取周期就会像它应该的那样工作，而不是像<em class="kl">可以</em>和通常<em class="kl">会</em>那样工作。</p><p id="1f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个redux <em class="kl">框架</em>–<a class="ae ks" href="https://rosmaro.js.org" rel="noopener ugc nofollow" target="_blank">ROS maro</a>可以为任何redux应用程序提供完整的“xstate”体验，包括可视化编辑器。</p><div class="mq mr gp gr ms mt"><a href="https://medium.com/dailyjs/a-javascript-framework-for-functions-of-state-and-action-26b7789eeed0" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">用于状态和动作功能的JavaScript框架</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">状态和动作的函数是带有两个参数的函数:状态和动作。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="oh l ne nf ng nc nh lh mt"/></div></div></a></div><h2 id="0d7a" class="oi lo iq bd lp oj ok dn lt ol om dp lx jy on oo mb kc op oq mf kg or os mj ot bi translated">定义事情应该如何运作，然后把事情做对。</h2><p id="d2b2" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">这些库可以提供的最大优势是——您可能在运行它之前就知道“某些东西”将如何工作。因为你用“宣示性”来描述它。你描述的方式是人类和计算机可以理解的。你们将成为同一页。</p><blockquote class="nj"><p id="f8b6" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">状态图是一个图形，图形是一个固定的结构。你可以建立，遍历，检查它。再次检查、模拟、预测、重构、测试。</p></blockquote><p id="132e" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">我认为——对于超级严肃的事情，比如登月者——最好使用xstate——它会迫使你构建非常可靠的软件。不是授权——而是强制，只要很难创建<em class="kl">不可靠的</em>软件。</p><p id="d8e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用FSM设计你的软件就像做测试驱动开发一样，但是更好。在TDD中，你首先要<strong class="jp ir">创建测试，</strong>定义什么是“应用程序工作正常”<em class="kl"/>，然后写一个<strong class="jp ir">代码来通过</strong>你写的测试。</p><p id="e124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">XState将改变它的工作方式——你不必“提取”应用程序的行为来测试它，也不必“逆向工程”你的应用程序来把它分解到单元测试的层次。你只是在描述它将如何工作——它将按计划工作。还有(！)你不需要写一些代码和一些测试，因为你已经在画状态图的时候做了。状态图是测试，状态图是代码。</p><blockquote class="nj"><p id="5aa6" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">您的应用程序将按照您设计的那样工作。</p></blockquote><p id="d14c" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">但是对于凡人来说，这并不总是方便的。太抽象了。太马蒂什。</p><h1 id="45e7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">真正的用例。</h1><p id="b52c" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">解决问题的最好方法——玩弄它。所以让我们一起玩吧，让我们认识…我！我的不同状态。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ou"><img src="../Images/bb1cec18ad48273e7e04e43b0b134107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_K6PraCZx0i-3slepPosg.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">我——睡觉、写作、加班</figcaption></figure><p id="8d55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我的“我吃”的行为。正如我祖母所说——吃饭时不要说话，那对消化不好。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ov"><img src="../Images/c0d97b7fbbfffa5df130f222a5073cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*we2eg13H_IcnCiVH211nJw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">关于(食物)，什么时候(总是)，然后(不要说话！)</figcaption></figure><p id="9c86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，对不起奶奶，当我吃饭的时候，我在听和说。我是👨‍💻，而我在吃，所以我甚至不改变状态。可能“我”是不同状态机的组合，而消化是其中之一。</p><h2 id="a1d7" class="oi lo iq bd lp oj ok dn lt ol om dp lx jy on oo mb kc op oq mf kg or os mj ot bi translated">反应取决于行动和状态</h2><p id="0d29" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我将如何应对另一个事件？</p><blockquote class="km kn ko"><p id="3cc5" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">如果我醒了，并且有了主意——写一个中型库。</p><p id="9d00" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">如果我要睡觉——刷牙。</p></blockquote><p id="784b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些形成了一个“Excel表格”，这个表格描述了我何时以及如何对事件做出反应，以及我如何从一种状态转换到另一种状态。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ow"><img src="../Images/49a4cbeb76cc0b0fe631cdf93d63f18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezmIjX33ygrTwzBlmiavrQ.png"/></div></div></figure><p id="77fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我遇到朋友时，我会:</p><ul class=""><li id="cda6" class="ox oy iq jp b jq jr ju jv jy oz kc pa kg pb kk pc pd pe pf bi translated">进入<code class="fe kt ku kv kw b">talking</code>状态，<strong class="jp ir">如果</strong>我有一段时间没见到我的伴侣。</li><li id="83b4" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">就<code class="fe kt ku kv kw b">emit</code>“嘿，伙计！”，<strong class="jp ir">如果</strong>昨天遇到他。</li></ul><p id="86b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都可以用简单的规则来描述。简单到足以防止错误。这是定义FSM的最常见形式— <a class="ae ks" href="https://en.wikipedia.org/wiki/Finite-state_machine#State/Event_table" rel="noopener ugc nofollow" target="_blank">状态或事件表。</a>(非图表/图形)</p><h2 id="cf6d" class="oi lo iq bd lp oj ok dn lt ol om dp lx jy on oo mb kc op oq mf kg or os mj ot bi translated">行动是一种反应</h2><p id="9e7d" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">任何行为都会导致反作用。对于不同的状态，实际的动作处理程序可能是不同的，但是应该做一些事情。</p><blockquote class="nj"><p id="56d9" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">当我单击按钮时—调用onClick事件</p><p id="20e7" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">如果按钮被“禁用”,它将不会接受事件。或者什么都不做。或者干脆不调用onClick。</p></blockquote><p id="4570" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated"><strong class="jp ir">不能点击禁用按钮</strong>的原因——在<code class="fe kt ku kv kw b">disabled</code>状态下不接受<code class="fe kt ku kv kw b">onClick</code>。但是<code class="fe kt ku kv kw b">disabled</code>、<code class="fe kt ku kv kw b">hovered</code>、<code class="fe kt ku kv kw b">focused</code>、<code class="fe kt ku kv kw b">pressed</code>“状态”应该如何共存？按钮可能同时处于所有这些状态！</p><blockquote class="km kn ko"><p id="85b9" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">“我”可能存在于100500个不同的状态中，或者“我”实际上可能只存在于😴(睡觉)还有🤔(没有下滑)，而其他一切都是“子状态”👨‍💻作为...的替代🤔和🧛‍♂️作为一个州😴？</p></blockquote><p id="be90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上——当我和朋友交谈时——我是处于<code class="fe kt ku kv kw b">talking</code>状态，还是只是我的某个部分在说话，而“我”只是<code class="fe kt ku kv kw b">awake?</code></p><p id="80aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“嵌套状态”可能非常有用，任何使用React或其他“组件”方法的人都很熟悉。BigState由较小的状态机组成。他们甚至可以共享一个“状态”(在“状态”的反应意义上)。</p><h1 id="82cd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">禁食</h1><p id="fab0" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">Faste是一个事件(“Excel”)表。还有一个库，让你描述"<strong class="jp ir">什么</strong>应该做什么，<strong class="jp ir">当</strong>在某种<strong class="jp ir">状态下</strong>收到某种<strong class="jp ir">信号</strong>。</p><blockquote class="km kn ko"><p id="b06f" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">表格没有“图形”或“图表”冗长，但也不包含某些信息。例如，在中只包含“操作句柄”，但没有关于“状态转换”的内容。</p></blockquote><p id="29cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Faste是一个黑匣子——你可以<strong class="jp ir">把</strong>一些动作放在里面，<strong class="jp ir">观察</strong>机器的状态如何变化，并在某处连接机器的<strong class="jp ir">输出</strong>通道。例如连接到另一个Faste输入。</p><blockquote class="nj"><p id="b35b" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">Faste是一个黑盒子。一个输入，一个输出，魔术在里面。</p></blockquote><p id="6518" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">一个很好的例子——交通灯。什么-&gt;什么时候-&gt;然后</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="10d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，你可以<code class="fe kt ku kv kw b">light.put('tick')</code>它会跨州移动。</p><p id="5f50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Faste的“力量”来自知识<code class="fe kt ku kv kw b">when</code>我们正在倾听一些行动。在红绿灯的情况下，我们总是只听一个事件——<code class="fe kt ku kv kw b">tick</code>，但是在真实的情况下，你肯定会听到不同的事件，其中一些事件将被绑定到一些州，而不是每个州。Faste提供了钩子，当某个动作<strong class="jp ir">开始或停止被接受时，钩子就会触发。</strong></p><p id="b605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个很好的例子——拖放。就是极好的例子！先来一张桌子。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pl"><img src="../Images/a8c95b1ad8873c266b26ddbee94c0c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KkeWffBU7ta1IEG0ZhRcqQ.png"/></div></div></figure><p id="bd50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只在空闲状态下监听down，只在活动状态下监听move/up。</p><blockquote class="km kn ko"><p id="387b" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">它不完全是关于“状态变化”，更多的是关于事件转移。</p></blockquote><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oe of l"/></div></figure><blockquote class="km kn ko"><p id="16b2" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这不是一个真实的例子，<a class="ae ks" href="https://github.com/theKashey/React-stroller/blob/master/src/DragEngine.ts" rel="noopener ugc nofollow" target="_blank">真实的“drag engine”</a>要复杂一点。</p></blockquote><p id="a579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个faste机器监听<code class="fe kt ku kv kw b">mousedown</code>，然后释放一个事件，并开始监听<code class="fe kt ku kv kw b">mousemove/mouseup</code>，触发消息返回到faste，<strong class="jp ir">将它们发送</strong>，结果<strong class="jp ir">到外部消费者</strong>。附加，分离处理程序，编码和解码数据，做所有的事情。可预测且清晰。</p><blockquote class="nj"><p id="3d36" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">Faste是一个“组件”状态机。</p><p id="cc34" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">它可以做任何它必须做的工作。</p></blockquote><h1 id="265e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly pm ma mb mc pn me mf mg po mi mj mk bi translated">属性和状态。</h1><p id="1c46" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">正如我上面提到的——Faste是一个黑盒子。黑匣子离部件如此之近。我提到过Faste是一个组件状态机。并且能够在不同的地方重用一个组件——它需要属性，比如React props。</p><p id="db58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Faste拥有:</p><ul class=""><li id="4931" class="ox oy iq jp b jq jr ju jv jy oz kc pa kg pb kk pc pd pe pf bi translated">属性，<strong class="jp ir">您可以在外部设置</strong>，<strong class="jp ir">可以读取</strong>，但不能更改。</li><li id="51d0" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">状态，等于反应状态，它可以在内部使用。但是你不能从外面进入T21。</li><li id="66eb" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">因而“自动机状态”被命名为相位。</li></ul><p id="6cee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一个例子中，<code class="fe kt ku kv kw b">Light</code>使用内部状态来跟踪它应该去的“方向”,并且它也由另一个机器“tickSource”控制，该机器<code class="fe kt ku kv kw b">put</code>点亮，以将其从一个阶段切换到另一个阶段。tickSource也是可控的——你可以“切换”它。</p><p id="2146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果一些反应成分将<code class="fe kt ku kv kw b">observe</code>光相位改变，并呈现出来。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1d89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来很复杂。事实上，它是安全且可维护的(🤞).</p><blockquote class="nj"><p id="445d" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">查看完整演示</p></blockquote><figure class="nz oa ob oc od lc"><div class="bz fp l di"><div class="pp of l"/></div></figure><p id="bfa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我为您准备的一些代码片段，以突出基于事件表的状态机相对于“通用”代码的优势:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="f85a" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">那么我为什么要用FSM呢？</h1><p id="fdfc" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">它更容易出错。<strong class="jp ir">方式更</strong>。它让你更简短地描述复杂的事物，更重要的是，正确地描述它们。</p><p id="ac01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或许xstate的创建者——<a class="pq pr ep" href="https://medium.com/u/3b9ee2f9eaa2?source=post_page-----9fb9f9b44f30--------------------------------" rel="noopener" target="_blank">大卫·库尔希德</a>更好地解释了这一点。状态图也很好理解。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="ps of l"/></div></figure><p id="04e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Faste不是xstate。它不支持并行或嵌套状态，并且您不能从它构建一个奇特的图形。但是它支持内部“状态”、自动钩子绑定和typescript(它能用来构建一个图吗？).</p><ul class=""><li id="6aab" class="ox oy iq jp b jq jr ju jv jy oz kc pa kg pb kk pc pd pe pf bi translated">没有“平行”状态—使用内部状态。</li><li id="6830" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">没有“嵌套”状态，但是您可以嵌套独立的机器。</li><li id="874a" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">但是没有办法“嵌套”机器，只能将它们<code class="fe kt ku kv kw b">connect</code>到一起(在一个神奇的<code class="fe kt ku kv kw b">@init</code>事件处理程序中)。</li><li id="abcc" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">但是有集成调试，你可以通过一个命令激活，一切都会变得更加透明。</li><li id="58a5" class="ox oy iq jp b jq pg ju ph jy pi kc pj kg pk kk pc pd pe pf bi translated">有一种简单的方法可以单独调试机器，并重用它们，就像您可以对UI组件所做的那样。</li></ul><p id="5b54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Faste的发明并不是为了解决UI问题，而是在差不多10年前为VoIP硬件加电。</p><blockquote class="km kn ko"><p id="3343" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">创建C++ Faste版本是为了处理EDSS(E1，Q.931，QSIG，H.232)协议——3层，31个状态，12个事件和定时器..这是一个庞大且有很多错误的代码库，我们无法处理。</p><p id="19e1" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">Faste是IBM (Telelogic) TauSDL的“克隆”，它是一个基于SDL的开发工具。大卫在他的视频(2018)中提到的“从图生成代码”。SDL是一个框图，你可以在一些计算机课程中看到。</p></blockquote><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pt"><img src="../Images/4ef3a59d7f572f2c37e0a5430bd5f676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0H3fcY2mC2IZOwVQBx8lkg.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">U17州🤯</figcaption></figure><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="pu of l"/></div></figure><p id="1938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">10年来，我想拥有和使用C语言一样的JavaScript体验，这就是我构建Faste的原因(抱歉，我应该在10年前就这么做)。我在Faste上使用的第一个应用程序是另一个react自定义滚动条的拖拽器— <a class="ae ks" href="https://github.com/theKashey/React-stroller" rel="noopener ugc nofollow" target="_blank"> react-stroller </a>。</p><blockquote class="km kn ko"><p id="f7cb" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">我写过JS draggers可能10年10次。使用jQuery，Google Maps，React和DOM API。这是我不用调试的第一个程序。</p></blockquote><blockquote class="nj"><p id="8370" class="nk nl iq bd nm nn pv pw px py pz kk dk translated">在你的状态下禁食。高速行驶时注意安全。</p></blockquote><p id="81cb" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">有限状态机和状态图可以节省你的时间，让你更容易地做复杂的事情。</p><div class="mq mr gp gr ms mt"><a href="https://github.com/theKashey/faste" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">早餐/斋饭</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">基于快速组件📦有限状态机管理器🤖</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="qa l ne nf ng nc nh lh mt"/></div></div></a></div><p id="7db1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:需要更多例子？看一看faste测试。然后——看看你的代码，尝试在任何地方应用FSM数据获取、事件处理、事件流。敬一切。</p><blockquote class="nj"><p id="a067" class="nk nl iq bd nm nn no np nq nr ns kk dk translated">你知道，有限状态机有无限的应用。</p></blockquote><p id="1463" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">PS:你可以把动作从一个发明状态转移到另一个状态。XState也可以作为一个构建模块。</p><h2 id="d4c1" class="oi lo iq bd lp oj ok dn lt ol om dp lx jy on oo mb kc op oq mf kg or os mj ot bi translated">参考</h2><div class="mq mr gp gr ms mt"><a href="https://medium.com/@elianne/vintage-concepts-fresh-applications-cs-in-js-af85be4ed487" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">古老的概念，全新的应用——计算机科学与工程</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">上个月，我有幸参加了React Amsterdam，那里有许多精彩的演讲。我建议你检查一下…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="qb l ne nf ng nc nh lh mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://github.com/davidkpiano/xstate" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">davidkpiano/xstate</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">xstate - Functional，无状态JS有限状态机和状态图</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="qc l ne nf ng nc nh lh mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://github.com/MicheleBertoli/react-automata" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">MicheleBertoli/反应自动机</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">react自动机——React的状态机抽象</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="qd l ne nf ng nc nh lh mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://github.com/mocoding-software/redux-automata" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">编码软件/冗余自动机</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">redux的有限状态自动机。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">github.com</p></div></div><div class="nc l"><div class="qe l ne nf ng nc nh lh mt"/></div></div></a></div></div></div>    
</body>
</html>