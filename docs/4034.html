<html>
<head>
<title>Protected view-only Postgres schemas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">受保护的只读Postgres模式</h1>
<blockquote>原文：<a href="https://itnext.io/protected-view-only-postgres-schemas-60635e4fe01d?source=collection_archive---------10-----------------------#2020-04-13">https://itnext.io/protected-view-only-postgres-schemas-60635e4fe01d?source=collection_archive---------10-----------------------#2020-04-13</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/d2bcb258c24359a30bfdce68bca389ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEq-xUAAhk8kWcGPmINb4g.jpeg"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">军刀钟</figcaption></figure><p id="a754" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">希望你在这场健康危机中一切都好。记得保持安全，如果可能的话呆在家里。</p><p id="49e2" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">您是否曾经需要给<em class="le">一些</em>对数据库的访问权限，比如说<em class="le">选择</em>对某些表的访问权限，但是还要记录用户执行了哪些查询？<br/>我们不久前就有这个要求。前两个部分很容易实现:</p><ol class=""><li id="04e3" class="lf lg iu ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="ki iv"> <em class="le">一些权限</em> </strong>:创建一个新的使用角色，同时只有选择权限。</li><li id="75a0" class="lf lg iu ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="ki iv"> <em class="le">访问部分表格</em> </strong>:创建所需表格的视图</li></ol><p id="2519" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">记录执行的查询并不那么简单，因为在一个<em class="le"> SELECT </em>查询上没有触发器。</p><h1 id="e2e7" class="lt lu iu bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">肮脏的把戏</h1><p id="dac9" class="pw-post-body-paragraph kg kh iu ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld in bi translated">所以我们需要记录执行了哪些查询。我们可能需要一个新表，可能在另一个模式上，还需要一个<em class="le"> Postgres </em>函数在日志表上插入一条记录。</p><h2 id="6dda" class="mw lu iu bd lv mx my dn lz mz na dp md kr nb nc mh kv nd ne ml kz nf ng mp nh bi translated">桌子</h2><p id="c307" class="pw-post-body-paragraph kg kh iu ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld in bi translated">经典结构:</p><ul class=""><li id="f9d9" class="lf lg iu ki b kj kk kn ko kr lh kv li kz lj ld ni ll lm ln bi translated"><strong class="ki iv"> <em class="le"> id </em> </strong>:序列号，主键</li><li id="c887" class="lf lg iu ki b kj lo kn lp kr lq kv lr kz ls ld ni ll lm ln bi translated"><strong class="ki iv"> <em class="le">用户</em> </strong> : varchar，执行查询的数据库用户</li><li id="209a" class="lf lg iu ki b kj lo kn lp kr lq kv lr kz ls ld ni ll lm ln bi translated"><strong class="ki iv"> <em class="le"> sql </em> </strong>:文本，查询本身</li><li id="1cda" class="lf lg iu ki b kj lo kn lp kr lq kv lr kz ls ld ni ll lm ln bi translated"><strong class="ki iv"> <em class="le"> ip </em> </strong> : varchar，用户连接的ip</li><li id="5fe1" class="lf lg iu ki b kj lo kn lp kr lq kv lr kz ls ld ni ll lm ln bi translated"><strong class="ki iv"> <em class="le"> executed_at </em> </strong>:时间戳，查询执行的完整日期。</li></ul><p id="64dd" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">顺便说一下，在创建数据库对象时，一个好主意是包含一些关于每个列用途的注释(如果是表的话)。可能会有一些额外的工作，但每个人都会感谢。</p><pre class="nj nk nl nm gu nn no np nq aw nr bi"><span id="78ad" class="mw lu iu no b gz ns nt l nu nv">CREATE TABLE public.query_log (<br/>  id serial NOT NULL,<br/>  "user" varchar(150) NULL,<br/>  "sql" text NULL,<br/>  ip varchar(25) NULL,<br/>  executed_at timestamp NULL DEFAULT NOW(),<br/>  CONSTRAINT query_log_pkey PRIMARY KEY (id)<br/>);</span></pre><p id="7d31" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">表<em class="le"> query_log </em>将在<em class="le"> public </em>模式上创建，您可能希望也可能不希望更改，这取决于您自己的需要。</p><h2 id="4fa7" class="mw lu iu bd lv mx my dn lz mz na dp md kr nb nc mh kv nd ne ml kz nf ng mp nh bi translated">该功能</h2><p id="1eda" class="pw-post-body-paragraph kg kh iu ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld in bi translated">它基本上是一个简单的插入，但是你需要它作为一个函数，这样你就可以完成这个任务。</p><pre class="nj nk nl nm gu nn no np nq aw nr bi"><span id="4d5e" class="mw lu iu no b gz ns nt l nu nv">-- DROP FUNCTION public.log_query_information;<br/>CREATE OR REPLACE FUNCTION public.log_query_information(quser character varying, qsql text, qip character varying)<br/> RETURNS boolean<br/> LANGUAGE plpgsql<br/>AS $function$<br/>BEGIN  <br/> INSERT INTO public.query_log<br/>  ("user", "sql", ip)<br/>  VALUES(quser, qsql, qip) ON CONFLICT DO NOTHING;<br/> RETURN TRUE;<br/>END;<br/>$function$<br/>;</span></pre><p id="0b10" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">对<em class="le">下拉</em>进行注释，以防您稍后需要删除该功能。</p><p id="9d9e" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这里有两件重要的事情。首先<em class="le">返回true，</em>因为这个函数必须返回一些东西<em class="le"> ( </em>记住<em class="le">，这个窍门)。</em>其次<em class="le">在冲突上什么都不做，</em>这是为了避免<em class="le">【休斯顿我们有问题】</em>的实例<em class="le">。</em></p><p id="eccd" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">我建议在生产环境中尝试之前，在您机器上的<em class="le"> Postgres </em>安装上或者在<em class="le"> docker </em>上运行的<em class="le"> Postgres </em>服务器上进行本地测试。就我个人而言<em class="le">避免复制&amp;粘贴任务</em>我有意跳过重要的部分，以确保你阅读并理解整篇文章。</p><p id="da32" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">如您所见，表和函数都是在<em class="le">公共</em>模式上创建的。它可能是另一个模式，但是我建议使用一个与您将要为视图创建的新模式不同的模式，视图模式是用于视图的。</p><h2 id="2b57" class="mw lu iu bd lv mx my dn lz mz na dp md kr nb nc mh kv nd ne ml kz nf ng mp nh bi translated">模式和角色</h2><p id="0f03" class="pw-post-body-paragraph kg kh iu ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld in bi translated">新的模式必须包含您希望授予视图访问权限的表的所有视图。<br/>跳过一些其他的额外功能，新的用户角色必须拥有对表的<em class="le"> SELECT </em>特权(在视图模式之外)和对<em class="le"> query_log </em>表的<em class="le"> INSERT </em>特权。</p><pre class="nj nk nl nm gu nn no np nq aw nr bi"><span id="9388" class="mw lu iu no b gz ns nt l nu nv">-- Create the new schema, grant authorization to <br/>-- postgres user (change if needed)<br/>CREATE SCHEMA "restricted_schema" AUTHORIZATION postgres;</span><span id="35cd" class="mw lu iu no b gz nw nt l nu nv">-- Create new role<br/>CREATE ROLE restricted_user NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT LOGIN PASSWORD 'restricted_USER_passsword';</span><span id="9682" class="mw lu iu no b gz nw nt l nu nv">-- Grant SELECT access to original tables on internal schema<br/>-- Will use schema: internal and table: company_users as example<br/>GRANT SELECT ON TABLE internal.company_users TO restricted_user;</span><span id="4cd0" class="mw lu iu no b gz nw nt l nu nv">-- Grant INSERT on query_log and allow operations on sequence<br/>GRANT INSERT ON TABLE public.query_log TO restricted_user;<br/>GRANT ON SEQUENCE public.query_log_id<br/>GRANT USAGE, SELECT ON SEQUENCE public.query_log_id_seq TO restricted_user;</span><span id="f5ac" class="mw lu iu no b gz nw nt l nu nv">-- Allows the user to access the restricted schema<br/>GRANT USAGE ON SCHEMA restricted_schema TO restricted_user;</span><span id="5813" class="mw lu iu no b gz nw nt l nu nv">-- Removes all other permissions to the restricted user<br/>REVOKE ALL ON ALL TABLES IN SCHEMA  pg_catalog FROM restricted_user;   <br/>REVOKE ALL PRIVILEGES ON TABLE pg_catalog.pg_proc FROM restricted_user;<br/>REVOKE ALL PRIVILEGES ON TABLE pg_views FROM restricted_user;<br/>REVOKE SELECT ON TABLE pg_proc FROM restricted_user;<br/>REVOKE SELECT ON TABLE pg_views FROM restricted_user;</span><span id="25e9" class="mw lu iu no b gz nw nt l nu nv">-- Allow the execution of the function<br/>GRANT EXECUTE ON FUNCTION public.log_query_information("varchar","text","varchar") TO restricted_user;</span></pre><h2 id="fd0b" class="mw lu iu bd lv mx my dn lz mz na dp md kr nb nc mh kv nd ne ml kz nf ng mp nh bi translated">景色</h2><p id="d515" class="pw-post-body-paragraph kg kh iu ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld in bi translated">这里有一个技巧，您将像往常一样创建一个视图，但是从您的"<em class="le">视图选择</em>的最后一列将调用<em class="le">public . log _ query _ information</em>函数(这就是我们需要<em class="le">返回true </em> for的原因)。</p><pre class="nj nk nl nm gu nn no np nq aw nr bi"><span id="ecd6" class="mw lu iu no b gz ns nt l nu nv">-- DROP VIEW restricted_schema.company_users;<br/>CREATE OR REPLACE VIEW restricted_schema.company_users<br/>AS SELECT <br/>    pp.id,<br/>    pp.code,<br/>    pp.name,<br/>    pp.last_name,<br/>    pp.soc_sec_number,<br/>    pp.created_at,<br/>    pp.updated_at,<br/>    pp.deleted_at,<br/>    pp.company_id<br/>from (SELECT p.id,<br/>    p.code,<br/>    p.name,<br/>    p.last_name,<br/>    p.soc_sec_number,<br/>    p.created_at,<br/>    p.updated_at,<br/>    p.deleted_at,<br/>    p.company_id,<br/>    public.log_query_information(current_user::varchar, current_query(), inet_server_addr()::varchar) <br/>   FROM internal.company_users p<br/>     LEFT JOIN internal.company cc ON cc.id = p.company_id AND cc.id = 123) AS pp;</span></pre><p id="907b" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">因此，我们的视图只对带有<em class="le"> company_id=123 </em>的记录进行选择。您还应该注意到一个别名为<em class="le"> pp </em>的子查询，这只是为了保持视图中的<em class="le"> SELECT * </em>干净，没有奇怪的<em class="le">函数</em>到处调用。</p><p id="ec02" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><strong class="ki iv"> <em class="le">诀窍</em> </strong>:视图返回所有请求的信息，但是在每条记录上，它还会在我们的<em class="le"> public.query_log表</em>上插入一条新记录。继续，试一试…</p><p id="923d" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">看到这里的问题了吗？再看一遍…这还没有结束。假设你有50000名公司用户。由于<em class="le">视图<em class="le">内的</em>选择</em>会对每条记录执行<em class="le">功能</em>，您的<em class="le">插入</em>也会被执行那么多次。一个<strong class="ki iv">单个</strong>查询的<em class="le"> query_log </em>记录太多。不好…</p><p id="a437" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated"><strong class="ki iv"> <em class="le">如何解决这个</em> </strong>:还记得<em class="le">上冲突什么都不做</em>吗？这就是我说的休斯顿。<br/>一些你如何需要确保每个查询只插入一个日志查询记录。为此，我们得到了一些独特的指标<strong class="ki iv"><em class="le"/></strong>。<br/>只需在所有<em class="le">列上创建一个新的<em class="le">索引</em>当任何<em class="le">选择</em>而不是<em class="le">视图</em>被执行时，你看到的</em>就会重复。</p><p id="3759" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">那就是:</p><pre class="nj nk nl nm gu nn no np nq aw nr bi"><span id="8ef0" class="mw lu iu no b gz ns nt l nu nv">CREATE UNIQUE INDEX query_log_unique_records ON public.query_log ("user","sql",ip,executed_at);</span></pre><p id="d104" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">这应该适用于大多数情况，因为对于单个查询，<strong class="ki iv"> <em class="le">用户</em> </strong>、<strong class="ki iv"> <em class="le"> sql </em> </strong>查询、连接<strong class="ki iv"> <em class="le"> ip </em> </strong>和<strong class="ki iv"> <em class="le"> executed_at </em> </strong>时间戳应该是相同的。</p><p id="f40c" class="pw-post-body-paragraph kg kh iu ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld in bi translated">和往常一样，您的收获可能会有所不同，但是这应该会让您对如何使用查询日志创建一个仅查看模式有一个很好的想法。如果您需要某种“<em class="le">选择触发器</em>”解决方法，它也可以帮助您。</p></div></div>    
</body>
</html>