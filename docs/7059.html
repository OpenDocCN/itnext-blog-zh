<html>
<head>
<title>Getting Functional with C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#获得功能</h1>
<blockquote>原文：<a href="https://itnext.io/getting-functional-with-c-6c74bf279616?source=collection_archive---------0-----------------------#2022-05-28">https://itnext.io/getting-functional-with-c-6c74bf279616?source=collection_archive---------0-----------------------#2022-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1506" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着C#的成熟，它一直在采用函数式编程的元素。正如我之前讨论过的，在许多情况下，C#继续与TypeScript和JavaScript融合。</p><p id="d887" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有一个小的repo，在那里我与C#的更多功能方面分享了我的一些实验:</p><div class="kl km gp gr kn ko"><a href="https://github.com/CharlieDigital/js-ts-csharp" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">GitHub-Charlie digital/js-ts-cs harp:一个展示C# 10函数技术的资源库…</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">这个库旨在突出C#中可用的各种功能技术。点击此处阅读更多内容…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">github.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><p id="a72e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://www.reddit.com/r/csharp/comments/ups0y4/can_i_store_functions_in_a_list_but_when_i_call/" rel="noopener ugc nofollow" target="_blank">受Reddit帖子</a>中一个问题的启发(你可以在那里看到我的原始回复)，让我们来看看这个实验室的最新成员。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="c83a" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">使用Lambda表达式</h2><p id="af92" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">为了方便起见，我们可以通过创建<a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions" rel="noopener ugc nofollow" target="_blank"> lambda表达式</a>到“alias”<code class="fe mk ml mm mn b">Console.WriteLine</code>来开始我们的实验:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/931aa4c2636a2935a9fbb78403c7a65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MqfKtomrN_3_yZkEienOw.png"/></div></div></figure><p id="1b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是减少代码中视觉混乱的一个非常方便的方法。我在引号中使用“alias ”,因为我们所做的只是编写一个名为<code class="fe mk ml mm mn b">log</code>的函数，但是使用lambda表达式和局部函数使它更加简洁。</p><h2 id="93d4" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">Lambda表达式列表</h2><p id="7047" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们的第一个例子是一个简单的函数数组。我们可以遍历数组，用我们的输入调用每个函数:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mz"><img src="../Images/4892bda95bb77b2a909e976555955a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOLFPEO7Sxa6rl8EpKR_OQ.png"/></div></div></figure><p id="6862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">用例</em> </strong>:验证器，当运行不同的计算来比较不同算法的结果时，快速而肮脏的轻量级<a class="ae le" href="https://refactoring.guru/design-patterns/chain-of-responsibility" rel="noopener ugc nofollow" target="_blank">责任链</a>。</p><h2 id="8420" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">命名Lambda表达式</h2><p id="5826" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们还可以通过将函数放入字典中，将它们命名为字符串:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nb"><img src="../Images/0ae960ee29339591bc0b6ab214a376a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCGrRTuOcNsJWJwvMsb_Xg.png"/></div></div></figure><p id="306f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这看起来应该与任何编写JavaScript或TypeScript的人非常相似(尽管在C#中有点冗长，因为编译器无法推断出<code class="fe mk ml mm mn b">namedFunctions</code>的类型，因为C#有不止一个字典类型(<em class="na"> idea </em>):我们能让它默认为<code class="fe mk ml mm mn b">Dictionary&lt;string,string&gt;</code>吗？那就太棒了。)</p><p id="f927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">用例</em> </strong>:通过使用字符串索引器代替属性上的反射，用一个更有性能的选项替换反射。</p><h2 id="b8a1" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">Lambda表达式的引用</h2><p id="7ec9" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们还可以使用lambda表达式的引用列表:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/1954451e41d2057441fc5dbb05a982ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JxIpkgjT2BZGqqLeDlC6jQ.png"/></div></div></figure><h2 id="2c53" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">接受任意数量的参数</h2><p id="d2b6" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">利用<a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/" rel="noopener ugc nofollow" target="_blank"> LINQ </a>，我们可以接受任意数量的参数:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nd"><img src="../Images/2e9a486a1377dc126751daba7c3254d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_m7KPxkOiVrpyL6gUX9b9g.png"/></div></div></figure><h2 id="3b05" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">用另一个Lambda表达式包装</h2><p id="2f50" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们可以将lambda表达式的列表包装在另一个lambda表达式中:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ne"><img src="../Images/d88b4a954644935d2e8dd5cbafb0021e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZvTkvP4XurxHyuIpFjCAw.png"/></div></div></figure><h2 id="d990" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">在字典中返回结果</h2><p id="41c5" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们可以将结果作为一个字典返回，如果我们通过JSON与前端接口，这个字典会很有用:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/21c8eb680abe39ee6fd0baac8e351e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kM25VPE17XavQBFZwsxFTw.png"/></div></div></figure><p id="8bb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="na">用例:</em> </strong> <em class="na">动态生成JSON结果到一个前端，验证你想要的地方有一个键值标识哪个验证器失败。</em></p><h2 id="312e" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">以元组的形式返回结果</h2><p id="0cd1" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们还可以将结果作为一个元组:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ng"><img src="../Images/2257f9348dcee2e29490b014b6c9e2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjlc5Sue278mPVUD1CdhSw.png"/></div></div></figure><h2 id="f1d6" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">按参数数量执行</h2><p id="d5f0" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">使用C# <a class="ae le" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/switch-expression" rel="noopener ugc nofollow" target="_blank">开关表达式</a>，可以根据参数数量选择输出:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/069e0fc108d2663ccefd541a4544f675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BoQ-qzmnblDz3v6tn7m2A.png"/></div></div></figure><p id="a160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的很喜欢switch表达式的表现力，事实上，虽然它远比替代方案更紧凑，但它似乎没有失去任何可读性；我认为这实际上改善了它。</p><h2 id="3c39" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">参数和λ表达式的数量</h2><p id="d57b" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我们甚至可以将开关表达式与lambda表达式结合起来:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/9d2b34407f411fb184e437f72fb008a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVTBNZ7pCK2gjYW3MnpySA.png"/></div></div></figure><h2 id="1d54" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">模式匹配开关表达式与内联Lambda表达式</h2><p id="d91e" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">或者将这些相同的lambda表达式与switch表达式内联:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/91574c17b60c49bd1ec67242223df036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mym8ZEbefONm4oeLNSZH1g.png"/></div></div></figure><h2 id="ee49" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">通过参数类型执行Lambda</h2><p id="8e02" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">关于switch表达式，我最喜欢的一点是，我们甚至可以通过类型进行切换，并在一个简洁的语句中进行赋值:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/01c604ccdf63b3f9497d141454e4f555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVF-HLjBbc5Pm_ufiMuAdA.png"/></div></div></figure><p id="9faa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://timdeschryver.dev/blog/pattern-matching-examples-in-csharp" rel="noopener ugc nofollow" target="_blank"> Tim Deschryver有一组很好的例子来说明C# </a>中的模式匹配是多么有趣。到目前为止，这是C#最好的特性之一！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="2c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这个小实验室能激起你探索C#更多功能的兴趣。许多C#开发人员要么没有意识到这些特性，要么主动回避语言的这些特性🤣。对我来说，这些是一些最有趣的语言特性，switch表达式是任何语言中最通用的表达式之一(至少是我使用的语言！).</p><p id="3a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">lambda表达式和局部函数的一个最好的用途是它可以简化调用，否则你将需要来回传递额外的参数。换句话说，如果您有一个带有参数(A，B，C)的入口函数，它可能会调用一个需要(B，C，<em class="na"> D 【T11，<em class="na"> E </em>)的辅助函数，其中D和E是在入口函数中计算的。使用lambda表达式和局部函数允许您捕获作用域，而不必在函数中有重叠的参数集(有时，那些帮助函数并不真正配得上它们自己的顶级方法！).</em></p><p id="b457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看repo和<strong class="jp ir"> <em class="na">包含了C#和</em> </strong>更多的功能方面。网！</p></div></div>    
</body>
</html>