<html>
<head>
<title>Kubernetes rolling updates, rollbacks and multi-environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes滚动更新、回滚和多环境</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-rolling-updates-rollbacks-and-multi-environments-4ff9912df5?source=collection_archive---------1-----------------------#2019-12-15">https://itnext.io/kubernetes-rolling-updates-rollbacks-and-multi-environments-4ff9912df5?source=collection_archive---------1-----------------------#2019-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e1c14f1b317c595ca7fcdf224e20d439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2f2yMlT14HkVI-GfK7fPw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由来自<a class="ae kc" href="https://www.pexels.com/photo/birds-eye-view-photo-of-freight-containers-2226458/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kc" href="https://www.pexels.com/@tomfisk?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">汤姆·菲斯克</a>拍摄</figcaption></figure><p id="9bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的帖子(<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/deploy-an-app-on-kubernetes-gke-with-kong-ingress-letsencrypt-and-cloudflare-94913e127c2b">https://it next . io/deploy-an-app-on-kubernetes-gke-with-Kong-Ingress-letsencrypt-and-cloudflare-94913 e 127 c2b</a>)中，我们学习了如何将一个具有2个微服务(前端和后端)的应用程序部署到Kubernetes，使用Kong Ingress、LetsEncrypt提供TLS证书，使用cloud flare提供代理和额外的安全性。</p><p id="460f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们希望对我们部署的应用程序进行一些更新，在出现错误时回滚它们，最后但同样重要的是使用多个环境，以便我们可以在部署到生产环境之前测试我们的应用程序。</p><p id="d7a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我将重新部署我的原始应用程序。(我总是删除不用的应用程序，不需要花钱托管它们)</p><p id="f331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">kubectl</code>的一个漂亮的特性是你可以连接所有的资源文件并批量应用它们。这是我的文件:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="e182" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要应用它:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="3d3b" class="lp lq iq le b gy lr ls l lt lu">$ kubectl apply -f outsrc.yml<br/>namespace/outsrc created<br/>ingress.extensions/outsrc-dev-ingress created<br/>service/service-frontend created<br/>deployment.apps/deployment-frontend created<br/>service/service-backend created<br/>deployment.apps/deployment-backend created</span></pre><p id="f4b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几秒钟后(容器运行，TLS证书发出),我们让应用程序重新联机:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/992b23ab2b55da3c3ed9717b564c4980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSS5v0MN-kZVi8BPxMQMvg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">outsrc.dev部署到Kubernetes</figcaption></figure><p id="1e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止一切顺利。现在，我们需要对应用程序进行一些更改。我们将添加一个包含美国地图的地图页面，我们将从主页和州页面链接地图。在添加了该特性的代码并将其归档后:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="ebaa" class="lp lq iq le b gy lr ls l lt lu">$ docker build -t outsrc-demo-front .<br/>...</span><span id="4605" class="lp lq iq le b gy lw ls l lt lu">$ docker tag outsrc-demo-front:latest gcr.io/outsrc/outsrc-demo-front:<strong class="le ir">1.1.0</strong></span><span id="10e8" class="lp lq iq le b gy lw ls l lt lu">$ docker push gcr.io/outsrc/outsrc-demo-front:<strong class="le ir">1.1.0<br/>...</strong></span></pre><p id="a802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意版本是不同的，我们将使用docker图像标签来做滚动更新。</p><h2 id="d139" class="lp lq iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">滚动更新</h2><p id="8092" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">每次我们想要更新部署在kubernetes集群上的应用程序时，我们都会更改部署资源文件并更新它们。每次检测到更改时，将执行滚动更新。</p><p id="233c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免停机，kubernetes将逐个更新我们正在运行的容器的每个副本，并在顶层重新路由服务。</p><p id="a6ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查更新历史记录:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="b250" class="lp lq iq le b gy lr ls l lt lu">$ kubectl rollout history deployment/deployment-frontend<br/>deployment.extensions/deployment-frontend<br/>REVISION  CHANGE-CAUSE<br/>1         &lt;none&gt;</span></pre><p id="0bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更新前端容器图像标签:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="5d3b" class="lp lq iq le b gy lr ls l lt lu">$ kubectl set image deployment/deployment-frontend frontend-container=gcr.io/outsrc/outsrc-demo-front:<strong class="le ir">1.1.0</strong><br/>deployment.extensions/deployment-frontend image updated</span></pre><p id="8753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以修改部署资源文件，更改图像标签并通过<code class="fe lb lc ld le b">kubectl</code>应用它。这是我处理更新的首选方式，因为它保留了资源描述符文件的真实来源。</p><p id="5730" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观看更新:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="0ea1" class="lp lq iq le b gy lr ls l lt lu">$ kubectl rollout status -w deployment/deployment-frontend </span><span id="2037" class="lp lq iq le b gy lw ls l lt lu">Waiting for deployment "deployment-frontend" rollout to finish: 1 out of 2 new replicas have been updated...<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 out of 2 new replicas have been updated...<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 out of 2 new replicas have been updated...<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 old replicas are pending termination...<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 old replicas are pending termination...<br/>deployment "deployment-frontend" successfully rolled out</span></pre><p id="3373" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是部署的首次展示历史:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="1c94" class="lp lq iq le b gy lr ls l lt lu">$ kubectl rollout history deployment/deployment-frontend<br/>deployment.extensions/deployment-frontend<br/>REVISION  CHANGE-CAUSE<br/>1         &lt;none&gt;<br/>2         &lt;none&gt;</span></pre><p id="8a64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应用程序现在有了一个美国地图页面:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/f421989ee44a4ec05d9d22c03b48bd19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fG5G3ZZ_h8cCvS_WWsFFuQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">已部署新地图页面</figcaption></figure><p id="c9f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦不，我们有一个错误！反转..</p><p id="d645" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个用户在我们新部署的应用程序版本上发现了一个bug。我们需要回滚到先前已知的工作版本。</p><p id="4738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们倒回去:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="f40a" class="lp lq iq le b gy lr ls l lt lu">$ kubectl rollout undo deployment/deployment-frontend<br/>deployment.extensions/deployment-frontend rolled back</span><span id="ab45" class="lp lq iq le b gy lw ls l lt lu">$ kubectl rollout status -w deployment/deployment-frontend<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 old replicas are pending termination...<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 old replicas are pending termination...<br/>deployment "deployment-frontend" successfully rolled out</span></pre><p id="97bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的应用程序被恢复到以前的版本。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/2f9a2f9657ccf274d0273b7cf6ec8d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZrf_CzWCquo1xMGfFTVXg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序版本1.0.0</figcaption></figure><p id="451d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意历史记录，修订号仍在上升:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="1727" class="lp lq iq le b gy lr ls l lt lu">$ kubectl rollout history deployment/deployment-frontend<br/>deployment.extensions/deployment-frontend<br/>REVISION  CHANGE-CAUSE<br/>2         &lt;none&gt;<br/>3         &lt;none&gt;</span></pre><p id="4305" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们随时可以回到任何修改。在这种情况下，修订#2是我们的地图修订。让我们把它带回来。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="f504" class="lp lq iq le b gy lr ls l lt lu">$ kubectl rollout undo deployment/deployment-frontend --to-revision=2<br/>deployment.extensions/deployment-frontend rolled back</span><span id="9022" class="lp lq iq le b gy lw ls l lt lu">$ kubectl rollout status -w deployment/deployment-frontend<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 old replicas are pending termination...<br/>Waiting for deployment "deployment-frontend" rollout to finish: 1 old replicas are pending termination...<br/>deployment "deployment-frontend" successfully rolled out</span></pre><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/c59b49486b34322064db4cca4baf0190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ablqsFTm63CMYgzuArCPQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">回到1.1.0版本(带美国地图)</figcaption></figure><p id="b57a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止一切顺利。现在，在一个实时网站上来回寻找功能和缺陷并不是一件好事。如果我们推出一个特性，却发现它有缺陷，然后又退回去，我们的用户会感到沮丧。这是我们拥有不同<strong class="kf ir">部署环境的原因之一。</strong></p><p id="2e1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很常见的是发现这一套环境:</p><p id="4a79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主|暂存|生产</p><ul class=""><li id="d78d" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><strong class="kf ir">主</strong>:或开发，通常是最新版本，匹配回购上的主分支。</li><li id="a677" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><strong class="kf ir">分级</strong>:最接近生产，通常是最后一次QA执行的地方。</li><li id="9649" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><strong class="kf ir">生产</strong>:就是你的用户看到的。</li></ul><p id="1651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种设置下，任何新特性或错误修复都将从主版本进入试运行，然后进入生产版本。</p><p id="1a30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的美国州应用程序之外，让我们再创建一个环境:<strong class="kf ir">开发</strong></p><p id="3e4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们需要选择一个子域，对于我当前的应用程序，我将选择:<code class="fe lb lc ld le b">dev.outsrc.dev</code> (master.outsrc.dev也可以)</p><p id="5cf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先:DNS，让我们创建一个DNS注册表，使我们的子域指向集群代理IP。这是:(记住我们上一篇文章中的DNS是托管在Cloudflare上的)</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/5094dc19abcc6fad8ef94c644ac197e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHmaA6fzgKHi7GnRInmjrg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">dev.outsrc.dev -&gt; CNAME代理</figcaption></figure><p id="2fa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此后，将返回一个<code class="fe lb lc ld le b">dev.outsrc.dev</code>的NSLOOKUP:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="4b85" class="lp lq iq le b gy lr ls l lt lu">$ dig dev.outsrc.dev<br/>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; dev.outsrc.dev<br/>;; global options: +cmd<br/>;; Got answer:<br/>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 38625<br/>;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1</span><span id="c3dc" class="lp lq iq le b gy lw ls l lt lu">;; OPT PSEUDOSECTION:<br/>; EDNS: version: 0, flags:; udp: 4096<br/>;; QUESTION SECTION:<br/>;dev.outsrc.dev.   IN A</span><span id="8bc8" class="lp lq iq le b gy lw ls l lt lu"><br/>;; ANSWER SECTION:<br/>dev.outsrc.dev.  300 IN CNAME proxy.outsrc.dev.<br/>proxy.outsrc.dev. 300 IN A <strong class="le ir">35.209.76.89</strong></span><span id="9ea6" class="lp lq iq le b gy lw ls l lt lu"><br/>;; Query time: 66 msec<br/>;; SERVER: 192.168.1.254#53(192.168.1.254)<br/>;; WHEN: Sun Dec 15 14:48:42 EST 2019<br/>;; MSG SIZE  rcvd: 79</span></pre><p id="f606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">dev.outsrc.dev</code>指向我们的星团。</p><p id="ca9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们在不同的名称空间上创建一组不同的资源文件:<code class="fe lb lc ld le b">outsrc-dev</code></p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="65a7" class="lp lq iq le b gy lr ls l lt lu">$ kubectl apply -f outsrc-dev.yml<br/>namespace/outsrc-dev created<br/>ingress.extensions/dev-outsrc-dev-ingress created<br/>service/service-frontend created<br/>deployment.apps/deployment-frontend created<br/>service/service-backend created<br/>deployment.apps/deployment-backend created</span></pre><p id="7d4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">准备好了，我们现在可以访问<code class="fe lb lc ld le b">http://dev.outsrc.dev</code></p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/6db8b0a6266976189c97c6ca2c271863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Hq44RQeyBjjiQh5VxEhGg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">开发外包服务公司</figcaption></figure><p id="26fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，这是一个子域，我们不希望每个人都能访问它。这仅限于内部开发团队、产品经理和QA团队、设计师、测试工程师等。</p><p id="0b7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要限制谁可以访问这个子域。有几种方法可以实现这一点。一种解决方案是使用孔插件(<a class="ae kc" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank">、</a>)、更具体的IP限制插件(<a class="ae kc" href="https://docs.konghq.com/hub/kong-inc/ip-restriction/" rel="noopener ugc nofollow" target="_blank">、</a>)</p><p id="7f0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你知道我为什么在上一篇文章中使用孔入口了。</p><h2 id="bfc7" class="lp lq iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">用Kong插件限制IP访问</h2><p id="043c" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">首先让我们创建一个插件资源描述符</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="4ebf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先应用它:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="5719" class="lp lq iq le b gy lr ls l lt lu">$ kubectl apply -f ip-restrict.yml<br/>kongplugin.configuration.konghq.com/ip-restriction created</span></pre><p id="0fa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此后，我们可以修改入口资源文件，以表明所有路由都应该受到IP限制:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="24d1" class="lp lq iq le b gy lr ls l lt lu">...<br/>apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: dev-outsrc-dev-ingress<br/>  namespace: outsrc-dev<br/>  annotations:<br/>    kubernetes.io/ingress.class: kong<br/>    kubernetes.io/tls-acme: 'true'<br/>    cert-manager.io/cluster-issuer: letsencrypt-production<br/>    <strong class="le ir">plugins.konghq.com: ip-restriction</strong><br/>spec:<br/>  tls:<br/>    - secretName: dev-outsrc-dev-tls<br/>      hosts:<br/>        - dev.outsrc.dev<br/>  rules:<br/>    - host: dev.outsrc.dev<br/>...</span></pre><p id="9742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并更新它:</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="4900" class="lp lq iq le b gy lr ls l lt lu">$ kubectl apply -f outsrc-dev.yml<br/>namespace/outsrc-dev unchanged<br/>ingress.extensions/dev-outsrc-dev-ingress configured<br/>service/service-frontend unchanged<br/>deployment.apps/deployment-frontend unchanged<br/>service/service-backend unchanged<br/>deployment.apps/deployment-backend unchanged</span></pre><p id="e41e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果您尝试从未列入白名单的IP地址访问，您将会看到:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/3f3ff295e051cbf3ffdd8dcad0846d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg4-1iO4Ll4QyCkDRy3OxQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">拒绝！</figcaption></figure><p id="3710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:这个IP限制插件的一个好处是你可以将IP地址列入白名单，并且只更新插件资源。入口将使用更新的列表。</p><h1 id="958f" class="nn lq iq bd lx no np nq ma nr ns nt md nu nv nw mg nx ny nz mj oa ob oc mm od bi translated">结论</h1><ul class=""><li id="fb36" class="mv mw iq kf b kg mo kk mp ko oe ks of kw og la na nb nc nd bi translated">滚动更新只需要对部署容器进行更改。</li><li id="f6c1" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">回滚实际上非常快。</li><li id="79de" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">我们可以回滚到任何以前部署的版本。(仍然不确定这里的限制是什么)</li><li id="fdf7" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">为了避免在生产环境中来回切换，请使用部署环境。</li><li id="cf40" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">如果部署在同一个集群上，请为不同的环境使用不同的名称空间。</li><li id="c995" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">最好创建两个集群，将生产环境与试运行和开发分开。</li><li id="db9c" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">查一下Kong插件，有些真的很不错或者你可以自己写(准备好学习Lua了？或者给我发短信，我可能会帮你写)</li></ul><p id="5187" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">黑客快乐…</p></div></div>    
</body>
</html>