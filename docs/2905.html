<html>
<head>
<title>Designing a Kotlin memory safe mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计Kotlin内存安全模式</h1>
<blockquote>原文：<a href="https://itnext.io/designing-a-kotlin-memory-safe-mode-c76c06317c3e?source=collection_archive---------2-----------------------#2019-08-26">https://itnext.io/designing-a-kotlin-memory-safe-mode-c76c06317c3e?source=collection_archive---------2-----------------------#2019-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/896e0c30ba33d1b43de921fc309f400a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qGWYc4OCz7CxfWUy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">瑞安·弗兰科拍摄的照片</figcaption></figure><p id="c553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的上一篇文章中，我分享了我对kot Lin/本机内存模型在运行时如何实施的<a class="ae kc" href="https://medium.com/@timelzayus/why-the-kotlin-native-memory-model-cannot-hold-ae1631d80cf6" rel="noopener">挫败感</a>，并提出了语言解决方案的开端，在类型系统中使用<strong class="kf ir"> const </strong>。</p><p id="16d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设计一门语言，即使在理论上，也是一个非常有趣的挑战，所以让我们戴上我们的假语言设计师的帽子，看看我们如何为Kotlin/Native memory模型提供一个解决方案。</p><p id="b290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">警告:这是一篇长文，描述了一个不存在的语言特性！不过，我希望如此。这篇文章描述了这个提议背后的原因。</em></p><p id="bef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将与rust语言做一些比较，特别是Rust如何处理<a class="ae kc" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="noopener ugc nofollow" target="_blank">所有权</a>、<a class="ae kc" href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html" rel="noopener ugc nofollow" target="_blank">生存期</a>和<a class="ae kc" href="https://doc.rust-lang.org/book/ch16-00-concurrency.html" rel="noopener ugc nofollow" target="_blank">并发性</a>。您不必阅读这些链接来理解本文，但是如果您想更深入地了解这些概念，我强烈建议您这样做。Rust是一种令人惊叹的语言，拥有令人惊叹的文档。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="e3d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要扩展一种现有的语言时，我们首先必须理解管理这种语言的规则框架。</p><p id="c34f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust有一个非常严格的规则框架:如果没有明确允许，那么就是禁止。默认情况下，对象是不可变的，除非被指定为可变的，除非明确处理所有权，否则不能传递指针，不能有多个可变引用，等等。</p><p id="dca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，Java有一个非常“宽松”的规则框架。如果没有明确禁止，那么它就是允许的。一切都是可变的，每个类都可以扩展，除非显式地是final，泛型参数是可选的，等等。</p><p id="5fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin介于两者之间:它的设计者一直说它首先是实用主义的，这导致了一些看起来矛盾的决定:</p><ul class=""><li id="f961" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">默认情况下，类是最终的，但重写只有在显式的情况下才是最终的。</li><li id="387a" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">对象是可变的，但是集合接口首先是不可变的，然后才是可变的(可变列表扩展列表)。</li><li id="4805" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">可空性必须显式处理，但所有异常都是隐式的。</li></ul><p id="2e19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我认为，在考虑扩展Kotlin语言时，我们必须记住以下“实用”的规则框架:</p><ul class=""><li id="5f25" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">约束不能“妨碍”程序员。如果约束被“变通”的次数多于它被使用的次数，那么它就不应该被强制执行。</li><li id="3a57" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">代码必须简洁明了，这意味着默认行为应该是更频繁的行为，但是行为的任何变化都必须明确定义并且可读。</li></ul><p id="2fc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个规则是Kotlin执行它最臭名昭著的规则的原因:“默认情况下，一切都是公开的”。</p><p id="eadd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当然:</p><ul class=""><li id="4ccf" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">语言的新增加必须是向后兼容的，不能突然改变现有Kotlin代码的语义。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="c816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开始吧。</p><p id="af23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，从著名的kot Lin/本机内存模型规则“数据要么是可变的，要么是共享的”，我们可以推断出描述完全相同概念的完全相反的规则:“数据要么是线程本地的，要么是不可变的”。</p><p id="b5d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin/Native提出了一个冻结API，它使得一个对象(及其所有子图)不可变。我在以前的文章中已经指出，我认为在运行时实施不变性是一个非常糟糕的想法。那么我们来介绍一下Kotlin中的<em class="lb"> const </em>关键字。</p><p id="2ff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C++对此有一个有趣的方法:类型注释。在科特林，它看起来像这样:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7ba6" class="mg mh iq mc b gy mi mj l mk ml">fun description(foo: <strong class="mc ir">const</strong> Foo): String {}</span></pre><p id="f10a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">描述</em>函数声明它不会改变foo对象，只会从中读取值。为了加强这一点，编译器将只允许函数访问<em class="lb">常量值获取器</em>和<em class="lb">常量函数</em>，在Kotlin中类似于:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3edb" class="mg mh iq mc b gy mi mj l mk ml">class Foo {<br/>    <strong class="mc ir">const</strong> val answer = 42<br/>    <strong class="mc ir">const</strong> fun getName(): String = <em class="lb">TODO</em>()<br/>}</span></pre><p id="4e03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，<em class="lb"> getName </em>方法本质上是纯的，编译器将确保它不会使对象变异(没有副作用)。</p><p id="e07b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种const类型注释在Kotlin中是一个非常糟糕的想法，原因有很多:</p><ul class=""><li id="048c" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">这将意味着检查整个标准库代码库，将<em class="lb"> const </em>关键字添加到每个纯函数，如<em class="lb"> map </em>、<em class="lb"> filter </em>等。</li><li id="49a8" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">到处都会有<em class="lb">常数</em>。绝大多数函数和方法不会改变数据。果然，C++中的const关键字无处不在，削弱了可读性。</li></ul><p id="2e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么为什么不相反呢？假设一切都是不可变的，除非明确定义为可变的。Rust用<em class="lb"> mut </em>关键字来做这件事。不幸的是，虽然这对喜欢约束的程序员(我很自豪地加入了这个团体)来说很有吸引力，但我们不会改变整个现有Kotlin代码库的语义。这将要求每个人仔细检查所有被创建的Kotlin代码，以便在任何需要的地方添加<em class="lb"> mut </em>关键字。</p><p id="06b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不会发生的。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="44ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，这是可能发生的事情:一个<em class="lb">常量类注释</em>。大概是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="71cb" class="mg mh iq mc b gy mi mj l mk ml"><strong class="mc ir">const</strong> class User(val firstName: String, val lastName: String) {<br/>    fun fullName() = "$firstName $lastName"<br/>}</span></pre><ul class=""><li id="d55a" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">在编译时，编译器确保<em class="lb"> const </em>类不包含<em class="lb"> var </em>属性，只包含原语或<em class="lb"> const </em>值。</li><li id="f057" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">在运行时，在Kotlin/Native中，默认情况下，所有const类的具体化及其子树都是冻结的。</li></ul><p id="800e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这消除了对冻结API的需要。对象要么是常量，要么是冻结的，要么不是。有些人会认为这消除了创建和配置一个对象并在以后冻结它的可能性。我相信这是一个巨大的代码味道(你无法知道对象何时被冻结，并且禁止改变它)，并且会将你重定向到<em class="lb">构建器模式</em>。还有:大多数垃圾收集者已经成为处理短命对象的专家。</p><p id="5933" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，我知道这仍然需要一些标准库的改变:标准类如<em class="lb">字符串</em>需要用<em class="lb">常量</em>进行注释。</p><p id="9173" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个问题是关于多态性。我们能扩展常量类吗？是否允许<em class="lb">常量接口</em>？如果是，那么它们的所有实现都需要是<em class="lb"> const </em>吗？<br/>这些是非常相关的问题，但与本文的范围无关。本演示不需要回答这些问题。<br/>还有，我不知道；)</p><p id="1bd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">附带好处:<em class="lb"> const数据类</em>可以在初始化时生成并缓存它们的<em class="lb"> toString() </em>和<em class="lb"> hashCode() </em>值，这将极大地提高使用数据类作为映射键的性能。我的上一个基准测试表明，缓存哈希代码将地图查找速度提高了3倍。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="1c9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回到我们最初的规则:“数据要么是线程本地的，要么是不可变的”。这意味着编译器不应该允许非常数的全局值。这是现有Kotlin代码失效的部分。<br/>希望Kotlin/Native还处于早期阶段，所以我相信引入一个编译器<em class="lb">安全模式</em>是可以接受的，在使用Kotlin/JVM或Kotlin/JS时可以启用也可以不启用，但在任何包含Kotlin/Native目标的多平台项目中都会强制启用。</p><p id="e6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种“安全模式”将简单地<strong class="kf ir">禁止可变共享全局状态</strong>(但是允许线程本地根变量):</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="dd63" class="mg mh iq mc b gy mi mj l mk ml">class Foo { <em class="lb">/*...*/ </em>}<br/>const class Bar { <em class="lb">/*...*/ </em>}<br/><br/>val <em class="lb">foo </em>= Foo() <em class="lb">// </em><strong class="mc ir"><em class="lb">Forbidden</em></strong><em class="lb">, Foo is not const<br/></em>var <em class="lb">bar </em>= Bar() <em class="lb">// </em><strong class="mc ir"><em class="lb">Forbidden</em></strong><em class="lb">, var are not allowed<br/><br/></em>val <em class="lb">global </em>= Bar() <em class="lb">// </em><strong class="mc ir"><em class="lb">Allowed</em></strong><em class="lb"><br/></em><br/>@ThreadLocal<br/>var local = Foo() // <strong class="mc ir"><em class="lb">Allowed</em></strong><em class="lb"> (because thread-local)<br/></em><br/>fun main() { <em class="lb">TODO</em>() }</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><blockquote class="mm mn mo"><p id="740d" class="kd ke lb kf b kg kh ki kj kk kl km kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">“不要靠分享记忆来交流，要靠交流来分享记忆”。<br/>—Go语言设计者。</p></blockquote><p id="ba5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这已经成为许多现代编程语言和程序员的目标。在某些情况下，线程需要在它们之间传递信息，可以通过改变共享数据(这是不好的，这是全部要点)或者通过从一个线程向另一个线程发送数据来实现。</p><p id="8f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust有<em class="lb">所有权</em> &amp; <em class="lb">生存期</em>的概念，它确保只有一个变量拥有它所包含的数据，并且当它失去对其值的所有权时，变量的生存期就结束了。这使得在线程之间传递可变对象变得可能和安全。这些观念在科特林语中是说不出来的，太晚了。</p><p id="5995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们已经引入了常量类的概念。Const classes对象是直接冻结的，所以它们可以在线程之间共享。对于处理线程消息传递的函数来说，我们需要的只是声明它只接受常数值参数的方法。<br/>泛型可以帮助我们:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="23c3" class="mg mh iq mc b gy mi mj l mk ml"><strong class="mc ir">const</strong> class ConstChannel&lt;T : <strong class="mc ir">const</strong> Any&gt; { <em class="lb">/*...*/ </em>}<br/><br/>fun &lt;<strong class="mc ir">const</strong> T : Any&gt; newConstChannel(): ConstChannel&lt;T&gt; = <em class="lb">TODO</em>()</span></pre><p id="e35f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">常量通道</em>是一个<em class="lb">常量类</em>，所以它可以安全地在线程间共享。它允许发送和接收类型为<em class="lb"> T </em>的数据，这些数据本身必须为<em class="lb"> const </em>。<br/>如何使<em class="lb"> ConstChannel </em>成为<em class="lb"> const类</em>，同时处理线程间消息传递内部机制(这肯定需要可变性)？继续读！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="6ef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Kotlin中，lambda函数可以捕获外部范围的值和变量。本质上，它们实际上是闭包，不应该被称为lambdas。</p><p id="d72f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们正在使用<em class="lb">执行器模式</em>(或者Kotlin/Native worker API)并且想要调度一个lambda在执行器上运行，该怎么办？代码很有可能在另一个线程上执行，这意味着这个lambda一定不能捕获非常数值。</p><p id="7eed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何声明executor类:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="60cf" class="mg mh iq mc b gy mi mj l mk ml"><strong class="mc ir">const</strong> class ConstExecutor {<br/>    fun schedule(block: <strong class="mc ir">const</strong> () -&gt; Unit) = TODO()<br/>}</span></pre><p id="7896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">块是一个<em class="lb">常量λ</em>，这意味着它只能捕获常量值。下面的例子说明了它的用法:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4b87" class="mg mh iq mc b gy mi mj l mk ml"><strong class="mc ir">const</strong> data class GameState(val level: Int)<br/><br/>val <em class="lb">executor </em>= ConstExecutor()<br/><br/>fun save(level: Int) {<br/>    val state = GameState(level)<br/>    <em class="lb">executor</em>.schedule <strong class="mc ir">{ </strong>writeToFile(state) <strong class="mc ir">}<br/></strong>}</span></pre><p id="b725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为state的类型是<em class="lb"> GameState </em>，并且因为<em class="lb"> GameState </em>是<em class="lb"> const类</em>，所以lambda可以捕获它。<br/>相比之下，这段代码将<strong class="kf ir">不会</strong>编译:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ec29" class="mg mh iq mc b gy mi mj l mk ml">fun save(level: Int) {<br/>    var saveLevel = level<br/>    if (level &gt; 10)<br/>        saveLevel -= 1 <em class="lb">// Games become hard and frustrating!<br/>    executor</em>.schedule <strong class="mc ir">{<br/>        </strong>writeToFile(GameState(saveLevel))<br/>        <em class="lb">//                    ^^^^^^^^^<br/>        // Cannot capture a mutable value!<br/>    </em><strong class="mc ir">}<br/></strong>}</span></pre><p id="d22b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何使<em class="lb"> ConstExecutor </em>成为<em class="lb"> const类</em>，并且处理线程间调度内部(这肯定需要可变性)？继续读！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="a998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个搞砸的方法。或者更具体地说，我们需要一种绕过这些限制的方法。类似于！！运算符，我们可以对编译器说“你不能保证这个值为空，但是我可以，相信我；如果我错了，我接受运行时崩溃的可能性”。</p><p id="3453" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin/Native已经用<em class="lb"> Atomic* </em>类做到了这一点，这些类允许在冻结时进行变异。</p><p id="cda4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经定义了一个<em class="lb"> const lambda </em>的可能性，它只能捕获常数值，但是没有什么可以阻止这样的lambda返回非常数值。考虑以下定义:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2c7b" class="mg mh iq mc b gy mi mj l mk ml"><strong class="mc ir">const</strong> class Attachable&lt;T&gt;(creator: <strong class="mc ir">const</strong> () -&gt; T) {<br/>    fun &lt;R : <strong class="mc ir">const</strong> Any?&gt; attach(block: <strong class="mc ir">const</strong> (T) -&gt; R): R<br/>}</span></pre><p id="7127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们来分析一下。</p><ul class=""><li id="7ef5" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated"><em class="lb">可附加的</em>是一个<em class="lb">常量类</em>，所以它可以在线程间共享。</li><li id="c465" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated"><em class="lb">创建者</em>构造函数参数是一个<em class="lb">常量lambda，</em>，它确保返回一个捕获的常量值(共享安全)或者一个没有其他引用的新的可变数据(因为lambda不能捕获可变数据)，这些数据可以在线程之间安全地分离/重新附加。</li><li id="edc4" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">attach函数执行<em class="lb">块const lambda </em>，在lambda执行期间将可变数据附加到当前线程。<br/>因为它是一个带有<em class="lb">常量返回</em>的<em class="lb">常量λ</em>，所以它不能在λ之外转义或“泄漏”引用。</li><li id="e449" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">如果多个线程同时连接，那么在Kotlin/native中运行时会<strong class="kf ir">崩溃，而在Kotlin/JVM中不会</strong>(但是可能会出现竞争情况)。</li></ul><p id="f0f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，为什么为什么？为什么要为设计一个漂亮的安全系统而头疼，只为提供棒球棒来摧毁它？我们希望确保在运行时没有崩溃，我们希望确保无论目标是什么都有相似的语义，我们在3行代码中摧毁了这两个梦。</p><p id="79b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经把所有我们想避免的放在一个类中。本质上，我们已经将<strong class="kf ir">的不安全性</strong>限制在<em class="lb">的可附加性</em>中。这就引出了下面一点:<em class="lb">如果你是应用程序开发人员，就不要使用Attachable</em>。<em class="lb">可附加的</em>类只为库开发者存在，为应用开发者提供更高级别的&amp;更安全的工具，如<em class="lb">const channel</em>&amp;<em class="lb">const executor</em>。</p><p id="aaf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust与<a class="ae kc" href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html" rel="noopener ugc nofollow" target="_blank">同步&amp;发送特征</a>完全相同。只有当你设计一个更高级的工具来正确处理安全问题时，才使用它。请记住，当使用它时，你是在不安全的领土，这里是龙。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="0ea5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个<em class="lb">可附加的</em>类，创建一个在Kotlin/JVM中使用<em class="lb"> ReentrantLock </em>和在Kotlin/Native中使用<em class="lb"> pthread_mutex </em>的多平台互斥体就变得很简单，这导致了死锁的可能性。</p><p id="6c76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">互斥并不是一件坏事，它们通常比线程间的消息传递要快得多，并且是低层次、高性能的东西所需要的，例如，Kotlin/Native embedded开发者可能需要编写的东西。大多数死锁都很容易调试。只需在调试器中暂停应用程序，并查看哪些线程正在等待哪些互斥体。另一方面，竞争条件很难发现和正确调试，因为当它们发生时你不能暂停。你不能可靠地检测它们。这就是为什么我对一个允许死锁的编程规则框架完全满意，但却不可能有竞争条件。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="bfce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我真诚地希望Kotlin语言&amp; kot Lin/Native编译器能够发展成一个更安全、更好的规则框架，它能够:</p><ul class=""><li id="2bb4" class="lj lk iq kf b kg kh kk kl ko ll ks lm kw ln la lo lp lq lr bi translated">鼓励安全模式和实践。</li><li id="29b7" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">在编译时强制约束。</li><li id="8013" class="lj lk iq kf b kg ls kk lt ko lu ks lv kw lw la lo lp lq lr bi translated">如果需要，允许不安全的代码。</li></ul><p id="17e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些<em class="lb"> const </em>的东西不会进入Kotlin语言(我既不在Jetbrains工作，也不在Kotlin编译器上工作)，但我真的希望这可以成为“修复”当前情况的一个例子。<br/>科特林多平台&amp;科特林/本土故事都可以改进，我们作为一个社区，可能会成为引发讨论、发起运动、找到解决方案的火花。</p></div></div>    
</body>
</html>