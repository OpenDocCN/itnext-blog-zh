# C++20 —实用协同程序

> 原文：<https://itnext.io/c-20-practical-coroutines-79202872ebba?source=collection_archive---------2----------------------->

在 C++20 中，编写定制的协程不是一项简单的任务。在本文中，我将通过三个越来越复杂的协程示例来指导您。

虽然本文将详细解释每个例子，但我不会深入研究协程的基础知识。为此，请阅读我的 [C++20 协程](/c-20-coroutines-complete-guide-7c3fc08db89d)文章。所有的例子都来自我的[协程 Epoll 和套接字库](https://github.com/HappyCerberus/ces)。

![](img/875511ea307af70fbc6ec076e180fe8f.png)

# 同步协同程序

最简单的协程是行为像普通函数的协程。因此，当然，实现这样一个协程似乎是没有意义的。但是请记住，我们不能在协程之外使用像`co_await`这样的协程关键字。所以为了方便起见，我们可以为异步 main 编写一个特殊的协程类型。

与完全同步的协程的主要区别是我们在`final_suspend()`中返回`std::suspend_always`(第 8 行)。如果没有这个，promise 将在协程结束运行时被破坏。但是，我们用承诺来存储结果。我们在`return_value`(第 10 行)中设置它，在`co_return`上调用它，然后在到`int`操作符的转换中读取它(第 23 行)。

我们还需要写一个析构函数，因为协程现在必须被显式销毁(第 20 行)。

然后我们可以用这个协程来代替`main`,如下所示:

在我们的`async_main`中，我们现在可以在其他协程上`co_await`了。

# 可链接的协程

协程的一个引人注目的特性是对称传输的能力。使用同步代码，我们很少需要关心栈空间的耗尽。然而，在异步代码中，只执行一小块代码，然后将控制权交给程序的另一部分是很常见的。避免堆栈空间问题需要精心设计。有了协程，我们可以完全依靠编译器生成的代码来避免这个问题。

我们将在下一节讨论`chainable_task`，不过，让我们先来看看这里发生了什么。我们根据`async_op()`的结果调用`co_await`。这就需要结果类型`chainable_task`提供所需的`await_ready()`、`await_suspend()`和`await_resume()`接口。用`await_resume()`提供结果值。

从调用者的角度来看，这就像同步调用一样。调用结束后，调用方被挂起，只在结束时继续读取结果值。然而，在后台，我们改为链接协程而不嵌套它们。

让我们来看看后台发生了什么:

让我们把重点放在关键部分。首先，第 43–48 行上的可编辑界面相对简单:

*   我们希望调用者暂停，所以我们在`await_ready()`中返回`false`
*   在`await_suspend()`中，我们记住调用者的句柄(调用者在最后一个例子中是`demo()`)并返回我们的句柄，这将恢复这个协程(在最后一个例子中是`async_op()`)
*   在`await_resume()`中，我们返回存储的结果

其次，承诺类型(第 16-19 行)本身就是我们设定任务主要行为的地方:

*   我们在`initial_suspend()`中暂停，将控制(和`chainable_task`的一个实例)返回给调用者，调用者然后调用前面讨论的`co_await`
*   在`final_suspend()`中，我们希望将控制权交还给调用者，所以我们返回一个特殊的可调用对象，该对象返回(第 5 行)我们存储在第 45 行`await_suspend()`中的句柄
*   最后，第 19 行上的`return_value()`方法存储结果，然后在第 48 行上的`await_resume()`中读取结果

所有这些加在一起是为了链接执行，而不是嵌套执行。这是一个很大的挑战，所以如果你还在挣扎，我建议你获取库代码，并在构造函数和析构函数中添加调试打印。它将允许您在更改代码时观察行为的变化。

# 分离的任务

到目前为止，我们只讨论了线性执行模型。我的意思是，我们编写的代码仍然表现得像完全同步的代码。当我们写`co_await some_coro()`时，下面一行将只在`some_coro()`结束运行时执行。

想象这样的代码:

如果我们从未在 server1 上收到连接，该代码将阻止 server2 接受连接，即使我们有很多连接。当然，我们可以在单独的线程上产生这些，但是我们可以避免这种情况，仍然可以用协程在一个线程上运行所有的东西。

从概念上讲，我们希望在外部事件(连接到达、要读取的数据、定时器到期等)发生时阻止协程。)处于挂起状态，并且只有当我们确定它们有工作要做时才恢复它们。

为了实现这一点，我们需要引入一个全局组件，一个协程调度器。我们希望调度程序成为一个生成器风格的协程，它保持循环，并将控制权让给可以运行的协程:

发射器是事件的外部来源(连接到达、套接字准备写入、条件评估为真、超时过期等)。).然后，调度程序将接收到的事件映射到被它阻塞的相应协程，并恢复它:

在 CES 库中，被事件阻塞的协程句柄是发出事件的一部分。因此，我们只需使用一种特殊的可唤醒类型切换到协程。

我们现在有一种方法来恢复暂停的协程。然而，我们仍然需要另一方面，这是一种挂起协程并在调度程序中注册它的方法:

这种适当的类型存储阻塞协程的事件的延续和信息。在`await_ready`中，当协程`co_awaits`条件已经成立时，我们也处理提前返回的情况。第 14 行的`notify_emitters`调用是上一个例子中`notify_departure`调用的反向调用。发出通知的发射器将注册要被观看的事件，离开将取消注册该事件以减轻 fantom 事件。

难题的最后一部分是调用协程来产生多个分离的协程的方法。除此之外，我们还需要一种方法将事件发射器添加到调度程序中。

有了这个接口，多个协程可以排队，然后调度程序通过调用`run`恢复。

# 链接和技术说明

所有的代码例子要么直接取自一个简化的来自 [CES: Coroutines，Epoll 和 Sockets 库](https://github.com/HappyCerberus/ces)。这个库使用 GCC 12 的主干版本进行了测试和运行。

# 感谢您的阅读

感谢您阅读这篇文章。你喜欢吗？

我也在 YouTube 上发布视频。你有问题吗？在[推特](https://twitter.com/SimonToth83)或 [LinkedIn](https://www.linkedin.com/in/simontoth) 上联系我。