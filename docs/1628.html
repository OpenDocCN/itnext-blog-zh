<html>
<head>
<title>React optimization tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React优化技巧</h1>
<blockquote>原文：<a href="https://itnext.io/react-optimization-tips-224c66b4b30d?source=collection_archive---------2-----------------------#2018-12-15">https://itnext.io/react-optimization-tips-224c66b4b30d?source=collection_archive---------2-----------------------#2018-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8cf9e93c184563fc9b7e4963f0d60faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1e304N-Ng-IF4ws6byMbMA.png"/></div></div></figure><div class=""/><p id="d925" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React中，当组件的状态或道具改变时，它会重新渲染。虽然state表示内部数据，props表示外部数据是有意义的，但情况并非总是如此。有一些技术可以防止组件不必要的渲染。让我们看一下例子。</p><h1 id="1f01" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">总是重新渲染</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="33ba" class="md kx jb lz b gy me mf l mg mh">let count = 0;</span><span id="eb61" class="md kx jb lz b gy mi mf l mg mh">class Button extends React.Component {<br/>  render = () =&gt; {<br/>    const { color } = this.props<br/>    count++;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;span&gt; Render count: { count } &lt;/span&gt;<br/>        &lt;button style={{ color }}&gt; text &lt;/button&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>  }<br/>}</span><span id="bd64" class="md kx jb lz b gy mi mf l mg mh">class App extends React.Component {<br/>  state = {<br/>    color: 'red'<br/>  }</span><span id="bcf7" class="md kx jb lz b gy mi mf l mg mh">  showRedButton = () =&gt; {<br/>    this.setState({<br/>      color: 'red'<br/>    })<br/>  }</span><span id="af38" class="md kx jb lz b gy mi mf l mg mh">  showGreenButton = () =&gt; {<br/>    this.setState({<br/>      color: 'green'<br/>    })<br/>  }</span><span id="a8c2" class="md kx jb lz b gy mi mf l mg mh">  render() {<br/>    const { color } = this.state;<br/>    const { showRedButton, showGreenButton } = this;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;Button color={color}/&gt;<br/>        &lt;button onClick={showRedButton}&gt; red &lt;/button&gt;<br/>        &lt;button onClick={showGreenButton}&gt; green &lt;/button&gt;<br/>     &lt;/React.Fragment&gt;)<br/>  }<br/>}</span><span id="cff2" class="md kx jb lz b gy mi mf l mg mh">ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))</span></pre><p id="995e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://codepen.io/n0rush/pen/MZwwZr" rel="noopener ugc nofollow" target="_blank">在线代码示例</a></p><p id="4ade" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次我们点击按钮(或者是<code class="fe mk ml mm lz b">red</code>或者是<code class="fe mk ml mm lz b">green</code>),<code class="fe mk ml mm lz b">count</code>增加，表明<code class="fe mk ml mm lz b">Button</code>组件正在重新渲染。然而，<code class="fe mk ml mm lz b">Button</code>唯一依赖的道具就是<code class="fe mk ml mm lz b">color</code>。如果<code class="fe mk ml mm lz b">color</code>保持不变，渲染是不必要的。</p><p id="e0a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目标:如果我们一直按下<code class="fe mk ml mm lz b">red</code>按钮，我们希望<code class="fe mk ml mm lz b">count</code>保持不变，因为我们不想重新渲染<code class="fe mk ml mm lz b">Button</code>组件，因为<code class="fe mk ml mm lz b">color</code>保持不变。</p><h1 id="f1ca" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">技巧1:shouldcomponentdupdate</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c09e" class="md kx jb lz b gy me mf l mg mh">let count = 0;</span><span id="34d6" class="md kx jb lz b gy mi mf l mg mh">class Button extends React.Component {<br/>  shouldComponentUpdate(nextProps) {<br/>    if(this.props.color === nextProps.color) {<br/>      return false;<br/>    }<br/>    return true<br/>  }</span><span id="d91e" class="md kx jb lz b gy mi mf l mg mh">  render = () =&gt; {<br/>    const { color } = this.props<br/>    count++;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;span&gt; Render count: { count } &lt;/span&gt;<br/>        &lt;button style={{ color }}&gt; text &lt;/button&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>  }<br/>}</span><span id="a85f" class="md kx jb lz b gy mi mf l mg mh">class App extends React.Component {<br/>  state = {<br/>    color: 'red'<br/>  }</span><span id="013f" class="md kx jb lz b gy mi mf l mg mh">  showRedButton = () =&gt; {<br/>    this.setState({<br/>      color: 'red'<br/>    })<br/>  }</span><span id="5e61" class="md kx jb lz b gy mi mf l mg mh">  showGreenButton = () =&gt; {<br/>    this.setState({<br/>      color: 'green'<br/>    })<br/>  }</span><span id="a3d2" class="md kx jb lz b gy mi mf l mg mh">  render() {<br/>    const { color } = this.state;<br/>    const { showRedButton, showGreenButton } = this;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;Button color={color}/&gt;<br/>        &lt;button onClick={showRedButton}&gt; red &lt;/button&gt;<br/>        &lt;button onClick={showGreenButton}&gt; green &lt;/button&gt;<br/>     &lt;/React.Fragment&gt;)<br/>  }<br/>}</span><span id="9a44" class="md kx jb lz b gy mi mf l mg mh">ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))</span></pre><p id="8f1a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://codepen.io/n0rush/pen/KbpdGr" rel="noopener ugc nofollow" target="_blank"> ShouldComponentUpdate代码示例</a></p><h1 id="775d" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">技巧二:反应。纯组件</h1><h1 id="d177" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">它是如何工作的</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6598" class="md kx jb lz b gy me mf l mg mh">let count = 0;</span><span id="fd43" class="md kx jb lz b gy mi mf l mg mh">class Button extends React.PureComponent {<br/>  render = () =&gt; {<br/>    const { color } = this.props<br/>    count++;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;span&gt; Render count: { count } &lt;/span&gt;<br/>        &lt;button style={{ color }}&gt; text &lt;/button&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>  }<br/>}</span><span id="fbdd" class="md kx jb lz b gy mi mf l mg mh">class App extends React.Component {<br/>  state = {<br/>    color: 'red'<br/>  }</span><span id="9dc6" class="md kx jb lz b gy mi mf l mg mh">  showRedButton = () =&gt; {<br/>    this.setState({<br/>      color: 'red'<br/>    })<br/>  }</span><span id="730b" class="md kx jb lz b gy mi mf l mg mh">  showGreenButton = () =&gt; {<br/>    this.setState({<br/>      color: 'green'<br/>    })<br/>  }</span><span id="b716" class="md kx jb lz b gy mi mf l mg mh">  render() {<br/>    const { color } = this.state;<br/>    const { showRedButton, showGreenButton } = this;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;Button color={color}/&gt;<br/>        &lt;button onClick={showRedButton}&gt; red &lt;/button&gt;<br/>        &lt;button onClick={showGreenButton}&gt; green &lt;/button&gt;<br/>     &lt;/React.Fragment&gt;)<br/>  }<br/>}</span><span id="56c3" class="md kx jb lz b gy mi mf l mg mh">ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))</span></pre><p id="af2c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://codepen.io/n0rush/pen/JwdYVG" rel="noopener ugc nofollow" target="_blank"> PureComponent代码示例</a></p><h1 id="73cb" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">银弹？</h1><p id="0129" class="pw-post-body-paragraph jy jz jb ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated"><code class="fe mk ml mm lz b">PureComponent</code>基本上是内置<code class="fe mk ml mm lz b">shouldComponentUpdate</code>挂钩的<code class="fe mk ml mm lz b">Component</code>。似乎我们应该在任何情况下使用<code class="fe mk ml mm lz b">PureCompnent</code>,因为它有本地渲染优化？不完全是。<code class="fe mk ml mm lz b">PureComponent</code>正在使用浅相等进行道具和状态比较。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="995c" class="md kx jb lz b gy me mf l mg mh">class TodoList extends React.PureComponent {<br/>  render() {<br/>    const { todos } = this.props;<br/>    return (&lt;ul&gt;<br/>      {<br/>        todos.map((it, index) =&gt; &lt;li key={index}&gt; {it} &lt;/li&gt;)<br/>      }<br/>    &lt;/ul&gt;)<br/>  }<br/>}</span><span id="1ae7" class="md kx jb lz b gy mi mf l mg mh">class App extends React.Component {<br/>  inputRef = React.createRef()</span><span id="c4e5" class="md kx jb lz b gy mi mf l mg mh">  state = {<br/>    todos: []<br/>  }</span><span id="24a5" class="md kx jb lz b gy mi mf l mg mh">  onAdd = () =&gt; {<br/>    let { todos } = this.state;<br/>    const text = this.inputRef.current.value;<br/>    todos.push(text);<br/>    this.setState({<br/>      todos<br/>    });<br/>  }</span><span id="6e0b" class="md kx jb lz b gy mi mf l mg mh">  render() {<br/>    const { todos } = this.state;<br/>    const { onAdd, inputRef } = this<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;input ref={inputRef} type='text' placeholder='enter todo'/&gt;<br/>        &lt;button onClick={onAdd}&gt; add todo &lt;/button&gt;<br/>        &lt;TodoList todos={todos}/&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>  }<br/>}</span><span id="8c53" class="md kx jb lz b gy mi mf l mg mh">ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))</span></pre><p id="5566" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://codepen.io/n0rush/pen/wRKKZp" rel="noopener ugc nofollow" target="_blank">抗纯组分</a></p><p id="903c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，<code class="fe mk ml mm lz b">TodoList</code>永远不会重新渲染，因为<code class="fe mk ml mm lz b">todos</code>(这是来自<code class="fe mk ml mm lz b">App</code>的状态，并作为道具传递给<code class="fe mk ml mm lz b">TodoList</code>)总是具有相同的引用。</p><h1 id="74c2" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何让它发挥作用？</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7494" class="md kx jb lz b gy me mf l mg mh">class TodoList extends React.PureComponent {<br/>  render() {<br/>    const { todos } = this.props;<br/>    return (&lt;ul&gt;<br/>      {<br/>        todos.map((it, index) =&gt; &lt;li key={index}&gt; {it} &lt;/li&gt;)<br/>      }<br/>    &lt;/ul&gt;)<br/>  }<br/>}</span><span id="0ac1" class="md kx jb lz b gy mi mf l mg mh">class App extends React.Component {<br/>  inputRef = React.createRef()</span><span id="66e2" class="md kx jb lz b gy mi mf l mg mh">  state = {<br/>    todos: []<br/>  }</span><span id="888c" class="md kx jb lz b gy mi mf l mg mh">  onAdd = () =&gt; {<br/>    let { todos } = this.state;<br/>    const text = this.inputRef.current.value;<br/>    this.setState({<br/>      todos: [...todos, text]<br/>    });<br/>  }</span><span id="b8d7" class="md kx jb lz b gy mi mf l mg mh">  render() {<br/>    const { todos } = this.state;<br/>    const { onAdd, inputRef } = this<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;input ref={inputRef} type='text' placeholder='enter todo'/&gt;<br/>        &lt;button onClick={onAdd}&gt; add todo &lt;/button&gt;<br/>        &lt;TodoList todos={todos}/&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>  }<br/>}</span><span id="91f4" class="md kx jb lz b gy mi mf l mg mh">ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))</span></pre><p id="10bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae mj" href="https://codepen.io/n0rush/pen/wRKMMj" rel="noopener ugc nofollow" target="_blank">纯组件参考</a></p><p id="5f86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它现在的工作原理是，我们现在每次调用<code class="fe mk ml mm lz b">setState</code>时都创建一个新的<code class="fe mk ml mm lz b">todos</code>数组</p><h1 id="a4ee" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">React.memo —用于功能组件</h1><h1 id="b324" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">它是如何工作的</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="917f" class="md kx jb lz b gy me mf l mg mh">let count = 0;</span><span id="c8f5" class="md kx jb lz b gy mi mf l mg mh">const Button = React.memo(function(props) {<br/>  const { color } = props<br/>  count++;<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>       &lt;span&gt; Render count: { count } &lt;/span&gt;<br/>       &lt;button style={{ color }}&gt; text &lt;/button&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>})</span><span id="ccf5" class="md kx jb lz b gy mi mf l mg mh">class App extends React.Component {<br/>  state = {<br/>    color: 'red'<br/>  }</span><span id="97f8" class="md kx jb lz b gy mi mf l mg mh">  showRedButton = () =&gt; {<br/>    this.setState({<br/>      color: 'red'<br/>    })<br/>  }</span><span id="c87b" class="md kx jb lz b gy mi mf l mg mh">  showGreenButton = () =&gt; {<br/>    this.setState({<br/>      color: 'green'<br/>    })<br/>  }</span><span id="41e0" class="md kx jb lz b gy mi mf l mg mh">  render() {<br/>    const { color } = this.state;<br/>    const { showRedButton, showGreenButton } = this;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;Button color={color}/&gt;<br/>        &lt;button onClick={showRedButton}&gt; red &lt;/button&gt;<br/>        &lt;button onClick={showGreenButton}&gt; green &lt;/button&gt;<br/>     &lt;/React.Fragment&gt;)<br/>  }<br/>}</span><span id="8a8c" class="md kx jb lz b gy mi mf l mg mh">ReactDOM.render(&lt;App/&gt;, document.getElementById('root'))</span></pre><h1 id="ec88" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">通知；注意</h1><ul class=""><li id="9232" class="ms mt jb ka b kb mn kf mo kj mu kn mv kr mw kv mx my mz na bi translated">如果您想关注我的博客系列的最新消息/文章，请<a class="ae mj" href="https://github.com/n0ruSh/blogs/" rel="noopener ugc nofollow" target="_blank">【观看】</a>订阅。</li></ul></div></div>    
</body>
</html>