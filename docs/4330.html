<html>
<head>
<title>Why Should You Build Your Own Kubernetes Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该构建自己的Kubernetes运营商</h1>
<blockquote>原文：<a href="https://itnext.io/why-should-you-build-your-own-kubernetes-operator-f60c25df0b1c?source=collection_archive---------3-----------------------#2020-06-09">https://itnext.io/why-should-you-build-your-own-kubernetes-operator-f60c25df0b1c?source=collection_archive---------3-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4528" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这比你想象的更容易，也更有益</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd2921ba4dfd2357a35603d257ace41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJf5IIeh8Mz_B-pAsXPTJA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">贷项:CorrieMiracle/P <a class="ae ky" href="https://pixabay.com/photos/beach-sand-ocean-sand-castle-2445836/" rel="noopener ugc nofollow" target="_blank"> ixabay </a></figcaption></figure><p id="8f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes Operator是Kubernetes社区中最流行的技术之一。截至2020年5月，<a class="ae ky" href="https://github.com/operator-framework/awesome-operators/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> Awesome Operators </a> repo列出了145家运营商。Kube上托管的每一个主流软件——比如MySQL、Kafka和elastic search——都有一个或多个运营商。如果您是一个不托管数据库的普通Kube用户，您可能会考虑构建一个不相关的操作符，这是完全错误的。</p><p id="8106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文讨论了什么是Kubernetes操作符，以及为什么所有Kube用户都应该考虑为他们的应用程序建立一个操作符。</p><h1 id="614f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Kubernetes操作简单来说</h1><p id="abce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Kubernetes操作符是一个遵循Kube操作符模式的程序。根据官方<a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/" rel="noopener ugc nofollow" target="_blank"> Kubernetes网站</a>:</p><blockquote class="ms mt mu"><p id="7b70" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">操作员是Kubernetes的软件扩展，它利用<strong class="lb iu">定制资源</strong>来管理应用程序及其组件。操作员遵循Kubernetes原则，特别是<strong class="lb iu">控制回路</strong></p></blockquote><p id="7b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，操作符模式由两个主要部分组成:</p><ul class=""><li id="6ada" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu">定制资源(CR):</strong>CR是一个Kube API对象，类似于现成的Kube资源，如Pod、部署和服务，但是Kube用户定义了它的大部分模式。CR有规格和状态部分，由Kube维护，因此用户可以通过Kube APIs创建、读取、更新和删除(CRUD)它。规格部分允许用户用他们各自的语言描述他们应用程序的期望状态。例如，用户可以在CR中创建一个名为“replicasPerRegion”的键，它存储每个区域应该有多少个应用程序实例。</li><li id="0eb9" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">控制循环:</strong>控制循环是Kube用户实现的一段代码。该循环的工作是不断地与Kube APIs交互，并将现实与期望状态(CR)进行比较和协调。因此，它的另一个名字是:调和循环。该循环还将比较和协调的结果放入CR的status部分。</li></ul><p id="e5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何遵循这种模式的程序都是Kube操作符。你可能也听说过叫做<a class="ae ky" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank"> Operator SDK </a>的东西，但是它只不过是一个构建操作符的框架，因此没有必要。</p><h1 id="9477" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我为什么要构建一个运算符</h1><h2 id="9b1d" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated"><strong class="ak">面向Kubernetes的OOP</strong></h2><p id="b53a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">运算符模式优化和重构容器，就像面向对象编程(OOP)对软件系统所做的那样。它通过提高基于容器的应用程序的模块化、可读性和可重用性来管理复杂性。</p><p id="afc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Java这样的编程语言带有内置的原语和数据结构，如integer、map和list，允许用户在其上构建复杂的自定义类。正如所有经验丰富的程序员所知道的，根据OOP原则，与其使用内置类型<code class="fe nz oa ob oc b">Map&lt;String, String&gt;</code>来存储学生信息，不如创建如下的类:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="32d9" class="nn lw it oc b gy oh oi l oj ok">public class Student {<br/>  private String firstName;<br/>  private String lastName;<br/>  private String id;<br/>}</span></pre><p id="feed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，Kube为运行容器提供了一组“原语”,如Pod、副本集和部署。虽然使用它们来快速运行一些容器很方便，但是随着系统复杂性的增加，维护所有容器变得更具挑战性。通过定义您自己的CR，并让控制循环逻辑创建更多的Kube“原语”，您可以归档以下内容</p><ul class=""><li id="5f22" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">为了更好的可读性，在Kube清单文件中使用更有意义的名称。</li><li id="0490" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">特定于您的用例的验证。例如，您可以让Kube拒绝一个CR，如果它将一个应用程序的实例数设置为小于3。</li><li id="71cb" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">Kube“原语”之上的定制部署逻辑例如，强制一个部署与另一个部署具有相同数量的副本。</li><li id="7ee8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">操作人员看不到复杂性，因此他们不需要学习几十个YAML文件，只需要学习几个门面CRs。</li></ul><h2 id="25bc" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">轻便</h2><p id="ed64" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用Kubernetes的一个原因是可移植性。它提供了一个通用层，基于容器的应用可以在其上运行，而不管底层基础设施、AWS、IBM Cloud或您自己的数据中心。运营商进一步增强了便携性。</p><p id="d98e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署复杂的应用程序并不简单:一些容器可能需要等待其他容器，或者在某些情况下可能需要禁用部分部署逻辑。人们发明了像Spinnaker和Jenkins这样的连续交付(CD)框架，以及像Helm和Kustomize这样的工具，来处理这样的复杂性。因此，以一组图像、Kube清单和部署脚本/图表/配置文件的形式交付应用程序是很常见的。但是让我们面对现实:不同的团队选择不同的工具，不同的客户有不同的CD设置。操作员可以将您从为不同设置复制和定制相同部署逻辑的困境中解救出来。</p><p id="3406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Operator模式，Kube Operator的控制循环处理订单和条件的部署逻辑。操作符本身是一个可以在任何Kube集群上运行的容器，这使得Kube之外的部署依赖性需求最小化。要部署一个应用程序，所有用户需要做的就是创建操作员容器和一个或几个CRs，其余的由操作员负责。仍然需要CD和其他部署工具，但是它们的逻辑归结为几行代码，只需要几分钟就可以从一个移植到另一个。</p><h2 id="e666" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">更好的操作</h2><p id="7ad0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">操作员模式旨在模拟和自动化操作员的行为。人类操作员:</p><ol class=""><li id="284f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ol nf ng nh bi translated">根据文档(如操作手册)建立系统的期望状态。例如，有多少实例应该是健康的或者通过了某些检查。</li><li id="1765" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ol nf ng nh bi translated">检查当前情况是否符合期望的状态，如果不符合，则继续步骤3。</li><li id="8f3c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ol nf ng nh bi translated">采取行动解决问题。</li><li id="e962" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ol nf ng nh bi translated">重复步骤2和3，直到达到所需的状态。</li></ol><p id="9e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于人工操作员来说，无论他们是sre还是购买你的应用程序在现场运行的客户，操作员模式都会将他们的注意力引导到正确的地方。CRs的规格部分为操作员详细说明了期望的状态，而CRs的状态部分显示了现实如何与所述期望的状态相一致。它们的声明式风格也使得状态易于阅读和维护，同时也隐藏了所需状态如何存档的复杂性。最后但同样重要的是，您的应用程序获得了“自我修复”的能力，因为控制循环不会停止，直到达到所需的状态。</p><h2 id="2358" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">享受Kube生态系统</h2><p id="b305" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于CRs也是Kube API对象，如Deployment和Pod，它们本质上与Kube生态系统中的工具兼容。与其投资你自己的工具来可视化、管理和监控你的应用，不如使用像<code class="fe nz oa ob oc b">kubectl</code>和Kube dashboard这样的工具。与内部操作工具相比，Kube社区提供了更多的功能、错误修复和教程。此外，人类操作员可以避免花费时间学习新工具，并更快地登船。</p><h2 id="d51b" class="nn lw it bd lx no np dn mb nq nr dp mf li ns nt mh lm nu nv mj lq nw nx ml ny bi translated">这很简单</h2><p id="bfd1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，<a class="ae ky" href="https://sdk.operatorframework.io/build/" rel="noopener ugc nofollow" target="_blank">运营商SDK </a>让打造运营商变得简单。它支持建立一个带有Golang，Ansible或Helm的操作符。我强烈建议从基于Ansible的操作符开始，即使你已经熟悉Golang。在Ansible的<code class="fe nz oa ob oc b">k8s</code>和<code class="fe nz oa ob oc b">template</code>模块的帮助下，您可以用一个相当简单的YAML文件来描述您的操作员的任务，并在几个小时内让一个不平凡的操作员开始工作。</p><h1 id="c64c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="e071" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你在Kubernetes上发布复杂的应用程序，Kube Operator应该是你的首要任务。它使用起来很简单，但从长远来看，它可以改善你的应用程序的结构、可移植性和操作体验，同时节省开发时间。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="94d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，<a class="ae ky" href="https://medium.com/@nealhu" rel="noopener">在Medium上跟随我</a>！我撰写关于分布式系统和软件架构的文章，例如:</p><ul class=""><li id="3f7d" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/before-you-use-kustomize-eaa9529cdd19">在使用Kustomize </a>之前。流行的Kubernetes配置管理工具Kustomize的优缺点</li><li id="6c3e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/logging-like-a-pro-8cc6ad09e415">类日志记录</a>。向更好的自动化方向设计软件系统的技巧</li><li id="0ccf" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/automation-friendly-software-systems-and-how-to-build-them-7a7c5e3c1a15">自动化友好的软件系统以及如何构建它们</a>。向更好的自动化方向设计软件系统的技巧</li><li id="d5b1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/minimalist-software-architecture-426888684e60">极简软件架构</a>。构建大规模多区域分布式系统的经验教训</li></ul></div></div>    
</body>
</html>