<html>
<head>
<title>Conquering the Cache Stampede</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">征服高速缓存狂潮</h1>
<blockquote>原文：<a href="https://itnext.io/conquering-the-cache-stampede-3a4c9feb691c?source=collection_archive---------5-----------------------#2020-11-15">https://itnext.io/conquering-the-cache-stampede-3a4c9feb691c?source=collection_archive---------5-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d7b45fb70235e367f135e246dd7a1cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aLR5zLsrk4RpRrr7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jorgetung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jorge Tung </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="38ae" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">雷鸣般的兽群</h1><p id="77b7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您听从了每个人的建议，构建了一个无状态的应用程序。数据不在你的应用服务器中，因此当你收到请求时，你查询数据库。为了简单起见，您的代码看起来像下面这样，其中数据库被交换了:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ab55" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">我们可以用一个快速的curl命令来测试服务器。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9c83" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">随着时间的推移，您的服务规模不断扩大，您开始收到许多请求。每个请求都会导致一次数据库查询，有些查询很慢。在足够的负载下，您的延迟是不可接受的。您可以尝试通过添加索引、重写和基准测试查询、迁移数据模型等来优化数据层的查询执行时间。这可能是对时间的有益和有价值的利用，但是有一个更简单的解决方案。您可以在应用服务器中缓存数据库中给定查询的结果。在一段时间内，对相同数据的后续请求将由内存中的缓存提供服务，从而减少数据库的负载和延迟。问题解决了对吗？您的代码看起来会像这样:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="22e7" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">为了测试服务器，我们可以编写一个简单的bash一行程序来请求数据并观察结果。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="06a0" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">当应用程序和数据库负载不足时，这种方法可能在低流量下工作。然而，有一个问题。当多个并发请求针对相同的数据，而数据没有被缓存时会发生什么？值得注意的是，http库将在单独的goroutines中运行请求处理程序，因此对数据库的多个调用有可能同时发生。现实与你的预期不同。您可能认为第一个请求从数据库填充缓存，其他请求从缓存提供服务。实际情况是，我们有5个对数据库的相同数据的请求。</p><p id="f33d" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">注意，我在下面的curl命令中添加了一个<code class="fe mn mo mp mq b">&amp;</code>来同时运行它们。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="cd50" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">所有的go routine检查缓存，值不存在，所有的go routine查询数据库来填充缓存。这被称为“雷霆一族”或<a class="ae kf" href="https://en.wikipedia.org/wiki/Cache_stampede" rel="noopener ugc nofollow" target="_blank">缓存踩踏</a>。更不幸的是，这个问题出现在足够的负载下，因此当数据层无法承担额外的工作时，它会收到对相同数据的多个请求。脸书<a class="ae kf" href="https://www.facebook.com/watch/?v=10153675295382200" rel="noopener ugc nofollow" target="_blank">几年前发布了一个关于这个话题的视频</a>，值得一看。</p><h1 id="87ce" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">解决方案</h1><p id="1fee" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们如何解决这个问题？我们需要协调并发的go例程，使得一次只有一个例程为给定的键填充缓存。其他例程应该等待缓存填充，然后从缓存提供服务。为了使这更容易，我们将把填充逻辑推到缓存中，因为它已经被多个例程共享。我们将接受一个加载函数，该函数在给定一个键的情况下查询数据库。我们可以对调用者隐藏关于从数据库加载或从缓存读取的决定，并提供一个单独的<code class="fe mn mo mp mq b">Get</code>方法。</p><p id="7b2e" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">在我们深入实现之前，让我们回顾一下高层次的想法。我们将在填充缓存条目时创建一个通道。如果该通道存在，其他go例程将等待我们完成值的填充。一旦我们填充了这个值，关闭通道，所有其他的goroutines将从缓存中返回这个值。</p><p id="335a" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">缓存的代码比以前长了，因此我把它分成了自己的文件。<code class="fe mn mo mp mq b">Get</code>方法包含主要逻辑。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c91b" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">如果直接将其投入生产，这种缓存实现会有一些问题，即没有驱逐策略，以及潜在的严重锁争用。如果你想了解更多，请查看<a class="ae kf" href="https://dgraph.io/blog/post/caching-in-go/" rel="noopener ugc nofollow" target="_blank">这篇关于go缓存的文章</a>。也就是说，这个缓存说明了解决问题的方法。</p><p id="b914" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">我们的服务器的main方法现在需要将数据库查询设置为loader函数的一部分。它应该看起来像这样。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="54e6" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">如果我们运行并发curl命令，我们将看到只有第一个请求从数据库中查询数据！</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4ce4" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">我们解决了单个流程的问题。在具有外部缓存的分布式设置中，如Redis，解决方案是类似的。Redis实验室已经有一篇关于这个问题的<a class="ae kf" href="https://redislabs.com/blog/caches-promises-locks/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="9b7d" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated">感谢您的阅读，请在评论中告诉我您的想法。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="4d9b" class="pw-post-body-paragraph le lf it lg b lh mi lj lk ll mj ln lo lp mk lr ls lt ml lv lw lx mm lz ma mb im bi translated"><em class="my">原载于</em><a class="ae kf" href="https://www.sidneyw.com/conquering-the-cache-stampede/" rel="noopener ugc nofollow" target="_blank"><em class="my">sidneyw.com</em></a><em class="my">。</em></p></div></div>    
</body>
</html>