<html>
<head>
<title>What if Svelte would had another change-detector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果斯维特有另一个变化探测器会怎么样</h1>
<blockquote>原文：<a href="https://itnext.io/what-if-svelte-would-had-another-change-detector-4955f9b584d4?source=collection_archive---------1-----------------------#2020-06-20">https://itnext.io/what-if-svelte-would-had-another-change-detector-4955f9b584d4?source=collection_archive---------1-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/9a567588e2941e29d18f6373472ff330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*90BmLaHbtP0z3cDuKE6cEw.jpeg"/></div></figure><p id="e287" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Svelte 是非常好的框架/库，但是它有一个敏感的问题——它是一个变化检测器，如果你改变对象，它不能很好地检测变化，所以有时我听说我应该使用不可变的方式。</p><p id="fb99" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我想尝试任何其他细长的变化检测器，例如Angular。所以我做了一些类似于Svelte (Svelte-M)的实验性编译器，顺便说一下它给出了更好的捆绑包大小和性能:</p><p id="fa51" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">一个测试todo-app的bundle </strong>大小几乎是<strong class="jw ir"> </strong> <em class="ks">的两倍</em>:</p><ul class=""><li id="e336" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">纤薄:<strong class="jw ir"> 4.7k </strong> (2.2k gzipped)</li><li id="aaf8" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">纤薄M: <strong class="jw ir"> 2.7k </strong> (1.2k gzipped)</li></ul><p id="588e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">性能</strong> <em class="ks">(基准更新于2020年7月5日，Firefox 78)</em>:</p><ul class=""><li id="6408" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated">5000项渲染:svelet<strong class="jw ir">353 ms</strong>，svelet-M<strong class="jw ir">327 ms</strong>(svelet-M略快)</li><li id="5215" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated">重新渲染(移除和添加5000个项目):svelet:<strong class="jw ir">445 ms</strong>，svelet-M<strong class="jw ir">277 ms</strong>(快两倍)</li></ul><p id="0aa5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用Svelte-M编译的todo-app示例:<a class="ae lh" href="https://github.com/lega911/svelte-m/blob/master/example.html" rel="noopener ugc nofollow" target="_blank">example.html</a>并部署在<a class="ae lh" href="https://jsfiddle.net/lega911/w1a63hj8/" rel="noopener ugc nofollow" target="_blank"> jsfiddle </a>中。<a class="ae lh" href="https://gist.github.com/lega911/4372e9eabb3bba29057be0f7766264a9" rel="noopener ugc nofollow" target="_blank">基准源</a>。</p><p id="3be4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">警告:Svelte-M只是一个小实验，所以功能不多，非常有限</em></p><p id="983a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">为什么更快？</strong> Svelte逐个元素地构建DOM，然后添加props，这不是构建DOM的最快方法，而且会增加源代码，Svelte-M将DOM构建为一个命令，并使用<em class="ks"> Node.cloneNode </em>克隆项目(DOM树)(作为一个命令，而不是逐个元素地构建)。</p><blockquote class="li lj lk"><p id="1362" class="ju jv ks jw b jx jy jz ka kb kc kd ke ll kg kh ki lm kk kl km ln ko kp kq kr ij bi translated">以后还想看这个故事吗？把它保存在<a class="ae lh" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=blog&amp;utm_campaign=noteworthy&amp;utm_content=eid7" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">期刊中。</em></p></blockquote><h2 id="c35a" class="lo lp iq bd lq lr ls dn lt lu lv dp lw kf lx ly lz kj ma mb mc kn md me mf mg bi translated">另一个变化检测器</h2><p id="c077" class="pw-post-body-paragraph ju jv iq jw b jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ij bi translated">但最重要的是另一个变化检测(我会称之为绑定检查)，下面几个例子如何更好:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="dab2" class="lo lp iq mr b gy mv mw l mx my">let todos = [];</span><span id="7dc5" class="lo lp iq mr b gy mz mw l mx my">const add = () =&gt; {<br/>  todos.push({name: 'Hello!'});<br/>};</span></pre><p id="8d9a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当你调用函数“add()”时，Svelte没有检测到变化，所以DOM不会被更新，你必须使用赋值，例如t <em class="ks"> odos=todos </em>(看起来像其他框架中的手动“setValue”)。这个片段与Svelte-M一起工作很好，它检测任何变化。</p><p id="0bff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个例子:我有一个待办事项列表，我想通过点击待办事项来更改一些内容:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8fb5" class="lo lp iq mr b gy mv mw l mx my">&lt;script&gt;<br/>  let todos = [];<br/>  const fix = (todo) =&gt; {<br/>    todo.name += '!';<br/>  }<br/>&lt;/script&gt;</span><span id="4c8f" class="lo lp iq mr b gy mz mw l mx my">&lt;ul&gt;<br/>  {#each todos as todo }<br/>  &lt;li&gt;<br/>    &lt;span on:click={() =&gt; fix(todo)}&gt;{todo.name}&lt;/span&gt;<br/>  &lt;/li&gt;<br/>  {/each}<br/>&lt;/ul&gt;</span></pre><p id="683b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当你点击一个项目，函数“修复”将被调用，Svelte不会检测到变化，有几种方法可以修复它，但无论如何你需要做些什么。与苗条-M它的工作只是因为它被改变了。</p><p id="ccb2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，另一个变化检测系统可能会更好，它像预期的那样工作(更接近javascript)，技巧更少，工作速度足够快。我想看到类似的苗条…</p><p id="ca24" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Svelte-M编译器的源代码:<a class="ae lh" href="https://github.com/lega911/svelte-m" rel="noopener ugc nofollow" target="_blank">https://github.com/lega911/svelte-m</a></p><p id="1b72" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你愿意尝试，有一个小的绑定变化，只是因为它更短:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9926" class="lo lp iq mr b gy mv mw l mx my">Svelte:<br/>  &lt;span on:click={() =&gt; fix(todo)}&gt;</span><span id="f8b6" class="lo lp iq mr b gy mz mw l mx my">Svelte-M:<br/>  &lt;span on:click={fix(todo)}&gt;</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="70f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">📝把这个故事保存在<a class="ae lh" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_read_later_text" rel="noopener ugc nofollow" target="_blank">杂志</a>上。</p><p id="6b1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">👩‍💻每周日早上醒来，你的收件箱里会有本周最值得关注的科技新闻。<a class="ae lh" href="https://usejournal.com/newsletter/noteworthy-in-tech/?utm_source=medium.com&amp;utm_medium=noteworthy_blog&amp;utm_campaign=tech&amp;utm_content=guest_post_text" rel="noopener ugc nofollow" target="_blank">阅读科技简讯</a>中值得关注的内容。</p></div></div>    
</body>
</html>