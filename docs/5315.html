<html>
<head>
<title>Delayed code execution in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中延迟的代码执行</h1>
<blockquote>原文：<a href="https://itnext.io/delayed-code-execution-in-flutter-23d60b51e76f?source=collection_archive---------3-----------------------#2021-02-07">https://itnext.io/delayed-code-execution-in-flutter-23d60b51e76f?source=collection_archive---------3-----------------------#2021-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5c6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微任务，Future或者postFrameCallback，我该用哪个？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f2e43cb6d5e07e75c895328862d8441c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jFgICVPeu3DAR_64.jpg"/></div></div></figure><p id="961a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将带您深入了解Flutter，并了解更多关于调度代码执行的信息。作为对话的开始，让我们假设我们正在使用<a class="ae kx" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> Provider </a>库构建一个标准<a class="ae kx" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/options#bloc--rx" rel="noopener ugc nofollow" target="_blank"> BLoC </a>架构的应用程序。为了使这项任务具有挑战性，在打开一个新的屏幕时，我们将不得不发起一个网络请求来通过互联网获取某些东西。在这种情况下，我们有几个选项来启动我们的请求:</p><ol class=""><li id="92be" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">在显示我们的屏幕之前获取数据，并显示预加载的数据。这可能不是最好的选择。如果您决定只获取所需的数据部分，您可能会加载大量不必要的数据或者用微调器阻塞用户界面。</li><li id="9b19" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">在<code class="fe lm ln lo lp b">BLoC</code>中启动加载程序，就在屏幕显示之前，当创建<code class="fe lm ln lo lp b">BLoC</code>本身时或通过使用一个协调器对象为您启动它。如果您想保持您的架构整洁，这将是推荐的方法。</li><li id="00e9" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">在屏幕的<a class="ae kx" href="https://api.flutter.dev/flutter/widgets/State/initState.html" rel="noopener ugc nofollow" target="_blank"> initState </a>中启动加载过程，尝试将该逻辑封装在屏幕本身中。</li></ol><p id="5672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就架构正确性而言，第三个选项可能不是最好的，但实际上是Flutter世界中相当常见的方法。让我们来检查一下，因为它在现实世界的场景中完美地展示了我们的主题。</p><p id="09f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于演示目的，这里有一个示例代码。注意到它有什么问题吗？</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="4c18" class="lu lv iq lp b gy lw lx l ly lz">import 'package:flutter/material.dart';<br/>import 'package:provider/provider.dart';</span><span id="1cd2" class="lu lv iq lp b gy ma lx l ly lz">void main() {<br/>  runApp(<br/>    MaterialApp(<br/>      title: 'Demo',<br/>      home: ChangeNotifierProvider(<br/>        create: (_) =&gt; MyHomePageBloc(),<br/>        child: MyHomePage(),<br/>      ),<br/>    ),<br/>  );<br/>}</span><span id="764a" class="lu lv iq lp b gy ma lx l ly lz">class MyHomePage extends StatefulWidget {<br/>  MyHomePage({Key key}) : super(key: key);</span><span id="911f" class="lu lv iq lp b gy ma lx l ly lz">  @override<br/>  _MyHomePageState createState() =&gt; _MyHomePageState();<br/>}</span><span id="f9c7" class="lu lv iq lp b gy ma lx l ly lz">class _MyHomePageState extends State&lt;MyHomePage&gt; {<br/>  @override<br/>  void initState() {<br/>    super.initState();<br/>    context.read&lt;MyHomePageBloc&gt;().fetchData();<br/>  }</span><span id="f967" class="lu lv iq lp b gy ma lx l ly lz">  @override<br/>  Widget build(BuildContext context) {<br/>    final bloc = context.watch&lt;MyHomePageBloc&gt;();</span><span id="b8e4" class="lu lv iq lp b gy ma lx l ly lz">    return Scaffold(<br/>      appBar: AppBar(),<br/>      body: Center(<br/>        child: bloc.loading ? CircularProgressIndicator() : Text(bloc.data),<br/>      ),<br/>      floatingActionButton: FloatingActionButton(<br/>        onPressed: () =&gt; context.read&lt;MyHomePageBloc&gt;().fetchData(),<br/>        tooltip: 'Fetch',<br/>        child: Icon(Icons.add),<br/>      ),<br/>    );<br/>  }<br/>}</span><span id="8ab1" class="lu lv iq lp b gy ma lx l ly lz">class MyHomePageBloc with ChangeNotifier {<br/>  String data = "Loading";<br/>  bool loading = false;</span><span id="c955" class="lu lv iq lp b gy ma lx l ly lz">  void fetchData() {<br/>    loading = true;<br/>    data = "Loading";<br/>    notifyListeners();</span><span id="79f8" class="lu lv iq lp b gy ma lx l ly lz">    Future.delayed(Duration(seconds: 3), () {<br/>      loading = false;<br/>      data = "Done";<br/>      notifyListeners();<br/>    });<br/>  }<br/>}</span></pre><p id="5627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，似乎一切都很好。然而，如果你运行它，它将不可避免地崩溃，你会在你的日志中看到类似的东西:<code class="fe lm ln lo lp b"><em class="mb">‘package:flutter/src/widgets/framework.dart’: Failed assertion: line 4349 pos 12: ‘!_dirty’: is not true.</em></code></p><p id="4c51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个错误表明<strong class="jp ir">我们试图在构建时</strong>修改小部件树。小部件的<a class="ae kx" href="https://api.flutter.dev/flutter/widgets/State/initState.html" rel="noopener ugc nofollow" target="_blank"> initState </a>方法在构建过程中被调用<strong class="jp ir">，因此任何从那里修改小部件树的尝试都将失败。在我们的例子中，当调用fetch方法时，它同步执行<a class="ae kx" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank"> notifyListeners() </a>，这导致小部件树中的变化。</strong></p><p id="88b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你试图做更多看似不相关的事情时，你可能会遇到类似的错误。例如，显示一个对话框，也会因为类似的原因而失败，因为<a class="ae kx" href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" rel="noopener ugc nofollow" target="_blank">上下文</a> ( <a class="ae kx" href="https://api.flutter.dev/flutter/widgets/Element-class.html" rel="noopener ugc nofollow" target="_blank">元素</a>)当前还没有安装在小部件树中。</p><p id="e5ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论您尝试做什么，都必须延迟代码执行，直到构建过程完成。换句话说，您需要异步执行您的代码<strong class="jp ir"/>。现在谈谈我们的选择。</p><h1 id="1234" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">如何在Flutter中延迟代码执行？</h1><p id="fefa" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">通过在网上研究这个话题，我整理了一份最常推荐的解决方案清单。您甚至可以找到一些附加选项，但以下是最引人注目的选项:</p><ul class=""><li id="4351" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Zone/scheduleMicrotask.html" rel="noopener ugc nofollow" target="_blank">日程安排任务</a></li><li id="4a00" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Future/Future.microtask.html" rel="noopener ugc nofollow" target="_blank">未来&lt; T &gt;。微任务</a></li><li id="a80c" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Future/Future.html" rel="noopener ugc nofollow" target="_blank">未来&lt;T&gt;T11】</a></li><li id="39c9" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Future/Future.delayed.html" rel="noopener ugc nofollow" target="_blank">未来&lt; T &gt;。延迟</a></li><li id="f9a7" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Timer/run.html" rel="noopener ugc nofollow" target="_blank"> Timer.run </a></li><li id="308c" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">widgetsbinding . addpostframcallback</a></li><li id="a384" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ne le lf lg bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/scheduler/SchedulerBinding/addPostFrameCallback.html" rel="noopener ugc nofollow" target="_blank">scheduler binding . addpostframcallback</a></li></ul><p id="7921" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会说，这是相当多的选择，而且你是对的。说到我们前面提到的问题，这些都可以解决。然而，现在我们面临着如此多种多样的选择，让我们放纵自己的好奇心，努力了解它们之间的差异。</p><h1 id="62f4" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">事件循环和多线程</h1><p id="d7fd" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">你可能知道，<strong class="jp ir"> Dart是单线程系统</strong>。令人惊讶的是，您的应用程序可以同时做多件事情，或者至少看起来是这样。这就是<code class="fe lm ln lo lp b">Event Loop</code>发挥作用的地方。一个<code class="fe lm ln lo lp b">Event Loop</code>实际上是一个无限循环(对于iOS开发人员来说是<a class="ae kx" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" rel="noopener ugc nofollow" target="_blank">运行循环</a>),它执行预定的事件。事件(或者只是代码块，如果你喜欢的话)必须是轻量级的，否则，你的应用会感觉滞后或者完全冻结。每个<code class="fe lm ln lo lp b">event</code>，比如一个按钮的按下或者一个网络响应，都被安排在一个<code class="fe lm ln lo lp b">events queue</code>中，等待被<code class="fe lm ln lo lp b">Event Loop</code>拾取和执行。这种设计模式在UI和其他处理各种事件的系统中很常见。可能很难用几句话来解释这个概念，所以我建议如果你对这个主题不熟悉的话，可以另外读一些东西。不要想太多，我们实际上是在讨论一个简单的无限循环和一系列计划执行的任务(代码块)，每次循环迭代一个任务。</p><p id="c2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们即将了解的飞镖<code class="fe lm ln lo lp b">Event Loop</code>晚会的特邀嘉宾是<a class="ae kx" href="https://api.dart.dev/stable/2.10.5/dart-async/scheduleMicrotask.html" rel="noopener ugc nofollow" target="_blank">微任务</a>。我们的<code class="fe lm ln lo lp b">Event Loop</code>里面有额外的队列，就是<code class="fe lm ln lo lp b">Microtask Queue</code>。关于这个队列，需要记住的唯一一件事是:在执行<code class="fe lm ln lo lp b">event</code>本身之前，在<code class="fe lm ln lo lp b">Event Loop</code>的一次迭代中，将会执行<strong class="jp ir">队列中调度的所有</strong>任务<strong class="jp ir">。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/736c52354439c8bb1ac0e81619e1f47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*MDY0_btfvduaUJAA.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">每次迭代首先执行<strong class="bd md">所有</strong>到<code class="fe lm ln lo lp b">microtasks</code>，接着执行一个<code class="fe lm ln lo lp b">event</code>。循环重复。</figcaption></figure><p id="52ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，没有太多关于这个主题的信息，我所看到的最好的解释可以在网络档案<a class="ae kx" href="https://web.archive.org/web/20170704074724/https://webdev.dartlang.org/articles/performance/event-loop" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae kx" href="https://dart.cn/articles/archive/event-loop" rel="noopener ugc nofollow" target="_blank">这里</a>中找到。</p><p id="ee68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些知识，让我们看看上面列出的所有选项，并了解它们的工作方式和它们之间的差异。</p><h1 id="7104" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">事件</h1><p id="4597" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">任何进入<code class="fe lm ln lo lp b">event queue</code>的东西。这是在Flutter中调度异步任务的默认方法。调度一个<code class="fe lm ln lo lp b">event</code>，我们将它添加到<code class="fe lm ln lo lp b">event queue</code>中，由<code class="fe lm ln lo lp b">Event Loop</code>拾取。这种方法被许多抖动机制使用，比如I/O、手势事件、定时器等。</p><h2 id="bb58" class="lu lv iq bd md nk nl dn mh nm nn dp ml jy no np mp kc nq nr mt kg ns nt mx nu bi translated"><strong class="ak">定时器</strong></h2><p id="ae63" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated"><a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Timer-class.html" rel="noopener ugc nofollow" target="_blank">定时器</a>是Flutter中异步任务的基础。它用于调度<code class="fe lm ln lo lp b">event queue</code>中的代码执行，有延迟或没有延迟。由此产生的有趣事实是，如果队列繁忙，您的计时器将永远不会执行，即使时间到了。</p><p id="fc44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">如何使用:</em> </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="d499" class="lu lv iq lp b gy lw lx l ly lz">Timer.run(() {<br/>  print("Timer");<br/>});</span></pre><h2 id="d90e" class="lu lv iq bd md nk nl dn mh nm nn dp ml jy no np mp kc nq nr mt kg ns nt mx nu bi translated"><strong class="ak">未来&lt; T &gt;和未来&lt; T &gt;。延期</strong></h2><p id="b61c" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">一种广为人知且广泛使用的飞镖<a class="ae kx" href="https://api.dart.dev/dart-async/Future-class.html" rel="noopener ugc nofollow" target="_blank">特征</a>。这可能会令人惊讶，但如果你看引擎盖下，你只会看到前面提到的<code class="fe lm ln lo lp b">Timer</code>的包装。</p><p id="b9a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">如何使用:</em> </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="68fe" class="lu lv iq lp b gy lw lx l ly lz">Future&lt;void&gt;(() {<br/>  print("Future Event");<br/>});</span><span id="7637" class="lu lv iq lp b gy ma lx l ly lz">Future&lt;void&gt;.delayed(Duration.zero, () {<br/>  print("Future.delayed Event");<br/>});</span></pre><p id="aeee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">内部实现(</em> </strong> <a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Future/Future.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mb">链接</em></strong></a><strong class="jp ir"><em class="mb">):</em></strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="f73b" class="lu lv iq lp b gy lw lx l ly lz">factory Future(FutureOr&lt;T&gt; computation()) {<br/>  _Future&lt;T&gt; result = new _Future&lt;T&gt;();<br/>  Timer.run(() {<br/>    try {<br/>      result._complete(computation());<br/>    } catch (e, s) {<br/>      _completeWithErrorCallback(result, e, s);<br/>    }<br/>  });<br/>  return result;<br/>}</span></pre><h1 id="cc08" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">微任务</h1><p id="7c50" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">如前所述，所有预定的<code class="fe lm ln lo lp b">microtasks</code>都在下一个预定的<code class="fe lm ln lo lp b">event</code>之前执行。建议<strong class="jp ir">避开</strong>这个队列，除非绝对有必要异步执行代码，但是在<code class="fe lm ln lo lp b">event queue</code>的下一个<code class="fe lm ln lo lp b">event</code>之前。您也可以将此队列视为属于前一个事件的任务队列，因为它们将在下一个事件之前完成。重载这个队列会完全冻结你的应用程序，因为它必须执行这个队列中的所有东西，然后才能继续下一个<code class="fe lm ln lo lp b">event queue</code>的迭代，比如处理用户输入，甚至是呈现应用程序本身。然而，以下是我们的选择:</p><h2 id="3228" class="lu lv iq bd md nk nl dn mh nm nn dp ml jy no np mp kc nq nr mt kg ns nt mx nu bi translated"><strong class="ak">日程安排任务</strong></h2><p id="6ce8" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">顾名思义，在<code class="fe lm ln lo lp b">microtask queue</code>中安排一个块代码。类似于<code class="fe lm ln lo lp b">Timer</code>，如果出现问题，会使应用程序崩溃。</p><p id="a319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">如何使用:</em> </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="1c50" class="lu lv iq lp b gy lw lx l ly lz">scheduleMicrotask(() {<br/>  print("Microtask");<br/>});</span></pre><h2 id="3ce9" class="lu lv iq bd md nk nl dn mh nm nn dp ml jy no np mp kc nq nr mt kg ns nt mx nu bi translated"><strong class="ak">未来&lt; T &gt;。微任务</strong></h2><p id="e1e5" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">与我们之前看到的类似，将我们的<code class="fe lm ln lo lp b">microtask</code>包装在<code class="fe lm ln lo lp b">try-catch</code>块中，以一种简洁明了的方式返回执行结果或错误。</p><p id="4d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">如何使用:</em> </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="1c93" class="lu lv iq lp b gy lw lx l ly lz">Future&lt;void&gt;.microtask(() {<br/>  print("Microtask");<br/>});</span></pre><p id="d74a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">内部实现(</em> </strong> <a class="ae kx" href="https://api.flutter.dev/flutter/dart-async/Future/Future.microtask.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mb">链接</em></strong></a><strong class="jp ir"><em class="mb">):</em></strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="7103" class="lu lv iq lp b gy lw lx l ly lz">factory Future.microtask(FutureOr&lt;T&gt; computation()) {<br/>  _Future&lt;T&gt; result = new _Future&lt;T&gt;();<br/>  scheduleMicrotask(() {<br/>    try {<br/>      result._complete(computation());<br/>    } catch (e, s) {<br/>      _completeWithErrorCallback(result, e, s);<br/>    }<br/>  });<br/>  return result;<br/>}</span></pre><h1 id="5d4f" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">后帧回调</h1><p id="544e" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">尽管前两种方法涉及较低层次的<code class="fe lm ln lo lp b">Event Loop</code>机制，我们现在转向颤振领域。这个回调在渲染管道完成时被调用，因此它被<strong class="jp ir">绑定到小部件的生命周期</strong>。调度的时候只调用一次<strong class="jp ir"/>，不是每一帧都调用。使用<a class="ae kx" href="https://api.flutter.dev/flutter/scheduler/SchedulerBinding/addPostFrameCallback.html" rel="noopener ugc nofollow" target="_blank"> addPostFrameCallback </a>方法，您可以安排一个或多个回调在框架构建完成后执行。所有预定的回调将在帧的末尾按照它们被添加的顺序执行。在调用这个回调函数时，可以保证<strong class="jp ir">小部件构建过程已经完成</strong>。通过一些烟雾和镜子，您甚至可以访问小部件的布局(<a class="ae kx" href="https://api.flutter.dev/flutter/rendering/RenderBox-class.html" rel="noopener ugc nofollow" target="_blank"> RenderBox </a>)，例如它的大小，并进行其他类型的不推荐的攻击。回调本身将在正常的事件队列中运行，默认情况下，Flutter对几乎所有事情都使用这个队列。</p><h2 id="7af9" class="lu lv iq bd md nk nl dn mh nm nn dp ml jy no np mp kc nq nr mt kg ns nt mx nu bi translated"><strong class="ak">调度绑定</strong></h2><p id="2583" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">这是一个负责绘图回调的<a class="ae kx" href="https://dart.dev/guides/language/language-tour#adding-features-to-a-class-mixins" rel="noopener ugc nofollow" target="_blank"> mixin </a>并实现了我们感兴趣的这个方法。</p><p id="3aae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">如何使用:</em> </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="f65e" class="lu lv iq lp b gy lw lx l ly lz">SchedulerBinding.instance.addPostFrameCallback((_) {<br/>  print("SchedulerBinding");<br/>});</span></pre><h2 id="430d" class="lu lv iq bd md nk nl dn mh nm nn dp ml jy no np mp kc nq nr mt kg ns nt mx nu bi translated"><strong class="ak"> WidgetsBinding </strong></h2><p id="d85d" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我特意包括了这个，因为它经常和<a class="ae kx" href="https://api.flutter.dev/flutter/scheduler/SchedulerBinding-mixin.html" rel="noopener ugc nofollow" target="_blank">调度绑定</a>一起被提及。它从<code class="fe lm ln lo lp b">SchedulerBinding</code>继承了这个方法，并增加了与我们的主题无关的方法。一般来说，不管你使用<code class="fe lm ln lo lp b">SchedulerBinding</code>还是<a class="ae kx" href="https://api.flutter.dev/flutter/widgets/WidgetsBinding-mixin.html" rel="noopener ugc nofollow" target="_blank"> WidgetsBinding </a>，两者都会执行<strong class="jp ir">中完全相同的代码</strong>。</p><p id="1868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mb">如何使用:</em> </strong></p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="55ae" class="lu lv iq lp b gy lw lx l ly lz">WidgetsBinding.instance.addPostFrameCallback((_) {<br/>  print("WidgetsBinding");<br/>});</span></pre><h1 id="e5fb" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将我们的知识付诸实践</h1><p id="cd3c" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">既然我们今天已经学了很多理论，我强烈建议先玩一会儿，以确保你理解正确。我们可以在之前的initState中使用下面的代码，并尝试预测它将以何种顺序执行，这看起来并不容易。</p><pre class="km kn ko kp gt lq lp lr ls aw lt bi"><span id="2d7d" class="lu lv iq lp b gy lw lx l ly lz">SchedulerBinding.instance.addPostFrameCallback((_) {<br/>  print("SchedulerBinding");<br/>});</span><span id="d6bd" class="lu lv iq lp b gy ma lx l ly lz">WidgetsBinding.instance.addPostFrameCallback((_) {<br/>  print("WidgetsBinding");<br/>});</span><span id="b963" class="lu lv iq lp b gy ma lx l ly lz">Timer.run(() {<br/>  print("Timer");<br/>});</span><span id="0cf5" class="lu lv iq lp b gy ma lx l ly lz">scheduleMicrotask(() {<br/>  print("scheduleMicrotask");<br/>});</span><span id="b72d" class="lu lv iq lp b gy ma lx l ly lz">Future&lt;void&gt;.microtask(() {<br/>  print("Future Microtask");<br/>});</span><span id="1093" class="lu lv iq lp b gy ma lx l ly lz">Future&lt;void&gt;(() {<br/>  print("Future");<br/>  Future&lt;void&gt;.microtask(() {<br/>    print("Microtask from Event");<br/>  });<br/>});</span><span id="76ff" class="lu lv iq lp b gy ma lx l ly lz">Future&lt;void&gt;.delayed(Duration.zero, () {<br/>  print("Future.delayed");<br/>  Future&lt;void&gt;.microtask(() {<br/>    print("Microtask from Future.delayed");<br/>  });<br/>});</span></pre><h1 id="cfbc" class="mc lv iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论</h1><p id="12ef" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">既然我们已经了解了这么多细节，您可以考虑一下如何安排您的代码了。根据经验，如果你需要你的上下文或者与布局或UI相关的东西，使用<code class="fe lm ln lo lp b">addPostFrameCallback</code>。在其他任何情况下，用<code class="fe lm ln lo lp b">Future&lt;T&gt;</code>或<code class="fe lm ln lo lp b">Future&lt;T&gt;.delayed</code>安排在<code class="fe lm ln lo lp b">event queue</code>就足够了。<code class="fe lm ln lo lp b">microtask queue</code>是一个你可能永远也不会遇到的非常小众的东西，但是仍然值得了解。当然，如果您有一项繁重的任务，您会看到创建一个<a class="ae kx" href="https://api.dart.dev/stable/2.10.5/dart-isolate/Isolate-class.html" rel="noopener ugc nofollow" target="_blank">隔离</a>，正如您可能已经猜到的那样，它将由<code class="fe lm ln lo lp b">event queue</code>进行通信。但这是另一篇文章的主题。感谢您的时间，下次再见。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="12f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb">在考虑开发一个Flutter或者iOS的app，或者寻找顾问或者人力？从初创企业到公司层面，我都可以雇佣。就</em> <a class="ae kx" href="https://oleksandrkirichenko.com/contact/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">联系我</em> </a> <em class="mb">看看我们能一起做什么！</em></p><p id="90d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb">喜欢这篇文章？别忘了砸这个拍手</em>👏<em class="mb">按钮让我感觉棒极了，有动力写更多！</em></p><p id="f113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb">原载于2021年2月7日https://oleksandrkirichenko.com</em><em class="mb">的</em> <a class="ae kx" href="https://oleksandrkirichenko.com/blog/delayed-code-execution-in-flutter/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">。</em></a></p></div></div>    
</body>
</html>