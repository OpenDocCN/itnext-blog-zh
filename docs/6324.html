<html>
<head>
<title>Deploying Next Gen Serverless Functions with WebAssembly and Module Federation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebAssembly和模块联合部署下一代无服务器功能</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-next-gen-serverless-functions-with-webassembly-and-module-federation-202d2bca497e?source=collection_archive---------5-----------------------#2021-10-17">https://itnext.io/deploying-next-gen-serverless-functions-with-webassembly-and-module-federation-202d2bca497e?source=collection_archive---------5-----------------------#2021-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不需要部署自动化。第1部分，共3部分。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6575ac75c1dd729a113e3763814e10a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5veNfzZLuwq8JEp8wl5dQ.jpeg"/></div></div></figure><p id="74d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为WebAssembly (WASM)是容器的替代方案，提供了比OS级隔离更多的不受信任代码的保护，以大多数流行语言的编译目标的中间格式分发，并达到接近本机的速度，所以它是无服务器运行时的理想选择。WasmEdge是目前最快的WASM运行时和堆栈机器，实现了不到30毫秒的冷启动。</p><p id="b2f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们如何使用WASM开发和部署无服务器功能呢？第一个问题的答案可以在大量关于C、C++、C#、Go、Rust工具链的文献中找到……不胜枚举。然而，第二个问题的答案有点黯淡，取决于当前的容器技术，例如与K8s和其他容器工具的集成。</p><p id="5784" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我提供一个替代方案。根本不要安装软件。</p><p id="01a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着什么呢？这意味着在运行时通过网络(例如从CDN)传输软件，而不是在服务器上安装软件。这种类似浏览器的分发技术由<a class="ae lq" href="https://medium.com/codex/federated-applications-ba396d6925b1?sk=c198b9af988537c754edb5cf283adf9e" rel="noopener"> <em class="lr">联合应用</em> </a>在后端使用。联合应用程序组件包括:</p><ul class=""><li id="2233" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">由许多不同的开发团队构建:没有单一的代码库，</li><li id="204e" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">设计为在运行时从多个repos和多个网络位置加载，</li><li id="275c" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">不是安装在服务器上，而是根据需要通过网络传输，</li><li id="cfde" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">不需要部署自动化</li><li id="95df" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">高度可组合，支持动态功能和零停机时间的服务组件运行时绑定，</li><li id="df0e" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">在任何环境中以相同的方式安装，不受供应商或计算交付方式的影响。</li><li id="dd45" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">可以在单个进程中一起运行</li><li id="95a0" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">可以随时重新部署，而无需重新启动流程或中断流程中运行的其他组件</li></ul><p id="6457" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里看到这种技术<a class="ae lq" href="http://github.com/module-federation/microlib" rel="noopener ugc nofollow" target="_blank">的一个例子，当Github发布新版本时，它直接从Github传输代码。目前，它支持用Javascript编写的组件的所有上述特性。</a></p><p id="e191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebAssembly支持正在开发中，在无服务器的情况下，需要对实现进行更改，即通过在嵌入式JS引擎(例如secondstate.io的QuickJS)中执行或通过移植到Rust或AssemblyScript来支持WASM运行时。也就是说，基本支持<em class="lr">是</em>可用的。</p><p id="c9db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当加载一个模块时，系统生成一组API，这些API调用针对该模块的专用数据源的CRUD操作，该数据源也是自动生成的。适配器被加载并绑定到模块在运行时公开的端口，允许它们相互通信或与任何其他本地或远程服务通信。模块还可以通过管道连接在一起，形成本地或分布式控制流，自动回滚以补偿下游事务失败…等等。</p><p id="78ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，在无服务器部署解决方案中，所有这些是如何结合在一起的呢？我们会在<a class="ae lq" href="https://trmidboe.medium.com/deploying-next-gen-serverless-functions-with-webassembly-and-module-federation-1471b94e425c" rel="noopener">第二部</a>中看到。敬请关注。感谢阅读。欢迎评论和提问。</p></div></div>    
</body>
</html>