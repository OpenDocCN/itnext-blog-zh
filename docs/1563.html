<html>
<head>
<title>Kubernetes Client Authentication on Amazon EKS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亚马逊EKS上的Kubernetes客户端认证</h1>
<blockquote>原文：<a href="https://itnext.io/how-does-client-authentication-work-on-amazon-eks-c4f2b90d943b?source=collection_archive---------1-----------------------#2018-11-24">https://itnext.io/how-does-client-authentication-work-on-amazon-eks-c4f2b90d943b?source=collection_archive---------1-----------------------#2018-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b15a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">亚马逊<a class="ae ko" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank">Kubernetes(EKS)弹性容器服务</a>是AWS的托管Kubernetes服务。本文解释了在EKS上对API服务器请求的认证是如何工作的。</p><p id="339b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">讨论分为两个主要部分，可以通过这些快捷方式直接访问:</p><ul class=""><li id="cc3a" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="#b575" rel="noopener ugc nofollow"> <strong class="js iu"> EKS认证:服务器端</strong> </a></li><li id="9e41" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="#609a" rel="noopener ugc nofollow"> <strong class="js iu"> EKS认证:客户端</strong> </a></li></ul><h1 id="ca99" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">亚马逊EKS</h1><p id="c322" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">亚马逊EKS于2018年6月<a class="ae ko" href="https://aws.amazon.com/blogs/aws/amazon-eks-now-generally-available/" rel="noopener ugc nofollow" target="_blank">正式上市</a>。它与来自谷歌云平台的<a class="ae ko" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> GKE </a>或来自微软Azure的<a class="ae ko" href="https://docs.microsoft.com/en-us/azure/aks/" rel="noopener ugc nofollow" target="_blank"> AKS </a>属于同一类服务。</p><p id="22af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，与后两种服务不同，EKS并不为您创建和运行整个集群，而是为您创建和运行集群的<em class="mg">控制平面</em>。控制平面的含义一般是<em class="mg">主节点</em>。</p><p id="b790" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别是，EKS在AWS管理的帐户中的不同可用性区域运行多个主节点(为了高可用性)(也就是说，您在自己的帐户中看不到主节点)。您负责在自己的帐户中作为EC2实例供应和运行工作节点(数据平面),并使它们加入主节点以形成完整的集群。</p><p id="cb04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法使您能够在流程的早期接触到Kubernetes客户端身份验证(工作节点必须在控制平面中针对API服务器进行身份验证，以便加入集群)。此外，EKS以一种非常特殊的方式处理客户端身份验证(使用IAM身份)。这就是为什么客户端认证对于EKS用户来说是一个非常重要的话题。</p><p id="9477" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，“身份验证”指的是针对Kubernetes API服务器的请求(来自任何类型的客户机)的身份验证。</p><h1 id="92b7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Kubernetes基础知识</h1><h2 id="65ce" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">Kubernetes API和API服务器</h2><p id="e7c8" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">从用户的角度来看，Kubernetes本质上是一个HTTP REST API。这个API的端点叫做<a class="ae ko" href="https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> API服务器</strong> </a>。API服务器通常运行在Kubernetes集群的主节点上。</p><p id="6329" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户端与Kubernetes的每次交互都是通过API调用API服务器来实现的。例如，如果您执行<code class="fe mt mu mv mw b">kubectl get pods</code>，那么幕后的<code class="fe mt mu mv mw b">kubectl</code>向API服务器发出一个HTTP请求，API服务器执行所请求的<code class="fe mt mu mv mw b">get pods</code>动作，并将结果返回给您。</p><p id="9445" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不仅适用于来自集群外部的请求，也适用于来自集群内部的请求，包括集群组件本身。例如，工作节点通过对API服务器的API调用与主节点上的控制平面通信。这与您在集群外部使用的API和API服务器相同。</p><p id="4c07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes可以通过这个API完全控制，所以很明显，对这个API的访问必须是安全的。这就是客户端身份验证的用武之地。</p><h2 id="2b3c" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">证明</h2><p id="e48d" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">从任何客户端到API服务器的每个请求都由API服务器进行身份验证。这适用于来自集群外部的请求(例如，来自您的本地机器)，也适用于来自集群内部的请求(例如，来自工作节点上的<code class="fe mt mu mv mw b">kubelet</code>)。身份验证机制在所有情况下都是相同的。</p><p id="db1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes提供了许多可以被API服务器使用的<strong class="js iu">认证方法</strong>。这些认证方法也被称为<em class="mg">认证模块</em>或<em class="mg">认证器</em>。</p><p id="9f4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从概念上来说，API服务器将每个接收到的请求传递给认证器，认证器将认证决定返回给API服务器(尽管有些认证器简单得就像静态的令牌列表，如果请求包含列表中的令牌，则请求被认证)。</p><p id="4908" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以同时使用多个授权码，在这种情况下，API服务器会按顺序查询它们。启动API服务器时，必须为API服务器配置所需的授权码。</p><p id="f32d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是所有可用认证方法的列表，如Kubernetes文档中的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" rel="noopener ugc nofollow" target="_blank">这里的</a>所述:</p><ul class=""><li id="e269" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> X509客户端证书</strong> </a></li><li id="4a42" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">静态令牌文件</strong> </a></li><li id="924a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#bootstrap-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">自举令牌</strong> </a></li><li id="883c" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-password-file" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">静态密码文件</strong> </a></li><li id="ff2b" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">服务账户令牌</strong> </a></li><li id="5339" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> OpenID连接令牌</strong> </a></li><li id="0ad0" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Webhook令牌认证</strong> </a></li><li id="0671" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">认证代理</strong> </a></li></ul><p id="4cd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，如果一个验证者可以验证一个请求，那么它会将该请求映射到Kubernetes系统内部的一个“主题”(让我们称之为Kubernetes用户)。这个Kubernetes用户是后续授权步骤的基础。</p><h2 id="44fb" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">授权</h2><p id="7bec" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">经过身份验证后，我们知道请求来自集群的有效用户。然而，每个请求都带有一个特定的<strong class="js iu"> Kubernetes动作</strong>(例如，<code class="fe mt mu mv mw b">get pods</code>或<code class="fe mt mu mv mw b">create deployment</code>)。集群的不同用户通常具有执行或不执行特定操作的不同特权。因此，我们需要检查请求的发送者是否有权执行所请求的操作。这就是授权的来源。</p><p id="b849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">授权步骤看起来非常类似于认证步骤。有许多可用的<strong class="js iu">授权方法</strong>(也称为<em class="mg">授权模块</em>或<em class="mg">授权者</em>)，您可以在创建API服务器时配置希望API服务器使用的方法。</p><p id="f38c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是Kubernetes文档中<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" rel="noopener ugc nofollow" target="_blank">这里</a>描述的可用授权方法列表:</p><ul class=""><li id="c350" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/node/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">节点授权</strong> </a></li><li id="9de1" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/abac/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">【基于属性的访问控制(ABAC) </strong> </a></li><li id="cc59" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">【RBAC】</strong></a></li><li id="224f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/webhook/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Webhook授权</strong> </a></li></ul><p id="1284" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">授权者的输入包括Kubernetes用户(由身份验证步骤返回)和该用户请求的Kubernetes操作。在对照其内部策略进行检查之后，授权者向API服务器返回一个允许/拒绝决定。</p><p id="9f0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">授权者和被授权者是相互独立的，它们是分开配置的。在<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/" rel="noopener ugc nofollow" target="_blank">这里</a>可以找到认证和授权的高级描述。</p><h1 id="14a2" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">EKS认证和授权</h1><p id="0de1" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">现在我们知道Kubernetes提供了什么样的认证和授权方法。EKS配置并启动API服务器以供使用，作为集群控制平面的一部分。那么EKS使用哪些认证者和授权者呢？</p><p id="a1d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简短的回答如下:</p><ul class=""><li id="7e11" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><strong class="js iu">认证:</strong> <a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> webhook令牌认证</strong> </a></li><li id="2d41" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><strong class="js iu">授权:</strong> <a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">基于角色的访问控制(RBAC) </strong> </a></li></ul><p id="2413" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">认证</strong>方法是高度特定于EKS的，这是本文的主题。简而言之，它与一个<strong class="js iu"> </strong> <a class="ae ko" href="https://tools.ietf.org/html/rfc6750" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">承载令牌</strong> </a>(包含在每个请求中)一起工作，该令牌由AWS提供的webhook服务在服务器端进行验证。关键的一点是，这个承载令牌包括AWS <strong class="js iu">身份和访问管理(IAM) </strong>身份，并且webhook服务的认证决定基于这个IAM身份。这意味着客户端使用IAM身份向EKS集群进行身份验证。您必须为webhook服务配置IAM标识，以便授予对集群的访问权限。本文将详细解释所有这些是如何工作的。</p><p id="ad8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在EKS，授权由RBAC授权人完成。它独立于认证系统，并以标准的Kubernetes方式完成。也就是说，在授权步骤中没有任何特定于EKS的内容。授权不是基于IAM身份，而是基于EKS认证者返回的标准Kubernetes用户。您为EKS集群配置RBAC授权器的方式与为任何其他Kubernetes集群配置授权器的方式相同(如何做，在<a class="ae ko" href="#8424" rel="noopener ugc nofollow">这一</a>部分有简要说明)。</p><p id="851e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文的剩余部分将讨论EKS认证机制，该机制分为<strong class="js iu">客户端部分</strong>和<strong class="js iu">服务器端部分</strong>。客户端部分定义了客户端如何生成承载令牌并将其包含在请求中，而服务器端部分定义了身份验证器如何验证该令牌。</p><p id="9000" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面我们就从服务器端部分开始(客户端部分这里是<a class="ae ko" href="#609a" rel="noopener ugc nofollow">这里是</a>)。</p><h1 id="b575" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">EKS认证:服务器端</h1><p id="7ede" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">下图说明了EKS身份验证机制的服务器端部分。为了完整起见，还包括授权步骤。</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi mx"><img src="../Images/a5770aad5b14d10cb3763a082a28ec60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQJZp8zc27jCkbJLaIVhZQ.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">EKS认证和授权(服务器端)。</figcaption></figure><p id="2fdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下小节解释了该系统的各个组件。</p><h2 id="7403" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">使用IAM身份验证</h2><p id="4aab" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">首先要注意的是，EKS使用<a class="ae ko" href="https://aws.amazon.com/iam/" rel="noopener ugc nofollow" target="_blank">身份和访问管理(IAM) </a>身份进行认证。IAM <a class="ae ko" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id.html" rel="noopener ugc nofollow" target="_blank">身份</a>可以是IAM <a class="ae ko" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html" rel="noopener ugc nofollow" target="_blank">用户</a>或IAM <a class="ae ko" href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html" rel="noopener ugc nofollow" target="_blank">角色</a>。</p><p id="f73e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，这意味着客户端包含在请求中的承载令牌必须包含IAM身份(以ARN的形式)。然后，服务器端的身份验证服务检查这个IAM身份是否对应于集群的有效用户。</p><p id="1d0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这个不记名令牌包含一个IAM身份，所以在上图中我称之为<em class="mg"> IAM身份令牌</em>。</p><p id="e27b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用IAM身份进行身份验证的EKS团队的想法是，不必为Kubernetes集群定义一组新的用户和凭证，而是重用现有的IAM身份。</p><h2 id="c7ca" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">AWS IAM验证器</h2><p id="40aa" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">如前所述，EKS的认证决定是由API服务器调用的webhook服务做出的。这个webhook服务是由一个叫做<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator" rel="noopener ugc nofollow" target="_blank"> AWS IAM Authenticator </a>的工具实现的。</p><p id="8806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS IAM Authenticator是一个开源项目，由Kubernetes特别兴趣小组(SIG)维护，在<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上维护。</p><blockquote class="nn no np"><p id="b2ae" class="jq jr mg js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">注意，相同的AWS IAM认证器工具也用于EKS认证机制的客户端部分，这将在这里<a class="ae ko" href="#609a" rel="noopener ugc nofollow">讨论</a>。事实上，您只能在客户端使用AWS IAM身份验证器，因为在服务器端，EKS会为您完成这项工作。</p></blockquote><p id="b944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS IAM认证器工具提供了可执行文件<code class="fe mt mu mv mw b">aws-iam-authenticator</code>，该文件提供了几个子命令。这些子命令之一如下:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="7036" class="mh le it mw b gy nx ny l nz oa">aws-iam-authenticator server</span></pre><p id="0e9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此命令启动EKS webhook身份验证服务。这意味着，当您创建EKS集群时，EKS会为您运行这个命令(可能在一个主节点上)，并配置API服务器使用提供的端点作为webhook令牌身份验证方法的目标。</p><p id="4bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，每当API服务器接收到请求时，它都会将请求中的IAM身份令牌转发给webhook服务。webhook服务首先使用AWS IAM服务验证包含的IAM标识是否是有效的IAM标识。</p><p id="2913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，webhook服务会咨询一个名为<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap的对象，检查IAM标识是否对应于集群的有效用户。<code class="fe mt mu mv mw b">aws-auth</code>配置映射对于服务器端认证机制至关重要，您必须在这里定义IAM身份，以便授予对集群的访问权限。所有这些将是下一节的主题。</p><h2 id="a7fb" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">AWS-授权配置映射</h2><p id="5503" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated"><code class="fe mt mu mv mw b">aws-auth</code> ConfigMap包含IAM身份到Kubernetes用户的映射。在这里，您必须定义谁和什么可以访问您的EKS集群。如何做到这一点将在后面解释，因为首先，我们应该知道什么是ConfigMap。</p><p id="e170" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">什么是配置图？</strong></p><p id="36b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配置映射是一个Kubernetes API对象。这意味着它是一个可以存在于集群中的对象，如<em class="mg"> Pod </em>或<em class="mg"> Deployment </em>。配置图对象的规格可以在这里<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#configmap-v1-core" rel="noopener ugc nofollow" target="_blank">找到。</a></p><p id="0fbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配置图具有非常简单的内部结构。它只是由一组<strong class="js iu">键/值对</strong>组成。所有键都是字符串，值可以是字符串或二进制数据。</p><p id="0b54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配置映射的目的是包含配置信息。它的作用类似于本地程序中的配置文件。配置图是为pod和系统组件创建和使用的。</p><p id="4c02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单配置图的YAML定义如下:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="154b" class="mh le it mw b gy nx ny l nz oa">kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>  name: my-configmap<br/>data:<br/>  key1: value1<br/>  key2: value2<br/>  key3: value3</span></pre><p id="5e4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，这个ConfigMap由三个键/值对组成，它们都是字符串。键/值对包含在<code class="fe mt mu mv mw b">data</code>字段中(也存在可以包含具有二进制数据值的键/值对的<code class="fe mt mu mv mw b">binaryData</code>字段)。</p><p id="3a28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与任何其他Kubernetes对象一样，您可以在集群中使用<code class="fe mt mu mv mw b">kubectl</code>创建这个配置映射，例如:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="7771" class="mh le it mw b gy nx ny l nz oa">kubectl apply -f configmap.yml</span></pre><p id="91e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">配置图现在存在于集群中，集群组件(例如，pods)可以通过您为其指定的名称(在本例中为<code class="fe mt mu mv mw b">my-configmap</code>)来访问它。</p><p id="a74b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以查看集群中的所有现有配置图，如下所示:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="b79e" class="mh le it mw b gy nx ny l nz oa">kubectl get configmaps --all-namespaces</span></pre><p id="3d86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe mt mu mv mw b"><strong class="js iu">aws-auth</strong></code><strong class="js iu">配置图</strong></p><p id="7df1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mt mu mv mw b">aws-auth</code>配置映射是一个名为<code class="fe mt mu mv mw b">aws-auth</code>的配置映射，它必须存在于每个EKS集群中(特别是在<code class="fe mt mu mv mw b">kube-system</code>名称空间中)。如前所述，它由AWS IAM Authenticator webhook服务读取，以读取应该被授权访问集群的IAM身份的列表。</p><p id="e426" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">EKS为您做了很多工作，但它没有为您创建<code class="fe mt mu mv mw b">aws-auth</code>配置图！您负责创建和维护该对象</p><p id="9789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果您按照<a class="ae ko" href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> EKS入门</em> </a>指南创建了EKS集群，那么您已经创建了此配置图！具体来说，在<a class="ae ko" href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html#eks-launch-workers" rel="noopener ugc nofollow" target="_blank">“启动工作节点”</a>步骤中，要求您将工作节点的IAM角色ARN插入到ConfigMap模板中，然后将该模板应用到集群。</p><p id="5a33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您必须修改的配置映射模板如下所示:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="e688" class="mh le it mw b gy nx ny l nz oa">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: aws-auth<br/>  namespace: kube-system<br/>data:<br/>  mapRoles: |<br/>    - rolearn: &lt;WorkerNodesRoleARN&gt;<br/>      username: system:node:{{EC2PrivateDNSName}}<br/>      groups:<br/>        - system:bootstrappers<br/>        - system:nodes</span></pre><p id="8bac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们更仔细地看看。</p><p id="c859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">格式</strong></p><p id="a3a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该配置图在<code class="fe mt mu mv mw b">data</code>字段中包含一个键/值对。不要被管道字符(<code class="fe mt mu mv mw b">|</code>)和看起来像是YAML文档的一部分的后续行所迷惑。<code class="fe mt mu mv mw b">|</code>是一个<a class="ae ko" href="https://yaml-multiline.info/" rel="noopener ugc nofollow" target="_blank"> YAML多行字符串</a>指示符，这意味着后面的所有内容都将被解释为一个单独的多行字符串。</p><p id="cd96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，该键被称为<code class="fe mt mu mv mw b">mapRoles</code>，其值是以下字符串:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="ac6c" class="mh le it mw b gy nx ny l nz oa">- rolearn: &lt;WorkerNodesRoleARN&gt;<br/>  username: system:node:{{EC2PrivateDNSName}}<br/>  groups:<br/>    - system:bootstrappers<br/>    - system:nodes</span></pre><p id="c029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个字符串(键和值)对Kubernetes来说没有任何意义。对于Kubernetes来说，它们只是一个键字符串和一个值字符串。但是，键和值对于AWS IAM认证器都有<em class="mg">的意义。</em></p><p id="8296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，这是AWS IAM认证器要求<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap数据采用的格式。此配置格式在AWS IAM认证器文档中的<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#full-configuration-format" rel="noopener ugc nofollow" target="_blank">处</a>处定义。</p><p id="3f98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">内容</strong></p><p id="dc05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，这个键/值对对AWS IAM认证器意味着什么呢？又来了:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="3d96" class="mh le it mw b gy nx ny l nz oa">mapRoles: |<br/>  - rolearn: &lt;WorkerNodesRoleARN&gt;<br/>    username: system:node:{{EC2PrivateDNSName}}<br/>    groups:<br/>      - system:bootstrappers<br/>      - system:nodes</span></pre><p id="129f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在AWS IAM认证器<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#full-configuration-format" rel="noopener ugc nofollow" target="_blank">配置格式规范</a>中，我们可以看到<code class="fe mt mu mv mw b">mapRoles</code>的每个条目都将一个IAM角色映射到一个用户名和一组组。</p><p id="31d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，应该被授予集群访问权限的每个IAM角色都必须有一个条目。映射的用户名和组定义了一个Kubernetes“主题”。该主题对认证系统没有意义，但它将是后续RBAC授权步骤的基础。这将在<a class="ae ko" href="#8424" rel="noopener ugc nofollow">后面的章节</a>中解释。</p><p id="24cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，worker nodes IAM角色被映射到组<code class="fe mt mu mv mw b">system:bootstrappers</code>和<code class="fe mt mu mv mw b">system:nodes</code>中名为<code class="fe mt mu mv mw b">system:node:&lt;DNSName&gt;</code>的“用户”(<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#full-configuration-format" rel="noopener ugc nofollow" target="_blank">配置格式规范</a>还定义了<code class="fe mt mu mv mw b">{{EC2PrivateDNSName}}</code>将被解析为发出请求的实例的DNS名称)。此用户名和组定义了RBAC授权者将允许此请求执行的操作。</p><p id="a1dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#full-configuration-format" rel="noopener ugc nofollow" target="_blank">规范</a>还定义了一个名为<code class="fe mt mu mv mw b">mapUsers</code>的键，用于为<em class="mg"> IAM用户</em>(而不是IAM角色)指定映射。下面将展示一个带有额外IAM用户和IAM角色的扩展<code class="fe mt mu mv mw b">aws-auth</code>配置图。</p><p id="d50a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们为什么要这么做？</strong></p><p id="5fac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么我们必须创建此配置图？<a class="ae ko" href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> EKS入门</em> </a>指南说，它使我们的工作节点能够加入集群。但是为什么呢？</p><p id="ea06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">表述这一点的另一种方式是，它首先使工作节点能够与API服务器“对话”。</p><p id="552c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遵循<em class="mg"> EKS入门</em>指南，我们创建了工人节点作为EC2自动缩放组。此时，它们还没有与集群相关联。为了作为工作节点添加到集群中，它们必须从API服务器请求(通过已经在其上运行的<code class="fe mt mu mv mw b">kubelet</code>)。如上所述，对API服务器的每个请求都必须包含一个IAM标识作为承载令牌。工作节点在其请求中包含的IAM身份是我们在创建过程中分配给工作节点的IAM角色。该角色在官方<a class="ae ko" href="https://amazon-eks.s3-us-west-2.amazonaws.com/cloudformation/2018-11-07/amazon-eks-nodegroup.yaml" rel="noopener ugc nofollow" target="_blank"> CloudFormation模板</a>中被称为<em class="mg"> NodeInstanceRole </em>，该模板在<em class="mg"> EKS入门</em>指南中使用。</p><p id="a351" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，到目前为止，这个IAM角色没有在<code class="fe mt mu mv mw b">aws-auth</code>配置图中列出，所以AWS IAM验证器没有验证来自工作节点的这些请求(实际上，到目前为止，<code class="fe mt mu mv mw b">aws-auth</code>配置图甚至还不存在)。</p><p id="fd94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将worker节点的IAM角色添加到<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap中，我们解决了这个问题，并最终使来自worker节点的请求由AWS IAM Authenticator进行身份验证。这允许工作节点最终与API服务器对话，并被添加到集群中。</p><p id="aa81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">一个扩展的</strong> <code class="fe mt mu mv mw b"><strong class="js iu">aws-auth</strong></code> <strong class="js iu">配置图</strong></p><p id="79aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在<code class="fe mt mu mv mw b">aws-auth</code>配置图中列出IAM worker nodes角色，我们实际上定义了第一个被允许与API服务器对话的“用户”。如果我们想要添加额外的集群用户，那么我们必须将他们作为新条目添加到<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap中。</p><p id="56c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，我编辑了<code class="fe mt mu mv mw b">aws-auth</code>配置图，以包含一个额外的IAM角色和IAM用户(以粗体突出显示):</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="ccac" class="mh le it mw b gy nx ny l nz oa">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: aws-auth<br/>  namespace: kube-system<br/>data:<br/>  mapRoles: |<br/>    - rolearn: &lt;WorkerNodesRoleARN&gt;<br/>      username: system:node:{{EC2PrivateDNSName}}<br/>      groups:<br/>        - system:bootstrappers<br/>        - system:nodes<br/><strong class="mw iu">    - rolearn: &lt;LambdaRoleARN&gt;<br/>      username: lambda<br/>      groups:<br/>        - system:masters<br/>  mapUsers: |<br/>    </strong><strong class="mw iu">- userarn: &lt;UserARN&gt;<br/>      username: user<br/>      groups:<br/>        - system:masters</strong></span></pre><p id="02d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我必须将IAM角色映射添加到已经存在的<code class="fe mt mu mv mw b">mapRoles</code>键的值中，并将IAM用户映射添加到单独的<code class="fe mt mu mv mw b">mapUsers</code>键中。所有这些都在AWS IAM Authenticator <a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#full-configuration-format" rel="noopener ugc nofollow" target="_blank">配置格式规范</a>中定义。</p><p id="6f56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我自由地为两个映射选择了一个用户名，并将它们与<code class="fe mt mu mv mw b">system:masters</code>组相关联，这是一个预定义的组，由RBAC授权者解释为允许对集群的完全访问(更多信息见下面的<a class="ae ko" href="#8424" rel="noopener ugc nofollow">)。</a></p><p id="7fc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如何编辑</strong> <code class="fe mt mu mv mw b"><strong class="js iu">aws-auth</strong></code> <strong class="js iu"> ConfigMap？</strong></p><p id="fdbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建完成后，您可以使用以下命令轻松编辑<code class="fe mt mu mv mw b">aws-auth</code>配置图:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="39f5" class="mh le it mw b gy nx ny l nz oa">kubectl edit -n kube-system configmap/aws-auth</span></pre><p id="f88c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您保存编辑过的文件时，您的更改将自动应用。</p><p id="3cfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集群创建者呢？</strong></p><p id="5af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建EKS集群的IAM身份自动“硬连接”在AWS IAM身份验证器中。这意味着该IAM身份由AWS IAM验证器识别和验证(并映射到<code class="fe mt mu mv mw b">system:masters</code>组中的用户),而不会在<code class="fe mt mu mv mw b">aws-auth</code>配置映射中列出。这就是为什么在创建EKS集群之后，您已经可以使用<code class="fe mt mu mv mw b">kubectl</code>访问集群，而无需进行任何配置(如果您对<code class="fe mt mu mv mw b">kubectl</code>使用相同的IAM身份)。但是，您想要授予对集群的访问权限的任何其他IAM身份，您必须在<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap中显式配置。</p><h2 id="8424" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">授权</h2><p id="285b" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap中，我们定义了从IAM身份到“用户名”和“组”的映射。这些用户名和用户组定义了所谓的“主题”,这是成功认证后为每个请求执行的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC授权</a>步骤的基础。</p><p id="643d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，授权系统由定义谁能做什么的<em class="mg">政策</em>驱动。对于Kubernetes RBAC授权，这些策略由一组名为<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#role-v1-rbac-authorization-k8s-io" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> Role </em> </a>和<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#rolebinding-v1-rbac-authorization-k8s-io" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> RoleBinding </em> </a>的Kubernetes API对象指定(还有<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#clusterrole-v1-rbac-authorization-k8s-io" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> ClusterRole </em> </a>和<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/#clusterrolebinding-v1-rbac-authorization-k8s-io" rel="noopener ugc nofollow" target="_blank"><em class="mg">ClusterRole binding</em></a>，它们具有集群作用域而不是名称空间作用域)。这些对象必须专门为RBAC授权人创建，并且只能由RBAC授权人使用。</p><p id="7dc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，一个<strong class="js iu">角色</strong>由一个或多个<strong class="js iu">规则</strong>组成。每个规则都定义了一组允许的Kubernetes操作(例如，<code class="fe mt mu mv mw b">get pods</code>)。一个<strong class="js iu">角色绑定</strong>将一个角色绑定到一个或多个<strong class="js iu">主题</strong>。并且主题可以是<strong class="js iu">用户名</strong>或<strong class="js iu">组</strong>。</p><p id="12bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果在<code class="fe mt mu mv mw b">aws-auth</code> ConfigMap中，您定义了一个特定的IAM身份映射到组<code class="fe mt mu mv mw b">group</code>中的用户名<code class="fe mt mu mv mw b">user</code>，那么如果请求的Kubernetes操作在某个角色中列出，并且该角色(通过角色绑定)绑定到用户名<code class="fe mt mu mv mw b">user</code>或组<code class="fe mt mu mv mw b">group</code>，那么RBAC授权者将允许该请求。</p><p id="89b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在上一节中，我们定义了从IAM用户到<code class="fe mt mu mv mw b">system:masters</code>组中的用户的映射。<code class="fe mt mu mv mw b">system:masters</code>组是默认组。还有一个RBAC默认角色叫做<code class="fe mt mu mv mw b">cluster-admin</code>，它允许所有可能的Kubernetes动作。此外，还存在一个默认的角色绑定<em class="mg"> </em>，它将<code class="fe mt mu mv mw b">cluster-admin</code>角色绑定到<code class="fe mt mu mv mw b">system:masters</code>组。因此，当RBAC授权者处理来自这个用户的请求时，它应用<code class="fe mt mu mv mw b">cluster-admin</code>角色，因为这个角色被绑定到<code class="fe mt mu mv mw b">system:masters</code>组。</p><p id="cf7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这与非默认用户名和组(即您自己选择的用户名和组名)完全相同，但在这种情况下，您必须定义并创建自己的自定义<em class="mg">角色</em>和<em class="mg">角色绑定</em> ( <em class="mg"> ClusterRole </em>和<em class="mg"> ClusterRoleBinding </em>)对象。一旦您创建了这些对象，它们将被RBAC授权者考虑用于所有后续请求。</p><p id="3926" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以像创建任何其他Kubernetes API对象一样创建这些对象，方法是根据YAML文件中的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.12/" rel="noopener ugc nofollow" target="_blank">规范</a>定义它们，然后用<code class="fe mt mu mv mw b">kubectl apply</code>应用它们。关于创建角色和角色绑定的指南可以分别在<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="be10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，您可以为用户名和组选择任何字符串，但是前缀<code class="fe mt mu mv mw b">system:</code>是为Kubernetes系统保留的。</p><p id="9fda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令查看集群中所有现有的角色和角色绑定:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="64c3" class="mh le it mw b gy nx ny l nz oa">kubectl get roles --all-namespaces<br/>kubectl get clusterroles<br/>kubectl get rolebindings --all-namespaces<br/>kubectl get clusterrolebindings</span></pre><p id="e1f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以查看特定角色或角色绑定的内容，如下所示:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="50a3" class="mh le it mw b gy nx ny l nz oa">kubectl describe clusterrole cluster-admin<br/>kubectl describe clusterrolebinding cluster-admin</span></pre><p id="d14e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，认证和授权是独立的系统，但它们是协同工作的。IAM认证器的输出是RBAC授权器的输入。您可以在authenticator中定义任何用户名和组，但是您必须在authoriser中为它们赋予意义。</p><p id="95ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们对服务器端EKS认证机制的讨论到此结束。现在让我们来看看客户端部分。</p><h1 id="609a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">EKS身份验证:客户端</h1><p id="3d59" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">正如我们所看到的，EKS身份验证机制要求所有发送到API服务器的请求都在一个承载令牌中包含一个IAM标识。在服务器端部分，我们已经讨论了如何在服务器端验证这个令牌。现在，在客户端部分，我们将讨论客户端如何获取IAM身份并生成这样的令牌。</p><p id="4543" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下图总结了整个过程。请注意，该过程适用于所有类型的客户端，无论是您的本地计算机、EC2实例、Lambda函数还是集群中的工作节点:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ob"><img src="../Images/74a0115bd2c251d3560a5774e1d317ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8rXK8rR0J3IEaYWBd_cqA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">EKS客户端身份验证(客户端)。</figcaption></figure><p id="6c0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下小节将解释该过程的所有主要组成部分。</p><h2 id="108d" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">Kubernetes客户端库</h2><p id="7d01" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">上图的中心是一个Kubernetes客户端库。<a class="ae ko" href="https://kubernetes.io/docs/reference/using-api/client-libraries/" rel="noopener ugc nofollow" target="_blank"> Kubernetes客户端库</a>将Kubernetes API调用的HTTP请求包装成可以从代码中调用的函数。这允许对Kubernetes进行编程访问(也就是说，您可以编写一个程序来做您可以用<code class="fe mt mu mv mw b">kubectl</code>做的所有事情)。</p><p id="88fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，像<code class="fe mt mu mv mw b">kubectl</code>和<code class="fe mt mu mv mw b">kubelet</code>这样的工具只不过是通过客户端库访问Kubernetes的程序(并且<code class="fe mt mu mv mw b">kubectl</code>为您提供了一个很好的命令行界面，通过它您可以调用单独的API请求)。因此，我们可以说，对API服务器的每个请求都是通过Kubernetes客户端库发出的(除非您通过原始HTTP调用访问API服务器，但是我们可以忽略这一点)。</p><p id="a823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多官方支持的不同编程语言的Kubernetes客户端库。它们都托管在以下GitHub组织中:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="f1dd" class="mh le it mw b gy nx ny l nz oa"><a class="ae ko" href="https://github.com/kubernetes-client" rel="noopener ugc nofollow" target="_blank"><strong class="mw iu">https://github.com/kubernetes-client</strong></a></span></pre><p id="4852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有一个非常重要的Kubernetes客户端库，即官方的Kubernetes <strong class="js iu"> Go客户端库</strong>。它托管在以下GitHub存储库中:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="03d9" class="mh le it mw b gy nx ny l nz oa"><a class="ae ko" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"><strong class="mw iu">https://github.com/kubernetes/client-go</strong></a></span></pre><p id="ff37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go客户端库很重要，因为它是官方Kubernetes工具使用的库，比如<code class="fe mt mu mv mw b">kubectl</code>和<code class="fe mt mu mv mw b">kubelet</code>(但是你也可以在自己的程序中使用它)。如果有新的Kubernetes特性，这个库通常会首先实现它们)。</p><h2 id="f922" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">kubeconfig文件</h2><p id="9a68" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">所有Kubernetes客户端库从哪里获得集群信息？，比如API服务器的URL？答案来自一个<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/" rel="noopener ugc nofollow" target="_blank"> <em class="mg"> kubeconfig </em> </a>文件。在使用Kubernetes客户端库时，通常要做的第一件事就是读取一个<em class="mg"> kubeconfig </em>文件。</p><p id="f785" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<em class="mg"> kubeconfig </em>文件是用于Kubernetes集群访问的YAML配置文件。默认的<em class="mg"> kubeconfig </em>文件是<code class="fe mt mu mv mw b">~/.kube/config</code>，但是<em class="mg"> kubeconfig </em>文件可以有任何名称，并且可以有多个。</p><blockquote class="nn no np"><p id="9a4d" class="jq jr mg js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">请注意，创建EKS集群后，可以使用以下命令自动创建或更新kubeconfig文件:</p><p id="8ca5" class="jq jr mg js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated"><code class="fe mt mu mv mw b"><em class="it">aws eks update-kubeconfig --name &lt;ClusterName&gt;</em></code></p></blockquote><p id="64a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes文档中的<em class="mg"> kubeconfig </em>文件的语法格式在这里<a class="ae ko" href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" rel="noopener ugc nofollow" target="_blank">有所描述。简而言之，一个<em class="mg"> kubeconfig </em>文件包含三条主要信息:</a></p><ul class=""><li id="9d1e" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><strong class="js iu">集群</strong></li><li id="e11b" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><strong class="js iu">语境</strong></li><li id="ede6" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><strong class="js iu">用户</strong></li></ul><p id="7ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集群</strong>部分包含两条强制信息:(<em class="mg">1)</em>API服务器URL，以及<em class="mg">(2)</em>API服务器认证机构(CA)证书。客户端使用CA证书来验证服务器证书，即验证API服务器的身份(这是服务器认证，与本文的主题客户端认证相反)。</p><p id="de54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了便于参考，<strong class="js iu">上下文</strong>部分定义了集群、名称空间和用户的三元组。</p><p id="79df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，<strong class="js iu">用户</strong>部分定义了<strong class="js iu">凭证</strong>，用于向API服务器进行认证。对于EKS集群，<em class="mg"> users </em>部分必须采用特定的格式，这将在下一部分描述。</p><h2 id="e62f" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">凭据插件功能</h2><p id="2314" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">首先，让我们看看EKS集群的<em class="mg"> kubeconfig </em>文件<em class="mg">用户</em>部分是什么样子的:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="46ec" class="mh le it mw b gy nx ny l nz oa">users:<br/>  - name: &lt;ClusterARN&gt;<br/>    user:<br/>      exec:<br/>        apiVersion: client.authentication.k8s.io/v1alpha1<br/>        command: aws-iam-authenticator<br/>        args:<br/>          - token<br/>          - -i<br/>          - &lt;ClusterName&gt;</span></pre><p id="c93c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最关键的一点是<code class="fe mt mu mv mw b">exec</code>的财产。这个属性是由Go客户端库的一个名为<em class="mg">凭证插件</em>的特性提供的，这里的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins" rel="noopener ugc nofollow" target="_blank">对其进行了描述</a>。</p><p id="7707" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mt mu mv mw b">exec</code>属性允许定义一个生成并返回凭证的外部命令。返回的凭证可以是两种形式中的一种:不记名令牌或私钥和证书(这在这里的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#input-and-output-formats" rel="noopener ugc nofollow" target="_blank">中解释</a>)。</p><p id="d4c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">凭证插件特性必须由Kubernetes客户端库实现，因为客户端库读取<em class="mg"> kubeconfig </em>文件，并且必须“理解】属性。也是客户端库执行外部命令，然后读取命令的输出值。</p><blockquote class="nn no np"><p id="3e70" class="jq jr mg js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">注意“凭证插件”是一个相对较新的特性(Kubernetes v1.10)，目前并不是所有的Kubernetes客户端库都实现了它。官方的Go客户端库实现了它，由于<code class="fe mt mu mv mw b">kubectl</code>和<code class="fe mt mu mv mw b">kubelet</code>使用Go客户端库，你也可以通过这些工具使用这个特性。但是，对于其他客户端库，您需要检查它们是否已经支持它。</p></blockquote><p id="7710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于EKS集群，外部的<code class="fe mt mu mv mw b">exec</code>命令如下:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="5869" class="mh le it mw b gy nx ny l nz oa">aws-iam-authenticator token -i &lt;ClusterName&gt;</span></pre><p id="51f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们执行这个命令，看看它能做什么。输出如下所示:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="1ed0" class="mh le it mw b gy nx ny l nz oa">{<br/>  "kind": "ExecCredential",<br/>  "apiVersion": "client.authentication.k8s.io/v1alpha1",<br/>  "status": {<br/>    "token": &lt;TOKEN&gt;<br/>  }<br/>}</span></pre><p id="59f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令打印一些JSON。这个JSON的格式是由凭证插件特性指定的(参见这里的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#input-and-output-formats" rel="noopener ugc nofollow" target="_blank"/>)。最重要的部分是<code class="fe mt mu mv mw b">token</code>的财产。这是必须包含在API服务器请求中的承载令牌，并且是针对API服务器的认证的基础。</p><p id="6af4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一节解释该命令如何生成这个令牌。</p><h2 id="06c4" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">客户端的AWS IAM身份验证器</h2><p id="53ac" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">您可能已经注意到，上面的<code class="fe mt mu mv mw b">exec</code>命令是由已经在服务器端使用的同一个<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator" rel="noopener ugc nofollow" target="_blank"> AWS IAM Authenticator </a>工具提供的。下面是客户端命令:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="9001" class="mh le it mw b gy nx ny l nz oa">aws-iam-authenticator token -i &lt;ClusterName&gt;</span></pre><p id="9e6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与服务器端的区别在于使用了<code class="fe mt mu mv mw b">token</code>子命令，而不是<code class="fe mt mu mv mw b">server</code>子命令。</p><p id="044d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所述，生成的令牌必须包含一个IAM标识。但是，我们不能在输出中直接看到它，因为令牌被编码为符合HTTP格式要求。幸运的是，AWS IAM Authenticator还提供了另一个解码令牌的子命令:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="9068" class="mh le it mw b gy nx ny l nz oa">aws-iam-authenticator verify -i &lt;ClusterName&gt; -t &lt;TOKEN&gt;</span></pre><p id="9d01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个命令打印一个<a class="ae ko" href="https://tour.golang.org/moretypes/2" rel="noopener ugc nofollow" target="_blank"> Go结构</a>(因为AWS IAM Authenticator是用Go编写的)，它包含在令牌中编码的IAM身份的ARN。</p><blockquote class="nn no np"><p id="9c26" class="jq jr mg js b jt ju jv jw jx jy jz ka nq kc kd ke nr kg kh ki ns kk kl km kn im bi translated">请注意，<code class="fe mt mu mv mw b">-i</code>值可以是任何字符串，但是对于<code class="fe mt mu mv mw b">token</code>和<code class="fe mt mu mv mw b">verify</code>子命令必须是相同的(此处解释了<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#what-is-a-cluster-id" rel="noopener ugc nofollow" target="_blank">，并且令牌在15分钟后过期(<code class="fe mt mu mv mw b">verify</code>子命令将在此时间后失效)。</a></p></blockquote><p id="5842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在最大的问题是:这个命令从哪里获得IAM标识？</p><p id="9e1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">哪个IAM身份？</strong></p><p id="cea4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是，在主机系统上配置的AWS <strong class="js iu">凭证链</strong>中遇到的第一个IAM身份。此处详细解释了AWS凭证链<a class="ae ko" href="https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials" rel="noopener ugc nofollow" target="_blank">。简而言之，它是由AWS工具和SDK检查IAM身份的位置序列。默认凭据链如下:</a></p><ol class=""><li id="7690" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn oc kv kw kx bi translated"><code class="fe mt mu mv mw b">AWS_ACCESS_KEY_ID</code>、<code class="fe mt mu mv mw b">AWS_SECRET_ACCESS_KEY</code>和<code class="fe mt mu mv mw b">AWS_PROFILE</code>环境变量</li><li id="80b6" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn oc kv kw kx bi translated"><code class="fe mt mu mv mw b">~/.aws/credentials</code>文件</li><li id="d521" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn oc kv kw kx bi translated">如果主机是EC2实例或Lambda函数，则分配IAM角色</li></ol><p id="e4b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mt mu mv mw b">aws-iam-authenticator token</code>命令使用相同的凭证链来确定要包含在令牌中的IAM身份。通过执行以下AWS CLI命令，您可以随时检查这是哪个IAM标识:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="d3eb" class="mh le it mw b gy nx ny l nz oa">aws sts get-caller-identity</span></pre><p id="92da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这已经结束了我们对EKS认证机制的客户端部分的探索。如上所述，在执行了<code class="fe mt mu mv mw b">aws-iam-authenticator token</code>命令之后，客户端库读取生成的令牌，并将其作为承载令牌包含在对API服务器的请求中。</p><h2 id="5036" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">客户端身份验证成分</h2><p id="b709" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我提到过身份验证机制的客户端部分总是相同的，不管请求来自哪里。让我们通过考虑一些示例场景来深入了解这一点。</p><p id="83a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下列表总结了客户端环境中需要存在的组件，以便能够向API服务器发出请求:</p><ul class=""><li id="6d97" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">Kubernetes客户端库或工具(例如<code class="fe mt mu mv mw b">kubectl</code>或<code class="fe mt mu mv mw b">kubelet</code>)</li><li id="70e4" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><em class="mg"> kubeconfig </em>文件</li><li id="5b3a" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><code class="fe mt mu mv mw b">aws-iam-authenticator</code>可执行</li><li id="2d0b" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">IAM身份</li></ul><p id="417e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看不同示例主机上的一些场景:一台本地机器、一个EC2实例、一个Lambda函数和集群中的一个EKS工作节点。</p><p id="d5de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">本地机器</strong></p><p id="0507" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的本地机器上，您很可能已经安装了<code class="fe mt mu mv mw b">kubectl</code>。要访问EKS集群，您必须更新您的<em class="mg"> kubeconfig </em>文件，您可以使用以下命令来完成:</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="6870" class="mh le it mw b gy nx ny l nz oa">aws eks update-kubeconfig --name &lt;ClusterName&gt;</span></pre><p id="f25a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要安装<code class="fe mt mu mv mw b">aws-iam-auhenticator</code>，您可以使用下面的命令来完成(参见此处的<a class="ae ko" href="https://github.com/kubernetes-sigs/aws-iam-authenticator#4-set-up-kubectl-to-use-authentication-tokens-provided-by-aws-iam-authenticator-for-kubernetes" rel="noopener ugc nofollow" target="_blank"/>):</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="fce3" class="mh le it mw b gy nx ny l nz oa">go get -u github.com/kubernetes-sigs/aws-iam-authenticator/cmd/aws-iam-authenticator</span></pre><p id="1d68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，在凭证链中必须有一个IAM身份，这可能是您在<code class="fe mt mu mv mw b">~/.aws/credentials</code>文件中的主要IAM用户。</p><p id="9bde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> EC2实例</strong></p><p id="cedc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想从EC2实例访问EKS集群，很可能您想以编程方式访问集群(也就是说，部署一个访问集群的程序)。在这种情况下，您不需要<code class="fe mt mu mv mw b">kubectl</code>，而是需要一个Kubernetes客户端库。通常通过将该库指定为主程序的依赖项来将它包含在程序中。</p><p id="bdc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要创建一个<em class="mg"> kubeconfig </em>文件，并在EC2实例上安装AWS IAM Authenticator可执行文件，这可以使用上面显示的相同命令来完成。</p><p id="d529" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您为EC2实例分配了一个IAM角色，那么这个角色将被<code class="fe mt mu mv mw b">aws-iam-authenticator token</code>命令使用。如果EC2实例没有IAM角色，那么您必须指定一个IAM身份，或者作为一个环境变量，或者通过在EC2实例上创建一个<code class="fe mt mu mv mw b">~/.aws/credentials</code>文件。</p><p id="3d2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">λ函数</strong></p><p id="81fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个场景中，您将创建一个Lambda函数来访问您的EKS集群。由于对Kubernetes的访问是编程式的，所以您也不需要<code class="fe mt mu mv mw b">kubectl</code>，而是需要一个客户端库，您将它指定为Lambda函数代码的依赖项。</p><p id="e95f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Lambda函数需要在运行时在其文件系统中有一个<em class="mg"> kubeconfig </em>文件和<code class="fe mt mu mv mw b">aws-iam-authenticator</code>可执行文件。你可以将这些文件添加到artefact文件夹中，然后通过<code class="fe mt mu mv mw b">aws cloudformation package</code>命令压缩并上传到S3(如果你使用CloudFormation)。每次调用Lambda函数时，文件将从这个位置部署到该函数的运行时环境中。</p><p id="47e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，因为您必须将<code class="fe mt mu mv mw b">aws-iam-authenticator</code>作为二进制文件提供给Lambda函数，所以它需要针对Lambda函数使用的目标平台进行编译。幸运的是，AWS IAM Authenticator是用Go编写的，你可以很容易地交叉编译它。为了编译Lambda使用的Linux目标平台，可以设置变量<code class="fe mt mu mv mw b">GOARCH=amd64</code>和<code class="fe mt mu mv mw b">GOOS=linux</code>，然后用<code class="fe mt mu mv mw b">go build</code>编译源代码。</p><p id="a9f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个Lambda函数需要有一个IAM角色，默认情况下，<code class="fe mt mu mv mw b">aws-iam-authenticator</code>将使用这个角色来生成认证令牌。</p><p id="0345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> EKS职工节点</strong></p><p id="d463" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于EKS集群中的一个工作者节点(使用官方的<a class="ae ko" href="https://amazon-eks.s3-us-west-2.amazonaws.com/cloudformation/2018-11-07/amazon-eks-nodegroup.yaml" rel="noopener ugc nofollow" target="_blank"> CloudFormation模板</a>创建)来说，所有的需求都已经存在(这实际上是它们能够加入集群的原因)。因为这是一个有趣的主题，所以让我们在下一节中更详细地检查一个worker节点。</p><h2 id="1638" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated"><strong class="ak">检查工人节点</strong></h2><p id="0521" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">使用SSH登录到现有EKS集群的一个工作节点(注意，要实现这一点，您可能需要添加一个入站规则，允许SSH流量进入工作节点的安全组):</p><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="f25c" class="mh le it mw b gy nx ny l nz oa">ssh -i my-key.pem ec2-user@XXXX.compute.amazonaws.com</span></pre><p id="beba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">登录后，您可以检查所有客户端身份验证组件是否都在:</p><ul class=""><li id="d764" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">确认<code class="fe mt mu mv mw b">kubelet</code>已安装:</li></ul><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="a6df" class="mh le it mw b gy nx ny l nz oa">kubelet --version</span></pre><ul class=""><li id="4477" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">参见<code class="fe mt mu mv mw b">kubelet</code>使用的<em class="mg"> kubeconfig </em>文件:</li></ul><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="2ae2" class="mh le it mw b gy nx ny l nz oa">cat /var/lib/kubelet/kubeconfig</span></pre><ul class=""><li id="9caa" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">确认<code class="fe mt mu mv mw b">aws-iam-authenticator</code>已安装:</li></ul><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="fdd2" class="mh le it mw b gy nx ny l nz oa">aws-iam-authenticator --help</span></pre><ul class=""><li id="9697" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">查看<code class="fe mt mu mv mw b">aws-iam-authenticator</code>使用的IAM身份:</li></ul><pre class="my mz na nb gt nt mw nu nv aw nw bi"><span id="2884" class="mh le it mw b gy nx ny l nz oa">aws sts get-caller-identity</span></pre><p id="2c02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，一切都在那里，看起来与您本地机器上的相似。重点是展示EKS身份验证的客户端部分对于任何类型的客户端都是一样的，不管它是您的本地机器、EC2实例、Lambda函数还是集群中的工作节点。</p><p id="632b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望阅读这篇文章能让您很好地理解客户端身份验证在EKS上是如何工作的。如果你对EKS认证有任何疑问，请在评论中告诉我。</p></div></div>    
</body>
</html>