<html>
<head>
<title>The Practical Testing Strategy of Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端的实用测试策略</h1>
<blockquote>原文：<a href="https://itnext.io/the-practical-testing-strategy-of-frontend-dd3c93027739?source=collection_archive---------2-----------------------#2022-09-25">https://itnext.io/the-practical-testing-strategy-of-frontend-dd3c93027739?source=collection_archive---------2-----------------------#2022-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/c8a0102b0b3270f268b700ea54b9c88c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*4mcRyTp5iWT2DgUWJ8PokA.png"/></div></figure><p id="c25c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每个人都知道编写测试非常重要，因为从长远来看，它可以加速开发。在任何应用程序中，你都会面临一个突破性的变化。没有测试，你唯一能做的就是害怕。</p><p id="e247" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最近，因为前端测试工具已经成熟，你也可以在前端编写合适的测试。然而，我遇到许多人放弃在前端编写测试，因为它只是耗费时间。</p><p id="ae68" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，本文总结了我的总体测试策略，并解释了每个测试的细节。</p><h1 id="cd3c" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">4层测试</h1><p id="f5ed" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">首先，我的策略受到Kent C.Dodds的<a class="ae ly" href="https://testingjavascript.com/" rel="noopener ugc nofollow" target="_blank">测试奖杯</a>的强烈影响，我从中学到了很多，并安排了我的项目。</p><p id="aa5a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如测试奖杯介绍，有如下4层前端测试。</p><figure class="ma mb mc md gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi lz"><img src="../Images/833c631ac50488b7adb6b37af936e9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWIR5bBQGvR6-QJxk6kAhg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">ref:<a class="ae ly" href="https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications" rel="noopener ugc nofollow" target="_blank">https://kentcdodds . com/blog/the-testing-trophy-and-testing-classifications</a></figcaption></figure><p id="5fcf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一般来说，你挑的越高，成本就越高。这意味着仅仅编写E2E测试是不实际的。因此，您必须将一些测试角色委派给适当的测试层。</p><p id="fbd0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，许多软件工程师刚刚开始编写测试。它导致了你的测试彼此相似的情况。例如，即使单元测试对按钮文本进行测试，E2E和集成测试也会测试按钮文本。</p><p id="f044" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这种情况下，很自然地会认为编写测试很耗时，因为您编写了很多类似的测试，而且这不会增加可靠性。</p><p id="86c4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是为什么测试策略对于前端来说超级重要。具体来说，你必须明确每一层的测试角色。如果你明确了每一层应该测试什么，你甚至可以在前端编写更有效的测试。</p><h1 id="f9fb" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">测试策略</h1><p id="46e1" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">正如我上面所说的，测试策略意味着明确在每一层测试中应该测试什么。这里，我使用一个电子商务应用程序作为例子。</p><h2 id="b226" class="mm kw it bd kx mn mo dn lb mp mq dp lf ki mr ms lj km mt mu ln kq mv mw lr mx bi translated">E2E</h2><ul class=""><li id="df63" class="my mz it jz b ka lt ke lu ki na km nb kq nc ku nd ne nf ng bi translated">应该测试什么？？</li></ul><p id="a425" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它测试通常依赖于多个页面的关键用户场景。例如，用户应该添加一件t恤到购物车并购买它。这一层不关心您的应用程序是如何实现的。</p><ul class=""><li id="eac3" class="my mz it jz b ka kb ke kf ki nh km ni kq nj ku nd ne nf ng bi translated">哪些是不应该测试的？？</li></ul><p id="c819" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有两件事。第一个是你不应该测试外表。例如，您不应该检查产品列表页面中的表头文本，因为在单元测试中编写可视化测试更有效。</p><p id="b143" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此外，您不应该测试不重要的逻辑分支。比如不要写<code class="fe nk nl nm nn b">without a stock, T-Shirt should not be added to a shopping cart</code>这样的测试。</p><p id="639d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我知道你想说什么。上面的场景仍然很关键，不是吗？在这里，<code class="fe nk nl nm nn b">critical</code>确实是取决于一个团队和阶段的应用。如果应用程序还不成熟，需要更快的速度，我会在集成测试中测试这个逻辑分支。但这应该在你的团队中讨论。</p><h2 id="b39f" class="mm kw it bd kx mn mo dn lb mp mq dp lf ki mr ms lj km mt mu ln kq mv mw lr mx bi translated">综合</h2><ul class=""><li id="7659" class="my mz it jz b ka lt ke lu ki na km nb kq nc ku nd ne nf ng bi translated">应该测试什么？？</li></ul><p id="0e28" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它测试容器组件的用户场景。因为容器组件是依赖注入层，有很多逻辑，这是一个很好的集成测试点。</p><p id="3b67" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">与E2E测试不同，集成测试应该覆盖逻辑分支。这里的逻辑分支主要指来自API请求结果和状态管理(比如redux和vuex)。</p><p id="6534" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们考虑付款方式。我肯定会用API请求的成功和失败模式来编写测试。所以API应该在集成测试中被嘲笑。此外，我会编写类似于<code class="fe nk nl nm nn b">should not submit payment with validation errors</code>的测试。对于这种测试，您应该提前模拟验证错误状态。</p><p id="b1f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请阅读<a class="ae ly" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表示和容器组件模式</a>并在你不知道的情况下使用它。</p><ul class=""><li id="4aec" class="my mz it jz b ka kb ke kf ki nh km ni kq nj ku nd ne nf ng bi translated">哪些是不应该测试的？？</li></ul><p id="8daf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">集成测试不应该覆盖表象的东西。所以它不应该测试视觉上的东西，因为容器组件对外观没有责任。</p><p id="dfbb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你在不同文件中分离钩子逻辑，我建议不要在钩子中测试逻辑。例如，如果你有如下的钩子，你不应该测试<code class="fe nk nl nm nn b">someConditionA false</code>模式，因为它应该包含在钩子单元测试中。</p><pre class="ma mb mc md gt no nn np nq aw nr bi"><span id="9d15" class="mm kw it nn b gy ns nt l nu nv">// hooks.ts</span><span id="4b6e" class="mm kw it nn b gy nw nt l nu nv">const useForm = () =&gt; {<br/>  const handleSubmit = useCallback((product) =&gt; {<br/>    if(someConditionA){<br/>      dispatch(callAPI({}))<br/>    }<br/>  })<br/>}</span></pre><h2 id="1210" class="mm kw it bd kx mn mo dn lb mp mq dp lf ki mr ms lj km mt mu ln kq mv mw lr mx bi translated">单位</h2><ul class=""><li id="7d14" class="my mz it jz b ka lt ke lu ki na km nb kq nc ku nd ne nf ng bi translated">应该测试什么？？</li></ul><p id="fbcb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它测试每个模块。因为模块类型实际上取决于应用程序，所以我分享我的基本单元测试。</p><ol class=""><li id="8c1f" class="my mz it jz b ka kb ke kf ki nh km ni kq nj ku nx ne nf ng bi translated">表象成分<br/>有2种测试。首先，用通过的道具出场。它包括固定文本测试。所以它可能看起来像<code class="fe nk nl nm nn b">should show product table</code>。其次，I测试回调应该设置在适当的地方。所以它看起来像<code class="fe nk nl nm nn b">should fire handleChange when submit button is clicked</code>。<br/>在这一层应该嘲讽所有的道具，但是子组件不应该被嘲讽。</li><li id="3270" class="my mz it jz b ka ny ke nz ki oa km ob kq oc ku nx ne nf ng bi translated">钩子<br/>钩子表示容器组件中使用的实际逻辑块。如果用Vue，和composition API差不多。所以请把这一节当做composition API来读。<br/>测试逻辑。如果你有<code class="fe nk nl nm nn b">if</code>条件，你应该在钩子层测试。如果您将<code class="fe nk nl nm nn b">useEffect</code>与React一起使用，您应该测试回调何时被触发以及发生了什么。</li><li id="cdd2" class="my mz it jz b ka ny ke nz ki oa km ob kq oc ku nx ne nf ng bi translated">Redux logics(如果有)<br/>我用reducer，selector，thunk写一个测试。</li><li id="9337" class="my mz it jz b ka ny ke nz ki oa km ob kq oc ku nx ne nf ng bi translated">其他实用逻辑</li></ol><h2 id="ca2e" class="mm kw it bd kx mn mo dn lb mp mq dp lf ki mr ms lj km mt mu ln kq mv mw lr mx bi translated">静态</h2><p id="fb7f" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">这一层应该用TypeScript和ESLint实现自动化。所以您应该做的只是检查CI中的类型错误和lint错误。如果你想签入提交，你可以引入像husky这样的工具。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="afbe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本文介绍了前端的实用测试策略。为了解释，我首先解释了测试的种类。之后，它明确了每一个类别中应该测试什么样的东西。</p><h1 id="14f4" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">参考</h1><ul class=""><li id="1e9d" class="my mz it jz b ka lt ke lu ki na km nb kq nc ku nd ne nf ng bi translated">了解测试任何JavaScript应用程序的智能、高效的方法。</li><li id="2021" class="my mz it jz b ka ny ke nz ki oa km ob kq oc ku nd ne nf ng bi translated"><a class="ae ly" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表象和容器组件</a></li></ul></div></div>    
</body>
</html>