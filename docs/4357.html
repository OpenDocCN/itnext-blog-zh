<html>
<head>
<title>Node.js: Validate the Conformity of a Configuration File at Runtime with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js:在运行时验证配置文件与TypeScript的一致性</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-validate-the-conformity-of-a-configuration-file-at-runtime-with-typescript-d117134100b2?source=collection_archive---------6-----------------------#2020-06-14">https://itnext.io/node-js-validate-the-conformity-of-a-configuration-file-at-runtime-with-typescript-d117134100b2?source=collection_archive---------6-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b8046e1d7271f99400b3902ea83d10d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XVbiCGk4TSAqOPY4L0If6g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">感谢<a class="ae kf" href="https://www.goodfreephotos.com/united-states/washington/northern-cascades-national-park/sahale-at-north-cascades-np-in-wa-landscape.jpg.php" rel="noopener ugc nofollow" target="_blank">好的免费照片</a>。</figcaption></figure><p id="0406" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我将展示一种在运行时验证任何现有项目中JSON配置文件一致性的方法。在<a class="ae kf" href="https://www.npmjs.com/package/typeonly" rel="noopener ugc nofollow" target="_blank"> TypeOnly </a>的帮助下，我们将能够使用我们自己的配置类型的类型脚本定义。</p><h1 id="0255" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们从一个JSON配置文件开始</h1><p id="4366" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">假设我们有一个Node.js项目。在主目录下，TypeScript源文件在<code class="fe mh mi mj mk b">src/</code>目录下，生成的JavaScript文件在<code class="fe mh mi mj mk b">dist/</code>目录下。我们也有一个类似这样的<code class="fe mh mi mj mk b">config.json</code>配置文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2b1f" class="mt lf it mk b gy mu mv l mw mx">{<br/>  "tmpDir": "/tmp/data",<br/>  "httpServer": {<br/>    "port": 8212,<br/>    "hostName": null<br/>  },<br/>  "log": {<br/>    "level": "trace",<br/>    "prettyPrint": true<br/>  }<br/>}</span></pre><h1 id="264e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">配置文件的TypeScript定义</h1><p id="e2f5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript可以帮助描述这种数据结构。我们需要在一个定义文件中对与配置相关的类型进行分组。在我们的<code class="fe mh mi mj mk b">src/</code>目录下，创建一个文件<code class="fe mh mi mj mk b">configuration-types.d.ts</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c0ec" class="mt lf it mk b gy mu mv l mw mx">export interface AppConf {<br/>  tmpDir: string<br/>  httpServer: HttpServerConf<br/>  log: LogConf<br/>}</span><span id="b314" class="mt lf it mk b gy my mv l mw mx">export interface HttpServerConf {<br/>  port: number<br/>  hostName: string | null<br/>}</span><span id="db19" class="mt lf it mk b gy my mv l mw mx">export interface LogConf {<br/>  level: "silent" | "error" | "warn" | "info" | "debug" | "trace"<br/>  <em class="mz">/**<br/>   * Omit for stdout.<br/>   */</em><br/>  file?: string<br/>  prettyPrint: boolean<br/>}</span></pre><h1 id="83c1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安装<code class="fe mh mi mj mk b">typeonly</code>解析器及其验证器</h1><p id="e77d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，安装<code class="fe mh mi mj mk b">typeonly</code>作为开发依赖项，安装<code class="fe mh mi mj mk b">@typeonly/validator</code>作为普通依赖项:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0fab" class="mt lf it mk b gy mu mv l mw mx"><em class="mz"># Needed at compile time.</em><br/>npm install typeonly --save-dev</span><span id="2b92" class="mt lf it mk b gy my mv l mw mx"><em class="mz"># Needed at run time.</em><br/>npm install @typeonly/validator</span></pre><h1 id="8ff3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">编写要在编译时执行的命令</h1><p id="ad84" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">编辑项目的<code class="fe mh mi mj mk b">package.json</code>文件，以便在<code class="fe mh mi mj mk b">scripts</code>部分添加命令:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e33d" class="mt lf it mk b gy mu mv l mw mx">    "typeonly": "typeonly --bundle dist/conf-types.to.json src/configuration-types.d.ts"</span></pre><p id="fbaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，运行新命令:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1d91" class="mt lf it mk b gy mu mv l mw mx">npm run typeonly</span></pre><p id="fe4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个命令执行<code class="fe mh mi mj mk b">typeonly</code>解析器:解析<code class="fe mh mi mj mk b">src/configuration-types.d.ts</code>文件，然后提取类型并存储以供运行时使用。因此，创建了一个新的<code class="fe mh mi mj mk b">dist/conf-types.to.json</code>文件。</p><h1 id="60a7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在运行时使用我们的TypeScript类型验证数据</h1><p id="fe5d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，<code class="fe mh mi mj mk b">@typeonly/validator</code>包可以使用我们在<code class="fe mh mi mj mk b">dist/conf-types.to.json</code>中的类型在运行时验证数据。在<code class="fe mh mi mj mk b">src/</code>目录下，创建一个新的源文件<code class="fe mh mi mj mk b">validate-configuration.ts</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2558" class="mt lf it mk b gy mu mv l mw mx">import { createValidator } from "@typeonly/validator"<br/>import { join } from "path"<br/>import { AppConf } from "./configuration-types"</span><span id="2719" class="mt lf it mk b gy my mv l mw mx">export function validateConfiguration(<br/>  packageDir: string, <br/>  data: unknown<br/>): asserts data is AppConf {<br/>  <em class="mz">// Create the </em>validator<em class="mz"> using a JSON file with types</em><br/>  const validator = createValidator({<br/>    bundle: require(join(packageDir, "dist", "conf-types.to.json"))<br/>  })<br/>  <em class="mz">// Use the </em>validator<em class="mz"> to validate 'data' using the interface</em><br/>  <em class="mz">// 'AppConf'</em><br/>  const result = validator.validate("AppConf", data)<br/>  if (!result.valid)<br/>    throw new Error(`Invalid config file: ${result.error}`)<br/>}</span></pre><p id="d250" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在主源文件中，我们现在可以使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8d80" class="mt lf it mk b gy mu mv l mw mx">import { readFileSync } from "fs"<br/>import { dirname } from "path"<br/>import { validateConfiguration } from "./validate-configuration";</span><span id="43b3" class="mt lf it mk b gy my mv l mw mx">const packageDir = dirname(__dirname)<br/>const conf = JSON.parse(readFileSync("config.json", "utf8"))<br/>validateConfiguration(packageDir, conf)</span><span id="ded6" class="mt lf it mk b gy my mv l mw mx"><em class="mz">// Here, 'conf' really is of type 'AppConf'</em></span><span id="febd" class="mt lf it mk b gy my mv l mw mx">console.log(conf)</span></pre><p id="a3d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成了。我们的配置文件在运行时得到验证。你可以检查一下:编辑<code class="fe mh mi mj mk b">config.json</code>文件；设置日志级别为<code class="fe mh mi mj mk b">"dummy"</code>，你会得到一个非常清晰的错误信息；</p><blockquote class="na nb nc"><p id="2ad3" class="kg kh mz ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">在属性“level”中，值“dummy”不符合联合:在“silent”|“error”|“warn”|“info”|“debug”|“trace”中没有匹配的类型。</p></blockquote><h1 id="51db" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">关于TypeOnly的一句话</h1><p id="9a28" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeOnly使得在运行时使用TypeScript类型成为可能。</p><p id="f9b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是关于TypeOnly的一些附加信息:</p><ul class=""><li id="91be" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">TypeOnly解析器是使用ANTLR从头开始编写的。它根本不使用TypeScript。它产生JSON数据。</li><li id="2e8e" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">在运行时，不需要解析器。所有的输入数据都存储在一个简单的JSON文件中。所以它真的很有表演性。</li><li id="c71f" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">前端也可以使用类型作为运行时。事实上，生成的包含输入数据的JSON文件可以被打包:只需<code class="fe mh mi mj mk b">require</code>它们！</li><li id="19d5" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">TypeOnly源文件必须是纯定义文件(扩展名为<code class="fe mh mi mj mk b">.d.ts</code>)。它们可以是几个:通过在命令行中列出它们，或者通过使用<code class="fe mh mi mj mk b">--source-dir</code>选项(<a class="ae kf" href="https://www.npmjs.com/package/typeonly#using-the-cli" rel="noopener ugc nofollow" target="_blank">参见文档</a>)。一个定义文件可以<code class="fe mh mi mj mk b">import</code>别人。</li><li id="3749" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">一个很大的限制:泛型还没有实现。</li></ul></div></div>    
</body>
</html>