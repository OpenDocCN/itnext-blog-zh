<html>
<head>
<title>3 small tips for better Redux performance in a React app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React应用中提高Redux性能的3个小技巧</h1>
<blockquote>原文：<a href="https://itnext.io/3-small-tips-for-better-redux-performance-in-a-react-app-9cde549df6af?source=collection_archive---------0-----------------------#2019-03-07">https://itnext.io/3-small-tips-for-better-redux-performance-in-a-react-app-9cde549df6af?source=collection_archive---------0-----------------------#2019-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ea1c1336429e73ed105a6baac995965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meCFnZ5MK_7Fu1ogYfBvNQ.png"/></div></div></figure><p id="3034" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的<a class="ae kw" href="https://medium.com/@aggelosarvanitakis/6-tips-for-better-react-performance-4329d12c126b" rel="noopener">上一篇文章</a>中，我介绍了React应用中性能优化的一些核心概念。本文将通过关注实践来扩展这些概念，这些实践将确保在您的项目中引入Redux不会在您的应用程序增长时导致任何性能瓶颈。</p><p id="5123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如安德鲁<a class="ae kw" href="https://twitter.com/acdlite/status/1024852895814930432?lang=en" rel="noopener ugc nofollow" target="_blank">有趣地指出的那样</a>，Redux本身只是一个事件发射器。因此，所有可能的优化都被自动委托给反应本身。在React中，我们将优化转化为整体渲染的<strong class="ka ir">渲染时间减少</strong>和<strong class="ka ir">。</strong>前者与组件渲染阶段的工作量有关(昂贵的计算、多次函数调用、自定义DOM突变等)。)，而后者与组件渲染的次数有关。React组件内部的工作量与业务逻辑紧密相关，并且很可能与redux无关，但是呈现的数量很容易与redux相关，并且如果不小心的话会逐渐增加。</p><p id="1121" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们开始吧:</p><h2 id="6e30" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">1.在你的选择器中利用记忆</h2><p id="e7c3" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">选择器在redux中并不是什么新东西，它们只是从读取它的组件中抽象出实际状态实现的一种方式；组件和实际redux状态之间的代理。编写选择器可以像这样简单:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">“items”键的一个简单的冗余选择器</figcaption></figure><p id="34d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们假设数据存储在一个列表中。Redux docs虽然，<a class="ae kw" href="https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape" rel="noopener ugc nofollow" target="_blank">推荐状态被规范化</a>。这意味着我们应该将项目存储在一个对象中，其中键是项目的id，值是项目本身。为了获得与上面例子相似的结果，我们会天真地重写一个选择器(假设条目的顺序无关紧要):</p><pre class="lv lw lx ly gt mf mg mh mi aw mj bi"><span id="b242" class="kx ky iq mg b gy mk ml l mm mn">// remember, items is an object in this case<br/>export const getItems = state =&gt; Object.keys(state.items);</span></pre><p id="236c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个实现实际上服务于我们的目的，但是有一个大的缺陷。任何时候<strong class="ka ir">Redux状态</strong>的任何部分被更新，我们的组件将重新呈现，不管存储更新是否与我们的组件相关。你看，当你使用react-redux的<code class="fe mo mp mq mg b">connect()</code> HOC连接一个组件时，redux重新计算已经提供给<code class="fe mo mp mq mg b">connect()</code>的<code class="fe mo mp mq mg b">mapStateToProps</code>的输出，并执行一个浅层的相等检查。如果存储更新前后的属性在引用上是相同的，则组件不会重新呈现。如果它们不同，那么组件将重新呈现。在我们的例子中，<code class="fe mo mp mq mg b">Object.keys</code>每次被调用时都返回不同的实例。因此，由于这个选择器在我们的<code class="fe mo mp mq mg b">mapStateToProps</code>中，它将在每次执行存储更新时被重新评估。仅仅因为这个数组的引用将不同于它的前一个，react-redux将错误地认为组件的属性是不同的，因此它将“允许”react重新呈现。</p><p id="716e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像<code class="fe mo mp mq mg b">.map</code>和<code class="fe mo mp mq mg b">.filter</code>这样的操作符每次被调用时都返回不同的引用值。因此，我们必须确保当实际输出相同时，基准电压保持不变；当实际输出不同时，基准电压也应该不同。为此，我们采用了一种叫做记忆化的技术。这种技术保证了“只要函数的输入是相同的，那么输出将是相同的”。一个流行的库选项是<a class="ae kw" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>。有了它，我们可以像这样重写我们的选择器:</p><pre class="lv lw lx ly gt mf mg mh mi aw mj bi"><span id="0437" class="kx ky iq mg b gy mk ml l mm mn">import { createSelector } from 'reselect';</span><span id="59b8" class="kx ky iq mg b gy mr ml l mm mn">export const getItems = <br/>  createSelector(state =&gt; state.items, items =&gt; Object.keys(items))</span></pre><p id="f72d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mg b">createSelector</code>接受任意数量的函数参数，其中前N-1个函数是选择器的“输入”，第N个是“输出”。它保证只要输入具有相同的值，输出就会被“缓存”和重用。如果任何输入的值与上次选择器调用时的值不同，那么将重新计算第n个函数的“输出”。在我们的例子中，只要项目保持不变，那么无论调用多少次,<code class="fe mo mp mq mg b">getItems</code>选择器都将返回一个具有相同引用的值。如果添加了新的条目，那么<code class="fe mo mp mq mg b">items</code>状态将不再具有相同的值，因此<code class="fe mo mp mq mg b">getItems</code>将返回一个新的引用，该引用将被缓存和重用。</p><p id="255d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个规则，每当您需要在每次选择器调用时执行返回新引用的操作时，请确保您记住了结果(提示:在处理复杂的选择器逻辑时，您可以在另一个记忆选择器中使用一个记忆选择器)。</p><h2 id="36f6" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">2.使用参照一致的动作创建者</h2><p id="bba8" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">有时动作创建器是简单的函数，比如:</p><pre class="lv lw lx ly gt mf mg mh mi aw mj bi"><span id="500a" class="kx ky iq mg b gy mk ml l mm mn">const fireAction = () =&gt; ({ type: 'ACTION', payload: {} });</span></pre><p id="5ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，<code class="fe mo mp mq mg b">fireAction</code>有一个固定的引用，但不幸的是并不总是这样。有时候，您需要将组件的<code class="fe mo mp mq mg b">props</code>传递给动作创建者，以便区分传递给缩减器的数据。例如，让我们来看下面这个案例:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">使用组件道具的动作创建器</figcaption></figure><p id="6abf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的实现有点幼稚。我们希望将<code class="fe mo mp mq mg b">fireAction</code>动作创建者“绑定”到<code class="fe mo mp mq mg b">MyComponent</code>作为道具的特定<code class="fe mo mp mq mg b">item</code>。为了实现这一点，我们从<code class="fe mo mp mq mg b">mapDispatchToProps</code>内部“读取”道具，并使用它们来创建<code class="fe mo mp mq mg b">fireActionWithItem</code>。有些人不知道的是，每当你从你的<code class="fe mo mp mq mg b">mapDispatchToProps</code>中使用组件的道具时(每当你使用这个函数的第二个参数时)，react-redux会在每次组件的道具改变时重新计算<code class="fe mo mp mq mg b">mapDispatchToProps</code>的输出。因此，如果来自<code class="fe mo mp mq mg b">MyComponent</code>的任何道具发生变化，那么<code class="fe mo mp mq mg b">mapDispatchToProps</code>将再次运行。由于匿名函数的性质，作为道具传递给<code class="fe mo mp mq mg b">MyComponent</code>的<code class="fe mo mp mq mg b">fireActionWithItem</code>每次都会有不同的引用。这对于正在渲染的组件来说不是问题(因为不管在我们的<code class="fe mo mp mq mg b">mapDispatchToProps</code>中发生了什么，它都会重新渲染)，但是对于在<code class="fe mo mp mq mg b">MyComponent</code>中声明的将<code class="fe mo mp mq mg b">fireActionWithItem</code>作为道具的其他组件来说，这可能会产生问题。例如，让我们看看下面的场景:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">昂贵的组件无缘无故地重新渲染…</figcaption></figure><p id="18b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个组件:<code class="fe mo mp mq mg b">MyComponent</code>和<code class="fe mo mp mq mg b">ExpensiveComponent</code>。如你所见，<code class="fe mo mp mq mg b">ExpensiveComponent</code>被包裹在<code class="fe mo mp mq mg b">memo()</code>中，所以只有当它的道具改变时才会重新渲染。每次<code class="fe mo mp mq mg b">MyComponent</code>中的<code class="fe mo mp mq mg b">randomProp</code>改变，那么<code class="fe mo mp mq mg b">mapDispatchToProps</code>将被重新计算，<code class="fe mo mp mq mg b">fireActionWithItem</code>将获得新的参考，<code class="fe mo mp mq mg b">MyComponent</code>将被重新渲染，<code class="fe mo mp mq mg b">ExpensiveComponent</code>也将被强制重新渲染，因为它的<code class="fe mo mp mq mg b">onClick</code>道具将会不同。最终，<code class="fe mo mp mq mg b">ExpensiveComponent</code>根本不应该被重新渲染，因为没有任何影响它的东西实际上已经改变了。</p><p id="1fd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了应对这种情况，您可以将带有正确参数的动作触发委托给组件本身(通过将<code class="fe mo mp mq mg b">item</code>和<code class="fe mo mp mq mg b">fireAction</code>作为道具传递给组件)，允许它使用固定引用“创建”<code class="fe mo mp mq mg b">fireActionWithItem</code>(通过使用<code class="fe mo mp mq mg b">.bind</code> &amp; <code class="fe mo mp mq mg b">useCallback</code>)，或者您可以在动作创建器中使用记忆化技术。对于后者，您可以使用与选择器中相同的概念，并确保引用总是相同的。两种选择都可以在下面的要点中看到:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">参照一致动作创建者的两种方法</figcaption></figure><h2 id="5b3f" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">3.减少渲染次数的批处理操作</h2><p id="c91d" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">每当你不得不一个接一个地链接多个动作时(你<strong class="ka ir">有意</strong>在你的动作中分开关注点)，你最好批处理它们并用一个<code class="fe mo mp mq mg b">dispatch</code>发射它们。对这些动作进行分组可以保证将只有1次而不是X次可能的重新渲染。不过有一个警告:为了使操作“可批处理”，它们需要相互独立。这意味着N动作必须独立于N-1动作所创建的状态。换句话说，您应该能够在不影响结束状态的情况下更改这些操作的触发顺序。如果是这样的话，<code class="fe mo mp mq mg b">react-redux</code> 7.x.x提供了一个新的<code class="fe mo mp mq mg b">batch</code>功能，可以帮助你只通过一个调度来更新你的状态，为你节省额外的——可能是昂贵的——渲染。</p><pre class="lv lw lx ly gt mf mg mh mi aw mj bi"><span id="952b" class="kx ky iq mg b gy mk ml l mm mn">import { batch } from 'react-redux'<br/>import { action1, action2 } from './actions';</span><span id="1953" class="kx ky iq mg b gy mr ml l mm mn">// dispatches both actions at the same time<br/>batch(() =&gt; {<br/>  dispatch(action1());<br/>  dispatch(action2());<br/>});</span></pre><p id="e5af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用它，需要访问调度功能。有很多方法可以实现这一点，这取决于从哪里触发操作。例如，您可以从您的<code class="fe mo mp mq mg b">mapDispatchToProps</code>函数、从<code class="fe mo mp mq mg b">redux-thunk</code> thunk或者从手动导入<code class="fe mo mp mq mg b">store</code>并使用<code class="fe mo mp mq mg b">store.dispatch</code>来访问<code class="fe mo mp mq mg b">dispatch</code>。这主要归结于你的应用程序是如何构建的。不得不说，这种技术很少使用，但在主线程的自由度至关重要的情况下，它可以提高性能。例如，如果您在启动这些动作后正在执行繁重的动画，那么单个调度可能会为您节省宝贵的帧。</p><h1 id="efa3" class="ms ky iq bd kz mt mu mv lc mw mx my lf mz na nb li nc nd ne ll nf ng nh lo ni bi translated">结论</h1><p id="e2f0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我故意没有触及正确组织你的状态的话题，这比上面的建议更重要。本文的目的是揭示React应用程序中动作创建者和选择器的非最优集成可能导致的性能损失。我绝不相信所有项目都应该使用这些概念——因为对大多数项目来说它们都是多余的——但是知道这些概念是有好处的。</p><p id="9140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢:)</p><p id="7048" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="nj"/></strong>👋<strong class="ka ir"> <em class="nj">嗨，我是</em></strong><a class="ae kw" href="https://aggelosarvanitakis.me" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nj">Aggelos</em></strong></a><strong class="ka ir"><em class="nj">！如果你喜欢这个，考虑一下</em> </strong> <a class="ae kw" href="https://twitter.com/AggArvanitakis" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nj">在twitter上关注我</em> </strong> </a> <strong class="ka ir"> <em class="nj">并与你的开发者朋友分享这个故事</em>😀</strong></p></div></div>    
</body>
</html>