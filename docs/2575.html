<html>
<head>
<title>RxJS: Don’t takeUntil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS:不要等到</h1>
<blockquote>原文：<a href="https://itnext.io/rxjs-dont-takeuntil-ce76a01e977?source=collection_archive---------3-----------------------#2019-06-17">https://itnext.io/rxjs-dont-takeuntil-ce76a01e977?source=collection_archive---------3-----------------------#2019-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d6f9810d723d6964ed92ce5cab05ad61.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/0*DG54Uqxsp9BSeowb.jpg"/></div></figure><p id="b090" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是本·莱什的优秀文章<a class="ae ks" href="https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87" rel="noopener"> RxJS:不要退订</a>的后续。我想在这里取一个能反映他的朗朗上口的标题。我认为你 <strong class="jw ir"> <em class="kt">应该</em> </strong> <em class="kt">在你有充分理由这样做的时候使用</em> <code class="fe ku kv kw kx b"><em class="kt">takeUntil</em></code> <em class="kt">，订阅管理就是一个充分的理由。</em>就像本说的</p><blockquote class="ky kz la"><p id="85a1" class="ju jv kt jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr ij bi translated">嗯…好吧，只是不要退订太多。</p></blockquote><p id="abf7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我会说，确保你也正确地使用了<code class="fe ku kv kw kx b">takeUntil</code>来管理你的可观测量。与此相关的是，你可能想看看Nicholas Jamieson的文章<a class="ae ks" href="https://blog.angularindepth.com/rxjs-avoiding-takeuntil-leaks-fb5182d047ef" rel="noopener ugc nofollow" target="_blank"> RxJS:避免takeUntil泄露</a>。</p><p id="ba57" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">本文将详细介绍我在一个Ionic (Angular)项目中天真地使用<code class="fe ku kv kw kx b">takeUntil</code>时遇到的一些问题。希望这能帮助你们中的一些人预先避免这些陷阱！这个应用是Ionic v3应用，所以我们仍然使用一些旧的生命周期挂钩。Ionic v4建议在某些情况下使用Angular的内置挂钩。参见:<a class="ae ks" href="https://ionicframework.com/docs/angular/lifecycle" rel="noopener ugc nofollow" target="_blank">https://ionicframework.com/docs/angular/lifecycle</a></p><h2 id="a68b" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">带takeUntil的订阅管理</h2><p id="bf72" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">假设你有一个不止一个可观测的组件。你应该先问自己几个问题:</p><ol class=""><li id="0240" class="mc md iq jw b jx jy kb kc kf me kj mf kn mg kr mh mi mj mk bi translated">我可以使用<code class="fe ku kv kw kx b">| async</code>管道来管理组件中的可观察订阅吗？</li><li id="95b1" class="mc md iq jw b jx ml kb mm kf mn kj mo kn mp kr mh mi mj mk bi translated">有没有什么合理的方法可以合并观察对象来管理单个订阅？</li></ol><p id="a003" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">即使你对第二个问题回答“是”，为了保持一致，你可能还是要使用<code class="fe ku kv kw kx b">takeUntil</code>。例如:</p><pre class="mq mr ms mt gt mu kx mv mw aw mx bi"><span id="d74f" class="le lf iq kx b gy my mz l na nb">@Component()<br/>export class ObservingPage {<br/>  users = this.store.selectObservable('users');<br/>  userList = [];<br/>  unsubscriber = new Subject();</span><span id="a030" class="le lf iq kx b gy nc mz l na nb">  ionViewDidLoad() {<br/>    this.users.pipe(takeUntil(unsubscriber)).subscribe(users =&gt;<br/>      this.userList = users,<br/>    );<br/>  }</span><span id="e6eb" class="le lf iq kx b gy nc mz l na nb">  ionViewWillUnload() {<br/>    this.unsubscriber.next();<br/>    this.unsubscriber.complete();<br/>  }<br/>}</span></pre><p id="b416" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，使用带有<code class="fe ku kv kw kx b">users</code>的异步管道是有利的，但是您可能有一些队友在他们不熟悉异步管道或者不想使用它时编写了代码。也许有一个更好的例子，您必须创建一个手动订阅。无论哪种方式，这里的要点是当视图卸载时，<code class="fe ku kv kw kx b">users</code>可观察将完成，因为我们正在发射到<code class="fe ku kv kw kx b">unsubscriber</code>并使用<code class="fe ku kv kw kx b">takeUntil</code>。</p><p id="7a5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我和一个大型团队一起开发的应用程序有许多由不正确的取消订阅Observables引起的内存泄漏问题。在没有任何判断的情况下，我们遵循了团队的建议，在卸载组件时使用<code class="fe ku kv kw kx b">takeUntil</code>来修复这些内存泄漏。在很大程度上，这非常有效，是一个可行的解决方案。</p><h2 id="d9f2" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">管理具有不同生命周期的订阅</h2><p id="1f20" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">这个解决方案很好，但是Ionic会将页面保存在内存中，即使你离开它们。这导致一些订阅回调在页面的后台被调用，这可能是不必要的或不可取的。没关系……我们可以使用WillEnter / WillLeave生命周期挂钩来代替。</p><pre class="mq mr ms mt gt mu kx mv mw aw mx bi"><span id="952a" class="le lf iq kx b gy my mz l na nb">@Component()<br/>export class OnlyWhenEnteredPage {<br/>  users = this.store.selectObservable('users');<br/>  userList = [];<br/>  unsubscriber = new Subject();</span><span id="1849" class="le lf iq kx b gy nc mz l na nb">  ionViewWillEnter() {<br/>    this.users.pipe(takeUntil(unsubscriber)).subscribe(users =&gt;<br/>      this.userList = users,<br/>    )<br/>  }</span><span id="b977" class="le lf iq kx b gy nc mz l na nb">  ionViewWillLeave() {<br/>    this.unsubscriber.next();<br/>    this.unsubscriber.complete();<br/>  }<br/>}</span></pre><p id="ea5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望，对你们中的一些人来说这看起来足够无辜，就像我一样。也许其他人会对这个显而易见的(回顾起来)问题感到惊讶:<code class="fe ku kv kw kx b"><strong class="jw ir">unsubscriber</strong></code> <strong class="jw ir">是在页面加载时创建的，但是我们在页面离开</strong>时完成它。这意味着每次我们重新进入页面时，任何使用<code class="fe ku kv kw kx b">takeUntil(unsubscriber)</code>的操作都会立即完成，因为我们已经向它发出了请求。</p><p id="53f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你被一个类似的问题弄得措手不及，开始质疑你对可观察的创造和完成的理解，我完全了解你的感受，因为我经历了那件事。这里的解决方案相对简单:也在enter上创建您的退订主题管理器。</p><pre class="mq mr ms mt gt mu kx mv mw aw mx bi"><span id="2e89" class="le lf iq kx b gy my mz l na nb">@Component()<br/>export class OnlyWhenEnteredPage {<br/>  users = this.store.selectObservable('users');<br/>  userList = [];<br/>  unsubscriber: Subject&lt;void&gt;();</span><span id="922c" class="le lf iq kx b gy nc mz l na nb">  ionViewWillEnter() {<br/>    this.unsubscriber = new Subject();<br/>    this.users.pipe(takeUntil(unsubscriber)).subscribe(users =&gt;<br/>      this.userList = users,<br/>    );<br/>  }</span><span id="f47d" class="le lf iq kx b gy nc mz l na nb">  ionViewWillLeave() {<br/>    this.unsubscriber.next();<br/>    this.unsubscriber.complete();<br/>  }<br/>}</span></pre><h2 id="4d1f" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">更强大的方法？</h2><p id="b06c" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">出于某种原因，像这样使用<code class="fe ku kv kw kx b">takeUntil</code>总是让我不愉快。我认为这可能与同时调用<code class="fe ku kv kw kx b">.next</code>和<code class="fe ku kv kw kx b">.complete</code>有关，(从技术上讲，你不必做<code class="fe ku kv kw kx b">.complete</code>，但如果我没弄错的话，不这样做可能会导致内存泄漏)。</p><p id="f3ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Ward Bell的简单的subsink工具似乎是一个不错的方法。这实际上只是在你取消订阅接收器时，对你正在创建的订阅列表进行手动取消订阅，但是你不必担心管理和完成一个单独的<em class="kt">主题</em>，这是另一个需要处理的可观察主题。</p><pre class="mq mr ms mt gt mu kx mv mw aw mx bi"><span id="812d" class="le lf iq kx b gy my mz l na nb">import { SubSink } from 'subsink';</span><span id="ae17" class="le lf iq kx b gy nc mz l na nb">@Component()<br/>export class WhenEnteredAndLoadedPage {<br/>  users = this.store.selectObservable('users');<br/>  invitations = this.store.selectObservable('invitations')<br/>  userList = [];<br/>  invitationList = [];<br/>  pageEnterSubs = new SubSink();<br/>  pageLoadSubs = new SubSink();</span><span id="6a54" class="le lf iq kx b gy nc mz l na nb">  ionViewDidLoad() {<br/>    this.pageLoadSubs.sink = this.invitations.subscribe(inv =&gt;<br/>      this.invitationList = inv,<br/>    );<br/>  }</span><span id="83d1" class="le lf iq kx b gy nc mz l na nb">  ionViewWillEnter() {<br/>    this.pageEnterSubs.sink = this.users.subscribe(users =&gt;<br/>      this.userList = users,<br/>    );<br/>  }</span><span id="915f" class="le lf iq kx b gy nc mz l na nb">  ionViewWillLeave() {<br/>    this.pageEnterSubs.unsubscribe();<br/>  }</span><span id="83f8" class="le lf iq kx b gy nc mz l na nb">  ionViewWillUnload() {<br/>    this.pageLoadSubs.unsubscribe();<br/>  }<br/>}</span></pre><p id="af98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的每个例子对于每个生命周期挂钩只使用一个订阅，但是您可以使用任意多个。<code class="fe ku kv kw kx b">subsink</code>似乎不是特别受欢迎，但在这种情况下，这似乎是管理我的多个订阅的好方法。如果你不想使用它，你可以以类似的方式使用<code class="fe ku kv kw kx b">takeUntil</code>和两个subject，只是你必须在<code class="fe ku kv kw kx b">ionViewWillEnter</code>中创建一个subject而不是构造函数。</p><p id="3ae0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，异步管道总是引人注目。</p><p id="514d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">一位读者还向我指出，</strong>这个功能也内置在RxJS订阅中，所以如果你不想使用<code class="fe ku kv kw kx b">subsink</code>，你可以简单地使用<code class="fe ku kv kw kx b">new Subscription</code>和<code class="fe ku kv kw kx b">.add</code>来获得类似的功能。参见:<a class="ae ks" href="https://rxjs.dev/api/index/class/Subscription#add" rel="noopener ugc nofollow" target="_blank">https://rxjs.dev/api/index/class/Subscription#add</a>和<a class="ae ks" href="https://blog.angularindepth.com/rxjs-composing-subscriptions-b53ab22f1fd5" rel="noopener ugc nofollow" target="_blank">https://blog . angularindepth . com/rxjs-composing-subscriptions-b 53 ab 22 f1 FD 5</a>。</p><h2 id="b2bc" class="le lf iq bd lg lh li dn lj lk ll dp lm kf ln lo lp kj lq lr ls kn lt lu lv lw bi translated">经验教训</h2><p id="bc4c" class="pw-post-body-paragraph ju jv iq jw b jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr ij bi translated">RxJS非常强大，但为此很容易出错。无论何时使用RxJS操作符，都要考虑自己在做什么，并询问这将如何影响流，以及流是否会适当地完成，这一点很重要。很容易犯一个错误，那就是从不完成一个可观察的，并造成内存泄漏。正如我所发现的，过早地完成可观测也很容易，当你期望它发射时，它不会发射。</p><p id="aafa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当使用生命周期挂钩时，记住在相应的挂钩中镜像操作也很重要。您可能会想“这个主题是在WillLeave中完成的，所以需要在WillEnter中创建它。”</p></div></div>    
</body>
</html>