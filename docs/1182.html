<html>
<head>
<title>HTTP request timeouts in Go for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者在Go中的HTTP请求超时</h1>
<blockquote>原文：<a href="https://itnext.io/http-request-timeouts-in-go-for-beginners-fe6445137c90?source=collection_archive---------0-----------------------#2018-08-07">https://itnext.io/http-request-timeouts-in-go-for-beginners-fe6445137c90?source=collection_archive---------0-----------------------#2018-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b6df340cd29a60a999f5502a12e0e229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E7Ekq0SoA5ZBEDf3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@hharvey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张浩</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6839" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超时是分布式系统中基本的可靠性概念之一，可以减轻分布式系统不可避免的故障的影响，正如这篇推文中所提到的</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><h1 id="4704" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">问题是</h1><blockquote class="mi mj mk"><p id="47ae" class="kg kh ml ki b kj kk kl km kn ko kp kq mm ks kt ku mn kw kx ky mo la lb lc ld im bi translated">如何模拟504 http？StatusGatewayTimeout有条件响应？</p></blockquote><p id="c474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当试图在<a class="ae kf" href="https://github.com/zalando/skipper/issues/633" rel="noopener ugc nofollow" target="_blank"> zalando/skipper </a>中实现OAuth令牌验证时，我必须理解并实现一个测试，以便在服务器超时时使用<code class="fe mp mq mr ms b">httptest</code>来<a class="ae kf" href="https://stackoverflow.com/questions/51319726/how-to-mimic-504-timeout-error-for-http-request-inside-a-test-in-go" rel="noopener ugc nofollow" target="_blank">模拟一个</a> <code class="fe mp mq mr ms b"><a class="ae kf" href="https://stackoverflow.com/questions/51319726/how-to-mimic-504-timeout-error-for-http-request-inside-a-test-in-go" rel="noopener ugc nofollow" target="_blank">504 http.StatusGatewayTimeout</a></code>，但只是在客户端因服务器延迟而超时时。作为一个语言初学者，我做了我们大多数人都会做的事情；创建标准HTTP客户端并添加一个超时，如下所示:</p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="4003" class="mx ll it ms b gy my mz l na nb">client := http.Client{Timeout: 5 * time.Second}</span></pre><p id="5e4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当想要创建一个客户机来发出http请求时，上面的内容看起来非常简单和直观。但是隐藏在下面的是许多底层细节，包括客户端超时、服务器超时和负载平衡器超时。</p><h2 id="a04d" class="mx ll it bd lm nc nd dn lq ne nf dp lu kr ng nh ly kv ni nj mc kz nk nl mg nm bi translated">客户端超时</h2><p id="6ae9" class="pw-post-body-paragraph kg kh it ki b kj nn kl km kn no kp kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">可以在客户端使用多种方法定义http请求超时，具体取决于请求周期中的超时帧。请求-响应周期由<code class="fe mp mq mr ms b">Dialer</code>、<code class="fe mp mq mr ms b">TLS Handshake</code>、<code class="fe mp mq mr ms b">Request Header</code>、<code class="fe mp mq mr ms b">Request Body</code>、<code class="fe mp mq mr ms b">Response Header</code>和<code class="fe mp mq mr ms b">Response Body</code>超时组成。根据请求-响应的上述部分，Go提供了以下创建超时请求的方法</p><ul class=""><li id="be0a" class="ns nt it ki b kj kk kn ko kr nu kv nv kz nw ld nx ny nz oa bi translated"><code class="fe mp mq mr ms b">http.client</code></li><li id="e749" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated"><code class="fe mp mq mr ms b">context</code></li><li id="ffb3" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated"><code class="fe mp mq mr ms b">http.Transport</code></li></ul><h2 id="8cb0" class="mx ll it bd lm nc nd dn lq ne nf dp lu kr ng nh ly kv ni nj mc kz nk nl mg nm bi translated"><a class="ae kf" href="https://godoc.org/net/http#Client" rel="noopener ugc nofollow" target="_blank"> http.client </a>:</h2><p id="2708" class="pw-post-body-paragraph kg kh it ki b kj nn kl km kn no kp kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated"><code class="fe mp mq mr ms b">http.client</code>超时是超时的高级实现，包括从<code class="fe mp mq mr ms b">Dial</code>到<code class="fe mp mq mr ms b">Response Body</code>的整个请求周期。实现方式<code class="fe mp mq mr ms b">http.client</code>是一个结构类型，它接受类型<code class="fe mp mq mr ms b">time.Duration</code>的可选<code class="fe mp mq mr ms b">Timeout</code>属性，该属性定义了从请求开始到响应体被刷新的时间限制</p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="35fe" class="mx ll it ms b gy my mz l na nb">client := http.Client{Timeout: 5 * time.Second}</span></pre><h2 id="92f7" class="mx ll it bd lm nc nd dn lq ne nf dp lu kr ng nh ly kv ni nj mc kz nk nl mg nm bi translated"><a class="ae kf" href="https://godoc.org/context" rel="noopener ugc nofollow" target="_blank">语境</a></h2><p id="1ddf" class="pw-post-body-paragraph kg kh it ki b kj nn kl km kn no kp kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">go <code class="fe mp mq mr ms b">context</code>包通过<code class="fe mp mq mr ms b"><a class="ae kf" href="https://godoc.org/context#WithTimeout" rel="noopener ugc nofollow" target="_blank">WithTimeout</a></code>、<code class="fe mp mq mr ms b">WithDeadline</code>和<code class="fe mp mq mr ms b">WithCancel</code>方法提供了处理超时、截止日期和可取消请求的有用工具。使用<code class="fe mp mq mr ms b">WithTimeout</code>，您可以使用<code class="fe mp mq mr ms b">req.WithContext</code>方法将超时添加到<code class="fe mp mq mr ms b">http.Request</code></p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="322c" class="mx ll it ms b gy my mz l na nb">ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)<br/>defer cancel()<br/>req, err := http.NewRequest("GET", url, nil)<br/>if err != nil {<br/>    t.Error("Request error", err)<br/>}<br/><br/>resp, err := http.DefaultClient.Do(req.WithContext(ctx))</span></pre><h2 id="be7b" class="mx ll it bd lm nc nd dn lq ne nf dp lu kr ng nh ly kv ni nj mc kz nk nl mg nm bi translated"><a class="ae kf" href="https://godoc.org/net/http#Transport" rel="noopener ugc nofollow" target="_blank"> http。运输</a>:</h2><p id="79c4" class="pw-post-body-paragraph kg kh it ki b kj nn kl km kn no kp kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">您还可以使用低层实现来指定超时，即使用<code class="fe mp mq mr ms b">DialContext</code>创建自定义<code class="fe mp mq mr ms b">http.Transport</code>，并使用它来创建<code class="fe mp mq mr ms b">http.client</code></p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="d53d" class="mx ll it ms b gy my mz l na nb">transport := &amp;http.Transport{<br/>    DialContext: (&amp;net.Dialer{   <br/>        Timeout: timeout,<br/>    }).DialContext,<br/>}</span><span id="147d" class="mx ll it ms b gy og mz l na nb">client := http.Client{Transport: transport}</span></pre><h1 id="a950" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">解决方案</h1><p id="6375" class="pw-post-body-paragraph kg kh it ki b kj nn kl km kn no kp kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">所以带着上面的问题和手头的选项，我用<code class="fe mp mq mr ms b">context.WithTimeout()</code>创建了一个<code class="fe mp mq mr ms b">http.request</code>。但这仍然失败，并出现以下错误</p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="493d" class="mx ll it ms b gy my mz l na nb">client_test.go:40: Response error Get <a class="ae kf" href="http://127.0.0.1:49597" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:49597</a>: context deadline exceeded</span></pre><h2 id="a19d" class="mx ll it bd lm nc nd dn lq ne nf dp lu kr ng nh ly kv ni nj mc kz nk nl mg nm bi translated"><strong class="ak">服务器端超时</strong></h2><p id="83b0" class="pw-post-body-paragraph kg kh it ki b kj nn kl km kn no kp kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated"><code class="fe mp mq mr ms b">context.WithTimeout()</code>方法的问题是它仍然只模拟请求的客户端。如果请求头或请求体花费的时间超过预算的超时时间，则请求在客户端本身失败，而不是在服务器端失败，状态代码为<code class="fe mp mq mr ms b">504 http.StatusGatewayTimeout</code>。</p><p id="ce18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建每次都超时的httptest服务器的一种方法如下。</p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="0228" class="mx ll it ms b gy my mz l na nb">httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request){<br/>    w.WriteHeader(http.StatusGatewayTimeout)<br/>}))</span></pre><p id="98b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我希望它只根据客户端超时值超时。为了让服务器基于客户机超时返回一个504，您可以用一个处理函数<code class="fe mp mq mr ms b">http.TimeoutHandler()</code>包装处理程序，使服务器上的请求超时。下面是应用这个场景的工作测试</p><pre class="le lf lg lh gt mt ms mu mv aw mw bi"><span id="37a3" class="mx ll it ms b gy my mz l na nb">func TestClientTimeout(t *testing.T) {<br/>    handlerFunc := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>        d := map[string]interface{}{<br/>            "id":    "12",<br/>            "scope": "test-scope",<br/>        }<br/><br/>        time.Sleep(100 * time.Millisecond) //&lt;- Any value &gt; 20ms<br/>        <!-- -->b, err:= json.Marshal(d)<br/>        if err != nil {<br/>            t.Error(err)<br/>        }</span><span id="8a01" class="mx ll it ms b gy og mz l na nb">        <!-- -->io.WriteString(w, string(b))<br/>        w.WriteHeader(http.StatusOK)<br/>    })<br/><br/>    backend := httptest.NewServer(http.TimeoutHandler(handlerFunc, 20*time.Millisecond, "server timeout"))<br/><br/>    url := backend.URL<br/>    req, err := http.NewRequest("GET", url, nil)<br/>    if err != nil {<br/>        t.Error("Request error", err)<br/>        return<br/>    }<br/><br/>    resp, err := http.DefaultClient.Do(req)<br/>    if err != nil {<br/>        t.Error("Response error", err)<br/>        return<br/>    }<br/><br/>    defer resp.Body.Close()<br/>}</span></pre><p id="bbb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述问题的细节在<a class="ae kf" href="https://github.com/zalando/skipper/" rel="noopener ugc nofollow" target="_blank"> zalando/skipper </a>中<a class="ae kf" href="https://github.com/zalando/skipper/blob/8b23d2c2dd0ec54585b276a9ceb2a5137dc92db0/filters/auth/tokeninfo_test.go#L271" rel="noopener ugc nofollow" target="_blank">tokeninfo _ test . go/testoauth 2 tokentimeout</a>的实现中使用</p><p id="da5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个初学gopher的人可能会发现理解http超时的高级工作方式很有用！如果你想查看go中<code class="fe mp mq mr ms b">http timeouts </code>的更多细节，这篇来自<a class="ae kf" href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>的文章是必读书。</p></div></div>    
</body>
</html>