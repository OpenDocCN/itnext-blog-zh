# 更新用户界面:值比较与变异跟踪

> 原文：<https://itnext.io/updating-uis-value-comparison-vs-mutation-tracking-9f6fe912dd9a?source=collection_archive---------3----------------------->

我看到了来自[丹·阿布拉莫夫](https://medium.com/u/a3a8af6addc1?source=post_page-----9f6fe912dd9a--------------------------------)的推文，强调了[与](https://reactjs.org/)[相比](https://vuejs.org/)的反应方式:

98

作为一名库作者，我从值比较和变化跟踪的角度探索了应用程序状态管理的实现。在本文中，我将解释这两种方法是如何工作的，以及为什么我个人认为在保持 ui 与应用程序状态同步方面，一种方法优于另一种方法。

# 前言

在本文中，我们将比较两种不同的检测状态变化的方法如何影响你如何构造状态，如何编写逻辑来改变状态，以及最终如何影响 UI 性能。

重要的是要记住进一步阅读，不变性(值比较)和代理(变异跟踪)是可以用来解决不同环境中许多不同挑战的工具。在本文中，我们将讨论值比较和变异跟踪，以应对在状态改变时更新 UI 的挑战。还要注意，当我说“UI 更新”时，我并不是指实际接触 DOM。我指的是组件所做的工作，以确定是否需要更新以及需要更新什么。

我将在示例中使用 React，但是您不需要了解它的任何内容就可以从本文中获益。

# 价值比较说明

我记得当我第一次接触到不变性时，它是一个很大的问号。即使我明白了它是如何工作的，我仍然不明白它是用来做什么的。为了更好地解释不变性，我将首先解释值比较是如何工作的，然后解释不变性是如何使之成为可能的:

想象一个简单的组件:

该组件接收用户状态，并呈现该用户的姓名和年龄。这意味着无论何时名称或年龄发生变化，我们都需要这个组件进行更新。我们可以解决这个问题。我们可以明确地检查姓名和/或年龄是否已经改变:

但是像这样手动优化所有组件将是乏味和脆弱的。随着复杂性的增加，当一个组件在不应该更新的时候更新，或者在应该更新的时候不更新时，调试变得越来越困难。

如果我们的用户是不可变的，我们将不再需要检查姓名和年龄。检查用户本身是否已经改变就足够了。让我们看看如何使用可变和不可变的方法更新年龄:

如果我们使用可变方法，用户本身不会改变，只有年龄属性会改变。对于不变性，我们还创建了一个新的用户对象。简而言之，这就是不变性。坦率地说，每当对象或数组中的属性改变时，所有的直接父对象和数组也会改变。

在我们的组件中，我们现在可以通过比较新旧用户值来确保它的更新:

与 Vue 不同，React 本身没有优化组件更新的逻辑。它为您提供了 **shouldComponentUpdate** 生命周期挂钩来进行价值比较。结合不变性，这是检测 UI 何时需要更新的简单而有效的方法。

在我们开始讨论优势和挑战之前，让我们看看另一种方法。

# 变异追踪解释

对于同样的挑战，一种完全不同的方法是允许开发人员像平常一样改变状态，而是跟踪正在改变的内容。通过使用 JavaScript 中新的[代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)特性，我们可以跟踪组件访问了什么状态以及在哪里发生了突变。通过比较这两条信息，我们知道哪些组件应该更新哪些突变。

与值比较不同，变异跟踪可能更难实现。也就是说，实现本身对开发人员是隐藏的，不像值比较，您可能需要手动比较值来优化更新。

以 React 为例，我们需要为组件引入一个包装器，这很好地突出了它的实际工作方式:

我们的用户组件被负责跟踪状态访问的逻辑所包装。当组件呈现我们访问用户的两个不同属性时，**姓名**和**年龄**，这由 **trackStateAccess** 包装器存储。

当我们的用户被定义时，我们做同样的包装，只是为了跟踪突变:

我们现在跟踪状态访问和突变，并有能力找出什么突变影响什么组件。如果一个组件依赖于**用户名**，我们对**用户名**，进行变异，它们就匹配了。

既然我们已经了解了这两种不同的方法是如何工作的，我们就可以开始比较它们了。

# 国家结构

**值比较**要求你知道你把什么状态带入你的组件。原因是嵌套更改将导致所有直接父对象和数组的更改。如果你看这个例子:

每次您更改文件的**内容**时，依赖于**工作空间**、 **workspace.files** 或**workspace . files【0】**的任何组件都会更新。由于这个事实，你将很快满足[状态正常化](https://redux.js.org/recipes/structuring-reducers/normalizing-state-shape)的概念。状态规范化并不特定于值比较方法，但是与变异跟踪不同，如果忽略它，您可能会遇到性能问题。具体来说，在这种情况下，您希望将结构更改为:

这确保了当文件内容改变时，它不会影响工作区或文件阵列。不过，规范化并不能完全解决问题。对文件的任何更改都会影响依赖于文件本身的任何组件，即使它并不关心实际的属性更改。它还引入了将文件数组的 id 映射到文件字典的额外逻辑需求。

**变异跟踪**允许你任意构建你的状态。因为它跟踪组件中使用的确切状态，所以它是如何构造的并不重要。在上面的例子中，只有组件实际上指向 **workspace.files[0]。内容**会受到内容更改的影响。这并不意味着你永远不会使用规范化。例如，用户可以是帖子的作者，也可以是评论的作者。为了避免在您的州中出现单个用户的重复版本，您可以使用规范化来确保当您更改用户名时，帖子和评论都会更新。与不变性不同，出于性能原因，您不需要这样做。

**结论**在某些应用程序中，值比较会导致额外的精神负担，在这些应用程序中，您必须小心状态是如何构造的，否则就会遇到性能问题。尽管导致性能问题的不一定是可规范化的状态，但可以说您应该总是规范化您的状态。有了值比较，你会对组件进行不必要的更新，因为比较每一个值太单调乏味了。有了变异追踪，你就相信了系统。它减轻了你计算组件如何更新的精神负担，它只是工作，而且最好如此。

# 句法

**值比较**会增加表达状态变化所需的语法量，因为 JavaScript 没有内置的不变性。上面的例子可以通过使用 [spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) 来改进，你也可以使用像 [Immer](https://github.com/mweststrate/immer) 这样的库来用传统的可变 API 表达不可变的变化。Immer 实际上在幕后使用代理。作为一个库作者，Immer 可以以这样一种方式集成，使得库的不可改变性完全隐藏起来。

**变异追踪**让你正常变异状态。跟踪集成到库中真的没有区别。

有人可能会说，变异跟踪方法鼓励代码中的命令式风格，而不可变性鼓励声明式的函数式风格。

结论**语法永远不应该成为决定性因素。我们对如何表达代码有不同的看法，这完全没关系！**

# 表演

**值比较**是非常高效的，因为实际上没有与组件相关的实现细节。我们只是比较价值观。也就是说，任何状态改变都需要每一个组件来验证是否需要更新，除非你使用带有[镜头](https://github.com/kofile/redux-lenses)概念的库。如果你对组件中需要的状态很明确，你通常会没事，但是当你不小心的时候，它可能会有巨大的影响。例如，更改复杂表单中输入的文本可以很容易地导致整个表单更新，这仅仅是因为其他组件构造和使用状态的方式。

执行状态更改也是有成本的。因为所有直接的父对象和数组都需要被替换，所以你将消耗更多的内存，这将更频繁地触发垃圾收集器。不可变库使用结构化共享来帮助解决这个问题，但是最终还是要付出代价的。

**突变跟踪**使用代理，其在访问属性上有开销，用于跟踪状态使用或状态突变。就像不变性一样，也有降低跟踪成本的技术。

**结论**很难比较两种截然不同的解决方案的性能。还有三种完全不同的东西需要进行基准测试:

1.  突变的性能成本
2.  检测变更的性能成本
3.  UI 更新的性能成本

这里的最后一点很有意思。如果变异跟踪在检测变化上有更高的成本，但是有更少的 UI 更新，你如何比较？我自己没有做过这方面的基准测试，我认为这毫无意义。这取决于应用程序，还有许多其他不相关但更重要的性能指标会影响您的应用程序。

# 主要结论和发布

就我个人而言，我倾向于使用变异跟踪来处理 UI 更新，这是我的理由:

*   突变跟踪准确地跟踪哪些状态变化会影响组件。它会根据您访问的任何状态自动优化。光是知道价值比较引起很多不必要的更新就让我觉得失控
*   尽管我倾向于使用声明式函数方法进行编程，但在某种程度上，您总是会编写命令式代码。我认为重要的是要有明确的区分。没有什么可以阻止您将在变异跟踪世界中编写的命令性代码抽象到声明性函数世界中
*   可以说，变异追踪更容易进行。而且我在这里故意用了**易**这个术语。我们的工具可以非常智能，但是面向公众的 API 不应该如此
*   突变跟踪可以产生关于变化之间的关系以及受这些变化影响的事物的更多信息。这意味着您可以获得当前状态的报告，了解对该状态的反应以及发生了哪些状态变化

关于这最后一点，实际上是整篇文章，我想宣布一个为库作者设计的工具，叫做[代理状态树](https://github.com/christianalfoni/proxy-state-tree)，它目前在**测试版**。它实现了跟踪状态访问和变化所需的逻辑，并通过简单的 API 和调试信息公开。我用 [Fabrice](https://github.com/FWeinb) (紧紧拥抱 Fabrice)来帮助开发人员迭代构建 web 应用程序中真正有问题的部分:“状态应该在哪里以及如何定义，状态应该在哪里以及如何更新？”。你如何检测变化和更新用户界面应该只是工作和性能！

作为使用这个工具的一个例子，我在 [Preact](https://preactjs.com/) 上构建了一个演示库。它允许您将应用程序包装在接收状态和动作的**提供者**中。状态和动作暴露给所有**连接的**组件。在这个简单的演示中需要注意的是组件和 devtools 的实现，因为它展示了代理状态树 API 是多么强大和灵活。使用来自代理状态树的信息，您可以轻松地构建调试体验，让您深入了解应用程序中正在发生的事情。在演示中，请注意以下几点:

*   您将获得 UI 中活动组件的列表，以及它们所依赖的状态路径和它们渲染的次数
*   你得到了在什么路径上进行的突变列表
*   **toggleItemCompleted** 动作实际上获得了一个**项目**状态并对其进行了变异，但是 devtools 给出了它在状态树中的位置的完整路径
*   尝试检查/取消检查项目等。并查看渲染计数与执行的突变相比的表现。你可以看到突变和组件之间是一对一的关系。这是自动发生的
*   您不能在操作之外改变状态，否则会引发错误

感谢阅读！我希望这是有用的，也许能激发你尝试一些你有的状态管理想法！:-)