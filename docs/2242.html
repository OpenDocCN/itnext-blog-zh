<html>
<head>
<title>Let’s Migrate Symfony Project to Kubernetes! Part 1: Containerizing the Application.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们将Symfony项目迁移到Kubernetes！第1部分:应用程序的容器化。</h1>
<blockquote>原文：<a href="https://itnext.io/containerizing-symfony-application-a2a5a3bd5edc?source=collection_archive---------0-----------------------#2019-04-23">https://itnext.io/containerizing-symfony-application-a2a5a3bd5edc?source=collection_archive---------0-----------------------#2019-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c441a4329cd2740647674e625ee01486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nf67c_XuIhHxWHVAR00Fsg.jpeg"/></div></div></figure><h1 id="48f0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于这个系列</h1><p id="cf3b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个系列中，我们将讨论现有Symfony项目到Kubernetes (K8s)的迁移。无论您当前在何处以及如何发布您的应用程序:裸机、VM、容器编排平台，通过遵循本指南，您将能够将其部署到K8s集群。</p><p id="a7f3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些<strong class="ky ir"> how to </strong>文章的目标读者是那些已经了解Kubernetes、Docker和持续集成(CI)的一些基础知识、想要学习新技巧或者只想完成工作的人。</p><p id="5ba7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">本系列的每一部分都致力于一个特定的主题:构建Docker环境，<a class="ae lz" href="https://medium.com/@babenko.i.a/testing-symfony-application-d02317d4018a" rel="noopener">在不同的级别上测试应用程序</a>，<a class="ae lz" href="https://medium.com/@babenko.i.a/publishing-symfony-application-with-helm-ecb525b34289" rel="noopener">用Helm将应用程序部署到Kubernetes】，</a><a class="ae lz" href="https://medium.com/@babenko.i.a/building-continuous-delivery-pipeline-2cc05e213935" rel="noopener">构建CI管道</a>。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="cb56" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">关于第1部分</h1><p id="9288" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于Kubernetes是一个容器编排平台，它要求您的应用程序被容器化，以便部署到集群。在本文中，我们将构建一个Docker设置，它是为K8s部署和开发中的方便使用而准备的。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="8836" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">关于虚拟项目</h1><p id="94d7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我为这个系列准备了一个简单的Symfony 4应用程序，包括:</p><ul class=""><li id="cf7b" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">具有三个字段的产品实体:id、价格、名称。</li></ul><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><ul class=""><li id="9fc0" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">具有显示动作的产品控制器，用于呈现给定的产品。</li></ul><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><ul class=""><li id="f60a" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">用Bootstrap构建的布局树枝模板。尽管您可以将CDN用于引导资产，但我下载了css文件并将其放在项目的assets文件夹中，以向您展示如何处理静态文件。</li></ul><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><ul class=""><li id="c453" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">产品小枝模板。</li></ul><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="0307" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">让我们集装箱化！</h1><p id="e9d5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要运行虚拟项目，我们需要以下服务:</p><ul class=""><li id="fc22" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">作为数据库的MySQL。对于生产环境来说，使用数据库容器不是最好的主意，但是对于开发和测试来说，这是一个很好的选择。</li><li id="7b2a" class="mm mn iq ky b kz nb ld nc lh nd ll ne lp nf lt mr ms mt mu bi translated">Nginx作为web服务器。</li><li id="5570" class="mm mn iq ky b kz nb ld nc lh nd ll ne lp nf lt mr ms mt mu bi translated">PHP-FPM处理PHP代码。</li></ul><h2 id="b558" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">MySQL图像</h2><p id="27c4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">以下是MySQL图像的完整docker文件:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d235" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">参数<strong class="ky ir">版本</strong>允许我们使用单个Dockerfile文件构建不同MySQL版本的图像。</p><p id="c9cb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">上下文目录中的<strong class="ky ir"> init </strong>文件夹包含将在容器启动时执行的文件。让我们在这个文件夹中创建<strong class="ky ir"> products.sql </strong>，为我们的应用程序初始化<strong class="ky ir"> products </strong>表:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="01d8" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">Nginx图像</h2><p id="a4ae" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">构建<strong class="ky ir">生产就绪</strong>映像时，尝试:</p><ul class=""><li id="6130" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">使用<strong class="ky ir">阿尔卑斯山</strong>图片作为基础，它们是轻量级的。</li><li id="2d8d" class="mm mn iq ky b kz nb ld nc lh nd ll ne lp nf lt mr ms mt mu bi translated">避免为生产装载卷，制作完整的映像。</li><li id="5578" class="mm mn iq ky b kz nb ld nc lh nd ll ne lp nf lt mr ms mt mu bi translated">如果您的开发映像与生产映像略有不同，请使用阶段。构建映像时，可以指定一个目标，它代表docker文件中的一个阶段。最终图像将包括达到目标的所有步骤。</li></ul><p id="6852" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">记住以上所有内容，我们可以为Nginx创建一个docker文件:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1869" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可能会注意到，我们只复制生产阶段的资产，而不复制开发阶段的资产。我们是故意这样做的:为了开发，我们将在容器中装入一个卷。这将允许我们实时查看文件更改，而无需每次都重建映像。</p><p id="0b28" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们复制到镜像的服务器配置几乎重复了Symfony教程提供的配置。唯一的变化是文档根目录和FastCGI url，它指向PHP-FPM服务:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="9fda" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">FPM图片</h2><p id="aa1b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">PHP-FPM Docker文件比前几个文件更复杂:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cd28" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们一步一步来。</p><h2 id="fc7e" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated"><strong class="ak">系统依赖</strong></h2><p id="3b6e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">安装系统依赖项时，请尝试:</p><ul class=""><li id="0c65" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">使用<strong class="ky ir"> -无缓存</strong>标志。在这种情况下，软件包管理器不会将下载的文件保存在缓存中，这样会减小图像的大小。</li><li id="b3fd" class="mm mn iq ky b kz nb ld nc lh nd ll ne lp nf lt mr ms mt mu bi translated">将<strong class="ky ir"> - virtual </strong>用于您希望在某个时候删除的依赖项。</li></ul><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4219" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们在生产中不需要<strong class="ky ir">git</strong>(Composer需要)或者<strong class="ky ir">autoconf gcc g++ make</strong>(XDebug需要)。我们将删除这些依赖项，这就是为什么我们将它们标记为<strong class="ky ir"> dev-deps </strong>。</p><h2 id="cc01" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">PHP扩展</h2><p id="cfee" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Docker附带有用的助手，可以简化PHP扩展的安装和配置。让我们使用它们来安装用于数据库连接的MySQL PDO驱动程序和用于代码覆盖的XDebug:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="2942" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">PHP配置</h2><p id="8d9a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您可以通过将<strong class="ky ir"> ini </strong>文件复制到image <strong class="ky ir"> conf.d </strong>文件夹来更改PHP设置:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8fa8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在<strong class="ky ir"> default.ini </strong>文件中，我们更改应用程序的内存限制和报告级别:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="2aff" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">设计者</h2><p id="e6d0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我建议将<strong class="ky ir"> hirak/prestissimo </strong>包和Composer一起安装。它将大大减少建造时间:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dcb3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将在PHP-FPM开发容器中安装项目文件，这就是为什么我们不复制源文件，也不在开发阶段执行<strong class="ky ir"> composer install </strong>。</p><h2 id="07ac" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">测试阶段</h2><p id="201f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最好将应用程序代码及其依赖项封装在映像中，这些代码将用于测试:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dc91" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">并将项目文件所有者更改为默认的PHP-FPM用户:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="2554" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">生产阶段</h2><p id="4ce9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们不需要生产映像中的开发依赖关系:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a34a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们也不需要XDebug:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e3a1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Nor dev utils:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="90c2" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">Docker撰写</h1><p id="f6b3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Docker Compose是在本地构建图像和创建容器的最佳选择。它允许你只用一个命令来构建环境:<strong class="ky ir"> docker-compose up </strong>。为了方便起见，Compose会自动从<strong class="ky ir">加载环境变量。env </strong>文件，位于执行<strong class="ky ir"> docker-compose </strong>命令的同一个目录下。</p><p id="e460" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们在<strong class="ky ir">中为Docker设置声明一些有用的变量。env </strong>文件:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="eed6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们指定了我们想要使用的软件的确切版本和数据库凭证。</p><p id="cc5d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们准备在<strong class="ky ir"> docker-compose.yml </strong>文件中为开发环境设置服务:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7827" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">乍看起来相当复杂，但不用担心，我们将仔细研究每个服务。</p><h2 id="7256" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">Nginx服务</h2><p id="23ff" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用<strong class="ky ir">的Nginx版本。env </strong>文件，我们需要将其声明为一个构建参数:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="89db" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们使用应用程序的根目录作为上下文，因为我们需要访问assets文件夹:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4633" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">由于上下文文件夹不同于Dockerfile所在的文件夹，我们需要显式设置Dockerfile的位置:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1096" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在让我们指示Docker只为开发阶段构建Nginx映像:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7903" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如我之前提到的，对于开发环境，我们将在容器中挂载assets文件夹:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="abff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">没有PHP-FPM启动Nginx容器是没有意义的:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7a54" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了访问web服务器，我们需要将端口从我们的主机转发到容器。为了避免一些冲突，我们将使用<strong class="ky ir"> 8000 </strong>:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="05d5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们再看一下完整的Nginx服务定义:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="15ae" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">PHP-FPM服务</h2><p id="1022" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">PHP-FPM服务定义与Nginx非常相似:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a521" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我想在这里澄清几件事:</p><ul class=""><li id="d831" class="mm mn iq ky b kz lu ld lv lh mo ll mp lp mq lt mr ms mt mu bi translated">我们将所有项目文件挂载到容器<strong class="ky ir"> app </strong>文件夹中，因为我们希望立即看到PHP文件中所做的更改。</li><li id="28f9" class="mm mn iq ky b kz nb ld nc lh nd ll ne lp nf lt mr ms mt mu bi translated">在启动时，我们安装Composer依赖项并启动PHP-FPM守护进程。如果我们在Dockerfile中安装依赖项，然后挂载应用程序文件，供应商目录将会丢失，如果它在主机上不存在的话。</li></ul><h2 id="386c" class="ng jz iq bd ka nh ni dn ke nj nk dp ki lh nl nm km ll nn no kq lp np nq ku nr bi translated">MySQL服务</h2><p id="b4b1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">数据库定义略有不同:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5be6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">上下文目录是一个专用的<strong class="ky ir"> mysql </strong>文件夹:这个图像不需要访问项目文件。我们使用环境变量来指定数据库和root密码。我们共享一个卷来保存数据库更改，以防重启容器。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="aab9" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">让我们运行应用程序吧！</h1><p id="2f0d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Docker设置就绪。现在我们只需要配置应用程序。让我们创建<strong class="ky ir"> .env.dev </strong>文件并设置数据库连接:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="815b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，我们可以使用以下命令构建开发环境:</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="92dc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">启动PHP-FPM服务需要一些时间，因为我们首先安装Composer依赖项，然后才启动PHP-FPM。</p><p id="32fa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当所有服务准备就绪后，在浏览器中打开<a class="ae lz" href="http://localhost:8000/products/1" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/products/1</a>。您应该会看到一个产品页面:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/4f376b7e3f573b3810e0bbb918505d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSun_CqACV7BB2_Jimx4SQ.png"/></div></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="d648" class="jy jz iq bd ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv bi translated">下一步是什么？</h1><p id="37a0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">应用程序现在已经容器化，可以部署到K8s了。<a class="ae lz" href="https://medium.com/@babenko.i.a/publishing-symfony-application-with-helm-ecb525b34289" rel="noopener">在下一个指南</a>中，我将向您展示如何定义一个Helm包并将其部署到Kubernetes Docker桌面。</p><p id="d797" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">感谢您的阅读，下次再见！</p></div></div>    
</body>
</html>