<html>
<head>
<title>What are Front End Service layers?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是前端服务层？</h1>
<blockquote>原文：<a href="https://itnext.io/what-are-front-end-service-layers-4dba95db21bb?source=collection_archive---------0-----------------------#2021-06-03">https://itnext.io/what-are-front-end-service-layers-4dba95db21bb?source=collection_archive---------0-----------------------#2021-06-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/7f5306640a82ef115183ec5fb061cb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTMmttAlrERMvMMEBONUhA.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">汉堡包是对n层应用程序各层的一个极好的比喻。<a class="ae jh" href="https://www.flickr.com/photos/98756468@N04/9408040030/in/photolist-fkmEwJ-8Y2gTC-xRkYT-rc1SS-6RQRzy-CnwdEP-Cy1HqX-EVEk8e-5WJomt-xRnFC-vbHsiB-7hN55p-fi3WnV-58bYyM-4iErYj-8AiBhn-UkzWPN-7PXKka-UNEFLs-9rRuHB-tWvFhA-V45rn8-xjQDa-38PhYz-77vh29-ohFKxV-iaHYbD-9dVSHj-a6wbyK-8SsUm5-9UEw15-r788FD-BdrtY9-8rRDMD-8HBzFM-hwDXSq-peUZUy-7Y1cn2-dmvh8o-xjQGg-mMykHi-8GdKhL-CDZ91L-412ofm-h6rLvR-8HBzQn-WLHXZN-4PBtuM-qtE3ya-r8Zs9g" rel="noopener ugc nofollow" target="_blank">媒体新闻</a>拍摄并在其<a class="ae jh" href="https://creativecommons.org/licenses/by/2.0/" rel="noopener ugc nofollow" target="_blank">许可</a>的期限内使用。</figcaption></figure><div class=""/><div class=""><h2 id="846b" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">组成全栈项目团队的技能是什么？</h2></div><p id="046b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当我在1995年开始构建web应用程序时，它们被称为数据驱动网站，当时令人兴奋的行话是“三层”。这个想法是一个web应用程序有三层。在浏览器中运行的前端显示“视图”层，而在后端则是“控制器”层(可能是一个REST API，或者只是将“视图”呈现为HTML的代码)，以及“模型”层，这是一些易变数据的表示。(我知道3层架构比网站要早得多，但是直到20世纪90年代中期，很少有人听说过网站，更不用说3层或MVC架构了)。</p><p id="0252" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">随着时间的推移，后端的复杂性不断增加，出现了消息队列、事件源服务、带有与REST APIs和WebSockets交互的解析器的GraphQL服务，以及将数据存储在任何或所有Postgres、Redis和MongoDb类型的数据存储中的服务。并且需要部署和配置这些服务；那时候通常是在你自己的硬件上，但现在变成了云服务或容器，它们抽象了硬件并支持可编程的服务编排。</p><h2 id="5621" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">分离关注点</h2><p id="9e95" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">看到既需要后端开发人员又需要开发运维专家的需求并不罕见。当人们提到Devops时，他们往往指的是知道如何组合配置AWS、GCP和Azure的人，他们用Perl、Puppet脚本和Kubernetes配置等编写代码。对于那些编写Java SpringBoot REST APIs、Ruby on Rails、Node JS、Elixir、Python或其他服务的人来说，这显然是一套不同的技能，他们理解业务和流程建模，但他们的Devops技能通常扩展到创建一个<code class="fe mt mu mv mw b">docker-compose.yml</code>文件和配置CircleCI。</p><p id="7404" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">类似地，开发UX和应用程序设计方面的人，通常以草图文档或Figma文件或类似文件的形式交付，需要不同于网站分析和SEO方面的人和实际构建前端代码的开发人员的技能。大多数项目领导都认识到，进行独立的用户验收测试比仅仅信任开发人员要好得多。</p><p id="8e30" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然而，经常被忽视的是，在“前端开发人员”的保护伞下，真正获得结构和数据的开发人员与真正获得CSS的开发人员之间有着明显的区别，以及如何呈现用户实现UX和设计师愿景所需的数据和控件。</p><h1 id="b561" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">现代多层web应用程序</h1><p id="43a2" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">现代应用程序(无论是响应式web应用程序，还是在桌面或手机上运行的本机代码应用程序)都可以分为以下几层(您可以根据需要添加或删除一些元素，但这基本上就是现代应用程序的样子)。</p><figure class="nj nk nl nm gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ni"><img src="../Images/ac84fb90219579190656f032d187fc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUXnETeKScfmBUvaPu2jYQ.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">现代n层应用程序架构看起来很像顶部照片中的汉堡，你不觉得吗？</figcaption></figure><h2 id="a760" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">现代后端</h2><p id="26ba" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">在最底层，我们有已故苏格兰小说家伊恩·M·班克斯所说的“<a class="ae jh" href="https://www.goodreads.com/book/show/7937744-surface-detail" rel="noopener ugc nofollow" target="_blank">基础现实</a>”。这是硬件层，一切都在其上运行。</p><figure class="nj nk nl nm gu iw gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/424e9acd5cc677d8931ff8637be48097.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*7l42FedonIeCojwXQikN2Q.jpeg"/></div></figure><p id="5fc1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这可能是您的开发笔记本电脑，运行由简单的<code class="fe mt mu mv mw b">docker-compose.yml</code>文件编排的docker容器，也可能是基于云的系统，如Amazon Web Services、Heroku、Google Cloud Platform或Microsoft Azure。事实上，这可能是一种混合，本地开发服务在本地容器中运行，而共享开发、准备和生产服务在一个主要的云服务上运行，通过CI/CD系统部署，如CircleCI、Travis或类似的服务。</p><p id="25fa" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这些容器中运行的是传统的后端服务；REST API服务器，通常带有用于实时交互的相关Web Socket服务器，带有相关视图和投影的数据库或事件源服务器，以及通过GraphQL解析器连接到其他服务的GraphQL服务器。通常，这些服务通过消息总线(如RabbitMQ或Kafka)连接在一起。</p><p id="6a07" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">后端如何工作与前端无关。后端做什么和前端需要的数据之间的抽象通常由一个或多个REST APIs、WebSocket连接或GraphQL服务来定义。</p><h2 id="1376" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">现代前端</h2><p id="c056" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">UI开发人员主要关心的是，当需要时，正确的数据和约定的<code class="fe mt mu mv mw b">shape</code>被提供给他们的UI组件，并且UI中的用户活动发出的动作被解释和执行。</p><figure class="nj nk nl nm gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj no"><img src="../Images/d85d6d7ce70cd9487d792e7c81bf7733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uahmnutJ3QnshBsuKiTf-g.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">前端服务层(从上面的n层图中提取)</figcaption></figure><p id="ea28" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">沿着堆栈向上，大多数现代前端使用某种状态管理层来处理用户生成的操作，以及来自后端套接字连接或GraphQL订阅的事件。前端还需要能够进行API或GraphQL查询，从后端请求数据，并将数据推送到后端；将响应转换成前端组件可以使用的状态数据。</p><p id="e43d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是<strong class="lb jl">前端服务</strong>层；位于样式规则和组件之下的层，在前端运行，获取和更新数据，并管理UI和后端之间的交互。</p><p id="b1bc" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">虽然这适用于几乎所有的现代web应用系统，无论是Angular、Vue还是Svelte，但我最熟悉React，因此，在React上下文中，UI组件开发人员以服务挂钩的形式获得了她需要的所有处理程序和控件。(Vue使用“复合函数”来达到类似的目的。)</p><h2 id="84c0" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">UX和用户界面设计</h2><p id="8328" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">在前端堆栈的最顶端是用户体验(UX)和设计层。这一层由UX和视觉设计专家合作开发，严格来说不是软件层，而是文档层。UX专家计算出应用程序需要做什么，以及用户将如何使用该应用程序以一种让他们最开心的方式实现他们的目标。设计专家与UX专家密切合作，将愿景转化为线框图表、屏幕设计、字体选择和调色板。</p><p id="fd1b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一名优秀的业务分析师将与UX和设计人员以及应用程序的样本用户、构建应用程序的开发人员和分析团队密切合作，他们会影响与SEO相关的事情，如<code class="fe mt mu mv mw b">slugs</code>与<code class="fe mt mu mv mw b">ids</code>的使用、url路由路径、标题等。</p><p id="190b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">关于屏幕元素的决策必然会影响关于必须开发哪些组件、如何设计它们的样式、它们需要的数据以及它们需要处理的用户操作的决策。</p><blockquote class="np"><p id="d68f" class="nq nr jk bd ns nt nu nv nw nx ny lu dk translated">但是一次又一次，我从事的项目错误地认为UI和前端服务开发人员之间没有区别。</p></blockquote><p id="7ba4" class="pw-post-body-paragraph kz la jk lb b lc nz kl le lf oa ko lh li ob lk ll lm oc lo lp lq od ls lt lu in bi translated">前端编程团队通常会划分职责，更适合样式和组件设计的开发人员与设计人员更紧密地合作，而更适合建模用户操作和底层数据管理的开发人员与后端团队更紧密地合作。但是一次又一次，我从事的项目错误地认为UI和前端服务开发人员之间没有区别。</p><h2 id="87ba" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">前端服务</h2><p id="39e0" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">让应用看起来像设计和UX专家所设想的那样所需的技能，与有效地对用户、数据和后端服务之间的交互进行建模所需的技能截然不同。在一个复杂的项目中，你需要比前端服务开发人员更多的UI开发人员。</p><p id="7fd3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在React上下文中，前端服务开发人员将专注于开发React挂钩集，以及Redux操作、reducers和选择器。开发人员可以根据应用程序的特定需求，利用API和套接字管理器、GraphQL查询系统、sagas等中间件。(Vue开发人员通常会使用Vuex之类的东西，Angular开发人员可能会使用NgRx，而Svelte开发人员可以使用Stores，但值得注意的是，Redux实际上并没有绑定到React，几乎可以在任何地方使用。我写过使用Redux的Node JS命令行应用。)</p><p id="b37a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">UI和前端服务开发人员必须从约定的数据表面开始工作，通常指定为组件可以用来验证输入的<code class="fe mt mu mv mw b">shapes</code>文件，就像GraphQL或OpenAPI定义形成前端服务和后端之间的契约关系一样。</p><p id="6043" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您的特定应用程序可能不使用GraphQL(尽管GraphQL很棒，您确实应该使用它)，但它总是需要一种与数据交互和处理用户交互的方式。</p><h1 id="5b7d" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">示例:显示任务的简单组件</h1><p id="755b" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated"><em class="oe">如果您不关心React / Redux JavaScript代码示例，请跳过这一点(下面的“为什么不两者都要”)。</em></p><p id="955e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">举例来说，让我们想象我们的应用程序有一个允许用户显示任务的功能。所以我们需要定义什么是任务，一个显示任务的简单组件，以及一个用给定的<code class="fe mt mu mv mw b">id</code>获取任务的服务。</p><h2 id="3b01" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">什么是任务？</h2><p id="797b" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">为了简单起见，我们假设一个任务有一个<code class="fe mt mu mv mw b">id</code>、一个<code class="fe mt mu mv mw b">title</code>和一个可选的<code class="fe mt mu mv mw b">text</code>属性。我们需要定义一个任务的<code class="fe mt mu mv mw b">shape</code>。通过事先达成一致，我们在UI和前端服务之间建立了一个<em class="oe">契约</em>。(Typescript的粉丝当然会定义一个<code class="fe mt mu mv mw b">Interface</code>而不是使用React的<code class="fe mt mu mv mw b">prop-types</code>)</p><p id="c758" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/services/tasks/shapes.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="a467" class="lv lw jk mw b gz oj ok l ol om">import { string } from 'prop-types'</span><span id="48f4" class="lv lw jk mw b gz on ok l ol om">export const taskShape = {<br/>  id: string.isRequired,<br/>  title: string.isRequired,<br/>  text: string<br/>}</span><span id="9ff9" class="lv lw jk mw b gz on ok l ol om">export const taskDefaults = { text: null }</span></pre><p id="9015" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里有一个简单的、功能性的React组件，如果它有一个<code class="fe mt mu mv mw b">id</code>和<code class="fe mt mu mv mw b">title</code>就显示一个任务，如果有<code class="fe mt mu mv mw b">text</code>就显示它。</p><p id="a798" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/components/ShowTask/ShowTask.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="1f23" class="lv lw jk mw b gz oj ok l ol om">import {<br/>  taskDefaults,<br/>  taskShape<br/>} from 'services/tasks/shapes'</span><span id="5f3a" class="lv lw jk mw b gz on ok l ol om">const ShowTask = ({ id, title, text }) =&gt; {<br/>  if (!id || !title) return null</span><span id="597b" class="lv lw jk mw b gz on ok l ol om">  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;{title} ({id})&lt;/h2&gt;<br/>      {text &amp;&amp; &lt;p&gt;{text}&lt;/p&gt;}<br/>    &lt;/div&gt;<br/>  )<br/>}<br/>ShowTask.propTypes = { ...taskShape }<br/>ShowTask.defaultProps = { ...taskDefaults }</span><span id="4aa4" class="lv lw jk mw b gz on ok l ol om">export default ShowTask</span></pre><h2 id="375f" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">任务服务</h2><p id="2bcb" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">为了从后端加载任务，我们需要一个任务服务。假设我们使用Redux进行状态管理，并且有一个REST API公开了一个<code class="fe mt mu mv mw b">/task/:id</code>端点，我们将需要一些调用API的动作，以及返回新状态的reducers，给定一个先前的状态和一个动作。我们还需要一种方法来选择处于Redux存储当前状态的任务。</p><h2 id="4975" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">行动</h2><p id="e3bb" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">为了简单起见，让我们假设我们正在使用不可思议的<code class="fe mt mu mv mw b"><a class="ae jh" href="https://github.com/agraboso/redux-api-middleware" rel="noopener ugc nofollow" target="_blank">redux-api-middlware</a></code>库来处理任务的获取。</p><p id="8ebb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/services/tasks/actions.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="3c5c" class="lv lw jk mw b gz oj ok l ol om">import { createAction } from 'redux-api-middleware'</span><span id="5c19" class="lv lw jk mw b gz on ok l ol om">import { apiBase, headers } from 'config'</span><span id="4ca1" class="lv lw jk mw b gz on ok l ol om">export const taskLoad = <em class="oe">id</em> =&gt;<br/>  createAction({<br/>    endpoint: `${apiBase}/task/${id}`,<br/>    headers,<br/>    method: 'GET',<br/>    types: [<br/>      'TASK_LOAD',<br/>      'TASK_LOAD_SUCCESS',<br/>      'TASK_LOAD_FAIL'<br/>    ]<br/>})</span></pre><p id="bf8e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当被调度时，这个动作将被<code class="fe mt mu mv mw b">redux-api-middleware</code>捕获，然后<code class="fe mt mu mv mw b">dispatch</code>一个简单的<code class="fe mt mu mv mw b">TASK_LOAD</code>动作，然后从<code class="fe mt mu mv mw b">endpoint</code>获取任务数据。如果请求成功，中间件将把任务数据作为<code class="fe mt mu mv mw b">payload</code>传递给<code class="fe mt mu mv mw b">TASK_LOAD_SUCCESS</code>动作。如果请求失败，则<code class="fe mt mu mv mw b">error</code>作为<code class="fe mt mu mv mw b">payload</code>传递给<code class="fe mt mu mv mw b">TASK_LOAD_FAIL</code>动作。</p><p id="b8c1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">注意:<code class="fe mt mu mv mw b">taskLoad</code>动作可以很容易地进行<code class="fe mt mu mv mw b">GraphQL</code>查询，或者通过<code class="fe mt mu mv mw b">WebSocket</code>连接发送消息。任何此类操作的具体实现都与提供数据的服务的性质相关联。有些人会认为使用<code class="fe mt mu mv mw b">GraphQL</code>及其数据解析器会使Redux这样的状态管理系统变得无关紧要，但是我不同意这种观点。像这样的Redux动作的好处在于，无论数据传输层实际上是什么，逻辑都很容易封装和隔离在前端服务中的一致位置。</p><h2 id="53ac" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">还原剂</h2><p id="0b42" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">我们需要reducers来执行这些操作，以保持共享的应用程序状态是最新的。</p><p id="7527" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/services/tasks/reducer.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="205a" class="lv lw jk mw b gz oj ok l ol om">import { handleActions } from 'redux-actions'</span><span id="af27" class="lv lw jk mw b gz on ok l ol om">export const taskLoad = state =&gt; ({ ...state, loading: true })</span><span id="01b3" class="lv lw jk mw b gz on ok l ol om">export const taskLoadSuccess = (state, { payload: task }) =&gt; ({<br/>  ...state,<br/>  loading: false,<br/>  task: { ...task }<br/>})</span><span id="377d" class="lv lw jk mw b gz on ok l ol om">export const taskLoadFail = (state, { payload: error }) =&gt; ({<br/>  ...state,<br/>  loading: false,<br/>  error: error.toString()<br/>})</span><span id="1480" class="lv lw jk mw b gz on ok l ol om">export const INITIAL_STATE = {<br/>  loading: false,<br/>  error: null,<br/>  task: null<br/>}</span><span id="3e05" class="lv lw jk mw b gz on ok l ol om">export const handlers = {<br/>  TASK_LOAD: taskLoad,<br/>  TASK_LOAD_SUCCESS: taskLoadSuccess,<br/>  TASK_LOAD_FAIL: taskLoadFail<br/>}</span><span id="3fad" class="lv lw jk mw b gz on ok l ol om">export default handleActions(handlers, INITIAL_STATE)</span></pre><h2 id="38c6" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">选择器</h2><p id="d2c1" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">我们需要一个选择器，这样我们就可以轻松地从Redux状态中检索加载的任务。假设我们的服务的缩减器在<code class="fe mt mu mv mw b">tasks</code>被安装到Redux store的<code class="fe mt mu mv mw b">state</code>中，我们可以编写一个选择器，比如:</p><p id="c8cf" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/services/tasks/selectors.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="d301" class="lv lw jk mw b gz oj ok l ol om">export const getTask = ({ tasks: { task } }) =&gt; <em class="oe">task</em></span></pre><h2 id="b1e8" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">钩住</h2><p id="f7fd" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">为了对组件本身隐藏所有这些复杂性，任务服务公开了一个名为<code class="fe mt mu mv mw b">useTaskLoader</code>的钩子，它在组件挂载时加载一个任务。</p><p id="2008" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/services/tasks/hooks.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="ff02" class="lv lw jk mw b gz oj ok l ol om">import { useEffect } from 'react'<br/>import { useDispatch, useSelect } from 'redux'<br/>import { taskLoad } from './actions'<br/>import { getTask } from './selectors'</span><span id="3287" class="lv lw jk mw b gz on ok l ol om">export const useTaskLoader = id =&gt; {<br/>  const dispatch = useDispatch()<br/>  const task = useSelector(getTask)</span><span id="a1eb" class="lv lw jk mw b gz on ok l ol om">  useEffect(() =&gt; {<br/>    dispatch(taskLoad(id))<br/>  }, [dispatch, id])<br/>  <br/>  return task<br/>}</span></pre><p id="cf2e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">useTaskLoader</code>钩子获取一个任务的<code class="fe mt mu mv mw b">id</code>，获取Redux <code class="fe mt mu mv mw b">dispatch</code>函数，获取已经在Redux store的<code class="fe mt mu mv mw b">state</code>中的任务，然后使用React的<code class="fe mt mu mv mw b">useEffect</code>钩子通过提供的<code class="fe mt mu mv mw b">id</code>来<code class="fe mt mu mv mw b">dispatch</code>执行<code class="fe mt mu mv mw b">taskLoad</code>动作。</p><p id="8c61" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">只有当<code class="fe mt mu mv mw b">dispatch</code>函数或<code class="fe mt mu mv mw b">id</code>值改变时，该效果才会重新运行，但是<code class="fe mt mu mv mw b">task</code>的值会随着<code class="fe mt mu mv mw b">taskLoad</code>动作的副作用调用获取任务的API调用并分派<code class="fe mt mu mv mw b">taskLoadSuccess</code>动作而改变</p><h2 id="b528" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用钩子</h2><p id="05ac" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">添加一个使用<code class="fe mt mu mv mw b">useTaskLoader</code>钩子加载任务并将任务数据传递给纯<code class="fe mt mu mv mw b">ShowTask</code>组件的组件。</p><p id="0ab0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">src/components/ShowTask/index.js</code></p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="98f3" class="lv lw jk mw b gz oj ok l ol om">import PureShowTask from './ShowTask'</span><span id="4f85" class="lv lw jk mw b gz on ok l ol om">import { useTaskLoader } from './hooks'</span><span id="8f48" class="lv lw jk mw b gz on ok l ol om">const ShowTask = ({ id }) =&gt; {<br/>  const task = useTaskLoader(id)<br/>  <br/>  return &lt;PureShowTask {...task} /&gt;<br/>}</span></pre><p id="52e1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mt mu mv mw b">ShowTask</code>从哪里得到它的<code class="fe mt mu mv mw b">id</code>？假设在组件层次结构的较高位置，从位置路径(例如类似于<code class="fe mt mu mv mw b">/task/:id</code>的路线)或从从任务概要列表中选择任务的某人处提取<code class="fe mt mu mv mw b">id</code>。</p><h2 id="e626" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">应用程序结构</h2><p id="4b84" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">我们现在有了下面的应用程序结构，突出显示了<code class="fe mt mu mv mw b">ShowTask/ShowTask.js</code>，这是UI开发人员需要关注的唯一组件:</p><pre class="nj nk nl nm gu of mw og oh aw oi bi"><span id="9fb6" class="lv lw jk mw b gz oj ok l ol om">src/<br/>  config.js<br/>  components/<br/>    ShowTask/<br/>      index.js<br/><em class="oe">      ShowTask.js<br/></em>  services/<br/>    tasks/<br/>      actions.js<br/>      hooks.js<br/>      reducer.js<br/>      selectors.js<br/>      shapes.js</span></pre><p id="18cf" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当然，您还需要为所有这些东西添加测试，并且理想情况下使用诸如<code class="fe mt mu mv mw b"><a class="ae jh" href="https://storybook.js.org" rel="noopener ugc nofollow" target="_blank">Storybook</a></code>之类的东西来单独显示<code class="fe mt mu mv mw b">ShowTask</code>组件。</p><h2 id="6416" class="lv lw jk bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">前端= UI +前端服务</h2><p id="dea8" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">组件现在可以独立于向组件提供数据的服务逻辑进行开发。UI开发人员现在可以相对独立于应用程序的其他部分，专注于<code class="fe mt mu mv mw b">src/components/ShowTask/ShowTask.js</code>中的组件。如果任务的定义发生了变化，比如说因为需求发生了变化，或者由于后端对任务的理解发生了变化，那么这种变化可以首先反映在<code class="fe mt mu mv mw b">src/services/tasks/shapes.js</code>中，然后独立地传播到组件和服务。</p><p id="8df7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">随着被操作的数据类型变得越来越复杂，并且随着可用用户交互数量的增长，UI和前端服务之间的这种关注点分离(通过数据的形状松散耦合)变得越来越重要。</p><h1 id="01d2" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">为什么不两者都要？</h1><p id="501a" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">一些开发人员是非常有天赋的人，他们可以在改进组件外观和管理应用程序数据之间来回穿梭。这对复杂性有限、时间限制很少的小型项目来说非常好。</p><figure class="nj nk nl nm gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj oo"><img src="../Images/a8ce15ff8d026dc6a22e3ac75651952d.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/1*PBjMRj8WDyPEeqc2sC-Rog.gif"/></div></div></figure><p id="0d08" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当你的任务是在截止日期前构建一个中等复杂的web应用程序时，你会发现区分UI和前端服务工作与区分前端和后端工作一样重要。像这样的划分允许你更有效地扩展你的团队。当然你不会期望UI开发人员完全忽略前端服务代码，你也不会期望编写Redux动作的人完全避免了解样式是如何工作的；但是一般来说，在一个中型到大型的项目中，前端的这些不同方面需要不同的概念框架和技能。</p><h1 id="a933" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">“全栈”开发者呢？</h1><p id="027c" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">没有真正的全栈开发者。</p><p id="e0c2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">随着职业的发展，所有的开发人员都会找到他们的舒适区。有些人倾向于硬件和云服务层，有些人喜欢构建事件和服务交互的语法，有些人过着真实的生活，编写GraphQL模式定义或Redux reducers，有些人甚至喜欢前端开发的可视化方面。</p><p id="2735" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">指望一个人是jQuery、Material UI、Tailwind CSS、React、Swagger、Java、C#、SQL、Ruby、NodeJS、GoLang、Perl、AWS、GCP、Azure、Terraform、Puppet和Capybara的专家，简直太可笑了。过去，我使用了几乎所有的工具，在所有的层面上工作过，我非常确定地知道我喜欢和享受的部分，以及我不感兴趣的部分。</p><blockquote class="op oq or"><p id="5261" class="kz la oe lb b lc ld kl le lf lg ko lh os lj lk ll ot ln lo lp ou lr ls lt lu in bi translated">我理想的‘全栈’是React+Redux+graph QL+Node+Docker(针对Postgres、RabbitMQ、Nginx、API或mock APIs等)+GitHub+circle ci+CodeCov+Snyk+Heroku+Netlify。因此，从许多定义来看，这使我成为“全栈”，因为我可以用这些工具构建和维护任何东西。但是，如果我必须使用Jenkins建立一个CI管道，从BitBucket中触发的PRs将Angular应用程序部署到AWS实例，那么我将让其他人来做这件事。</p></blockquote><h1 id="4aa1" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">扩展开发团队</h1><p id="82bd" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">作为一个项目，因此开发团队规模扩大，专业化是不可避免的，并提高效率。复杂的前端总是需要比前端服务开发人员更多的UI开发人员，就像复杂的后端总是需要比部署脚本更多的人来定义和交付API表面一样。</p><p id="6898" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所有开发人员、UX和设计专家、产品所有者/理想客户/领域专家以及BAs、QA和SEO专家之间的持续沟通和知识共享至关重要。</p><p id="15b5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所有开发人员，包括UI、前端服务和后端服务开发人员，都应该参与对应用程序所有方面的拉请求的审查，即使只是为了确保对数据形状、动作和事件的名称或查询名称和路径的共同理解不会在没有警告的情况下被更改。</p><ul class=""><li id="7884" class="ov ow jk lb b lc ld lf lg li ox lm oy lq oz lu pa pb pc pd bi translated">人物角色和示例数据需要在所有层中保持一致。在UX和后端团队的推动下，前端服务开发人员将创建<em class="oe">fixture</em>如<code class="fe mt mu mv mw b">src/fixtures/tasks.js</code>导出一致的示例数据集，这些数据集可以由故事书故事、单元测试导入，或用于播种mock REST API或GraphQL服务。</li><li id="279f" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">在上面的例子中，任务的<code class="fe mt mu mv mw b">shape</code>需要在后端API、数据库和事件层以及前端中明确定义。前端服务开发者将再次在故事、测试和种子中使用<code class="fe mt mu mv mw b">src/fixtures/tasks.js</code>中的<em class="oe">装置</em>。</li><li id="5c4c" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">属性、事件、动作和API端点的命名需要正交和清晰。</li><li id="9cf0" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">任何开发人员都需要很容易地构建一个模拟后端，用一组一致的数据作为种子，供开发和测试时使用，并且任何人都应该能够在自己的笔记本电脑上部署一个具有基线数据的工作系统。</li><li id="84cb" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated">作为CI/CD管道的一部分，对共享开发、暂存和生产系统的部署必须完全自动化。每当您部署一个新的开发服务器时，您也应该部署一个新的storybook服务器，以便团队的其他成员可以单独预览变更。</li></ul><p id="4475" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">贡献过程、命名和部署过程都需要成为整个开发团队的共同知识。这使得团队中的每个成员都可以专注于他们的专业领域和他们的团队互动，从而将所有事情整合在一起。</p><h1 id="450e" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">完整的项目团队</h1><p id="d38e" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">鉴于没有全栈开发人员这种东西，谈论全栈团队更有意义。</p><figure class="nj nk nl nm gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj pj"><img src="../Images/bc3e730ef7eec8466dc894115e2e5f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lJflng-u-HavNT9ORE68w.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">这些是构成梦想的东西。</figcaption></figure><p id="d1d7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">上图强调了全栈团队所需的技能领域和联系。您的团队的确切组成将因项目而异。在较小的项目中，您可能会发现将一些开发人员的角色合并到一个人身上，跳过专门的QA角色，或者有一个人将UX和设计角色，或者UI开发人员和设计角色合并在一起。不管项目的规模如何，从个人需要扮演的角色的角度来考虑你的团队是有帮助的。</p><p id="a665" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在一些非常小的项目中，我是一名UI、前端服务和后端服务开发人员，通过部署到Heroku和Netlify，我已经最大限度地减少了对Devops的需求，团队将UX和设计角色与另一名UI开发人员结合在一起，所以只有我们两个人编写代码，加上一名兼职BA + Scrum领导者，客户自己同时担任产品和SEO专家。但是在大型项目中很少看到这种重叠，尽管大多数开发人员，特别是如果栈是构建在节点后端上的JavaScript前端，可以在需要时在他们专业领域之外做出贡献。</p><h1 id="ce48" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">结论</h1><p id="1820" class="pw-post-body-paragraph kz la jk lb b lc mo kl le lf mp ko lh li mq lk ll lm mr lo lp lq ms ls lt lu in bi translated">当您为您的项目团队整合需求时，请确保您不会陷入前端开发人员的谬论，假设UI和前端服务角色是可互换的。擅长让ui好看的人和让数据好看的人有不同的技能。UI开发人员将与设计专家密切合作，而前端服务开发人员将与后端服务开发人员和Devops人员密切合作，并将比UI开发人员更多地参与软件架构决策。</p><p id="60ea" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">随着项目的扩展，确保你有一个团队，或一个团队的计划，涵盖所有上述角色，即使一个人可能需要承担一个以上的角色。</p><p id="0712" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一旦商定了数据的形式，就可以独立开发ui和前端服务。通常UI开发人员会比前端服务开发人员多，甚至在更大的项目中也是如此，因为使组件看起来正确通常比转换数据要多得多。类似地，构建后端服务通常比任何前端工作都要多得多。</p><p id="784e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">将Node用于后端带来了开发人员互操作性的优势，使开发人员更容易同时处理后端和前端任务，但这绝不是必需的，而且，理想情况下，前端不应该关心后端如何工作。</p><p id="edec" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通常通过REST APIs和WebSocket通道或GraphQL查询和订阅向前端服务公开的后端表面需要保持一致，并映射到前端中定义的形状，这些形状构成了UI和前端服务层之间的契约的一部分。</p><p id="4a02" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">开发人员和其他项目专家之间的交流需要畅通无阻，但是共同的假设、数据模式、事件名称和其他术语都需要记录并保持最新。对这些工件进行更改需要一个治理过程，以便可能影响几个应用层的更改不会被随意或单方面地实现。开发人员应该被给予对所有其他代码库的监督，并被邀请对新的拉请求执行代码审查。</p><p id="7c93" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">请记住这句老话:一周的编码可以节省一小时的计划。</p><p id="6e3c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi">—</p><p id="6f8b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">《伊恩·M·班克斯》《T2》《文化》《T3》是有史以来最好的推理小说，而《T4》《文化》在我看来是所有科幻小说中最好的发明。</p><h1 id="3f59" class="mx lw jk bd lx my mz na ma nb nc nd md kq ne kr mg kt nf ku mj kw ng kx mm nh bi translated">链接</h1><ul class=""><li id="17a6" class="ov ow jk lb b lc mo lf mp li pk lm pl lq pm lu pa pb pc pd bi translated"><a class="ae jh" href="https://github.com/agraboso/redux-api-middleware" rel="noopener ugc nofollow" target="_blank">https://github.com/agraboso/redux-api-middleware</a></li><li id="99dd" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated"><a class="ae jh" href="https://www.goodreads.com/book/show/7937744-surface-detail" rel="noopener ugc nofollow" target="_blank">https://www.goodreads.com/book/show/7937744-surface-detail</a></li><li id="c199" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated"><a class="ae jh" href="https://storybook.js.org" rel="noopener ugc nofollow" target="_blank">https://storybook.js.org</a></li><li id="eafd" class="ov ow jk lb b lc pe lf pf li pg lm ph lq pi lu pa pb pc pd bi translated"><a class="ae jh" href="https://www.redbubble.com/i/mug/A-week-of-coding-can-save-an-hour-of-planning-by-davesag/13000089.9Q0AD" rel="noopener ugc nofollow" target="_blank">https://www . red bubble . com/I/mug/A-week-of-coding-can-save-A-hour-of-planning-by-Dave sag/13000089.9 q0ad</a></li></ul><p id="6b72" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi">—</p><p id="f5f2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像这样但不是订户？你可以通过<a class="ae jh" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>