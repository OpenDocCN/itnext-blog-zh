<html>
<head>
<title>Feature Deployments in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中的功能部署</h1>
<blockquote>原文：<a href="https://itnext.io/feature-deployments-in-kubernetes-c74bdcff0d8e?source=collection_archive---------0-----------------------#2018-07-25">https://itnext.io/feature-deployments-in-kubernetes-c74bdcff0d8e?source=collection_archive---------0-----------------------#2018-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b2c11a46aaaa6de26e1fb51b5c1d4600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PSi5S5ywZqjAXRsjmmh1A.png"/></div></div></figure><p id="9662" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">许多公司想要同样的东西。能够部署代码来测试特定的功能/缺陷，而无需将其实际部署到开发、试运行或生产中。Kubernetes通过使用名称空间使这变得非常容易。有关名称空间的更多信息，请查看:<a class="ae kw" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/overview/working-with-objects/namespaces/</a></p><p id="6fd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以问题是:我们如何让我们的项目可以被部署到一个名称空间，而不必教我们所有的开发人员kubernetes的来龙去脉？要实现这一点，需要做几件事:</p><ul class=""><li id="1950" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">命名空间</li><li id="f000" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">配置映射</li><li id="a0da" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">秘密</li><li id="1bfe" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">正在部署的服务的清单</li><li id="453a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">一个将一切联系在一起的脚本</li></ul><p id="43a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定采取配置和约定相结合的方式来完成上述任务。</p><h1 id="02a7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><span class="l mj mk ml bm mm mn mo mp mq di"> T </span>何命名空间</h1><p id="11cd" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">我编写了一个简单的namespace.json模板，可以用名称空间覆盖它</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d726" class="nf lm iq nb b gy ng nh l ni nj">{<br/>  "kind": "Namespace",<br/>  "apiVersion": "v1",<br/>  "metadata": {<br/>    "name": "${NAMESPACE}",<br/>    "labels": {<br/>      "name": "${NAMESPACE}"<br/>    }<br/>  }<br/>}</span></pre><h1 id="0606" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">配置图</h1><p id="ec78" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">每个服务都有自己的配置变量，需要在运行时可供服务使用。我决定采用一种传统的方法，混合了how <a class="ae kw" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">。env </a>作品。</p><p id="6009" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">写入以'. env '结尾的文件的键值对将被组合在一起，并添加到环境变量服务将使用的配置映射中。</p><p id="5c13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下列方式为每个服务创建配置映射:</p><ul class=""><li id="e72d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><code class="fe nk nl nm nb b">.env/staging.env</code>将为暂存环境中的所有服务设置变量</li><li id="3c88" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nk nl nm nb b">.env/service-a.env</code>将为所有<code class="fe nk nl nm nb b">service-a</code>设置变量，而不管环境如何</li><li id="3bf2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nk nl nm nb b">.env/feature-myfeature.env</code>将为<code class="fe nk nl nm nb b">feature-myfeature</code>名称空间中的所有服务设置变量</li><li id="c827" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nk nl nm nb b">.env/staging/service-a.env</code>将为暂存环境中的所有<code class="fe nk nl nm nb b">service-a</code>设置变量</li><li id="d325" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><code class="fe nk nl nm nb b">.env/staging/feature-myfeature/service-a.env</code>将只为运行<code class="fe nk nl nm nb b">feature-myfeature</code>名称空间的staging上的<code class="fe nk nl nm nb b">service-a</code>设置变量</li></ul><p id="a8de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我意识到，允许基于特性设置配置的粒度，而不是强制将配置写入环境名称，可能有些矫枉过正…但是我觉得这是必要的，以便提供一种方法来测试一个特性，而不会在合并分支时意外覆盖上游配置。</p><p id="445f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是将每个文件组合成最终env文件的python脚本:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="eba7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在下面的脚本部分讨论如何创建实际的配置图。</p><h1 id="4968" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">秘密</h1><p id="ba31" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">每个重要的服务都有一些连接到各种其他服务所必需的秘密，比如密码、api令牌、随机数等。由于信息的敏感性，您不希望将其作为项目的一部分签入。因此，我们根据运行时定义的env变量创建一个kubernetes秘密。由于我一直在做的项目使用了<a class="ae kw" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>，我将讨论这是如何在那个环境中完成的。然而，它应该很容易应用于另一个集成工具，如<a class="ae kw" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>。剧本是这样的:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它遍历环境变量，并根据我们要部署到的环境将它们存储为密钥/值。因此，任何用前缀<code class="fe nk nl nm nb b">STAGING_</code>定义的键都将被写入到登台环境的机密文件中。由于功能部署是登台环境的分支，为登台环境定义的秘密适用于功能部署。</p><h1 id="d7f5" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">服务清单</h1><p id="320b" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">我在这里采用了传统的方法。将部署在与我们当前环境的名称相匹配的目录下定义的任何kubernetes清单。如上所述，特性部署是分支于登台环境的，所以来自登台的清单被应用于特性部署。</p><h1 id="2ee7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">脚本将所有这些联系在一起</h1><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="eda3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生的事情基本上是这样的:</p><ul class=""><li id="1518" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">如果<code class="fe nk nl nm nb b">NAMESPACE</code>不是默认的，创建一个新的名称空间</li><li id="ae93" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">基于设置的环境变量创建一个kubernetes秘密</li><li id="7720" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">结合所有的。env文件合并到一个文件中，并基于该文件创建一个kubernetes配置映射</li><li id="632c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">将<code class="fe nk nl nm nb b">MANIFEST_IN_DIR</code>中定义的所有清单应用到<code class="fe nk nl nm nb b">NAMESPACE</code>中</li><li id="ff76" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">等待每个<code class="fe nk nl nm nb b">IMAGES</code>的展示完成</li></ul><p id="de30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用<code class="fe nk nl nm nb b">envsubst</code>将环境变量注入到我为名称空间和清单创建的模板中。</p><h1 id="1c8a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="7c60" class="pw-post-body-paragraph jy jz iq ka b kb mr kd ke kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv ij bi translated">这在很大程度上仍是一项进行中的工作。我希望将大部分内容清理干净并放到我的github上，这样它就可以很容易地应用到其他项目中。我省略了部署过程中的一些步骤，比如构建/推送映像、在合并开发分支后清理名称空间，以及部署到生产环境而不是部署到暂存环境。我计划在以后的文章中写下这是如何实现的。</p></div></div>    
</body>
</html>