<html>
<head>
<title>Compose validation logics with Vue 3.0 and Vuelidate.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue 3.0和Vuelidate编写验证逻辑。</h1>
<blockquote>原文：<a href="https://itnext.io/compose-validation-logics-with-vue-3-0-and-vuelidate-20416d734295?source=collection_archive---------0-----------------------#2020-07-25">https://itnext.io/compose-validation-logics-with-vue-3-0-and-vuelidate-20416d734295?source=collection_archive---------0-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/2434a36974659bc8bfc42ea21b2f65f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*umxkFnS1lxMUWZX8nFF_IQ.png"/></div></figure><p id="b565" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">表单验证是许多前端工程师面临的最复杂的问题之一。虽然实现起来不是超级难，但是组织验证逻辑很难。</p><p id="afa0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有了Vue，你有两个主要的选择，<strong class="jz iu">基于模板的验证</strong>和<a class="ae kv" href="https://github.com/logaretm/vee-validate" rel="noopener ugc nofollow" target="_blank"> vee-validate </a>或者<strong class="jz iu">基于模型的验证</strong>和<a class="ae kv" href="https://github.com/vuelidate/vuelidate" rel="noopener ugc nofollow" target="_blank"> vuelidate </a>。这两个都是很棒的图书馆。vee-validate非常简单，可以快速解决问题。vuelidate有更多的灵活性。</p><p id="31ba" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">另一方面，感谢Vue核心团队成员，Vue 3.0正在发布。Vue 3.0的一个突破性变化是组合api。它使我们能够编写更有组织性和可组合性的代码。</p><p id="10d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后vuelidate还会推出一个新的api，带有Vue 3.0 composition api。因为它非常灵活，使开发人员能够编写超级有组织的代码，本文解释说</p><ul class=""><li id="6c49" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">Vue 2.x兼容vuelidate和Vue 3.0之间的实现差异</li><li id="30c9" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">如何用组合api和vuelidate组织验证逻辑</li></ul><h1 id="efb6" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">Vue 2.x验证概述</h1><p id="440c" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">在介绍下一代vuelidate之前，让我向您展示一下它在Vue 2.x上的样子。我准备了一个简单的登录表单，如下所示。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="750b" class="mw ll it ms b gy mx my l mz na">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;input type="email" placeholder="Email" v-model="email" /&gt;<br/>    &lt;input type="password" placeholder="Password" v-model="password" /&gt;<br/>    &lt;button type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/250a96f069f0da3b228a58d7a2c8e5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*Yc7RaA2M3Jr3CqFF6wz2OQ.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">简单登录表单</figcaption></figure><p id="b7ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要用vuelidate实现验证逻辑，您需要做3件事。</p><ol class=""><li id="8b44" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku ng lc ld le bi translated">实现验证逻辑</li><li id="728e" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku ng lc ld le bi translated">控制何时验证</li><li id="5f49" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku ng lc ld le bi translated">如果需要，显示错误</li></ol><h2 id="5870" class="mw ll it bd lm nh ni dn lq nj nk dp lu ki nl nm ly km nn no mc kq np nq mg nr bi translated">实现验证逻辑</h2><p id="4578" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">验证逻辑看起来非常简单，如下所示。<code class="fe ns nt nu ms b">validations</code>部分用于实现如何验证每个数据。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8ebc" class="mw ll it ms b gy mx my l mz na">&lt;script&gt;<br/>import { required, email, minLength } from "vuelidate/lib/validators";</span><span id="1946" class="mw ll it ms b gy nv my l mz na">export default {<br/>  data() {<br/>    return {<br/>      email: "",<br/>      password: "",<br/>    }<br/>  },<br/>  validations: {<br/>    email: { required, email },<br/>    password: { required, minLength: minLength(8) }<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="6e35" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你像上面那样设置，你可以用vue devtool检查验证状态。<code class="fe ns nt nu ms b">$v</code> computed属性显示每个验证状态。在键入任何值之前，<code class="fe ns nt nu ms b">$v.email.$invalid</code>为真，因为电子邮件要求验证失败。在输入某些内容时，<code class="fe ns nt nu ms b">$v.email.required</code>变为false，<code class="fe ns nt nu ms b">$v.email.email</code>也变为false。在输入格式化的邮件后，<code class="fe ns nt nu ms b">$v.email.email</code>和<code class="fe ns nt nu ms b">$v.email.$invalid</code>变为真。</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0d353e187d6063c502120546b6e26ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*JcPHopsLLrOxFF-DIzSdeA.gif"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">验证状态更改</figcaption></figure><h2 id="a0d8" class="mw ll it bd lm nh ni dn lq nj nk dp lu ki nl nm ly km nn no mc kq np nq mg nr bi translated">控制何时验证</h2><p id="3172" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">要控制验证时间，您必须知道<code class="fe ns nt nu ms b">$error</code>和<code class="fe ns nt nu ms b">$dirty</code>属性。<code class="fe ns nt nu ms b">$error</code>属性是<code class="fe ns nt nu ms b">$dirty</code>和<code class="fe ns nt nu ms b">$invalid</code>的逻辑组合。</p><p id="5289" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><code class="fe ns nt nu ms b">$invalid</code>纯粹具有验证状态。如上所述，在用户做某件事之前，<code class="fe ns nt nu ms b">$invalid</code>为真。但是只有<code class="fe ns nt nu ms b">$invalid</code>，在用户做一些事情之前，验证状态是失败的。为了处理这个问题，<code class="fe ns nt nu ms b">$dirty</code>属性存在了。<code class="fe ns nt nu ms b">$dirty</code>属性检查用户是否触摸了目标输入字段。如果用户输入内容，您必须将<code class="fe ns nt nu ms b">$dirty</code>改为true。</p><p id="f930" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好了，想想什么时候验证就够了。在这个例子中，这两个计时可能是好的。</p><ul class=""><li id="5e39" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">每个输入字段验证应该在<code class="fe ns nt nu ms b">@blur</code>触发</li><li id="842d" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">在提交表单之前。如果有任何错误，最好禁用登录按钮</li></ul><p id="b4c7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要实现模糊计时验证，您可以像下面这样将<code class="fe ns nt nu ms b">$touch()</code>添加到<code class="fe ns nt nu ms b">@blur</code>。<code class="fe ns nt nu ms b">$touch</code>功能改变<code class="fe ns nt nu ms b">$dirty</code>为真。所以<code class="fe ns nt nu ms b">$dirty</code>和<code class="fe ns nt nu ms b">$invalid</code>属性都准备好了。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="bbe3" class="mw ll it ms b gy mx my l mz na">// To fire validation in each blur</span><span id="0e81" class="mw ll it ms b gy nv my l mz na">  &lt;input<br/>    type="email"<br/>    placeholder="Email"<br/>    v-model="email"<br/>    @blur="$v.email.$touch()"<br/>  /&gt;</span><span id="8e04" class="mw ll it ms b gy nv my l mz na">  ...</span><span id="4d23" class="mw ll it ms b gy nv my l mz na">  &lt;input<br/>    type="password"<br/>    placeholder="Password"<br/>    v-model="password"<br/>    @blur="$v.password.$touch()"<br/>  /&gt;</span></pre><p id="3a76" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要禁用提交按钮，您可以通过<code class="fe ns nt nu ms b">$v.$invalid</code>。它检查所有验证密钥的<code class="fe ns nt nu ms b">$invalid</code>。那么<code class="fe ns nt nu ms b">div</code>标签必须是<code class="fe ns nt nu ms b">form</code>标签并添加调用一个提交函数。在提交函数内部，先调用<code class="fe ns nt nu ms b">$touch()</code>。它触发所有验证并检查是否有任何错误。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="747c" class="mw ll it ms b gy mx my l mz na">// To disable submit button disabled</span><span id="62ab" class="mw ll it ms b gy nv my l mz na">&lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;</span><span id="7f65" class="mw ll it ms b gy nv my l mz na">// To validate before submission</span><span id="104f" class="mw ll it ms b gy nv my l mz na">&lt;template&gt;<br/>  &lt;form @submit.prevent="login" &gt;<br/>    ...<br/>  &lt;/form&gt;<br/>&lt;/template&gt;</span><span id="a847" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;</span><span id="102f" class="mw ll it ms b gy nv my l mz na">...</span><span id="2e0b" class="mw ll it ms b gy nv my l mz na">  methods: {<br/>    login() {<br/>      this.$v.$touch();<br/>      if (this.$v.$invalid) {<br/>        // DO SOMETHING HERE<br/>      }<br/>    }<br/>  }<br/>...</span></pre><p id="0c39" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，现在您可以控制何时进行验证。</p><h2 id="462e" class="mw ll it bd lm nh ni dn lq nj nk dp lu ki nl nm ly km nn no mc kq np nq mg nr bi translated">如果需要，显示错误</h2><p id="e19f" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">因此，如果需要的话，让我们向用户显示错误。如果你想显示错误，你可以像下面这样实现。您需要检查目标值是否有<code class="fe ns nt nu ms b">$error</code>并显示每个验证的错误消息。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="003a" class="mw ll it ms b gy mx my l mz na">&lt;template&gt;<br/>  &lt;form @submit.prevent="login"&gt;<br/>    &lt;input<br/>      type="email"<br/>      placeholder="Email"<br/>      v-model="email"<br/>      @blur="$v.email.$touch()"<br/>    /&gt;<br/>    &lt;div v-if="$v.email.$error"&gt;<br/>      &lt;p v-if="!$v.email.email"&gt;Please enter a valid email&lt;/p&gt;<br/>      &lt;p v-if="!$v.email.required"&gt;Please enter an email&lt;/p&gt;<br/>    &lt;/div&gt;</span><span id="030f" class="mw ll it ms b gy nv my l mz na">    &lt;input<br/>      type="password"<br/>      placeholder="Password"<br/>      v-model="password"<br/>      @blur="$v.password.$touch()"<br/>    /&gt;<br/>    &lt;div v-if="$v.password.$error"&gt;<br/>      &lt;p v-if="!$v.password.minLength"&gt;<br/>       Password must be more than {{ passwordMinLength }} characters<br/>      &lt;/p&gt;<br/>      &lt;p v-if="!$v.password.required"&gt;Please enter an password&lt;/p&gt;<br/>    &lt;/div&gt;<br/>    <br/>    &lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;</span></pre><p id="c6c6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用Vue 2.x兼容的vuelidate，您需要创建自己的验证消息。</p><p id="d400" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">到目前为止，所有验证都已实现。让我向你展示所有代码的样子。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9832" class="mw ll it ms b gy mx my l mz na">&lt;template&gt;<br/>  &lt;form @submit.prevent="login"&gt;<br/>    &lt;input<br/>      type="email"<br/>      placeholder="Email"<br/>      v-model="email"<br/>      @blur="$v.email.$touch()"<br/>    /&gt;<br/>    &lt;div v-if="$v.email.$error"&gt;<br/>      &lt;p v-if="!$v.email.email"&gt;Please enter a valid email&lt;/p&gt;<br/>      &lt;p v-if="!$v.email.required"&gt;Please enter an email&lt;/p&gt;<br/>    &lt;/div&gt;</span><span id="569f" class="mw ll it ms b gy nv my l mz na">    &lt;input<br/>      type="password"<br/>      placeholder="Password"<br/>      v-model="password"<br/>      @blur="$v.password.touch()"<br/>    /&gt;<br/>    &lt;div v-if="$v.password.$error"&gt;<br/>      &lt;p v-if="!$v.password.minLength"&gt;<br/>       Password must be more than {{ passwordMinLength }} characters<br/>      &lt;/p&gt;<br/>      &lt;p v-if="!$v.password.required"&gt;Please enter an password&lt;/p&gt;<br/>    &lt;/div&gt;<br/>    <br/>    &lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="87c8" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import { required, email, minLength } from "vuelidate/lib/validators";</span><span id="6fab" class="mw ll it ms b gy nv my l mz na">export default {<br/>  data() {<br/>    return {<br/>      email: "",<br/>      password: "",<br/>    }<br/>  },<br/>  validations: {<br/>    email: { required, email },<br/>    password: { required, minLength: minLength(8) }<br/>  },<br/>  methods: {<br/>    login() {<br/>      this.$v.$touch();<br/>      if (this.$v.$invalid) {<br/>        // DO SOMETHING HERE<br/>      }<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="b296" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如你所知，即使这个超级简单的登录表单也有很多代码。所以如果你有更多的领域和更多的其他逻辑，它很容易变得更乱。当我第一次看到这个实现时，我认为模板中的<code class="fe ns nt nu ms b">validations</code>部分和错误消息可以被提取出来或者很简单。</p><h1 id="e755" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用vuelidate进行Vue 3.0验证</h1><p id="5b84" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">Vue 3.0组合api让我们能够超级轻松地组合和组织逻辑。想了解composition api，就看<a class="ae kv" href="https://www.vuemastery.com/courses/vue-3-essentials/why-the-composition-api" rel="noopener ugc nofollow" target="_blank"> Vue精通课程</a>。</p><p id="2999" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以让我们用Vue 3.0 composition api和vuelidate实现相同的登录表单。首先，我们用composition api创建vue项目。<code class="fe ns nt nu ms b">vue-cli</code>是最简单的方法。组合api提供了<code class="fe ns nt nu ms b">@vue/composition-api</code>。</p><p id="b10c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">※如果Vue 3.0发布了，可以直接使用vue-cli，安装Vue 3.0。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8062" class="mw ll it ms b gy mx my l mz na">$ yarn global add @vue/cli  // If you don't have it</span><span id="6b6f" class="mw ll it ms b gy nv my l mz na">$ vue create vuelidate-with-vue-composition-api<br/>$ cd vuelidate-with-vue-composition-api</span><span id="6526" class="mw ll it ms b gy nv my l mz na">$ yarn add <a class="ae kv" href="http://twitter.com/vue/composition-api" rel="noopener ugc nofollow" target="_blank">@vue/composition-api</a></span></pre><p id="af50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">改变<code class="fe ns nt nu ms b">src/components/HelloWorld.vue</code>如下图。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f98c" class="mw ll it ms b gy mx my l mz na">// Form.vue</span><span id="c972" class="mw ll it ms b gy nv my l mz na">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;input type="text" v-model="email"&gt;<br/>    &lt;input type="password" v-model="password"&gt;<br/>    &lt;button type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="b548" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import { reactive, toRefs } from "@vue/composition-api";</span><span id="97a8" class="mw ll it ms b gy nv my l mz na">export default {<br/>  name: "Form",<br/>  setup(){<br/>    const state = reactive({<br/>      email: "",<br/>      password: ""<br/>    });</span><span id="e52e" class="mw ll it ms b gy nv my l mz na">    return {<br/>      ...toRefs(state)<br/>    };<br/>  }<br/>};<br/>&lt;/script&gt;</span><span id="d219" class="mw ll it ms b gy nv my l mz na">// STYLE CAN BE ANYTHING<br/>&lt;style scoped&gt;<br/>div,form {<br/>  display: flex;<br/>  flex-direction: column;<br/>  justify-content: center;<br/>}<br/>input, button {<br/>  width: 300px;<br/>  height: 50px;<br/>  font-size: 1rem;<br/>  margin: 20px auto 0px;<br/>}<br/>p {<br/>  margin: 5px 60px 0 0;<br/>}<br/>&lt;/style&gt;</span></pre><p id="d566" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">而<code class="fe ns nt nu ms b">App.vue</code>一定是下面这个样子。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="e586" class="mw ll it ms b gy mx my l mz na">// Replace HelloWorld component with Form component<br/>&lt;template&gt;<br/>  &lt;div id="app"&gt;<br/>    &lt;img alt="Vue logo" src="./assets/logo.png" /&gt;<br/>    &lt;Form /&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="640a" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import Form from "./components/Form.vue";</span><span id="ad81" class="mw ll it ms b gy nv my l mz na">export default {<br/>  name: "App",<br/>  components: {<br/>    Form<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="afa3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所以还是加上vuelidate吧。其实从Vue 3.0兼容版本开始，vuelidate就被分成了两个包，<code class="fe ns nt nu ms b">@vuelidate/core</code>和<code class="fe ns nt nu ms b">@vuelidate/validators</code>。像<code class="fe ns nt nu ms b">required</code>和<code class="fe ns nt nu ms b">minLength</code>这样的验证逻辑是分离的。而且因为vuelidate还是beta版，它需要<code class="fe ns nt nu ms b">@vue/composition-api</code>作为依赖，也许在不久的将来它会消失。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="f1ca" class="mw ll it ms b gy mx my l mz na">$ yarn add @vuelidate/core @vuelidate/validators</span></pre><p id="bac4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您应该首先设置vuelidate和composition api。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0728" class="mw ll it ms b gy mx my l mz na">// main.js<br/>import Vue from 'vue';<br/>import VueCompositionApi from '@vue/composition-api';<br/>import { VuelidatePlugin } from '@vuelidate/core';<br/>import App from './App.vue';</span><span id="d1ee" class="mw ll it ms b gy nv my l mz na">Vue.config.productionTip = false;</span><span id="b447" class="mw ll it ms b gy nv my l mz na">Vue.use(VueCompositionApi);<br/>Vue.use(VuelidatePlugin);</span><span id="f57f" class="mw ll it ms b gy nv my l mz na">new Vue({<br/>  render: h =&gt; h(App),<br/>}).$mount("#app");</span></pre><p id="1cbb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有设置都已完成！让我们像我上面做的那样实现一个表单验证。</p><h2 id="7aa7" class="mw ll it bd lm nh ni dn lq nj nk dp lu ki nl nm ly km nn no mc kq np nq mg nr bi translated">实现验证逻辑</h2><p id="48c6" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">新的vuelidate是使用Vue 3.0组合api实现的。看起来像下面。一点是你现在不能用<code class="fe ns nt nu ms b">reactive</code>。这就变成了T21的问题。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="76f1" class="mw ll it ms b gy mx my l mz na">// Form.vue</span><span id="70d9" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import { ref } from "@vue/composition-api";<br/>import useVuelidate from "@vuelidate/core";<br/>import { required, email, minLength } from "@vuelidate/validators";</span><span id="1322" class="mw ll it ms b gy nv my l mz na">export default {<br/>  name: "Form",<br/>  setup(){<br/>    const userEmail = ref("");<br/>    const userPassword = ref("");</span><span id="f739" class="mw ll it ms b gy nv my l mz na">    // Validation Logics<br/>    const rules = {<br/>      userEmail: { required, email },<br/>      userPassword: { required, minLength: minLength(8) }<br/>    };<br/>    const $v = useVuelidate(<br/>      rules,<br/>      { userEmail, userPassword }<br/>    );</span><span id="c487" class="mw ll it ms b gy nv my l mz na">    return {<br/>      userEmail,<br/>      userPassword,<br/>      $v<br/>    };<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="1775" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">实际上，当你只看到验证逻辑时，它与Vue 2.x <code class="fe ns nt nu ms b">validations</code>部分非常相似。另一方面，<code class="fe ns nt nu ms b">$v</code>与Vue 2.0兼容的vuelidate有些不同。</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/6dee208838236647bb98bd6be7424728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrxRYLGF-aTetfcpOZIh5Q.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">兼容Vue 3.0的$v</figcaption></figure><p id="7009" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如你在上面看到的，全新的<code class="fe ns nt nu ms b">$errors</code>属性出现了。因为它存储默认的错误信息，所以您不必编写自己的错误信息。</p><h2 id="ad52" class="mw ll it bd lm nh ni dn lq nj nk dp lu ki nl nm ly km nn no mc kq np nq mg nr bi translated">控制何时验证</h2><p id="d089" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">让我们实现输入字段模糊和提交时间验证。</p><p id="001b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">可惜因为原生<code class="fe ns nt nu ms b">$touch</code>函数没有发布，所以必须自己把<code class="fe ns nt nu ms b">$dirty</code>改成true。在<code class="fe ns nt nu ms b">handleBlur</code>和<code class="fe ns nt nu ms b">login</code>函数中实现。希望它能在不久的将来发布。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="eccf" class="mw ll it ms b gy mx my l mz na">&lt;template&gt;<br/>  &lt;form @submit.prevent="login"&gt;<br/>    &lt;input<br/>      type="text"<br/>      v-model="userEmail"<br/>      @blur="handleBlur('userEmail')"<br/>    &gt;<br/>    ...<br/>    &lt;input<br/>      type="password"<br/>      v-model="userPassword"<br/>      @blur="handleBlur('userPassword')"<br/>    &gt;<br/>    &lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;</span><span id="8308" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;</span><span id="7fa9" class="mw ll it ms b gy nv my l mz na">...</span><span id="6d33" class="mw ll it ms b gy nv my l mz na">  setup(){<br/>    <br/>    ...<br/>    <br/>    const handleBlur = (key) =&gt;{<br/>      $v[key].$dirty = true;<br/>    };</span><span id="67a8" class="mw ll it ms b gy nv my l mz na">    const login = () =&gt; {<br/>      $v.$dirty = true;<br/>      if (!$v.$error) {<br/>        // DO SOMETHING HERE<br/>      }<br/>    };</span><span id="5fe9" class="mw ll it ms b gy nv my l mz na">    return {<br/>      userEmail,<br/>      userPassword,<br/>      $v,<br/>      handleBlur<br/>    };<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><h2 id="dc66" class="mw ll it bd lm nh ni dn lq nj nk dp lu ki nl nm ly km nn no mc kq np nq mg nr bi translated">如果需要，显示错误</h2><p id="8038" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">正如我上面提到的，Vue 3.0兼容的vuelidate有<code class="fe ns nt nu ms b">$errors</code>存储默认的错误信息。再配合<code class="fe ns nt nu ms b">v-for</code>使用吧。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d5bb" class="mw ll it ms b gy mx my l mz na">&lt;template&gt;<br/>  &lt;form @submit.prevent="login"&gt;<br/>    &lt;input<br/>      type="text"<br/>      v-model="userEmail"<br/>      @blur="handleBlur('userEmail')"<br/>    &gt;<br/>    &lt;div v-if="$v.userEmail.$error"&gt;<br/>      &lt;p v-for="$error in $v.userEmail.$errors" :key="$error.$property"&gt;<br/>        {{ $error.$message }}<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;</span><span id="c4d0" class="mw ll it ms b gy nv my l mz na">    &lt;input<br/>      type="password"<br/>      v-model="userPassword"<br/>      @blur="handleBlur('userPassword')"<br/>    &gt;<br/>    &lt;div v-if="$v.userPassword.$error"&gt;<br/>      &lt;p v-for="$error in $v.userPassword.$errors" :key="$error.$property"&gt;<br/>        {{ $error.$message }}<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>    &lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;</span></pre><p id="1d17" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，错误消息部分可以分成不同的部分，如下所示。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d933" class="mw ll it ms b gy mx my l mz na">// ErrorMessage.vue</span><span id="4e17" class="mw ll it ms b gy nv my l mz na">&lt;template&gt;<br/>  &lt;div v-if="validationStatus.$error"&gt;<br/>    &lt;p v-for="$error in validationStatus.$errors" :key="$error.$property"&gt;<br/>      {{ $error.$message }}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="4855" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>export default {<br/>  name: "ErrorMessage",<br/>  props: {<br/>    validationStatus: {<br/>      type: Object,<br/>      required: true<br/>    },<br/>  }<br/>};<br/>&lt;/script&gt;<br/>// ADD STYLE IF YOU WANT</span></pre><p id="b966" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建<code class="fe ns nt nu ms b">ErrorMessage</code>组件后，你的模板变得非常干净。模板中的错误消息部分被提取🎉</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1836" class="mw ll it ms b gy mx my l mz na">// Form.vue<br/>&lt;template&gt;<br/>  &lt;form @submit.prevent="login"&gt;<br/>    &lt;input type="text" v-model="userEmail" @blur="handleBlur('userEmail')"&gt;<br/>    &lt;ErrorMessage :validationStatus="$v.userEmail" /&gt;</span><span id="8ad8" class="mw ll it ms b gy nv my l mz na">    &lt;input type="password" v-model="userPassword" @blur="handleBlur('userPassword')"&gt;<br/>    &lt;ErrorMessage :validationStatus="$v.userPassword" /&gt;<br/>  <br/>    &lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;</span></pre><p id="ea1c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有验证逻辑都已实现。让我给你看完整的代码。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6f49" class="mw ll it ms b gy mx my l mz na">// Form.vue<br/>&lt;template&gt;<br/>  &lt;form @submit.prevent="login"&gt;<br/>    &lt;input type="text" v-model="userEmail" @blur="handleBlur('userEmail')"&gt;<br/>    &lt;ErrorMessage :validationStatus="$v.userEmail" /&gt;</span><span id="65a0" class="mw ll it ms b gy nv my l mz na">&lt;input type="password" v-model="userPassword" @blur="handleBlur('userPassword')"&gt;<br/>    &lt;ErrorMessage :validationStatus="$v.userPassword" /&gt;<br/>  <br/>    &lt;button :disabled="$v.$invalid" type="submit"&gt;Login&lt;/button&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;</span><span id="141c" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import { ref } from "@vue/composition-api";<br/>import useVuelidate from "@vuelidate/core";<br/>import { required, email, minLength } from "@vuelidate/validators";<br/>import ErrorMessage from "./ErrorMessage.vue";</span><span id="84a6" class="mw ll it ms b gy nv my l mz na">export default {<br/>  name: "Form",<br/>  components: {<br/>    ErrorMessage,<br/>  },<br/>  setup(){<br/>    const userEmail = ref("");<br/>    const userPassword = ref("");</span><span id="fdfa" class="mw ll it ms b gy nv my l mz na">    const rules = {<br/>      userEmail: { required, email },<br/>      userPassword: { required, minLength: minLength(8) }<br/>    };<br/>    const $v = useVuelidate(<br/>      rules,<br/>      { userEmail, userPassword }<br/>    );</span><span id="76b3" class="mw ll it ms b gy nv my l mz na">    const handleBlur = (key) =&gt;{<br/>      $v[key].$dirty = true;<br/>    };<br/>    const login = () =&gt; {<br/>      $v.$dirty = true;<br/>      if (!$v.$error) {<br/>        // DO SOMETHING<br/>      }<br/>    };</span><span id="b307" class="mw ll it ms b gy nv my l mz na">    return {<br/>      userEmail,<br/>      userPassword,<br/>      $v,<br/>      handleBlur,<br/>      login<br/>    };<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="a441" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有了Vue 3.0 composition api，你已经有了两样东西。</p><ol class=""><li id="f3db" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku ng lc ld le bi translated">因为您不必编写自己的错误消息，所以创建<code class="fe ns nt nu ms b">ErrorMessage</code>组件非常容易。</li><li id="6ed4" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku ng lc ld le bi translated">虽然在Vue 2.x中，验证逻辑在<code class="fe ns nt nu ms b">validations</code>、<code class="fe ns nt nu ms b">methods</code>中是分开的，但在Vue 3.0中，所有与验证相关的逻辑都组织在一个地方。</li></ol><p id="7730" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是组合api可以让你的代码更加简洁。让我告诉你怎么做！</p><h1 id="b643" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">构建验证逻辑</h1><p id="dbef" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">首先，在<code class="fe ns nt nu ms b">Form.vue</code>中创建<code class="fe ns nt nu ms b">useLoginForm</code>函数，并复制粘贴<code class="fe ns nt nu ms b">setup</code>中的所有逻辑，如下图。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="93b0" class="mw ll it ms b gy mx my l mz na">// Form.vue</span><span id="32d2" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import { ref } from "@vue/composition-api";<br/>...</span><span id="43e1" class="mw ll it ms b gy nv my l mz na">export default {<br/>  name: "Form",<br/>  components: { ErrorMessage },<br/>  setup(){    <br/>    const { userEmail, userPassword, $v, handleBlur, login } = useLoginForm();</span><span id="818f" class="mw ll it ms b gy nv my l mz na">    return {<br/>      userEmail,<br/>      userPassword,<br/>      $v,<br/>      handleBlur,<br/>      login<br/>    };<br/>  }<br/>};</span><span id="857b" class="mw ll it ms b gy nv my l mz na">const useLoginForm = () =&gt;{<br/>  const userEmail = ref("");<br/>  const userPassword = ref("");</span><span id="b1d1" class="mw ll it ms b gy nv my l mz na">  const rules = {<br/>    userEmail: { required, email },<br/>    userPassword: { required, minLength: minLength(8) }<br/>  };</span><span id="0fd4" class="mw ll it ms b gy nv my l mz na">  const $v = useVuelidate(<br/>    rules,<br/>    { userEmail, userPassword }<br/>  );</span><span id="82b7" class="mw ll it ms b gy nv my l mz na">  const handleBlur = (key) =&gt;{<br/>    $v[key].$dirty = true;<br/>  };</span><span id="7aeb" class="mw ll it ms b gy nv my l mz na">  const login = () =&gt; {<br/>    $v.$dirty = true;<br/>    if (!$v.$error) {<br/>      // DO SOMETHING<br/>    }<br/>  };</span><span id="2551" class="mw ll it ms b gy nv my l mz na">  return {<br/>    userEmail,<br/>    userPassword,<br/>    $v,<br/>    handleBlur,<br/>    login<br/>  };<br/>};<br/>&lt;/script&gt;</span></pre><p id="35ef" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为<code class="fe ns nt nu ms b">useLoginForm</code>函数只是一个函数，可以像<code class="fe ns nt nu ms b">src/composables/useLoginForm.js</code>一样单独放在一个不同的文件里。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="d153" class="mw ll it ms b gy mx my l mz na">// Form.vue</span><span id="44c8" class="mw ll it ms b gy nv my l mz na">&lt;script&gt;<br/>import { useLoginForm } from "../composables/useLoginForm";<br/>import ErrorMessage from "./ErrorMessage.vue";</span><span id="f086" class="mw ll it ms b gy nv my l mz na">export default {<br/>  name: "Form",<br/>  components: { ErrorMessage },<br/>  setup(){    <br/>    const { userEmail, userPassword, $v, handleBlur, login } = useLoginForm();</span><span id="f28c" class="mw ll it ms b gy nv my l mz na">return {<br/>      userEmail,<br/>      userPassword,<br/>      $v,<br/>      handleBlur,<br/>      login<br/>    };<br/>  }<br/>};<br/>&lt;/script&gt;<br/></span><span id="6eda" class="mw ll it ms b gy nv my l mz na">// src/composables/useLoginForm.js</span><span id="a409" class="mw ll it ms b gy nv my l mz na">import { ref } from "@vue/composition-api";<br/>import useVuelidate from "@vuelidate/core";<br/>import { required, email, minLength } from "@vuelidate/validators";</span><span id="8717" class="mw ll it ms b gy nv my l mz na">export const useLoginForm = () =&gt;{<br/>  const userEmail = ref("");<br/>  const userPassword = ref("");</span><span id="08c3" class="mw ll it ms b gy nv my l mz na">  const rules = {<br/>    userEmail: { required, email },<br/>    userPassword: { required, minLength: minLength(8) }<br/>  };</span><span id="ca30" class="mw ll it ms b gy nv my l mz na">  const $v = useVuelidate(<br/>    rules,<br/>    { userEmail, userPassword }<br/>  );</span><span id="1591" class="mw ll it ms b gy nv my l mz na">  const handleBlur = (key) =&gt;{<br/>    $v[key].$dirty = true;<br/>  };</span><span id="ac83" class="mw ll it ms b gy nv my l mz na">  const login = () =&gt; {<br/>    $v.$dirty = true;<br/>    if (!$v.$error) {<br/>      // DO SOMETHING<br/>    }<br/>  };</span><span id="bf89" class="mw ll it ms b gy nv my l mz na">  return {<br/>    userEmail,<br/>    userPassword,<br/>    $v,<br/>    handleBlur,<br/>    login<br/>  };<br/>};</span></pre><p id="5915" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在<code class="fe ns nt nu ms b">Form.vue</code>超级干净但是可以理解！即使在<code class="fe ns nt nu ms b">Form.vue</code>中加入其他类似fetch的逻辑，你也可以用同样的方式进行组合，并保持<code class="fe ns nt nu ms b">Form.vue</code>非常干净。</p><h1 id="c672" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">包裹</h1><p id="f54e" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">到目前为止，这篇文章解释说</p><ul class=""><li id="0e06" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">Vue 2.x兼容vuelidate和Vue 3.0之间的实现差异</li><li id="fccf" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">如何用组合api和vuelidate组织验证逻辑</li></ul><p id="767b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如有疑问，欢迎随时写评论！非常期待Vue 3.0的发布！谢谢你。</p><h1 id="0ff4" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">参考</h1><ul class=""><li id="f0c0" class="kw kx it jz b ka mi ke mj ki oc km od kq oe ku lb lc ld le bi translated">某视频剪辑软件</li><li id="2b71" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://github.com/logaretm/vee-validate" rel="noopener ugc nofollow" target="_blank"> vee-validate </a></li><li id="6366" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://github.com/vuelidate/vuelidate" rel="noopener ugc nofollow" target="_blank"> vuelidate </a></li><li id="2d13" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://github.com/vuejs/vue-cli-plugin-vue-next" rel="noopener ugc nofollow" target="_blank"> vue-cli </a></li><li id="7c4b" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated"><a class="ae kv" href="https://www.vuemastery.com/" rel="noopener ugc nofollow" target="_blank"> Vue掌握度</a></li></ul></div></div>    
</body>
</html>