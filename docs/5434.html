<html>
<head>
<title>ES6 Iterators and Generators — when are they actually useful?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6迭代器和生成器——它们什么时候真正有用？</h1>
<blockquote>原文：<a href="https://itnext.io/es6-iterators-and-generators-when-are-they-actually-useful-e954cab345cc?source=collection_archive---------1-----------------------#2021-03-04">https://itnext.io/es6-iterators-and-generators-when-are-they-actually-useful-e954cab345cc?source=collection_archive---------1-----------------------#2021-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd02517bbcfff4d63bd92d1cf970291f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MT3vt7yr362L_MNs"/></div></div></figure><p id="eec9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迭代器和生成器(某种程度上)是ES6引入的新JavaScript特性。当我第一次遇到迭代器和生成器时，我很高兴将它们添加到我的工具库中。我甚至写了一篇关于迭代器和生成器的文章，你可以在这里查看<a class="ae kz" href="https://isamatov.com/iterators-and-generators-work-perfect-together/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6fb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，作为近年来多个项目的前端开发人员，我还没有遇到过积极使用迭代器或生成器的情况。这句话的反义词可能是<a class="ae kz" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>，其中发电机是主要的构建模块。但我并不认为这是一个有价值的例子，因为在redux-saga中，生成器的使用是使用库的一个强制副作用。</p><p id="0981" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在做了更多的挖掘之后，我发现了一些用例，它们比简单的“Hello World”类型的代码更进一步，更接近真实世界的场景。让我们从迭代器开始。</p><h1 id="3a2d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么使用迭代器</h1><p id="7acb" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在ES6中，迭代器是内置的符号，用于将自定义对象转化为可迭代对象。如果你想了解更多关于符号和迭代器的知识，看看<a class="ae kz" href="https://isamatov.com/iterators-and-generators-work-perfect-together/" rel="noopener ugc nofollow" target="_blank">我的帖子。</a></p><p id="bf22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能会想:“为什么要不厌其烦地为您的自定义对象添加迭代器呢”？相反，您可以通过编写一个定制的实用函数来迭代对象来完成同样的事情。你没有错——对于任何编程语言，都有十几种不同的方法来解决任何给定的问题。</p><p id="b6d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，将迭代器视为标准化定制对象的一种更优雅的方式是很有用的。它们为定制数据结构在更大的JS环境中很好地工作提供了一种方式。</p><p id="4600" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，提供定制数据结构的库经常使用它们。例如，<a class="ae kz" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank">不可变。JS </a>库使用迭代器为它们的定制对象(如<code class="fe md me mf mg b">Map</code>)提供本地Javascript功能。</p><p id="f2a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据经验，当您需要为封装良好的定制数据结构提供本机迭代功能时，值得考虑迭代器。我说封装良好是因为你不想让不熟悉迭代器的人对实现细节感到困惑。</p><p id="3305" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迭代器的另一个有趣的用途是创建一个简单的实用方法，将普通的旧JavaScript对象转换成可迭代对象，这也是我在项目中用到的:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="5e8c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么要使用发电机</h1><p id="ff40" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">生成器的一个众所周知的用途是使编写迭代器更容易。上面带<code class="fe md me mf mg b">getIterableMap</code>的例子可以写成更简洁的形式:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看起来简单多了，对吧？如果你想了解更多关于这个生成器函数的内部工作原理，以及为什么它是创建迭代器的完美工具，请查看我的帖子。</p><p id="208e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当考虑生成器时，尽量不要将它们与常规的for循环进行比较是很有用的。相反，可以把它们看作是内置于JavaScript语言中的强大的流原语。这让我们看到了生成器的主要优势——惰性评估。</p><p id="b2ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">惰性求值是一种健壮的数据流技术。这对于处理不明确或内存开销大的数据特别有用。借助延迟求值，您可以按需计算数据集，而不是像传统的for循环那样提前计算。它提供了更有效的内存使用，并可以帮助执行操作，否则会冻结应用程序。</p><p id="bdc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个例子，当用户向下滚动时，我们从一个API获取电影:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6c7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了模拟用户滚动，我使用了一个简单的<code class="fe md me mf mg b">setInterval</code>客户端实现。但这并不能改变要点。正如你所看到的，我们不知道收集的最终规模。相反，我们使用按需方法获取，并让API告诉我们何时停止。生成器提供了一个方便的<code class="fe md me mf mg b">done</code>结果属性，当我们用完了我们的列表时，它会向我们发出信号。</p><p id="6917" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，对于发电机，有两个主要标准需要考虑:</p><ul class=""><li id="7809" class="mn mo it kd b ke kf ki kj km mp kq mq ku mr ky ms mt mu mv bi translated">您不知道正在迭代的集合的最终大小。例如，当您的集合来自分页的请求，并且您需要不断获取新的项，直到流用完。</li><li id="61ba" class="mn mo it kd b ke mw ki mx km my kq mz ku na ky ms mt mu mv bi translated">您可能正在对巨大的二进制文件执行计算，如果您试图同时执行这些操作，可能会冻结您的应用程序。因此，您可以将计算应用到块上。您可以使用按需方法一次完成一个任务。</li></ul><h1 id="251e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="29cb" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我提供的两个例子通常不是您在构建web应用程序时经常遇到的。这就是为什么生成器仍然有非常合适的用例。因此，通过在代码库中包含迭代器或生成器来添加实值，总是值得仔细检查的。否则，你可能会不必要地让和你一起工作的其他人感到困惑。顺便提一下，甚至Airbnb <a class="ae kz" href="https://airbnb.io/javascript/#iterators-and-generators" rel="noopener ugc nofollow" target="_blank">的工程师也建议不要在代码中使用生成器和迭代器。</a></p><p id="828c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我倾向于认为，在编写封装良好的代码(如实用程序库)时，使用生成器和迭代器更安全。因为这样客户端就不需要为实现细节而烦恼了。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="6166" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">原载于2021年3月4日</em><a class="ae kz" href="https://isamatov.com/iterators-generators-useful/" rel="noopener ugc nofollow" target="_blank"><em class="ni">【https://isamatov.com】</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>