<html>
<head>
<title>Serverless Twitter bot with Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用谷歌云的无服务器Twitter机器人</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-twitter-bot-with-google-cloud-35d370676f7?source=collection_archive---------0-----------------------#2018-07-29">https://itnext.io/serverless-twitter-bot-with-google-cloud-35d370676f7?source=collection_archive---------0-----------------------#2018-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2980" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章通过开发一个Twitter书签机器人来探索使用Google Cloud组件的无服务器开发。该机器人允许用户通过向机器人的Twitter用户发送直接消息或在推文中提及机器人来保存和检索链接。</p><p id="65e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该机器人使用Google Cloud函数作为其业务逻辑，使用NoSQL数据库Google Cloud Datastore来存储和查询链接，使用消息队列Google Cloud Pubsub来进行函数之间的通信。</p><h1 id="f6e2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是无服务器？</h1><p id="68f7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">无服务器或功能即服务，允许开发人员通过实现事件驱动的业务逻辑的功能来创建应用程序。无服务器平台将功能部署在短期容器中，以响应触发这些功能的事件。这种触发事件包括外部端点上的HTTP请求或云组件中的活动，例如由其他无服务器功能发布到队列的消息。</p><p id="7bc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器为功能提供了近乎无限的可扩展性，因为平台部署了足够多的功能容器来处理任何时候发生的大量触发事件，并允许应用程序开发者忽略运行应用程序的操作方面。</p><h1 id="e286" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">生产发展</h1><p id="8d1b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">无服务器平台通过提供具有不同语言运行时的容器来支持用多种编程语言编写函数，并支持在触发事件发生时调用和监控每种语言的函数。</p><p id="c48f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人最熟悉静态类型的语言，比如Java、Scala和Rust，但是我觉得这个bot是一个足够小的项目，使用Google Cloud Functions提供的内嵌JavaScript编辑器可能会更有成效。</p><p id="e764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内联JavaScript编辑器将代码完全保存在Google Cloud中，每当有人保存对代码的更改时，新版本的函数将部署在NodeJS容器中，以处理下一个触发事件。代码通过Google Cloudstack的函数日志进行调试和监控。</p><h1 id="5e19" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">机器人的功能规范</h1><p id="c812" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Twitter将通过向一个端点(一个webhook)发送HTTP请求来与我们的bot进行交互，我们在Twitter API中注册了这个端点。端点必须能够响应每小时的加密活动挑战，Twitter将定期向端点发布一批直接消息和推文提及，作为JSON数据。我们的机器人将需要解析所有的直接消息和推文，并把它们分成机器人的命令。该机器人应该支持以下命令</p><ol class=""><li id="7a6f" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">机器人应该保存用户在直接消息或推文中发送给机器人用户的链接。链接应该用消息中包含的任何标签进行注释。</li><li id="ad1e" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">如果用户发送包含单词“列表！”，机器人应该用一些用户链接的列表来响应。如果消息包含标签，那么只应该选择带有这些标签的链接。</li></ol><p id="c8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了开放机器人供公众使用，人们希望允许用户注册机器人，这样机器人就可以跟踪他们，并让他们向机器人用户发送直接消息，但这是以后的版本，我现在只是让机器人通过Twitter用户界面跟踪我自己的用户。</p><h1 id="d044" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">设计</h1><p id="0906" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们的机器人将被实现为两个无服务器功能</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/a04491be2e87577300a7dffb9f6d9007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*3OnSLhkg6trm-Rere69aqA.png"/></div></figure><ol class=""><li id="154a" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">一个<strong class="jp ir"> <em class="mk"> twitterHook </em> </strong>函数公开了一个端点，并由来自Twitter的HTTP请求触发。该函数处理对Twitter的加密活动挑战的响应，并接收和解析批量活动数据的帖子。它将批处理分成单独的命令，以存储链接或执行列表，并将命令作为消息发布到Google Pubsub命令主题。</li><li id="293f" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">一个<strong class="jp ir"> <em class="mk"> performCommand </em> </strong>函数由命令主题上的消息触发，并执行一个命令，要么在Google Cloud Datastore中存储一个链接，要么查询链接并将结果作为Twitter direct消息发送。</li></ol><p id="e2a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在一个函数中完成所有这些工作，但是这需要链接异步数据存储和列表发送操作，并且会使代码和错误处理变得复杂。如果在向Twitter API发送直接消息时速度缓慢或超时，这也可能会使无服务器功能花费太长时间来完成大批量操作。为了能够快速伸缩，无服务器平台只让函数运行几分钟就终止它们，这样函数就可以快速完成。</p><p id="92d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以将<strong class="jp ir"> <em class="mk"> performCommand </em> </strong>函数的工作分成两个独立的函数，一个存储链接，另一个响应列表命令，但是这要么需要发布到两个不同的主题，要么如果两个函数都由每个消息的相同主题触发，就会导致不必要的函数调用。</p><p id="f614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第三种方法是为结果列表创建一个额外的主题，并让<strong class="jp ir"><em class="mk">perform command</em></strong>函数发布到这个主题，而不是通过Twitter API直接发送消息。结果列表主题将触发一个单独的函数，并发出直接消息。如果list命令不经常出现，这可能会导致它们的等待时间更长。</p><p id="6d02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不经常调用的函数可能需要更长时间才能完成，因为它不太可能有可重用的运行容器来处理触发事件。启动一个新的容器会增加第一个函数执行的额外时间，这就是所谓的无服务器冷启动问题。</p><h1 id="db04" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">谷歌云的功能相当于Twitter的网络钩子</h1><p id="ab09" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一旦我们在Twitter开发人员控制台中为我们的bot创建了一个用户和应用程序，Twitter API就允许我们注册一个端点，一个webhook，它将被调用，并通知帐户上的活动。这些通知包括帐户何时收到直接消息，或何时创建提及用户的推文。要使webhook获得Twitter的批准，它还需要对初始加密注册挑战和Twitter每小时发送的周期性挑战做出响应。</p><p id="59dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在下面创建Google Cloud函数，并将其配置为由Google Cloud控制台生成的端点触发。当函数在触发了异步发布操作(稍后将通过回调完成)后返回时，函数和回调调用响应对象上的<strong class="jp ir"> send </strong>以让平台知道工作何时完成是很重要的。</p><p id="4443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">APP_SECRET等环境变量来自我们的bot应用程序的Twitter开发人员控制台，并且已经在Google Cloud控制台中的<strong class="jp ir"> <em class="mk"> twitterHook </em> </strong>函数的配置中指定(我知道，Google不建议在环境变量中存储机密，但是enterprise vault不是这个项目的选项)。</p><p id="a28a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建函数后，我们还需要向Twitter API发送请求，将函数的端点注册为webhook，并订阅bot用户的活动。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="9f34" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">谷歌云发布</h1><p id="1b39" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Google Pubsub是一个消息队列，让云中的不同组件通过发布和订阅主题进行通信。由于我们的<strong class="jp ir"> <em class="mk"> twitterHook </em> </strong>函数向Google Pubsub上的主题<em class="mk">命令</em>发布消息，我们需要在我们的项目中创建主题，并授予我们的函数发布该主题的权限。我们可以在为下一个函数选择触发器时创建主题。</p><p id="6250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了<strong class="jp ir"><em class="mk">perform command</em></strong>函数，并选择它应该由Pubsub主题上的消息触发，这使我们有机会创建<em class="mk"> commands </em>主题。虽然我们的新函数现在可以在新消息发布到主题时接收调用，但我们仍然需要在Google Cloud Console的Pubsub配置中将我们的<strong class="jp ir"> <em class="mk"> twitterHook </em> </strong>函数的用户注册为主题的发布者。</p><h1 id="ef95" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">命令功能和云数据存储</h1><p id="984d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">下面的<strong class="jp ir"><em class="mk">perform command</em></strong>函数在命令消息发布到我们的Pubsub主题时被调用。它解析命令，或者存储到Google Cloud Datastore的链接，或者查询链接，并将结果作为直接消息发送到Twitter API，发送给请求用户ID。该函数通过调用提供的回调来通知平台它已经完成。</p><p id="eb1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据模型有一个分层键，用户ID位于顶部，链接存储为子键，标签存储在数组属性中。查询是通过指定用户键并为标签添加结果过滤器来完成的。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="462d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">问题</h1><p id="3fed" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">谷歌云功能不成熟的一个标志是，编辑器自动为<strong class="jp ir"> <em class="mk"> performCommand </em> </strong>功能生成了错误的签名，这在使用动态类型语言时变得更加恼人。该函数通过3个参数(事件、上下文和回调)调用，但编辑器忽略了上下文，只生成了2个参数，因此在生成的签名上调用回调会导致“不是函数”错误，因为第二个参数实际上是上下文。</p><h1 id="b4cf" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">最终印象</h1><p id="1aa7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">使用谷歌云功能及其JavaScript编辑器真的很快，没有摩擦，因为人们可以跳过配置服务器或打包应用程序，流量很小的项目可以轻松地放在谷歌的免费使用层中。</p><p id="2a0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，随着系统复杂性的增加，这种开发形式的局限性也逐渐显现出来，即使是像这样的小项目。我怀疑带有编译器支持的类型化SDK最终会同样高效，尽管每个部署步骤会比在编辑器中按save花费更长的时间。</p><p id="b536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器对分布式可扩展性的关注和对专有云组件的严重依赖意味着开发、测试和维护完整多功能应用程序的最佳实践很少。这可能是需要出现的东西，以便更广泛的行业采用。无服务器功能可能会让位于无服务器容器平台，如AWS Fargate和Kubernetes Knative，它们提供了一个不同的部署单元，具有更成熟的实践。</p><p id="adc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器的可扩展性既吸引人又可怕，因为对性能和成本几乎没有限制。导致函数循环的编程错误或导致平台组件大量活动的加载攻击可能会变得非常昂贵，我还没有找到在谷歌平台上限制成本的简单方法(尽管像这个Twitter bot这样的项目可以防止恶意活动，因为Twitter API对用户活动进行速率限制和批处理)。</p><h1 id="4bf3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">无服务器功能的利与弊</h1><p id="2d9e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">赞成的意见</p><ul class=""><li id="e8ef" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk mn lu lv lw bi translated">巨大的可扩展性</li><li id="e96d" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk mn lu lv lw bi translated">支持超快速开发和部署</li><li id="1f77" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk mn lu lv lw bi translated">前期成本低，流量少的时候</li></ul><p id="6a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">骗局</p><ul class=""><li id="b7f9" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk mn lu lv lw bi translated">对云组件的依赖导致供应商锁定</li><li id="9eeb" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk mn lu lv lw bi translated">成本随流量线性增长，难以设定限制</li><li id="595b" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk mn lu lv lw bi translated">维护和测试多功能版本化应用程序的最佳实践很少，对云组件的依赖使得离线测试很困难</li></ul></div></div>    
</body>
</html>