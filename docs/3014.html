<html>
<head>
<title>React — state management without libraries (with hooks) PART 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —不带库的状态管理(带钩子)第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/react-state-management-without-libraries-with-hooks-part-2-d087278185a9?source=collection_archive---------3-----------------------#2019-09-15">https://itnext.io/react-state-management-without-libraries-with-hooks-part-2-d087278185a9?source=collection_archive---------3-----------------------#2019-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf22" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在React中不使用任何外部库的情况下管理状态？</h2></div><blockquote class="kf kg kh"><p id="98d4" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">阅读这篇博文时，打开CodeSandbox编辑器可能会有所帮助。</p></blockquote><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="lk ll l"/></div></figure><blockquote class="kf kg kh"><p id="7df7" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="iq">这是“无库状态管理”的第二部分。如果你没有读第一个，可能很难理解这一个，所以请查看</em> <a class="ae lm" href="https://erdem.pl/2019/09/react-state-management-without-libraries-with-hooks" rel="noopener ugc nofollow" target="_blank"> <em class="iq">第一部分</em> </a></p></blockquote><h1 id="0596" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">第一部分有什么问题？</h1><p id="2f44" class="pw-post-body-paragraph ki kj iq kl b km mf jr ko kp mg ju kr mh mi ku kv mj mk ky kz ml mm lc ld le ij bi translated">正如你在第一部分中所记得的，我们已经创建了<code class="fe mn mo mp mq b">AppStateContext</code>，它允许我们在React的<strong class="kl ir">上下文</strong>中存储我们的应用程序状态，并使用一个reducer修改它。那个唯一的问题是<strong class="kl ir"> 63 </strong>。这是用于创建我们的减速器的许多行。</p><pre class="lf lg lh li gt mr mq ms mt aw mu bi"><span id="94f0" class="mv lo iq mq b gy mw mx l my mz">// AppState.tsx<br/>function reducer(state: AppState, action: ActionType) {<br/>  const { type, payload } = action;<br/>  switch (type) {<br/>    case ACTIONS.SET:<br/>      return {<br/>        ...state,<br/>        [payload.name as string]: payload.value<br/>      };<br/>    case ACTIONS.ADD_ITEM:<br/>      return {<br/>        ...state,<br/>        list: [<br/>          {<br/>            ...payload,<br/>            seen: false,<br/>            isInFavourites: false,<br/>            hashId: uuid()<br/>          },<br/>          ...state.list<br/>        ]<br/>      };<br/>    case ACTIONS.ADD_TO_FAVOURITES:<br/>      const el = state.list.find(el =&gt; el.hashId === payload);<br/>      if (el == null || el.isInFavourites) {<br/>        return state;<br/>      }<br/>      return {<br/>        ...state,<br/>        list: state.list.map(element =&gt; {<br/>          if (element.hashId === payload) {<br/>            return {<br/>              ...element,<br/>              isInFavourites: true<br/>            };<br/>          }<br/>          return element;<br/>        }),<br/>        favourites: [<br/>          {<br/>            ...el,<br/>            isInFavourites: true<br/>          },<br/>          ...state.favourites<br/>        ]<br/>      };<br/><br/>    case ACTIONS.REMOVE_FROM_FAVOURITES:<br/>      return {<br/>        ...state,<br/>        list: state.list.map(element =&gt; {<br/>          if (element.hashId === payload) {<br/>            return {<br/>              ...element,<br/>              isInFavourites: false<br/>            };<br/>          }<br/>          return element;<br/>        }),<br/>        favourites: state.favourites.filter(fav =&gt; fav.hashId !== payload)<br/>      };<br/>    default:<br/>      throw new Error();<br/>  }<br/>}</span></pre><p id="68dd" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">这很好，但在我们的应用程序中添加更多的功能后，它就成线性增长了。因为我们不想以1k行长的文件结束，所以我们必须重新安排我们的结构。</p><h1 id="ddc8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">将主减速器分割成块</h1><p id="5840" class="pw-post-body-paragraph ki kj iq kl b km mf jr ko kp mg ju kr mh mi ku kv mj mk ky kz ml mm lc ld le ij bi translated">我们的main <code class="fe mn mo mp mq b">reducer</code>包含了所有类型的动作，我们要做的第一件事就是根据目的(或其他)将它们分组。</p><p id="da67" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">第一个想法是制造3个减速器:</p><ul class=""><li id="417d" class="na nb iq kl b km kn kp kq mh nc mj nd ml ne le nf ng nh ni bi translated"><code class="fe mn mo mp mq b">favouritesReducer</code> -处理<strong class="kl ir">收藏夹</strong>属性的所有操作</li><li id="534f" class="na nb iq kl b km nj kp nk mh nl mj nm ml nn le nf ng nh ni bi translated"><code class="fe mn mo mp mq b">listReducer</code> -处理<strong class="kl ir">列表</strong>属性的所有动作</li><li id="c70a" class="na nb iq kl b km nj kp nk mh nl mj nm ml nn le nf ng nh ni bi translated"><code class="fe mn mo mp mq b">settingsReducer</code> -处理<strong class="kl ir">设置</strong>属性的所有动作</li></ul><p id="be1a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">例如，我们的<code class="fe mn mo mp mq b">listReducer.ts</code>将如下所示:</p><pre class="lf lg lh li gt mr mq ms mt aw mu bi"><span id="2722" class="mv lo iq mq b gy mw mx l my mz">export default function listReducer(state: AppState, action: ActionType) {<br/> const { type, payload } = action;<br/> switch (type) {<br/>   case ACTIONS.ADD_ITEM:<br/>     return {<br/>       ...state,<br/>       list: [<br/>         {<br/>           ...payload,<br/>           seen: false,<br/>           isInFavourites: false,<br/>           hashId: uuid()<br/>         },<br/>         ...state.list<br/>       ]<br/>     };<br/>   default:<br/>     return state;<br/> }<br/>}</span></pre><p id="e87e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">现在，我们必须找到一种方法将这些减速器合二为一。有不同的方法可以做到这一点:</p><ul class=""><li id="e819" class="na nb iq kl b km kn kp kq mh nc mj nd ml ne le nf ng nh ni bi translated">每个减速器可以修改整个状态(1)</li><li id="e905" class="na nb iq kl b km nj kp nk mh nl mj nm ml nn le nf ng nh ni bi translated">每个缩减器只修改它的状态部分(2)</li></ul><p id="1cad" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">哪个更好？</p><p id="e04d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">@1如果reducer能够修改状态对象中的每一个属性，那么我们可能会遇到两个reducer在响应同一动作时试图修改状态的同一属性的情况。</p><p id="8a5a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">@2 W没有来自@1的问题，但是在这种情况下，在reducer中提供dispatcher会很有用。</p><p id="c9b8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">我们将选择其中的第一个。这是有原因的，我们只考虑小型到小型/中型应用程序，在这些应用程序中，您的状态定义可以显示在一个屏幕上。除此之外，如果你想选择第二个选项，请选择Redux。</p><h1 id="3a21" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">数据流</h1><p id="0168" class="pw-post-body-paragraph ki kj iq kl b km mf jr ko kp mg ju kr mh mi ku kv mj mk ky kz ml mm lc ld le ij bi translated">在我们决定要使用@1方法之后，我们必须想象我们的动作流从现在开始会是什么样子</p><pre class="lf lg lh li gt mr mq ms mt aw mu bi"><span id="27c1" class="mv lo iq mq b gy mw mx l my mz">function reducer(state: AppState, action: ActionType) {<br/>  return [listReducer, favouritesReducer, settingsReducer].reduce(<br/>    (acc, reducer) =&gt; reducer(acc, action),<br/>    state<br/>  );<br/>}</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/f069e230064a5606be5b004421e6eb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qjX6KwvqQJHIbvyj.gif"/></div></div></figure><p id="6915" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">如果你沿着这条路走下去，<strong class="kl ir"> AppState Reducer </strong>正在获得<code class="fe mn mo mp mq b">ADD_TO_FAV</code>带有一些有效负载的动作。之后，它遍历其中的每一个reducer，并允许它们修改状态。一切看起来都很好，对吗？不完全是，我已经按正确的顺序添加了所有的还原剂。如果你改变顺序，你会得到不同的结果。</p><pre class="lf lg lh li gt mr mq ms mt aw mu bi"><span id="fbbc" class="mv lo iq mq b gy mw mx l my mz">function reducer(state: AppState, action: ActionType) {<br/>  return [favouritesReducer, listReducer, settingsReducer].reduce(<br/>    (acc, reducer) =&gt; reducer(acc, action),<br/>    state<br/>  );<br/>}</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nv"><img src="../Images/62d778917a4327836f9ea347e4e8498e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cbZzOq1BTr3dSe3K.png"/></div></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/fe17d62ae7ee2ea0065dcb37c3c84e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WRlbI6Q8w3C1fK24.gif"/></div></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nw"><img src="../Images/d8d9c134405bb3100bf8ff5afc698362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qb275nieSJ2LspLT.png"/></div></div></figure><p id="57bc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">如你所见，在这种情况下，添加到<strong class="kl ir">收藏夹</strong>列表中的对象与<strong class="kl ir">列表</strong>中的对象不同。因为<strong class="kl ir"> listReducer </strong>被第二次调用，所以在被复制到<strong class="kl ir">收藏夹</strong>之前，它不能修改列表项。我们可以以更好的方式设计这个结构，这样我们就不会复制那个标志(<code class="fe mn mo mp mq b">isInFavourites</code>)，但是这是显示在处理您的reducers时可能会出现什么样的问题的最简单的方法之一(有时可能需要一段时间来调试它)。</p><p id="80c8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated">一个快速的解决方法是在从列表中创建对象的副本时总是将<code class="fe mn mo mp mq b">isInFavourites</code>设置为<code class="fe mn mo mp mq b">true</code>。</p><pre class="lf lg lh li gt mr mq ms mt aw mu bi"><span id="138b" class="mv lo iq mq b gy mw mx l my mz">return {<br/>        ...state,<br/>        favourites: [<br/>          {<br/>            ...el,<br/>            isInFavourites: true<br/>          },<br/>          ...state.favourites<br/>        ]<br/>      };</span></pre><h1 id="f658" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="6f63" class="pw-post-body-paragraph ki kj iq kl b km mf jr ko kp mg ju kr mh mi ku kv mj mk ky kz ml mm lc ld le ij bi translated">我们已经设法把我们的单级减速器分成几个更小的减速器。这种方法允许我们在应用程序中为状态的不同部分分离逻辑。它有一些缺点，但是因为我们在小应用中不处理真正复杂的状态，移除复杂的状态管理器对我们更有利。这又是一个完整的代码(但是你可能已经浏览过了:p)。</p><p id="0814" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated"><a class="ae lm" href="https://codesandbox.io/s/mutable-dust-yggp9?fontsize=14" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mutable-dust-yggp9?fontsize=14</a></p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="2a6b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mh kt ku kv mj kx ky kz ml lb lc ld le ij bi translated"><em class="kk">最初发布于</em><a class="ae lm" href="https://erdem.pl/2019/09/react-state-management-without-libraries-with-hooks-part-2" rel="noopener ugc nofollow" target="_blank"><em class="kk">https://erdem . pl</em></a><em class="kk">。</em></p></div></div>    
</body>
</html>