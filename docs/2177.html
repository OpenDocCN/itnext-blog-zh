<html>
<head>
<title>Enforcing Commit Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强制提交模板</h1>
<blockquote>原文：<a href="https://itnext.io/enforcing-commit-templates-8cf3dbfe2510?source=collection_archive---------2-----------------------#2019-04-12">https://itnext.io/enforcing-commit-templates-8cf3dbfe2510?source=collection_archive---------2-----------------------#2019-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a5a0da4bb28c82fc1bdf96c2850365c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVjZretfNpRC7YICO_OBXw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/photo/adult-american-football-athlete-audience-209954/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kf" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><p id="4d17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很多时候，公司会有一个标准的提交消息模板。类似“发行号:短信，详情”之类的。就像编码风格一样，这些有助于使历史清晰易读。但是就像编码风格一样，如果不强制执行，它们就没有任何意义。</p><p id="5778" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">典型的标准提交消息可能是:</p><blockquote class="le lf lg"><p id="5515" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">您的git提交应该以一个简短的单行开始，以:</p><p id="2dff" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">DE:针对缺陷，后跟缺陷号</p><p id="c53c" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">美国:对于新功能的用户故事，后跟故事编号</p></blockquote><p id="30ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，一个好的提交应该是这样的:</p><blockquote class="le lf lg"><p id="1c18" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">DE175:修复缺陷简短描述</p><p id="96dc" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">下面是对修复缺陷所做的变更的更长的描述。</p></blockquote><p id="0cce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以(也应该)在您的git服务器上执行这些规则。使用<a class="ae kf" href="https://help.github.com/en/enterprise/2.16/admin/developer-workflow/creating-a-pre-receive-hook-script" rel="noopener ugc nofollow" target="_blank">预接收钩</a>可以做到这一点。设置预接收挂钩相当容易。预接收挂钩将进行检查，以确保所有提交到服务器的提交都通过您拥有的任何提交消息规则。</p><p id="6b44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果他们没有呢？</p><p id="ab23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">git服务器将拒绝来自客户端的推送。由客户端决定修复任何提交消息，然后再次尝试推送。</p><p id="449e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果违规行为在最前面，这并不太难。一个简单的<a class="ae kf" href="https://www.atlassian.com/git/tutorials/rewriting-history" rel="noopener ugc nofollow" target="_blank"> commit amend </a>命令就可以解决这个问题。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="12dd" class="lu lv it lq b gy lw lx l ly lz">git commit --amend</span></pre><p id="b213" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将允许您快速轻松地修改上次提交。</p><p id="8b95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果违规的提交不是在头部，如果有不止一个违规的提交呢？</p><p id="e143" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，用户需要执行一个<a class="ae kf" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">交互式rebase </a>。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="07cd" class="lu lv it lq b gy lw lx l ly lz">git rebase -i</span></pre><p id="0d64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能是一个冗长乏味的过程。如果提交非常旧，并且在头部和违规提交之间发生了合并，那么修复提交就更加困难。有时，我不得不放弃整个变更历史，简单地做一个<a class="ae kf" href="https://git-scm.com/docs/git-merge" rel="noopener ugc nofollow" target="_blank">合并挤压</a>来修复和删除任何违规的提交。显然，这并不理想，因为我已经丢失了违规分支上的所有提交。</p><p id="1080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这些只是解决我的烂摊子的方法。</p><p id="f828" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我一开始就阻止自己制造混乱呢？</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ma"><img src="../Images/ad83d7a718471ad588488b7b59a1ee55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Qko1Y9z7vupnfFiaWdj1g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>从<a class="ae kf" href="https://www.pexels.com/photo/board-game-business-challenge-chess-277052/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</figcaption></figure><h1 id="4407" class="mb lv it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">Git客户端挂钩</h1><p id="3513" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">就像我们前面看到的服务器端git挂钩强制提交消息一样，我们可以在本地使用类似的机制来确保我们不会创建任何错误的提交。</p><p id="4497" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Git挂钩是在git执行的特定阶段执行的特殊程序。我们可以使用几种不同的挂钩，但出于我们的目的，我们将重点关注:</p><ul class=""><li id="3f99" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated"><strong class="ki iu"> commit-msg: </strong>用于检查消息文件后拒绝提交。</li></ul><p id="771e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">钩子本身必须是一个名为commit-msg的可执行文件。为了让事情变得更快，让我们只使用一个简单的bash脚本。</p><p id="d227" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跑步时:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="5509" class="lu lv it lq b gy lw lx l ly lz">git commit</span></pre><p id="ec28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您实际上正在运行一个名为git-commit的独立程序。然后，这个程序将使用提交消息的内容创建一个临时文件。这个文件然后被传递到我们的<strong class="ki iu"> commit-msg </strong>脚本中。如果脚本返回非零状态代码，则提交被视为无效并被拒绝。</p><p id="dc65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个小的示例<strong class="ki iu">提交消息</strong>脚本</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="de6c" class="lu lv it lq b gy lw lx l ly lz">#!/bin/bash</span><span id="d819" class="lu lv it lq b gy nm lx l ly lz">MSG_FILE=$1<br/>FILE_CONTENT="$(cat $MSG_FILE)"</span><span id="8f08" class="lu lv it lq b gy nm lx l ly lz"># Initialize constants here<br/>export REGEX='^(DE[0-9]+:|US[0-9]+|Merge) .+'<br/>export ERROR_MSG="Commit message format must match regex \"${REGEX}\""</span><span id="6f77" class="lu lv it lq b gy nm lx l ly lz">if [[ $FILE_CONTENT =~ $REGEX ]]; then<br/> echo "Good commit!"<br/>else<br/>  echo "Bad commit \"$FILE_CONTENT\""<br/> echo $ERROR_MSG<br/> exit 1<br/>fi</span><span id="c7de" class="lu lv it lq b gy nm lx l ly lz">exit 0</span></pre><p id="db6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意正则表达式，我们也允许以“Merge”开头的行。这是为了使默认的合并提交消息也有效。</p><h2 id="9305" class="lu lv it bd mc nn no dn mg np nq dp mk kr nr ns mo kv nt nu ms kz nv nw mw nx bi translated">自动前缀</h2><p id="ded7" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我们可以通过让git根据分支名称自动为我们的任何提交加上适当的缺陷或故事的前缀来进一步发展这种策略。这样，我们就不必为跟踪者记住我们正在做的事情的细节，而只需专注于编写好的提交消息。</p><p id="ad44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们需要使用另一个git挂钩:</p><blockquote class="le lf lg"><p id="49c5" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">准备提交消息</p><p id="a614" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">这个钩子由<a class="ae kf" href="https://git-scm.com/docs/git-commit" rel="noopener ugc nofollow" target="_blank"> git-commit </a>在准备默认日志消息之后、编辑器启动之前调用。</p><p id="b141" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">它需要一到三个参数。</p><p id="40c9" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">第一个是包含提交日志消息的文件的名称。</p><p id="9b3f" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">第二个是提交消息的来源，可以是:</p><p id="63b2" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><code class="fe ny nz oa lq b">message</code>(如果给出了<code class="fe ny nz oa lq b">-m</code>或<code class="fe ny nz oa lq b">-F</code>选项)；</p><p id="e614" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><code class="fe ny nz oa lq b">template</code>(如果给出了<code class="fe ny nz oa lq b">-t</code>选项或设置了配置选项<code class="fe ny nz oa lq b">commit.template</code>)；</p><p id="865b" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><code class="fe ny nz oa lq b">merge</code>(如果提交是合并或者存在<code class="fe ny nz oa lq b">.git/MERGE_MSG</code>文件)；</p><p id="ae45" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><code class="fe ny nz oa lq b">squash</code>(如果存在<code class="fe ny nz oa lq b">.git/SQUASH_MSG</code>文件)；</p><p id="6099" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">或<code class="fe ny nz oa lq b">commit</code>，后跟提交SHA-1(如果给出了<code class="fe ny nz oa lq b">-c</code>、<code class="fe ny nz oa lq b">-C</code>或<code class="fe ny nz oa lq b">--amend</code>选项)。</p><p id="4874" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">如果退出状态不为零，<code class="fe ny nz oa lq b">git commit</code>将中止。</p></blockquote><p id="9ce9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://git-scm.com/docs/githooks" rel="noopener ugc nofollow" target="_blank"> (Git Docs) </a></p><p id="a388" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个脚本有点复杂，但请继续关注我。基本前提是，我们将修改传入的提交，并从当前分支名称中为问题编号添加前缀。</p><p id="e6bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们遵循以下分支命名方案:</p><blockquote class="le lf lg"><p id="b035" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">$ { type }/$ { userid }/$ { issue # } _ $ { message }</p></blockquote><p id="a099" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><blockquote class="le lf lg"><p id="292f" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">缺陷/efenglu/de 253 _ bad注释</p></blockquote><p id="cb4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们需要一个小的bash脚本:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="bc12" class="lu lv it lq b gy lw lx l ly lz">#!/bin/bash</span><span id="c7e2" class="lu lv it lq b gy nm lx l ly lz">MSG_FILE=$1<br/>MSG_TYPE=$2<br/>FILE_CONTENT="$(cat $MSG_FILE)"</span><span id="6bc3" class="lu lv it lq b gy nm lx l ly lz">export REGEX='^(DE[0-9]+:|US[0-9]+:|Merge) .+'<br/># If commit is already good, take it<br/>if [[ $FILE_CONTENT =~ $REGEX ]]; then<br/> exit 0<br/>fi</span><span id="0db2" class="lu lv it lq b gy nm lx l ly lz"># Skip files<br/>skip_list=`git rev-parse --git-dir`"/hooks/pre-commit.skip"<br/>if [[ -f $skip_list ]]; then<br/>  if grep -E "^$BRANCH$" $skip_list; then<br/>    exit 0<br/>  fi<br/>fi</span><span id="d75e" class="lu lv it lq b gy nm lx l ly lz"># Get curent branch<br/>BRANCH="$(git rev-parse --abbrev-ref HEAD)"</span><span id="a03f" class="lu lv it lq b gy nm lx l ly lz"># Create prefix based off parsing branch name<br/>STORY=$(echo ${BRANCH} | awk 'match($0, /US[0-9]+|DE[0-9]+/) {print toupper(substr($0, RSTART, 1))  substr($0, RSTART + 1, RLENGTH - 1)}')</span><span id="cf0c" class="lu lv it lq b gy nm lx l ly lz"># If unable to parse story information from branch abort with zero<br/># Our other commit hook will catch bad commits for exit 0<br/>if [[ ! $STORY ]]; then<br/>  exit 0<br/>fi</span><span id="0676" class="lu lv it lq b gy nm lx l ly lz"># Add story to commit in attempt to make it good<br/>echo "Prepending branch information \"$STORY\"..."<br/>echo "Message Type: $MSG_TYPE"<br/>echo "$STORY: $FILE_CONTENT" &gt; $MSG_FILE</span><span id="e557" class="lu lv it lq b gy nm lx l ly lz">exit 0</span></pre><p id="d66b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在当我从分支<strong class="ki iu">缺陷/efenglu/de253 </strong>运行时:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="e02b" class="lu lv it lq b gy lw lx l ly lz">git commit -m "Sample message."</span></pre><p id="04dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日志将包含:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="aba6" class="lu lv it lq b gy lw lx l ly lz">DE253: Sample message.</span></pre><h2 id="d97a" class="lu lv it bd mc nn no dn mg np nq dp mk kr nr ns mo kv nt nu ms kz nv nw mw nx bi translated">控制脚本</h2><p id="b8e4" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">现在，您很可能从具有潜在不同规则的多个不同存储库中检出。例如，我使用我们的公司存储库和公共github。我不希望在我的公共github库上强制执行公司规则。</p><p id="f0cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我在提交挂钩的开头添加了一个复选标记:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9e8d" class="lu lv it lq b gy lw lx l ly lz">#!/bin/bash</span><span id="9af2" class="lu lv it lq b gy nm lx l ly lz">if [[ $(git remote -v | grep github.com) ]]; then<br/>  echo "Commit Rules NOT enforced"<br/>  exit 0<br/>else<br/>  echo "Commit Rules enforced"  <br/>fi</span></pre><h2 id="6607" class="lu lv it bd mc nn no dn mg np nq dp mk kr nr ns mo kv nt nu ms kz nv nw mw nx bi translated">文件名检查</h2><p id="1143" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">还有其他几个钩子可以扩展，并提供各种其他功能。我们还想强制文件名区分大小写。因为我们的开发人员使用不同的文件系统，有些不区分大小写(OSX)，有些不区分大小写(Linux)。有时git会因为文件名冲突而无法签出文件。</p><p id="caf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对我们的开发人员产生了许多奇怪的错误，并且很难解决。</p><p id="18a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我们将检查添加到了git存储库中，但我们也希望进行客户端检查。</p><ul class=""><li id="f341" class="nd ne it ki b kj kk kn ko kr nf kv ng kz nh ld ni nj nk nl bi translated"><strong class="ki iu">预提交:</strong>验证将要提交的内容</li></ul><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="165f" class="lu lv it lq b gy lw lx l ly lz">#!/bin/bash</span><span id="da4b" class="lu lv it lq b gy nm lx l ly lz">if git rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1<br/>then<br/> against=HEAD<br/>else<br/> # Initial commit: diff against an empty tree object<br/> against=4b825dc642cb6eb9a060e54bf8d69288fbee4904<br/>fi</span><span id="dd95" class="lu lv it lq b gy nm lx l ly lz"># Redirect output to stderr.<br/>exec 1&gt;&amp;2</span><span id="6fa1" class="lu lv it lq b gy nm lx l ly lz">TF=$(mktemp)<br/>trap "rm -f $TF" 0 1 2 3 15<br/>checkstdin() {<br/>    sort -f | uniq -di &gt; $TF<br/>    cat $TF<br/>    test -s $TF || return 0   # if $TF is empty, we are good<br/>    echo "non-unique (after case folding) names found!" 1&gt;&amp;2<br/>    cat $TF 1&gt;&amp;2<br/>    return 1<br/>}</span><span id="6989" class="lu lv it lq b gy nm lx l ly lz">git ls-files | checkstdin || {<br/>    echo "ERROR - file name collision, check case of names, stopping commit" 1&gt;&amp;2<br/>    exit 1<br/>}</span></pre><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ob"><img src="../Images/47dea018f133d50d5d26b7c162adb20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvugJ_4QwiSKYg_Sbxw76Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>从<a class="ae kf" href="https://www.pexels.com/photo/referee-raising-both-hands-163294/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</figcaption></figure><h1 id="b61c" class="mb lv it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">设置</h1><p id="5ace" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">不幸的是，要让客户端使用客户端挂钩，它们必须由客户端来设置。</p><p id="16ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，这是一个非常简单的一次性过程。只需克隆包含您的共享git客户端脚本的repo。</p><p id="51f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后启用git中的脚本:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="6561" class="lu lv it lq b gy lw lx l ly lz">git config --global core.hooksPath ~/git/git-hooks</span></pre><h1 id="2746" class="mb lv it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">示例代码</h1><p id="63ea" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">检查我的仓库，上面有完整的代码示例。</p><div class="oc od gp gr oe of"><a href="https://github.com/efenglu/example-git-client-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">efenglu/example-git-client-hooks</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">使用客户端钩子来执行提交编码标准的例子</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot jz of"/></div></div></a></div></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><div class="ll lm ln lo gt of"><a href="https://githooks.com" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">学习如何提高你的Git技能</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">Git挂钩的介绍性指南和资源。了解如何使用提交前挂钩、提交后挂钩、接收后挂钩…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">githooks.com</p></div></div></div></a></div><div class="oc od gp gr oe of"><a href="https://git-scm.com/docs/githooks" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">Git - githooks文档</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">钩子接收将要更新当前分支的尖端的提交。它可以用一个…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">git-scm.com</p></div></div><div class="oo l"><div class="pb l oq or os oo ot jz of"/></div></div></a></div></div></div>    
</body>
</html>