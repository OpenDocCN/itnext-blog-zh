<html>
<head>
<title>Simplifying WebSockets in RxJS.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化RxJS中的WebSockets。</h1>
<blockquote>原文：<a href="https://itnext.io/simplifying-websockets-in-rxjs-a177b887f3b8?source=collection_archive---------1-----------------------#2019-12-12">https://itnext.io/simplifying-websockets-in-rxjs-a177b887f3b8?source=collection_archive---------1-----------------------#2019-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/dc5b0515c9520414da64e01b59884559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3D-b9xlDz7d4xBfcR0JIQ.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="49c3" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">对复杂管道使用Redux-Observable。</h2></div><p id="85d8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">我是Redux-Observable的狂热用户，虽然它掩盖了使用RxJS的许多困难，但您仍然需要对RxJS有更深入的了解，以处理真正复杂的用例。</em> <strong class="ks jc"> <em class="lm"> </em> </strong> <em class="lm">使用WebSockets，</em> <strong class="ks jc"> <em class="lm">我将向您展示如何制作自己的复杂管道并理解它们！</em>T19】</strong></p><h1 id="818b" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">Node.js中与RxJS的WebSocket连接</h1><p id="194a" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">在Node.js中，设置与RxJS的<code class="fe mk ml mm mn b">webSocket</code>连接有点困难，因为与浏览器不同，Node.js没有原生的<code class="fe mk ml mm mn b">WebSocket</code>对象。有了<code class="fe mk ml mm mn b">ws</code>库，你需要做的就是覆盖<code class="fe mk ml mm mn b">WebSocketCtor</code>值，然后你就可以开始了:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="381a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">很简单，对吧？但是这个版本没有伸缩性。所有这些只是创造了一个可观测的<code class="fe mk ml mm mn b">webSocketConnection$</code>。它只建立一个连接，您必须在您的消费者中编写重新连接逻辑。</p><p id="8799" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有时服务器会关闭，您希望通过连接到下一台可用的服务器来确保您可以恢复运行。</p><p id="115c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另外请记住，<code class="fe mk ml mm mn b">webSocketConnection$</code>是“热”的意思，其他任何监听它的东西都不会启动一个新的，但会监听这个特定的实例。把它想象成一个独生子。</p><p id="6dd0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">知道了这些限制，您可以改为像这样编写代码:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d364" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们通过使用递归调用增加了复杂度。因为我们正在使用<code class="fe mk ml mm mn b">timer</code> ( <code class="fe mk ml mm mn b">setTimeout</code>)，所以我们不必担心抛出堆栈溢出错误。</p><p id="d687" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你想要更多的功能呢？取消怎么办？假设您的服务得到了它所需要的，并且不再需要侦听这个WebSocket连接？如果您的回调需要知道连接何时终止并重新连接，该怎么办？</p><p id="215c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我经常在前端和后端应用程序中使用像这样更复杂的功能。例如，当您离开关心WebSocket连接的视图时，您通常希望关闭该连接。</p><p id="5066" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这么简单的例子你怎么能做到呢？</p><p id="10b1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为此，您需要监听一个事件，或者更好的是，使用Redux-Observable。</p><h1 id="4aaf" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">redux-可在前端或后端观察到</h1><p id="bdb8" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">我已经使用Redux-Observable作为前端和后端框架两年多了，几乎用在了我的每个项目上。我甚至为Node.js编写了我自己的<a class="ae mu" href="https://github.com/Sawtaytoes/Redux-Observable-Backend" rel="noopener ugc nofollow" target="_blank"> Redux-Observable后端</a>库，我已经在许多生产项目中使用了它，例如<a class="ae mu" href="https://github.com/Sawtaytoes/Smart-Home-Services" rel="noopener ugc nofollow" target="_blank">智能家居服务</a>。该库允许您在Node.js中使用Redux和Redux-Observable而不使用React来创建事件源应用程序，如Kafka、RabbitMQ等。</p><p id="513d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我创建的其中一个包可以轻松实现高级WebSocket连接。在Redux-Observable中设置WebSockets需要一些思考，所以让我们一步步来。</p><h1 id="542d" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">可重复观察的风格</h1><p id="cd93" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">使用Redux，首先调用一个动作来建立WebSocket连接:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1d0b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是可重复观测的。我们不只是在不知名的地方行动。对于本例，我们将在应用程序启动时启动它:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="dd28" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那更好。当<code class="fe mk ml mm mn b">APP_STARTED</code>消息通过我们的管道时，<em class="lm">然后</em>我们将开始连接。</p><h2 id="d8b8" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">这是一个更简单的版本</h2><p id="da4a" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">作为免责声明，本文中您将看到的所有内容都是基于单个WebSocket连接的。我在生产中使用的代码支持您给它的所有连接。</p><p id="6f85" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我本来打算在这些例子中使用这段代码，但是它增加了大量的复杂性，并且需要对RxJS和Redux-Observable有更深入的理解。</p><p id="87ae" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您对多插座代码感兴趣，请查看本节中的代码。</p><h2 id="b6c7" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">设置监听器</h2><p id="2ae3" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">现在我们有一个动作告诉我们需要建立一个WebSocket连接，现在我们需要编写代码来实际完成它。现在不要担心去理解这一切；我们将一点一点地来看:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4164" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这最初看起来应该很复杂，但是在把它分解成几个部分之后，它会变得更容易理解。</p><h1 id="9fdb" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">把它拆开</h1><h2 id="56b4" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">开始简单</h2><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7021" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果没有这段代码，建立WebSocket连接是没有用的，因为这是其余逻辑存在的全部原因。</p><p id="f7e1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当一个<code class="fe mk ml mm mn b">webSocketConnection$</code>消息进来时，调用<code class="fe mk ml mm mn b">receivedWebSocketMessage</code>动作创建者来格式化该消息，并使其对所有Redux和Redux-Observable可用。</p><h2 id="5520" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">最聪明的RxJS运算符:` startWith '</h2><p id="897f" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">RxJS给人印象最深的一个运营商是<code class="fe mk ml mm mn b">startWith</code>。我用了太多疯狂的方式使用这个操作符。这部史诗居然用了两次！</p><p id="81e9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦我们创建了一个<code class="fe mk ml mm mn b">webSocketConnection</code>，我们需要向侦听器发送一条消息，告诉它们连接已经准备好了。使用<code class="fe mk ml mm mn b">startWith</code>，我们可以立即通过管道推送<code class="fe mk ml mm mn b">CONNECTION_READY</code>动作，一旦可观察对象被订阅，该动作就会被自动调度；甚至在任何数据传来之前。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4e77" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我们使用<code class="fe mk ml mm mn b">startWith</code>的另一个地方，它相当于:</p><pre class="mo mp mq mr gt nh mn ni nj aw nk bi"><span id="3f9b" class="mv lo jb mn b gy nl nm l nn no">const someFunction = () =&gt; { /* do stuff */ }</span><span id="8c8a" class="mv lo jb mn b gy np nm l nn no">someFunction()</span></pre><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6f57" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这部分代码代码说“一旦这个可观察对象被订阅，立即从这个时间点开始并开始执行”。这让我们可以重用重连监听器在订阅时创建<code class="fe mk ml mm mn b">webSocket</code>连接。这非常巧妙，也是我认为<code class="fe mk ml mm mn b">startWith</code>如此强大的原因。</p><h2 id="a7b0" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">连接错误时重新连接</h2><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2e0e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这部分订阅了<code class="fe mk ml mm mn b">webSocketConnection$</code> observable并捕捉任何连接错误，就像我们在Node.js示例中所做的那样。它甚至还设置了计时器！</p><p id="b8c2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们绝不是递归调用函数；相反，我们正在发送一个动作<code class="fe mk ml mm mn b">RECONNECT_TO_SERVER</code>,这个动作恰好是我们在这个内在可观察对象上听到的动作。</p><h2 id="e67c" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">取消</h2><p id="c1a5" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">使用RxJS最重要的原因之一是<strong class="ks jc">取消</strong>。与没有内置取消方法的承诺和回调不同，有许多方法可以取消可观察性。</p><p id="b689" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当一个可观察对象在RxJS中被取消时，它可能是通过一个错误或完成可观察对象。在我们的例子中，我们使用<code class="fe mk ml mm mn b">takeUntil</code>来监听一个动作，该动作最终在执行的不同阶段完成可观察的动作。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a288" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">听<code class="fe mk ml mm mn b">action$</code>，我们可以检查各种动作类型，并保持我们的可观察对象运行，直到一个完成它的动作类型出现，如<code class="fe mk ml mm mn b">DISCONNECT_FROM_SERVER</code>。</p><p id="428f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当<code class="fe mk ml mm mn b">takeUntil</code>打开<code class="fe mk ml mm mn b">RECONNECT_TO_SERVER</code>时，我们说“完成这个可观察到的连接，因为我们正在重新连接”。</p><p id="99d0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe mk ml mm mn b">takeUntil</code>的第一个实例只监听<code class="fe mk ml mm mn b">DISCONNECT_FROM_SERVER</code>。这是因为它是<code class="fe mk ml mm mn b">RECONNECT_TO_SERVER</code>的监听器。如果我们让它在<code class="fe mk ml mm mn b">RECONNECT_TO_SERVER</code>之后取消，它会在启动后立即取消，并且永远不会启动WebSocket连接。</p><h2 id="e844" class="mv lo jb bd lp mw mx dn lt my mz dp lx kz na nb lz ld nc nd mb lh ne nf md ng bi translated">为什么这么多取消？</h2><p id="c4ba" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">我们在三个地方监听具有<code class="fe mk ml mm mn b">RECONNECT_TO_SERVER</code>和<code class="fe mk ml mm mn b">DISCONNECT_FROM_SERVER</code>类型的动作。虽然你会认为当父可观测量完成时，子可观测量也会完成，但事实并非如此。</p><p id="d56c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从<code class="fe mk ml mm mn b">catchError</code>和<code class="fe mk ml mm mn b">switchMap</code>订阅的observables在处理完之前不会完成。如果父进程发送一个触发<code class="fe mk ml mm mn b">switchMap</code>操作符的值，并且父进程完成，<code class="fe mk ml mm mn b">switchMap</code>中的可观察对象仍然有效，直到它也完成。这就是为什么我们需要在这三个地方定义<code class="fe mk ml mm mn b">takeUntil</code>操作符。</p><h1 id="014c" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">再次看到这一切</h1><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3756" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">概括地说，我们首先看了在Node.js中用RxJS创建WebSocket observables，然后讨论了如何使用Redux-Observable在浏览器或Node.js中做同样的事情。</p><p id="ed99" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后我们把这个史诗分解成几个部分，学习WebSocket消息如何转换成动作，为什么<code class="fe mk ml mm mn b">startWith</code>非常有用，如何<code class="fe mk ml mm mn b">catchError</code>帮助我们处理重新连接，以及如何取消是可能的，但需要一些思考。</p><h1 id="a695" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">结论</h1><p id="9e97" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">再看一遍代码，现在更有意义了吗？为什么要这样写以及我们获得的好处清楚吗？在经历了这一切之后，请随意评论你的想法。我很想听听你学到了什么，以及这对你自己的项目有什么帮助。</p><p id="b312" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你想看一个现实世界中允许多个WebSocket连接的相同代码的生产示例，只需看一下<a class="ae mu" href="https://github.com/Sawtaytoes/Redux-Observable-Backend/tree/2d561c327421328d64f42dc95c2e24dde5d81bea/packages/websocket/redux/externalConnections" rel="noopener ugc nofollow" target="_blank">本节my Redux-Observable-back end repo</a>。</p><h1 id="56a2" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">更多阅读</h1><p id="b3bc" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><ul class=""><li id="c25e" class="nq nr jb ks b kt ku kw kx kz ns ld nt lh nu ll nv nw nx ny bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-can-solve-your-state-problems-15b23a9649d7"> Redux-Observable将解决您的状态问题</a></li><li id="03c4" class="nq nr jb ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/the-best-practice-anti-pattern-5e8bd873aadf"> Redux-Observable的最佳实践是反模式</a></li><li id="74dc" class="nq nr jb ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/redux-observable-code-that-fixes-everything-b7832b904b6b">修复一切的Redux-Observable代码</a></li><li id="bf7e" class="nq nr jb ks b kt nz kw oa kz ob ld oc lh od ll nv nw nx ny bi translated"><a class="ae mu" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">回访:权威指南</a></li></ul></div></div>    
</body>
</html>