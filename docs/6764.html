<html>
<head>
<title>How to bind (Python + NumPy) with (Rust + Ndarray)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将(Python + NumPy)与(Rust + Ndarray)绑定</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-bind-python-numpy-with-rust-ndarray-2efa5717ed21?source=collection_archive---------0-----------------------#2022-02-21">https://itnext.io/how-to-bind-python-numpy-with-rust-ndarray-2efa5717ed21?source=collection_archive---------0-----------------------#2022-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/95eaa62150846b369bfd1793734a96bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrXePzNBDhIFG4zTnlJbjA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这只是一张图片，让文章看起来更漂亮。不过，这是我们将要构建的代码。如果你想知道“这是Emacs吗？”是的，这是Emacs，是的，有时它看起来很漂亮。也许我们会在下一篇文章中讨论Emacs、Neovim和VScode。谁知道呢？我知道。</figcaption></figure><h1 id="b9cf" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">内容</h1><p id="8207" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">本文将讨论:</p><ul class=""><li id="a7d1" class="ly lz iq lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated">PyO3绑定(Rust to Python)</li><li id="49f6" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">Python NumPy to Rust Ndarray(无拷贝，即快速)</li><li id="2127" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">Rust Ndarray到Python NumPy</li><li id="60a6" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">可变和不可变的例子</li></ul><p id="76e8" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">如果您只想阅读如何实现绑定，请跳过“背景”部分。</p><h1 id="ed00" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">背景</h1><p id="bd81" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">自然Python代码不是最快的(迄今为止)，有时会使Python成为不太合适的任务选择。然而，用Python构建更大的数据(或其他)项目是好的，因为存在所有好的包。</p><p id="df1d" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">那么，我们如何处理速度的问题呢？如今常见的方式是使用C进行扩展，大部分主流包(如NumPy和PyTorch)都是用C、C++甚至CUDA实现的。对于许多习惯于使用简单Python代码的Python人员来说，一直使用C或C++通常不是一种有趣的体验。</p><p id="2023" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">幸运的是，其他低级语言确实存在，相对较新的语言Rust就是一个很好的例子。让铁锈成为杀手的特征(IMHO)是:</p><ul class=""><li id="2212" class="ly lz iq lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated">优秀包装经理(货物)。</li><li id="1cce" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">无垃圾收集，性能可预测。</li><li id="14bb" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">处理记忆的安全方式(有利于新人少犯错误)。</li><li id="a3c6" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated">由于其令人难以置信的工具(例如VSCode的rust-analyser ),易于上手。不过，与编译器斗争有时会很乏味，也很有教育意义。</li></ul><h1 id="49f5" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">入门指南</h1><h2 id="a4ea" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">包装</h2><p id="c627" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">为Python编写Rust绑定出奇的简单(经过几次拼命的尝试)。首先，我们将依赖几个包:</p><p id="b284" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">锈</p><ul class=""><li id="81fb" class="ly lz iq lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated"><a class="ae nd" href="https://docs.rs/ndarray/latest/ndarray/" rel="noopener ugc nofollow" target="_blank">n数组</a></li><li id="c1b3" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><a class="ae nd" href="https://docs.rs/numpy/latest/numpy/" rel="noopener ugc nofollow" target="_blank"> numpy </a></li><li id="85f1" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><a class="ae nd" href="https://pyo3.rs/v0.15.1/" rel="noopener ugc nofollow" target="_blank"> PyO3 </a></li></ul><p id="ee48" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">计算机编程语言</p><ul class=""><li id="4a40" class="ly lz iq lc b ld ma lh mb ll mc lp md lt me lx mf mg mh mi bi translated"><a class="ae nd" href="https://numpy.org/install/" rel="noopener ugc nofollow" target="_blank"> numpy </a></li><li id="ea2a" class="ly lz iq lc b ld mj lh mk ll ml lp mm lt mn lx mf mg mh mi bi translated"><a class="ae nd" href="https://github.com/PyO3/maturin" rel="noopener ugc nofollow" target="_blank"> maturin </a>(有趣的名字，食物-尿液直接从瑞典语翻译过来)</li></ul><h2 id="3ea2" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">Rust设置</h2><p id="273f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">首先创建一个新项目(您可以随意命名)。注意，选择的名称将是您在python中导入的名称。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1b01" class="mr kd iq nj b gy nn no l np nq">cargo new --lib rust_numpy_ext</span></pre><p id="f70d" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">然后将这些包添加到您的货物中(在撰写本文时，这些都是最新的版本)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="67c6" class="mr kd iq nj b gy nn no l np nq">[package]<br/>name = "rust_numpy_ext"<br/>version = "0.1.0"<br/>edition = "2021"</span><span id="f5f7" class="mr kd iq nj b gy nr no l np nq">[lib]<br/>crate-type = ["cdylib"]</span><span id="6748" class="mr kd iq nj b gy nr no l np nq">[dependencies]<br/>ndarray = "0.15.3"<br/>numpy = "0.15"<br/>rand = "0.8.5" # Specific for this example<br/>ordered-float = "2.10.0" # Specific for this example</span><span id="180f" class="mr kd iq nj b gy nr no l np nq">[dependencies.pyo3]<br/>version = "0.15.1"<br/>features = ["extension-module"]</span></pre><h2 id="5c03" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">Python设置</h2><p id="ed6e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><em class="ns">对于不知道什么是Python虚拟环境的人，请查一下，因为需要将Rust包/模块安装到虚拟环境中。网上有很多很棒的教程。它可能因操作系统而异。</em></p><p id="4c19" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">为了安装Rust包，我们需要一个Python虚拟环境。您可以使用以下命令创建一个本地环境(取决于您为Python取的名称)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="eb87" class="mr kd iq nj b gy nn no l np nq">python3 -m venv ./test_venv</span></pre><p id="58ff" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">下一步是激活环境，这可以通过调用</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c046" class="mr kd iq nj b gy nn no l np nq">source ./test_venv/bin/activate</span></pre><p id="80fd" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">一旦激活，你应该在你的终端上看到你的venv的名字，见下面的例子。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/35ed566f9a4db5842855954a5e162340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meISRwU_1nSMVpA7eYeWqA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">激活环境后的终端外观示例。</figcaption></figure><p id="fd54" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">现在我们还需要在venv中安装我们的依赖项。注意，当激活虚拟环境时，您的python可能会以不同的名称被调用(python3 -&gt; python)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0471" class="mr kd iq nj b gy nn no l np nq">python -m pip install numpy<br/>python -m pip install maturin<br/>python -m pip install matplotlib</span></pre><p id="782c" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">注意，matplotlib仅用于可视化，对于绑定不是必需的。</p><h1 id="ba51" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">密码</h1><p id="0f90" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在，我们将大致按照PyO3 中的<a class="ae nd" href="https://github.com/PyO3/rust-numpy" rel="noopener ugc nofollow" target="_blank">示例进行操作，该示例包含许多感兴趣的内容。因为他们例子已经存在，所以我选择做一些新的“花哨”的函数来测试。</a></p><p id="92b7" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated"><em class="ns">Rust和它的社区的一个奇妙的部分是伟大的软件包的数量每天都在增加，并且超级容易安装。我们将使用Rust包“numpy ”,它让我们可以轻松地将Python“numpy”数据转换为本地Rust“ndarray”数据。壮观！</em></p><p id="771e" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">让我们转储<a class="ae nd" href="https://gist.github.com/Machine-Jonte/9117f826af0c7f2267441dfeb3e57a04" rel="noopener ugc nofollow" target="_blank">所有的代码</a>，然后遍历它！</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="bb39" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">Rust创建Python模块</h2><p id="c6fe" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">生锈的一面乍一看可能很吓人。但是我们正在做的是指定Python模块，它必须与包同名。空模块将看起来像</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3ff9" class="mr kd iq nj b gy nn no l np nq">#[pymodule]<br/>fn rust_numpy_ext(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {<br/>    Ok(())<br/>}</span></pre><p id="a12a" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">不太恐怖。我们将Python和对PyModule的引用作为输入，并返回一个PyResult。这个不用想太多。您可以复制它并将模块重命名为包名。标准程序。</p><h2 id="d564" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">Rust填充Python模块</h2><p id="3fa3" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">下一步是在Python模块中创建第一个函数。让我们从最简单的一个函数开始。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="498f" class="mr kd iq nj b gy nn no l np nq">    #[pyfn(m)]<br/>    fn eye&lt;'py&gt;(py: Python&lt;'py&gt;, size: usize) -&gt; &amp;PyArray2&lt;f64&gt; {<br/>        let array = ndarray::Array::eye(size);<br/>        array.into_pyarray(py)<br/>    }</span></pre><p id="ef14" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">这将在pymodule内部创建，完整代码如下。我们可以看到，我们的pyfn会将我们的<em class="ns"> PythonModule </em> <em class="ns"> m </em>作为输入，将我们的函数添加到模块中，即代码部分“#[pyfn(m)]”。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="26cb" class="mr kd iq nj b gy nn no l np nq">#[pymodule]<br/>fn rust_numpy_ext(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {</span><span id="2f86" class="mr kd iq nj b gy nr no l np nq">    #[pyfn(m)]<br/>    fn eye&lt;'py&gt;(py: Python&lt;'py&gt;, size: usize) -&gt; &amp;PyArray2&lt;f64&gt; {<br/>        let array = ndarray::Array::eye(size);<br/>        array.into_pyarray(py)<br/>    }</span><span id="7b1b" class="mr kd iq nj b gy nr no l np nq">    Ok(())<br/>}</span></pre><p id="816f" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">这里的包装将为我们处理很多。PyO3将尝试并自动将Python参数转换为Rust类型。在这种情况下:</p><p id="49f3" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">Python int -&gt; Rust usize</p><p id="e905" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">每个pyfn都需要Python作为输入，然后是其他类型。同样，我们可以将此视为创建Rust/Python函数的标准过程。</p><p id="6244" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">接下来，我们使用Rust包ndarray来创建眼睛矩阵(即对角线上的一个)。为了将它发送回Python，我们需要将ndarray转换成Python numpy数组。这里我们使用Rust中的包“numpy ”,带有特征“IntoPyArray”。将这作为一个特征的好处是，这个特征也可以在其他Rust包中实现，比如“nalgebra”。这使得将Rust数据转换成Python numpy数据的过程标准化成为可能。太好了！</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="1bf4" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">我们将要编写的其他函数遵循相同的逻辑，只是在幕后多了一些操作。其中一个函数改变了numpy数组，这可能会更有效。另一个将numpy数组作为只读数组，这样就不可能改变输入数据。</p><h2 id="a1dd" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">Rust用NumPy输入填充Python模块</h2><p id="1a7d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="lc ir">只读<br/> </strong>第一个例子是取一个numpy数组作为输入，它是<strong class="lc ir">不可变的</strong>。如果你遵循纯函数式编程，这是非常好的！现在，我们可以确保数组没有任何变化(不同于Python/C/C++)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="98f4" class="mr kd iq nj b gy nn no l np nq">#[pyfn(m)]<br/>    fn max_min&lt;'py&gt;(py: Python&lt;'py&gt;, x: PyReadonlyArrayDyn&lt;f64&gt;) -&gt; &amp;'py PyArray1&lt;f64&gt; {<br/>        let array = x.as_array();<br/>        let result_array = rust_fn::max_min(&amp;array);<br/>        result_array.into_pyarray(py)<br/>    }</span></pre><p id="1591" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">我们将输入的numpy数组“x”转换成一个ndarray的“ArrayView”。as_array()"。这意味着“数组”变量是不可变的。然后我们可以调用Rust函数<em class="ns"> min_max </em>，该函数将一个ndarray作为输入，找到最大值和最小值，并将其作为ndarray [max，min]返回。</p><p id="670d" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">太好了！然后，正如已经讨论过的，我们可以使用特征“IntoPyArray”将其转换回Python numpy数组。现在我们可以将结果返回给Python了！</p><p id="c02a" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated"><strong class="lc ir">可变<br/> </strong>在下一个例子中，我们将获取一个可变的numpy数组，对它进行循环，将每个值加倍，并向它添加一个随机扰动。和以前很像。不同之处在于，在将numpy数组转换为ndarray时，我们必须使用“as_array_mut()”使其可变。这将是一个不安全的操作。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ea04" class="mr kd iq nj b gy nn no l np nq">#[pyfn(m)]<br/>    fn double_and_random_perturbation(<br/>        _py: Python&lt;'_&gt;,<br/>        x: &amp;PyArrayDyn&lt;f64&gt;,<br/>        perturbation_scaling: f64,<br/>    ) {<br/>        let mut array = unsafe { x.as_array_mut() };<br/>        rust_fn::double_and_random_perturbation(&amp;mut array, perturbation_scaling);<br/>    }</span></pre><p id="1dd6" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">我们现在可以调用Rust函数来改变ndarray。我们不需要返回数组，因为ndarray上的突变直接发生在numpy数组上，因为<strong class="lc ir"> ndarray和numpy数组共享数据</strong>。</p><h1 id="34dd" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">构建/安装软件包</h1><p id="8988" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><em class="ns">确保在建造之前激活你的venv</em></p><p id="ff11" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">为了能够从Python导入包，我们必须构建它。为此，我们将使用“maturin”。在你的Rust包的根目录下运行</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="685a" class="mr kd iq nj b gy nn no l np nq">maturin develop</span></pre><p id="d71f" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">一旦你对这个包满意了，你就可以用release标志来运行，以获得一个更加优化的版本(也就是说，你的Rust代码运行得更快)。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="a2df" class="mr kd iq nj b gy nn no l np nq">maturin develop --release</span></pre><p id="fe5e" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">运行<em class="ns"> maturin </em>命令将使模块可以在Python中导入。<br/>模块可以从任何python文件导入，只要你在运行Python时使用相同的venv。也就是说，您的Python项目可以从Rust模块中分离出来，这太棒了！</p><h1 id="74b9" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Python —测试我们的模块</h1><p id="bf98" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><em class="ns">运行</em>前，确保您的venv已激活</p><h2 id="798c" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">导入包</h2><p id="0e4f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">从Python的角度来看，事情的表现和预期的一样。我们可以将模块导入为</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c351" class="mr kd iq nj b gy nn no l np nq">import rust_numpy_ext as RNE</span></pre><p id="5e44" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">或者，如果我们只想要一个功能，我们可以做到</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="18cc" class="mr kd iq nj b gy nn no l np nq">from rust_numpy_ext import double_and_random_perturbation</span></pre><p id="4a71" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">我们唯一的问题是Python linter(至少在VSCode中)不会自动完成我们的函数，我们看不到函数想要什么参数。为了解决这个问题，我们可以用Python函数包装我们的函数。如果我们要为numpy数组使用非默认类型(例如u8、f32等),这些Python侧函数也可以处理我们的类型转换。).</p><p id="1478" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">包装函数可能类似于下面的代码块。请注意，您可以将所有函数包装在同一个文件中。包装该模块将使它成为Python的一等公民，并像numpy一样具有本机行为。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="od nv l"/></div></figure><h2 id="dd47" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">运行简单的测试</h2><p id="ee3f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在，让我们测试一下我们编写的函数是否正常工作。这与之前列出的Python代码相同(main.py)。我把它放在这里是为了方便。只要在运行期间激活了正确的venv，main.py文件可以在任何地方。这应该没有任何问题。你应该得到如下的图，我们可以看到numpy数组的加倍和扰动。</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="od nv l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">main.py</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/57162b232fd897c825c79dc6c7244a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NESmVcHXaOx0RkdH9v04dA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">double_and_random_perturbation函数的输出。看起来不出所料。</figcaption></figure><h1 id="8645" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="1a2c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">使用Rust和Python很棒，PyO3和其他助手包完成了很多工作。根据经验，我发现使用Rust比编写C/C++扩展有趣得多。尽管PyTorch在启用C++扩展方面做得很好，但这是一个例外(依赖于pybind11)。</p><p id="13f6" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">最终，这一切都归结于偏好，以及团队拥有的专业知识。Rust是现代的，最近越来越受欢迎，但是C/C++在业界已经很成熟，很难与之竞争。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="d4d1" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">如果你喜欢这篇文章，支持我的最好方式就是鼓掌和/或关注我！如果你非常善良，你会和你的朋友一起分享。但是说实话，我很高兴你能走到这一步，享受它，最重要的是学到了一些东西。</p><p id="ea9b" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mo ln lo lp mp lr ls lt mq lv lw lx ij bi translated">干杯！</p></div></div>    
</body>
</html>