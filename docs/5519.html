<html>
<head>
<title>What the… State Machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么…国家机器</h1>
<blockquote>原文：<a href="https://itnext.io/what-the-state-machine-96189764567e?source=collection_archive---------3-----------------------#2021-03-22">https://itnext.io/what-the-state-machine-96189764567e?source=collection_archive---------3-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="841c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当您开始使用案例管理时，熟悉一些术语是很有用的。我已经决定，今年我要做研究，尽可能简单地解释这些概念。然后，当我们实现它时，我将把它与案例管理框架联系起来。而我会一路评估是否值得。</p><p id="c773" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">(当然，你不需要读完整本书，如果你想在刚刚学会这个概念后挖掘出来，我没问题。或者，如果您只想了解状态机的案例管理框架版本，请跳到<em class="km">那么您是如何实现这个案例管理框架的呢？</em></p><p id="11de" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">今天…我们将谈论状态机。</p><p id="b6d3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">状态机</strong></p><p id="c6bb" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">状态机是一组状态以及它们之间所有可能的转换。这听起来不像是革命性的，但也算是吧。如果你习惯于编程顺序进程，你可能会想:“那有什么用？状态转换自然会从过程中产生。”</p><p id="b061" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">但问题是，状态机不仅是一种记住哪些状态转换是可能的方法，也是一种将状态与导致状态转换的事件分开的方法。这非常方便，因为它将你的项目分解成更小的块。你不需要理解整个过程，你只需要知道案件如何发展到一个特定的状态，以及当它发展到那个状态时会发生什么。</p><p id="0b65" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">状态机方法如下:</p><ol class=""><li id="b113" class="kn ko iq jq b jr js jv jw jz kp kd kq kh kr kl ks kt ku kv bi translated">你定义各州</li><li id="ffca" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">您定义了这些状态之间的潜在转换</li><li id="7e56" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">您对是否需要进行这样的转换进行评估</li><li id="140b" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">神奇！</li></ol><p id="ea58" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们举一个荷兰的好例子:</p><p id="87da" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果你把你的自行车带到商店，它会以“坏了”开始，这是我们的初始状态。你只能有一个初始状态。坏了的自行车可能修好了，或者判断无法修复了，这是两种后续状态。自行车修好后，你将进入付款过程，这将有潜在的阶段，如“已付款”、“付款期限已过”和“债务出售”。到目前为止，它非常简单，你可以很容易地在BPT把它模拟成这样:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/842ef5ebce385e71c18833f9b81eada7.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/0*O7QmEkthTmZEX7uk"/></div></figure><p id="191d" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">(快速注意，我在这里放置计时器的方式是为了说明的目的，如果您真正实现它，它会略有不同，但我想保持我的说明简单。在本文的这一部分，我将保持事情的简单性，甚至不惜牺牲准确性。)</p><p id="90f7" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在说，这是一个非常年轻的自行车店，他们只做了一些维修，并希望能够扩展和调整这一进程，因为他们的增长。在这种情况下，采用一种以更松散耦合的方式建模的建模方法可能是有用的。在一个连续的过程中做出改变意味着你需要审视你的部分与过程中所有其他部分的交互方式。你可能无法预见所有的后果。</p><p id="3d8e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在状态机中，事物之间的联系并不那么紧密，因此这是一种使您能够构建不那么严格的流程的方法。你可能不知道自行车从进店到出店的路径，但你知道它可能经过的一些状态。随着商店的扩张和增加更多的服务，你将调整模型。</p><p id="1473" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">那么自行车修理是如何在状态机中建模的呢？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lj"><img src="../Images/56d00390b825b4d499a3aedfaf0d38d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ut-83D87WdrWyqC7"/></div></div></figure><p id="cb30" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在状态机中，状态之间的每次转换都是由一个事件触发的。如果一辆曾经坏了的自行车被修理工修好了，这个事件就是使它进入“已修复”状态的原因。达到已修复状态是触发付款期限时钟开始倒计时的事件，而时钟耗尽是将自行车移动到拖欠债务状态的事件，除非债务被付清。</p><p id="cb81" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">为了扩展这一点，我们可以添加一个“无容量状态”,当一辆新的坏自行车进入商店并且没有可用时，该状态会自动设置。然后，当雇佣了新的修理工并且可用能力超过正常能力20%时，最近被拒绝的维修可能会自动转移到“能力现在可用”状态，并收到他们最终可以进来的电子邮件。或者，如果我们在组织中添加一个将债务人纳入付款计划的财务部门，我们将为付款计划添加一个状态，并添加一个从拖欠债务到付款计划的转换。也许当人们开始拖欠付款计划时，也是一个过渡。</p><p id="5d18" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">一旦我们有了基本的设置，添加新的状态，新的转换和新的逻辑是一个相对较小和独立的工作。我们本质上开始创建随着组织和人的发展而发展的自然过程，而不是预先制定一套严格的过程。</p><p id="25e3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">因此，设置状态机可以使您的案例管理更加灵活。</p><p id="19cc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">(现在事情要变得技术化了，所以如果你不喜欢，请跳到<strong class="jq ir">“值得吗？</strong>”)</p><p id="59b0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">那么，您如何利用案例管理框架做到这一点呢？</strong></p><p id="eee1" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">为了进行设置，我们需要执行以下操作:</p><ol class=""><li id="8e54" class="kn ko iq jq b jr js jv jw jz kp kd kq kh kr kl ks kt ku kv bi translated">设置具有业务实体和业务流程的应用程序</li><li id="eb01" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">建立一个状态机</li><li id="0a57" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">使用状态机来创建我们的应用程序</li></ol><p id="cb79" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们走吧！</p><p id="0fd1" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">对于MVP，我们将暂时避免所有的自动化，一切都基于人的交互。</p><p id="7e90" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们首先为维修请求建立一个业务实体，制定一个相关的业务流程，并根据本教程<a class="ae lo" href="https://success.outsystems.com/Documentation/Case_Management/Set_up_a_case_management_app" rel="noopener ugc nofollow" target="_blank">配置案例定义和案例状态。</a></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/ccac3af2dd0694ca5f545131aeff49ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*-xAxcFnTpFXvj1Mh"/></div></figure><p id="0a80" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在可以随意忘记那个业务流程，当它变得相关时我会告诉你！然后，我们使用本教程中的<a class="ae lo" href="https://success.outsystems.com/Documentation/Case_Management/Case_state_machine" rel="noopener ugc nofollow" target="_blank">将允许的状态转换添加到模型中。<br/> </a>我已经用这些教程制作了一个自举动作的截图。它用我们的状态机的正确信息填充元数据数据库表。</p><p id="8c40" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">(如果您不明白我的意思，请阅读<a class="ae lo" href="https://medium.com/@sezen.debruijn/what-the-case-management-framework-780e94c026a0" rel="noopener">“什么……案例管理框架”</a>。)</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/c7b7f3c0b17d8f97a1b8161b85507b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/0*68SaGOiuIgpO37zW"/></div></figure><p id="df9e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">发布配置模块以触发引导操作后，我们将构建一个操作，通过该操作我们可以创建修复请求。正如您在屏幕截图中看到的，此操作首先从初始化案例开始，这样我们就可以使用其id来提出维修请求。这样，数据和业务流程将被链接在一起。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lr"><img src="../Images/b3d1bb99c1ace7cf7d8beb2d2b8734a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/0*d2t7WccBGjb3eSB4"/></div></div></figure><p id="c9b8" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在是构建UI的时候了。</p><p id="1300" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们将基于修复请求实体搭建两个简单的屏幕。详细信息屏幕中的“保存”按钮将替换为我们针对维修请求的新创建操作，以便我们在创建请求时启动案例。<br/>我们还添加了一个DataAction来获取基于RepairRequestID的可能状态。为此，我们将使用案例管理框架的Case_GetAllPossibleStatus，您可以在CaseServices_API中找到它。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/555bc4b72799a0d061faed9f5baf3d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/0*2J4LOOKceX8w9DBw"/></div></figure><p id="63f5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">为了测试我们的状态机是否正常工作，我们现在将在连接到DataAction的屏幕中添加一个列表元素。在列表元素中，我们将添加一个按钮元素，标签为StatusName。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/86a8a6b35b3b4921a6dfbe7e2914b1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/0*ENtJkiHfPmhZ-wgP"/></div></figure><p id="d821" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">onclick操作调用Case_UpdateStatus操作，该操作使用RepairRequestId和CaseStatusId更新案例的状态，然后刷新数据操作。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lu"><img src="../Images/eb285dc3acfd007bc1496eca81d7ec1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AfThiaBuwEkysFJe"/></div></div></figure><p id="31d4" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">现在我们将通过创建一个请求然后打开它来进行测试。我们可以在“被盗”、“已修复”和“无法修复”之间做出选择。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lv"><img src="../Images/c4e4aaa1a1aae2c9efcce879ea37ffa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e7wu0dIC8-3v9vvp"/></div></div></figure><p id="daa9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">点击已修复，我们现在得到新的选项，即“被盗”，“拖欠债务”和“已支付”。这将一直工作，直到我们到达终端状态“结案”，因为这个状态自然没有任何后续状态。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lw"><img src="../Images/860212de770b573e506754c81e6f4c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PzFFPBj019_wgkFo"/></div></div></figure><p id="d673" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">我们已经成功地实现了一个低级状态机。现在让我们去添加一些自动化！</p><p id="620e" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">让我们自动化</p><p id="9eb0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">还记得我们在整个实施开始时创建的流程，该流程与案例相关联，但很快就被遗忘了吗？是时候让这一切变得有意义了！</p><p id="f03c" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">对于这个实现，我将使用一个初级模式，我称之为星型模式。星形的核心是检查哪些状态转换是可能的逻辑。对于可能的转换，可能需要启动自动或人工活动来检查是否满足转换条件。这些活动形成了星的点，当它们被执行时，它们将指向回心脏。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lx"><img src="../Images/1bae48d12e0ca061400a657f5dc450b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E09ms2MZSkL3Vj7G"/></div></div></figure><p id="a0f7" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在我们的自行车商店中，星星的中心是一个名为“下一个状态”的决策点。该决策的目标是根据潜在的后续状态和其他信息，确定接下来应该采取的行动。</p><p id="b823" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">因为我们的自行车商店示例非常简单，所以我们将只关注允许的后续状态。因此，首先我们使用Case_CetAllPossibleStatus操作来获取潜在后续状态的列表，就像我们在屏幕上所做的那样。然后，我们将循环遍历该列表，并在切换中检查可能的下一个状态是已修复还是已修复。如果是这样，我们将连接到一个名为RepairJob的决策结果。RepairJob是一个动作，它将检查这些状态中的哪一个是合适的下一阶段。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ly"><img src="../Images/02005f554f61381297f23deaafef15a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bLPM_Cqxh4ZjaL0a"/></div></div></figure><p id="2aaf" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果潜在的下一阶段是付款或拖欠债务，我们将连接到PaymentTermStarts决策结果。(见正下图。)</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lz"><img src="../Images/64f30f7c04646c91d8a30843dda29eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vb01Hk5ARMphbCsj"/></div></div></figure><p id="ebc0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">还记得状态机只是一组状态和在这些状态间转换的方法吗？</p><p id="80e0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这部分逻辑的要点只是查看发生了哪些潜在的转换，然后创建一个新的活动来评估哪个状态应该是下一个状态。请允许我热情洋溢地讲述这种方法的美妙之处:</p><p id="e696" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果你以一种连续的方式思考，你将会看到一个过程大部分是一组自动的和/或人工的活动连接在一起，偶尔会导致状态的改变。状态只是为了让人们清楚进程的状态。当构建一个国家机器时，改变你的视角是很重要的。在状态机中，流程是一组状态，活动只是用来确定应该发生哪种状态转换。</p><p id="f4ae" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在状态机中，活动的重要性仅在于它们能够实现准确的状态转换。它们本身完全不重要。</p><p id="65d4" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">说到这里，现在让我们花一半的时间讨论活动…🙃</p><p id="f4a5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在下一节中，我们将了解三种活动以及它们如何帮助实现状态之间的转换:</p><ol class=""><li id="b6d0" class="kn ko iq jq b jr js jv jw jz kp kd kq kh kr kl ks kt ku kv bi translated">修理工作</li><li id="43b6" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">付款期限开始</li><li id="9744" class="kn ko iq jq b jr kw jv kx jz ky kd kz kh la kl ks kt ku kv bi translated">结案了</li></ol><p id="3c19" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">维修工作</strong></p><p id="94a5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当我们需要决定是过渡到已修复阶段还是BeyondRepair阶段时，修复作业活动将会启动。它是一个名为“RepairTask”的人工活动，并在具有RepairRequestId的RepairRequest被更新时关闭。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f21dc03a0195fd288393f79969ae8a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/0*vs_Z4ADpcILgH5kt"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/aee6711b237d0e3de8827fe1e96603f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/0*9iiZUxisTwUg8Ao_"/></div></figure><p id="0713" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">检验自行车的实际人工任务决定了两个可能的转换中的哪一个发生。如果自行车已修理，则案例从“损坏”状态转换为“已修理”状态。如果自行车无法维修，案例将从“损坏”状态转换为“无法维修”状态。应用程序实际上无法读取修理工的想法(目前还不行！)，所以对于我们的目的来说，决定这个转换的人工任务实际上是更新维修请求记录的操作。</p><p id="6e74" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">此更新会关闭人工活动，并且活动的关闭会触发一个在此活动关闭时运行的操作。“关闭时”操作从数据库中获取修复请求，检查它是否设置为Beyondrepair，并根据此信息更新状态，如下所示:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/12a6fd4e6101716881585f0289530b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/0*3fRyg5_rLkHvCYEL"/></div></figure><p id="355f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在此操作运行之后，我们返回到下一个状态决策，以确定接下来应该发生什么。</p><p id="83f3" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">付款期限开始</strong></p><p id="d4fe" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当下一个状态转换为“拖欠债务”或“已支付”时，WaitTillPaymentTermRunsOut活动启动，以确定应该发生哪种情况。WaitTillPaymenTermsRunOut活动是一个计时器，它在收到修复请求的更新或5天后超时时关闭。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi md"><img src="../Images/d1832734ac3ba042e192bfa0553b602b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/0*O6USSyz2jw2yMOrx"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi me"><img src="../Images/79864bdb748967b577164ce5416d06ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/0*kZdlnSoHQYlfM5wp"/></div></figure><p id="ba9b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当它关闭时，会运行一个动作来判断时间是否结束或付款是否收到。与前面的操作一样，它从数据库的维修请求中获取数据，检查账单是否已支付，并相应地更新状态。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mf"><img src="../Images/9b15dddc8d7b297fb8fc5936f8dea4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*GTzAx0PE6Z17aPMX"/></div></div></figure><p id="189f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">此操作运行后，流程将返回到下一个状态步骤。</p><p id="229f" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">结案</strong></p><p id="ccb5" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这是我们最后的活动。结案是唯一一个我们不需要满足任何条件的。我们通过未能满足任何其他结果的标准来达到这个活动。</p><p id="7f55" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">当我们到达这里时，我们执行的活动是最终的状态转换。我们只需将状态更新为已结案。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d79cf789718ed465ed8c57471c5ccbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/0*Tq5xWaWWxrmQmiW-"/></div></figure><p id="8111" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这样我们就有了一个全自动的轻量级状态机，如下所示:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c3812403188b726abd51171536a754aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/0*pkfGY4xC8wkIhhid"/></div></figure><p id="33ed" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">这值得吗？</strong></p><p id="5506" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">既然我们已经制造出了我们的国家机器，你可能会怀疑所有这些努力是否值得。为什么要在一个可以用简单的BPT过程完美构建的应用程序上走这么长的弯路呢？</p><p id="7ee6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">如果你是这么想的:很好！这是您在构建自己的状态机或任何CMF应用程序之前应该问自己的问题。如果你能走一条比这更容易的路，这可能就是正确的解决方案。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mi"><img src="../Images/955ad15c44311e3d74f834c16f4e5003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0vQ_aQqivlSYiY84l51aA.png"/></div></div></figure><p id="2fdc" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">在这种情况下，我们看到了状态机方法的一些好处:在应用程序中添加新功能变得更加容易。为此，我们只需将状态和转换添加到数据库中，将其添加到决策的评估中，以查看我们是否需要执行相关活动并构建相关活动。我们不需要弄清楚这在已经存在的顺序过程中的确切位置。在这里，我们也有一个更简单的方法来调整流程，因为我们现在有一个状态产生状态的情况。想让你花时间检查自行车的钱成为可能，即使你已经判断自行车无法修理了？</p><p id="8ce6" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">只需将从“无法修复”到“结案”的过渡转换为从“无法修复”到“已支付”或“拖欠债务”的过渡，您将自动进入下一步的计时器。</p><p id="492b" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">作为一个小测试，我实现了一个等待列表机制，如果我们已经满员了，我们就把自行车放在等待列表上。整个实现花了半个小时，而且做起来非常简单，因为状态机方法严重限制了影响。我只需要稍微扩展一下修复作业中的状态转换条件。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/0d4981c7d44023cf1fd0e5ef080add97.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*tLb4PH-B1iL5cjdi3yYYMQ.png"/></div></figure><p id="75e9" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">最后，这也是走向动态过程的一种方式。在状态机中，您可以对其进行建模，以便案例可以切换到完全不同的状态，而您通常不会在顺序流程中连接这些状态。这允许您构建更像人类那样工作的应用程序。</p><p id="e863" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这就是状态机方法的好处。</p><p id="9327" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">然而，设置案例已经花了一些时间，然后我们必须实际建模我们想要使用的状态转换。这比我用简单的连续过程做同样的事情要花费更多的时间。</p><p id="f2cd" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">因此，这是否值得，在一定程度上取决于我们的自行车店是否会改进他们的流程，并超越我们目前的流程。如果他们想做的只是这个简单的流程，那么业务流程就已经足够了。</p><p id="d0da" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">但是，如果他们预期在他们的过程中有很多变化或增长，状态机可能会帮助他们。</p><p id="4203" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated"><strong class="jq ir">一些最后的想法。</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mk"><img src="../Images/b692bba1f83f292eb256d402efaa5366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_y5qXH9KO6kIr6ETkdipg.png"/></div></div></figure><p id="bfd0" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">对我来说，状态机是一种有趣的建模方法。通过把国家放在首位并使活动从属于它们，我们把重点放在进程的目标上，而不是放在我们实现目标的方式上。</p><p id="db94" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">这是一个哲学上有趣的思维转变，可能会让我们赢回对其工作方式的一些控制。我经常看到人们为一个制度化的过程服务，而不是过程为人们服务。国家机器可以通过将焦点转移到目标而不是活动上来帮助解决这个问题，并避免一条严格规划的道路。</p><p id="c685" class="pw-post-body-paragraph jo jp iq jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ij bi translated">尽管如此，我认为仍然可以用状态机构建令人讨厌的流程，或者使用顺序设计方法构建自然的流程。状态机不会是您工具箱中的唯一工具，也不会解决您的所有问题，但它仍然是一个有趣的工具。</p></div></div>    
</body>
</html>