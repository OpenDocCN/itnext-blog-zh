<html>
<head>
<title>State restoration in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振状态恢复</h1>
<blockquote>原文：<a href="https://itnext.io/state-restoration-in-flutter-b6030b95a4d4?source=collection_archive---------0-----------------------#2022-02-17">https://itnext.io/state-restoration-in-flutter-b6030b95a4d4?source=collection_archive---------0-----------------------#2022-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d6c58fa258045cbf36c984c46d2b2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10RECXGTH5NyaeBg5yD1pw.png"/></div></div></figure><p id="e076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当编写一个应用程序时，通常不用担心当它进入后台时会发生什么，因为你只关心当用户直接与你的应用程序交互时，他们在做什么，对吗？不完全是。</p><p id="4025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些情况下，用户会暂时离开你的应用，但这并不意味着他们不再与它互动。例如，如果用户在你的应用程序中创建一个帐户，并需要验证他们的电子邮件地址，他们可能需要快速转到他们的电子邮件应用程序并返回。当他们回到你的应用程序时，他们希望从他们停止的地方继续。</p><p id="905c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<strong class="ka ir">系统资源受限</strong>时，问题就出现了。假设用户同时运行许多应用程序，也许他们的手机没有太多可用内存。在这种情况下，一旦他们切换到电子邮件应用程序，<strong class="ka ir">你的应用程序就会被操作系统关闭</strong>。然后，当用户切换回您的应用程序时，它会重新启动并丢失所有状态。因此，如果他们在某个屏幕序列中导航很深，他们将不得不从头开始，直到找到他们想要的东西。这远非理想，因为很有可能<strong class="ka ir">这个用户会简单地放弃</strong>注册。</p><p id="9508" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是国家恢复的作用。在本教程中，我们将看到我们可以使用什么策略来防止这种问题。</p><h2 id="32ce" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">入门指南</h2><p id="8805" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">对于本教程，我们将修改Flutter的默认应用程序，以更好地说明这个问题。我们的应用程序将由两个屏幕组成<strong class="ka ir"/>，一个主屏幕，只有一个按钮将我们带到我们的第二个屏幕，在那里我们将有一个按钮，当点击时增加一个计数器(就像默认的应用程序)。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/83c1feabab093410c47901de5141c018.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*xrSB7TyU5YRezJBOa6tEAQ.gif"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">我们简单的应用程序</figcaption></figure><p id="0c43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以查看下面的代码:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4602" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，目前为止没什么特别的。在实现我们的更改之前，让我们模拟一下，如果我们的应用程序由于缺乏资源而被操作系统终止会发生什么。要在Android上模拟这一点，请进入<strong class="ka ir">设置&gt;系统&gt;开发者选项</strong>并选中选项<strong class="ka ir">不保留活动</strong>。</p><p id="633a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将执行以下操作:</p><ol class=""><li id="c985" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">运行我们的应用</li><li id="a338" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">点击主屏幕上的按钮，进入第二个屏幕</li><li id="a30f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">将计数器递增3次</li><li id="bfe2" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">切换到设置应用程序</li><li id="238f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">切换回我们的应用程序</li></ol><p id="9425" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记下上面的步骤。我们将在整个教程中重复它们。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/7b1e44fb8bd7bca94fabba1c6678f4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*gsRvu4NHWECBe2YCX6nT3g.gif"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">我们的应用被操作系统扼杀了</figcaption></figure><p id="b4c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在上面看到的，当我们回到我们的应用程序时，它只是重新启动，然后<strong class="ka ir">我们被带回到主屏幕</strong>。应用程序状态完全丢失，我们不再看到与之前相同的屏幕，并且<strong class="ka ir">我们的计数器回到0 </strong>。</p><p id="2334" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想要的是回到应用程序，找到我们离开时的一切。但是我们怎么做呢？</p><p id="9b3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序在这里处理两种类型的状态信息。一个是<strong class="ka ir">导航</strong>状态(即什么是活动路线？)和另一个是<strong class="ka ir">应用</strong>状态(即，我们增加了多少次计数器？).我们将分别处理这些问题。</p><p id="4644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从<strong class="ka ir">导航</strong>状态开始。这是最容易修复的一个。我们只需要做两个改变。</p><p id="2dc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个与<strong class="ka ir">我们如何推动第二个屏幕</strong>有关。我们没有调用方法<code class="fe mt mu mv mw b">Navigator.push</code>，而是简单地用<code class="fe mt mu mv mw b">Navigator.restorablePush</code>代替它。该方法将<code class="fe mt mu mv mw b">BuildContext</code>作为一个参数以及一个应该返回我们路线的构建函数。这里需要注意的一点是<strong class="ka ir">builder函数必须在你的widget类中定义为一个静态方法</strong>(而不是一个匿名函数),否则你会从框架中得到一个错误。</p><p id="5f27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的第二个改变是当<strong class="ka ir">实例化我们的</strong> <code class="fe mt mu mv mw b"><strong class="ka ir">MaterialApp</strong></code>时。我们将把参数<code class="fe mt mu mv mw b">restorationScopeId</code>传递给构造函数。这需要是一个唯一的字符串，框架将使用它来保存我们的导航状态。</p><p id="6189" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在下面看到更新的代码(更改在第14行和第41到49行):</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">我们的应用程序代码现在可以恢复导航状态</figcaption></figure><p id="c651" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您现在运行该应用程序，并尝试按照之前概述的相同步骤进行操作，那么现在当我们返回到该应用程序时，您会看到，<strong class="ka ir">我们看到了正确的屏幕</strong>:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/4e074f2ff6b945eae60e054dd421c8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*LrP0QabDDO6OFZxE8iswMQ.gif"/></div></figure><p id="58a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您会看到<strong class="ka ir">导航被保留</strong>，但我们的计数器被重置为零。让我们看看现在如何解决这个问题。</p><p id="13b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当谈到恢复我们的应用程序状态时，Flutter的工作方式是，当操作系统发出通知，表明我们的应用程序将被杀死时，<strong class="ka ir"> Flutter会将我们告诉它的任何信息保存到磁盘上</strong>。然后，当我们的应用程序重新启动时，<strong class="ka ir"> Flutter会将该信息</strong>重新注入到我们应用程序的状态中。</p><p id="b845" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让Flutter知道我们希望它保存什么，我们需要稍微修改一下我们的代码。首先，我们将使用<code class="fe mt mu mv mw b">RestorableInt</code>类代替简单的<code class="fe mt mu mv mw b">int</code>来存储我们的计数器值。这个类的构造函数将接收一个初始值(在我们的例子中是零)，为了访问包装的值，我们使用属性<code class="fe mt mu mv mw b">.value</code>。</p><p id="ac91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要修改我们的<code class="fe mt mu mv mw b">StatefulWidget’s</code>状态类，以便它实现<code class="fe mt mu mv mw b">RestorationMixin</code>。对于这个mixin，我们需要实现两个方法，一个是<code class="fe mt mu mv mw b">restorationId</code> getter，它将简单地返回一个惟一的标识符字符串，Flutter将使用它来保存我们的屏幕状态，另一个是方法<code class="fe mt mu mv mw b">restoreState</code>，它将告诉Flutter我们需要保存我们的计数器值。最后一件事是我们需要记住，当我们的小部件使用完我们的<code class="fe mt mu mv mw b">RestorableInt</code>实例时，要处理掉它。</p><p id="958e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，说得够多了，让我们看看代码(更改在第59、60、64、82和95到107行):</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">我们完全可恢复的应用程序</figcaption></figure><p id="aed7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们再次经历我们的测试步骤，<strong class="ka ir">当我们切换回it </strong>时，我们的应用完全恢复。干得好！</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/0fa080669eed299e3732b34a89aa707d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*q8nRfvm9B2CC_oo74PsgPA.gif"/></div></figure><p id="1e1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的例子，我们的状态只是一个对应于计数器值的整数，但是你可能需要保存其他的东西。Flutter提供了一堆可以让你保存原始值的类，比如<code class="fe mt mu mv mw b">RestorableBool</code>、<code class="fe mt mu mv mw b">RestorableString</code>、<strong class="ka ir">、</strong>、<strong class="ka ir">、</strong>等等。同样，如果你的变量碰巧是可空的，那么同样的类也有可空的版本(<code class="fe mt mu mv mw b">RestorableBoolN</code> <strong class="ka ir">、</strong> <code class="fe mt mu mv mw b">RestorableStringN</code> <strong class="ka ir">、</strong>和<code class="fe mt mu mv mw b">RestorableDateTimeN</code>)。</p><p id="2cec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您需要恢复一个非原始值(比如您自己的类的一个实例)，您可以子类化<code class="fe mt mu mv mw b">RestorableValue</code>类，以向框架指示您的实例如何能够被转换成一组原始值，以及如何被转换回来。你可以在<a class="ae mx" href="https://api.flutter.dev/flutter/widgets/RestorableValue-class.html" rel="noopener ugc nofollow" target="_blank">颤振文档</a>中找到很好的例子。</p><h2 id="1a2c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">额外小费</h2><p id="68da" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">当使用导航器来推送新的屏幕时，<strong class="ka ir">我们有时可能需要将数据从第二个屏幕</strong>传递给它的展示者。当您使用常规方法<code class="fe mt mu mv mw b">Navigator.push</code>(即没有状态恢复)时，您会得到一个<code class="fe mt mu mv mw b">future</code> <strong class="ka ir"> </strong>返回，您可以用它来访问第二个屏幕返回的数据。然而，当使用一种可恢复的导航方法(如<code class="fe mt mu mv mw b">Navigator.restorablePush</code>)时，您会注意到它返回的不是未来，而是一个字符串。那么我们如何做到这一点呢？</p><p id="e9f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从一个可恢复的方法中得到的字符串是一个<strong class="ka ir">恢复标识符</strong>。这个标识符可以用来在<code class="fe mt mu mv mw b">RestorableRouteFuture</code>类的帮助下从第二个屏幕获取数据。</p><p id="35d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了了解这是如何实现的，让我们修改我们的应用程序，让主屏幕显示一个文本，说明上次计数器增加了多少次。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/8de125eaafa2edb680346f6ba11c4c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*KX6LO0kXLkZAmYmBGWIp9A.gif"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">使用状态恢复时在屏幕之间传递数据</figcaption></figure><p id="c01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是我们更新后的代码:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="2b21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，所以代码有相当多的变化。您将注意到的第一件事是，我们必须将我们的主页类转换为一个<code class="fe mt mu mv mw b">StatefulWidget</code>，因为<strong class="ka ir">现在它将有一个状态变量</strong>，指示计数器上次增加了多少次(<code class="fe mt mu mv mw b">_lastCounter</code>)。这个变量的值显示在按钮的正上方。</p><p id="1905" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们在主页的state类中添加了一个类型为<code class="fe mt mu mv mw b">RestorableRouteFuture</code> <strong class="ka ir"> </strong>的新属性<code class="fe mt mu mv mw b">_counterRoute</code>。这个参数是在类'<code class="fe mt mu mv mw b">initState</code>方法中设置的，它的构造函数接收两个简单的回调。一个是当我们决定按下第二个屏幕时调用的，另一个是当我们从那个屏幕收到结果时调用的。然后，每当用户按下按钮时，我们不调用<code class="fe mt mu mv mw b">Navigator.restorablePush</code>，而是调用我们的<code class="fe mt mu mv mw b">_counterRoute</code>变量上的<code class="fe mt mu mv mw b">present()</code> <strong class="ka ir"> </strong>方法。</p><p id="06a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们让主页的state类实现了<code class="fe mt mu mv mw b">RestorationMixin</code>(就像我们之前对CounterPage所做的那样)，并告诉Flutter我们需要保存我们的<code class="fe mt mu mv mw b">_counterRoute</code>值。</p><p id="9951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们更改了CounterPage的state类的build方法，这样一切都被包装在一个<a class="ae mx" href="https://api.flutter.dev/flutter/widgets/WillPopScope-class.html" rel="noopener ugc nofollow" target="_blank"> WillPopScope </a>小部件中，这样我们就可以截取屏幕弹出的时刻，并将计数器的当前值传回我们的主页。</p><p id="a2ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！唷，那是相当多的，所以为你做的如此伟大的工作拍拍你自己的背。</p><h2 id="fc4c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">关于性能的说明</h2><p id="e14c" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">根据我的经验，我没有发现使用这些技术对性能有任何影响。唯一需要注意的是<strong class="ka ir"> Android有1MB的数据保存/恢复限制</strong>。</p><p id="24fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为，在引擎盖下，Flutter使用<a class="ae mx" href="https://developer.android.com/reference/android/os/Parcel" rel="noopener ugc nofollow" target="_blank">包</a>对象在你的应用程序和操作系统之间传输数据，这些对象有大小限制，否则你会遇到<code class="fe mt mu mv mw b"><a class="ae mx" href="https://developer.android.com/reference/android/os/TransactionTooLargeException" rel="noopener ugc nofollow" target="_blank">TransactionTooLargeException</a></code>。</p><p id="5ac9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是一般来说，你应该使用这些技术来保存简单的原始值，所以你很可能永远不会达到这个极限。例如，如果您有大量不想丢失的二进制数据，您应该将它们保存到磁盘上，并且只将其路径存储在一个<code class="fe mt mu mv mw b">RestorableString</code>属性中。</p><h2 id="abac" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="4118" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">国家恢复是你认为永远也不会需要的东西之一，直到它来咬你。</p><p id="7ffe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，当你的应用程序中有一些关键流程时，比如用户注册或产品结账，用户不能丢失他们已经添加的任何信息，否则他们很可能会简单地放弃。这些时候使用上述技术将会有很大的价值。</p><p id="7edf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你喜欢这个教程！如果你有任何问题，打电话给我。</p></div></div>    
</body>
</html>