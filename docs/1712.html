<html>
<head>
<title>Release &amp; Measure Code to Kubernetes using CircleCI/Quay/Datadog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CircleCI/Quay/Datadog向Kubernetes发布和测量代码</h1>
<blockquote>原文：<a href="https://itnext.io/release-measure-code-to-kubernetes-using-circleci-quay-datadog-f7e3b0802ff9?source=collection_archive---------6-----------------------#2019-01-08">https://itnext.io/release-measure-code-to-kubernetes-using-circleci-quay-datadog-f7e3b0802ff9?source=collection_archive---------6-----------------------#2019-01-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi ju"><img src="../Images/26e59dc40f0cfde34e8b0b8f935f7bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*fbRWmHPEW3OXPZOr.png"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">1.Kubernetes平台工程</figcaption></figure><p id="c5f9" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">下面的故事将展示如何使用CircleCI创建一个100%自动化的软件交付，并一步一步地部署到Kubernetes中，从开发到登台，以及使用精心制作的工具从登台到生产。</p><h1 id="46ac" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基础设施</h1><p id="a90c" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">我有一个在AWS中通过Kops启动的Kubernetes Cluster 1.8。如果你需要了解如何创建一个集群，那么就去它的官方Github页面<a class="ae mh" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/kops</a>吧，这是有据可查的。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/19eb942f65f0ff3e9fd88d3c756e2b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9XJMe8cxjJRwN37r.jpg"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">2.Kubernetes运营工具</figcaption></figure><h1 id="db84" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义正确的分支战略</h1><p id="79da" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">定义正确的分支策略是在<strong class="ki ir"> <em class="mn">长期</em> </strong>中成功的关键，因为在开发过程中会涉及太多的特性和工程师。通过在使用平台时采用DevOps思维模式，工程师需要在开发新功能、修复应用程序和尽可能快地交付软件以实现无摩擦、无时间限制的生产之间找到准确的平衡。</p><p id="6f91" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我们的场景将基于从主干  释放<a class="ae mh" href="https://trunkbaseddevelopment.com/release-from-trunk/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="mn">来工作，因此我们不断地合并到<strong class="ki ir"><em class="mn"/></strong>和<strong class="ki ir"> <em class="mn">主</em> </strong>是<strong class="ki ir"> <em class="mn">通过<strong class="ki ir"> <em class="mn">部署管道交付</em> </strong>，直到生产</em> </strong>。开发将在<strong class="ki ir"> <em class="mn">短命特性分支</em> </strong>中进行，最多持续几天<strong class="ki ir"><em class="mn"/></strong>，然后将合并到主分支中，通过<strong class="ki ir"> <em class="mn">自动化</em> </strong>交付给环境，不得允许手动任务。使用从主干发布的团队有一个<strong class="ki ir"> <em class="mn">高发布节奏</em> </strong>。</em></strong></a></p><p id="e923" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">让我们来定义什么是发布节奏:</p><blockquote class="mo mp mq"><p id="cc4c" class="kg kh mn ki b kj kk kl km kn ko kp kq mr ks kt ku ms kw kx ky mt la lb lc ld ij bi translated">交付团队需要做的事情之一，通常是与产品管理部门合作，是选择他们产品的<strong class="ki ir">发布节奏</strong>。…您的<strong class="ki ir">发布节奏</strong>定义了您的<strong class="ki ir">多久发布一次</strong>您的解决方案，包括内部和外部的产品(或市场)。</p></blockquote><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mu"><img src="../Images/0aecd5691f88dd7b2b99ea60a2aad484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tH0wq5p8SnXzWkCw.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">3.从行李箱中释放</figcaption></figure><p id="9bb5" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">更多的<strong class="ki ir"> <em class="mn">低发布节奏</em> </strong>团队将需要使用更多的<a class="ae mh" href="https://trunkbaseddevelopment.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir"> <em class="mn">基于主干的开发</em> </strong> </a>方法，以便适当地支持每个发布，因为它们将在生产中持续更长的时间，并且对于工程师来说将需要稳定/无摩擦和永恒的消耗。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mu"><img src="../Images/b3de04cfb26a1a09f14f4cb2b049fa11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F-3Af-i_nRPh49T6.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">4.基于主干的开发</figcaption></figure><p id="a31f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">还有谁支持这个想法？</p><p id="16f0" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><strong class="ki ir">微软</strong>是通过他们所谓的<a class="ae mh" href="https://blogs.msdn.microsoft.com/devops/2018/04/19/release-flow-how-we-do-branching-on-the-vsts-team/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki ir">发布流程</strong> </a> <strong class="ki ir">在VSTS内部开发的。</strong></p><p id="8043" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><strong class="ki ir">Google</strong>※<strong class="ki ir"/><a class="ae mh" href="https://dzone.com/articles/googles-scaled-trunk-based" rel="noopener ugc nofollow" target="_blank"><strong class="ki ir">基于主干开发</strong> </a> <strong class="ki ir">。</strong></p><p id="dd5f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我会说这是逃离合并地狱的唯一方法，在那里我们花了几个小时试图在环境之间移动代码，这并不奇怪，它可能会在下一个环境中失败，可能是因为合并太大，可能有太多的冲突要解决，等等。</p><p id="e27f" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">使用主干作为真实的单一来源，并保持其稳定，交付它，标记它。我见过太多的团队用master branch做任何事情，合并我们无法探测其工作的东西根本没有任何意义。</p><h1 id="cc06" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Git-Flow还是基于主干的开发？</h1><p id="c68c" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">这两种策略在业内都被广泛接受，这是当今的标准。</p><p id="ac55" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">作为工程师，我们可能会陷入两种选择中的一种。这是真的，这应该是一个深思熟虑的决定。</p><h2 id="eb07" class="mv lf iq bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated"><strong class="ak"> Gitflow </strong></h2><p id="b597" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">Gitflow使用以下分支:</p><ul class=""><li id="0299" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki ir">开发</strong></li><li id="87d5" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki ir">主人</strong></li><li id="081f" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki ir">功能</strong></li><li id="a45f" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki ir">热修复</strong></li><li id="8204" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki ir">发布</strong></li></ul><p id="d360" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">每一次迭代，开发团队都将从develop创建分支，并通过pull请求集成到其中。一旦开发人员准备好发布，发布分支就被创建了。当发布分支准备好生产时，它被合并到主分支。为了向前发展，需要进行几次合并。</p><p id="4285" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">何时使用:</p><ul class=""><li id="3e02" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">当你在做一个开源项目时。</li><li id="280c" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当团队有几个初级成员时。</li></ul><p id="0300" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">不使用时:</p><ul class=""><li id="bd99" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">当运行一个启动项目时，它会降低开发团队的速度。</li><li id="a1e5" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当您希望依赖开发运维并依赖自动化时。</li><li id="ed81" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当队员都是学长的时候。</li></ul><h2 id="504e" class="mv lf iq bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">基于主干的开发</h2><p id="3392" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">参与这一战略的分支机构有:</p><ul class=""><li id="068d" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki ir">主人</strong></li><li id="f4ed" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki ir">短命特色分支</strong></li></ul><p id="64e0" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">工程师将在一小段时间内致力于一个从主版本中提取的短命特性分支，然后发布它。发布的节奏往往很快，因为团队很快就要进入生产阶段，他们相信自动化的工作流程会更快。</p><p id="5934" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">何时使用:</p><ul class=""><li id="f96b" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">当适应DevOps心态时。</li><li id="8072" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当团队适应自动化时。</li><li id="3ec2" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当团队中有资深成员时。</li><li id="b174" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当它是一个启动项目时。</li></ul><p id="e91a" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">不使用时:</p><ul class=""><li id="fbb8" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">团队不资深的时候。</li><li id="90de" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当它是一个大型开源项目时。</li></ul><p id="41c6" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">因此，在采用正确的策略之前，要三思而行。毕竟，这一切都是通过做来学习，通过测量我们的流程来学习，从团队中获得反馈，我们可以根据需要改变它来改进工作流程。做事并不总是有独特的方式。每个团队和项目都是不同的。</p><h1 id="53b9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为工作选择合适的工具</h1><p id="f804" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">既然选择了分支策略模型，是时候考虑什么是需要的和容易执行我们的工作了。我将在下面描述我选择以下工具的原因:</p><ul class=""><li id="16dd" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki ir"> Helm包经理</strong>:是Kubernetes包经理。这意味着我们可以在一个包中转换一堆用于部署到Kubernetes的YML文件。更好的是，我们可以将每个包作为一个单独的单元来部署，所以它是抽象的，这意味着我们可以用同样的方式部署所有的东西。我发现HELM非常强大，是部署到K8S的最佳工具之一。想象一下，无论技术如何，数十个微服务都以相同的方式部署，这使得自动化变得非常容易。</li></ul><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1dc724f8d7dd2de3f4c4b8a79812b62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*gN8VZuYNGiBNmIEY.png"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">4.舵</figcaption></figure><ul class=""><li id="1e85" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki ir"> CircleCI </strong>:一个基于容器的平台，允许使用短暂的Docker容器来部署我们的环境，并在完成任务后死去。我们使用我们自己的Docker映像，这些映像完全连接到环境中，其中包含正确的工具，因此每个容器都有我完成部署所需的一切。CircleCI是一项非常快速的技术，从Circle 2.0开始，它允许自定义工作流，因此工程师可以选择正确的路径来上线。</li></ul><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/d5d3a5c4e54dabe9f2890c2e0da1d5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*93pJEHE59BVYbIAg.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">5.切尔莱西</figcaption></figure><ul class=""><li id="bb2c" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki ir"> Quay </strong> : Quay是一个在注册表中构建和保存docker图片的平台。到目前为止，它在建立形象方面做得不好，但在安全方面做得很好。每一个构建的图像都经过全面分析，寻找漏洞，并且总是很好地显示出来。</li></ul><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nx"><img src="../Images/f9bee6c8d1e2ffad3861b5e641f49d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5opORVKEV-fpiGyE"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">6.码头</figcaption></figure><ul class=""><li id="41e2" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">这是一个像Graphite/Grafana这样的度量后端，令人印象深刻并且非常容易使用。我使用Datadog来衡量基础设施指标，如CPU/内存利用率、定制业务指标和<strong class="ki ir"> <em class="mn">管道指标。</em> </strong>因此，部署工具将其部署指标发送给Datadog，以便通过HTTP协议(也可以通过UDP协议)计算部署/失败/时间。</li></ul><h1 id="2227" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将API准备到CI/CD</h1><p id="1da6" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">第一步是配置我们的服务，通过CircleCI进行部署。为此，我们需要添加一个文件夹。使用circleci工作流的circleci/config.yml。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ny"><img src="../Images/2f5fa365368be5093436ceb0fa804852.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*ImNDQHQQvenJUZ8jCMxVvQ.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">6.API项目</figcaption></figure><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">7.CircleCI工作流程</figcaption></figure><p id="fc28" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我们可以看到工作流程的步骤是:</p><ul class=""><li id="e368" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">构建和运行测试</li><li id="c69e" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">请求circle ci docker守护进程的一个实例构建一个映像，并将其上传到Quay.io hashed(它会将此映像存储在注册表中并执行安全分析)。</li><li id="9d0f" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">在开发环境中执行部署，无需通过Helm包管理器批准。</li><li id="391e" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">发送QA和生产环境的批准，必须由发布经理或任何负责人手动批准。</li><li id="d369" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">一旦获得批准，将自动触发QA/Prod部署。</li></ul><p id="5fe8" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我们可以在CircleCI的YML定义中看到全局命令的用法。正如我之前提到的，我们使用预构建的docker映像，并在全球范围内安装工具。在这种情况下，它们是一堆bash脚本版本，以保存所做更改的历史记录，并支持回溯兼容性，以防工具的新版本出现问题。</p><p id="cac0" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我为每个环境准备了一个docker映像，其中包含以下内容:</p><ul class=""><li id="9151" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">自定义bash脚本，用于构建和上传图像到Quay。</li><li id="de90" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">用于部署到Kubernetes的定制bash脚本。</li><li id="d0c2" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">当CircleCI secrets运行部署容器时，在AWS中连接集群所需的所有凭证集都由circle ci secrets注入。</li></ul><p id="e7af" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">下面让我们看看docker图像是如何构建的:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">8.Dockerfile CircleCI自定义</figcaption></figure><h1 id="3056" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构建工具</h1><p id="976b" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">以下bash脚本将完成以下工作:</p><ul class=""><li id="1adf" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">接收一堆具有所需配置的环境变量。</li><li id="943e" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">通过HTTP协议将指标发送到datadog后端。</li><li id="a81f" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">登录码头。</li><li id="d370" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">请求Docker守护进程CircleCI。(我强烈建议不要有码头建筑的图像，它经常无缘无故地失败。)</li><li id="abec" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">将Docker映像推送到Quay并运行漏洞检查。</li></ul><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">9.构建工具</figcaption></figure><p id="ed97" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">下面我们可以欣赏一下推送的图片中的漏洞检查。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ob"><img src="../Images/b9a8c83f20ef919adf9945885b4bf6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChVUY2SblPY2YRv1o61ulg.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">10.漏洞报告</figcaption></figure><h1 id="3fe0" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">释放工具</h1><p id="a1a5" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">以下Bash脚本将在docker映像被推送并且准备好执行部署之后执行。该脚本将执行以下操作:</p><ul class=""><li id="079a" class="nh ni iq ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">通过环境变量接收大量配置。</li><li id="3538" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">通过HTTP向Datadog发送指标。</li><li id="fd63" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">初始化头盔。</li><li id="9da2" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">在AWS中设置私有Helm repo。</li><li id="0836" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">从S3下载Helm values.yaml文件(我更喜欢将部署配置与开发人员代码分开)。</li><li id="910f" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">确定it是否需要安装/升级应用程序。</li><li id="0ba3" class="nh ni iq ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">通过Helm安装/升级。</li></ul><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">11.释放工具</figcaption></figure><h1 id="6e79" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">平台指标</h1><p id="0b80" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">DevOps思维模式非常信任自动化。了解我们的自动化工作流程中发生了什么的最好方法是测量指标。这是变革的推动者，是我们的眼睛。我们不能改进任何未经测量的东西。它只是盲目地工作。我在管道执行期间发送指标，以便了解正在部署什么，部署发生的频率，花费的时间。一段时间后，通过查看指标，您会惊讶地发现自动化节省了多少时间。</p><p id="6290" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">外部存在太多可用作数据狗的时序后端指标，在下图中以图形方式显示它们。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oc"><img src="../Images/3ce9595ba31b4578552a94697f1793c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKbXVIUR-Dx9QfO8tf492g.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">12.韵律学</figcaption></figure><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi od"><img src="../Images/83486be59ea728aca220e537f17c76ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLLqcHY25grh1mZJ9cQAOg.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">13.库伯内特原木</figcaption></figure><p id="de7a" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">CircleCI提供了一个名为Insights的2.0特性，它也提供了一些漂亮的信息。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oe"><img src="../Images/cdeee550f190a8ad5a9f691899bbcc91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHmwu725iZ77E8QF6pN1jg.png"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">14.CircleCI洞察</figcaption></figure><h1 id="3e51" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结尾词</h1><p id="b144" class="pw-post-body-paragraph kg kh iq ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld ij bi translated">这是一个真正完整的CI/CD工作流，有一个有趣的工具集(至少对我来说)。我们有太多新奇的选择可以使用。用于部署Kubernetes的下一代CD工具是Spinakker，它提供了一系列功能来提高自动化，并通过可定制的策略(如我稍后将发布的蓝绿色/淡黄色/黑色部署)来显著改变零停机部署的概念。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="of oa l"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">15.CircleCI结束工作流</figcaption></figure><p id="e845" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated"><strong class="ki ir">精心制作的CI/CD工具回购&amp; API回购如下:</strong></p><div class="og oh gp gr oi oj"><a href="https://github.com/hmarcelodn/helm-tool" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">hmarcelodn/helm工具</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">Bash工具。在GitHub上创建一个帐户，为hmarcelodn/helm-tool开发做出贡献。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ka oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://github.com/hmarcelodn/ts-sample" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">hmarcelodn/ts样本</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">CircleCI / Helm在GitHub上创建一个帐户，为hmarcelodn/ts-sample开发做出贡献。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ka oj"/></div></div></a></div><p id="811e" class="pw-post-body-paragraph kg kh iq ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">我花了很多时间准备这个完整的周期，所以如果你喜欢，拍我。感谢阅读。</p></div></div>    
</body>
</html>