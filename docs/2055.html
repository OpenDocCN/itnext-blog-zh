<html>
<head>
<title>Web app load metrics automated testing as a part of CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为CI一部分的Web应用程序负载指标自动化测试</h1>
<blockquote>原文：<a href="https://itnext.io/web-app-load-metrics-automated-testing-as-a-part-of-ci-ddbdc6a3f013?source=collection_archive---------2-----------------------#2019-03-24">https://itnext.io/web-app-load-metrics-automated-testing-as-a-part-of-ci-ddbdc6a3f013?source=collection_archive---------2-----------------------#2019-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0f042380fe87d79938c9f9a0e6106bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OWBgWzyXQ5blHitu.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">度量图像</figcaption></figure><p id="7fbe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现代Web应用程序在大多数情况下都在努力尽可能快地呈现API数据，并为UI呈现进行批处理。尤其是使用React，有时我们必须检查我们的web应用程序加载/渲染时间如何受到一些第三方库或新功能的影响。</p><h2 id="d3c1" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">怎么开始的</h2><p id="8f8e" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">大约两年前，当我们将我们的web应用程序/仪表板发布到产品中时，我们并不担心加载速度或渲染时间，因为应用程序很小，没有与之匹配的复杂性。但是随着时间的推移，当我们开始一个功能一个功能地发布时，应用程序的渲染时间变得更长了。这是几乎所有类型的应用程序开发过程的通常过程，但这里的关键是，我们只是在它非常慢之后才开始测量性能指标。</p><p id="1cbe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">到了那一步，就意味着你要在UI端重构很多组件，或者调查API响应时间。对于我们的例子，我们只是在几个冲刺阶段阻止了新功能的开发，并通过代码重构和加载/渲染时间测量来处理，慢慢地提高了原始应用程序的速度和加载时间。</p><p id="1b74" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是！这里是关键的事情:我们应该在每个特性发布时都这样做，当代码改进可以在小块中完成时。</p><h2 id="c4cb" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">CI期间的网站指标</h2><p id="672e" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">当我们意识到我们必须花大量时间重构大多数应用程序组件时，我们决定以某种方式跟踪应用程序性能指标，修复它们，然后跟踪它对新特性的影响。因此，我们只是将headless Google Chrome集成到我们的自动化测试流程中，并开始在我们的时间序列数据库中保存性能指标，以跟踪随时间的变化，并在应用程序开始变慢时进行重构。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b39d" class="ld le it mg b gy mk ml l mm mn">import puppeteer from 'puppeteer';<br/>import devices from 'puppeteer/DeviceDescriptors';<br/><br/>....<br/>const page = await browser.newPage();<br/><br/>// Getting Desktop metrics<br/>await page.setViewport({ width: 1366, height: 768 });<br/>await page.goto(url);<br/>const metricsDesktop = await page.metrics();<br/>...<br/><br/>// Getting Tablet metrics<br/>await page.emulate(iPad);<br/>await page.reload();<br/>const metricsTablet = await page.metrics();<br/>....<br/><br/>// Getting Mobile metrics<br/>await page.emulate(iPhone);<br/>await page.reload();<br/>const metricsMobile = await page.metrics();</span></pre><p id="da52" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每当我们将代码推送到<code class="fe mo mp mq mg b">master</code>分支，最终的应用测试开始运行时，这个过程就会发生。如果性能指标非常糟糕，我们的CI系统会拒绝新版本，这样我们就会知道，存在一些重大的负载/呈现问题。</p><h2 id="f790" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">自动获取结果</h2><p id="911d" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">作为我们项目<a class="ae mr" href="https://hexometer.com" rel="noopener ugc nofollow" target="_blank">Hexometer.com</a>的一部分，我们开始收集全网的网站指标，并对React应用或Angular应用的平均加载时间进行内部排名。这将有助于提供基于API的CI集成，以便始终获得有关web应用指标的数据，并跟踪新功能发布的性能。</p><p id="bd57" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一般来说，每个CI平台都可以与<code class="fe mo mp mq mg b">Google puppeteer</code>集成，并使用headless chrome作为服务器端浏览器测试的一部分。但是请记住，在CI平台和笔记本电脑上，您的web应用程序的整体性能指标可能完全不同。通常CI平台使用共享的服务器空间进行数百个测试，其中每个测试在不超过512 MB ram和1个CPU的容器内运行。这意味着所有网站指标都将与CI服务器上发生的事情相关，但总体流程不应有太大不同。对于我们的情况，我们设置了最小和最大垃圾收集，这在大多数情况下是可以的，但当然有时我们会遇到测试失败，而没有任何具体的性能降级，这只是因为我们的CI服务器过载，性能指标上升。</p><h2 id="f62d" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">结论</h2><p id="32b0" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">恭喜你到了这一步！！现在我们知道为什么保持网站满负荷时间和应用程序渲染的指标是重要的。这有助于让用户满意，让你的代码不断优化。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="e426" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">拍手声👏并分享您在全自动测试方面的经验！</p></div></div>    
</body>
</html>