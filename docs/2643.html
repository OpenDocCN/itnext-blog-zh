<html>
<head>
<title>React Native — How to handle an app with both pre-AndroidX and AndroidX dependencies (RN60)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Native——如何处理同时具有pre-AndroidX和AndroidX依赖项的应用程序(RN60)</h1>
<blockquote>原文：<a href="https://itnext.io/react-native-how-to-handle-an-app-with-both-pre-androidx-and-androidx-dependencies-rn60-bf4df7ea0dd2?source=collection_archive---------0-----------------------#2019-07-02">https://itnext.io/react-native-how-to-handle-an-app-with-both-pre-androidx-and-androidx-dependencies-rn60-bf4df7ea0dd2?source=collection_archive---------0-----------------------#2019-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f713" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在开始和深入研究如何处理一个具有非Android和Android依赖性的应用程序的原因/方法/解决方案之前，有必要花一点时间讨论一下Android是什么。</p><p id="4fb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你还没听说过这个术语，<a class="ae ko" href="https://developer.android.com/jetpack/androidx" rel="noopener ugc nofollow" target="_blank"> AndroidX </a>是谷歌推出的用Jetpack打包图书的新程序。本质上，旧的图书馆管理方式变得过于复杂，所以谷歌决定开始清理他们的行为，并使用新的系统，以及新的图书馆名称。</p><p id="5366" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果您的项目依赖于一个名为<code class="fe kp kq kr ks b">com.android.support:appcompat-v7</code>的库，并且您想迁移到AndroidX，那么您必须调用<code class="fe kp kq kr ks b">androidx.appcompat:appcompat:1.0.0</code>。谷歌很有帮助，甚至在这里提供了一个新旧名字的列表:<a class="ae ko" href="https://developer.android.com/jetpack/androidx/migrate" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/jetpack/androidx/migrate</a></p><p id="d2ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么这对您的React原生项目意味着什么呢？如果你像我们一样使用一些第三方库(Firebase，Auth0，Mapbox等等)。)那么，要么你的项目直接引入Google librairies，要么你的一些第三方依赖Google librairies。</p><p id="2ae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着在你的android项目中的某个地方，在你的build.gradle中，你可能有这样一行:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="d475" class="lb lc it ks b gy ld le l lf lg">implementation "<!-- -->com.android.support:appcompat-v7:&lt;version-name&gt;"</span></pre><p id="4271" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者在你的依赖关系树中(在Android Studio中，点击终端，然后运行<code class="fe kp kq kr ks b">./gradlew app:dependencies</code>,这将显示如下内容:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="5c4f" class="lb lc it ks b gy ld le l lf lg">+--- project :react-native-code-push<br/>|    +--- com.facebook.react:react-native:+ -&gt; 0.57.5<br/>|    |    +--- com.facebook.infer.annotation:infer-annotation:0.11.2<br/>|    |    |    \--- com.google.code.findbugs:jsr305:3.0.1 -&gt; 3.0.2<br/>|    |    +--- javax.inject:javax.inject:1<br/>|    |    +--- com.android.support:appcompat-v7:27.1.1<br/>|    |    |    +--- com.android.support:support-annotations:27.1.1<br/>|    |    |    +--- com.android.support:support-core-utils:27.1.1<br/>|    |    |    |    +--- com.android.support:support-annotations:27.1.1<br/>|    |    |    |    \--- com.android.support:support-compat:27.1.1<br/>|    |    |    |         +--- com.android.support:support-annotations:27.1.1<br/>|    |    |    |         \--- android.arch.lifecycle:runtime:1.1.0<br/>|    |    |    |              +--- android.arch.lifecycle:common:1.1.0<br/>|    |    |    |              \--- android.arch.core:common:1.1.0<br/>|    |    |    +--- com.android.support:support-fragment:27.1.1<br/>|    |    |    |    +--- com.android.support:support-compat:27.1.1 (***)</span></pre><p id="06f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe kp kq kr ks b">react-native-code-push</code>依赖项依赖于React Native，而React Native本身又依赖于com . Android . support:appcompat-v7，而app compat-V7又依赖于com . Android . support:support-core-utils</p><p id="8052" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一切都很好，只要:</p><ul class=""><li id="1006" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">所有的依赖项和第三方库都依赖于AndroidX之前的名称空间(即<code class="fe kp kq kr ks b">com.android.support...)</code></li></ul><p id="02e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运筹学</p><ul class=""><li id="4170" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">你所有的依赖依赖于AndroidX命名空间(例如<code class="fe kp kq kr ks b">androidx.appcompat...)</code></li></ul><p id="7bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发生在我们身上的事情是，我们发现自己被推到了一种状态，在这种状态下，我们的依赖使用了两者的混合。</p><h1 id="659b" class="lq lc it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">怎么就开始出问题了</strong></h1><p id="669a" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">发生了什么事？好吧，不要说太多细节，我们需要升级我们的一些图书馆来修复一些错误。我们需要的版本已经开始在幕后使用AndroidX，这让我们陷入了这种宿命的境地。</p><p id="a58a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为这也会发生在许多迁移到React Native 59(或60)的人身上，他们会发现尽管React Native现在使用AndroidX，但一些第三方模块可能仍然不支持AndroidX。</p><p id="22c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最初看到的是一个与我们的AndroidManifest相关的错误:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="e13e" class="lb lc it ks b gy ld le l lf lg">ERROR: Manifest merger failed : Attribute application@appComponentFactory value=(android.support.v4.app.CoreComponentFactory) from [com.android.support:support-compat:28.0.0] AndroidManifest.xml:22:18-91<br/> is also present at [androidx.core:core:1.0.0] AndroidManifest.xml:22:18-86 value=(androidx.core.app.CoreComponentFactory).<br/> Suggestion: add 'tools:replace="android:appComponentFactory"' to &lt;application&gt; element at manifestMerger4756582261911642725.xml:7:5-9:19 to override.</span></pre><p id="c904" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在这里看到的，该消息告诉我们，两个图书馆试图写入清单的同一个密钥，导致合并失败。你还会注意到，试图写入同一个键的两个库是pre-AndroidX和AndroidX，但是<em class="ms">它们实际上是同一个库</em>——因此它们都试图做同样的事情！</p><p id="27bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">唯一的解决方案是“选择一边”并强制我们的项目使用AndroidX名称空间。谢天谢地，谷歌已经想到了这一点，并提供了一个解决方案。只需将下面这些密钥添加到您的<code class="fe kp kq kr ks b">android &gt; gradle.properties</code>文件中:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="0e62" class="lb lc it ks b gy ld le l lf lg"><strong class="ks iu">android.useAndroidX</strong>=<strong class="ks iu">true<br/>android.enableJetifier</strong>=<strong class="ks iu">true</strong></span></pre><p id="3eeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上，这些代码行所做的是“拦截”您的项目和第三方模块所需的旧名称空间，并用新的AndroidX名称空间替换它们。换句话说，当构建依赖树时，它会“看到”需要<code class="fe kp kq kr ks b">com.android.support:support-compat</code>，而不是加载它，它会加载<code class="fe kp kq kr ks b">androidx.core.app</code>。很棒吧？</p><p id="01fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只是下一步引入了一个新问题:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="97fa" class="lb lc it ks b gy ld le l lf lg">&gt; Task :@mapbox_react-native-mapbox-gl:compileReleaseJavaWithJavac</span><span id="38f8" class="lb lc it ks b gy mt le l lf lg">/Users/vsts/agent/2.153.2/work/1/s/node_modules/@mapbox/react-native-mapbox-gl/android/rctmgl/src/main/java/com/mapbox/rctmgl/utils/ResourceUtils.java:6: error: package android.support.v4.content does not exist</span><span id="0e06" class="lb lc it ks b gy mt le l lf lg">import android.support.v4.content.ContextCompat;</span><span id="b22a" class="lb lc it ks b gy mt le l lf lg">^</span><span id="5f66" class="lb lc it ks b gy mt le l lf lg">/Users/vsts/agent/2.153.2/work/1/s/node_modules/@mapbox/react-native-mapbox-gl/android/rctmgl/src/main/java/com/mapbox/rctmgl/components/camera/constants/CameraMode.java:3: error: package android.support.annotation does not exist</span><span id="3acb" class="lb lc it ks b gy mt le l lf lg">import android.support.annotation.IntDef;</span><span id="b1f5" class="lb lc it ks b gy mt le l lf lg">^</span><span id="fceb" class="lb lc it ks b gy mt le l lf lg">/Users/vsts/agent/2.153.2/work/1/s/node_modules/@mapbox/react-native-mapbox-gl/android/rctmgl/src/main/java/com/mapbox/rctmgl/components/camera/constants/CameraMode.java:14: error: cannot find symbol</span><span id="3e26" class="lb lc it ks b gy mt le l lf lg">@IntDef({ FLIGHT, EASE, NONE })</span><span id="2c82" class="lb lc it ks b gy mt le l lf lg">^</span><span id="6eec" class="lb lc it ks b gy mt le l lf lg">symbol:   class IntDef</span><span id="dbf9" class="lb lc it ks b gy mt le l lf lg">location: class CameraMode</span><span id="55c8" class="lb lc it ks b gy mt le l lf lg">/Users/vsts/agent/2.153.2/work/1/s/node_modules/@mapbox/react-native-mapbox-gl/android/rctmgl/src/main/java/com/mapbox/rctmgl/components/camera/CameraStop.java:4: error: package android.support.annotation does not exist</span><span id="8f66" class="lb lc it ks b gy mt le l lf lg">import android.support.annotation.NonNull;</span></pre><p id="7369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个不同的问题:<code class="fe kp kq kr ks b">useAndroidX</code>标志已经动态地进行了交换，但是一些第三方库(通过npm安装并使用react-native link链接)现在显式地调用模块，这些模块不再能被找到，因为它们不是项目的一部分。</p><p id="4486" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果您导航到文件<code class="fe kp kq kr ks b">node_modules/@mapbox/react-native-mapbox-gl/android/rctmgl/src/main/java/com/mapbox/rctmgl/utils/ResourceUtils.java</code>，您确实会看到:</p><figure class="kt ku kv kw gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mu"><img src="../Images/ac36fa10d19684d380e61ad1c25c632e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4dHwhVHolzuJDrcHs8gwg.png"/></div></div></figure><p id="6193" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在该文件中，我们有两条错误消息:</p><ul class=""><li id="f5f6" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated"><code class="fe kp kq kr ks b">android.support.v4.content</code>不再存在，因为它在构建时被<code class="fe kp kq kr ks b">androidx.core.content</code>交换了。因此，您不能导入上下文兼容</li><li id="77ea" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated"><code class="fe kp kq kr ks b">return ContextCompat.getDrawable()</code>显然也不行</li></ul><p id="ee60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您将导入替换为(同样，您可以在此处找到旧名称/新名称的映射<a class="ae ko" href="https://developer.android.com/jetpack/androidx/migrate" rel="noopener ugc nofollow" target="_blank"/>):</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="ffd2" class="lb lc it ks b gy ld le l lf lg">import androidx.core.content.ContextCompat;</span></pre><p id="897d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都会好的。</p><p id="675b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，问题很明显了:你需要更新你的第三方库的代码来构建这个项目。所以我们的选择是:</p><ul class=""><li id="c82e" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">确保你使用最新版本的图书馆，因为有些可能已经支持AndroidX:我们这样做了，解决了一些问题。</li><li id="8e2a" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">对于没有支持AndroidX版本的图书馆，让开发者更新他们的图书馆以支持AndroidX。有些人可能要等几周，有些人可能要等几个月。这不是一个有效的策略</li><li id="00d8" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">手动找到所有专门导入Android前版本库的Java文件，并更改代码以使用新的Android命名空间。</li></ul><h1 id="57d1" class="lq lc it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">奋力营救</h1><p id="8935" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">虽然选项3运行良好，尽管这是一项耗时、费力的工作，但它并不能真正扩展。</p><p id="7218" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不手动构建我们的apk，我们使用AppCenter来完成，所以这已经是一个阻碍。AppCenter在每次构建之前都会执行一次清理<code class="fe kp kq kr ks b">npm install</code>,因此在node_modules内部重写代码可以在本地工作，但不能在CI环境中工作。</p><p id="dac8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们在一个团队中工作，我们不希望必须在每台机器上重新编写node_module代码。</p><p id="9a87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，每次你不得不做一个<code class="fe kp kq kr ks b">npm install</code>，你会覆盖你的改变，并不得不重新做一遍。</p><p id="099a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们必须找到一种可以在CI环境中使用的自动化方式。和往常一样，bash脚本最终成为首选。最终，所要做的就是一个<code class="fe kp kq kr ks b">search and replace.</code>,如果你看一下映射表，它非常简单明了:</p><figure class="kt ku kv kw gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nh"><img src="../Images/0ea14d3462e94961702205546aa01e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PeLPYbaucLo8acYbtm-O_A.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">AndroidX映射表</figcaption></figure><p id="0502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要的是找到旧名称表左栏中的值(见完整列表<a class="ae ko" href="https://developer.android.com/jetpack/androidx/migrate" rel="noopener ugc nofollow" target="_blank">此处</a>)，并用新名称栏中给出的新值替换它们。另外，我们知道导入只发生在<code class="fe kp kq kr ks b">.java</code>文件中，即(在99.9%的情况下)可以在<code class="fe kp kq kr ks b">node_modules/.../android/..</code>文件结构中找到。</p><p id="7a85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过，有一点需要注意，谷歌给出的名单很长:它有近2000个条目。所以搜索每一个名字要花很长时间。另外，我们从构建阶段的错误消息中知道，我们只需要搜索几个特定的字符串。</p><p id="1638" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们做的是:</p><ul class=""><li id="21af" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">我们通过一次替换一个node_modules文件中的导入来手动修复错误(听起来很可怕，但只花了大约1个小时)</li><li id="a7cd" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">我们记下了所有用旧名字进口的艺术品</li><li id="e294" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">我们在一个txt文件中写了一个旧名字-&gt;新名字的列表</li><li id="6da4" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">然后我们编写了下面的脚本，在我们的项目中搜索并替换这些字符串</li></ul><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="8aeb" class="lb lc it ks b gy ld le l lf lg">#!/bin/bash</span><span id="64f8" class="lb lc it ks b gy mt le l lf lg">for f in $(find node_modules -wholename "*/android/*.java");</span><span id="636d" class="lb lc it ks b gy mt le l lf lg">do</span><span id="f45a" class="lb lc it ks b gy mt le l lf lg">   cat androidxNodeModuleReplaceList.txt| while read line || [ -n   "$line" ]</span><span id="cbab" class="lb lc it ks b gy mt le l lf lg">   do</span><span id="10d7" class="lb lc it ks b gy mt le l lf lg">      if grep -q $(echo $line | sed 's/\/.*//') $f;</span><span id="5777" class="lb lc it ks b gy mt le l lf lg">         then</span><span id="2912" class="lb lc it ks b gy mt le l lf lg">         sed s/$line/g $f &gt; $f.new &amp;&amp; mv $f.new $f</span><span id="f79d" class="lb lc it ks b gy mt le l lf lg">         echo "$f &gt;&gt; $line \n"</span><span id="fe5b" class="lb lc it ks b gy mt le l lf lg">      fi</span><span id="4471" class="lb lc it ks b gy mt le l lf lg">   done</span><span id="fa6e" class="lb lc it ks b gy mt le l lf lg">done</span></pre><p id="1276" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个简单的脚本实现了它在tin上所说的功能:search。node_module/下的java文件../安卓/..当它找到一个文件时，它会搜索我们的引用文件<code class="fe kp kq kr ks b">androidxNodeModuleReplaceList.txt</code>中的任何键。用新字符串替换旧字符串。控制台记录更换并继续。</p><p id="1361" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为参考，这里是我们的<code class="fe kp kq kr ks b">androidxNodeModuleReplaceList.txt:</code></p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="f939" class="lb lc it ks b gy ld le l lf lg">android.support.v4.content.ContextCompat/androidx.core.content.ContextCompat<br/>android.support.annotation.IntDef/androidx.annotation.IntDef<br/>android.support.annotation.NonNull/androidx.annotation.NonNull<br/>android.support.annotation.Nullable/androidx.annotation.Nullable<br/>android.support.v4.app.NotificationManagerCompat/androidx.core.app.NotificationManagerCompat<br/>android.support.v4.app.NotificationCompat/androidx.core.app.NotificationCompat<br/>android.support.v4.content.res.ResourcesCompat/androidx.core.content.res.ResourcesCompat<br/>android.support.annotation.RequiresApi/androidx.annotation.RequiresApi<br/>android.support.v4.app.ActivityCompat/androidx.core.app.ActivityCompat<br/>android.support.v4.content.FileProvider/androidx.core.content.FileProvider<br/>android.support.v4.net.ConnectivityManagerCompat/androidx.core.net.ConnectivityManagerCompat<br/>android.support.customtabs.CustomTabsIntent/androidx.browser.customtabs.CustomTabsIntent<br/>android.support.v4.util.Pools/androidx.core.util.Pools<br/>android.support.annotation.Keep/androidx.annotation.Keep<br/>android.support.annotation.RequiresPermission/androidx.annotation.RequiresPermission<br/>android.support.v4.content.LocalBroadcastManager/androidx.localbroadcastmanager.content.LocalBroadcastManager<br/>android.support.v4.app.RemoteInput/androidx.core.app.RemoteInput<br/>android.support.annotation.StyleRes/androidx.annotation.StyleRes<br/>android.support.v7.app.AlertDialog/androidx.appcompat.app.AlertDialog<br/>android.support.annotation.MainThread/androidx.annotation.MainThread</span></pre><p id="c4ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，只需将txt文件放在项目的根目录下，并将bash脚本放在项目的根目录下。</p><p id="3bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在本地构建，只需在控制台中调用就可以运行bash脚本。我们称之为<code class="fe kp kq kr ks b">appcenter-pre-build.sh</code>,所以你只需在命令行输入<code class="fe kp kq kr ks b">./appcenter-pre-build.sh</code>,然后按回车键。您将看到该脚本将替换整个文件结构中的许多导入。</p><h1 id="3a44" class="lq lc it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如何在AppCenter中运行它</h1><p id="1983" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">AppCenter提供了构建脚本工具，这在CI领域非常普遍，在Circle CI和其他领域也将存在。</p><p id="44f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让AppCenter识别您的脚本，您需要给它一个特定的名称，这取决于您想在哪里调用它。在我们的例子中，脚本需要在<code class="fe kp kq kr ks b">npm install</code>之后和<code class="fe kp kq kr ks b">build</code>之前运行。这就是我们使用<code class="fe kp kq kr ks b">appcenter-pre-build.sh</code>的原因。你可以在这里看到更多的文档:<a class="ae ko" href="https://docs.microsoft.com/en-us/appcenter/build/custom/scripts/" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/app center/build/custom/scripts/</a></p><p id="b46d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过，有一点需要注意，要将您的脚本考虑在内，您需要:</p><ul class=""><li id="e286" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">提交包括新文件在内的更改，并推入远程分支。</li><li id="e3e0" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">登录到AppCenter，并导航到该分支的构建设置</li><li id="e013" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">您将看到一个视觉指示，即您的脚本通过看到蓝色的小勾号被识别出来(见下文)]</li><li id="b962" class="lh li it js b jt nc jx nd kb ne kf nf kj ng kn lm ln lo lp bi translated">您仍然需要“保存”或“保存并构建”，即使不做任何更改，否则脚本将不会运行。有点奇怪，但是给你..</li></ul><figure class="kt ku kv kw gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nm"><img src="../Images/0995273d7973da849206f6c8eea7e5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jltvDvQ1Ul59jxPIQCzKfA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">AppCenter构建设置</figcaption></figure><p id="34fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧啊。您的分支现在将构建并使用该脚本。您可以检查日志，应该能够看到类似这样的内容:</p><figure class="kt ku kv kw gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nn"><img src="../Images/46e6e98196a66af465d73ebd74675e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Fz-5X7wkVyXQpuUrPDKjw.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">带有预构建脚本的AppCenter构建</figcaption></figure><h1 id="748c" class="lq lc it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">处理特殊情况</h1><p id="a52c" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">有时更新Java文件的代码可能还不够。通常，如果您使用<code class="fe kp kq kr ks b">react-native-image-crop-picker </code>，那么您可能会得到与AndroidManifest.xml相关的错误消息。这是因为库试图在引用旧类的主AndroidManifest.xml中插入一些代码:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="4c3c" class="lb lc it ks b gy ld le l lf lg">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</span><span id="06d9" class="lb lc it ks b gy mt le l lf lg">package="com.reactnative.ivpusic.imagepicker"&gt;</span><span id="4baf" class="lb lc it ks b gy mt le l lf lg">&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</span><span id="7244" class="lb lc it ks b gy mt le l lf lg">&lt;application&gt;</span><span id="6e92" class="lb lc it ks b gy mt le l lf lg">&lt;provider</span><span id="b151" class="lb lc it ks b gy mt le l lf lg">android:name="android.support.v4.content.FileProvider"</span><span id="46ce" class="lb lc it ks b gy mt le l lf lg">android:authorities="${applicationId}.provider"</span><span id="5732" class="lb lc it ks b gy mt le l lf lg">android:exported="false"</span><span id="b592" class="lb lc it ks b gy mt le l lf lg">android:grantUriPermissions="true"&gt;</span><span id="57da" class="lb lc it ks b gy mt le l lf lg">&lt;meta-data</span><span id="6ae6" class="lb lc it ks b gy mt le l lf lg">android:name="android.support.FILE_PROVIDER_PATHS"</span><span id="14f2" class="lb lc it ks b gy mt le l lf lg">android:resource="@xml/provider_paths" /&gt;</span><span id="b70f" class="lb lc it ks b gy mt le l lf lg">&lt;/provider&gt;</span><span id="bc90" class="lb lc it ks b gy mt le l lf lg">&lt;activity</span><span id="e3ae" class="lb lc it ks b gy mt le l lf lg">android:name="com.yalantis.ucrop.UCropActivity"</span><span id="eadc" class="lb lc it ks b gy mt le l lf lg">android:theme="@style/Theme.AppCompat.Light.NoActionBar" /&gt;</span><span id="48be" class="lb lc it ks b gy mt le l lf lg">&lt;/application&gt;</span><span id="1d71" class="lb lc it ks b gy mt le l lf lg">&lt;/manifest&gt;</span></pre><p id="bcb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，<code class="fe kp kq kr ks b">provider</code>键正在使用<code class="fe kp kq kr ks b">android:name="android.support.v4.content.FileProvider"</code></p><p id="2d4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所述，一旦<code class="fe kp kq kr ks b">useAndroidX</code>被设置为true，该引用将不起作用，因此构建将起作用，但是当在设备或模拟器上安装应用程序时，您可能会遇到以下消息:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="ca0b" class="lb lc it ks b gy ld le l lf lg">E/AndroidRuntime: FATAL EXCEPTION: main<br/>    Process: net.communityapp, PID: 5107<br/>    java.lang.RuntimeException: Unable to get provider android.support.v4.content.FileProvider: java.lang.ClassNotFoundException: Didn't find class "android.support.v4.content.FileProvider" on path: DexPathList[[zip file "/data/app/&lt;your-app-id&gt;-EANMnjI7DZQI_uIRCAQ7Sg==/base.apk", zip file "/data/app/net</span></pre><p id="00c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，关于找不到类的错误..</p><p id="9e8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题实际上很容易解决。Android提供了一些工具来帮助你操作由不同图书馆插入到清单中的数据，并提供了处理这些数据的工具。</p><p id="20fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，您需要做的就是在清单中使用xmlns:tools = " http://schemas . Android . com/tools ",并在清单中强制使用新的AndroidX名称空间。</p><p id="e71f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，请将这段代码插入您的清单:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="d9ae" class="lb lc it ks b gy ld le l lf lg">&lt;!-- Necessary to override the react-native-image-croper Manifest which still references the old android.support... instead of androidx... --&gt;</span><span id="5811" class="lb lc it ks b gy mt le l lf lg">&lt;!-- Remove whenever that library gets updated to androidx --&gt;</span><span id="ac00" class="lb lc it ks b gy mt le l lf lg">&lt;provider</span><span id="6018" class="lb lc it ks b gy mt le l lf lg">android:name="androidx.core.content.FileProvider"</span><span id="de76" class="lb lc it ks b gy mt le l lf lg">android:authorities="${applicationId}.provider"</span><span id="b959" class="lb lc it ks b gy mt le l lf lg">android:enabled="true"</span><span id="2610" class="lb lc it ks b gy mt le l lf lg">android:exported="false"</span><span id="fe94" class="lb lc it ks b gy mt le l lf lg">android:grantUriPermissions="true"</span><span id="08e5" class="lb lc it ks b gy mt le l lf lg">tools:replace="android:name"&gt;</span><span id="f609" class="lb lc it ks b gy mt le l lf lg">&lt;meta-data</span><span id="142e" class="lb lc it ks b gy mt le l lf lg">android:name="android.support.FILE_PROVIDER_PATHS"</span><span id="9d23" class="lb lc it ks b gy mt le l lf lg">android:resource="@xml/provider_paths" /&gt;</span><span id="45f9" class="lb lc it ks b gy mt le l lf lg">&lt;/provider&gt;</span></pre><p id="0eaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以添加到清单中的结束标签<code class="fe kp kq kr ks b">&lt;/application&gt; </code>之前。这是指定一个使用AndroidX引用的提供者密钥。您还需要确保您的清单引用了“工具”:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="7bf8" class="lb lc it ks b gy ld le l lf lg">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"</span><span id="0abe" class="lb lc it ks b gy mt le l lf lg"><strong class="ks iu">xmlns:tools="http://schemas.android.com/tools"</strong></span><span id="537b" class="lb lc it ks b gy mt le l lf lg">package="net.communityapp"&gt;</span></pre><p id="b614" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有更多关于AndroidManifest文件相关工具的细节:<a class="ae ko" href="https://developer.android.com/studio/build/manifest-merge" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/studio/build/manifest-merge</a></p><h1 id="a544" class="lq lc it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="0fc2" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">虽然这个解决方案“有效”,并让我们重新构建和部署，但它只是一个临时的解决方案。</p><p id="ec38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将密切关注我们使用的各种第三方图书馆发布的更新，并尝试慢慢地完全摆脱这个脚本。</p><p id="d52d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望对你有帮助，如果你有问题，或者改进的建议，请告诉我！我们仍然是相当新的反应原生，所以也许有更好，更有效的方法来处理这一点。</p></div></div>    
</body>
</html>