<html>
<head>
<title>Debug a Go Application in Kubernetes from IDE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从IDE调试Kubernetes中的Go应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/debug-a-go-application-in-kubernetes-from-ide-c45ad26d8785?source=collection_archive---------2-----------------------#2018-08-28">https://itnext.io/debug-a-go-application-in-kubernetes-from-ide-c45ad26d8785?source=collection_archive---------2-----------------------#2018-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="613f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为开发人员，能够用自己的IDE调试应用程序总是很有用的。</p><p id="1bc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您的应用程序只与Kubernetes API一起工作时，您可以简单地在IDE中启动您的应用程序，并将其连接到远程Kubernetes API。</p><p id="4968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是当您的应用程序需要连接到只能在Kubernetes集群中使用的其他系统时，这个解决方案就不再有效了。</p><h2 id="35bf" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">构建应用程序</h2><p id="d799" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我想调试的应用程序是一个Cassandra操作符，它基于CoreOS <a class="ae lj" href="https://github.com/operator-framework/operator-sdk" rel="noopener ugc nofollow" target="_blank">操作符SDK </a></p><p id="dfcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作员使用脚本build.sh来构建Go应用程序，我向脚本添加了一个输入参数<strong class="jp ir"> DEBUG </strong>，这样它可以构建一个应用程序的调试版本，添加了特定的gcflags，然后在二进制文件后面加上<em class="lk"> -debug </em>。</p><p id="099b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们还将dlv二进制文件(它是Go调试器)添加到了我们的目标二进制文件中。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="b011" class="kl km iq lq b gy lu lv l lw lx"><strong class="lq ir">#!/usr/bin/env bash<br/><br/></strong><em class="lk">set </em>-o errexit<br/><em class="lk">set </em>-o nounset<br/><em class="lk">set </em>-o pipefail<br/><br/><strong class="lq ir">if ! </strong><em class="lk">which </em>go <em class="lk">&gt; /dev/null</em>; <strong class="lq ir">then<br/>   </strong><em class="lk">echo </em>"golang needs to be installed"<br/>   <em class="lk">exit </em>1<br/><strong class="lq ir">fi<br/><br/></strong>BIN_DIR="<strong class="lq ir">$</strong>(pwd)/tmp/_output/bin"<br/><em class="lk">mkdir </em>-p <strong class="lq ir">$</strong>{BIN_DIR}<br/>PROJECT_NAME="cassandra-operator"<br/>REPO_PATH="gitlab.si.francetelecom.fr/kubernetes/cassandra-operator"<br/>BUILD_PATH="<strong class="lq ir">$</strong>{REPO_PATH}/cmd/<strong class="lq ir">$</strong>{PROJECT_NAME}"<br/><br/><strong class="lq ir">if [ </strong>$# <strong class="lq ir">-gt </strong>0<strong class="lq ir"> ] &amp;&amp; [ </strong>"$1" <strong class="lq ir">= </strong>"DEBUG"<strong class="lq ir"> ] </strong>; <strong class="lq ir">then<br/>  </strong><em class="lk">echo </em>"building "<strong class="lq ir">$</strong>{PROJECT_NAME}" In DEBUG Mode..."<br/>  GOOS=linux GOARCH=amd64 CGO_ENABLED=0 <em class="lk">go </em>build -gcflags "-N -l" -o <strong class="lq ir">$</strong>{BIN_DIR}/<strong class="lq ir">$</strong>{PROJECT_NAME}-debug $BUILD_PATH<br/>  <em class="lk">cp </em>/usr/local/bin/dlv <strong class="lq ir">$</strong>{BIN_DIR}<br/><strong class="lq ir">else<br/>  </strong><em class="lk">echo </em>"building "<strong class="lq ir">$</strong>{PROJECT_NAME}"..."<br/>  GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o <strong class="lq ir">$</strong>{BIN_DIR}/<strong class="lq ir">$</strong>{PROJECT_NAME} $BUILD_PATH<br/><strong class="lq ir">fi</strong></span></pre><h2 id="d903" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">建立Docker形象</h2><p id="f1e0" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">操作员SDK生成一个docker文件来为我们的操作员构建映像，并生成一个脚本(<em class="lk"> docker_build.sh) </em>用于构建映像，在这个脚本上<em class="lk"> </em>我们还添加了<strong class="jp ir"> DEBUG </strong>参数:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="1349" class="kl km iq lq b gy lu lv l lw lx"><strong class="lq ir">#!/usr/bin/env bash<br/><br/>if ! </strong><em class="lk">which </em>docker <em class="lk">&gt; /dev/null</em>; <strong class="lq ir">then<br/>   </strong><em class="lk">echo </em>"docker needs to be installed"<br/>   <em class="lk">exit </em>1<br/><strong class="lq ir">fi<br/><br/></strong><em class="lk">: </em><strong class="lq ir">$</strong>{IMAGE:?"Need to set IMAGE, e.g. gcr.io/&lt;repo&gt;/&lt;your&gt;-operator"}<br/><br/><strong class="lq ir">if [ </strong>$# <strong class="lq ir">-gt </strong>0<strong class="lq ir"> ] &amp;&amp; [ </strong>"$1" <strong class="lq ir">= </strong>"DEBUG"<strong class="lq ir"> ] </strong>; <strong class="lq ir">then<br/>  </strong><em class="lk">echo </em>"building container <strong class="lq ir">$</strong>{IMAGE} in DEBUG Mode..."<br/>  <em class="lk">docker </em>build -t "<strong class="lq ir">$</strong>{IMAGE}" -f tmp/build/Dockerfile-debug .<br/><strong class="lq ir">else<br/>  </strong><em class="lk">echo </em>"building container <strong class="lq ir">$</strong>{IMAGE}..."<br/>  <em class="lk">docker </em>build -t "<strong class="lq ir">$</strong>{IMAGE}" -f tmp/build/Dockerfile .<br/><strong class="lq ir">fi</strong></span></pre><p id="df21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们添加了一个新的Dockerfile-debug，最后只做了一些修改:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="462f" class="kl km iq lq b gy lu lv l lw lx">....<br/>ADD tmp/_output/bin/cassandra-operator-debug /usr/local/bin<br/>ADD tmp/_output/bin/dlv /usr/local/bin<br/><br/>EXPOSE 40000<br/><br/>ENTRYPOINT ["/usr/local/bin/dlv", "--listen=:40000", "--headless=true", "--api-version=2", "exec", "/usr/local/bin/cassandra-operator-debug"]</span></pre><p id="7d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在docker映像中添加了应用程序的调试版本和delve调试器。我们还更改了入口点，告诉映像启动调试器，调试器将在调试模式下执行操作符。</p><p id="e44f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Delve公开了端口40000，我们将在这个端口上配置我们的IDE来与之通信。</p><p id="1cae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于在调试模式下构建整个运算符的Makefile的摘录:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="c2fb" class="kl km iq lq b gy lu lv l lw lx">docker-build-debug: docker-get-deps<br/>  echo "Generate CRD Client"<br/>  tmp/codegen/update-generated.sh<br/>  echo "Build Go Application In DEBUG Mode"<br/>  docker run --rm -v $(PWD):$(WORKDIR):rw $(REPOSITORY)/dev:$(VERSION) /bin/bash -c './tmp/build/build.sh DEBUG'<br/>  echo "Build Docker Image With DEBUG Enabled"<br/>  IMAGE=$(REPOSITORY):$(VERSION)-debug ./tmp/build/docker_build.sh DEBUG</span></pre><h2 id="9c75" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">部署应用程序</h2><p id="54f8" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">一旦您在调试模式下编译了操作符并重新创建了Docker映像，我们还需要在部署中做一点小小的更改，以公开端口40000并向集群中的操作符Pod添加<strong class="jp ir"> SYS_PTRACE </strong>功能。为了部署管理调试值的应用程序，我使用了一个Helm图表来定制部署:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="a348" class="kl km iq lq b gy lu lv l lw lx">...</span><span id="8f32" class="kl km iq lq b gy ly lv l lw lx">{{- if .Values.debug }}<br/>        <strong class="lq ir">image: </strong>"{{ .Values.image.repository }}:{{ .Values.image.tag }}-debug"<br/>{{- else}}<br/>        <strong class="lq ir">image: </strong>"{{ .Values.image.repository }}:{{ .Values.image.tag }}"<br/>{{- end }}<br/>        <strong class="lq ir">imagePullPolicy: </strong>"{{ .Values.image.pullPolicy }}"<br/>        resources:<br/>{{ toYaml .Values.resources | indent 10 }}<br/>        <strong class="lq ir">env:<br/>          </strong>- name: WATCH_NAMESPACE<br/>            valueFrom:<br/>              fieldRef:<br/>                fieldPath: metadata.namespace<br/>        ports:<br/>        - containerPort: 9710<br/>          name: metrics<br/>          protocol: TCP<br/>{{- if .Values.debug }}<br/>        - <strong class="lq ir">containerPort: </strong>40000<br/>          name: debug<br/>          protocol: TCP<br/>      securityContext:<br/>        capabilities:<br/>          add:<br/>            SYS_PTRACE<br/>{{- end }}</span></pre><p id="f796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在调试模式下部署操作员，我只需增加调试值:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9346" class="kl km iq lq b gy lu lv l lw lx">helm install ./helm/cassandra-operator --name cassandra-operator-debug --set debug=true</span></pre><p id="4322" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将为操作员创建所有必要的Kubernetes对象。如果您有一个TCP入口，您可以配置一个特定的路由到达您的pod的端口40000。因为我没有端口，所以我将创建一个端口转发，以便能够从我的IDE所在的本地机器到达这个端口:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="8585" class="kl km iq lq b gy lu lv l lw lx">kubectl port-forward &lt;cassandra-operator-debug-pod-name&gt; 40000:40000</span></pre><h2 id="18ef" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">配置IDE</h2><p id="b5f9" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我使用Goland来调试我的围棋程序，但它也可以在其他IDE上类似地运行</p><p id="0f7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要创建一个远程调试，并将其指向localhost:40000，因为我已经激活了端口转发。</p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lz"><img src="../Images/83fb3aadce99e8ff7b23ab0db0e076eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLsN9yc388OvE6WOaLl2qg.png"/></div></div></figure><p id="f78e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从那时起，我们能够在本地IDE中设置断点，它将与Kubernetes集群中部署的delve调试器通信，以允许调试我们的应用程序:</p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/5fe0dea2026c5be3cae9d10e74a43609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oi5QBVQEV6PeYoYnAzj6nA.png"/></div></div></figure><h2 id="25fd" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">最后</h2><p id="86a2" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在开始执行代码之前，应用程序将等待IDE连接到它，这样您就可以从头开始调试。</p><p id="741b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当您在IDE端停止调试(或松散连接)时，Pod将停止在状态<strong class="jp ir"> completed </strong>中，如果您使用的是Kubernetes部署，它可能会自动重启。</p><p id="84dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你需要知道:</p><ul class=""><li id="bb55" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">由于delve和您的IDE之间的网络延迟，您的远程调试将会变慢</li><li id="cd4f" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">每次您想测试一行新代码时，您都需要在调试模式下重新构建代码，在调试模式下重新构建docker映像，将其重新推送到Docker注册表中，然后在调试模式下重新部署操作符。</li></ul></div></div>    
</body>
</html>