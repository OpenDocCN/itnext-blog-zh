<html>
<head>
<title>Directive Type Checking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">指令类型检查</h1>
<blockquote>原文：<a href="https://itnext.io/directive-type-checking-3d3c5f1137b3?source=collection_archive---------1-----------------------#2022-12-05">https://itnext.io/directive-type-checking-3d3c5f1137b3?source=collection_archive---------1-----------------------#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/55a51fe66cccb0d2c11d8d3ee1ec3596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BVnx3NEh93UIQF0nuFza1A.png"/></div></div></figure><p id="1b7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">指令</strong>是一个非常强大的工具，我们应该掌握它来提高我们的角度技巧。Typescript强制执行严格类型，并帮助我们使我们的代码库更有弹性。不幸的是，定制指令并不是开箱即用的。本文的目的是向您展示如何将严格的类型添加到您的结构化指令中，并使您的角度代码库更具弹性。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="08d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了支持类型检查，我们需要使用Angular提供的两个方便的类型保护:</p><ul class=""><li id="93e8" class="ld le iq ka b kb kc kf kg kj lf kn lg kr lh kv li lj lk ll bi translated">ngTemplateContextGuard :为我们的自定义指令的上下文声明一个自定义类型</li><li id="db52" class="ld le iq ka b kb lm kf ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="ka ir">ngTemplateGuard _[customInputProperty]</strong>:缩小输入属性的呈现类型。</li></ul><p id="8584" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们深入这些静态角度函数之前，我们需要理解Typescript类型谓词是如何工作的。如果你不理解或者从未听说过这篇文章，我邀请你阅读这篇文章。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/@thomas.laforge/typescript-type-predicate-d9b8c4a15569" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">类型脚本类型谓词</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在Typescript中获取您的类型的控件</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jw lv"/></div></div></a></div></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="df10" class="mk ml iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">ngTemplateContextGuard</h2><p id="ea9e" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">如果我们需要为我们的自定义指令提供一个上下文，我们可以使用静态函数<strong class="ka ir"> ngTemplateContextGuard </strong>确保它在模板中被正确地键入。它的工作方式类似于Typescript类型保护函数，并返回一个类型谓词。</p><p id="5937" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子来更好地理解这个概念。</p><pre class="ni nj nk nl gt nm nn no bn np nq bi"><span id="fb56" class="nr ml iq nn b be ns nt l nu nv">interface DemoUrl {<br/>  url: string;<br/>  video: boolean;<br/>}<br/><br/>// interface declaring the Context of this Directive<br/>interface DemoContext {<br/>  $implicit: number;<br/>  demo: string;<br/>  url: DemoUrl;<br/>}<br/><br/>@Directive({<br/>  selector: '[demo]',<br/>  standalone: true,<br/>})<br/>export class DemoDirective implements OnInit {<br/>  @Input() demo!: string;<br/>  @Input() demoUrl!: DemoUrl;<br/><br/>  constructor(<br/>    private readonly viewContainerRef: ViewContainerRef,<br/>    private readonly templateRef: TemplateRef&lt;DemoContext&gt;<br/>  ) {}<br/><br/>  ngOnInit(): void {<br/>    const context = {<br/>      $implicit: 1,<br/>      demo: this.demo,<br/>      url: this.demoUrl,<br/>    };<br/>    this.viewContainerRef.createEmbeddedView(this.templateRef, context);<br/>  }<br/><br/>  // Guard to help Typescript correctly type checked <br/>  // the context with which the template will be rendered<br/>  static ngTemplateContextGuard(<br/>    directive: DemoDirective,<br/>    context: unknown<br/>  ): context is DemoContext {<br/>    return true;<br/>  }<br/>}</span></pre><p id="68e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nw">ngTemplateContextGuard返回true，因为该指令总是将DemoContext类型的上下文传递给模板。</em></p><p id="6966" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我们在模板中使用这个指令时，我们得到了类型正确的属性。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/13dac0dc452c49efb0a11bfc3b90f86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHN1l5PCJma-ig0rIph9Mg.png"/></div></div></figure><blockquote class="ny nz oa"><p id="39fa" class="jy jz nw ka b kb kc kd ke kf kg kh ki ob kk kl km oc ko kp kq od ks kt ku kv ij bi translated">额外提示:我们可以用三种不同的方式编写结构指令。所有这些都被编译器以同样的方式解释。</p></blockquote><pre class="ni nj nk nl gt nm nn no bn np nq bi"><span id="69ed" class="nr ml iq nn b be ns nt l nu nv">&lt;ng-template demo="toto" [demoUrl]="demoUrl" let-version let-demo="demo" let-url="url"&gt;<br/>  {{ url.url }}<br/>&lt;/ng-template&gt;<br/><br/>// * is the shorthand for what angular will interpret with ng-template<br/>&lt;div *demo="'toto'; let version; url: demoUrl; let demo = demo; let url = url"&gt;<br/>  {{ url.url }}<br/>&lt;/div&gt;<br/><br/>// We can use "as" in replacement of "let ... = "<br/>&lt;div *demo="'toto' as version; url: demoUrl; demo as demo; url as url"&gt;<br/>  {{ url.url }}<br/>&lt;/div&gt;</span></pre><h2 id="45e2" class="mk ml iq bd mm mn mo dn mp mq mr dp ms kj mt mu mv kn mw mx my kr mz na nb nc bi translated">ngTemplateGuard _[customInputProperty]</h2><p id="1823" class="pw-post-body-paragraph jy jz iq ka b kb nd kd ke kf ne kh ki kj nf kl km kn ng kp kq kr nh kt ku kv ij bi translated">理解这个保护有点复杂。结构指令控制模板在运行时的呈现方式。<em class="nw">(例如，只有当输入条件为thrustly时，NgIf才会将模板添加到DOM中。)</em></p><p id="a26b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们的自定义指令的输入具有复杂的类型，并且该指令仅在满足特定条件时才呈现模板，那么我们可以使用这种保护来缩小呈现的类型。</p><p id="70c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们展示这个例子来更好地理解这个概念:</p><pre class="ni nj nk nl gt nm nn no bn np nq bi"><span id="3e8c" class="nr ml iq nn b be ns nt l nu nv">// Typescript type guard<br/>export const isDog = (animal: Animal): animal is Dog =&gt; {<br/>  return (animal as Dog).breed !== undefined;<br/>}<br/><br/>interface Cat {<br/>  name: string;<br/>  type: 'cat';<br/>}<br/><br/>interface Dog {<br/>  name: string;<br/>  race: string;<br/>  type: 'dog';<br/>}<br/><br/>type Animal = Dog | Cat;<br/><br/>@Directive({<br/>  selector: '[isDog]',<br/>  standalone: true,<br/>})<br/>export class DogDirective {<br/>  @Input('isDog') set isDogInput(animal: Animal) {<br/>    if (isDog(animal.type)) {<br/>      this.viewContainerRef.createEmbeddedView(this.templateRef);<br/>    } else {<br/>      this.viewContainerRef.clear();<br/>    }<br/>  }<br/><br/>  constructor(<br/>    private readonly viewContainerRef: ViewContainerRef,<br/>    private readonly templateRef: TemplateRef&lt;unknown&gt;<br/>  ) {}</span></pre><p id="92ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该指令将一个<code class="fe oe of og nn b">Animal</code>作为输入，并且仅当输入动物的类型为<code class="fe oe of og nn b">Dog</code>时才呈现模板。尽管我们100%确定只有当我们的输入是<code class="fe oe of og nn b">Dog</code>类型时，这个模板才会被渲染，但是我们可以看到模板中的动物变量仍然是<code class="fe oe of og nn b">Animal</code>类型。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/df406d780e9669d4ea375d333f648e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*5nVCWmTNEyAVkMatHxIMoA.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">没有<strong class="bd mm"> ngTemplateGuard </strong></figcaption></figure><p id="cc28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<strong class="ka ir"> ngTemplateGuard </strong>前来救援的地方。我们使用下面的函数将我们的类型缩小到<code class="fe oe of og nn b">Dog</code>，并在模板中享受更好的类型安全性。</p><pre class="ni nj nk nl gt nm nn no bn np nq bi"><span id="dccf" class="nr ml iq nn b be ns nt l nu nv">static ngTemplateGuard_isDog(<br/>  dir: DogDirective,<br/>  state: Animal // input type<br/>): state is Dog { // output type<br/>  return true;<br/>}</span></pre><p id="b9e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以在模板中看到正确推断的类型</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/662716acfd4f7486489659d53b7bc62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*OAlA-WL6Cvz5D1Fz6w6mNQ.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated">与<strong class="bd mm"> ngTemplateGuard </strong></figcaption></figure><p id="5352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">备注:</strong>如果我们决定更改绑定到我们内部输入名称的模板中使用的名称，如<em class="nw">@ Input(' isDogExternal ')isDog</em>，则防护采用外部值。这意味着守卫将变成<em class="nw">ngTemplateGuard _ isDogExternal</em>。</p><p id="0fda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，除非我们有充分的理由，否则应该避免混淆。同一个属性有两个名称(外部和内部)会引起混淆。<em class="nw">(查看</em> <a class="ae lr" href="https://angular.io/guide/styleguide#avoid-aliasing-inputs-and-outputs" rel="noopener ugc nofollow" target="_blank"> <em class="nw">棱角风格指南</em> </a> <em class="nw">)。)</em></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="5aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！您不再有任何借口不严格输入您的自定义指令…</p><p id="d9f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得这篇文章有用，请考虑支持我的工作，为它鼓掌👏👏帮助它接触到更广泛的受众。非常感谢你的支持。</p><p id="0f5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你学到了新的角度概念。你可以在<a class="ae lr" href="https://medium.com/@thomas.laforge" rel="noopener">媒体</a>、<a class="ae lr" href="https://twitter.com/laforge_toma" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae lr" href="https://github.com/tomalaforge" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到我。如果你有更多的问题，不要犹豫来找我</p><blockquote class="on"><p id="010e" class="oo op iq bd oq or os ot ou ov ow kv dk translated">👉如果你想加快你的角度学习之旅，来看看<a class="ae lr" href="https://github.com/tomalaforge/angular-challenges" rel="noopener ugc nofollow" target="_blank">角度挑战</a>。</p></blockquote></div></div>    
</body>
</html>