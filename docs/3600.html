<html>
<head>
<title>Terminal/Console User Interface in .NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终端/控制台用户界面。网络核心</h1>
<blockquote>原文：<a href="https://itnext.io/terminal-console-user-interface-in-net-core-4e978f1225b?source=collection_archive---------2-----------------------#2020-01-15">https://itnext.io/terminal-console-user-interface-in-net-core-4e978f1225b?source=collection_archive---------2-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们并不总是使用桌面环境来与应用程序交互。有时(或者可能总是)我们进入计算机/服务器并在终端内执行我们的命令。</p><p id="18ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于终端/控制台的GUI不像一个丰富的桌面/移动应用程序那样有图像和复杂的组件，它都是关于字符的。我在大学的时候，对于系统编程语言课程，我们要用<a class="ae ko" href="https://en.wikipedia.org/wiki/X86_assembly_language" rel="noopener ugc nofollow" target="_blank"> x86汇编语言</a>写一个类似<a class="ae ko" href="https://en.wikipedia.org/wiki/Norton_Commander" rel="noopener ugc nofollow" target="_blank">诺顿指挥官</a> (NC)的应用。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/1b306f33a3891701f4e81c127589ef5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_4HEd4WynnHY3uIJprf8A.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">Ali Commander(AC)——我的NC，我几年前用x86汇编写的</figcaption></figure><p id="57b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那时，编写基于控制台的应用程序对我来说只是将ASCII字符打印到屏幕上，<strong class="js iu">但它不仅仅是字符。</strong></p><p id="e0a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将介绍:</p><ol class=""><li id="1d89" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">基于终端/控制台的应用程序如何工作？</li><li id="710f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">介绍<a class="ae ko" href="https://github.com/migueldeicaza/gui.cs" rel="noopener ugc nofollow" target="_blank">图形用户界面。CS </a>，一个简单的UI工具包。网，。网芯和Mono。</li><li id="1e30" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">用Gui.cs实现项目</li></ol><p id="4482" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">T13】</strong></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="5b5e" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">基于终端/控制台的应用程序是如何工作的？</h2><p id="7902" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">终端显示有两种模式，<strong class="js iu">帧缓冲</strong>和<strong class="js iu">文本模式</strong>:</p><p id="2ef4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">文本模式</strong>:是一种终端显示模式，内容在显示器上用<a class="ae ko" href="https://en.wikipedia.org/wiki/Character_(computing)" rel="noopener ugc nofollow" target="_blank">字符</a>而不是单个<a class="ae ko" href="https://en.wikipedia.org/wiki/Pixel" rel="noopener ugc nofollow" target="_blank">像素</a>来表示。从字面上看，屏幕将被认为是一个统一的<a class="ae ko" href="https://en.wikipedia.org/wiki/Rectangular_grid" rel="noopener ugc nofollow" target="_blank">矩形网格</a>的字符单元。在文本模式下，应用程序可以使用字符在终端上显示它们的用户界面。例如，IBM PC代码页437提供了几个字符，比如框形绘制字符(像边、线等)，许多应用程序用它们来绘制UI。例如，在这里(或者在Ali Commander中),我使用盒形绘制字符来绘制我的UI。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="c36b" class="mb mc it na b gy ne nf l ng nh">╔══════════════════════════════════════════╗<br/>╟──────────────────────────────────────────╢<br/>║ Progress                          25%    ║<br/>║ ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ ║<br/>║                                          ║<br/>║ ┌────┐  ┌────────┐                       ║ <br/>║ │ OK │  │ Cancel │                       ║<br/>║ ╘════╛  ╘════════╛                       ║   <br/>╚══════════════════════════════════════════╝</span></pre><p id="b73e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://www.kernel.org/doc/Documentation/fb/framebuffer.txt" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">frame buffer</strong></a><strong class="js iu">:</strong>在显示器上显示图形的图形硬件无关的抽象层。不像文本模式，帧缓冲区使用图形，像素。帧缓冲区在Linux终端上使用。以下是一个帧缓冲模式的示例:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/4a40b7dbec4aa22cc6794707b63a03e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sw05eF5suPs3lTati7WB-w.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">奶牛计算博客的Framebuffer</figcaption></figure><p id="c07d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">写一个基于控制台的GUI是困难的，因为你需要记住很多东西，物体的位置，像素，字符，知道什么时候重新绘制，最糟糕的是图层。想象一下，你需要打开一个提示来请求用户输入，你需要在你的应用程序上覆盖提示对话框，这太疯狂了！</p><p id="bcce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而且不是一切都是绝对的！你需要知道终端/控制台的高度和宽度。默认的(文本模式)MS-DOS显示是80列25行。这很容易，你可以保持一切固定，但现在终端模拟器和控制台的大小可以变化，用户可以自定义它们。</p><p id="49f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了所有的困难之外，要创建一个基于控制台的应用程序，你需要计算所有的百分比，以使其响应迅速！</p><p id="240e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们知道了一些关于基于终端/控制台的应用程序的信息，是时候写一些代码了。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="c9c0" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">的终端用户界面工具包。网</h2><p id="1f5f" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">Gui.cs是一个ui工具包，用于使用. NET创建令人惊叹的基于控制台的应用程序。他是这样介绍它的工具的:</p><blockquote class="nj nk nl"><p id="e8c0" class="jq jr lt js b jt ju jv jw jx jy jz ka nm kc kd ke nn kg kh ki no kk kl km kn im bi translated">这是我在2007年为<a class="ae ko" href="https://github.com/mono/mono-curses" rel="noopener ugc nofollow" target="_blank"> mono-curses </a>编写的<a class="ae ko" href="http://tirania.org/blog/archive/2007/Apr-16.html" rel="noopener ugc nofollow" target="_blank"> gui.cs </a>的更新版本。</p><p id="80d7" class="jq jr lt js b jt ju jv jw jx jy jz ka nm kc kd ke nn kg kh ki no kk kl km kn im bi translated">最初的gui.cs是一个ui工具包，放在一个文件中，与curses绑定在一起。这个版本尝试与控制台无关，而不是有一个容器/小部件模型，只使用视图(可以包含子视图),并更改渲染模型以依赖损坏区域，而不是用细节来加重每个视图的负担。</p><p id="42cc" class="jq jr lt js b jt ju jv jw jx jy jz ka nm kc kd ke nn kg kh ki no kk kl km kn im bi translated">—米盖尔·德·伊卡萨<a class="ae ko" href="https://github.com/migueldeicaza/gui.cs" rel="noopener ugc nofollow" target="_blank">https://github.com/migueldeicaza/gui.cs</a></p></blockquote><p id="428e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">功能:</strong></p><ul class=""><li id="8fca" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn np ll lm ln bi translated">丰富的组件集，如按钮、标签、文本输入、文本视图、时间字段、单选按钮、复选框、对话框、窗口、菜单、列表视图、框架、进度条、滚动条、滚动视图和十六进制编辑器/查看器。</li><li id="0af4" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">良好的<a class="ae ko" href="https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui.html" rel="noopener ugc nofollow" target="_blank"> API文档</a></li><li id="e633" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated"><a class="ae ko" href="https://www.nuget.org/packages/Terminal.Gui" rel="noopener ugc nofollow" target="_blank"> NuGet包</a></li><li id="7777" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">支架<em class="lt">。网</em>，<em class="lt">。网芯</em>和<em class="lt">单声道</em>。</li><li id="9c25" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">可在Windows、Linux和MacOS上运行。</li><li id="37ce" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">鼠标和键盘输入</li></ul><p id="74ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">工具包库设计得很好，也很容易使用，但在这一切之前，我们需要学习一些信息和概念。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h2 id="ab88" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">建筑和设计</h2><p id="ddd2" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><strong class="js iu"> Gui.cs </strong>是一个基于文本的工具包，但是它以类似于图形工具包的方式提供Gui。屏幕上的每个可见元素都被实现为<a class="ae ko" href="https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.View.html" rel="noopener ugc nofollow" target="_blank">视图</a>。视图是独立的对象，负责显示它们自己。它们可以接收键盘和鼠标输入，并参与聚焦机制。每个视图可以包含零个或多个子视图，称为子视图。</p><h2 id="21a5" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated"><strong class="ak"> -布局</strong></h2><p id="3528" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">cs支持两种不同的布局系统，绝对的和计算的。当你想通过固定点(x，y)手动控制视图的位置时，使用绝对系统<strong class="js iu"> </strong>。计算布局系统提供了一些附加功能，如自动居中、尺寸扩展和一些其他功能。</p><h2 id="0e43" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">-顶层视图</h2><p id="b321" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><a class="ae ko" href="https://migueldeicaza.github.io/gui.cs/api/Terminal.Gui/Terminal.Gui.Toplevel.html" rel="noopener ugc nofollow" target="_blank">顶层视图没有可见的用户界面元素，占据了部分屏幕。</a></p><h2 id="892d" class="mb mc it bd md me mf dn mg mh mi dp mj kb mk ml mm kf mn mo mp kj mq mr ms mt bi translated">-线程</h2><p id="b5bb" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">Gui.cs不是线程安全的，但是它有一个变通方法可以让你的应用程序线程安全。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="7603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">学习一个新的框架、工具或库的最好方式(当然是在阅读文档之后)是使用它。</p><p id="e275" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单的聊天应用程序可以向在线的每个人广播消息。用户可以看到在线用户。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5b730bfbed92231022c5bdb64e1ce241.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*W1Tew68Q_3iOaVA-cV2xlw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">登录用户界面</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3aeb8b48cd6f26a28b0ca47f070e18b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Cpz1TiXPVX0mTgpib7v9sg.png"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><ol class=""><li id="016c" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">创建新的控制台项目</li></ol><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="088f" class="mb mc it na b gy ne nf l ng nh">dotnet new console -o RetroChat</span></pre><p id="a71c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.添加<strong class="js iu">端子。Gui </strong>包给项目</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="2ff9" class="mb mc it na b gy ne nf l ng nh">dotnet add package Terminal.Gui</span></pre><p id="517e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.用您喜欢的编辑器或IDE打开项目</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="eaa1" class="mb mc it na b gy ne nf l ng nh">code .</span></pre><p id="a88d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.在<code class="fe ns nt nu na b">Prgram.cs</code>内，将内容替换为:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4ed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您需要通过调用<code class="fe ns nt nu na b">Application.Init</code>来初始化控制台应用程序。为了创建UI，我们需要获得一个顶级对象。这可以通过致电<code class="fe ns nt nu na b">Application.Top</code>物业来完成。</p><p id="196d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RetroChat应用程序需要一个窗口，所以我们创建了一个新的<code class="fe ns nt nu na b">Window</code>对象。标题是“RetroChat”，它将<strong class="js iu">定位</strong>到<strong class="js iu"> 0，1 </strong>上，借助<code class="fe ns nt nu na b">Dim.Fill</code>方法，它的宽度和高度将充满屏幕。</p><p id="501f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 0，1 </strong>是什么意思？它们是x轴和y轴。它们从左上角开始，也就是0，0。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/465a1690cc551a267e3a343a4bf24448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*4vYeLLGkRIphgjFYKoIJkw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">x、y轴，从左上角开始</figcaption></figure><p id="6c8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你只是运行应用程序，你会看到一个蓝色的空屏幕。是时候创建第一个真正的UI了。您可以在<strong class="js iu"> Program.cs、</strong>中编写所有代码，但是为了清楚起见，我为应用程序中的不同视图创建了不同的文件。为了设计和实现登录窗口，我创建了一个不同的类。</p><p id="df91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们的用户界面草图:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5b730bfbed92231022c5bdb64e1ce241.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*W1Tew68Q_3iOaVA-cV2xlw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">登录用户界面</figcaption></figure><p id="c237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它需要一个窗口、两个文本字段、两个标签和两个按钮。让我们创建一个名为<code class="fe ns nt nu na b">LoginWindow</code>的类，并用下面的内容填充它:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="10ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我创建了<code class="fe ns nt nu na b">LoginWindow</code>类，它继承了<strong class="js iu">窗口的</strong>类。所以我们至少需要调用窗口类的一个构造函数。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="9530" class="mb mc it na b gy ne nf l ng nh">base("Login", 5)// Title and Margin</span></pre><p id="ab9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于窗口需要两个按钮，我将两个动作定义为事件，<strong class="js iu"> OnExit </strong>和<strong class="js iu"> OnLogin </strong>。为了知道窗口的父窗口，我还定义了一个构造函数参数<strong class="js iu"> parent </strong>。</p><p id="e0a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们需要告诉哪里(位置)和如何(宽度和高度)窗口应该出现。有两个类Dim和Pos对在Gui.cs中创建UI有很大的帮助。</p><p id="2506" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我需要打开登录窗口，在屏幕中央，所以我定义了<code class="fe ns nt nu na b">X = Pos.Center()</code>。它计算中心并设置值，然后我需要窗口是屏幕的50%，我可以设置它<code class="fe ns nt nu na b">Width = Dim.Percent(50)</code>。</p><p id="ea7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Gui.cs对每个控件都有一个类，所以很容易创建它们的不同实例。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="14eb" class="mb mc it na b gy ne nf l ng nh">var nameLabel = new Label(0, 0, "Nickname");<br/>var nameText = new TextField("")<br/>{<br/> X = Pos.Left(nameLabel),<br/> Y = Pos.Top(nameLabel) + 1,<br/> Width = Dim.Fill()<br/>};<br/>Add(nameLabel);<br/>Add(nameText);</span></pre><ul class=""><li id="ec9c" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn np ll lm ln bi translated"><strong class="js iu">名称标签</strong>位于0，0，标题为“昵称”。</li><li id="9753" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated"><strong class="js iu">名称文本</strong>应位于<strong class="js iu">名称标签下方。</strong></li><li id="aecd" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">我们希望文本框的宽度填充一行。</li><li id="9ca0" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">将每个视图添加到容器中很重要，这可以通过<code class="fe ns nt nu na b">Add</code>方法来完成。在我们的例子中，<strong class="js iu"> LoginWindow </strong>继承了<strong class="js iu"> Window </strong>，一个窗口也是一个视图，这就是为什么我们可以访问Add方法。</li></ul><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="0c2b" class="mb mc it na b gy ne nf l ng nh">var loginButton = new Button("Login", true) // Text, default button?<br/>{<br/> X = Pos.Left(birthText),<br/> Y = Pos.Top(birthText) + 1<br/>};</span><span id="6f36" class="mb mc it na b gy ny nf l ng nh">var exitButton = new Button("Exit")<br/>{<br/> X = Pos.Right(loginButton) + 5,<br/> Y = Pos.Top(loginButton)<br/>};</span><span id="b4f5" class="mb mc it na b gy ny nf l ng nh">// add them to the container<br/>Add(exitButton);<br/>Add(loginButton);</span></pre><p id="af87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建按钮与创建其他控件一样，构造函数需要两个参数:文本和一个布尔值，以确定按钮是否被默认选中。在我们的例子中，按钮应该彼此相邻，所以它们有相同的顶部，但不同的高度。这里我使用了<code class="fe ns nt nu na b">Pos.Right</code>将退出按钮放在登录按钮旁边。</p><p id="c9e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个没有动作的按钮是没有意义的，我们需要在它们被点击的时候设置一个动作。每个按钮都有一个名为<code class="fe ns nt nu na b">OnClicked</code>的属性，可以如下设置:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="7f34" class="mb mc it na b gy ne nf l ng nh">exitButton.Clicked = () =&gt;<br/>{<br/> OnExit?.Invoke();<br/> Close();<br/>};</span></pre><p id="5790" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> LoginWindow </strong>班。我定义了两个动作作为窗口的事件。因此，当用户点击<strong class="js iu">退出按钮</strong>时，它将调用<code class="fe ns nt nu na b">OnExit</code>动作。</p><p id="ec20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">登录比退出按钮有更多的逻辑，比如验证。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="1813" class="mb mc it na b gy ne nf l ng nh">loginButton.Clicked = () =&gt;<br/>{<br/> if (nameText.Text.ToString().TrimStart().Length == 0)<br/> {<br/>  MessageBox.ErrorQuery(25, 8, "Error", "Name cannot be empty.", "Ok");<br/>  return;<br/> }</span><span id="fb94" class="mb mc it na b gy ny nf l ng nh">var isDateValid = DateTime.TryParse(birthText.Text.ToString(), out DateTime birthDate);</span><span id="3632" class="mb mc it na b gy ny nf l ng nh">if (string.IsNullOrEmpty(birthText.Text.ToString()) || !isDateValid)<br/> {<br/>  MessageBox.ErrorQuery(25, 8, "Error", "Date is required\nor is invalid.", "Ok");<br/>  return;<br/> }</span><span id="54db" class="mb mc it na b gy ny nf l ng nh">OnLogin?.Invoke((name: nameText.Text.ToString(), birthday: birthDate));</span><span id="6b26" class="mb mc it na b gy ny nf l ng nh">Close();<br/>};</span></pre><p id="a1e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要访问每个文本字段值，可以很容易地使用一个名为text的getter。在验证过程中，如果出现任何错误，我们需要向用户显示一条消息。幸运的是，Gui.cs为它提供了一个类。用<strong class="js iu">消息框。查询</strong>或<strong class="js iu">消息框。错误查询</strong>你可以显示消息对话框。这里您可以看到我是如何向用户显示错误的。</p><p id="06bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还为LoginWindow定义了一个名为Close的特殊方法:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="3292" class="mb mc it na b gy ne nf l ng nh">public void Close()<br/>{<br/> _parent?.Remove(this);<br/>}</span></pre><p id="7e93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你只是在另一个窗口上打开一个窗口，它们会相互重叠。在RetroChat中，登录对话框只出现在应用程序的开始，登录后，它应该是关闭的。为了在屏幕上隐藏它，我需要请求父视图将它从显示中移除。</p><p id="4737" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们回到Program.cs来显示登录窗口，只需将main方法代码更改为下面的代码。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="74c8" class="mb mc it na b gy ne nf l ng nh">Application.Init();<br/>var top = Application.Top;</span><span id="a704" class="mb mc it na b gy ny nf l ng nh">var mainWindow = new Window("Retro Chat")<br/>{<br/> X = 0,<br/> Y = 1, // Leave one row for the toplevel menu</span><span id="7faf" class="mb mc it na b gy ny nf l ng nh">// By using Dim.Fill(), it will automatically resize without manual intervention<br/> Width = Dim.Fill(),<br/> Height = Dim.Fill()<br/>};</span><span id="2a25" class="mb mc it na b gy ny nf l ng nh">// login window will be appear on the center screen<br/>var loginWindow = new LoginWindow(mainWindow);<br/>mainWindow.Add(loginWindow);</span><span id="7d1d" class="mb mc it na b gy ny nf l ng nh">Application.Run(mainWindow);</span></pre><p id="86d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你所看到的，这就像给一个窗口添加控件一样，我们只是把我们的窗口添加到一个窗口中。你可以看到对话框和窗口是如何出现在窗口上的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nz"><img src="../Images/0dd4df05e5db74e21120c0b6b1ed17f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*POuTSxskEpuE5MlVgUl8dg.gif"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">示例运行时</figcaption></figure><p id="3094" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">聊天界面的时间到了:</strong></p><p id="d19d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从菜单栏开始，它应该有两个菜单:</p><ol class=""><li id="b887" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">文件-&gt;退出</li><li id="0a0b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">帮助-&gt;关于</li></ol><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e71c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">MenuBar、MenuBarItem和MenuItem可以轻松创建菜单:</p><ul class=""><li id="7249" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn np ll lm ln bi translated">菜单栏是主顶部菜单。</li><li id="3c77" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">MenuBarItem是一级菜单项，如文件、帮助。</li><li id="8d8f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">MenuItem是子项目，例如Exit和About。</li><li id="3ad4" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn np ll lm ln bi translated">每个菜单都以下划线开始，这是为了快捷，例如通过按<strong class="js iu"> Alt+F，</strong>用户可以访问文件菜单。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oa"><img src="../Images/20470bc91b1774da3159077687c17deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnXlKcQcGP9TRTE3QpQdrA.png"/></div></div></figure><p id="dee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在应用程序中添加了菜单栏和登录窗口。正如你所看到的，用户界面有些烦人；我们还没有登录，但是用户可以看到菜单。</p><p id="d1f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在程序类上进行以下更改:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="de6f" class="mb mc it na b gy ne nf l ng nh">// login window will be appear on the center screen<br/>var loginWindow = new LoginWindow(null);<br/>loginWindow.OnExit = () =&gt; Application.RequestStop();</span><span id="1d98" class="mb mc it na b gy ny nf l ng nh">loginWindow.OnLogin = (loginData) =&gt;<br/>{<br/> mainWindow.Add(menu);<br/> Application.Run(top);<br/>};</span><span id="e9cf" class="mb mc it na b gy ny nf l ng nh">top.Add(mainWindow);</span><span id="44df" class="mb mc it na b gy ny nf l ng nh">// run login-window-first<br/>Application.Run(loginWindow);</span></pre><p id="4b57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在顶层视图中添加了主窗口，我们首先通过<code class="fe ns nt nu na b">loginWindow</code>运行应用程序。</p><p id="2f71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在登录窗口中，将关闭方法更改为:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="14f9" class="mb mc it na b gy ne nf l ng nh">public void Close()<br/>{<br/> Application.RequestStop();<br/> _parent?.Remove(this);<br/>}</span></pre><p id="52a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们称之为<code class="fe ns nt nu na b">Application.RequestStop</code>，这个方法会请求终止最顶层的对象。在我们的例子中，最顶层的对象是<code class="fe ns nt nu na b">login-window</code>，紧接着，在登录方法中，我们用另一个视图运行应用程序。</p><p id="17f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果将如下所示:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ob"><img src="../Images/fb2c85aa309708a08b0a47bc30a066a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MmgfdGKBYL6bye-JhFiVpg.gif"/></div></div></figure><p id="3ddd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经学习了如何添加控件，如何定位控件，如何关闭窗口以及如何返回到上一个视图。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3aeb8b48cd6f26a28b0ca47f070e18b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Cpz1TiXPVX0mTgpib7v9sg.png"/></div></figure><p id="4916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加了菜单栏，让我们添加其他控件。</p><p id="c066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要一个聊天区的盒子。我们可以使用框架视图，它的工作方式类似于分组框。我们还需要一个列表来显示消息。</p><ol class=""><li id="7910" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">创建框架视图</li><li id="d42e" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">创建列表视图</li><li id="00bb" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">将ListView添加到框架视图</li><li id="5e3f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">将框架视图添加到主窗口</li></ol><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="907c" class="mb mc it na b gy ne nf l ng nh">#region chat-view<br/>var chatViewFrame = new FrameView("Chats")<br/>{<br/> X = 0,<br/> Y = 1,<br/> Width = Dim.Percent(75),<br/> Height = Dim.Percent(80),<br/>};</span><span id="1f90" class="mb mc it na b gy ny nf l ng nh">var chatView = new ListView<br/>{<br/> X = 0,<br/> Y = 0,<br/> Width = Dim.Fill(),<br/> Height = Dim.Fill(),<br/>};<br/>chatViewFrame.Add(chatView);<br/>mainWindow.Add(chatViewFrame);<br/>#endregion</span></pre><p id="54f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在线用户列表也与消息相同:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="fdad" class="mb mc it na b gy ne nf l ng nh">#region online-user-list<br/>var userListFrame = new FrameView("Online Users")<br/>{<br/> X = Pos.Right(chatViewFrame),<br/> Y = 1,<br/> Width = Dim.Fill(),<br/> Height = Dim.Fill()<br/>};<br/>var userList = new ListView(_users)<br/>{<br/> Width = Dim.Fill(),<br/> Height = Dim.Fill()<br/>};<br/>userListFrame.Add(userList);<br/>mainWindow.Add(userListFrame);<br/>#endregion</span></pre><p id="4da4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Pos </strong>和<strong class="js iu"> Dim </strong>类有帮助；例如，我只提到了<strong class="js iu">用户列表框</strong>位于<strong class="js iu">聊天视图框</strong>的右边，它应该填满屏幕的其余部分。Dim和Pos计算了所有的宽度、高度和位置。</p><p id="1763" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">聊天栏有点不同；它包括一个<strong class="js iu">按钮</strong>和一个<strong class="js iu">文本框:</strong></p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="0f95" class="mb mc it na b gy ne nf l ng nh">#region chat-bar<br/>var chatBar = new FrameView(null)<br/>{<br/> X = 0,<br/> Y = Pos.Bottom(chatViewFrame),<br/> Width = chatViewFrame.Width,<br/> Height = Dim.Fill()<br/>};</span><span id="9e45" class="mb mc it na b gy ny nf l ng nh">var chatMessage = new TextField("")<br/>{<br/> X = 0,<br/> Y = 0,<br/> Width = Dim.Percent(75),<br/> Height = Dim.Fill()<br/>};</span><span id="dc23" class="mb mc it na b gy ny nf l ng nh">var sendButton = new Button("Send", true)<br/>{<br/> X = Pos.Right(chatMessage),<br/> Y = 0,<br/> Width = Dim.Fill(),<br/> Height = Dim.Fill()<br/>};</span><span id="d6d3" class="mb mc it na b gy ny nf l ng nh">sendButton.Clicked = () =&gt;<br/>{<br/> Application.MainLoop.Invoke(() =&gt;<br/> {<br/>  _messages.Add($"{_username}: {chatMessage.Text}");<br/>  chatView.SetSource(_messages);<br/>  chatMessage.Text = "";<br/> });<br/>};</span><span id="0aaa" class="mb mc it na b gy ny nf l ng nh">chatBar.Add(chatMessage);<br/>chatBar.Add(sendButton);<br/>mainWindow.Add(chatBar);<br/>#endregion</span></pre><p id="d781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相同的概念，但检查<strong class="js iu">发送按钮。点击</strong>代码:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="c740" class="mb mc it na b gy ne nf l ng nh">sendButton.Clicked = () =&gt;<br/>{<br/> Application.MainLoop.Invoke(() =&gt;<br/> {<br/>  _messages.Add($"{_username}: {chatMessage.Text}");<br/>  chatView.SetSource(_messages);<br/>  chatMessage.Text = "";<br/> });<br/>};</span></pre><p id="61be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我已经提到的，终端。默认情况下，GUI不是线程安全的。如果你要在UI中改变一些从不同线程调用的东西，你需要像上面一样把它包装在一个invoke方法中。</p><p id="6db9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让事情变得更真实，我创建了一个虚拟类，在另一个线程中运行，向聊天室添加新用户。</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="31f3" class="mb mc it na b gy ne nf l ng nh">public static class DummyChat<br/>{<br/> public static Action&lt;(string name, DateTime birthday)&gt; OnUserAdded;<br/> private static readonly object _mutex = new object();<br/> private static Thread _main;</span><span id="c2ad" class="mb mc it na b gy ny nf l ng nh">public static void StartSimulation()<br/> {<br/>  lock (_mutex)<br/>  {<br/>   if (_main == null)<br/>   {<br/>    _main = new Thread(new ThreadStart(Simulate));<br/>    _main.Start();<br/>   }<br/>  }<br/> }</span><span id="73dd" class="mb mc it na b gy ny nf l ng nh">private static void Simulate()<br/> {<br/>  int counter = 0;<br/>  while (++counter &lt;= 10)<br/>  {<br/>   var name = $"User {counter}";<br/>   OnUserAdded?.Invoke((name, DateTime.Now));<br/>   Thread.Sleep(2000);<br/>  }</span><span id="afd8" class="mb mc it na b gy ny nf l ng nh">}<br/>}</span></pre><p id="2772" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Program.cs内部，我将调用<strong class="js iu"> StartSimulation </strong>在后台运行一个线程:</p><pre class="kq kr ks kt gt mz na nb nc aw nd bi"><span id="adda" class="mb mc it na b gy ne nf l ng nh">var loginWindow = new LoginWindow(null)<br/>{<br/> OnExit = Application.RequestStop,</span><span id="d1aa" class="mb mc it na b gy ny nf l ng nh">OnLogin = (loginData) =&gt;<br/> {<br/>  // for thread-safety<br/>  Application.MainLoop.Invoke(() =&gt;<br/>  {<br/>   _users.Add(loginData.name);<br/>   _username = loginData.name;<br/>   userList.SetSource(_users);<br/>  });<br/>  DummyChat.StartSimulation();<br/>  Application.Run(top);<br/> }<br/>};</span><span id="0a6e" class="mb mc it na b gy ny nf l ng nh">top.Add(mainWindow);</span><span id="1a80" class="mb mc it na b gy ny nf l ng nh">DummyChat.OnUserAdded = (loginData) =&gt;<br/>{<br/> Application.MainLoop.Invoke(() =&gt;<br/> {<br/>  _users.Add(loginData.name);<br/>  userList.SetSource(_users);<br/> });<br/>};</span></pre><p id="75e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">登录后，模拟将开始，每2秒钟，它将向应用程序添加一个新用户。经过这些更改后，program.cs应该如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oc"><img src="../Images/d825c7602d1cdfaa5eef25b041b8fb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BNfXmoZicdKnYgvTslzvOA.gif"/></div></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="4998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我试图涵盖一些基础知识，比如创建控件、创建窗口、嵌套布局和多线程。<a class="ae ko" href="https://github.com/migueldeicaza/gui.cs" rel="noopener ugc nofollow" target="_blank">终端。Gui </a>是一个很棒的工具包，它有更多的特性。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="8610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在我的<a class="ae ko" href="https://github.com/0x414c49/gui-cs-chat-sample" rel="noopener ugc nofollow" target="_blank">存储库</a>上下载、派生、克隆示例项目。</p></div></div>    
</body>
</html>