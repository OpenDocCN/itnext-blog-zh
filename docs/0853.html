<html>
<head>
<title>Angular patterns 1: modules organisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度模式1:模块组织</h1>
<blockquote>原文：<a href="https://itnext.io/angular-patterns-1-modules-organisation-d3b2224ec4cf?source=collection_archive---------3-----------------------#2018-06-09">https://itnext.io/angular-patterns-1-modules-organisation-d3b2224ec4cf?source=collection_archive---------3-----------------------#2018-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a7bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在现实生活的项目中与Angular一起工作，我开发了自己的一套模式，用于在大型复杂的应用程序上组织可伸缩的Angular代码。我认为分享它们会很有用。</p><p id="65e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试着把它们分成小文章，尽可能简洁明了。</p><p id="e4f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该系列的其他文章:</p><ul class=""><li id="cd8a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/angular-patterns-2-how-to-write-seriously-reusable-components-96be16568abc"> 2:如何认真编写可复用组件</a></li><li id="5ed0" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://medium.com/@adrdilauro/angular-patterns-3-flexible-and-scalable-design-of-complex-pages-c35f327ac50" rel="noopener"> 3:复杂页面的灵活可扩展设计</a></li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/cde381e283f13a4d1934f12fc6e58113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZuSl1tncCpePR_VJOH5rQ.png"/></div></div></figure><p id="c20e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">懒加载模块</strong></p><p id="406a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，我总是把我正在做的项目分成一组页面，这些页面分组在不同的惰性加载模块中。</p><p id="0dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这种心理结构来自于我的Ruby on Rails背景，在不同的控制器中有类似的动作划分。这两个概念非常不同，但相似之处依然存在，因为将你必须做的事情归类到一个高层次的项目列表中总是有益的，每个项目包含一个子列表。</p><p id="bc01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了决定你的惰性加载模块的结构，你要做的第一件事就是看需求，并且清楚地写下在用户旅程中被访问的所有不同的URL。Url = page =这种情况下，如果用户刷新浏览器，他会返回到他正在查看的那个HTML。</p><p id="dc2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你有了完整的页面列表，你需要将它们分组到不同的惰性加载模块中，<strong class="jp ir">试图优化它们之间的共享依赖关系</strong>。共享依赖=放在样板文件中的可重用组件。</p><blockquote class="lm ln lo"><p id="e913" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">如果两个页面依赖于一组非常相似的可重用组件，那么将它们放在同一个惰性加载模块中。</p></blockquote><p id="0a24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以这种方式对页面进行分组对性能非常有利，因为您可以最大限度地减少依赖于同一个可重用组件的延迟加载模块的数量。</p><p id="580f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设页面P1依赖于可重用组件A、B、C，页面P2依赖于A、B、d。如果你把P1和P2放在两个不同的延迟加载模块中，他们每个人都有A和B的副本，因此，对于每个人来说，最终的包可能比它可能的要大。</p><p id="e94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，不要对此疑神疑鬼，有些情况下，您无法避免一个组件在两个不同的模块中重复。您还必须考虑到，像WebPack这样的工具在优化包方面变得越来越复杂，所以您总是可以依赖用于生产的比用于开发的更轻的包。所以，这只是一个很好的经验法则，如果你从一开始就开始优化，当应用程序增长时，维护起来会更容易。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="c500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">页面组件和可重用组件</strong></p><p id="409b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我总是倾向于重用任何组件，并且只使用根组件来获取正确的可重用组件并将它们放在HTML中。这样做了一段时间后，我发现我所有的项目都假设了一个精确的结构:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="d08d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看相应的文件夹结构</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="f164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件夹“p_edit”中的文件“component.ts”是我声明页面/posts/:id/edit的根组件的地方。这种组件的HTML只不过是我在另一个文件夹中定义的必要的可重用组件的捆绑包。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="5de1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在惰性加载模块的路由中，我将子路径“/:id/edit”指向正确的根组件:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，这是惰性加载模块的样子(包括上面路由的导入)</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该模块确切地声明了两个根页面组件，并且不导出任何内容(因为编写它的目的只是为了延迟加载)。</p><p id="bbd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SharedModule是您应该随处导入的模块，它包含您想要全局使用的公共组件和指令。在官方文档中有大量关于共享模块模式的文档。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="c4ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">命名法</strong></p><p id="aad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您已经注意到I命名空间文件夹和组件/模块名称。这非常有助于保持事物的条理和清晰，也避免了重复同一个名字的风险</p><ul class=""><li id="2246" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">ll_…代表“懒装”</li><li id="41a2" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">p_…代表“页面”</li><li id="5155" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">f_…代表“特性”</li></ul><p id="838a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在组件/模块名称中，相同的命名空间一个接一个地嵌套，如下所示:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以清楚地看到，这是“编辑”页面的根组件，包含在延迟加载的模块“帖子”中。</p><p id="98e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，我喜欢的另一件事是避免为每个文件名重复命名空间。我只是将每个文件简单地称为“component.ts”或“component.html”，然后您可以通过查看其内容的名称或其在文件夹结构中的位置来推断它是什么组件。这有助于保持文件夹结构的可读性。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="0fb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">可重复使用的组件</strong></p><p id="f6f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在官方教程中，包含可在整个应用程序中重用的组件包的模块被称为“功能模块”:这就是为什么我习惯于将所有可重用的组件放在一个名为“功能”的文件夹中，并以字母“f_…”开头命名它们。</p><p id="8d4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我个人喜欢使用可重用组件的方式比文档中建议的方式更“极端”。</p><p id="9f4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">围绕文档中所谓的“功能模块”的常见模式是将一堆组件、指令和管道放在一起，这些组件、指令和管道可以作为工具在其他地方使用。一种可重用的工具库。这种“特性模块”的例子有RouterModule、CommonModule、RxJs以及大部分可以在Angular环境中使用的东西。</p><p id="4b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些模块的工作方式与Ruby on Rails中的帮助器非常相似(当然不同之处在于它们是分开的，并且您可以准确地包含您需要的帮助器)。我从现在开始将这种类型的模块称为“<strong class="jp ir">助手模块</strong>；我通常把这些模块放在它们自己的名为“helpers”的文件夹中，并以字母“h_…”作为前缀。</p><blockquote class="lm ln lo"><p id="0dce" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">助手模块=包含大量可重用工具(指令、组件、管道)的模块</p></blockquote><p id="d9b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，虽然这种捆绑助手模块的方式很有用，但当我想要实现真正的、广泛的可重用性时，我仍然发现这是不够的。</p><p id="fd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我为特定页面开发新组件时，我都希望能够(1)定义组件所依赖的输入和输出的通用列表，(2)将它打包成允许我在任何需要的地方无缝重用它的东西。</p><p id="962f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了做到这一点，我需要定义一个只导出一个组件的模块，这就是我个人现在更喜欢称之为“<strong class="jp ir">特性模块</strong>”:一个包含一个特性的模块。当我需要使用我的组件时，我在相应的惰性加载模块中导入该模块，并从页面的根组件(或其子组件)中调用该组件。</p><blockquote class="lm ln lo"><p id="a649" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">特征模块=仅包含一个可重用组件(特征)的模块</p></blockquote><p id="2852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法与包含几个工具的助手模块之间存在一些概念上的差异:</p><p id="4f83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">辅助模块:</strong></p><ul class=""><li id="4f8f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">一个模块包含几个组件和指令</li><li id="0c60" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">潜在地，这样的组件和指令可以在我的特定应用程序的上下文之外使用</li><li id="784f" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">通常，大多数组件/指令都是导出的</li><li id="e21a" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">导出的组件通常以某种方式相互关联，但可以独立使用，所以每个组件都有自己的CSS范围</li></ul><p id="010e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">功能模块:</strong></p><ul class=""><li id="c926" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">一个模块对应一个可重用组件</li><li id="6703" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">该组件不太可能在我的应用程序环境之外重用</li><li id="2c5c" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">该模块只导出一个组件:内部可能需要几个子组件来构建最终的可重用组件，但是这些组件只是被声明，而不是被导出</li><li id="d9d0" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">模块代表一个特定的、独立的HTML块，它只有一个CSS文件:内部子组件没有自己的CSS</li></ul><p id="f199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好，让我们来看一个例子:在我们的应用程序中，对于一个特定的页面，我们必须开发一个属于一个相册的片段图像的垂直列表；在设计中，列表底部有一个“加号”按钮，用于添加新图像。</p><p id="ce5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">片段图像列表看起来像是我想在将来重用的东西，所以我将以下文件夹添加到我的“功能”中:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们只需要一个子组件(single_image)，但根据具体情况，可以有多个子组件。</p><p id="9b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在模块中，我声明了两个组件，但是我只导出了“公共”组件:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c61e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，只有一个CSS文件，位于根文件夹中。</p><p id="e0e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个有用的技巧是每个文件夹都有一个“index.ts”文件，这样，当您需要导入这个组件时，您就不必每次都疯狂地记住文件是如何在内部命名的。</p><p id="2b32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，一旦你开始拥有大量可重用的组件，你可能会寻找一种方法来组织它们:将几个功能组件模块捆绑在一起成为一个更大的模块可能会很好:你将拥有功能模块的模块，等等，这完全取决于你，取决于你需要实现什么。</p><blockquote class="lm ln lo"><p id="443e" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">我的想法是，不管你打算如何有效地使用或组织你的组件，最好是找到最小的独立部件，并分别包装。</p></blockquote></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="030b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结:我在大型项目中常用的文件夹结构</strong></p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ma mb l"/></div></figure></div></div>    
</body>
</html>