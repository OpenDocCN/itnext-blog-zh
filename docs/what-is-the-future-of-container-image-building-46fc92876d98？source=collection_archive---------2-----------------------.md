# 集装箱形象建设的前景如何？

> 原文：<https://itnext.io/what-is-the-future-of-container-image-building-46fc92876d98?source=collection_archive---------2----------------------->

![](img/4c2bf69b043ea5a26272e07481ac3c78.png)

发布在 [Giant Swarm 的博客](https://blog.giantswarm.io/what-is-the-future-of-container-image-building/)上的原始文章

从某种意义上说，自从 Docker 1.0 在 2014 年夏天发布以来，似乎没有任何时间，但从另一种意义上说，却感觉像过了一辈子。在接下来的 4 到 5 年中，云原生范式已经发展成为一个全面的行业，大大小小的企业都将自己的生存寄托在云原生带来的所谓好处上。

结出这一果实的种子是 Docker 对容器抽象的推广，它为开发人员提供了一种将应用程序定义为自给自足、不可变的包(容器映像)的机制。然而，尽管云原生技术领域的发展速度惊人，但自 2014 年夏天以来，我们定义容器映像的方式，以及我们将它们构建成可用工件的方式，却变化甚微。随着容器技术的发展和成熟，容器映像构建过程中的缺陷和限制慢慢暴露出来，这导致了云原生社区中的一些挫折。

在过去的一两年里，不同的项目涌现出来，试图解决一些或所有这些缺陷。在这一系列名为“容器图像构建的艺术状态”的文章中，我们将关注其中的一些项目和工具，看看它们是如何规避已知问题的。

然而，在我们这样做之前，我们首先必须了解容器映像构建的基础，以及我们试图克服的缺陷。

# Dockerfiles 和 API 构建端点

历史上，容器映像是在 docker 文件中定义的，使用声明性指令集来生成文件系统内容和元数据，以通知容器运行时引擎如何运行派生的容器。然后使用 Docker 引擎的 API 端点构建容器映像，Docker 引擎顺序执行每个 Dockerfile 指令来创建内容，或者记录与正在构建的映像相关的元数据。构建端点总是使用 Docker 客户机的 docker build 命令来执行。

因此，创作容器图像需要我们使用一组适当的 Dockerfile 指令及其相关参数来定义图像，然后使用 Docker 引擎 API 来构建图像。简单，这有什么错呢？

# 对 Docker 守护进程的依赖

一个常见的问题是，使用 Docker 引擎 API 构建容器映像需要使用 Docker 守护进程。Docker 守护进程包含许多功能，其中大部分与构建容器映像的任务完全无关。此外，对于它执行的许多其他功能，它需要以 root 权限运行，正如我们将在后面看到的，这带来了安全问题。如果手头的任务是制作容器映像，那么仅仅为了这个目的部署 Docker 守护进程是笨拙而低效的，并且对于 CI/CD 管道来说不是最佳的。有一种观点认为，容器映像构建体验应该是无梦的。

# 无效缓存

Docker 引擎很早就有了缓存功能。这意味着，如果从一个构建到下一个构建的 Dockerfile 指令的执行导致相同的命令被运行，或者相同的内容被添加到映像，那么将使用缓存的内容，而不是重新创建它。它大大加快了映像构建的速度，使整个过程更加高效。

不幸的是，由于构建 API 的顺序性质，一旦缓存由于内容或 Dockerfile 指令的改变而无效，Dockerfile 中的每个后续指令都将被再次执行。不管那些后续指令是否已经改变，都会发生这种情况。这意味着需要非常注意指令的顺序，以便最大限度地提高构建缓存的效率。

# 顺序执行

正如我们所说的，低效的构建缓存使用是构建过程中顺序执行 Dockerfile 指令的副作用。如果仔细考虑了指令排序，那么指令的顺序执行是不成问题的。然而，当在 API 中引入[多阶段](https://docs.docker.com/develop/develop-images/multistage-build/)构建时，构建执行的顺序性抑制了主要的潜在好处；不相关指令的并行执行。当然，这与构建所需的时间长度有关，在某些情况下，构建所需的时间可以大大减少。当在应用程序开发期间迭代映像构建时，这可能会大大延长该过程。

# 安装临时内容

通常，构建容器映像的过程依赖于或受益于临时提供的内容。换句话说，我们希望内容在构建过程中出现，但不希望它出现在最终产品中，因为这会不必要地增加图像的大小。例如，我们需要源代码来构建二进制文件，但不需要最终映像中的源代码。我们可以利用编译器[构建缓存](https://golang.org/cmd/go/#hdr-Build_and_test_caching)来加快构建，但是我们不希望缓存在映像本身中。

多阶段构建可以帮助我们解决这个问题，但是更好的解决方案是在构建过程中需要的时候临时装载内容。尽管无数[请求](https://github.com/moby/moby/issues/3156)添加该功能的变体，但它从未进入 Dockerfile 指令语法，或作为 docker build 命令的命令行参数。

# 建立秘密

有时，我们需要使用秘密来访问需要客户端验证和授权的内容。例如，我们可能需要提供一个 SSH 密钥来从 GitHub 或类似的地方克隆一个存储库，这样我们就可以利用构建中的内容。在构建过程中，可以将秘密从主机复制到映像中，但这会带来秘密仍然嵌入在映像中的风险，以便任何有权访问映像的人随后进行审查。我们甚至可能会尝试使用环境变量，但是这种方法也容易被利用。

有人提议添加一个构建特性来处理图像构建所需的秘密，但是没有一个提议能够合并到 API 中。最佳实践指南的承诺已经成为图像构建者的最佳选择。这对容器图像作者来说是一个巨大的挑战，需要使用一些新的技术作为解决方法。

# 构建权限

Docker 守护进程要求客户端要么拥有 root 访问权限，要么是`docker`组的成员，以便与 API 及其构建端点进行交互。这通常被认为是不可取的，甚至在一些对访问特权帐户有严格政策的组织中被禁止。实际上，这使得构建容器映像的任务非常困难。

当我们希望在使用 Docker 作为容器运行时的 Kubernetes 集群中构建映像时，这一点会进一步扩展——可能作为 CI/CD 工作流的一部分。为了利用运行在 Kubernetes 节点上的 Docker 引擎 API，我们必须将守护进程的套接字安装到一个“客户端”容器中，以便构建时可以访问它。从安全角度来看，这是危险的，因为它有效地给予了容器对节点的根访问权，并且完全绕过了 Kubernetes 抽象。另一个解决方案可能是避免在节点上使用 Docker 守护进程，而使用 Docker-in-Docker (DinD)来提供一个自包含的映像构建环境。但是，这也有安全隐患，因为运行 DinD 的容器需要作为特权容器运行。

一段时间以来，获得“无根”构建一直是社区中的一个追求。

# 结论

尽管有这些限制，使用 Docker 的构建 API 端点和 Dockerfile 语法仍然是构建容器映像的主要方法。Docker Hub 和 Quay 等公共图像注册中心托管的成千上万张图像及其相关的 Docker 文件就证明了这一点。但是这些限制也促使新的技术和工具出现，这些技术和工具旨在解决其中一些问题，并增强容器映像构建体验。这些工具是在社区支持下开放开发的，并且在功能上经常重叠。为了更好地理解容器图像构建的最新技术，本系列的下一篇文章将探讨提供了什么。

准备好将您的云原生项目投入生产了吗？简单地请求你的大群邀请[这里](https://giantswarm.io/)。

由[Puja Abbas si](https://twitter.com/puja108)——开发者倡议@ [巨型虫群](https://giantswarm.io/)撰写

[](https://twitter.com/puja108) [## Puja Abbassi (@puja108) |推特

### Puja Abbassi 的最新推文(@puja108)。开发者关系&产品@ GiantSwarm 研究员；主题…

twitter.com](https://twitter.com/puja108)