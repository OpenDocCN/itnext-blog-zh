<html>
<head>
<title>Effective State Management in React: Comprehensive guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的有效状态管理:综合指南</h1>
<blockquote>原文：<a href="https://itnext.io/effective-state-management-in-react-comprehensive-guide-5c30fb0f95da?source=collection_archive---------5-----------------------#2022-05-23">https://itnext.io/effective-state-management-in-react-comprehensive-guide-5c30fb0f95da?source=collection_archive---------5-----------------------#2022-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/457f623bf2ad67800fff68ed2f8005cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GP8vL_lMi6T7me1ovGtUDQ.png"/></div></div></figure><p id="0a2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">状态管理可以决定React应用的成败。如果你的状态流是合理的，你的开发速度将会保持很高，即使你的项目变得越来越复杂。另一方面，糟糕的状态流设计会成倍地增加开发时间。</p><p id="1f1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将概述一些我多年来在React中获得的有效状态管理的技巧和要点。我不会涉及任何特定的状态管理库或解决方案。相反，我将关注React中有效状态管理的核心概念和原则。</p><h1 id="ffd3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">花时间规划你的状态</h1><p id="2024" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在开始编写组件代码之前，花时间规划状态管理。</p><p id="4197" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">思考一下国家在这部电影中的角色。如何使它在将来易于扩展，应该使用哪些数据结构？这可能看起来像是大量的前期工作，但是随着新的业务需求的出现，从长远来看，这将节省您的时间和麻烦。</p><h1 id="95ff" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">避免将状态保存在不同的地方</h1><p id="1681" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我看到的一个常见错误是一个组件有多个状态源，这使得很难可视化状态逻辑和数据流。</p><p id="5d33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我见过一个组件依赖于URL参数、Redux和本地存储。不出所料，很难破译它到底发生了什么。</p><p id="c86c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，目标是在组件中有一个状态源。如果您有一个依赖于Redux的表单，请确保它从Redux获取所有数据。</p><p id="133f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，有时，您必须使用多个状态源。但这并不意味着你不能将它们相互抽象。</p><p id="b19d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果同一个表单需要从URL params中获取它的初始数据集，那么将它包装在另一个组件中，并让该组件读取URL params并将它们作为props传递。这样，核心组件保持松散耦合，并且更容易推断其内部状态逻辑。</p><h1 id="84da" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">尽可能推导出您的状态</h1><p id="6a14" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">派生状态是一种我认为被低估的技术。这个想法是存储尽可能少的状态数据。</p><p id="0d2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免存储状态变量，您可以动态地派生它们，这简化了在发生变化时保持数据同步的工作。</p><p id="8729" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设您有多个复选框，当所有复选框都被选中时，您需要显示一个额外的标签。您可以将每次渲染时选中复选框的数量与总数进行比较，而不是存储单独的“isAllSelected”变量。如果两者相等，您知道所有复选框都被选中。</p><p id="7ef6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这看起来像是一个小的优化，但是当你有很多需要保持同步的状态变量时，它就会累积起来。</p><p id="3e61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解更多，请查看我写的这篇关于派生状态的博文。</p><h1 id="327d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">额外的API调用是可以接受的</h1><p id="e9ae" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一些开发人员认为，进行“多余的”API调用是web开发中最大的罪过之一。</p><p id="76f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，发送API调用来刷新状态可以大大简化代码。您可以避免编写复杂的逻辑来保持本地状态与数据库变化同步。</p><p id="1ce4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">API带宽不是软件公司最宝贵的资源，是开发者的时间。当您编写代码来保持状态同步而不依赖于额外的API调用时，您会增加维护的复杂性。</p><p id="52a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也有例外，比如说，如果你正在开发一个被成千上万人使用的软件产品，引入多余的API调用会明显降低应用程序的性能和UX。</p><p id="3957" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与任何事情一样，使用良好的判断并考虑权衡。进行额外的API调用可能不是性能最好的方法，但通常是最简单、最容易推理的方法。</p><h1 id="7a71" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">全局与本地状态</h1><p id="f26a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我经常看到新手React开发人员在没有太多理由的情况下将几乎每一点数据都存储在全局状态中。</p><p id="e4c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这会影响代码的性能和复杂性。只要有可能，最好使用本地状态。您应该仅对应用程序中多个页面使用的数据使用全局状态。</p><p id="a886" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本地状态通常也有更好的性能。对全局存储进行更新可以触发对许多利用它的组件的更新，即使它们不使用更新的数据。</p><p id="c1b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经常触发的动作，比如用户输入，应该保存在本地。</p><h1 id="21f6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">避免深度嵌套的状态对象</h1><p id="df97" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">深度嵌套的对象可能很难处理，尤其是当您需要向下更新几个级别的字段时。</p><p id="81fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽量保持你的状态结构扁平，因为这样更容易处理和改变。</p><p id="1b76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拥有包含组件所需的所有数据的对象的一个好处是简单快速的访问。嗯，有另一种数据结构会给你带来同样的好处:<a class="ae mc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> maps </a>。</p><p id="f357" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">地图为san提供了对值的即时访问，无需过滤或搜索。地图也是松散耦合的，这意味着您可以轻松地添加或删除项目，而不会影响州的其他部分。</p><h1 id="6f74" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通用更新处理程序</h1><p id="fca5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在React中，您将使用许多事件处理程序。当用户键入、切换单选按钮或单击删除按钮时，您需要提供一个处理程序。</p><p id="f4c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我经常看到开发人员为每种类型的事件创建一个独特的处理程序。虽然这样做是可行的，但这是不必要的，并且会导致大量的重复代码。相反，您可以创建一个通用处理程序，它接受要更新的字段键和新值。</p><p id="100c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，您只需编写一个函数，就可以在所有事件处理程序中重复使用。</p><p id="e304" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数的代码可能如下所示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0ba0" class="mm la it mi b gy mn mo l mp mq"><strong class="mi iu">function</strong> updateField(field, value) {<br/>   setObject({...object, [field]<strong class="mi iu">:</strong> value})<br/>}</span></pre><p id="77cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，你可以像这样在你孩子的组件中使用它:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3edf" class="mm la it mi b gy mn mo l mp mq">onChange<strong class="mi iu">=</strong>{(event) =&gt; updateField('firstName', event.target.value)}</span></pre><p id="8931" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您甚至可以更进一步，提供一个接受更新对象的处理程序。假设您有一个包含标题、正文和作者字段的post对象。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b500" class="mm la it mi b gy mn mo l mp mq"><strong class="mi iu">function</strong> updatePost(post) {<br/>   setPost({...post});<br/>}</span></pre><p id="5045" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，您可以为任何触发post更新的事件重用这个<code class="fe mr ms mt mi b">updatePost</code>函数，甚至是更新多个对象字段的事件。</p><h1 id="010d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="364f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这个帖子到此为止。我介绍了我所知道的管理React状态的最有用的技巧和要点。我希望这篇文章对你有所帮助，并且你能够在你的项目中使用其中的一些技巧。</p><p id="d214" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae mc" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我，</a>我在那里分享我学到的东西。<br/>快乐编码！</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="2b19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nb">原载于2022年5月23日https://isamatov.com</em><a class="ae mc" href="https://isamatov.com/react-state-management-guide/" rel="noopener ugc nofollow" target="_blank"><em class="nb"/></a><em class="nb">。</em></p></div></div>    
</body>
</html>