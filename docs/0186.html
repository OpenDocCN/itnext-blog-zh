<html>
<head>
<title>An illustrated guide to Kubernetes Networking [Part 1]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes网络图解指南[第1部分]</h1>
<blockquote>原文：<a href="https://itnext.io/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727?source=collection_archive---------0-----------------------#2017-11-14">https://itnext.io/an-illustrated-guide-to-kubernetes-networking-part-1-d1ede3322727?source=collection_archive---------0-----------------------#2017-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="571f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我所知道的关于Kubernetes网络的一切</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81e59b7eb15f5fa97cbecb11d137ff45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBYlyYsz0NsWHvh1lpUbzw.png"/></div></div></figure><p id="f925" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated">你已经在Kubernetes集群上运行了许多服务，并从中获益。或者至少，你打算这么做。尽管有很多工具可以用来设置和管理集群，但是您仍然想知道它是如何工作的。如果它坏了，你去哪里找？我知道我做到了。</p><p id="9c42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然Kubernetes是足够简单的开始使用它。但是让我们面对现实吧——这是一只隐藏在引擎盖下的复杂野兽。有许多活动的部分，如果你想为失败做好准备，了解它们如何相互配合和协同工作是必须的。最复杂，也可能是最关键的部分之一是网络。</p><p id="ee12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我开始了解Kubernetes的网络是如何运作的。我阅读了文档，观看了一些演讲，甚至浏览了代码库。这是我发现的。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="10fb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Kubernetes网络模型</h1><p id="f18d" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">Kubernetes网络的核心有一个重要的基本设计理念:</p><blockquote class="na"><p id="0603" class="nb nc iq bd nd ne nf ng nh ni nj lm dk translated">每个Pod都有一个唯一的IP。</p></blockquote><p id="5ec1" class="pw-post-body-paragraph kr ks iq kt b ku nk jr kw kx nl ju kz la nm lc ld le nn lg lh li no lk ll lm ij bi translated">此Pod IP由该Pod中的所有容器共享，并且可从所有其他Pod路由。有没有注意到一些“暂停”容器在Kubernetes节点上运行？它们被称为“沙盒容器”，其唯一的工作是保留和保存一个网络名称空间(netns)，该名称空间由pod中的所有容器共享。这样，即使一个容器死亡，一个新的容器在它的位置上被创建，一个pod IP也不会改变。这种IP-per-pod模型的一个巨大优势是不会与底层主机发生IP或端口冲突。我们不必担心应用程序使用什么端口。</p><p id="8fba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这一点，Kubernetes的唯一要求是这些Pod IPs可从所有其他Pod路由/访问，而不管它们在哪个节点上。</p><h2 id="b251" class="np me iq bd mf nq nr dn mj ns nt dp mn la nu nv mp le nw nx mr li ny nz mt oa bi translated">节点内通信</h2><p id="8454" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">第一步是确保同一节点上的pod能够相互通信。这个想法然后被扩展到跨节点的通信，到互联网等等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/27f418189cec0febd7579484146d9c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9gyGWgVah4-Rt3SyUBN6w.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Kubernetes节点<br/>(根网络名称空间)</figcaption></figure><p id="5a07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在每个Kubernetes节点上，在本例中是一台linux机器，有一个根网络名称空间(root as in base，而不是超级用户)—根netns。</p><p id="aa39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">主网络接口<code class="fe og oh oi oj b">eth0</code>在这个根网络中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/5c405ebbd109194ee0bab639aa80719a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Dr6i0cIhQ3YtN7Y3v15Ng.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Kubernetes节点<br/> (pod网络名称空间)</figcaption></figure><p id="f50d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类似地，每个pod都有自己的网络，通过虚拟以太网对将其连接到根网络。这基本上是一个管道对，一端在根网，另一端在荚网。</p><p id="bae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将pod-end命名为<code class="fe og oh oi oj b">eth0</code>，因此pod不知道底层主机，并认为它有自己的根网络设置。另一端被命名为类似<code class="fe og oh oi oj b">vethxxx</code>的东西。您可以使用<code class="fe og oh oi oj b">ifconfig</code>或<code class="fe og oh oi oj b">ip a</code>命令在您的节点上列出所有这些接口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/dcb14c21ca28acad5ecba35c4dae99ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8TZAvh7_4Zb7KGoC5JHUA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Kubernetes节点<br/> (linux网桥)</figcaption></figure><p id="6f7d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是为节点上的所有单元完成的。为了让这些单元互相交流，使用了一个linux以太网桥<code class="fe og oh oi oj b">cbr0</code>。Docker使用了一个类似的名为<code class="fe og oh oi oj b">docker0</code>的桥。</p><p id="95c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以使用<code class="fe og oh oi oj b">brctl show</code>命令列出这些桥。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/8070b8f77fd36aedb8944ce86546609b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kh6BRLkxDqerh6wYLVLdTA.gif"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Kubernetes节点<br/>(同一个节点点对点通信)</figcaption></figure><p id="33a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设一个数据包从<code class="fe og oh oi oj b">pod1</code>发送到<code class="fe og oh oi oj b">pod2</code>。<br/> <strong class="kt ir"> 1。</strong>它在<code class="fe og oh oi oj b">eth0</code>离开<code class="fe og oh oi oj b">pod1</code>的网，在<code class="fe og oh oi oj b">vethxxx</code>进入根网。<br/>T23】2。它被传递到<code class="fe og oh oi oj b">cbr0</code>，T8使用ARP请求发现目的地，说“谁拥有这个IP？”<br/> <strong class="kt ir"> 3。</strong> <code class="fe og oh oi oj b">vethyyy</code>表示它有那个IP，所以网桥知道把包转发到哪里。<br/> <strong class="kt ir"> 4。</strong>数据包到达<code class="fe og oh oi oj b">vethyyy</code>，穿过管道对到达<code class="fe og oh oi oj b">pod2</code>的网络。</p><p id="a1ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">节点上的容器就是这样相互通信的。显然还有其他方法，但这可能是最简单的，docker也是这样使用的。</p><h2 id="a1d4" class="np me iq bd mf nq nr dn mj ns nt dp mn la nu nv mp le nw nx mr li ny nz mt oa bi translated">节点间通信</h2><p id="96f8" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">正如我前面提到的，pod也需要跨节点可达。Kubernetes不在乎怎么做。我们可以使用L2(跨节点的ARP)、L3(跨节点的IP路由——像云提供商路由表)、覆盖网络，甚至信鸽。只要流量能够到达另一个节点上的所需pod，这都没有关系。每个节点都为pod IPs分配了一个唯一的CIDR块(一个IP地址范围),因此每个pod都有一个唯一的IP，不会与另一个节点上的pod冲突。</p><p id="1ae5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在大多数情况下，尤其是在云环境中，云提供商路由表确保数据包到达正确的目的地。同样的事情可以通过在每个节点上设置正确的路由来完成。还有一堆其他的网络插件在做自己的事情。</p><p id="f089" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们有两个节点，类似于我们之前看到的。每个节点都有不同的网络名称空间、网络接口和网桥。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/eb0674e7fb9b614343330fd65122f3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r27TvmTUKNvaLmahvTsLIQ.gif"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Kubernetes带路由表的节点<br/>(跨节点点对点通信)</figcaption></figure><p id="535a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设数据包从<code class="fe og oh oi oj b">pod1</code>发送到<code class="fe og oh oi oj b">pod4</code>(在不同的节点上)。</p><ol class=""><li id="a163" class="om on iq kt b ku kv kx ky la oo le op li oq lm or os ot ou bi translated">它在<code class="fe og oh oi oj b">eth0</code>离开<code class="fe og oh oi oj b">pod1</code>的网络，在<code class="fe og oh oi oj b">vethxxx</code>进入根网络。</li><li id="6b49" class="om on iq kt b ku ov kx ow la ox le oy li oz lm or os ot ou bi translated">它被传递给<code class="fe og oh oi oj b">cbr0</code>，后者使ARP请求找到目的地。</li><li id="fe81" class="om on iq kt b ku ov kx ow la ox le oy li oz lm or os ot ou bi translated">它从<code class="fe og oh oi oj b">cbr0</code>出来到达主网络接口<code class="fe og oh oi oj b">eth0</code>，因为这个节点上没有人拥有<code class="fe og oh oi oj b">pod4</code>的IP地址。</li><li id="59ee" class="om on iq kt b ku ov kx ow la ox le oy li oz lm or os ot ou bi translated">它离开机器<code class="fe og oh oi oj b">node1</code>到带有<code class="fe og oh oi oj b">src=pod1</code>和<code class="fe og oh oi oj b">dst=pod4</code>的线上。</li><li id="b728" class="om on iq kt b ku ov kx ow la ox le oy li oz lm or os ot ou bi translated">路由表为每个节点CIDR块设置了路由，并将数据包路由到其CIDR块包含<code class="fe og oh oi oj b">pod4</code> IP的节点。</li><li id="8682" class="om on iq kt b ku ov kx ow la ox le oy li oz lm or os ot ou bi translated">因此数据包到达主网络接口<code class="fe og oh oi oj b">eth0</code>的<code class="fe og oh oi oj b">node2</code>。<br/>现在，即使<code class="fe og oh oi oj b">pod4</code>不是<code class="fe og oh oi oj b">eth0</code>的IP，由于节点被配置为启用IP转发，数据包仍然被转发到<code class="fe og oh oi oj b">cbr0</code>。<br/>在节点的路由表中查找任何匹配<code class="fe og oh oi oj b">pod4</code> IP的路由。它找到<code class="fe og oh oi oj b">cbr0</code>作为该节点的CIDR块的目的地。<br/>您可以使用<code class="fe og oh oi oj b">route -n</code>命令列出节点路由表，它将显示一条<code class="fe og oh oi oj b">cbr0</code>的路径，如下所示:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/52b6f579cec90f13315b35c4abb4870a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mU6x8n0V-vexvE-XFbvblQ.png"/></div></div></figure><p id="8a21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">7.网桥接收数据包，发出ARP请求，并发现该IP属于<code class="fe og oh oi oj b">vethyyy</code>。</p><p id="694e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">8.数据包穿过管道对到达<code class="fe og oh oi oj b">pod4</code>🏠</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="fbde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是Kubernetes网络的基础。所以下一次它坏了，一定要检查那些桥和路由表😉</p><p id="d1ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前就这些。在接下来的部分中，我们将看到<a class="ae pb" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-2-13fdc6c4e24c" rel="noopener">覆盖网络如何工作【第2部分】</a>，当pod来来去去时会发生什么<a class="ae pb" href="https://medium.com/@ApsOps/an-illustrated-guide-to-kubernetes-networking-part-3-f35957784c8e" rel="noopener">网络变化，以及出站和入站流量如何流动【第3部分】</a>。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="9a48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，我对网络概念还很陌生，所以我希望得到反馈，尤其是当有不清楚或错误的地方🙂</p><blockquote class="na"><p id="693f" class="nb nc iq bd nd ne nf ng nh ni nj lm dk translated">你在Kubernetes遇到过什么样的网络或其他问题？</p><p id="05ea" class="nb nc iq bd nd ne nf ng nh ni nj lm dk translated">请在这里留言或在推特上联系我。</p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="60aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi">-</p></div></div>    
</body>
</html>