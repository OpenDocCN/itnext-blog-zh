<html>
<head>
<title>Watch out for the Trap When Using Default for Django Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Django模型使用Default时要小心陷阱</h1>
<blockquote>原文：<a href="https://itnext.io/watch-out-for-the-trap-when-using-default-for-django-models-44350f672be2?source=collection_archive---------5-----------------------#2018-05-22">https://itnext.io/watch-out-for-the-trap-when-using-default-for-django-models-44350f672be2?source=collection_archive---------5-----------------------#2018-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9b91bfaa2f68166a1ead7d789fb22bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXYJ8t3Wii-8i-JVJ02m7w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae kc" href="https://www.flickr.com/photos/psd/" rel="noopener ugc nofollow" target="_blank">保罗·唐尼</a>来自<a class="ae kc" href="https://www.flickr.com/photos/psd/506497408/" rel="noopener ugc nofollow" target="_blank"> Flickr </a></figcaption></figure><p id="e189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我今天花了一整天来解决我们代码库中的一个奇怪问题。问题是，无论何时在我们的系统中创建一个“Book”实例，它都会自动从任何地方获得一些默认值。最令人沮丧的是，这个问题从来没有在我的本地盒子上重现。</p><p id="a5a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的系统是用django构建的，使用PostgreSQL作为数据库。在一些代码阅读和删除之后，我把注意力放在了<code class="fe lb lc ld le b">Book</code>模型本身上。模型定义是这样的:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f8c7" class="ln lo iq le b gy lp lq l lr ls">from django.contrib.postgres.fields import JSONField</span><span id="146e" class="ln lo iq le b gy lt lq l lr ls">class Book(models.Model):<br/>    name = models.CharField(max_length=100)<br/>    detail = JSONField(default={})</span></pre><p id="6bd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没错吧。我也没有发现任何问题…在开始的时候。我绝望地再次阅读文件，试图找到任何线索，直到我读到这句话:</p><blockquote class="lu lv lw"><p id="2b46" class="kd ke lx kf b kg kh ki kj kk kl km kn ly kp kq kr lz kt ku kv ma kx ky kz la ij bi translated">如果你给这个字段一个<code class="fe lb lc ld le b"><strong class="kf ir">default</strong></code>，确保它是一个可调用的，比如<code class="fe lb lc ld le b"><strong class="kf ir">dict</strong></code>(对于一个空的默认值)或者一个返回字典的可调用的(比如一个函数)。不正确地使用<code class="fe lb lc ld le b"><strong class="kf ir">default={}</strong></code>会创建一个可变缺省值，该值在<code class="fe lb lc ld le b"><strong class="kf ir">JSONField</strong></code>的所有实例之间共享。(<a class="ae kc" href="https://docs.djangoproject.com/en/2.0/ref/contrib/postgres/fields/#django.contrib.postgres.fields.JSONField" rel="noopener ugc nofollow" target="_blank"> src </a>)</p></blockquote><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/bec21b78d84125dae4b45f8be476ba99.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*chLPG31ZWPDDk0F9Sc_0UA.jpeg"/></div></figure><p id="8e87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">{}</code>不应该总还一本新字典吗？但是后来我意识到…</p><p id="1be5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是JAVASCRIPT！</p><p id="02ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯……有道理。为了验证这个问题，我创建了一个测试项目。我将省略模型设置部分(它与上面的代码相同),直接进入测试脚本。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="cff8" class="ln lo iq le b gy lp lq l lr ls">from django.core.management.base import BaseCommand<br/>from django_default_trap.demo.models import Book</span><span id="3307" class="ln lo iq le b gy lt lq l lr ls">class Command(BaseCommand):</span><span id="6da5" class="ln lo iq le b gy lt lq l lr ls">  def handle(self, *args, **options):<br/>      book1 = Book(name='Book 1')<br/>      print('book1.detail.author = %s' % book1.detail.get('author'))<br/>      book1.detail['author'] = 'Steven'<br/>      print('book1.detail.author = %s' % book1.detail.get('author'))<br/>      book1.save()<br/>      print('book1 saved.')</span><span id="57aa" class="ln lo iq le b gy lt lq l lr ls">      book2 = Book(name='Book 2')<br/>      print('book2.detail.author = %s' % book2.detail.get('author'))<br/>      book2.save()</span></pre><p id="1408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行此测试:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5dea" class="ln lo iq le b gy lp lq l lr ls">$ ./manage.py default_test<br/>book1.detail.author = None<br/>book1.detail.author = Steven<br/>book1 saved.<br/>book2.detail.author = Steven</span></pre><p id="c263" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不出所料，<code class="fe lb lc ld le b">book2.detail</code>不知从哪里得到了一个值<code class="fe lb lc ld le b">{ "author": "Steven" }</code>(我们从来没有给<code class="fe lb lc ld le b">book2.detail</code>赋值！).数据库查询也证实了这一点:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5b77" class="ln lo iq le b gy lp lq l lr ls">django_default_trap=# select * from demo_book;<br/> id |  name  |        detail        <br/>----+--------+----------------------<br/> 12 | Book 1 | {"author": "Steven"}<br/> 13 | Book 2 | {"author": "Steven"}<br/>(2 rows)</span></pre><p id="e906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，在创建<code class="fe lb lc ld le b">book1</code>时，默认值<code class="fe lb lc ld le b">{}</code>被使用并通过引用赋给<code class="fe lb lc ld le b">book1.detail</code> <strong class="kf ir">，下一行<code class="fe lb lc ld le b">book1.detail['author']</code>实际上是将<strong class="kf ir">全局</strong>对象<code class="fe lb lc ld le b">{}</code>改为<code class="fe lb lc ld le b">{'author': 'Steven'}</code>。这就是价值的来源。</strong></p><p id="44c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在测试脚本中，这个问题只影响当前会话(脚本的生命周期)本身，但是在服务器上，这个奇怪的缺省值将一直存在，直到服务器重新启动。那是一个严重的错误！</p><p id="c39e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案:正如文档中提到的，只需使用:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="066e" class="ln lo iq le b gy lp lq l lr ls">detail = JSONField(default=dict)</span></pre><p id="e246" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对测试项目感兴趣，请访问我的<a class="ae kc" href="https://github.com/charlee/django-default-trap" rel="noopener ugc nofollow" target="_blank"> github </a>。如果这篇文章有帮助，也请为我鼓掌。感谢您的阅读！</p></div></div>    
</body>
</html>