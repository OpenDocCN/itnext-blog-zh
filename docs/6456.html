<html>
<head>
<title>Writing code for your future self</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为未来的自己编写代码</h1>
<blockquote>原文：<a href="https://itnext.io/writing-code-for-your-future-self-65e66e098303?source=collection_archive---------5-----------------------#2021-11-21">https://itnext.io/writing-code-for-your-future-self-65e66e098303?source=collection_archive---------5-----------------------#2021-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3fa8eb9dd9ba06485773845c836cdad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4q790GbDK1Swh6QJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@hudsoncrafted?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">王思然·哈德森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="28d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都写过糟糕的代码。让我们面对现实吧。即使我们尽了最大努力来编写最高效和设计良好的代码，我们都碰巧编写了这种肮脏的方法，我们对此并不感到自豪，并害怕在下个月或明年进行调试。</p><p id="9617" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不打算谈论那些代码，因为它很容易被发现，也没有必要写关于它的博文。我感兴趣的是代码，当你打完的时候看起来很好，但是有一天会在背后咬你一口。结果是很难维护、扩展甚至理解。经过多年的编码，我已经想出了一套警告，每当我走向死胡同时，它们都会提醒我。</p><h1 id="ecae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">意义</h1><p id="80d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代码就是语言。当你使用像Ruby这样的编程语言时更是如此，Ruby被设计成非常具有表现力。但对我来说，当代码变得不清楚它真正做什么时，它就开始变得有味道了。</p><h2 id="8bb9" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">名称</h2><p id="073e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">命名至关重要。在我的创建过程中变化最大的一件事可能是我设计的类、方法和变量的名字。人类给他们理解的事物命名。而且一个元素的知识越高，命名就越犀利。在开发过程中重命名我的类通常是一个好的迹象，表明我对它们做什么或代表什么概念有了更好的了解。</p><h2 id="dcff" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">方法长度</h2><p id="54a5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">作为有抱负的OOP开发人员，我们被教导的最常见的设计模式之一是保持方法短于几行。然而，有一点需要注意的是，代码最终会分散在各处，有时您会与数据的生命周期脱节。对于用于构建数据结构的类来说尤其如此。</p><p id="94a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，这个类构建了一个要发送给FCM的<code class="fe mq mr ms mt b">data</code>散列:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="477c" class="me lc iq mt b gy nc nd l ne nf">module MobilePush<br/>  class FcmNotification &lt; BaseNotification<br/>    <br/>    def launch<br/>      # Bootstrap stuff...</span><span id="405e" class="me lc iq mt b gy ng nd l ne nf">      push_service.send_message(project, data)<br/>    end</span><span id="d316" class="me lc iq mt b gy ng nd l ne nf">    private<br/>      # Lots of methods...</span><span id="6889" class="me lc iq mt b gy ng nd l ne nf">      def data<br/>       {<br/>          notification: json_notification,<br/>          recipient: recipient_name,<br/>          room: room_name<br/>        }<br/>      end</span><span id="f4eb" class="me lc iq mt b gy ng nd l ne nf">      # Lots of other methods...</span><span id="aa8b" class="me lc iq mt b gy ng nd l ne nf">      def json_notification<br/>        @notification.to_json<br/>      end</span><span id="da7e" class="me lc iq mt b gy ng nd l ne nf">      def recipient_name<br/>        @recipient.name<br/>      end<br/>     <br/>      # Maybe a few other methods...</span><span id="02d4" class="me lc iq mt b gy ng nd l ne nf">      def room_name<br/>        @room.name<br/>      end</span><span id="7156" class="me lc iq mt b gy ng nd l ne nf">      # The rest of the methods...</span><span id="be80" class="me lc iq mt b gy ng nd l ne nf">  end<br/>end</span></pre><p id="8069" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh">注意:为了简洁起见，这些例子有点过于简化。但是你明白了。</em></p><p id="04a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写这个想法<em class="nh">“嘿，真聪明！一切都整理得很好。看起来真的很像干净的代码"</em>。</p><p id="7392" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我和家人一起休息了几天。当我不在的时候，我的一个同事必须处理我的新代码并添加一个新特性。但是他发现这是不必要的抽象，难以维护和扩展。他是对的。所以我把它重构为:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="b33c" class="me lc iq mt b gy nc nd l ne nf">module MobilePush<br/>  class FcmNotification &lt; BaseNotification<br/>    <br/>    def launch<br/>      # Bootstrap stuff...</span><span id="4310" class="me lc iq mt b gy ng nd l ne nf">      push_service.send_message(project, data)<br/>    end</span><span id="c646" class="me lc iq mt b gy ng nd l ne nf">    private<br/>      # Lots of methods...</span><span id="4ef4" class="me lc iq mt b gy ng nd l ne nf">      def data<br/>       {<br/>          notification: @notification.to_json,<br/>          recipient: @recipient.name,<br/>          room: @room.name<br/>        }<br/>      end</span><span id="7ff2" class="me lc iq mt b gy ng nd l ne nf">      # The rest of the methods...</span><span id="f02f" class="me lc iq mt b gy ng nd l ne nf">  end<br/>end</span></pre><p id="925a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，我不得不在班上的两三个地方把<code class="fe mq mr ms mt b">room_name</code>换成<code class="fe mq mr ms mt b">@room.name</code>，因为它在其他地方也被使用。但是我也让我的代码不那么抽象了。现在，我的同事一看就知道<code class="fe mq mr ms mt b">data</code>是什么做的了。</p><h1 id="e953" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">故事</h1><p id="11d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">写代码时要记住的一件事是，它不仅仅意味着有效和简洁。代码应该被其他人阅读。你的同事，你的团队领导，甚至更重要的是，你的新代码库的负责人。</p><h2 id="6bc0" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">一行程序</h2><p id="11d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我喜欢俏皮话。它们很有趣，直截了当，展示了创作者的技能和智慧。他们对于编程就像妙语或报纸标题对于写作一样。但是谁愿意读一整本这样写的书呢？</p><p id="b82e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我有时会在代码中使用一行程序，但我只有在确信我的继任者——或者未来的我——能够轻松理解它的时候才会这么做。</p><h2 id="c8b1" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">明确一点</h2><p id="a35d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我相信大部分代码应该是清晰的，用地标来引导读者，帮助他们理解。</p><p id="ff16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，代替这种表达:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="a35e" class="me lc iq mt b gy nc nd l ne nf">Device.where('last_seen &gt; ?', 1.hour.ago).where(logging: true).where(notifications: true).last.send_message(topic, payload)</span></pre><p id="fe8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我宁愿要么使用类方法，要么使用模型中的作用域，最后得到:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="29bf" class="me lc iq mt b gy nc nd l ne nf">device = Device.active_last(1.hour).logging.notifying.last<br/>device.send_message(topic, payload)</span></pre><p id="e414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不傻。我能理解第一个例子。但是当解析数百行代码来查找bug时，我可以查看这些代码并立即判断它的作用。不需要确保我得到了正确的答案。这种方法在输入的当天就完成了一次，我可以放心地依赖它，因为这些方法都经过了测试，而且确实如它所说的那样。</p><h2 id="24c3" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">有条不紊</h2><p id="a6e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我喜欢在课堂上把不同的意图分开。当你讲故事时，你首先用清晰的描述来介绍你的角色。那么只有你在你的故事里给他一个积极的角色。这就是上面的代码示例所做的。我也可以轻松地写下:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="ca28" class="me lc iq mt b gy nc nd l ne nf">Device.active_last(1.hour).logging.notifying.last.send_message(topic, payload)</span></pre><p id="a251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这是混合意图。这一行既是对模型的查询，也是触发一个动作，所以你开始读这一行时会想:"<em class="nh">哦，他正在定义设备"</em>，结束时会想<em class="nh">"啊。不，他正在向这个装置发送一条信息“</em>”。你的读者永远不应该被误导，即使是像这样简单的断言。</p><p id="fe18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我试图将查询与操作分开。它们是两种类型的任务，在我的代码中需要两个不同的步骤。</p><p id="a675" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑这三句话:</p><blockquote class="ni nj nk"><p id="883f" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">酒吧里那个又老又脏的男人正在谈论昨天的足球比赛结果。—凌乱</p><p id="4d0f" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">有一个人正在肮脏的旧酒吧里谈论昨天的足球比赛结果。—更清晰</p><p id="8f0d" class="kd ke nh kf b kg kh ki kj kk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">在肮脏的旧酒吧里，有一个男人。他正在谈论昨天的足球比赛结果。—清澈透明</p></blockquote><p id="5f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望我的代码非常清晰。我希望我的代码审查者、我的继任者或我未来在周五下午非常疲惫的自己能够完美地理解我正在做的代码。</p><h1 id="a8dc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">试验</h1><p id="5f2e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">编写测试帮助我识别依赖性。集成测试通常需要相当多的引导:一个登录的用户，一些相关的实体…这很好。</p><p id="c920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我有时会编写过于依赖其他模型的测试。如果没有Post模型就无法测试您的注释模型，那么代码中有些东西耦合得太紧了，需要查询那些实体之间的关系。</p><p id="b521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">断言也引导我走向代码清晰。我发现，当我在测试中难以定义一个期望时，通常意味着这个特定的方法做得不够清楚。它要么需要被分割成更小的方法，要么完全重新考虑。</p><h1 id="f896" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于评论的一句话</h1><p id="2af7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代码需要重构的另一个标志是注释。评论大多指出程序做什么还不清楚。因此，当我在代码中看到注释时，我做的第一件事就是删除它们，并在不阅读它们的情况下找出发生了什么。无论何时出现混乱，这都是一个好迹象，表明它们都可以被一个<code class="fe mq mr ms mt b">TODO: refactor</code>所取代。</p><p id="390d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注释通常也是外部依赖性的标志。通常，你会得到这样的东西:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="42ab" class="me lc iq mt b gy nc nd l ne nf"># Handle temperature &gt; 21</span><span id="3732" class="me lc iq mt b gy ng nd l ne nf"># Deal with legacy customer IDs</span></pre><p id="5603" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个可能取决于您正在处理的设备，这种依赖性可能由硬件团队来解决。</p><p id="c5d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个可以通过求助于一个继承的类来删除，比如<code class="fe mq mr ms mt b">LegacyCustomer</code>，它可以处理那种特殊的用户情况，并通过一个可预测的简单接口来保持<code class="fe mq mr ms mt b">Customer</code>类的整洁。</p><p id="eb89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我保留的唯一注释是类声明上面的顶级注释、代码文档、一些重构TODOs和关于代码的愚蠢、有趣的meta。</p><h2 id="ee0b" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">结论</h2><p id="a2e7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我有时会看着凌乱的代码，想知道，<em class="nh">“这是谁写的垃圾？”</em></p><p id="32b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我想想…该死的…</p><p id="03fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nh"> Me </em>。</p><p id="6a80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不喜欢这种感觉。我想为我的代码感到骄傲。我希望其他开发人员，包括我未来的自己，能够立即轻松地理解它，并感谢我为编写有意义、易于调试和维护的代码所做的努力。</p><p id="af6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望遵循这些指导方针能帮助我走上这条路。</p></div></div>    
</body>
</html>