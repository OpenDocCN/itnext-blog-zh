<html>
<head>
<title>Can Kubernetes Keep a Secret? It all depends what tool you’re using</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes能保守秘密吗？这完全取决于你使用什么工具</h1>
<blockquote>原文：<a href="https://itnext.io/can-kubernetes-keep-a-secret-it-all-depends-what-tool-youre-using-498e5dee9c25?source=collection_archive---------0-----------------------#2019-01-31">https://itnext.io/can-kubernetes-keep-a-secret-it-all-depends-what-tool-youre-using-498e5dee9c25?source=collection_archive---------0-----------------------#2019-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de71935dc77c8e968d70e06c7028342f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_bFrDFQfycUjLt-k.png"/></div></div></figure><p id="5f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Soluto，我们的超级开发人员拥有完全的所有权:从编写代码到部署到监控。当我们转向Kubernetes时，我们希望保持我们的开发人员独立，并投入大量精力让他们能够快速创建服务(T3)。这一切都运转得很好——直到他们不得不处理凭证。</p><p id="50d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个挑战引导我们建立了<a class="ae kw" href="https://github.com/Soluto/kamus" rel="noopener ugc nofollow" target="_blank">Kamus</a>——一个开源的、<a class="ae kw" href="https://www.weave.works/blog/gitops-operations-by-pull-request" rel="noopener ugc nofollow" target="_blank"> GitOps </a>、零信任、针对Kubernetes应用的秘密解决方案。Kamus允许您无缝地加密秘密值，并将它们提交给源代码控制。但是在深入研究Kamus如何工作之前，让我们快速回顾一下Kubernetes的本地秘密解决方案，以及我们为什么需要Kamus。</p><p id="5545" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经知道了，Kubernetes有一个内置的秘密管理对象，名字超级惊人的“secret”。Kubernetes secret是一个由orchestrator安全存储(例如静态加密)的简单对象，可以包含键值格式的任意数据。这里有一个库伯内特秘密的例子:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="cd9b" class="lg lh iq lc b gy li lj l lk ll">apiVersion: v1<br/>data:<br/> super-secret: aHR0cDovL2pvYnMuc29sdXRvLmNvbS9hcHBseS95MDVYSXEvUHJvZHVjdGlvbi1FbmdpbmVlci1EZXZPcHM=<br/>kind: Secret<br/>metadata:<br/> name: sensitive-data<br/> namespace: default<br/>type: Opaque</span></pre><p id="35eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们有类型(秘密)和数据。该值是base64编码的，因此我们也可以像存储证书一样存储二进制数据。Kubernetes通过让您简单地将秘密装载到您的容器上，或者作为env var——不推荐——或者作为一个文件，使得使用秘密变得容易。</p><h1 id="c97f" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">库伯内特平原秘密有什么问题？</h1><p id="3be7" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为什么我们需要另一种解决方案？首先，Kubernetes的秘密是base64编码，而不是<em class="mo">加密</em>。这意味着您不能将这些文件按原样提交到源代码控制中(这甚至是在文档中指定的<a class="ae kw" href="https://kubernetes.io/docs/concepts/configuration/secret/#security-properties" rel="noopener ugc nofollow" target="_blank">)。任何能够访问存储库的人都可以获取秘密并使用秘密值(除非这是一个您愿意接受的威胁，这在某些情况下是有效的)。因此，我们仍然需要一种简单的方法来存储这个秘密并将其上传到生产中，理想情况下不需要任何手动操作。</a></p><p id="5e50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就引出了我的第二点:可用性。秘密对于服务的正常执行至关重要，其中一个秘密的更改会导致生产问题。您需要很好地了解这些秘密——谁更改了它们，何时更改了什么——以便您可以调查生产问题。这就是为什么我如此支持GitOps，所有的事情都通过git进行审计。是的，Kubernetes有审计机制，但它不像git那样简单。因此，当谈到可用性时，我们需要一种透明且易于遵循的方法来修改秘密。</p><p id="4c99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三，考虑你的服务如何消耗秘密。在Kubernetes中，你可以通过两种方式之一使用秘密:将秘密作为一个<a class="ae kw" href="https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables" rel="noopener ugc nofollow" target="_blank">环境变量</a>或者作为一个<a class="ae kw" href="https://kubernetes.io/docs/concepts/storage/volumes/#secret" rel="noopener ugc nofollow" target="_blank">卷</a>挂载。将秘密作为环境变量安装是最简单的方法，但是并不是每个人都喜欢将敏感数据存储在环境变量中(查看这个<a class="ae kw" href="https://twitter.com/omerlh/status/1079088158929797121" rel="noopener ugc nofollow" target="_blank"> twitter帖子</a>以了解一些观点)。</p><p id="7c85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这个原因，有些人(包括我自己)更喜欢把<a class="ae kw" href="https://kubernetes.io/docs/concepts/storage/volumes/#secret" rel="noopener ugc nofollow" target="_blank">秘密装裱成册</a>。这允许您像访问容器中的普通文件一样访问秘密内容。Kubernetes为秘密数据中的每个密钥创建一个文件，并将解码值作为文件内容。当有一两个键时，这可能行得通，但是键越多，就越难——你需要从应用程序的代码中读取所有这些文件。这就是为什么我们通常最终会创建一个配置文件，对其进行base64编码，并将其存储为一个单独的秘密值。然而，这使得理解发生了什么变化变得更加困难。</p><p id="fce3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，Kubernetes拥有强大的RBAC支持，但它也有自己的缺点。秘密的现有权限是<em class="mo"> get </em>和<em class="mo"> set </em>(以及与本讨论不太相关的其他权限)。秘密在静止时被加密，但是没有权限说“允许用户得到加密的秘密”。一旦用户被允许得到一个秘密，她将得到解密。理想情况下，我们希望有一个零信任系统，一旦你加密了一个秘密，就没有简单的方法来解密它。目前，使用Kubernetes没有简单的方法来实现这一点。</p><h1 id="7600" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Kubernetes秘密的替代品</h1><p id="1036" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">有一些很好的替代品，比如<a class="ae kw" href="https://github.com/bitnami-labs/sealed-secrets" rel="noopener ugc nofollow" target="_blank">密封秘密</a>和<a class="ae kw" href="https://github.com/futuresimple/helm-secrets" rel="noopener ugc nofollow" target="_blank">头盔秘密</a>。这两种解决方案都允许您创建可以提交给源代码控制的加密秘密，并在以后解密成常规的Kubernetes秘密(无论是在CD上还是在集群中)。但是这些解决方案也不是完美的。不支持一次性加密，因为为了修改秘密中的值，您必须解密其内容。我们之前所有的可用性问题仍然存在。</p><h1 id="747b" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">介绍Kamus</h1><p id="aa05" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一天，在制作<a class="ae kw" href="https://github.com/OWASP/glue" rel="noopener ugc nofollow" target="_blank">胶水</a>的时候，我使用了Travis secrets <a class="ae kw" href="https://docs.travis-ci.com/user/encryption-keys/" rel="noopener ugc nofollow" target="_blank">加密解决方案</a>。如果您不熟悉Travis如何处理秘密，服务器会为每个存储库创建一个RSA密钥对，然后公开公钥。Devs可以使用公钥来加密值，这些值以后只能由Travis解密。这让我想到:如果我为Kubernetes创建一个类似的解决方案会怎么样？如果每个部署都有一个特定的RSA密钥对，这样我就可以利用相同的机制，那会怎么样？结果……是卡姆斯。</p><p id="c028" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何使用Kamus，然后深入了解它的工作原理和解决方案的安全性。Kamus为一个特定的<a class="ae kw" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" rel="noopener ugc nofollow" target="_blank">服务帐户</a>加密秘密，该帐户随后被一个pod用来认证Kamus并解密它们。因此，我们需要做的第一件事是创建一个服务帐户:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5a5a" class="lg lh iq lc b gy li lj l lk ll">kubectl create sa dummy</span></pre><p id="903c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以使用<a class="ae kw" href="https://github.com/Soluto/kamus/tree/master/cli" rel="noopener ugc nofollow" target="_blank"> kamus-cli </a>来加密这个服务帐户的超级秘密值:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7fb0" class="lg lh iq lc b gy li lj l lk ll">kamus-cli encrypt --secret super-secret --service-account some-sa --namespace some-ns --kamus-url <a class="ae kw" href="https://kamus.my-company.com" rel="noopener ugc nofollow" target="_blank">https://kamus.my-company.com</a></span></pre><p id="ece2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回值将是加密值。我们现在可以安全地将它提交给git，并且在运行时，使用Kamus API和pod的服务帐户的令牌来解密这个值。如果具有不同服务帐户的不同pod尝试解密该值，操作将会失败。</p><p id="5d5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解密一个秘密很简单——只需使用<a class="ae kw" href="https://github.com/Soluto/kamus/tree/master/init-container" rel="noopener ugc nofollow" target="_blank"> Kamus init容器</a>。init容器将读取所有加密的秘密，使用服务帐户令牌用Kamus解密这些值，并将解密的值写入临时位置。要了解这一点，请尝试运行<a class="ae kw" href="https://github.com/Soluto/kamus/tree/master/example" rel="noopener ugc nofollow" target="_blank">示例应用程序</a>。</p><h1 id="3e2b" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">准备好试试了吗？</h1><p id="3ac9" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在过去的六个月里，我们Soluto一直在生产中使用Kamus。这极大地改善了开发人员的体验，现在使用secrets是一项有趣而简单的任务。这也是我们决定开源Kamus的原因。开始使用它很简单——只需在Kubernetes集群上安装Helm即可:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3deb" class="lg lh iq lc b gy li lj l lk ll">helm repo add soluto <a class="ae kw" href="https://charts.soluto.io" rel="noopener ugc nofollow" target="_blank">https://charts.soluto.io</a></span><span id="f773" class="lg lh iq lc b gy mp lj l lk ll">helm install kamus soluto/kamus</span></pre><p id="40b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以查看我们的<a class="ae kw" href="https://github.com/Soluto/kamus/blob/master/docs/install.md" rel="noopener ugc nofollow" target="_blank">安装指南</a>进行生产级部署。</p><p id="73a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安全对我们很重要，这也是我们建造Kamus的原因。因为我们知道像Kamus这样的项目有多敏感，作为开源版本的一部分，我们也发布了一个<a class="ae kw" href="https://github.com/Soluto/kamus/tree/master/docs/features" rel="noopener ugc nofollow" target="_blank">威胁模型</a>。在这里，您可以找到我们检测到的所有不同威胁，以及Kamus如何减轻这些威胁。如果您发现了安全问题，我们很乐意听到—请查看<a class="ae kw" href="https://github.com/Soluto/kamus/blob/master/security.md" rel="noopener ugc nofollow" target="_blank"> security.md文档</a>，了解如何向我们报告安全问题。</p><p id="b594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保秘密安全至关重要，但并不总是那么简单。Kamus通过提供一个安全的GitOps解决方案来解决这个问题。它让你告诉Kubernetes一个秘密，并确保没有其他人知道这个秘密。剩下的就看你的了——你会给Kamus一个机会吗？</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="6872" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">最初发表于</em> <a class="ae kw" href="https://blog.solutotlv.com/can-kubernetes-keep-a-secret?utm_source=medium" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> Soluto工程博客</em> </a> <em class="mo">。</em></p></div></div>    
</body>
</html>