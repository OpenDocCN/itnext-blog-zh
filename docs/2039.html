<html>
<head>
<title>Learn Dependency Injection By Building an Injector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建注入器来学习依赖注入</h1>
<blockquote>原文：<a href="https://itnext.io/learn-dependency-injection-by-building-an-injector-fb48408af6a?source=collection_archive---------4-----------------------#2019-03-20">https://itnext.io/learn-dependency-injection-by-building-an-injector-fb48408af6a?source=collection_archive---------4-----------------------#2019-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/573015afdb46078c15db2410a95a70b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXZvJi2c-PhIxo_rZflZxA.png"/></div></div></figure><p id="d261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你用Angular构建过任何东西，毫无疑问你对依赖注入(DI)有一些经验，但是并不是每个人都使用Angular，甚至使用Angular的人可能并不真正理解DI在做什么。为了真正探索这一点，我们可以用大约20行的类型脚本构建我们的DI容器(您可以使用普通的JavaScript，但我觉得类型注释会有所帮助)。</p><p id="188b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们从DI的简单定义开始。来自<a class="ae kw" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">维基百科</a>“在<a class="ae kw" href="https://en.wikipedia.org/wiki/Software_engineering" rel="noopener ugc nofollow" target="_blank">软件工程</a>、<strong class="ka ir">依赖注入</strong>是一种一个对象提供另一个对象的依赖的技术。”虽然这听起来不错，但让我们看一个具体的例子。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="acce" class="lg lh iq lc b gy li lj l lk ll">class HttpService {<br/>  get(url: string) {...}<br/>  post(url: string) {...}<br/>}</span><span id="df4b" class="lg lh iq lc b gy lm lj l lk ll">class UserService {<br/>  constructor(private http: HttpService) {}</span><span id="0251" class="lg lh iq lc b gy lm lj l lk ll">  login(email: string, password: string) {<br/>    return this.http.post('/login', { email, password})<br/>  }<br/>}</span><span id="bb27" class="lg lh iq lc b gy lm lj l lk ll">const userService = new UserService(new HttpService())</span></pre><p id="7226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们不希望我们的用户服务关心如何发出http请求，我们希望它关心如何登录。虽然上面的例子现在满足了我们的需求，但随着我们获得更多的依赖，它可能会变得很麻烦。我们不想关心你如何创建一个HttpService，我们想说“嘿，我需要发出HTTP请求，给我HTTP服务！！！!"这是注射容器变得有用的时候。前面使用其中一个神秘容器的例子可能看起来像这样。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="f558" class="lg lh iq lc b gy li lj l lk ll">class HttpService { ... }</span><span id="6186" class="lg lh iq lc b gy lm lj l lk ll">class UserService { ... }</span><span id="fc2e" class="lg lh iq lc b gy lm lj l lk ll">// this is the thing we are going to build<br/>const injector = new Injector();</span><span id="7966" class="lg lh iq lc b gy lm lj l lk ll">const userService = injector.get(UserService);</span></pre><p id="6211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，我们希望我们的注射器做一些事情:</p><ol class=""><li id="0e4c" class="ln lo iq ka b kb kc kf kg kj lp kn lq kr lr kv ls lt lu lv bi translated">它应该为给定的类创建一个新的实例。</li><li id="045c" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">它应该创建给定类的依赖关系的新实例。</li><li id="0d0e" class="ln lo iq ka b kb lw kf lx kj ly kn lz kr ma kv ls lt lu lv bi translated">它应该返回单例对象。这意味着如果先前已经创建了一个实例，它将返回该实例。</li></ol><h2 id="2639" class="lg lh iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">步骤1–2:创建实例和依赖关系</h2><p id="9980" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">首先，我们需要创建一个新实例。在继续之前，停下来想一想，我们需要哪些信息来动态地做这件事……想过吗？我们需要知道依赖关系是什么。为了使事情更明确，我们将静态声明我们的类的依赖关系。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="86cf" class="lg lh iq lc b gy li lj l lk ll">class HttpService {}</span><span id="f243" class="lg lh iq lc b gy lm lj l lk ll">class AuthService {<br/>  static deps = [HttpService];<br/>  ...<br/>}</span></pre><p id="d763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以拥有创建新实例所需的一切，并且可以创建我们的注射器的第一个版本了！</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4dbb" class="lg lh iq lc b gy li lj l lk ll">// This type defines a "Provider" <br/>// as a class with a static "deps" property<br/>type Provider&lt;T&gt; = {<br/>  deps: Provider&lt;any&gt;[];</span><span id="9efd" class="lg lh iq lc b gy lm lj l lk ll">  new (...args: any[]): T;<br/>};</span><span id="a92a" class="lg lh iq lc b gy lm lj l lk ll">class Injector {<br/>  get&lt;T&gt;(P: Provider&lt;T&gt;): T {<br/>    return new P(...P.deps.map(dep =&gt; this.get(dep)));<br/>  }<br/>}</span></pre><p id="b40e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我们创建了一个新的“P”实例，并递归地调用“Injector.get”来获得每个依赖项的实例，非常简单！每次调用“Injector.get”时，都会创建新的实例。</p><h2 id="0290" class="lg lh iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">步骤3:缓存结果并返回单例</h2><p id="3d9e" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">既然我们已经成功地创建了服务和服务依赖的新实例，我们需要以某种方式记住它们，以便以后可以返回它们。我们需要一个贮藏处！</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="dd22" class="lg lh iq lc b gy li lj l lk ll">type Provider&lt;T&gt; = { ... };</span><span id="d9ba" class="lg lh iq lc b gy lm lj l lk ll">class Injector {<br/>  // singleton cache<br/>  private cache = new WeakMap&lt;Provider&lt;any&gt;, any&gt;();</span><span id="50ce" class="lg lh iq lc b gy lm lj l lk ll">  get&lt;T&gt;(P: Provider&lt;T&gt;): T {<br/>    // if provided is in cache return it<br/>    if (this.cache.has(P)) {<br/>      return this.cache.get(P);<br/>    }</span><span id="fd27" class="lg lh iq lc b gy lm lj l lk ll">    // if no existing instance create a new one<br/>    const instance = new P(...P.deps.map(dep =&gt; this.get(dep)));<br/>    <br/>    // then cache the resulting instance<br/>    this.cache.set(P, instance);<br/>    <br/>    return instance<br/>  }<br/>}</span></pre><p id="437c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了缓存，我们总是可以返回一个singleton，这意味着如果我们愿意，我们的对象现在可以保存状态。</p><p id="4a17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看一个更复杂的例子，看看我们可以用上面的注射器做什么。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6312" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！希望这个简单的阿迪容器的例子能帮助你理解DI在做什么，以及它是如何工作的。</p><p id="ff38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以为这个注入器实现添加什么其他特性？如果一个注射器可以有一个父代呢？覆盖一个提供者会是什么样子？试试吧，让我知道你想出了什么！</p><p id="c897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想看更复杂的实现，请看这里。</p></div></div>    
</body>
</html>