<html>
<head>
<title>GraphQL made easy by AWS AppSync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS AppSync简化了GraphQL</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-made-easy-by-aws-appsync-21dfae586d51?source=collection_archive---------3-----------------------#2018-06-12">https://itnext.io/graphql-made-easy-by-aws-appsync-21dfae586d51?source=collection_archive---------3-----------------------#2018-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a24ad76cdf558b0cf73f4a3c0eecc9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDd-tfXWsUeOaAI3ugpNxA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">堆栈</figcaption></figure><p id="0f75" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开始使用GraphQL可能会很困难。然而，我仍然听到有人加入了这项技术的宣传行列，他们讨厌它。</p><p id="bf13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为一名寻求学习AWS服务的前端开发人员，我对无服务器架构非常感兴趣。为我的应用程序忽略后端服务器的能力显示了很大的潜力，我很高兴了解支持这一点的技术。我相信前端和后端开发之间的界限将继续模糊，直到我们有了云管理者和开发者。我越来越多的开发人员同事可以互换工作，我自己每天看到的Java Spring比我承认的要多。</p><p id="4d00" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为一个未来的开发者，我们将创建GUI，查询数据库和API，并创建用户友好的逻辑。</p><p id="325a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，您将拥有云管理器，通过用户池、身份验证、业务逻辑、数据库模式等设置后端即服务。</p><blockquote class="la lb lc"><p id="c123" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">我的观点是——我认为无服务器架构是新的希望！</p></blockquote><p id="6190" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ld">学分</em> <a class="lh li ep" href="https://medium.com/u/695782484bda?source=post_page-----21dfae586d51--------------------------------" rel="noopener" target="_blank"> <em class="ld">纳德达比特</em> </a> <em class="ld">你可以看到这个教程在这里帮了我很大的忙。他有一些关于媒体的很棒的教程。如果你喜欢视频，可以在这里看他的视频教程</em></p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><h1 id="874c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">先决条件:</strong></h1><ul class=""><li id="e0eb" class="mn mo iq ke b kf mp kj mq kn mr kr ms kv mt kz mu mv mw mx bi translated">客户端是用React或React Native编写的。</li><li id="3de1" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated"><a class="ae nd" href="https://aws.amazon.com/console/" rel="noopener ugc nofollow" target="_blank">有一些AWS控制台的经验是个好主意。</a></li><li id="dafe" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">您应该了解AWS Cognito和AWS DynamoDB的基本知识。</li><li id="3811" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">此外，我建议您熟悉一下Apollo客户机&amp; GraphQL，尽管我开始时并不熟悉。他们都有很好的文档:</li></ul><div class="ne nf gp gr ng nh"><a href="https://www.apollographql.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">阿波罗图表</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">了解Apollo平台:客户端、引擎、GraphQL服务器、GraphQL支持等等。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">www.apollographql.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jw nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://graphql.org/learn/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">GraphQL:一种API查询语言。</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">GraphQL在您的API中提供了完整的数据描述，使客户能够准确地要求他们…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">graphql.org</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv jw nh"/></div></div></a></div><p id="b8b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">源代码Github链接:</strong></p><blockquote class="la lb lc"><p id="bd8e" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">没有AWS配置文件(aws-mobile.js、AppSync.js将丢失)</p></blockquote><p id="ad25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae nd" href="https://github.com/Jeyloh/recipe-web-appsync" rel="noopener ugc nofollow" target="_blank">https://github.com/Jeyloh/recipe-web-appsync</a></p><ul class=""><li id="be5f" class="mn mo iq ke b kf kg kj kk kn nx kr ny kv nz kz mu mv mw mx bi translated">在这篇文章中，我使用web资源库作为指南。如果你想看源代码，请看这里:</li></ul><p id="01c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae nd" href="https://github.com/Jeyloh/recipe-react-native-appsync" rel="noopener ugc nofollow" target="_blank">https://github.com/Jeyloh/recipe-react-native-appsync</a></p><ul class=""><li id="05a6" class="mn mo iq ke b kf kg kj kk kn nx kr ny kv nz kz mu mv mw mx bi translated">如果您想对React Native也这样做，步骤1–3是相同的，而客户端实现几乎是相同的。看看我的<a class="ae nd" href="https://github.com/Jeyloh/recipe-react-native-appsync" rel="noopener ugc nofollow" target="_blank"> github回购</a>。<strong class="ke ir">我完成了web项目，并将GraphQL文件夹复制到我的create-react-native-app中，剩下的就是React Native方式的组件。</strong></li></ul><h1 id="d790" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">入门—技术堆栈</h1><ul class=""><li id="e2bf" class="mn mo iq ke b kf mp kj mq kn mr kr ms kv mt kz mu mv mw mx bi translated">反应/自然反应</li><li id="d82a" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">GraphQL + Apollo客户端</li><li id="94ca" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">AWS Amplify + Mobilehub用于配置</li><li id="23cf" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">AWS AppSync、Cognito和DynamoDB</li></ul><p id="b08e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在这里要做的是一个简单的Recipe应用程序，带有React和React本地客户端。GraphQL客户端是在Apollo客户端中编写的，而GraphQL API服务器托管在AWS AppSync上。我们将使用Cognito添加身份验证，并将我们的数据存储在DynamoDB中。几乎后端的一切都将通过点击按钮和简单的外观来完成。</p><blockquote class="la lb lc"><p id="f072" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">GraphQL既不是语言也不是框架，而是规范。客户机和DB/API之间的一层。—就像REST端点一样。如果GraphQL是规范，那么Apollo Client就是实现。</p></blockquote><p id="7d59" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae nd" href="https://medium.com/@calebmer/whether-or-not-graphql-is-actually-a-graph-query-language-is-kind-of-a-technical-question-2f06bdb6788d" rel="noopener">来自脸书的Caleb Meredith </a>的这篇文章可以更好地解释GraphQL是什么和不是什么！</p><h1 id="5577" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">1.AppSync中的GraphQL服务器API</h1><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/eef39c71a18d928c58bcbdfadbbea404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zM83ecOZior3wDxSVfCIg.png"/></div></div></figure><p id="9c79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们从AppSync配置开始。<a class="ae nd" href="https://aws.amazon.com/console/" rel="noopener ugc nofollow" target="_blank">转到AWS控制台</a>。登录或注册<a class="ae nd" href="https://aws.amazon.com/free/" rel="noopener ugc nofollow" target="_blank">免费层</a>，通过搜索或点击服务找到AppSync:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/492511ac5de217b71cc97e027d4658e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kG_mRpAtDE8UesJxVso5wQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AWS控制台登录屏幕</figcaption></figure><p id="9680" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您会发现“创建API”按钮。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/d98b4e959b9760c5227825c0faf4db69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JE9XXwy0nRa-Y8OazQu5Ug.png"/></div></div></figure><p id="47ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">填写API名称(如Recipe GraphQL Server)并创建。</p><p id="9e68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单击Schema并删除注释。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/238c17871216d1d0fdfc08cc02e31521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jniNsqhDVt_-JAOrg9jFUA.png"/></div></div></figure><p id="41c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">粘贴此代码，然后单击保存。这里我们定义了与我们的应用程序相关的GraphQL模式类型。</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="2149" class="oj lq iq of b gy ok ol l om on">type Query {<br/> fetchRecipe(id: ID): Recipe<br/>}</span><span id="f0de" class="oj lq iq of b gy oo ol l om on">type Recipe {<br/> id: ID!<br/> name: String!<br/> directions: [String]!<br/> ingredients: [String]!<br/>}</span></pre><p id="0f55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们将使用AppSync来生成更多代码，并将DynamoDB资源连接到我们的GraphQL服务器。在“架构”页面上，单击“创建资源”。在这里，您可以选择刚刚定义的类型。</p><p id="998f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">选择配方，保留所有默认值，观察将生成的GraphQL代码。AppSync根据您的类型为您创建整个CRUD API。保存它，瞧，您现在有了一个与GraphQL API服务器通信的文档数据库。</p><p id="968a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了测试这一点，您可以使用AppSync的查询功能来测试您的GraphQL服务器。这里有一些你可以复制进来测试你的API的查询。</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="362f" class="oj lq iq of b gy ok ol l om on">query listRecipes {<br/>  listRecipes {<br/>    items {<br/>      id<br/>      name<br/>      directions<br/>      ingredients<br/>    }<br/>  }<br/>}</span><span id="119d" class="oj lq iq of b gy oo ol l om on">query fetchRecipe {<br/>   getRecipe(id: "1") {<br/>    id<br/>    name<br/>    ingredients<br/>    directions<br/>  }<br/>}</span><span id="c0a1" class="oj lq iq of b gy oo ol l om on">mutation createRecipe {<br/>  createRecipe( input: {<br/>    id:"1",<br/>    name:"Blueberry Oats",<br/>    directions: ["cook oats in milk", "add blueberries"],<br/>    ingredients: ["oats", "milk", "blueberry fresh/yam"]<br/>  }) {id, name, directions, ingredients}<br/>}</span></pre><p id="2b53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">测试它:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/be3aede4b18b6fce2be42ea8e5e04e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpZLt5pI4RQ0nqmN1cZwGg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AppSync查询</figcaption></figure><p id="9e9a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在调用createRecipe并输入一些内容后，您可以在DynamoDB表“RecipeTable”中看到结果。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/2cc70eaaaa056a450adcab6d327da860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZj8xHTGJ55jhDaRN_AF8A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AppSync数据源</figcaption></figure><p id="2cd7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将把您带到DynamoDB表，并向您显示新添加的配方:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/e8f9f749c232ff04941b56aca5735684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIOPqzeMaQbJTCjyKM2XJg.png"/></div></div></figure></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="5e55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">太好了！我们的GraphQL服务器API已经启动并运行。在我们继续之前，我们需要AppSync.js配置文件以便稍后使用。转到AppSync项目的根目录，向下滚动并点击:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/45c64c97cbd2021ea583df97e0976c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*cSGWWpvO0TbH6sJKf_MbVA.png"/></div></figure><p id="c9ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请稍后保存，我们将使用它来连接客户端应用程序。</p><blockquote class="la lb lc"><p id="1b2e" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">AWS AppSync有多种授权方法。默认值是每7天过期一次的API密钥。这是不够的。让我们用Cognito用户池实现一石二鸟。</p></blockquote></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><h1 id="7ef0" class="lp lq iq bd lr ls pa lu lv lw pb ly lz ma pc mc md me pd mg mh mi pe mk ml mm bi translated">2.AWS Amplify + mobilehub连接</h1><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/b9256127a7bc11f642653816514fbb0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ebb9fu67yYBnu6sBDUmOQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的客户使用Amplify与Cognito通信。它对用户进行身份验证，使他们能够通过一些特定的认知设置与AppSync进行通信。然后，客户端应用程序可以使用AppSync GraphQL服务器从DynamoDB获取数据</figcaption></figure><p id="39ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们开始用Mobilehub和Amplify设置Cognito之前，我们将创建我们的客户端应用程序，以便我们可以随时配置它。</p><p id="cb61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用create-react-app并从一开始就下载所有的包。这是你完成这个项目所需物品的完整清单。</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="7719" class="oj lq iq of b gy ok ol l om on">npx create-react-app recipe-demo &amp;&amp; cd recipe-demo/</span><span id="8966" class="oj lq iq of b gy oo ol l om on">npm i -S aws-appsync aws-appsync-react graphql-tag react-apollo uuid aws-amplify aws-amplify-react</span></pre><p id="d32e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然我们的应用程序已经初始化，我们就可以启动AWS Mobilehub了。这纯粹是一个配置工具，让你的生活更轻松。AppSync、Mobilehub和Amplify差不多是同时发布的。</p><p id="b9f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在AWS控制台中输入Mobilehub，然后单击Create Project。</p><ol class=""><li id="6eb7" class="mn mo iq ke b kf kg kj kk kn nx kr ny kv nz kz pg mv mw mx bi translated">输入名称(如配方演示)</li><li id="0f3d" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz pg mv mw mx bi translated">选择平台，我将向您展示如何在同一个用户池中同时连接Web和React Native。</li><li id="3285" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz pg mv mw mx bi translated">系统会提示您全局下载awsmobile-cli。回到你的终端，cd进入你的项目。请遵循以下步骤:</li></ol><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ph"><img src="../Images/413cd62bb9f0e717b73f0b1140d3f038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8qaS1XBd7QyyRUef3_cRA.png"/></div></div></figure><p id="352f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行awsmobile init后，您可能会被重定向到AWS控制台以创建新的IAM用户。只需遵循这里的默认设置，完成后，记下用户名和密钥。NB！！请妥善保管，否则您将再也看不到秘钥。</p><blockquote class="la lb lc"><p id="03e4" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><strong class="ke ir">AWS mobile init的结果是根文件夹中的“aws-exports.js”文件。这个文件与前面的“AppSync.js”文件一起构成了您与AWS服务的连接。请确保现在已经将它们都放入了您的客户端应用程序中。</strong></p></blockquote><p id="eb3a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤4 </strong>要求您下载Amplify，我们在启动客户端应用程序时已经下载了。忽略这个，点击“完成”！</p><h1 id="75d3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 3。集成Cognito用户池</strong></h1><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/eadf6cbb036b657b977e1336b5d1d036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*Kei6nTPdi_k9pJwyC6IIJw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">mobilehub“中心”,包含一系列项目和所有相关服务</figcaption></figure><p id="7710" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在你的mobile hub“hub”中，你会看到一个项目列表。当您向下滚动时，您可以添加许多与npm包aws-amplify相对应的AWS服务。</p><ul class=""><li id="d1a5" class="mn mo iq ke b kf kg kj kk kn nx kr ny kv nz kz mu mv mw mx bi translated">发电机数据库:NoSQL数据库</li><li id="04e0" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">Cognito:用户登录</li><li id="5f2c" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">λ:云函数</li><li id="4701" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">S3:静态文件存储</li><li id="7175" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">CloudFront:网站托管</li></ul><p id="e3ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于我们的例子来说，用户登录就足够了。单击它，只添加设置用户名:用户名。所有这些设置都可以在以后更改。</p><p id="3059" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建用户池，回到mobilehub项目，点击web项目上的Integrate。</p><p id="5fdf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们被告知在终端中输入我们的客户端，我们之前在那里启动了awsmobile。运行awsmobile pull，您的本地应用程序应该与您的AWS Mobilehub项目保持一致。整个AWS过程会向您的客户端项目添加一些文件夹。</p><p id="093e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经创建了Cognito用户池，您可以返回AWS AppSync并在项目设置中连接它:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pj"><img src="../Images/515edf08f7d1ca3db6e954a54e13fa3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h38p1L4Dq1AAAj0ZYZEsYg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">返回AppSync并添加您新创建的用户池。现在，这将成为您的GraphQL服务器的新认证方法</figcaption></figure><p id="916f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还将修改AppSync GraphQL服务器解析器。这是为了确保每个登录的Cognito用户只阅读他们自己创作的食谱。转到AppSync &gt; Schema并浏览右边的ListRecipes列表。点击它的解析器。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/aff68f80e89253c6cb6a91f240fa1fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*63STEIyMRdpxKawXAfBNYg.png"/></div></figure><p id="74b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在那里，每次用户调用ListRecipes时，我们希望他们只浏览自己创作的食谱。在配置模板对象中，添加“表达式”、“表达式值”和“索引”，使对象看起来像这样:</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="e13f" class="oj lq iq of b gy ok ol l om on">{<br/>  "version": "2017-02-28",<br/>  "operation": "Query",<br/>  <strong class="of ir">"query": {<br/>   "expression": "author = :author",<br/>    "expressionValues": {<br/>     ":author": {"S": "${ctx.identity.username}" }<br/>    }<br/>  },</strong><br/>  <strong class="of ir">"index": "author-index",</strong><br/>  "limit": $util.defaultIfNull($ctx.args.first, 20),<br/>  "nextToken": $util.toJson($util.defaultIfNullOrEmpty($ctx.args.after, null)),<br/>}</span></pre><p id="77ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们的应用程序将在资源(DynamoDB)中寻找正确的作者。但是作者字段是怎么加进去的呢？我们必须为CreateRecipe的解析器做同样的事情。回到模式并找到它:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/e58aced56153d80aed8dc1c370d497b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*AFyPYECSpRxnrsZq3eFMrw.png"/></div></figure><p id="e534" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个解析器中，我们将添加用户名作为作者(参见第二个#set行)。用突出显示的文本修改代码:</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="f3bd" class="oj lq iq of b gy ok ol l om on"><strong class="of ir">#set($attribs = $util.dynamodb.toMapValues($ctx.args.input))<br/>#set($attribs.author = $util.dynamodb.toDynamoDB($ctx.identity.username))</strong></span><span id="1ff4" class="oj lq iq of b gy oo ol l om on">{<br/>  "version": "2017-02-28",<br/>  "operation": "PutItem",<br/>  "key": {<br/>    "id": $util.dynamodb.toDynamoDBJson($ctx.args.input.id),<br/>  },<br/><strong class="of ir">  "attributeValues": $util.toJson($attribs),<br/></strong>  "condition": {<br/>    "expression": "attribute_not_exists(#id)",<br/>    "expressionNames": {<br/>      "#id": "id",<br/>    },<br/>  },<br/>}</span></pre><p id="4f6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">太好了！现在，我们的用户将只能阅读他们自己创建的食谱:</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/c8100aabf4c20a9f5560621a3915cbf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vv_veKXmx5m9G9OeAYKqSw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用户需要登录到客户端，只能看到他们的食谱</figcaption></figure><p id="c906" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在是我们动手编写代码的时候了。转到您的项目index.js文件，按照我在这里使用的设置进行操作。确保您的配置文件相对于index.js文件是正确的。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="pn lo l"/></div></figure><p id="32ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这段代码做了很多事情。</p><ol class=""><li id="c97d" class="mn mo iq ke b kf kg kj kk kn nx kr ny kv nz kz pg mv mw mx bi translated">ApolloProvider让你在代码中使用Apollo-Client。我们传递一个客户机作为props，它是用AppSync特定数据和Amplify Cognito认证方法设置的。</li><li id="0bdb" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz pg mv mw mx bi translated">恢复后的容器允许AppSync进一步处理您的代码。</li><li id="75a5" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz pg mv mw mx bi translated">AppWithAuth是带有<em class="ld">AWS-amplify-react</em>HOC<em class="ld">with authenticator()</em>的应用程序，它为您的登录屏幕提供了一个预制的GUI。</li><li id="6c9a" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz pg mv mw mx bi translated">amplify . configure(AWS-exports . js)将您的客户端与AWS mobilehub连接起来。再往下，我们就可以轻松使用所有的mobilehub服务了！这里有一个来自<a class="ae nd" href="https://aws.github.io/aws-amplify/media/authentication_guide" rel="noopener ugc nofollow" target="_blank">Amplify docs</a>的例子:</li></ol><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi po"><img src="../Images/df502eac95465b6fe75b4d073d691a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*fr0ah3KDnF3Nbkpi_H5DlA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">web的AWS GUI登录屏幕，需要2行代码</figcaption></figure><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pp"><img src="../Images/21afed541e02e72863528a1eb3d0223d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uu0otBWd8fIj3opK8f7Jiw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">从他们的文档中放大进一步的配置</figcaption></figure><p id="3b4a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在index.js文件中设置这一切的原因是它们主要是特设的、容器和配置。它们将被设置一次。对于项目的最后一部分，我们将创建客户机，并将其与Apollo-Client连接起来。</p><h1 id="3ee4" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">4.创建客户端</h1><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pq"><img src="../Images/d9851ddebf83f6e519cdb638e0e23727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rpDaFkgdgZrbW5b6x_HzQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">React、GraphQL和Apollo客户端</figcaption></figure><p id="4959" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一切都归结于此。我们的客户代码时间到了。在终端中转到您的项目，创建两个文件夹components和graphql。然后在graphql中，创建4个文件夹:突变、查询、订阅和解析器:</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="dd94" class="oj lq iq of b gy ok ol l om on">&gt; cd src &amp;&amp; mkdir components graphql</span><span id="5841" class="oj lq iq of b gy oo ol l om on">&gt; cd graphql &amp;&amp; mkdir mutations queries subscriptions resolvers</span></pre><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/70a8a26f35d0cb986094ab9126985df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*C1cx-T4mq18zgbJIaoNBSQ.png"/></div></figure><h1 id="4468" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">阿波罗+ GraphQL</h1><p id="8582" class="pw-post-body-paragraph kc kd iq ke b kf mp kh ki kj mq kl km kn ps kp kq kr pt kt ku kv pu kx ky kz ij bi translated">在突变、查询和订阅文件夹中，我们保留了所有的GraphQL API函数，就像我们在AppSync查询选项卡中创建的一样。在解析器中，我们目前有一个index.js来保存我们所有的Apollo客户端解析器。它导入我们所有的GraphQL。解析器是我们导入App.js并组合它们的函数，如下所示:</p><pre class="lj lk ll lm gt oe of og oh aw oi bi"><span id="4321" class="oj lq iq of b gy ok ol l om on"><strong class="of ir">import </strong>React, { Component } <strong class="of ir">from </strong>'react';<br/><strong class="of ir">import </strong>{ compose } <strong class="of ir">from </strong>'react-apollo';<br/><strong class="of ir">import </strong>* <strong class="of ir">as </strong>resolver <strong class="of ir">from </strong>'./graphql/resolvers/index';</span><span id="a861" class="oj lq iq of b gy oo ol l om on"><strong class="of ir">class </strong>App <strong class="of ir">extends </strong>Component { ... }</span><span id="f6fa" class="oj lq iq of b gy oo ol l om on"><strong class="of ir">export default </strong>compose(resolver.listRecipeGQLAction, resolver.createRecipeGQLAction, resolver.deleteRecipeAction)(App);</span></pre><p id="604a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下解析器包含我们应用程序的所有Apollo客户端逻辑。这是一份很重的文件，有很多事情要处理。Apollo团队已经声明这不是一个非常友好的开发者体验，将来会被简化。要获得对实现的解释，请查看我在开始时链接的由Nader Dabit制作的视频。我通过添加DeleteRecipe和DeleteRecipeSubscription对他的代码做了一些修改。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="pn lo l"/></div></figure><p id="9ea3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在解析器中看到，它们在每个函数中都返回props。因为我们在我们的App.js中对它们进行了合成，所以这些道具会自动映射到我们的App.js中，并且可以传递下去。我们的Recipe应用程序App.js的内容如下所示:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="pn lo l"/></div></figure><p id="029d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的State和onChange、addDirection和addIngredient函数管理当前添加的配方。</p><p id="863f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在componentDidMount()中，我们设置了订阅流，这是与我们的数据库的实时连接！这确保了我们的客户随时得到更新。</p><p id="5dbd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">addRecipe函数调用我们的props.onAdd()，它是在Apollo Resolver createripegqlaction中创建的。</p><p id="dfec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的渲染组件被视为任何普通的React组件，并传递了属性。请在这里查看这些github URL，因为它们大多是标准的React代码:</p><ul class=""><li id="222b" class="mn mo iq ke b kf kg kj kk kn nx kr ny kv nz kz mu mv mw mx bi translated"><a class="ae nd" href="https://github.com/Jeyloh/recipe-web-appsync/blob/master/src/components/Header.js" rel="noopener ugc nofollow" target="_blank"> Header.js </a></li><li id="5e8b" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated"><a class="ae nd" href="https://github.com/Jeyloh/recipe-web-appsync/blob/master/src/components/CookbookWrapper.js" rel="noopener ugc nofollow" target="_blank"> CookbookWrapper.js </a></li><li id="7be7" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated"><a class="ae nd" href="https://github.com/Jeyloh/recipe-web-appsync/blob/master/src/components/RecipeOverview.js" rel="noopener ugc nofollow" target="_blank"> RecipeOverview.js </a></li></ul><p id="cae1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里唯一的例外是在Header.js中，我用aws-amplify创建了一个注销函数:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="pn lo l"/></div></figure><h1 id="87dd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">额外好处</h1><ul class=""><li id="fd31" class="mn mo iq ke b kf mp kj mq kn mr kr ms kv mt kz mu mv mw mx bi translated">Apollo-Client提供了出色的缓存和离线支持。有了这个应用程序，我可以关闭互联网，添加一个食谱，刷新错误信息，去厕所，返回返回互联网和刷新，食谱将在我的数据库中刷新。</li><li id="9366" class="mn mo iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">如上所述，我能够在这里完成所有步骤，使用create-react-native-app并复制GraphQL文件夹，设置一些RN组件并获得我的食谱列表，如果我直接在DynamoDB或web客户端中删除，该列表会实时更新。</li></ul><h1 id="b757" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">最终结果</strong></h1><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pv"><img src="../Images/c6993f8dacc622340794591b0aef6e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eK73KTS0hKrXbkQSvEz1XA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">与Webapp并行运行的React原生app截图，在Add上实时更新！</figcaption></figure><h1 id="b65f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">结论</strong></h1><p id="a0df" class="pw-post-body-paragraph kc kd iq ke b kf mp kh ki kj mq kl km kn ps kp kq kr pt kt ku kv pu kx ky kz ij bi translated">这个项目真正有趣的是，我遵循了<a class="lh li ep" href="https://medium.com/u/695782484bda?source=post_page-----21dfae586d51--------------------------------" rel="noopener" target="_blank">纳德</a>的指南，除了几次会议之外，我没有任何GraphQL的经验，只有一些AWS的经验。这样做之后，我可以通过youtube和学习来完全提升我的技能。两周后，我在一个大约50名前端开发人员的会议上展示了这个，这相当不错。</p><p id="3aed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我前阵子已经在AWS上卖了。现在我非常喜欢Apollo的GraphQL，我得到了所有的宣传。</p><p id="6b57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你还在，非常感谢你的阅读！！这是我在Medium上呆了几年后的第一篇技术文章，从社区中学到了很多。如果您有任何问题或有任何遗漏——评论或尽快联系我，我们会聊天！</p><p id="2c2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">干杯，乔根利贝克</p></div></div>    
</body>
</html>