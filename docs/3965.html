<html>
<head>
<title>React Native Candy Crush Clone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应原生糖果粉碎克隆</h1>
<blockquote>原文：<a href="https://itnext.io/react-native-candy-crush-clone-c41a797fed0a?source=collection_archive---------1-----------------------#2020-04-03">https://itnext.io/react-native-candy-crush-clone-c41a797fed0a?source=collection_archive---------1-----------------------#2020-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b5cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们要做的</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fe964af7c572e92304c5743569a3d2b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oZcb9vt14fpkIXUEeIQo_g.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">软糖果酱的宣传片</figcaption></figure><p id="ed7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我开始制作<a class="ae le" href="https://itunes.apple.com/US/app/id1436558861?mt=8" rel="noopener ugc nofollow" target="_blank">软糖果酱</a>作为<a class="ae le" href="http://www.puppetryarts.org/TuffyTiger/" rel="noopener ugc nofollow" target="_blank">木偶艺术有限责任公司</a>的志愿者项目。我想在React Native中获得经验，这似乎是一个有趣的开始方式。</p><p id="47ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们开始之前，别忘了在App Store上免费下载<a class="ae le" href="https://itunes.apple.com/us/app/jellybean-jam/id1436558861?mt=8" rel="noopener ugc nofollow" target="_blank">软糖果酱</a>并试用一下。我的最高分是1400。</p><h1 id="cae1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们第一部分的目标</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/2730ea6d51662ef3c3bbdeaf0286d65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I_ML9vtuxZ_4PW5-Ynj-YA.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">简单的可交换网格</figcaption></figure><p id="3919" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第1部分中，我们将用一些随机的糖豆构建一个简单的可交换网格。我们还将讨论如何使用滑动手势、动画值、资产管理和一些算法。</p><h2 id="85f0" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">入门指南</h2><p id="e730" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">当您准备好了，继续下载下面两个入门项目中的一个。</p><ul class=""><li id="4a83" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated"><a class="ae le" href="https://github.com/fennean1/ReactNativeCandyStarterProject" rel="noopener ugc nofollow" target="_blank">ReactNativeCandyStarterProject</a>通过<code class="fe ne nf ng nh b">react-native init</code>创建</li><li id="5a40" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated"><a class="ae le" href="https://github.com/fennean1/ReactNativeCandyStarterProjectExpo" rel="noopener ugc nofollow" target="_blank">通过<code class="fe ne nf ng nh b">create-react-native-app</code>创建的ReactNativeCandyStarterProjectExpo</a></li></ul><p id="cd21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不管你选哪个，跑<code class="fe ne nf ng nh b">npm install</code>、<code class="fe ne nf ng nh b">npm install react-navigation</code>、&amp;、<code class="fe ne nf ng nh b">npm install react-native-swipe-gestures</code></p><h2 id="d00f" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">那么有什么区别呢？</h2><p id="f0ce" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">不同的是，ReactNativeCandyStarterProjectExpo将在<a class="ae le" href="https://expo.io/tools" rel="noopener ugc nofollow" target="_blank"> Expo </a>上运行，而另一个将需要Xcode或Android Studio。我通常为开发和测试保留我的应用程序的Expo版本，然后在以后将它们转换成“常规的”RN项目。如果您需要创建到本机代码的桥梁，这不是一个选项，但是由于我们的项目(根据设计)具有很少的依赖性，在两者之间切换将会很容易。</p><h2 id="aad9" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">四处打探</h2><p id="249d" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">让我们快速看一下文件夹结构:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b8a601518f12fb5851c1a214e81f09b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*pQ51gLWgAKB4swaplu_KSw.png"/></div></figure><p id="b7d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将要编辑的所有文件都在所示的<code class="fe ne nf ng nh b">src</code>文件夹中，您会注意到<code class="fe ne nf ng nh b">App.js</code>(未显示)只是我们的AppNavigator的包装器。它看起来是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="d629" class="me lg it nh b gy ns nt l nu nv">// App.js</span><span id="644d" class="me lg it nh b gy nw nt l nu nv">import React from 'react';<br/>import { StyleSheet, Text, View } from 'react-native';</span><span id="9037" class="me lg it nh b gy nw nt l nu nv">// Import AppContainer<br/>import AppNavigator from "./src/containers/AppNavigator";</span><span id="3aed" class="me lg it nh b gy nw nt l nu nv">export default class App extends React.Component {<br/>  render() {<br/>    return &lt;AppNavigator /&gt;;<br/>  }<br/>}</span></pre><p id="a30e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许我们将<code class="fe ne nf ng nh b">App.js</code>和<code class="fe ne nf ng nh b">src</code>直接复制到任何新项目中，不管它是用<code class="fe ne nf ng nh b">react-native init</code>还是<code class="fe ne nf ng nh b">create-react-native-app.</code>创建的</p><h2 id="4f93" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">航行</h2><p id="47d8" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">因为这不是React导航教程，所以我只给你一个根组件的样板代码，稍后我们会添加更多。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="f571" class="me lg it nh b gy ns nt l nu nv">// AppNavigator.js</span><span id="f278" class="me lg it nh b gy nw nt l nu nv">import React from "react";<br/>import ReactNative from "react-native";</span><span id="7df9" class="me lg it nh b gy nw nt l nu nv">var GameScreen = require("../screens/GameScreen");</span><span id="55f9" class="me lg it nh b gy nw nt l nu nv">import { createStackNavigator } from "react-navigation";</span><span id="3f61" class="me lg it nh b gy nw nt l nu nv">const Game = ({navigation}) =&gt; {<br/>  return &lt;GameScreen navigation={navigation}  /&gt;;<br/>};</span><span id="62ff" class="me lg it nh b gy nw nt l nu nv">const AppNavigator = createStackNavigator({<br/>  Root: {<br/>    screen: Game,<br/>    navigationOptions: {<br/>      header: null<br/>    }<br/>  }<br/>});</span><span id="fdd1" class="me lg it nh b gy nw nt l nu nv">module.exports = AppNavigator;</span></pre><h1 id="2242" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">现在让我们写一些代码</h1><h2 id="4a91" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">游戏屏幕</h2><p id="1549" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">在<code class="fe ne nf ng nh b">GameScreen.js</code>里面，你会看到我用<code class="fe ne nf ng nh b">&lt;ImageBackground/&gt;.</code>用一个漂亮的多云背景包裹了这个视图，这是我们要渲染组件<code class="fe ne nf ng nh b">SwappableGrid.</code>的地方，当你运行它时，它应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/62cc454ca63a10b809f45061b60fcc9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKURsk255NEYDT2cAJH8vw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">只是一颗孤独的豆子</figcaption></figure><p id="d8bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还没什么好幻想的。为了把事情做好，我们需要在里面做一些工作</p><h2 id="206a" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">数据源</h2><p id="7fda" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">如果你在SwappableGrid.js中查找，你会注意到<code class="fe ne nf ng nh b">tileDataSource: this.initializeDataSource()</code>一行已经被注释掉了。您还会看到，我们的render()函数返回一个居中的手势容器，其中有一个蓝色的果冻豆瓷砖。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="ca44" class="me lg it nh b gy ns nt l nu nv">export default class SwappableGrid extends Component&lt;{}&gt; {<br/>  constructor(props) {<br/>    super(props);</span><span id="4a65" class="me lg it nh b gy nw nt l nu nv">this.state = {<br/>      // tileDataSource: this.initializeDataSource()<br/>    };<br/>    <br/>  }<br/>  render() {<br/>    return (<br/>      &lt;GestureRecognizer style = {styles.gestureContainer}&gt;<br/>        &lt;Tile img = {BLUE_BEAN} /&gt;<br/>      &lt;/GestureRecognizer&gt;<br/>    );<br/>  }<br/>}</span><span id="2cbd" class="me lg it nh b gy nw nt l nu nv">// Need Gesture Container Style Here</span></pre><p id="8fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了初始化我们的数据源，我们需要创建一个二维的TileData类数组。如果您查看<code class="fe ne nf ng nh b">lib</code>下的<code class="fe ne nf ng nh b">TileData.js</code>，您会发现这个课程是为您创建的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="e4ea" class="me lg it nh b gy ns nt l nu nv">// TileData.js</span><span id="78e1" class="me lg it nh b gy nw nt l nu nv">import {<br/>  Animated,<br/>} from "react-native";</span><span id="0b38" class="me lg it nh b gy nw nt l nu nv">class TileData {<br/>  constructor(image, key) {<br/>    this.key = key;<br/>    this.location = new Animated.ValueXY();<br/>    this.img = image;<br/>    this.scale = new Animated.Value(1);<br/>  }<br/>}</span></pre><p id="10ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是细目分类:</p><ul class=""><li id="d039" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated"><strong class="js iu"> key — </strong>由于我们的实际组件也将存储为一个数组，React Native要求我们为每个组件提供一个唯一的键。在我们的例子中，它只是一个介于0和24之间的唯一整数。(因为网格是5x5)</li><li id="6a4e" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated"><strong class="js iu"> location — </strong>它将组件位置的x &amp; y值存储为动画，这一点也不奇怪。ValueXY()(稍后将详细介绍动画值)</li><li id="b773" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated"><strong class="js iu"> img — </strong>你猜对了！这是我们的图块在网格上时将呈现的图像。</li><li id="9f34" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated"><strong class="js iu"> scale — </strong>这是另一个动画值，用于调整组件的比例，使其在匹配完成后可以向外“弹出”或“缩小”。</li></ul><h2 id="93dd" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">初始化数据源</h2><p id="c1ff" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">一个有趣的方法是从0到24之间的5x5二维整数数组开始。然后，我们通过向构造函数提供图像和键，将这些键映射到TileData类的数组上。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="e634" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js</span><span id="5317" class="me lg it nh b gy nw nt l nu nv">initializeDataSource() {</span><span id="c86f" class="me lg it nh b gy nw nt l nu nv">let keys = [<br/>      [0, 1, 2, 3, 4],<br/>      [5, 6, 7, 8, 9],<br/>      [10, 11, 12, 13, 14],<br/>      [15, 16, 17, 18, 19],<br/>      [20, 21, 22, 23, 24]<br/>    ];</span><span id="d220" class="me lg it nh b gy nw nt l nu nv">let tileData = keys.map((row, i) =&gt; {<br/>       let dataRows = row.map((key, j) =&gt; {<br/>          return new TileData(BLUE_BEAN, key);<br/>       });<br/>      return dataRows;<br/>    });</span><span id="40fc" class="me lg it nh b gy nw nt l nu nv">return tileData;<br/>}</span></pre><p id="8fd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我已经对键的数组进行了硬编码，因为我将在整个教程中使用5x5的网格。我将把它留给读者作为动态生成他们自己的键数组的练习。</p><h2 id="99ce" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">资产</h2><p id="d483" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我使用图像BLUE_BEAN作为占位符，但是我们真正想要的是用随机的彩色豆子填充我们的网格。您会注意到，在<code class="fe ne nf ng nh b">/lib/Images.js</code>中，我导出了一个包含所有bean图像的数组，称为bean。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="82c8" class="me lg it nh b gy ns nt l nu nv">// Images.js</span><span id="560d" class="me lg it nh b gy nw nt l nu nv">export const PINK_BEAN = require("../assets/PinkJellyBean.png");<br/>export const  PURPLE_BEAN = require("../assets/PurpleJellyBean.png");<br/>export const BLUE_BEAN = require("../assets/BlueJellyBean.png");<br/>export const  ORANGE_BEAN = require("../assets/OrangeJellyBean.png");<br/>export const  GREEN_BEAN = require("../assets/GreenJellyBean.png");<br/>export const YELLOW_BEAN = require("../assets/YellowJellyBean.png");<br/>export const  RED_BEAN = require("../assets/RedJellyBean.png");</span><span id="47c2" class="me lg it nh b gy nw nt l nu nv">export const BEANS = [PINK_BEAN,PURPLE_BEAN,BLUE_BEAN,ORANGE_BEAN,GREEN_BEAN,YELLOW_BEAN,RED_BEAN]</span></pre><p id="6a5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要生成一个0到6之间的随机整数，并将其插入到BEANS数组中。我已经编写了自己的随机整数生成器，并从GridApi导入，grid API是我们放置所有与管理网格相关的方法的地方，比如查找匹配和识别重复。</p><p id="2ace" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的<code class="fe ne nf ng nh b">initializeDataSource</code>应该是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="7c98" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js</span><span id="4efc" class="me lg it nh b gy nw nt l nu nv">initializeDataSource() {</span><span id="ea25" class="me lg it nh b gy nw nt l nu nv">let keys = [<br/>      [0, 1, 2, 3, 4],<br/>      [5, 6, 7, 8, 9],<br/>      [10, 11, 12, 13, 14],<br/>      [15, 16, 17, 18, 19],<br/>      [20, 21, 22, 23, 24]<br/>    ];</span><span id="6337" class="me lg it nh b gy nw nt l nu nv">let tileData = keys.map((row, i) =&gt; {<br/>      let dataRows = row.map((key, j) =&gt; {<br/>         let int = getRandomInt(7)<br/>         let randomBean = BEANS[int]<br/>         return new TileData(randomBean, key);<br/>       });<br/>      return dataRows;<br/>    });</span><span id="7343" class="me lg it nh b gy nw nt l nu nv">return tileData;</span><span id="eae4" class="me lg it nh b gy nw nt l nu nv">}</span></pre><p id="b048" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到<code class="fe ne nf ng nh b">BLUE_BEAN</code>已经被一个随机生成的bean所取代，这个bean是从我们在<code class="fe ne nf ng nh b">Images.js.</code>中创建的<code class="fe ne nf ng nh b">BEANS</code>数组中挑选出来的</p><h2 id="abe1" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">创建切片</h2><p id="2694" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">重要的是要认识到，我们的瓷砖组件不需要二维数组。我们的数据源将决定它们是如何排列的，所以我们需要做的就是将它们连接到数据上，然后将它们转储到我们的网格中。我们通过遍历tileDataSource并为每个图块提供存储在每个tileData类中的属性来创建图块。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="fd13" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js</span><span id="9fb0" class="me lg it nh b gy nw nt l nu nv">renderTiles(tileDataSource) {<br/>    let tiles = [];<br/>    tileDataSource.forEach((row, i) =&gt; {<br/>      let rows = row.forEach((e, j) =&gt; {<br/>       // e is a singular TileData class.<br/>        tiles.push(<br/>          &lt;Tile<br/>            location={e.location}<br/>            scale={e.scale}<br/>            key={e.key}<br/>            img = {e.img}<br/>          /&gt;<br/>        );<br/>      });<br/>    });<br/>    return tiles<br/>  }</span></pre><p id="18f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个呈现实际组件的函数，回过头来用下面的代码替换SwappableGrid的呈现方法:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="1dcc" class="me lg it nh b gy ns nt l nu nv">render() {<br/>    return (<br/>      &lt;GestureRecognizer style = {styles.gestureContainer}&gt;<br/>        {this.renderTiles(this.state.tileDataSource)<br/>      &lt;/GestureRecognizer&gt;<br/>    );</span></pre><p id="7e73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将把所有的图块组件放置到网格上，但不会告诉它们去哪里。结果就是一堆不同颜色的瓷砖叠在一起。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/aa5a95eadd72890b4d57579f85dae6e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xaapryww_zKQX9rjdpGmEQ.png"/></div></div></figure><p id="cccb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来很有希望，但是我们仍然需要把这些豆子放在正确的位置。要做到这一点，我们将不得不深入瓷砖组件内部，并挂接一些东西。现在它应该是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="79c8" class="me lg it nh b gy ns nt l nu nv">export default class Tile extends Component&lt;{}&gt; {</span><span id="746b" class="me lg it nh b gy nw nt l nu nv">render() {<br/>    return &lt;Animated.Image source = {this.props.img} style = {styles.tile}/&gt;;<br/>  }<br/>}</span></pre><p id="099a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到我用的是动画。图像，但我没有提供任何动画值。这里的语法有点挑战性，所以用这个替换<code class="fe ne nf ng nh b">style = {styles.tile}</code>:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="0d98" class="me lg it nh b gy ns nt l nu nv">// Replace style ={styles.tile} with this.</span><span id="fc1c" class="me lg it nh b gy nw nt l nu nv">style={[<br/>          styles.tile,<br/>          { transform: [{ translateX: this.props.location.x }, { translateY: this.props.location.y }, { scale: this.props.scale}] }<br/>        ]}</span></pre><p id="dd1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这为我们的样式添加了一组转换对象，这些对象与我们提供给Tile组件的道具相关联。<code class="fe ne nf ng nh b">translateX</code>和<code class="fe ne nf ng nh b">translateY</code>将控制图块在网格中的位置，而scale将控制图像的比例。现在它应该是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="4dc7" class="me lg it nh b gy ns nt l nu nv">export default class Tile extends Component&lt;{}&gt; {</span><span id="aa8e" class="me lg it nh b gy nw nt l nu nv">render() {<br/>    return &lt;Animated.Image source = {this.props.img} style={[<br/>          styles.tile,<br/>          { transform: [{ translateX: this.props.location.x }, { translateY: this.props.location.y }, { scale: this.props.scale}] }<br/>        ]}<br/>/&gt;<br/>  }<br/>}</span></pre><p id="d323" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe ne nf ng nh b">SwappableGrid</code>，我们将通过操纵<code class="fe ne nf ng nh b">tileDataSource.</code>中的<code class="fe ne nf ng nh b">location</code>属性，将每个图块组件动画化到其在网格上的正确位置。记住，<code class="fe ne nf ng nh b">location</code>是作为道具提供给图块组件的，因此操纵它将导致图块组件更新其位置。</p><p id="1d5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续把它复制到SwappableGrid中，然后我们再来讨论它。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="bcb4" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js</span><span id="c91c" class="me lg it nh b gy nw nt l nu nv">animateValuesToLocations() {<br/>    this.state.tileDataSource.forEach((row, i) =&gt; {<br/>      row.forEach((e, j) =&gt; {<br/>        Animated.timing(e.location, {<br/>          toValue: { x: TILE_WIDTH * i, y: TILE_WIDTH * j },<br/>          duration: 250<br/>        }).start();<br/>      });<br/>    });<br/>  }</span></pre><p id="81a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好了吗？</p><p id="6f26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将tileData元素的<code class="fe ne nf ng nh b">[i,j]</code>索引转换为XY位置，方法是将它们乘以TILE_WIDTH，然后使用Animated.timing. <a class="ae le" href="https://facebook.github.io/react-native/docs/animated" rel="noopener ugc nofollow" target="_blank">(或Animated.spring或Animated.decay等)将它们设置为该值。)</a></p><h2 id="eeda" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">快速笔记</h2><p id="d0be" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">您可以找到就在我们的样式表上方定义的TILE_WIDTH，如下所示:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="54f3" class="me lg it nh b gy ns nt l nu nv">let Window = Dimensions.get("window");<br/>let windowSpan = Math.min(Window.width, Window.height);<br/>let TILE_WIDTH = windowSpan / 6;</span></pre><p id="df44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以随意设置TILE_WIDTH，我决定将其设为设备较小尺寸的六分之一。</p><h2 id="4c3f" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">开始了。</h2><p id="2847" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">因为我想在组件安装后立即定位图块，所以我将像这样调用<code class="fe ne nf ng nh b">componentWillMount</code>中的<code class="fe ne nf ng nh b">animateValuesToLocation</code>:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="d2fc" class="me lg it nh b gy ns nt l nu nv">// In SwappableGrid.js</span><span id="2f91" class="me lg it nh b gy nw nt l nu nv">componentWillMount() {<br/>    this.animateValuesToLocations();<br/>  }</span></pre><p id="98a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果应该如下所示:(出于演示目的，持续时间设置为1000)</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/e9331279fdf0dc286de5cf06370392bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*F5Lyb9MPQD0n9ZXGHr3ijg.gif"/></div></div></figure><p id="68f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">酷毙了。</p><h2 id="d61c" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">味道平淡的低级啤酒</h2><p id="fba9" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">现在剩下要做的就是读取我们滑动手势的方向并执行交换。我已经成功地使用了<a class="ae le" href="https://www.npmjs.com/package/react-native-swipe-gestures" rel="noopener ugc nofollow" target="_blank">react-native-swipe-gestures</a>来实现这一点，但它似乎没有得到积极的维护。您可以使用React-Native PanGestures编写自己的代码，但我们将把它留到以后再说。可以说，我仍然在寻找好的手势识别替代方案。</p><p id="e6fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经注意到，React原生滑动手势提供了一个手势识别器组件，该组件包装了我们试图从其接收触摸的任何视图。在这种情况下，我们的<code class="fe ne nf ng nh b">SwappableGrid.</code></p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="a97e" class="me lg it nh b gy ns nt l nu nv">&lt;GestureRecognizer<br/>            style={styles.gestureContainer}<br/>            onSwipe={(direction, state) =&gt; this.onSwipe(direction, state)}<br/>          &gt;<br/>            {this.renderTiles(this.state.tileDataSource)}<br/>          &lt;/GestureRecognizer&gt;.</span></pre><p id="7f44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在的任务是配置手势识别器的<code class="fe ne nf ng nh b">onSwipe</code>道具来执行交换。这意味着我们需要:</p><ul class=""><li id="e3b6" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">计算收到推送的分块的索引(数学)</li><li id="774d" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">根据滑动方向执行交换(switch语句)</li></ul><p id="c19c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的解决方案是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="1797" class="me lg it nh b gy ns nt l nu nv">onSwipe(gestureName, gestureState) {</span><span id="ec75" class="me lg it nh b gy nw nt l nu nv">// Swipe direction constants.<br/>const { SWIPE_UP, SWIPE_DOWN, SWIPE_LEFT, SWIPE_RIGHT } = swipeDirections;</span><span id="5e6a" class="me lg it nh b gy nw nt l nu nv">let initialGestureX = gestureState.x0;<br/>let initialGestureY = gestureState.y0;</span><span id="834d" class="me lg it nh b gy nw nt l nu nv">let i = Math.round((initialGestureX - 0.5 * TILE_WIDTH) / TILE_WIDTH);</span><span id="f073" class="me lg it nh b gy nw nt l nu nv">let j = Math.round((initialGestureY - 0.5 * TILE_WIDTH) / TILE_WIDTH);</span><span id="8af1" class="me lg it nh b gy nw nt l nu nv">switch (gestureName) {<br/>        case SWIPE_UP:<br/>          break;<br/>        case SWIPE_DOWN:<br/>          break;<br/>        case SWIPE_LEFT:<br/>          break;<br/>        case SWIPE_RIGHT:<br/>          break;<br/>      }<br/>  }</span></pre><p id="ca2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好，但是我忽略了一个关键点:</p><blockquote class="nx ny nz"><p id="06fd" class="jq jr oa js b jt ju jv jw jx jy jz ka ob kc kd ke oc kg kh ki od kk kl km kn im bi translated">手势位置是从手势识别器的父组件测量的。</p></blockquote><p id="bb26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还记得，我们的可切换网格的父组件是GameScreen。事实上，这是目前GameScreen中唯一呈现的东西。这意味着为了在网格坐标系中找到<code class="fe ne nf ng nh b">initialGestureX</code>和<code class="fe ne nf ng nh b">initialGestureY</code>，我们需要在它的视图中减去网格的原点。</p><p id="d165" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过使用一个名为<code class="fe ne nf ng nh b">onLayout</code>的可选属性来实现这一点，您可以将该属性提供给任何视图，以便在视图首次挂载时测量其属性。</p><p id="2c78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像这样向手势识别器提供<code class="fe ne nf ng nh b">onLayout</code>:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="5c82" class="me lg it nh b gy ns nt l nu nv">&lt;GestureRecognizer<br/>         style={styles.gestureContainer}<br/>         onLayout={this.onLayout.bind(this)}      <br/>         onSwipe={(direction, state) =&gt; this.onSwipe(direction, state)}<br/>          &gt;<br/>               {this.renderTiles(this.state.tileDataSource)}<br/>          &lt;/GestureRecognizer&gt;</span></pre><p id="2802" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并这样定义它:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="f3f7" class="me lg it nh b gy ns nt l nu nv">onLayout(event) {<br/>    this.gridOrigin = [event.nativeEvent.layout.x, event.nativeEvent.layout.y];<br/>}</span></pre><p id="c183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将网格的原点存储为<code class="fe ne nf ng nh b">this.gridOrigin</code>，我们可以用它来计算滑动的指数。回到你的<code class="fe ne nf ng nh b">onSwipe</code>方法，从你的初始手势中减去gridOrigin的x和y分量，就像这样:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="936a" class="me lg it nh b gy ns nt l nu nv">onSwipe(gestureName, gestureState) {</span><span id="d422" class="me lg it nh b gy nw nt l nu nv">const { SWIPE_UP, SWIPE_DOWN, SWIPE_LEFT, SWIPE_RIGHT } = swipeDirections;</span><span id="a405" class="me lg it nh b gy nw nt l nu nv">let initialGestureX = gestureState.x0;<br/>let initialGestureY = gestureState.y0;</span><span id="d2bb" class="me lg it nh b gy nw nt l nu nv">// RIGHT HERE!<br/>let i = Math.round((initialGestureX - this.gridOrigin[0] - 0.5 * TILE_WIDTH) / TILE_WIDTH);</span><span id="49f1" class="me lg it nh b gy nw nt l nu nv">// ALSO HERE!<br/>let j = Math.round((initialGestureY - this.gridOrigin[1] - 0.5 * TILE_WIDTH) / TILE_WIDTH);</span><span id="b50d" class="me lg it nh b gy nw nt l nu nv">switch (gestureName) {<br/>        case SWIPE_UP:<br/>          break;<br/>        case SWIPE_DOWN:<br/>          break;<br/>        case SWIPE_LEFT:<br/>          break;<br/>        case SWIPE_RIGHT:<br/>          break;<br/>      }<br/>  }</span></pre><p id="4e30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完美！现在，我们能够从我们的SwappableGrid中准确地检测到滑动的索引。</p><h2 id="db24" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">交换</h2><p id="3007" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我们已经做了很好的准备工作，所以这一部分会很简单。</p><p id="1f89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了执行实际的交换，我们将编写一个单独的方法来获取交换的索引和方向。看看</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="fd0b" class="me lg it nh b gy ns nt l nu nv">swap(i,j,di,dj){</span><span id="dd51" class="me lg it nh b gy nw nt l nu nv">const swapStarter = this.state.tileDataSource[i][j];<br/>const swapEnder = this.state.tileDataSource[i + di][j + dj];</span><span id="5fca" class="me lg it nh b gy nw nt l nu nv">this.state.tileDataSource[i][j] = swapEnder;<br/>this.state.tileDataSource[i+di][j+dj] = swapStarter;</span><span id="a4ee" class="me lg it nh b gy nw nt l nu nv">this.animateValuesToLocations()<br/>}</span></pre><p id="b110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了了解这里到底发生了什么，我们应该分解一下<code class="fe ne nf ng nh b">swap</code>的论点</p><ul class=""><li id="b7e1" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated"><code class="fe ne nf ng nh b">i,j</code> —在其上注册交换的区块的索引。</li><li id="b3a8" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated"><code class="fe ne nf ng nh b">di,dj</code> —瓷砖需要在<code class="fe ne nf ng nh b">i</code>或<code class="fe ne nf ng nh b">j</code>方向移动多少。</li></ul><p id="9201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用这个信息来交换注册交换的元素和交换指向的元素的位置。回到您的<code class="fe ne nf ng nh b">onSwipe</code>函数，在switch语句中添加以下对<code class="fe ne nf ng nh b">swap</code>的调用。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="a404" class="me lg it nh b gy ns nt l nu nv">switch (gestureName) {<br/>        case SWIPE_UP:</span><span id="d5ac" class="me lg it nh b gy nw nt l nu nv">this.swap(i,j,0,-1)</span><span id="0369" class="me lg it nh b gy nw nt l nu nv">break;<br/>        case SWIPE_DOWN:</span><span id="5725" class="me lg it nh b gy nw nt l nu nv">this.swap(i,j,0,1)</span><span id="8184" class="me lg it nh b gy nw nt l nu nv">break;<br/>        case SWIPE_LEFT:</span><span id="9dbc" class="me lg it nh b gy nw nt l nu nv">this.swap(i,j,-1,0)</span><span id="cd23" class="me lg it nh b gy nw nt l nu nv">break;<br/>        case SWIPE_RIGHT:</span><span id="146a" class="me lg it nh b gy nw nt l nu nv">this.swap(i,j,1,0)</span><span id="a70a" class="me lg it nh b gy nw nt l nu nv">break;</span></pre><p id="213f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，向上滑动具有负的<code class="fe ne nf ng nh b">dj</code>值，因为索引是从左上角开始测量的。还记得<code class="fe ne nf ng nh b">animateValuesToLocation</code>根据元素在<code class="fe ne nf ng nh b">tileDataSource</code>数组中的位置来定位元素。由于元素被交换了，一旦动画运行，它们将会假定彼此的位置。</p><p id="d9a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在它应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/2730ea6d51662ef3c3bbdeaf0286d65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I_ML9vtuxZ_4PW5-Ynj-YA.gif"/></div></div></figure><h2 id="d532" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">看起来不错，但是…</h2><p id="194f" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">在大多数iOS设备上，这将运行得相当流畅。尝试在Android上运行它，你可能会看到动画延迟或跳过帧。这有几个原因:</p><h2 id="ef7d" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">原因一:效率低下</h2><p id="b4dc" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">您可能已经注意到，即使只有两个图块被动画显示，我们的<code class="fe ne nf ng nh b">animateValuesToLocations</code>函数也会更新网格上的每一个图块。当我们需要布置网格时，这很有用，但是当我们只制作两个物体的动画时，这就太过分了。</p><p id="c79e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们修复我们的交换函数，以便它只激活参与交换的图块:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="928b" class="me lg it nh b gy ns nt l nu nv">swap(i,j,dx,dy){</span><span id="ebad" class="me lg it nh b gy nw nt l nu nv">let newData = this.state.tileDataSource</span><span id="176d" class="me lg it nh b gy nw nt l nu nv">const swapStarter = this.state.tileDataSource[i][j];<br/>    const swapEnder = this.state.tileDataSource[i + dx][j + dy];</span><span id="6f87" class="me lg it nh b gy nw nt l nu nv">// Swap the tiles in the data source<br/>    newData[i][j] = swapEnder;<br/>    newData[i+dx][j+dy] = swapStarter;</span><span id="c7ae" class="me lg it nh b gy nw nt l nu nv">// Animate the two tiles in parallel<br/>Animated.parallel([<br/>      Animated.timing(swapStarter.location, {<br/>        toValue: {x: TILE_WIDTH*(i+dx),y: TILE_WIDTH*(j+dy)},<br/>        duration: 120,<br/>      }),<br/>      Animated.timing(swapEnder.location, {<br/>        toValue: {x: TILE_WIDTH*i,y: TILE_WIDTH*j},<br/>        duration: 120,<br/>      }),<br/>    ]).start()</span><span id="b550" class="me lg it nh b gy nw nt l nu nv">// Set state with newData<br/>   this.setState({tileDataSource: newData})</span><span id="3103" class="me lg it nh b gy nw nt l nu nv">// No need to call animateValuesToLocations() <br/> <br/>}</span></pre><p id="0597" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加了一个动画块来并行执行交换。这意味着我们实际上只运行了一个动画块，而不是25个(太棒了！)这也意味着我们可以删除<code class="fe ne nf ng nh b">this.animateValuesToLocation</code>，因为我们已经完成了动画。</p><h2 id="bd00" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">原因二:原生驱动</h2><p id="eb5d" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我们需要做的最后一件事是确保我们使用的是本地驱动程序。为此，只需将<code class="fe ne nf ng nh b">useNativeDriver: true</code>添加到动画属性中。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="d9c6" class="me lg it nh b gy ns nt l nu nv">// Animate the two tiles in parallel<br/>Animated.parallel([<br/>      Animated.timing(swapStarter.location, {<br/>        toValue: {x: TILE_WIDTH*(i+dx),y: TILE_WIDTH*(j+dy)},<br/>        duration: 120,<br/>        useNativeDriver: true</span><span id="3a33" class="me lg it nh b gy nw nt l nu nv">}),<br/>      Animated.timing(swapEnder.location, {<br/>        toValue: {x: TILE_WIDTH*i,y: TILE_WIDTH*j},<br/>        duration: 120,<br/>        useNativeDriver: true}),<br/>    ]).start()</span></pre><p id="450c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里阅读更多关于使用原生驱动<a class="ae le" href="https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated" rel="noopener ugc nofollow" target="_blank">的内容，但这里是官方文档的要点:</a></p><blockquote class="nx ny nz"><p id="816a" class="jq jr oa js b jt ju jv jw jx jy jz ka ob kc kd ke oc kg kh ki od kk kl km kn im bi translated">动画API的设计考虑了一个非常重要的约束，它是可序列化的。这意味着我们可以在动画开始之前就将有关动画的所有内容发送到本机，并允许本机代码在UI线程上执行动画，而不必在每一帧上都通过桥。这非常有用，因为一旦动画开始，JS线程可以被阻塞，动画仍然可以流畅地运行。</p></blockquote><p id="f581" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将动画推送到原生UI线程将使我们的动画运行得更快，但这也意味着我们所有的动画都需要在原生上运行。因此，确保您返回到<code class="fe ne nf ng nh b">animateValuesToLocation</code>并设置<code class="fe ne nf ng nh b">useNativeDriver = true</code></p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="10b8" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js</span><span id="31da" class="me lg it nh b gy nw nt l nu nv">animateValuesToLocations() {<br/>    this.state.tileDataSource.forEach((row, i) =&gt; {<br/>      row.forEach((elem, j) =&gt; {<br/>        Animated.timing(elem.location, {<br/>          toValue: { x: TILE_WIDTH * i, y: TILE_WIDTH * j },<br/>          duration: 250,<br/>          useNativeDriver: true &lt;----- HERE<br/>        }).start();<br/>      });<br/>    });<br/>  }</span></pre><h2 id="0f5b" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">配对</h2><p id="c236" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">现在，我们应该有一个简单的网格，使用滑动手势交换豆子。接下来，我们必须检测匹配，并在新的豆子落入它们的位置时将它们消灭掉。让我们重温一下<code class="fe ne nf ng nh b">Images.js</code></p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="9274" class="me lg it nh b gy ns nt l nu nv">// Images.js</span><span id="7c3d" class="me lg it nh b gy nw nt l nu nv">// Beans<br/>export const PINK_BEAN = require("../assets/PinkJellyBean.png");<br/>export const PURPLE_BEAN = require("../assets/PurpleJellyBean.png");<br/>export const BLUE_BEAN = require("../assets/BlueJellyBean.png");<br/>export const ORANGE_BEAN = require("../assets/OrangeJellyBean.png");<br/>export const GREEN_BEAN = require("../assets/GreenJellyBean.png");<br/>export const YELLOW_BEAN = require("../assets/YellowJellyBean.png");<br/>export const  RED_BEAN = require("../assets/RedJellyBean.png");</span><span id="7642" class="me lg it nh b gy nw nt l nu nv">export const BEANS = [PINK_BEAN,PURPLE_BEAN,BLUE_BEAN,ORANGE_BEAN,GREEN_BEAN,YELLOW_BEAN,RED_BEAN]</span></pre><p id="3181" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">信不信由你，我可以直接比较这些图像常数来决定它们是否匹配。因此，下面的代码可以工作:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="1049" class="me lg it nh b gy ns nt l nu nv">isMatch(imageOne,ImageTwo) {<br/>  if imageOne == imageTwo {<br/>    return true<br/>   } else {<br/>     return false <br/>   }  <br/>}</span></pre><p id="4aac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但有时我们可能希望根据其他标准来比较图像。如果你玩过最初的<a class="ae le" href="https://itunes.apple.com/us/app/jellybean-jam/id1436558861?mt=8" rel="noopener ugc nofollow" target="_blank">软糖果酱</a>(我推荐你这么做)，连续三罐也算一次比赛，不管颜色如何。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/f725e512f96921552ade8300ac4a0b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ncT17m4SbnJEmp4d5M84uw.gif"/></div></div></figure><p id="e9f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，直接比较图像并不总是有效的。您可以编写一些助手函数来解决这些情况，但我个人不建议这样做。</p><p id="6c83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得成功和可伸缩性，我们将把每个图像重新定义为存储图像属性的对象。为此，将以下代码添加到<code class="fe ne nf ng nh b">Images.js</code></p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="6588" class="me lg it nh b gy ns nt l nu nv">// Enum<br/>const COLORS = {<br/>  BLUE: 1,<br/>  RED: 2,<br/>  YELLOW: 3,<br/>  PINK: 4,<br/>  PURPLE: 5,<br/>  ORANGE: 6,<br/>  GREEN: 7,<br/>}<br/>export const PINK_BEAN_OBJ =  {<br/>  image: PINK_BEAN,<br/>  color: COLORS.PINK,<br/>  isJar: false<br/>}</span><span id="05fb" class="me lg it nh b gy nw nt l nu nv">export const BLUE_BEAN_OBJ=  {<br/>  image: BLUE_BEAN,<br/>  color: COLORS.BLUE,<br/>  isJar: false<br/>}</span><span id="cbe2" class="me lg it nh b gy nw nt l nu nv">export const RED_BEAN_OBJ =  {<br/>  image: RED_BEAN,<br/>  color: COLORS.RED,<br/>  isJar: false<br/>}</span><span id="7cb8" class="me lg it nh b gy nw nt l nu nv">export const PURPLE_BEAN_OBJ =  {<br/>  image: PURPLE_BEAN,<br/>  color: COLORS.PURPLE,<br/>  isJar: false<br/>}</span><span id="fdac" class="me lg it nh b gy nw nt l nu nv">export const YELLOW_BEAN_OBJ =  {<br/>  image: YELLOW_BEAN,<br/>  color: COLORS.YELLOW,<br/>  isJar: false<br/>}</span><span id="8c49" class="me lg it nh b gy nw nt l nu nv">export const GREEN_BEAN_OBJ =  {<br/>  image: GREEN_BEAN,<br/>  color: COLORS.GREEN,<br/>  isJar: false<br/>}</span><span id="ab18" class="me lg it nh b gy nw nt l nu nv">export const ORANGE_BEAN_OBJ =  {<br/>  image: ORANGE_BEAN,<br/>  color: COLORS.ORANGE,<br/>  isJar: false<br/>}</span><span id="e7ab" class="me lg it nh b gy nw nt l nu nv">export const BEAN_OBJS = [PINK_BEAN_OBJ,PURPLE_BEAN_OBJ,BLUE_BEAN_OBJ,ORANGE_BEAN_OBJ,GREEN_BEAN_OBJ,YELLOW_BEAN_OBJ,RED_BEAN_OBJ]</span></pre><p id="898b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们的资产对象现在存储颜色、图像和一个布尔变量，该变量告诉我们图像是否是一个罐子。您可以使用这种策略来存储关于您的图像的所有类型的元数据，但这是我们目前所需要的。</p><h2 id="2127" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">让我们稍微整理一下</h2><p id="df1d" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">为了区分我们的常规图像资产和资产对象，我们使用了格式<code class="fe ne nf ng nh b">IMG_NAME_OBJS.</code>，我们还导出了一个名为<code class="fe ne nf ng nh b">BEAN_OBJS</code>的所有这些对象的数组，以取代我们到目前为止一直使用的<code class="fe ne nf ng nh b">BEANS</code>数组。</p><p id="c906" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe ne nf ng nh b">SwappableGrid</code>中，导入<code class="fe ne nf ng nh b">BEAN_OBJS</code>而不是<code class="fe ne nf ng nh b">BEANS</code>，并用<code class="fe ne nf ng nh b">let randomBean = BEAN_OBJS[int]</code>替换行<code class="fe ne nf ng nh b">let randomBeans = BEANS[int]</code></p><p id="65c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，不要忘记确保更新您的TileData类，以反映我们现在传递的是一个图像对象，而不仅仅是一个图像:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="db8f" class="me lg it nh b gy ns nt l nu nv">// TileData.js</span><span id="34c9" class="me lg it nh b gy nw nt l nu nv">export class TileData {<br/>    constructor(imgObj, key) {<br/>    this.key = key;<br/>    this.location = new Animated.ValueXY();<br/>    this.imgObj = imgObj; &lt;------ Used to be this.image<br/>    this.scale = new Animated.Value(1);<br/>  }<br/>}</span></pre><p id="2cef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们准备开始检测匹配。</p><h2 id="f90c" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">查找匹配项</h2><p id="d9d4" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我们将通过与网格上的坐标相对应的索引数组来定义“匹配”。例如，如果第一行的前三个牌是匹配的，则记录如下:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="1143" class="me lg it nh b gy ns nt l nu nv">firstThreeOfFirstRow = [[0,0],[0,1],[0,2]]</span></pre><p id="0240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了定义匹配的标准，我们将在<code class="fe ne nf ng nh b">GridApi.js</code>中放置一个名为<code class="fe ne nf ng nh b">isMatch</code>的函数，并确保它执行以下操作:</p><ul class=""><li id="e847" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">如果任一对象为<code class="fe ne nf ng nh b">null</code>，则返回<code class="fe ne nf ng nh b">false</code></li><li id="2f36" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">如果图像相同，则返回<code class="fe ne nf ng nh b">true</code>。</li><li id="0c5f" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">如果图像都是罐子，则返回<code class="fe ne nf ng nh b">true</code>。</li></ul><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="e78a" class="me lg it nh b gy ns nt l nu nv">// In GridApi.js</span><span id="3811" class="me lg it nh b gy nw nt l nu nv">export const isMatch = (objOne,objTwo) =&gt; {</span><span id="14d3" class="me lg it nh b gy nw nt l nu nv">if (objOne != null &amp;&amp; objTwo != null) {<br/>  if (objOne.image == objTwo.image) {<br/>    return true<br/>  } else if (objOne.isJar &amp;&amp; objTwo.isJar) {<br/>    return true<br/>  } else {<br/>    return false<br/>  }<br/> }<br/>}</span></pre><p id="958d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们的对象也存储它是否是一个罐子，所以我们可以很容易地比较我们正在查看的两个对象是罐子还是仅仅是同一个图像。我们检查null，因为这将有助于在下一节中处理我们的一个边缘情况。</p><h2 id="f12e" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">匹配算法</h2><p id="1402" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">既然我们已经完全具备了构成匹配和不匹配的标准，我们就可以开始遍历数据源并收集匹配。</p><p id="0512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于网格的维度不够大，无法在同一行中进行两次匹配，我们可以假设在给定的行或列中只有一次匹配。我将把这个方法推广到同一行或同一列中的多个匹配，作为一个练习留给读者。</p><p id="a73c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计划是这样的:</p><ul class=""><li id="bbd5" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">记录我们行中第一个图块的对象和索引。</li><li id="249a" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">将索引添加到名为<code class="fe ne nf ng nh b">potentialMatch</code>的空数组中</li><li id="d052" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">检查下一个图像是否匹配。</li><li id="7e22" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">将索引添加到数组中。</li><li id="6223" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">当我们发现下一个图块与我们正在计数的图像不匹配时，我们会检查潜在匹配的数组是否大于或等于3。</li><li id="ca72" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">如果我们找到一个有效的匹配，将它添加到名为<code class="fe ne nf ng nh b">matches</code>的匹配数组中</li><li id="2d1d" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">通过用下一个元素的索引填充来重置<code class="fe ne nf ng nh b">potentialMatch</code>数组</li><li id="d3fb" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">对每一行都这样做。</li></ul><p id="5628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="88ee" class="me lg it nh b gy ns nt l nu nv">// Iterates through each row to look for a match.<br/>export const checkRowsForMatch = (tileData) =&gt; {<br/>    // Store the array of matches<br/>    let matches = []</span><span id="79d9" class="me lg it nh b gy nw nt l nu nv">// Iterate through the rows from top to bottom.<br/>    for (var j = 0; j &lt; 5; j++) {<br/>      // Record the first index in the row.<br/>      let firstIndex = [0,j]<br/>      // Add the index to our potentialMatch<br/>      let potentialMatch = [firstIndex]<br/>      // Record the imgage object corresponding to the first element in our potentialMatch<br/>      let currentImageObj = tileData[0][j].imgObj</span><span id="dc89" class="me lg it nh b gy nw nt l nu nv">// Traverse the elements of the row.<br/>      for (var i = 0; i &lt; 5; i++) {</span><span id="5662" class="me lg it nh b gy nw nt l nu nv">// Get the object stored in the next tile. Set to null if the next index is out of range.<br/>      let nextTileObj = (i+1) &lt; 5 ? tileData[i+1][j].imgObj: null</span><span id="48d6" class="me lg it nh b gy nw nt l nu nv">if (isMatch(currentImageObj,nextTileObj)) {<br/>        // Add the next index to our potential Match.<br/>        potentialMatch.push([i+1,j])</span><span id="2e40" class="me lg it nh b gy nw nt l nu nv">} else {<br/>        // Check to see if the potentialMatch is greater than 3.<br/>        if (potentialMatch.length &gt;= 3) {<br/>          matches.push(potentialMatch)<br/>        }<br/>          // Reset the first index.<br/>          firstIndex = [i+1,j]<br/>          // Add it to the potentialMatch<br/>          potentialMatch = [firstElement]<br/>          // Reset the current imageObj to that of the next image.<br/>          currentImageObj = (i+1) &lt; 5 ? tileData[i+1][j].imgObj: null<br/>      }<br/>    }<br/>  }<br/>  return matches<br/>}</span></pre><p id="6a04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还记得我们如何给我们的<code class="fe ne nf ng nh b">isMatch</code>函数添加一个空检查吗？原因如下:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="b661" class="me lg it nh b gy ns nt l nu nv">// Assigning next tileObject<br/>let nextTileObj = (i+1) &lt; 5 ? tileData[i+1][j].imgObj: null</span></pre><p id="7ec5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们的索引超出范围，我们使用这个三元运算符返回null。这允许我们安全地查看行中的下一个元素。</p><p id="e547" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了检查每一列，我们可以使用相同的算法并交换I和j的角色，如下所示:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="0f4c" class="me lg it nh b gy ns nt l nu nv">// Iterates through each row to look for a match.<br/>export const checkColsForMatch = (tileData) =&gt; {<br/>    // Store the array of matches<br/>    let matches = []</span><span id="0a79" class="me lg it nh b gy nw nt l nu nv">// Iterate through the rows from top to bottom.<br/>    for (var i = 0; i &lt; 5; i++) {<br/>      // Record the first index in the row.<br/>      let firstIndex = [i,0]<br/>      // Add the index to our potentialMatch<br/>      let potentialMatch = [firstIndex]<br/>      // Record the imgage object corresponding to the first element in our potentialMatch<br/>      let currentImageObj = tileData[i][0].imgObj</span><span id="6f3e" class="me lg it nh b gy nw nt l nu nv">// Traverse the elements of the row.<br/>      for (var j = 0; j &lt; 5; j++) {</span><span id="cc7c" class="me lg it nh b gy nw nt l nu nv">// Get the object stored in the next tile. Set to null if the next index is out of range.<br/>      let nextTileObj = (j+1) &lt; 5 ? tileData[i][j+1].imgObj: null</span><span id="401d" class="me lg it nh b gy nw nt l nu nv">if (isMatch(currentImageObj,nextTileObj)) {<br/>        // Add the next index to our potential Match.<br/>        potentialMatch.push([i,j+1])</span><span id="f924" class="me lg it nh b gy nw nt l nu nv">} else {<br/>        // Check to see if the potentialMatch is greater than 3.<br/>        if (potentialMatch.length &gt;= 3) {<br/>          matches.push(potentialMatch)<br/>        }<br/>          // Reset the first index.<br/>          firstIndex = [i,j+1]<br/>          // Add it to the potentialMatch<br/>          potentialMatch = [firstIndex]<br/>          // Reset the current imageObj to that of the next image.<br/>          currentImageObj = (j+1) &lt; 5 ? tileData[i][j+1].imgObj: null<br/>      }<br/>    }<br/>  }<br/>  return matches<br/>}</span></pre><h2 id="3083" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">尝试一下</h2><p id="c455" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">在<code class="fe ne nf ng nh b">SwappableGrid.js</code>中，导入我们的两个匹配函数，并在<code class="fe ne nf ng nh b">viewDidLoad()</code>中调用它们。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="99e0" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js inside swap(i,j,dx,dy)</span><span id="605a" class="me lg it nh b gy nw nt l nu nv">console.log("Row Matches",checkRowsForMatch(newData))<br/>console.log("Column Matches",checkColsForMatch(newData))</span></pre><p id="dad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">摆弄它，确保数据看起来是正确的。作为参考，如果您的网格看起来像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8b8248832344768b3ef0684e9c4a4e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*fOAD_LIE3Tq2uYNny9RARg.png"/></div></figure><p id="eb1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么输出应该是这样的:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="60ee" class="me lg it nh b gy ns nt l nu nv">Row Matches = [[[0,1],[1,1],[2,1]]]<br/>Column Matches = [[[2,0],[2,1],[2,2]],[[3,1],[3,2],[3,3],[3,4]]]</span></pre><p id="04a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了方便起见，让我们也创建一个小助手函数，通过调用两个<code class="fe ne nf ng nh b">checkRowsForMatch</code> &amp; <code class="fe ne nf ng nh b">checkColsForMatch.</code>来返回所有匹配</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="165a" class="me lg it nh b gy ns nt l nu nv">export const getAllMatches = (tileData) =&gt; {</span><span id="3cbc" class="me lg it nh b gy nw nt l nu nv">let rowMatches = checkRowsForMatch(tileData)<br/>  let colMatches = checkColsForMatch(tileData)</span><span id="d355" class="me lg it nh b gy nw nt l nu nv">return [...rowMatches,...colMatches]</span><span id="637b" class="me lg it nh b gy nw nt l nu nv">}</span></pre><p id="7683" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">别忘了在<code class="fe ne nf ng nh b">SwappableGrid.</code>里面导入<code class="fe ne nf ng nh b">getAllMatches</code></p><h2 id="1e16" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">处理匹配</h2><p id="0b67" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">那么当我们找到匹配时会发生什么呢？嗯，我们首先必须删除匹配的beans，使列就位，然后检查其他匹配。当我们完成时，它将看起来像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/2be9b2953ea0d26bd1e404d6e807f979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d8psUhECvHiTnSa24s9ojQ.gif"/></div></div></figure><h2 id="d14f" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">冷凝塔</h2><p id="964d" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我把刷新棋盘和填充火柴留下的空白空间的过程称为“浓缩”列。这是因为一个有空的空间的柱子必须“压缩”才能腾出空间让新的豆子放在上面。</p><p id="521f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们要在<code class="fe ne nf ng nh b">GridApi.js</code>中定义这个函数，我们需要将我们的tileDataSource传递给它。然而，它还需要知道哪些索引是匹配的一部分。让我们使用<code class="fe ne nf ng nh b">TileData</code>类来标记哪些图块需要更新，而不是同时传递图块数据和匹配。回到<code class="fe ne nf ng nh b">TileData.js</code>，添加一个名为<code class="fe ne nf ng nh b">markedAsMatch.</code>的新布尔属性</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="15a7" class="me lg it nh b gy ns nt l nu nv">// In TileData.js</span><span id="88d3" class="me lg it nh b gy nw nt l nu nv">export class TileData {<br/>  constructor(imgObj, key) {<br/>    this.key = key;<br/>    this.markedAsMatch = false &lt;---- HERE<br/>    this.location = new Animated.ValueXY();<br/>    this.imgObj = imgObj;<br/>    this.scale = new Animated.Value(1);<br/>  }<br/>}</span></pre><p id="af74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们将创建一个函数，该函数获取我们的图块数据源以及匹配项，并标记它们以便更新。在<code class="fe ne nf ng nh b">gridApi</code>中，我们需要以下内容:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="1fd3" class="me lg it nh b gy ns nt l nu nv">// In gridApi.js</span><span id="ed65" class="me lg it nh b gy nw nt l nu nv">export const markAsMatch = (matches,tileData) =&gt; {<br/>  matches.forEach(match =&gt; {<br/>    match.forEach(e =&gt; {<br/>    let i = e[0]<br/>    let j = e[1]<br/>    tileData[i][j].markedAsMatch = true})<br/>  })<br/>}</span></pre><p id="9c78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们要传递一个匹配数组，所以我们需要两个语句。一个用于提取匹配，另一个用于遍历匹配的元素。</p><p id="89e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们的tile数据源知道哪些元素是匹配的一部分，我们就可以开始压缩列了。在最一般的意义上，我们通过遍历列，并根据每个bean下面的空白空间的数量向下移动每个bean来实现这一点。</p><p id="d692" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果一个bean位于<code class="fe ne nf ng nh b">[2,1]</code>并且在两个空格之上，那么它将被移动到<code class="fe ne nf ng nh b">[2,3]</code>等等。这就是事情的真相:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="c31a" class="me lg it nh b gy ns nt l nu nv">// DON'T FORGET TO IMPORT TILE WIDTH:<br/>import {TILE_WIDTH} from "../components/SwappableGrid"</span><span id="719d" class="me lg it nh b gy nw nt l nu nv">export const condenseColumns = (tileData) =&gt; {<br/>    // Get number of rows and number of columns.<br/>    let numOfRows = tileData[0].length<br/>    let numOfCols = tileData.length</span><span id="129f" class="me lg it nh b gy nw nt l nu nv">let spotsToFill = 0;<br/>    for (let i = 0; i &lt; numOfRows; i++) {<br/>      spotsToFill = 0;</span><span id="837a" class="me lg it nh b gy nw nt l nu nv">// Iterate through each column<br/>      for (let j = numOfCols-1; j &gt;= 0; j--) {</span><span id="90f7" class="me lg it nh b gy nw nt l nu nv">// Check to see if the element is a spot that needs filling.<br/>        if (tileData[i][j].markedAsMatch == true) {<br/>          // Increment the spots to fill since we found a spot to fill.<br/>          spotsToFill++;<br/>          // Place the location above the top of the screen for when it "falls"<br/>          tileData[i][j].location.setValue({<br/>            x: TILE_WIDTH * i,<br/>            y: -4 * TILE_WIDTH<br/>          });</span><span id="3ab5" class="me lg it nh b gy nw nt l nu nv">} else if (spotsToFill &gt; 0) {<br/>          // Move bean downward<br/>          const currentSpot = tileData[i][j];<br/>          const newSpot = tileData[i][j + spotsToFill];</span><span id="23fc" class="me lg it nh b gy nw nt l nu nv">tileData[i][j] = newSpot;<br/>          tileData[i][j + spotsToFill] = currentSpot;<br/>        }<br/>      }<br/>    }<br/>  }</span></pre><p id="8142" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，当我找到一个已被标记为匹配的图块时，我不仅增加了<code class="fe ne nf ng nh b">spotsToFill</code>的值，还将bean放置在屏幕上方四个图块宽度的位置。这确保了一旦动画出现，豆子看起来是从上面“落下”的。这也意味着你将不得不在顶层从我们的<code class="fe ne nf ng nh b">SwappableGrid</code>中导入<code class="fe ne nf ng nh b">TILE_WIDTH</code>。</p><p id="e61b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将下面的代码一直放在<code class="fe ne nf ng nh b">SwappableGrid.js</code>内的<code class="fe ne nf ng nh b">swap</code>函数的末尾来尝试一下</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="b81a" class="me lg it nh b gy ns nt l nu nv">// In SwappableGrid at the end of swap(i,j,di,dj)</span><span id="449d" class="me lg it nh b gy nw nt l nu nv">let allMatches = getAllMatches(this.state.tileDataSource)</span><span id="862b" class="me lg it nh b gy nw nt l nu nv">if (allMatches.length != 0) {<br/>      markAsMatch(matches,this.state.tileDataSource)<br/>      condenseColumns(this.state.tileDataSource)<br/>      this.animateValuesToLocations()<br/>    }</span></pre><p id="c399" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里所做的就是提取所有匹配，标记它们以便更新，压缩列，然后执行动画。结果相当酷。看一看:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/696aa59d0422249608e0a2e66ed58b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DEhM6NhSvdbNlifeL3qVJQ.gif"/></div></div></figure><p id="635e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进展不错，但我们仍有一些问题:</p><ul class=""><li id="5a63" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">新豆子不会变色(我们知道)</li><li id="0888" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">所有以前的匹配都被视为仍然匹配。(你能猜到为什么吗？)</li><li id="8469" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">动画甚至在交换完成之前就出现了。</li></ul><p id="c2f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之前的匹配即使在处理后仍然保持动画的原因是因为我还没有将<code class="fe ne nf ng nh b">markedAsMatch</code>属性重置回(简单修复)然而，如果我要用新的颜色补充网格，我还有很多工作要做。</p><h2 id="6d7c" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">改变颜色</h2><p id="0b3a" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">到目前为止，我们还没有对<code class="fe ne nf ng nh b">setState</code>进行一次调用，尽管整个网格依赖于一个状态变量<code class="fe ne nf ng nh b">tileDataSource.</code>这是因为我们对tileDataSource所做的只是…</p><ol class=""><li id="8aa8" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn of nb nc nd bi translated">交换数组中的元素</li><li id="0c6c" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn of nb nc nd bi translated">操纵动画值</li></ol><p id="8b53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，自从我们的组件第一次挂载以来，<code class="fe ne nf ng nh b">this.renderTiles</code>甚至还没有被调用过。不相信我？继续把一个<code class="fe ne nf ng nh b">console.log("rendering Tiles")</code>放在里面，然后去玩网格。我会等…</p><p id="7d25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是现在我们必须考虑如何改变在我们的tile组件上呈现的图像。在我们这样做之前，让我们先提醒自己图像是如何出现。这一切都是从<code class="fe ne nf ng nh b">renderTiles</code>开始的，当时我们从<code class="fe ne nf ng nh b">tileDataSource:</code>中提供了图片作为道具</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="6344" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid.js<br/>renderTiles(tileData) {<br/>    console.log("Render Tiles Called")<br/>    let tiles = [];<br/>    tileData.forEach((row, i) =&gt; {<br/>      let rows = row.forEach((e, j) =&gt; {<br/>       // e is a singular TileData class.<br/>        tiles.push(<br/>          &lt;Tile<br/>            location={e.location}<br/>            scale={e.scale}<br/>            key={e.key}<br/>            img = {e.imgObj.image}<br/>          /&gt;<br/>        );<br/>      });<br/>    });<br/>    return tiles<br/>  }</span></pre><p id="fde8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了用新图像重新渲染，我们需要调用<code class="fe ne nf ng nh b">setState,</code>，但是首先，我们必须配置新图块数据源的状态。新切片数据源将是原始切片数据源的副本，但有两处修改:</p><ul class=""><li id="ac5c" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">对应于匹配的索引将被分配新的随机图像对象。</li><li id="9acd" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated"><code class="fe ne nf ng nh b">markedAsMatch</code>属性将被重置为假。</li></ul><p id="ba15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用一个名为<code class="fe ne nf ng nh b">recolorMatches</code>的函数来完成这项工作，该函数遍历tile数据源并执行前面提到的更新。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="fe66" class="me lg it nh b gy ns nt l nu nv">// In SwappableGrid.js</span><span id="423e" class="me lg it nh b gy nw nt l nu nv">recolorMatches(tileData) {<br/>    tileData.forEach(row =&gt; {<br/>      row.forEach(e=&gt; {<br/>      if (e.markedAsMatch == true){<br/>        let randIndex = getRandomInt(7);<br/>        let randomBeanObj = BEAN_OBJS[randIndex]<br/>        e.markedAsMatch = false<br/>        e.imgObj = randomBeanObj<br/>      }<br/>    })<br/>    });<br/>  }</span></pre><p id="50e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我写这个函数时，我体内的Swift开发人员突然想让函数返回一个新的tile数据源，而不仅仅是操纵输入。这是因为默认情况下，Swift中的所有内容都是作为副本传递的，但在Javascript中，任何对象都是通过引用传递的。实际上，当我们将数据传递给<code class="fe ne nf ng nh b">GridApi</code>中的函数时，我们一直都在这么做</p><h2 id="5673" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">准备好</h2><p id="07a5" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">现在我们已经准备好让整个事情开始运行了。现在，我们用来处理匹配的代码被填充在我们的<code class="fe ne nf ng nh b">swap</code>函数中。因为不是每一次交换都会产生一个匹配，所以让我们创建一个名为<code class="fe ne nf ng nh b">processMatches</code>的独立函数，当棋盘上有匹配时就会调用这个函数。我们将从一个精简的版本开始，然后添加关键细节。将以下代码放入可交换网格中:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="ec84" class="me lg it nh b gy ns nt l nu nv">// SwappableGrid</span><span id="95c2" class="me lg it nh b gy nw nt l nu nv">processMatches(matches) {</span><span id="1dad" class="me lg it nh b gy nw nt l nu nv">this.setState((state =&gt; {<br/>      // Create a copy to our existing tileDataSource<br/>      let newTileDataSource = state.tileDataSource.slice()</span><span id="eff7" class="me lg it nh b gy nw nt l nu nv">// Mark matches for update.<br/>      markAsMatch(matches,newTileDataSource)</span><span id="9a5b" class="me lg it nh b gy nw nt l nu nv">// Repositioning tiles marked for update.<br/>      condenseColumns(newTileDataSource)</span><span id="1aad" class="me lg it nh b gy nw nt l nu nv">// Recoloring those tiles &amp; reseting update status.<br/>      this.recolorMatches(newTileDataSource)</span><span id="dcec" class="me lg it nh b gy nw nt l nu nv">// Set the new state animate the tiles.<br/>      return {tileDataSource: newTileDataSource}}),()=&gt;{this.animateValuesToLocations()})</span><span id="c134" class="me lg it nh b gy nw nt l nu nv">}</span></pre><p id="5bf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在我们检查棋盘上是否有匹配之后，在<code class="fe ne nf ng nh b">swap</code>中添加一个对它的调用。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="514b" class="me lg it nh b gy ns nt l nu nv">// In SwappableGrid at the end of swap(i,j,di,dj)</span><span id="ad0a" class="me lg it nh b gy nw nt l nu nv">let allMatches = getAllMatches(this.state.tileDataSource)</span><span id="876a" class="me lg it nh b gy nw nt l nu nv">if (allMatches.length != 0) {<br/>      this.processMatches(allMatches) &lt;--- Here<br/>   }</span></pre><p id="be54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续运行它，您会看到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/50373b1117a8a2964df129346d1ce748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zsUP88cvnJPSz8dXhdS5hg.gif"/></div></div></figure><p id="50ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很好，但是还有两个问题:</p><ul class=""><li id="8775" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">在补充beans之前，交换动画没有机会完成。</li><li id="9b8a" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">在注册新的交换之前，不会评估网格的新状态中包含的匹配。</li></ul><p id="4b21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢天谢地，这两个都很容易修复，但是首先我们应该仔细看看我们的<code class="fe ne nf ng nh b">processMatch</code>函数到底在做什么。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="c384" class="me lg it nh b gy ns nt l nu nv">processMatches(matches) {</span><span id="3246" class="me lg it nh b gy nw nt l nu nv">this.setState((state =&gt; {</span><span id="9f82" class="me lg it nh b gy nw nt l nu nv">// Create a copy to our existing tileDataSource<br/>      let newTileDataSource = state.tileDataSource.slice()</span><span id="74f5" class="me lg it nh b gy nw nt l nu nv">// Mark matches for update.<br/>      markAsMatch(matches,newTileDataSource)</span><span id="914d" class="me lg it nh b gy nw nt l nu nv">// Repositioning tiles marked for update.<br/>      condenseColumns(newTileDataSource)</span><span id="079b" class="me lg it nh b gy nw nt l nu nv">// Recoloring those tiles &amp; reseting update status.<br/>      this.recolorMatches(newTileDataSource)</span><span id="7d09" class="me lg it nh b gy nw nt l nu nv">let nextMatches = getAllMatches(newTileDataSource)</span><span id="6198" class="me lg it nh b gy nw nt l nu nv">// Set the new state animate the tiles.<br/>      return {tileDataSource: newTileDataSource}}),()=&gt;{this.animateValuesToLocations()})</span><span id="478e" class="me lg it nh b gy nw nt l nu nv">}</span></pre><p id="400a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能已经注意到我们的<code class="fe ne nf ng nh b">setState</code>采用了一个接收当前状态并返回包含新状态的对象的箭头函数。在该函数中，我们使用<code class="fe ne nf ng nh b">state.tileDataSource.slice()</code>复制当前状态，并对其执行以下更新:</p><ol class=""><li id="0b69" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn of nb nc nd bi translated">使用<code class="fe ne nf ng nh b">markAsMatch</code>标记需要更新的匹配项</li><li id="7e86" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn of nb nc nd bi translated">使用<code class="fe ne nf ng nh b">condenseColumns</code>浓缩色谱柱</li><li id="c86e" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn of nb nc nd bi translated">给火柴重新上色。(这也将<code class="fe ne nf ng nh b">markedAsMatch</code>属性重置为<code class="fe ne nf ng nh b">false</code>)</li><li id="e33a" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn of nb nc nd bi translated">计算<code class="fe ne nf ng nh b">nextMatches</code>以查看新数据中是否有任何匹配。</li></ol><p id="9dfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在调用<code class="fe ne nf ng nh b">setState.</code>之前计算<code class="fe ne nf ng nh b">newTileDataSource</code>中的所有匹配很重要，这是因为<code class="fe ne nf ng nh b">setState</code>是异步的，我们不能保证在我们开始寻找新的匹配时它会被更新。因此，使用我们知道新状态最终会变成的值比等待它被设置更安全。</p><h2 id="7755" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">动画回调</h2><p id="826a" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">确保交换动画完成的解决方案隐藏在动画块本身中。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="795c" class="me lg it nh b gy ns nt l nu nv">swap(i,j,dx,dy){</span><span id="225f" class="me lg it nh b gy nw nt l nu nv">const swapStarter = this.state.tileDataSource[i][j];<br/>    const swapEnder = this.state.tileDataSource[i + dx][j + dy];</span><span id="dfcb" class="me lg it nh b gy nw nt l nu nv">this.state.tileDataSource[i][j] = swapEnder;<br/>    this.state.tileDataSource[i+dx][j+dy] = swapStarter;</span><span id="29ba" class="me lg it nh b gy nw nt l nu nv">Animated.parallel([<br/>      Animated.timing(swapStarter.location, {<br/>        toValue: {x: TILE_WIDTH*(i+dx),y: TILE_WIDTH*(j+dy)},<br/>        duration: 120,<br/>        useNativeDriver: true<br/>      }),<br/>      Animated.timing(swapEnder.location, {<br/>        toValue: {x: TILE_WIDTH*i,y: TILE_WIDTH*j},<br/>        duration: 120,<br/>        useNativeDriver: true<br/>      }),<br/>    ]).start() &lt;------- RIGHT HERE</span></pre><p id="ec02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们不调用<code class="fe ne nf ng nh b">.start()</code>，我们的动画块将什么也不做。这样，您可以在运行动画之前定义它们。也许你注意到了这一点，但是你可能没有注意到的是<code class="fe ne nf ng nh b">start()</code>实际上接受了一个在动画完成时执行的回调。因此，如果我们检查匹配并在回调中调用<code class="fe ne nf ng nh b">processMatch</code>,它应该确保动画首先完成。</p><p id="c3dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过将动画块定义为一个常量，然后单独调用它，使其更具可读性。像这样:</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="73a8" class="me lg it nh b gy ns nt l nu nv">swap(i,j,dx,dy){</span><span id="70df" class="me lg it nh b gy nw nt l nu nv">const swapStarter = this.state.tileDataSource[i][j];<br/>    const swapEnder = this.state.tileDataSource[i + dx][j + dy];</span><span id="d639" class="me lg it nh b gy nw nt l nu nv">this.state.tileDataSource[i][j] = swapEnder;<br/>    this.state.tileDataSource[i+dx][j+dy] = swapStarter;</span><span id="eeae" class="me lg it nh b gy nw nt l nu nv">// Define the block<br/>const animateSwap = Animated.parallel([<br/>      Animated.timing(swapStarter.location, {<br/>        toValue: {x: TILE_WIDTH*(i+dx),y: TILE_WIDTH*(j+dy)},<br/>        duration: 120,<br/>        useNativeDriver: true<br/>      }),<br/>      Animated.timing(swapEnder.location, {<br/>        toValue: {x: TILE_WIDTH*i,y: TILE_WIDTH*j},<br/>        duration: 120,<br/>        useNativeDriver: true<br/>      }),<br/>    ])</span><span id="6194" class="me lg it nh b gy nw nt l nu nv">// Call it<br/>animateSwap.start(()=&gt; {<br/>        let allMatches = getAllMatches(this.state.tileDataSource)<br/>        if (allMatches.length != 0) {<br/>          this.processMatches(allMatches)<br/>        }})<br/>  }</span></pre><p id="cd66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在可以清楚地看到，只有在交换动画完成之后，我们才使用回调来检查新的匹配。现在我们所要做的就是确保我们检查在棋盘“浓缩”后形成的新匹配。</p><h2 id="c9d6" class="me lg it bd lh mf mg dn ll mh mi dp lp kb mj mk lt kf ml mm lx kj mn mo mb mp bi translated">递归</h2><p id="1bed" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi translated">我们很幸运在这里有一个使用递归的好例子。但是我们必须小心一件事。“浓缩”动画需要在我们再次调用<code class="fe ne nf ng nh b">processMatch</code>之前完成。上次我们使用动画回调函数来确保这一点，但是如果你看一下我们的<code class="fe ne nf ng nh b">animateValuesToLocations</code>函数，你就会明白为什么那不是一个选项。</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="aca7" class="me lg it nh b gy ns nt l nu nv">animateValuesToLocations() {<br/>    this.state.tileDataSource.forEach((row, i) =&gt; {<br/>      row.forEach((elem, j) =&gt; {<br/>        Animated.timing(elem.location, {<br/>          toValue: { x: TILE_WIDTH * i, y: TILE_WIDTH * j },<br/>          duration: 250,<br/>          useNativeDriver: true<br/>        }).start(); &lt;---- Executed 25 times.<br/>      });<br/>    });<br/>  }</span></pre><p id="5340" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看到了吗？每次我们调用<code class="fe ne nf ng nh b">processMatch.</code>时，动画块会被执行25次，这对于我们需要一次更新电路板上的一大堆东西来说非常方便，但这并不是一个放置函数调用的好地方。</p><p id="2859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以对于我最后一个肮脏的小把戏，我们将让<code class="fe ne nf ng nh b">processMatch</code>在<code class="fe ne nf ng nh b">setTimout.</code>内部调用它自己</p><pre class="kp kq kr ks gt no nh np nq aw nr bi"><span id="cb2c" class="me lg it nh b gy ns nt l nu nv">// At the end of processMatch</span><span id="602b" class="me lg it nh b gy nw nt l nu nv">if (nextMatches.length != 0) {<br/>        setTimeout(()=&gt;{this.processMatches(nextMatches)},250)<br/>      }</span></pre><p id="721a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将阻止<code class="fe ne nf ng nh b">processMatch</code>进行递归调用，直到动画需要完成的250毫秒之后。继续运行，它应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi md"><img src="../Images/bac07d5ac66b388ff384fd8e7f584583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YnetXrZw0IsS_T12N9Ee1A.gif"/></div></div></figure><p id="26b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都好吗？这就结束了本教程的第一部分。希望你已经有了很多工作要做，但是不要忘记关注我们的第二部分，在那里我们会更深入地让这感觉像一个真正的游戏。</p><h1 id="4f2b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">请继续关注第二部分</h1><ul class=""><li id="a0da" class="mv mw it js b jt mq jx mr kb og kf oh kj oi kn na nb nc nd bi translated">制作罐子&amp;添加游戏逻辑</li><li id="551d" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">错误检查</li><li id="d702" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">重复算法</li><li id="e148" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">分数跟踪</li><li id="18b0" class="mv mw it js b jt ni jx nj kb nk kf nl kj nm kn na nb nc nd bi translated">航行</li></ul></div></div>    
</body>
</html>