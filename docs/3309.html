<html>
<head>
<title>JavaScript Fundamentals: Understanding ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:理解ES6</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-fundamentals-understanding-es6-583efbe43c4f?source=collection_archive---------4-----------------------#2019-11-19">https://itnext.io/javascript-fundamentals-understanding-es6-583efbe43c4f?source=collection_archive---------4-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bf126436d3b0c7e57cdb092014dc0a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8OsgpwsHL8Lj6gGlyTOtw.png"/></div></div></figure><p id="0ab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ES6(或ECMAScript 2015)是ECMAScript编程语言的第6个版本。ECMAScript是2015年发布的JavaScript的标准化版本，因此得名:ECMAScript 2015！</p><p id="774e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ES6的一个很大的优点是，它允许我们以一种更现代和可读的方式编写代码。它还引入了许多新特性，比如:let/const、arrow函数、新的“this”作用域、类、getter/setter、模块、模板文字、默认参数、扩展运算符、析构、for..循环和更多！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="d852" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="lg">想与web dev保持同步吗？</em> <br/>🚀<em class="lg">想把最新消息直接发到你的收件箱里吗？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</em></p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lh" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="fc6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们来看看这些新功能..</p><h1 id="d0cf" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe mg mh mi mj b">let</code>和<code class="fe mg mh mi mj b">const</code></h1><p id="4f41" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">ES6引入了两个新的定义变量的关键字:<code class="fe mg mh mi mj b">let</code>和<code class="fe mg mh mi mj b">const</code>。虽然<code class="fe mg mh mi mj b">var</code>仍然可以被使用，但是随着现代编码标准的推进，它已经不被鼓励了。让我们比较一下每种情况的一些用例..</p><p id="c599" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mg mh mi mj b">var</code>是<strong class="kd iu">函数作用域</strong>。</p><p id="1ea9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mg mh mi mj b">let</code>是<strong class="kd iu">块作用域</strong>。</p><p id="5f97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mg mh mi mj b">let</code>变量的工作方式与<code class="fe mg mh mi mj b">var</code>相似，但有一个关键区别。还要注意，任何用<code class="fe mg mh mi mj b">let</code>声明的变量都将是<strong class="kd iu">可变的</strong>(它们的值可以改变)。</p><p id="c59d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们用<code class="fe mg mh mi mj b">let</code>在for循环中声明变量，在if或普通块中，它不能“转义”块，而<code class="fe mg mh mi mj b">var</code>被提升到函数定义。</p><p id="1b51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mg mh mi mj b">const</code>就像<code class="fe mg mh mi mj b">let</code>，但是<strong class="kd iu">是不可变的</strong>(算是吧！).</p><p id="8bc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它主要用于在变量中存储一个不会被改变的值。<code class="fe mg mh mi mj b">let</code>和<code class="fe mg mh mi mj b">const</code>的主要区别在于，一旦你用<code class="fe mg mh mi mj b">const</code>给一个变量赋值，你就不能再给它赋值了。</p><p id="1e03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，仅仅因为用<code class="fe mg mh mi mj b">const</code>声明了一个变量并不意味着它是不可变的，它只意味着值不能被重新赋值。</p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从技术上来说，引用本身是<strong class="kd iu">不可变的</strong>，但是变量持有的值不会变成不可变的。</p><p id="c148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在今天的JavaScript中，你很可能会看到很少甚至没有<code class="fe mg mh mi mj b">var</code>声明，现在的惯例是只使用<code class="fe mg mh mi mj b">let</code>和<code class="fe mg mh mi mj b">const</code>。</p><h1 id="ac1a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">箭头功能</h1><p id="f921" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">箭头函数改变了大多数JavaScript代码的外观(和工作方式！).它们是编写函数的更简洁的语法，来自:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="3312" class="mx lj it mj b gy my mz l na nb">// Old Syntax</span><span id="97fb" class="mx lj it mj b gy nc mz l na nb">const something = function something() {<br/>  //...<br/>}</span></pre><p id="80bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可读性更强的:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="adf8" class="mx lj it mj b gy my mz l na nb">// New Syntax</span><span id="d462" class="mx lj it mj b gy nc mz l na nb">const something = () =&gt; {<br/>  //...<br/>}</span></pre><p id="d825" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法有两个新部分:</p><ul class=""><li id="8557" class="nd ne it kd b ke kf ki kj km nf kq ng ku nh ky ni nj nk nl bi translated"><code class="fe mg mh mi mj b">const something = ()</code></li><li id="4fad" class="nd ne it kd b ke nm ki nn km no kq np ku nq ky ni nj nk nl bi translated"><code class="fe mg mh mi mj b">=&gt; {}</code></li></ul><p id="0781" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一部分是我们的变量声明和函数赋值，即<code class="fe mg mh mi mj b">()</code>。它只是将变量设置为一个函数。</p><p id="9fbe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二部分，即<code class="fe mg mh mi mj b">=&gt;,</code>是声明函数的主体。箭头后面是包含正文的花括号。</p><p id="df56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果函数体是一行代码，箭头函数会更简单:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="f0ae" class="mx lj it mj b gy my mz l na nb">const something = () =&gt; doSomething()</span></pre><p id="4062" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，如果只有一个参数，可以这样写:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="813e" class="mx lj it mj b gy my mz l na nb">const something = param =&gt; doSomething(param)</span></pre><p id="722c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">具有旧语法的函数将像以前一样继续工作。然而，当我们向更现代和简洁的语法前进时，ES6箭头函数是更好的选择！</p><h2 id="1d5d" class="mx lj it bd lk nr ns dn lo nt nu dp ls km nv nw lw kq nx ny ma ku nz oa me ob bi translated">关于范围的注释</h2><p id="e24e" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">对于箭头函数，<code class="fe mg mh mi mj b">this</code>范围是从上下文中继承<strong class="kd iu">的。</strong></p><p id="29b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住对于常规函数，<code class="fe mg mh mi mj b">this</code>总是指最近的函数。</p><p id="a632" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们遇到的问题现在已经解决了，你不会再发现自己在写<code class="fe mg mh mi mj b">var that = this</code>了！</p><h1 id="cacf" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">班级</h1><p id="4e88" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">类是面向对象编程(OOP)的核心。在ES6中，JavaScript中引入了类。本质上，它们是内部工作的语法糖，但它们改变了我们构建许多程序的方式。在构造函数的帮助下，类可以用来创建新的对象(注意:每个类只能有一个构造函数)。</p><p id="2a82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="4578" class="mx lj it mj b gy my mz l na nb">class Person {<br/>  constructor(name) {<br/>    this.name = name<br/>  }</span><span id="1056" class="mx lj it mj b gy nc mz l na nb">  hello() {<br/>    return 'Hello, I'm ' + this.name + '.'<br/>  }<br/>}</span><span id="cba1" class="mx lj it mj b gy nc mz l na nb">class Musician extends Person {<br/>  hello() {<br/>    return super.hello() + ' I am a musician.'<br/>  }<br/>}</span><span id="9997" class="mx lj it mj b gy nc mz l na nb">let prince = new Musician('Prince')<br/>Prince.hello()</span><span id="1061" class="mx lj it mj b gy nc mz l na nb">// output: "Hello, I'm Prince. I am a musician."</span></pre><p id="bb2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类没有显式的类变量声明，但是您必须在其构造函数中初始化任何变量。</p><h1 id="32f2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Getters和setters</h1><p id="6a8f" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">在一个类中，我们可以选择使用“getters”和“setters”。它们是ES6中引入的有用特性，在使用类时特别方便:</p><p id="c374" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参见下面的例子，<strong class="kd iu">没有</strong>getter和setters:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="756a" class="mx lj it mj b gy my mz l na nb">class People {</span><span id="b275" class="mx lj it mj b gy nc mz l na nb">constructor(name) {<br/>      this.name = name;<br/>    }<br/>    getName() {<br/>      return this.name;<br/>    }<br/>    setName(name) {<br/>      this.name = name;<br/>    }<br/>}</span><span id="deef" class="mx lj it mj b gy nc mz l na nb">let person = new People("Taylor Phinney");<br/>console.log(person.getName());<br/>person.setName("Fred");<br/>console.log(person.getName());</span><span id="1894" class="mx lj it mj b gy nc mz l na nb">// Output:<br/>Taylor Phinney<br/>Fred</span></pre><p id="710c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面我们可以看到，在我们的<code class="fe mg mh mi mj b">People</code>类中有两个函数，用于获取和设置人名。</p><p id="25bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看如何使用ES6的getters和setters来实现这一点:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="4351" class="mx lj it mj b gy my mz l na nb">class People {</span><span id="20a6" class="mx lj it mj b gy nc mz l na nb">constructor(name) {<br/>      this.name = name;<br/>    }<br/>    get Name() {<br/>      return this.name;<br/>    }<br/>    set Name(name) {<br/>      this.name = name;<br/>    }<br/>}</span><span id="a8de" class="mx lj it mj b gy nc mz l na nb">let person = new People("Taylor Phinney");<br/>console.log(person.Name);<br/>person.Name = "Fred";<br/>console.log(person.Name);</span></pre><p id="bb2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你会看到在类<code class="fe mg mh mi mj b">People</code>中有两个函数具有“get”和“set”属性。“get”属性用于获取变量的值,“set”属性用于设置变量的值。</p><p id="d084" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并且调用<code class="fe mg mh mi mj b">getName</code>函数不带括号。另外<code class="fe mg mh mi mj b">setName</code>调用时不带括号。就像给变量赋值一样！</p><h1 id="9dd2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">模块</h1><p id="e6ee" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">模块对于在我们的项目中将代码组织成逻辑文件非常有用。在ES6之前，有许多我们在整个社区使用的模块解决方案，例如RequireJS、CommonJS和AMD。</p><p id="aeac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ES6中，我们已经将这些标准化为统一的格式。</p><p id="96b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ES6中，每个模块都在自己的文件中定义。一个模块中的函数和变量在另一个模块中根本不可见，除非它们已经被导出。</p><p id="09c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">导入</strong>是通过<code class="fe mg mh mi mj b">import ... from ...</code>构造完成的:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="63fa" class="mx lj it mj b gy my mz l na nb">import * from 'mymodule'<br/>import React from 'react'<br/>import { React, Component } from 'react'<br/>import React as MyLibrary from 'react'</span></pre><p id="86c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<strong class="kd iu">导出</strong>时，您可以使用<code class="fe mg mh mi mj b">export</code>关键字编写模块并将任何内容导出到其他模块:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="2c77" class="mx lj it mj b gy my mz l na nb">export var number = 10<br/>export function bar() { /* ... */ }</span></pre><p id="0d4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在不同的模块中使用导出的变量，可以使用<code class="fe mg mh mi mj b">import</code>。</p><h1 id="7ca7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">模板文字</h1><p id="5b80" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">模板文字允许我们以比过去更好的方式处理字符串。请参见下面创建字符串的示例:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="21fd" class="mx lj it mj b gy my mz l na nb">const myString = `My string`</span></pre><p id="7840" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">注意:</em>我们使用反勾<code class="fe mg mh mi mj b">``</code>而不是单引号或双引号。</p><p id="1a7c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模板文字提供了一种将表达式嵌入字符串的方法，通过使用<code class="fe mg mh mi mj b">${variable}</code>语法有效地插入值:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="5464" class="mx lj it mj b gy my mz l na nb">const name = 'John'<br/>const string = `Text ${name}` //Text John</span></pre><p id="85a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ES6之前，我们会使用<code class="fe mg mh mi mj b">+</code>操作符来连接字符串，或者在字符串中使用变量。模板文字可读性更好！</p><p id="964c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，您也可以执行更复杂的表达式:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="5bdd" class="mx lj it mj b gy my mz l na nb">const string = `text ${1 + 2 + 3}`<br/>const string2 = `text ${doSomething() ? 'x' : 'y' }`</span></pre><p id="eda8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以将字符串跨越多行，就像这样:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="0111" class="mx lj it mj b gy my mz l na nb">const string3 = `This<br/>string</span><span id="5a39" class="mx lj it mj b gy nc mz l na nb">is neat!`</span></pre><p id="e533" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这比旧的多行语法更容易编写:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="e7fe" class="mx lj it mj b gy my mz l na nb">var str = 'One\n' +<br/>'Two\n' +<br/>'Three'</span></pre><p id="66e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过使用模板文字，我们可以极大地提高代码的可读性。</p><h1 id="31f1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">默认参数</h1><p id="1317" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">对于ES6，函数现在支持默认参数:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="448b" class="mx lj it mj b gy my mz l na nb">const myFunction = function(index = 0, testing = true) { /* ... */ }<br/>myFunction()</span></pre><p id="19e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认参数允许您预先定义一个参数，这在许多情况下很有用。在JavaScript中，我们的函数参数默认为undefined。我们现在能够设置不同的默认值。</p><p id="7170" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ES6之前，我们通过测试默认函数体中的参数值来定义默认参数，如果未定义，则分配一个值<strong class="kd iu">。</strong></p><h1 id="6fe5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">扩展运算符</h1><p id="9e4b" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">Spread操作符(<code class="fe mg mh mi mj b">...</code>)是ES6提供的一个操作符，它允许我们很容易地从一个数组中获得一个参数列表。</p><p id="0451" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从一个数组示例开始:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="429e" class="mx lj it mj b gy my mz l na nb">const a = [1, 2, 3]</span></pre><p id="79f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以创建一个新数组，如下所示:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="9eaa" class="mx lj it mj b gy my mz l na nb">const b = [...a, 4, 5, 6]</span></pre><p id="23a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您也可以创建数组的副本:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="7479" class="mx lj it mj b gy my mz l na nb">const c = [...a]</span></pre><p id="f4df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也适用于克隆对象:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="385e" class="mx lj it mj b gy my mz l na nb">const newObj = { ...oldObj }</span></pre><p id="aa3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用字符串时，spread运算符可以用字符串中的每个字符创建一个数组:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="a5f1" class="mx lj it mj b gy my mz l na nb">const hello = 'hello'<br/>const imArrayed = [...hello] // ['h', 'e', 'l', 'l', 'o']</span></pre><p id="ea6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在还可以以一种非常简单的方式使用数组作为函数参数:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="6377" class="mx lj it mj b gy my mz l na nb">const f = (arg1, arg2) =&gt; {}<br/>const a = [1, 2]<br/>f(...a)</span></pre><h1 id="8776" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">析构赋值</h1><p id="7613" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">JavaScript中的析构本质上是将复杂的结构(比如对象或数组)分解成更简单的部分。通过析构赋值，我们将数组对象“解包”到许多变量中。</p><p id="6d48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们没有为对象的每个属性分别声明变量，而是将值放在花括号中来访问对象的任何属性。</p><p id="72df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，让我们从一个对象中提取一些值，并将它们放入命名变量中:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="12e7" class="mx lj it mj b gy my mz l na nb">const person = {<br/>  firstName: 'Bill',<br/>  lastName: 'Billson',<br/>  famous: false,<br/>  age: 45,<br/>}</span><span id="71d6" class="mx lj it mj b gy nc mz l na nb">const {firstName: name, age} = person</span></pre><p id="c25a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mg mh mi mj b">name</code>和<code class="fe mg mh mi mj b">age</code>包含我们想要的值。</p><p id="725c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法适用于数组:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="5edd" class="mx lj it mj b gy my mz l na nb">const a = [1,2,3,4,5]<br/>const [first, second] = a</span></pre><p id="2282" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该语句通过从数组<code class="fe mg mh mi mj b">a</code>中获取索引为<strong class="kd iu"> 0，1，4 </strong>的项目来创建三个新变量:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="b00b" class="mx lj it mj b gy my mz l na nb">const [first, second, , , fifth] = a</span></pre><h1 id="90e1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">For-of循环</h1><p id="1223" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">在ES6之前，通常使用<code class="fe mg mh mi mj b">forEach()</code>回路。他们很好地服务于目的，但没有提供打破的方法，就像<code class="fe mg mh mi mj b">for</code>循环总是有。</p><p id="4d87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ES6给了我们<code class="fe mg mh mi mj b"><strong class="kd iu">for-of</strong></code> <strong class="kd iu"> </strong>循环，它结合了<code class="fe mg mh mi mj b">forEach</code>的简洁和突破的能力:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="706c" class="mx lj it mj b gy my mz l na nb">// Iterate over a value</span><span id="9b0c" class="mx lj it mj b gy nc mz l na nb">for (const x of ['a', 'b', 'c']) {<br/>  console.log(x);<br/>}</span><span id="c787" class="mx lj it mj b gy nc mz l na nb">// Get the index, using `entries()`<br/>for (const [i, x] of ['a', 'b', 'c'].entries()) {<br/>  console.log(i, x);<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ff2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">你准备好让你的JavaScript技能更上一层楼了吗？</em> </strong> <em class="lg">今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lg">《JavaScript掌握完全指南》</em> </a> <em class="lg">带你从零到英雄！</em></p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><em class="oh">现已上市！👉</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="f4fd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="6e96" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">我们走吧！我们已经看了很多ES6的新特性，比如:let/const、arrow函数&amp;它的‘this’作用域、类、getter/setter、模块、模板文字、默认参数、spread运算符、析构和for..循环的。</p><p id="1c11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以我们现在可以实现这种现代语法，并将我们的JavaScript带到下一个层次！</p><p id="4025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以在媒体上跟我学。我也在<a class="ae lh" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="e73a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在我的个人博客上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在构建我的<a class="ae lh" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业者完整指南</a>。坏消息是它还不可用！但是如果你对它感兴趣，你可以<a class="ae lh" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用时会通知你</a>👍</p><p id="876a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>