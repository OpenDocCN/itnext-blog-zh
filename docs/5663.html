<html>
<head>
<title>Creating Popup Controls in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Angular中创建弹出控件</h1>
<blockquote>原文：<a href="https://itnext.io/creating-popup-controls-in-angular-bacb5a411caa?source=collection_archive---------2-----------------------#2021-04-27">https://itnext.io/creating-popup-controls-in-angular-bacb5a411caa?source=collection_archive---------2-----------------------#2021-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0a2ec0f54fe53aec6ed2fb3eccfa4e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mMqiCWphrXlH_JU5C_2-g.png"/></div></div></figure><p id="6450" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多控件类型可以被认为是弹出控件，例如选择、日期时间选择器、模态对话框等。所有这些控件都有脱离布局流并与其他UI元素重叠的部分。在HTML中实现重叠行为有一些众所周知的方法，但是在Angular中开发自己的组件库时，使用这些方法可能会有问题。接下来，我们将看看弹出控件的潜在问题以及避免这些问题的一些技巧。</p><h2 id="a7a8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">HTML中的覆盖图</h2><p id="5ca3" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">创建本地弹出窗口的最简单有效的方法是对宿主元素使用相对位置，对弹出窗口使用绝对位置:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7036" class="kw kx iq lz b gy md me l mf mg">&lt;div id="host"&gt;<br/>  &lt;div id="control"&gt;<br/>    Host<br/>    &lt;div id="popup"&gt;<br/>      Popup<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;style&gt;<br/>  #host{<br/>    width: 90px;<br/>    height: 50px;<br/>  }</span><span id="963f" class="kw kx iq lz b gy mh me l mf mg">  #control{<br/>    position: relative;<br/>  }</span><span id="ed2e" class="kw kx iq lz b gy mh me l mf mg">  #popup{<br/>    position: absolute;<br/>    top: 30px;<br/>    left: 10px;<br/>  }<br/>&lt;/style&gt;</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/65cddf9310c666d31118bf9524ce9a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*mbCo81On0k5tF7qCuYTl6Q.png"/></div></figure><p id="d991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果宿主元素不隐藏溢出，它会工作得很好，否则弹出窗口可能会被剪切，并且z-index也没有帮助:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7c2f" class="kw kx iq lz b gy md me l mf mg">#host{<br/>  width: 90px;<br/>  height: 50px;<br/>  overflow: hidden;<br/>}</span><span id="1db1" class="kw kx iq lz b gy mh me l mf mg">#control{<br/>  position: relative;    <br/>  z-index: 10000; /*It does not help*/<br/>}</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/b4777fe23691c480390b381576ddde48.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*5cXIDYDkA4JmodOLUBwGcw.png"/></div></div></figure><p id="1b5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">库控件可以放在任何主机中，因此上述解决方案不能视为通用的。</p><p id="4f16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个解决方案是使用<strong class="ka ir">固定</strong>位置弹出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0501" class="kw kx iq lz b gy md me l mf mg">&lt;div id="host"&gt;<br/>  &lt;div id="control"&gt;<br/>    Control<br/>      &lt;div id="popup"&gt;<br/>        Popup<br/>      &lt;/div&gt;<br/>  &lt;/div&gt;  <br/>&lt;/div&gt;<br/>&lt;style&gt;<br/>  #host{<br/>    width: 90px;<br/>    height: 50px;<br/>    overflow: hidden;<br/>  }</span><span id="0d0b" class="kw kx iq lz b gy mh me l mf mg">  #popup{<br/>    position: fixed;<br/>    top: 50px;<br/>    left: 50px;<br/>  }<br/>&lt;/style&gt;</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/741f0cfcd4321cb130dbc23b0a13bf84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*xFKc5J7_iPP9SaJlHiqIFg.png"/></div></figure><p id="7727" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的缺点是弹出窗口和控件位置需要通过JavaScript同步，但主要问题是控件主机可以启动<a class="ae ml" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context" rel="noopener ugc nofollow" target="_blank">一个新的堆栈上下文</a>，因此，弹出窗口可能会被其他元素覆盖，z索引也不会有帮助:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7120" class="kw kx iq lz b gy md me l mf mg">&lt;div id="host"&gt;<br/>  &lt;div id="control"&gt;<br/>    Control<br/>      &lt;div id="popup"&gt;<br/>        Popup<br/>      &lt;/div&gt;<br/>  &lt;/div&gt;  <br/>&lt;/div&gt;<br/>&lt;div id="overlap"&gt;<br/>  Overlap<br/>&lt;/div&gt;<br/>&lt;style&gt;<br/>  #host{<br/>    width: 90px;<br/>    height: 50px;<br/>    overflow: hidden;</span><span id="8e82" class="kw kx iq lz b gy mh me l mf mg">    /*New stacking context*/<br/>    position: relative;<br/>    z-index: 0;<br/>  }</span><span id="82b9" class="kw kx iq lz b gy mh me l mf mg">  #popup{<br/>    position: fixed;<br/>    top: 50px;<br/>    left: 35px;<br/>    z-index: 1000;/*It does not help*/<br/>  }</span><span id="3145" class="kw kx iq lz b gy mh me l mf mg">  #overlap{<br/>    transform: translate(80px, -50px);<br/>  }<br/>&lt;/style&gt;</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/fbae770c6419fd0228c1fe6e37e3affb.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*4ZvRtAVIhMBiSQA6QzFxEg.png"/></div></figure><p id="5d8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的解决方案是在根堆栈上下文中呈现弹出窗口:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c9e2" class="kw kx iq lz b gy md me l mf mg">&lt;div id="host"&gt;<br/>  &lt;div id="control"&gt;<br/>    Control<br/>  &lt;/div&gt;  <br/>&lt;/div&gt;<br/>&lt;div id="overlap"&gt;<br/>  Overlap<br/>&lt;/div&gt;<br/>&lt;div id="popup"&gt;<br/>  Popup<br/>&lt;/div&gt;</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/18b71a0e000965a5227cc31eec596960.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*ZXSJl7dKkSxFRp4K0fo09g.png"/></div></figure><p id="a257" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一招很管用，但是那些倒霉的角度控制的创造者应该怎么做呢？这些控件可以放在任何地方，它们的弹出窗口如何移动到应用程序根目录之后？此外，我将向您展示如何做到这一点。</p><h2 id="d8b8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">实现内角</strong></h2><p id="a469" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">第一个目标是在除控件本身之外的任何地方呈现一个弹出部件。</p><p id="f0dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们正在开发一个下拉控件，我们希望在应用程序根组件之后呈现“向下”部分:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="dac5" class="kw kx iq lz b gy md me l mf mg">&lt;div class="l-box"&gt;<br/>  &lt;ng-content select="lib-drop-down-label"&gt;<br/>  &lt;/ng-content&gt;<br/>&lt;/div&gt;<br/>&lt;div class="l-popup"&gt;<br/>  &lt;ng-content select="lib-drop-down-content"&gt;<br/>  &lt;/ng-content&gt;<br/>&lt;/div&gt;</span></pre><p id="4625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals?file=src/app/lib/directives/popup-rect.directive.ts" rel="noopener ugc nofollow" target="_blank">一个角度结构指令</a>我们可以捕获弹出部分作为模板，并将其存储在某个服务中:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a8f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals?file=src/app/lib/services/popup.service.ts" rel="noopener ugc nofollow" target="_blank">服务</a>:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c31f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是侦探的用法:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4758" class="kw kx iq lz b gy md me l mf mg">...<br/>&lt;div<br/>  *libPopupRect="isOpen;top:rect.top;left:rect.left;width:rect.width;"<br/>    class="l-popup"&gt;</span><span id="fc10" class="kw kx iq lz b gy mh me l mf mg">&lt;ng-content select="lib-drop-down-content"&gt;<br/>  &lt;/ng-content&gt;<br/>&lt;/div&gt;</span></pre><p id="a151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要<a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals?file=src/app/lib/components/popup-host/popup-host.component.html" rel="noopener ugc nofollow" target="_blank">一个主机组件来呈现存储的模板</a>:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="da97" class="kw kx iq lz b gy md me l mf mg">&lt;ng-container *ngFor="let p of popups"&gt;<br/>  &lt;div <br/>    class="l-popup"<br/>    [style.top.px]="p.rect.top" <br/>    [style.left.px]="p.rect.left" <br/>    [style.bottom.px]="p.rect.bottom" <br/>    [style.right.px]="p.rect.right" <br/>    [style.width.px]="p.rect.width" <br/>    [style.height.px]="p.rect.height"<br/>    [style.z-index]="p.rect.zIndex"<br/>  &gt;<br/>    &lt;ng-container [ngTemplateOutlet]="p.tr"&gt;&lt;/ng-container&gt;<br/>  &lt;/div&gt;<br/>&lt;/ng-container&gt;<br/>&lt;style&gt;<br/>  .l-popup {<br/>    position: fixed;<br/>    pointer-events: initial;<br/>  }  <br/>&lt;/style&gt;</span></pre><p id="c728" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals?file=src/app/lib/components/popup-host/popup-host.component.ts" rel="noopener ugc nofollow" target="_blank">组件类</a>:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2a73" class="kw kx iq lz b gy md me l mf mg"><a class="ae ml" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>(...)<br/>export class PopupHostComponent {</span><span id="9443" class="kw kx iq lz b gy mh me l mf mg">  popups: PopupData[];<br/>    <br/>  constructor(private readonly _cd: ChangeDetectorRef) { }</span><span id="1d13" class="kw kx iq lz b gy mh me l mf mg">  update(popups: PopupData[]) {<br/>    this.popups = popups;<br/>    this._cd.detectChanges();<br/>  }<br/>}</span></pre><p id="0302" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，使用该服务，我们可以在应用程序根之后动态创建主机组件:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在DOM中，打开的下拉菜单如下所示:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/2716e582a0a437490870bb35c052c72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*t-o9hjIIluffHtaJs9bV2w.png"/></div></figure><h2 id="4d37" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">弹出窗口的定位</h2><p id="0c7a" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">弹出窗口使用<strong class="ka ir">固定的</strong>位置，这意味着它们应该相对于锚点明确定位:</p><p id="fe7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals?file=src/app/lib/components/drop-down/drop-down.component.ts" rel="noopener ugc nofollow" target="_blank">下拉菜单</a>，我们可以使用组件元素ref作为锚点，并在弹出菜单出现时对其进行定位:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="38f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是，我们不能保持下拉菜单始终打开，因为主机DOM布局的任何变化(调整大小，滚动等。)可能导致不正确的定位。该问题最简单的解决方案是关闭任何外部活动的下拉弹出窗口:</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2bba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他弹出控件也可以用同样的方式开发。例如<a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals?file=src/app/lib/components/modal-dialog/modal-dialog.component.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">模态对话框</strong> </a>。</p><p id="2cc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi">—</p><p id="56fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面描述的技术可能看起来有点过于复杂，但这是一个很好的解决方案，可以99%确保您的弹出窗口不会被任何其他东西覆盖。</p><p id="a848" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">链接到<a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals" rel="noopener ugc nofollow" target="_blank">堆栈上的示例</a>:<a class="ae ml" href="https://stackblitz.com/edit/angular-popup-modals" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/angular-popup-modals</a></p></div></div>    
</body>
</html>