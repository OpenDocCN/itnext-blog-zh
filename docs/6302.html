<html>
<head>
<title>Intersection Observer in OutSystems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外部系统中的交叉点观测器</h1>
<blockquote>原文：<a href="https://itnext.io/intersection-observer-in-outsystems-8f614bb24921?source=collection_archive---------4-----------------------#2021-10-12">https://itnext.io/intersection-observer-in-outsystems-8f614bb24921?source=collection_archive---------4-----------------------#2021-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/df867d584f3f9385d410e6cf76d08899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KzH6Do7i8FhyTGv7dM-jQg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@agk42?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae kc" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="a133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">弄清楚用户能在你的web应用上看到什么是一项复杂的任务。</p><p id="f3db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论您选择设置一个事件侦听器来检测滚动位置还是计算当前元素相对于顶部的偏移量，对于一些看起来微不足道的事情来说，这都是很大的努力。</p><p id="b8ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，大多数现代浏览器都实现了交叉点观察器Web API。</p><blockquote class="lb lc ld"><p id="77aa" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">交叉点观察器API提供了一种异步观察目标元素与祖先元素或顶级文档的视口的交叉点变化的方法。</p><p id="140c" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">历史上，检测元素的可见性或两个元素相对于彼此的相对可见性一直是一项困难的任务，其解决方案不可靠，并且容易导致浏览器和用户正在访问的网站变得缓慢。随着网络的成熟，对这类信息的需求也在增长。</p><p id="11e4" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">(<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">在路口观察器API </a></p></blockquote><p id="3a58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想到了几个用例，即延迟加载、无限滚动、当动画实际可见时激活动画，或者在启用“我同意”按钮之前经典地滚动到EULA的结尾(反正没人看)。</p><h2 id="9b29" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">外部系统实现</h2><p id="11b8" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我们从库模块上的一个简单块开始。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/b9d4e31202649c2e4c6755f32bc4a46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*FnYADiiNnPjer5JaIP9u_Q.png"/></div></figure><p id="67f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有target元素是必需的，它表示您想要监视的元素。</p><p id="50e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根元素表示目标的祖先元素，相对于它来测量可见性。默认情况下，它使用浏览器的视口。</p><p id="f362" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阈值表示以百分比形式报告可见性的触发点。例如，如果您想在元素为0%、25%、50%、75%和100%可见时获取事件，您可以输入[0，0.25，0.5，0.75，1]。</p><p id="6952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当超过这些阈值时，就会触发OnObserved事件。你所需要做的就是在你的应用程序中实现事件的逻辑。</p><p id="9882" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这条路很窄:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/50b29c17431b6fc7c2ad55748c342126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*kf_g0c9FlXJW16mCY-U00w.png"/></div></figure><p id="f436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和JavaScript细节:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/de50791de63cfff5a5a3bcef42325500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*sxKcOc17ZFYiQ0ONhdPyGA.png"/></div></figure><pre class="mh mi mj mk gt mn mo mp mq aw mr bi"><span id="4b38" class="li lj iq mo b gy ms mt l mu mv">var observer = new IntersectionObserver($actions.Observer_CallBack,options);</span></pre><p id="f490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一行使用Observer_Callback方法作为交叉点观察器的回调。</p><p id="ce0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Observer_Callback方法:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5964a8545a4b02ab11ce414d8023d52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*s_xFYR-Lu3ToU6MPIaIl0A.png"/></div></figure><p id="3ce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在对象的一些序列化之后触发OutSystems事件。</p><h2 id="effd" class="li lj iq bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">实施注意事项</h2><p id="7393" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">Web API交叉点观察器确实有更多的方法和功能。</p><p id="ac82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以同时监视几个目标元素，可以根据需要添加目标元素，也可以通过编程启动和停止观察。</p><p id="b8aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要的话，叫我一声。</p><h1 id="1eb1" class="mx lj iq bd lk my mz na ln nb nc nd lq ne nf ng lt nh ni nj lw nk nl nm lz nn bi translated">使用组件</h1><p id="a2cb" class="pw-post-body-paragraph kd ke iq kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">您需要做的就是将组件放到页面上(在您想要观察的内容之后)，为target设置元素并实现OnObserve事件。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="b3fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，该组件可在<a class="ae kc" href="https://www.outsystems.com/forge/component-overview/11709/web-api-intersection-observer" rel="noopener ugc nofollow" target="_blank">锻造厂</a>获得。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d01c891faf9e5abcb2d9a9eddb8f8aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*x0ekCi0GHuC12GcHVzw5ZA.png"/></div></figure><p id="88ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你所要做的就是去构建那些应用程序。</p></div></div>    
</body>
</html>