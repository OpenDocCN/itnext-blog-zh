<html>
<head>
<title>Micro In Action: Error Handling Across Service Boundaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微在行动:跨服务边界的错误处理</h1>
<blockquote>原文：<a href="https://itnext.io/micro-in-action-error-handling-across-services-boundary-2f9f27821bd5?source=collection_archive---------1-----------------------#2020-04-05">https://itnext.io/micro-in-action-error-handling-across-services-boundary-2f9f27821bd5?source=collection_archive---------1-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f91b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何在Go Micro v2中的服务之间传递结构错误信息</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/48b8d6082418acfcc69d464c1a215fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDKyN2VKlBOrEes_dcsPSg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@rutzsepp?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">塞普·鲁兹</a>在<a class="ae le" href="https://unsplash.com/backgrounds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="06c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在分布式系统中，一个服务产生错误然后返回给另一个服务是很常见的情况。如果我们能够在不丢失细节信息的情况下跨服务传递所有结构性错误，那就太好了。</p><p id="904e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Micro v2的<code class="fe lf lg lh li b">github.com/micro/go-micro/v2/errors</code>包正是为此服务的。让我引用官方文档中的介绍:</p><blockquote class="lj lk ll"><p id="5ba6" class="jq jr lm js b jt ju jv jw jx jy jz ka ln kc kd ke lo kg kh ki lp kk kl km kn im bi translated">Go Micro为分布式系统中发生的大多数事情(包括错误)提供了抽象和类型。通过提供一组核心错误和定义详细错误类型的能力，我们可以始终如一地了解典型Go错误字符串之外的情况</p></blockquote><p id="bed2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它在整个Micro v2中使用，并在基于Micro的所有服务中提供一致的编组/解编能力。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="704a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">定义</h1><p id="71b2" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">错误类型由ProtoBuf定义:</p><pre class="kp kq kr ks gt na li nb nc aw nd bi"><span id="314f" class="ne ly it li b gy nf ng l nh ni">syntax = "proto3";</span><span id="6392" class="ne ly it li b gy nj ng l nh ni">package errors;</span><span id="bb02" class="ne ly it li b gy nj ng l nh ni">message Error {<br/>  string id = 1;<br/>  int32 code = 2;<br/>  string detail = 3;<br/>  string status = 4;<br/>};</span></pre><p id="a767" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Golang代码就是从这个ProtoBuf文件中生成的。在Go Micro中，每个字段都有常规含义:</p><ul class=""><li id="dad4" class="nk nl it js b jt ju jx jy kb nm kf nn kj no kn np nq nr ns bi translated"><strong class="js iu"> Id </strong>用于识别错误。在Micro中，服务名通常被分配给这个字段。比如“go.micro.web”、“com.foo.service.hello”。</li><li id="1b41" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><strong class="js iu">代码</strong>是表示错误类型的数字。我们知道Micro使用gRPC作为默认传输协议。简单地说，gRPC是基于HTTP/2的。所以框架继承HTTP状态码约定是很自然的，取500表示“内部服务器错误”，403表示“禁止”，等等。</li><li id="2f6c" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><strong class="js iu">详细信息</strong>是底层错误字符串。</li><li id="4d40" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><strong class="js iu">状态</strong>表示代码字段对应的简短描述。因为一般来说，code字段是一个有效的HTTP状态代码，所以这个字段的值只是从标准库中返回的值<code class="fe lf lg lh li b">http.StatusText(code)</code>。</li></ul><h1 id="211b" class="lx ly it bd lz ma ny mc md me nz mg mh mi oa mk ml mm ob mo mp mq oc ms mt mu bi translated">助手功能</h1><p id="f656" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">除了类型定义，这个包还提供了一些帮助函数来简化日常开发。</p><ul class=""><li id="a9e8" class="nk nl it js b jt ju jx jy kb nm kf nn kj no kn np nq nr ns bi translated"><code class="fe lf lg lh li b">func New(id, detail string, code int32) error</code>:创建一个新的结构错误，并提供id、详细信息和代码。(如前所述，<strong class="js iu">状态</strong>字段将自动填充)。</li><li id="1285" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated"><code class="fe lf lg lh li b">func Parse(err string) *Error</code>:试图将一个JSON字符串解析成一个<code class="fe lf lg lh li b">errors.Error</code>。如果失败，输入字符串将被分配给返回错误的<strong class="js iu">细节</strong>字段。</li></ul><p id="286c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会注意到上面两个函数的返回值是不同的。我猜这是一个深思熟虑的设计决定。这表明当您在服务处理程序中返回一个新错误时，您并不关心实际的错误类型。另一方面，当您试图解析来自服务客户端的错误时，错误的类型变得至关重要。</p><p id="b6c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，还有另外八个函数包装了最常用的代码。它们是<code class="fe lf lg lh li b">BadRequest</code>、<code class="fe lf lg lh li b">Unauthorized</code>、<code class="fe lf lg lh li b">Forbidden</code>、<code class="fe lf lg lh li b">NotFound</code>、<code class="fe lf lg lh li b">MethodNotAllowed</code>、<code class="fe lf lg lh li b">Timeout</code>、<code class="fe lf lg lh li b">Conflict</code>、<code class="fe lf lg lh li b">InternalServerError<strong class="js iu">.</strong></code>如果你熟悉HTTP状态码，你应该马上就能明白这些函数的含义。</p><h1 id="f730" class="lx ly it bd lz ma ny mc md me nz mg mh mi oa mk ml mm ob mo mp mq oc ms mt mu bi translated">应用场景</h1><p id="3333" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">这个包的应用场景是在服务边界附近。</p><p id="97e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，在处理程序中返回一个错误:</p><pre class="kp kq kr ks gt na li nb nc aw nd bi"><span id="290a" class="ne ly it li b gy nf ng l nh ni">func (e *Hello) Call(ctx context.Context, req *hello.Request, rsp *hello.Response) error {<br/>   if len(req.Name) == 0 {<br/>      <strong class="li iu">return</strong> <strong class="li iu">errors.BadRequest("com.foo.service.hello", "name is required")</strong><br/>   }<br/>   rsp.Msg = "Hello " + req.Name<br/>   return nil<br/>}</span></pre><p id="cc22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，解析来自客户端的错误:</p><pre class="kp kq kr ks gt na li nb nc aw nd bi"><span id="5a31" class="ne ly it li b gy nf ng l nh ni">// create hello service client<br/>helloClient := hello.NewHelloService("com.foo.service.hello", service.Client())<br/><br/>// invoke hello service method<br/>resp, err := helloClient.Call(context.TODO(), &amp;hello.Request{Name: "Bill 4"})<br/>if err != nil {<br/>   e := <strong class="li iu">errors.Parse(err.Error())</strong><br/>   if <strong class="li iu">e.Code == http.<em class="lm">StatusBadRequest</em></strong><em class="lm"> </em>{<br/>      // deal with bad request<br/>   }<br/>}</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="0ccd" class="ne ly it bd lz od oe dn md of og dp mh kb oh oi ml kf oj ok mp kj ol om mt on bi translated">包扎</h2><p id="0db5" class="pw-post-body-paragraph jq jr it js b jt mv jv jw jx mw jz ka kb mx kd ke kf my kh ki kj mz kl km kn im bi translated">Micro v2中的<code class="fe lf lg lh li b">errors</code>包，像这个框架的其他组件一样，为分布式系统中的常见任务提供了抽象。</p><p id="59dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个包的帮助下，开发人员可以用一致的方式处理服务间的错误。任何熟悉HTTP状态代码的人都会发现适应起来非常容易，因为这个包重用了众所周知的HTTP状态代码集。</p><p id="8259" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将帮助我们建立一个易于理解和维护的分布式系统。你越早将它引入你的项目，你就越能从中受益。</p><p id="b53f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干杯。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="d320" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关Micro v2的逐步教程和其他有关Micro的文章，请访问<a class="ae le" href="https://medium.com/@dche423/micro-in-action-1be29b057f2d" rel="noopener"> Micro In Action </a>系列的索引页面。</p></div></div>    
</body>
</html>