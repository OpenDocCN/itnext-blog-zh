<html>
<head>
<title>How to faster Node Scale your Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何加快Kubernetes集群的节点扩展</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-faster-node-scale-your-kubernetes-cluster-2c988c7c7d08?source=collection_archive---------1-----------------------#2020-03-23">https://itnext.io/how-to-faster-node-scale-your-kubernetes-cluster-2c988c7c7d08?source=collection_archive---------1-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="561f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">再也不要在这可怕的几分钟里等待新节点上线</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b0436fce43e052be4f796292fa30990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaJjlgGpYnfEYl6k4fBKIg.jpeg"/></div></div></figure><p id="f0aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kubernetes集群自动缩放器(或节点自动缩放器)非常棒。启用后，如果群集中有挂起的pod，它会请求新节点。</p><p id="3c36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">集群自动缩放器<a class="ae lq" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">是Kubernetes </a>的一部分，提供特定节点设置的建议。如果有人听了这个建议(像GCP，AWS，Azure，DigitalOcean)，节点将被添加或删除。</p><h2 id="4c38" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">待定窗格</h2><p id="f29b" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">如果没有更多资源可用于调度新的pod，K8s中的HPA和VPA会导致pod处于未决状态。这将触发集群自动缩放。</p><h2 id="d3cb" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">问题</h2><p id="ca52" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">根据您的云提供商，启动新节点可能需要一些时间。对于Azure和一个2CPU-2GB的节点，5分钟以上。</p><h2 id="b922" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="467c" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">创建具有较低优先级的占位符单元，作为将由HPA创建的单元。这样，当创建其他窗格时，占位符窗格将立即被替换。<strong class="kw iu">缺点</strong>:如果需要的话，至少还有一个节点在运行。这是你为速度付出的代价。</p><h2 id="5546" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">有关系的</h2><ol class=""><li id="226a" class="mp mq it kw b kx mk la ml ld mr lh ms ll mt lp mu mv mw mx bi translated"><a class="ae lq" href="https://medium.com/faun/kubernetes-cka-hands-on-challenge-6-pod-priority-1fe95f613ac5?source=friends_link&amp;sk=7f9ea22abbe4b0c5c1758e756c3ff2cf" rel="noopener">如何使用K8s优先级的实际例子</a></li><li id="57d7" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><a class="ae lq" href="https://codeburst.io/practical-guide-to-kubernetes-scaling-1-pods-5a7ed08f4e8b?source=friends_link&amp;sk=22602bf9789af6112fa53e9d20c05ed0" rel="noopener" target="_blank">Kubernetes卧式容器自动缩放实用指南</a></li><li id="b95c" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><a class="ae lq" href="https://codeburst.io/practical-guide-to-kubernetes-node-scaling-5a7fc3499a56?source=friends_link&amp;sk=ac4e04e5bc9a21197871ecdc8ccec911" rel="noopener" target="_blank">Kubernetes节点自动缩放实用指南</a></li><li id="64c0" class="mp mq it kw b kx my la mz ld na lh nb ll nc lp mu mv mw mx bi translated"><a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/k8s-vertical-pod-autoscaling-fd9e602cbf81?source=friends_link&amp;sk=df7289cb35bcfdfa7f191546e6d555b6">垂直Pod自动缩放</a></li></ol><h1 id="b64d" class="nd ls it bd lt ne nf ng lw nh ni nj lz jz nk ka mc kc nl kd mf kf nm kg mi nn bi translated">优先级占位符</h1><p id="e591" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们想要创建占位符窗格。</p><h2 id="ad62" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">负优先级</h2><p id="cd55" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">具有负优先级的单元将被集群自动缩放器忽略。这些被认为是“填充物”:</p><blockquote class="no np nq"><p id="b631" class="ku kv nr kw b kx ky ju kz la lb jx lc ns le lf lg nt li lj lk nu lm ln lo lp im bi translated">非关键工作负载可能有更多可以放入集群的单元。如果您为非关键工作负载设置了负优先级，那么当非关键pod挂起时，Cluster Autoscaler不会向您的集群添加更多节点。因此，你不会产生更高的费用。当您的关键工作负载需要更多计算资源时，调度程序会抢占非关键单元并调度关键单元。(<a class="ae lq" href="https://kubernetes.io/blog/2019/04/16/pod-priority-and-preemption-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="8e0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们需要给pod的优先级≥ 0。</p><h2 id="e891" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">创建优先级类别</h2><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="c9e4" class="lr ls it nw b gy oa ob l oc od"><strong class="nw iu">apiVersion</strong>: scheduling.k8s.io/v1<br/><strong class="nw iu">kind</strong>: PriorityClass<br/><strong class="nw iu">metadata</strong>:<br/>  <strong class="nw iu">name</strong>: placeholder<br/><strong class="nw iu">value</strong>: 0<br/><strong class="nw iu">preemptionPolicy</strong>: Never<br/><strong class="nw iu">globalDefault</strong>: false<br/><strong class="nw iu">description</strong>: 'placeholder'<br/>---<br/><strong class="nw iu">apiVersion</strong>: scheduling.k8s.io/v1<br/><strong class="nw iu">kind</strong>: PriorityClass<br/><strong class="nw iu">metadata</strong>:<br/>  <strong class="nw iu">name</strong>: normal<br/><strong class="nw iu">value</strong>: 1<br/><strong class="nw iu">preemptionPolicy</strong>: Never<br/><strong class="nw iu">globalDefault</strong>: true              # default<br/><strong class="nw iu">description</strong>: 'normal'</span></pre><p id="295f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将PriorityClass <code class="fe oe of og nw b">normal</code>定义为所有pod的默认值。</p><h2 id="887d" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">创建占位符部署</h2><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="85c9" class="lr ls it nw b gy oa ob l oc od"><strong class="nw iu">apiVersion</strong>: apps/v1<br/><strong class="nw iu">kind</strong>: Deployment<br/><strong class="nw iu">metadata</strong>:<br/>  <strong class="nw iu">name</strong>: placeholder<br/><strong class="nw iu">spec</strong>:<br/>  <strong class="nw iu">replicas</strong>: 2<br/>  <strong class="nw iu">selector</strong>:<br/>    <strong class="nw iu">matchLabels</strong>:<br/>      <strong class="nw iu">app</strong>: placeholder<br/>  <strong class="nw iu">template</strong>:<br/>    <strong class="nw iu">metadata</strong>:<br/>      <strong class="nw iu">labels</strong>:<br/>        <strong class="nw iu">app</strong>: placeholder<br/>    <strong class="nw iu">spec</strong>:<br/>      <strong class="nw iu">terminationGracePeriodSeconds</strong>: 0        # important<br/>      <strong class="nw iu">priorityClassName</strong>: placeholder          # important<br/>      <strong class="nw iu">containers</strong>:<br/>      - <strong class="nw iu">image</strong>: nginx<br/>        <strong class="nw iu">name</strong>: placeholder<br/>        <strong class="nw iu">resources</strong>:<br/>          <strong class="nw iu">requests</strong>:<br/>            <strong class="nw iu">cpu</strong>: 1500m</span></pre><p id="9b28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要根据节点大小来定义资源请求。如果我们将CPU请求设置为<code class="fe oe of og nw b">2000m</code>，它可能不会触发集群自动缩放，因为它甚至不能在新的2CPU节点上进行调度，所以我们将其设置得稍低一些。副本数量指定了我们想要保留的节点数量。在上面的示例代码中，我们在Azure上保留了2个2CPU-2GB的节点。</p><p id="befe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">还要检查terminationGracePeriodSeconds</strong>，这确保占位符pod不会在30秒内(默认)处于终止状态，在此期间，它仍然被调度并且仍然会使用资源。</p><h1 id="82b0" class="nd ls it bd lt ne nf ng lw nh ni nj lz jz nk ka mc kc nl kd mf kf nm kg mi nn bi translated">虚拟库伯勒</h1><p id="b663" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">也看看<a class="ae lq" href="https://virtual-kubelet.io/" rel="noopener ugc nofollow" target="_blank">的虚拟库伯莱</a>和<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-without-nodes-caedd172f940?source=friends_link&amp;sk=a7cd94bbb7e8776fa4f0802de4e41094">我关于它的文章</a>。它将允许您在云容器引擎而不是节点上运行pods，并可以让您更快地扩展。</p><h1 id="29b2" class="nd ls it bd lt ne nf ng lw nh ni nj lz jz nk ka mc kc nl kd mf kf nm kg mi nn bi translated">概述</h1><p id="a1da" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">速度还是金钱，这是这里的问题。</p><h1 id="828b" class="nd ls it bd lt ne nf ng lw nh ni nj lz jz nk ka mc kc nl kd mf kf nm kg mi nn bi translated">成为Kubernetes认证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://killer.sh"><div class="gh gi oh"><img src="../Images/cf3901a56841fcb55f9e4e17b9f07672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kbj17_6VncUuoBqNsAzzg.png"/></div></a><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated"><a class="ae lq" href="https://killer.sh" rel="noopener ugc nofollow" target="_blank"> https://killer.sh </a></figcaption></figure></div></div>    
</body>
</html>