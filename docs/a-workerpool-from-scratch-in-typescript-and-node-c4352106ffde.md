# 在类型脚本和节点中从头开始工作

> 原文：<https://itnext.io/a-workerpool-from-scratch-in-typescript-and-node-c4352106ffde?source=collection_archive---------1----------------------->

![](img/c8e1a07881d52e199dd7fdd6830212e5.png)

照片由[张秀坤·贝德纳兹](https://unsplash.com/@betno?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/workers?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

`await`和`async`关键字受到 JavaScript 开发人员的喜爱，因为它们能够以优雅的方式编写复杂的异步逻辑。但有一件事是不可能的:多个代码块同时运行的“真正”并发。JavaScript 的架构是以这样一种方式建立的，即总是有一个进程运行在一个执行所有代码的线程上。异步行为是通过使用一个队列来实现的，该队列保存将要执行的下一个代码块。通过对该队列进行战术调度，可以暂停某个功能，直到在节点进程之外运行的某个后台任务完成，如文件操作或网络调用。但是不可能在另一个 JavaScript 函数运行的同时让其他 JavaScript 函数继续运行。

如何在节点中阻塞主进程的示例

在上面的代码示例中，将会进行 api 调用，但是在此之后的`api`函数中的所有内容都不会被执行，因为该过程被 while 循环阻塞了。在处理大量数据的大节点应用程序中，这可能会成为一个严重的问题。为了解决这个问题[工人](https://developer.mozilla.org/nl/docs/Web/API/Worker)在那里介绍。它们允许开发人员启动一个全新的节点流程，该流程运行一个脚本，并可以通过事件系统与主流程通信。然而，这确实是一个新的节点实例，不像基于线程的系统那样有共享内存(例如 C#或 Java 中的多线程)。这意味着当您将数据发送给一个 worker 时，它将被克隆并在另一个运行时重新创建。当在一个过程中传递对象并对其进行变异时，这可能会令人困惑。那些变异不会在另一边体现出来！模块的每个节点进程也将有一个实例，打破了它们默认的单例行为。

# 资源池

在上一段中，我们已经讨论了创建 workers 将会创建一个新的节点实例。这意味着创造新工人是一项相对繁重的任务。此外，还存在创建大量工作进程并使主机系统充满进程的风险。这就是资源池的用武之地。当我们启动应用程序时，我们将创建一定数量的工作线程，并在每次我们想要在另一个进程上运行任务时重用这些工作线程。这个工作线程池将由池管理器管理，池管理器接受任务并将它们分配给一个空闲的工作线程。函数本身将被封装在`Task`接口中，该接口提供了链接和运行任务的方法。我们可以使用 Promises 来轻松处理这种“真正的”异步代码，就像节点主机在后台为我们运行的网络和文件操作一样。

# **创建池**

我们将从定义我们架构的总体形状开始。将有一个 workerspool，它将包含所有带有任务的 worker 和 queues。我决定给 workerpool 一个公共方法:`createTask`。此方法将创建一个任务，该任务将在创建它的池内运行。`Task`接口也有一个单独的公共方法:`runAsync`。该方法将在工作线程上运行包装的函数。这个函数的返回值是一个承诺，当一个工人执行完这个函数时，这个承诺就会被解决。这些接口定义如下:

任务是围绕一个函数的盒子，它使函数异步

实现这些接口将从为 workerpool 创建一个构造函数开始。这个函数从定义池的所有内部开始:

*   一个 id 和 workers 的映射，包含我们池中的所有 workers。这些 workers 将被一次性创建，并被 workerpool 将要执行的所有任务重用。
*   一个集合，包含空闲并准备接受新任务的工作线程的 id。
*   已排队并将尽快执行的积压任务。这些任务包括一个 id、一个函数和发送给工人的附加数据。这里所有的数据都被输入为`any`，类型安全将在`Task`界面中介绍
*   带有 taskid 和解析器的映射。解析器是当工作人员完成任务时将被调用的函数。每个任务都有自己的解析器。
*   将用于分配增量任务标识符的计数器。

我们允许外界来定义这个池子的大小

workers 由一个脚本构成，该脚本将是该节点实例的主进程。我们稍后将定义它的内容。有了这些定义，我们就可以开始添加执行任务的逻辑了。我们将从创建一个函数开始，如果有一个工人准备好了，这个函数将运行 backlog 上的下一个任务。为此，必须采取某些步骤:

1.  检查我们是否有一个任务和一个空闲的工作线程
2.  接受下一个任务和空闲的工人
3.  为员工构建信息。我们不能在工人之间发送函数，所以我们必须把它变成一个字符串
4.  将任务发送给员工

最后我们会再次调用`runNext`。这样，只要我们还有空闲的工作线程和任务，我们就会继续在工作线程上调度任务。每次我们接触到 backlog 或`idle`集合时，都应该调用`runNext`。这样，我们将总是尽可能快地安排任务。

在函数上调用 toString 会给出源代码

之后，是时候创建将在 workers 内部运行的脚本了。这个脚本将监听任务的到达。当一个任务到达时，它将运行它们并将结果和标识符一起发送回来。要运行我们的函数，我们必须首先将它转换成命名函数。之后我们可以使用`eval`运行编译并运行它。该脚本可以在下面找到:

我们使用一些 js 魔法来确保我们总是在评估一个命名的函数

接下来将发生的事情是 workerpool 接收结果并解析任务。为此，我们为所有工人添加了一个`message`监听器。在这里，我们调用任务 id 的 resolver 函数，并将 worker 放在空闲任务列表中。最后，我们调用`runNext`,以便处理积压工作，新的空闲工作者得到一个任务。

请注意，我们还在工作线程之间传输结果，因此它们也必须是可克隆的

# 创建任务

现在我们已经有了 workerpool 的内部结构，我们可以开始创建和排队任务了。任务将由从`createWorkerpool`返回的函数创建。这意味着任务总是绑定到特定的 workerpool。因此，我们的结构将如下所示:

从函数中返回对象意味着我们捕获了任务内部的池

在`createTask`中，不发生任何退出的事情，它只是返回一个带有运行任务和使用池的函数的对象。为了运行该任务，我们必须采取以下步骤:

1.  创建新的 taskid
2.  将任务添加到待办事项中
3.  创建承诺并将解决程序添加到解决程序中
4.  兑现承诺
5.  调用`runNext`启动系统

请注意，我们将 Promise 构造函数中的解析器设置为一个映射，该映射位于更高的闭包中。这样，我们可以回报承诺，并在以后从外部解决它。

主进程一次只运行一个函数，所以我们不会在 taskIdCounter 中得到竞争条件

现在是时候对我们的系统进行第一次测试了。在下面的例子中，我在后台运行 3 个函数来计算不同数字的斐波纳契数列。如果您阅读控制台输出，您将看到任务在不同的时间并行运行和完成。

我们不能使`task`递归，因为它将在另一个不存在`task`的节点实例中运行

# **链接任务**

承诺的一个常用特性是将多个承诺按顺序连接起来，其中下一个承诺依赖于前一个承诺的输出。本文简介中的 api 调用就是一个很好的例子。我们使用`fetch`的结果来调用`json` on，并使用其结果来提取`value`属性。我还将把`then`函数添加到我们的`Task`接口中，以允许这种后台进程的链接。更新后的界面如下所示:

我们用一个从我们的结果到一个新的结果的任务来链接

对于实现，我们简单地覆盖`runAsync`函数，首先运行当前任务，当它解决后运行下一个任务。有了这个函数，我们可以不断地将任务链接在一起，以创建更大的进程，从而最佳地利用工人池的排队能力。

基于你是否使用`:`，这在对象文字上的工作是不同的

这个功能是这样使用的:

链接任务的工作方式与承诺相同

# 结论

在这篇文章中，我讨论了 JavaScript 的一些最大的弱点和最强的特性。围绕这一点，我们编写了一个托管 workerpool，它允许我们在并发性的道路上走得比 JavaScript 设计的更远。源代码可以在 [Github](https://github.com/WimJongeneel/ts-workerpool) 上找到。这篇文章是我关于 it 的最新文章的后续，接下来你可能会喜欢:

[](/a-web-server-from-scratch-in-typescript-854642a85402) [## 在 TypeScript 和 Node 中从头开始创建 Web 服务器

### 通过制作自己的来了解互联网

itnext.io](/a-web-server-from-scratch-in-typescript-854642a85402)