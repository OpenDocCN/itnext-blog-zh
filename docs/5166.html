<html>
<head>
<title>Performing a code review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">执行代码审查</h1>
<blockquote>原文：<a href="https://itnext.io/performing-a-code-review-1297967683f6?source=collection_archive---------2-----------------------#2020-12-30">https://itnext.io/performing-a-code-review-1297967683f6?source=collection_archive---------2-----------------------#2020-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2711b17efa18f51517433f91256d2bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGwG5AJ4P88K2bNO_upjOQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">卢卡·布拉沃在<a class="ae kf" href="https://unsplash.com/s/photos/code-review?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3fca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天早些时候，一个名为<strong class="ki iu"> <em class="le"> /aliezsid </em> </strong>的用户在Reddit上发布了一个<a class="ae kf" href="https://www.reddit.com/r/golang/comments/kmziuv/would_like_to_request_a_code_review/?utm_medium=android_app&amp;utm_source=share" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a>帖子，要求进行代码审查。我需要在咖啡时间做些事情，所以我想为什么不呢。</p><p id="678f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Aliezsid要求对他的新项目<a class="ae kf" href="https://github.com/barelyhuman/commitlog" rel="noopener ugc nofollow" target="_blank"> commitlog </a>进行代码审查。我访问了他的GitHub来看看这个项目是关于什么的，看起来它是一个基于GitHub上的提交历史来生成变更日志的工具。我很喜欢他的想法，所以我决定做一个小回顾。你可以在这里阅读他的项目。</p><h2 id="dbdc" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">侦察</h2><p id="cf29" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">当执行代码评审时，我做的第一件事总是检查文档。我需要了解这个库以及它背后的想法。</p><p id="12cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">README.md指定这个库正在进行大量的开发，并声明没有被认为不稳定的测试。在代码评审期间，我通常做的第二件事是检查测试以查看使用示例。测试不仅是确保事情不被破坏的重要手段，而且我发现在理解一个库的用法时，测试也很有用。</p><p id="56f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是正如Aliezsid自己所写的，他知道目前没有测试，所以让它去吧。</p><h2 id="4cdc" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated"><strong class="ak">代码分析</strong></h2><p id="9b0d" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">接下来我要做的就是抓取代码。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2079" class="lf lg it mi b gy mm mn l mo mp">mkdir codereview-gitcommit<br/>cd codereview-gitcommit<br/>git init<br/>git pull <a class="ae kf" href="https://github.com/barelyhuman/commitlog" rel="noopener ugc nofollow" target="_blank">https://github.com/barelyhuman/commitlog</a></span></pre><p id="686c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们打开<strong class="ki iu"> main.go. </strong>我要去看看程序中发生了什么，然后一步一步地走过去。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gitcommit主函数的第一行。</figcaption></figure><p id="295d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先看到的是，他希望程序有一个输入参数。然后，他将使用<a class="ae kf" href="https://github.com/go-git/go-git" rel="noopener ugc nofollow" target="_blank"> go-git </a>打开GitHub存储库。如果我们检查PlainOpen做了什么，我们将看到以下内容。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自go-git的PlainOpen</figcaption></figure><p id="ce79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，该程序需要GitHub存储库的路径，而不是URL。知道这一点很好，所以让我们稍微修改一下，使它更清楚。让我们使用golang <a class="ae kf" href="https://golang.org/pkg/flag/" rel="noopener ugc nofollow" target="_blank">国旗</a>包来帮助我们。我想使用标志的原因是，它将帮助我们生成用户错误，它也更具可伸缩性。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阅读论据的更新版本</figcaption></figure><p id="03ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在执行我们将要看到的程序时，用户更容易掌握如何使用它</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/eddf67329b6d09f7bef2facbdfb01c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*RSinscW3z7-snSmpj8gi9A.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用gitcommit错误时输出错误。</figcaption></figure><p id="e8e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们继续。代码中接下来发生的是，他打开git存储库，获取git头引用并提取提交历史。这是非常不清楚的，因为没有评论。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gitcommit打开repo并提取头引用和提交的代码</figcaption></figure><p id="4e16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在这段代码被隔离在主包之外，不清楚到底发生了什么。我想要把这个拆开一些。我将创建一个名为Repository的新结构来保存这些函数。这将使测试变得更加容易，代码更加干净，可伸缩性更强。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个新的存储库结构保存了我们的功能，测试将会容易得多</figcaption></figure><p id="2cd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他做的下一件事是从存储库中提取最新的标签。这是通过用utils包提取latestTag来完成的。实际上，我们现在可以删除utils包，并将其插入到存储库结构的函数中。由于utils只支持这一个函数，我觉得将逻辑插入到我们的存储库结构中更合适。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这是旧的gitcommit代码，他从中提取最新的标签。</figcaption></figure><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7e93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，他检查latestTag是否与存储库头相同。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自main函数的代码，用于检查第一次提交是否与存储库头相同。</figcaption></figure><p id="a1a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我也想删除<strong class="ki iu"> tillLatest </strong>检查，取而代之的是它自己的功能。这使得测试变得更容易，并且在包增长的情况下<em class="le">重用</em>也变得更容易。在第116行的后面，他还重用了<strong class="ki iu">is Committee arest</strong>函数中完全相同的代码，每次我们不止一次使用代码时，<em class="le">将其分解到自己的函数中，以避免重复代码</em>。我们需要了解两种用例中需要什么，并确保我们可以在两种情况下使用我们的新函数。</p><p id="620d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">isCommitToNearestTag还包含一个小错误，它会重复检查一个错误并使用log.Fatal。第二个错误检查实际上永远无法访问，因为第一个错误检查会因为使用log.Fatal而取消。似乎tillLatest布尔标志用于强制检查latestTag。哈希()。所以代码实际上会执行一次这种检查，只是为了强制以后再执行一次。这是我们可以删除的东西，所以它只执行一次，不是说我们有优化问题，而是没有理由重新运行代码。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">旧的isCommittoNearestTag代码。</figcaption></figure><p id="53ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将彻底删除执行第一次tillLatest检查的代码，它实际上没有任何用途(第58–79行)。当移除它时，我们会注意到我们可以完全移除对最新标签的获取。我们留着以后再说吧。</p><p id="0b21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的新函数将被称为IsCommitLatest，它将接受一个指向object.Commit的指针。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">isCommitNearest现在可以在交换机内部使用，而无需运行两次。</figcaption></figure><p id="b1b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后是最后一次迭代，遍历所有提交，并将它们附加到一个日志中。日志是由logcategory包处理的，所以让我们对它进行消化以了解它做了什么。</p><p id="8438" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和utils一样，它也是一个非常小的包。实际上，它是一个附加了一个函数的结构。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">gitcommits logcategory包。</figcaption></figure><p id="9095" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们从结构开始。在结构中很少看到大写的名字，我最后一次看到这种用法是在Java中。也许我们的作者是一个老爪哇鲨鱼？这没什么不好，我有点喜欢它，但我知道不是每个人都喜欢。让我们按照作者的想法去做吧。</p><p id="ed6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GenerateMarkDown函数检查所有切片的长度，并基于它们创建字符串和一个小标题。它使用常规字符串串联(old string+=“hello”+“world”)。它在这种情况下工作，因为字符串非常简单，但我实际上建议使用String.Builder。</p><p id="0d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还对每个切片重复同样的事情。并且结构中的每个切片都是[]字符串。所以让我们创建一个函数来做我们需要的事情。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">接受指向字符串生成器的指针、标题和要打印的日志</figcaption></figure><p id="c74a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在GenerateMarkdown会变成这样</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="aa3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我宁愿把它放在主包中，去掉logcategory的额外包。所以我将所有与logcategory相关的逻辑放入主包中一个名为<strong class="ki iu"> logcategories.go. </strong>的新文件中</p><p id="01a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还建议保持主函数的整洁和易于查看，所以我们也创建一个名为<strong class="ki iu"> repository.go. </strong>的文件，所有与存储库结构相关的代码都放在那里。</p><p id="56df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以对于代码审查的最后一部分，之前提到的提交迭代。它检查所有提交，并将这些消息附加到logcategory中适当的片上。你知道，因为我建议保持主街道的清洁。这实际上是我将移到logcategories文件中的内容。此外，我想把它从主要的，所以它可以更容易地测试。</p><p id="3b40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现很难测试驻留在main中的东西。我建议总是把东西分开，这样在测试中更容易接近。</p><p id="583c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我为LogsByCategory struct创建了一个新函数，它将为我们处理逻辑。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">逻辑是从main中分离出来的，所以它是可测试的</figcaption></figure><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="33bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们最后的主线。</p><p id="5d83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，他提到他目前在git actions中创建了自己的changelog。所以让我们修改。github/workflows/create-binaries . yml因为我们改变了程序的执行方式。还记得我们添加了-path标志吗？</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c774" class="lf lg it mi b gy mm mn l mo mp">Line 30: ./commitlog . &gt; CHANGELOG.txt<br/>// Replaced with<br/>.commitlog -path=. &gt; CHANGELOG.txt</span></pre><p id="27e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以！我现在不干了。</p><p id="d918" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你喜欢我的小代码回顾和我的制作过程。</p><p id="c943" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">已提交PR请求。</p></div></div>    
</body>
</html>