<html>
<head>
<title>JavaScript Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript模块</h1>
<blockquote>原文：<a href="https://itnext.io/a-couple-of-years-ago-javascript-developers-were-blessed-with-a-new-es6-standard-which-brought-us-51d585382704?source=collection_archive---------1-----------------------#2019-02-10">https://itnext.io/a-couple-of-years-ago-javascript-developers-were-blessed-with-a-new-es6-standard-which-brought-us-51d585382704?source=collection_archive---------1-----------------------#2019-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/63bd1182fd9161c1e10d48b6a8119377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCqHTYCMv3Ep_l2nkUq7rg.png"/></div></div></figure><p id="f96d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几年前，JavaScript开发人员有幸获得了一个新的ES6标准，它给我们带来了许多新奇的语言特性，比如模块、类、箭头函数、async/await等等。然而，我们仍然必须将代码移植到ES5中，并用polyfills捆绑起来，以适应遗留浏览器用户，这带来了一堆不必要的代码。</p><p id="8ae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，我们可以通过简单地利用<strong class="ka ir"> JavaScript模块</strong>来检测浏览器是否支持ES6特性，并向现代浏览器提供必要的最低限度。虽然在服务器端，事情比较复杂。</p><p id="22c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我将深入探讨一个主题，模块实际上是什么，当今最流行的标准，即CommonJS (CJS)和JavaScript模块(ESM)之间有什么区别，以及为什么开始在所有地方使用单一标准如此困难。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="d3c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅提及模块格式(<a class="ae ld" href="https://github.com/amdjs/amdjs-api/wiki/AMD" rel="noopener ugc nofollow" target="_blank"> AMD </a>、<a class="ae ld" href="http://www.commonjs.org/" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>、<a class="ae ld" href="https://github.com/umdjs/umd" rel="noopener ugc nofollow" target="_blank"> UMD </a>、<a class="ae ld" href="http://www.2ality.com/2014/09/es6-modules-final.html#an_overview_of_the_es6_module_syntax" rel="noopener ugc nofollow" target="_blank"> JavaScript模块</a>)、捆绑工具(<a class="ae ld" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank"> Browserify </a>、<a class="ae ld" href="http://webpack.github.io/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae ld" href="http://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>、<a class="ae ld" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package</a>)和动态加载器(<a class="ae ld" href="https://requirejs.org/" rel="noopener ugc nofollow" target="_blank"> RequireJS </a>、<a class="ae ld" href="https://github.com/systemjs/systemjs" rel="noopener ugc nofollow" target="_blank"> SystemJS </a></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="3190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过去，我们必须确保相关功能以正确的顺序包含在页面中，因为前一段代码需要满足某些条件:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="83b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于所有文件共享一个全局状态，开发人员必须手动控制包含脚本的顺序，并确保变量不会覆盖已经定义的变量。</p><p id="d622" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多年来，Javascript应用程序变得越来越复杂，当应用程序变得更加复杂时，通过将代码分解成封装的功能块，模块成为避免污染全局状态的解决方案，这使得测试、调试和组合更加容易。</p><p id="b249" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们提出模块模式的时候。</p><h2 id="04c4" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">揭示模块模式</h2><p id="5842" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated"><a class="ae ld" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript" rel="noopener ugc nofollow" target="_blank">模块模式</a>是一种为变量和函数提供私密性的通用方法，同时公开一个期望的公共API。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="4955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法之所以有效，是因为Javascript的作用域被限制在一个函数级别上(至少直到ES6)，这意味着函数中定义的内容不能暴露在外部。</p><p id="674d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面函数周围的圆括号只是为了说明它是一个函数表达式，可以被调用，但是我们可以不用它，因为把它赋给变量<code class="fe mi mj mk ml b">var myUser =</code>已经把它转换成表达式了。</p><p id="b7c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">公共方法由一个返回的对象公开，其余的声明包含在函数范围内，使得它在外部不可访问。</p><p id="1882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法效果很好。它不需要任何库，并被所有平台支持，但它有其缺点，如管理依赖性，因为<code class="fe mi mj mk ml b">setUserEmail</code>隐式依赖于<code class="fe mi mj mk ml b">re</code>模块，但模块定义中没有显示这一点。</p><p id="2399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后NodeJS出现了，并普及了CommonJS用于后端JavaScript。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="44c7" class="mm ll iq bd lm mn mo mp lp mq mr ms ls mt mu mv lv mw mx my ly mz na nb mb nc bi translated">🛠CommonJS模块</h1><p id="1a9d" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">这是NodeJS组件在2009年采用的官方模块系统。与模块模式一样，它将每个模块隔离在其闭包中。</p><p id="0e02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最大的<a class="ae ld" href="http://www.modulecounts.com/" rel="noopener ugc nofollow" target="_blank">包仓库</a> <code class="fe mi mj mk ml b">npm</code>是基于CommonJS格式构建的。</p><p id="ae67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它由两个实体组成——<code class="fe mi mj mk ml b">exports</code>对象，它将你放入其中的所有东西作为公共符号公开(例如函数和变量):</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="7031" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和一个<code class="fe mi mj mk ml b">require</code>函数，使用提供的模块说明符将另一个模块的符号放入您的范围:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="c126" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要返回所需的模块，需要执行五个步骤:</p><ol class=""><li id="2398" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated"><strong class="ka ir">将模块的指定符解析为NodeJS理解的绝对路径或工件。它可以是模块的路径或者是<code class="fe mi mj mk ml b">node_modules</code>目录中的模块名。NodeJS将在由<code class="fe mi mj mk ml b">module.paths</code>定义的路径中搜索模块:</strong></li></ol><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/d614a994cd05d48021d01ed36656b6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3TmreL9JIavFoYEUNhDjw.png"/></div></div></figure><p id="d3e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果模块说明符是一个文件夹，并且该文件夹中有一个<code class="fe mi mj mk ml b">package.json</code>文件，加载程序将解析该文件并加载该文件，如<em class="nn">主</em>字段所示。如果<code class="fe mi mj mk ml b">package.json</code>丢失，<code class="fe mi mj mk ml b">index.js</code>文件将被NodeJS用作默认条目。</p><p id="5273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也可以使用<code class="fe mi mj mk ml b">require.resolve("module")</code>来检查文件是否存在，而不加载它。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/03c3e18c6222727a592f146370b301ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tWpsP4_JimA0VlD4VdJHw.png"/></div></div></figure><p id="b2c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<strong class="ka ir">加载</strong>决定文件的类型。如果它是一个JavaScript文件，那么NodeJS假设该文件是一个CommonJS模块。在将加载的JavaScript字符串传递给JavaScript运行时进行评估之前，字符串被封装在函数中。</p><p id="aa41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.包装赋予文件私有的范围。这使得<code class="fe mi mj mk ml b">require</code>方法和<code class="fe mi mj mk ml b">exports</code>对象对于所需的文件都是本地的。</p><p id="bd23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">常用的<code class="fe mi mj mk ml b">exports</code>、<code class="fe mi mj mk ml b">require</code>、<code class="fe mi mj mk ml b">module</code>、<code class="fe mi mj mk ml b">__fileame</code>、<code class="fe mi mj mk ml b">__dirname</code>等构件不是全局的，而是一个模块的包装函数的参数。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="0284" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管在标准的CommonJS (CJS)模块规范和节点对<code class="fe mi mj mk ml b">module.exports</code>对象的实现上存在差异。在NodeJS中，<code class="fe mi mj mk ml b">module.exports</code>是一个被导出的特殊对象，而<code class="fe mi mj mk ml b">exports</code>只是一个指向<code class="fe mi mj mk ml b">module.exports</code>的指针。另一方面，CommonJS没有<code class="fe mi mj mk ml b">module.exports</code>对象。因此，如果<code class="fe mi mj mk ml b">exports</code>变量被重新分配，它会丢失一个引用并引入一个新变量，而不是改变<code class="fe mi mj mk ml b">module.exports</code>对象:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="bd1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CommonJS模块是为服务器端实现而设计的，因为它们是同步解析的。这意味着模块是按顺序加载和执行的，它们在源文件中是必需的，并且没有办法知道模块在执行前导出了什么，这使得这种模块不太适合客户端。这也是为什么不能异步改变<code class="fe mi mj mk ml b">exports</code>对象的原因:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3caa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是模块可以以编程方式包含在源代码中。也可以使用析构:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="b014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2011年，Browserify发布，将CommonJS模块带到浏览器中，通过将所有必需的依赖项捆绑到单个JavaScript文件中，允许客户端JavaScript到<code class="fe mi mj mk ml b">require</code> npm包。</p><p id="e131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.<strong class="ka ir">JavaScript运行时评估</strong>加载的代码。</p><p id="d899" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.包装函数<strong class="ka ir">缓存</strong>对象用于进一步的<code class="fe mi mj mk ml b">require</code>调用，如果解析为相同的文件，将得到完全相同的对象。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6c43" class="mm ll iq bd lm mn mo mp lp mq mr ms ls mt mu mv lv mw mx my ly mz na nb mb nc bi translated">🚀JavaScript模块(又名ESM)</h1><p id="bd70" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">JavaScript模块于2015年在ES6中引入，作为一种解决方案，用于标准化当时已经存在的所有平台上的模块系统动物园。</p><p id="771d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建一个JavaScript模块，只需使用<code class="fe mi mj mk ml b">export</code>指令导出公共功能供其他模块使用:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="e0fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用一个模块，<code class="fe mi mj mk ml b">import</code>它的元素在另一个模块的命名空间中:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="a530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种导入模块的语法形式是静态声明:它只接受一个<strong class="ka ir">字符串文字</strong>作为模块说明符，并通过一个<em class="nn">预运行时</em>“链接”过程将绑定引入局部范围。</p><p id="71c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，尽管破坏CJS的进口是可能的，但ESM却不可能:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="6019" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于JavaScript模块被设计成可静态分析的，并且在没有运行程序的情况下，运行时无法预先知道导出的符号将被赋予什么值——这就是为什么<code class="fe mi mj mk ml b">export/import</code>指令应该只在文件的顶层使用的原因。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/3b9f8da331880fac0d6065133dbad8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T58trAnHJTuaFEPGdwQB4g.png"/></div></div></figure><p id="ab95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">import和export指令的静态特性允许静态分析器在不运行代码的情况下构建完整的依赖关系树，它还支持重要的用例，如捆绑工具和树抖动，这非常酷。</p><p id="5132" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript模块本质上是异步的，因为它们可以分三个阶段处理。</p><ol class=""><li id="aa45" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated"><strong class="ka ir">构造</strong> —获取并解析文件，生成模块记录。</li><li id="ac03" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv ni nj nk nl bi translated"><strong class="ka ir">实例化</strong> —构建静态模块图，在内存中连接导出/导入。</li><li id="51c4" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv ni nj nk nl bi translated"><strong class="ka ir">评估</strong> —在Javascript运行时加载代码。</li></ol><p id="1211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在NodeJS中，模块应该在扩展名为<code class="fe mi mj mk ml b">.mjs</code>的文件中创建，这表明它是一个模块，而不是用熟悉的<code class="fe mi mj mk ml b">.js</code>扩展名定义的常规脚本。这个决定被批评了很多次，但可能是目前最理想的。另一方面，浏览器并不真正关心扩展名，只要文件包含具有特殊属性<code class="fe mi mj mk ml b">&lt;script type="module" src="esm-index.js"&gt;&lt;/script&gt;</code>的脚本元素，并使用正确的<code class="fe mi mj mk ml b">MIME</code>类型，如JavaScript文件的<code class="fe mi mj mk ml b">text/javascript</code>。</p><p id="3f2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于NodeJS中没有特殊的属性或<code class="fe mi mj mk ml b">MIME</code>类型，所以决定使用<code class="fe mi mj mk ml b">.mjs</code>扩展来确定它是<code class="fe mi mj mk ml b">module</code>还是常规的<code class="fe mi mj mk ml b">script</code>。</p><p id="bbb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为什么它如此重要呢？</p><p id="90b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">规格中的<code class="fe mi mj mk ml b">script</code>和<code class="fe mi mj mk ml b">module</code>有区别:</p><ol class=""><li id="694c" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">默认情况下，模块启用了<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener ugc nofollow" target="_blank">严格模式</a>(就好像它们在顶部隐含了一个“use strict”)。</li><li id="16fa" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv ni nj nk nl bi translated">静态的<code class="fe mi mj mk ml b">export</code>和<code class="fe mi mj mk ml b">import</code>指令只在模块中可用，在常规脚本中不起作用。</li><li id="6cd3" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv ni nj nk nl bi translated">模块只被求值一次，而经典脚本被求值多次。</li></ol><p id="c155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">网络上的模块具有额外的显著特征:</p><ol class=""><li id="e1e0" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">模块有一个词法顶级范围。这意味着，举例来说，在一个模块中运行<code class="fe mi mj mk ml b">var foo = 42;</code>不会<em class="nn">而</em>创建一个名为<code class="fe mi mj mk ml b">foo</code>的全局变量，可以在浏览器中通过<code class="fe mi mj mk ml b">window.foo</code>访问，尽管在经典脚本中会是这种情况。</li><li id="8be1" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv ni nj nk nl bi translated">模块是用CORS取的。任何跨源模块脚本都必须使用正确的头文件，比如<code class="fe mi mj mk ml b">Access-Control-Allow-Origin: *</code></li></ol><p id="97c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这些差异，JavaScript引擎在处理模块和经典脚本时会有不同的表现，因此需要理解什么在哪里。</p><p id="061a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，浏览器可以通过设置一个<code class="fe mi mj mk ml b">type</code>属性将<code class="fe mi mj mk ml b">&lt;script&gt;</code>标签视为模块:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="baff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，如果现代浏览器理解模块类型，它将忽略一个<code class="fe mi mj mk ml b">nomodule</code>脚本标签，而传统浏览器将使用回退脚本！这意味着如果您的<code class="fe mi mj mk ml b">esm-index.mjs</code>文件使用ES6特性，您就不必再传输它了，这些特性是与<code class="fe mi mj mk ml b">window.fetch</code>、<code class="fe mi mj mk ml b">Classes</code>、<code class="fe mi mj mk ml b">arrow functions</code>或<code class="fe mi mj mk ml b">async/await</code>等模块同时引入的，它们会使您的包变得更小。🤘</p><p id="48a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经提到过，与CommonJS的<code class="fe mi mj mk ml b">require</code>相比，<code class="fe mi mj mk ml b">import</code>不是动态的(例如，它不能被有条件地调用)，因为JavaScript模块的导出是按词汇定义的<em class="nn"/>。也就是说，模块导出的符号是在JavaScript代码被解析之前确定的。但是有一条出路！</p><h2 id="2529" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">JavaScript模块:动态导入()</h2><p id="406a" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在某些情况下，有条件或按需导入模块、在运行时编写模块说明符或从<code class="fe mi mj mk ml b">script</code>文件导入模块是很有用的。这些在静态导入中都是不可能的。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="e3c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与<em class="nn">词法</em> <code class="fe mi mj mk ml b">import</code>不同，<em class="nn">动态</em> <code class="fe mi mj mk ml b">import()</code>函数是在当时进行处理或求值的(就像CJS <code class="fe mi mj mk ml b">require</code>)。</p><p id="003a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ml b">import()</code>为所请求模块的模块名称空间对象返回一个<code class="fe mi mj mk ml b">Promise</code>，它是在构建、实例化和评估模块的所有依赖项以及模块本身之后创建的。</p><p id="c6d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe mi mj mk ml b">import()</code>返回一个承诺，所以可以用<code class="fe mi mj mk ml b">async/await </code>来代替:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="4ca0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然<code class="fe mi mj mk ml b">import()</code>看起来像一个函数调用，但它被指定为恰好使用括号的语法(类似于super())，并且它不继承<code class="fe mi mj mk ml b">Function.prototype</code>。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="46b3" class="mm ll iq bd lm mn mo mp lp mq mr ms ls mt mu mv lv mw mx my ly mz na nb mb nc bi translated">欧洲稳定机制和CJS的区别</h1><p id="7816" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">以及为什么NodeJS对采用JavaScript模块如此敏感。</p><p id="170a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从8.9.0版本开始，NodeJS中就提供了带有实验标志<code class="fe mi mj mk ml b">—-experimental-modules</code>的JavaScript模块。在我的理解中，主要的差异和难点是:</p><ol class=""><li id="6ac1" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">同步与异步加载器。JavaScript模块应该支持异步加载。Node的CommonJS模块是同步加载的，因为它们通常是从本地文件系统加载的——所以不太需要支持异步。</li><li id="04a1" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv ni nj nk nl bi translated">解决算法(例如裸导入)</li></ol><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="bfa6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">裸导入是指模块说明符只有在<code class="fe mi mj mk ml b">package.json</code>中定义的模块名称，例如<code class="fe mi mj mk ml b">require("lodash")</code>。在这种情况下，NodeJS会查看<code class="fe mi mj mk ml b">node_modules</code>目录，这是对算法功能的一个非常简单的解释。这个算法是整个CommonJS系统的核心，它是<code class="fe mi mj mk ml b">npm</code>的基础。</p><p id="4144" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据JavaScript modules规范，当<code class="fe mi mj mk ml b">import</code>调用模块时，说明符必须是完整的URL，或者以<code class="fe mi mj mk ml b">/</code>、<code class="fe mi mj mk ml b">./</code>或<code class="fe mi mj mk ml b">../</code>开头的相对URL，但是没有提到裸导入，目前不支持裸导入。</p><p id="9cb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，NodeJS实现了与CJS相同的解析算法，但用于ESM。这意味着，例如，如果你做了<code class="fe mi mj mk ml b">import _ from 'lodash'</code>，它将在<code class="fe mi mj mk ml b">node_modules</code>中寻找一个<code class="fe mi mj mk ml b">lodash</code>目录，并寻找它的<code class="fe mi mj mk ml b">package.json</code>来确定要加载的文件。</p><p id="571e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.加载模块的默认规则是:</p><ul class=""><li id="d7db" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv nv nj nk nl bi translated">一个JavaScript模块可以使用<code class="fe mi mj mk ml b">import</code>加载其他JavaScript模块。</li><li id="c83c" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv nv nj nk nl bi translated">JavaScript模块可以使用<code class="fe mi mj mk ml b">import</code>加载CommonJS模块，但只能默认导入。</li><li id="9f6a" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv nv nj nk nl bi translated">一个CommonJS模块可以使用<code class="fe mi mj mk ml b">require</code>加载其他CommonJS模块。</li><li id="3c61" class="nd ne iq ka b kb nq kf nr kj ns kn nt kr nu kv nv nj nk nl bi translated">CommonJS模块<strong class="ka ir">不能</strong>加载JavaScript模块(除了动态<code class="fe mi mj mk ml b"><a class="ae ld" href="http://2ality.com/2017/01/import-operator.html" rel="noopener ugc nofollow" target="_blank">import()</a></code>承诺)，所以后者必须被转换成CommonJS，比如你可以用Babel来做。但是请记住，除了JavaScript模块中的命名导出之外，还有一个<code class="fe mi mj mk ml b">default</code>导出，当它被转换为CommonJS模块时，会在<code class="fe mi mj mk ml b">exports</code>对象中添加一个“默认”属性:</li></ul><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="651c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你必须<code class="fe mi mj mk ml b">const lowerFirst = require("string-case").default</code>它。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="a38e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我试图掌握并演示流行模块系统的基本原理和差异。我认为这对进一步理解不同的生态系统和流行的捆绑器是如何组织的至关重要。</p><p id="a689" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>