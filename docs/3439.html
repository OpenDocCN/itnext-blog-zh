<html>
<head>
<title>Configure Prometheus scraping from relational database in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Kubernetes中的关系数据库配置Prometheus抓取</h1>
<blockquote>原文：<a href="https://itnext.io/configure-prometheus-scraping-from-relational-database-in-kubernetes-9b4466d16f85?source=collection_archive---------1-----------------------#2019-12-17">https://itnext.io/configure-prometheus-scraping-from-relational-database-in-kubernetes-9b4466d16f85?source=collection_archive---------1-----------------------#2019-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些在Kubernetes集群中安装了Prometheus，并且愿意使用可以从SQL数据库中提取的定制业务指标的人来说，本文将会很有帮助。</p><h1 id="1844" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">先决条件</h1><ul class=""><li id="a725" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">库伯内特星团</li><li id="f0a4" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">普罗米修斯在你的集群中像豆荚一样运行</li><li id="9054" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">SQL数据库</li></ul><h1 id="0291" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">简短的业务案例描述</h1><h2 id="4e02" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">成分</h2><p id="76f0" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">让我们描述一个我们将要实现的用例。假设我们有一个数据源，我们称之为<strong class="jp ir">发布者</strong>。</p><p id="fcc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个组件是一个<strong class="jp ir">数据接收</strong>服务，处理一个重要的业务逻辑，并最终将结果存储在任何一种<strong class="jp ir">存储中</strong>。一旦处理完成，它可以有<em class="mo">成功</em>或<em class="mo">失败</em>的结果。</p><p id="c913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还有一个特殊的<strong class="jp ir">处理跟踪器</strong> (Tracker) <strong class="jp ir"> </strong>服务，负责通过HTTP通道接收数据摄取的结果。Tracker服务也连接到SQL数据库，结果将保存在该数据库中。</p><p id="d35d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但并非最不重要的元素是<strong class="jp ir"> Prometheus </strong>，它目前只收集Kubernetes集群状态。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/72c3eecef611933a619270a6ce49868b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUFRDWuEqdbvnbCSa6rBIA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">初始配置</figcaption></figure><h2 id="3f8f" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">任务描述</h2><p id="f6a0" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">到目前为止很棒！现在我们有了新的要求。我们必须意识到在数据摄取中数据处理失败的情况。如果发生这种情况，我们必须立即通知我们的支持团队和第三个新的<strong class="jp ir">订阅</strong>服务，该服务将对数据源执行新的订阅。</p><h2 id="49b4" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">解决办法</h2><p id="56c4" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">乍一看，很简单。您需要在基础设施中添加一些东西，以便能够访问数据库、执行查询并将结果存储在某个地方。应该分析该结果并进行通知。</p><p id="2c93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，有一个社区支持的数据库扫描器，它可以通过SQL调用扫描您的业务信息，并以Prometheus可理解的格式存储结果。然后，Prometheus自己正在ping这个扫描仪并输入数据。</p><h1 id="a974" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">实施阶段</h1><h2 id="7218" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">普罗米修斯出口商</h2><p id="719f" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">为我们提供普罗米修斯度量格式的附加软件(扫描仪)称为普罗米修斯导出器。在官方文件中，你可以找到一个大的出口商名单。对于我们的例子，我们感兴趣的是<a class="ae nf" href="https://github.com/wrouesnel/postgres_exporter" rel="noopener ugc nofollow" target="_blank"> postgresql导出器</a>。我们先安装一下。</p><h2 id="c0d6" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">PostgreSQL导出器安装</h2><p id="07df" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们回到Kubernetes集群，使用helm来安装PostgreSQL exporter。为了加快速度，你可以使用一张<a class="ae nf" href="https://github.com/helm/charts/tree/master/stable/prometheus-postgres-exporter" rel="noopener ugc nofollow" target="_blank">现有的舵图</a>。您的执行命令将如下所示:</p><pre class="mq mr ms mt gt ng nh ni nj aw nk bi"><span id="5337" class="lz km iq nh b gy nl nm l nn no">helm upgrade --install --wait postgres-exporter \<br/> -f ./helm/postgres-exporter/values.yaml \<br/> stable/prometheus-postgres-exporter</span></pre><p id="fef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导出器将尝试连接您的数据库，因此我们必须填写数据库配置属性。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="a6ca" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">PostgreSQL导出器查询定义</h2><p id="95bf" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">一旦我们的出口商能够连接到数据库，我们必须定义这些查询，将在每次刮擦时间执行。您可以用三种普罗米修斯指标<a class="ae nf" href="https://prometheus.io/docs/concepts/metric_types/" rel="noopener ugc nofollow" target="_blank">中的一种来标记查询中的每个选定值。</a></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="62f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们希望将过去5分钟内发生的错误数量存储在errors变量中。因此，我们将错误标记为<strong class="jp ir">规格</strong>度量(14–16)。至此，您可以开始在Prometheus数据库中搜索&lt;query _ name&gt;_&lt;GAUGE metric name&gt;metric。指标的名称将是<strong class="jp ir"><em class="mo">pg _ failing _ event _ processing _ errors</em></strong>。</p><p id="1016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，您可以在您的指标中包含几个额外的标签，作为<strong class="jp ir">标签</strong>的查询类型，因为它是用事件名称(17–19)完成的。</p><h2 id="3cbc" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">连接Prometheus和PostgreSQL导出程序</h2><p id="2bdb" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们假设您已经在集群中安装了一个Prometheus。如果没有，您可以找到<a class="ae nf" href="https://github.com/helm/charts/tree/master/stable/prometheus" rel="noopener ugc nofollow" target="_blank">一个完美的掌舵图</a>并为集群提供它。此外，我们将集中扩展一个输入配置文件，以便您可以等到文章结束。</p><p id="bdf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我们需要添加一个新的scraper，它将在Prometheus端运行，并从PostgreSQL exporter中提取导出值。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="457c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来很简单，对吧？这里只有一个工作名称，频率和目标的地方刮的指标。我们刚刚使用了一个PostgreSQL exporter服务，它自动安装到带有helm chart的集群中，默认情况下有80个端口(第5行)。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/bdff5875324ff0aa474079094fb90760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWVImkEcq_l4Kfq0dyKZiw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Prometheus + PostgreSQL导出程序</figcaption></figure><h2 id="ecfb" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">警报管理器</h2><p id="f29c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们的系统必须配备Alertmanager，它将负责在触发警报时向订阅服务发送通知。</p><p id="5257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Alertmanager与Prometheus chart一起交付。您只需要提供一个适当的<em class="mo"> alertmanager.yml </em>属性:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">警报管理器配置</figcaption></figure><p id="e774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以找到关于<a class="ae nf" href="https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/" rel="noopener ugc nofollow" target="_blank">警报</a>的综合文档，并应用符合您目的的配置。</p><p id="1ada" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">警报是包含<a class="ae nf" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> PromQL </a>表达式的普罗米修斯实体。表达式会不时地被求值，一旦表达式变得有效，就会向Alertmanager发送适当的警报。</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">普罗米修斯警报</figcaption></figure><h2 id="10a4" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">订阅服务</h2><p id="6c95" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">您还需要开发一个警报接收器。将会推出订阅服务。我们将引入一个用于POST请求的<strong class="jp ir">/通知</strong>端点和文档中定义的<a class="ae nf" href="https://prometheus.io/docs/alerting/configuration/#webhook_config" rel="noopener ugc nofollow" target="_blank">消息数据模型</a>。</p><h2 id="67d4" class="lz km iq bd kn ma mb dn kr mc md dp kv jy me mf kz kc mg mh ld kg mi mj lh mk bi translated">确认</h2><p id="8b7d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">如果您现在部署Prometheus，将状态为<strong class="jp ir">ERROR</strong>的警报放入数据库，并等待5分钟(您可以减少测试时间),然后您将看到警报已被检测到并发送到Alertmanager，后者将消息进一步转发到订阅服务。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/7e1a9ba4182a2c3f97b28faab5bdd550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkKWsc9MP4byvFzWneevDg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">最终建筑</figcaption></figure><p id="479c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以按照自己的意愿自由管理收到的警报。在我们的例子中，我们希望订阅服务找出事件的来源，并通知它发生了错误，这意味着我们希望再次收到丢失的消息。</p><p id="44a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记，Alertmanager已经能够向<a class="ae nf" href="https://prometheus.io/docs/alerting/configuration/#webhook_config" rel="noopener ugc nofollow" target="_blank">预定义的系统</a>发送消息。我们描述的方法是基于webhook的，旨在提供最灵活的警报消息处理方式。</p><h1 id="4c50" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="6ff5" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在本文中，我们学习了如何识别传入消息处理中发生的问题，以及如何执行操作以避免丢失数据。</p><p id="acf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们观察了Prometheus导出器的现有实现。</p><p id="2b6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们安装了PostgreSQL exporter并定义了一个定期执行的查询。结果被普罗米修斯抓住，在内部坚持。</p><p id="c785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们描述了如何配置Alertmanager。之后，如果触发了特殊的Prometheus实体警报，将会生成一条适当的消息，并发送给充当代理的Alertmanager，并将消息转发给webhook。</p></div></div>    
</body>
</html>