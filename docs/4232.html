<html>
<head>
<title>Templating Concourse pipelines with Jsonnet: An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jsonnet模板化Concourse管道:简介</h1>
<blockquote>原文：<a href="https://itnext.io/templating-concourse-pipelines-with-jsonnet-an-introduction-1d5fdadc1db2?source=collection_archive---------10-----------------------#2020-05-19">https://itnext.io/templating-concourse-pipelines-with-jsonnet-an-introduction-1d5fdadc1db2?source=collection_archive---------10-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/2fc075e27fb1860664e0b279b3ae3f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/0*H7pEH6uCGNyPlB6x.png"/></div></figure><p id="81b2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你在YAML 谈论<a class="ae kv" href="https://www.thoughtworks.com/radar/techniques/templating-in-yaml" rel="noopener ugc nofollow" target="_blank">模板，这肯定会引起一些人的惊讶。这是完美风暴。一个支持空白的模板语言加上一些糟糕的注释意味着你将陷入痛苦的世界。我最近试图滥用</a><a class="ae kv" href="https://docs.gomplate.ca/" rel="noopener ugc nofollow" target="_blank"> gomplate </a>来生成一些<em class="kw"> YAML </em>的文件，结果很恶心。</p><p id="2808" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们同意不做它。它不是为此而建的。然而，在某些时候，YAML的文件变得很难处理。就像你在<a class="ae kv" href="https://concourse-ci.org/" rel="noopener ugc nofollow" target="_blank">广场</a>定义管道一样。</p><p id="b603" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是为什么我想讨论生成YAML的<em class="kw">模板。为此我一直在使用Jsonnet，我对目前的结果很满意。代码是<a class="ae kv" href="https://github.com/sirech/example-concourse-pipeline" rel="noopener ugc nofollow" target="_blank">这里</a>如果你想直接跳到它。</em></p><h1 id="774f" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">无论如何，模板化有什么意义呢？</h1><p id="33c7" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">简单地说，<em class="kw"> YAML </em>很<strong class="jz iu">啰嗦。这也是大多数CI/CD工具选择的格式。这意味着很有可能你迟早会使用<em class="kw"> YAML </em>定义交付管道。我在<a class="ae kv" href="https://www.thoughtworks.com/insights/blog/modernizing-your-build-pipelines" rel="noopener ugc nofollow" target="_blank">深度</a>中写过关于高质量管道的文章。我只关心管道，它能告诉我到底哪里出了问题，而不必检查大量的日志输出。假设我的管道中有一个作业失败了:</strong></p><figure class="mb mc md me gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/b130fb06478e339e3edbcd380c04e0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vVD8Uu_JEOIkcAjd.png"/></div></div></figure><p id="3821" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我知道林挺失败了。具体是哪一部分？如果这项工作被很好地分成几个任务，我一眼就能发现问题所在:</p><figure class="mb mc md me gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/4fd4981e729f914f43139cc9ca6c4cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nqXgITYwtwz78saj.png"/></div></div></figure><p id="9e44" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我有一个颗粒分解，包括每一个任务，我可以直接找到错误，而不用进行考古调查。不过，坏处呢？很多加价。很喜欢，非常喜欢。这就是这个简单的任务的样子:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6382" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个任务定义使用锚和一个参数化的任务来减少重复，这是你在<em class="kw">会场</em>所能做的最多的事情。尽管如此，这仍然是太多的代码。随着管道功能的增加，它会变得越来越大。YAML并没有给我们提供一种对抗重复的方法。</p><h1 id="99a1" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">拯救世界</h1><p id="d30a" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated"><em class="kw"> Jsonnet </em>是一种数据模板语言。您定义您的数据，它为您创建一个或多个<em class="kw"> JSON </em>文档。至关重要的部分是，它为您提供了函数、条件、变量和其他工具来构建更强大的抽象。正是我需要的！一会儿之后，我们就可以出发了。</p><p id="c08d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你肯定知道，<em class="kw"> YAML </em>是<em class="kw"> JSON </em>的超集。如果该工具正在输出<em class="kw"> JSON </em>，我们可以无损地将其转换为<em class="kw"> YAML </em>。我们将建立一个精简的、可维护的、没有任何丑陋的漏洞的管道。</p><h1 id="9e32" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一个小型实用函数库</h1><p id="868d" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">Concourse有一堆基本的抽象概念。你有<a class="ae kv" href="https://concourse-ci.org/resources.html" rel="noopener ugc nofollow" target="_blank">资源</a>、<a class="ae kv" href="https://concourse-ci.org/jobs.html" rel="noopener ugc nofollow" target="_blank">工作</a>和<a class="ae kv" href="https://concourse-ci.org/tasks.html" rel="noopener ugc nofollow" target="_blank">任务</a>等等。每一个都由一个具有某些属性的对象来表示。我们可以通过使用接收配置并发出有效对象的函数来实例化一个。以下是一些例子:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4506" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在导入库之后，您可以在一个<code class="fe ml mm mn mo b">.jsonnet</code>文件中使用它们作为常规函数。</p><pre class="mb mc md me gt mp mo mq mr aw ms bi"><span id="2517" class="mt ky it mo b gy mu mv l mw mx">local concourse = import 'concourse.libsonnet'; concourse.GitResource(source, 'https://github.com/sirech/example-concourse-pipeline.git')</span></pre><p id="dfa7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">语法有点类似于JavaScript和Python。它不完全是一种编程语言，但是你有更多的玩具可以玩。此外，还有一个很大的标准库可以使用。我已经将这些构建模块打包成一个<a class="ae kv" href="https://github.com/sirech/concourse-jsonnet-utils" rel="noopener ugc nofollow" target="_blank">小库</a>，只需提取代码就可以重用。</p><h1 id="6fc3" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">少点YAML，多点索尼特</h1><p id="a129" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">假设我们正在定义我们的<code class="fe ml mm mn mo b">resources</code>。我有一个示例项目，看起来像这样:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d6a5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">代码并不多，但是你可以感觉到它的结构非常重复。在我们之前定义的助手的帮助下，我们可以做得更好。</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b9cd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过使用<code class="fe ml mm mn mo b">GitResource</code>和<code class="fe ml mm mn mo b">DockerResource</code>，我们在不损失可读性的情况下获得了更紧凑的东西。</p><h1 id="6008" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">构建您自己的DSL</h1><p id="8474" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">每个管道都是不同的，这意味着很难找到通用的抽象。但是在一个管道中，你倾向于看到某些模式的出现。我们创造它们是为了让过量的YAML更容易被接受，即使我们仍然依赖于复制粘贴。</p><p id="086c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果构建一个小型DSL来表达这些模式会怎么样？我通常将相同的输入传递给每个作业，因此我有一个函数来并行获取它们:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e626" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可以看到，通过变量，我将它与上面定义的资源保持同步。你可以使用<a class="ae kv" href="https://www.pythonforbeginners.com/basics/list-comprehensions-in-python" rel="noopener ugc nofollow" target="_blank">列表理解</a>让代码更有表现力。</p><p id="c5a8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我的<a class="ae kv" href="https://concourse-ci.org/tasks.html" rel="noopener ugc nofollow" target="_blank">任务定义</a>也遵循定义好的结构。它们存储在<code class="fe ml mm mn mo b">source</code>中，在一个定义的文件夹中。我们设置了一些基线参数。所有这些上下文都以特定于管道的方式来创建任务。</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0df0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一步一步，我们有一个定制的功能集，产生一个更小的管道。这样更一致，也更容易改变。</p><h1 id="1add" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">回到我们开始的庞大的棉绒工作</h1><p id="6e79" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">那个剥棉绒的工作有很多重复。是时候将所有这些小块组合成一个作业定义了。其结构如下所示:</p><figure class="mb mc md me gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/3c2b369af0b1af896c89ae28faf7169c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*XemAUoSE3XYSh4ah.png"/></div></figure><p id="1699" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们有<code class="fe ml mm mn mo b">Job</code>、<code class="fe ml mm mn mo b">Inputs</code>，还有一些<code class="fe ml mm mn mo b">Tasks</code>。让我们使用我们定义的所有函数:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d21d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我真的很喜欢这个！是不是太自作聪明了？我觉得不是！你会看到一个清晰的结构。如果你需要改变或添加什么东西，你做一次，而不是多次。我们已经从大约30行的纯粹重复变成了一个紧密的块，仍然清楚地传达它做了什么。</p><h1 id="8705" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">如何由此生成管道</h1><p id="e8c4" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">我喜欢将<code class="fe ml mm mn mo b">json</code>输出转换为<em class="kw"> YAML </em>，并使用<code class="fe ml mm mn mo b">fly set-pipeline</code>生成文件。这是脚本:</p><figure class="mb mc md me gt ju"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="3f43" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="2a9b" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">当我开始使用Jsonnet时，我有所保留，但我真的印象深刻。您可以真正减少重复的数量。检查<a class="ae kv" href="https://github.com/sirech/example-concourse-pipeline/blob/master/pipeline.jsonnet" rel="noopener ugc nofollow" target="_blank">该管道</a>以获得初步体验。在以后的文章中，我会试着举一个更大的例子，我们正在处理一个巨大的500多行的基础设施管道。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="c768" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kw">原载于2020年5月19日https://hceris.com</em><em class="kw">T21</em><a class="ae kv" href="https://hceris.com/templating-concourse-pipelines-with-jsonnet/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>