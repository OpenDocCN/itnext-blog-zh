<html>
<head>
<title>Why the Kotlin/Native memory model cannot hold.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么科特林/原生记忆模型不成立。</h1>
<blockquote>原文：<a href="https://itnext.io/why-the-kotlin-native-memory-model-cannot-hold-ae1631d80cf6?source=collection_archive---------1-----------------------#2019-08-19">https://itnext.io/why-the-kotlin-native-memory-model-cannot-hold-ae1631d80cf6?source=collection_archive---------1-----------------------#2019-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f4c08f4591a8191929a41152b0f5d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9D1Mwf982eJTzhUq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">冰冻是美丽的。(照片由<a class="ae kc" href="https://unsplash.com/@giacbrd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贾科莫·贝拉尔迪</a>拍摄)</figcaption></figure><p id="b93b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">编辑:本文描述的记忆模型并不成立。Jetbrains在一篇</em></strong><a class="ae kc" href="https://blog.jetbrains.com/kotlin/2020/07/kotlin-native-memory-management-roadmap/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">2020年7月的帖子</em> </strong> </a> <strong class="kf ir"> <em class="lb">中公布了一个急需的改动，其中已经更新了一篇</em></strong><a class="ae kc" href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-native-memory-management-update/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lb">2021年5月的帖子</em> </strong> </a> <strong class="kf ir"> <em class="lb">。由于新的内存管理器尚未稳定或默认，因此本文仍然相关。然而，请注意，本文中描述的一切都将在未来发生变化，Jetbrains正在积极努力减轻所描述的痛苦。</em> </strong></p><p id="af61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你听说过Kotlin多平台，它与你通常看到的银弹多平台不同:</p><ul class=""><li id="285c" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">它实际上编译成“本机”二进制文件。这意味着Android的JVM字节码或iOS的LLVM /二进制位。</li><li id="49bd" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">它提出了一个专用于多平台的完整的代码架构，允许平台特定的实现。</li><li id="a19e" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">它有着惊人的互操作性故事，无论是与Swift、JS、C &amp;当然还有Java。</li><li id="d5c4" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">它是由实际设计该语言的公司开发和支持的，所以它不是“添加”在语言之上，而是从一开始就存在的。</li></ul><p id="5b28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以也许这一次，会有所不同。也许会有用。也许有一个银弹。怀着喜悦的心情，您开始将依赖于JVM的Kotlin代码移植到多平台架构上，它可以编译了！</p><p id="3c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你运行它…</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="4aa7" class="lz ma iq lv b gy mb mc l md me">Uncaught Kotlin exception: kotlin.native.concurrent.InvalidMutabilityException: mutation attempt of frozen com.Whatever@1aec038</span></pre><p id="44d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为，是的，Kotlin/Native runtime实际上强制执行了一批非常重要的线程相关代码健全性规则，第一条是:</p><blockquote class="mf"><p id="f0fe" class="mg mh iq bd mi mj mk ml mm mn mo la dk translated">数据要么是可变的，要么是共享的。</p></blockquote><p id="679c" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如果您需要共享一个对象，您可以冻结它，因为:</p><blockquote class="mf"><p id="7594" class="mg mh iq bd mi mj mk ml mm mn mo la dk translated">冻结的数据不能被改变。</p></blockquote><p id="d18e" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">另外:</p><blockquote class="mf"><p id="8a31" class="mg mh iq bd mi mj mk ml mm mn mo la dk translated">冻结对象会冻结它引用的所有内容。冻结的对象不能解冻。</p></blockquote><p id="17e5" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">那么,“静态”数据呢，比如顶级变量或对象？<br/>嗯:</p><blockquote class="mf"><p id="b7a9" class="mg mh iq bd mi mj mk ml mm mn mo la dk translated">默认情况下，顶级对象被冻结。</p></blockquote></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="0783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是一个关于如何克服这些限制或如何正确地让代码在Kotlin多平台上工作的故事。这是一个关于局限性本身的故事。</p><p id="b9ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要了解这些局限性背后的原因。它们是哲学的和实用的。</p><p id="c2c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从哲学上讲，这是一个范式转变。没有可共享的可变数据，就不需要互斥，这意味着没有竞争条件以及固定的性能。这个模型鼓励我们以不同于我们习惯的方式来思考我们的代码:我们不是在线程之间共享资源，而是命名一个负责资源的线程并向它发送动作。只有一个线程访问资源，所有其他线程都要求所有者线程代表它们对资源执行操作。这种模型被称为“基于演员的编程”, KotlinX Coroutines库(有趣的是，正是因为这些限制，kot linx Coroutines库不支持Kotlin/Native上的多线程)使这个模型变得非常简单。然而，他们正在<a class="ae kc" href="https://github.com/Kotlin/kotlinx.coroutines/issues/462" rel="noopener ugc nofollow" target="_blank">为之努力</a>。</p><p id="773a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，实施这一点意味着运行时垃圾收集器更容易编写、可优化和可预测。</p><p id="8a9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我真的很喜欢这些约束。我碰巧认为，一种编程语言强加给我们的约束越多，我们就越不会发布有问题的应用程序。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="becf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，这些约束有什么问题呢？<br/>可悲的是，很多。虽然约束本身是合理的，非常有趣，但它们在Kotlin/Native编译器&amp;运行时的实现是有问题的。原因如下:</p><p id="9085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1:这些限制仅适用于kot Lin/Native</strong></p><p id="7baf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin/Native只有作为多平台体验的一部分才有价值。悲伤却真实。没有一个iOS程序员会用Kotlin而不是Swift来制作一个仅支持iOS的应用程序。也没有一个高性能的服务器程序员会喜欢Kotlin/Native而不是C++或Rust。高性能桌面应用也是如此。Kotlin/Native可能获得一些关注的唯一领域是嵌入式。这还远远没有完成。</p><p id="f645" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这些限制是Kotlin/Native独有的，它们将程序员从Kotlin多平台体验中推开。当他们试图移植现有的工作代码时，不得不重新思考他们的整个架构，这让他们中的大多数人感到沮丧。</p><p id="bf09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，由于对应的API只存在于Kotlin/Native中，这使得<a class="ae kc" href="https://github.com/Kotlin/kotlinx.coroutines/issues/462#issuecomment-450035178" rel="noopener ugc nofollow" target="_blank">几乎不可能</a>用通用代码&amp;通用语义编写一些库。</p><p id="ea1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2:这些限制是纯粹的。我们很实际。</strong></p><p id="9f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你第一次开始思考基于演员的编程时，你会大吃一惊。你觉得开明，聪明。将代码分解成参与者意味着划分资源和职责。每个参与者的功能都是原子性的，每个参与者都可以与其他参与者就其原子功能之外的请求进行通信。这是一种非常有趣、安全、伟大的编码方式……直到你开始进行基准测试。</p><p id="f1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请理解我与那些认为#PerfMatters无处不在，无时不在的人相去甚远。我更喜欢“效率高于性能”的人。然而，有时候性能确实很重要。一切都取决于上下文，我们不能排除关键路径中性能的必要性。</p><p id="25b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看<a class="ae kc" href="https://gist.github.com/SalomonBrys/688b2ccc10e3a7cea47966bf57d1cf89" rel="noopener ugc nofollow" target="_blank">这个基准</a>。下面是它打印的内容:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="b983" class="lz ma iq lv b gy mb mc l md me">With Mutex:<br/>Completed 1000000 actions in 661 ms<br/>Counter = 1000000<br/>With Semaphore:<br/>Completed 1000000 actions in 413 ms<br/>Counter = 1000000<br/>With Lock:<br/>Completed 1000000 actions in 81 ms<br/>Counter = 1000000<br/>With Actor:<br/>Completed 1000000 actions in 576 ms<br/>Counter = 1000000</span></pre><p id="2af1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">系统锁比actors快7倍。这个<em class="lb">可能</em>是件大事。<br/>如果共享资源不是通过关键路径访问的，那么演员的表现绝对没问题。如果是的话，那就有问题了。<br/>那是因为只有<em class="lb">一个</em>演员被限制在<em class="lb">一个</em>线程中。基于Actor的编程的优点也是它的弱点:每次你需要访问资源时，都有消息在线程间传递。</p><p id="1a8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">演员大部分时候都很棒，但不是每次都很棒。</p><p id="23af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哦。该基准测试甚至没有显示使用读写锁的好处，因为它非常依赖于上下文，但是在很少写入和大量读取的情况下，使用这样的锁可以进一步提高actors的性能。</p><p id="eff3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3:这些限制在运行时强制执行</strong></p><p id="6fb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JVM或JS中编译和运行良好的代码在本机运行时会崩溃。<br/>只需5行代码:</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="57c2" class="lz ma iq lv b gy mb mc l md me">object Foo { var bar = 21 }<br/>fun main() {<br/>    Foo.bar = 42 // Crash happens here!<br/>    <em class="lb">println</em>(Foo.bar)<br/>}</span></pre><p id="fcaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记得吗？这是“<em class="lb">顶层对象默认冻结</em>”和“<em class="lb">冻结的数据不能变异</em>”的工作。</p><p id="30bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这些限制是在运行时强制实施的，所以编译器和IDE都不会警告你正在做<em class="lb">禁止</em>的事情。它会编译，在JVM &amp; JS中运行良好，在Native中崩溃。<br/>事实上，IDE的编译器没有办法警告你，因为不变性不是类型系统的一部分。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="e9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第1点和第2点的影响是相似的:这让开发者望而却步。关于观点，这可以是好事也可以是坏事。有人可能会说“如果你不喜欢做正确的事情，就离开我的语言”。是的，强迫开发者执行好的实践是一件非常好的事情。我们都喜欢将可空性嵌入到Kotlin类型系统中，即使我们必须编写额外的可空性检查。迫使开发者进行范式转变可能是件好事，但我担心JetBrains低估了这种转变的成本。我担心强迫开发者采用他们“更好”的方式，实际上是在把他们推开。这是一种直觉，我没有数据支持它。但是，作为一个专业认证的Kotlin训练师，我看到过Kotlin/Native的采用被推迟正是因为这个。</p><p id="3f45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，最让我困扰的是第三点。就我个人而言，我无法理解JetBrains是如何认为让这么简单的代码编译并在运行时崩溃是没问题的。<br/>kot Lin如此受欢迎的一个主要原因是<em class="lb">确切地说是</em>，因为在编译时会检测到许多崩溃，从而阻止应用程序的编译和部署。这就是为什么人们喜欢可空性、智能强制转换、(非常)强类型等。<br/>在运行时强制实施不变性似乎是一个巨大的错误。感觉就像<em class="lb">让狼进羊圈</em>(法语表达)。突然，在Kotlin/Native中编译并在任何其他平台上运行的代码会崩溃，而没有太多警告。突然，感觉这种语言在和我们作对，而不是和我们合作。感觉科特林背叛了我们。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="eee7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种方法可以改善这种情况。要么修复语言，要么修复运行时。</p><p id="8fcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何修复这种语言？一种方法是将<strong class="kf ir">常量类</strong>添加到语言中，这将被描述为“一个只有不可变数据的类:要么是原语，要么是常量对象”。这种方法的一个好处是允许<a class="ae kc" href="https://github.com/Kotlin/KEEP/pull/51" rel="noopener ugc nofollow" target="_blank"> hashcode优化</a>。那么就不需要freeze() API: const类是freeze的定义。再者，“const”已经是一个语言关键词了。<br/>另一种方式是像Rust一样实现<a class="ae kc" href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" rel="noopener ugc nofollow" target="_blank">所有权</a> &amp; <a class="ae kc" href="https://doc.rust-lang.org/book/ch16-00-concurrency.html" rel="noopener ugc nofollow" target="_blank">并发原语</a>。我很乐意这样做，但我担心Kotlin已经偏离这些原则太多了，而且为时已晚(此外，Rust中的所有权与内存收集高度相关)。</p><p id="13fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可悲的是，修复语言是一个更加复杂和令人生畏的方法，所以看起来JetBrains正在走一条更容易的路。是好事吗？<br/>我应该说没有办法确定这种新的“放松模式”真的会上市。这可能只是一个测试。<br/>修复运行时确实降低了门槛，因为每个程序员都可以继续用他们过去的方式编码，但我无法停止这样的感觉，即我们作为一个语言社区，可能正在失去“正确并发”的梦想。也许我们还不够努力？</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="b81b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结论来了:以它目前的形式，它的记忆模式正在伤害Kotlin/Native。这使得编写不管平台如何都具有相同语义的多平台代码变得非常困难，这使得开发人员望而却步，并且这使人感觉这种语言在运行时崩溃，强制执行工具没有显示的任意规则，从而与我们作对。</p><p id="7386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它撑不住了。<br/>我真的希望不会。</p><p id="3f01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不意味着范式本身就是错误的。只是实现。有很多方法可以以一种正确的、不那么令人沮丧的方式实现这一点，我真诚地希望Kotlin语言设计者会选择这条路。如果没有，那么编译器插件可能是我们尝试新事物的一种方式！</p></div></div>    
</body>
</html>