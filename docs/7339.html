<html>
<head>
<title>Optimistic Lock in GORM Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松实现GORM的乐观锁定</h1>
<blockquote>原文：<a href="https://itnext.io/optimistic-lock-in-gorm-made-easy-19eb90f796bd?source=collection_archive---------0-----------------------#2022-08-25">https://itnext.io/optimistic-lock-in-gorm-made-easy-19eb90f796bd?source=collection_archive---------0-----------------------#2022-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="70aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于在GORM中实现乐观锁您需要知道的一切。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8342f321f332189178b514ea54acb038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtiWiUaXsUBAA0jgTCQxFA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@paulius005?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">保利乌斯·德拉古纳斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/db-lock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="7d32" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是乐观锁？</h1><p id="1b86" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">乐观锁</strong>又称<strong class="lt iu">乐观并发控制</strong> (OCC)，是一种应用于RDBMS等事务型系统的并发控制方法。</p><p id="c8e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如<a class="ae ky" href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" rel="noopener ugc nofollow" target="_blank">维基百科</a>所述:</p><blockquote class="ms mt mu"><p id="9b0c" class="lr ls mv lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated">OCC通常用于低<a class="ae ky" href="https://en.wikipedia.org/wiki/Block_contention" rel="noopener ugc nofollow" target="_blank">数据争用</a>的环境中。当冲突很少发生时，事务可以完成，而不需要管理锁，也不需要事务等待其他事务的锁被清除，从而比其他并发控制方法具有更高的吞吐量</p></blockquote><p id="164b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于本文的目的是讨论如何在GORM中实现OCC，所以我将忽略对OCC本身的详细解释。</p><p id="6485" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了方便后面的讨论，我先列出一个OCC的核心要素:</p><ol class=""><li id="a1e7" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">向表中添加一列，记录该行的版本</li><li id="c1c3" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">在更新该行的任何字段之前，从数据库中读取版本</li><li id="e6fe" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">在更新过程中，调整SQL的两个部分:</li></ol><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5e0d" class="ns la it no b gy nt nu l nv nw">1. add a condition to <!-- -->WHERE<!-- --> clause to make sure only the data with the same version could be updated: <strong class="no iu">WHERE … and version = [current version] </strong></span><span id="85a2" class="ns la it no b gy nx nu l nv nw">2. increase version number in SET clause to make sure version will be changed for every update: <strong class="no iu">UPDATE SET version = version + 1 ...</strong></span></pre><p id="3cdf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">4.更新后检查受影响的行数，如果它为零(表示更新冲突)，那么我们应该重试更新，直到它不为零。</p><h1 id="0c4c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">如何在GORM中实现乐观锁</h1><p id="39d0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上面的逻辑并不复杂，但是每次我们需要OCC的时候手动这样做是非常无聊和容易出错的。</p><p id="9cf2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">众所周知，GORM有一个基于插件的架构师。如果我们可以用插件实现OCC，那将是一个优雅的解决方案。</p><p id="f55d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">幸运的是，GORM团队的想法和我们完全一样。事实上，他们已经提供了我们需要的插件:<code class="fe ny nz oa no b"><a class="ae ky" href="https://github.com/go-gorm/optimisticlock" rel="noopener ugc nofollow" target="_blank">go-gorm/optimisticlock</a></code>。</p><p id="2304" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个插件的帮助下，在GORM中实现OCC变得非常简单。我举个例子来演示一下。</p><p id="60f4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们向GORM模型添加一个版本字段，它的类型是<code class="fe ny nz oa no b">optimisticlock.Version</code></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6ada" class="ns la it no b gy nt nu l nv nw">import (    <br/>    "<strong class="no iu">gorm.io/plugin/optimisticlock</strong>" <br/>)<br/> ... <br/>type Blog struct {    <br/>    Id      int  <br/>    Title string  <br/>    Content string     <br/>    // add version column to support optimistic lock  <br/>    <strong class="no iu">Version optimisticlock.Version </strong><br/>}</span></pre><p id="661b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">深入挖掘插件的源代码，你会发现<code class="fe ny nz oa no b">optimisticlock.Version</code>是<code class="fe ny nz oa no b">sql.NullInt64</code>的简单类型别名</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0ff4" class="ns la it no b gy nt nu l nv nw">package <strong class="no iu">optimisticlock</strong> <br/>... <br/>type Version sql.NullInt64</span></pre><p id="4a87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">添加了版本字段后，GORM中的更新会自动获得OCC容量。</p><p id="ebc5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当发生更新冲突时，<code class="fe ny nz oa no b">RowsAffected</code>将为零，我们应该向调用者返回一个错误。下面的代码片段显示了如何更新一篇<strong class="lt iu">博客</strong>文章的标题字段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更新磁贴</figcaption></figure><p id="4737" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在更新冲突的情况下，需要重试。我们使用我的另一篇文章中提到的通用库<code class="fe ny nz oa no b">samber/lo</code>:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c51a" class="ns la it no b gy nt nu l nv nw">// retry three times in case error<br/>_, err := lo.Attempt(3, func(_ int) error {      <br/>    return UpdateTitle(db, 1, "foo bar")  <br/>})</span></pre><h1 id="f66f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">有哪些GORM方法受到了<code class="fe ny nz oa no b">the Plugin</code>的影响？</h1><p id="5460" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ny nz oa no b">go-gorm/optimisticlock</code>是一个GORM插件，所以所有支持插件的方法都会受到影响:</p><ol class=""><li id="5fec" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe ny nz oa no b">Update</code></li><li id="9f39" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe ny nz oa no b">Updates</code></li><li id="c5fb" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe ny nz oa no b">Create</code></li></ol><p id="50e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不支持插件的方法不受影响:</p><ol class=""><li id="a144" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe ny nz oa no b">UpdateColumn</code></li><li id="4d71" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe ny nz oa no b">UpdateColumns</code></li></ol><h1 id="2d3e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">注意:不要使用DB。救援</h1><p id="c8c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">不要用<code class="fe ny nz oa no b">DB.Save</code>，因为用<code class="fe ny nz oa no b"><a class="ae ky" href="https://github.com/go-gorm/optimisticlock" rel="noopener ugc nofollow" target="_blank">go-gorm/optimisticlock</a></code>无法正常工作，虽然支持插件。</p><p id="b1f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面的代码片段显示了这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用保存更新全部</figcaption></figure><p id="a1e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">发生更新冲突时，<code class="fe ny nz oa no b">UpdateAll</code>返回一个错误，并显示消息“<strong class="lt iu">重复键值违反</strong>”，而不是预期的<code class="fe ny nz oa no b">ErrOptimisticLock.</code></p><p id="ab82" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">仅当主键重复时，才会出现错误“<strong class="lt iu">重复键值违反了“</strong>”。</p><p id="ea19" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为什么我们会得到这个错误？答案在<code class="fe ny nz oa no b">DB.Save</code>的源代码里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DB。保存()</figcaption></figure><p id="0b2e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是<code class="fe ny nz oa no b">DB.Save</code>的流程图。从这个图表中，你会发现错误的根本原因是<code class="fe ny nz oa no b">tx.RowsAffected == 0</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e5e19ca464ee808104fcaf0310711d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7n-9QeVhbdGVQ0beCQrZg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">数据库流程图。救援</figcaption></figure><p id="5478" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ny nz oa no b">tx.RowsAffected</code>是否将<strong class="lt iu">置零</strong>如果发生更新冲突，这将导致<code class="fe ny nz oa no b">DB.Save</code>再次插入。</p><p id="498e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是主键不为空，所以返回错误“<strong class="lt iu">重复键值违反了</strong><strong class="lt iu">。</strong></p><p id="4412" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要解决这个问题，我们需要用<code class="fe ny nz oa no b">DB.Updates</code>替换<code class="fe ny nz oa no b">DB.Save</code>。</p><p id="ba68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于<code class="fe ny nz oa no b">DB.Updates</code>默认只更新<a class="ae ky" href="https://gorm.io/docs/update.html#Updates-multiple-columns" rel="noopener ugc nofollow" target="_blank">非零字段</a>，我们还需要在更新前添加<code class="fe ny nz oa no b">DB.Select(*)</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">全部更新</figcaption></figure><h1 id="8873" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结束语</h1><ul class=""><li id="fa8d" class="mz na it lt b lu lv lx ly ma oe me of mi og mm oh nf ng nh bi translated">OCC是控制数据库并发的有用工具。</li><li id="6827" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oh nf ng nh bi translated">用官方团队的插件在GORM中实现OCC非常容易</li><li id="e855" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oh nf ng nh bi translated">避免在这个插件中使用<code class="fe ny nz oa no b">DB.Save</code>,因为它们有冲突</li></ul></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="4867" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>