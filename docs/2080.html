<html>
<head>
<title>Teleporter: Design your own network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传送器:设计你自己的网络</h1>
<blockquote>原文：<a href="https://itnext.io/teleporter-design-your-own-network-af20d12454be?source=collection_archive---------4-----------------------#2019-03-27">https://itnext.io/teleporter-design-your-own-network-af20d12454be?source=collection_archive---------4-----------------------#2019-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f7df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你是否曾希望在工作时可以接入家庭网络？事情变得简单了…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c2cf1dd68de66627639e7447a54c6fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NEbK_ar_RZmGRX8K7BJTlw.png"/></div></div></figure><p id="77cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我一直在思考我们一年前做的一个项目，我们定制了NGrok代码来创建一个隧道解决方案，将基于AWS的浏览器连接到客户的本地web服务器，用于功能测试产品(Microfocus SRF)。我一直认为协议隧道是一个令人兴奋的概念，是一种在雷达下爬行的聪明方法，可以向相反方向发送请求，钻透令人窒息的保护漏洞，并建立不可能的连接。</p><p id="a178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想到了创建类似的东西，这将有助于保护家庭自动化设置，并在不使用端口映射、设置VPN或严重影响网络性能的情况下将工作和家庭环境融合在一起。传送是我想出来的，从头开始写在muxado上，<strong class="jp ir">并且设置起来很容易。</strong></p><h2 id="b83d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">使用</h2><p id="5655" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">因此，在进一步解释之前，这里是如何使用它:</p><p id="beed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">本地机器上的演示:</strong></p><ol class=""><li id="e412" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">下载最新建造的<a class="ae me" href="https://github.com/amitbet/teleporter/releases/tag/1.0" rel="noopener ugc nofollow" target="_blank">传送点</a></li><li id="66f3" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk ma mb mc md bi translated">在任一示例中使用“run.bat”在本地主机上运行几个节点</li><li id="cea4" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk ma mb mc md bi translated">将您的浏览器配置为使用现在在localhost:10101上运行的socks5代理来查看它的运行情况。</li></ol><p id="bdd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">建立真实网络:</strong></p><ol class=""><li id="893e" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk ma mb mc md bi translated">安装一些免费的云服务器(GCP会给你300美元一年，没有义务，只要输入信用卡信息，AWS免费云服务器也是一个选择)</li><li id="84b5" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk ma mb mc md bi translated">在机器上放置一个节点，并向公众开放中继端口</li><li id="8310" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk ma mb mc md bi translated">在你喜欢的机器上部署传送节点&amp;配置(见下文)构建你自己的互联网！</li></ol><h2 id="1900" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">配置文件结构:</h2><p id="f042" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">该配置的设计基本上是自解释的，它保存了创建侦听器、建立连接和限制网络访问的所有信息。默认规则是拒绝访问，当前请求将被路由到允许所请求地址的第一个节点。</p><p id="2a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传送配置文件分为3个部分:</p><ul class=""><li id="21f2" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk mk mb mc md bi translated"><strong class="jp ir">服务器</strong>:创建两种不同类型的监听器:socks5代理&amp;中继</li><li id="de70" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated"><strong class="jp ir"> Tethers </strong>:定义与其他节点上中继端口的连接</li><li id="323b" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated"><strong class="jp ir"> netConf </strong>:包含节点的ID和映射规则，允许访问可从该节点到达的资源，这部分配置在连接到其他节点时发送给它们，这实现了智能路由。映射规则是按顺序执行的，它们规定了下一步将为路由选择哪个节点，选择“本地”意味着请求已经到达目的地，应该在当前机器上运行。</li></ul><pre class="km kn ko kp gt ml mm mn mo aw mp bi"><span id="e4a2" class="kx ky iq mm b gy mq mr l ms mt">{<br/>    "servers": [<br/>        {<br/>            "port": 10101,<br/>            "type": "socks5",<br/>            "acceptLocalOnly": true,<br/>            "useAuthentication": true,<br/>            "authClients": {<br/>                "socks5User": "&lt;SECRET STRING&gt;"<br/>            }<br/>        }<br/>    ],<br/>    "tethers": [<br/>        {<br/>            "port": 10201,<br/>            "host": "127.0.0.1",<br/>            "connectionType": "tls",<br/>            "connectionName": "Connection to node2",<br/>            "proxy": {<br/>                "address": "&lt;proxy address&gt;"<br/>                "user":"&lt;optional proxy user&gt;"<br/>                "pass":"&lt;optional proxy password&gt;"<br/>            },<br/>            "password": "&lt;SECRET STRING&gt;"<br/>        }<br/>    ],<br/>    "netConf": {<br/>        "clientId": "node1",<br/>        "networkMapping": {<br/>            <strong class="mm ir">// send all *google* domain requests through node2</strong><br/>            "*google*": "node2",<br/>           <strong class="mm ir"> //if not captured with prev rules - execute locally</strong><br/>            "*": "local"<br/>        }<br/>    },<br/>    "proxy": null,<br/>    "numConnsPerTether": 10<br/>}</span></pre><h2 id="107e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">潜在用途:</h2><ul class=""><li id="13f0" class="lv lw iq jp b jq lq ju lr jy mu kc mv kg mw kk mk mb mc md bi translated">保持与家用设备的安全连接，无需端口映射</li><li id="476a" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">无缝RDP/VNC到多个网络，以实现远程支持</li><li id="15e9" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">创建从客户站点到云服务的安全代理连接</li><li id="cb6a" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">无需您的IT部门的帮助，弥合网络差距</li><li id="479c" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">无需使用VPN即可保持工作连接</li><li id="a810" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">用作自定义VPN来欺骗您的来源，保护您的隐私并获得基于位置的服务</li><li id="5428" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">通过socks5代理和一些中继向潜在客户或云测试场公开本地web服务器</li></ul><h2 id="183e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">安全功能:</h2><ul class=""><li id="90dd" class="lv lw iq jp b jq lq ju lr jy mu kc mv kg mw kk mk mb mc md bi translated">节点间连接(网络)是TLS加密的</li><li id="c863" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">Socks5连接可以受密码保护(尽管没有加密)</li><li id="1a33" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">Socks5连接可以被限制为只接受来自本地主机的连接</li><li id="a4bf" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">中继服务器验证(客户端在服务器配置中有一个密码)</li></ul><h2 id="6f67" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">瞬移不就是另一个VPN吗？</h2><p id="6ba0" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我思考这个问题已经有一段时间了:VPN、隧道和Socks5已经存在很多年了，这个想法以前有过吗？事实证明，有很多类似的东西:OpenVPN、BadVPN &amp; Brook，仅举几个例子，但每一个在一些基本方面都是不同的。但是VPN本质上是点对点隧道，通过加密通道将你带入网络，就像传送一样:</p><ul class=""><li id="a69a" class="lv lw iq jp b jq jr ju jv jy lx kc ly kg lz kk mk mb mc md bi translated"><strong class="jp ir"> Teleporter在每个隧道的多个TCP通道上使用多路复用</strong>，大多数VPN在较低的网络层上运行，其他VPN(如OpenVPN)依赖UDP作为其主要传输方式，以避免<a class="ae me" href="https://en.wikipedia.org/wiki/Head-of-line_blocking" rel="noopener ugc nofollow" target="_blank">线路头问题</a>，有一些实现支持TCP隧道，但使用单一TCP连接，并认为这是在特定情况下使用的糟糕解决方案。TCP支持允许通过大多数公司环境限制的隧道，这些限制基于只允许TCP在端口80/443上或使用HTTP代理，使用多个连接这样做可以避免在未知或丢失的TCP数据包后面阻塞浏览器连接。</li><li id="14b0" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated"><strong class="jp ir"> Teleporter只中继指定地址的请求，</strong>它创建了一个极度分裂的隧道，让用户完全控制路由，这意味着大多数请求可以在本地处理，没有延迟或网络成本。这些特定的地址是你的偏远地方(如家里)，或被你的工作网络屏蔽的地址(如:box.com，thepiratebay等)。)对于在本地执行的流量，几乎没有性能损失，而对于从未到达过的站点，只需支付少量的性能费用，这样就可以进行家庭访问，而不必进行杂乱的端口映射，以免将您的家庭机器暴露给公共互联网上的攻击者。Socks5不使用多路复用，也是未加密的，这意味着本地流量没有握手延迟或加密开销。</li><li id="a477" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated"><strong class="jp ir"> Teleporter轻松创建多跳网络</strong>，这不是典型的VPN设置</li><li id="e943" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated"><strong class="jp ir"> Teleporter非常容易设置:</strong>只需更改JSON文件中的几行，在几台机器上运行单个二进制文件就可以为自己创建一个分布式网络，设置浏览器或OS代理通过本地socks5代理运行，就大功告成了。</li><li id="04b3" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated"><strong class="jp ir">传送机内置于Go </strong>中，所以它很容易编译到所有主流操作系统中。</li><li id="7069" class="lv lw iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mb mc md bi translated">在Teleporter(未来功能)中，重写规则可以用来拥有一个“CNAME ”,比如:home.com代表你的家庭机器地址。</li></ul><h2 id="1f56" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">它是如何工作的？</h2><p id="3cfc" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">每个传送节点都能够创建中继服务器、socks5服务器，并将连接束(也称为系绳)连接到其他中继节点，一个系绳拥有多个TCP连接，每个连接都能够进行TCP多路复用。每个这样的系绳都是双向的，允许任何一方发起请求。</p><h2 id="219b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">完整的故事</h2><p id="96da" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我们最初的解决方案基于NGrok 1.0，在浏览器机器上添加了http代理服务器，这意味着对于每个浏览器连接，我们都创建了从代理到隧道服务器、从隧道客户端到隧道服务器以及从隧道客户端到web服务器的连接。在我们构建它并开始致力于连接缓存和重用之后，我认为“这可以通过多路复用来更好地解决”，但是当深入研究这个主题时，我发现由于TCP要求每个数据包都有一个ACK，所以它往往会被卡住(T4的线路头问题)，UDP应该用于这样的解决方案，但是UDP不会通过大多数公司的设置， 永远不要把WAF传递到AWS农场……我决定放弃这个话题，但我脑海中的某个角落一直在唠叨，应该有更好的方法 ..所以我创建了<strong class="jp ir">传送点</strong>作为辅助项目来更好地探索可能性。</p></div></div>    
</body>
</html>