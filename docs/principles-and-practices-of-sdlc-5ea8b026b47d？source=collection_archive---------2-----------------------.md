# 企业软件开发的原则、实践和谚语

> 原文：<https://itnext.io/principles-and-practices-of-sdlc-5ea8b026b47d?source=collection_archive---------2----------------------->

![](img/d6a4fae5ff4b67e332eeca82c0846252.png)

本文总结了一些核心原则、最佳实践，以及我对管理软件开发生命周期的常识。这些 SDLC 思想适用于产品和项目。我期待着与更广泛的社区讨论这些想法。

**可行性(为什么)**

*   确定产品/项目**投资者、**业务发起人、关键利益相关者和系统客户。
*   建立**经济模型**，其成本和收益跨越平均水平和最佳/最坏情况。
*   写一份清晰的**使命和愿景陈述**。

**需求(什么)**

*   记录最低可行产品的业务和技术需求( **MVP** )。
*   肉出**用户**故事、**数据**模型、**第三方** **约束**，商业规则，以及为什么，而不仅仅是什么。
*   原型 **UI** 和 **MVP** 概念；从关键用户和领域专家那里获得反馈。

**项目管理(谁、何时、何地)**

*   将项目或产品的交付定义为大的**里程碑**和更小的**迭代**。
*   每次迭代使用 3-4 周，然后**冲刺**。作为一个团队计划短跑。
*   安排**每日**检查和**每周**会议，以审查**进度**、**障碍**和**范围**。
*   定义**变更控制流程**，将利益相关者与变更的成本/收益权衡联系起来。
*   创建**工作分解结构**；定义和排序活动。
*   从工程部门获得劳动力和材料**成本估算**——而不是管理或营销部门。
*   为技术、流程和业务事宜建立**单一责任点**。
*   计划和分发**通信**。管理利益相关者的期望。报告绩效。
*   确定十大项目/产品**风险**。全程监控和传达风险评估。
*   确定由 3-5 名**人员**组成的**核心团队**(例如，大披萨的大小)，包括业务、工程和 QA。
*   发布用于管理成本、风险、QA、团队、采购和需求的计划**文档**。

**系统架构和组件设计(How)**

*   定义主要构建模块，包括它们的**职责**和**接口**(米勒法则:< 9)。
*   **使用 **UML** 图将**解决方案架构可视化，以便共同理解。
*   **单一责任** —组件应该只有一个改变和存在的理由。
*   **封装** —只共享需要的东西；隐藏细节。
*   **内聚**——收集和发布相关的组件、功能和数据。
*   **依赖倒置**——依靠抽象，而不是具体来管理变化。
*   **简单** —尽可能使部件/系统简单；最小化复杂性。
*   **稳定性** —使用稳定的抽象、依赖和接口。
*   一致性 —使用一致的命名约定、代码风格等。
*   **干**——不重复自己。
*   YAGNI——你不会需要它的。事情变了。计划变了。避免镀金。
*   **接吻**——尽量简单。但并不简单。
*   在维护迭代期间重构。设计不会在一个阶段结束。
*   考虑**领域特定语言**来表示灵活的逻辑和规则。
*   考虑**反射**，动态特征表面的基于属性的编程。
*   考虑**微服务**将单片系统缩减为模块化组件。
*   考虑**并发**和扩展到多个处理器、机器和网络。
*   考虑**可移植性**和向其他平台/基础设施环境的迁移。
*   为国际观众考虑本地化和国际化。
*   考虑将**语音**和**触摸**用户接入更广泛的受众。

**安全**

*   如何保护解决方案？考虑**用户**，**数据**，以及**系统**本身。
*   用户**如何认证**和**如何授权**？
*   数据在存储和传输中需要**加密**吗？
*   向用户和服务帐户授予**最低权限**。
*   使用**企业身份管理**系统(例如活动目录)，这些系统**联合**。
*   避免发明自己的用户/组/密码管理和加密系统。

**数据库**

*   酸有必要吗？然后可能是 SQL/RDBMS。或者可伸缩性建议 NoSQL？
*   **使用图表可视化**逻辑**实体**及其**关系**。
*   使用主键和外键实现参照完整性。
*   对列数据完整性使用 default 和 check 约束。
*   对大型表(1M+)使用索引，对大型数据集(1B+)使用分区。
*   对于非常大的数据集(1T 以上)，使用面向文档的 NoSQL 数据库。
*   避免使用游标、触发器和动态 SQL。谨慎而有意识地使用它们。
*   **通过组和角色保护**访问。
*   针对**增长**和**灾难恢复**的计划。**性能**和**可靠性**的压力测试。

**神器控制**

*   使用**版本控制系统**管理源代码、二进制引用和文档。
*   更喜欢**饭桶**；所有其他 VCS 系统都是劣等的。
*   通过组和角色保护对工件的访问。
*   计划让几个人在一段时间内，也许是同时在系统上工作。
*   源代码不归 1 个人所有；它属于这个团队。

**质量控制**

*   防御性编码。检查参数。使用断言。没有破窗。
*   有正确性测试吗？整合？性能？保安？UX？
*   定义**自动化单元测试**，例如 MSTest、NUnit、jUnit 或 RUnit。
*   将清单驱动的手动 beta 测试分配给**独立的**高级用户组。
*   编码前审查设计。
*   **在生产部署前审查**代码。

**Devops**

*   解决方案将在哪里运行？台式机？手机？在 Prem？云？
*   随着时间的推移，您将如何交付系统更新和**变更**？
*   为开发、测试和生产维护**单独的环境**。
*   你如何**记录**系统活动，尤其是**错误**和**最终用户**使用情况？
*   **使用 VSTS、Chef、Octopus、PowerShell、bash 等，从开发到生产自动化构建和部署。**

**支持(发布后的寿命)**

*   用户**如何就特性和缺陷联系**你？
*   在**在线待办事项列表**中跟踪过去、现在和未来的工作。
*   使用 JIRA、VSTS 或类似的系统。像躲避瘟疫一样避开电子表格和电子邮件。

**客户**

*   **取悦**用户。承诺不足，兑现过度。
*   **优先考虑**来自影响他人且充满热情的超级用户的系统反馈。
*   关键用户应该是项目和产品团队的一部分，并且**每天在现场**可用。

**Peopleware**

*   将团队成员的兴趣与工作分配结合起来。
*   创建**工作空间**，支持深思熟虑、专注、不间断的工作。避免开放式办公室。
*   通过让人们参与游戏来建立决策的责任和义务。
*   花时间**庆祝**达到里程碑并进行**事后检查**。

**比喻**

*   **不确定性的圆锥**—探索风险领域并学习减少生命周期中的不确定性。
*   **三角形**约束——成本、范围和质量。3 选 2；想要拥有一切是很难的。
*   **追踪器**子弹——使用原型和特征长钉在黑暗中寻找移动目标。
*   **Microstones** —跟踪较小单位工作的进展，以保持团队专注于里程碑。

**谚语**

*   和用户一起工作，像用户一样思考。
*   不要像散落的种子一样聚集需求；像挖掘宝藏一样挖掘它们。
*   如果没有计划，没有人遵循计划，当事情发生变化时也不改变计划，你就会失败。
*   抽象比细节更长久。
*   尽早、经常、自动地进行测试。
*   提供选项；不要给蹩脚的借口。
*   别人口中的话，比打开你的更好卖。
*   具有概念完整性的好架构应该管理复杂性和变化。
*   不要假设某事是真的；试着证明一下。
*   在你的作品上签名；以质量和工艺为荣。
*   如果你发现痛苦超过两次，那就自动化它。
*   “又快又脏”的代价往往比速赢的好处持续更久，变得更脏。
*   最好和完美是好的敌人。
*   你不是靠开发软件赚钱，而是靠交付和销售软件赚钱。
*   利用 80/20 法则——在设计前完成 80%的需求，在编码前完成 80%的设计。

*欣赏文章？关注我* [*中*](https://medium.com/@bishr_tabbaa) *和* [*推特*](https://twitter.com/bishr_tabbaa) *了解更多更新。*

**参考文献**

*   [精益企业](http://a.co/7e7x5ZG)作者:Humble，Molesky 和 O'Reilly
*   肯特·贝克[极限编程](http://a.co/aDgf7mz)
*   安德鲁·亨特和迪夫·托马斯的实用程序员
*   史蒂夫·麦康奈尔完成的
*   [GoF 设计模式](http://a.co/fQYBYSE)
*   迈克尔·尼加德[发布](http://a.co/f2b8QEr)
*   史蒂夫·麦康奈尔的软件项目生存指南
*   汤姆·狄马克和蒂姆·李斯特的《人民软件》
*   乔尔·斯波尔斯基的《通向伟大代码的 12 个步骤》
*   比什尔·塔巴的企业软件架构师阅读清单