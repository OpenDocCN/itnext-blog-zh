<html>
<head>
<title>Scala Syntax for Java Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Scala语法</h1>
<blockquote>原文：<a href="https://itnext.io/scala-syntax-for-java-developers-69734ce17cdf?source=collection_archive---------1-----------------------#2020-08-21">https://itnext.io/scala-syntax-for-java-developers-69734ce17cdf?source=collection_archive---------1-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a00e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Scala和Java之间一些常见语法差异的快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a89b784ea2f39a1f4bcdb0617a6437f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tB-b31cGbI1tGFpl"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@disguise_truth?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安娜斯塔西娅·杰尼娜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fbfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对Scala感兴趣的Java开发人员可能会发现语法上的差异令人望而生畏。下面是一些不同于Java的Scala语法规则的指南。最后，我们将浏览一个全面的Scala代码示例。</p><p id="dcc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们不会在这里探究Scala的高级、强大的特性。<a class="ae ky" href="https://medium.com/wix-engineering/scala-comprehending-the-for-comprehension-67c9f7953655" rel="noopener">For-comprehensive</a>、<a class="ae ky" href="https://medium.com/@olxc/https-medium-com-olxc-implicits-in-scala-b2dcfccaa9e8" rel="noopener">implicit</a>、<a class="ae ky" href="https://www.tutorialspoint.com/scala/scala_pattern_matching.htm" rel="noopener ugc nofollow" target="_blank"> pattern-matching </a>以及其他特性将在专门的文章中更好地讨论。相反，本文将帮助那些对探索Scala感兴趣，但只是很难理解他们所看到的代码示例的Java开发人员。</p><p id="2b18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p><h2 id="e662" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">类型声明在变量名之后</h2><p id="ffc9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Java中，我们先声明类型，然后声明变量名，就像这样:<br/> <code class="fe mt mu mv mw b"><strong class="lb iu">Animal</strong> a = getAnimal();</code></p><p id="1f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，类型在后面:<br/> <code class="fe mt mu mv mw b">val a: <strong class="lb iu">Animal</strong> = getAnimal();</code></p><h2 id="10a3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">变量被声明为不可变的(val)或可变的(var)</h2><p id="b0be" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Scala中，我们以<code class="fe mt mu mv mw b">val</code>或<code class="fe mt mu mv mw b">var</code>开始变量声明，而不是像在Java中那样以类名开始。</p><p id="d449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">val</code>(简称<em class="mx">值</em>)表示变量不可变(类似Java中的<code class="fe mt mu mv mw b">final</code>):<br/><code class="fe mt mu mv mw b">val a: Animal = getAnimal(); // `a` <em class="mx">cannot</em> be subsequently reassigned</code></p><p id="6939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">var</code>(变量的简称)表示变量是可变的:<br/> <code class="fe mt mu mv mw b">var a: Animal = getAnimal(); // `a` <em class="mx">can</em> be subsequently reassigned</code></p><p id="4c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala支持不变性，所以大多数情况下，你会看到使用<code class="fe mt mu mv mw b">val</code>。</p><h2 id="4774" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">类型声明通常可以省略</h2><p id="889e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Scala有非常强的类型推断能力。所以我们很少需要显式声明类型。这就是当声明一个变量时，类放在最后的原因之一；很容易这样简单地省略:<br/> <code class="fe mt mu mv mw b">var a = getAnimal(); // `a` is still an instance of Animal</code></p><h2 id="35dd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">不需要用分号来表示行尾</h2><p id="d899" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">分号实际上只在多条语句出现在同一行时才需要:<br/> <code class="fe mt mu mv mw b">var a = getAnimal(); println(a)</code></p><p id="b364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以，而且几乎总是这样做，省略行尾的分号:<br/> <code class="fe mt mu mv mw b">var a = getAnimal()</code></p><h2 id="a4c8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法和函数是用“def”关键字声明的</h2><p id="280f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">方法和函数(一个<em class="mx">函数</em>类似于一个<em class="mx">方法</em>，但不属于任何类)用<code class="fe mt mu mv mw b">def</code>关键字声明。它们的返回类型在函数名和冒号后声明。他们的身体通常跟在等号后面:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="8836" class="lv lw it mw b gy nc nd l ne nf">def getAnimal(): Animal = {<br/>  // body goes here ...<br/>}</span></pre><h2 id="b091" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">当调用无参数方法或函数时，可以省略括号</h2><p id="3242" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Java中，我们总是在调用方法时提供括号:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="3a08" class="lv lw it mw b gy nc nd l ne nf">Animal a = getAnimal();</span></pre><p id="0551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当调用不带参数的Scala函数或方法时，可以省略括号:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="ace6" class="lv lw it mw b gy nc nd l ne nf">val a = getAnimal()<br/>// or<br/>val a = getAnimal</span></pre><h2 id="a47c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法和函数不需要显式返回任何东西</h2><p id="e581" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">方法或函数中的最后一个值或表达式成为隐式返回值:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="0ba3" class="lv lw it mw b gy nc nd l ne nf">def add(x: Int, y: Int): Int = {<br/>  x + y  // the sum of x and y will be implicitly be returned<br/>}</span></pre><p id="6836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，尽管Scala中存在<em class="mx"> return </em>关键字，但它几乎从未被使用过。</p><h2 id="0c54" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">单位表示无效</h2><p id="b5c8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果一个Java方法没有返回值，那么它被声明为返回<em class="mx"> void </em>:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="2390" class="lv lw it mw b gy nc nd l ne nf">public void output(String s) {<br/>  System.out.println(s);<br/>}</span></pre><p id="ba31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，返回类型将被声明为<em class="mx">单元</em>:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="f01e" class="lv lw it mw b gy nc nd l ne nf">def output(s: String): Unit = {<br/>  println(s)<br/>}</span></pre><h2 id="c78a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法和函数很少需要声明它们的返回类型</h2><p id="28cd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Scala的强类型推理意味着我们很少需要声明函数/方法的返回类型:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="0684" class="lv lw it mw b gy nc nd l ne nf">def add(x: Int, y: Int) = {<br/>  x + y  // The compiler infers that an Int will be returned<br/>}</span></pre><p id="a7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在以下情况下，我们仍然需要声明返回类型:</p><ul class=""><li id="5de8" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">该方法是抽象的</li><li id="018a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们想返回一个推断返回类型的超类</li><li id="3c06" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们只是想更加清楚</li></ul><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="fd69" class="lv lw it mw b gy nc nd l ne nf">def getAnimal(): Animal {<br/>  // if we omitted the return type, Scala would infer Dog<br/>  new Dog() <br/>}</span></pre><h2 id="c909" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">方法和函数不需要大括号</h2><p id="5413" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果方法或函数的主体不超过一行(或表达式)，则可以省略大括号:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="d94f" class="lv lw it mw b gy nc nd l ne nf">def add(x: Int, y: Int) = <br/>  x + y</span><span id="c80a" class="lv lw it mw b gy nu nd l ne nf">// or</span><span id="1d71" class="lv lw it mw b gy nu nd l ne nf">def add(x: Int, y: Int) = x + y</span></pre><h2 id="2a01" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">可以用命名参数调用方法和函数</h2><p id="3dc5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Java中，当调用接受多个参数的方法时，我们不能包含参数名。相反，我们只是按照在方法中声明的顺序传递值:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="bdb4" class="lv lw it mw b gy nc nd l ne nf">int i = add(6, 8);</span></pre><p id="fbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，我们可以选择将方法/函数称为“Java方式”,也可以包含全部或部分参数名:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="b1d9" class="lv lw it mw b gy nc nd l ne nf">val i = add(6, 8)<br/>// or<br/>val i = add(x = 6, y = 8)<br/>// or<br/>val i = add(x = 6, 8)<br/>// note: below will not compile:<br/>val i = add(6, y = 8)</span></pre><h2 id="06f5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">特征而不是接口</h2><p id="1dff" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java提供接口，Scala提供特性。像Java接口一样，特征可以包括抽象方法。和Java接口的默认方法一样，traits可以提供实现的方法。与接口不同，特征还可以包含变量。</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="830e" class="lv lw it mw b gy nc nd l ne nf">trait Shape {<br/>  val point: Point<br/>  def print() // no implementation, so implicitly abstract<br/>}</span></pre><h2 id="e2ec" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">`延伸'和` with '</h2><p id="5009" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">和Java一样，Scala类不能扩展多个父类。同样类似于Java，Scala类可以实现(或者用Scala的说法，<em class="mx">扩展</em>)多个特征。</p><p id="8548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个Scala类扩展一个类或一个特征时，就会使用<code class="fe mt mu mv mw b">extends</code>关键字。如果这个类扩展了任何额外的特征，那么使用关键字<code class="fe mt mu mv mw b">with</code>:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="4d88" class="lv lw it mw b gy nc nd l ne nf">class Shape { ... }</span><span id="6198" class="lv lw it mw b gy nu nd l ne nf">trait Drawable { ... }</span><span id="975a" class="lv lw it mw b gy nu nd l ne nf">trait Movable { ... }</span><span id="61f3" class="lv lw it mw b gy nu nd l ne nf">class Circle extends Shape with Drawable with Movable</span><span id="cacd" class="lv lw it mw b gy nu nd l ne nf">class Raster extends Drawable with Movable</span></pre><h2 id="95d5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">类是用括号中直接列出的成员来声明的</h2><p id="7c26" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">而我们可能在Java中定义一个简单的类，如下所示:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="f07f" class="lv lw it mw b gy nc nd l ne nf">public class Foo {<br/>  private String a;<br/>  private int b;<br/>  // getters, setters, constructors, etc<br/>}</span></pre><p id="91ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常会在一行中定义一个Scala类，就像这样:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="f1dc" class="lv lw it mw b gy nc nd l ne nf"><strong class="mw iu">class </strong>Foo(a: String, b: Int) { }</span></pre><p id="4722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号是可选的，除非需要声明额外的成员、方法等:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="27a1" class="lv lw it mw b gy nc nd l ne nf"><strong class="mw iu">class </strong>Foo(a: String, b: Int)</span></pre><h2 id="f56f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">案例类代表专门的数据类</h2><p id="c457" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java 14引入了记录的概念。如果您熟悉记录，那么您将很快熟悉案例类。否则，case类就是特殊的数据类。它们的语法类似于常规类:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="f451" class="lv lw it mw b gy nc nd l ne nf"><strong class="mw iu">case class </strong>Foo(a: String, b: Int)</span></pre><p id="5544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，编译器会自动生成数据类所需的标准方法，如<code class="fe mt mu mv mw b">equals()</code>、<code class="fe mt mu mv mw b">hashCode()</code>和<code class="fe mt mu mv mw b">toString()</code>方法、getters等。</p><p id="755f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还用<code class="fe mt mu mv mw b">apply()</code>和<code class="fe mt mu mv mw b">unapply()</code>方法生成一个“伴随对象”(我们稍后会讨论这些)。</p><h2 id="42b6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">泛型由方括号(<code class="fe mt mu mv mw b">[]</code>)表示，而不是尖括号(<code class="fe mt mu mv mw b">&lt;&gt;</code>)</h2><p id="6383" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Java中，我们用尖括号来表示泛型类型:<br/> <code class="fe mt mu mv mw b">List&lt;String&gt; list;</code></p><p id="0e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，方括号用来表示泛型类型:<br/> <code class="fe mt mu mv mw b">List[String] list</code></p><h2 id="3d3a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">字符串插值是通过以“s”为前缀的字符串来完成的</h2><p id="6221" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Java中，为了快速连接字符串，我们使用加号(+):<br/><code class="fe mt mu mv mw b">System.out.println("Hello, "+ firstName + " "+ lastName + "!");</code></p><p id="f551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，我们通过在字符串前面加上<em class="mx"> s </em>来执行字符串插值，并通过使用美元符号(<em class="mx"> $ </em> ): <br/> <code class="fe mt mu mv mw b">println(s"Hello, $firstName $lastName!")</code>来引用变量</p><p id="f201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">若要访问嵌套值或表达式，请使用大括号:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="958e" class="lv lw it mw b gy nc nd l ne nf">println(s"Hello, ${name.first} ${name.middle.getOrElse("")} ${name.last}!")</span></pre><h2 id="e8b4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">匿名函数看起来类似于Java lambdas，但是带有= &gt;符号</h2><p id="c25e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java在构造lambda函数时提供了语法糖:<br/> <code class="fe mt mu mv mw b">list.foreach(item -&gt; System.out.println("* " + item));</code></p><p id="095a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Scala中，我们在匿名函数中使用了<code class="fe mt mu mv mw b">=&gt;</code>符号:<br/> <code class="fe mt mu mv mw b">list.foreach(item =&gt; println(s"* $item"))</code></p><h2 id="7df9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">下划线充当占位符</h2><p id="d6ca" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Scala使用下划线作为占位符。您会在一些不同的用例中看到下划线，包括:</p><p id="2c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mx">匿名函数:</em> </strong> <br/>而不是在匿名函数中声明变量:<br/> <code class="fe mt mu mv mw b">list.foreach(item =&gt; println(item))</code></p><p id="cc55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以省略<em class="mx">项</em>变量，用下划线代替:<br/> <code class="fe mt mu mv mw b">list.foreach(println(_))</code></p><p id="29ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，与Java类似，我们可以通过提供对<code class="fe mt mu mv mw b">println</code>函数的引用来简化上面的行(该函数将隐式地将当前变量作为参数):<br/> <code class="fe mt mu mv mw b">list.foreach(println)</code></p><p id="f18a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mx">模式匹配:</em> </strong> <br/>当我们执行模式匹配时，我们试图将一个实例与其类型进行匹配。假设我们有这样一个案例类:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="ae12" class="lv lw it mw b gy nc nd l ne nf"><strong class="mw iu">case class</strong> Dog(name: String) extends Animal</span></pre><p id="723f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一个动物的实例<em class="mx">和</em>，我们可以尝试确定它是否是一只有特定名字的狗:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="26d1" class="lv lw it mw b gy nc nd l ne nf">a <strong class="mw iu">match</strong> {<br/>  case Dog(name) =&gt; println(s"Found a dog named $name");<br/>  ...<br/>}</span></pre><p id="a103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可能不关心狗的名字。<code class="fe mt mu mv mw b">Dog</code>的构造函数仍然接受一个参数，所以我们可以简单地使用下划线作为占位符:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="5d16" class="lv lw it mw b gy nc nd l ne nf">a <strong class="mw iu">match</strong> {<br/>  case Dog(_) =&gt; println(s"Found some dog");<br/>  ...<br/>}</span></pre><p id="0fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可能想知道我们是否找到了一个<code class="fe mt mu mv mw b">Dog</code>，或者除了<code class="fe mt mu mv mw b">Dog</code>之外的任何东西。我们再次使用下划线:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="ff2c" class="lv lw it mw b gy nc nd l ne nf">a <strong class="mw iu">match</strong> {<br/>  case Dog(_) =&gt; println(s"Found a dog");<br/>  case _ =&gt; println("Found something other than a dog")<br/>}</span></pre><h2 id="9e29" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">伴随对象而不是静态对象</h2><p id="058d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java有<em class="mx">静态</em>关键字，它描述绑定到特定<em class="mx">类</em>的变量和方法，而不是一个对象的实例。</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="ad83" class="lv lw it mw b gy nc nd l ne nf">public class UserManager {<br/>  public static void save(User u) {<br/>    //...<br/>  }<br/>}</span><span id="c9b9" class="lv lw it mw b gy nu nd l ne nf">// we can invoke that static method via:</span><span id="9639" class="lv lw it mw b gy nu nd l ne nf">UserManager.save(new User("Pat"));</span></pre><p id="7bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala不提供静态关键字<em class="mx">。然而，使用Scala，我们可以创建对象，这些对象有效地提供了相同的东西:</em></p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="1d09" class="lv lw it mw b gy nc nd l ne nf">object User {<br/>  def save(u: User) = {<br/>    // ...<br/>  }<br/>}</span><span id="d760" class="lv lw it mw b gy nu nd l ne nf">// we can invoke that object's method via:</span><span id="c14d" class="lv lw it mw b gy nu nd l ne nf">User.save(new User("Pat"))</span></pre><p id="2504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，Scala允许我们创建“伴侣对象”；也就是说，<em class="mx">对象</em>对应于同名的<em class="mx">类</em>:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="ec4c" class="lv lw it mw b gy nc nd l ne nf">class User(name: String) {<br/>}</span><span id="f2e3" class="lv lw it mw b gy nu nd l ne nf">// This is the companion object to the User class<br/>object User {<br/>  def apply() {<br/>    new User("Noname")<br/>  }<br/>  def apply(name: String) = {<br/>    new User(name)<br/>  }<br/>  def unapply(u: User) = {<br/>    Some(u.name)<br/>  }<br/>  def save(u: User) = {<br/>    // ...<br/>  }<br/>}</span></pre><p id="6c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们可以在类的伴随对象中定义任何函数，但是<code class="fe mt mu mv mw b">apply()</code>和<code class="fe mt mu mv mw b">unapply()</code>方法有特殊的含义。</p><p id="fa87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要调用对象的名称，后跟带有任意数量参数的括号，那么对象中相应的<code class="fe mt mu mv mw b">apply(…)</code>方法将被调用。</p><p id="9a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，调用<code class="fe mt mu mv mw b">User()</code>会导致<code class="fe mt mu mv mw b">User.apply()</code>被调用；调用<code class="fe mt mu mv mw b">User("Chris")</code>实际上会调用<code class="fe mt mu mv mw b">User.apply("Chris")</code>。通常，构造并返回伴生类的一个实例。以这种方式，一个伴随对象的<code class="fe mt mu mv mw b">apply()</code>方法可以——并且通常被——用作工厂方法。</p><p id="63bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们通常会看到这样创建的对象:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="179f" class="lv lw it mw b gy nc nd l ne nf">val u = User("Suzie")</span></pre><p id="9e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而不是这个:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="9f23" class="lv lw it mw b gy nc nd l ne nf">val u = new User("Suzie")</span></pre><p id="a856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe mt mu mv mw b">unapply()</code>用作解构者。每当需要一个类的单个组件时(比如在模式匹配期间)，它的<code class="fe mt mu mv mw b">unapply()</code>方法就会在后台被调用。</p><h1 id="0a4d" class="nv lw it bd lx nw nx ny ma nz oa ob md jz oc ka mg kc od kd mj kf oe kg mm of bi translated">一个全面的例子</h1><p id="b546" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们根据刚才的内容来分析一段Scala代码:</p><pre class="kj kk kl km gt my mw mz na aw nb bi"><span id="6a9d" class="lv lw it mw b gy nc nd l ne nf"><strong class="mw iu">case class </strong>Point(x: Int, y: Int)  // 1<br/><br/><strong class="mw iu">trait </strong>Drawable {  // 2<br/>  <strong class="mw iu">def </strong>draw(): Unit  // 3<br/>}<br/><br/><strong class="mw iu">abstract class </strong>Shape(<strong class="mw iu">val </strong>center: Point) {  // 4<br/>  <strong class="mw iu">def </strong>area(): Double <br/>}<br/><br/><strong class="mw iu">case class </strong>Circle(<strong class="mw iu">override val </strong>center: Point, radius: Int) <strong class="mw iu">extends </strong>Shape(center) <strong class="mw iu">with </strong>Drawable {  // 5<br/>  <strong class="mw iu">override def </strong>draw(): Unit = { // 6<br/>    <em class="mx">println</em>(<strong class="mw iu">s"⊙ "</strong>)<br/>  }<br/>  <strong class="mw iu">override def </strong>area() = Math.<em class="mx">PI </em>* (radius * radius) <br/>  <strong class="mw iu">def </strong>growBy(add: Int) = <em class="mx">Circle</em>(center, radius + add)  // 7<br/>}<br/><br/><strong class="mw iu">case class </strong>Square(<strong class="mw iu">override val </strong>center: Point, side: Int) <strong class="mw iu">extends </strong>Shape(center) <strong class="mw iu">with </strong>Drawable {<br/>  <strong class="mw iu">override def </strong>draw(): Unit = {<br/>    <em class="mx">println</em>(<strong class="mw iu">"◼︎"</strong>)<br/>  }<br/>  <strong class="mw iu">override def </strong>area() = Math.<em class="mx">PI </em>* (side * side)<br/>}<br/><br/><strong class="mw iu">object Canvas</strong> {  // 8<br/><br/>  <strong class="mw iu">def </strong>main(args: Array[String]): Unit = {  // 9<br/>    <strong class="mw iu">val </strong>circle1 = Circle(<em class="mx">Point</em>(50, 25), radius = 10)  // 10<br/>    <strong class="mw iu">val </strong>circle2 = circle1.growBy(5)<br/>    <strong class="mw iu">val </strong>square = Square(<em class="mx">Point</em>(100, 150), side = 30)<br/><br/>    <strong class="mw iu">val </strong>l: List[Drawable] = <em class="mx">List</em>(circle1, circle2, square)  // 11<br/>    l.foreach(_.draw())  // 12<br/><br/>    l.map(d =&gt; d <strong class="mw iu">match </strong>{  // 13<br/>      <strong class="mw iu">case </strong>Circle(_, r) =&gt; <strong class="mw iu">s"Circle of radius $</strong>r<strong class="mw iu">"  </strong>// 14<strong class="mw iu"><br/>      case </strong>Square(_, s) =&gt; <strong class="mw iu">s"Square of side length $</strong>s<strong class="mw iu">"<br/>      case </strong>_ =&gt; <strong class="mw iu">"Unknown shape"  </strong>// 15<strong class="mw iu"><br/>    </strong>}).foreach(<em class="mx">println</em>)  // 16<br/>  }<br/><br/>}</span></pre><ol class=""><li id="e7fc" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu og nm nn no bi translated">我们定义一个案例类，<code class="fe mt mu mv mw b">Point</code>。编译器在幕后为我们创建了一堆样板文件，包括一个<code class="fe mt mu mv mw b">Point</code>伴生类。</li><li id="73c8" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们定义一个特质，<code class="fe mt mu mv mw b">Drawable</code>，用…</li><li id="1efa" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">…一个隐式抽象方法，<code class="fe mt mu mv mw b">draw()</code>。由于该方法是抽象的，我们将返回类型指定为<code class="fe mt mu mv mw b">Unit</code>(这意味着不会返回任何内容)</li><li id="2d2e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们定义了一个抽象类<code class="fe mt mu mv mw b">Shape</code>，它声明了一个<code class="fe mt mu mv mw b">val</code>、<code class="fe mt mu mv mw b">center</code>和一个隐式抽象方法<code class="fe mt mu mv mw b">area()</code></li><li id="537a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们定义了一个case类<code class="fe mt mu mv mw b">Circle</code>，它扩展了<code class="fe mt mu mv mw b">Shape</code>类和<code class="fe mt mu mv mw b">Drawable</code>特征。</li><li id="83d0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们使用<code class="fe mt mu mv mw b">override</code>关键字来实现父类<code class="fe mt mu mv mw b">Shape</code>的抽象<code class="fe mt mu mv mw b">draw()</code>方法。这里，我们选择将方法体放在花括号中。</li><li id="9b5a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">然后我们定义另外两个方法:从父类<code class="fe mt mu mv mw b">Shape</code>覆盖的<code class="fe mt mu mv mw b">area()</code>方法，以及返回新<code class="fe mt mu mv mw b">Circle</code>实例的新<code class="fe mt mu mv mw b">growBy()</code>方法。在这两个基础中，我们从方法体中省略了花括号。</li><li id="ea2b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们创建一个<code class="fe mt mu mv mw b">Canvas</code>对象。它的所有功能都可以认为类似于Java的静态方法。</li><li id="d7d4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们可以定义一个<code class="fe mt mu mv mw b">main</code>方法，就像在Java中一样。在一个对象中，这个方法是静态的，可以像<code class="fe mt mu mv mw b">Canvas.<em class="mx">main</em>(<em class="mx">Array</em>())</code>一样被调用。</li><li id="bbbd" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们使用调用<code class="fe mt mu mv mw b">Circle</code>伴随对象的<code class="fe mt mu mv mw b">apply()</code>方法的语法糖创建一个<code class="fe mt mu mv mw b">Circle</code>实例。回想一下，<code class="fe mt mu mv mw b">Circle</code>伴随对象及其<code class="fe mt mu mv mw b">apply()</code>方法是由编译器生成的，因为<code class="fe mt mu mv mw b">Circle</code>是一个case类。</li><li id="688c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们创建了一个<code class="fe mt mu mv mw b">Drawable</code>的<code class="fe mt mu mv mw b">List</code>，用方括号表示<code class="fe mt mu mv mw b">List</code>的泛型类型。</li><li id="aa3d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们使用<code class="fe mt mu mv mw b">List</code>的<code class="fe mt mu mv mw b">foreach</code>方法来迭代它的<code class="fe mt mu mv mw b">Drawable</code>方法，调用各自的<code class="fe mt mu mv mw b">draw()</code>方法。为了简洁起见，我们使用下划线字符来表示当前的<code class="fe mt mu mv mw b">Drawable</code>。</li><li id="0e1c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">然后我们使用<code class="fe mt mu mv mw b">List</code>的<code class="fe mt mu mv mw b">map</code>方法将每个<code class="fe mt mu mv mw b">Drawable</code>转换成一个<code class="fe mt mu mv mw b">String</code>值。</li><li id="264d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们使用模式匹配来确定我们正在迭代的<code class="fe mt mu mv mw b">Drawable</code>的具体类型。在这一行中，我们寻找一个具有任何<em class="mx">中心</em>值的<code class="fe mt mu mv mw b">Circle</code>(由下划线字符表示)，并使用<em class="mx"> r </em>变量捕获<em class="mx">半径</em>值。然后我们使用字符串插值来创建一个包含那个<em class="mx"> r </em>值的<code class="fe mt mu mv mw b">String</code>。当匹配下面一行中的<code class="fe mt mu mv mw b">Square</code>时，我们做类似的事情。</li><li id="c3ea" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">我们通过使用下划线字符来捕获匹配既不是<code class="fe mt mu mv mw b">Circle</code>也不是<code class="fe mt mu mv mw b">Square</code>的<code class="fe mt mu mv mw b">Drawable</code>的情况。</li><li id="d1f0" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu og nm nn no bi translated">然后我们在<code class="fe mt mu mv mw b">Strings</code>的结果<code class="fe mt mu mv mw b">List</code>上调用<code class="fe mt mu mv mw b">foreach</code>，并引用<code class="fe mt mu mv mw b">println()</code>函数，该函数被当前正在迭代的<code class="fe mt mu mv mw b">String</code>隐式调用。</li></ol></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="8150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这个故事有用？想多读点？只需<a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener">在这里订阅</a>就可以将我的最新故事直接发送到你的收件箱。</p><p id="ba57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以支持我和我的写作——并获得无限数量的故事——通过今天<a class="ae ky" href="https://dt-23597.medium.com/membership" rel="noopener">成为媒体会员</a>。</p></div></div>    
</body>
</html>