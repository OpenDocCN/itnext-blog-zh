<html>
<head>
<title>Yeah, RISC-V Is Actually a Good Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是的，RISC-V实际上是一个很好的设计</h1>
<blockquote>原文：<a href="https://itnext.io/yeah-risc-v-is-actually-a-good-design-1982d577c0eb?source=collection_archive---------0-----------------------#2022-05-25">https://itnext.io/yeah-risc-v-is-actually-a-good-design-1982d577c0eb?source=collection_archive---------0-----------------------#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">业内知名人士如Dave Jaggar、Jim B. Keller和Dave Ditzel都对RISC-V竖起了大拇指。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc19a35b103c0d93804b2a61641cbaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRqRkTExeY4C5v0wW-02jw.png"/></div></div></figure><p id="8ffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">我写的关于RISC-V的文章越多，我就越意识到RISC-V在许多圈子里是多么有争议。20世纪80年代，RISC狂热者声称RISC-V是一个糟糕的设计，这并不罕见。问题是:你应该对互联网上发表这种言论的人投入多少股票？</p><p id="3512" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，你应该根据它的优点来判断一个设计，但是如果这对你来说还不够好，那么也许你可以尊重备受尊敬的微处理器设计师的意见。这是他们中的一些人对RISC-V的评论。</p><h1 id="97fa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">戴夫·贾格尔——手臂设计师</h1><p id="575a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">最近，Dave Jaggar做了一个关于Arm公司及其微处理器历史的演讲。你问戴夫·贾格尔是谁？维基百科是这样说的:</p><blockquote class="mw mx my"><p id="ab3c" class="ku kv mz kw b kx ky ju kz la lb jx lc na le lf lg nb li lj lk nc lm ln lo lp im bi translated">David Jaggar(生于1967年2月4日)是一名计算机科学家，他在1992年至2000年期间负责ARM架构的开发，将其从低成本工作站处理器重新定义为占主导地位的嵌入式系统处理器。</p></blockquote><p id="90d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">贾格尔做了许多重要的设计，这些设计有助于Arm的成功。一个重要的选择是，他负责发明压缩16位指令(Thumb ),这使得Arm在嵌入式领域取得了巨大成功。如果没有拇指臂，它永远也不会进入智能手机市场。Arm被诺基亚选中，因为他们将密集代码、高性能和低功耗集于一身。这对于压缩指令来说是不可能的。有趣的是，现代64位Arm没有压缩指令，但它是RISC-V的重要组成部分。</p><p id="bda3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在关于Arm历史的演讲中，Dave Jaggar被问到，如果你对微处理器感兴趣，应该研究什么架构。<a class="ae nd" href="https://youtu.be/%5C_6sh097Dk5k?t=3071" rel="noopener ugc nofollow" target="_blank">贾格尔回应</a> (51分钟):</p><blockquote class="mw mx my"><p id="6f5b" class="ku kv mz kw b kx ky ju kz la lb jx lc na le lf lg nb li lj lk nc lm ln lo lp im bi translated">有武装狙击手吗？我会在谷歌上搜索RISC-V，找到关于它的所有信息。<strong class="kw iu">他们做了一个很好的指令集</strong>，一个很好的工作，他们正在解释它。伯克利和斯坦福是幕后黑手。显然有SiFive这样的商业公司在做事情，但它是32位通用指令集的最先进产品，它有16位压缩的东西。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">戴夫·贾格尔讲述他是如何设计Arm芯片的，以及他对RISC-V的评论</figcaption></figure><h2 id="4cc7" class="nk ma it bd mb nl nm dn mf nn no dp mj ld np nq ml lh nr ns mn ll nt nu mp nv bi translated">吉姆·凯勒——AMD、苹果、特斯拉和英特尔设计师</h2><p id="4ce9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">吉姆·b·凯勒可能是当今最著名的微处理器设计师之一，因为他在AMD和苹果的成功中发挥了关键作用。让我们再次引用<a class="ae nd" href="https://en.wikipedia.org/wiki/Jim_Keller_(engineer)" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="mw mx my"><p id="be22" class="ku kv mz kw b kx ky ju kz la lb jx lc na le lf lg nb li lj lk nc lm ln lo lp im bi translated">詹姆斯·b·凯勒(生于1958年/1959年)是一名微处理器工程师，因其在AMD和苹果公司的工作而闻名。他是AMD K8微架构(包括最初的Athlon 64)的首席架构师，并参与了Athlon (K7)和苹果A4/A5处理器的设计。他还是x86–64指令集和HyperTransport互连规范的合著者。从2012年到2015年，他回到AMD，从事AMD K12和Zen微体系结构的工作。</p></blockquote><p id="b744" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用于苹果重要产品如iPhone 4、iPad和iPad 2的芯片是由凯勒设计的。在TechTechPotato 关于Arm vs x86 vs RISC-V的采访中，他这样说道:</p><blockquote class="mw mx my"><p id="bb84" class="ku kv mz kw b kx ky ju kz la lb jx lc na le lf lg nb li lj lk nc lm ln lo lp im bi translated">现在，RISC-V出现了。它是闪亮的新表亲，因为没有遗产，它实际上是一个开放的指令集架构，人们在大学里构建，他们没有时间或兴趣像一些架构那样添加太多垃圾，所以相对而言，因为它的血统和年龄，它处于复杂性生命周期的早期，并且<strong class="kw iu">它是一个非常好的指令集。他们做得很好</strong>，所以如果我只是想说我想建立一个计算机真的很快，我希望它去快，RISC-V是最简单的一个。它拥有所有合适的特征。它有所有正确的前八条指令。那些你真正需要优化的。它没有太多的垃圾。</p></blockquote><p id="0887" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Kelly提到的八条指令是在之前的采访中提到的，当时他谈到微处理器在大多数时间里只执行八条常用指令中的一条，如load、store、branch、add等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">吉姆·凯勒对RISC-V进行了评论，并解释了为什么他会选择它来制造快速CPU</figcaption></figure><h2 id="1f1e" class="nk ma it bd mb nl nm dn mf nn no dp mj ld np nq ml lh nr ns mn ll nt nu mp nv bi translated">戴夫·迪泽尔— Transmeta，RISC，世界语</h2><p id="f79a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">戴夫·迪泽尔以打破常规思维著称。让我引用<a class="ae nd" href="https://www.eejournal.com/article/machine-learning-esperanto-coaxes-1092-risc-v-processors-to-dance-on-the-head-of-a-pin-er-chip/" rel="noopener ugc nofollow" target="_blank"> EE期刊</a>来介绍他:</p><blockquote class="mw mx my"><p id="fe0c" class="ku kv mz kw b kx ky ju kz la lb jx lc na le lf lg nb li lj lk nc lm ln lo lp im bi translated">在贝尔实验室，迪特泽尔还与加州大学伯克利分校的大卫·帕特森教授合著了基础RISC文档“精简指令集计算机的案例”。然后，Ditzel加入Sun Microsystems，担任SPARC技术业务的首席技术官，领导SPARC RISC处理器体系结构和64位SPARC ISA的开发。甲骨文在2010年收购了太阳微系统公司，后来在2016年停止了SPARC公司的开发。但是由于SPARC国际，SPARC ISA继续作为完全开放的，非专有的，免版税的知识产权。</p></blockquote><p id="4b9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你们中的一些人可能还记得Transmeta，它是由迪策尔于1995年创立的。这是21世纪初Crusoe处理器的热门话题，许多人认为它会取代x86。它基于超长指令字(VLIW)的思想，编译器捆绑了可以并行执行的指令以提高性能。这个想法也是Transmeta芯片可以模拟任何ISA，包括x86。</p><p id="97e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读更多关于VLIW: <a class="ae nd" href="https://erik-engheim.medium.com/very-long-instruction-word-microprocessors-17262def3037" rel="noopener">超长指令字微处理器</a></p><p id="d1f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，我的观点是迪泽尔有跳出框框思考的历史。在创办世界语科技公司时，他和他的处理器设计师们着眼于创造这些定制芯片来加速人工智能。他们为这些芯片开发了自己的指令集，但意识到在工具和其他基础设施方面需要大量投资，因此开始关注RISC-V。通过一系列内部测试，他们得出结论，RISC-V实际上是一种设计非常好的ISA，可以用来构建他们的ET-SOC-1推理引擎。</p><h2 id="5f51" class="nk ma it bd mb nl nm dn mf nn no dp mj ld np nq ml lh nr ns mn ll nt nu mp nv bi translated">自己做比较</h2><p id="4066" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">多亏了<a class="ae nd" href="https://godbolt.org/z/bhhjscr3W" rel="noopener ugc nofollow" target="_blank"> Godbolt </a>，很容易快速地对各种指令集架构进行比较。许多人会制作这些小的汇编代码片段来证明RISC-V是一个糟糕的设计，它需要比同类架构多很多倍的指令。然而，如果你不仅仅看4-5个汇编操作码的玩具例子，这种情况就不会出现。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="6fa3" class="nk ma it nx b gy ob oc l od oe">// C - Most basic sorting algorithm<br/><br/>void bubble_sort(int xs[], int n) {<br/>    for (int i = 0; i &lt; n - 1; i++) {<br/>        for (int j = 0; j &lt; n - i - 1; j++) {    <br/>            // swap values if not in order<br/>            if (xs[j] &gt; xs[j + 1]) {<br/>                int temp = xs[j];<br/>                xs[j] = xs[j + 1];<br/>                xs[j + 1] = temp;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="4d81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在<a class="ae nd" href="https://godbolt.org/z/bhhjscr3W" rel="noopener ugc nofollow" target="_blank"> Godbolt </a>中比较一下这个基础代码的RISC-V、Arm和x86汇编代码。我尝试使用gcc 10.2.0，其中的选择有些随意，我使用针对小代码优化的<code class="fe of og oh nx b">-Os</code>开关得到了以下结果。</p><ul class=""><li id="89a1" class="oi oj it kw b kx ky la lb ld ok lh ol ll om lp on oo op oq bi translated">RV32gc (RISC-V 32位)— 24行代码</li><li id="e084" class="oi oj it kw b kx or la os ld ot lh ou ll ov lp on oo op oq bi translated">ARM 32位— 25行代码</li><li id="136f" class="oi oj it kw b kx or la os ld ot lh ou ll ov lp on oo op oq bi translated">x86–64–26行代码</li><li id="41a3" class="oi oj it kw b kx or la os ld ot lh ou ll ov lp on oo op oq bi translated">POWER (IBM RISC ISA) — 32行代码</li></ul><p id="6c90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有人可能会说，我们应该与64位Arm指令集等较新的架构进行比较。我们可以做到。然而，这对代码数量没有影响。奇怪的是，它在RISC-V代码中添加了另一行，但这一行完全没有意义。RV32gc开头的以下RISC-V汇编被重写:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="2237" class="nk ma it nx b gy ob oc l od oe"># RISC-V 32-bit code<br/><br/>li      a4,0            # Load 0 into register a4<br/>addi    a1,a1,-1        # Add -1 to register a1 and store in a1</span></pre><p id="8d51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于RV64gc，我们得到了一个不需要的move ( <code class="fe of og oh nx b">MV</code>)指令:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="b99a" class="nk ma it nx b gy ob oc l od oe"># RISC-V 64-bit code<br/><br/>addiw   t1,a1,-1   # could have written ADDIW a1, a1, -1 instead <br/>li      a4,0<br/>mv      a1,t1</span></pre><p id="9117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，即使RISC-V具有避免复杂指令的最小指令集，这个汇编代码对于冒泡排序也是最短的:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="3b6a" class="nk ma it nx b gy ob oc l od oe">bubble_sort:<br/>        li      a4,0           # load 0 into register a4<br/>        addi    a1,a1,-1       # add -1 to a1 and store in a1<br/>.L2:<br/>        ble     a1,a4,.L1      # if a1 &lt;= a4 goto L1<br/>        mv      a5,a0          # copy a0 into register a0<br/>        li      a3,0<br/>        sub     a7,a1,a4<br/>        j       .L6            # jump to .L6<br/>.L4:<br/>        lw      a2,0(a5)       # load word at address 0 + a5 into a2<br/>        lw      a6,4(a5)<br/>        ble     a2,a6,.L3<br/>        sw      a6,0(a5)       # store word in a6 at address 0 + a5<br/>        sw      a2,4(a5)<br/>.L3:<br/>        addi    a3,a3,1<br/>        addi    a5,a5,4<br/>.L6:<br/>        blt     a3,a7,.L4     # if a3 &lt; a7 goto .L4<br/>        addi    a4,a4,1<br/>        j       .L2<br/>.L1:<br/>        ret</span></pre><p id="2a52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许只是侥幸，那么用斐波那契递归调用怎么样？</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="8de2" class="nk ma it nx b gy ob oc l od oe">int fibonacci(int n) {<br/>   if (n == 0)<br/>      return 0;<br/>   else if (n == 1)<br/>      return 1;<br/>   else<br/>      return fibonacci(n-1) + fibonacci(n-2);<br/>}</span></pre><p id="fcd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，RISC-V稍微长一点:</p><ul class=""><li id="d1dc" class="oi oj it kw b kx ky la lb ld ok lh ol ll om lp on oo op oq bi translated">RISC-V 32和64位25行代码</li><li id="0039" class="oi oj it kw b kx or la os ld ot lh ou ll ov lp on oo op oq bi translated">ARM 64位— 20行代码</li><li id="7b18" class="oi oj it kw b kx or la os ld ot lh ou ll ov lp on oo op oq bi translated">x86–64–22行代码</li><li id="28f3" class="oi oj it kw b kx or la os ld ot lh ou ll ov lp on oo op oq bi translated">POWER64 (IBM RISC ISA) — 30行代码</li></ul><p id="0294" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RISC-V变得更长的主要原因是递归调用需要在堆栈上加载和存储变量:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c6c7" class="nk ma it nx b gy ob oc l od oe"># RISC-V 32-bit - recursive fibonacci <br/><br/>fibonacci:<br/>        addi    sp,sp,-16<br/>        sw      s0,8(sp)<br/>        sw      s1,4(sp)<br/>        sw      s2,0(sp)<br/>        sw      ra,12(sp)<br/>        mv      s0,a0<br/>        li      s1,0<br/>        li      s2,1<br/>.L3:<br/>        beq     s0,zero,.L2<br/>        beq     s0,s2,.L2<br/>        addi    a0,s0,-1<br/>        call    fibonacci<br/>        addi    s0,s0,-2<br/>        add     s1,s1,a0<br/>        j       .L3<br/>.L2:<br/>        add     a0,s0,s1<br/>        lw      ra,12(sp)<br/>        lw      s0,8(sp)<br/>        lw      s1,4(sp)<br/>        lw      s2,0(sp)<br/>        addi    sp,sp,16<br/>        jr      ra</span></pre><p id="43cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们写一个斐波那契的非递归变体，那么它最终会占用与64位Arm完全相同的19行代码。<a class="ae nd" href="https://godbolt.org/z/K91jTWsrq" rel="noopener ugc nofollow" target="_blank">看这里Godbolt </a>。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="9bee" class="nk ma it nx b gy ob oc l od oe"># RISC-V 64-bit - non-recursive fibonacci <br/><br/>fib:<br/>        li      a4,1<br/>        mv      a5,a0<br/>        bleu    a0,a4,.L5     # Branch Less or Equal Unsigned<br/>        li      a4,2<br/>        li      a0,0<br/>        li      a3,1<br/>        li      a2,0<br/>.L3:<br/>        ble     a4,a5,.L4<br/>        ret<br/>.L4:<br/>        addw    a0,a2,a3     # Add word (full 64-bits)<br/>        addiw   a4,a4,1<br/>        mv      a2,a3        # MoVe a3 to a2 (copy a3 to a2)<br/>        mv      a3,a0<br/>        j       .L3          # Jump to .L3<br/>.L5:<br/>        ret</span></pre><p id="9245" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">x86版本看起来更短，只有18行，但这只是因为它使用了更少的标签。如果你计算一下指令的数量，你会得到15条指令，这与64位Arm和RISC-V完全相同。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1593" class="nk ma it nx b gy ob oc l od oe">; x86-64 - non-recursive fibonacci<br/><br/>fib:<br/>        mov     eax, edi<br/>        cmp     edi, 1<br/>        jbe     .L1<br/>        mov     edx, 2<br/>        xor     eax, eax     # x86 trick to zero out eax register<br/>        mov     ecx, 1<br/>        xor     esi, esi     # set esi register to zero<br/>.L3:<br/>        cmp     edx, edi<br/>        jg      .L1<br/>        lea     eax, [rsi+rcx]<br/>        inc     edx          # increment edx (add 1)<br/>        mov     esi, ecx<br/>        mov     ecx, eax<br/>        jmp     .L3<br/>.L1:<br/>        ret</span></pre><p id="f0ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以做很多这样的测试，看看你得到了什么。我尝试了合并排序，得到了102条RISC-V指令、96条Arm指令和112条x86指令(去掉了标签)。我尝试了二叉树搜索，矩阵乘法和许多其他例子。一般来说，RISC-V做得很好。当有大量的保存寄存器要堆栈时，它做得不好，因为RISC-V没有像Arm那样存储和加载对或寄存器的指令。</p><p id="9756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阅读RISC-V如何产生更紧凑的代码:精简指令集的新案例<a class="ae nd" href="https://arxiv.org/abs/1607.02318" rel="noopener ugc nofollow" target="_blank"> Set Computer:通过RISC-V的宏操作融合避免ISA膨胀</a></p><p id="cf27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">视频讲座论文覆盖:<a class="ae nd" href="https://www.youtube.com/watch?v=HNjcQcjINNY" rel="noopener ugc nofollow" target="_blank">ISA Shootout—RISC V、ARM和x86的比较加州大学伯克利分校Chris Celio</a></p><p id="d3f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我也会谈到这个话题:<a class="ae nd" href="https://erik-engheim.medium.com/the-genius-of-risc-v-microprocessors-b19d735abaa6" rel="noopener">RISC-V微处理器的天才</a></p><h2 id="d5b1" class="nk ma it bd mb nl nm dn mf nn no dp mj ld np nq ml lh nr ns mn ll nt nu mp nv bi translated">结论</h2><p id="6ee9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">RISC-V完美吗？绝对不是，但RISC-V是一个平庸的设计，没有从处理器设计的最新创新中学到任何东西的想法是没有根据的。如果RISC-V是一个糟糕的设计，它就不会迅速发展，也不会出现在众多新的芯片设计中。RISC-V之所以成功，只是因为你不必支付许可费，这种想法是垃圾。如今有大量的开放架构，如<a class="ae nd" href="https://www.mips.com/mipsopen/" rel="noopener ugc nofollow" target="_blank"> MIPS Open </a>、<a class="ae nd" href="https://openpowerfoundation.org" rel="noopener ugc nofollow" target="_blank"> OpenPOWER </a>和<a class="ae nd" href="https://www.oracle.com/servers/technologies/opensparc-t2-page.html" rel="noopener ugc nofollow" target="_blank"> OpenSPARC </a>，然而这些都没有引起太多关注，尽管它们都是公认的行业标准。</p></div></div>    
</body>
</html>