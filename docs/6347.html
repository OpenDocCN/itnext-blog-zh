<html>
<head>
<title>Solving JavaScript Problems from Bigfrontend (BFE): Throttle and Debounce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Bigfrontend (BFE)解决JavaScript问题:节流和去反跳</h1>
<blockquote>原文：<a href="https://itnext.io/solving-javascript-problems-from-bigfrontend-bfe-throttle-and-debounce-87a809e5952b?source=collection_archive---------1-----------------------#2021-10-21">https://itnext.io/solving-javascript-problems-from-bigfrontend-bfe-throttle-and-debounce-87a809e5952b?source=collection_archive---------1-----------------------#2021-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eb66a8850297af806b7a670ef6d601ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6kVZW_FetYPUv9jMmPYAQ.png"/></div></div></figure><p id="d31c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一系列文章中，我想解决BFE问题(<a class="ae kw" href="https://bigfrontend.dev" rel="noopener ugc nofollow" target="_blank">https://big fronted . dev</a>)并分析解决方案。BFE网站的任务是让你为前端面试做准备，并扩展你的JavaScript知识。</p><p id="0982" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我要考虑2个问题，它们是<a class="ae kw" href="https://bigfrontend.dev/problem/implement-basic-throttle" rel="noopener ugc nofollow" target="_blank">油门</a>和<a class="ae kw" href="https://bigfrontend.dev/problem/implement-basic-debounce" rel="noopener ugc nofollow" target="_blank">去抖</a>。</p><h1 id="f969" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.喉咙</h1><p id="c0b7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">理论:</p><p id="b224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Throttle允许您在给定的时间间隔内只执行一次该函数。</p><p id="7d69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上:</p><p id="a529" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们需要处理页面的滚动，并执行一些使用滚动坐标的<strong class="ka ir"> fn </strong>函数。我们可以直接订阅<strong class="ka ir"> onscroll </strong>事件，但是它会被非常频繁地调用(取决于我们滚动的速度)，但是即使我们做得很快，事件也会多于1–2。可以在throttle中修饰执行的函数，每N ms执行一次。</p><p id="a100" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是这样工作的:</p><p id="b774" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.第一次调用onscroll时，修饰变量立即将调用传递给<strong class="ka ir"> fn </strong>。用户可以看到这些变化。</p><p id="f364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.如果我们继续滚动页面，那么ms. Onscroll事件将被忽略。</p><p id="df27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.当滚动停止时，修饰功能将等待N ms，并使用最后一个坐标执行<strong class="ka ir"> fn </strong>。它将处理滚动停止的最终坐标。</p><p id="23fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决方案:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="0894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来分析一下解决方案:</p><p id="397b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">throttle函数有两个参数:要执行的函数和超时(毫秒)</p><p id="7134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第7–9行，我们需要保存我们的计时器，它是我们为在给定的时间间隔触发函数调用而创建的，我们需要保存调用上下文和参数，以便当计时器超时时，我们可以使用正确的上下文和参数执行函数。</p><p id="c838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第11行返回函数，因为我们需要做一个闭包，并在throttle中修饰原来的函数。</p><p id="6145" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mg">const throttled = throttle(func，3) </em></p><p id="a5dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们应该处理两个选项:第一个调用和后续调用。第一次调用应该立即生效，而不需要等待计时器超时。随后的应该被“覆盖”,而最近的应该在定时器到期时被调用。</p><p id="a0c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查是否是第一次调用是根据运行的定时器来执行的，所以在第12行你可以看到，如果这不是第一次调用，我们只保存上下文和参数。</p><p id="cdbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这是第一次调用，则立即执行该功能(第16行),并以指定的时间间隔启动计时器(第18行)。对计时器内部参数的额外检查是为了，如果我们只有一个调用(我们马上进行了第一个调用),那么在时间到期后它不会被再次调用。如果有调用，那么在时间过去之后，将使用保存的上下文和参数调用函数(第20行)，计时器被清除(第22行)，最后一次调用的数据也被清除(第23、24行)。</p><h1 id="a3b8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.去抖</h1><p id="1550" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">理论:</p><p id="97f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦用户停止事件调用，该函数将仅在指定时间后执行。</p><p id="6ed7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上:</p><p id="0aa1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要处理页面的滚动，并执行使用滚动坐标的<strong class="ka ir"> fn </strong>函数。如果定时器启动后没有更多事件被触发，去抖将在N ms后调用<strong class="ka ir"> fn </strong>。如果触发了新的事件，并且定时器没有结束，则先前的定时器取消，并且开始新的定时器。</p><p id="cc07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是这样工作的:</p><p id="1ba8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.当onscroll第一次被调用时，修饰函数通过调用<strong class="ka ir"> fn </strong>来启动定时器。</p><p id="a10e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.如果我们继续滚动页面，那么先前的计时器被取消，一个新的计时器开始计时。</p><p id="792f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.如果在指定时间N ms内没有发生onscroll事件，则使用最后一个事件的上下文和参数执行<strong class="ka ir"> fn </strong>函数。</p><p id="b677" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决方案:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="b7b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">去抖函数有两个参数:要执行的函数和超时。</p><p id="b40d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第8–10行，我们需要保存我们的定时器，它是我们在时间到期时为函数调用的触发器而创建的，我们需要保存调用上下文和参数，以便当定时器到期时，我们可以使用正确的上下文和参数来执行函数。</p><p id="32f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第12行返回函数，因为我们需要做一个闭包，并在去抖中修饰原始函数。</p><p id="ed90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">常数去反跳=去反跳(func，3)</p><p id="ee7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">时间到期时将运行的函数是第16行。我们用上次调用保存的上下文和参数调用原来的<strong class="ka ir"> fn </strong>函数，并将它们设置为null。</p><p id="d304" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着每个后续调用，我们应该取消计时器并重新启动它，在第23行取消被实现。</p><p id="a69d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第25行通过在指定的等待时间后调用我们的<strong class="ka ir"> fnCall </strong>函数来启动计时器。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="a962" class="kx ky iq bd kz la mo lc ld le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu bi translated">结论</h1><p id="e44f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如你所见，这些方法的实现并没有什么困难。希望生活中描述的算法能更好的记住油门和去抖是怎么工作的，区别是什么。</p><p id="bd24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一篇文章中，我们将分析这些问题的后续(解决<a class="ae kw" href="https://bigfrontend.dev/problem/implement-throttle-with-leading-and-trailing-option" rel="noopener ugc nofollow" target="_blank">油门</a> / <a class="ae kw" href="https://bigfrontend.dev/problem/implement-debounce-with-leading-and-trailing-option" rel="noopener ugc nofollow" target="_blank">去抖</a>与领先和落后的选择)</p></div></div>    
</body>
</html>