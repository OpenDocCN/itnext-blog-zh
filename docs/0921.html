<html>
<head>
<title>HttpClient may kill your system, be careful !!!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HttpClient可能会杀死你的系统，小心！！！</h1>
<blockquote>原文：<a href="https://itnext.io/httpclient-may-kill-your-system-be-careful-62b1533ad456?source=collection_archive---------0-----------------------#2018-06-19">https://itnext.io/httpclient-may-kill-your-system-be-careful-62b1533ad456?source=collection_archive---------0-----------------------#2018-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何正在构建或生产的中到高复杂度的软件都会对其他远程服务进行服务(HTTP)调用。随着越来越多的细粒度服务(如微服务)的建立，这正在成为一种标准做法。。Net framework有一个非常棒的名为HttpClient的库，用于对远程Rest Apis进行HTTP调用。这个库为现代实现内置了异步/等待支持。<a class="ae kl" href="https://msdn.microsoft.com/en-us/library/hh193681(v=vs.110)" rel="noopener ugc nofollow" target="_blank">官方文档在此</a>。</p><p id="9614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工程师是一个懒惰的物种，我们不想写已经写好的代码，我们几乎不会质疑高级工程师写的代码。在我的公司里，一位工程师编写了如下代码，在没有意识到可伸缩性问题的情况下尽可能快地完成他的工作。如果你关心你的api的可扩展性，那么请不要像下面这样写代码。这将同步执行您的代码。Asp.net请求工作线程将被阻塞，直到从远程服务器收到响应，从而消耗昂贵的线程，而实际上不做任何工作，直到它从远程服务器收到响应。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="bc5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍微好一点的实现是让你的整个代码路径完全异步，就像世界上每个人建议的那样。因此，当我构建编排api时，我遵循了让一切都异步的建议，并编写了如下代码，对以前的实现做了较小的更改。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="f3b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这让我现在可以说，新的Api是完全异步的，可以处理比其他Api更多的请求吞吐量。我对我的实现感到非常自豪，可能太自我了，但是当我们开始并行执行大量集成测试时，我才真正意识到这一点。在运行了20多次高吞吐量测试后，我开始观察套接字耗尽异常。这开始让我抓狂，我浏览了各种在线文章，但毫无帮助。在我疯狂搜索的第二天，我发现了一篇来自<a class="ae kl" href="https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/" rel="noopener ugc nofollow" target="_blank"> aspnetmonsters </a>的有用文章，它处理了和我完全一样的问题。我接受了队列并通读了HttpClient的微软文档，而不是依赖于我的前辈的实现，我违背了每个人的意愿，开始在HttpClient方法的包装类中使用HttpClient的单例实例。这是我使用HttpClient的RestApiAccesor的下一次迭代，它有自己的问题，但解决了套接字耗尽问题。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="c4e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我实例化了一次HttpClient，在Unity中注册了它，并开始通过我的构造函数注入它，从而在应用程序生命周期内将实例保存在内存中。</p><p id="100c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的实现对我所有的高吞吐量集成测试都有效，我过早地宣布了胜利。我没有密切注意HttpClient文档的细节，文档中说“<strong class="jp ir">所有方法都是线程安全的，但是属性不是</strong>”。因此，代码在一个用户(我的集成测试用户)中运行良好，但当我们开始测试不同的用户时，由于共享方法“UpdateHttpClientWithHeaders”在为不同的用户进行api调用之前更新auth令牌，线程冲突和令牌问题开始发生，远程服务开始随机返回400系列错误(401和403是最常见的)。</p><p id="22cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在经历了许多痛苦和大量的日志记录和跟踪之后，终于解决了共享属性被单个线程改变的问题。然后写了下面的实现，它解决了所有的<strong class="jp ir">稳定性问题</strong>，并稍微提高了整个api的性能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="d811" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同一个类中还有其他http方法，如post、put、delete等，遵循与上面类似的方法。该实施能够承受服务器上的巨大并发负载在我们对各种工作流的负载测试中，我们能够实现40 req/sec(包括许多posts和put ),分布在36台服务器上，没有发生灾难性故障。但是响应时间仍然很长，在下一篇文章中，我将写一些简单的改变，通过切换ServicePointManager类的设置，使所有api调用的性能更好。</p><p id="c417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是该类的完整实现</p><p id="f6bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://gist.github.com/rahulbhuwal/8c62a1a1eab628453b2b4c0f82ccf5bb.js" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/rahulbhuwal/8c 62 a1 eab 628453 b 2 B4 c 0 f 82 CCF 5 bb . js</a></p><p id="7dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kt">下一篇- &gt; </em> <a class="ae kl" href="https://medium.com/@rahulbhuwal/reusing-httpclient-didnt-solve-all-my-problems-142a32a5b4d8" rel="noopener"> <em class="kt">重用HttpClient并没有解决我所有的问题</em> </a></p></div></div>    
</body>
</html>