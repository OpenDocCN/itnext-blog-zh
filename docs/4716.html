<html>
<head>
<title>A Deep Dive into Serverless Tracing with AWS X Ray &amp; Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS X射线和Lambda深入了解无服务器跟踪</h1>
<blockquote>原文：<a href="https://itnext.io/a-deep-dive-into-serverless-tracing-with-aws-x-ray-lambda-5ff1821c3c70?source=collection_archive---------0-----------------------#2020-08-31">https://itnext.io/a-deep-dive-into-serverless-tracing-with-aws-x-ray-lambda-5ff1821c3c70?source=collection_archive---------0-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/49774eb5e35f580ed0f2250206822f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjtRUAzmuhUO89BLAlVkvw.jpeg"/></div></div></figure><p id="762a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几周里，我一直在尝试在AWS上构建一个无服务器API，目标是拥有运行生产系统所需的一切。一个必要的部分是分布式跟踪。虽然我已经看到了一些非AWS选项必须提供的东西，但服务本身的额外成本，以及实际获得数据的成本，对于我想象的只有AWS才可能实现(并且更便宜)的事情来说有点令人望而却步，这让我想到了X射线。因此，我想看看是否可以使用AWS X射线从跟踪解决方案中获得我想要的一切。首先，我将对产品跟踪解决方案的需求设定一些期望，作为研究过程的目标。</p><h1 id="c12e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">编辑02/20/21</h1><p id="a710" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在发布这个帖子的几个月后，我在尝试X射线追踪采样规则时被提醒我错过了一些东西(大声喊<a class="ae lz" href="https://twitter.com/vishnuprasad73" rel="noopener ugc nofollow" target="_blank"> Vishnu Prasad </a>来找我)。虽然你似乎可以增加API Gateway的采样率，但Lambda实际上固定在每秒1个请求，根据<a class="ae lz" href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html" rel="noopener ugc nofollow" target="_blank">这份文档</a>，比这个数字高出5%。显然，提高λ采样率的能力正在<a class="ae lz" href="https://forums.aws.amazon.com/message.jspa?messageID=941643" rel="noopener ugc nofollow" target="_blank">进行中，目前还没有发布日期</a>。不幸的是，这使得X射线对于业余爱好项目之外的无服务器开发毫无用处。Cloudwatch日志很棒，但是作为一个跟踪解决方案，每秒1个请求是非常低的吞吐量。幸运的是，有一些替代品，如Lumigo和Epsagon似乎正在接受这一挑战。</p><h1 id="1d2c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">要求</h1><ol class=""><li id="a953" class="ma mb iq ka b kb lu kf lv kj mc kn md kr me kv mf mg mh mi bi translated">分布式跟踪。在较高的层次上，我希望看到请求从服务到服务的路径，以及错误的位置和延迟的细节。</li><li id="9a12" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">内部跟踪，或“火焰图”。我希望能够看到lambda中请求的分解，以及错误发生时的堆栈跟踪。这也将帮助我找出lambda中运行效率特别低的部分。</li></ol><h1 id="f6e0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置</h1><p id="a8f3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，一个标准的无服务器项目设置和代码演练。顺便说一下，我在这篇文章中使用的所有代码都可以在<a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f170" class="mx kx iq mt b gy my mz l na nb">npm i -g serverless<br/>sls create --template aws-nodejs --path lambda-demo-api<br/>cd lambda-demo-api &amp;&amp; npm init &amp;&amp; npm i --save-dev serverless-offline</span></pre><p id="7ffa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将要部署的lambda的文件结构如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1823" class="mx kx iq mt b gy my mz l na nb">├── anotherFile.js<br/>├── index.js<br/>├── logger.js<br/>├── node_modules<br/>├── package-lock.json<br/>├── package.json<br/>├── serverless.yml<br/>└── utils.js</span></pre><p id="361b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后我将解释这些文件。现在，让我们来看看初始的无服务器配置。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8fc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试不同的配置选项，我添加了三个端点:一个健康检查返回200状态代码，第二个返回400状态代码，第三个抛出错误并返回500状态代码；三种典型的API响应。这里的想法是，我们应该能够通过我们的跟踪解决方案(X射线)隔离返回500的api调用，以及伴随它们的堆栈跟踪。我在provider下添加了lambda tracing，它为每个lambda打开X射线，这是一个更新的选项，以前需要一个插件。</p><p id="36a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当对所有功能使用默认的全局角色时，Serverless会自动为Cloudwatch提供权限，但是当提供特定功能的角色时，您需要自己授予他们访问Cloudwatch的权限。我还提供了一些权限，允许lambda连接到X射线进行跟踪。</p><p id="861d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，我已经下载了<a class="ae lz" href="https://github.com/dherault/serverless-offline" rel="noopener ugc nofollow" target="_blank">无服务器离线</a>插件，这对于使用无服务器框架的本地开发很有帮助。它被保存为开发依赖项，因此不会包含在已部署的节点模块中。任何额外的依赖项都会增加冷启动时间，所以保持依赖项的分离非常重要。</p><p id="c5c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第10行和第34行，我们使用＄{ opt:stage }选项来访问运行以下命令时提供的值:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="65dd" class="mx kx iq mt b gy my mz l na nb">sls deploy --stage &lt;test | dev | staging | prod&gt;</span></pre><p id="e587" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在此设置中，如果不包含此标志，Serverless将抛出一个错误。强制您显式声明阶段有助于防止不正确的部署。Serverless在每个已部署资源的名称中包含您的stage，这是一个很小但很有用的功能，有助于搜索资源，这是AWS SAM所不具备的，至少在默认情况下是不具备的。</p><p id="8bcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这个<a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo/tree/23eb0b174f7a75967555634ade51cbcc643dabf2" rel="noopener ugc nofollow" target="_blank">提交</a>中找到我所有的初始设置代码。对这个回购的提交将遵循本文中的代码更新，但是我也将检查每个文件。模拟API的初始处理程序如下所示。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="77e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们正在做一些路由，考虑到我们使用的是无服务器，你可能会觉得有些多余。我们<em class="ne">可以</em>使用我们的无服务器配置将每个端点路由到不同的功能，这样我们就不必做这些条件。我可以就此写一整篇文章，所以现在我只能说这主要是个人偏好。尽管如此，if块还是有点难看，还有一个更好的内部路由选项，我将在后面介绍，但它现在可以工作了。让我们进入我在处理程序中导入的其他文件。</p><p id="6cda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个“utils.js”:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="25eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面是几个简单的函数，集中了模拟API的响应格式。首先是一个扩展原生JS错误类的类，名为“ApiError”。这样做的目的是区分自定义/预期错误和意外异常，并提供提供状态代码和自定义响应主体的选项。第21–30行的handleError函数是根据自定义错误类检查当前错误类的地方。最后，还有formatError和formatResp，它们标准化了输出和头格式。</p><p id="91ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后是“anotherFile.js”</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些函数模拟了我前面提到的3个API响应。我将它们放在另一个文件中，这样当我们到达那里时，堆栈跟踪会更加详细。</p><p id="4100" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候在本地运行它了:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/1cf4fcc0953b339015392164a937cc04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8T_-bqT1MKxGZ78pBZkmsw.gif"/></div></div></figure><p id="66b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是回应:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/2cc3da6fa2c3a80139f5a6503e200b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*brrEa60h7WP6I_mFkIdbnw.gif"/></div></div></figure><p id="1e05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，一切正常。现在让我们在AWS上部署和使用它。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="030b" class="mx kx iq mt b gy my mz l na nb">sls deploy --stage dev</span></pre><h1 id="358f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">x光</h1><p id="7e6b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我不会告诉你部署输出，但是部署后我们得到了3个URL，现在可以发送一些请求了。当我们像上面本地所做的那样到达每个端点时，我们得到预期的输出和状态代码。我们可以通过导航到AWS控制台的lambda部分并单击AWS X射线下的“查看活动跟踪”,来查看X射线的跟踪效果。X射线仪表板看起来像这样:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/a21454f229881c5c7ffb9585dfc94d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTFw81dadqNCgyx85eWLWw.png"/></div></div></figure><p id="6a3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">端点被击中9次，平均响应时间为79.7 ms酷！但是有些事情有点奇怪。为什么所有的回答200都没问题？我多次碰到“/dev/throw_error”端点，所以不应该出现这种情况。此外，我们不知道我们到达的具体端点，这不是很有帮助。让我们通过在跟踪列表下选择一个蓝色的超链接id来看看跟踪的结果。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/fc6622989b9c6b3d6ec2f87fc4a2a888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErfqAS99FufTtxk2KR27yQ.png"/></div></div></figure><p id="7e8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有意思。我们可以看到调用和lambda函数，但是我们看不到任何与我们在lambda中调用的特定函数有关的东西，甚至看不到处理程序。这里有几个问题，但有一个有点明显的是，我们没有在我们的无服务器配置中设置<a class="ae lz" href="https://www.serverless.com/blog/framework-release-v141" rel="noopener ugc nofollow" target="_blank"> API Gateway X射线集成。这是一个相对简单的单行修复。我们只需要将“apiGateway: true”添加到无服务器配置的“provider”块的跟踪部分，就像这样(这里的代码是</a><a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo/tree/88cf383291cf8cc792440b348d27aa705c5f0804" rel="noopener ugc nofollow" target="_blank"/>):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e680" class="mx kx iq mt b gy my mz l na nb">provider:<br/>name: aws<br/>runtime: nodejs12.x<br/>stage: ${opt:stage}<br/>region: us-east-2<br/>tracing:<br/>  lambda: true<br/>  apiGateway: true</span></pre><p id="e547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是由于某些与云形成相关的原因，如果不完全删除堆栈，就无法添加API网关跟踪，因此我们必须运行以下代码:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7ef7" class="mx kx iq mt b gy my mz l na nb">sls remove --stage dev &amp;&amp; sls deploy --stage dev</span></pre><p id="b689" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在尝试了新的端点并导航回X射线仪表板后，我们可以看到立即的改进。它现在不仅有预期的状态代码，而且我们的响应也按端点分组。漂亮。我们还可以看到客户的IP地址，出于隐私考虑，我屏蔽了这个地址。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/4ff5fb81476b46ba79254853bc09afca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-gHYQ47rF6K4VEtneBHU8A.png"/></div></div></figure><p id="8c1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单击500响应的跟踪，您可以看到这里还有更多信息:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/6d538882df3330c9390e0898f75b1249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9XfsCvhz72xTi7ON_SEXA.png"/></div></div></figure><p id="2496" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">API网关现在位于跟踪图和火焰图中。然而，我们仍然没有对lambda内部调用的函数进行任何内部跟踪，但我们马上就会谈到这一点。您现在还可以看到发生了一个错误，尽管它不是“错误”，这表明返回了一个400+代码。这是指示500+状态代码的“故障”。点击详细信息并导航到“exceptions”选项卡，我们可以看到我们的错误不幸没有堆栈跟踪，这是我前面提到的需求之一(见下文)。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/4de29d8489e4c6717ca06246aadae190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt21cuQi_s28lTOLTJc6xw.png"/></div></div></figure><p id="5315" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解这是为什么，我们需要看看λ和X射线是如何一起工作的。为了让X射线报告一个错误，它实际上需要你的lambda失败(至少只要我们不使用SDK，我马上就要谈到它)，当你考虑它的时候，这是有意义的。X射线必须传递的唯一信息是你从lambda返回的信息。因此，如果您返回一个没有实际错误对象的已解决的承诺或正常响应，它没有理由报告错误，即使报告了也没有什么可报告的。失败的lambda的响应格式如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="eb25" class="mx kx iq mt b gy my mz l na nb">{<br/>  "errorType": "...",<br/>  "errorMessage": "...",<br/>  "trace": [<br/>    "..."<br/>  ]<br/>}</span></pre><p id="4470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">x射线需要该错误输出来提供堆栈跟踪(不使用SDK，我将在后面介绍)。为了失败，lambda将需要使用context.fail函数，即所提供的lambda回调函数的第一个参数(例如callback(error))，或者在异步lambda的情况下，返回一个被拒绝的承诺。让我们看看在500的情况下，当我们在错误处理函数中拒绝而不是解决时会发生什么。utils.handleError函数现在将如下所示:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cfc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新部署后，我们看到来自throw_error端点的以下Postman输出:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/6d959e0fea08c05dd0dd033a15900be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pi4hfDpaqC-ozlzozPJyXA.png"/></div></div></figure><p id="8ec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">响应代码不再是500，错误消息现在是JSON。发生了什么事？我们现在看到的错误消息实际上不是从API响应发送的错误消息(正如我前面提到的，我们现在拒绝错误本身，而不是使用formatError函数)。502响应表示路由我们请求的代理服务器下游出现错误。这是有意义的，因为API网关就是代理服务器。</p><p id="4275" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在跟踪中可以看到一个错误和一个错误。当检查异常细节时，我们现在可以看到堆栈跟踪。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/c877b23814d11b5b7529845ed44f3846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiO5BNQKn8BOhdD39wUbsQ.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/b61b00ed1fc6e05167a86733d1b529de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Or-trdN1DkMt8BYJQKQrKA.png"/></div></div></figure><p id="f547" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">厉害！这就完成了第一个要求。内部跟踪还没有建立，但是现在我们可以一直跟踪一个请求，直到出现任何错误，并立即找到堆栈跟踪，而不用在日志中挖掘。</p><p id="6c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个缺点是不能用不同的5XX错误来指示不同的问题。在这种设置下，lambda必须无法为X射线提供跟踪，因此我们只能在出现意外错误时使用502 API网关响应。但是，有两种方法可以解决这个问题。一个是使用“Lambda集成”而不是API Gateway的“Lambda代理集成”,它使用正则表达式和映射模板的组合来生成您的响应。你可以在这里阅读更多关于那个<a class="ae lz" href="https://medium.com/@lakshmanLD/lambda-proxy-vs-lambda-integration-in-aws-api-gateway-3a9397af0e6d" rel="noopener">的内容。另一种选择是使用SDK通过X射线片段提供错误，这要容易得多。我将在下一节讨论这个问题。</a></p><h2 id="1e7b" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">抽样</h2><p id="6329" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在继续之前，非常重要的是要注意，默认情况下，X射线不能捕获每个请求。默认算法是<a class="ae lz" href="https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html" rel="noopener ugc nofollow" target="_blank">每秒1个请求，在那之后的5%的请求是</a>。这是从一个端点捕获的轨迹图像，我点击了100次，没有任何延迟:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/8b5147e697bb886474dac18700a78960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJCcv3qBYQnejqOK06Da-g.png"/></div></div></figure><p id="a84f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">旁注，我不确定为什么我的一些请求通过http，一些通过https？我不确定这是Axios的错误还是API Gateway的错误，但如果有人能解决这个问题，请告诉我。</p><p id="d186" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管怎样，只捕获了46条轨迹。那还不到一半。如果你有一个错误，而你找不到相关的跟踪，这将是相当恼人的，对不对？要解决这个问题，你需要<a class="ae lz" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-console-sampling.html" rel="noopener ugc nofollow" target="_blank">改变应用于你的函数</a>的采样规则。这是您将在控制台中找到的默认设置:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/f5fbbf8575d55892d0e7cea8e1184e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fABvHpTkp2FKEFC2JnFeVw.png"/></div></div></figure><p id="fab5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有我刚刚加的那个:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/042b65d26ad77e1fd0c727e18bf69a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdSSuD5DB4tNKksiGrxHFQ.png"/></div></div></figure><p id="460d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将固定比率更改为100%，我会认为它将捕获我的所有请求。不幸的是，这只让我得到了100分中的65分:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/5336668b8e887b9e79f4f26f86da70a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HaC2Hj3h8Ln8o0V4bevwrg.png"/></div></div></figure><p id="c8e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来，如果你的初始请求/秒限制足够低，固定速率就跟不上了。经过一番折腾后，我能够以每秒100个请求获得100%的覆盖率。显然，这将取决于您的用例。您的API可能会受到速率限制，因此您将对每秒可能会看到多少请求有所了解。或者，如果您经常获得大量的流量，您可能希望限制X射线的跟踪量以节省资金(我认为这是采样选项的初衷)。</p><p id="d799" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不利的一面是，云形成对重要细节的随机支持似乎取决于风吹的方向或杰夫·贝索斯今天早上吃了什么早餐，似乎不支持采样配置。好的一面是，您的控制台更改似乎不会被后续部署覆盖，并且该规则可能不会改变太多，因此您可以在初始部署后设置它并忘记它。然而，如果你喜欢地形，他们确实有一个选项。</p><h1 id="162e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">X射线内部追踪</h1><p id="bdab" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">既然X射线已经设置好了，我们可以看到请求从API Gateway转移到lambda，很快也会转移到下游的AWS服务。让我们看看一些X射线函数，它们允许我们跟踪lambda内部，添加元数据，并将错误附加到我们的跟踪中。</p><p id="a19c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，安装X射线sdk，它可以让您访问这些选项。(<a class="ae lz" href="https://github.com/aws/aws-xray-sdk-node/tree/master/packages/core" rel="noopener ugc nofollow" target="_blank">你可以在这里阅读更多关于套餐的信息</a></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b9a2" class="mx kx iq mt b gy my mz l na nb">npm i aws-xray-sdk-core</span></pre><h2 id="bb0c" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">地方发展</h2><p id="a2f4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一个简短的说明。X射线sdk并不真的玩无服务器-离线。当lambda运行时，它需要一个跟踪id，否则它会抛出以下错误:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2a5b" class="mx kx iq mt b gy my mz l na nb">Error: Missing AWS Lambda trace data for X-Ray. Expected _X_AMZN_TRACE_ID to be set.</span></pre><p id="fcef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能看到的另一个本地运行的错误如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9e55" class="mx kx iq mt b gy my mz l na nb">"Error: Failed to get the current sub/segment from the context.</span></pre><p id="5f66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至少可以防止这些错误导致lambda失败的一个选项是这个环境变量:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3a87" class="mx kx iq mt b gy my mz l na nb">AWS_XRAY_CONTEXT_MISSING=LOG_ERROR sls offline --stage dev</span></pre><p id="f8eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这告诉X射线记录错误，而不是抛出错误。然而，日志输出相当冗长和烦人。要关闭它，您可以将X射线输入您自己的记录器，并将级别设置得足够低，这样它就不会在您的测试中显示出来，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="471b" class="mx kx iq mt b gy my mz l na nb">f(process.env.NODE_ENV === 'local_dev' ) {<br/>  AWSXRay.setLogger(Logger('silent'));<br/>}</span></pre><p id="005e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您走这条路，重要的是在一个工具文件中导入X射线一次，其他时间从该文件导入，否则X射线的一些实例不会有您提供的记录器。</p><h2 id="1ac9" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">片段</h2><p id="b7da" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，理解“细分市场”的概念很重要。一个段仅仅是由时间跨度度量的代码的一部分。段都是树的一部分，顶部是一个根段，下面是子段。子段只是另一个段的子段。两者之间只有细微的功能差异。有两个与段相关的函数需要注意:“addNewSegment”将生成调用段的子段，“addSubsegment”将一个段作为子段添加到任何其他段。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2ee2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面看到的，在这个选项中，您必须显式地将您的段向下传递给较低的函数，并在那里创建一个新的子段。下面是它在拒绝函数中的样子:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="95d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您<strong class="ka ir"> <em class="ne">必须</em> </strong>对您的所有段调用“close ”,否则您的所有段都不会显示，并且您会丢失堆栈跟踪(这也是为什么您还想打印日志而不是仅仅依赖X射线)。另一个要提到的重要事情是，Lambda是特殊的，它带有一个自动生成的根段，您可以通过AWXRay.getSegment访问它。它是不可变的，因此您不能向它添加注释或元数据，并且在调用时其他段函数都不工作，但是您可以将它用作其他子段的父段(作为普通段)。</p><p id="92f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看这些部分在仪表板中的样子:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/4312ffbb76953f2d01e3040268506c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DU-N1euvBAPl6su-rs2-eA.png"/></div></div></figure><p id="99a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">厉害！我们可以看到三种不同的输出:1个正常响应(200)、1个错误(400 +)和1个错误(500 +)，现在我们可以深入到被调用的函数，看看它们用了多长时间，以及哪里发生了错误。现在迹线图:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/6b77b9f91af49e44b82f23b39f9bfe6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dLN-Qw0IC1vTU8nwX-PEA.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/82047544cc7f3396518d34aedb38edd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCx8hkrnfHlfu3Qc2Iz5eg.png"/></div></div></figure><p id="c362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以更深入地了解该函数所花费的时间，并可以看到错误发生在哪里。</p><h2 id="6549" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">addError</h2><p id="0a20" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">正如您可能已经注意到的，在上面的例子中，“addError”在失败的函数段中被调用。这解决了以前需要拒绝lambda在X射线中发送堆栈跟踪的问题。让我们看看仪表板是什么样子的，如果我们现在解决了lambda不需要为堆栈跟踪失败的承诺。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/2ef3686bfdb3ae6952b05a202545b73d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rKGRd1WdmXF-9EFYWDlfQ.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/64820de941cfb6ce64c608e5c4a3328a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14HbjGFUHzSVw19mcUHH7w.png"/></div></div></figure><p id="1c51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">错误仍然存在，您可以获得堆栈跟踪，但是X射线不再显示lambda本身失败，只显示端点和函数。</p><h2 id="ab08" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">添加批注和添加元数据</h2><p id="1ce8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">作为Segment对象的一部分，您可能还想利用其他几个函数，其中两个是“addAnnotation”和“addMetadata”。这些允许您将信息添加到单个区段，您将能够在X射线仪表板中看到这些信息。两者之间的一个关键区别是，您可以搜索X射线注释，但不能搜索元数据。另一个原因是元数据允许存储整个对象，而注释是键值对。你可以在这里阅读更多关于追踪搜索<a class="ae lz" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-console-filters.html#xray-console-filters-details" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e0f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个查询示例，用于在所有跟踪中搜索调用花费不到一秒钟且注释为“a = b”的失败:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="acd2" class="mx kx iq mt b gy my mz l na nb">service("lambda-api-demo-dev-DemoLambda") AND duration &lt; 1 AND !ok AND annotation.a = "b"</span></pre><p id="361d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于X射线的概念，你可以在<a class="ae lz" href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html" rel="noopener ugc nofollow" target="_blank">这里</a>阅读。</p><h2 id="896a" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">captureFunc &amp; captureAsynFunc</h2><p id="0934" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您可能想要利用的另外两个函数是“captureFunc”和“captureAsynFunc”。addNewSegment不支持承诺，因此“captureAsynFunc”解决了这个问题。下面，你可以看到我是如何在“anotherFile.js”中使用captureAsyncFunc的(顺便说一下，所有这些代码都可以在<a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo/tree/915a4ebe98a2c44863701b8a2491cdf3ba1730be" rel="noopener ugc nofollow" target="_blank"> this commit </a>中找到)。</p><p id="7f6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将addNewSubsegment与async/await一起使用更简洁一些，但是直到我写了这一部分之后，我才意识到它是异步调用的一个选项，所以在本文的其余部分，我将使用captureAsynFunc。</p><p id="476a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是包含X射线包装器的更新处理程序:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ec4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及“anotherFile.js”:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然你在上面看不到它，但我在处理程序中调用了“close”。在记录错误之前，您可能也想在errorHandler中调用addError，但是这样会将错误报告为发生在错误处理程序函数中，而不是实际发生的函数中。</p><h2 id="082c" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">几句告诫的话</h2><p id="1db6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在继续之前，我要暂停一下，补充几句警告的话。虽然分段很酷，但我不推荐在这种程度上使用它们。达到这一点对代码来说是非常具有侵略性的<em class="ne">。我也不喜欢包装我写的每一个函数的想法，事实上你<em class="ne">必须</em>在你的异步段上调用close，否则你的内部跟踪将会崩溃，这是一个很大的精神开销。几乎就像写c一样。</em></p><p id="f7bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，能够用您喜欢的任何状态代码来解析您的函数，并且仍然向X射线报告一个错误，这是非常好的。因此，如果您不想包装所有的函数调用，用单个段包装您的函数可能是使用该功能的合理限制。有了X射线的其他特性，跟踪每一个函数调用可能都是不必要的，您将在接下来的几节中看到这一点。</p><h2 id="7200" class="mx kx iq bd ky np nq dn lc nr ns dp lg kj nt nu lk kn nv nw lo kr nx ny ls nz bi translated">captureAWS &amp; capturePostgres</h2><p id="9a4d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我说的“其他功能”是指X射线提供的跟踪您的功能所涉及的任何东西的功能。让我们看三个选项:其他AWS服务、http请求和数据库。为此，我将创建一些额外的资源:一个DynamoDB表、一个SQS队列、一个SNS主题和另一个lambda函数。这种设置是人为设计的，对于任务来说过于复杂，但它只是提供一个示例。我将添加一个端点，它将从dynamo表中提取5个值，并将它们推送到SNS。SNS将推送到SQS，在那里另一个功能将提取数据并将其发送到一个slack通道。你可以在这里找到这部分<a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo/tree/d4e67509e3a42593e73c41f8bf107741baa647ce" rel="noopener ugc nofollow" target="_blank">的代码。我通过https://randomuser.me/</a>的<a class="ae lz" href="https://randomuser.me/" rel="noopener ugc nofollow" target="_blank">生成了虚假的用户数据，我用</a><a class="ae lz" href="https://stevensteam-workspace.slack.com/apps/new/A0F7XDUAZ-incoming-webhooks" rel="noopener ugc nofollow" target="_blank">这个slack app </a>做了slack webhook。部署后，您可以使用以下内容作为数据库的种子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b336" class="mx kx iq mt b gy my mz l na nb">npm run seed-dev</span></pre><p id="767f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还在“common”文件夹中添加了两个文件:dynamodb.js和sns.js。每个文件都包含这两行(您也可以在处理程序的顶部调用一次):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b963" class="mx kx iq mt b gy my mz l na nb">const AWSXRay = require('aws-xray-sdk-core')<br/>const AWS = AWSXRay.captureAWS(require('aws-sdk'));</span></pre><p id="951f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是为您使用的任何AWS资源提供跟踪所需要做的全部工作。一旦我们调用新端点“/dev/send_data”，然后查看X射线控制面板，我们将看到一些新信息:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/1d3b542b5cea04d54fb0b87181288c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3X1shPtfDV-kpVzA1yNklA.png"/></div></div></figure><p id="4155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有DynamoDB扫描和5个SNS调用的分段。如果我们看一下轨迹图，我们会发现它也发生了一些变化:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/1702b7903c67dd7f3d76fb12218a9209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv1SIhai7hw6cWBQKO2Wzg.png"/></div></div></figure><p id="a916" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DynamoDB和SNS现在包括在内了，但是等一下…为什么我们没有看到SQS或其他lambda函数？我一会儿就会谈到这个问题，首先让我们看看另一个函数的处理程序:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8663" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前三行是最重要的。与“captureAWS”包装AWS资源调用的方式相同，captureHTTPsGlobal包装所有出站http(s)调用。如果我们查看该功能的X射线仪表盘，我们会看到以下内容:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/354839a65cc42ad27ca6fa1dc92b3a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrsnEFphqkMq6PLt6S8nQg.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/dc6f53dfac1458d667ef9488ad9ab8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58f8M1hZTaXYmB1K_4FBaw.png"/></div></div></figure><p id="4d4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在图形和图表中看到对slack端点的调用。然而，在这里你仍然看不到SQS队。不幸的是，一旦你与你的lambda超过一个分离度，X射线就无法连接轨迹，或者至少从SNS到SQS到另一个lambda，正如你在github的<a class="ae lz" href="https://github.com/aws/aws-xray-sdk-node/issues/208" rel="noopener ugc nofollow" target="_blank">中看到的。显然，AWS正在进行一些更新，其中包括对这个问题的修复，所以我们现在只能等待并处理单独的仪表板。显然，你至少可以将sqs放入你的跟踪中(就像那期的海报一样)，但我不知道如何做。</a></p><p id="d0d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我们已经介绍了如何跟踪http请求和对其他AWS服务的调用。然而，我们仍然需要涵盖数据库。这里需要一个VPC/RDS实例，我用了Terraform，所以它不在repo中，抱歉。但是，如果您自己设置它们，您应该注意到我使用SSM拉入了安全组id、vpc id和rds端点，您也可以复制它们。准备就绪后，您可以使用以下脚本来播种您的数据库:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="05df" class="mx kx iq mt b gy my mz l na nb">npm run seed-rds-local<br/>npm run seed-rds-dev</span></pre><p id="e025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在lambda中，X射线的设置相当简单。与aws-sdk和http非常相似，您只需将数据库导入封装在一个函数调用中，如下所示(您可以在<a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo/tree/81ac39a111be284463ab318be3ee0c1069f4aeb4" rel="noopener ugc nofollow" target="_blank"> this commit </a>中找到添加的RDS代码)。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这个例子中使用pg-promise，所以我在导入之前调用capturePostgres，就像导入Axios之前调用captureHTTPsGlobal一样。如您所见，我们现在在跟踪图中有一个SQL段:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/314060517da14ad8cde5bd23a7fa7f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-6JF67V5mJ1-PApo3Q1hQ.png"/></div></div></figure><p id="de6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这三种捕获段的方法，手动包装函数似乎就没什么必要了，除非您需要深入了解是什么导致了性能问题。</p><h1 id="738f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用λ和X射线表示</h1><p id="e67c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这篇文章的开始，我提到有一个更好的方法在每个lambda的基础上在内部路由请求(如果你不想对所有的路由都使用API Gateway的话)。一种选择是快递。使用<a class="ae lz" href="https://www.npmjs.com/package/aws-serverless-express" rel="noopener ugc nofollow" target="_blank"> aws-serverless-express </a>模块，您可以在lambda中使用express，它为您提供路由、中间件和查询参数的自动解析，只需花费很少的成本来设置路由和在冷启动时调用“listen”。我知道有些人可能会认为这是一种反模式，但我不认为这是什么大不了的事情，如果你只是为一个端点加载几个路由。然而，使用express意味着我们必须更新处理程序代码来适应express。见下文(顺便你可以在这里找到这个代码<a class="ae lz" href="https://github.com/5t33/production-mock-serverless-api-demo/tree/0209bc3fdc52c5d75cfceef2aed68535f3566bb4" rel="noopener ugc nofollow" target="_blank"/>)。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d0b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae lz" href="https://www.npmjs.com/package/aws-serverless-express" rel="noopener ugc nofollow" target="_blank"> aws-serverless-express </a>包，路由现在使用express处理。为了像以前一样给记录器添加一个惟一的请求id，我将它包含在一个中间件函数中。还有一个名为aws-xray-sdk-express的X射线快速中间件包，尽管它似乎只不过是添加了一个包装段，我在上面使用的是包装段，而不是手动的“处理程序”段。我认为它至少可以跟踪中间件的功能，但事实似乎并非如此。可能它在lambda中的行为与在express容器中不同。</p><p id="e2b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">x-ray中间件的另一个小缺点是，它不是为lambda设计的，所以它创建了两个单独的跟踪——一个用于lambda调用，一个用于处理程序，如下所示。这可能是由于express插件试图创建自己的根段。这似乎会导致所记录的测量值之间的微小差异。您可以看到输出如下所示:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/af998687cef85f39e47a52b51f635f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a5P8PVYllY_BmB1iI174cg.png"/></div></div></figure><p id="39fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这并不理想，中间件也没有增加太多东西，所以我决定回到lambda的单一包装器，如下所示:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="22df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">这里有一个警告</em>:现在我们正在返回express的结果，你有机会向你的客户发送一个堆栈跟踪。只有在错误处理程序上游的中间件中出现未捕获的错误时，才会发生这种情况。aws-serverless-express处理这个错误，但是它用一个500来解决这个问题，这个500会返回完整的错误。</p><h1 id="536f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="23c3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">差不多就是这样。这篇文章比我预想的要长得多，但是我认为投入进去做一些实验是值得的。我没有讨论X射线控制台中可用的监控，但我建议快速浏览一下。我希望X射线中增加的一点是一种将跟踪与日志记录联系起来的简单方法。看起来好像有另一个名为“ServiceLense”的服务可以做到这一点，但它无法想象在X射线跟踪的相关日志流中添加一个按钮会有多困难。无论如何，感谢您的阅读，我希望这能帮助您开始在您的无服务器API中使用X射线。</p><p id="21b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，我想大声说出崔琰的<a class="ae lz" href="https://www.manning.com/livevideo/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">这个课程</a>，以及<a class="ae lz" href="https://theburningmonk.com/" rel="noopener ugc nofollow" target="_blank">他的博客</a>，这两个资源是我反复参考的关于构建无服务器系统的信息。</p></div></div>    
</body>
</html>