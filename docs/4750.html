<html>
<head>
<title>Practical Query Tagging in EF Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">EF核心中实用的查询标记</h1>
<blockquote>原文：<a href="https://itnext.io/practical-query-tagging-in-ef-core-ad0b38fa3436?source=collection_archive---------2-----------------------#2020-09-07">https://itnext.io/practical-query-tagging-in-ef-core-ad0b38fa3436?source=collection_archive---------2-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0cf404a85e1c146cae269aa4dc908cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJFi098PRWgjk6IhhTUQkg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">示例查询标记！</figcaption></figure><p id="f760" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">EF核心中的<a class="ae ld" href="https://docs.microsoft.com/en-us/ef/core/querying/tags" rel="noopener ugc nofollow" target="_blank">查询标签</a>是什么？</p><blockquote class="le lf lg"><p id="26e1" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc im bi translated">在EF核心2.2中有介绍。该功能有助于将代码中的LINQ查询与日志中捕获的生成的SQL查询相关联。使用新的<code class="fe ll lm ln lo b">TagWith()</code>方法注释LINQ查询。</p></blockquote><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="0adf" class="lx ly it lo b gy lz ma l mb mc">var publishedBlogPosts = dbContext.BlogPosts<br/>    .Where(b =&gt; b.PublishedAt != null)<br/>    .TagWith("Getting published blog posts")<br/>    .ToList();</span></pre><p id="611a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当EF用<code class="fe ll lm ln lo b">TagWith</code>方法生成SQL时，它也将标签作为注释包含在查询中；因此，调试和分析查询可能会更容易。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="309b" class="lx ly it lo b gy lz ma l mb mc">-- Getting published blog posts</span><span id="d15a" class="lx ly it lo b gy md ma l mb mc">SELECT [b].[BlogPostId], [b].[Content], [b].[PublishedAt], [b].[Title]<br/>      FROM [BlogPosts] AS [b]<br/>      WHERE [b].[PublishedAt] IS NOT NULL</span></pre><h2 id="29ae" class="lx ly it bd me mf mg dn mh mi mj dp mk kq ml mm mn ku mo mp mq ky mr ms mt mu bi translated">如何让它更实用？</h2><p id="3d5a" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">调试和分析都是为了获得更多的信息。我们可以通过<a class="ae ld" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information" rel="noopener ugc nofollow" target="_blank">调用者信息属性</a>轻松访问成员名称、代码行和源文件。</p><p id="9165" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在看看我的扩展方法:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="879d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它从编译器中检索方法名、文件路径和行号，并将其应用于任何<code class="fe ll lm ln lo b">IQueryable&lt;T&gt;</code>。</p><p id="3748" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">用法举例:</strong></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="da9f" class="lx ly it lo b gy lz ma l mb mc">var publishedBlogPosts = dbContext.BlogPosts<br/>    .Where(b =&gt; b.PublishedAt != null)<br/>    .TagWithSource("Getting published blog posts")<br/>    .ToList();</span></pre><p id="18af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">生成的SQL将如下所示:</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="2c05" class="lx ly it lo b gy lz ma l mb mc">-- Getting published blog posts<br/>-- Main  - D:\Projects\Sample1\Program.cs:17</span><span id="1be1" class="lx ly it lo b gy md ma l mb mc">SELECT [b].[BlogPostId], [b].[Content], [b].[PublishedAt], [b].[Title]<br/>      FROM [BlogPosts] AS [b]<br/>      WHERE [b].[PublishedAt] IS NOT NULL</span></pre><p id="6a0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种做法有一些限制，例如在从<code class="fe ll lm ln lo b">BaseRepository</code>继承的情况下，您将获得基类的信息，而不是派生类的信息。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="a24a" class="lx ly it bd me mf mg dn mh mi mj dp mk kq ml mm mn ku mo mp mq ky mr ms mt mu bi translated">结论</h2><p id="f539" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">查询标记是EF Core的一个很好的特性，将它与调用者信息结合起来对于调试来说是非常好的。</p></div></div>    
</body>
</html>