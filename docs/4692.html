<html>
<head>
<title>Always Run Migrations with DbUp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">始终使用DbUp运行迁移</h1>
<blockquote>原文：<a href="https://itnext.io/always-run-migrations-with-dbup-7ea88c31ee82?source=collection_archive---------4-----------------------#2020-08-24">https://itnext.io/always-run-migrations-with-dbup-7ea88c31ee82?source=collection_archive---------4-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dd9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将介绍如何使用DbUp在每次运行时运行特定的迁移，而不是只运行一次。如果您是DbUp的新手，可以看看下面的帖子，看看示例项目是如何达到当前状态的。</p><p id="c49b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://elanderson.net/2020/08/database-migrations-with-dbup/" rel="noopener ugc nofollow" target="_blank">使用DbUp进行数据库迁移</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/08/code-based-database-migrations-with-dbup/" rel="noopener ugc nofollow" target="_blank">使用DbUp进行基于代码的数据库迁移</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/be20abe8d4dab97e4ea933a4a81632bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MlZ0XYp62o81AY95.jpg"/></div></div></figure><h2 id="0918" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">区分始终运行</h2><p id="9432" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">获得应该每次都运行的迁移的关键之一是能够将它们与应该只运行一次的迁移区分开来。这可以在文件名级别完成，也可以通过将所有始终运行的文件放在特定目录中来完成。这个示例使用目录方法，但是文件方法的工作方式基本相同。在示例项目中，在现有的<strong class="jp ir">脚本</strong>目录下，我添加了一个AlwaysRun目录。我还在这个目录中添加了一个示例脚本，这样我们可以验证它是否在每次运行时都被执行。在示例中，该文件被命名为<strong class="jp ir"> Everytime.sql </strong>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/e81082e4418b27bee71187bc2426ecd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*BHCoz8WPB37iBJY4.png"/></div></figure><p id="36e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于以上内容，当DbUp正在处理时，它会将<strong class="jp ir"> Everytime.sql </strong>视为<strong class="jp ir"> DbupTest。scripts . always run . every time . SQL</strong>。</p><h2 id="1b9c" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">过滤掉总是运行</h2><p id="6c2a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在，我们有了一种方法来确定我们希望始终运行的迁移，我们需要将它们从现有的升级过程中筛选出来，这样它们就不会包含在已执行迁移的日志中。在DbUp中，该日志被称为日志。设置如何定位迁移的扩展方法，在我们的示例中是<strong class="jp ir">withscriptsbembeddedinassembly</strong>或<strong class="jp ir">WithScriptsAndCodeEmbeddedInAssembly</strong>，可以提供一个过滤器，我们将使用该过滤器排除<strong class="jp ir"> AlwaysRun </strong>目录中的迁移。以下代码是安装了过滤器的升级程序。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="751a" class="ky kz iq ly b gy mc md l me mf">var upgrader =<br/>    DeployChanges.To<br/>                 .SqlDatabase(connectionString)<br/>                 .WithScriptsAndCodeEmbeddedInAssembly(Assembly.GetExecutingAssembly(),<br/>                                                       f =&gt; !f.Contains(".AlwaysRun."))<br/>                 .LogToConsole()<br/>                 .Build();<br/><br/>var result = upgrader.PerformUpgrade();</span></pre><h2 id="ef43" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">执行始终运行迁移</h2><p id="18af" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">既然我们已经调整了我们的原始升级程序以排除AlwaysRun目录中的迁移，我们需要一些东西来执行always run迁移。为了实现这一点，我们添加了第二个升级程序，该升级程序被过滤为总是运行脚本。关于这个第二升级程序的第二个真正重要的地方是它使用了一个<strong class="jp ir"> NullJournal </strong>。<strong class="jp ir"> NullJournal </strong>阻止脚本的执行被记录，这导致它们总是运行。在上述代码之后插入了以下代码。突出显示的位指出过滤器和空日志。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="20d2" class="ky kz iq ly b gy mc md l me mf">if (result.Successful)<br/>{<br/>    var alwaysRunUpgrader =<br/>        DeployChanges.To<br/>                     .SqlDatabase(connectionString)<br/>                     .WithScriptsAndCodeEmbeddedInAssembly(Assembly.GetExecutingAssembly(),<br/>                                                           f =&gt; f.Contains(".AlwaysRun."))<br/>                     .JournalTo(new NullJournal())<br/>                     .LogToConsole()<br/>                     .Build();<br/><br/>    result = alwaysRunUpgrader.PerformUpgrade();<br/>}</span></pre><p id="b0aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是完整的<strong class="jp ir"> Main </strong>函数，以防上面的代码没有给出足够的上下文来说明代码应该如何组合在一起。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="ca7a" class="ky kz iq ly b gy mc md l me mf">static int Main(string[] args)<br/>{<br/>    var connectionString =<br/>        args.FirstOrDefault()<br/>        ?? "Server=localhost; Database=WideWorldImporters; Trusted_connection=true";<br/><br/>    var upgrader =<br/>        DeployChanges.To<br/>                     .SqlDatabase(connectionString)<br/>                     .WithScriptsAndCodeEmbeddedInAssembly(Assembly.GetExecutingAssembly(),<br/>                                                           f =&gt; !f.Contains(".AlwaysRun."))<br/>                     .LogToConsole()<br/>                     .Build();<br/><br/>    var result = upgrader.PerformUpgrade();<br/><br/>    if (result.Successful)<br/>    {<br/>        var alwaysRunUpgrader =<br/>            DeployChanges.To<br/>                         .SqlDatabase(connectionString)<br/>                         .WithScriptsAndCodeEmbeddedInAssembly(Assembly.GetExecutingAssembly(), <br/>                                                               f =&gt; f.Contains(".AlwaysRun."))<br/>                         .JournalTo(new NullJournal())<br/>                         .LogToConsole()<br/>                         .Build();<br/><br/>        result = alwaysRunUpgrader.PerformUpgrade();<br/>    }<br/><br/>    if (!result.Successful)<br/>    {<br/>        Console.ForegroundColor = ConsoleColor.Red;<br/>        Console.WriteLine(result.Error);<br/>        Console.ResetColor();<br/>#if DEBUG<br/>        Console.ReadLine();<br/>#endif                <br/>        return -1;<br/>    }<br/><br/>    Console.ForegroundColor = ConsoleColor.Green;<br/>    Console.WriteLine("Success!");<br/>    Console.ResetColor();<br/><br/>    return 0;<br/>}</span></pre><h2 id="16f7" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">包扎</h2><p id="b084" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">有了上面的更改，我们现在有了一个可以运行正常迁移、基于代码的迁移和始终运行迁移的项目。无论您决定采用哪种类型的数据库变更管理，在某种源代码控制系统中进行变更都会非常有帮助。</p><p id="62a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多关于DbUp日志的信息，请查看<a class="ae kl" href="https://dbup.readthedocs.io/en/latest/more-info/journaling/" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="ca5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mn">原载于</em><a class="ae kl" href="https://elanderson.net/2020/08/always-run-migrations-with-dbup/" rel="noopener ugc nofollow" target="_blank"><em class="mn"/></a><em class="mn">。</em></p></div></div>    
</body>
</html>