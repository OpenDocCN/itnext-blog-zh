<html>
<head>
<title>Sending logs from Flutter apps in real-time using ELK stack &amp; MQTT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ELK stack &amp; MQTT从Flutter应用程序实时发送日志</h1>
<blockquote>原文：<a href="https://itnext.io/sending-logs-from-flutter-apps-in-real-time-using-elk-stack-mqtt-c24fa0cb9802?source=collection_archive---------1-----------------------#2020-07-03">https://itnext.io/sending-logs-from-flutter-apps-in-real-time-using-elk-stack-mqtt-c24fa0cb9802?source=collection_archive---------1-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ed460312ab589291cd811da74431d498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daSdHzNK-UeKuPLJaMEybQ.png"/></div></div></figure><h1 id="3348" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">调试多个应用程序的问题:</h1><p id="e245" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您是否曾经不得不使用存储在不同来源的日志来调试应用程序的问题？我不得不这样做，并且花费了大量的时间来获取日志，仅仅是为了开始调试过程。有时，我甚至会等上好几天才能最终获得我请求的日志，因为我的用户的设备会被关闭。我的大部分时间都花在使用推送通知请求获取日志并等待它们到达。</p><figure class="lu lv lw lx gt jr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><blockquote class="ma mb mc"><p id="df5c" class="kw kx md ky b kz me lb lc ld mf lf lg mg mh lj lk mi mj ln lo mk ml lr ls lt ij bi translated">解决应用程序问题的第一步是减少解决问题所需的时间。</p></blockquote><p id="53dc" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">从一开始，日志可用性就一直是我的团队面临的最大问题。过去，我们确实尝试过一些解决方案，但没有一个是一致和可靠的。</p><p id="2747" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">生产环境中总会有异常和问题，但是检索日志并不一定是一个紧张的过程。如果你有日志，找出问题就不是问题了，因为最终，你将能够追踪模式，但是另一方面，如果你没有日志，找出问题可能是一场噩梦。</p><h1 id="84ff" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">正确的解决方案:</h1><p id="8cc8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">解决这个问题的方法是使用任何日志记录器在你的设备上存储异常日志，有审计日志和任何崩溃报告服务也很好，但是如果你有很多应用程序，管理日志本身就成为一个障碍。如何管理每天来自多个来源的数千个日志条目？有了<a class="ae mm" href="https://www.elastic.co/what-is/elk-stack" rel="noopener ugc nofollow" target="_blank"> ELK Stack </a>，解决方案变得更加简单。</p><h2 id="e1e7" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">ELK Stack是一个开源项目的集合，结合起来可以帮助您解决上述问题。</h2><blockquote class="ma mb mc"><p id="e5c5" class="kw kx md ky b kz me lb lc ld mf lf lg mg mh lj lk mi mj ln lo mk ml lr ls lt ij bi translated">TL；DR: Elasticsearch是一个搜索和分析引擎。Logstash是一个服务器端数据处理管道，它同时从多个来源获取数据，对其进行转换，然后将其发送到像Elasticsearch这样的“stash”。</p></blockquote><h1 id="26c6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我们的要求:</h1><p id="85b7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要将应用程序中特定事件的日志实时发送到一个集中的远程服务器，这些日志可以存储在一个由组织和用户分开的文件中。在报告任何问题的情况下，我们应该能够打开网站，通过应用适当的过滤器来搜索日志。一旦我们跟踪了日志，我们应该能够下载完整的日志文件进行审计。就这么简单。</p><h2 id="28c3" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">下面是它应该如何工作的简单流程:</h2><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/919cb3d49b87b696fffd502fb887bfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ssy7ls1OnGVbHrWRAOlMEg.png"/></div></div></figure><h1 id="11f5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置环境:</h1><p id="4561" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了开始这个解决方案，我必须在Azure Windows机器上安装ELK栈。我不会进入安装步骤，因为它们非常简单。你可以在这里找到安装步骤<a class="ae mm" href="https://www.elastic.co/start" rel="noopener ugc nofollow" target="_blank"/>。对我来说棘手的部分是设置配置。让我们深入研究一下。</p><h1 id="d767" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置MQTT:</h1><p id="35b1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了实时发送日志，我们选择了MQTT发布订阅。我们已经准备好了MQTT服务器，我们需要做的就是在<strong class="ky ir"> elk服务器和flutter应用</strong>上配置代理URL、端口、主题和证书。</p><p id="7973" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">ELK的插件<strong class="ky ir">‘log stash’</strong>提供了对MQTT输入的支持，但是它没有附带MQTT插件，所以我们必须自己安装。这个插件可以从这个<a class="ae mm" href="https://rubygems.org/gems/logstash-input-paho-mqtt/versions/0.1.1" rel="noopener ugc nofollow" target="_blank">链接</a>下载。下载完成后，可以通过执行一些额外的<a class="ae mm" href="https://www.rubydoc.info/gems/logstash-input-paho-mqtt/0.1.5" rel="noopener ugc nofollow" target="_blank">步骤</a>来安装。最后一步是将它添加到位于logstash目录中的gem文件:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/2af1c932e51fedebe6c7a55877221e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9mcRYTLzui2cRqOvWyW3A.png"/></div></div></figure><p id="67cb" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">我们的应用程序将发布日志到Logstash插件订阅的主题。为了告诉logstash监听MQTT输入，我们需要配置它。下面是我们在logstash上应用的配置:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/d76629557fd387935dd69699d4e872f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uibMdLEyK6V8htOUN2ZPg.png"/></div></div></figure><p id="911a" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">该配置保存在<strong class="ky ir"> logstash.conf </strong>文件中。这里我们使用MQTT的输入配置，过滤器从JSON模式中提取消息字段，接下来我们将讨论JSON模式。这里的输出将以文件的形式出现。每个日志条目将包含一些用于组织、应用程序&amp;用户的JSON字段。Logstash将使用这些值来创建一个新的目录或文件(如果尚未创建的话)。文件名将被时间格式化。</p><h1 id="7b55" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">FileBeats配置:</h1><p id="b5a4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Logstash从多个来源收集和解析文件中的日志，我们还需要将这些日志发送到Kibana仪表板。我们使用Filebeat作为高效的日志发送器。在我们的例子中，我们只需要它将日志从源路径发送到Kibana。我们在这里提供的路径与logtash放置日志的路径相同。Filebeat的配置保存在<strong class="ky ir"> filebeat.yml </strong>文件中。我们是这样配置的:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/26a59195920b7b5c5f647ed704a94a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otGAbZneT7jJy0W_b1LEnA.png"/></div></div></figure><h1 id="0319" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">运行服务:</h1><p id="51b6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一旦所有的配置都完成了，我们必须从命令行运行它们。必须启动以下服务和插件:</p><h2 id="0fbd" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">弹性服务</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="0de8" class="mn jz iq ne b gy ni nj l nk nl">./elasticsearch.bat</span></pre><h2 id="8f1a" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">基巴纳</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="9e3d" class="mn jz iq ne b gy ni nj l nk nl">./kibana.bat</span></pre><h2 id="55f1" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">Logstash</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="8857" class="mn jz iq ne b gy ni nj l nk nl">./logstash.bat -f logstash.conf</span></pre><h2 id="cc52" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">Filebeats</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="1d64" class="mn jz iq ne b gy ni nj l nk nl">./filebeat -c filebeat.yml -e -d "*"</span></pre><h1 id="e3e4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">ELK模式:</h1><p id="7f33" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了在<strong class="ky ir"> Kibana </strong>仪表板上显示日志，并能够对记录的数据应用过滤器，ELK要求将日志嵌入到预定义的模式中。这个模式的细节可以在<a class="ae mm" href="https://www.elastic.co/guide/en/ecs/current/ecs-reference.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们将该模式缩小到几个值，下面是该模式的一个示例:</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="ec5b" class="mn jz iq ne b gy ni nj l nk nl">{<br/>  "user": {<br/>    "user.email": "m.umair.adil@gmail.com",<br/>    "user.full_name": "umair",<br/>    "user.id": "17282738",<br/>    "user.hash": "1",<br/>    "user.name": "Umair"<br/>  },<br/>  "message": "{OkHttpClient}  {X-XSS-Protection: 1; mode=block} [30 June 2020 04:15:16 PM]",<br/>  "@version": "1",<br/>  "log.logger": "PLogger",<br/>  "host": {<br/>    "host.type": "Android",<br/>    "host.name": "LG",<br/>    "host.architecture": "LG 23",<br/>    "host.hostname": "8000",<br/>    "host.id": "LG",<br/>    "host.ip": "0.0.0.0",<br/>    "host.mac": ""<br/>  },<br/>  "labels": "{}",<br/>  "app": {<br/>    "app.language": "en-US",<br/>    "app.id": "com.example.develop",<br/>    "app.name": "Flutter Dev",<br/>    "app.version": "0.0.108"<br/>  },<br/>  "process.thread.name": "DATA_LOG",<br/>  "organization": {<br/>    "organization.name": "debug",<br/>    "organization.id": "BlackBox"<br/>  },<br/>  "geo": {<br/>    "geo.location": "{ \"lon\": 0.0, \"lat\": 0.0 }"<br/>  },<br/>  "service.name": "Network",<br/>  "@timestamp": "2020-06-30T16:27:36.894Z",<br/>  "topic": "com.flutter.elk.logs",<br/>  "log.level": "INFO"<br/>}</span></pre><p id="48ce" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">您在上面看到的一些字段是由Logstah自动插入的。这是因为我们使用了JSON过滤器插件。更多详情见此<a class="ae mm" href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-json.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="fc28" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">这里<strong class="ky ir">【消息】</strong>字段包含&amp;的日志信息，其他字段用于搜索&amp;过滤日志。在发布到MQTT之前，每个日志条目都将被嵌入到这个模式中。日志将作为JSON分隔的字符串写入文件。幸运的是，使用flutter日志插件创建这个模式的过程变得很简单，我们接下来将讨论这个插件。</p><h1 id="41b9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用于日志记录的Flutter插件:</h1><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/cab1894463c455e1c9efee1630a6b497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OISDyeUaSWdGUiMBTWtIrw.png"/></div></div></figure><p id="e671" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">我们已经创建了一个名为<strong class="ky ir">‘flutter _ logs’</strong>的flutter插件，用于记录日志文件中的数据，并在MQTT主题上发布它们。此插件可在以下位置找到:</p><div class="nn no gp gr np nq"><a href="https://pub.dev/packages/flutter_logs" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">flutter_logs | Flutter包</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">用于Flutter应用程序的基于文件的高级日志框架(Android)。iOS支持即将推出。颤振日志提供…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">公共开发</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe jw nq"/></div></div></a></div><p id="5028" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">这个插件是专门为更容易将日志实时发送到ELK stack而设计的。以下是该插件的一些主要特性:</p><ol class=""><li id="ea0a" class="of og iq ky b kz me ld mf lh oh ll oi lp oj lt ok ol om on bi translated">简单的MQTT配置&amp;主题的自动发布者</li><li id="cfc9" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated">记录ELK模式中的数据</li><li id="912d" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated">在本地存储上记录数据，以防需要完整的日志记录</li></ol><h2 id="e4d1" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">为了将这个插件添加到flutter项目中，只需在pubspec文件中添加这一行:</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="a959" class="mn jz iq ne b gy ni nj l nk nl">dependencies:<br/>  flutter_logs: [LATEST_VERSION]</span></pre><h2 id="a4cb" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">下一步是用一些配置初始化flutter_logs:</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="8b5d" class="mn jz iq ne b gy ni nj l nk nl"><strong class="ne ir">await</strong> FlutterLogs.initLogs(<br/>        logLevelsEnabled: [<br/>          LogLevel.INFO,<br/>          LogLevel.WARNING,<br/>          LogLevel.ERROR,<br/>          LogLevel.SEVERE<br/>        ],<br/>        timeStampFormat: TimeStampFormat.TIME_FORMAT_READABLE,<br/>        directoryStructure: DirectoryStructure.FOR_DATE,<br/>        logTypesEnabled: ["Locations","APIs"],<br/>        logFileExtension: LogFileExtension.LOG,<br/>        logsWriteDirectoryName: "FlutterLogs",<br/>        logsExportDirectoryName: "FlutterLogs/Exported"<br/>);</span></pre><p id="d09d" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">这里我们定义了以下内容:</p><ol class=""><li id="1b91" class="of og iq ky b kz me ld mf lh oh ll oi lp oj lt ok ol om on bi translated"><strong class="ky ir"> logLevelsEnabled: </strong>应该存储或发布多少级日志，默认为all，但您可以选择只发送<code class="fe ot ou ov ne b">ERROR or SEVERE</code>来保存数据</li><li id="924a" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated"><strong class="ky ir"> timeStampFormat: </strong>应该在每个日志条目中附加什么格式的时间</li><li id="18f6" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated"><strong class="ky ir"> directoryStructure: </strong>默认情况下，它提供3种类型，这里我们选择将日志放在设备上当前日期的目录中。例如，日志03102020</li><li id="45c4" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated"><strong class="ky ir"> logTypesEnabled: </strong>默认情况下，记录器将始终将数据记录到根据设备时间创建的每小时文件中，但您也可以添加自己的数据文件来记录特定事件。这些必须在日志配置中定义。</li><li id="c984" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated"><strong class="ky ir">日志文件扩展名:</strong>您可以使用该选项定义日志文件的扩展名。</li><li id="e638" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated"><strong class="ky ir">logsWriteDirectoryName:</strong>在该字段中，必须提供存储目录的路径，您希望在该目录中存储所有日志。</li><li id="27e5" class="of og iq ky b kz oo ld op lh oq ll or lp os lt ok ol om on bi translated"><strong class="ky ir">logsExportDirectoryName:</strong>在此字段中，必须提供存储目录的路径，您希望将所有日志导出为压缩的zip文件。</li></ol><h2 id="d759" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">要添加MQTT配置，请添加以下块:</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="9d95" class="mn jz iq ne b gy ni nj l nk nl"><strong class="ne ir">await</strong> FlutterLogs.initMQTT(<br/>        topic: "YOUR_TOPIC",<br/>        brokerUrl: "", <em class="md">//Add URL without schema</em><br/>        certificate: "name_of_your_certificate_file",<br/>        port: "8883");</span></pre><h2 id="208f" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">要启用和添加ELK模式选项，请在初始化日志后添加以下块:</h2><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="9eb3" class="mn jz iq ne b gy ni nj l nk nl"><strong class="ne ir">await</strong> FlutterLogs.setMetaInfo(<br/>      appId: "flutter_logs_example",<br/>      appName: "Flutter Logs Demo",<br/>      appVersion: "1.0",<br/>      language: "en-US",<br/>      deviceId: "00012",<br/>      environmentId: "7865",<br/>      environmentName: "dev",<br/>      organizationId: "5767",<br/>      userId: "883023-2832-2323",<br/>      userName: "umair13adil",<br/>      userEmail: "m.umair.adil@gmail.com",<br/>      deviceSerial: "YJBKKSNKDNK676",<br/>      deviceBrand: "LG",<br/>      deviceName: "LG-Y08",<br/>      deviceManufacturer: "LG",<br/>      deviceModel: "989892BBN",<br/>      deviceSdkInt: "26"<br/>    );</span></pre><p id="b866" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated"><strong class="ky ir">注意:</strong>所有这些字段都是可选的。</p><h1 id="225d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">运行Flutter应用:</h1><p id="b872" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一旦我们运行我们的应用程序，我们的日志将开始出现在Kibana仪表板中:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/f053e4d812f87860d0f36c5c15229ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEeGG1K03Kr5_qZo4KqN6g.png"/></div></div></figure><p id="1808" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">我们可以很容易地从这些日志中找到组织id和用户id，一旦有了这些信息，我们就可以从服务器的存储中下载这些日志的完整文件。</p><h1 id="a1b0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论:</h1><p id="e9db" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">ELK stack是一个强大的日志集中工具，即使有多个应用程序，我们也可以将所有日志转发到一个点，它能够处理大量的日志数据。跟踪问题和获取日志的时间大大减少了。我们期待使用ELK stack提供的机器学习功能。通过尝试Kibana提供的不同特性和插件，我们有很多方法可以使它更好地用于我们未来的应用程序。</p><p id="baae" class="pw-post-body-paragraph kw kx iq ky b kz me lb lc ld mf lf lg lh mh lj lk ll mj ln lo lp ml lr ls lt ij bi translated">下面是<strong class="ky ir"> flutter_logs </strong>演示的样本代码:</p><div class="nn no gp gr np nq"><a href="https://github.com/umair13adil/flutter_logs" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">umair13adil/flutter_logs</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">iOS支持即将推出。Flutter Logs提供快速简单的基于文件的日志解决方案。所有日志都保存到文件中…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="ox l ob oc od nz oe jw nq"/></div></div></a></div></div></div>    
</body>
</html>