<html>
<head>
<title>Implementing LDAP authentication for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Kubernetes实现LDAP认证</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-ldap-authentication-for-kubernetes-732178ec2155?source=collection_archive---------0-----------------------#2020-06-22">https://itnext.io/implementing-ldap-authentication-for-kubernetes-732178ec2155?source=collection_archive---------0-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="84a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文展示了如何使用<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌</a>认证插件为Kubernetes实现<a class="ae ko" href="https://connect2id.com/products/ldapauth/auth-explained" rel="noopener ugc nofollow" target="_blank"> LDAP认证</a>。这篇文章包括一个教程，带你从零到完整的系统，一步一步的指示。不需要事先了解Kubernetes认证。</p><p id="883a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，您将从头开始设置一个LDAP目录、一个webhook服务和一个Kubernetes集群。你将所有组件部署到<a class="ae ko" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>。最终，您将拥有一个完全可用的Kubernetes集群，用户可以使用他们的LDAP凭证访问它。</p><blockquote class="kp kq kr"><p id="ac00" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">这篇文章的前一个版本已经发表在learnk8s.io 上。</p></blockquote><h1 id="23f1" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">内容</h1><ul class=""><li id="fdc3" class="lu lv it js b jt lw jx lx kb ly kf lz kj ma kn mb mc md me bi translated"><a class="ae ko" href="#bfce" rel="noopener ugc nofollow"> <strong class="js iu">简介</strong> </a></li><li id="c7f0" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#a4ab" rel="noopener ugc nofollow"> <strong class="js iu"> Kubernetes API访问</strong> </a></li><li id="852f" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#59be" rel="noopener ugc nofollow"> <strong class="js iu">认证</strong> </a></li><li id="f282" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#bc98" rel="noopener ugc nofollow"> <strong class="js iu">教程概述</strong> </a></li><li id="f088" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#ed12" rel="noopener ugc nofollow">教程<strong class="js iu">先决条件</strong>教程</a></li><li id="3dda" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#6c69" rel="noopener ugc nofollow"> <strong class="js iu">第一步:创建LDAP目录</strong> </a></li><li id="7278" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#96d3" rel="noopener ugc nofollow"> <strong class="js iu">第二步:创建webhook服务</strong> </a></li><li id="1e7b" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#a94a" rel="noopener ugc nofollow"> <strong class="js iu">步骤3:创建Kubernetes集群</strong> </a></li><li id="85db" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#15eb" rel="noopener ugc nofollow"> <strong class="js iu">第四步:测试LDAP认证</strong> </a></li><li id="32b1" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#cb95" rel="noopener ugc nofollow"> <strong class="js iu">清理</strong> </a></li><li id="8e89" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#2bf4" rel="noopener ugc nofollow"> <strong class="js iu">结论</strong> </a></li></ul><h1 id="bfce" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h1><p id="b57a" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">Kubernetes支持几种开箱即用的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" rel="noopener ugc nofollow" target="_blank">认证方法</a>，比如<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs" rel="noopener ugc nofollow" target="_blank"> X.509客户端证书</a>、<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file" rel="noopener ugc nofollow" target="_blank">静态HTTP承载令牌</a>，以及<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a>。</p><p id="8794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，Kubernetes也允许实现定制的身份验证方法。这些可能是已经用于组织中现有应用程序和服务的身份验证方法。这使得Kubernetes能够与现有的认证基础设施无缝集成。</p><p id="6fa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在企业中广泛使用的认证方法之一是<a class="ae ko" href="https://connect2id.com/products/ldapauth/auth-explained" rel="noopener ugc nofollow" target="_blank"> LDAP认证</a>。</p><blockquote class="kp kq kr"><p id="4e4b" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">LDAP代表<a class="ae ko" href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">轻量级目录访问协议</strong> </a>，是一种<a class="ae ko" href="https://en.wikipedia.org/wiki/Directory_service" rel="noopener ugc nofollow" target="_blank">目录服务</a>(类似于DNS)，通常用作组织中凭证和其他用户信息的中心来源。</p></blockquote><p id="1c34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LDAP身份验证意味着用户凭证集中保存在LDAP服务器(称为LDAP目录)中，使用LDAP身份验证的应用程序通过查询该LDAP目录来验证所提供的用户凭证。这意味着用户可以在多个应用程序和服务中重复使用相同的凭据，并且可以在整个组织的一个中心位置管理所有凭据。</p><p id="018a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文的教程部分，您将为Kubernetes集群实现LDAP身份验证。这意味着:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/82de71474cc4d33bd27fc99de8645a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ne1jVrYf8SysxapO34J_Bg.png"/></div></div></figure><p id="d15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有用户的凭据都保存在外部LDAP目录中并进行管理。当用户访问Kubernetes时，他们会在其Kubernetes请求中包含一个由这些凭证组成的令牌。然后，LDAP身份验证实现通过对照LDAP目录检查包含的凭据来验证这些令牌。</p><p id="9f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">在进入实践部分之前，让我们回顾一下关于如何访问Kubernetes API的一些理论，特别是身份验证。</em></p><h1 id="a4ab" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Kubernetes API访问</h1><p id="ff31" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">对Kubernetes API的每个请求在API服务器中都要经过三个阶段:<strong class="js iu">认证</strong>、<strong class="js iu">授权</strong>和<strong class="js iu">准入控制</strong>:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mz"><img src="../Images/da5324c9f6966230420e23034b026b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8v09gHiC8LUgpt-XJck7Q.png"/></div></div></figure><p id="0f9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个阶段都有明确的目的:</p><ul class=""><li id="a6bb" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">认证</strong> </a>检查发出请求的用户是否是Kubernetes集群的合法用户。</li><li id="c2a6" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">授权</strong> </a>检查用户是否有权执行所请求的Kubernetes API操作。</li><li id="1057" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">准入控制</strong> </a>对请求执行各种附加的可配置验证和变异。</li></ul><p id="268f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请求可以在每个阶段被拒绝，只有成功通过所有三个阶段的请求才由Kubernetes API处理。</p><p id="5517" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">因为本教程是关于认证的，所以让我们仔细看看认证阶段。</em></p><h1 id="59be" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">证明</h1><p id="a11f" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">在内部，认证阶段由一系列<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authentication-strategies" rel="noopener ugc nofollow" target="_blank">认证插件</a>组成:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nd"><img src="../Images/b8cb574f2daab5528da37bb985575e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtJLv97-JYDNgGnYfMqx4A.png"/></div></div></figure><p id="59d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传入的请求按顺序传递给每个身份验证插件。每个身份验证插件都会尝试验证请求中的凭据:</p><ul class=""><li id="6014" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated">如果认证插件成功验证了凭证，则剩余的认证插件被短路，并且请求直接进行到授权阶段。</li><li id="e4e6" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">如果一个身份验证插件无法验证凭证，请求将被传递给链中的下一个身份验证插件。</li><li id="9a41" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">如果没有一个认证插件可以验证凭证，则该请求将被拒绝，并显示一个<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> 401未授权</strong> </a> HTTP状态代码。</li></ul><blockquote class="kp kq kr"><p id="aa44" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">旁注:<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> 401未授权</strong> </a>状态码是<a class="ae ko" href="https://stackoverflow.com/a/6937030/4747193" rel="noopener ugc nofollow" target="_blank">长期以来的误称</a>，因为它表示认证错误，而不是顾名思义的授权错误。授权错误的HTTP状态代码是<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> 403禁止</strong> </a>。</p></blockquote><p id="181d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看认证插件。</p><h2 id="ca78" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">认证插件</h2><p id="0175" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">首先，这里有两个关于认证插件的重要事实:</p><ul class=""><li id="7cde" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated">认证插件被编译成<a class="ae ko" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> kube-apiserver </a>二进制文件。这意味着，它们有一个固定的集合，你不能从头开始开发你自己的认证插件。但是，您可以将自己的身份验证逻辑注入到一些现有的身份验证插件中(这是您在本教程中将会做的)。</li><li id="3114" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">当API服务器启动时，可以有选择地启用认证插件，命令行标志指向<a class="ae ko" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> kube-apiserver </a>二进制文件。更改启用的身份验证插件集需要重新启动API服务器。可以启用任意数量的认证插件及其组合。</li></ul><p id="5f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么有哪些认证插件呢？</p><p id="a6a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是Kubernetes v1.18中未被否决的认证插件的完整列表:</p><ol class=""><li id="25d1" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">静态令牌文件</strong> </a></li><li id="eec3" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> X.509客户证书</strong> </a></li><li id="4e58" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> OpenID连接令牌</strong> </a></li><li id="c369" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">认证代理</strong> </a></li><li id="c338" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Webhook令牌</strong> </a></li><li id="e327" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">服务账户令牌</strong> </a></li><li id="35d5" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#bootstrap-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">自举令牌</strong> </a></li></ol><blockquote class="kp kq kr"><p id="5645" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">直到Kubernetes v1.16，还有<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-password-file" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">静态密码文件</strong> </a>认证插件(实现<a class="ae ko" href="https://tools.ietf.org/html/rfc7617" rel="noopener ugc nofollow" target="_blank"> HTTP基本认证</a>)，现在<a class="ae ko" href="https://v1-16.docs.kubernetes.io/docs/setup/release/notes/#deprecations-and-removals" rel="noopener ugc nofollow" target="_blank">已弃用</a>。</p></blockquote><p id="d44c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们对这些认证插件进行简单分类，并讨论每个插件的作用。</p><p id="5b1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是<strong class="js iu">完全实现的认证插件</strong>，这意味着它们实现了特定的认证方法:</p><ul class=""><li id="f1af" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">静态令牌文件</strong> </a> <strong class="js iu"> : </strong>允许使用静态定义的<a class="ae ko" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank"> HTTP承载令牌</a>进行认证。</li><li id="8e93" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> X.509客户端证书</strong> </a> <strong class="js iu"> : </strong>允许使用由静态定义的证书颁发机构(CA)签名的X.509客户端证书进行身份验证。</li><li id="fc41" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> OpenID连接令牌</strong> </a> <strong class="js iu"> : </strong>允许使用外部OpenID连接身份提供者颁发的<a class="ae ko" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID连接</a>令牌进行身份验证。</li></ul><p id="412b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是<strong class="js iu">框架认证插件</strong>，也就是说它们本身不实现任何认证逻辑，但是允许你注入自己的认证逻辑:</p><ul class=""><li id="f235" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">认证代理</strong> </a> <strong class="js iu"> : </strong>允许在Kubernetes集群前配置一个代理服务器，执行用户请求的认证，并将认证的请求转发给Kubernetes。</li><li id="6c93" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Webhook令牌</strong> </a> <strong class="js iu"> : </strong>允许定义一个外部Webhook服务，该服务由webhook令牌认证插件调用，用于验证用户在其请求中包含的<a class="ae ko" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank"> HTTP承载令牌</a>。</li></ul><p id="cdeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，以下是<strong class="js iu">系统认证插件</strong>，这意味着它们仅用于系统目的，而不用于人类集群用户的认证:</p><ul class=""><li id="422e" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">服务账户令牌</strong> </a> <strong class="js iu"> : </strong>处理<a class="ae ko" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" rel="noopener ugc nofollow" target="_blank"> Kubernetes服务账户</a>的请求认证。</li><li id="1f39" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#bootstrap-tokens" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">引导令牌</strong> </a> <strong class="js iu"> : </strong>仅在kubeadm等工具进行集群引导期间使用，用于临时认证来自Kubernetes系统组件的请求。</li></ul><p id="aff5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，您永远不需要直接处理<strong class="js iu">系统认证插件</strong> ( <a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens" rel="noopener ugc nofollow" target="_blank">服务帐户令牌</a>和<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#bootstrap-tokens" rel="noopener ugc nofollow" target="_blank">引导令牌</a>)，因为它们只由Kubernetes本身或集群创建工具使用。</p><p id="ad8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果任何一个<strong class="js iu">完全实现的认证插件</strong> ( <a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#static-token-file" rel="noopener ugc nofollow" target="_blank">静态令牌文件</a>、<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs" rel="noopener ugc nofollow" target="_blank"> X.509客户端证书</a>、<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens" rel="noopener ugc nofollow" target="_blank"> OpenID连接令牌</a>)实现了您想要的认证方法，您可以开箱即用。否则，您可以使用一个<strong class="js iu">框架认证插件</strong> ( <a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy" rel="noopener ugc nofollow" target="_blank">认证代理</a>和<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌</a>)来实现您想要的认证方法。</p><p id="9d04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文的教程部分，您将使用<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Webhook令牌</strong> </a>身份验证插件实现LDAP身份验证。</p><p id="f771" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">让我们仔细看看您在教程中将构建什么。</em></p><h1 id="bc98" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">教程概述</h1><p id="f4d9" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">以下是您将在本教程中构建的完整系统:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nr"><img src="../Images/a9a2d993e8f15b9cd6b30aa28553bba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gh_Ly0ZwRkSNEueLBNjFNg.png"/></div></div></figure><p id="e07b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该系统包括三个主要组件(编号如上):</p><ol class=""><li id="6676" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn nq mc md me bi translated">LDAP目录:这是管理所有用户信息的中心。LDAP目录完全独立于Kubernetes，它可能存在于Kubernetes集群之前(在为Kubernetes实现LDAP身份验证的实际场景中，LDAP目录很可能已经存在并用于其他应用程序)。您将使用<a class="ae ko" href="https://www.openldap.org/" rel="noopener ugc nofollow" target="_blank"> OpenLDAP </a>作为您的LDAP目录实现。</li><li id="9845" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><strong class="js iu"> Webhook服务:</strong>这是处理来自Kubernetes API服务器中的<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌</a>认证插件的令牌验证请求的Webhook服务。为此，webhook服务与LDAP目录进行交互。您将在<a class="ae ko" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>中实现该服务。</li><li id="f8aa" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated"><strong class="js iu"> Kubernetes集群:</strong>这是向用户提供LDAP认证的Kubernetes集群。它启用了Webhook令牌身份验证插件，并配置为与上述webhook服务一起工作。您将使用<a class="ae ko" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>创建这个集群。</li></ol><p id="88e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将把所有这些组件部署到<a class="ae ko" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">谷歌云平台(GCP) </strong> </a>。</p><blockquote class="kp kq kr"><p id="9e5c" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">为本教程创建的GCP资源超过了<a class="ae ko" href="https://cloud.google.com/free" rel="noopener ugc nofollow" target="_blank"> GCP免费等级</a>，因此将产生费用。这些费用不应超过每小时0.10美元(即每天2.40美元)。如果你<a class="ae ko" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">创建了一个新的GCP账户</a>，你将获得300美元的信用点数，可以用于本教程。</p></blockquote><p id="ea95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Webhook令牌认证插件期望Kubernetes请求包含一个<a class="ae ko" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank"> HTTP承载令牌</a>。在您将要构建的系统中，该令牌具有以下形式:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="8572" class="ne kx it nt b gy nx ny l nz oa">username:password<!-- --> </span></pre><p id="3604" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个令牌中，<code class="fe ob oc od nt b">username</code>是发出请求的用户的用户名，<code class="fe ob oc od nt b">password</code>是保存在LDAP目录中的相应密码。</p><blockquote class="kp kq kr"><p id="212c" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">在现实场景中，这个令牌也应该用<a class="ae ko" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> Base64 </a>编码(或类似的编码)，以允许用户名或密码中有特殊字符。</p></blockquote><p id="76d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果有一个名为爱丽丝的用户，在LDAP目录中保存了用户名<code class="fe ob oc od nt b">alice</code>和密码<code class="fe ob oc od nt b">alicepassword</code>，那么爱丽丝的令牌就是<code class="fe ob oc od nt b">alice:alicepassword</code>。为了访问Kubernetes集群，Alice将把这个令牌作为HTTP承载令牌包含在她的Kubernetes请求中。</p><p id="efd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一下如果Alice提出这样的请求会发生的步骤:</p><ol class=""><li id="d954" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn nq mc md me bi translated">Webhook令牌认证插件接收请求并提取令牌<code class="fe ob oc od nt b">alice:alicepassword</code>。</li><li id="8b59" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">Webhook令牌身份验证插件将令牌提交给webhook服务进行验证。</li><li id="5835" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">webhook服务解释令牌并从中提取用户名部分(<code class="fe ob oc od nt b">alice</code>)和密码部分(<code class="fe ob oc od nt b">alicepassword</code>)。</li><li id="0705" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">webhook服务查询LDAP目录以检查<code class="fe ob oc od nt b">alice</code>和<code class="fe ob oc od nt b">alicepassword</code>是否是Alice的正确用户名和密码。</li><li id="0817" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">webhook服务将该查询的结果传递回Webhook令牌认证插件。</li><li id="e081" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">Webhook令牌身份验证插件根据webhook服务的响应接受或拒绝请求。</li></ol><p id="d4e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你应该对你将在教程中构建什么有一个粗略的想法。</p><p id="604e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">接下来，让我们确保您的机器已准备好执行任务。</em></p><h1 id="ed12" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">教程的先决条件</h1><p id="053b" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">以下是本教程的先决条件列表:</p><ul class=""><li id="179b" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><a class="ae ko" href="#ebf9" rel="noopener ugc nofollow"> <strong class="js iu"> GCP账号和命令行工具</strong> </a></li><li id="600e" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#257d" rel="noopener ugc nofollow"> <strong class="js iu"> Go工具</strong> </a></li><li id="f220" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><a class="ae ko" href="#17f4" rel="noopener ugc nofollow"> <strong class="js iu"> LDAP客户端工具</strong> </a></li></ul><h2 id="ebf9" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">GCP帐户和命令行工具</h2><p id="1fc5" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">由于系统将在<a class="ae ko" href="https://connect2id.com/products/ldapauth/auth-explained" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>上运行，你需要一个GCP账户。您还需要<code class="fe ob oc od nt b"><a class="ae ko" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank">gcloud</a></code>命令行工具来管理您的GCP帐户中的GCP资源，</p><p id="0398" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你还没有GCP账户，你可以在GCP网站上创建一个。如果你创建了一个新帐户，你将获得价值300美元的积分，可以用于本教程。</p><p id="f9e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，如果您还没有这样做，您需要在您的机器上安装<code class="fe ob oc od nt b"><a class="ae ko" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank">gcloud</a></code>命令行工具。<code class="fe ob oc od nt b">gcloud</code>是<a class="ae ko" href="https://cloud.google.com/sdk" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a>的一部分。您可以按如下方式<a class="ae ko" href="https://cloud.google.com/sdk/docs/downloads-interactive" rel="noopener ugc nofollow" target="_blank">安装Google Cloud SDK </a>:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="a3d2" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ curl https://sdk.cloud.google.com | bash</strong></span></pre><p id="53d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，重启你的外壳，<code class="fe ob oc od nt b">gcloud</code>应该就能正确安装了。</p><p id="53ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您刚刚安装了<code class="fe ob oc od nt b">gcloud</code>，您必须使用以下命令对其进行初始化:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="e5d1" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud init</strong></span></pre><p id="cf5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令带你通过一个交互式对话框，允许你用各种默认值配置<code class="fe ob oc od nt b">gcloud</code>工具。</p><blockquote class="kp kq kr"><p id="4e8a" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">在该对话中，确保设置一个<a class="ae ko" href="https://cloud.google.com/compute/docs/regions-zones/" rel="noopener ugc nofollow" target="_blank">默认计算区域和区域</a>。</p></blockquote><p id="0831" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你还必须确保在你当前的<a class="ae ko" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank"> GCP项目</a>中启用了<a class="ae ko" href="https://cloud.google.com/compute/" rel="noopener ugc nofollow" target="_blank">谷歌计算引擎API </a>:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="3e90" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud services enable compute.googleapis.com</strong></span></pre><p id="2c24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为最后一项检查，您可以通过运行以下命令来验证<code class="fe ob oc od nt b">gcloud</code>是否设置正确:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="f53d" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute instances list</strong></span></pre><p id="d7a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这个命令没有错误地完成，那么您就已经设置好了。</p><h2 id="257d" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">Go工具</h2><p id="4de1" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">您将在Go中实现webhook服务，因此您需要能够编译Go源代码。这可以通过在机器上安装Go工具来实现。</p><p id="1523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> macOS </strong>上，您可以使用:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="08a0" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ brew install go</strong></span></pre><p id="4efc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> Linux </strong>上，您可以使用以下命令序列安装Go工具(如<a class="ae ko" href="https://golang.org/doc/install#tarball" rel="noopener ugc nofollow" target="_blank"> Go文档</a>中所述):</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="1e46" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">{<br/>  wget </strong><a class="ae ko" href="https://dl.google.com/go/go1.14.linux-amd64.tar.gz" rel="noopener ugc nofollow" target="_blank"><strong class="nt iu">https://dl.google.com/go/go1.14.linux-amd64.tar.gz</strong></a><strong class="nt iu"><br/>  sudo tar -C /usr/local -xzf go1.14.linux-amd64.tar.gz<br/>  echo "PATH=$PATH:/usr/local/go/bin" &gt;&gt;~/.bash_profile &amp;&amp;<br/>    . ~/.bash_profile<br/>}</strong></span></pre><p id="c75a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令验证Go的安装:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="2ee9" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ go version</strong></span></pre><h2 id="17f4" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">LDAP客户端工具</h2><p id="0be9" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">您需要从本地机器与LDAP目录进行交互。这可以通过一组名为<code class="fe ob oc od nt b">ldapsearch</code>、<code class="fe ob oc od nt b">ldapadd</code>和<code class="fe ob oc od nt b">ldapmodify</code>的LDAP客户端工具来完成，等等。</p><p id="b3ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> macOS </strong>上，这些工具是默认安装的，所以你不需要做任何事情。</p><p id="335a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> Linux </strong>上，这些工具是由<code class="fe ob oc od nt b"><a class="ae ko" href="https://wiki.debian.org/LDAP/LDAPUtils" rel="noopener ugc nofollow" target="_blank">ldap-utils</a></code>包提供的，你可以按如下方式安装:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="b247" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ sudo apt-get install ldap-utils</strong></span></pre><p id="e4c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令验证您的计算机上是否安装了LDAP客户端工具:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="6f34" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ ldapsearch -VV</strong></span></pre><p id="f397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">你现在已经准备好开始学习教程了，所以让我们开始吧！</em></p><h1 id="6c69" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤1:创建LDAP目录</h1><p id="68a5" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">您将从创建LDAP目录开始，该目录将作为您组织中所有用户信息的中心来源:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nr"><img src="../Images/641bde7d9b0680378df33710b281fe68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7s1fGQ4zr_3cSnZzVMs3fA.png"/></div></div></figure><blockquote class="kp kq kr"><p id="79e3" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">对于本教程，LDAP目录是按需创建的。然而，在您实施Kubernetes LDAP身份验证的真实场景中，您的组织中可能已经有一个LDAP目录，并将其用于其他应用程序和服务。在这种情况下，您可以跳过这一步，直接从教程的<a class="ae ko" href="#96d3" rel="noopener ugc nofollow"> <strong class="js iu">步骤2 </strong> </a>开始。</p></blockquote><p id="b7c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要设置LDAP目录，您需要在您的GCP帐户的<a class="ae ko" href="https://cloud.google.com/compute/docs/instances" rel="noopener ugc nofollow" target="_blank"> GCP虚拟机实例</a>上安装<a class="ae ko" href="https://www.openldap.org/" rel="noopener ugc nofollow" target="_blank"> OpenLDAP </a>。</p><p id="9357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从创建必要的GCP基础设施开始。</p><h2 id="55fc" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">创建基础设施</h2><p id="5d2e" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">首先，您需要创建一个新的<a class="ae ko" href="https://cloud.google.com/vpc/docs/vpc" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> GCP VPC网络和子网</strong> </a>，您将在其中创建所有其他GCP资源:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="2093" class="ne kx it nt b gy nx ny l nz oa"><em class="ks"># VPC network<br/></em><strong class="nt iu">$ gcloud compute networks create k8s-authn-vpc \<br/>    --subnet-mode custom<br/></strong><em class="ks"># Subnet<br/></em><strong class="nt iu">$ gcloud compute networks subnets create k8s-authn-subnet \<br/>    --network k8s-authn-vpc \<br/>    --range 10.0.0.0/16</strong></span></pre><p id="5234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，创建<a class="ae ko" href="https://cloud.google.com/compute/docs/instances" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> GCP虚拟机实例</strong> </a>，稍后您将在其中部署OpenLDAP:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="5e7e" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute instances create authn \<br/>    --subnet k8s-authn-subnet \<br/>    --machine-type n1-standard-1  \<br/>    --image-family ubuntu-1804-lts \<br/>    --image-project ubuntu-os-cloud</strong></span></pre><blockquote class="kp kq kr"><p id="1cc2" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">上面的命令在您之前刚刚创建的子网<code class="fe ob oc od nt b">k8s-authn-subnet</code>中创建了一个名为<code class="fe ob oc od nt b">authn</code>的VM实例。</p></blockquote><p id="225b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您刚刚创建的实例既有一个<em class="ks">内部</em> IP地址(可以从运行该实例的VPC网络内部访问)又有一个<em class="ks">外部</em> IP地址(可以从VPC网络外部访问，比如从您的本地机器)。</p><p id="cb49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，您将需要多次引用这些IP地址，因此将它们保存在环境变量中，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="cd31" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ AUTHN_EXTERNAL_IP=$(gcloud compute instances describe authn \<br/>    --format='value(networkInterfaces[0].accessConfigs[0].natIP)')<br/>$ AUTHN_INTERNAL_IP=$(gcloud compute instances describe authn \<br/>    --format='value(networkInterfaces[0].networkIP)')</strong></span></pre><p id="baa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，创建下面的<a class="ae ko" href="https://cloud.google.com/vpc/docs/firewalls" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> GCP防火墙规则</strong> </a>，使该实例可以从同一个GCP子网中的其他实例和您的本地机器访问:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c31d" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute firewall-rules create allow-internal-and-admin \<br/>    --network k8s-authn-vpc \<br/>    --allow icmp,tcp,udp \<br/>    --source-ranges 10.0.0.0/16,$(curl checkip.amazonaws.com)</strong></span></pre><blockquote class="kp kq kr"><p id="3f47" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">上述防火墙规则允许来自子网中所有其他实例(IP地址范围<code class="fe ob oc od nt b">10.0.0.0/16</code>)和您的本地机器(IP地址由<code class="fe ob oc od nt b">curl</code>确定)的所有流量进入您的子网中的所有实例。如果您本地机器的公共IP地址发生了变化，您可以用<code class="fe ob oc od nt b"><a class="ae ko" href="https://cloud.google.com/sdk/gcloud/reference/compute/firewall-rules/update" rel="noopener ugc nofollow" target="_blank"><em class="it">gcloud compute firewall-rules update</em></a></code>命令更新防火墙规则。</p></blockquote><p id="5519" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您应该能够从本地计算机连接到该实例。尝试通过SSH登录到实例，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="8da7" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute ssh root@authn</strong></span></pre><p id="52d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">如果登录成功，那么您就准备好将OpenLDAP部署到这个实例了。</em></p><h2 id="3e77" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">安装OpenLDAP</h2><p id="4ad0" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">安装OpenLDAP是通过安装<code class="fe ob oc od nt b"><a class="ae ko" href="https://packages.ubuntu.com/bionic/slapd" rel="noopener ugc nofollow" target="_blank">slapd</a></code>包来完成的。为了便于OpenLDAP的配置，您将预置这个包的一些设置，您可以使用下面的命令来完成(确保您仍然登录到实例):</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="8e40" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ cat &lt;&lt;EOF | debconf-set-selections<br/></strong>slapd slapd/password1 password adminpassword<br/>slapd slapd/password2 password adminpassword<br/>slapd slapd/domain string mycompany.com<br/>slapd shared/organization string mycompany.com<strong class="nt iu"><br/>EOF</strong></span></pre><p id="798f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，安装<code class="fe ob oc od nt b">slapd</code>包，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="4be4" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ apt-get update<br/>$ apt-get install -y slapd</strong></span></pre><p id="b719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这样，OpenLDAP现在应该已经启动并运行，而且配置正确。您可以再次从实例中注销:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="4e23" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ exit</strong></span></pre><p id="6cec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">下一步是将一些数据放入LDAP目录中。</em></p><h2 id="203c" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">创建LDAP用户条目</h2><p id="21b2" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">目前，您的LDAP目录是空的。让我们通过创建一个初始用户条目来改变这种情况。该条目应对应于名为Alice的用户，并包含以下信息:</p><ul class=""><li id="675c" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated">名字:爱丽丝</li><li id="4b98" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">姓氏:</strong>仙境</li><li id="80be" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">组:</strong> <code class="fe ob oc od nt b">dev</code></li><li id="0ff6" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">用户名:</strong>T3】</li><li id="838b" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">密码:</strong>T4】</li></ul><p id="99a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，这定义了关于Alice的一些基本信息(姓名、组成员)，以及Alice的凭证(用户名<code class="fe ob oc od nt b">alice</code>和密码<code class="fe ob oc od nt b">alicepassword</code>)。</p><blockquote class="kp kq kr"><p id="3dd2" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">这些是Alice在本教程结束时能够向Kubernetes集群进行身份验证的凭证。</p></blockquote><p id="f014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在LDAP目录中创建一个条目，必须用<a class="ae ko" href="https://en.wikipedia.org/wiki/LDAP_Data_Interchange_Format" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> LDAP数据交换格式(LDIF) </strong> </a>格式来表示。为此，将以下信息保存在名为<code class="fe ob oc od nt b">alice.ldif</code>的文件中:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c0b4" class="ne kx it nt b gy nx ny l nz oa">dn: cn=alice,dc=mycompany,dc=com<br/>objectClass: top<br/>objectClass: inetOrgPerson<br/>gn: Alice<br/>sn: Wonderland<br/>ou: dev<br/>cn: alice<br/>userPassword: alicepassword</span></pre><blockquote class="kp kq kr"><p id="549b" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">如果您以前没有使用过LDAP，LDIF格式可能会显得奇怪。一般来说，LDIF条目由一个标识符<code class="fe ob oc od nt b">dn</code>(专有名称)和一组属性组成，例如<code class="fe ob oc od nt b">gn</code>(名)<code class="fe ob oc od nt b">sn</code>(姓)<code class="fe ob oc od nt b">ou</code>(组织单位)<code class="fe ob oc od nt b">cn</code>(通用名)和<code class="fe ob oc od nt b">userPassword</code>。</p></blockquote><p id="25b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在LDAP目录中创建这个条目，您可以使用<code class="fe ob oc od nt b">ldapadd</code>工具(您确保已经安装在<a class="ae ko" href="#17f4" rel="noopener ugc nofollow">先决条件</a>中)，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="736a" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ ldapadd -H ldap://"$AUTHN_EXTERNAL_IP" \<br/>    -x -D cn=admin,dc=mycompany,dc=com -w adminpassword \<br/>    -f alice.ldif</strong></span></pre><p id="273f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令应该通过显示一条消息<code class="fe ob oc od nt b">adding new entry "cn=alice,dc=mycompany,dc=com"</code>来确认条目已经被添加。</p><p id="ade6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了仔细检查条目是否已经添加，让我们从LDAP目录中查询它。这可以用<code class="fe ob oc od nt b">ldapsearch</code>工具来完成:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="7291" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ ldapsearch -LLL -H ldap://"$AUTHN_EXTERNAL_IP" \<br/>    -x -D cn=admin,dc=mycompany,dc=com -w adminpassword \<br/>    -b dc=mycompany,dc=com \<br/>    cn=alice</strong></span></pre><p id="ba33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该会打印出以下输出:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="4588" class="ne kx it nt b gy nx ny l nz oa">dn: cn=alice,dc=mycompany,dc=com<br/>objectClass: top<br/>objectClass: inetOrgPerson<br/>givenName: Alice<br/>sn: Wonderland<br/>ou: dev<br/>cn: alice<br/>userPassword:: YWxpY2VwYXNzd29yZA==</span></pre><p id="1524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答对了，这正是您刚刚添加的条目(唯一的区别是密码已经被LDAP目录进行了<a class="ae ko" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> Base64编码</a>)。因此，Alice的用户条目现在确实保存在LDAP目录中。</p><p id="4d87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，您已经成功地安装了一个LDAP目录，并为Alice添加了一个用户条目。</p><p id="17bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">这就完成了教程的第一步。</em></p><h1 id="96d3" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤2:创建webhook服务</h1><p id="3a35" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">在此步骤中，您将创建webhook服务，该服务将侦听来自Webhook令牌身份验证插件的令牌验证请求，并通过查询LDAP目录来验证令牌:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nr"><img src="../Images/08dc377ce38a13521ec97b2b280f9ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbguKVka9H8iN2_3gx284w.png"/></div></div></figure><p id="0087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要实现这个服务，你需要知道Webhook令牌认证插件是如何工作的，所以让我们从一些解释开始。</p><h2 id="3173" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">了解Webhook令牌认证插件</h2><p id="3238" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌</a>认证插件要求Kubernetes API请求包含一个<a class="ae ko" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> HTTP承载令牌</strong> </a>。HTTP承载令牌在HTTP请求的<code class="fe ob oc od nt b">Authorization</code>报头中设置如下:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="00ae" class="ne kx it nt b gy nx ny l nz oa">Authorization: Bearer &lt;TOKEN&gt;</span></pre><p id="4ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当Webhook令牌身份验证插件收到这样的请求时，它会从标头中提取令牌，并以JSON格式将其包装在一个<em class="ks"> TokenReview </em>对象中。</p><p id="a1d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JSON格式的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#tokenreview-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> TokenReview </strong> </a>对象如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="38dc" class="ne kx it nt b gy nx ny l nz oa">{<br/>  "apiVersion": "authentication.k8s.io/v1",<br/>  "kind": "TokenReview",<br/>  "spec": {<br/>    "token": "&lt;TOKEN&gt;"<br/>  }<br/>}</span></pre><p id="9c3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，Webhook令牌认证插件将TokenReview对象作为一个<strong class="js iu"> HTTPS邮报</strong>请求提交给webhook服务。</p><blockquote class="kp kq kr"><p id="4a5e" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">TokenReview对象是Webhook令牌身份验证插件和webhook服务之间的“通用语言”。</p></blockquote><p id="7f4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">webhook服务接收TokenReview对象并从中提取令牌。它的任务是验证这个令牌的有效性。如何完成这种验证完全取决于webhook服务，并且取决于实现的身份验证方法。</p><p id="962e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在令牌被验证之后，webhook服务设置TokenReview对象的<em class="ks">状态</em>字段，并在对初始请求的响应中将其返回给Webhook令牌认证插件。</p><p id="814b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TokenReview对象的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#tokenreviewstatus-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">状态</strong> </a>字段包含两个重要字段:</p><ul class=""><li id="62c5" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><code class="fe ob oc od nt b">authenticated</code>:表示令牌是否有效的布尔值。</li><li id="8843" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe ob oc od nt b">user</code>:仅当令牌有效且包含一个<em class="ks"> UserInfo </em>对象时设置。</li></ul><p id="5e69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#userinfo-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> UserInfo </strong> </a>对象包含一组关于发出请求的用户的识别信息，包括用户名和任何组成员资格(该信息将在API服务器的授权阶段使用，以检查用户是否有权执行所请求的操作)。如何确定用户信息完全取决于webhook服务。</p><p id="a8eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Webhook令牌</strong> </a>认证插件收到Webhook服务的响应时，它根据返回的TokenReview对象的Status字段中的信息处理请求。也就是说，如果令牌有效，它就接受请求，如果令牌无效，它就拒绝请求。</p><p id="f77a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">唷，这听起来很拗口——但要点是webhook服务监听来自Webhook令牌认证插件的令牌审查请求，然后验证包含的令牌。</em></p><p id="6b44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然您已经知道了Webhook令牌认证插件是如何工作的，下一步就是实现一个合适的webhook服务。</p><h2 id="0127" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">实现webhook服务</h2><p id="9253" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">您的目标是用形式为<code class="fe ob oc od nt b">username:password</code>的令牌实现LDAP认证。因此，简而言之，您的webhook服务必须检查令牌的<code class="fe ob oc od nt b">username</code>和<code class="fe ob oc od nt b">password</code>部分是否对应于LDAP目录中的实际用户。如果是，令牌有效，否则无效。</p><p id="88bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将在Go中实现这个webhook服务(您马上就会明白为什么使用Go来完成这个任务是有意义的)。</p><p id="87ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先为webhook服务的源代码创建一个新目录:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="e198" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ mkdir k8s-ldap-authentication<br/>$ cd k8s-ldap-authentication</strong></span></pre><p id="780e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，安装您的实施所需的以下Go软件包:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="80dc" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ go get github.com/go-ldap/ldap<br/>$ go get k8s.io/api/authentication/v1</strong></span></pre><p id="d3e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面你可以找到webhook服务的完整源代码。继续并将它保存在上面创建的目录中的一个名为<code class="fe ob oc od nt b">main.go</code>的文件中:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="oe of l"/></div></figure><blockquote class="kp kq kr"><p id="325b" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">你也可以在GitHub上的<a class="ae ko" href="https://github.com/weibeld/k8s-ldap-authentication" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Wei bel/k8s-LDAP-authentic ation</strong></a>中找到这个代码。</p></blockquote><p id="537d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们简单地浏览一下这个源代码。</p><p id="7643" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实施包括三个核心功能:</p><ul class=""><li id="92fe" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><code class="fe ob oc od nt b"><strong class="js iu">main</strong></code>:创建一个HTTPS服务器。</li><li id="f555" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe ob oc od nt b"><strong class="js iu">handler</strong></code>:处理HTTPS请求。</li><li id="a111" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe ob oc od nt b"><strong class="js iu">ldapSearch</strong></code>:执行LDAP查询。</li></ul><p id="e226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面解释了这些功能。</p><p id="6ad0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ob oc od nt b"><strong class="js iu">main</strong></code>功能建立一个HTTPS服务器。此HTTPS服务器侦听来自Webhook令牌身份验证插件的令牌查看请求。HTTPS服务器使用<code class="fe ob oc od nt b">handler</code>函数来处理这些请求。</p><p id="0b31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ob oc od nt b"><strong class="js iu">handler</strong></code>函数处理HTTPS服务器收到的请求。所有这些请求都应该是TokenReview请求，即主体中带有TokenReview对象的HTTPS POST请求。<code class="fe ob oc od nt b">handler</code>功能执行以下步骤:</p><ol class=""><li id="d052" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn nq mc md me bi translated">提取POST请求的主体，它应该是JSON格式的TokenReview对象。</li><li id="f19f" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">将TokenReview JSON对象解码为内部TokenReview对象表示。</li><li id="31b2" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">将TokenReview对象中包含的令牌解析为其<code class="fe ob oc od nt b">username</code>和<code class="fe ob oc od nt b">password</code>部分。</li><li id="8950" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">向LDAP目录发出请求，检查提取的<code class="fe ob oc od nt b">username</code>和<code class="fe ob oc od nt b">password</code>是否有效。该请求尝试使用给定的<code class="fe ob oc od nt b">username</code>和<code class="fe ob oc od nt b">password</code>从LDAP目录中检索用户条目。如果成功，这意味着凭证是正确的，因此令牌是有效的。</li><li id="1c04" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">根据令牌是否有效设置TokenReview对象的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#tokenreviewstatus-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank">状态</a>字段。如果令牌有效，则<code class="fe ob oc od nt b">authenticated</code>字段被设置为<code class="fe ob oc od nt b">true</code>，而<code class="fe ob oc od nt b">user</code>字段被设置为一个<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#userinfo-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> UserInfo </a>对象，该对象是根据上一步中检索到的用户条目构建的。</li><li id="b54e" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">将TokenReview对象编码回JSON，并将其包含在对Webhook令牌身份验证插件的响应中。</li></ol><p id="5b6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ob oc od nt b"><strong class="js iu">ldapSearch</strong></code>函数实现LDAP目录请求，该请求在上面的<code class="fe ob oc od nt b">handler</code>函数的第四步中执行。<code class="fe ob oc od nt b">ldapSearch</code>功能执行以下步骤:</p><ol class=""><li id="2cd2" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn nq mc md me bi translated">建立到LDAP目录的连接。</li><li id="8a83" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">使用LDAP管理员用户凭据验证LDAP目录。</li><li id="7442" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">使用给定的<code class="fe ob oc od nt b">username</code>和<code class="fe ob oc od nt b">password</code>查询LDAP目录中的用户条目。这是一个<a class="ae ko" href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol#Search_and_Compare" rel="noopener ugc nofollow" target="_blank"> LDAP搜索</a>请求，它类似于您之前使用<code class="fe ob oc od nt b">ldapsearch</code>命令行工具执行的请求。</li><li id="256b" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">处理LDAP请求的响应。如果响应为空，则凭证无效，<code class="fe ob oc od nt b">ldapSearch</code>函数返回<code class="fe ob oc od nt b">nil</code>。如果响应非空，则凭证有效，并且<code class="fe ob oc od nt b">ldapSearch</code>函数返回一个由检索到的条目中的信息构造的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#userinfo-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> UserInfo </a>对象。</li></ol><p id="db80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">程序的参数作为<strong class="js iu">命令行参数</strong>传递。命令行参数的顺序是:</p><ol class=""><li id="bbc5" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn nq mc md me bi translated">LDAP目录的IP地址</li><li id="bce9" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">HTTPS服务器私钥</li><li id="cafc" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn nq mc md me bi translated">HTTPS服务器证书</li></ol><p id="02e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，webhook服务的命令行界面如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="90d5" class="ne kx it nt b gy nx ny l nz oa">main &lt;ip&gt; &lt;key&gt; &lt;cert&gt;</span></pre><blockquote class="kp kq kr"><p id="04cb" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><strong class="js iu">现在，对于上面的问题:为什么使用Go来实现这一点是有益的？</strong></p><p id="ae15" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">考虑一下包<code class="fe ob oc od nt b">k8s.io/api/authentication/v1</code>。这个包是直接从<a class="ae ko" href="https://github.com/kubernetes/api/blob/master/authentication/v1/types.go" rel="noopener ugc nofollow" target="_blank"> Kubernetes源代码</a>导入的(Kubernetes也是用Go写的)。该包包含代码中使用的TokenReview和UserInfo对象的类型定义。这意味着您不必自己定义这些类型，但是您可以重用Kubernetes源代码中的现有定义。这极大地简化了您的实现，并使其更加可靠，因为类型定义保证是正确的。</p><p id="7c34" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">合并部分Kubernetes源代码的能力使得Go成为实现Kubernetes相关应用程序的一个非常好的选择。</p></blockquote><h2 id="db33" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">部署webhook服务</h2><p id="74c9" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">既然已经实现了webhook服务，下一步就是部署它。对于本教程，您将把webhook服务部署到已经运行LDAP目录的同一个实例上。</p><p id="26a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从编译源代码开始，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="eb04" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ GOOS=linux GOARCH=amd64 go build main.go</strong></span></pre><blockquote class="kp kq kr"><p id="2f56" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">上面的命令<a class="ae ko" href="https://golangcookbook.com/chapters/running/cross-compiling/" rel="noopener ugc nofollow" target="_blank">交叉编译</a>AMD64 Linux机器的代码，该代码对应于您将部署它的VM实例的架构。</p></blockquote><p id="b75d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令创建了一个名为<code class="fe ob oc od nt b">main</code>的静态链接二进制文件。要部署此二进制文件，请将其上传到您现有的GCP虚拟机实例:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="7f24" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute scp main root@authn:~</strong></span></pre><p id="0736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，登录到实例:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="e866" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute ssh root@authn</strong></span></pre><p id="6dd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您需要创建一个HTTPS服务器私有密钥和证书，它们将作为命令行参数传递给webhook服务。您可以使用以下命令来完成此操作:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="0fcc" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ openssl req -x509 -newkey rsa:2048 -nodes \<br/>    -subj "/CN=localhost" \<br/>    -keyout key.pem \<br/>    -out cert.pem</strong></span></pre><blockquote class="kp kq kr"><p id="5e93" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">上面的命令创建了一个<a class="ae ko" href="https://en.wikipedia.org/wiki/Self-signed_certificate" rel="noopener ugc nofollow" target="_blank">自签名证书</a>。这对于本教程来说已经足够了，但是在现实世界中，您应该使用由证书颁发机构(CA)签名的证书。</p></blockquote><p id="f2b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令在实例的当前工作目录中创建了两个名为<code class="fe ob oc od nt b">key.pem</code>和<code class="fe ob oc od nt b">cert.pem</code>的文件，它们分别对应于HTTPS服务器的私钥和证书。</p><p id="564d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您已经为启动webhook服务做好了一切准备。您可以使用以下命令来完成此操作:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="cbb8" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ ./main localhost key.pem cert.pem \<br/>    &amp;&gt;/var/log/k8s-ldap-authentication.log &amp;</strong></span></pre><p id="7644" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意该命令的以下内容:</p><ul class=""><li id="f6aa" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated">第一个命令行参数(LDAP目录的IP地址)被设置为<code class="fe ob oc od nt b">localhost</code>，因为LDAP目录与webhook服务运行在同一个主机上。</li><li id="2120" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">第二个和第三个命令行参数被设置为您刚刚在上面创建的私钥和证书文件。</li><li id="c41f" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">所有输出都被重定向到日志文件。</li><li id="e0c8" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">webhook服务作为后台进程执行，因此您可以从实例中注销，而无需停止webhook服务。</li></ul><p id="764a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的webhook服务现在已经启动并正在运行，因此您可以从实例中注销:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="d72d" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ exit</strong></span></pre><p id="393f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是测试你的webhook服务是否像预期的那样工作。</p><h2 id="d807" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">测试webhook服务</h2><p id="a4ff" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">为了测试您的webhook服务，您将从本地计算机执行一些TokenReview请求。这模拟了webhook服务在生产中从Kubernetes API服务器中的Webhook令牌身份验证插件接收的请求。</p><p id="7425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在名为<code class="fe ob oc od nt b">tr.json</code>的文件中保存以下<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#tokenreview-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> TokenReview </a>对象:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="7fb6" class="ne kx it nt b gy nx ny l nz oa">{<br/>  "apiVersion": "authentication.k8s.io/v1",<br/>  "kind": "TokenReview",<br/>  "spec": {<br/>    "token": "alice:alicepassword"<br/>  }<br/>}</span></pre><p id="c1ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的TokenReview对象包含令牌<code class="fe ob oc od nt b">alice:alicepassword</code>。请注意，这包括您在本教程的<a class="ae ko" href="#6c69" rel="noopener ugc nofollow">步骤1 </a>中保存在LDAP目录中的Alice用户条目的用户名和密码。</p><p id="8075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着，<code class="fe ob oc od nt b">alice:alicepassword</code>是一个有效的令牌，webhook服务应该成功验证它！</p><p id="b1bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要测试它，请执行以下请求:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="ce7e" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ curl -k -X POST -d @tr.json https://"$AUTHN_EXTERNAL_IP"</strong></span></pre><blockquote class="kp kq kr"><p id="b9b5" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">上述命令使用主体数据中的TokenReview对象对webhook服务执行HTTPS POST请求。</p></blockquote><p id="a4cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">响应应该是一个JSON对象，打印出来应该是这样的:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c107" class="ne kx it nt b gy nx ny l nz oa">{<br/>  "kind": "TokenReview",<br/>  "apiVersion": "authentication.k8s.io/v1beta1",<br/>  "metadata": {<br/>    "creationTimestamp": null<br/>  },<br/>  "spec": {<br/>    "token": "alice:alicepassword"<br/>  },<br/>  <strong class="nt iu">"status": {<br/>    "authenticated": true,<br/>    "user": {<br/>      "username": "alice",<br/>      "uid": "alice",<br/>      "groups": [<br/>        "dev"<br/>      ]<br/>    }<br/>  }</strong><br/>}</span></pre><blockquote class="kp kq kr"><p id="f7a2" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">您可以通过将输出管道化到<a class="ae ko" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"/><code class="fe ob oc od nt b"><a class="ae ko" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">jq</a></code><a class="ae ko" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">工具</a>来美化JSON响应，如下所示:<code class="fe ob oc od nt b">curl ... | jq</code>。</p></blockquote><p id="b3aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答对了，这是您提交的同一个TokenReview对象，带有一个附加的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#tokenreviewstatus-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank">状态</a>字段。在这个状态字段中，<code class="fe ob oc od nt b">authenticated</code>字段被设置为<code class="fe ob oc od nt b">true</code>，而<code class="fe ob oc od nt b">user</code>字段被设置为一个<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#userinfo-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank"> UserInfo </a>对象，该对象包含一些关于Alice的用户信息，比如她的用户名和组成员。</p><p id="68cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着，您的webhook服务成功验证了令牌！</p><p id="7110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">让我们也测试提交无效令牌的相反情况。</em></p><p id="01f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">修改<code class="fe ob oc od nt b">tr.json</code>文件中的TokenReview对象，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="04d4" class="ne kx it nt b gy nx ny l nz oa">{<br/>  "apiVersion": "authentication.k8s.io/v1",<br/>  "kind": "TokenReview",<br/>  "spec": {<br/><strong class="nt iu">    "token": "alice:WRONGalicepassword"<br/></strong>  }<br/>}</span></pre><p id="beea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">令牌的密码部分现在不包含爱丽丝的真实密码，这意味着它不是一个有效的令牌。</p><p id="f4a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，webhook服务应该认为这个令牌是无效的。</p><p id="9fa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要测试它，请提出以下请求:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c3b4" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ curl -k -X POST -d @tr.json https://"$AUTHN_EXTERNAL_IP"</strong></span></pre><p id="c86f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JSON响应现在应该是这样的:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="a219" class="ne kx it nt b gy nx ny l nz oa">{<br/>  "kind": "TokenReview",<br/>  "apiVersion": "authentication.k8s.io/v1",<br/>  "metadata": {<br/>    "creationTimestamp": null<br/>  },<br/>  "spec": {<br/>    "token": "alice:WRONGalicepassword"<br/>  },<br/>  <strong class="nt iu">"status": {<br/>    "user": {}<br/>  }</strong><br/>}</span></pre><p id="dcba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，响应由您提交的相同TokenReview对象组成，并添加了一个<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#tokenreviewstatus-v1-authentication-k8s-io" rel="noopener ugc nofollow" target="_blank">状态</a>字段。但是，这一次状态字段为空。特别是，没有设置<code class="fe ob oc od nt b">authenticated</code>字段。</p><p id="b5c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着webhook服务判定令牌无效！</p><blockquote class="kp kq kr"><p id="bad3" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">在Go中，布尔值的默认值是<code class="fe ob oc od nt b">false</code>。因此，如果<code class="fe ob oc od nt b">authenticated</code>字段丢失，Kubernetes会以同样的方式解释它，就好像它被显式设置为<code class="fe ob oc od nt b">false</code>。</p></blockquote><p id="c1d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，您已经实现并部署了一个webhook服务，并测试了它是否正常工作。</p><p id="ec0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">本教程的第2步到此结束。</em></p><h1 id="a94a" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤3:创建Kubernetes集群</h1><p id="2f41" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">在这一步中，您将创建Kubernetes集群，该集群将向用户提供LDAP身份验证:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nr"><img src="../Images/e2ef5d9f02e823ea382a5e03069a7166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFpUTOxMEv5XmC-7PpJd3Q.png"/></div></div></figure><p id="b0e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将在GCP基础设施上使用<a class="ae ko" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>创建这个集群。在本教程中，您将只创建一个单节点集群，即只包含一个节点的集群。因此，该节点将同时充当主节点和工作节点。这允许您使用更少的GCP资源(从而节省资金)。</p><blockquote class="kp kq kr"><p id="6dcc" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">在实际场景中，您很少使用单节点集群。然而，对于本教程来说，这已经足够了，因为重点是配置Webhook令牌认证插件。无论群集中有多少个节点，此过程都是相同的。</p></blockquote><h2 id="075d" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">准备基础设施</h2><p id="caf3" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">首先，为您的单节点集群创建一个新的GCP虚拟机实例:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="0970" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute instances create k8s \<br/>    --subnet k8s-authn-subnet \<br/>    --machine-type e2-medium \<br/>    --image-family ubuntu-1804-lts \<br/>    --image-project ubuntu-os-cloud</strong></span></pre><p id="b465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将此实例的外部IP地址保存在一个环境变量中(因为您以后会需要它):</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="0aae" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ K8S_EXTERNAL_IP=$(gcloud compute instances describe k8s \<br/>    --format='value(networkInterfaces[0].accessConfigs[0].natIP)')</strong></span></pre><p id="8637" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，登录到实例:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="95a9" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute ssh root@k8s</strong></span></pre><p id="7d0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为您将使用<a class="ae ko" href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" rel="noopener ugc nofollow" target="_blank"> kubeadm </a>创建这个集群，所以您必须在实例上安装kubeadm和Docker。您可以通过直接在实例上执行以下命令集来实现这一点:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="a06b" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">{</strong><em class="ks"><br/>  # Register Kubernetes package repository</em><strong class="nt iu"><br/>  apt-get update<br/>  apt-get install -y apt-transport-https curl<br/>  curl </strong><a class="ae ko" href="https://packages.cloud.google.com/apt/doc/apt-key.gpg" rel="noopener ugc nofollow" target="_blank"><strong class="nt iu">https://packages.cloud.google.com/apt/doc/apt-key.gpg</strong></a><strong class="nt iu"> |<br/>    apt-key add -<br/>  echo "deb </strong><a class="ae ko" href="https://apt.kubernetes.io/" rel="noopener ugc nofollow" target="_blank"><strong class="nt iu">https://apt.kubernetes.io/</strong></a><strong class="nt iu"> kubernetes-xenial main" \<br/>    &gt;/etc/apt/sources.list.d/kubernetes.list<br/>  </strong><em class="ks"># Install kubeadm and Docker</em><strong class="nt iu"><br/>  apt-get update<br/>  apt-get install -y docker.io kubeadm<br/>}</strong></span></pre><p id="3f15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装完成后，您可以再次从实例中注销:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c771" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ exit </strong></span></pre><p id="5ae1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">您的基础设施现在已经可以安装Kubernetes了。</em></p><h2 id="9d4d" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">创建配置文件</h2><p id="ff50" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">理论上，您可以立即开始安装Kubernetes。但是您不希望仅仅创建一个普通的集群，而是要创建一个使用自定义LDAP身份验证方法的集群。为此，您首先需要创建一些配置。</p><p id="2df0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别是，您需要创建以下两个配置文件:</p><ul class=""><li id="9cfa" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><strong class="js iu"> Webhook令牌配置文件:</strong>这是Webhook令牌认证插件的配置文件。其中包含了webhook服务的URL。这个配置文件必须被传递给<a class="ae ko" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> kube-apiserver </a>二进制文件的<code class="fe ob oc od nt b">--authentication-token-webhook-config-file</code>标志。其格式在<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a>中定义。</li><li id="ecc1" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu"> kubeadm配置文件:</strong>这是一个用于kubeadm的<a class="ae ko" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file" rel="noopener ugc nofollow" target="_blank">配置文件</a>。在您的例子中，它将包含kubeadm在kube-apiserver二进制文件上设置<code class="fe ob oc od nt b">--authentication-token-webhook-config-file</code>标志的指令。kubeadm配置文件被传递给<code class="fe ob oc od nt b"><a class="ae ko" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/" rel="noopener ugc nofollow" target="_blank">kubeadm init</a></code>命令的<code class="fe ob oc od nt b">--config</code>标志。</li></ul><p id="f949" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将在本地计算机上创建这两个配置文件，然后将它们上传到实例。</p><p id="644c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ks">让我们从Webhook令牌配置文件开始。</em>T19】</strong></p><p id="f1c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令在本地机器上创建<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌配置文件</a>:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="1a2d" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ cat &lt;&lt;EOF &gt;webhook-config.yaml<br/></strong>apiVersion: v1<br/>kind: Config<br/>clusters:<br/>  - name: authn<br/>    cluster:<br/>      server: https://$AUTHN_INTERNAL_IP<br/>      insecure-skip-tls-verify: true<br/>users:<br/>  - name: kube-apiserver<br/>contexts:<br/>- context:<br/>    cluster: authn<br/>    user: kube-apiserver<br/>  name: authn<br/>current-context: authn<strong class="nt iu"><br/>EOF</strong></span></pre><p id="248d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该配置文件中的<code class="fe ob oc od nt b">server</code>字段包含webhook服务的URL(<code class="fe ob oc od nt b">https://$AUTHN_INTERNAL_IP</code>)。这就是Webhook令牌身份验证插件知道将令牌查看请求发送到哪里的方式。</p><blockquote class="kp kq kr"><p id="6940" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">webhook服务URL使用相应GCP虚拟机实例的内部IP地址。这是因为Kubernetes集群和webhook服务运行在同一个GCP VPC网络中。在这种情况下，实例必须使用它们的内部IP地址相互通信。</p></blockquote><p id="5365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述配置文件中的<code class="fe ob oc od nt b">insecure-skip-tls-verify</code>字段禁止webhook令牌认证插件验证Webhook服务的HTTPS服务器证书。这是必要的，因为您的webhook服务使用自签名证书(如前所述，在现实场景中，您应该使用正确签名的证书，因此不应该设置<code class="fe ob oc od nt b">insecure-skip-tls-verify</code>字段)。</p><p id="47ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Webhook令牌配置文件中的其他字段没有任何内在含义，主要是为了满足配置文件格式的要求(该格式也用于<a class="ae ko" href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" rel="noopener ugc nofollow" target="_blank"> kubeconfig </a>文件)。</p><p id="49d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在可以将Webhook令牌配置文件上传到单节点Kubernetes集群的实例，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="9619" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute scp webhook-config.yaml root@k8s:/root</strong></span></pre><p id="e527" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ks">接下来，我们来处理kubeadm配置文件。</em>T12】</strong></p><p id="5f75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令在本地机器上创建<a class="ae ko" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file" rel="noopener ugc nofollow" target="_blank"> kubeadm配置文件</a>:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="9ebe" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ cat &lt;&lt;EOF &gt;kubeadm-config.yaml</strong><br/>apiVersion: kubeadm.k8s.io/v1beta2<br/>kind: ClusterConfiguration<br/>apiServer:<br/>  extraVolumes:<br/>    - name: authentication-token-webhook-config-file<br/>      mountPath: /etc/webhook-config.yaml<br/>      hostPath: /root/webhook-config.yaml<br/>  extraArgs:<br/>    authentication-token-webhook-config-file: /etc/webhook-config.yaml<br/>  certSANs:<br/>    - $K8S_EXTERNAL_IP<br/><strong class="nt iu">EOF</strong></span></pre><p id="808a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上是类型为<a class="ae ko" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2?tab=doc#ClusterConfiguration" rel="noopener ugc nofollow" target="_blank"> ClusterConfiguration </a>的kubeadm配置文件。它包含一个<code class="fe ob oc od nt b"><a class="ae ko" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2?tab=doc#APIServer" rel="noopener ugc nofollow" target="_blank">apiServer</a></code>字段，允许为Kubernetes API服务器定义自定义设置。</p><p id="3702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述配置中的<code class="fe ob oc od nt b">apiServer</code>字段包含三个子字段:<code class="fe ob oc od nt b">extraVolumes</code>、<code class="fe ob oc od nt b">extraArgs</code>和<code class="fe ob oc od nt b">certSANs</code>。让我们简要讨论一下其中每一项的含义:</p><ul class=""><li id="d4a8" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><code class="fe ob oc od nt b"><a class="ae ko" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2?tab=doc#ControlPlaneComponent" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">extraVolumes</strong></a></code> <strong class="js iu"> : </strong>该字段定义API服务器Pod中的自定义<a class="ae ko" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes卷</a>(kube ADM启动Kubernetes控制平面组件作为Pod)。这个卷将Webhook令牌配置文件(您刚刚上传到GCP虚拟机实例上的<code class="fe ob oc od nt b">/root/webhook-config.yaml</code>)挂载为Pod中的<code class="fe ob oc od nt b">/etc/webhook-config.yaml</code>。这意味着Webhook令牌配置文件将位于API服务器Pod中的<code class="fe ob oc od nt b">/etc/webhook-config.yaml</code>。</li><li id="b546" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe ob oc od nt b"><a class="ae ko" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2?tab=doc#ControlPlaneComponent" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">extraArgs</strong></a></code> <strong class="js iu"> : </strong>该字段允许为<a class="ae ko" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> kube-apiserver </a>二进制文件定义额外的命令行标志。上面的配置定义了值为<code class="fe ob oc od nt b">/etc/webhook-config.yaml</code>的<code class="fe ob oc od nt b">--authentication-token-webhook-config-file</code>标志，它是Webhook令牌配置文件(作为一个卷安装在那里)。此标志启用API服务器中的Webhook令牌身份验证插件，并根据指定的Webhook令牌配置文件进行设置。</li><li id="9fa5" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe ob oc od nt b"><a class="ae ko" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2?tab=doc#APIServer" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">certSANs</strong></a></code> <strong class="js iu"> : </strong>该字段允许为API服务器证书定义额外的主题替换名称(San)。上述配置将GCP虚拟机实例的外部IP地址定义为附加s an。这对于从GCP VPC网络外部(例如从您的本地机器)访问集群是必要的。原因是，在这些情况下，您必须使用运行API服务器的GCP虚拟机实例的外部IP地址(而不是其内部IP地址，默认情况下，它作为SAN包含在证书中)。否则，在本地机器上验证API服务器证书将会失败。</li></ul><p id="9260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，将kubeadm配置文件上传到实例，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="f6ba" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute scp kubeadm-config.yaml root@k8s:~</strong></span></pre><p id="7dc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">现在所有的配置都已就绪，您已经准备好创建集群了！</em></p><h2 id="2dba" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">创建集群</h2><p id="13c3" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">在下面的内容中，您将创建Kubernetes集群，对其应用一些基本设置，并使其可以从您的本地机器上访问。</p><p id="b7f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先登录到实例:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="97f5" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute ssh root@k8s</strong></span></pre><p id="5054" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，使用<code class="fe ob oc od nt b"><a class="ae ko" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/" rel="noopener ugc nofollow" target="_blank">kubeadm init</a></code>命令和刚才创建的kubeadm配置文件安装Kubernetes，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="98f9" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubeadm init --config kubeadm-config.yaml</strong></span></pre><p id="879f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个命令完成后，您的单节点Kubernetes集群就启动并运行了。在实例上的<code class="fe ob oc od nt b">/etc/kubernetes/admin.conf</code>处还有一个<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/" rel="noopener ugc nofollow" target="_blank"> kubeconfig文件</a>(包含一个管理员用户的凭证)，您可以使用它从实例访问带有kubectl的集群。</p><p id="d6ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，当您的集群运行时，它还没有完全发挥作用。要使您的集群可用，您必须执行以下附加步骤:</p><ul class=""><li id="e463" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated"><strong class="js iu">解开主节点</strong></li><li id="0eee" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><strong class="js iu">安装CNI插件</strong></li></ul><p id="5d6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，Kubernetes集群的主节点有一个<a class="ae ko" href="http://w" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">污点</strong> </a>，它阻止将工作负载pod调度给它们。但是，由于您有一个单节点集群，主节点同时也是一个工作节点，因此工作负载单元必须在其上运行。因此，从主节点中删除相应的污点，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="e4ac" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig /etc/kubernetes/admin.conf \<br/>    taint node k8s node-role.kubernetes.io/master:NoSchedule-</strong></span></pre><p id="7ef2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，用kubeadm创建的集群没有默认安装的<a class="ae ko" href="https://github.com/containernetworking/cni" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> CNI插件</strong> </a>。如果没有CNI插件，你的集群的节点就是<code class="fe ob oc od nt b">NotReady</code>，新的Pods不能被调度并且停留在<code class="fe ob oc od nt b">Pending</code>状态。您可以在集群中安装<a class="ae ko" href="http://of" rel="noopener ugc nofollow" target="_blank">纤毛CNI插件</a>，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c7b1" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl apply --kubeconfig /etc/kubernetes/admin.conf \<br/>-f https://raw.githubusercontent.com/cilium/cilium/1.7.0/install/kubernetes/quick-install.yaml</strong></span></pre><p id="e8ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的群集现在完全正常，您可以从实例中注销:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="25c1" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ exit</strong></span></pre><p id="3e0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是让您的集群<strong class="js iu">可以从您的本地机器</strong>访问。为此，将kubeadm从实例创建的kubeconfig文件下载到本地机器:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="b0d9" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ gcloud compute scp root@k8s:/etc/kubernetes/admin.conf .</strong></span></pre><p id="379c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要对这个kubeconfig文件做一点修改，使它在您的本地机器上可用:这个kubeconfig文件中的API服务器URL包含运行您的集群的GCP VM实例的<em class="ks">内部</em> IP地址。但是，这个IP地址不能从您的本地机器访问，您需要用实例的<em class="ks">外部</em> IP地址来替换它。您可以使用以下命令来完成此操作:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="198b" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf \<br/>    config set-cluster kubernetes \<br/>    --server https://"$K8S_EXTERNAL_IP":6443</strong></span></pre><p id="c84b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以使用这个kubeconfig文件从本地机器访问集群。例如:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="66e9" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf get nodes</strong></span></pre><blockquote class="kp kq kr"><p id="ed9f" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">请注意，到目前为止，您发出的所有Kubernetes请求都使用了<code class="fe ob oc od nt b">admin.conf</code> kubeconfig文件中的管理员凭证。这些凭证由一个客户端证书和私钥组成，这意味着相应的请求由<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs" rel="noopener ugc nofollow" target="_blank"> X.509客户端证书</a>身份验证插件(kubeadm默认启用)处理。这意味着，您还没有触发<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌</a>认证插件和LDAP认证方法。</p></blockquote><p id="b2db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，您已经设置好了系统的所有组件。唯一缺少的是测试您的定制LDAP身份验证方法是否按预期工作。</p><p id="b084" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">您将在接下来的练习中完成。</em></p><h1 id="15eb" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">步骤4:测试LDAP身份验证</h1><p id="2ccb" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">在最后一步中，您将测试您的定制Kubernetes LDAP身份验证方法是否按预期工作。以下是您的系统目前的情况:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nr"><img src="../Images/403db640f4fe2ddffe9a484cfa57bd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNreAMwIeLkWUcBE5zRaiw.png"/></div></div></figure><p id="6c04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们概括一下您在本教程中创建的内容:</p><ul class=""><li id="66bb" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated">Kubernetes集群使用Webhook令牌身份验证插件提供LDAP身份验证。</li><li id="b098" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">webhook服务侦听来自Kubernetes群集中的Webhook令牌身份验证插件的TokenReview请求。</li><li id="0629" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">一个LDAP目录，包含爱丽丝的用户条目(用户名<code class="fe ob oc od nt b">alice</code>和密码<code class="fe ob oc od nt b">alicepassword</code>)。</li></ul><p id="79e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的LDAP身份验证方法按预期工作，那么Alice现在应该能够通过在她的请求中包含HTTP承载令牌<code class="fe ob oc od nt b">alice:alicepassword</code>来访问Kubernetes集群。</p><p id="3dfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看这是否可行！</p><h2 id="8b39" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">测试访问</h2><p id="56c1" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">要轻松地在Kubernetes请求中包含HTTP承载令牌，您可以将带有该令牌的用户条目添加到kubeconfig文件中。要将带有令牌<code class="fe ob oc od nt b">alice:alicepassword</code>的Alice的用户条目添加到kubeconfig文件中，请执行以下命令:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="c4c6" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf \<br/>    config set-credentials alice --token alice:alicepassword</strong></span></pre><p id="d5e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，每当您为带有<code class="fe ob oc od nt b">--user alice</code>标志的kubectl命令选择这个用户条目时，kubectl将自动在请求中包含<code class="fe ob oc od nt b">alice:alicepassword</code>作为HTTP承载令牌(而不是默认使用的kubeconfig文件中admin用户条目的密钥和证书)。</p><p id="d6ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请求中出现这个HTTP承载令牌将导致请求被Webhook令牌身份验证插件处理，这意味着您的定制LDAP身份验证方法将被执行。</p><p id="4578" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们面对现实，用爱丽丝的令牌提出一个请求:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="9d6a" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf --user alice get nodes</strong></span></pre><p id="f70b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出应该是:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="8e24" class="ne kx it nt b gy nx ny l nz oa">Error from server (Forbidden): nodes is forbidden: User "alice" cannot list resource "nodes" in API group "" at the cluster scope</span></pre><p id="5160" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">哎呀...！</strong></p><p id="dfe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是否意味着您的自定义身份验证方法不起作用？😰</p><p id="0064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不，别担心！您刚刚陷入了99%开始尝试Kubernetes身份验证的人都会陷入的陷阱。</p><p id="2d56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">此错误与身份验证无关。</strong></p><p id="9f5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是经过授权。</p><p id="35f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请求正确地通过了认证阶段，但是随后被授权阶段拒绝。事情是这样的:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi og"><img src="../Images/fc9610b8d93ab054e0a46ef3dcd1e374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVNRGf1so2urfUjDurg2yg.png"/></div></div></figure><blockquote class="kp kq kr"><p id="3d89" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">您可以通过将kubectl命令的详细程度增加到<code class="fe ob oc od nt b">-v 4</code>来确认响应代码是<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> 403禁止</strong> </a>。如果请求在认证阶段被拒绝，状态代码将是<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> 401未授权</strong> </a>。</p></blockquote><p id="5a59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过错误消息中的指示器<code class="fe ob oc od nt b">Forbidden</code>看到请求成功通过了身份验证阶段，该指示器指示了一个<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403" rel="noopener ugc nofollow" target="_blank"> <em class="ks"> 403禁止</em> </a>状态代码(用于授权错误)，以及Alice ( <code class="fe ob oc od nt b">alice</code>)的用户名已被识别的事实(这是您保存在LDAP目录中的Alice的用户名，已经由您的webhook服务确定并返回到Kubernetes API服务器)。</p><p id="f374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">授权阶段拒绝请求的原因是用户<code class="fe ob oc od nt b">alice</code>没有权限执行<code class="fe ob oc od nt b"><a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#list-node-v1-core" rel="noopener ugc nofollow" target="_blank">list nodes</a></code>操作(默认情况下，用户没有权限在Kubernetes中执行<em class="ks">任何</em>操作)。您可以通过创建适当的<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#clusterrole-v1-rbac-authorization-k8s-io" rel="noopener ugc nofollow" target="_blank"> ClusterRole </a>和<a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#clusterrolebinding-v1-rbac-authorization-k8s-io" rel="noopener ugc nofollow" target="_blank"> ClusterRoleBinding </a>来授予Alice对<code class="fe ob oc od nt b"><a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#list-node-v1-core" rel="noopener ugc nofollow" target="_blank">list nodes</a></code>操作的权限，从而进行更改，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="18fd" class="ne kx it nt b gy nx ny l nz oa"><em class="ks"># Create ClusterRole<br/></em><strong class="nt iu">$ kubectl --kubeconfig admin.conf \<br/>    create clusterrole alice --resource nodes --verb list</strong><br/><em class="ks"># Create ClusterRoleBinding<br/></em><strong class="nt iu">$ kubectl --kubeconfig admin.conf \<br/>    create clusterrolebinding alice --clusterrole alice --user alice</strong></span></pre><blockquote class="kp kq kr"><p id="c4d9" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">请注意，以上请求是使用kubeconfig文件中admin用户的凭证发出的(没有使用<code class="fe ob oc od nt b">--user alice</code>标志)，该用户拥有执行以上操作的权限。</p></blockquote><p id="4fbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，用户<code class="fe ob oc od nt b">alice</code>拥有<code class="fe ob oc od nt b"><a class="ae ko" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#list-node-v1-core" rel="noopener ugc nofollow" target="_blank">list nodes</a></code>操作的权限，所以让我们再次执行同样的请求:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="45e1" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf --user alice get nodes</strong></span></pre><p id="7631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">宾果，现在请求成功了！</p><p id="49ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，Alice可以使用令牌<code class="fe ob oc od nt b">alice:alicepassword</code>访问集群！</p><p id="bc7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们概括一下刚刚发生的事情。</p><p id="a56c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在LDAP目录中保存了一个用户名为<code class="fe ob oc od nt b">alice</code>和密码为<code class="fe ob oc od nt b">alicepassword</code>的用户条目。当Alice用令牌<code class="fe ob oc od nt b">alice:alicepassword</code>向Kubernetes发出请求时，Webhook令牌认证插件将这个令牌提交给webhook服务进行验证。webhook服务查询LDAP目录以检查<code class="fe ob oc od nt b">alice</code>和<code class="fe ob oc od nt b">alicepassword</code>是否属于LDAP目录中的实际用户，并将响应返回给Webhook令牌认证插件。基于这些信息，Webhook令牌认证插件对请求进行认证。</p><p id="bd72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将授予Alice使用令牌<code class="fe ob oc od nt b">alice:alicepassword</code> <em class="ks">访问集群的权限，而无需您在Kubernetes本身</em>中配置该权限。保存该令牌信息的唯一位置是LDAP目录。</p><p id="22e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，一切似乎都很顺利！但是让我们做另一个测试。</p><h2 id="343a" class="ne kx it bd ky nf ng dn lc nh ni dp lg kb nj nk lk kf nl nm lo kj nn no ls np bi translated">更改密码</h2><p id="d2b5" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">假设Alice想要更改保存在LDAP目录中的密码。这种情况下会发生什么？旧令牌是否仍然允许她访问群集？新令牌是什么？</p><p id="661e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来测试一下。要修改LDAP条目，您必须以<a class="ae ko" href="https://en.wikipedia.org/wiki/LDAP_Data_Interchange_Format" rel="noopener ugc nofollow" target="_blank"> LDIF格式</a>创建一个修改规范。要更改Alice的密码，请将以下规范保存在名为<code class="fe ob oc od nt b">modify.ldif</code>的文件中:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="4e0c" class="ne kx it nt b gy nx ny l nz oa">dn: cn=alice,dc=mycompany,dc=com<br/>changetype: modify<br/>replace: userPassword<br/>userPassword: newpassword</span></pre><blockquote class="kp kq kr"><p id="a2e0" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">上面的LDIF修改规范将Alice的用户条目中的密码更新为<code class="fe ob oc od nt b">newpassword</code>。</p></blockquote><p id="2b98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后使用以下命令在LDAP目录中应用更改:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="7a4b" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ ldapmodify -H ldap://"$AUTHN_EXTERNAL_IP" \<br/>    -x -D cn=admin,dc=mycompany,dc=com -w adminpassword \<br/>    -f modify.ldif</strong></span></pre><p id="b5de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">爱丽丝的密码现在已经改成了<code class="fe ob oc od nt b">newpassword</code>。直觉上，这将意味着旧令牌<code class="fe ob oc od nt b">alice:alicepassword</code>必须是无效的，而新的有效令牌必须是<code class="fe ob oc od nt b">alice:alicepassword</code>，对吗？我们来测试一下。</p><p id="7142" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先测试一下，如果Alice试图用旧令牌<code class="fe ob oc od nt b">alice:alicepassword</code>访问集群会发生什么。</p><p id="ef98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，提出以下请求(旧令牌<code class="fe ob oc od nt b">alice:alicepassword</code>仍然保存在kubeconfig文件中):</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="5130" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf --user alice get pods nodes</strong></span></pre><p id="f2f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出应该是:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="49fc" class="ne kx it nt b gy nx ny l nz oa">error: You must be logged in to the server (Unauthorized)</span></pre><p id="c684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">宾果，如你所料，请求被拒绝了。事情是这样的:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi og"><img src="../Images/81f8120a0d3411d4b6f387adb00a0de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGDQv9aN53MwZlElbRCk3g.png"/></div></div></figure><blockquote class="kp kq kr"><p id="e473" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">通过将kubectl命令的详细程度增加到<code class="fe ob oc od nt b"><em class="it">-v 4</em></code>，可以看到响应是<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> 401未授权</strong> </a>。401未授权状态码表示认证错误(而不是授权错误，顾名思义)。</p></blockquote><p id="09ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，请求在身份验证阶段被Webhook令牌身份验证插件拒绝(您可以通过指示器<code class="fe ob oc od nt b">Unauthorized</code>看到，它指示一个<em class="ks"> 401未授权</em>状态代码，并且在错误消息中没有用户名)。</p><p id="8083" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原因是您的webhook服务将<code class="fe ob oc od nt b">alice:alicepassword</code>视为无效令牌，因为LDAP目录中没有用户名为<code class="fe ob oc od nt b">alice</code>和密码为<code class="fe ob oc od nt b">alicepassword</code>的用户条目。</p><p id="fd61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这正是你所期望的！</p><p id="0877" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们测试如果Alice用新令牌<code class="fe ob oc od nt b">alice:newpassword</code>发出请求会发生什么。</p><p id="baf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以更改kubeconfig文件中Alice条目的令牌，如下所示:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="a9ec" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf \<br/>    config set-credentials alice --token alice:newpassword</strong></span></pre><p id="a299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从现在开始，当选择Alice的用户条目时，kubectl将在请求中使用新的令牌<code class="fe ob oc od nt b">alice:newpassword</code>。</p><p id="df48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，用这个新令牌发出请求:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="5f95" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">$ kubectl --kubeconfig admin.conf --user alice get nodes</strong></span></pre><p id="ee1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">宾果，现在请求成功了！</p><p id="dd60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，<code class="fe ob oc od nt b">alice:newpassword</code>是新的有效令牌，爱丽丝可以用它来访问集群。</p><p id="3611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们概括一下刚刚发生的事情。</p><p id="c9c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您在LDAP目录中更改了Alice的密码，这立即使Alice用来访问Kubernetes集群的旧令牌<code class="fe ob oc od nt b">alice:alicepassword</code>失效，并启动了新令牌<code class="fe ob oc od nt b">alice:newpassword</code> <em class="ks">。</em></p><p id="4f4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些都发生在你没有改变Kubernetes本身的情况下。您所做的唯一更改是在LDAP目录中，它完全独立于Kubernetes。</p><p id="8891" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ks">您成功验证了您的LDAP身份验证方法能够正常工作。恭喜你！</em> </strong></p><p id="b646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ks">教程到此结束。</em> </strong></p><p id="3cf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您愿意，可以继续试验您的集群。例如，您可以在LDAP目录中创建额外的用户，并在Kubernetes集群中授予他们不同的权限。</p><p id="f649" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，请确保清理所有GCP资源，您可以在下面找到相关说明。</p><h1 id="cb95" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">清理</h1><p id="b298" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">当您使用完集群和LDAP目录后，删除您为本教程创建的所有GCP资源是非常重要的。否则，你的下一张GCP账单上可能会有不必要的费用！</p><p id="5b71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用以下命令删除在本教程中创建的所有GCP资源:</p><pre class="mo mp mq mr gt ns nt nu nv aw nw bi"><span id="eff3" class="ne kx it nt b gy nx ny l nz oa"><strong class="nt iu">{<br/>  gcloud compute instances delete authn k8s<br/>  gcloud compute firewall-rules delete allow-internal-and-admin<br/>  gcloud compute networks subnets delete k8s-authn-subnet<br/>  gcloud compute networks delete k8s-authn-vpc<br/>}</strong></span></pre><h1 id="2bf4" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="d658" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">首先，祝贺你坚持到了最后！这是相当多的工作。您成功地为Kubernetes实现了定制的LDAP身份验证方法。你建立了一个由几个运动部件组成的系统:</p><ul class=""><li id="4998" class="lu lv it js b jt ju jx jy kb na kf nb kj nc kn mb mc md me bi translated">一个通用的LDAP目录，您可以在其中集中管理组织中所有用户的信息和凭证。</li><li id="fefc" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">一个<strong class="js iu"> webhook服务</strong>监听来自Kubernetes API服务器中webhook令牌认证插件的令牌验证请求。webhook服务通过查询LDAP目录来检查收到的令牌是否有效。</li><li id="5d24" class="lu lv it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated">一个<strong class="js iu"> Kubernetes集群</strong>，配置为使用Webhook令牌认证插件为其用户提供LDAP认证。</li></ul><p id="6e3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LDAP身份验证方法允许用户使用保存在LDAP目录中的凭证向Kubernetes进行身份验证。这意味着用户不需要一个单独的用户帐户。相反，他们可以重复使用他们可能也用于您组织中的其他应用程序和服务的相同凭据。</p><p id="bb9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这也意味着可以在一个地方管理所有用户的凭证。对凭证的任何更改都会立即在所有使用LDAP身份验证的应用程序和服务中生效(Kubernetes集群就是其中之一)。</p><p id="aee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文展示了如何使用<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" rel="noopener ugc nofollow" target="_blank"> Webhook令牌</a>身份验证插件为Kubernetes实现特定的LDAP身份验证方法。然而，LDAP身份验证只是您可以为Kubernetes实现的许多身份验证方法之一。您可以在webhook服务中放置任何您想要的逻辑，从而实现不同的认证方法(您可以用<a class="ae ko" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy" rel="noopener ugc nofollow" target="_blank">认证代理</a>认证插件做同样的事情)。</p><p id="f05a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于您选择实现的任何身份验证方法，设置webhook服务和配置Webhook令牌身份验证插件的基本机制都是相同的。本文向您展示了这些基本机制，您应该能够使用这些知识来实现您的用例所需的任何特定的身份验证方法。</p><p id="eae3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">快乐的Kubernetes工程！</em></p></div></div>    
</body>
</html>