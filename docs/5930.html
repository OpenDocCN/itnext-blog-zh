<html>
<head>
<title>Visual Guide to C# async/await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#异步/等待可视化指南</h1>
<blockquote>原文：<a href="https://itnext.io/visual-guide-to-csharp-async-await-bc85db77f36a?source=collection_archive---------0-----------------------#2021-07-04">https://itnext.io/visual-guide-to-csharp-async-await-bc85db77f36a?source=collection_archive---------0-----------------------#2021-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d10c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">C#中异步等待的可视化解释</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/93d365d475442d62286ee359f728f09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5AMh4HPJDHfMxeb324j8A.png"/></div></div></figure><p id="986c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">微软早在2011年就在C# 5.0中首次引入了<code class="fe ln lo lp lq b">async/await</code>模式。我认为这是对异步编程的最大贡献之一——在语言层面上——这导致了其他编程语言的跟进，比如Python和JavaScript等等。它使异步代码更具可读性，更像普通的同步代码。还记得C# 1.0中那些老派的<a class="ae lr" href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm" rel="noopener ugc nofollow" target="_blank"> <em class="ls">异步编程模型/APM </em> </a>中的<code class="fe ln lo lp lq b">BeginXxx</code> / <code class="fe ln lo lp lq b">EndXxx</code>吗？我仍然记得在2002年用Visual Studio写的那些。NET 2002。</p><div class="lt lu gp gr lv lw"><a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">异步编程模型(APM)</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">使用IAsyncResult设计模式的异步操作实现为两个名为…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">docs.microsoft.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div><p id="5348" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">足够前言。你还记得斯蒂芬·克利里著名的“<a class="ae lr" href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html" rel="noopener ugc nofollow" target="_blank">没有线索</a>”帖子吗？</p><div class="lt lu gp gr lv lw"><a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">没有线</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">这是async最纯粹的一个基本事实:没有线程。反对这一真理的人数不胜数…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">blog.stephencleary.com</p></div></div><div class="mf l"><div class="ml l mh mi mj mf mk kp lw"/></div></div></a></div><p id="436e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你是C#新手，去读一下吧。我会等的。或许，我应该说<code class="fe ln lo lp lq b">await ReadAsync()</code>？😆</p><p id="0381" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧，我很高兴你还在。这篇文章是我试图帮助C#开发者更好地理解async/await是怎么一回事。</p><h1 id="30e5" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">同步码</h1><p id="b776" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">先说同步版。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/046715948630aac0531e9a42d8b61de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*36pNjD8qAjiUhkyidq-Z7Q.gif"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">可视化:C#中普通的同步方法调用</figcaption></figure><p id="8e52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里没什么特别的。我想这非常简单明了。</p><h1 id="f02c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">异步代码</h1><p id="7cff" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">接下来，异步的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/187029f8935eae651b9e44b4ef25dd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JUlC43DA7pMGtaRt2Sg_eg.gif"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">可视化:C#中的异步方法调用</figcaption></figure><p id="cc8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们的异步厨师将<code class="fe ln lo lp lq b">await MethodAsync()</code>放入厨房，然后不等🍜(<code class="fe ln lo lp lq b">Task&lt;🍜&gt;</code>)做好准备。相比之下，我们的同步厨师将会在附近徘徊，也许永远在厨房里，等待🍜。</p><p id="8c56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的异步厨师离开厨房，回到他的<strong class="kt ir"> <em class="ls">家</em> </strong>(线程<strong class="kt ir"> <em class="ls">池</em> </strong>)，和他可爱的<strong class="kt ir"> <em class="ls">家人</em> </strong>(线程池<strong class="kt ir"> <em class="ls">线程</em> </strong>)一边等着门开着(假设<code class="fe ln lo lp lq b">ConfigureAwait(false)</code>；试图在此模拟“无<a class="ae lr" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" rel="noopener ugc nofollow" target="_blank">同步上下文</a>”。此时，我们处于所谓的“没有线程”状态。厨房里没有人。我们的🍜仍在微波炉中(正在进行的I/O操作)。<em class="ls">抱歉让你失望了，我亲爱的读者，是方便面</em>😂。</p><p id="f387" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦它被加热，我们超级智能的人工智能供电的警报形状的无人机(I/O完成端口-IOCP)就会飞到我们的厨师家通知他们。记住门是开着的(同样，没有<a class="ae lr" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" rel="noopener ugc nofollow" target="_blank">同步上下文</a>)，但是我们的厨师在厕所里🚽所以他请他的妻子——碰巧也是厨师——去继续他的工作。她继续她丈夫剩余的任务，从她丈夫停止的地方开始(继续<code class="fe ln lo lp lq b">AsyncStateMachine</code>)。其余同同步版。</p><h1 id="797f" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">使用Visual Studio可视化</h1><p id="e07e" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">动画gif是为了说明我们这个几乎真实的世界中的类比。让我们尝试使用Visual Studio将其可视化。</p><p id="ee55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用下面的代码，一个<a class="ae lr" href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-preview-4/#introducing-minimal-apis" rel="noopener ugc nofollow" target="_blank">最小API</a>，新的。NET 6。</p><div class="lt lu gp gr lv lw"><a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-preview-4/#introducing-minimal-apis" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">ASP。NET核心更新。NET 6预览版4</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">NET 6 Preview 4现已推出，它包含了许多对ASP.NET核心的重大改进。</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">devblogs.microsoft.com</p></div></div><div class="mf l"><div class="no l mh mi mj mf mk kp lw"/></div></div></a></div><pre class="kg kh ki kj gt np lq nq nr aw ns bi"><span id="7c45" class="nt mn iq lq b gy nu nv l nw nx">var builder = WebApplication.CreateBuilder(args);<br/>await using var app = builder.Build();</span><span id="73f2" class="nt mn iq lq b gy ny nv l nw nx">if (app.Environment.IsDevelopment())<br/>{<br/>  app.UseDeveloperExceptionPage();<br/>}</span><span id="bf4c" class="nt mn iq lq b gy ny nv l nw nx">app.MapGet("/sleep", (CancellationToken cancellationToken) =&gt;<br/>{<br/>  while (!cancellationToken.IsCancellationRequested)<br/>  {<br/>    Enumerable.Range(1, 100).Select(x =&gt; x).ToList().ForEach(x =&gt;<br/>    {<br/>      //WARNING: BAD CODE<br/>      Task.Run(() =&gt; Thread.Sleep(3 * 60 * 1_000), cancellationToken);<br/>    });<br/>    Thread.Sleep(2 * 60 * 1_000);<br/>  }<br/>  return "Done.";<br/>});</span><span id="aa22" class="nt mn iq lq b gy ny nv l nw nx">app.MapGet("/delay", async (CancellationToken cancellationToken) =&gt;<br/>{<br/>  while (!cancellationToken.IsCancellationRequested)<br/>  {<br/>    Enumerable.Range(1, 100).Select(x =&gt; x).ToList().ForEach(x =&gt;<br/>    {<br/>      //WARNING: BAD CODE<br/>      Task.Run(async () =&gt; await Task.Delay(3 * 60 * 1_000, cancellationToken), cancellationToken);<br/>    });<br/>    await Task.Delay(2 * 60 * 1_000, cancellationToken);<br/>  }<br/>  return "Done.";<br/>});</span><span id="8d92" class="nt mn iq lq b gy ny nv l nw nx">await app.RunAsync();</span></pre><h1 id="b7b3" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">同步码</h1><p id="94ea" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">首先，我们将检查同步版本。转到<em class="ls">https://localhost:5001/sleep</em>。使用<a class="ae lr" href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" rel="noopener ugc nofollow" target="_blank">过程浏览器</a>检查过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/565286998b4a0605dfbd76ff71e83c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f513CGWiuYjqzDPP_SwmvQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">使用流程浏览器检查</figcaption></figure><p id="19bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以看到我们正在启动<strong class="kt ir"> 100个线程</strong>。注意到滚动条了吗？我们有很多线索。</p><blockquote class="oa ob oc"><p id="d42a" class="kr ks ls kt b ku kv jr kw kx ky ju kz od lb lc ld oe lf lg lh of lj lk ll lm ij bi translated"><em class="iq">📝即使我们在呼叫<code class="fe ln lo lp lq b">Thread.Sleep</code>，这仍然是一种资源浪费。</em></p></blockquote><p id="b1b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们回到Visual Studio，使用<strong class="kt ir"> Break All </strong>来暂停应用程序的执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/bc60b6729912c67da16af8d226f75d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*GtN_HrYHeJE48E_RpzGvLg.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在Visual Studio中全部中断</figcaption></figure><blockquote class="oa ob oc"><p id="2ae1" class="kr ks ls kt b ku kv jr kw kx ky ju kz od lb lc ld oe lf lg lh of lj lk ll lm ij bi translated"><em class="iq">📝</em>你可以用<code class="fe ln lo lp lq b">Debugger.Break</code>来达到同样的效果。详情:<a class="ae lr" href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debugger.break" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/API/system . diagnostics . debugger . break</a></p></blockquote><p id="260d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看<strong class="kt ir">平行堆栈</strong>窗口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/a8558a8d7bc78b51dc8fc3401954bd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKDJa4Pxf9-G-MmLnLwMXg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">并行堆栈窗口</figcaption></figure><p id="eeb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大量休眠线程处于“阻塞”状态。这就像我们的同步厨师在厨房里什么也不做，除了等待🍜用微波炉加热。</p><p id="3f31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，将<strong class="kt ir">视图</strong>切换到<strong class="kt ir">线程</strong>视图，看看它看起来如何，按线程分组。几百根线！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/1e6592b5e0c933494a59d65c1b74b490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WRfuChV1IAaDgGf42rpPg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">按线程查看。</figcaption></figure><p id="6fca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看<strong class="kt ir">线程</strong>窗口。注意到滚动条了吗？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/2b5ea0c6aa7d5367bfdd775a15b28ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUajcQvatkDFqzZ4-srh5Q.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">线程窗口</figcaption></figure><h1 id="57d6" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">异步代码</h1><p id="c261" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">接下来，我们来看异步版本。转到<em class="ls">https://localhost:5001/delay</em>。使用<a class="ae lr" href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" rel="noopener ugc nofollow" target="_blank">过程浏览器</a>检查过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/1afecc1993c9f4ca36199f1fc42e43da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VoliFRL3PX6NEyRpHZokOQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">使用流程浏览器检查</figcaption></figure><p id="cbd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经开始了100个任务，但是没有滚动条！</p><p id="5e9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">返回Visual Studio，暂停应用程序执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/bc60b6729912c67da16af8d226f75d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*GtN_HrYHeJE48E_RpzGvLg.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">在Visual Studio中全部中断</figcaption></figure><p id="bb65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看<strong class="kt ir">平行堆栈</strong>窗口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/3fc8a227da3be5791e639b1eebd3a076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhgVpD6T9vJ8ss-wfohXPw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">平行堆栈窗口。一堆任务处于“预定”状态。</figcaption></figure><p id="ffdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">许多<em class="ls">任务</em>处于“已调度”状态；计划在未来被解雇。在<strong class="kt ir">螺纹</strong>栏中，可以看到<strong class="kt ir">没有螺纹信息，没有螺纹ID </strong>。</p><p id="8b8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你刚才是不是向上滚动查看同步版的截图了？欢迎回来！😆</p><p id="5a46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，将<strong class="kt ir">视图</strong>切换到<strong class="kt ir">线程</strong>视图，看看它是如何按线程分组的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/d20f737879fdc20664225dd6556fde00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8GVw2Dzsjs68_DwWqqhEg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">按线程查看。</figcaption></figure><p id="a005" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不到10个线程，大部分是框架线程。</p><p id="29c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看<strong class="kt ir">螺纹</strong>窗口。请注意，这里没有滚动条。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/f015a11d56ba87c5e2556762a682d096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ji0Yk4aOeclAJIXiusefGw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">线程窗口</figcaption></figure><p id="d25c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以没错，这里就有<strong class="kt ir">【无螺纹】</strong>。准确地说，没有用户代码线程。没有线，就没有厨师。就像我们的异步厨师，他不是在厨房里等待，而是回到他甜蜜的家。</p><p id="1474" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！</p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><p id="7cb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么这意味着什么呢？对于ASP.NET来说，这种"<strong class="kt ir">无线程"</strong>将转化为<strong class="kt ir">可伸缩性的提高</strong>，因为我们不会阻塞我们宝贵的线程池线程；阻塞可能会导致线程池饥饿。这里有个类比。我们只有五个厨师。他们现在都在厨房里等着，无所事事。我们不能再处理额外的烹饪订单。但是，如果他们不只是简单地在厨房里等待，他们就可以只用两个厨师来处理同样数量的订单。鉴于厨房里有两个忙碌的厨师，我们仍然有三个剩余的厨师闲着，等待新的额外烹饪订单。</p></div><div class="ab cl oo op hu oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="ij ik il im in"><h1 id="0c7c" class="mm mn iq bd mo mp ov mr ms mt ow mv mw jw ox jx my jz oy ka na kc oz kd nc nd bi translated">源代码</h1><p id="3ab8" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">你可以在我的<a class="ae lr" href="https://github.com/jo-ninja/visual-guide-async-await" rel="noopener ugc nofollow" target="_blank"> GitHub库</a> <em class="ls">找到源代码。</em></p></div></div>    
</body>
</html>