<html>
<head>
<title>Camel K — “Containerless” Deployments on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">camel K——Kubernetes上的“无集装箱”部署</h1>
<blockquote>原文：<a href="https://itnext.io/camel-k-containerless-deployments-349da12bfa9d?source=collection_archive---------1-----------------------#2022-04-01">https://itnext.io/camel-k-containerless-deployments-349da12bfa9d?source=collection_archive---------1-----------------------#2022-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0e0a7adf76d089a4617018057ce66cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*6_ZY447R4dJtk1j-9KA4XA.png"/></div></figure><p id="8fd4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最近，我被要求为我正在从事的一个项目调查骆驼。Camel是一个轻量级集成框架，旨在以即插即用的方式实现所有众所周知的企业集成模式。因此，举例来说，如果您想从S3桶中读取一个文件并打印出它的内容，您可以使用几行Java / Groovy / Kotlin或一系列其他特定于领域的语言(<a class="ae ks" href="https://camel.apache.org/manual/dsl.html" rel="noopener ugc nofollow" target="_blank"> DSL </a>)快速配置Camel来做到这一点。以下是来自<a class="ae ks" href="https://github.com/apache/camel-examples" rel="noopener ugc nofollow" target="_blank">阿帕奇骆驼示例报告</a>的示例:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="d09e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Camel拥有数量惊人的<a class="ae ks" href="https://camel.apache.org/components/3.15.x/index.html" rel="noopener ugc nofollow" target="_blank">组件</a>，可以用来将几乎任何系统或服务轻松地集成到任何其他系统或服务中。如果您需要的组件不可用，可以使用Camel框架创建您自己的组件。</p><p id="5628" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于Camel已经说得够多了，让我们继续讨论Camel K，毕竟，我肯定你想知道我说的<em class="kz">【无容器】</em>部署<em class="kz">是什么意思。</em></p><h1 id="490b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">输入骆驼K</h1><p id="19c4" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">Camel K 是Kubernetes的一个扩展，它可以快速加速在Kubernetes上部署Camel应用程序的过程。Camel K在安装后作为Kubernetes操作员运行，并从一个名为<em class="kz"> kamel的CLI工具监听新的应用程序部署请求。</em>以<a class="ae ks" href="https://github.com/apache/camel-k/tree/main/examples" rel="noopener ugc nofollow" target="_blank">为例</a>，Camel DSL可以用一个Java类编写，如下所示:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="6d04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个例子中，Camel将打印出字符串“Hello World！”每秒向控制台发送一次。要将这个应用程序(或者在Camel中称为route)部署到Kubernetes，在安装了camel CLI工具之后，可以从包含<em class="kz">camelBasic.java</em>文件的目录中运行下面的命令。</p><pre class="kt ku kv kw gt md me mf mg aw mh bi"><span id="0887" class="mi lb iq me b gy mj mk l ml mm">kamel run camelBasic.java</span></pre><p id="2b70" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，Camel K将通过操作符启动一个包含该应用程序代码的新pod。它做到了这一点<em class="kz">而不需要</em>要求开发者在部署之前创建一个容器映像。</p><p id="3b6b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不考虑Camel提供的丰富功能，让我们花点时间来体会一下这意味着什么。定制软件项目的典型Kubernetes部署是这样的:</p><ul class=""><li id="cc12" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated">开发人员编写一些代码</li><li id="2f42" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">开发人员将代码提交给版本控制系统</li><li id="83b9" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">构建管道被触发并构建代码</li><li id="04a8" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">代码工件被创建</li><li id="a449" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">工件被推送到工件储存库</li><li id="5963" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">然后，触发容器映像构建</li><li id="35e8" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">构建的映像被推送到容器注册表</li><li id="aca4" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">最后，触发一个发布管道，将映像部署到Kubernetes集群(kubectl / Helm等)。)</li></ul><p id="c625" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于开发人员来说，测试他或她的代码需要经历很多步骤。更重要的是，构建映像是一个CPU密集型的过程，因此需要时间。容器映像的大小也各不相同，从几兆字节到几百兆字节甚至更大。这些图像往往存储在远程注册表中，所以如果你碰巧在慢速网络上，你只能…等待…然后再等一会儿…然后再等一会儿。</p><h2 id="0c05" class="mi lb iq bd lc nb nc dn lg nd ne dp lk kf nf ng lo kj nh ni ls kn nj nk lw nl bi translated">那么骆驼K是怎么做到这一点的呢？</h2><p id="b0ed" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">当请求Camel K安装一个应用程序Kubernetes时，Camel K操作员将拦截该请求，并且在上面的Java示例中，启动一个部署过程，如下所示:</p><ul class=""><li id="70e1" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated">Kubernetes内部创建了一个<em class="kz">集成</em> <strong class="jw ir"> </strong>对象来跟踪您的应用程序代码、它的依赖项和配置。</li><li id="f3fb" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">然后创建一个<em class="kz"> IntegrationKit </em>对象，该对象定义了一个容器映像，在其中托管应用程序。IntegrationKit不包含任何源代码。</li><li id="d1ed" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">运行一个构建过程，该过程执行一个maven目标来构建Java代码。</li><li id="bc8c" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">一旦这个完成，就会动态<strong class="jw ir">构建一个容器</strong>，对，没错，动态<strong class="jw ir">。</strong>然后图像被推送到您配置的容器注册中心，Kubernetes将从那里获取它。Camel K操作者将把任务移交给Camel K运行时，并从刚刚构建的动态构建映像中旋转出一个pod。在内部，Camel K通过操作器中的功能来监视应用程序的状态。</li></ul><p id="f63e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，如果您想在开发周期中更改代码并重新部署应用程序，该怎么办呢？为此，Camel K提供了一个<em class="kz"> dev </em>标志，可以将其传递给<em class="kz"> kamel </em> CLI工具。在这种模式下，在IDE中所做的任何代码更改都会被自动获取，并被发送给操作员进行重新编译和重新部署。真正巧妙的是，并不是每次都创建新的容器映像，这意味着更快的部署周期，从而更快的开发周转时间。</p><h1 id="5d28" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">利益</h1><p id="f558" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">Apache团队定位Camel K的方式有一些非常明显的好处:</p><ul class=""><li id="3abf" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated">我已经提到了等待容器被创建和部署的开发时间的减少，但是开发人员很懒——他们喜欢效率，这对开发人员来说无疑是一个福音。</li><li id="cd16" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">操作团队成员可以重建应用程序容器，而不需要开发团队的帮助，因为代码工件不会改变。随着在容器操作系统中检测到越来越多的漏洞，只需修补一个基本映像，然后重新部署所有Camel集成就成为了一项真正高效的操作任务。</li></ul><h1 id="272a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="335a" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">使用Camel K部署Camel集成代码而无需预先构建容器映像非常有吸引力，尤其是在开发期间。这种部署定制应用程序代码的精益方法与构建图像的传统方式有点背道而驰，使用类似Helm chart的东西打包图像，然后将其部署到Kubernetes——我喜欢这种方式！</p><p id="344c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本系列的下一期文章中，我将介绍如何使用Camel K运行Camel应用程序之外的其他功能，以及这对替代性(实验性)部署策略意味着什么。这将更像是一个实验系列——但是尝试新事物很有趣。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="08c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你喜欢这篇文章，请考虑关注我，这是在媒体上建立追随者基础的唯一方法，也是确保我在这里的努力到达目标受众的唯一方法。</p></div></div>    
</body>
</html>