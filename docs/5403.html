<html>
<head>
<title>Nginx As Reverse Proxy In Front Of Keycloak</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nginx作为Keycloak前面的反向代理</h1>
<blockquote>原文：<a href="https://itnext.io/nginx-as-reverse-proxy-in-front-of-keycloak-21e4b3f8ec53?source=collection_archive---------0-----------------------#2021-02-26">https://itnext.io/nginx-as-reverse-proxy-in-front-of-keycloak-21e4b3f8ec53?source=collection_archive---------0-----------------------#2021-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">具有访问管理服务器、HTTP服务器和后端服务的全栈基础架构，设置只需几分钟。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/380a55dbb5277bc10263a316fc4de9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OaLeP-_zvJDCGV5y"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@hannahbusing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汉娜·布斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="1c03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Nginx是最受欢迎的HTTP服务器之一，根据W3Tech的调查，超过33%的网站使用nginx。这是提供静态内容和将客户端请求转发到服务器的完美选择，从而充当反向代理。</p><p id="3797" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Keycloak是一个开源的身份和访问管理服务。它提供了您可能需要的所有功能，如多因素身份认证、与通用身份提供商的集成、用户联盟、强力保护等。</p><p id="0cb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么不把它们放在一起？在这篇博客中，我们将讨论:</p><ul class=""><li id="053a" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">Nginx提供静态内容</li><li id="d24e" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">将流量路由到Keycloak</li><li id="ad08" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">微调键锁</li><li id="8ad9" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">带托管数据库的键盘锁</li><li id="0061" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">在HTTPS服役</li><li id="d70f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">安全微调</li><li id="162d" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">摘要</li></ul><p id="592d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TL；DR可以随意跳到摘要中查看完整的工作设置。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="c77c" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">1.Nginx提供静态内容</h1><p id="a579" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">让我们从创建nginx.conf配置文件开始，它定义了HTTP服务器的行为方式。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器部分，我们定义到达端口80和任何路径的传入流量应该被路由到data/www文件夹。</p><p id="299e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">try_files指令指示Nginx在根目录中搜索$uri，并使用index.html作为后备。</p><p id="c380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在本地创建一个名为www的文件夹，并将一些有效的index.html文件放入其中，在下一步中，我们将把这个文件映射到服务器的data/www文件夹。</p><p id="6ca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经准备好了Nginx配置，但是还没有Nginx服务器。幸运的是，旋转一个只是几秒钟的事。创建以下docker-compose.yml文件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="17e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Test: </strong>在根目录下的命令行中键入docker-compose up来运行它。导航到<a class="ae le" href="http://localhost/" rel="noopener ugc nofollow" target="_blank"> http://localhost/ </a>查看您的index.html。</p><h1 id="23d2" class="ma mb it bd mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt nj mv mw mx bi translated">2.添加键盘锁</h1><p id="0f3e" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">启动Keycloak最简单的方法是将JBoss Keycloak映像添加到docker-compose.yml文件中</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="43af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本地根目录中，创建一个名为。env并在其中写入Keycloak管理员密码，就像这样<code class="fe nk nl nm nn b">KEYCLOAK_PASSWORD=mysecret!</code></p><p id="d81f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，Keycloak服务在路径/auth上可用。因此，我们需要指示Nginx，到达端点/auth的流量应该被重定向到Keycloak服务器，所有其他流量都应该由静态内容提供服务。为了实现这一点，nginx.conf需要通过附加的location部分进行扩展，如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4368" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，如果客户端使用路径/auth Nginx请求端点，则将请求传递给内部网络端点mykeycloak:8080/auth。这个内部网络端点应该与我们之前在docker-compose文件中定义的服务名称相匹配。端口8080是JBoss Keycloak映像公开的默认端口。</p><p id="ffe6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，但同样重要的是，通过设置<code class="fe nk nl nm nn b">proxy_set_header</code>，我们将关于原始主机和客户端IP的信息传递给Keycloak。这使得Keycloak能够生成正确的应用内导航链接。如果我们没有这样做，当用户点击登录按钮时，Keycloak页面会将他发送到不正确的<a class="ae le" href="http://localhost/auth/admin/master/console" rel="noopener ugc nofollow" target="_blank">https://mykey cloak:8080/auth/admin/master/console</a>，而不是正确的【https://example.com/auth/admin/master/console】T4。我们还想将客户机IP传递给Keycloak，以支持正确的访问日志记录。</p><p id="e73b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">测试:</strong>运行docker-compose up，浏览到<a class="ae le" href="http://localhost/auth" rel="noopener ugc nofollow" target="_blank"> http://localhost/auth </a>。您将看到Keycloak登录页面，导航到管理控制台时，您可以使用之前在中提供的凭据登录。环境文件。当导航到任何其他路径时，您会看到index.html</p><h1 id="639d" class="ma mb it bd mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt nj mv mw mx bi translated">3.微调键盘锁</h1><h2 id="1675" class="no mb it bd mc np nq dn mg nr ns dp mk kb nt nu mo kf nv nw ms kj nx ny mw nz bi translated">连接到数据库</h2><p id="e608" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">到目前为止，我们的Keycloak实例使用内存中的H2数据库来存储领域、角色或客户端等设置。为了使这些设置持久化，Keycloak需要连接到一个真实的数据库。JBoss Keycloak docker image支持几个数据库，如Postgress、MariaDB、MySQL、Oracle。让我们假设在my-sql-host端点上有一个可用的MySQL数据库(您可以用MySQL容器扩展docker-compose或者连接到现有的DB)。首先，当您使用admin帐户连接到数据库实例时，创建一个数据库和Keycloak使用的用户。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7ce1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们准备修改docker-compose.yml文件，将以下环境变量附加到mykeycloak服务中。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要忘记编辑。env文件添加一个新行<code class="fe nk nl nm nn b">DB_KEYCLOAK_PASSWORD=mytopsecret</code></p><p id="7b3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">测试</strong>:运行docker-compose up。登录到Keycloak管理控制台，创建一个新的领域、角色或客户端。用docker-compose down把所有东西都拆了，然后再用docker-compose up重新开始。登录到管理控制台，看到您的领域、角色或客户端仍然存在。</p><h2 id="ed53" class="no mb it bd mc np nq dn mg nr ns dp mk kb nt nu mo kf nv nw ms kj nx ny mw nz bi translated">分配内存</h2><p id="319c" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">一旦我们有了一个合适的数据库，我们可能想尝试其他设置。例如，即使Keycloak规范规定最低内存需求是512MB，内存不足的容器也会崩溃。内存和其他配置可以通过docker-compose.yml文件中的JAVA_OPTS params环境变量来传递</p><p id="b42d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nk nl nm nn b">-JAVA_OPTS=-Xms1024m -Xmx2048m</code></p><h2 id="f379" class="no mb it bd mc np nq dn mg nr ns dp mk kb nt nu mo kf nv nw ms kj nx ny mw nz bi translated">导入领域</h2><p id="f066" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">导出Keycloak设置然后在部署到其他地方时导入它们可能会很方便。</p><p id="1f3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Keycloak管理控制台中，我们可以导出领域并将其存储为本地文件(realm-export.json)。我们可以将它挂载为一个卷，然后浏览Keycloak容器来加载这个配置。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="7623" class="ma mb it bd mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt nj mv mw mx bi translated">4.带托管数据库的键盘锁</h1><p id="938a" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">我用几个托管数据库测试了上面的设置。</p><ul class=""><li id="69c4" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">对于使用MySQL引擎的<a class="ae le" href="https://aws.amazon.com/rds/aurora/serverless/" rel="noopener ugc nofollow" target="_blank">亚马逊Aurora无服务器v1 </a>，我必须通过设置环境变量<code class="fe nk nl nm nn b">JDBC_PARAMS=enabledTLSProtocols=TLSv1.2</code>来指定TLSProtocol</li><li id="935e" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">我在数字海洋<a class="ae le" href="https://www.digitalocean.com/" rel="noopener ugc nofollow" target="_blank">上用托管的MySQL数据库</a>测试这个设置失败了，因为在初始化期间Keycloak试图创建一个没有主键<code class="fe nk nl nm nn b">Unable to create or change a table without a primary key CREATE TABLE keycloak.DATABASECHANGELOG</code>的表。我的第一个想法是运行:<code class="fe nk nl nm nn b">SET GLOBAL sql_require_primary_key=OFF</code>，但是，数字海洋不允许在他们的托管数据库上更改这个设置。</li><li id="a225" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">AWS RDS MySQL 运行良好</li></ul><h1 id="1436" class="ma mb it bd mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt nj mv mw mx bi translated">5.配置TLS协议</h1><p id="567f" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">对于只是玩玩，依赖HTTP是完全可以的，但是对于产品设置，安全的通信是必须的。</p><p id="723b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将通过HTTPS进行从互联网到Nginx的通信，而Nginx背后的内部通信，例如当我们的后端服务将与Keycloak对话时，将通过HTTP进行。这对应于Keycloak对“sslRequired”的默认设置:“external”。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/580885c421ddaf85e8cb2fc581216be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*YnB3kAQf9dHIZkVWYHurcQ.png"/></div></figure><p id="f4a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:Keycloak的文档建议在生产中将sslRequired设置为“all”。我敢肯定，在生产环境中运行的许多堆栈在负载均衡器或反向代理后面没有TLS，因此依赖于网络隔离。根据项目的具体情况，仔细考虑安全问题。</p><p id="5aa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们为我们的域获取一个有效的TLS证书。我们可以从<a class="ae le" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>中免费获得一个，或者只是为了本教程的目的，生成一个自签名证书(这里的例子<a class="ae le" href="https://gist.github.com/cecilemuller/9492b848eb8fe46d462abeb26656c4f8" rel="noopener ugc nofollow" target="_blank">是</a>)。</p><p id="88a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们现在已经将fullchain.pem和privkey.pem存储在本地目录/etc/letsencrypt中。</p><p id="1c91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将它们挂载为docker-compose.yml的nginx_rproxy部分中的卷</p><p id="b2b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nk nl nm nn b">- /etc/letsencrypt/:/etc/letsencrypt/</code></p><p id="8f77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对nginx.conf文件进行最后的调整:</p><ul class=""><li id="db94" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">修改服务器以指定证书和私钥的路径</li><li id="b7c8" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">将服务器修改为仅侦听端口443，以服务HTTPS流量</li><li id="6f78" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">添加一个监听端口80并将所有HTTP流量重定向到HTTPS端点的服务器</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="28a9" class="ma mb it bd mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt nj mv mw mx bi translated">6.安全微调</h1><p id="79fe" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">基础设施已经准备好了，我们开发并部署了一个漂亮的web应用程序，除了<a class="ae le" href="https://observatory.mozilla.org/" rel="noopener ugc nofollow" target="_blank"> Mozilla Observatory </a>(或者你喜欢的安全扫描工具)之外，每个人都很高兴。幸运的是，我们可以通过添加nginx.conf安全相关的响应头来修复一些最常见的问题。请参见下面的例子获取灵感:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="46d2" class="ma mb it bd mc md nf mf mg mh ng mj mk ml nh mn mo mp ni mr ms mt nj mv mw mx bi translated">摘要</h1><p id="f548" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在这篇博客中，我们配置了Nginx服务器来提供静态内容，并将授权请求传递给Keycloak。类似地，我们可以将请求传递到任何其他内部服务器，例如/api到myservice:5000，如完整的nginx.conf:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8119" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过docker-compose.yml文件定义了运行容器和服务(可用于开发目的或小型项目)。为了使这个例子完整，我们假设myservice是一个运行应用程序的容器，它公开了端口5000，并且是从根目录中的docker文件构建的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="27ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">docker-compose.yml文件假设您有。带有机密的env文件已准备好:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="063b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！</p></div></div>    
</body>
</html>