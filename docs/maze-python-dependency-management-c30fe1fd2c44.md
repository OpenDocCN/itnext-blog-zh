# Python 依赖管理的迷宫

> 原文：<https://itnext.io/maze-python-dependency-management-c30fe1fd2c44?source=collection_archive---------4----------------------->

![](img/8b7608ff1177eff0f780a89f3a717f85.png)

20 多年来，我一直为 JVM 开发代码，首先用 Java，然后用 Kotlin。然而，JVM 不是银弹，*，例如*，在脚本中:

1.  虚拟机会产生额外的内存需求
2.  在许多情况下，脚本运行的时间不够长，无法从性能方面获得任何好处。字节码被解释，永远不会编译成本机代码。

由于这些原因，我现在用 Python 写我的脚本。其中一个从不同来源收集社交媒体指标，并将其存储在 BigQuery 中进行分析。

我不是 Python 开发人员，但我正在学习——艰难地学习。在这篇文章中，我想解释一下 Python 中的依赖管理。

# Python 中足够的依赖管理

在 JVM 上，依赖性管理似乎是一个已经解决的问题。首先，选择您的构建工具，最好是 Maven 或我不知道名字的替代工具。然后，你声明你的*直接*依赖，工具管理间接依赖。这并不意味着没有问题，但你可以或多或少地快速解决它们。

Python 依赖管理是一个完全不同的世界。首先，在 Python 中，运行时及其依赖项是系统范围的。一个系统只有一个运行时，依赖关系在这个系统的所有项目中共享。因为不可行，所以开始一个新项目首先要做的就是创建一个虚拟环境。

> *这个问题的解决方案是创建一个虚拟环境，一个自包含的目录树，其中包含特定版本 Python 的 Python 安装，以及许多附加包。*
> 
> *不同的应用可以使用不同的虚拟环境。为了解决前面的需求冲突示例，应用程序 A 可以拥有自己的安装了 1.0 版的虚拟环境，而应用程序 B 拥有另一个 2.0 版的虚拟环境。如果应用程序 B 需要将库升级到版本 3.0，这不会影响应用程序 A 的环境。*
> 
> *—* [*虚拟环境和包*](https://docs.python.org/3/tutorial/venv.html)

一旦做到这一点，事情开始认真。

Python 提供了一个名为`pip`的现成依赖管理工具:

> *您可以使用名为 pip 的程序安装、升级和删除软件包。*
> 
> *—* [*用 pip*](https://docs.python.org/3/tutorial/venv.html#managing-packages-with-pip) 管理包

工作流程如下:

*   用户在虚拟环境中安装所需的依赖关系:

`pip install flask`

*   安装完所有需要的依赖项后，按照惯例，将它们保存在一个名为`requirements.txt`的文件中:

`pip freeze > requirements.txt`

该文件应与常规代码一起保存在个人的 VCS 中。

*   其他项目开发人员可以通过将`pip`指向`requirements.txt`来安装相同的依赖项:

`pip install -r requirements.txt`

下面是上述命令产生的`requirements.txt`:

```
click==8.1.3
Flask==2.2.2
itsdangerous==2.1.2
Jinja2==3.1.2
MarkupSafe==2.1.1
Werkzeug==2.2.2
```

# 依赖性和传递依赖性

在描述这个问题之前，我们需要解释什么是*传递*依赖。可传递依赖项是项目不直接需要的依赖项，而是项目的一个依赖项，或者一个依赖项的依赖项，一直到下面。在上面的例子中，我添加了`flask`依赖项，但是`pip`总共安装了 6 个依赖项。

我们可以安装`deptree`依赖来检查依赖树。

```
pip install deptree
deptree
```

输出如下所示:

```
Flask==2.2.2  # flask
  Werkzeug==2.2.2  # Werkzeug>=2.2.2
    MarkupSafe==2.1.1  # MarkupSafe>=2.1.1
  Jinja2==3.1.2  # Jinja2>=3.0
    MarkupSafe==2.1.1  # MarkupSafe>=2.0
  itsdangerous==2.1.2  # itsdangerous>=2.0
  click==8.1.3  # click>=8.0
# deptree and pip trees
```

内容如下:`Flask`需要`Werkzeug`，而`Werkzeug`又需要`MarkupSafe`。`Werkzeug`和`MarkupSafe`符合我的项目的可传递依赖关系。

版本部分也很有趣。第一部分提到已安装的版本，而注释部分指的是兼容的版本范围。比如`Jinja`需要版本`3.0`或以上，安装的版本是`3.1.2`。

安装的版本是`pip`在安装时找到的与*兼容的最新*版本。`pip`和`deptree`了解分布在各库的`setup.py`文件中的兼容性:

> 安装脚本是使用分发工具构建、分发和安装模块的所有活动的中心。安装脚本的主要目的是向 Distutils 描述您的模块分布，以便对您的模块进行操作的各种命令做正确的事情。
> 
> *—* [*编写设置脚本*](https://docs.python.org/3/distutils/setupscript.html)

这里是烧瓶:

```
from setuptools import setupsetup(
    name="Flask",
    install_requires=[
        "Werkzeug >= 2.2.2",
        "Jinja2 >= 3.0",
        "itsdangerous >= 2.0",
        "click >= 8.0",
        "importlib-metadata >= 3.6.0; python_version < '3.10'",
    ],
    extras_require={
        "async": ["asgiref >= 3.2"],
        "dotenv": ["python-dotenv"],
    },
)
```

# Pip 和传递依赖

出现这个问题是因为我希望我的依赖项是最新的。为此，我已经配置了 Dependabot 来监视`requirements.txt`中列出的新版本的依赖项。当此类事件发生时，它会在我的回购中打开一个 PR。大多数时候，PR 工作得非常好，但是在少数情况下，当我在合并后运行脚本时会出现错误。它看起来像下面这样:

```
ERROR: libfoo 1.0.0 has requirement libbar<2.5,>=2.0, but you'll have libbar 2.5 which is incompatible.
```

问题是，Dependabot 为每个列出的库打开一个 PR。但是可以发布新的库版本，这不在兼容范围之内。

想象一下下面的情况。我的项目需要`libfoo`依赖项。反过来，`libfoo`需要`libbar`的依赖。安装时，`pip`使用最新版本的`libfoo`和最新的*兼容*版本的`libbar`。由此产生的`requirements.txt`是:

```
libfoo==1.0.0
libbar==2.0
```

一切按预期运行。过了一会儿，Dependabot 运行后发现`libbar`发布了新版本*，例如*、`2.5`。忠实地，它打开一个 PR 来合并以下变更:

```
libfoo==1.0.0
libbar==2.5
```

上述问题是否出现完全取决于`libfoo 1.0.0`如何在`setup.py`中指定其依赖关系。如果`2.5`在兼容范围内，则工作；如果没有，就不会。

# `pip-compile`去救援

`pip`的问题在于它列出了传递依赖和直接依赖。Dependabot 然后获取所有依赖项的最新版本，但不验证可传递依赖项版本更新是否在该范围内。它可能会检查，但是`requirements.txt`文件格式不是结构化的:它不区分直接依赖和传递依赖。显而易见的解决方案是只列出直接依赖关系。

好消息是`pip`只允许列出直接依赖关系；它会自动安装[传递依赖关系](https://disjoint.ca/til/2016/03/18/pip-and-transitive-dependencies/)。坏消息是，我们现在有两个`requirements.txt`选项，无法区分它们:一些选项只列出直接依赖项，另一些选项列出所有依赖项。

这需要一个替代方案。 [pip-tools](https://github.com/jazzband/pip-tools) 有一个:

1.  其中一个在一个`requirements.in`文件中列出了它们的直接依赖关系，该文件的格式与`requirements.txt`相同
2.  `pip-compile`工具从`requirements.in`中生成一个`requirements.txt`。

例如，以我们的烧瓶为例:

```
Flask==2.2.2pip-compile#
# This file is autogenerated by pip-compile with python 3.10
# To update, run:
#
#    pip-compile requirements.in
#
click==8.1.3
    # via flask
flask==2.2.2
    # via -r requirements.in
itsdangerous==2.1.2
    # via flask
jinja2==3.1.2
    # via flask
markupsafe==2.1.1
    # via
    #   jinja2
    #   werkzeug
werkzeug==2.2.2
    # via flaskpip install -r requirements.txt
```

它有以下好处和后果:

*   生成的`requirements.txt`包含理解依赖树的注释
*   由于`pip-compile`生成文件，你不应该把它保存在 VCS 中
*   该项目与依赖于`requirements.txt`的遗留工具兼容
*   最后但同样重要的是，它改变了安装工作流程。不是安装软件包然后保存它们，而是首先列出软件包然后安装它们。

而且，Dependabot 可以管理`pip-compile`的依赖版本升级。

# 结论

这篇文章描述了默认的 Python 依赖管理系统，以及它是如何破坏自动版本升级的。我们继续描述解决问题的`pip-compile`替代方案。

注意，Python 有一个依赖管理规范，[PEP 621——将项目元数据存储在 pyproject.toml](https://peps.python.org/pep-0621/) 中。它类似于 Maven 的 POM，只是格式不同。这对于我的脚本来说是多余的，因为我不需要分发这个项目。但是要做的话，知道`pip-compile`是兼容它的。

**更进一步:**

*   [虚拟环境和包](https://docs.python.org/3/tutorial/venv.html)
*   [使用 pip 管理包](https://docs.python.org/3/tutorial/venv.html#managing-packages-with-pip)
*   [画中画工具](https://github.com/jazzband/pip-tools)
*   [PEP 621 —在 pyproject.toml 中存储项目元数据](https://peps.python.org/pep-0621/)

*原载于* [*一个 Java 极客*](https://blog.frankel.ch/maze-python-dependency-management/)*2022 年 9 月 11 日*