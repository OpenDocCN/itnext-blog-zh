<html>
<head>
<title>Autoscaling Redis applications on Kubernetes 🚀🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的自动缩放Redis应用🚀🚀</h1>
<blockquote>原文：<a href="https://itnext.io/autoscaling-redis-applications-on-kubernetes-25c1867e95d7?source=collection_archive---------0-----------------------#2021-03-02">https://itnext.io/autoscaling-redis-applications-on-kubernetes-25c1867e95d7?source=collection_archive---------0-----------------------#2021-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="13a6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用KEDA放大/缩小芹菜工人容器</h2></div><p id="4806" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇博文演示了如何在Kubernetes上自动缩放基于Redis的应用程序。<a class="ae lb" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>是一个广泛使用的(<a class="ae lb" href="https://redislabs.com/blog/redis-is-the-most-loved-database-for-the-4th-year-in-a-row/" rel="noopener ugc nofollow" target="_blank">并且深受喜爱！</a>)数据库，支持一组丰富的数据结构(字符串、哈希、流、地理空间)，以及其他功能，如发布/订阅消息、集群(HA)等。一种这样的数据结构是支持诸如插入(<code class="fe lc ld le lf b">LPUSH</code>、<code class="fe lc ld le lf b">RPUSH</code>、<code class="fe lc ld le lf b">LINSERT</code>等操作的<a class="ae lb" href="https://redis.io/topics/data-types-intro#lists" rel="noopener ugc nofollow" target="_blank">列表</a>。)，读取(<code class="fe lc ld le lf b">LRANGE</code>)，删除(<code class="fe lc ld le lf b">LREM</code>，<code class="fe lc ld le lf b">LPOP</code>等。)等。但这还不是全部！</p><p id="5f22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redis列表非常通用，用作实现可伸缩架构模式的主干，如消费者-生产者(基于队列)，生产者应用程序将项目推入列表，消费者(也称为工人)处理这些项目。热门项目如<code class="fe lc ld le lf b"><a class="ae lb" href="https://github.com/resque/resque" rel="noopener ugc nofollow" target="_blank">resque</a></code>、<code class="fe lc ld le lf b"><a class="ae lb" href="https://sidekiq.org/" rel="noopener ugc nofollow" target="_blank">sidekiq</a></code>、<code class="fe lc ld le lf b"><a class="ae lb" href="https://docs.celeryproject.org/en/stable/getting-started/brokers/redis.html" rel="noopener ugc nofollow" target="_blank">celery</a></code>等。在后台使用Redis实现后台作业。</p><p id="7086" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇博客中，您将学习如何自动扩展使用Redis作为代理的芹菜工人。有多种方法可以实现这一点——这个博客使用了一个基于Kubernetes的事件驱动自动缩放器(<code class="fe lc ld le lf b"><a class="ae lb" href="https://keda.sh/" rel="noopener ugc nofollow" target="_blank">KEDA</a></code>)来完成繁重的工作，包括根据工作负载扩大工作人员队伍，如果队列中没有任务，还可以将其缩小到零！</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/8b66bb66ade892d3b9d11b63cd70c182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMJA5-hLXiJtHbsbQABjng.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">使用KEDA自动缩放芹菜工作进程</figcaption></figure><blockquote class="lw lx ly"><p id="6c3e" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">请注意，这篇博文使用了一个</em> <a class="ae lb" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Golang </em> </a> <em class="iq">应用(感谢</em><a class="ae lb" href="https://github.com/gocelery/gocelery/" rel="noopener ugc nofollow" target="_blank"><em class="iq">go celery</em></a><em class="iq">！)作为例子，但这同样适用于Python或任何其他使用Celery协议的应用程序。</em></p></blockquote><p id="70ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它涵盖以下主题:</p><ul class=""><li id="515c" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">从应用程序的基本概述开始</li><li id="a7e5" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">设置infra (AKS、Redis)并随kEDA部署worker应用程序</li><li id="2ff0" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">测试端到端自动缩放的运行情况</li></ul><blockquote class="lw lx ly"><p id="cc5f" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">样例代码可在</em> <a class="ae lb" href="https://github.com/abhirockzz/redis-celery-kubernetes-keda" rel="noopener ugc nofollow" target="_blank"> <em class="iq">这个GitHub资源库</em> </a>中找到</p></blockquote><p id="f786" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，这里有一个快速的介绍！</p><h1 id="9dd1" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">芹菜</h1><p id="1f39" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">简单地说，<strong class="kh ir">芹菜</strong>是一个分布式消息处理系统。它使用经纪人来协调客户和员工之间的交流。客户端应用程序向代理添加消息(任务),然后将消息交付给一个或多个工作器——这种设置是水平可伸缩的(并且高度可用),因为您可以让多个工作器分担处理负载。</p><p id="e31d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然Celery是用Python写的，但好在协议可以用任何语言实现。这意味着您可以用完全不同的编程语言编写客户端和工作者应用程序(一个基于Node.js的客户端和一个基于Python的工作者应用程序)，但它们将能够互操作，只要它们使用Celery协议！</p><h1 id="3755" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">KEDA</h1><p id="6611" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">KEDA采用即插即用的架构，并在现有的Kubernetes原语(如Horizontal Pod Autoscaler)的基础上构建(扩展),以根据需要处理的事件数量来扩展任何Kubernetes容器。</p><p id="2f38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe lc ld le lf b">KEDA</code>缩放器负责与外部服务集成，以获取驱动自动缩放的指标。我们将使用<a class="ae lb" href="https://keda.sh/docs/scalers/redis-lists/" rel="noopener ugc nofollow" target="_blank">Redis的KEDA缩放器</a>，它根据Redis列表的长度(条目数)自动缩放应用程序。</p><blockquote class="lw lx ly"><p id="a9d4" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated">深入探讨不在这篇博文的讨论范围之内。要了解更多，请参考以下资源:<a class="ae lb" href="https://keda.sh/docs/2.1/concepts/" rel="noopener ugc nofollow" target="_blank">概念</a>、<a class="ae lb" href="https://keda.sh/docs/2.1/concepts/#architecture" rel="noopener ugc nofollow" target="_blank">架构</a>、<a class="ae lb" href="https://cloudblogs.microsoft.com/opensource/2020/05/12/scaling-kubernetes-keda-intro-kubernetes-based-event-driven-autoscaling/" rel="noopener ugc nofollow" target="_blank">入门博文</a>、<a class="ae lb" href="https://levelup.gitconnected.com/auto-scale-kafka-applications-on-kubernetes-with-keda-6fde6aef9d800" rel="noopener ugc nofollow" target="_blank">使用Kafka的动手教程</a>等。</p></blockquote><p id="5e3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们深入研究本质之前，这里有一个应用程序的高级概述。</p><h1 id="76fe" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">高层架构</h1><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi no"><img src="../Images/57b4b378df04e767f19924797e32dcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*3GgIXIq2n4NhAPd2FCOJSQ.jpeg"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">高层架构</figcaption></figure><p id="a81b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序包括以下组件:</p><ul class=""><li id="2c6c" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">Redis(用作芹菜经纪人)</li><li id="2944" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">模拟提交任务的客户端应用程序的生成器</li><li id="12ef" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">处理任务的工作应用程序(运行在Kubernetes中)</li></ul><h2 id="c854" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">生产者应用</h2><p id="4cea" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">生产者是一个向Redis提交任务的Go应用程序(使用<code class="fe lc ld le lf b">gocelery</code>库)。你可以在GitHub 上查看<a class="ae lb" href="https://github.com/abhirockzz/redis-celery-kubernetes-keda/blob/master/celery-go-app/producer.go" rel="noopener ugc nofollow" target="_blank">代码，但这里有一个片段:</a></p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="d2ed" class="np ms iq lf b gy of og l oh oi">go func() {<br/>        for !closed {<br/>            _, err := celeryClient.Delay(taskName, rdata.FullName(rdata.RandomGender), rdata.Email(), rdata.Address())<br/>            if err != nil {<br/>                panic(err)<br/>            }<br/>            time.Sleep(1 * time.Second)<br/>        }<br/>    }()</span></pre><p id="423c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它运行一个循环(作为goroutine)并发送随机生成的数据(全名、电子邮件和地址)。</p><blockquote class="lw lx ly"><p id="6ffe" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">producer应用程序可用作预构建的Docker映像</em><a class="ae lb" href="https://hub.docker.com/repository/docker/abhirockzz/celery-go-producer" rel="noopener ugc nofollow" target="_blank"><em class="iq">abhirockzz/celery-go-producer</em></a><em class="iq">，但是，您可以选择使用repo中提供的</em> <code class="fe lc ld le lf b"><em class="iq">Dockerfile</em></code> <em class="iq">构建另一个映像。</em></p></blockquote><h2 id="7345" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">芹菜工人</h2><p id="e2e8" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">Celery worker应用程序处理这些信息(通过Redis作业队列)。在这种情况下，处理逻辑包括将数据存储在Redis <code class="fe lc ld le lf b">HASH</code>中(但它可以是任何东西)。你可以在GitHub 上查看<a class="ae lb" href="https://github.com/abhirockzz/redis-celery-kubernetes-keda/blob/master/celery-go-app/worker.go" rel="noopener ugc nofollow" target="_blank">代码，但这里有一个片段:</a></p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="5a85" class="np ms iq lf b gy of og l oh oi">save := func(name, email, address string) string {<br/>        sleepFor := rand.Intn(9) + 1<br/>        time.Sleep(time.Duration(sleepFor) * time.Second)</span><span id="7719" class="np ms iq lf b gy oj og l oh oi">        info := map[string]string{"name": name, "email": email, "address": address, "worker": workerID, "processed_at": time.Now().UTC().String()}</span><span id="b3ca" class="np ms iq lf b gy oj og l oh oi">        hashName := hashNamePrefix + strconv.Itoa(rand.Intn(1000)+1)</span><span id="7832" class="np ms iq lf b gy oj og l oh oi">        _, err := redisPool.Get().Do("HSET", redis.Args{}.Add(hashName).AddFlat(info)...)<br/>        if err != nil {<br/>            log.Fatal(err)<br/>        }<br/>        return hashName<br/>    }</span></pre><p id="d5ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加<a class="ae lb" href="https://dev.to/abhirockzz/autoscale-redis-applications-on-kubernetes-using-keda-4bca-temp-slug-8481103?preview=430909cfebb8f7ca2982f68c48be98f943ca2755dadc606497190778d83e459653095be962eec082fdc964acff0274bfa083f865d89e546b5066e4d8" rel="noopener ugc nofollow" target="_blank">睡眠</a>是为了让工作应用程序可以在0到10秒之间暂停(这是随机的)。这将有助于模拟一个“高负载”场景，并有助于演示自动缩放(在接下来的部分中有详细介绍)。</p><blockquote class="lw lx ly"><p id="d9cf" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">worker应用程序可用作预构建的Docker映像</em><a class="ae lb" href="https://hub.docker.com/repository/docker/abhirockzz/celery-go-worker" rel="noopener ugc nofollow" target="_blank"><em class="iq">abhirockzz/celery-go-worker</em></a><em class="iq">，但是，您可以选择使用repo中提供的</em> <code class="fe lc ld le lf b"><em class="iq">Dockerfile</em></code> <em class="iq">构建另一个映像。</em></p></blockquote><h2 id="e625" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">KEDA <code class="fe lc ld le lf b">ScaledObject</code></h2><p id="fa3c" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">一个<code class="fe lc ld le lf b">ScaledObject</code>将我们想要自动伸缩的<code class="fe lc ld le lf b">Deployment</code>(在本例中，是芹菜工人应用程序)与度量的来源(Redis列表的长度)关联起来:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="e2b5" class="np ms iq lf b gy of og l oh oi">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: redis-scaledobject<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    kind: Deployment<br/>    name: celery-worker<br/>  pollingInterval: 15<br/>  cooldownPeriod: 200<br/>  maxReplicaCount: 10<br/>  triggers:<br/>    - type: redis<br/>      metadata:<br/>        addressFromEnv: REDIS_HOST<br/>        passwordFromEnv: REDIS_PASSWORD<br/>        enableTLS: "true"<br/>        listName: celery<br/>        listLength: "10"</span></pre><p id="a224" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是清单中使用的属性的摘要:</p><ul class=""><li id="3f09" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">(<code class="fe lc ld le lf b">spec.scaleTargetRef.deploymentName</code>)指定自动缩放的目标<code class="fe lc ld le lf b">Deployment</code>。</li><li id="a35b" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">触发类型为<code class="fe lc ld le lf b">redis</code>，而<code class="fe lc ld le lf b">triggers.metadata</code>部分用于提供更多细节:</li><li id="89e7" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">本例中<code class="fe lc ld le lf b">address</code>的值是<code class="fe lc ld le lf b">REDIS_HOST</code>，这是期望出现在<code class="fe lc ld le lf b">Deployment</code>中的环境变量的名称(运行时)</li><li id="4b19" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><code class="fe lc ld le lf b">listName</code>是Redis列表的名称，其待定项用于驱动自动缩放过程</li><li id="6017" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><code class="fe lc ld le lf b">listLength</code>是阈值(列表项目的数量)，超过该阈值将创建新的<code class="fe lc ld le lf b">Pod</code>(针对指定的<code class="fe lc ld le lf b">Deployment</code>)。在本例中，将为Redis列表中的每一个<code class="fe lc ld le lf b">10</code>未决项目创建一个新的<code class="fe lc ld le lf b">Pod</code>(为了便于测试，该数字保持较低)</li><li id="9cc9" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><code class="fe lc ld le lf b">maxReplicaCount</code>定义应用程序可扩展的上限，即无论扩展标准如何，都是可创建的<code class="fe lc ld le lf b">Pod</code>的最大数量</li></ul><p id="8a58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候转向实际的东西了。但是，在你去那里之前，请确保你已经准备好了:</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="a778" class="mr ms iq bd mt mu or mw mx my os na nb jw ot jx nd jz ou ka nf kc ov kd nh ni bi translated">先决条件</h1><p id="c9ad" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">要使用本博客中的应用程序，您需要:</p><ul class=""><li id="b6b3" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">Azure账户。你可以<a class="ae lb" href="https://azure.microsoft.com/free/?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank">创建一个免费账户</a>获得12个月的免费服务。</li><li id="5a94" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">安装了<a class="ae lb" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae lb" href="https://docs.microsoft.com/cli/azure/install-azure-cli?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a></li><li id="bb55" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><a class="ae lb" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<code class="fe lc ld le lf b"><a class="ae lb" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>一起集群:我已经使用了<a class="ae lb" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>，尽管<code class="fe lc ld le lf b"><a class="ae lb" href="https://kubernetes.io/docs/tasks/tools/install-minikube" rel="noopener ugc nofollow" target="_blank">minikube</a></code>应该也能工作。</li><li id="531e" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">Redis:我已经为Redis 使用了<a class="ae lb" href="https://docs.microsoft.com/azure/azure-cache-for-redis/?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Cache，但是可以自由探索其他选项，例如，你可以使用<code class="fe lc ld le lf b"><a class="ae lb" href="https://github.com/helm/charts/tree/master/stable/redis" rel="noopener ugc nofollow" target="_blank">Helm</a></code> </a><a class="ae lb" href="https://github.com/helm/charts/tree/master/stable/redis" rel="noopener ugc nofollow" target="_blank">图表</a>在你的Kubernetes集群中安装一个</li></ul><p id="81cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的部分中，我们将:</p><ul class=""><li id="7553" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">安装<code class="fe lc ld le lf b">KEDA</code></li><li id="a736" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">部署单个组件—芹菜工、<code class="fe lc ld le lf b">ScaledObject</code>等。</li><li id="bd53" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">生成负载并测试自动伸缩</li></ul><h1 id="2e7e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">基本设置</h1><p id="c537" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">首先，请确保:</p><ul class=""><li id="810e" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">在Azure 上建立一个Kubernetes集群</li><li id="0115" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><a class="ae lb" href="https://docs.microsoft.com/azure/azure-cache-for-redis/quickstart-create-redis?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank">为Redis实例创建Azure缓存</a></li></ul><h2 id="4167" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">安装KEDA</h2><p id="221e" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated"><code class="fe lc ld le lf b">KEDA</code>允许<a class="ae lb" href="https://keda.sh/docs/deploy/" rel="noopener ugc nofollow" target="_blank">多种安装选项</a>。我将<a class="ae lb" href="https://keda.sh/docs/deploy/#yaml" rel="noopener ugc nofollow" target="_blank">直接使用YAML</a></p><blockquote class="lw lx ly"><p id="93ed" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq"> KEDA组件将被安装到</em> <code class="fe lc ld le lf b"><em class="iq">keda</em></code> <em class="iq">命名空间中。</em></p></blockquote><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="68ff" class="np ms iq lf b gy of og l oh oi">kubectl apply -f <a class="ae lb" href="https://github.com/kedacore/keda/releases/download/v2.1.0/keda-2.1.0.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/kedacore/keda/releases/download/v2.1.0/keda-2.1.0.yaml</a></span></pre><p id="a5a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将分别启动<code class="fe lc ld le lf b">KEDA</code>操作员和Metrics API服务器<code class="fe lc ld le lf b">Deployment</code></p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="535a" class="np ms iq lf b gy of og l oh oi">kubectl get deployment -n keda</span><span id="a111" class="np ms iq lf b gy oj og l oh oi">NAME                              READY   UP-TO-DATE   AVAILABLE   AGE<br/>keda-operator                     1/1     1            1           1h</span><span id="0de4" class="np ms iq lf b gy oj og l oh oi">keda-operator-metrics-apiserver   1/1     1            1           1h</span></pre><blockquote class="lw lx ly"><p id="5838" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">在你继续下一步之前，等待</em> <code class="fe lc ld le lf b"><em class="iq">Deployment</em></code> <em class="iq"> s成为</em> <code class="fe lc ld le lf b"><em class="iq">READY</em></code></p></blockquote><p id="b677" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以部署自动扩展应用程序所需的组件。首先克隆此存储库，然后切换到正确的文件夹:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="8f81" class="np ms iq lf b gy of og l oh oi">git clone https://github.com/abhirockzz/redis-celery-kubernetes-keda<br/>cd redis-celery-kubernetes-keda</span></pre><h2 id="568b" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">部署芹菜工和KEDA <code class="fe lc ld le lf b">ScaledObject</code></h2><p id="bdc2" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我们需要首先部署<code class="fe lc ld le lf b">Secret</code>，因为芹菜工人<code class="fe lc ld le lf b">Deployment</code>使用它。首先，对Redis实例的密码进行编码(<code class="fe lc ld le lf b">base64</code>)(检查Azure Portal 中的<a class="ae lb" href="https://docs.microsoft.com/azure/azure-cache-for-redis/cache-development-faq?WT.mc_id=data-18088-abhishgu#retrieve-host-name-ports-and-access-keys-from-the-azure-portal" rel="noopener ugc nofollow" target="_blank">访问密钥)，以便将其存储为<code class="fe lc ld le lf b">Secret</code>。</a></p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="77d0" class="np ms iq lf b gy of og l oh oi">echo 'enter_redis_password' | base64</span></pre><p id="a22d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lc ld le lf b">secret.yaml</code>的<code class="fe lc ld le lf b">credentials</code>属性中替换它。例如，如果密码是<code class="fe lc ld le lf b">foobared</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="9f88" class="np ms iq lf b gy of og l oh oi">echo -n 'foobared' | base64</span><span id="fd14" class="np ms iq lf b gy oj og l oh oi">//output: Zm9vYmFyZWQ=</span></pre><p id="d87e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">secret.yaml</code>的最终版本将如下所示(注意<code class="fe lc ld le lf b">credentials</code>属性中的编码密码):</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="6f2c" class="np ms iq lf b gy of og l oh oi">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: redis-password<br/>type: Opaque<br/>data:<br/>  credentials: Zm9vYmFyZWQ=</span></pre><p id="be03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建<code class="fe lc ld le lf b">Secret</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="6c89" class="np ms iq lf b gy of og l oh oi">kubectl apply -f deploy/secret.yaml</span></pre><p id="9d74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们几乎已经准备好部署芹菜工人应用程序了。在此之前，请用Redis主机和端口更新<code class="fe lc ld le lf b">consumer.yaml</code>文件。以下是片段:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="46fb" class="np ms iq lf b gy of og l oh oi">...<br/>          env:<br/>            - name: REDIS_PASSWORD<br/>              valueFrom:<br/>                secretKeyRef:<br/>                  name: redis-password<br/>                  key: credentials<br/>            - name: REDIS_HOST<br/>              value: <strong class="lf ir">[replace with redis host and port e.g. foobar.redis.cache.windows.net:6380]</strong><br/>            - name: REDIS_LIST<br/>              value: celery<br/>...</span></pre><blockquote class="lw lx ly"><p id="0b4e" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><code class="fe lc ld le lf b"><em class="iq">celery</em></code> <em class="iq">是芹菜工创建的Redis </em> <code class="fe lc ld le lf b"><em class="iq">LIST</em></code> <em class="iq">的默认名称——请保持不变。</em></p></blockquote><p id="1a28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署工人应用程序，检查<code class="fe lc ld le lf b">Pod</code>并等待状态转换到<code class="fe lc ld le lf b">Running</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="d53e" class="np ms iq lf b gy of og l oh oi">kubectl apply -f deploy/consumer.yaml</span><span id="6008" class="np ms iq lf b gy oj og l oh oi">kubectl get pods -l=app=celery-worker -w</span><span id="8a81" class="np ms iq lf b gy oj og l oh oi">NAME                              READY   STATUS    RESTARTS   AGE<br/>celery-worker-5b644c6688-m8nf4   1/1     Running   0          20s</span></pre><blockquote class="lw lx ly"><p id="0e26" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">您可以使用</em> <code class="fe lc ld le lf b"><em class="iq">kubectl logs &lt;pod_name&gt;</em></code>查看日志</p></blockquote><p id="af9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">展开KEDA <code class="fe lc ld le lf b">ScaledObject</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="4eb9" class="np ms iq lf b gy of og l oh oi">kubectl apply -f deploy/redis-scaledobject.yaml</span></pre></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="9efe" class="mr ms iq bd mt mu or mw mx my os na nb jw ot jx nd jz ou ka nf kc ov kd nh ni bi translated">自动缩放正在运行</h1><p id="b9f2" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我们已经准备好测试端到端设置了！</p><h2 id="a030" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">缩放至零💥💥</h2><p id="fc8c" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">检查芹菜工<code class="fe lc ld le lf b">Pod</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="abb3" class="np ms iq lf b gy of og l oh oi">kubectl get pods -l=app=celery-worker</span><span id="66ff" class="np ms iq lf b gy oj og l oh oi">//output: No resources found</span></pre><p id="4e17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">No resources found</code>？？？等等，我们已经准备好了一个消费者应用程序<code class="fe lc ld le lf b">Pod</code>，刚刚发生了什么？别急，这是<code class="fe lc ld le lf b">KEDA</code>在行动！因为Redis列表中现在没有条目(因此工人没有工作)，<code class="fe lc ld le lf b">KEDA</code>确保没有空闲的<code class="fe lc ld le lf b">Pod</code>在运行。</p><blockquote class="lw lx ly"><p id="8a7d" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">这种行为可以通过</em> <code class="fe lc ld le lf b"><em class="iq">ScaledObject</em></code> <em class="iq">中的</em> <code class="fe lc ld le lf b"><em class="iq">minReplicaCount</em></code> <em class="iq">属性来控制(参考</em> <a class="ae lb" href="https://keda.sh/docs/concepts/scaling-deployments/#details" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> KEDA文档</em> </a> <em class="iq"> ) </em></p></blockquote><p id="f736" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">KEDA</code>使用<code class="fe lc ld le lf b">ScaledObject</code>中的信息创建一个<a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>对象:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="16da" class="np ms iq lf b gy of og l oh oi">kubectl get hpa </span><span id="bdc8" class="np ms iq lf b gy oj og l oh oi">NAME                          REFERENCE                  TARGETS              MINPODS   MAXPODS   REPLICAS   AGE<br/>keda-hpa-redis-scaledobject   Deployment/celery-worker   &lt;unknown&gt;/10 (avg)   1         10        0          2m51s</span></pre><h2 id="c127" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">扩大⬆️</h2><p id="8d3c" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">让我们运行Celery producer应用程序，并通过将项目推入Redis列表来模拟一些工作。在此之前，切换到另一个终端并开始观察消费者<code class="fe lc ld le lf b">Deployment</code>以跟踪自动缩放:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="02cd" class="np ms iq lf b gy of og l oh oi">kubectl get pods -l=app=celery-worker -w</span></pre><p id="59b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回上一个终端并运行应用程序:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="cd13" class="np ms iq lf b gy of og l oh oi">export REDIS_HOST=[replace with redis host and post info e.g. foobar.redis.cache.windows.net:6380]<br/>export REDIS_PASSWORD=[replace with redis password]</span><span id="e382" class="np ms iq lf b gy oj og l oh oi">docker run --rm -e REDIS_HOST=$REDIS_HOST -e REDIS_PASSWORD=$REDIS_PASSWORD abhirockzz/celery-go-producer</span><span id="2ba9" class="np ms iq lf b gy oj og l oh oi">//output:<br/>celery producer started...</span></pre><p id="34a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等待几秒钟。在另一个终端中，您会注意到芹菜工人正在被逐渐创建:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="c8ab" class="np ms iq lf b gy of og l oh oi">celery-worker-5b644c6688-2zk5c   0/1   ContainerCreating   0     0s<br/>celery-worker-5b644c6688-2zk5c   1/1   Running             0     4s<br/>celery-worker-5b644c6688-h22hp   0/1   Pending             0     0s<br/>celery-worker-5b644c6688-h22hp   0/1   Pending             0     0s<br/>celery-worker-5b644c6688-h22hp   0/1   ContainerCreating   0     0s<br/>celery-worker-5b644c6688-h22hp   1/1   Running             0     4s<br/>celery-worker-5b644c6688-r2m48   0/1   Pending             0     0s<br/>celery-worker-5b644c6688-r2m48   0/1   Pending             0     0s<br/>celery-worker-5b644c6688-r2m48   0/1   ContainerCreating   0     0s<br/>celery-worker-5b644c6688-r2m48   1/1   Running             0     3s</span></pre><p id="edac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您检查<code class="fe lc ld le lf b">Deployment</code> ( <code class="fe lc ld le lf b">kubectl get deployment/celery-worker</code>)，您将会看到与此类似的内容(取决于创建了多少个<code class="fe lc ld le lf b">Pod</code>):</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="539d" class="np ms iq lf b gy of og l oh oi">NAME            READY   UP-TO-DATE   AVAILABLE   AGE<br/>celery-worker   3/3     3            3           9m51s</span></pre><p id="fab3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以检查水平Pod自动缩放器。它应该反映相同的统计数据:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="673e" class="np ms iq lf b gy of og l oh oi">kubectl get hpa</span><span id="4472" class="np ms iq lf b gy oj og l oh oi">NAME                          REFERENCE                  TARGETS      MINPODS   MAXPODS   REPLICAS   AGE<br/>keda-hpa-redis-scaledobject   Deployment/celery-worker   9/10 (avg)   1         10        3          8m15s</span></pre><p id="1ede" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您碰巧检查了某个工作应用程序的日志，您将会记录如下输出:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="e0fd" class="np ms iq lf b gy of og l oh oi">...<br/>2021/03/01 10:05:36 got info -  Benjamin Moore liammiller233@test.com 9 Franklin Circle,<br/>Burrton, WY, 37213<br/>2021/03/01 10:05:36 worker b2928e0f-2c79-a227-7547-7bd2acdaacba sleeping for 3<br/>2021/03/01 10:05:39 saved hash info users:674<br/>2021/03/01 10:05:39 got info -  Lily Smith jacobwilliams126@example.net 84 Jackson Ter,<br/>New Deal, FM, 53234<br/>2021/03/01 10:05:39 worker b2928e0f-2c79-a227-7547-7bd2acdaacba sleeping for 7<br/>2021/03/01 10:05:46 saved hash info users:473<br/>2021/03/01 10:05:46 got info -  William Williams joshuadavis821@example.com 32 Washington Rdg,<br/>Baldock, MN, 60018<br/>2021/03/01 10:05:46 worker b2928e0f-2c79-a227-7547-7bd2acdaacba sleeping for 9<br/>2021/03/01 10:05:55 saved hash info users:275<br/>...</span></pre><p id="5cea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们的员工快乐地工作时，让我们也来看看Redis。使用<code class="fe lc ld le lf b">redis-cli</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="450e" class="np ms iq lf b gy of og l oh oi">redis-cli -h [redis host e.g. foobar.redis.cache.windows.net] -p 6380 -a [redis password] --tls</span></pre><p id="06c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，检查Redis列表的长度(在本例中命名为<code class="fe lc ld le lf b">celery</code>)。输出将反映producer应用程序已经推入但尚未处理的作业数量。</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="ae03" class="np ms iq lf b gy of og l oh oi"><strong class="lf ir">llen celery</strong></span><span id="2d24" class="np ms iq lf b gy oj og l oh oi">(integer) 10</span></pre><p id="6d6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工作应用程序使用用户信息创建散列(基于它从生产者应用程序接收的随机数据)。要进行检查，请使用<code class="fe lc ld le lf b">SCAN</code>:</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="e206" class="np ms iq lf b gy of og l oh oi"><strong class="lf ir">scan 0 match users*</strong></span><span id="5b0f" class="np ms iq lf b gy oj og l oh oi">1) "960"<br/>2) 1) "users:169"<br/>   2) "users:272"<br/>   3) "users:855"<br/>   4) "users:429"</span></pre><p id="f287" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查几个条目(使用<code class="fe lc ld le lf b">hgetall</code>)。例如</p><pre class="lh li lj lk gt ob lf oc od aw oe bi"><span id="c27f" class="np ms iq lf b gy of og l oh oi"><strong class="lf ir">hgetall users:169</strong><br/> 1) "name"<br/> 2) "Natalie White"<br/> 3) "email"<br/> 4) "ethanjackson245@test.net"<br/> 5) "address"<br/> 6) "20 Jefferson Ter,\nDerby Center, ME, 18270"<br/> 7) "worker"<br/> 8) "6769253c-9dc3-9232-1860-4bc01ce760a3"<br/> 9) "processed_at"<br/>10) "2021-03-01 10:13:11.230070643 +0000 UTC"</span></pre><p id="6ddb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了用户详细信息，请注意处理该记录的工人的ID<strong class="kh ir">也是可用的。这是为了确认不同的工作实例正在共享工作负载。</strong></p><blockquote class="lw lx ly"><p id="b55f" class="kf kg lz kh b ki kj jr kk kl km ju kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated"><em class="iq">我们已经将</em> <code class="fe lc ld le lf b"><em class="iq">10</em></code> <em class="iq">设置为</em> <code class="fe lc ld le lf b"><em class="iq">ScaledObject</em></code> <em class="iq">清单中的</em> <code class="fe lc ld le lf b"><em class="iq">listLength</em></code> <em class="iq">，并将</em> <code class="fe lc ld le lf b"><em class="iq">maxReplicaCount</em></code> <em class="iq">指定为</em> <code class="fe lc ld le lf b"><em class="iq">10</em></code> <em class="iq">(因此</em> <code class="fe lc ld le lf b"><em class="iq">Pod</em></code> <em class="iq"> s的数量将被限制为这个数量)。</em></p></blockquote><h2 id="c913" class="np ms iq bd mt nq nr dn mx ns nt dp nb ko nu nv nd ks nw nx nf kw ny nz nh oa bi translated">缩小⬇️</h2><p id="c8ee" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">停止生成器应用程序。</p><p id="cadd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦列表中的所有项目都被消耗完，并且列表为空，在到达<code class="fe lc ld le lf b">cooldown</code>周期(本例中为<code class="fe lc ld le lf b">200</code>秒)后，<code class="fe lc ld le lf b">Deployment</code>将按比例缩小。最终，<code class="fe lc ld le lf b">Pod</code>的数量会归零。您可以再次“清洗并重复”这一过程，并对您想要发送的消息数量(模拟负载)、您想要扩展到的副本数量、不同的<code class="fe lc ld le lf b">thresholdCount</code>等进行不同的实验。</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="f957" class="mr ms iq bd mt mu or mw mx my os na nb jw ot jx nd jz ou ka nf kc ov kd nh ni bi translated">打扫</h1><p id="76da" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">完成后，不要忘记删除您创建的资源:</p><ul class=""><li id="01d0" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">删除芹菜工app，<code class="fe lc ld le lf b">ScaledObject</code>和<code class="fe lc ld le lf b">Secret</code> : <code class="fe lc ld le lf b">kubectl delete -f deploy</code></li><li id="90db" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">到<a class="ae lb" href="https://keda.sh/docs/2.1/deploy/#uninstall-2" rel="noopener ugc nofollow" target="_blank">卸载KEDA </a> : <code class="fe lc ld le lf b">kubectl delete -f <a class="ae lb" href="https://github.com/kedacore/keda/releases/download/v2.1.0/keda-2.1.0.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/kedacore/keda/releases/download/v2.1.0/keda-2.1.0.yaml</a></code></li><li id="99f9" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><a class="ae lb" href="https://docs.microsoft.com/cli/azure/aks?view=azure-cli-latest&amp;WT.mc_id=data-18088-abhishgu#az_aks_delete" rel="noopener ugc nofollow" target="_blank">如果不再需要，删除AKS集群</a>:<code class="fe lc ld le lf b">az aks delete --name &lt;cluster name&gt; --resource-group &lt;group name&gt;</code></li><li id="6e51" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated"><a class="ae lb" href="https://docs.microsoft.com/azure/azure-cache-for-redis/scripts/delete-cache?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank">删除Redis实例的Azure缓存</a> : <code class="fe lc ld le lf b">az redis delete --name &lt;cache name&gt; --resource-group &lt;group name&gt;</code></li></ul><h1 id="bc21" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="8d56" class="pw-post-body-paragraph kf kg iq kh b ki nj jr kk kl nk ju kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">我们在这个博客中讨论过Redis Scaler，但是<code class="fe lc ld le lf b">KEDA</code>提供了<a class="ae lb" href="https://keda.sh/docs/scalers/" rel="noopener ugc nofollow" target="_blank">许多这样的Scaler</a>。<code class="fe lc ld le lf b">KEDA</code>处理应用程序的自动扩展，但是，如果您可以在Kubernetes集群节点之外的基础设施上运行所有这些应用程序实例，例如无服务器平台，会怎么样？</p><p id="ff87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这听起来很有趣，请查看Azure Kubernetes服务中的<a class="ae lb" href="https://docs.microsoft.com/azure/aks/virtual-nodes?WT.mc_id=data-18088-abhishgu" rel="noopener ugc nofollow" target="_blank">虚拟节点</a>,看看如何使用它们将您的应用无缝扩展到Azure容器实例，并从pods的快速供应中受益，并且只需为它们的执行时间按秒付费。AKS的虚拟节点附加组件基于开源项目<a class="ae lb" href="https://virtual-kubelet.io/" rel="noopener ugc nofollow" target="_blank"> Virtual Kubelet </a>，这是一个开源<a class="ae lb" href="https://kubernetes.io/docs/reference/generated/kubelet/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a> <code class="fe lc ld le lf b"><a class="ae lb" href="https://kubernetes.io/docs/reference/generated/kubelet/" rel="noopener ugc nofollow" target="_blank">kubelet</a></code>实现。</p></div></div>    
</body>
</html>