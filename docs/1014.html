<html>
<head>
<title>Real store’is: Utility stores (part 1 of 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“真正的商店”是:实用商店(第1部分，共3部分)</h1>
<blockquote>原文：<a href="https://itnext.io/real-storeis-utility-stores-part-1-of-3-1277a0d76720?source=collection_archive---------5-----------------------#2018-07-04">https://itnext.io/real-storeis-utility-stores-part-1-of-3-1277a0d76720?source=collection_archive---------5-----------------------#2018-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cc73" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">MobX将定义存储在现实应用中</h2></div><blockquote class="kf kg kh"><p id="a85c" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这篇文章展示了<a class="ae lf" href="https://www.timefic.com" rel="noopener ugc nofollow" target="_blank">timefic.com</a>的“状态管理”方面，这意味着我们在这里不是在谈论React组件，渲染到dom或处理用户事件。它将讲述如何组织数据(状态)以及如何对基于3种或3类商店的任何应用进行建模:</p></blockquote><ul class=""><li id="2f0d" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated"><strong class="kl ir">实用商店</strong>:对应用程序(很可能是你现在正在构建的应用程序)来说是“架构性的”商店，因此它们可以被你的“大图”中定义的所有模块或服务使用。</li><li id="667a" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">本地商店</strong>:本地持久化或根本不持久化的商店。它们保存临时数据，但对用户的客户端体验至关重要。</li><li id="d9c1" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">域存储</strong>:与特定的域或服务相关的存储，业务规则就位于其中。</li></ul><p id="228c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">所以，我们不会在这篇文章中看到太多的代码，也许是一些形象的想法，因为我知道你有多爱看javascript代码😀！！</p><h2 id="c40d" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">商店#1:根商店</h2><p id="a58d" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated"><em class="kk">又名:所有商店之母</em></p><p id="51d5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">当您创建第一家商店时，您会逐步将所有需要的功能放在那里，例如:</p><ul class=""><li id="f6e3" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated">添加大多数商店将需要的字段(可观察的)，如<strong class="kl ir"> dbData </strong>(来自服务器的数据)和<strong class="kl ir"> ready </strong>(一个布尔值，表示该数据已经加载)。</li><li id="9375" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">调用服务器</strong>来填充您需要的数据。</li><li id="2ba9" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">创建一个名为<strong class="kl ir">的<strong class="kl ir">通用动作</strong>修改</strong>来改变你声明的任何字段(可观察的)的值。</li><li id="cbf0" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">将每个存储记录到窗口对象中，例如:<strong class="kl ir">窗口。行动商店</strong>。</li><li id="f878" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">用数据初始化存储库</strong>，而不是从你的服务器加载数据(这在你测试系统时很有用)。</li></ul><p id="cd9c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">在我的例子中，也是<strong class="kl ir">从任何将使用这个根存储构建的存储中完全隐藏MobX原语</strong>:<strong class="kl ir">可观察的</strong>、<strong class="kl ir">动作</strong>、<strong class="kl ir">计算的</strong>、<strong class="kl ir">反应</strong>、<strong class="kl ir">当</strong>、<strong class="kl ir">自动运行</strong>以提及最频繁使用的原语。如果你想了解更多关于这种模式的信息，请查看这篇文章。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/196148c2d60f49092d934a9291e8f066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bsKIWo-i4okUOcesmisoQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">用于定义根存储的代码片段</figcaption></figure><h2 id="c262" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">商店#2:支票商店</h2><p id="a26b" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated"><em class="kk">又名:门卫。</em></p><p id="16b1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">你需要验证一个<em class="kk">电子邮件</em>或者<em class="kk">密码吗？</em>一个<em class="kk">电话号码</em>或者一个<em class="kk">当你的用户在输入框中输入时一个字符串的最小长度</em>？</p><p id="0b5e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">在我的案例中，我经历了3个阶段来解决这个问题:</p><ul class=""><li id="1890" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated"><strong class="kl ir">在动作层</strong>验证:当用户输入(onChange事件)或提交字段(onClick事件)时，会调度一个动作。该操作接受此输入，但在进入后端之前，会检查电子邮件看起来是否良好。这很好，直到你需要在另一个地方验证一封电子邮件:你会再次写同样的代码吗？</li><li id="d6f0" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">使用效用函数进行验证</strong>:不，你知道你不能忍受这种明显的代码重复(你也知道将来会有三倍的重复……)。因此，您创建了名为<em class="kk"> checkEmail </em>、<em class="kk"> checkPassword </em>、<em class="kk"> checkToken </em>等实用函数。这很好，这里没有重复，但是您需要将这个验证的结果存储在某个地方，不是吗？</li><li id="2c61" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">使用商店验证</strong>:我们的朋友商店出现。它不仅包含您编写的实用函数(对于一个函数来说，有一个家是很好的)，还将存储从您所做的检查中返回的数据。因此，React组件可以观察这些数据并显示一条好消息(也是在存储中定义的！)给用户。最后，因为这个错误不应该永远可见，所以您还将定义一个标准机制来使它消失:例如超时。</li></ul><h2 id="01e0" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">商店#3:提醒商店</h2><p id="1945" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated">又名:可用性增强器。</p><p id="a218" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">类似的故事比支票店在这里。</p><p id="6666" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">假设一个用户刚刚创建了一个联系人，发送了一个会议邀请，或者给秘书写了一个投稿通知。</p><p id="0fd7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">在提交这个动作后的第二秒，他会问自己:<strong class="kl ir">我发送了吗？</strong> <strong class="kl ir">他收到了吗？Whatsapp 发明了单双检查之后，你知道用户期待对某些行为的即时反馈(不是每个行为！).</strong></p><p id="84d9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">因此，这个存储提供了一种标准机制来创建将由React组件显示的可观察数据，使用标准消息(也在存储级别定义)和一种消除警报的机制(超时或删除警报的显式处理程序)。</p><blockquote class="kf kg kh"><p id="ff43" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">请记住，这是实用商店，所以你需要决定如何在应用程序的具体模块中使用它们。</p><p id="b3da" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">例如:在timefic中，我选择让所有的支票存储都是实用程序存储的精确副本，因为我认为它的用途是“通用的”。</p><p id="7120" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">但是对于警报存储，我决定每个模块都用自己的警报定义来扩展实用程序存储。</p></blockquote><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/e90805d1642b4fc50437803eca7b004b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMpWbTyl-vDbnti36_fIGw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">仪表板模块中定义的预警示例</figcaption></figure><h2 id="8dc5" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">存储#4:队列存储</h2><p id="1bbb" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated"><em class="kk">又名:主管。</em></p><p id="914a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这个存储负责编排来自用户的所有动作，然后转到后端(一次或多次)，然后返回给用户。</p><p id="e794" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">编排有一个“奇特的”<em class="kk">基于承诺的</em>实现，这是需要将同步动作与异步动作相结合的结果。</p><p id="4acf" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">例如:</p><ul class=""><li id="17cf" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated">会议组织者创建一个要投票的新协议，用字段<strong class="kl ir"> <em class="kk">文本</em> </strong>(协议的描述)调用一个动作。</li><li id="9528" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">状态</strong>(我们将在本文的第2部分中查看的商店)已经知道当前正在使用的<em class="kk"> meeting_id </em>。因此，动作创建者不需要明确告知这个值。</li><li id="b6f3" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">我们在后端调用一个名为<strong class="kl ir"> <em class="kk"> AddAgreement </em> </strong>的方法来传递这些值，并在创建后取回协议的<strong class="kl ir"> <em class="kk"> _id </em> </strong>。</li><li id="d955" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">此<strong class="kl ir"> <em class="kk"> _id </em> </strong>允许<strong class="kl ir">更新状态</strong>以在屏幕中选择此新协议。</li><li id="fd8f" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">最后，<strong class="kl ir">我们清理状态</strong>(新协议的文本)，以便可用于将来的新协议。</li></ul><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/1cb785b19459895a60d8d746a0aed584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQFb4B_IzHI_3GirvGYm6A.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">队列存储所需形式的操作</figcaption></figure><p id="9f83" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">队列存储的任务是从所有地方接收这样的动作，并把它们放在一个内部队列中(我们存储的一个可观察的数组)。</p><p id="0530" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">每个动作都是按顺序处理的，每个动作中的每个步骤也是如此。因为每个步骤可以是同步的或异步的，所以我们在这里做的是<strong class="kl ir">将每个步骤包装在一个承诺</strong>中。</p><p id="f2a1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这就是队列控制执行流程的方式，也是为什么客户端和服务器可以在每个步骤完成后互相传递数据。</p><blockquote class="kf kg kh"><p id="5435" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这种方法的优点是什么？我有数百个像这样定义的动作，这个模式仍然有效。</p><p id="3a7b" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">同样，动作定义只是一个对象。<strong class="kl ir">看一看:是不是很可爱？</strong></p></blockquote><h2 id="ca50" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">商店#5:本地商店</h2><p id="f65a" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated"><em class="kk">又名:小db。</em></p><p id="6d86" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这个存储只是浏览器本地存储的包装。</p><p id="8c73" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">该商店存在的主要原因是<strong class="kl ir">能够作为队列商店</strong>的一个步骤。例如，当用户设置首选语言“西班牙语”时，您可以更改状态，转到后端，并将其保存在您的浏览器中。每个动作，队列一步。</p><p id="a83b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">此外，您可以在这里填充本地存储(如果您的浏览器不支持<em class="kk"> localStorage </em>，您可以使用<em class="kk"> cookies </em>),还可以将它用作对本机使用做出反应的<em class="kk"> AsyncStorage </em>的包装器。</p><p id="a83c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这里没有更多的。这个商店只是一个与用户保存在本地的数据进行交流的接口，通过便捷的方式<strong class="kl ir">获取</strong>、<strong class="kl ir">设置</strong>、<strong class="kl ir">清除</strong>、<strong class="kl ir">计数</strong>和<strong class="kl ir">检查可用性</strong>。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/e60714eef1685afe69c9d3c5157ac269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzJgqHdcPRuS4WNcmjpeYg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">本地商店的定义</figcaption></figure><h2 id="d13b" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">商店#6:钟表商店</h2><p id="8f0f" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated"><em class="kk">又名:同步器。</em></p><p id="679c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这个商店不像以前的商店那么普通，但我把它变成了一个实用商店，因为它在timefic的许多“应用程序模块”中使用(<em class="kk">仪表板</em>、<em class="kk">计划者</em>、<em class="kk">会议</em>)。</p><p id="afa9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">时间管理是timefic中的关键，所以这可能也是你的情况，取决于你正在构建的应用程序。</p><blockquote class="kf kg kh"><p id="d482" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">警告:这个商店不是“多年发展的结果”…它只是一种适合我的方法，所以小心使用它<em class="iq">😊</em></p></blockquote><p id="2114" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">简而言之，这家店:</p><ul class=""><li id="89a4" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated">有一个名为<strong class="kl ir"> <em class="kk">服务器时钟</em> </strong>的可观察字段。</li><li id="35fa" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">每隔1000毫秒，它检查是否有来自<strong class="kl ir"><em class="kk">serverClockFromStream</em></strong>的新值。</li><li id="e91d" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">如果是，则用该值更新<strong class="kl ir"> <em class="kk">服务器时钟</em> </strong>。</li><li id="a034" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated">否则，更新<strong class="kl ir"> <em class="kk">服务器时钟</em> </strong>，将1000毫秒加到先前的值。</li></ul><p id="9988" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这样，从后端每10秒(您可以定义最适合您需求的时间间隔)将时间戳发送到所有连接的客户端(字段<strong class="kl ir"><em class="kk">serverClockFromStream</em></strong>)。</p><p id="5bf6" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">这个存储被导入到需要时间管理的模块中，并使用基于serverClock和其他字段的计算字段进行扩展。例如:会议的<strong class="kl ir"> <em class="kk">过去的时间</em> </strong>？从<strong class="kl ir">服务器时钟</strong>中减去<strong class="kl ir">开始日期</strong>。</p><blockquote class="kf kg kh"><p id="cfd8" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意:再看一下<a class="ae lf" href="https://github.com/mobxjs/mobx-utils" rel="noopener ugc nofollow" target="_blank"> mobx now </a>，一个每秒都有时间的可观测场。这可能对你也有用。这是同步应用程序不同片段的简单方法(但不是与服务器同步)。</p></blockquote><h2 id="bb69" class="lx ly iq bd lz ma mb dn mc md me dp mf li mg mh mi lk mj mk ml lm mm mn mo mp bi translated">商店#7:溪流商店</h2><p id="1e79" class="pw-post-body-paragraph ki kj iq kl b km mq jr ko kp mr ju kr li ms ku kv lk mt ky kz lm mu lc ld le ij bi translated"><em class="kk">又名:客户端之间的无服务器通信</em></p><p id="7323" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">最后，Streams Store是另一个出现在timefic中的模式，当时我试图解决:</p><ul class=""><li id="ce81" class="lg lh iq kl b km kn kp kq li lj lk ll lm ln le lo lp lq lr bi translated">当我在<strong class="kl ir">输入</strong>时，通知其他加入聊天的人(也收到相同的信息)。</li><li id="8d2f" class="lg lh iq kl b km ls kp lt li lu lk lv lm lw le lo lp lq lr bi translated"><strong class="kl ir">将光标</strong>显示在我正在演示的幻灯片内。</li></ul><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/01f5e65c8c4ba74b3ce5eb4d734f0f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIxbHj3J16FcPO59fMt9OA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">无服务器交流:组织者向观众展示一些东西</figcaption></figure><p id="f097" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">当然，您需要一个React组件来订阅该事件，用CSS施展您的魔法。</p><p id="9a32" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">但是，如果这是无服务器的，谁来充当服务器呢？需要澄清的是，这并不是严格意义上的无服务器，而是<strong class="kl ir">没有使用你的服务器</strong>，这意味着数据来自另一台服务器。作为一个例子，我使用<a class="ae lf" href="https://www.pubnub.com/" rel="noopener ugc nofollow" target="_blank"> PubNub </a>服务来发出和订阅这个事件。</p><p id="9922" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr li kt ku kv lk kx ky kz lm lb lc ld le ij bi translated">在下一集，我们将谈论本地商店或不将其数据保存到后端并用于封装用户界面复杂性的商店。</p></div></div>    
</body>
</html>