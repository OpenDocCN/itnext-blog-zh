<html>
<head>
<title>Forget About Redux Boilerplate — Now It is Just One Little Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">忘掉Redux样板文件吧——现在它只是一个小钩子</h1>
<blockquote>原文：<a href="https://itnext.io/forget-about-redux-boilerplate-now-it-is-just-one-little-hook-bd95a7a44d6f?source=collection_archive---------3-----------------------#2020-10-26">https://itnext.io/forget-about-redux-boilerplate-now-it-is-just-one-little-hook-bd95a7a44d6f?source=collection_archive---------3-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b0f9a656ff86c740bc6a02ad35f40d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgRkewiZVaQ2scWg6X9JWA.png"/></div></div></figure><blockquote class="jy jz ka"><p id="8602" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我试图尽可能减少React应用程序中的Redux设置，并成功做到了这一点。</p></blockquote><p id="c376" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果你不喜欢自己开发的应用程序中的Redux设置，请对这一行进行评论。是你做的吗？我想是的。</p><p id="d9a2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Redux在React开发人员中臭名昭著，因为它需要庞大、混乱的样板文件和大量无关的代码。虽然<a class="ae ld" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux架构</a>的核心非常简单，其概念清晰易懂，但在实现时，无论是Redux、Vuex还是NgRx，通常都不那么容易处理。</p><p id="a964" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">今天，我希望向您展示一种方法来处理繁琐的定义问题，以及在React应用程序中冗余使用Redux的问题。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="a81b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">工具</h1><p id="c1c3" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">我们将使用一个示例React应用程序。首先，让我们概述一下将要用来构建它的工具:</p><ul class=""><li id="78ae" class="mo mp iq ke b kf kg kj kk la mq lb mr lc ms kz mt mu mv mw bi translated"><strong class="ke ir">反应</strong> 16.8+和<strong class="ke ir">还原</strong>4；</li><li id="4373" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated">丹·阿布拉莫夫的<strong class="ke ir">创建-反应-应用</strong>，用于更快的设置；</li><li id="0a19" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated"><strong class="ke ir">打字稿</strong>(大粉丝！).</li></ul><blockquote class="jy jz ka"><p id="d330" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">TypeScript是整个方法的重要部分。如果你不使用它，也不打算使用它，就此停止阅读，为自己节省时间。</p><p id="7204" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有，不要太担心TypeScript版本。我在文章里用的是v4.0，在回购里用的是v3.9。差异非常小。</p></blockquote><h1 id="dcbb" class="ll lm iq bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">初始设置</h1><p id="2f83" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">本指南假设React应用程序和Redux流已经存在。如果您没有，我已经在一个示例存储库中介绍了这个步骤，只需克隆它并签出到分支<code class="fe nh ni nj nk b">initial-setup</code>:</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="b3c7" class="nt lm iq nk b gy nu nv l nw nx">git clone \<br/>  <a class="ae ld" href="https://github.com/parzhitsky/minimal-redux-example.git" rel="noopener ugc nofollow" target="_blank">https://github.com/parzhitsky/minimal-redux-example.git</a> \<br/>  --branch <!-- -->initial-setup</span><span id="edbf" class="nt lm iq nk b gy ny nv l nw nx">npm clean-install</span></pre><blockquote class="jy jz ka"><p id="1aec" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论如何都要考虑克隆它，这样我们就平等了。</p></blockquote><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/120b01e5cafa7fa53db87e2c93662a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*pouunKuo6E2gqxj_RZHBRA.png"/></div></figure><p id="730a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是典型React应用程序中Redux的典型设置，存储通常位于<code class="fe nh ni nj nk b">src/store/index.ts</code>中。一些现实世界的项目可能使用符号而不是字符串来标识操作；有些人选择枚举；有些人决定不在动作类型前面加上商店的名称。</p><p id="3c26" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">不过，这些都不重要。实际上重要的是:</p><ol class=""><li id="2cc4" class="mo mp iq ke b kf kg kj kk la mq lb mr lc ms kz oa mu mv mw bi translated">代码不是<a class="ae ld" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>的，例如<code class="fe nh ni nj nk b">Action</code>类型的联合需要不断的重复更新，否则会导致难以追踪的问题。</li><li id="3fbd" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz oa mu mv mw bi translated">每个动作类型和动作对象都被定义为一个完全独立的实体，例如，<code class="fe nh ni nj nk b">ActionSetName</code>接口，尽管非常相似，却完全与<code class="fe nh ni nj nk b">ActionClearName</code>分开定义。</li><li id="6547" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz oa mu mv mw bi translated">触发一个动作需要至少两个实体出现在作用域中:<code class="fe nh ni nj nk b">dispatch</code>函数和专用的动作创建者函数。</li><li id="17ae" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz oa mu mv mw bi translated">编译错误，如果有的话，显示得很好；总的来说，该设置按预期工作，提供了完全的类型安全。</li></ol><p id="d5a4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">毫无疑问，一个正常工作的应用程序是一件好事，但是也有扩展它、添加新功能、修复错误等等的意图。而且，尽管一些设计选择看似合理，但目前的设置在这方面做得并不多。</p><p id="cd87" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">最终，这种设置有两个大问题:永远不完整的动作/类型/有效载荷等的定义。，以及所有这些的详细用法。</p><h2 id="9db1" class="nt lm iq bd ln ob oc dn lr od oe dp lv la of og lz lb oh oi md lc oj ok mh ol bi translated">(旁注)不，泛型没有用</h2><blockquote class="jy jz ka"><p id="238f" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你不知道泛型，<a class="ae ld" href="https://www.typescriptlang.org/docs/handbook/generics.html#generic-types" rel="noopener ugc nofollow" target="_blank">去读一读它们</a>，那会非常有帮助。</p></blockquote><p id="fe19" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><code class="fe nh ni nj nk b">Action</code>类型的联合显然是最差的，并且可能有将其重新定义为泛型的诱惑。虽然泛型非常有用(我们将在后面广泛使用它们)，但在这里它可能更像是一个快速而不实用的解决方案，而不是一个合适的解决方案。原因如下。</p><p id="04f6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">泛型需要参数。在我们的例子中，它们可能意味着给定动作的<code class="fe nh ni nj nk b">type</code>和<code class="fe nh ni nj nk b">payload</code>——这样每个特定的动作看起来就像<code class="fe nh ni nj nk b">Action&lt;"SET_NAME", string&gt;</code>。</p><p id="faea" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这里最大的问题是减速器。它希望第二个参数是所有的动作同时发生，就像现在这样。为此，<code class="fe nh ni nj nk b">Action</code>泛型必须将其参数设置为<em class="kd">所有动作类型</em>和<em class="kd">所有有效载荷</em>。这可以通过两种方式实现:</p><ul class=""><li id="835c" class="mo mp iq ke b kf kg kj kk la mq lb mr lc ms kz mt mu mv mw bi translated">指定所有已知的<em class="kd">类型和有效载荷——这将需要另外两个类型的联合，并且必须不断更新；</em></li><li id="6f4c" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated">允许<em class="kd">任何</em>类型和有效负载——这将TypeScript的类型检查的所有有用性抛到了脑后。</li></ul><p id="a710" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果你已经克隆了我的库，检查一下<code class="fe nh ni nj nk b">generics/no-type-checking</code>和<code class="fe nh ni nj nk b">generics/too-verbose</code>分支，看看在代码中的实际效果，以及一些额外的注释。</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="8891" class="nt lm iq nk b gy nu nv l nw nx">git checkout generics/no-type-checking</span></pre><h1 id="9cae" class="ll lm iq bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">行动与有效载荷的对应</h1><p id="7327" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">当定义一个新的动作时，你如何知道它的<code class="fe nh ni nj nk b">payload</code>属性的类型或者缺少它？你怎么知道<code class="fe nh ni nj nk b">"SET_NAME"</code>动作带走了<code class="fe nh ni nj nk b">string</code>的有效载荷，而<code class="fe nh ni nj nk b">"RESET_STATE"</code>根本不带走任何有效载荷？</p><p id="9be7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">答案是动作到有效载荷的对应或动作到有效载荷的映射。有些动作只需要一些东西就能完成，而其他的动作是自洽的，不需要任何有效载荷。动作和它们的有效载荷之间存在单向的内在对应。作为一名开发人员，这允许您在需要时轻松地指定动作的有效负载类型。</p><p id="aa46" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是，虽然人类可以很容易地弄清楚这一点，但计算机就不那么容易了，而且必须明确地告诉TypeScript编译器，一个函数需要一个<code class="fe nh ni nj nk b">string</code>参数，而另一个函数不需要任何参数。如果有可能教TypeScript关于这个动作到有效载荷的对应关系，那么每个动作都将会预先隐含地知道它的所有类型。</p><p id="c310" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">谢天谢地，这是可能的。</p><p id="ca41" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">可能有点不太习惯，这种映射可以使用JavaScript的hashmaps来完成，即普通的旧的常规对象；至于没有有效载荷的动作，按照惯例，使用<code class="fe nh ni nj nk b">never</code>类型是明智的——稍后，将有逻辑来区分<code class="fe nh ni nj nk b">never</code>和其他类型:</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b84002d78e3839da258e24bedf8e4ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*IaMshwD3q57Dl99yIeEjWQ.png"/></div></figure><blockquote class="jy jz ka"><p id="fde8" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如此简单。</p></blockquote><p id="9909" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">为了了解这是如何工作的，让我们暂时抛开定义，毕竟，设置的“使用”部分也需要注意。</p><h1 id="1353" class="ll lm iq bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">一切都是单钩</h1><p id="4f3a" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">概括地说，目前，要更新商店中的数据，需要获取<code class="fe nh ni nj nk b">dispatch</code>函数，导入所有需要的动作创建者，创建动作对象，并在适当的时候“分派”它们:</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4db6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是一个巨大的概念开销。不管这意味着什么，动作被“分派”并不重要；不要紧，<code class="fe nh ni nj nk b">dispatch</code>函数是<code class="fe nh ni nj nk b">“react-redux”</code>模块的一部分，而不是<code class="fe nh ni nj nk b">“redux”</code>；记住“动作”实际上指的是一个对象是无益的。</p><blockquote class="jy jz ka"><p id="4c8a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们在不同的抽象层次上，ffs！</p></blockquote><p id="bf0c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">关于动作的重要事情应该是a) <em class="kd">何时</em>调用它们，以及b) <em class="kd">它们做什么</em>。这是多么简单的事情:</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="27e4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">让我们试着逆向设计这段代码，让它正常工作。</p><h2 id="64f8" class="nt lm iq bd ln ob oc dn lr od oe dp lv la of og lz lb oh oi md lc oj ok mh ol bi translated">实现挂钩</h2><p id="7298" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">需要注意的要点是:</p><ul class=""><li id="528f" class="mo mp iq ke b kf kg kj kk la mq lb mr lc ms kz mt mu mv mw bi translated">动作类型是硬编码的，不是导入的；</li><li id="cbd2" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated"><code class="fe nh ni nj nk b">useAction</code>取动作类型，返回函数；</li><li id="ab12" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated"><code class="fe nh ni nj nk b">setName</code>接受一个参数(如第一个片段所示)；</li><li id="ea6b" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated">操作对象是自动创建和调度的；</li><li id="69cd" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated">所有类型检查都按预期工作。</li></ul><p id="02f0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">您可能能够在这里识别出一个<a class="ae ld" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">定制钩子</a>——这正是它。前面代码片段中所有与Redux相关的复杂性都被提取到一个单独的函数中，该函数采用React挂钩的形式(一个函数，其名称以“use”开头)。</p><blockquote class="jy jz ka"><p id="b727" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有人可能会说硬编码的值不好。对此我的回答是，在我们的情况下，他们不是。因为TypeScript最终将只传递有效值，所以这些值不需要也存在于JavaScript范围内。</p></blockquote><p id="9328" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">上面的观察足以实现钩子(我们现在忽略最后一项)。它必须是一个JavaScript函数，有一个字符串(动作的类型)作为参数。在内部，它必须创建一个<code class="fe nh ni nj nk b">dispatch</code>函数的实例，稍后会用到它。</p><p id="a1d0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">钩子必须返回另一个函数，这个函数没有或者只有一个参数，这取决于动作类型；该参数被视为有效载荷。给定有效载荷，这个函数在被调用时，必须使用之前创建的<code class="fe nh ni nj nk b">dispatch</code>函数创建并分派一个action对象，这部分工作要归功于<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>的概念。</p><blockquote class="jy jz ka"><p id="1c8f" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，这段代码远没有上面描述它的文本那么冗长。</p></blockquote><p id="a107" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">就这样，钩子实现了，可以使用了。</p><p id="9066" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然而，最后一项——类型安全——有点难，所以这个钩子暂时还没有完全类型化；这将在下一节中解决。</p><p id="dfc7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">钩子的参考实现可以在<code class="fe nh ni nj nk b">use-action/untyped</code>分支看到。</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="6555" class="nt lm iq nk b gy nu nv l nw nx">git checkout use-action/untyped</span></pre><h2 id="1b92" class="nt lm iq bd ln ob oc dn lr od oe dp lv la of og lz lb oh oi md lc oj ok mh ol bi translated">向挂钩添加类型安全</h2><p id="1098" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">让我们回忆一下，上面的<code class="fe nh ni nj nk b">PayloadMap</code>界面是什么样子的:</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b84002d78e3839da258e24bedf8e4ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*IaMshwD3q57Dl99yIeEjWQ.png"/></div></figure><p id="cc06" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是一个简明、简洁、组织有序的信息，允许轻松执行以下操作:</p><ul class=""><li id="ec49" class="mo mp iq ke b kf kg kj kk la mq lb mr lc ms kz mt mu mv mw bi translated">使用<code class="fe nh ni nj nk b">keyof</code>操作符获得所有动作类型的并集；</li><li id="998b" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated">使用TypeScript的<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors" rel="noopener ugc nofollow" target="_blank">方括号运算符</a>的变体，获取给定动作的有效负载类型；</li><li id="64f5" class="mo mp iq ke b kf mx kj my la mz lb na lc nb kz mt mu mv mw bi translated">将动作类型与任意值分开；</li></ul><p id="8130" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">此外，使用不同的实体，将有必要区分<code class="fe nh ni nj nk b">never</code>和其他类型，正如所承诺的那样，首先找出有效载荷的存在或不存在。</p><p id="46b6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">下面的代码击中了一个好的、类型安全的钩子的所有要点:</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ce37472ef4454f1b1c41d7ea68b8be29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkJk5k7hZeSeVZrxX8cqbw.png"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">指责<a class="ou ov ep" href="https://medium.com/u/504c7870fdb6?source=post_page-----bd95a7a44d6f--------------------------------" rel="noopener" target="_blank">介质</a>造成了这种可怕的格式。为了使用更好的格式，我需要一个更宽的图像，但是由于像素错位，这里更宽的图像将会模糊和难看——对此我无能为力。</figcaption></figure><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="bebc" class="nt lm iq nk b gy nu nv l nw nx">git checkout use-action/typed</span></pre><h1 id="b238" class="ll lm iq bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">处理减速器</h1><p id="698b" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">设置改进的最后一部分是处理减速器。它仍然需要那个通用的<code class="fe nh ni nj nk b">Action</code>类型——而这个类型还不存在。</p><p id="f88c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">其实这部分是最难的。我决定制作一个名为 <code class="fe nh ni nj nk b"><a class="ae ld" href="https://www.npmjs.com/package/@parzh/typed-redux-actions" rel="noopener ugc nofollow" target="_blank">@parzh/typed-redux-actions</a></code>的<a class="ae ld" href="https://www.npmjs.com/package/@parzh/typed-redux-actions" rel="noopener ugc nofollow" target="_blank"> npm模块，将流程中最繁琐的部分委托给第三方。</a></p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="1ac7" class="nt lm iq nk b gy nu nv l nw nx">npm i @parzh/typed-redux-actions</span></pre><blockquote class="jy jz ka"><p id="1e38" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这不是广告。不要害怕。如果我的包被下载，我不会从npm或其他任何人那里得到任何利润。如果你不想让我的名字出现在你的<code class="fe nh ni nj nk b"><em class="iq">package.json</em></code>里，那就直接从回购里偷代码<a class="ae ld" href="https://github.com/parzh/typed-redux-actions" rel="noopener ugc nofollow" target="_blank">，说真的。对我来说不会太好，但我不介意，我保证。</a></p></blockquote><p id="5625" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个模块导出三样东西，但是作业只需要其中之一<code class="fe nh ni nj nk b">ActionFrom</code>。有了这种类型，创造<code class="fe nh ni nj nk b">Action</code>简直易如反掌:</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="c9fb" class="nt lm iq nk b gy nu nv l nw nx">type Action = ActionFrom&lt;PayloadMap, keyof PayloadMap&gt;;</span></pre><p id="c8d9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><code class="fe nh ni nj nk b">ActionFrom</code>的第一个类型参数显然是有效载荷图。第二个参数指定给定动作的类型；它必须是有效载荷映射的键的子集。</p><p id="7b96" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然而，正如代码片段所示，所提供的类型不仅仅是一个子集，它是有效负载映射的所有键的集合。因此<em class="kd">,</em><code class="fe nh ni nj nk b"><em class="kd">Action</em></code><em class="kd">类型一次包括所有动作的</em> <code class="fe nh ni nj nk b"><em class="kd">type</em></code> <em class="kd">和</em> <code class="fe nh ni nj nk b"><em class="kd">payload</em></code> <em class="kd">，好处是保留了它们之间的正确映射。</em>现在只是给参数分配类型的问题，如<code class="fe nh ni nj nk b">action: Action</code>所示。</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/770cfc516c9e0bf200a515148e26d291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*3iAXLBLk3yty-RqJngCCXg.png"/></div></figure><p id="35b3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这就是如何制作类型安全的缩减器。分支<code class="fe nh ni nj nk b">proper-action-type</code>显示了这种方法的实现。</p><pre class="nl nm nn no gt np nk nq nr aw ns bi"><span id="525b" class="nt lm iq nk b gy nu nv l nw nx">git checkout <!-- -->proper-action-type</span></pre><h1 id="6c7e" class="ll lm iq bd ln lo nc lq lr ls nd lu lv lw ne ly lz ma nf mc md me ng mg mh mi bi translated">结论</h1><p id="1cef" class="pw-post-body-paragraph kb kc iq ke b kf mj kh ki kj mk kl km la ml kp kq lb mm kt ku lc mn kx ky kz ij bi translated">Redux的设置并不复杂。今天，我们讨论了一种简化it并减少多余/样板代码的方法。你可以在<code class="fe nh ni nj nk b">master</code>分支观察小林挺后的完整结果。</p></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><p id="b16a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">非常感谢您，并为阅读全文赢得+50 kudos！❤❤❤</p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/5c2d3e93d0c994f352276e1156c1c99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/1*D75HQkSUK4sxkmOoy91hWA.gif"/></div></figure><p id="c575" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我希望，这是一次有趣的旅程，充满了丰富的思想和有益的建议。如果是的话，要知道这是我最看重的东西——不要犹豫，留下尽可能多的掌声来表达你对我的支持和感谢。此外，如果你觉得我肯定应该写更多，请在<em class="kd">parzhitsky@gmail.com</em>给我留言——毕竟，你和我可以一起合作，让我们不要错过机会。</p><p id="50e0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">与此同时，请看看我以前的文章，在这篇文章中，我试图揭开正则表达式的神秘面纱，使它们成为通用的日常开发工具:</p><div class="oy oz gp gr pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/regular-expressions-1580bbb26319"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">正则表达式</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">比你想象的要容易得多！</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">itnext.io</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp jw pb"/></div></div></a></div></div></div>    
</body>
</html>