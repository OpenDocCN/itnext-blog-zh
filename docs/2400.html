<html>
<head>
<title>Delegates, Anonymous Methods and Lambda Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">委托、匿名方法和Lambda表达式</h1>
<blockquote>原文：<a href="https://itnext.io/delegates-anonymous-methods-and-lambda-expressions-5ea4e56bbd05?source=collection_archive---------0-----------------------#2019-05-18">https://itnext.io/delegates-anonymous-methods-and-lambda-expressions-5ea4e56bbd05?source=collection_archive---------0-----------------------#2019-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7121" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将写下</p><ul class=""><li id="753c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">代表</li><li id="2daa" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">匿名函数(匿名方法和Lambda表达式)</li><li id="7590" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">内置委托(功能和动作委托)</li></ul><p id="03c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从什么是代表开始。</p><h2 id="c113" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">代表</h2><p id="943d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated"><a class="ae lx" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/delegate" rel="noopener ugc nofollow" target="_blank">委托</a>是一种类型，它表示对具有特定参数列表和返回类型的方法的引用。</p><ul class=""><li id="3ed1" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">委托允许方法作为参数传递。</li><li id="66ee" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">委托是一种引用类型，它保存方法的引用。</li><li id="0332" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">所有委托都隐式地从<code class="fe ly lz ma mb b">System.Delegate</code>类派生。</li><li id="dfd0" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">C#通过委托处理回调函数和事件处理程序。</li></ul><p id="d40e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你实例化一个委托时，你可以将它的实例与任何具有<strong class="jp ir"> <em class="mc">兼容签名和返回类型</em> </strong>的方法相关联。您可以通过委托实例调用该方法。</p><p id="255a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个演示如何声明和实例化委托的示例:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="af09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e1edd1292f022a0f22617ecbd64cf69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*0PvK60eTciMsro3CI-wz6w.png"/></div></figure><p id="ede2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">组播代理</strong></p><p id="24ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">指向多个方法的委托称为多播委托。<code class="fe ly lz ma mb b">+</code>操作符向委托对象添加一个函数，而<code class="fe ly lz ma mb b">-</code>操作符从委托对象中删除一个现有的函数。</p><p id="4ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当调用多播委托时，它按顺序调用列表中的委托。只能组合相同类型的委托。</p><p id="c9e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是多播代理用法的一个示例:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/6607ae5e311f6c6a0abf1f944b0df419.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*vZBXz25rjuRnjS3L229JHg.png"/></div></figure><p id="27f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">C #中委托的演变</strong></p><p id="7f26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在C# 1.0中，您通过使用代码中其他地方定义的方法显式初始化委托来创建委托的实例。</p><p id="4a43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C# 2.0引入了<strong class="jp ir"> <em class="mc">匿名方法</em> </strong>的概念，作为编写可以在委托调用中执行的未命名内联语句块的方法。</p><p id="0195" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C# 3.0引入了<strong class="jp ir"> <em class="mc"> lambda表达式</em> </strong>，在概念上类似于匿名方法，但更具表现力和简洁。</p><p id="202f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个特性统称为<strong class="jp ir"> <em class="mc">匿名函数</em> </strong>。</p><p id="6d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mc">一般来说，针对3.5及更高版本的应用程序。NET Framework应该使用lambda表达式。</em></p><h2 id="6e20" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">匿名方法</strong></h2><p id="9b4d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">匿名方法是没有名字的方法。C#中的匿名方法可以使用关键字<code class="fe ly lz ma mb b">delegate</code>来定义，并且可以分配给委托类型的变量。</p><p id="7c15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">匿名方法</p><ul class=""><li id="2dad" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">可以访问外部变量或函数。</li><li id="0628" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">可以作为参数传递</li><li id="6518" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">可以用作事件处理程序。</li></ul><p id="ee15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用匿名方法，您可以减少实例化委托的编码开销，因为您不必创建单独的方法。</p><p id="cfca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子展示了我们上面使用的委托例子的匿名方法版本:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h2 id="8a42" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">λ表达式</strong></h2><p id="fa81" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated"><strong class="jp ir"><em class="mc">λ表达式</em> </strong>是被视为对象的代码块(表达式或语句块)。它可以作为参数传递给方法，也可以通过方法调用返回。</p><p id="c76f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lambda表达式是表示匿名方法的一种更简短的方式。</p><p id="58d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">lambda表达式使用<code class="fe ly lz ma mb b">=&gt;</code>、<a class="ae lx" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-operator" rel="noopener ugc nofollow" target="_blank"> lambda声明操作符</a>，将lambda的参数列表与其可执行代码分开。要创建lambda表达式，需要在lambda操作符的左边指定输入参数(如果有的话),并将表达式或语句块放在另一边。</p><p id="7d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们在第一个委托示例中使用的代码的lambda表达式版本:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9a64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于上面的例子，我们可以省略花括号，因为只有一个语句，我们也可以排除参数类型。以下是简明版:</p><pre class="md me mf mg gt mo mb mp mq aw mr bi"><span id="bc32" class="kz la iq mb b gy ms mt l mu mv">ArithmeticOperation sum = (number1, number2) =&gt; <br/>Console.WriteLine($"{number1} + {number2} = {number1 + number2}");</span></pre><p id="0bdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以有不带任何参数的lambda表达式，我们可以在lambda表达式中使用局部变量，如下例所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/7226b17a941dfe389d1fe19fbfbc5480.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*W_wqJE6W1FBS7Yjupr_m1A.png"/></div></figure><p id="2925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lambda表达式也可以用于LINQ查询:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/07adec2df3d6bfb125cc76b5369b4a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*LqWLljigrey4y4P3GvEpTQ.png"/></div></figure><p id="c126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lambda表达式可以分配给Func或Action委托。我们将在下一节研究这些。</p><h2 id="2455" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated"><strong class="ak">动作和功能委托</strong></h2><p id="26a8" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">C# 3.0引入了内置的通用委托类型<code class="fe ly lz ma mb b">Func</code>和<code class="fe ly lz ma mb b">Action</code>，这样我们就不必声明自定义委托。这些包含在<code class="fe ly lz ma mb b">System</code>名称空间中。</p><p id="a9eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">动作委托</strong></p><p id="4cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C#中的Action表示具有void返回类型和可选参数的委托。</p><p id="b416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个动作委托可以接受多达16个不同类型的输入参数。</p><p id="edf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的委托示例中，我们将委托声明如下:</p><pre class="md me mf mg gt mo mb mp mq aw mr bi"><span id="cbfb" class="kz la iq mb b gy ms mt l mu mv">delegate void ArithmeticOperation(double operand1, double operand2);</span></pre><p id="6fbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用一个动作委托，我们不需要这个声明，我们可以直接进行如下赋值:</p><pre class="md me mf mg gt mo mb mp mq aw mr bi"><span id="840a" class="kz la iq mb b gy ms mt l mu mv">Action&lt;double,double&gt; sum = Addition;</span></pre><p id="b588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，参数类型必须相同。</p><p id="86a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的代码如下:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="30d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以将匿名方法分配给操作委托，如下所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="776a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">lambda表达式也可以与动作委托一起使用，如下所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="952e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你比较第一个版本和最后一个版本，你可以看到当我们使用动作委托和lambda表达式时，代码变得更加简洁:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/6882f85e42916413bb1482f85635e397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_E_WnwytArjYId4gjqflQ.png"/></div></div></figure><p id="6cc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">功能委托</strong></p><p id="4120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Func委托用于返回值方法。</p><ul class=""><li id="629d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">它可以包含最小0和最大16个输入参数<strong class="jp ir"> </strong>和<strong class="jp ir"> </strong>它必须包含一个输出参数。</li><li id="01c6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">Func委托的<em class="mc">最后一个参数是输出参数或结果参数<em class="mc">。</em></em></li><li id="4caa" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">它还可以包含相同类型或不同类型的参数。</li><li id="7d53" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">它不能包含<code class="fe ly lz ma mb b">ref</code>或<code class="fe ly lz ma mb b">out</code>参数<em class="mc">。</em></li></ul><p id="6b85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们修改我们从一开始使用的委托示例，以便它返回一个值:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="57e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想使用Func委托，我们不需要下面的自定义委托声明:</p><pre class="md me mf mg gt mo mb mp mq aw mr bi"><span id="0563" class="kz la iq mb b gy ms mt l mu mv">delegate double ArithmeticOperation(double operand1, double operand2);</span></pre><p id="d8af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以进行如下分配:</p><pre class="md me mf mg gt mo mb mp mq aw mr bi"><span id="dfbc" class="kz la iq mb b gy ms mt l mu mv">Func&lt;double,double,double&gt; sum = Addition;</span></pre><p id="b8e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，参数类型必须匹配。</p><p id="a97f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们的代码变成如下:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e1f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以为Func委托分配一个匿名方法，如下所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="767f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Func委托也可以用于lambda表达式，如下所示:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="d2cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你觉得这篇文章内容丰富，易于理解。如果你在下面的评论中有任何问题和/或更正，请告诉我。</p><p id="1779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再见！</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/4045e85ba05894552d94778be5b5c9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*mO11v2Ye1TTBmqo9GxIAYg.jpeg"/></div></figure><p id="99a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="mc">参考文献</em> </strong></p><p id="4970" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://docs . Microsoft . com/en-us/dot net/cs harp/programming-guide/delegates/</em></a></p><p id="de95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://docs . Microsoft . com/en-us/dot net/cs harp/programming-guide/statements-expressions-operators/anonymous-functions</em></a></p><p id="1ddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://www.tutorialsteacher.com/csharp/csharp-anonymous-method" rel="noopener ugc nofollow" target="_blank">T17】https://www . tutorialsteacher . com/cs harp/cs harp-anonymous-methodT19】</a></p><p id="9ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://docs . Microsoft . com/en-us/dot net/cs harp/programming-guide/statements-expressions-operators/lambda-expressions</em></a></p><p id="cffd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://www.tutorialsteacher.com/csharp/csharp-action-delegate" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://www . tutorial teacher . com/cs harp/cs harp-action-delegate</em></a></p><p id="ae2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lx" href="https://www.geeksforgeeks.org/c-sharp-func-delegate/" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://www.geeksforgeeks.org/c-sharp-func-delegate/</em></a></p></div></div>    
</body>
</html>