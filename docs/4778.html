<html>
<head>
<title>Database migrations on Kubernetes using Helm hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Helm hooks在Kubernetes上进行数据库迁移</h1>
<blockquote>原文：<a href="https://itnext.io/database-migrations-on-kubernetes-using-helm-hooks-fb80c0d97805?source=collection_archive---------0-----------------------#2020-09-16">https://itnext.io/database-migrations-on-kubernetes-using-helm-hooks-fb80c0d97805?source=collection_archive---------0-----------------------#2020-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="091a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">TL；DR:在应用程序安装或更新之前，您可以利用<code class="fe kp kq kr ks b">pre-install</code>和<code class="fe kp kq kr ks b">pre-upgrade</code> Helm钩子来运行数据库迁移。继续阅读，了解为什么简单的解决方案可能不是好主意，以及使用头盔挂钩时的几个问题。</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/da492c3a37b6137bedd19f7c6a5b3643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwakuQ2_fjUvQyUFP9qUiA.png"/></div></div></figure><p id="7c56" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果您的应用程序使用关系数据库，您的模式将随着时间的推移而发展。在部署应用程序的新版本之前，您必须确保数据库模式是最新的。本文不是关于如何生成和管理模式迁移(有多种工具可以处理)，而是如何将它们作为Kubernetes上应用程序部署过程的一部分。</p><h1 id="f8bc" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在应用程序中运行迁移</h1><p id="143e" class="pw-post-body-paragraph jq jr iq jt b ju mg jw jx jy mh ka kb lf mi ke kf lg mj ki kj lh mk km kn ko ij bi translated">您可以决定在服务启动时自动运行迁移。这似乎是个好主意:它保证了在应用迁移之前您的服务不会启动，并且消除了在过时的模式上运行应用程序的风险。<br/>但是在Kubernetes上运行时，这就带来了几个问题:</p><ul class=""><li id="63a7" class="ml mm iq jt b ju jv jy jz lf mn lg mo lh mp ko mq mr ms mt bi translated">每次创建或重新启动新的pod时，它都会尝试再次运行迁移。如果您的迁移脚本编写正确，这应该不是问题，但这不是一个干净的设计。</li><li id="6aa3" class="ml mm iq jt b ju mu jy mv lf mw lg mx lh my ko mq mr ms mt bi translated">如果迁移需要一段时间(想象一下在一个巨大的表上添加一列)，那么您的pod可能会错过准备就绪检查，并在迁移完成之前被终止。您可以增加pod准备就绪检查的初始延迟，但是这样一来，就很难了解pod没有启动是因为它正在应用数据库迁移还是因为其他问题。</li><li id="5bd7" class="ml mm iq jt b ju mu jy mv lf mw lg mx lh my ko mq mr ms mt bi translated">根据您的部署的中断预算(在部署期间的任何时间点可以添加/删除多少个单元)，您可能会同时运行两个相同的迁移，从而导致冲突和错误。</li></ul><h1 id="0510" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用初始化容器</h1><p id="bf02" class="pw-post-body-paragraph jq jr iq jt b ju mg jw jx jy mh ka kb lf mi ke kf lg mj ki kj lh mk km kn ko ij bi translated"><a class="ae mz" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank">初始化容器</a>是在你的容器中的常规容器启动之前运行完成的容器。这对于在应用程序启动之前执行任何必需的设置(例如下载一些机密或配置文件)非常有用。使用init容器来运行数据库迁移似乎是一个好主意，但是在应用程序启动期间，我们将面临与运行它们相同的问题:</p><ul class=""><li id="010c" class="ml mm iq jt b ju jv jy jz lf mn lg mo lh mp ko mq mr ms mt bi translated">如果同时创建多个pod，则可以同时运行多个init容器</li><li id="8a53" class="ml mm iq jt b ju mu jy mv lf mw lg mx lh my ko mq mr ms mt bi translated">init容器将在每次创建新的pod时运行</li></ul><h1 id="35cc" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用舵钩作为作业运行</h1><h2 id="f4a6" class="na lj iq bd lk nb nc dn lo nd ne dp ls lf nf ng lw lg nh ni ma lh nj nk me nl bi translated">Kubernetes乔布斯</h2><p id="571f" class="pw-post-body-paragraph jq jr iq jt b ju mg jw jx jy mh ka kb lf mi ke kf lg mj ki kj lh mk km kn ko ij bi translated">首先，我们来看看Kubernetes的乔布斯。作业允许我们运行一个或多个pod来完成。与部署或复制集中的pod相反，K8s会在pod终止时重新创建pod以保持所请求的pod数量运行，作业中的pod在退出时不会重新创建(除非它们失败并且作业被配置为在失败时重新启动)。<br/>这对于运行只需要运行一次就能完成的任务来说非常棒，而运行数据库迁移对于他们来说是一个完美的用例。</p><p id="6c8d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">现在的挑战是在部署新版本的应用程序之前自动运行作业。</p><h2 id="2034" class="na lj iq bd lk nb nc dn lo nd ne dp ls lf nf ng lw lg nh ni ma lh nj nk me nl bi translated">头盔释放生命周期</h2><p id="cc62" class="pw-post-body-paragraph jq jr iq jt b ju mg jw jx jy mh ka kb lf mi ke kf lg mj ki kj lh mk km kn ko ij bi translated"><a class="ae mz" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>允许您将应用程序定义的所有K8s清单打包到一个<em class="js">图表</em>中，以便一次性部署它们，并使用模板定制每个部署(例如，允许在多个环境中使用不同的参数部署同一个图表)。</p><p id="be69" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">Helm还提供了<a class="ae mz" href="https://helm.sh/docs/topics/charts_hooks/" rel="noopener ugc nofollow" target="_blank">钩子</a>来决定在部署期间何时创建资源。我们可以利用它在创建/更新任何资源之前运行迁移作业。</p><p id="6672" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我们的迁移工作看起来是这样的:</p><pre class="ku kv kw kx gt nm ks nn no aw np bi"><span id="86fe" class="na lj iq ks b gy nq nr l ns nt"><strong class="ks ir">apiVersion</strong>: batch/v1<br/><strong class="ks ir">kind</strong>: Job<br/><strong class="ks ir">metadata</strong>:<br/>  <strong class="ks ir">name</strong>: "{{ .Release.Name }}"<br/>  <strong class="ks ir">labels</strong>:<br/>  <strong class="ks ir">annotations</strong>:<br/>    <strong class="ks ir">"helm.sh/hook": </strong>pre-install,pre-upgrade<br/>    <strong class="ks ir">"helm.sh/hook-weight": </strong>"-1"<br/>    <strong class="ks ir">"helm.sh/hook-delete-policy": </strong>hook-succeeded<br/><strong class="ks ir">spec</strong>:<br/>  <strong class="ks ir">template</strong>:<br/>    <strong class="ks ir">metadata</strong>:<br/>      <strong class="ks ir">name</strong>: "{{ .Release.Name }}"<br/>    <strong class="ks ir">spec</strong>:<br/>      <strong class="ks ir">restartPolicy</strong>: Never<br/>      <strong class="ks ir">containers</strong>:<br/>      - <strong class="ks ir">name</strong>: db-migrations // we will have to build a dedicated<br/>                            // docker image to run the migrations<br/>        <strong class="ks ir">image</strong>: "database-migrations"</span></pre><p id="99b6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">挂钩是使用注释配置的:</p><ul class=""><li id="b22d" class="ml mm iq jt b ju jv jy jz lf mn lg mo lh mp ko mq mr ms mt bi translated"><code class="fe kp kq kr ks b"><strong class="jt ir">"helm.sh/hook": </strong>pre-install,pre-upgrade</code>告诉helm在安装和升级应用程序之前运行此作业。</li><li id="0824" class="ml mm iq jt b ju mu jy mv lf mw lg mx lh my ko mq mr ms mt bi translated"><code class="fe kp kq kr ks b"><strong class="jt ir">"helm.sh/hook-weight": </strong>"-1"</code>用于定义helm应该以何种顺序创建实现相同钩子的资源。</li><li id="707b" class="ml mm iq jt b ju mu jy mv lf mw lg mx lh my ko mq mr ms mt bi translated"><code class="fe kp kq kr ks b"><strong class="jt ir">"helm.sh/hook-delete-policy": </strong>hook-succeeded</code>告诉helm在作业成功后删除它。</li></ul><p id="a628" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">剩下的工作是一个常规的pod模板。</p><h1 id="8641" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">逮到你了</h1><h2 id="65c4" class="na lj iq bd lk nb nc dn lo nd ne dp ls lf nf ng lw lg nh ni ma lh nj nk me nl bi translated">头盔挂钩抓到你了</h2><p id="84ea" class="pw-post-body-paragraph jq jr iq jt b ju mg jw jx jy mh ka kb lf mi ke kf lg mj ki kj lh mk km kn ko ij bi translated">您的迁移作业很可能需要一些配置和/或机密才能运行(至少需要数据库服务器地址和凭证)，但是该作业将在图表中的所有其他资源之前创建。</p><p id="c546" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这意味着我们的作业将无法挂载图表创建的<code class="fe kp kq kr ks b">configmap</code>。我们需要创建一个实现相同钩子的<code class="fe kp kq kr ks b">configmap</code>。这里有一个<code class="fe kp kq kr ks b">configmap</code>的例子:</p><pre class="ku kv kw kx gt nm ks nn no aw np bi"><span id="5aa3" class="na lj iq ks b gy nq nr l ns nt"><strong class="ks ir">apiVersion</strong>: v1<br/><strong class="ks ir">kind</strong>: ConfigMap<br/><strong class="ks ir">metadata</strong>:<br/>  <strong class="ks ir">name</strong>: db-migrations<br/><strong class="ks ir">annotations</strong>:<br/>    <strong class="ks ir">"helm.sh/hook": </strong>pre-install,pre-upgrade<br/>    <strong class="ks ir">"helm.sh/hook-weight": </strong>"-10" // we use a smaller weight so it's<br/>                                 // created before the job    <br/>    <strong class="ks ir">"helm.sh/hook-delete-policy": </strong>hook-succeeded<br/><strong class="ks ir">data</strong>:<br/>  DB_ADDR: {{ .Values.db.addr }}<br/>  DB_NAME: {{ .Values.db.name }}</span></pre><h2 id="9128" class="na lj iq bd lk nb nc dn lo nd ne dp ls lf nf ng lw lg nh ni ma lh nj nk me nl bi translated">部署策略和回滚</h2><p id="c4cf" class="pw-post-body-paragraph jq jr iq jt b ju mg jw jx jy mh ka kb lf mi ke kf lg mj ki kj lh mk km kn ko ij bi translated">默认情况下，Kubernetes在更新部署时应用滚动更新策略。这意味着在部署过程中，会有pods同时运行应用程序的旧版本和新版本。<strong class="jt ir">这将要求所有迁移至少向后兼容</strong>以前的版本。</p><p id="bb23" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果您需要使用<code class="fe kp kq kr ks b">helm rollback</code>命令回滚到应用程序的先前版本，那么您正在重新部署的版本的迁移作业将再次运行。在回滚期间尝试将<em class="js">向下</em>迁移到模式的先前版本可能会导致现有的pod失败。最后，如果您必须回滚到一个更旧的版本，您需要确保当前模式与您计划回滚到的版本向后兼容。</p></div></div>    
</body>
</html>