<html>
<head>
<title>Antifragility in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特斯的抗脆性</h1>
<blockquote>原文：<a href="https://itnext.io/antifragility-in-kubernetes-bcac9ec5baaf?source=collection_archive---------7-----------------------#2018-03-14">https://itnext.io/antifragility-in-kubernetes-bcac9ec5baaf?source=collection_archive---------7-----------------------#2018-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bb2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何从波动、随机和无序中获益。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/acdfd358846d2b912798ed644b1ae79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UrNKd7zIrrsoTzRh."/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@arthuryeti" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@arthuryeti</a></figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="e30b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多工程师采取非常乐观的方法，认为他们的服务将完美无缺地工作，他们倾向于从一开始就以最终形状为目标，而不考虑可能导致灾难的潜在变化或不可预测的事件，而不是利用它并使他们的服务更加强大…</p><p id="e62a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题来了——如何从波动性、随机性和无序中获益？</p><p id="91fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多<a class="ae lb" href="http://lmgtfy.com/?q=antifrafile+systems" rel="noopener ugc nofollow" target="_blank">的博客文章</a>是关于防脆弱系统的，但是没有多少提到现有的技术。所以让我们把一切都包起来:)</p><h1 id="779b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">抗脆弱剂</h1><p id="8cd3" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">抗脆弱这个词是由<a class="ae lb" href="http://Nassim Nicholas Taleb" rel="noopener ugc nofollow" target="_blank">纳西姆·尼古拉斯·塔勒布</a>在他的书<a class="ae lb" href="https://www.amazon.com/Antifragile-Things-That-Disorder-Incerto/dp/0812979680" rel="noopener ugc nofollow" target="_blank">抗脆弱:从无序中获得的东西</a>中引入的。</p><blockquote class="mm mn mo"><p id="1e22" class="jn jo mp jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated">有些东西受益于冲击，它们在暴露于波动、<a class="ae lb" href="https://en.wikipedia.org/wiki/Randomness" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a>、无序、应激源和爱情冒险、<a class="ae lb" href="https://en.wikipedia.org/wiki/Risk" rel="noopener ugc nofollow" target="_blank">风险</a>和<a class="ae lb" href="https://en.wikipedia.org/wiki/Uncertainty" rel="noopener ugc nofollow" target="_blank">不确定性</a>时茁壮成长。然而，尽管这种现象无处不在，却没有与脆弱完全相反的词。让我们称之为抗脆弱。抗碎性超出了弹性或坚固性。有弹性的抵抗冲击并保持不变；抗碎性变得更好。</p></blockquote><h1 id="f100" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">库伯内特斯的抗脆性</h1><p id="e047" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我们如何衡量我们服务的脆弱性？万一失败会怎么样？Kubernetes如何提供帮助？</p><p id="51a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以归结为抗脆弱性的几个关键概念。</p><h2 id="44e5" class="mt lk iq bd ll mu mv dn lp mw mx dp lt jy my mz lx kc na nb mb kg nc nd mf ne bi translated">简单</h2><p id="69d8" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">复杂的系统很难监控和维护。系统越大，就越难改变。此外，任何意外事件都可能导致副作用或级联故障，这可能很难跟踪和调试。</p><p id="b672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes提供了名为<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" rel="noopener ugc nofollow" target="_blank"> Pod </a>的部署单元，它是一组运行在相同节点上的容器，具有共同的生命周期。我们可以有把握地假设一个容器应该负责一件特定的事情(保持简单)。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="2cbd" class="mt lk iq ng b gy nk nl l nm nn"><strong class="ng ir">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: web-app<br/>spec:<br/>  containers:<br/>    - name: web<br/>      image: nginx<br/>      ports:<br/>      - name: web<br/>        containerPort: 80<br/>        protocol: TCP<br/>    - name: database<br/>      image: postgres<br/>      ports:<br/>      - name: psql<br/>        containerPort: 5432<br/>        protocol: TCP</strong></span></pre><p id="c85b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，Kubernetes资源的类型更多，如<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> Deployment </a>、<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" rel="noopener ugc nofollow" target="_blank"> DaemonSet </a>、<a class="ae lb" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">statefullset</a>等。</p><h2 id="c807" class="mt lk iq bd ll mu mv dn lp mw mx dp lt jy my mz lx kc na nb mb kg nc nd mf ne bi translated">可观察性</h2><p id="b8c4" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">监控和日志记录是理解事物如何工作和执行的关键机制，尤其是在像Kubernetes这样的动态和分布式环境中。</p><p id="dc7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes上运行的每个容器都应该在stdout或stderr上记录应用程序输出。它有助于有单独的存储空间，并在我们的集装箱损坏时提供可视性。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="756c" class="mt lk iq ng b gy nk nl l nm nn">I0221 00:40:02.060314 version: 1.14.8<br/>I0221 00:40:02.133217 Using configuration read from directory: /kube-dns-config with period 10s<br/>I0221 00:40:02.133299 FLAG: --alsologtostderr="false"<br/>I0221 00:40:02.133312 FLAG: --config-dir="/kube-dns-config"<br/>I0221 00:40:02.133320 FLAG: --config-map=""<br/>I0221 00:40:02.133325 FLAG: --config-map-namespace="kube-system"<br/>I0221 00:40:02.133331 FLAG: --config-period="10s"<br/>I0221 00:40:02.133338 FLAG: --dns-bind-address="0.0.0.0"<br/>I0221 00:40:02.133344 FLAG: --dns-port="10053"<br/>I0221 00:40:02.133353 FLAG: --domain="cluster.local."<br/>I0221 00:40:02.133361 FLAG: --federations=""<br/>I0221 00:40:02.133368 FLAG: --healthz-port="8081"<br/>I0221 00:40:02.133373 FLAG: --initial-sync-timeout="1m0s"<br/>I0221 00:40:02.133378 FLAG: --kube-master-url=""<br/>I0221 00:40:02.133385 FLAG: --kubecfg-file=""<br/>I0221 00:40:02.133390 FLAG: --log-backtrace-at=":0"<br/>I0221 00:40:02.133400 FLAG: --log-dir=""<br/>I0221 00:40:02.133406 FLAG: --log-flush-frequency="5s"<br/>I0221 00:40:02.133411 FLAG: --logtostderr="true"<br/>I0221 00:40:02.133416 FLAG: --nameservers=""<br/>I0221 00:40:02.133421 FLAG: --stderrthreshold="2"<br/>I0221 00:40:02.133426 FLAG: --v="2"<br/>I0221 00:40:02.133431 FLAG: --version="false"<br/>I0221 00:40:02.133440 FLAG: --vmodule=""<br/>I0221 00:40:02.133520 Starting SkyDNS server (0.0.0.0:10053)<br/>I0221 00:40:02.133827 Skydns metrics enabled (/metrics:10055)<br/>I0221 00:40:02.133836 Starting endpointsController<br/>I0221 00:40:02.133841 Starting serviceController</span></pre><p id="fdbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Prometheus 是一个开源系统监控和警报工具包，最初在<a class="ae lb" href="http://soundcloud.com/" rel="noopener ugc nofollow" target="_blank"> SoundCloud </a>构建。与<a class="ae lb" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>结合使用，它提供了Kubernetes集群运行状况的完整可见性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/0f1472516bc82a7791d1d0e61f651600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eBJf5X-X3HSE16q-."/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Kubernetes Pod Metricsby <a class="ae lb" href="https://grafana.com/orgs/orezi" rel="noopener ugc nofollow" target="_blank">矿石Olarewaju </a></figcaption></figure><h2 id="e841" class="mt lk iq bd ll mu mv dn lp mw mx dp lt jy my mz lx kc na nb mb kg nc nd mf ne bi translated">公差和误差</h2><blockquote class="mm mn mo"><p id="b79a" class="jn jo mp jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated">想想大自然母亲不仅仅是“安全的”它在破坏和取代、选择和重组方面咄咄逼人。考虑到完美的稳健性无法实现，我们需要一种机制，通过这种机制，系统可以利用随机事件、不可预测的冲击、应激源和波动性，而不是遭受这些因素的影响，不断自我再生。</p></blockquote><p id="5ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样的原则也适用于Kubernetes环境，当某个节点由于某种原因死亡时，所有的容器都被重新分配给其他健康的节点，顺便说一下，平衡资源利用率。</p><p id="0257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就容器而言，有<a class="ae lb" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" rel="noopener ugc nofollow" target="_blank">活性和准备就绪探测器</a>。如果应用程序无法取得进展，活跃度负责重新启动。准备就绪是确定集装箱何时准备好开始接受流量。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="44fb" class="mt lk iq ng b gy nk nl l nm nn"><strong class="ng ir">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  labels:<br/>    test: liveness<br/>  name: liveness-exec<br/>spec:<br/>  containers:<br/>  - name: liveness<br/>    image: k8s.gcr.io/busybox<br/>    args:<br/>    - /bin/sh<br/>    - -c<br/>    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600<br/>    livenessProbe:<br/>      exec:<br/>        command:<br/>        - cat<br/>        - /tmp/healthy<br/>      initialDelaySeconds: 5<br/>      periodSeconds: 5<br/>    readinessProbe:<br/>      exec:<br/>        command:<br/>        - cat<br/>        - /tmp/healthy<br/>      initialDelaySeconds: 5<br/>      periodSeconds: 5</strong></span></pre><p id="25cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个重要的技术是故障注入，有时是混沌工程方法的一部分，让系统进化并在混沌中生存。</p><blockquote class="mm mn mo"><p id="f1ff" class="jn jo mp jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated">混沌工程是一门在分布式系统上进行实验的学科<br/>,目的是建立对系统能力的信心<br/>,以抵御生产中的动荡条件。</p><p id="55ff" class="jn jo mp jp b jq jr js jt ju jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj kk ij bi translated"><a class="ae lb" href="http://principlesofchaos.org/" rel="noopener ugc nofollow" target="_blank">混沌工程原理</a></p></blockquote><p id="3dae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">kube-monkey 是针对Kubernetes集群的<a class="ae lb" href="https://github.com/Netflix/chaosmonkey" rel="noopener ugc nofollow" target="_blank">网飞混沌猴</a>的实现。它随机删除集群中的Kubernetes pods，鼓励和验证故障恢复服务的开发。</p><h2 id="2b49" class="mt lk iq bd ll mu mv dn lp mw mx dp lt jy my mz lx kc na nb mb kg nc nd mf ne bi translated">分散和孤立</h2><p id="6e76" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">分布式系统类似于活的有机体，如果过度补偿到位，显然可以更好地响应意外事件。结合适当的隔离，<a class="ae lb" href="https://en.wikipedia.org/wiki/Blast_radius" rel="noopener ugc nofollow" target="_blank">爆炸半径</a>是有限的。</p><p id="8b99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes提供了<a class="ae lb" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a>的概念，我们可以将它们视为具有基于基于属性的访问控制(<a class="ae lb" href="https://kubernetes.io/docs/admin/authorization/abac/" rel="noopener ugc nofollow" target="_blank"> ABAC </a>)或更细粒度的基于角色的访问控制(<a class="ae lb" href="https://kubernetes.io/docs/admin/authorization/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>)的访问控制策略的作用域虚拟集群。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="1836" class="mt lk iq ng b gy nk nl l nm nn"><strong class="ng ir">kind: Role<br/>apiVersion: rbac.authorization.k8s.io/v1<br/>metadata:<br/>  namespace: default<br/>  name: pod-reader<br/>rules:<br/>- apiGroups: [""] <em class="mp"># "" indicates the core API group</em><br/>  resources: ["pods"]<br/>  verbs: ["get", "watch", "list"]</strong></span></pre><p id="e314" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还可以使用<a class="ae lb" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>在网络层上限制特定的名称空间，网络策略说明允许哪些组的pod相互通信以及与其他网络端点通信。</p><pre class="km kn ko kp gt nf ng nh ni aw nj bi"><span id="4ddc" class="mt lk iq ng b gy nk nl l nm nn"><strong class="ng ir">apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  name: test-network-policy<br/>  namespace: default<br/>spec:<br/>  podSelector:<br/>    matchLabels:<br/>      role: db<br/>  policyTypes:<br/>  - Ingress<br/>  - Egress<br/>  ingress:<br/>  - from:<br/>    - ipBlock:<br/>        cidr: 172.17.0.0/16<br/>        except:<br/>        - 172.17.1.0/24<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          project: myproject<br/>    - podSelector:<br/>        matchLabels:<br/>          role: frontend<br/>    ports:<br/>    - protocol: TCP<br/>      port: 6379<br/>  egress:<br/>  - to:<br/>    - ipBlock:<br/>        cidr: 10.0.0.0/24<br/>    ports:<br/>    - protocol: TCP<br/>      port: 5978</strong></span></pre><h2 id="db71" class="mt lk iq bd ll mu mv dn lp mw mx dp lt jy my mz lx kc na nb mb kg nc nd mf ne bi translated">非预测</h2><p id="6b85" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">有时在不确定的情况下很难做出决策，例如，我们应该分配多少资源来处理意外的高流量？我们需要多少运行在云中的实例？不幸的是，我们无法预测罕见事件的发生。</p><p id="9c44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes的优势之一是能够根据特殊情况(例如使用<a class="ae lb" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank"> cluster-autoscaler </a>调整节点数量，包括删除未充分利用的节点)来调整资源使用情况。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/8a50dc7725777b65f070a20299e21898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QFizRfRc6WLxCH8V."/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Kubernetes集群自动缩放器(通过Prometheus)由<a class="ae lb" href="https://grafana.com/orgs/bookchair" rel="noopener ugc nofollow" target="_blank"> bookchair </a></figcaption></figure><p id="e868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就应用层的自动扩展而言，我们可以使用<a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>，它可以根据资源利用率或自定义指标自动缩放Pod的数量。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3940383aed6d7757f40358f7e6ad21aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*yMeB6GZ0VK-iS16kiikpSQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/run-application/horizontal-pod-auto scale/</a></figcaption></figure><h1 id="cd73" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="0c65" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">让我们诚实地说:)这是不可能的，但经常和快速的失败可以使我们的系统更能抵抗错误。</p><p id="184b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了减少脆弱性，您应该不断地强调您的部署过程和运行在Kubernetes之上的服务。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><div class="km kn ko kp gt nr"><a href="https://twitter.com/antoniaklja" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Bartek Antoniak (@antoniaklja) |推特</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Bartek Antoniak的最新推文(@antoniaklja)。软件工程师、开发人员和安全爱好者</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">twitter.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kv nr"/></div></div></a></div></div></div>    
</body>
</html>