<html>
<head>
<title>Docker Over SSH</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SSH上的Docker</h1>
<blockquote>原文：<a href="https://itnext.io/docker-over-ssh-51ab25a79f2e?source=collection_archive---------0-----------------------#2019-11-18">https://itnext.io/docker-over-ssh-51ab25a79f2e?source=collection_archive---------0-----------------------#2019-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/45f8ccea051a4dbfc407c13b03fc8a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zFfhYaH7jIadUNY42Ns7Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Abigail Lynn 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="57c8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，我的一个副业项目遇到了挑战。我需要将我在一台机器上构建的docker容器转移到另一台可以通过SSH访问的机器上。我不想把我的容器推到一个公共的docker注册中心，或者设置我自己的私有注册中心。</p><h1 id="d7dd" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用内置工具</h1><p id="eb89" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">没多久就找到了栈溢出的答案(<a class="ae jg" href="https://stackoverflow.com/a/26226261/272958" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/26226261/272958</a>)</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7000" class="mq lf jj mm b gy mr ms l mt mu">docker save &lt;image&gt; | bzip2 | \<br/>     ssh user@host 'bunzip2 | docker load'</span></pre><p id="a7db" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来分解一下:</p><ol class=""><li id="96bc" class="mv mw jj ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated"><code class="fe ne nf ng mm b">docker save &lt;image&gt;</code>获取所有图像数据，并将其连同其标签一起序列化为二进制数据流。</li><li id="84e0" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated"><code class="fe ne nf ng mm b">docker load</code>获取二进制数据流并将其反序列化为带有标签的图像。</li><li id="3cf8" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated"><code class="fe ne nf ng mm b">bzip2</code>压缩流，<code class="fe ne nf ng mm b">bunzip2</code>解压缩流。</li><li id="70da" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated"><code class="fe ne nf ng mm b">ssh user@host 'some command'</code> ssh进入远程主机并运行指定的命令。</li></ol><p id="b923" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原来<code class="fe ne nf ng mm b">docker load</code>能够自动解压缩<code class="fe ne nf ng mm b">bzip</code>的内容，所以您可以将命令简化为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8578" class="mq lf jj mm b gy mr ms l mt mu">docker save &lt;image&gt; | bzip2 | \<br/>  ssh user@host 'docker load'</span></pre><p id="d5b1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以删除<code class="fe ne nf ng mm b">bzip2</code>，但是docker图像通常很大，而且<code class="fe ne nf ng mm b">bzip2</code>的压缩节省了大量的带宽。</p><p id="7029" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我仍然有一个问题。我是通过一个缓慢的3G互联网连接做这些事情的，远程主机已经有了我想要推送的图像中的大多数层，我只需要推送包含我的应用程序逻辑的微小的新层。</p><h1 id="1323" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用层推动</h1><p id="6664" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">再研究一下，我发现了<a class="ae jg" href="https://pypi.org/project/docker-push-ssh/" rel="noopener ugc nofollow" target="_blank"> docker-push-ssh </a>。使用此命令，您可以:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bb5f" class="mq lf jj mm b gy mr ms l mt mu">docker-push-ssh user@host &lt;image&gt;</span></pre><p id="7e24" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它只传输需要的层。为此，它:</p><ol class=""><li id="e793" class="mv mw jj ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">在本地机器上建立一个临时的docker注册表——这非常容易，因为在docker映像中有一个docker注册表，名为<code class="fe ne nf ng mm b">registry:2</code></li><li id="61ea" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated">对本地注册表执行一个<code class="fe ne nf ng mm b">docker push</code>操作。这很快，因为它遍布本地机器的网络。</li><li id="1ad8" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated">使用SSH来代理远程服务器上的端口，以便它连接到本地机器上的代理。</li><li id="12d9" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated">在远程服务器上执行<code class="fe ne nf ng mm b">docker pull</code>。这个pull是在SSH隧道上运行的，但是docker pull足够聪明，只拉它还没有的层。</li></ol><figure class="mh mi mj mk gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5e8e2f48f06142c8f615549e61a1a59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*HQnutj3kBekbXpuezJE8Ww.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">SSH上的Docker图</figcaption></figure><h1 id="edb0" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我自己的解决方案</h1><p id="6d3a" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这是一个伟大的想法，但我有三个问题:</p><ol class=""><li id="1f17" class="mv mw jj ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">它是用Python写的，需要Python 2.7，我不想依赖已经安装的Python 2.7。</li><li id="55a2" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated">它已经有一段时间没有更新了，这通常不是问题，但是考虑到它依赖于旧版本的Python，这就有点让人担心了。</li><li id="5add" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld na nb nc nd bi translated">不清楚它在远程机器上需要的特权级别。我希望能够锁定一些东西，这样做推送的用户除了将指定的docker图像推送到远程机器之外不能做任何事情。</li></ol><p id="aa46" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这一切，我决定在Node.js中创建一个名为<a class="ae jg" href="https://github.com/ForbesLindesay/docker-over-ssh" rel="noopener ugc nofollow" target="_blank"> docker-over-ssh </a>的CLI。尽管名字如此，<a class="ae jg" href="https://github.com/ForbesLindesay/docker-over-ssh" rel="noopener ugc nofollow" target="_blank"> docker-over-ssh </a>实际上是完全与传输无关的。它只需要一种通过stdin和stdout与自身的远程实例进行通信的方法。要使用它，您需要在本地和远程机器上安装<code class="fe ne nf ng mm b">docker-over-ssh</code>。然后你可以运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0978" class="mq lf jj mm b gy mr ms l mt mu">docker-over-ssh push &lt;image&gt; \<br/>  ssh user@host "docker-over-ssh pull &lt;image&gt;"</span></pre><p id="c158" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该图看起来与上一个解决方案完全相同。</p><p id="a6e6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ne nf ng mm b">docker-over-ssh push</code>命令启动一个本地docker注册表，将映像推送到其中，然后运行“子命令”(在本例中为<code class="fe ne nf ng mm b">ssh user@host "docker-over-ssh pull &lt;image&gt;"</code>)，并将tcp流量从该子命令的stdio代理到本地docker注册表。</p><p id="2b5e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ne nf ng mm b">docker-over-ssh pull &lt;image&gt;</code>命令启动一个本地TCP代理(用几行node.js代码编写),并将该代理连接到stdio，这样它就可以与本地docker注册表对话。然后它指向本地注册表运行<code class="fe ne nf ng mm b">docker pull</code>。只有新的层被转移，这使得一切都非常有效。</p><p id="3345" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户需要的唯一权限是能够在远程机器上运行<code class="fe ne nf ng mm b">docker-over-ssh pull &lt;image&gt;</code>，其他什么都不需要。</p><h1 id="43ca" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与CircleCI一起使用</h1><p id="2753" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这一点上，我有一个工作解决方案，但我想自动化这一点，以便部署可以从CircleCI完成。<a class="ae jg" href="https://circleci.com/docs/2.0/add-ssh-key/" rel="noopener ugc nofollow" target="_blank">向CircleCI </a>添加一个SSH密钥相当容易。挑战在于如何在复杂的docker网络设置中实现这一点:</p><ul class=""><li id="7713" class="mv mw jj ki b kj kk kn ko kr mx kv my kz mz ld nn nb nc nd bi translated">您的本地代码(即终止代理的node.js代码)不能与使用<code class="fe ne nf ng mm b">docker run</code>运行的容器对话。</li><li id="d654" class="mv mw jj ki b kj nh kn ni kr nj kv nk kz nl ld nn nb nc nd bi translated"><code class="fe ne nf ng mm b">docker</code>守护进程(用于运行<code class="fe ne nf ng mm b">docker push</code>)无法与作为主CircleCI作业的服务运行的容器对话。</li></ul><p id="9a0e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我找不到任何可行的方法来直接解决这些问题，但是我发现了<a class="ae jg" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> NGROK </a>，它使得创建一个代理本地服务的互联网可访问地址变得非常容易。有了这个，我可以告诉CircleCI启动一个docker注册表作为我构建的服务，然后使用<a class="ae jg" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>启动一个临时代理，将其暴露给<code class="fe ne nf ng mm b">docker</code>守护进程。它甚至支持使用用户名和密码(我会动态自动生成)来保护它，以确保一切都很安全。</p><p id="5c70" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我所要做的就是更新CircleCI配置:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a2d1" class="mq lf jj mm b gy mr ms l mt mu">docker:<br/>  - image: circleci/node:12<br/>    environment:<br/>      LOCAL_DOCKER_REGISTRY_PORT: '5000'<br/>  - image: registry:2</span></pre><p id="e3b3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并将<code class="fe ne nf ng mm b">DOCKER_REGISTRY_NGROK</code>环境变量设置为我的API key for ngrok，可以免费获得。</p><p id="ed2d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我在<a class="ae jg" href="https://github.com/ForbesLindesay/docker-over-ssh" rel="noopener ugc nofollow" target="_blank"> docker-over-ssh </a>中添加了一些代码来处理这两个环境变量。</p><h1 id="f4b8" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="533b" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我做这一切的原因是试图建立一个<a class="ae jg" href="http://dokku.viewdocs.io/dokku/" rel="noopener ugc nofollow" target="_blank"> dokku </a>服务器，我可以在其中运行许多辅助项目，并避免在heroku上为很少使用的东西花费大量金钱。我对这个问题的解决方案相当满意，但我现在决定调查Kubernetes，因为数字海洋有一个托管的Kubernetes服务，似乎非常实惠。这将需要我想出运行一个具有某种认证/授权的持久docker注册表。如果你对一篇关于我如何做到这一点的文章感兴趣，请记得点击“关注”按钮。</p></div></div>    
</body>
</html>