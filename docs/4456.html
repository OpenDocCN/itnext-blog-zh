<html>
<head>
<title>Build a Shopping Cart with React, Redux, and React-DnD — PART 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React、Redux和React-DnD构建购物车—第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-shopping-cart-with-react-redux-and-react-dnd-part-3-f1e1e8265d14?source=collection_archive---------2-----------------------#2020-07-04">https://itnext.io/build-a-shopping-cart-with-react-redux-and-react-dnd-part-3-f1e1e8265d14?source=collection_archive---------2-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d6617435532384981a028eaf870649ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_K8fX6RIe3lyWpOxJFlZTQ.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">拖放购物车</figcaption></figure><p id="0169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated"><span class="l kx ky kz bm la lb lc ld le di"> W </span>欢迎来到<strong class="ka ir">第3部分</strong>构建一个利用<a class="ae lf" href="https://react-dnd.github.io/react-dnd/about" rel="noopener ugc nofollow" target="_blank"> React DnD </a>的简单购物车。如果你还没有看完第2部分，你可以在这里找到它。同样，如果你想从第3部分开始构建，确保从这个<a class="ae lf" href="https://github.com/Eyongkevin/shopping-list---React-Redux-DragandDrop/tree/default-shopping-list" rel="noopener ugc nofollow" target="_blank">分支</a>克隆并下载第2部分的代码，因为第3部分是一个延续。</p><h1 id="5b78" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">入门指南</h1><p id="19be" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在本文中，我们将继续通过将React DnD集成到React应用程序中来构建我们的购物车。</p><blockquote class="mj"><p id="f4f5" class="mk ml iq bd mm mn mo mp mq mr ms kv dk translated"><em class="mt">本节的所有代码都可以在</em> <a class="ae lf" href="https://github.com/Eyongkevin/shopping-list---React-Redux-DragandDrop/tree/React-Drag-and-Drop" rel="noopener ugc nofollow" target="_blank"> <em class="mt">分支这里</em> </a>找到</p></blockquote><blockquote class="mu mv mw"><p id="9fae" class="jy jz mx ka b kb my kd ke kf mz kh ki na nb kl km nc nd kp kq ne nf kt ku kv ij bi translated">React DnD是一套React工具，帮助你建立复杂的拖放界面，同时保持组件的解耦。它非常适合Trello和Storify等应用程序，在这些应用程序中，拖动可以在应用程序的不同部分之间传输数据，并且组件会改变它们的外观和应用程序状态以响应拖放事件</p></blockquote><h1 id="30c5" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">安装反应DnD</h1><p id="8ae7" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">移动到应用程序的根目录，在终端中运行命令</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="644f" class="np lh iq nl b gy nq nr l ns nt">yarn add react-dnd react-dnd-html5-backend</span></pre><p id="77b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以注意到第二个包<code class="fe nu nv nw nl b">react-dnd-html5-backend </code>允许React DnD使用<a class="ae lf" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop" rel="noopener ugc nofollow" target="_blank">默认后台的HTML5拖放API </a>。你也可以选择使用第三方后端，比如<a class="ae lf" href="https://npmjs.com/package/react-dnd-touch-backend" rel="noopener ugc nofollow" target="_blank">触控后端</a>。</p><h1 id="9c3e" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">React DnD概述</h1><p id="2265" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">React DnD库提供了三个高阶组件:</p><ul class=""><li id="aa20" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated"><strong class="ka ir"> DragSource </strong>:返回给定组件的增强版本，增加了“可拖动”组件的行为。</li><li id="de7f" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><strong class="ka ir"> DropTarget </strong>:返回给定组件的增强版本，添加了处理被拖入其中的兼容组件的行为。</li><li id="8008" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">DndProvider :它为您的应用程序提供反应DnD功能。它必须包装发生拖放交互的父组件，并通过<code class="fe nu nv nw nl b">backend</code> prop注入后端。但是它可能被注入了一个<code class="fe nu nv nw nl b">window</code>对象</li></ul><blockquote class="mu mv mw"><p id="115b" class="jy jz mx ka b kb kc kd ke kf kg kh ki na kk kl km nc ko kp kq ne ks kt ku kv ij bi translated">高阶组件是JavaScript函数，它接受一个组件作为参数，并返回该组件的增强版本，增加了功能。</p></blockquote><h1 id="a3a7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">我们想要建造的东西</h1><p id="8a03" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">我们希望将React-DnD集成到我们的React应用程序中，以便拖动可以在应用程序的不同部分之间传输数据。使用React DnD可以让我们以“React方式”工作，同时支持单向数据流，定义源，并将目标逻辑作为纯数据删除，以及其他好处。</p><p id="3da7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了主要应用组件之外，该应用还包括三个重要组件:</p><ul class=""><li id="cb53" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated"><strong class="ka ir"> Phone </strong>组件:它将被DragSource增强，使其可拖动</li><li id="a352" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">ShoppingCart 组件:DropTarget将增强这一功能，使其能够处理拖入其中的兼容组件。</li><li id="5f5a" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><strong class="ka ir">容器</strong>组件:该组件包含电话和购物车组件，并由DndProvider增强，以提供电话和购物车之间的拖放功能。</li></ul><p id="abca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated"><span class="l kx ky kz bm la lb lc ld le di"> C </span> ontainer.js</p><p id="bd48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从处理容器组件开始，所有的拖放交互都将在这里发生。移至<code class="fe nu nv nw nl b">components/Container.js</code>，将其代码替换为以下内容:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">src/components/容器. js</figcaption></figure><p id="66a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们导入了我们的后端<code class="fe nu nv nw nl b">HTML5Backend</code>和高阶组件<code class="fe nu nv nw nl b">DndProvider</code>,我们用它们在<strong class="ka ir">行26 </strong>处封装我们的电话和购物车组件</p><h1 id="5f1c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">拖放源和拖放目标</h1><p id="e61d" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在实现剩下的两个组件之前，让我们先了解一些概念。如上所述，DragSource和DropTarget是高阶组件。前者将用于增强我们的电话组件，使其可拖动，而后者将用于增强ShoppingCart组件，使其能够处理拖动到其中的兼容组件。</p><p id="8d2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DragSource和DropTarget都需要一些需要进一步解释的设置。</p><h2 id="f574" class="np lh iq bd li on oo dn lm op oq dp lq kj or os lu kn ot ou ly kr ov ow mc ox bi translated"><strong class="ak">类型</strong></h2><p id="c5f2" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">它允许您指定哪些拖动源和拖放目标是兼容的。拖放目标只接受相同类型的拖动源，因此唯一标识每个拖动源非常重要。</p><h2 id="3b10" class="np lh iq bd li on oo dn lm op oq dp lq kj or os lu kn ot ou ly kr ov ow mc ox bi translated"><strong class="ak">规格对象</strong></h2><p id="1099" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">它描述了增强组件如何对拖放事件做出“反应”。它是一个普通的JS对象，具有在发生拖放交互时调用的函数，比如<code class="fe nu nv nw nl b">beginDrag</code>和<code class="fe nu nv nw nl b">endDrag</code>(对于DragSource)，以及<code class="fe nu nv nw nl b">canDrag</code>和<code class="fe nu nv nw nl b">onDrop</code>(对于DropTarget)。</p><h2 id="8eb9" class="np lh iq bd li on oo dn lm op oq dp lq kj or os lu kn ot ou ly kr ov ow mc ox bi translated"><strong class="ak">采集功能</strong></h2><p id="cfd2" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">正如React组件通过props相互传递信息一样，<code class="fe nu nv nw nl b">dragSource</code>和<code class="fe nu nv nw nl b">dropTarget</code>包装器也是这样将props注入到它们增强的组件中的。但是，反应DnD使用收集功能，让你控制如何和哪些道具将被注入。这给了你很大的权力，包括在道具被注入之前对其进行预处理的能力。</p><p id="067c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当发生拖放交互时，React DnD库调用收集函数，并向其传递两个参数:</p><ul class=""><li id="5820" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated"><strong class="ka ir">连接器:</strong>后端'【T6]'处理DOM事件，但是组件使用React来描述DOM。连接器将这两者链接起来，以便在呈现函数中将一个预定义的角色(拖动源、拖动预览或拖放目标)分配给DOM。它作为collect函数的第一个参数传递，并确定该项是否是预定义的角色之一</li><li id="51b4" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><strong class="ka ir"> Monitor </strong>:拖放是有状态的，以确定拖动操作是否正在进行，或者是否有任何当前项目或类型以及其他属性与该过程相关联。React DnD通过监视器将这些状态暴露给组件，并允许您更新组件属性以响应拖放状态的变化。例如，有一个状态<code class="fe nu nv nw nl b">isDragging</code>，它的值指示一个可拖动的项目是否被拖动，还有一个状态<code class="fe nu nv nw nl b">canDrop</code>，它指示一个组件是否可以处理一个被拖动的项目(如果兼容的话)。您必须定义一个收集函数，该函数将从监视器中检索相关的状态，React DnD负责调用该函数并将其返回值合并到组件的props中。</li></ul><blockquote class="mu mv mw"><p id="bccc" class="jy jz mx ka b kb kc kd ke kf kg kh ki na kk kl km nc ko kp kq ne ks kt ku kv ij bi translated"><strong class="ka ir">拖动源</strong>和<strong class="ka ir">放下目标</strong>是React DnD的主要抽象单位。它们确实将类型、副作用和收集功能与您的组件联系在一起。</p></blockquote><p id="a8eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看上面的在实践中是如何运作的。</p><p id="2100" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">onstants.js</p><p id="60f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这里定义我们的<strong class="ka ir">类型</strong>常量。如上所述，<strong class="ka ir">类型</strong>允许您指定哪些拖动源和拖放目标是兼容的。</p><p id="0d48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建文件<code class="fe nu nv nw nl b">components/Constants.js</code>并插入代码；</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="58eb" class="np lh iq nl b gy nq nr l ns nt">import React from 'react';</span><span id="95b2" class="np lh iq nl b gy oy nr l ns nt">export const ItemTypes = {<br/>    PHONE: 'phone'<br/>}</span></pre><p id="cbd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码是一个JavaScript模块，它导出一个带有PHONE常量的对象。</p><p id="5b36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">hoppingCart.js</p><p id="22ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，我们的ShoppingCart组件将通过<code class="fe nu nv nw nl b">DropTarget</code>得到增强，使其能够处理拖入其中的兼容组件。</p><blockquote class="mu mv mw"><p id="f3c3" class="jy jz mx ka b kb kc kd ke kf kg kh ki na kk kl km nc ko kp kq ne ks kt ku kv ij bi translated">所有代码应该在<code class="fe nu nv nw nl b">components/ShoppingCart.js</code></p></blockquote><p id="d991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们进口所有我们需要的东西</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="91cb" class="np lh iq nl b gy nq nr l ns nt">import React, { Component } from 'react'<br/>import { DropTarget } from 'react-dnd'</span><span id="e0e7" class="np lh iq nl b gy oy nr l ns nt">import Phone from './Phone'<br/>import { ItemTypes } from './Constants'</span></pre><p id="0959" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们定义我们的<strong class="ka ir">规范对象</strong>，它将描述放置目标如何对放置事件做出反应(当拖动源被放置时调用)。其他事件也是可能的</p><ul class=""><li id="79b2" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated"><strong class="ka ir">悬停</strong>:当一个项目悬停在拖放目标上时调用。</li><li id="a305" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><strong class="ka ir"> canDrop </strong>:当放置目标能够接受项目时调用。</li></ul><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="dcb9" class="np lh iq nl b gy nq nr l ns nt">// DnD Spec<br/>const ShoppingCartSpec = {<br/>    drop(){<br/>        return { name: 'ShoppingCart'}<br/>    }<br/>}</span></pre><p id="c67c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，它的反应是返回一个字符串。我们将在稍后的电话组件(拖动源)中使用这个返回值。</p><p id="36c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将实现<strong class="ka ir">收集函数</strong>，这将让我们将反应DnD连接器和状态映射到组件的道具。我们将在组件中注入三个道具</p><ul class=""><li id="eefa" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated"><strong class="ka ir"> connectDropTarget </strong>:用于将放置目标角色分配给组件DOM的一部分</li><li id="bbaf" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><strong class="ka ir"> isOver </strong>:决定一个项目是否悬停在它上面。</li><li id="eae5" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><strong class="ka ir"> canDrop </strong>:确定放置目标是否能够接受该物品。</li></ul><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="ac9a" class="np lh iq nl b gy nq nr l ns nt">// DnD DropTarget - collect<br/>let collect = ( connect, monitor )=&gt;{<br/>    return {<br/>        connectDropTarget: connect.dropTarget(),<br/>        isOver: monitor.isOver(),<br/>        canDrop: monitor.canDrop()<br/>    };<br/>}</span></pre><blockquote class="mu mv mw"><p id="d5fa" class="jy jz mx ka b kb kc kd ke kf kg kh ki na kk kl km nc ko kp kq ne ks kt ku kv ij bi translated">我们可以看到所有事件都来自于<code class="fe nu nv nw nl b">monitor</code></p></blockquote><p id="dd58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们定义了我们的<strong class="ka ir"> spec对象</strong>和<strong class="ka ir"> collect函数</strong>之后，我们现在可以定义我们的ShoppingCart组件了。仍然在<code class="fe nu nv nw nl b">components/ShoppingCart.js</code>中，插入代码</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">src/components/ShoppingCart.js</figcaption></figure><p id="a33d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们解释一下上面的代码中发生了什么；</p><ul class=""><li id="318c" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated">我们的组件现在有三个由我们的<strong class="ka ir"> collect函数注入的道具，</strong> ( <strong class="ka ir"> line 3 </strong>)</li><li id="c3e8" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated"><code class="fe nu nv nw nl b">canDrop</code>和<code class="fe nu nv nw nl b">isOver</code>用于当用户在拖放目标上拖动元素时显示不同的文本和背景颜色。</li><li id="a070" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">我们将div包装在<strong class="ka ir"> connectDropTarget </strong>中，这将把放置目标角色分配给组件的DOM部分(<strong class="ka ir">第15行</strong>)</li><li id="ac31" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">我们使用<code class="fe nu nv nw nl b">DropTarget</code>来增强我们的购物车组件。它采用类型、规范对象和收集函数。(<strong class="ka ir">第十七行</strong>)</li></ul><p id="67e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated"><span class="l kx ky kz bm la lb lc ld le di"> P </span> hone.js</p><p id="3cc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，我们的手机组件将通过<strong class="ka ir"> DragSource </strong>包装器得到增强，使其可拖动。</p><blockquote class="mu mv mw"><p id="e328" class="jy jz mx ka b kb kc kd ke kf kg kh ki na kk kl km nc ko kp kq ne ks kt ku kv ij bi translated">所有代码都应该在<code class="fe nu nv nw nl b"><em class="iq">components/Phone.js</em></code>中</p></blockquote><p id="f0e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们导入我们需要的东西</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="d884" class="np lh iq nl b gy nq nr l ns nt">import React, { Component } from 'react'<br/>import { DragSource } from 'react-dnd';</span><span id="cc02" class="np lh iq nl b gy oy nr l ns nt">import { ItemTypes } from './Constants';</span></pre><p id="88be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们实现我们的<strong class="ka ir">规范对象</strong>，它将描述<strong class="ka ir">拖动源</strong>如何对拖放事件做出“反应”</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="32ee" class="np lh iq nl b gy nq nr l ns nt">// phone DnD spec<br/>const phoneSpec = {<br/>    beginDrag(props){<br/>        console.log("begin drag")<br/>        return{<br/>            name: props.brand<br/>            <br/>        }<br/>    },<br/>    endDrag(props, monitor, component){<br/>        if (monitor.didDrop()){<br/>            const dragItem = monitor.getItem(); // from beginDrag<br/>            const dropResult = monitor.getDropResult();<br/>            // Move action goes here<br/>            console.log("You dropped ", dragItem.name, ' into '+ dropResult.name)<br/>        }else{<br/>            return;<br/>        }<br/>    }<br/>}</span></pre><p id="8969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的代码中，我们的拖动源响应了<code class="fe nu nv nw nl b">beginDrag</code>和<code class="fe nu nv nw nl b">endDrag</code>事件。在前一个事件中，当拖动开始时，我们返回我们手机的品牌，而在后一个事件中，当拖放发生时，我们检查它是否被放在兼容的拖放目标空间中(相同的<strong class="ka ir">类型</strong>)。如果为真，我们从我们放下的元素(从ShoppingCartSpec中的<code class="fe nu nv nw nl b">drop</code>中)获取返回的品牌和返回的字符串，并将两者记录到控制台。</p><p id="503d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将实现<strong class="ka ir">收集函数</strong>，这将允许我们将反应DnD连接器和状态映射到组件的道具。我们将在手机的组件中注入两个道具:<code class="fe nu nv nw nl b">connectDragSource</code>，用于将拖动源角色分配给DOM节点。<code class="fe nu nv nw nl b">isDragging</code>这是来自React DnD的一个状态，指示我们的电话是否被拖动。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f66f" class="np lh iq nl b gy nq nr l ns nt">// phone DragSource collect<br/>let collect = ( connect, monitor ) =&gt;{<br/>    return{<br/>        connectDragSource: connect.dragSource(),<br/>        isDragging: monitor.isDragging()<br/>    }<br/>}</span></pre><p id="2ce8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们定义了我们的<strong class="ka ir">规范对象</strong>和<strong class="ka ir">收集函数</strong>之后，我们现在可以定义我们的电话组件了。仍然在<code class="fe nu nv nw nl b">components/Phone.js</code>中，插入代码</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">src/components/Phone.js</figcaption></figure><p id="57b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们解释一下上面的代码中发生了什么；</p><ul class=""><li id="369d" class="nx ny iq ka b kb kc kf kg kj nz kn oa kr ob kv oc od oe of bi translated">phone组件包含三个道具，从容器组件传递给它的<code class="fe nu nv nw nl b">brand</code>和由collect函数插入的<code class="fe nu nv nw nl b">isDragging</code>、<code class="fe nu nv nw nl b">connectDragSource</code>。</li><li id="bef0" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">我们在内联样式规则中使用道具<code class="fe nu nv nw nl b">isDragging</code>来改变<br/>元素被拖动时的不透明度。我们还用它来设置我们的类名属性</li><li id="9cd1" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">我们使用<code class="fe nu nv nw nl b">connectDragSource</code>将拖动源角色分配给组件DOM的一部分。(<strong class="ka ir">第11行</strong></li><li id="73c4" class="nx ny iq ka b kb og kf oh kj oi kn oj kr ok kv oc od oe of bi translated">我们使用<code class="fe nu nv nw nl b">DragSource</code>来增强我们的电话组件。它采用类型、规范对象和收集函数。(<strong class="ka ir">第29行</strong>)</li></ul><blockquote class="mu mv mw"><p id="1802" class="jy jz mx ka b kb kc kd ke kf kg kh ki na kk kl km nc ko kp kq ne ks kt ku kv ij bi translated">注意这里DropTarget和DragSource接受的<strong class="ka ir">类型</strong>是相同的。这是为了使它们兼容。</p></blockquote><h1 id="0259" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">式样</h1><p id="c780" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">前往这个<a class="ae lf" href="https://github.com/Eyongkevin/shopping-list---React-Redux-DragandDrop/tree/React-Drag-and-Drop" rel="noopener ugc nofollow" target="_blank">分支</a>并下载文件<code class="fe nu nv nw nl b">src/index.css</code>并替换第2部分中的默认文件。</p><h1 id="e272" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">测试我们的应用</h1><p id="10ca" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">让我们确保一切顺利。要做到这一点，启动应用程序；</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="e7a4" class="np lh iq nl b gy nq nr l ns nt">yarn start</span></pre><p id="bf77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<a class="ae lf" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>在浏览器中查看。并尝试将一个电话项目拖动到目标空间，如上面的GIF图像所示。然后检查您的控制台，确保您得到类似于</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="35b9" class="np lh iq nl b gy nq nr l ns nt">Begin drag<br/>You dropped Iphone into ShoppingCart</span></pre><h1 id="2f3d" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="4bc1" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">旅程的第三部分是将React DnD集成到我们的React应用程序中。你可以在这里获得这部分<a class="ae lf" href="https://github.com/Eyongkevin/shopping-list---React-Redux-DragandDrop/tree/React-Drag-and-Drop" rel="noopener ugc nofollow" target="_blank">的完整代码。<strong class="ka ir">接下来，我们将响应</strong> <code class="fe nu nv nw nl b"><strong class="ka ir">endDrag</strong></code> <strong class="ka ir">事件，使用React reducers和actions </strong>将拖动的项目转移到拖放目标空间。正如承诺的那样，第四部现在已经上市了。</a></p></div></div>    
</body>
</html>