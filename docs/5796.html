<html>
<head>
<title>Continuous Infrastructure Deployment with Terraform Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform云进行持续基础架构部署</h1>
<blockquote>原文：<a href="https://itnext.io/continuous-infrastructure-deployment-with-terraform-cloud-2853cbbb920?source=collection_archive---------1-----------------------#2021-05-27">https://itnext.io/continuous-infrastructure-deployment-with-terraform-cloud-2853cbbb920?source=collection_archive---------1-----------------------#2021-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/48908e24a1fdc9ae52e810154a720fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etej6CTBPY8VLaGLGiIhQw.png"/></div></div></figure><h1 id="1207" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">地形和自动化</h1><p id="149d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我上一家公司，我们经常使用Terraform。它允许我们重复地创建基础设施，并利用彼此的代码来这样做。它还为我们提供了一种标准的方法，无需团队编写自己的专用工具就可以对基础设施进行更改，同时以代码的形式记录基础设施！如果您熟悉Terraform或其他基础设施作为代码工具，您可能已经理解并获得了使用它们的好处。</p><p id="dcf0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，有时Terraform需要共享的结构和工作流，以保持环境的一致性，并支持团队成员之间的协作。为此，您可以使用远程状态、工作区或类似于<a class="ae lz" href="https://terragrunt.gruntwork.io/" rel="noopener ugc nofollow" target="_blank"> Terragrunt </a>的工具。这也是像<a class="ae lz" href="https://www.terraform.io/docs/cloud/index.html" rel="noopener ugc nofollow" target="_blank">地形云</a>、<a class="ae lz" href="https://spacelift.io/" rel="noopener ugc nofollow" target="_blank">太空飞船</a>、<a class="ae lz" href="https://www.env0.com/" rel="noopener ugc nofollow" target="_blank"> env0 </a>、<a class="ae lz" href="https://scalr.com/" rel="noopener ugc nofollow" target="_blank"> Scalr </a>或<a class="ae lz" href="https://www.runatlantis.io/" rel="noopener ugc nofollow" target="_blank">亚特兰蒂斯</a>这样的选项发挥作用的地方。这些Terraform自动化工具<a class="ae lz" href="https://www.youtube.com/watch?v=4MLBpBqZmpM" rel="noopener ugc nofollow" target="_blank">由CloudPosse </a>创造的“TACOS”(terra form Automation&amp;协作软件)提供了多种优势，这些优势在部署您自己的基础设施自动化时难以匹敌。其中包括:</p><ul class=""><li id="598b" class="ma mb iq ky b kz lu ld lv lh mc ll md lp me lt mf mg mh mi bi translated">放手，保护你的地形状态的后端</li><li id="4520" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">共享计划输出，简化协作</li><li id="c21f" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">Terraform版本锁定</li><li id="85cb" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">版本控制之外的附加权限管理</li><li id="eb0a" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">一个工作空间的Webhooks和“触发器”基于另一个工作空间的运行</li><li id="d2e6" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">政策作为代码框架，如<a class="ae lz" href="https://www.openpolicyagent.org/" rel="noopener ugc nofollow" target="_blank"> OPA </a>或<a class="ae lz" href="https://www.hashicorp.com/sentinel" rel="noopener ugc nofollow" target="_blank"> Sentinel </a></li><li id="fb82" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">API驱动的地形运行</li><li id="5394" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">估价</li><li id="db7e" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">国家审计和税务</li><li id="03f4" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">私有模块注册表</li></ul><p id="30b4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然这些工具往往具有相似的功能集，但今天我将探索<a class="ae lz" href="https://www.terraform.io/docs/cloud/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform Cloud </a>通过GitHub操作自动化基础架构更改，并将这些更改从一个环境推广到下一个环境。作为演示，我将创建一个具有3种不同环境的小型AWS模块:“tst”、“stg”和“prd”。这些环境都将位于AWS区域“美国-西部-2”。</p><p id="8c85" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这篇文章的目标是探索三件事:</p><ol class=""><li id="fa26" class="ma mb iq ky b kz lu ld lv lh mc ll md lp me lt mo mg mh mi bi translated">使用“工作区”和Terraform云后端在同一模块中处理多个环境。</li><li id="8727" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mo mg mh mi bi translated">自动化从一个环境到下一个环境应用更改的过程。</li><li id="3508" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mo mg mh mi bi translated">使用哨兵策略，防止不符合规范的基础设施更新。</li></ol><h2 id="aa1c" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">21年6月2日更新</h2><p id="9e03" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我在发表这篇文章后被告知，通过提供<code class="fe nb nc nd ne b">TF_CLI_ARGS</code>环境变量，在Terraform Cloud中使用<code class="fe nb nc nd ne b">-tfvars</code>选项实际上是可能的。虽然我还没有尝试过，但这将解决我在创建这个演示时遇到的主要问题，正如你将看到的那样，无法为每个特定的环境提供特定的<code class="fe nb nc nd ne b">*.tfvars</code>文件，这意味着我必须做一些代码调整来弥补。相反，我可以将每个工作区中的<code class="fe nb nc nd ne b">TF_CLI_ARGS</code>设置为指定的<code class="fe nb nc nd ne b">tfvars</code>。如果这没有意义的话，应该在文章的最后。</p><p id="52f7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">大声呼喊<a class="ae lz" href="https://medium.com/@jeremygaither" rel="noopener">杰里米·盖瑟</a>指出这一点。</p><h1 id="45e8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">项目设置</h1><p id="ff32" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">不再浪费时间，让我们进入代码(你可以在这个报告中找到<a class="ae lz" href="https://github.com/5t33/tf-cloud-workspaces-demo" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="fe37" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我将使用的文件夹结构如下:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="6dea" class="mp jz iq ne b gy nn no l np nq">├── module<br/>├── sentinel<br/>├── usr_mgmt<br/>└── workspaces</span></pre><p id="ba7c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果这是一个真实的环境，这些文件夹中的每一个都代表一组资源，这些资源可能是它自己的存储库，但是出于演示的目的，我将它们放在一起。现在不用太担心其他文件夹，我将部署的资源将放入<code class="fe nb nc nd ne b">module</code>目录。</p><p id="84ec" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是我将部署的简单模块:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ec14" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以及随之而来的变量:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ffa1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">(编辑:这就是06/02/21更新将会改变的地方。代替一个vars文件，这些块中的每一个都在它自己的特定于环境的vars文件中，例如<code class="fe nb nc nd ne b">prd-us-west-2.json</code>。然后，通过<code class="fe nb nc nd ne b">TF_CLI_ARGS</code>环境变量，例如<code class="fe nb nc nd ne b">TF_CLI_ARGS="-var-file=prd-us-west-2.json"</code>，在自动化过程中指定vars文件</p><p id="f14c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可能会立即注意到我的变量声明的一些奇怪之处。我没有单独定义每个变量，而是将它们都定义在一个名为“变量”的映射中。这不是正常的模式。</p><p id="bb98" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您熟悉Terraform，您会知道通常不同的输入变量是通过变量文件或变量参数提供的。对于每个环境，可以使用<code class="fe nb nc nd ne b">-var-file</code>标志或通过<code class="fe nb nc nd ne b">-var</code>在文件中提供一组特定的配置变量。但是，Terraform Cloud目前不支持通过CLI提供var或var文件。</p><p id="a9b2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">相反，你有三个选择:</p><ol class=""><li id="3642" class="ma mb iq ky b kz lu ld lv lh mc ll md lp me lt mo mg mh mi bi translated">为你所有的变量使用<a class="ae lz" href="https://registry.terraform.io/providers/hashicorp/tfe/latest/docs/resources/variable" rel="noopener ugc nofollow" target="_blank"> Terraform云变量资源</a>(这极其繁琐，完全不现实)。</li><li id="7e81" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mo mg mh mi bi translated">用相同的代码使用完全不同的文件夹，或者潜在地调用一个模块。</li><li id="532d" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mo mg mh mi bi translated">把你的每个变量做成一个地图，然后根据工作空间选择变量，这就是我在这里做的。</li></ol><p id="8aa9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我的工作空间由<code class="fe nb nc nd ne b">environment</code> ( <code class="fe nb nc nd ne b">tst</code>、<code class="fe nb nc nd ne b">stg</code>或<code class="fe nb nc nd ne b">prd</code>)和<code class="fe nb nc nd ne b">aws_region</code>的组合来定义。然后这些在模块中被连接成一个局部变量，这给了我<code class="fe nb nc nd ne b">tst-us-west-2</code>、<code class="fe nb nc nd ne b">stg-us-west-2</code>和<code class="fe nb nc nd ne b">prd-us-west-2</code>。正如您马上会看到的，这两个变量(environment和aws_region)将通过Terraform cloud提供给工作区，因此开发人员不必担心设置它们。然后可以使用它们来检索特定于环境的变量，如下所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="5cbc" class="mp jz iq ne b gy nn no l np nq">var.variables[local.workspace].&lt;variable name&gt;</span></pre><p id="357b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">老实说，我真的不喜欢为了适应不同的自动化解决方案而不得不修改代码。感觉像是为了CI牺牲了我模块的逻辑。我通常选择上面列出的第二个选项，但是工作区应该给你从同一个模块部署不同环境的选择，以保持你的代码干燥，我想尝试一下。希望Hashicorp很快将<code class="fe nb nc nd ne b">-var-file</code>作为一个选项添加进来，因为没有它是一种拖累。</p><h1 id="1cb1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">工作区</h1><p id="d799" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在使用Terraform Cloud部署这个资源之前，我必须设置我的工作区。如果您正在跟进，并且您还没有TF Cloud帐户，您可以在此处注册一个<a class="ae lz" href="https://app.terraform.io/signup/account" rel="noopener ugc nofollow" target="_blank">。在</a><a class="ae lz" href="https://www.terraform.io/docs/cloud/workspaces/index.html" rel="noopener ugc nofollow" target="_blank">工作区</a>快速靠边。工作区是一个平台概念，其中同一个模块可以存在多种状态，通常用于区分环境，例如测试、试运行、生产。“工作空间”与状态文件1:1映射。</p><p id="5555" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">令人困惑的是，传统的CLI工作区与Terraform Cloud“工作区”并不相同，正如您可以从以下文档片段中看到的:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/130fef99983fa83450b52756cd7af0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drsdPQ_-QnhhakKIpXtV7g.png"/></div></div></figure><p id="2b66" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Terraform云工作空间是这样描述的:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/28d91cf7cdd67f38f4b1ba6de9dc3f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKe3OIed3aGa-8VhDh8tgg.png"/></div></div></figure><p id="5fdc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我明白他们在说什么…但最终每个工作空间仍然有一个状态，它们可以互换工作，所以我真的不明白为什么Terraform Cloud工作空间不是备用状态文件。我想这是因为在TF Cloud中,“工作空间”也意味着与之相关的产品特性，但是它的措辞很奇怪。无论如何，要了解工作区是如何工作的，最好先在TF Cloud控制台中设置一个工作区，这会给出以下设置屏幕:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/bac636f1d65e7d59df2f00782874f445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTR3mv6mzT9mygYcuAJvVQ.png"/></div></div></figure><p id="f705" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">有三个选项可供选择。各有利弊。让我们检查一下。</p><h2 id="1494" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">VCS工作区</h2><p id="a34c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">VCS工作区是迄今为止最容易设置的。它为您处理大量自动化工作。无需添加您自己的构建步骤，Terraform Cloud将克隆您的存储库，运行一个计划，并在计划通过后提供一个漂亮的绿色检查(哪个开发人员不喜欢绿色检查标记呢？):</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/b7a18131ba17698b6da2c0b7b683701d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4uuumXEj0bx53doL9WMzjA.png"/></div></div></figure><p id="5d71" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您的存储库有子模块，只要提供了令人满意的ssh密钥，它也会处理这个问题。一旦PR合并，它将开始应用运行，这必须在Terraform云控制台中批准(如果需要)。这个选择有很多优点。这可能是设置TF Cloud Automation最简单的方法，它可以防止从控制台进行应用，而您可能想要限制这种应用。然而，这也有点限制，而且<em class="nt">也有一些缺点。</em></p><h2 id="038b" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">VCS骗局</h2><p id="6400" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，您将无法从命令行运行应用程序，这可能是您所希望的，但它也有很大的局限性。TF Cloud <em class="nt">没有</em>为您提供在构建脚本中与计划/应用步骤一起运行额外代码的选项(其他一些TACOS有)，因此您可能希望选择更加手动的CLI方法来为您提供灵活性。</p><p id="979c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，如果您只在版本控制中的一个主要分支上工作，您将不能真正地按照您自己的方式将变更从一个环境提升到下一个环境。当PR被合并时，所有的申请被一次排队。对于具有多分支git-flow设置的存储库来说，这并不是一个问题，例如“开发”、“暂存”和“主”。然而，如果您依赖CI/CD管道来连续地对每个环境进行变更，这并不太好。对于一个主分支和多个工作区，不能保证顺序。运行以您在TF Cloud控制台中批准它们的任何顺序发生。假设您进行了合并，测试和试运行环境开始运行，并等待您在每个环境上点击“approve”以启动应用。您可以点击“运行:测试前的登台环境”,这是不允许的。此外，考虑到所有运行都是排队的，并且TF Cloud有并发限制，也有可能您会被迫在测试之前应用生产，因为测试卡在了队列中！</p><p id="2b88" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">此外，由于VCS工作区仅包含PR中计划结果的链接，因此所有用户都必须拥有一个帐户才能查看该计划。如果您更多地手动运行您的计划，您可以在注释中将计划输出到github，这只是流程的一部分。出于这些原因，我将在余下的演示中选择CLI工作区(另外，VCS工作区也很容易理解)。</p><h2 id="6882" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">CLI工作区</h2><p id="3d56" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">CLI工作区更需要手动操作，因为您必须运行一个计划并在您的CI环境中进行应用，但它让您能够更好地控制应用的时间，而不是在合并后立即进行。在只有一个主要分支的情况下，您可以构建一个部署管道，将变更依次应用到您的每个工作区。此外，您可以添加额外的步骤，比如在应用脚本之后进行冒烟测试。使用VCS选项时，您必须在申请后使用webhook来添加额外的自动化和检查。</p><p id="24c9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，设置更加复杂，您需要添加一个TF Cloud令牌作为Github操作的秘密(或者您用来运行Terraform的CI工具)。</p><h2 id="0733" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">API工作区</h2><p id="21b1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">API工作区并不是<em class="nt">真正的</em>一种独立类型的工作区。您可以从命令行(如CLI工作区)应用它们，并且可以在CLI、API或VCS工作区上使用<code class="fe nb nc nd ne b">/run</code> API端点。据我所知，CLI和API工作区的设置完全相同。我认为TF Cloud只是将它作为一个选项包含在builder中，以指出使用API调用运行您的Terraform是一个功能。请注意，创建带有工作区的应用运行如下所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="e98c" class="mp jz iq ne b gy nn no l np nq">export TOKEN="&lt;your token&gt;"<br/>curl \<br/>  --header "Authorization: Bearer $TOKEN" \<br/>  --header "Content-Type: application/vnd.api+json" \<br/>  --request POST \<br/>  --data @create_run.json \<br/>  https://app.terraform.io/api/v2/runs</span></pre><p id="4d5e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您的数据在哪里:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="a678" class="mp jz iq ne b gy nn no l np nq">{<br/>  "data": {<br/>    "attributes": {<br/>      "is-destroy": false,<br/>      "message": "This is an API driven run"<br/>    },<br/>    "type":"runs",<br/>    "relationships": {<br/>      "workspace": {<br/>        "data": {<br/>          "type": "workspaces",<br/>          "id": "id-xxxxxxxxx"<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9739" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，只有上面的初始设置，这将只适用于VCS的工作空间。为了进行远程运行，TF Cloud需要terraform资源文件来运行并与状态进行比较。VCS工作区的优势之一是每次运行时，TF Cloud都会从您的版本控制提供商那里获取文件。CLI工作区将要求您<a class="ae lz" href="https://www.terraform.io/docs/cloud/run/api.html" rel="noopener ugc nofollow" target="_blank">上传带有您的Terraform代码的zip文件</a>形式的“配置”。</p><h1 id="0301" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">地形改造</h1><p id="1044" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在TF Cloud控制台中点击来设置你的工作空间是相当简单的，但是这不是非常可重复的，所以我做了这个小的Terraform模块来完成它。像这样的“Terraforming Terraform”实际上是Terraform Cloud是一个好选择的原因之一，但其他TF自动化解决方案也提供提供商。</p><p id="f1b0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以下是使用Terraform云提供商的工作空间资源示例:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="075d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这是我创建的通用模块(顺便说一下，它位于演示库的<code class="fe nb nc nd ne b">workspaces</code>部分):</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="19b0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如你所看到的，它还延伸到一个名为“tf-cloud-variables”的子模块，这是我创建的一个模块，用于创建Terraform云变量，可以选择从AWS SSM参数存储中提取敏感数据。该模块看起来有点像这样:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9146" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当然，它去掉了一堆东西。你可以在回购中看到完整的模块。重点是允许我将变量&amp;环境变量声明包含在我的工作区声明中，如下面的tfvars文件示例所示:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2b53" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了节省空间，我删除了另外两个工作区，但是除了环境值/工作区名称之外，它们完全相同。通过将<code class="fe nb nc nd ne b">vcs_repo</code>设置为空，工作区就变成了CLI工作区。没有办法选择CLI或API(这使我认为它们是一回事)。如你所见，我在这里包含了两个变量:<code class="fe nb nc nd ne b">environment</code>和<code class="fe nb nc nd ne b">region</code>，它们将在前面的模块中用来创建局部变量:<code class="fe nb nc nd ne b">workspace</code>，这将允许模块为它正在运行的环境提取正确的配置。</p><p id="7744" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是，在设置工作空间之前，需要添加Terraform云提供商:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3007" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nb nc nd ne b">tfe_token</code>将需要是一个<a class="ae lz" href="https://www.terraform.io/docs/cloud/users-teams-organizations/teams.html" rel="noopener ugc nofollow" target="_blank">团队</a>或<a class="ae lz" href="https://www.terraform.io/docs/cloud/users-teams-organizations/users.html" rel="noopener ugc nofollow" target="_blank">用户</a>令牌，可以在TF Cloud应用程序上创建。我将这个变量添加到我的gitignore中的secrets文件中，名为secrets.auto.tfvars。</p><p id="589a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">应用workspaces模块后，您应该会看到它们在TF Cloud控制台中创建(以及在您的terraform命令行输出中):</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/3fef0f1840a0cbb1557d737d85110710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4DoG8vjVzovmdLnR2wghg.png"/></div></div></figure><p id="a570" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">(“应用的”部分还没有出现，但是我在创建初始工作空间后拍了这张照片)。</p><p id="e332" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">顺便说一句，我没有为这个工作空间模块设置后端，但讽刺的是，您可能必须首先在控制台中这样做，或者创建没有工作空间的工作空间模块的工作空间，然后在fact… meta之后添加它。</p><h1 id="b6c7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Terraform云后端</h1><p id="acbe" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在工作区已经设置好了，我们实际上可以开始使用它们了！为此，我们将返回S3模块，添加Terraform云后端，如下所示:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e8b6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这将取代你目前使用的后端。需要注意的一点是<code class="fe nb nc nd ne b">prefix</code>设置。这就是Terraform Cloud为单个模块设置多个工作区的方式。当您运行<code class="fe nb nc nd ne b">terraform init</code>时，任何以上述前缀<code class="fe nb nc nd ne b">tf-cloud-workspaces-demo-</code>开头的工作区都将是一个选项。</p><p id="ffd3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，在运行<code class="fe nb nc nd ne b">plan</code>之前，您还需要用令牌设置您的<code class="fe nb nc nd ne b">.terraformrc</code>配置。这可以通过运行<code class="fe nb nc nd ne b">terraform login</code>或者将以下内容复制到您的主目录中的一个名为<code class="fe nb nc nd ne b">.terraformrc</code>的文件中来完成</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="e10d" class="mp jz iq ne b gy nn no l np nq">credentials "app.terraform.io" {<br/>  token = "&lt;your token here&gt;"<br/>}</span></pre><p id="8e41" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来，当您运行<code class="fe nb nc nd ne b">terraform init</code>时，您将看到以下输入:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/4df9421a66c330b5b63d913843606561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNIJNqbK1LUppILAJK5tqQ.png"/></div></div></figure><p id="5a37" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从这里，您可以选择要在本地运行计划的工作空间。</p><h2 id="5754" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">本地工作区</h2><p id="309f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">工作区应该在TF Cloud服务器上的一致环境中运行(这可能是他们喜欢区别于“CLI”工作区的另一个原因)。因此，即使你在本地运行你的计划，它们实际上是从一个TF云服务器流结果。然而，如果你想在你自己的计算机上运行Terraform，而<em class="nt">只是</em>使用TF Cloud进行状态管理，你可以通过将你的工作空间设置为“本地”来实现。</p><h1 id="eeda" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">IAM &amp;承担角色提供者</h1><p id="c4bb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在部署这些资源之前，还有一个必要的步骤。我将使用辊运行此Terraform，因为这将是自动化的，我不会使用我自己的凭证。因为我不会使用Terraform Cloud的本地代理，所以我需要提供一些单独的凭据。这意味着创建一个有权限创建/更新指定存储桶和存储桶对象的用户。或者，更准确地说，是一个具有创建/更新存储桶权限的角色，Terraform用户能够承担这个角色。因为我很懒，不想为最少的perms而工作，所以该假定角色的策略资源如下所示:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e8db" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里的<code class="fe nb nc nd ne b">for_each</code>遍历每个工作区，我之前提到的是<code class="fe nb nc nd ne b">tst-us-west-2</code>、<code class="fe nb nc nd ne b">stg-us-west-2</code>和<code class="fe nb nc nd ne b">prd-us-west-2</code>。该策略的角色如下所示:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2f60" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如这条线所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="d756" class="mp jz iq ne b gy nn no l np nq">AWS = data.aws_iam_user.deployment_user.arn</span></pre><p id="a7fd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该角色只能由控制台中定义的用户担任。既然已经创建了角色和用户，模块的AWS提供者可以像这样更新:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="43a4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如您在上面看到的，我在每个Terraform Cloud工作区中提供了<code class="fe nb nc nd ne b">AWS_ACCESS_KEY_ID</code>和<code class="fe nb nc nd ne b">AWS_SECRET_ACCESS_KEY</code>环境变量(使用我之前创建的perms用户的密钥来承担部署角色)。</p><p id="6eb8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最酷的是，运行Terraform的人甚至不需要AWS权限来运行计划/应用程序，他们只需要权限来访问Terraform Cloud中的环境。这大大减少了为改变基础设施而需要的许可证数量。</p><p id="a79b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里的另一个选项是通过环境变量<code class="fe nb nc nd ne b">AWS_ACCESS_KEY_ID</code>、<code class="fe nb nc nd ne b">AWS_SECRET_ACCESS_KEY</code>和<code class="fe nb nc nd ne b">SESSION_TOKEN</code>为所承担的角色提供临时凭证。那么永久凭证就没有必要了，可以从aws提供者中删除“assume_role”。然而，这也需要一些自动化的过程来每天更新临时凭证，我不会在这里这样做。</p><p id="90c1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">既然提供者已经就位，我可以通过在本地运行一个计划来测试它，开始是这样的:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/4016fdca28587388bcf5df36b44ae5af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZ2nPDQwAQvBdYngMJMoTA.png"/></div></div></figure><p id="ae8e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">快速浏览显示，该计划正在使用Terraform v0.15的linux机器上运行，并且提供了一个漂亮的链接，可用于共享该计划的输出。接下来，我们得到了我们的计划以及成本估算:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/1f74b2ae562f09c6cdbd869f8e78c286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuZmdvyFKZphsAy0bcWvxg.png"/></div></div></figure><h1 id="37d4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Github操作</h1><p id="4c36" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，全自动部署的所有部分都应该就绪了。要开始Github操作，您需要将一个TF Cloud令牌添加到存储库的秘密中。你可以通过导航到你的仓库中的<strong class="ky ir">设置</strong>-&gt;-T14】秘密来找到Github的秘密部分。我将把这个令牌命名为<code class="fe nb nc nd ne b">TF_CLOUD_TOKEN</code>。</p><h2 id="28e4" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">计划</h2><p id="d723" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">创建PRs时，我们需要一个操作来为每个工作区运行一个计划。Github Actions的工作流程是这样的(正如我之前提到的，我在演示的这一部分使用了本教程的):</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9bf0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">和以前一样，我删除了<code class="fe nb nc nd ne b">stg</code>和<code class="fe nb nc nd ne b">prd</code>任务以节省空间，因为它们完全相同。为了澄清这里发生了什么，<code class="fe nb nc nd ne b">on</code>部分声明下面的作业列表将在针对主分支的拉请求时被触发。<code class="fe nb nc nd ne b">paths</code>指示将监视哪些文件夹路径的更改。另一个重要的部分是定义了一个环境变量的<code class="fe nb nc nd ne b">env</code>部分:<code class="fe nb nc nd ne b">TF_WORKSPACE</code>。这告诉Terraform选择哪个工作空间。如果没有这个，<code class="fe nb nc nd ne b">init</code>将需要手动输入。</p><p id="12b5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">随后，作业<code class="fe nb nc nd ne b">plan-tst</code>执行以下动作:</p><ul class=""><li id="9ead" class="ma mb iq ky b kz lu ld lv lh mc ll md lp me lt mf mg mh mi bi translated">结帐(结帐回购)</li><li id="f87f" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">设置Terraform(下载所需的Terraform版本)</li><li id="1947" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">Terraform Init(初始化工作空间)</li><li id="1b6e" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">地形格式</li><li id="82f3" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">地形图</li><li id="7261" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">更新拉式请求(将计划添加到拉式请求中)</li><li id="5ab7" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">地形计划状态(如果计划失败，退出1)</li></ul><p id="cfa0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些步骤相当简单，但是有一些事情需要强调。首先，<code class="fe nb nc nd ne b">cli_config_credentials_token:${{ secrets.TF_CLOUD_TOKEN}}</code>提供了我作为秘密添加到Github repo中的令牌。其次，在作业级设置的环境变量<code class="fe nb nc nd ne b">TF_WORKSPACE</code>将工作空间设置为<code class="fe nb nc nd ne b">tst-us-west-2</code>。这告诉Terraform使用哪个工作空间，否则<code class="fe nb nc nd ne b">init</code>将需要输入。最后，<code class="fe nb nc nd ne b">continue_on_error</code>允许作业继续进行，即使当<code class="fe nb nc nd ne b">plan</code>或<code class="fe nb nc nd ne b">fmt</code>命令失败时，这些结果可以作为注释的输出。此外，我在<code class="fe nb nc nd ne b">module</code>目录中过滤了作业，因此只有对模块的更改才会启动这些计划。</p><p id="724c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，一旦创建了PR，这些计划将运行并将其结果发布到PR:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/3f60dd49ce70a728829c1ebd2c349bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6khsHZWqIzI2SFeIf4JLRw.png"/></div></div></figure><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/20aabd1c3c20bd46a95532d293938c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mnc0DwdHSlvRa4Bo4JnBVA.png"/></div></div></figure><h2 id="885e" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">适用</h2><p id="82fa" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上面的GH操作提供了一个蓝图，可以很容易地进行调整，以在每个工作区中连续运行应用程序，并在操作之间进行批准。当Terraform Apply在TF Cloud workspace上运行时，您可以选择从TF Cloud控制台批准它:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/42b079411746bc69a3320f31be310410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2l2HLkO8NmJzabmIShu_A.png"/></div></div></figure><p id="192d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，实际上没有必要添加额外的逻辑来增加环境之间的审批门。此外，由于Terraform Cloud有自己的访问控制，所以您不需要依赖Github授权来获得批准。如果您的Github控制不像您希望的那样严格，这对于批准基础设施变更很有帮助。</p><p id="1af7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了更新应用的Github操作，我首先将<code class="fe nb nc nd ne b">on</code>条件更改为<code class="fe nb nc nd ne b">push</code>，这意味着工作流将在PR合并时启动。第二，我将把<code class="fe nb nc nd ne b">need</code>配置添加到<code class="fe nb nc nd ne b">stg</code>和<code class="fe nb nc nd ne b">prd</code>作业中，这样它们在开始之前会等待对方完成。如果一个失败了，下一个就不会开始。最后，我将删除<code class="fe nb nc nd ne b">fmt</code>命令和PR注释，因为它们对于应用阶段是不必要的。最后，我们将得到类似这样的结果(这次我将所有工作区都留在了中):</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="fb51" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，当我合并一个PR时，工作开始了:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/e6b37ab47b39809de976a6159ed73374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-tYPQmi2GjUC0H3kI4NuQ.png"/></div></div></figure><p id="531b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我可以在TF Cloud控制台中批准:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/55c40dd6d12a647cf3fae298f6bd8be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCKnEjP9Z2lOAEgl-C_F2g.png"/></div></div></figure><p id="87fc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">应用更改后，我看到下一个作业开始了:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/922f87c568ac981c82032b8d8ec2c22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_JO8J7vXAXsn6QfB2Kha-A.png"/></div></div></figure><h2 id="8660" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">审计线索</h2><p id="4244" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Terraform Cloud(和其他TACOS)的另一个很酷的方面是，每次基础架构更新都会记录状态差异，因此在应用后，您可以返回并查看您的状态是如何变化的:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/6b1c5f7b1a4515779bf5f7f96e48747e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNu2tzfDhg1BupVltJETRg.png"/></div></div></figure><h1 id="bb8c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">哨兵</h1><p id="8560" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Sentinel是Hashicorp的政策，作为代码语言，内置于他们的一些产品中。通过Terraform Cloud，Sentinel允许您指定计划必须遵守的规则才能通过。您可以对几乎任何想要的东西实施限制:EC2大小、公共S3桶、开放安全组、宽IAM策略等。事实上，因为TF Cloud也进行成本估算，所以您也可以强制实施成本限制。这些强制措施可以是“建议性的”、“硬性强制的”或“软性强制的”。</p><p id="ff86" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">与工作空间一样，Terraform Cloud provider允许您使用Terraform创建Sentinel策略。该资源如下所示:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e7fe" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些策略可以应用于单个VCS存储库、特定工作区，或者全局应用于所有工作区。我将创建一个全局策略，以确保所有存储桶都是私有的，如下所示:</p><p id="e22e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nb nc nd ne b">must_not_be_public.sentinel</code></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="356b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该策略通过<code class="fe nb nc nd ne b">tfplan/v2</code>导入应用于计划输出，过滤所有资源更改，以执行“aws_s3_bucket”资源上的“创建”或“更新”操作。然后检查公共选项的<code class="fe nb nc nd ne b">acl</code>属性。然后，对bucket对象执行相同的过程。最后，检查每个列表的长度是否为0。这发生在<code class="fe nb nc nd ne b">main</code>规则中，这是策略的入口点(顺便说一下，这个策略最初来自Hashicorp演示，但是我怎么也找不到它)。</p><h2 id="01ea" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">测试哨兵</h2><p id="1663" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要知道这个策略是否真的如我们所愿，需要对它进行测试，这就需要模拟数据。您可以从Terraform cloud中运行的任何计划中下载数据，方法是导航到该计划并点击“下载sentinel模拟”按钮:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/dc8ae02508241dcb2cb872317ffffbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKy9S96Ctf6ng_-JyP-oAg.png"/></div></div></figure><p id="0875" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">注意:这被称为“模拟”数据，但似乎包含敏感值。确保在添加到您的版本控制之前扫描它们。</strong></p><p id="dddd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下载完成后，您可以用tar解压它们:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="6894" class="mp jz iq ne b gy nn no l np nq">tar xzf ~/Downloads/run-xxxx-sentinel-mocks</span></pre><p id="04fe" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">提供了各种文件，其中一个将被称为<code class="fe nb nc nd ne b">mock-tfplan-v2.sentinel</code>。这对应于使用<code class="fe nb nc nd ne b">tfplan/v2</code>时可用的数据。这是我用来嘲笑我的哨兵测试计划的。这里需要注意的一点是，这些模拟计划中包含了敏感数据，在提交之前，您需要去除这些敏感数据。</p><p id="e7d5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Sentinel使用文件结构来确定测试的位置。您的sentinel策略应该在您的目录的底部，并且所有的测试应该在“test”文件夹中，就像这样:<code class="fe nb nc nd ne b">test/&lt;your_policy_name&gt;/*.json</code>。每个sentinel策略都有自己的文件夹，其中可能包含多个测试。按照这种格式，我有以下文件结构:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9afe27d83c58e98a811d2f3d95e9e462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*OH8ET8k1WgkJD0xqLIF22w.png"/></div></figure><p id="4194" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nb nc nd ne b">global</code>文件夹保存全球应用的sentinel策略。如果我要包含工作区或回购特定策略，我会将它们包含在<code class="fe nb nc nd ne b">workspaces/&lt;workspace name&gt;</code>或<code class="fe nb nc nd ne b">repository/&lt;repository name&gt;</code>文件夹中。<code class="fe nb nc nd ne b">module</code>保存将在多个文件夹中共享的共享Terraform模块。</p><p id="5fe9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">文件中的每个测试如下所示:</p><p id="5567" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nb nc nd ne b">fail-bucket.json</code>:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="f55d" class="mp jz iq ne b gy nn no l np nq">{<br/>  "mock": {<br/>    "tfplan/v2": "../../test-data/mock-plan-fail-bucket.sentinel"<br/>  },<br/>  "test": {<br/>    "main": false<br/>  }<br/>}</span></pre><p id="0b18" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe nb nc nd ne b">mock</code>部分指向被改变以使公共桶的标记检查失败的模拟数据，并且<code class="fe nb nc nd ne b">test</code>部分断言对于所提供的模拟数据，主检查为假。</p><p id="a037" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">运行<code class="fe nb nc nd ne b">sentinel test</code>后，我得到以下输出:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/58ea407c47812ef0638e95d72f962510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSOffhL4PGdv6hLP3lWnPg.png"/></div></div></figure><p id="d440" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我编写的三个测试都通过了，所以我可以继续部署了。</p><h2 id="e120" class="mp jz iq bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">地形哨兵</h2><p id="767d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">与前面的workspaces模块一样，我还创建了一个sentinel模块来集中和重用我的sentinel代码。sentinel策略Terraform资源如下所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="7671" class="mp jz iq ne b gy nn no l np nq">resource "tfe_sentinel_policy" "test" {<br/>  name         = "my-policy-name"<br/>  description  = "This policy always passes"<br/>  organization = "my-org-name"<br/>  policy       = "main = rule { true }"<br/>  enforce_mode = "hard-mandatory"<br/>}</span></pre><p id="7168" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这些策略被添加到策略“集合”中，如下所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="06f4" class="mp jz iq ne b gy nn no l np nq">resource "tfe_policy_set" "test" {<br/>  name          = "my-policy-set"<br/>  description   = "A brand new policy set"<br/>  organization  = "my-org-name"<br/>  policy_ids    = [tfe_sentinel_policy.test.id]<br/>  workspace_ids = [tfe_workspace.test.id]<br/>}</span></pre><p id="a265" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">策略可以<em class="nt"> </em>应用于<em class="nt"> </em>一组工作区，或者使用<code class="fe nb nc nd ne b">global</code>标志在所有工作区中全局应用(在这种情况下，不提供工作区id)。与其他Terraform云提供商资源一样，我已经将这两者捆绑到一个模块中，这次我不会深入讨论这个模块，但它允许我将策略集声明为工作区名称到策略的映射，如下所示:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="cbee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这将导致创建以下资源:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/6104f729809218578fab35c884255e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcNak1adTplGLDHxjP8yuQ.png"/></div></div></figure><p id="51a5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，我可以通过推动一项将我的存储桶公开的更改来测试该策略。让我们看看当我在s3资源上将acl设置为“public-read”时会发生什么，如下所示:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="5caf" class="mp jz iq ne b gy nn no l np nq">resource "aws_s3_bucket" "demo" {<br/>  bucket = "tf-cloud-workspaces-demo-${local.workspace}"<br/>  force_destroy = var.variables[local.workspace].force_destroy<br/>  tags =  var.variables[local.workspace].tags<br/>  acl = "public-read"<br/>}</span></pre><p id="519a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">打开公共读取选项后，当我运行一个计划时，我突然得到这个输出(在两张照片中，因为我的屏幕不够大):</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/b19a16e6cd0665268431e1ba0637d19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2WtpTWXWRcDXF8T_CJh0w.png"/></div></div></figure><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/f4a492b0c580ba66aadcb79255f49ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzVYnm-Gol5fUzCnM2w2SA.png"/></div></div></figure><p id="72b0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它没有通过检查！虽然“空策略集名称”很奇怪…但这似乎没什么大不了的。只是为了好玩，我也会把这个推给Github的一个PR，看看这个计划在那里也失败了。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/6a3722b6c76caee8706201143a7060dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXT7MygcqZDCMKXSx4PGJw.png"/></div></div></figure><p id="fbdc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就像在本地运行一样，我所有的Github检查都失败了。成功！或者..犯罪..失败…我猜。</p><h1 id="80db" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="c14c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如你所见… TF云！很好。它做的事情。</p><p id="21cd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我认为这些工具对大型组织非常有用，这样开发人员可以轻松地共享运行，拥有一致的部署环境，实施基础架构策略，监控成本，提供状态审计跟踪，并可能通过API调用运行自动化的基础架构更改。然而，即使对于一个较小的组织来说，让Terraform Cloud用锁而不是S3桶和dynamodb表(或者您选择的任何方式)来管理您的远程状态也是不错的。S3引发了一些引人注目的安全事件，因此将这一责任推给托管服务可能会有所帮助。您还可以随时添加远程执行和sentinel策略等功能。</p><p id="6e0d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">也就是说，我在开头列出的一些其他服务也有很强的产品，可能会超过Hashicorp的价格。此外，它们中的许多允许您用OPA编写策略，OPA是开源的，因此即使您停止使用该服务，您仍有可能使用它们。Sentinel不提供这个选项。其中一些甚至可能提供对<code class="fe nb nc nd ne b">-tvfars</code>的支持，这样你就不必编辑你的代码来使用单个文件夹中的多个工作空间。</p><p id="59ce" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我希望这是信息丰富的，并提供了关于Terraform Cloud基础设施自动化的广泛概述。如果您有任何问题或意见，请随时通过linkedin联系https://www.linkedin.com/in/steven-staley/ T2。</p></div></div>    
</body>
</html>