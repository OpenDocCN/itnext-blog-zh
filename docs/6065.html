<html>
<head>
<title>Rust’s Vector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拉斯特矢量</h1>
<blockquote>原文：<a href="https://itnext.io/rusts-vector-4a4a0f0e12eb?source=collection_archive---------2-----------------------#2021-08-08">https://itnext.io/rusts-vector-4a4a0f0e12eb?source=collection_archive---------2-----------------------#2021-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b80992afddec29081186d2cfa61e332b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQFTvqWb4oReA_ZIAHj0bg.jpeg"/></div></div></figure><p id="0dd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说:我最初想描述Rust中所有可用的集合以及它们的相关概念。然后，我开始钻研它，我觉得它太长了。出于这个原因，我将把范围限制在<code class="fe kw kx ky kz b">Vec</code>类型。</p><ul class=""><li id="7879" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/1/" rel="noopener ugc nofollow" target="_blank">我的第一杯铁锈</a></li><li id="d6b2" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/2/" rel="noopener ugc nofollow" target="_blank">我的第二杯铁锈</a></li><li id="822e" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/3/" rel="noopener ugc nofollow" target="_blank">生锈练习—第一部分</a></li><li id="3286" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/4/" rel="noopener ugc nofollow" target="_blank">生锈练习—第二部分</a></li><li id="a855" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/5/" rel="noopener ugc nofollow" target="_blank">前端生锈</a></li><li id="83bf" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/6/" rel="noopener ugc nofollow" target="_blank">库伯内特公司的铁锈控制器</a></li><li id="e1ca" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/7/" rel="noopener ugc nofollow" target="_blank"> Rust和JVM </a></li><li id="f892" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://blog.frankel.ch/start-rust/8/" rel="noopener ugc nofollow" target="_blank"> diceroller，一个样本生锈项目</a></li><li id="f4bd" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><em class="lp">锈氏矢量</em>(本帖)</li></ul><p id="c593" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们将要深入研究的图表:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/63deba6d7f976789f5b9560091470f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27rYjYKlP-nux0oqwKFYNA.png"/></div></div></figure><h1 id="d37b" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">向量基础</h1><p id="909e" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">来自<a class="ae lj" href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="my mz na"><p id="a5ea" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><em class="iq">连续的可增长数组类型，写为</em> <code class="fe kw kx ky kz b"><em class="iq">Vec&lt;T&gt;</em></code> <em class="iq">，读作‘vector’。</em></p></blockquote><p id="4ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像Java的<code class="fe kw kx ky kz b">ArrayList</code>，<code class="fe kw kx ky kz b">Vec</code>是以数组为后盾的。当数组达到最大容量时，<code class="fe kw kx ky kz b">Vec</code>会保留一个容量更大的新数组，并将元素从原始数组复制到新创建的数组中。然后，它解放了前者。请注意，集合可能会分配比所需更大的数组，以避免频繁的重新分配。</p><p id="1ca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给<code class="fe kw kx ky kz b">Vec</code>加值，我们需要使用一个额外的步骤<em class="lp">，例如</em>，<code class="fe kw kx ky kz b">push()</code>函数:</p><pre class="lr ls lt lu gt ne kz nf ng aw nh bi"><span id="755e" class="ni lw iq kz b gy nj nk l nl nm">let mut v = Vec::new();<br/>v.push(1);<br/>v.push(5);</span></pre><p id="3be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建新的<code class="fe kw kx ky kz b">Vec</code>的函数在初始化它们时没有任何条目。如果我们想同时创建一个<code class="fe kw kx ky kz b">Vec</code>和数值，Rust提供了<code class="fe kw kx ky kz b">vec!</code>宏。我们可以用下面的一行代码替换上面的代码:</p><pre class="lr ls lt lu gt ne kz nf ng aw nh bi"><span id="abbd" class="ni lw iq kz b gy nj nk l nl nm">let v = vec![1, 5];</span></pre><p id="b0e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，如果你已经涉猎了一点Rust，你可能没有学到什么新东西。与其描述<code class="fe kw kx ky kz b">Vec</code>上的每一个函数——它们与其他语言中的函数非常相似——不如让我们探索一下。</p><h1 id="1c24" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">向量和迭代器</h1><p id="2a5a" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated"><em class="lp">迭代器</em>是经典<em class="lp">设计模式:可重用面向对象软件的元素</em>一书中描述的设计模式；</p><blockquote class="my mz na"><p id="73ad" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">意图:</em> </strong> <em class="iq">提供一个对象，该对象遍历某个聚合结构，抽象出关于该结构实现的假设。</em></p><p id="1527" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae lj" href="https://wiki.c2.com/?IteratorPattern" rel="noopener ugc nofollow" target="_blank"> <em class="iq">迭代器模式</em> </a></p></blockquote><p id="a2f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管这本书描述了<em class="lp">迭代器</em>，但是没有任何东西将这种模式局限于OOP语言。这是一个非常普遍的抽象概念。</p><p id="2074" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rust提供了<code class="fe kw kx ky kz b">Iterator</code>特征，<code class="fe kw kx ky kz b">Vec</code>实现了它。因此，我们可以遍历它的值:</p><pre class="lr ls lt lu gt ne kz nf ng aw nh bi"><span id="29da" class="ni lw iq kz b gy nj nk l nl nm">let v = vec![1, 5];<br/>let mut iter = v.iter();                       // 1<br/>loop {<br/>    let value = iter.next();                   // 2<br/>    if value.is_some() {<br/>        println!("value: {}", value.unwrap());<br/>    } else {<br/>        break;<br/>    }<br/>}</span></pre><ol class=""><li id="1c2a" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv nn lg lh li bi translated">创建迭代器。因为调用<code class="fe kw kx ky kz b">next()</code>会改变<code class="fe kw kx ky kz b">iter</code>的状态，所以必须是<em class="lp">可变</em>。</li><li id="1676" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lg lh li bi translated">获取下一个值</li></ol><p id="0e45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我从一个错误的<code class="fe kw kx ky kz b">break</code>语句中得到一美元，我现在肯定很富有。如果你打破得太早，你失去了价值观；太晚了，一切都会失控(双关语)。因此，<code class="fe kw kx ky kz b">for</code>和迭代器是更好的选择。我们可以将上面的代码重写为:</p><pre class="lr ls lt lu gt ne kz nf ng aw nh bi"><span id="78eb" class="ni lw iq kz b gy nj nk l nl nm">let v = vec![1, 5];<br/>for value in v.iter() {                        // 1<br/>    println!("value: {}", value);<br/>}</span></pre><ol class=""><li id="eb41" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv nn lg lh li bi translated">更短，更安全，因此更好</li></ol><h1 id="7a52" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">要迭代的迭代器太多</h1><p id="cd57" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">有趣的是，我们可以稍微修改一下上面的代码，删除对<code class="fe kw kx ky kz b">iter()</code>的调用。还能用！</p><pre class="lr ls lt lu gt ne kz nf ng aw nh bi"><span id="68aa" class="ni lw iq kz b gy nj nk l nl nm">let v = vec![1, 5];<br/>for value in v {                               // 1<br/>    println!("value: {}", value);<br/>}</span></pre><ol class=""><li id="07cc" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv nn lg lh li bi translated">神奇！</li></ol><p id="047a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上不是魔术，而是Rust的语法糖在起作用。<code class="fe kw kx ky kz b">for</code>循环接受迭代器。然而，有些实例可以“动态地”转换成迭代器。该类型必须实现<code class="fe kw kx ky kz b">IntoIterator</code>特征和它的<code class="fe kw kx ky kz b">into_iter()</code>函数才有资格。从上图可以看出，<code class="fe kw kx ky kz b">Vec</code>就是这种情况。</p><p id="731d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你问自己<code class="fe kw kx ky kz b">iter()</code>和<code class="fe kw kx ky kz b">into_inter()</code>之间的区别，安慰自己我也想知道。经过一番研究，我找到了这个绝妙的答案:</p><blockquote class="my mz na"><p id="d826" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><strong class="ka ir"><em class="iq">TL；</em>博士:</strong></p><p id="a515" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">根据上下文，<code class="fe kw kx ky kz b">into_iter</code>返回的迭代器可能产生<code class="fe kw kx ky kz b">T</code>、<code class="fe kw kx ky kz b">&amp;T</code>或<code class="fe kw kx ky kz b">&amp;mut T</code>中的任何一个。</p><p id="fe8b" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">按照惯例，<code class="fe kw kx ky kz b">iter</code>返回的迭代器将产生<code class="fe kw kx ky kz b">&amp;T</code>。</p><p id="e1a3" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">按照惯例，<code class="fe kw kx ky kz b">iter_mut</code>返回的迭代器将产生<code class="fe kw kx ky kz b">&amp;mut T</code>。</p><p id="40ce" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><em class="iq">—</em><a class="ae lj" href="https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter" rel="noopener ugc nofollow" target="_blank"><em class="iq">ITER和into_iter有什么区别？</em> </a></p></blockquote><p id="32cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，由于<code class="fe kw kx ky kz b">FromIterator</code>，你可以从创建一个<code class="fe kw kx ky kz b">Vec</code> <em class="lp">。</em></p><pre class="lr ls lt lu gt ne kz nf ng aw nh bi"><span id="bbf5" class="ni lw iq kz b gy nj nk l nl nm">struct Foo {<br/>    count: u8<br/>}</span><span id="9fc6" class="ni lw iq kz b gy no nk l nl nm">impl Iterator for Foo {                           // 1<br/>    type Item = u8;<br/>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br/>        match self.count {<br/>            0 =&gt; {<br/>                self.count = self.count + 1;<br/>                Option::Some(1)                   // 2<br/>            }<br/>            1 =&gt; {<br/>                self.count = self.count + 1;<br/>                Option::Some(5)                   // 2<br/>            }<br/>            _ =&gt; None                             // 2<br/>        }<br/>    }<br/>}</span><span id="3e3f" class="ni lw iq kz b gy no nk l nl nm">let i = Foo { count: 0 };<br/>let v = Vec::from_iter(i);                        // 3<br/>for value in v {<br/>    println!("value: {}", value);<br/>}</span></pre><ol class=""><li id="c932" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv nn lg lh li bi translated">实现我们自己的<code class="fe kw kx ky kz b">Iterator</code></li><li id="f3a3" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lg lh li bi translated">首先，返回<code class="fe kw kx ky kz b">1</code>，然后是<code class="fe kw kx ky kz b">5</code>，然后什么都没有</li><li id="79ee" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lg lh li bi translated">从我们的迭代器中创建一个<code class="fe kw kx ky kz b">Vec</code></li></ol><h1 id="df9c" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">存储器分配</h1><p id="a7a1" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">到目前为止我们忽略了<code class="fe kw kx ky kz b">Vec</code>的一个方面:定义其实是<code class="fe kw kx ky kz b">Vec&lt;T, A: Allocator = Global&gt;</code>。虽然<code class="fe kw kx ky kz b">T</code>是<code class="fe kw kx ky kz b">Vec</code>包含的项目类型，但是我们没有看<code class="fe kw kx ky kz b">A</code>，也就是<strong class="ka ir">分配内存</strong>。我不会详细描述这个主题，因为我目前缺乏相关的知识。然而，我认为提到它很有趣，因为我所知道的其他语言都没有提供这种挂钩。</p><blockquote class="my mz na"><p id="5a4a" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><em class="iq"/><code class="fe kw kx ky kz b"><em class="iq">Allocator</em></code><em class="iq">的实现可以通过</em> <code class="fe kw kx ky kz b"><em class="iq">Layout</em></code> <em class="iq">描述分配、增长、收缩和解除分配任意数据块。</em></p><p id="87d1" class="jy jz lp ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><em class="iq">—</em><a class="ae lj" href="https://doc.rust-lang.org/stable/std/alloc/trait.Allocator.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">STD::alloc::Allocator</em></a></p></blockquote><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/87a995d92e7d6edc7712925485b55697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OyLzRQWVPRUJwQMJ.png"/></div></figure><p id="d655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rust默认使用<code class="fe kw kx ky kz b">Global</code>内存分配器。它委托给另一个分配器:它是<code class="fe kw kx ky kz b">System</code>，除非你用<code class="fe kw kx ky kz b">#[global_allocator]</code>属性注册一个。</p><p id="77f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了<code class="fe kw kx ky kz b">Vec&lt;T, A&gt;</code>，就有可能使用不同于集中定义的分配器。一个可能的用例是创建一个分配器，只为一个<code class="fe kw kx ky kz b">Vec</code>实例跟踪分配的字节。</p><h1 id="d368" class="lv lw iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="7527" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我对<code class="fe kw kx ky kz b">Vec</code>的涉猎到此结束。在这篇文章中，我试图避免这类文章的通常处理，并探索一下周围的情况。虽然在大多数情况下不需要专用的内存分配器，但我认为这是一个很好的技巧，以防万一。</p><p id="8cc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="110d" class="la lb iq ka b kb kc kf kg kj lc kn ld kr le kv lf lg lh li bi translated"><a class="ae lj" href="https://doc.rust-lang.org/std/collections/index.html" rel="noopener ugc nofollow" target="_blank">模块标准::集合</a></li><li id="aa7b" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://doc.rust-lang.org/book/ch08-01-vectors.html" rel="noopener ugc nofollow" target="_blank">用向量存储值列表</a></li><li id="cb61" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="noopener ugc nofollow" target="_blank">结构标准::vec::Vec </a></li><li id="d010" class="la lb iq ka b kb lk kf ll kj lm kn ln kr lo kv lf lg lh li bi translated"><a class="ae lj" href="https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter" rel="noopener ugc nofollow" target="_blank">ITER和into_iter有什么区别？</a></li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="e220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lp">原载于</em> <a class="ae lj" href="https://blog.frankel.ch/start-rust/9/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">一个Java极客</em></a><em class="lp">2021年8月8日</em></p></div></div>    
</body>
</html>