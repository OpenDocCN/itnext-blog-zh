<html>
<head>
<title>Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Micronaut数据R2dbc和Kotlin协程构建Micronaut应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines-a1416db5a7d0?source=collection_archive---------1-----------------------#2021-12-08">https://itnext.io/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines-a1416db5a7d0?source=collection_archive---------1-----------------------#2021-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="706e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将继续探索Micronaut数据R2dbc，并用数据R2dbc和Kotlin协同例程重写前面的数据Jdbc/Kotlin示例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d38920140561b805e62148f808dfd013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qU5tVqVsr_jHM71udRktIw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@ling_gigi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Gigi </a>在<a class="ae lb" href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Jdbc不同，R2dbc是另一种RDBMS数据库连接规范，但它为用户提供了异步无阻塞API。R2dbc API完全兼容反应流规范。Kotlin协同程序是一个官方的Kotlin扩展，提供了一个基于事件循环的异步编程模型。</p><h1 id="2b65" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">入门指南</h1><p id="fd19" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">打开浏览器，导航到<a class="ae lb" href="https://micronaut.io/launch" rel="noopener ugc nofollow" target="_blank"> Micronaut Launch </a>为这篇文章生成一个新的项目框架。在此页面上选择以下项目。</p><ul class=""><li id="c527" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">Java版本:<strong class="jp ir"> 17 </strong></li><li id="0ffb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">语言:<strong class="jp ir">科特林</strong></li><li id="88ac" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">构建工具:<strong class="jp ir">格雷尔·科特林</strong></li><li id="2e24" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">测试框架:<strong class="jp ir"> Kotest </strong></li><li id="ffec" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">包含的特性:<strong class="jp ir"> data-r2dbc </strong>，<strong class="jp ir"> postgres </strong>，<strong class="jp ir">kot Lin-extension-functions</strong>等。</li></ul><p id="7baa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<strong class="jp ir">生成项目</strong>按钮，生成一个项目档案，下载后解压到磁盘，导入到你的IDE，比如IDEA。</p><p id="8993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<em class="mt"> pom.xml </em>文件，将Kotlin协程添加到项目依赖项中。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="d19a" class="mz ld iq mv b gy na nb l nc nd">//kotlin coroutines<br/>implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")<br/>implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")</span></pre><p id="fc22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ne nf ng mv b">kotlinx-coroutines-reactor</code>提供了反应器API和Kotlin协同程序API之间的交换。</p><p id="427b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建映射到数据库中表的实体。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="66d2" class="mz ld iq mv b gy na nb l nc nd">@MappedEntity(value = "posts", namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)<br/>data class Post(<br/>    @AutoPopulated//generated value UUID does not work here.<br/>    @field:Id var id: UUID? = null,<br/>    var title: String,<br/>    var content: String,<br/>    var status: Status? = Status.DRAFT,<br/>    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()<br/>)</span></pre><p id="dc01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Micronaut Data R2dbc不包含一个<code class="fe ne nf ng mv b">UUID</code> ID生成器策略，这里我们使用<code class="fe ne nf ng mv b">@AutoPopulated</code>在持久化到数据库之前生成一个随机UUID。</p><p id="8fe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为<code class="fe ne nf ng mv b">Post</code>实体创建一个存储库接口。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="6f94" class="mz ld iq mv b gy na nb l nc nd">@R2dbcRepository(dialect = Dialect.POSTGRES)<br/>interface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt;</span></pre><p id="c47f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Micronaut Data为ReactiveStreams API提供了几个知识库接口，对于Reactor用户来说，有<code class="fe ne nf ng mv b">ReactorCrudRepository</code>。<code class="fe ne nf ng mv b">CoroutineCrudRepository</code>是一个Kotlin协同程序兼容的存储库接口，它在函数中返回一个<em class="mt">暂停</em>结果。</p><blockquote class="nh ni nj"><p id="3d4d" class="jn jo mt jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated"><em class="iq"/><code class="fe ne nf ng mv b"><em class="iq">@R2dbcRepository</em></code><em class="iq">这里需要一个</em> <code class="fe ne nf ng mv b"><em class="iq">dialect</em></code> <em class="iq">，否则应用启动时会失败。</em></p></blockquote><p id="ad75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，<code class="fe ne nf ng mv b">JpaSpecificationExecutor</code>有一些反应流的变体，<code class="fe ne nf ng mv b">CoroutineJpaSpecificationExecutor</code>为Kotlin协程做好了准备。我们已经创建了一个<code class="fe ne nf ng mv b">Specificaitons</code>来设置查询、更新和删除操作的几个标准，我们将在本帖中重用它们。</p><p id="56af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们转到控制器，创建一个名为<code class="fe ne nf ng mv b">PostController</code>的新控制器类。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="6909" class="mz ld iq mv b gy na nb l nc nd">@Controller("/posts")<br/>class PostController(private val posts: PostRepository) {</span><span id="96e7" class="mz ld iq mv b gy nn nb l nc nd">    @Get(uri = "/", produces = [MediaType.APPLICATION_JSON])<br/>    fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll())</span><span id="93ed" class="mz ld iq mv b gy nn nb l nc nd">    @Get(uri = "/{id}", produces = [MediaType.APPLICATION_JSON])<br/>    suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {<br/>        val post = posts.findById(id) ?: return notFound()<br/>        return ok(post)<br/>    }</span><span id="2e8e" class="mz ld iq mv b gy nn nb l nc nd">    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])<br/>    suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; {<br/>        val saved = posts.save(body)<br/>        return created(URI.create("/posts/" + saved.id))<br/>    }<br/>}</span></pre><p id="2a0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它看起来非常类似于我们在上一篇文章中所做的Jdbc版本，但是这里我们返回一个特定于<code class="fe ne nf ng mv b">Flow</code>类型的Kotlin协同程序或者使用一个<code class="fe ne nf ng mv b">suspend</code>函数。区别在于所有这些方法都是在协程上下文中执行的。</p><p id="5dfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们试着通过一个<code class="fe ne nf ng mv b">DataInitializer</code> bean添加一些样本数据，这个bean监听一个<code class="fe ne nf ng mv b">ServerStartUpEvent</code>。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="757b" class="mz ld iq mv b gy na nb l nc nd">@Singleton<br/>class DataInitializer(private val posts: PostRepository) {</span><span id="cddb" class="mz ld iq mv b gy nn nb l nc nd">    @EventListener//does not support `suspend`<br/>    fun onStartUp(e: ServerStartupEvent) {<br/>        log.info("starting data initialization at StartUpEvent: $e")</span><span id="eea0" class="mz ld iq mv b gy nn nb l nc nd">        runBlocking {<br/>            val deleteAll = posts.deleteAll()<br/>            log.info("deleted posts: $deleteAll")</span><span id="518d" class="mz ld iq mv b gy nn nb l nc nd">            val data = listOf(<br/>                Post(title = "Building Restful APIs with Micronaut and Kotlin Coroutine", content = "test"),<br/>                Post(title = "Building Restful APIs with Micronaut and Kotlin Coroutine: part 2", content = "test")<br/>            )<br/>            data.forEach { log.debug("saving: $it") }<br/>            posts.saveAll(data)<br/>                .onEach { log.debug("saved post: $it") }<br/>                .onCompletion { log.debug("completed.") }<br/>                .flowOn(Dispatchers.IO)<br/>                .launchIn(this);<br/>        }</span><span id="ae6f" class="mz ld iq mv b gy nn nb l nc nd">        log.info("data initialization is done...")<br/>    }</span><span id="8260" class="mz ld iq mv b gy nn nb l nc nd">    companion object DataInitializer {<br/>        private val log = LoggerFactory.getLogger(DataInitializer::class.java)<br/>    }</span><span id="06dc" class="mz ld iq mv b gy nn nb l nc nd">}</span></pre><p id="1ec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ne nf ng mv b">EventListener</code>不支持<code class="fe ne nf ng mv b">suspend</code>功能，使用<code class="fe ne nf ng mv b">runBlocking</code>阻塞当前线程，依次运行<em class="mt">暂停</em>功能。</p><h1 id="fa7c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">JPA标准API</h1><p id="f4d9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Micronaut Data为Data Jdbc和Data R2dbc都提供了JPA criteria API支持，还为Reactive Streams API添加了一些<code class="fe ne nf ng mv b">JpaSpecificationExecutor</code>变体，如前几节所述，Kotlin协程有一个<code class="fe ne nf ng mv b">CoroutineJpaSpecificationExecutor</code>。</p><p id="c8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<code class="fe ne nf ng mv b">jakarta-persistence-api</code>添加到依赖关系中，以提供JPA标准API。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="1275" class="mz ld iq mv b gy na nb l nc nd">implementation("jakarta.persistence:jakarta.persistence-api:3.0.0")</span></pre><p id="b8c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重复使用我们在上一篇文章中创建的<code class="fe ne nf ng mv b">Specifications</code>。</p><p id="ea97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个测试来验证<code class="fe ne nf ng mv b">Specifications</code>中定义的标准。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="871c" class="mz ld iq mv b gy na nb l nc nd">@MicronautTest(environments = [Environment.TEST], startApplication = false)<br/>class PostRepositoryTest(<br/>    private val posts: PostRepository,<br/>    private val template: R2dbcOperations<br/>) : StringSpec({</span><span id="e0e2" class="mz ld iq mv b gy nn nb l nc nd">    "save and find posts" {<br/>        val sql = "insert into posts(title, content, status) values ($1, $2, $3)";<br/>        Mono<br/>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br/>                Mono.from(<br/>                    status.connection.createStatement(sql)<br/>                        .bind(0, "test title")<br/>                        .bind(1, "test content")<br/>                        .bind(2, "DRAFT")<br/>                        .execute()<br/>                ).flatMap { Mono.from(it.rowsUpdated) }<br/>            })<br/>            .log()<br/>            .`as` { StepVerifier.create(it) }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .verifyComplete()</span><span id="7368" class="mz ld iq mv b gy nn nb l nc nd">        runBlocking {<br/>            val all = posts.findAll().toList()<br/>            all shouldHaveSize 1<br/>            log.debug("all posts: $all")<br/>            all.map { it.title }.forAny { it shouldContain "test" }<br/>        }</span><span id="a9f6" class="mz ld iq mv b gy nn nb l nc nd">    }</span><span id="b01d" class="mz ld iq mv b gy nn nb l nc nd">    "find by title" {<br/>        val sql = "insert into posts(title, content, status) values ($1, $2, $3)";<br/>        Mono<br/>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br/>                Mono.from(<br/>                    status.connection.createStatement(sql)<br/>                        .bind(0, "test title")<br/>                        .bind(1, "test content")<br/>                        .bind(2, "DRAFT")<br/>                        .execute()<br/>                ).flatMap { Mono.from(it.rowsUpdated) }<br/>            })<br/>            .`as` { StepVerifier.create(it) }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .verifyComplete()</span><span id="9bb3" class="mz ld iq mv b gy nn nb l nc nd">        runBlocking {<br/>            val all = posts.findAll(Specifications.titleLike("test")).toList()<br/>            log.debug("all posts size:{}", all.size)<br/>            all shouldHaveSize 1</span><span id="0555" class="mz ld iq mv b gy nn nb l nc nd">            val all2 = posts.findAll(Specifications.titleLike("test2")).toList()<br/>            log.debug("all2 posts size:{}", all2.size)<br/>            all2 shouldHaveSize 0<br/>        }</span><span id="1eed" class="mz ld iq mv b gy nn nb l nc nd">    }</span><span id="7aeb" class="mz ld iq mv b gy nn nb l nc nd">    "find by keyword" {<br/>        val sql = "insert into posts(title, content, status) values ($1, $2, $3)";<br/>        Flux<br/>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br/>                val statement = status.connection.createStatement(sql)<br/>                statement<br/>                    .bind(0, "test title")<br/>                    .bind(1, "test content")<br/>                    .bind(2, "DRAFT")<br/>                    .add()<br/>                statement.bind(0, "test2 title")<br/>                    .bind(1, "test2 content")<br/>                    .bind(2, "DRAFT")<br/>                    .add()</span><span id="c95b" class="mz ld iq mv b gy nn nb l nc nd">                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br/>            })<br/>            .`as` { StepVerifier.create(it) }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .verifyComplete()</span><span id="1afd" class="mz ld iq mv b gy nn nb l nc nd">        runBlocking {<br/>            val all = posts.findAll(Specifications.byKeyword("test")).toList()<br/>            log.debug("all posts size:{}", all.size)<br/>            all shouldHaveSize 2</span><span id="3639" class="mz ld iq mv b gy nn nb l nc nd">            val all2 = posts.findAll(Specifications.byKeyword("test2")).toList()<br/>            log.debug("all2 posts size:{}", all2.size)<br/>            all2 shouldHaveSize 1<br/>        }<br/>    }</span><span id="e4a1" class="mz ld iq mv b gy nn nb l nc nd">    "update posts" {<br/>        val sql = "insert into posts(title, content, status) values ($1, $2, $3)";<br/>        Flux<br/>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br/>                val statement = status.connection.createStatement(sql)<br/>                statement<br/>                    .bind(0, "test title")<br/>                    .bind(1, "test content")<br/>                    .bind(2, "PENDING_MODERATED")<br/>                    .add()</span><span id="91c8" class="mz ld iq mv b gy nn nb l nc nd">                statement<br/>                    .bind(0, "test2 title")<br/>                    .bind(1, "test2 content")<br/>                    .bind(2, "PENDING_MODERATED")<br/>                    .add()</span><span id="fde9" class="mz ld iq mv b gy nn nb l nc nd">                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br/>            })<br/>            .`as` { StepVerifier.create(it) }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .verifyComplete()</span><span id="53fd" class="mz ld iq mv b gy nn nb l nc nd">        runBlocking {<br/>            val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br/>            log.debug("updated posts size:{}", updated)<br/>            updated shouldBe 2</span><span id="6433" class="mz ld iq mv b gy nn nb l nc nd">            val all = posts.findAll().toList()<br/>            all shouldHaveSize 2<br/>            all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br/>        }<br/>    }</span><span id="6b11" class="mz ld iq mv b gy nn nb l nc nd">    "remove posts" {<br/>        val sql = "insert into posts(title, content, status) values ($1, $2, $3)";<br/>        Flux<br/>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br/>                val statement = status.connection.createStatement(sql)<br/>                statement<br/>                    .bind(0, "test title")<br/>                    .bind(1, "test content")<br/>                    .bind(2, "REJECTED")<br/>                    .add()<br/>                statement<br/>                    .bind(0, "test2 title")<br/>                    .bind(1, "test2 content")<br/>                    .bind(2, "DRAFT")<br/>                    .add()</span><span id="bc19" class="mz ld iq mv b gy nn nb l nc nd">                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br/>            })<br/>            .`as` { StepVerifier.create(it) }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br/>            .verifyComplete()</span><span id="13d8" class="mz ld iq mv b gy nn nb l nc nd">        runBlocking {<br/>            val deleted = posts.deleteAll(Specifications.removeAllRejected())<br/>            log.debug("deleted posts size:{}", deleted)<br/>            deleted shouldBe 1</span><span id="0400" class="mz ld iq mv b gy nn nb l nc nd">            val all = posts.findAll().toList()<br/>            all shouldHaveSize 1<br/>            all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br/>        }<br/>    }</span><span id="1290" class="mz ld iq mv b gy nn nb l nc nd">}) {<br/>    companion object {<br/>        private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java)<br/>    }</span><span id="ac53" class="mz ld iq mv b gy nn nb l nc nd">    override fun beforeEach(testCase: TestCase) {<br/>        val sql = "delete from posts";</span><span id="5d32" class="mz ld iq mv b gy nn nb l nc nd">        val latch = CountDownLatch(1)<br/>        Mono<br/>            .from(<br/>                this.template.withConnection { conn: Connection -&gt;<br/>                    Mono.from(conn.beginTransaction())<br/>                        .then(Mono.from(conn.createStatement(sql).execute())<br/>                            .flatMap { Mono.from(it.rowsUpdated) }<br/>                            .doOnNext { log.debug("deleted rows: $it ") }<br/>                        )<br/>                        .then(Mono.from(conn.commitTransaction()))<br/>                        .doOnError { Mono.from(conn.rollbackTransaction()).then() }<br/>                }<br/>            )<br/>            .log()<br/>            .doOnTerminate { latch.countDown() }<br/>            .subscribe(<br/>                { data -&gt; log.debug("deleted posts: $data ") },<br/>                { error -&gt; log.error("error of cleaning posts: $error") },<br/>                { log.info("done") }<br/>            )</span><span id="485e" class="mz ld iq mv b gy nn nb l nc nd">        latch.await(5000, TimeUnit.MILLISECONDS)<br/>    }<br/>}</span></pre><p id="50ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将现有的Jdbc版本转换为R2dbc，主要有一些不同。</p><ul class=""><li id="345c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">与阻塞<code class="fe ne nf ng mv b">TransactionOperations</code>类似，<code class="fe ne nf ng mv b">R2dbcOperations</code>提供了<code class="fe ne nf ng mv b">withConnection</code>和<code class="fe ne nf ng mv b">withTransaction</code>来将数据操作包装在连接或事务边界内。</li><li id="4772" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">R2dbc <code class="fe ne nf ng mv b">Connection</code>基于ReactiveStreams API。</li><li id="8c70" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将参数绑定到SQL语句时，参数索引从<strong class="jp ir"> 0 </strong>开始。</li><li id="5399" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">SQL参数占位符依赖于数据库本身，例如，Postgres使用<code class="fe ne nf ng mv b">$1</code>、<code class="fe ne nf ng mv b">$2</code>...</li></ul><h1 id="dc0f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">测试控制器</h1><p id="546a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这篇文章中，我们仍然使用Kotest作为测试框架，正如你在上面的<code class="fe ne nf ng mv b">PostRepositoryTest</code>中看到的，我们使用一个<code class="fe ne nf ng mv b">runBlocking</code>将协程的执行封装在一个阻塞的上下文中。</p><p id="39ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ne nf ng mv b">kotlinx-coroutines-test</code>提供了一些助手来简化Kotlin协程的测试，例如<code class="fe ne nf ng mv b">runBlockingTest</code>等。将<code class="fe ne nf ng mv b">kotlinx-coroutines-test</code>添加到测试依赖项中。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="b161" class="mz ld iq mv b gy na nb l nc nd">//gradle.properties<br/>kotlinCoVersion=1.6.0-RC</span><span id="93dc" class="mz ld iq mv b gy nn nb l nc nd">//build.gradle.kt<br/>val kotlinCoVersion=project.properties.get("kotlinCoVersoin")</span><span id="001e" class="mz ld iq mv b gy nn nb l nc nd">//update versions of kotlin coroutines<br/>implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}")<br/>implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}")</span><span id="e38e" class="mz ld iq mv b gy nn nb l nc nd">testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}")</span></pre><blockquote class="nh ni nj"><p id="940d" class="jn jo mt jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated"><em class="iq">还有一个</em> <a class="ae lb" href="https://stackoverflow.com/questions/70243380/test-kotlin-coroutines-with-runblockingtest-failed" rel="noopener ugc nofollow" target="_blank"> <em class="iq">的问题</em> </a> <em class="iq">要在一次测试中使用</em> <code class="fe ne nf ng mv b"><em class="iq">runBlockingTest</em></code> <em class="iq">，确保你使用的是最新的1.6.0-RC，而使用</em> <code class="fe ne nf ng mv b"><em class="iq">runTest</em></code> <em class="iq">代替。</em></p></blockquote><p id="5ff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于<code class="fe ne nf ng mv b">runBlocking</code>，您可以使用<code class="fe ne nf ng mv b">runTest</code>来包装测试功能。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="14a0" class="mz ld iq mv b gy na nb l nc nd">@Test<br/>fun `test GET all posts endpoint with runTest`() = runTest {<br/>    val response = client.exchange("/posts", Array&lt;Post&gt;::class.java).awaitSingle()<br/>    response.status shouldBe HttpStatus.OK<br/>    response.body()!!.map { it.title }.forAny {<br/>        it shouldContain "Micronaut"<br/>    }<br/>}</span></pre><blockquote class="nh ni nj"><p id="a65d" class="jn jo mt jp b jq jr js jt ju jv jw jx nk jz ka kb nl kd ke kf nm kh ki kj kk ij bi translated"><em class="iq"/><code class="fe ne nf ng mv b"><em class="iq">runBlockingTest</em></code><em class="iq">在Kotlin协程的最新1.6.0版本中已被弃用。</em></p></blockquote><p id="989b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以在测试控制器时模拟存储库，就像我们在上一篇文章中所做的那样。Mockk为Kotlin协程提供了一些变种，比如<code class="fe ne nf ng mv b">coEvery</code>、<code class="fe ne nf ng mv b">coVerify</code>等。</p><pre class="km kn ko kp gt mu mv mw mx aw my bi"><span id="9292" class="mz ld iq mv b gy na nb l nc nd">@MicronautTest(environments = ["mock"])<br/>class PostControllerTest(<br/>    private val postRepository: PostRepository,<br/>    @Client("/") private var client: HttpClient<br/>) : FunSpec({</span><span id="fe1a" class="mz ld iq mv b gy nn nb l nc nd">    test("test get posts endpoint") {<br/>        val posts = getMock(postRepository)<br/>        coEvery { posts.findAll() }<br/>            .returns(<br/>                flowOf(<br/>                    Post(<br/>                        id = UUID.randomUUID(),<br/>                        title = "test title",<br/>                        content = "test content",<br/>                        status = Status.DRAFT,<br/>                        createdAt = LocalDateTime.now()<br/>                    )<br/>                )<br/>            )<br/>        val response = client.toBlocking().exchange("/posts", Array&lt;Post&gt;::class.java)</span><span id="cc99" class="mz ld iq mv b gy nn nb l nc nd">        response.status shouldBe HttpStatus.OK<br/>        response.body()!![0].title shouldBe "test title"</span><span id="2a1f" class="mz ld iq mv b gy nn nb l nc nd">        coVerify(exactly = 1) { posts.findAll() }<br/>    }<br/>}) {<br/>    @MockBean(PostRepository::class)<br/>    fun mockedPostRepository() = mockk&lt;PostRepository&gt;()<br/>}</span></pre><p id="22b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，为<code class="fe ne nf ng mv b">PostRepository</code>创建一个模拟bean，然后用<code class="fe ne nf ng mv b">coEvery</code>进行存根化，并用<code class="fe ne nf ng mv b">coVerify</code>子句验证模拟中的调用。</p><h2 id="2868" class="mz ld iq bd le no np dn li nq nr dp lm jy ns nt lq kc nu nv lu kg nw nx ly ny bi translated">从我的Github获取完整的<a class="ae lb" href="https://github.com/hantsy/micronaut-sandbox/tree/master/r2dbc-kotlin-co" rel="noopener ugc nofollow" target="_blank">源代码</a>。</h2></div></div>    
</body>
</html>