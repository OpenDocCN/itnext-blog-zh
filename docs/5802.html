<html>
<head>
<title>MutableSharedFlow is kind of complicated</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可变共享流有点复杂</h1>
<blockquote>原文：<a href="https://itnext.io/mutablesharedflow-is-kind-of-complicated-61af68011eae?source=collection_archive---------0-----------------------#2021-05-28">https://itnext.io/mutablesharedflow-is-kind-of-complicated-61af68011eae?source=collection_archive---------0-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/75e0648f9a871d227da17e3c28882c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a9NuqdlUAPVASaR5"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@usmanyousaf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乌斯曼·优素福</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="6e87" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Kotlin协同程序版本<code class="fe lb lc ld le b">1.5.0</code>、<code class="fe lb lc ld le b">BroadcastChannel</code>和<code class="fe lb lc ld le b">ConflatedBroadcastChannel</code>开始被标记为<code class="fe lb lc ld le b">ObsoleteCoroutinesApi</code>，开发者现在应该使用<code class="fe lb lc ld le b">SharedFlow</code>和<code class="fe lb lc ld le b">StateFlow</code>来代替。</p><p id="4ba5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin文档甚至给出了如何从这些通道迁移到各自的流API的便捷指南:</p><blockquote class="lf lg lh"><p id="6a48" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated">要将<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-broadcast-channel/index.html" rel="noopener ugc nofollow" target="_blank"> BroadcastChannel </a>用法迁移到<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/index.html" rel="noopener ugc nofollow" target="_blank"> SharedFlow </a>，首先用<code class="fe lb lc ld le b">MutableSharedFlow(0, extraBufferCapacity=capacity)</code>替换<code class="fe lb lc ld le b">BroadcastChannel(capacity)</code>构造函数的用法(广播频道不会向新订户重播值)。将<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html" rel="noopener ugc nofollow" target="_blank"> send </a>和<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/try-send.html" rel="noopener ugc nofollow" target="_blank"> trySend </a>呼叫替换为<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/emit.html" rel="noopener ugc nofollow" target="_blank"> emit </a>和<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/try-emit.html" rel="noopener ugc nofollow" target="_blank"> tryEmit </a>，并将用户代码转换为流量运营商。</p></blockquote><p id="2a0c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，但是也许你会对这个参数<code class="fe lb lc ld le b">extraBufferCapacity</code>感到疑惑。它实际上是做什么的？而且<code class="fe lb lc ld le b">MutableSharedFlow</code>不是已经有<code class="fe lb lc ld le b">replay</code>参数了吗？有什么区别？</p><h2 id="8b16" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">证明文件</h2><p id="3f11" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在这种情况下，查看文档对这两个参数的描述通常是有用的(唉，并不总是有用的):</p><blockquote class="lf lg lh"><p id="cf1e" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated"><code class="fe lb lc ld le b">replay</code> -重放给新订户的值的数量(不能为负数，默认为零)。</p><p id="9004" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated"><code class="fe lb lc ld le b">extraBufferCapacity</code> -除了<code class="fe lb lc ld le b">replay</code>之外缓冲的值的数量。<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/emit.html" rel="noopener ugc nofollow" target="_blank">发射</a>在有缓冲空间剩余时不暂停(可选，不能为负，默认为零)。</p></blockquote><p id="5ed0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不知道你怎么想，但对我来说，这并不十分清楚上面提出的那些问题。我知道<code class="fe lb lc ld le b">replay</code>是做什么的，但是在阅读了文档之后，<code class="fe lb lc ld le b">extraBufferCapacity</code>仍然和我研究它之前一样难以捉摸。而这个参数<strong class="kf jh">的某些<strong class="kf jh">后果</strong>在第一次通读后根本不明显</strong>。</p><p id="6f29" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候深入挖掘和研究这些概念了。</p><h2 id="92a1" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">重播</h2><p id="3792" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">Replay参数很容易解释，熟悉RxJava的人会非常了解这个参数。本质上，用<code class="fe lb lc ld le b">replay=x</code>创建一个<code class="fe lb lc ld le b">MutableSharedFlow</code>和在RxJava中创建<code class="fe lb lc ld le b">ReplaySubject</code>是一回事。</p><p id="0633" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看这段代码:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="63f6" class="lm ln jg le b gy ms mt l mu mv"><em class="li">runBlocking </em><strong class="le jh">{<br/>    </strong>val testFlow = <em class="li">MutableSharedFlow</em>&lt;String&gt;()<br/>    testFlow.tryEmit("a")<br/>    val job = testFlow<br/>        .<em class="li">onEach </em><strong class="le jh">{ </strong><em class="li">println</em>(<strong class="le jh">it</strong>) <strong class="le jh">}<br/>        </strong>.<em class="li">launchIn</em>(this)<br/>    delay(100) <em class="li">// to give enough time for println to be executed before cancelling job<br/>    </em>job.cancel()<br/><strong class="le jh">}</strong></span></pre><p id="6828" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码的预期输出是什么？</p><p id="2743" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">….</p><p id="cc72" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，实际上<strong class="kf jh">没有输出</strong>。为什么？</p><p id="7b76" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为首先向<code class="fe lb lc ld le b">testFlow</code>发出一个值，而<code class="fe lb lc ld le b">testFlow</code>仅在发出一个值后<strong class="kf jh">才被收集。在执行这一行代码时，没有人在监听事件:<code class="fe lb lc ld le b">testFlow.tryEmit(“test”)</code>。</strong></p><p id="1e4f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果您想要缓存事件直到流被实际收集，您可以使用参数<code class="fe lb lc ld le b">replay</code>。该值是一个整数，指定应该缓存多少个最后事件。对于这个例子，让我们用<code class="fe lb lc ld le b">replay=1</code>来解决。现在让我们检查这段代码:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="aeee" class="lm ln jg le b gy ms mt l mu mv"><em class="li">runBlocking </em><strong class="le jh">{<br/>    </strong>val testFlow = <em class="li">MutableSharedFlow</em>&lt;String&gt;(replay = 1)<br/>    testFlow.tryEmit("a")<br/>    testFlow.tryEmit("b")<br/>    val job = testFlow<br/>        .<em class="li">onEach </em><strong class="le jh">{ </strong><em class="li">println</em>(<strong class="le jh">it</strong>) <strong class="le jh">}<br/>        </strong>.<em class="li">launchIn</em>(this)<br/>    delay(100) <em class="li">// to give enough time for println to be executed before cancelling job<br/>    </em>job.cancel()<br/><strong class="le jh">}</strong></span></pre><p id="3a0f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量是多少？</p><p id="b85e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">…</p><p id="8a42" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是<code class="fe lb lc ld le b">b</code>。为什么？</p><p id="b5ab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经指定了<code class="fe lb lc ld le b">replay=1</code>，这意味着最后一个<code class="fe lb lc ld le b">1</code>事件将被缓存，以供所有将来的收集器使用。有两个事件发送到<code class="fe lb lc ld le b">testFlow</code>，分别是<code class="fe lb lc ld le b">a</code>和<code class="fe lb lc ld le b">b</code>(按此顺序)。最后发出的事件是<code class="fe lb lc ld le b">b</code>,因此这是将要发出的事件。</p><p id="bf01" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，如果我们稍后再添加一个或多个收集器，它们仍然会收到这个<code class="fe lb lc ld le b">b</code>值。按照这个例子:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="b4d3" class="lm ln jg le b gy ms mt l mu mv"><em class="li">runBlocking </em><strong class="le jh">{<br/>    </strong>val testFlow = <em class="li">MutableSharedFlow</em>&lt;String&gt;(replay = 1)<br/>    testFlow.tryEmit("a")<br/>    testFlow.tryEmit("b")<br/>    val job = testFlow<br/>        .<em class="li">onEach </em><strong class="le jh">{ </strong><em class="li">println</em>(<strong class="le jh">it</strong>) <strong class="le jh">}<br/>        </strong>.<em class="li">launchIn</em>(this)<br/>    delay(100) <em class="li">// to give enough time for println to be executed before cancelling job<br/><br/><br/>    </em>val job2 = testFlow<br/>        .<em class="li">onEach </em><strong class="le jh">{ </strong><em class="li">println</em>(<strong class="le jh">it</strong>) <strong class="le jh">}<br/>        </strong>.<em class="li">launchIn</em>(this)<br/><br/>    job.cancel()<br/>    delay(100)<br/>    job2.cancel()<br/><strong class="le jh">}</strong></span></pre><p id="0be9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次的输出是:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="7a6e" class="lm ln jg le b gy ms mt l mu mv">b<br/>b</span></pre><p id="2df0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为使用<code class="fe lb lc ld le b">replay</code>缓存是为所有未来的收集者保留的。</p><p id="d9ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，很好，但是有时你不想要这种行为。有时，如果没有人在听，没关系，你想丢弃那些事件，不缓存它们。例如，让我们说你的<code class="fe lb lc ld le b">MutableSharedFlow</code>发送地理位置数据给收藏家。您可能不希望任何下一个收集器接收一些缓存的值，您可能宁愿等待下一个(更新的)值。在这种情况下，指定<code class="fe lb lc ld le b">reply=0</code>(或者不指定任何值，因为缺省值是<code class="fe lb lc ld le b">0</code>)是可行的方法。(对于Rx人来说，这大概相当于使用<code class="fe lb lc ld le b">PublishSubject</code>。</p><p id="9c06" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这种方法可能会出什么问题呢？</p><p id="98b2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，有一个问题你需要小心。</p><h2 id="655d" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">tryEmit和非阻塞协同作用域</h2><p id="68ab" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在前面的例子中，我们在阻塞<code class="fe lb lc ld le b">CoroutineScope</code>(由<code class="fe lb lc ld le b">runBlocking {}</code>创建)中收集流。</p><p id="f4c9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在应用程序的实际情况中，您可能会使用不同的协程作用域，或者是您的平台提供的，或者是您自己使用<code class="fe lb lc ld le b">CoroutineScope()</code>方法创建的。</p><p id="bf2e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码可以分布在多个文件中，假设您想要使用<code class="fe lb lc ld le b">tryEmit</code>，而不是<code class="fe lb lc ld le b">emit</code>，因为您想要从一个普通函数中发出事件，而不是从一个挂起的函数中发出事件(在一个协程之外)。</p><p id="114a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码模拟了这些条件:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="3935" class="lm ln jg le b gy ms mt l mu mv">fun main() {<br/>    val testSharedFlow = MutableSharedFlow&lt;String&gt;()</span><span id="abd3" class="lm ln jg le b gy mw mt l mu mv">    runBlocking {<br/>        CoroutineScope(Job()).launch {<br/>            testSharedFlow<br/>                .onStart { println("start") }<br/>                .collect { println(it) }<br/>        }</span><span id="6179" class="lm ln jg le b gy mw mt l mu mv">        delay(100) // to give enough time for println to be executed before execution finishes<br/>    }</span><span id="018d" class="lm ln jg le b gy mw mt l mu mv">    testSharedFlow.tryEmit("a")<br/>    testSharedFlow.tryEmit("b")<br/>}</span></pre><p id="022a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这段代码会输出什么呢？事件是在一个收集器开始收集之后发出的，所以我们应该看到<code class="fe lb lc ld le b">a</code>和<code class="fe lb lc ld le b">b</code>都发出了，<em class="li">对吗</em>？</p><h2 id="9ff5" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">不</h2><p id="a1a0" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">令人惊讶的答案是，我们只会收到上面这段代码的输出<code class="fe lb lc ld le b">start</code>。怎么回事？</p><p id="c6d5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回答起来会有点复杂，但是请继续听我说。</p><p id="4be4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须考虑这个过程中涉及的两方。<strong class="kf jh"> <em class="li">发射极</em> </strong>和<strong class="kf jh"> <em class="li">集电极</em> </strong>。<em class="li">发射器</em>是将事件推给<code class="fe lb lc ld le b">MutableSharedFlow</code>的发射器。<em class="li">收藏者</em>正在从流中阅读。</p><p id="6aab" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="li">发射极</em>和<em class="li">集电极</em>相互独立。<strong class="kf jh"> <em class="li">发射器</em> </strong>试图<strong class="kf jh">向<code class="fe lb lc ld le b">MutableSharedFlow</code>发射</strong>一个事件，它们<strong class="kf jh">不一定要等待</strong>等待<code class="fe lb lc ld le b">Collectors</code>来收集它们。</p><p id="d59d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在收集到事件之前不阻塞线程，<code class="fe lb lc ld le b">tryEmit</code>方法所做的是向<code class="fe lb lc ld le b">MutableSharedFlow</code>的缓存发送一个值。如果您使用<code class="fe lb lc ld le b">replay=1</code>或更多，那么您可以指定一些缓冲区大小(<code class="fe lb lc ld le b">1</code>或更多)，事件将被保存在缓存中，直到被收集器收集。否则，<strong class="kf jh">缓存大小为0 </strong>，因此事件只是<strong class="kf jh">被丢弃</strong>。</p><p id="5a80" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是正如我们上面讨论的，有些情况下，使用<code class="fe lb lc ld le b">replay</code>是不可接受的。如何解决这个问题？</p><h2 id="77db" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">选项1:用emit代替tryEmit</h2><p id="c90c" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">一种方法是使用<code class="fe lb lc ld le b">emit</code>而不是<code class="fe lb lc ld le b">tryEmit</code>:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="5420" class="lm ln jg le b gy ms mt l mu mv">fun main() {<br/>    val testSharedFlow = MutableSharedFlow&lt;String&gt;()</span><span id="f0bf" class="lm ln jg le b gy mw mt l mu mv">    runBlocking {<br/>        CoroutineScope(Job()).launch {<br/>            testSharedFlow<br/>                .onStart { println("start") }<br/>                .collect { println(it) }<br/>        }</span><span id="cfd0" class="lm ln jg le b gy mw mt l mu mv">        delay(100) // to give enough time for println to be executed before execution finishes<br/>    }<br/>    <br/>    runBlocking { <br/>        testSharedFlow.emit("a")<br/>        testSharedFlow.emit("b")<br/>    }<br/>}</span></pre><p id="f736" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次输出将如下所示:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="ff2a" class="lm ln jg le b gy ms mt l mu mv">start<br/>a<br/>b</span></pre><p id="fac1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，为什么这种方法一开始就应该有效呢？</p><p id="c2f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是因为<code class="fe lb lc ld le b">emit</code>是一个悬浮函数。所以<code class="fe lb lc ld le b">emit</code>实际上可以等待收集器处理事件，并在此之后继续执行剩余的代码。</p><p id="31d7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，但这有点作弊。还记得我们上面说过的，我们想要特别使用<code class="fe lb lc ld le b">tryEmit</code>以便我们也可以在协程之外发出事件吗？作为一个暂停函数，我们不得不在协程中调用它。如何才能让<code class="fe lb lc ld le b">tryEmit</code>发挥作用？</p><h2 id="6276" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">选项2:额外缓冲能力</h2><p id="e1ac" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">如果你还记得这篇文章是如何开始的，我们对这个参数<code class="fe lb lc ld le b">extraBufferCapacity</code>很好奇。</p><p id="a9ac" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先在实践中看到再讨论，到底是怎么回事。按照迁移指南，我们可能会得到类似这样的结果:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="6711" class="lm ln jg le b gy ms mt l mu mv">fun main() {<br/>    val testSharedFlow = MutableSharedFlow&lt;String&gt;(extraBufferCapacity = 1)</span><span id="de02" class="lm ln jg le b gy mw mt l mu mv">    runBlocking {<br/>        CoroutineScope(Job()).launch {<br/>            testSharedFlow<br/>                .onStart { println("start") }<br/>                .collect { println(it) }<br/>        }</span><span id="fdc8" class="lm ln jg le b gy mw mt l mu mv">        delay(1000) // to give enough time for println to be executed before execution finishes<br/>    }</span><span id="283b" class="lm ln jg le b gy mw mt l mu mv">    testSharedFlow.tryEmit("a")<br/>    testSharedFlow.tryEmit("b")<br/>    runBlocking { delay(100) } // to give enough time for println to be executed before execution finishes<br/>}</span></pre><p id="5876" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码的输出将是:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="76b6" class="lm ln jg le b gy ms mt l mu mv">start<br/>a</span></pre><p id="1e59" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，那么为什么我们现在只看到了<code class="fe lb lc ld le b">a</code>？<code class="fe lb lc ld le b">b</code>去哪了？为什么我们会看到<code class="fe lb lc ld le b">a</code>？</p><p id="14a1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们回到我们说过的<code class="fe lb lc ld le b">tryEmit</code>方法:</p><blockquote class="lf lg lh"><p id="e035" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated">为了在收集到事件之前不阻塞线程，方法<code class="fe lb lc ld le b">tryEmit</code>所做的是向<code class="fe lb lc ld le b">MutableSharedFlow</code>的缓存发送一个值。</p></blockquote><p id="8038" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没错。而当你创建一个像这样的可变共享流<code class="fe lb lc ld le b">MutableSharedFlow&lt;String&gt;()</code>时，内部缓存大小为0。</p><p id="a2ae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，由于缓存大小为0，事件会被立即丢弃。现在你可能开始明白了。<code class="fe lb lc ld le b">extraBufferCapacity</code>参数指定由<code class="fe lb lc ld le b">tryEmit</code>(或者在某些情况下甚至是<code class="fe lb lc ld le b">emit</code>)发送到<code class="fe lb lc ld le b">MutableSharedFlow</code>的事件的缓存大小，而不会导致新收集器的任何事件重放。</p><p id="1161" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为在上面的例子中<code class="fe lb lc ld le b">extraBufferCapacity</code>被设置为<code class="fe lb lc ld le b">1</code>，所以只有一个事件被缓存，那就是<code class="fe lb lc ld le b">a</code>。</p><h2 id="f1bf" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">但是为什么是a呢？为什么不是b？</h2><p id="79a0" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这听起来很可疑，不是吗？在一个类似的例子中指定<code class="fe lb lc ld le b">replay=1</code>输出<code class="fe lb lc ld le b">b</code>，<code class="fe lb lc ld le b">extraBufferCapacity=1</code>输出<code class="fe lb lc ld le b">a</code>。太奇怪了。为什么？</p><p id="6c0f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原因是，重放高速缓存试图重放传递给它的最后的<strong class="kf jh">事件。所以当一个新的事件进来时，重放缓存只是<code class="fe lb lc ld le b">1</code>，它将覆盖那个事件。有点道理。</strong></p><p id="0484" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了<code class="fe lb lc ld le b">extraBufferCapacity</code>，那一个就只剩下给<a class="ae jd" href="https://elizarov.medium.com/shared-flows-broadcast-channels-899b675e805c" rel="noopener">提供缓冲的<strong class="kf jh">快</strong> <em class="li">发射极</em>和<strong class="kf jh">慢</strong>集电极 </a>了。也就是说，如果<em class="li">发射器</em>产生事件的速度快于<em class="li">收集器</em>收集事件的速度。默认情况下，第一个事件被缓存，当缓存满后，任何其他事件都会被丢弃。类似于如果<code class="fe lb lc ld le b">extraBufferCapacity</code>是<code class="fe lb lc ld le b">0</code>——这实际上是默认值。</p><h2 id="b0bb" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">但是我不想放弃新的事件:-(</h2><p id="a768" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">正如我上面写的，这是默认行为。然而，这种默认行为可能不符合您的需求。幸运的是，有一种方法可以改变默认行为，通过指定参数<code class="fe lb lc ld le b">onBufferOverflow</code>。</p><p id="bf59" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，让我们看看文档对这个参数有什么说明:</p><blockquote class="lf lg lh"><p id="9d8d" class="kd ke li kf b kg kh ki kj kk kl km kn lj kp kq kr lk kt ku kv ll kx ky kz la ij bi translated"><code class="fe lb lc ld le b">onBufferOverflow</code> -配置缓冲区溢出时的<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/emit.html" rel="noopener ugc nofollow" target="_blank">发射</a>动作。可选，默认为<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-buffer-overflow/-s-u-s-p-e-n-d.html" rel="noopener ugc nofollow" target="_blank">暂停</a>尝试发出一个值。除了<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-buffer-overflow/-s-u-s-p-e-n-d.html" rel="noopener ugc nofollow" target="_blank"> BufferOverflow以外的值。只有在<code class="fe lb lc ld le b">replay &gt; 0</code>或<code class="fe lb lc ld le b">extraBufferCapacity &gt; 0</code>时才支持暂停</a>。<strong class="kf jh">仅当至少有一个订户未准备好接受新值时，缓冲区溢出才会发生。</strong>在没有用户的情况下，仅存储最近的<a class="ae jd" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow.html#kotlinx.coroutines.flow$MutableSharedFlow(kotlin.Int,%20kotlin.Int,%20kotlinx.coroutines.channels.BufferOverflow)/replay" rel="noopener ugc nofollow" target="_blank">重放</a>值，缓冲区溢出行为不会被触发，也不会产生影响。</p></blockquote><p id="ca89" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及<code class="fe lb lc ld le b">BufferOverflow</code>的哪些值可用？是<code class="fe lb lc ld le b">SUSPEND</code>、<code class="fe lb lc ld le b">DROP_OLDEST</code>和<code class="fe lb lc ld le b">DROP_LATEST</code>。<code class="fe lb lc ld le b">SUSPEND</code>策略在上面的文档中有解释，与我上面写的关于<code class="fe lb lc ld le b">emit</code>方法的内容一致，增加了一些细节，关于它什么时候真正挂起，什么时候可以立即执行。</p><p id="e078" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能已经猜到，为了保留新事件，丢弃旧事件，应该使用<code class="fe lb lc ld le b">BufferOverflow.DROP_OLDEST</code>策略。事实上这段代码:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="d7a0" class="lm ln jg le b gy ms mt l mu mv">fun main() {<br/>    val testSharedFlow = MutableSharedFlow&lt;String&gt;(extraBufferCapacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)</span><span id="fa82" class="lm ln jg le b gy mw mt l mu mv">    runBlocking {<br/>        CoroutineScope(Job()).launch {<br/>            testSharedFlow<br/>                .onStart { println("start") }<br/>                .collect { println(it) }<br/>        }</span><span id="7290" class="lm ln jg le b gy mw mt l mu mv">    delay(100) // to give enough time for println to be executed before cancelling job<br/>    }</span><span id="c536" class="lm ln jg le b gy mw mt l mu mv">    testSharedFlow.tryEmit("a")<br/>    testSharedFlow.tryEmit("b")<br/>    runBlocking { delay(100) }<br/>}</span></pre><p id="7293" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将输出:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="ff44" class="lm ln jg le b gy ms mt l mu mv">start<br/>b</span></pre><p id="977f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是你通常想要的。</p><p id="b3a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果您不想错过任何事件，甚至将<code class="fe lb lc ld le b">extraBufferCapacity</code>增加到更大的值也是明智的。</p><h2 id="d8bd" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">最后的想法</h2><p id="2b7f" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">希望这篇文章对正确使用<code class="fe lb lc ld le b">MutableSharedFlow</code>有所启发。正如您所见，使用开箱即用的<code class="fe lb lc ld le b">MutableSharedFlow</code>并不像听起来那么简单。此外，文档描述的迁移模式虽然等同于以前的<code class="fe lb lc ld le b">BroadcastChannel</code>API，但不一定是您可能<strong class="kf jh">需要的</strong>(您可能需要在您的应用程序中指定<code class="fe lb lc ld le b">onBufferOverflow = BufferOverflow.DROP_OLDEST</code>，这取决于您的用例)。</p><p id="fd07" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="li">注意:根据这篇文章，我已经建议去掉</em> <code class="fe lb lc ld le b"><em class="li">replay</em></code> <em class="li">和</em> <code class="fe lb lc ld le b"><em class="li">extraBufferCapacity</em></code> <em class="li">参数的默认值，因为我认为默认值会导致意想不到的行为，并且可能会在许多应用程序中引入未被注意到的错误。可以在这里支持这个提议:<br/></em><a class="ae jd" href="https://github.com/Kotlin/kotlinx.coroutines/issues/2387#issuecomment-850774203" rel="noopener ugc nofollow" target="_blank"><em class="li">https://github . com/kot Lin/kot linx . coroutines/issues/2387 # issue comment-850774203</em></a></p></div></div>    
</body>
</html>