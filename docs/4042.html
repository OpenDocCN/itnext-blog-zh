<html>
<head>
<title>Under-the-hood of React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩的引擎盖下</h1>
<blockquote>原文：<a href="https://itnext.io/under-the-hood-of-react-hooks-805dc68581c3?source=collection_archive---------1-----------------------#2020-04-15">https://itnext.io/under-the-hood-of-react-hooks-805dc68581c3?source=collection_archive---------1-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3253" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React充满了有趣的设计模式，当钩子被引入时，它清理了人们在更令人沮丧的特性上的许多问题，比如类和生命周期方法。今天我们将看看如何用钩子构建我们自己的React引擎，这样我们就能理解<em class="ko">使用状态</em>和<em class="ko">使用效果</em>的工作机制。</p><p id="bca7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<strong class="js iu">而不是</strong>涵盖<em class="ko">光纤</em>、<em class="ko">协调</em>或变化检测机制。</p><p id="841a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我的<a class="ae kp" href="https://craigtaub.dev/introducing-my-under-the-hood-of-series" rel="noopener ugc nofollow" target="_blank">“引擎盖下”系列</a>的一部分:</p><ul class=""><li id="2c26" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated"><a class="ae kp" href="https://craigtaub.dev/under-the-hood-of-web-bundlers" rel="noopener ugc nofollow" target="_blank">网络捆扎机(如网络包)</a></li><li id="289e" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><a class="ae kp" href="https://craigtaub.dev/under-the-hood-of-type-systems" rel="noopener ugc nofollow" target="_blank">类型系统(如TypeScript) </a></li><li id="8692" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><a class="ae kp" href="https://craigtaub.dev/under-the-hood-of-test-runners" rel="noopener ugc nofollow" target="_blank">测试跑步者(如摩卡)</a></li><li id="1c52" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><a class="ae kp" href="https://craigtaub.dev/under-the-hood-of-vscode-auto-formatters" rel="noopener ugc nofollow" target="_blank"> VSCode自动格式化程序(例如更漂亮)</a></li><li id="9d44" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><a class="ae kp" href="https://craigtaub.dev/source-maps-from-top-to-bottom" rel="noopener ugc nofollow" target="_blank">来源图</a></li><li id="ca8e" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/under-the-hood-of-apollo-6d8642066b28">阿波罗</a></li></ul><p id="80c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章的完整视频可以在<a class="ae kp" href="https://www.youtube.com/watch?v=mMTYRijTHEo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我的“<a class="ae kp" href="https://www.youtube.com/channel/UCYi23MnKBKn0yLZKBrz5Bfw" rel="noopener ugc nofollow" target="_blank"><em class="ko"/></a>”系列视频的一部分。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d041" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">反应概述</h1><p id="ed8c" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">我们应该从React的基本基本版本开始。为此，我们需要触及React的一些核心设计概念，例如:</p><p id="a98a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> JSX </strong></p><ul class=""><li id="8cc7" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">元素是POJO的(plain-old-javascript-objects)</li><li id="5b3b" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">组件是功能</li></ul><p id="cfe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">纯渲染</strong></p><ul class=""><li id="c1f9" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">一个渲染实例如下:<em class="ko">渲染=组件(数据)</em></li></ul><p id="13c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">状态机</strong></p><ul class=""><li id="99c4" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">单向数据流</li><li id="2809" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">数据更改检测强制所有需要的孩子进行更新</li></ul><p id="3628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将构建我们自己的(超级简单的)React版本，然后添加钩子，为此我们需要一个React引擎的基本版本，它应该使用一些道具来呈现一个组件并返回该组件(以便稍后进行交互)。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/4a8b532bcb34b17bb9c5b00f631360f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/0*Xti53fxBXMJ6_4kW"/></div></figure><p id="878f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个基本的引擎，我们需要一个伴随的组件来记录渲染过程中的数据:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5f29daeb7a12c9f16c1eb916fdbc99dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/0*cOqaa8Tb3xtqOZ6H"/></div></figure><p id="2f94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以一起使用React和Component，并查看其输出(在每行代码下面):</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/752cc75d1b92a91b34d6344643c64734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ihfkqqJ0VZzQN_oG"/></div></div></figure><p id="4ab9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个由React引擎渲染的基本组件。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="abeb" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">反应钩</h1><p id="50e4" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">关于钩子的简单提醒。</p><blockquote class="nc"><p id="5de0" class="nd ne it bd nf ng nh ni nj nk nl kn dk translated"><em class="nm">“钩子让你在一个纯组件中使用状态和其他React特性，而不用写类”</em></p></blockquote><p id="93a4" class="pw-post-body-paragraph jq jr it js b jt nn jv jw jx no jz ka kb np kd ke kf nq kh ki kj nr kl km kn im bi translated">类经常会使人迷惑，增加代码的臃肿，但是使用钩子还有其他的优势，其中一些是:</p><ul class=""><li id="885e" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">更容易构建和重用有状态逻辑</li><li id="94e5" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">更容易将组件拆分成可关联的部分</li><li id="b84e" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">消除对许多生命周期方法的混淆(例如，什么与什么事件相关)</li><li id="dac3" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">对你的反应知识没有根本性的改变，只是用一种更直接的方式来使用你已经知道的特性</li><li id="17b4" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">易于添加类型，因为钩子只是函数(不像高阶组件和大多数渲染道具模式)</li><li id="5b07" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">用<em class="ko">“react-DOM/test-utils”易于测试</em></li></ul><p id="d8d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以很容易理解为什么钩子是如此强大的机制。因此，让我们来看看它们是如何工作的，并建立我们自己的。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1e7e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">T5【使用状态】T6【挂钩】T7】</strong></h1><p id="0ae3" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">使用状态有几个核心概念:</p><ul class=""><li id="a70f" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">在纯组件中使用状态。</li><li id="e393" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">使用任何原语(字符串/数组/对象等。)</li></ul><p id="89cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据他们经常返还的文件:</p><ol class=""><li id="8e31" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn ns kw kx ky bi translated">还原状态</li><li id="4441" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn ns kw kx ky bi translated">行动调度员</li></ol><p id="927c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这可以简化为一个基本属性值和一个设置器。</p><p id="3883" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个简单的规则对钩子非常重要。那就是<strong class="js iu">钩子被称为顶端。这意味着在任何条件或嵌套块之外。这对于钩子机制至关重要，我们将研究原因。</strong></p><p id="51c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们扩展React engine来包含<em class="ko"> useState </em>钩子。我们将需要一个“<em class="ko">状态索引</em>计数器，以及“<em class="ko">状态存储</em>”值。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nt"><img src="../Images/f67c487ce0224c50c861b4875e272e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6F437GIOY7GgNQWm"/></div></div></figure><p id="fead" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还添加了一个<em class="ko">使用状态</em>方法。它的工作原理是:</p><ul class=""><li id="10ab" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">检查当前索引在状态中是否有值，如果没有则设置默认值</li><li id="bb27" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">然后为当前状态索引值构建setter</li><li id="589d" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">最后递增索引(为了下一个钩子)并返回setter和当前值。</li></ul><p id="207b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将在组件中使用我们的<em class="ko">使用状态</em>。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nu"><img src="../Images/222b9b9fd7718451e11dced93080c87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C0Yx6Njc3CCZPo41"/></div></div></figure><p id="79a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参见上面的“<em class="ko">计数</em>”和“<em class="ko">名称</em>”用法。我们还利用了“<em class="ko">内部</em>”属性，这样我们就可以在终端监视它。此外，我们还添加了一些手动方法来更新状态值。它们是手动的，因为我们不担心这篇文章中的变化检测或协调。我们将手动触发返回的函数以及<em class="ko"> render </em>方法(遵循我们之前在React engine部分中使用它的方式)。</p><p id="b220" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在运行下面的时，我们记录渲染输出。我们可以看到，通过每个“<em class="ko"> click() </em>”我们正在更新计数，通过“<em class="ko"> personArrived() </em>”我们正在更新person(代码行下面的终端输出)。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nv"><img src="../Images/b17197206568946c3e7882fb605939d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hAhNr_i7aPVhpmip"/></div></div></figure><p id="7c8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的使用中有一个主要问题。也就是说，这不会同时对许多组件起作用。它与我们的单个组件紧密耦合。状态应该保存在模块范围或组件的单个存储命名空间中。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f35b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak"> <em class="nm">使用效果</em>挂钩</strong></h1><p id="3f72" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj mn kl km kn im bi translated">文件中的简短引用:</p><blockquote class="nc"><p id="d15a" class="nd ne it bd nf ng nh ni nj nk nl kn dk translated"><em class="nm">“在初始渲染后和每次更新后运行的功能”</em></p></blockquote><p id="cf49" class="pw-post-body-paragraph jq jr it js b jt nn jv jw jx no jz ka kb np kd ke kf nq kh ki kj nr kl km kn im bi translated">与<em class="ko"> useState </em>类似，关于顶层调用的规则也适用。我们的实施也需要它。</p><p id="38dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">效果的几个概念:</p><ul class=""><li id="bfdd" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">渲染期间创建</li><li id="35a0" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">按定义顺序运行(如<em class="ko">使用状态</em>)</li><li id="d7a6" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">在给定的生命周期事件后运行(第一次渲染和/或当依赖关系发生变化时)。即安装和更新)</li><li id="9747" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">返回一个函数(某些效果需要清除，例如取消订阅)</li></ul><p id="701d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<em class="ko">使用效果</em>挂钩机构如下:</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nw"><img src="../Images/32d5bb2fa297c874921f4e4c77d2eab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PmtwyoE4nTF7qSAA"/></div></div></figure><p id="71a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码的预演:</p><ul class=""><li id="c32a" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">缓存存储索引</li><li id="f330" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">检查依赖关系的状态是否已经改变(这是我们的变量跟踪机制)</li><li id="fa58" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">如果没有给定的依赖项或者它发生了变化，那么运行我们的效果并用我们的依赖项值更新存储索引值</li><li id="4e9f" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">然后递增存储索引，以便将来的挂钩使用它们自己的索引</li><li id="9715" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">最后返回一个函数</li></ul><p id="8f0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我们的效果挂钩也依赖于“<em class="ko">状态索引</em>”。与<em class="ko"> useState </em>类似，它依赖于状态数组中值的确定性顺序。</p><blockquote class="nc"><p id="742a" class="nd ne it bd nf ng nh ni nj nk nl kn dk translated">所有的状态和效果挂钩必须以相同的顺序调用，这样它们的状态索引总是可以在状态数组中的相同位置找到。</p></blockquote><p id="9656" class="pw-post-body-paragraph jq jr it js b jt nn jv jw jx no jz ka kb np kd ke kf nq kh ki kj nr kl km kn im bi translated">现在让我们更新我们的组件来使用效果钩子</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nx"><img src="../Images/0c28bb5cdf38d17b6121fcab6d6956b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h44LYzQdoznui-lq"/></div></div></figure><p id="91c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的钩子将寻找"<em class="ko"> name </em>"属性的变化，我们也为我们的效果钩子公开了一个<em class="ko"> "unsubscribe" </em>函数。</p><p id="2a87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在来看渲染过程中的运行顺序，我已经记录了每个渲染的状态数组，以帮助我们跟踪(详细解释见下面的截图)。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ny"><img src="../Images/7dc1c17752ac51e513afb24194b30099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tqp-O1xJcLulNPOo"/></div></div></figure><p id="fbd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面详细描述了上面发生的事情对我们的影响。</p><p id="2c59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第一次渲染</strong></p><p id="e76e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在2状态运行后，现在"<em class="ko"> cachedIndex </em>"在<em class="ko"> useEffect </em>内。状态值为“<em class="ko">未定义</em>”，因为它对于该索引不存在(还不存在)。因此，我们将运行我们的回调并将一个新实体写入状态(在索引2下)，这是我们的依赖值(即当前的“S<em class="ko">teve】</em>)。</p><p id="d9b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以:state现在有本地状态值和效果值。它是基于<em class="ko">“状态索引”</em>(即它在组件中被调用的位置)的确定顺序。这意味着它是可靠的，因为这个顺序不应该改变。记住<strong class="js iu">规则#1 </strong>。</p><p id="aa55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">重新渲染</strong></p><p id="c7c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将检查状态数组中的第三个值，只有当它改变时，效果才会运行。看上面，当我们把名字改成<em class="ko">“Peter”</em>时，我们的钩子再次运行。最后，我们取消我们的挂钩。</p><p id="9605" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上有两个主要问题(除其他外):</p><ol class=""><li id="75cd" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn ns kw kx ky bi translated">仅适用于1个依赖项，不适用于数组</li></ol><p id="57c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很容易扩展我们的代码，所以我们可以使用数组。通过使用相同的存储索引并存储依赖于状态的数组，而不仅仅是单个值。然后迭代依赖数组来检查变化。</p><p id="0a17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.我们的是在渲染之前运行，而不是之后</p><p id="f100" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个更复杂的问题，需要对我们的React引擎进行根本性的改变。因为这是一个小的POC示例，所以不值得修复。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="86dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这是有用的，或者至少有点意思。我非常喜欢学习钩子，并且对它们有了更深的理解，因为它们是一个帮助前端开发人员体验向前发展的特性。</p><p id="0aee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里找到代码的要点:<a class="ae kp" href="https://gist.github.com/craigtaub/a131eb23a9aa15540a84dc2266e1b672" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/craigtaub/a 131 EB 23 a9 aa 15540 a 84 DC 2266 E1 b 672</a></p><p id="2e9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢谢，克雷格😃</p></div></div>    
</body>
</html>