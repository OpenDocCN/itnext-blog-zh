# 如何在 Nest.js 中进行交易

> 原文：<https://itnext.io/how-to-make-transactions-in-nest-js-9bff9b2b02af?source=collection_archive---------3----------------------->

![](img/35877dce080a153d3b2fffd0b597036d.png)

在许多情况下，开发人员在服务器上执行各种操作时必须使用事务。例如，资金转移或其他可衡量的价值，等等。对于这样的操作，我真的不希望收到一个会中断进程和破坏数据完整性的错误。

究竟什么是“交易”？维基百科[说](https://en.wikipedia.org/wiki/Database_transaction):

一个**数据库事务**象征着在一个数据库管理系统(或类似系统)中针对一个数据库执行的一个工作单元，并且以一种独立于其他事务的一致和可靠的方式被处理。事务通常代表数据库中的任何变化。数据库环境中的事务有两个主要目的:

1.  提供可靠的工作单元，允许从故障中正确恢复并保持数据库的一致性，即使在系统故障的情况下，当执行停止(完全或部分)并且对数据库的许多操作仍未完成，状态不明时。
2.  在并发访问数据库的程序之间提供隔离。如果不提供这种隔离，程序的结果可能是错误的。

现在，考虑一种可能发生错误的情况，如果不使用事务，会导致非常不愉快的后果。

我做了一个小的[项目](https://github.com/alphamikle/nest_transact/tree/master/example)，其中有两个实体:

*   用户
*   钱包

用户可以互相转账。转账时，除了许多其他检查之外，还会检查转账人的余额是否充足。如果发生这样的情况，钱已经从发送者的余额中被借记，但是没有被转移到接收者的账户，或者相反，我们将看到一个非常悲伤、愤怒的人，或者我们将不会看到一个非常高兴的人(*取决于转移金额*)。

太好了，事实上交易很重要，需要整理(*希望每个人都同意这一点*)。但是你如何应用它们呢？

首先，让我们看看如果使用 PostgreSQL，有错和无错查询的选项。

没有错误的常见查询集:

顺便说一下，我没有手写这个请求，而是从 ORM 日志中提取的，但是它反映了本质。一切都非常简单明了。为了构建查询，使用了 [TypeORM](https://typeorm.io/) ,稍后我们将回到这一点。

ORM 和 Postgres 设置是默认设置的，因此每个操作都将在自己的事务中执行，但是为了利用这一优势，您需要编写一个查询，其中与数据库相关的所有逻辑都将同时发生。

下面是在一个事务中执行多个查询的示例:

与前一个请求示例的主要区别在于，在这种情况下，所有请求都在一个事务中执行，因此，如果在某个阶段发生错误，整个事务将回滚，其中包含所有请求。或多或少像这样:

顺便说一下，这里是产生所有以前的 SQL 查询的代码。它包含一个标志，当设置时，错误在最不合适的时刻发生:

好吧。我们把自己从损失或非常不安的用户中拯救出来(至少在与资金转移相关的事情上是这样的)。

没有人睡着吗？

![](img/0eb936726c4d218ea5c1a8eb870ebb7f.png)

# 其他方式

下一步是什么？还有哪些写交易的方法？碰巧的是，你正在读的那个人(*这是我*)在他不得不写后端的时候，他真的很喜欢一个奇妙的框架。这个框架的名字叫 [Nest.js](https://nestjs.com/) 。它在 Node.js 平台上工作，里面的代码是用 Typescript 写的。这个伟大的框架几乎开箱即用，支持非常类型的表单。哪个(还是哪个？)我，正好，也真的喜欢。我不喜欢的只有一件事——在我看来，这是一种相当混乱、过于复杂的编写交易的方法。

这是编写事务的官方[示例](https://typeorm.io/#/transactions):

从文档创建交易的第二种方法:

一般来说，这种方法的要点如下:您需要获得一个`transactionEntityManager: EntityManager`——一个允许您在事务中执行查询的实体。然后将该实体用于基的所有操作。听起来不错，只要你不需要在实践中使用这种方法。

首先，我真的不喜欢将依赖项直接注入服务类的方法中的想法，以及这样编写的方法在使用注入服务本身的依赖项方面变得孤立的事实。该方法工作所需的所有依赖项都必须放入其中。但最烦人的是，如果你的方法调用了嵌入在你的方法中的其他服务，那么你就不得不在那些第三方服务中创建同样的特殊方法。并在其中传递`transactionEntityManager`。同时，应该记住，如果您决定通过 decorator 使用该方法，那么当您将`transactionEntityManager`从一个服务转移到第二个服务时，第二个服务的方法也将被修饰——在第二个方法中，您将接收到没有作为依赖项传递的`transactionEntityManager`和由 decorator 创建的【】,这意味着两个不同的事务，这意味着不幸的用户。

# 从例子开始

下面是处理用户请求的控制器操作的代码:

在这里，我们需要访问`connection`对象来创建一个`transactionManager`。我们可以按照 TypeORM 文档的建议去做——只使用如上所示的`getConnection`函数:

但是在我看来这样的代码会更难测试，这根本就是错误的(*大论证*)。因此，我们必须将`connection`依赖项传递给控制器构造函数。非常幸运的是，Nest 允许您通过简单地用适当的类型描述构造函数中的字段来做到这一点:

因此，我们得出结论，为了在使用 TypeORM 时能够在 Nest 中使用事务，有必要将`connection`类传递到控制器/服务构造函数中，因为现在我们只记住了这一点。

现在我们来看看我们`appService`的`makeRemittanceWithTypeOrmV1`方法:

整个项目是合成的，但是为了显示这种方法的不愉快之处——我将用于保存钱包的`savePurse`方法移动到一个单独的`appServiceV2`服务中，并在考虑的`makeRemittanceWithTypeOrmV1`方法中使用这个服务和这个方法。您可以在下面看到这个方法和服务的代码:

实际上，在这种情况下，我们会得到以下 SQL 查询:

如果我们发送一个发生错误的请求，我们将清楚地看到来自`appServiceV2`的内部事务没有回滚，因此我们的用户再次感到愤怒。

在这里，我们得出结论，对于标准的中继方法，您需要有特殊的方法，您需要将`transactionEntityManager`传递到这些方法中。

如果我们想摆脱将`transactionEntityManager`显式注入相应方法的需要，那么文档建议我们看看装饰者。

通过应用它们，我们得到这种控制器动作:

现在它变得更简单了——不需要使用`connection`类，无论是在构造函数中，还是通过调用全局方法 TypeORM。完全正确。但是我们服务的方法仍然应该得到一个依赖——`transactionEntityManager`。这就是那些装饰者来拯救的地方:

我们已经弄清楚了这样一个事实，简单地使用第三方服务方法会破坏我们的事务。因此，我们使用了第三方服务的新方法`transactionEntityManager`，它看起来是这样的:

正如你从代码中看到的，在这个方法中我们也使用了 decorator——这样我们实现了项目中所有方法的一致性( *yep yep* ),并且也消除了在使用我们的服务`appServiceV2`的控制器的构造器中使用`connection`的需要。

使用这种方法，我们得到以下请求:

因此，错误会破坏事务和应用程序逻辑:

文档中描述的唯一可行的方法是避免使用 decorators。如果你同时在所有方法中使用 decoratorss，那么那些将被其他服务使用的 decorator 将会注入它们自己的`transactionEntityManagers`，就像我们的`appServiceV2`服务和它的`savePurseInTransaction`方法一样。让我们试着用另一种方法来代替这种方法:

为了我们的方法的一致性，并摆脱已经出现的层次结构，这表现在一些方法可以调用其他方法，但仍有其他方法将不能调用第一个——我们将改变`appService`类的方法。因此，从文档中获得第一个选项后。

# 另一途径

嗯，看起来我们仍然需要将这个`connection`注入到控制器构造函数中。但是提议的用事务编写代码的方式看起来仍然非常麻烦和不方便。怎么办？为了解决这个问题，我做了一个包，让你用最简单的方式使用事务。它被称为[嵌套事务](https://stackedit.io/%28https://www.npmjs.com/package/nest-transact)。

他在做什么？这里一切都很简单。对于我们的用户和资金转移示例，让我们看看用 nest-transact 编写的相同逻辑。

我们的控制器的代码没有改变，因为我们已经确定在构造函数中不能没有`connection`，我们将指定它:

控制器的动作:

在使用文档中的第一种方法的情况下，它与操作的区别在于:

我们可以使用通常的服务方法，而无需为需要通过`transactionManager`的交易创建特定的变体。此外，在使用我们的服务业务方法之前，我们在同一个服务上调用`withTransaction`方法，并将我们的`transactionManager`传递给它。这里你可以问这样一个问题——这个方法是从哪里来的？因此:

这是请求代码:

错误是:

但是你已经从一开始就看到了。

要让这种魔法发挥作用，你需要完成两个步骤:

*   我们的服务必须继承自类`TransactionFor <ServiceType>`
*   我们的服务必须在构造函数依赖列表中有一个特殊的类`moduleRef: ModuleRef`

都是。顺便说一句，由于框架本身的依赖注入还没有实现——您不必显式抛出`moduleRef`。*仅用于测试。*

你可能会想— *为什么我要继承这个类？如果我的服务必须继承其他服务怎么办？*如果您认为，那么我建议计算一下您的服务中有多少是从其他类继承的，并在事务中使用。

现在它是如何工作的？出现的`withTransaction`方法——为该事务重新创建您的服务，以及您的服务的所有依赖项和依赖项的依赖项——一切，一切，一切。接下来，如果您以某种方式在您的服务中存储一些状态(*但是如果呢？* ) -那么当以这种方式创建交易时，它将不存在。您的服务的原始实例仍然存在，当您调用它时，一切都会像以前一样。

除了前面的例子，我还添加了一个贪婪的方法:带佣金的转移，它在一个控制器动作中同时使用两个服务:

此方法提出以下请求:

从中我们可以看到，所有请求仍然发生在一个事务中，它将正确工作。

总之，我想说——当在几个实际项目中使用这个包时，我得到了一种更方便的编写事务的方法——当然是在 Nest.js + TypeORM 堆栈中。希望你也觉得有用。如果你喜欢这个包并决定尝试一下，小小的愿望——在 [GitHub](https://github.com/alphamikle/nest_transact) 上给它一个星号。对你不难，但对我和这个包有用。我也很高兴听到建设性的批评和改进这一解决方案的可能方法。