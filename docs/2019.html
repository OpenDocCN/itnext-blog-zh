<html>
<head>
<title>TDD practical lessons 3 — Classes collaboration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDD实践课程3 —班级协作</h1>
<blockquote>原文：<a href="https://itnext.io/practical-tdd-3-9a76b3e045d8?source=collection_archive---------5-----------------------#2019-03-17">https://itnext.io/practical-tdd-3-9a76b3e045d8?source=collection_archive---------5-----------------------#2019-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c3dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在以前的帖子中，我解释了为什么TDD可以帮助你成为更好的开发人员，以及如何进行基本的TDD的两个实践课程(<a class="ae ko" href="https://medium.com/@raphaelyoshiga/practical-tdd-first-lesson-1c689fffe4ec" rel="noopener">第一课</a>，<a class="ae ko" href="https://medium.com/@raphaelyoshiga/practical-tdd-lesson-2-d9d48283b0c4" rel="noopener">第二课</a>)。现在，我将通过课堂教学协作，开始用TDD更接近真正的应用程序开发。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/1e2f96fd854bcbd4136e6c2f85bc4c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5X6iSBwKz20yKZJfvQkyw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/search/photos/collaboration-drawing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ko" href="https://unsplash.com/photos/IJFnMSGY_bM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>拍摄</figcaption></figure><p id="c5e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的场景中，测试是简单的数据测试，给定一个输入，就会有一个输出。但是在现实生活中，应用程序并没有那么简单，它们是由多个类组成的，这些类相互协作来完成期望的功能。</p><h2 id="486a" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">场景</h2><p id="0fff" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">假设我们有一个用户控制器，它需要调用用户存储库来获取用户，然后调用解析器来构建响应。基本合同:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">示例的合同</figcaption></figure><p id="cf01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们试图测试UserController的实现，首先要测试的是控制器正在从存储库中获取用户。大概是这样的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用模拟测试(最小起订量)</figcaption></figure><p id="4c2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个测试中，我们调用控制器，并验证使用正确的id调用了用户存储库。由于我们不想使用真正的存储库，我们需要模拟它，您可以通过实现接口或使用模拟框架来手动完成。对于这个例子，我将使用最小起订量。</p><p id="d5c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这之后，我们需要确保从存储库中检索到的用户调用解析器，所以它看起来像这样:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e367" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们来说，存根存储库的结果，我们<strong class="js iu">设置它</strong>，因为当它接收到那个id时，它返回用户对象。</p><p id="7b82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是等等，我们还需要从控制器返回那个用户，所以我们需要测试解析器的结果是否返回给客户机，而不是验证调用是否已经进行:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="2eb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样一步一步来，我们最终得到了这样一个文件:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="43a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你看到冗余了吗？例如，第一个测试“GetUserFromRepository”只测试对存储库的调用，但是这个调用已经被接下来的两个测试覆盖了。对于“ParseUserFromRepository”也是一样，最后一个测试也包括了协作，所以它们是多余的。清理之后，代码看起来像这样:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="9552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么我显示慢的方式？因为知道慢路径对你来说很重要，所以当你走得快时，你知道你没有错过测试覆盖率。</p><p id="8b47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们必须处理的另一个常见场景是处理异常。假设我们需要处理来自用户存储库的异常，如UserNotFoundException。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="e228" class="mf lg it bd lh mg mh mi lk mj mk ml ln mm mn mo lq mp mq mr lt ms mt mu lw mv bi translated">匹配参数</h1><p id="a0be" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">值得一提的是，之前的测试使用等式来匹配参数。前夫;前妻;前男友;前女友</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="8daf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些只是简单的相等比较，所以值类型在值级别进行比较(例如int ),引用类型在内存中的指针处通过equals的默认实现进行比较。您可以覆盖相等比较以进行自定义比较。</p><p id="3bd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">匹配参数的另一种方法是使用mocking框架工具来完成。这些是特定于Moq的，但在其他框架中也会有它们的对等物:</p><h2 id="a819" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">有吗</h2><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="6182" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它基本上匹配任何int类型的东西。<strong class="js iu">一般来说，它。代码中的IsAny意味着缺乏覆盖率</strong>,因为测试任何东西都会通过，所以即使是错误的值也会通过测试。它主要在测试负面场景时有用，例如:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">UserControllerShould &gt; notcallrepositoryidfidlowerthanone</figcaption></figure><p id="8349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将验证如果id小于1，存储库甚至没有被调用。</p><h2 id="43bd" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">它是</h2><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c4e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“It.is”基本上是一种调用参数匹配委托的方法，例如，如果您需要在测试中检查对象内部的属性，这很有用。</p><h1 id="635e" class="mf lg it bd lh mg mh mi lk mj mk ml ln mm mn mo lq mp mq mr lt ms mt mu lw mv bi translated">两种类型的TDD</h1><p id="4a6b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">关于TDD和设计应该如何发生有两种基本观点。一个是经典的TDD，因为几乎没有预先设计，您只需从测试中驱动整个实现。另一种选择更为人所知的是“模仿者”或伦敦学派的TDD，这是你在开发之前已经设计好的地方，因为你要模仿一些东西。哪个更好？</p><p id="6cc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">老实说，它们都有其优点和特定的场景。根据我的经验，商业应用程序通常需要相当多的类协作，所以我发现自己更多地使用“模仿者”风格。</p><h2 id="f720" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">CRC卡</h2><p id="4737" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">设计的一个技巧是CRC卡(类-责任-协作)，在这里你描述你需要的每一个特定业务特性的类。在描述中，您将拥有:</p><ul class=""><li id="13c4" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">这个名字——想想就好</li><li id="16f7" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">简言之，这就是责任</li><li id="2df4" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">它的亲密合作者。</li></ul><p id="317f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CRC卡为例</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nk"><img src="../Images/ad3b5955290c8ea670249bb44192d55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mccLLrsOcwFhSK0jIbJV7g.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">用https://echeung.me/crcmaker/<a class="ae ko" href="https://echeung.me/crcmaker/" rel="noopener ugc nofollow" target="_blank">创建的图表</a></figcaption></figure><p id="d3b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用CRC卡时，我已经使用真正的卡来绘制这些东西，伟大的事情是，然后你可以很容易地重新排列它们，向其他开发者解释事情。</p><h2 id="767d" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">一个单一责任被打破的例子</h2><p id="f2dc" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">从根本上说，单一责任原则是我们开发人员应该努力遵循的，它意味着类和对象应该只有一个改变的理由。以下是一个违规示例:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nl"><img src="../Images/4eec177398bfbbdbf4c835eac2cb67d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lk1keOAH86aIXqKrZKTjrA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">分解的单一责任—用<a class="ae ko" href="https://echeung.me/crcmaker/" rel="noopener ugc nofollow" target="_blank">https://echeung.me/crcmaker/</a>创建的图表</figcaption></figure><p id="53f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有解析器，现在控制器需要做所有的事情，实现如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="dd17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">控制器的测试也应该是这样的:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c4ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个问题的一个很大的迹象是在测试中，它同时测试行为和数据，通过断言协作和返回对象的单独属性。在实现中，也有问题的暗示，因为控制器正在实例化响应本身。</p><h2 id="6c70" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">结论</h2><p id="f970" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我希望这能帮助你踏上TDD之旅，这将为使用TDD开发真实世界的应用程序提供一个非常基本的工具集。下一步将是学习外-内TDD，或双环TDD，我以前在这里<a class="ae ko" href="https://medium.com/asos-techblog/atdd-acceptance-test-driven-development-at-asos-81577568e4f2" rel="noopener">解释过。</a></p><p id="5388" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">源代码也可以在<a class="ae ko" href="https://github.com/RaphaelYoshiga/TDD" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0f07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个TDD资源:</p><ul class=""><li id="2a9b" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated"><a class="ae ko" href="https://medium.com/@raphaelyoshiga/why-tdd-will-change-your-developer-life-b0bf234e15ac" rel="noopener">为什么TDD会改变你的开发者生活</a></li><li id="c545" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated"><a class="ae ko" href="https://medium.com/@raphaelyoshiga/practical-tdd-first-lesson-1c689fffe4ec" rel="noopener">实用TDD —第一课</a></li><li id="ce23" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated"><a class="ae ko" href="https://medium.com/@raphaelyoshiga/practical-tdd-lesson-2-d9d48283b0c4" rel="noopener">实用TDD —第二课</a></li><li id="4e77" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/acceptance-test-driven-development-in-net-core-with-specflow-dcb17fb7a893">验收测试驱动开发。带Specflow的网络核心</a></li></ul></div></div>    
</body>
</html>