<html>
<head>
<title>Docker + Rails + Puma + Nginx + Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">docker+Rails+Puma+Nginx+Postgres</h1>
<blockquote>原文：<a href="https://itnext.io/docker-rails-puma-nginx-postgres-999cd8866b18?source=collection_archive---------1-----------------------#2018-02-22">https://itnext.io/docker-rails-puma-nginx-postgres-999cd8866b18?source=collection_archive---------1-----------------------#2018-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c060811afbac160085c42605818b1130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w77ZoWUmK-mCdSkfjZuhxA.jpeg"/></div></div></figure><p id="6329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在编写一个rails应用程序并使用docker来部署您的应用程序。这篇文章是给你的。</p><p id="f4cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我分享生产就绪的配置文件，这将有助于您加快部署过程。</p><h1 id="c301" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置</h1><p id="fa9c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在你的项目根目录下创建一个名为<code class="fe lz ma mb mc b">docker</code>的文件夹，现在在里面再创建两个目录<code class="fe lz ma mb mc b">app</code>和<code class="fe lz ma mb mc b">web</code>。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="8219" class="ml kx iq mc b gy mm mn l mo mp">-app_name<br/>  -app<br/>  -db<br/>  -config<br/>    -database.yml<br/>  ...<br/>  -docker<br/>    -app<br/>      -DockerFile<br/>    -web<br/>      -DockerFile<br/>      -nginx.conf<br/>  -docker-compose.yml</span></pre><blockquote class="mq mr ms"><p id="aa82" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">我们创建的文件夹结构只是为了以模块化的方式保存我们的文件，你可以把它保存在任何你想要的地方。</p></blockquote><h1 id="3b59" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将你的Rails应用归档</h1><p id="09c1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将rails app的<em class="mt"> DockerFile </em>放入<code class="fe lz ma mb mc b">app</code>文件夹中。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="60d4" class="ml kx iq mc b gy mm mn l mo mp">FROM ruby:2.3.1</span><span id="8151" class="ml kx iq mc b gy mx mn l mo mp">RUN apt-get update -qq &amp;&amp; apt-get install -y build-essential libpq-dev nodejs </span><span id="dda6" class="ml kx iq mc b gy mx mn l mo mp"># Set an environment variable where the Rails app is installed to inside of Docker image</span><span id="d2cc" class="ml kx iq mc b gy mx mn l mo mp">ENV RAILS_ROOT /var/www/app_name<br/>RUN mkdir -p $RAILS_ROOT </span><span id="bdf9" class="ml kx iq mc b gy mx mn l mo mp"># Set working directory<br/>WORKDIR $RAILS_ROOT</span><span id="bc34" class="ml kx iq mc b gy mx mn l mo mp"># Setting env up<br/>ENV RAILS_ENV='production'<br/>ENV RACK_ENV='production' </span><span id="1e75" class="ml kx iq mc b gy mx mn l mo mp"># Adding gems<br/>COPY Gemfile Gemfile<br/>COPY Gemfile.lock Gemfile.lock</span><span id="3bcb" class="ml kx iq mc b gy mx mn l mo mp">RUN bundle install --jobs 20 --retry 5 --without development test </span><span id="fd16" class="ml kx iq mc b gy mx mn l mo mp"># Adding project files<br/>COPY . .<br/>RUN bundle exec rake assets:precompile</span><span id="b6e3" class="ml kx iq mc b gy mx mn l mo mp">EXPOSE 3000</span><span id="43be" class="ml kx iq mc b gy mx mn l mo mp">CMD ["bundle", "exec", "puma", "-C", "config/puma.rb"]</span></pre><p id="2b46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些配置将安装基本的系统需求，将您的项目复制到docker容器，安装gems，预编译您的资产。</p><h1 id="2211" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">代理您的web请求</h1><p id="5fae" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们需要一个<a class="ae my" href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="noopener ugc nofollow" target="_blank">反向代理</a>，在我们的例子中是Nginx web服务器，来代理对Puma的请求</p><h2 id="948a" class="ml kx iq bd ky mz na dn lc nb nc dp lg kj nd ne lk kn nf ng lo kr nh ni ls nj bi translated">Nginx的DockerFile</h2><p id="bb36" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将Nginx的<em class="mt"> DockerFile </em>放入<code class="fe lz ma mb mc b">web</code>文件夹</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="9156" class="ml kx iq mc b gy mm mn l mo mp"># Base image<br/>FROM nginx</span><span id="654f" class="ml kx iq mc b gy mx mn l mo mp"># Install dependencies<br/>RUN apt-get update -qq &amp;&amp; apt-get -y install apache2-utils</span><span id="c030" class="ml kx iq mc b gy mx mn l mo mp"># establish where Nginx should look for files<br/>ENV RAILS_ROOT /var/www/app_name</span><span id="bc9d" class="ml kx iq mc b gy mx mn l mo mp"># Set our working directory inside the image<br/>WORKDIR $RAILS_ROOT</span><span id="917f" class="ml kx iq mc b gy mx mn l mo mp"># create log directory<br/>RUN mkdir log</span><span id="244e" class="ml kx iq mc b gy mx mn l mo mp"># copy over static assets<br/>COPY public public/</span><span id="b680" class="ml kx iq mc b gy mx mn l mo mp"># Copy Nginx config template<br/>COPY docker/web/nginx.conf /tmp/docker.nginx</span><span id="2b0d" class="ml kx iq mc b gy mx mn l mo mp"># substitute variable references in the Nginx config template for real values from the environment <br/># put the final config in its place</span><span id="1f9c" class="ml kx iq mc b gy mx mn l mo mp">RUN envsubst '$RAILS_ROOT' &lt; /tmp/docker.nginx &gt; /etc/nginx/conf.d/default.conf</span><span id="5d5c" class="ml kx iq mc b gy mx mn l mo mp">EXPOSE 80</span><span id="a07a" class="ml kx iq mc b gy mx mn l mo mp"># Use the "exec" form of CMD so Nginx shuts down gracefully on SIGTERM (i.e. `docker stop`)<br/>CMD [ "nginx", "-g", "daemon off;" ]</span></pre><h2 id="d08e" class="ml kx iq bd ky mz na dn lc nb nc dp lg kj nd ne lk kn nf ng lo kr nh ni ls nj bi translated">Nginx配置文件</h2><p id="f3fe" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将<em class="mt"> nginx.conf </em>放到<code class="fe lz ma mb mc b">web</code>文件夹中</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5d0a" class="ml kx iq mc b gy mm mn l mo mp">upstream rails_app {  <br/>   server app:3000;<br/>} </span><span id="057c" class="ml kx iq mc b gy mx mn l mo mp">server {  <br/>   # define your domain  <br/>   server_name www.example.com;   </span><span id="0575" class="ml kx iq mc b gy mx mn l mo mp">   # define the public application root  <br/>   root   $RAILS_ROOT/public;  <br/>   index  index.html;</span><span id="0551" class="ml kx iq mc b gy mx mn l mo mp">   # define where Nginx should write its logs  <br/>   access_log $RAILS_ROOT/log/nginx.access.log;  <br/>   error_log $RAILS_ROOT/log/nginx.error.log;   <br/>  <br/>   # deny requests for files that should never be accessed  <br/>   location ~ /\. {    <br/>      deny all;  <br/>   }</span><span id="a0c2" class="ml kx iq mc b gy mx mn l mo mp">   location ~* ^.+\.(rb|log)$ {    <br/>      deny all;  <br/>   }  <br/> <br/>   # serve static (compiled) assets directly if they exist (for rails production)  <br/>   location ~ ^/(assets|images|javascripts|stylesheets|swfs|system)/   {    <br/>      try_files $uri @rails;     <br/>      access_log off;    <br/>      gzip_static on; </span><span id="3541" class="ml kx iq mc b gy mx mn l mo mp">      # to serve pre-gzipped version     <br/>      expires max;    <br/>      add_header Cache-Control public;     <br/>      <br/>      add_header Last-Modified "";    <br/>      add_header ETag "";    <br/>      break;  <br/>   } <br/>  <br/>   # send non-static file requests to the app server  <br/>   location / {    <br/>      try_files $uri @rails;  <br/>   }   </span><span id="aefe" class="ml kx iq mc b gy mx mn l mo mp">   location @rails {    <br/>      proxy_set_header  X-Real-IP  $remote_addr;    <br/>      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;         </span><span id="01ed" class="ml kx iq mc b gy mx mn l mo mp">      proxy_set_header Host $http_host;    <br/>      proxy_redirect off;    <br/>      proxy_pass http://rails_app;  <br/>   }<br/>}</span></pre><h1 id="e997" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍Docker编写器</h1><p id="ec3c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">因为我们的应用程序将跨多个容器运行，所以最好将它们作为一个容器来控制。这就是Docker Compose为我们做的事情。要使用Docker Compose启动我们的应用程序，请在Rails应用程序的根目录下创建一个文件<em class="mt"> docker-compose.yml </em>。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="075a" class="ml kx iq mc b gy mm mn l mo mp">version: '3'</span><span id="9682" class="ml kx iq mc b gy mx mn l mo mp">volumes:  <br/>  postgres_data: {} </span><span id="386a" class="ml kx iq mc b gy mx mn l mo mp">services:  <br/>  app:    <br/>    build:      <br/>      context: .      <br/>      dockerfile: ./docker/app/DockerFile    <br/>    depends_on:      <br/>      - db  </span><span id="aee6" class="ml kx iq mc b gy mx mn l mo mp">  db:    <br/>    image: postgres    <br/>    volumes:      <br/>      - postgres_data:/var/lib/postgresql/data  </span><span id="d4c6" class="ml kx iq mc b gy mx mn l mo mp">  web:    <br/>    build:      <br/>      context: .      <br/>      dockerfile: ./docker/web/DockerFile    <br/>    depends_on:      <br/>      - app    <br/>    ports:      <br/>      - 80:80</span></pre><h1 id="76f4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将您的数据库容器化</h1><p id="63e9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们用来运行Postgres数据库的名为“db”的引用docker容器。你需要更新你的<em class="mt">数据库</em></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="86f1" class="ml kx iq mc b gy mm mn l mo mp">default: &amp;default  <br/>  adapter: postgresql  <br/>  encoding: unicode  <br/>  username: postgres  <br/>  password:  <br/>  pool: 5  <br/>  host: db </span><span id="c3ea" class="ml kx iq mc b gy mx mn l mo mp">production:  <br/>  &lt;&lt;: *default  <br/>  database: app_name_production</span></pre></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="2a51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，您应该能够使用<code class="fe lz ma mb mc b">docker-compose build</code>构建所有容器</p><p id="92ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦构建完成，你可以用<code class="fe lz ma mb mc b">docker-compose run app rake db:create RAILS_ENV=production</code>初始化你的数据库，然后用<code class="fe lz ma mb mc b">docker-compose run app rake db:migrate db:seed RAILS_ENV=production</code>填充它。</p><blockquote class="mq mr ms"><p id="487d" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">如果您希望您的容器每次都运行相同的可执行文件，那么您应该考虑将entrypoint与<a class="ae my" href="https://docs.docker.com/engine/reference/builder/#/cmd" rel="noopener ugc nofollow" target="_blank"> CMD </a>结合使用。参见<a class="ae my" href="https://docs.docker.com/glossary/?term=ENTRYPOINT" rel="noopener ugc nofollow" target="_blank">入口点</a></p></blockquote><p id="564b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们终于可以用<code class="fe lz ma mb mc b">docker-compose up -d</code>运行应用程序了。</p><p id="7b91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要验证所有三个容器都启动并运行，请执行<code class="fe lz ma mb mc b">docker ps</code></p><h1 id="6ccb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="8076" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">通过正确的Docker设置，软件部署过程可以比以往任何时候都更快。此外，无论应用程序在哪里运行，您都可以确保一致的环境。</p><p id="086f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看<a class="ae my" href="https://gist.github.com/satendra02/1b335b06bfc5921df486f26bd98e0e89" rel="noopener ugc nofollow" target="_blank"> Github要点</a></p><h1 id="f7ab" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">重要说明</h1><p id="9e20" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你有任何关于实现的问题，不要忘记检查下面的评论，也许我已经回答了你的问题。</p><blockquote class="mq mr ms"><p id="409e" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">此外，对于Ruby &amp; Rails <strong class="ka ir"> </strong>的更新版本，请查看<a class="ae my" href="https://scotto.medium.com/2021-docker-ruby-3-rails-6-puma-nginx-postgres-d84c95f68637" rel="noopener">这篇文章</a>作者<a class="ae my" href="https://scotto.medium.com/" rel="noopener"><strong class="ka ir">joo Scotto</strong></a></p></blockquote><p id="3cdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(通过提供帮助其他人找到我在Medium上的文章👏🏽下面。)</p></div></div>    
</body>
</html>