<html>
<head>
<title>Modular Game Worlds in Phaser 3 (Tilemaps #5) — Matter Physics Platformer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Phaser 3中的模块化游戏世界(tile maps # 5)——物质物理平台</h1>
<blockquote>原文：<a href="https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-5-matter-physics-platformer-d14d1f614557?source=collection_archive---------0-----------------------#2018-08-20">https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-5-matter-physics-platformer-d14d1f614557?source=collection_archive---------0-----------------------#2018-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="44a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是第五个(也是最后一个！)发表一系列关于在<a class="ae kl" href="http://phaser.io/" rel="noopener ugc nofollow" target="_blank"> Phaser 3 </a>游戏引擎中使用tilemaps创建模块化世界的博文。在这个版本中，我们将增加我们的<a class="ae kl" href="http://brm.io/matter-js/" rel="noopener ugc nofollow" target="_blank"> Matter.js </a>知识，并创建一个小小的益智游戏平台:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c477fe81bf4ba0d2c0b1e4616f9222ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*46vo7NRMjPARJCGoqHzAOw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">推着板条箱四处躲避钉子，跳过跷跷板平台</em></figcaption></figure><p id="72ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有看过这个系列的前几篇文章，这里有一些链接:</p><ol class=""><li id="fbd3" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6" rel="noopener">静态磁贴地图&amp;一个神奇宝贝风格的世界</a></li><li id="774c" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a" rel="noopener">动态磁贴地图&amp;益智y平台</a></li><li id="4800" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-3-procedural-dungeon-3bc19b841cd" rel="noopener">动态磁贴地图&amp;程序地下城</a></li><li id="28b7" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated"><a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1" rel="noopener"> Meet Matter.js </a></li></ol><p id="9914" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，这篇文章的所有代码都在这个库中。这些教程使用截至21年8月13日的Phaser最新版本(v3.55.2)。</p><h1 id="57c7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">目标受众</h1><p id="8e1b" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果你对JavaScript(类、箭头函数和模块)、Phaser和<a class="ae kl" href="https://www.mapeditor.org/" rel="noopener ugc nofollow" target="_blank">平铺</a>地图编辑器有一些经验，这篇文章将会很有意义。如果你不知道，你可能想从<a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6" rel="noopener">系列</a>的开头开始，或者继续阅读并把Google、Phaser教程和Phaser <a class="ae kl" href="https://labs.phaser.io/" rel="noopener ugc nofollow" target="_blank">示例</a> &amp; <a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>放在手边。</p><h1 id="759b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">概观</h1><p id="29e0" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1" rel="noopener">的最后一个帖子</a>中，我们熟悉了Matter.js物理引擎，并在一个场景周围玩了扔弹性表情符号。现在，我们将在此知识的基础上逐步构建一个2D平台。我们将学习碰撞如何在Matter中工作，熟悉一个插件，它将允许我们在Phaser中整洁地观察碰撞，然后进入平台的核心。</p><h1 id="145c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">物质中的碰撞</h1><p id="cbc6" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我们要做的关键是处理物质碰撞。如果我们想在游戏中使用物理，我们需要能够在某些物体相互碰撞时做出反应，例如，像一个玩家角色踩上了一扇活板门。由于Phaser的Matter实现是底层库的一层薄薄的包装，因此有必要重温一下上次的普通Matter示例，以了解Matter中的碰撞检测。如果你不耐烦，你<em class="mu">可以</em>跳过两个部分直接进入平台。但是，如果你想了解一些东西真正是如何工作的——我认为从长远来看这是值得的——那就和我呆在一起吧。</p><p id="9fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们在这一部分的目标:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f753984156534e428ab6bee8a30b9238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*irRgssA8g4pEut1n4uqw3g.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">形状相互碰撞时会变亮，碰到地板时会变成紫色。</em></figcaption></figure><p id="aa84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个<a class="ae kl" href="https://codesandbox.io/s/kw73yy6375?module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox starter项目</a>，与我们上次所做的相匹配。我建议打开它，然后一起编码。文件底部有一个注释，告诉你从哪里开始编码。设置与上次相同:</p><ol class=""><li id="c11f" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">我们创建一个渲染器和引擎。</li><li id="7c34" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">我们创造了一些不同形状的物体，它们将在世界各地反弹。</li><li id="3d89" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">我们添加一些静态物体——不能移动或旋转的物体——作为障碍。</li><li id="8a1c" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">我们将一切添加到世界中，并启动渲染器和引擎循环。</li></ol><p id="a1a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了开始监听冲突，我们需要在文件的顶部添加一个新的模块别名，<code class="fe mv mw mx my b">Events</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5da0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mv mw mx my b">Events</code>允许我们在Matter中订阅事件发射器。我们将在这个演示中玩的两个事件是<code class="fe mv mw mx my b"><a class="ae kl" href="http://brm.io/matter-js/docs/classes/Engine.html#event_collisionStart" rel="noopener ugc nofollow" target="_blank">collisionStart</a></code>和<code class="fe mv mw mx my b"><a class="ae kl" href="http://brm.io/matter-js/docs/classes/Engine.html#event_collisionEnd" rel="noopener ugc nofollow" target="_blank">collisionEnd</a></code>。(参见其他<a class="ae kl" href="http://brm.io/matter-js/docs/classes/Engine.html#events" rel="noopener ugc nofollow" target="_blank">发动机事件</a>的文档。)</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dcc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在引擎循环的每一次滴答中，物质会跟踪所有刚刚开始碰撞(<code class="fe mv mw mx my b">collisionStart</code>)、持续碰撞了多个滴答(<code class="fe mv mw mx my b">collisionActive</code>)或刚刚结束碰撞(<code class="fe mv mw mx my b">collisionEnd</code>)的物体对。这些事件具有相同的结构。每一个都提供了一个参数——一个对象——带有一个<code class="fe mv mw mx my b">pairs</code>属性，这是一个所有碰撞物体对的数组。每个<code class="fe mv mw mx my b">pair</code>都有<code class="fe mv mw mx my b">bodyA</code>和<code class="fe mv mw mx my b">bodyB</code>属性，这两个属性让我们可以访问两个物体发生了碰撞。在我们的事件侦听器中，我们可以循环所有对，寻找我们关心的冲突并做一些事情。让我们从制造稍微透明的碰撞开始(使用身体的<a class="ae kl" href="http://brm.io/matter-js/docs/classes/Body.html#property_render" rel="noopener ugc nofollow" target="_blank">渲染属性</a>):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="de0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以扩展我们的<code class="fe mv mw mx my b">collisionStart</code>,基于哪些物体发生碰撞来建立一些条件逻辑:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0563" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个条件中，我们检查一个物体是否是地板，然后我们调整另一个物体的颜色以匹配地板的颜色。在第二个条件中，我们检查圆圈是否落地，如果是，就杀死它。有了这些基础，我们可以在游戏世界中做很多事情——比如检查玩家是否按了按钮，或者是否有任何物体掉进了熔岩。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">查看</em><a class="ae kl" href="https://codesandbox.io/s/yqv0qqjoj9?hidenavigation=1&amp;module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc">，</em> <a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/01-native-matter-collision" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> live示例</em> </a> <em class="lc">或者源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/01-native-matter-collision" rel="noopener ugc nofollow" target="_blank"> <em class="lc">这里</em> </a> <em class="lc">。</em></figcaption></figure><p id="e7bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这种方法并不十分友好或模块化。我们不得不担心<code class="fe mv mw mx my b">bodyA</code>和<code class="fe mv mw mx my b">bodyB</code>的顺序——楼层是A还是B？我们还必须有一个大的中央功能，知道所有的碰撞对。Matter采取的方法是尽可能保持引擎本身的精简，并让用户添加他们处理碰撞的特定方式。如果你想在没有相位器的情况下更进一步，那么看看这个使碰撞处理更容易的Matter插件:<a class="ae kl" href="https://github.com/dxu/matter-collision-events#readme" rel="noopener ugc nofollow" target="_blank">dxu/Matter-collision-events</a>。当我们使用Phaser时，我们将使用一个插件来解决这个问题。</p><h1 id="fd59" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">相位器中的简单碰撞</h1><p id="00fb" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">既然我们已经了解了物质中碰撞是如何工作的，让我们在Phaser中使用它们。在开始创建平台之前，让我们快速回顾一下上次的表情符号删除示例:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d46420789f5bd8ce0d7edf76a662e204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KK5tUBcIDflDUswmLBfonQ.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">像上次一样掉表情符号，只不过现在他们碰撞时会生气。</em></figcaption></figure><p id="5b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当表情符号与某物发生碰撞时，我们会让它播放一小段愤怒的表情动画。这里是另一个<a class="ae kl" href="https://codesandbox.io/s/l5ko8wo917?module=%2Fjs%2Fmain-scene.js" rel="noopener ugc nofollow" target="_blank">入门模板</a>，你可以在这里编码。它有一个tilesmap，在tile上设置了物体。注意:Phaser和更低版本有一个关于物质的<code class="fe mv mw mx my b">collisionEnd</code>的bug，但是现在在3.12和更高版本中已经被修补了。起始项目使用3.12。</p><p id="a6fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当玩家点击屏幕时，我们会放下一个启用事件的表情符号。上次我们用了一个<code class="fe mv mw mx my b"><a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html" rel="noopener ugc nofollow" target="_blank">Phaser.Physics.Matter.Image</a></code>作为表情符号，但这次我们将使用一个<code class="fe mv mw mx my b"><a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Sprite.html" rel="noopener ugc nofollow" target="_blank">Phaser.Physics.Matter.Sprite</a></code>，这样我们就可以使用动画了。这进入了我们场景的<code class="fe mv mw mx my b">create</code>方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="de52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们只需要处理碰撞(也在<code class="fe mv mw mx my b">create</code>):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="66e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">熟悉吧？其结构与native Matter非常相似，只是Phaser将事件名小写以匹配其自身的约定。<code class="fe mv mw mx my b">bodyA</code>和<code class="fe mv mw mx my b">bodyB</code>是物质体，但是有一个附加属性。如果身体属于Phaser游戏对象(如精灵、图像、瓷砖等)。)，他们会有一个<code class="fe mv mw mx my b">gameObject</code>属性。然后，我们可以使用该属性来识别碰撞的内容:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的场景中有两种类型的碰撞物体——精灵和瓷砖。我们使用<code class="fe mv mw mx my b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank">instanceof</a></code>来判断哪些身体是表情符号精灵。我们播放一个愤怒的动画，并使精灵半透明。我们也可以使用<code class="fe mv mw mx my b">collisionend</code>事件让精灵再次变得不透明:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">查看</em><a class="ae kl" href="https://codesandbox.io/s/810yw745v9?hidenavigation=1&amp;module=%2Fjs%2Fmain-scene.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc"/><a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/02-simple-phaser-collisions" rel="noopener ugc nofollow" target="_blank"><em class="lc">live示例</em> </a> <em class="lc">或源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/02-simple-phaser-collisions" rel="noopener ugc nofollow" target="_blank"> <em class="lc">此处</em> </a> <em class="lc">。</em></figcaption></figure><p id="765b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经看到了自然物质事件和Phaser对这些物质事件的包装。如果没有更好的结构，这两者使用起来都有点混乱，但在我们开始使用插件来帮助我们管理冲突之前，了解它们是很重要的。如果你决定不想依赖我的插件，这一点尤其重要😉。</p><h1 id="2371" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">碰撞插件</h1><p id="efb0" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我创建了一个Phaser插件，让我们在Phaser中进行物质碰撞时的生活变得更加轻松:<a class="ae kl" href="https://github.com/mikewesthad/phaser-matter-collision-plugin" rel="noopener ugc nofollow" target="_blank">Phaser-Matter-collision-plugin</a>。我们将使用它来构建这个(这是我们用平台化产品增加复杂性之前的最后一站):</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e9cdb9305724d35af7fa83f2a61ce847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iT6f2T3nzkO5wgUFItoDww.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">爱恨碰撞</em></figcaption></figure><p id="57eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个插件，我们可以检测特定游戏对象之间的冲突，例如:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="07a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者在游戏对象组之间:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bdbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者在游戏对象和任何其他物体之间:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="821e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一些其他有用的功能——如果你想了解更多，请查看文档。我们将使用它，并在过程中解释它是如何工作的。</p><p id="0570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Phaser的插件系统允许我们以结构化的方式连接到游戏引擎，并添加额外的功能。碰撞插件是一个场景插件(相对于一个全局插件，见<a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.Plugins.PluginManager.html" rel="noopener ugc nofollow" target="_blank">文档</a>)，所以在我们通过<code class="fe mv mw mx my b">this.matterCollision</code>安装后，每个场景都可以访问一个实例。</p><p id="1927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个<a class="ae kl" href="https://codesandbox.io/s/316pq9j541?module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox starter项目</a>用于编码。它的依赖项Phaser和PhaserMatterCollisionPlugin已经作为依赖项安装。(这里有额外的说明<a class="ae kl" href="https://mikewesthad.github.io/phaser-matter-collision-plugin/docs/#installation" rel="noopener ugc nofollow" target="_blank"/>关于如何从CDN加载插件或者在本地安装。)</p><p id="71d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在index.js中，我们可以加载安装了插件的游戏:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在main-scene.js里面，在<code class="fe mv mw mx my b">create</code>里面:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="217b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们不必担心碰撞对的顺序，或者找到附加的游戏对象(或者处理复合体)。我们可以在我们认为合适的类/模块中组织我们的冲突逻辑——比如让播放器监听它在player.js中关心的冲突。</p><p id="6bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是最终的代码，添加了一些额外的代码以使表情符号可拖动:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">c<em class="lc">check出</em><a class="ae kl" href="https://codesandbox.io/s/v829vxpp8l?hidenavigation=1&amp;module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc"/><a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/03-plugin-setup" rel="noopener ugc nofollow" target="_blank"><em class="lc">live示例</em> </a> <em class="lc">或者源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/03-plugin-setup" rel="noopener ugc nofollow" target="_blank"> <em class="lc">这里</em> </a></figcaption></figure><h1 id="a73c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">平台玩家:创建玩家</h1><p id="abb1" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">现在我们已经有了碰撞的基本原理，我们可以处理一些更复杂的东西——一个平台。我们将分块构建它，从玩家类开始。在第一部分，我们将以以下内容结束:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/fc1a6c5d78d03cba03f8ccbcf71aa70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*H5WZPeyctJmxK8A8xmxfiA.gif"/></div></div></figure><p id="ff99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是最后一个<a class="ae kl" href="https://codesandbox.io/s/pmkmj7r8lm?module=%2Fjs%2Fplayer.js" rel="noopener ugc nofollow" target="_blank"> starter CodeSandbox项目</a>,你可以用它来编写这篇文章的剩余部分。它已经有一个加载了碰撞的贴图，并且为我们将要创建的不同模块准备了空文件。</p><p id="800c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从创建我们的平台化“player.js”文件开始。像Matter这样的现实物理引擎带来的挑战之一是，它们在游戏环境中很难以可预测的方式控制。与我们在<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a">帖子中的两个</a>的单一矩形身体相比，这个角色将有一个由四部分组成的复合身体:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nd"><img src="../Images/125863b5e714c0bfa076f833945b1448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ne6pUF9fVdWdKqu8gZifQ.png"/></div></div></figure><p id="8485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的播放器由一个主体和三个传感器组成。主体将像我们以前创建的矩形体，除了它将有圆角(倒角)。这有助于消除碰撞(这在后面会更有意义)。至于其他三个部分，传感器是一个不与世界上其他物体发生物理反应，但仍然会引发碰撞的物体。这将允许我们实现一些特殊的逻辑——例如，玩家下方的传感器将让我们知道玩家当前是否在地面上。</p><p id="0b3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直接进入代码，我们将需要依赖本机物质API，可在<code class="fe mv mw mx my b">Phaser.Physics.Matter.Matter</code>(是的，双物质)下访问，来构建主体:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在main-scene.js中创建播放器，从地图中的平铺对象(已经在starter模板的level.json文件中)加载它的位置:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们最后会得到:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ce947160ed0e90a9e8eced47cacb0832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/1*v_Q-fBYlKYUmAh3Nisuvyg.gif"/></div></figure><p id="add2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到播放器类，添加一些控件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里做了一些事情。首先，为了更好地处理输入，我们使用了一个名为<code class="fe mv mw mx my b">MultiKey</code>的小类，这是我为我们提供的。源代码在沙箱中，但是对于我们的目的，我们需要知道的是我们传递给它尽可能多的Phaser键，然后<code class="fe mv mw mx my b">isDown()</code>方法会告诉我们是否有任何键被按下。这使得用W/A/S/D键或箭头键控制播放器变得很容易。</p><p id="b060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，我们将玩家的<code class="fe mv mw mx my b">update</code>方法与场景的生命周期<code class="fe mv mw mx my b">this.scene.events.on("update", this.update, this)</code>挂钩。在以前的帖子中，我们手动调用了播放器的更新方法，但现在每当场景更新时，播放器都会自行更新。</p><p id="2637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在update中，我们向玩家施加一个力来水平移动他们以响应按键输入。因为我们在任何时候按下键时都在施加力，所以速度会随着我们按住键的时间越长而不断增加——直到精灵飞出屏幕的速度达到惊人的速度。我们需要手动设定(水平)速度限制。为了让玩家跳跃，我们也增加了y方向的速度。</p><p id="7fa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个球员在世界各地移动，但我们有两个问题。首先，玩家可以在半空中跳跃，也就是超人:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/d30018db641dc77646c1fbdef00bb29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/1*O0dqEHO7tm_xi8zDGO4seg.gif"/></div></figure><p id="4ff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个是，因为玩家有一个有摩擦力的身体，玩家可以通过跳进一堵墙来粘在墙上，也就是蜘蛛侠:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8cec4dac19e97a0b4259459ba4512dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/1*q6tvuZBWQFGKcnDR2lHyRA.gif"/></div></figure><p id="5004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是那些传感器发挥作用的地方！我们可以使用地面传感器来知道玩家是在地面上还是在空中，这样我们就可以解决跳跃问题。我们可以使用左/右传感器来知道玩家何时靠墙，这样我们就可以取消蜘蛛侠贴墙的能力。我们将不得不修改一些东西:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1a94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们添加了两个属性——<code class="fe mv mw mx my b">canJump</code>&amp;<code class="fe mv mw mx my b">jumpCooldownTimer</code>——我们将在更新中使用。我们还添加了<code class="fe mv mw mx my b">isTouching</code>，这是我们如何跟踪世界上哪些传感器正在接触某些东西。我们挂钩到Matter的<code class="fe mv mw mx my b">beforeupdate</code>事件，它在任何碰撞事件之前运行，以将<code class="fe mv mw mx my b">isTouching</code>字段重置回<code class="fe mv mw mx my b">false</code>。使用物质碰撞插件，每当传感器击中场景中的另一个物体时，我们标记<code class="fe mv mw mx my b">isTouching</code>到<code class="fe mv mw mx my b">true</code>的适当区域。</p><p id="2cc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用了事件事件中的<code class="fe mv mw mx my b">pair.separation</code>。这告诉我们物体要移动多远才能不再碰撞。我们推动玩家稍微远离左侧或右侧的任何墙壁(但留下0.5px的重叠，以便传感器继续碰撞)。玩家的<code class="fe mv mw mx my b">mainBody</code>——也就是与世界进行物理交互的东西——不再能被压在墙上，所以摩擦贴墙的问题就解决了。</p><p id="d6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到更新，我们可以改变一些事情:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们调整了移动速度，让你在空中移动得更慢，这样你就不能在空中推来推去了(这对我们给世界添加可移动的物体很重要)。我们还修改了跳跃，这样你只能在地面传感器与某样东西碰撞时跳跃。我们还使用了一个相位计时器来创造一个冷却时间，这样你就必须在跳跃之间等待250毫秒。</p><p id="247a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">查看</em><a class="ae kl" href="https://codesandbox.io/s/5vlzl8j9vp?hidenavigation=1&amp;module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc"/><a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/04-platformer-step-1" rel="noopener ugc nofollow" target="_blank"><em class="lc">live示例</em> </a> <em class="lc">或源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/04-platformer-step-1" rel="noopener ugc nofollow" target="_blank"> <em class="lc">此处</em> </a></figcaption></figure><p id="ca4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经在那个沙箱中添加了玩家动画，检查一下<code class="fe mv mw mx my b">create</code>和<code class="fe mv mw mx my b">update</code>方法，看看它们是如何工作的。</p><h1 id="5696" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">关闭和销毁时整理</h1><p id="01a7" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我们会想给我们的世界增加更多的互动性。我们将增加的第一件事是杀死玩家的能力，并在他们落在熔岩或尖钉上时重启场景。要做到这一点，我们需要负责任，让玩家实例自己清理。</p><p id="a85c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一个教程中，我们有清理和破坏播放器的场景处理。因为我们将玩家直接挂钩到事件中，所以我们希望玩家监听<code class="fe mv mw mx my b">shutdown</code>和<code class="fe mv mw mx my b">destroy</code>场景事件。<code class="fe mv mw mx my b">shutdown</code>是在一个场景内调用<code class="fe mv mw mx my b"><a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.ScenePlugin.html#restart__anchor" rel="noopener ugc nofollow" target="_blank">this.scene.restart</a></code>或<code class="fe mv mw mx my b"><a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.Scenes.ScenePlugin.html#stop__anchor" rel="noopener ugc nofollow" target="_blank">this.scene.stop</a></code>触发的。停止时，场景实例不会被破坏，因此如果场景再次启动，它将通过<code class="fe mv mw mx my b">init</code>和<code class="fe mv mw mx my b">create</code>(但不是构造函数)。杀死场景实例，如果我们再次开始那个场景，一个新的实例将被创建。在这两种情况下，我们都将取消监听器对任何事件的订阅，并销毁玩家的精灵。player.js内部:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cdef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们监听关闭和销毁，作为响应，触发播放器的<code class="fe mv mw mx my b">destroy</code>方法。这将取消订阅任何可能在玩家场景事件中触发代码的东西，比如碰撞插件回调，计时器。我们也摧毁了精灵。尽管这个方法是由场景事件自动调用的，但它是以这样一种方式编写的，即我们可以决定在任何时间点摧毁玩家，而不管场景事件。</p><p id="ee46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还在代码中添加了一个<code class="fe mv mw mx my b">destroyed</code>标志。这是必要的，因为<a class="ae kl" href="https://github.com/primus/eventemitter3" rel="noopener ugc nofollow" target="_blank">事件发射器3 </a>的工作方式。当事件被触发时，事件的任何事件侦听器都会在事件开始时被缓存。因此，在更新事件中被摧毁的玩家可能仍然会收到更多的更新事件，这是有可能的(在使用物理时经常发生)。我们可以在未来使用类似于<a class="ae kl" href="https://github.com/samme/phaser-plugin-update" rel="noopener ugc nofollow" target="_blank">samme/phaser-update-plugin</a>或<a class="ae kl" href="https://github.com/sporadic-labs/phaser-lifecycle-plugin" rel="noopener ugc nofollow" target="_blank">emotional-labs/phaser-life cycle-plugin</a>的插件来解决这个问题。两者都是场景事件的代理，所以如果您通过它们取消订阅侦听器，您可以相信事件不会再次调用侦听器。</p><h1 id="991d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">玩家vs致命牌</h1><p id="677e" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">咻，现在我们可以继续通过添加一些简单的物理谜题来构建这个世界。首先，让我们在玩家落在长钉或熔岩上时杀死它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/6c08b1315d6e2857fbdfa9eef02d749a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HH2PZmWBAb1TJ3fIoz3k2g.gif"/></div></div></figure><p id="f473" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的主场景中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e91d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在设置玩家的精灵与世界上的任何东西发生碰撞。当它碰撞时，我们检查它碰撞的物体(<code class="fe mv mw mx my b">gameObjectB</code>)是否是瓷砖。如果是，而且是致命的磁贴(磁贴属性设置在磁贴中——见<a class="ae kl" href="https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6#b92b" rel="noopener">“随物理移动”一节</a>)，我们淡出并重新开始场景。</p><p id="dba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">播放器上的<code class="fe mv mw mx my b">freeze</code>方法(在starter模板中给出)只是让播放器的身体保持静止，这样它就不会在渐变期间移动。<code class="fe mv mw mx my b">unsubscribePlayerCollide</code>在这里真的很重要。这个函数——从<code class="fe mv mw mx my b">addOnCollideStart</code>返回——将移除我们添加的碰撞监听器，这样玩家只能死一次。</p><p id="c5a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是这篇文章的最后一个平台沙盒(包括致命瓷砖和接下来几节的代码):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">查看</em><a class="ae kl" href="https://codesandbox.io/s/j44k3844j3?hidenavigation=1&amp;module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc"/><a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/04-platformer-step-2" rel="noopener ugc nofollow" target="_blank"><em class="lc">live示例</em> </a> <em class="lc">或源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/04-platformer-step-2" rel="noopener ugc nofollow" target="_blank"> <em class="lc">此处</em> </a></figcaption></figure><h1 id="b3ba" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">板条箱和钉子拼图</h1><p id="1626" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">地图上有尖刺的部分在没有帮助的情况下是不可跳跃的。让我们创建一个非常简单的物理难题来展示物质。我们会在玩家面前放一些板条箱，让他们敲下来，这样他们就可以越过钉子。因为我们使用平铺来构建关卡，所以我们将使用一个对象层。它已经在starter项目中设置好了，但下面是它的制作过程:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/38a1d2091246b60710047170c99e5794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bFWxOBxT6qHq9g1pRDWypw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">使用图块对象工具，该工具允许您在地图中放置图块图形</em></figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/b1b5db9f3411db34e03f25cf1dff8eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YKrEDLjLNR2A1pNlsoj0Lg.gif"/></div></div></figure><h1 id="6e82" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">约束和跷跷板平台</h1><p id="4cb5" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在尖峰之后，我们有一个充满熔岩的大裂缝，所以让我们在那个区域添加一些旋转平台来创建另一个简单的物理难题。平台将使用约束将它们固定在空间中，但它们将自由旋转:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/c4cb9b37c979a9a8c32ecaa5f2577d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*u6r3GTGbUQ8XuprSSI0ARA.gif"/></div></div></figure><p id="b840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，它已经在starter项目中设置好了，但下面是如何使用Tiled来选择这些平台的位置:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/1be4d55707656700619f82cc49895274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qZ-bfrRVS_gJVzhLK49i6Q.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">放置点对象，并按住CTRL键以捕捉到栅格位置</figcaption></figure><p id="0472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们可以使用尚未创建的模块来放置平台:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="91a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望这些平台像一个静态物体一样呆在原地，但是我们不能在这里使用静态物体，因为这样平台就不能旋转。相反，我们将使用一种叫做约束的东西来将平台固定在一个固定的位置。从Matter.js查看<a class="ae kl" href="http://brm.io/matter-js/demo/#constraints" rel="noopener ugc nofollow" target="_blank">约束演示</a>和<a class="ae kl" href="https://github.com/liabru/matter-js/blob/master/examples/constraints.js" rel="noopener ugc nofollow" target="_blank">源代码</a>，我们可以将约束视为一种表达一个物体应该与空间中的另一个物体或点不可见地链接的方式。然后，该几何体将尝试与另一个几何体或点保持固定的距离(由您指定)。</p><p id="eab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个新文件“create-rotating-platform.js”中，我们可以导出一个创建平台的函数。(我们在这里并不真的需要一个类——我们只是在配置一个<a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.TileSprite.html" rel="noopener ugc nofollow" target="_blank">tile script</a>。)</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="33c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在利用<a class="ae kl" href="https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.TileSprite.html" rel="noopener ugc nofollow" target="_blank"> TileSprite </a>，这样我们就可以使用我们的tile资产(64 x 64像素)在世界中创建一个平台。我刚刚从tileset中提取了一个单独的图块，并将其裁剪为64 x 18像素。</p><p id="d581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">约束可以带来很多乐趣。我们在普通物质中能做的任何事情，我们都可以用物质和相位器来做。查看Matter的<a class="ae kl" href="http://brm.io/matter-js/docs/classes/Constraint.html" rel="noopener ugc nofollow" target="_blank">约束文档</a>了解更多信息。</p><p id="5982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是最后一个平台沙盒，其中包括这一部分的代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">查看</em><a class="ae kl" href="https://codesandbox.io/s/j44k3844j3?hidenavigation=1&amp;module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc"/><a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/04-platformer-step-2" rel="noopener ugc nofollow" target="_blank"><em class="lc">live示例</em> </a> <em class="lc">或源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/04-platformer-step-2" rel="noopener ugc nofollow" target="_blank"> <em class="lc">此处</em> </a></figcaption></figure><h1 id="8f5c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">庆祝触发器</h1><p id="9898" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">太好了——我们可以从屏幕的左侧看到右侧。当玩家这样做的时候，让我们做一些有趣的事情来庆祝。我们将创建一个不可见的传感器，当玩家碰到传感器时，我们会在玩家身上投放庆祝表情符号:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/c055d28ea68d8931a5535758c17fcf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jKRCyuic112BOIVxq8-nOw.gif"/></div></div></figure><p id="d65c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，已经在启动项目的level.json中创建了传感器，但是它是如何创建的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/c24598c401bfed7cc7a29d38964ad4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qEuK1r7y1tTsXHKLYSMl6Q.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">使用矩形对象工具，并给这个传感器一个特定的名称，以便它很容易在Phaser中找到</figcaption></figure><p id="b40a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以加载它，并在场景中监听碰撞:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fc4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种隐形传感器的相同想法可以用于触发按钮，下降平台，加载下一级等。</p><p id="6f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们就有了一个很好的小的物理水平，你可以进行实验和扩展。</p><p id="566e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这又是最后一个平台沙盒(包括这段代码):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb na l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><em class="lc">查看</em><a class="ae kl" href="https://codesandbox.io/s/j44k3844j3?hidenavigation=1&amp;module=%2Fjs%2Findex.js" rel="noopener ugc nofollow" target="_blank"><em class="lc">code sandbox</em></a><em class="lc"/><a class="ae kl" href="https://www.mikewesthad.com/phaser-3-tilemap-blog-posts/post-5/04-platformer-step-2" rel="noopener ugc nofollow" target="_blank"><em class="lc">live示例</em> </a> <em class="lc">或源代码</em> <a class="ae kl" href="https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-5/04-platformer-step-2" rel="noopener ugc nofollow" target="_blank"> <em class="lc">此处</em> </a></figcaption></figure><h1 id="3186" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">幽灵碰撞</h1><p id="bf44" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">在探索物质的某个时候，你可能会遇到常见的幽灵碰撞问题。如果你注意到一个玩家在瓷砖平台上行走时似乎没有被什么绊倒，你很可能遇到了幽灵碰撞。下面是它们的样子:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ni"><img src="../Images/d4097c3f4ea112c43559b996ba077fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OdTdtdka-Ob8Rf56245PLQ.gif"/></div></div></figure><p id="e1c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看看我在Phaser Labs上创建的相应的现场演示。当蘑菇在顶部平台上移动时，你可以看到它们抓住了瓷砖的垂直边缘。这是由于物理引擎如何解决碰撞。当蘑菇碰撞瓷砖时，引擎将瓷砖视为独立的实体。它不知道它们形成一条直线，蘑菇不应该碰到任何垂直边缘。查看这篇文章以获得更多信息，并了解Box2D如何解决这个问题。</p><p id="ebdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几种方法可以缓解这种情况:</p><ul class=""><li id="40b2" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk nj lj lk ll bi translated">给物体添加倒角，例如，像我们在这篇文章中做的那样，或者使用圆形物体来减少幽灵碰撞的影响。</li><li id="9072" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk nj lj lk ll bi translated">用尽可能少的形状来绘制关卡的生命盒，而不是给每个方块一个单独的实体。您仍然可以为此使用平铺。创建一个对象层，用形状填充它，在Phaser中将这些形状转换成物体。上面链接的演示代码就是这样做的。</li><li id="fc6d" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk nj lj lk ll bi translated">或者，使用@hexus的<a class="ae kl" href="https://github.com/hexus/phaser-slopes" rel="noopener ugc nofollow" target="_blank"> phaser-slopes </a>插件。它解决了对tilemaps的幽灵碰撞，让你保持你的瓷砖作为单独的机构。</li></ul><h1 id="2b80" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">系列大结局</h1><p id="f8af" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">感谢阅读。希望你喜欢阅读这个关于模块化游戏世界的系列。</p><p id="2392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这个系列已经结束，但我仍将发布关于Phaser 3的帖子，所以如果您对格式有反馈，或者您希望在未来的帖子中看到一些内容，请告诉我！</p><h1 id="96c1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">关于我</h1><p id="e504" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我是一名创意开发人员和教育家。我为Phaser 3编写了Tilemap API，并创建了大量有指导的示例，但我希望将所有这些信息收集成一种更有指导、更易理解的格式，以便人们可以更容易地进入Phaser 3。你可以看到更多我的作品，并在这里联系我。</p></div></div>    
</body>
</html>