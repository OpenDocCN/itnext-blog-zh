<html>
<head>
<title>Go Tutorial: Database queries on Go with PostgreSQL [Part III]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go教程:使用PostgreSQL进行数据库查询[第三部分]</h1>
<blockquote>原文：<a href="https://itnext.io/go-tutorial-database-queries-on-go-with-postgresql-part-iii-c8907729c2f?source=collection_archive---------3-----------------------#2020-07-14">https://itnext.io/go-tutorial-database-queries-on-go-with-postgresql-part-iii-c8907729c2f?source=collection_archive---------3-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div class="gh gi jr"><img src="../Images/99822f5ee94b0d91f528ad3c29e40c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Gbi_XNOkPFbWkIkJC7LnBQ.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">戈朗</figcaption></figure><h1 id="9d8a" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用PostgreSQL进行数据库查询</h1><h2 id="5e11" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">介绍</h2><p id="9223" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated"><em class="mk">注意:这是一个分为3部分的教程:</em></p><ol class=""><li id="56fd" class="ml mm it lr b ls mn lw mo lf mp li mq ll mr mj ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/@juancurti.it/go-tutorial-getting-started-part-i-f992a711ba49?source=your_stories_page---------------------------" rel="noopener">T3】安装围棋T5】</a></li><li id="8bd7" class="ml mm it lr b ls mx lw my lf mz li na ll nb mj ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/@juancurti.it/go-tutorial-tdd-with-go-and-postgresql-part-ii-489c929f02c9?source=your_stories_page---------------------------" rel="noopener"> <em class="mk"> TDD带Go和PostgreSQL </em> </a></li><li id="ae76" class="ml mm it lr b ls mx lw my lf mz li na ll nb mj ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/@juancurti.it/go-tutorial-database-queries-on-go-with-postgresql-part-iii-c8907729c2f?source=your_stories_page---------------------------" rel="noopener"> <em class="mk">使用PostgreSQL进行数据库查询</em> </a></li></ol><h2 id="e43b" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">完成工作</h2><p id="1118" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">在第二部分，我们最终为我们的方法编写所有的测试，特别是为我们的产品模型。回到我们的model.go文件，我们留下了许多“未实现”的消息，所以让我们修复它:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="59df" class="la kd it nh b gy nl nm l nn no">func (p *product) getProduct(db *sql.DB) error {<br/>  return db.QueryRow("SELECT name, price FROM products WHERE id=$1",<br/>        p.ID).Scan(&amp;p.Name, &amp;p.Price)<br/>}</span><span id="295e" class="la kd it nh b gy np nm l nn no">func (p *product) updateProduct(db *sql.DB) error {<br/>  _, err :=<br/>        db.Exec("UPDATE products SET name=$1, price=$2 WHERE id=$3",<br/>            p.Name, p.Price, p.ID)</span><span id="6cb1" class="la kd it nh b gy np nm l nn no">return err<br/>}</span><span id="56f3" class="la kd it nh b gy np nm l nn no">func (p *product) deleteProduct(db *sql.DB) error {<br/>  _, err := db.Exec("DELETE FROM products WHERE id=$1", p.ID)</span><span id="f1fc" class="la kd it nh b gy np nm l nn no">return err<br/>}</span><span id="f391" class="la kd it nh b gy np nm l nn no">func (p *product) createProduct(db *sql.DB) error {<br/>  err := db.QueryRow(<br/>        "INSERT INTO products(name, price) VALUES($1, $2) RETURNING id",<br/>        p.Name, p.Price).Scan(&amp;p.ID)</span><span id="77f4" class="la kd it nh b gy np nm l nn no">if err != nil {<br/>        return err<br/>    }</span><span id="e770" class="la kd it nh b gy np nm l nn no">return nil<br/>}</span><span id="1038" class="la kd it nh b gy np nm l nn no">func getProducts(db *sql.DB, start, count int) ([]product, error) {<br/>  rows, err := db.Query(<br/>        "SELECT id, name,  price FROM products LIMIT $1 OFFSET $2",<br/>        count, start)</span><span id="db67" class="la kd it nh b gy np nm l nn no">if err != nil {<br/>        return nil, err<br/>    }</span><span id="5ac0" class="la kd it nh b gy np nm l nn no">defer rows.Close()</span><span id="b9fa" class="la kd it nh b gy np nm l nn no">products := []product{}</span><span id="5333" class="la kd it nh b gy np nm l nn no">for rows.Next() {<br/>        var p product<br/>        if err := rows.Scan(&amp;p.ID, &amp;p.Name, &amp;p.Price); err != nil {<br/>            return nil, err<br/>        }<br/>        products = append(products, p)<br/>    }</span><span id="1c56" class="la kd it nh b gy np nm l nn no">return products, nil<br/>}</span></pre><h2 id="dadb" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">创建路线和处理程序</h2><p id="a0b1" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">现在我们可以开始添加位于app.go文件中的路线和路线处理程序。为此，首先我们将向app.go添加net/http、encoding/json和strconv模块。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7d9d" class="la kd it nh b gy nl nm l nn no">func (a *App) getProduct(w http.ResponseWriter, r *http.Request) {<br/>    vars := mux.Vars(r)<br/>    id, err := strconv.Atoi(vars["id"])<br/>    if err != nil {<br/>        respondWithError(w, http.StatusBadRequest, "Invalid product ID")<br/>        return<br/>    }<br/><br/>    p := product{ID: id}<br/>    if err := p.getProduct(a.DB); err != nil {<br/>        switch err {<br/>        case sql.ErrNoRows:<br/>            respondWithError(w, http.StatusNotFound, "Product not found")<br/>        default:<br/>            respondWithError(w, http.StatusInternalServerError, err.Error())<br/>        }<br/>        return<br/>    }<br/><br/>    respondWithJSON(w, http.StatusOK, p)<br/>}</span></pre><p id="3550" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">这个方法使用respondWithError和respondWithJSON方法来处理错误和成功响应，所以让我们实现它们:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="89e1" class="la kd it nh b gy nl nm l nn no">func respondWithError(w http.ResponseWriter, code int, message string) {<br/>    respondWithJSON(w, code, map[string]string{"error": message})<br/>}<br/><br/>func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {<br/>    response, _ := json.Marshal(payload)<br/><br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.WriteHeader(code)<br/>    w.Write(response)<br/>}</span></pre><p id="2cec" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">现在我们可以实现getProducts处理程序了:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="1867" class="la kd it nh b gy nl nm l nn no">func (a *App) getProducts(w http.ResponseWriter, r *http.Request) {<br/>    count, _ := strconv.Atoi(r.FormValue("count"))<br/>    start, _ := strconv.Atoi(r.FormValue("start"))<br/><br/>    if count &gt; 10 || count &lt; 1 {<br/>        count = 10<br/>    }<br/>    if start &lt; 0 {<br/>        start = 0<br/>    }<br/><br/>    products, err := getProducts(a.DB, start, count)<br/>    if err != nil {<br/>        respondWithError(w, http.StatusInternalServerError, err.Error())<br/>        return<br/>    }<br/><br/>    respondWithJSON(w, http.StatusOK, products)<br/>}</span></pre><p id="5da0" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">创建产品的处理程序:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7b43" class="la kd it nh b gy nl nm l nn no">func (a *App) createProduct(w http.ResponseWriter, r *http.Request) {<br/>    var p product<br/>    decoder := json.NewDecoder(r.Body)<br/>    if err := decoder.Decode(&amp;p); err != nil {<br/>        respondWithError(w, http.StatusBadRequest, "Invalid request payload")<br/>        return<br/>    }<br/>    defer r.Body.Close()<br/><br/>    if err := p.createProduct(a.DB); err != nil {<br/>        respondWithError(w, http.StatusInternalServerError, err.Error())<br/>        return<br/>    }<br/><br/>    respondWithJSON(w, http.StatusCreated, p)<br/>}</span></pre><p id="b770" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">更新产品的处理程序:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="486b" class="la kd it nh b gy nl nm l nn no">func (a *App) updateProduct(w http.ResponseWriter, r *http.Request) {<br/>    vars := mux.Vars(r)<br/>    id, err := strconv.Atoi(vars["id"])<br/>    if err != nil {<br/>        respondWithError(w, http.StatusBadRequest, "Invalid product ID")<br/>        return<br/>    }<br/><br/>    var p product<br/>    decoder := json.NewDecoder(r.Body)<br/>    if err := decoder.Decode(&amp;p); err != nil {<br/>        respondWithError(w, http.StatusBadRequest, "Invalid resquest payload")<br/>        return<br/>    }<br/>    defer r.Body.Close()<br/>    p.ID = id<br/><br/>    if err := p.updateProduct(a.DB); err != nil {<br/>        respondWithError(w, http.StatusInternalServerError, err.Error())<br/>        return<br/>    }<br/><br/>    respondWithJSON(w, http.StatusOK, p)<br/>}</span></pre><p id="e793" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">删除产品的处理程序:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="a738" class="la kd it nh b gy nl nm l nn no">func (a *App) deleteProduct(w http.ResponseWriter, r *http.Request) {<br/>    vars := mux.Vars(r)<br/>    id, err := strconv.Atoi(vars["id"])<br/>    if err != nil {<br/>        respondWithError(w, http.StatusBadRequest, "Invalid Product ID")<br/>        return<br/>    }<br/><br/>    p := product{ID: id}<br/>    if err := p.deleteProduct(a.DB); err != nil {<br/>        respondWithError(w, http.StatusInternalServerError, err.Error())<br/>        return<br/>    }<br/><br/>    respondWithJSON(w, http.StatusOK, map[string]string{"result": "success"})<br/>}</span></pre><h2 id="b30d" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">定义路线</h2><p id="e775" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">现在我们有了处理程序，我们实现一个方法initializeRoutes来指定路由名称和方法:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="03e6" class="la kd it nh b gy nl nm l nn no">func (a *App) initializeRoutes() {<br/>    a.Router.HandleFunc("/products", a.getProducts).Methods("GET")<br/>    a.Router.HandleFunc("/product", a.createProduct).Methods("POST")<br/>    a.Router.HandleFunc("/product/{id:[0-9]+}", a.getProduct).Methods("GET")<br/>    a.Router.HandleFunc("/product/{id:[0-9]+}", a.updateProduct).Methods("PUT")<br/>    a.Router.HandleFunc("/product/{id:[0-9]+}", a.deleteProduct).Methods("DELETE")<br/>}</span></pre><p id="1e79" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">在Initialize方法的底部，我们调用initializeRoutes:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5ec1" class="la kd it nh b gy nl nm l nn no">a.initializeRoutes()</span></pre><p id="4a42" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">最后，我们完成了我们运行方法:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5d3b" class="la kd it nh b gy nl nm l nn no">log.Fatal(http.ListenAndServe(":8010", a.Router))</span></pre><p id="0df4" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf nq mb mc li nr me mf ll ns mh mi mj im bi translated">如果现在我们用go test -v再次运行测试:</p><figure class="nc nd ne nf gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/414a382aa8b0f8ccd3aafcce3cf4d6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjAbzLWkdWwknUaKSgtRJA.png"/></div></div></figure><h1 id="f8ed" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="4416" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">本教程展示了如何使用测试驱动开发，使用Gorilla Mux和PostgresSQL通过Go语言构建REST API。在测试你自己的代码的同时学习一门新的编程语言不仅会让你对你的代码有更多的控制，而且你还会通过测试来学习。这样你就可以在 编写测试之前开始思考如何防止你的代码失败。尽管存在人为错误，但测试是一种很好的实践。</p></div></div>    
</body>
</html>