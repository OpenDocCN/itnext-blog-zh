<html>
<head>
<title>Kubectl and gcloud client with Google Cloud and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Google云和Docker的Kubectl和gcloud客户端</h1>
<blockquote>原文：<a href="https://itnext.io/port-forwarding-and-other-things-with-google-cloud-and-docker-e8862bb61d8f?source=collection_archive---------4-----------------------#2021-04-17">https://itnext.io/port-forwarding-and-other-things-with-google-cloud-and-docker-e8862bb61d8f?source=collection_archive---------4-----------------------#2021-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何节省资金并避免为在群集之间转发少量端口而支付VPN连接费用。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/375b87f0485576a5e5dd7def33a9ce96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bSoiI445DXxRNgsx"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hackernoon" rel="noopener ugc nofollow" target="_blank">黑客正午</a> @ Unsplash</figcaption></figure><p id="530c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的旗舰项目在GKE的<a class="lv lw ep" href="https://medium.com/u/4f3f4ee0f977?source=post_page-----e8862bb61d8f--------------------------------" rel="noopener" target="_blank">谷歌云中运行。即将推出的新版本运行在我的</a><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/i-broke-my-kubernetes-cluster-running-on-raspberry-pi-355234a24d">个人树莓派集群</a>上，不过我想用实时流量测试一下。由于我所做的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/building-best-telegram-bot-bbf905d09d74">架构决策</a>，微服务之间的所有通信都通过NATS.io中的队列进行，这使得任何潜在的端口转发都变得更加容易——毕竟，我不需要处理几十个端口(如果我使用RESTful通信的话),并且将漏洞引入生产就像连接到队列一样简单。</p><p id="fe90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谷歌云GKE认证机制比“常规的”Kubernetes要复杂一些，昨晚我坐在屏幕前，想知道如何将我的本地集群与GKE连接起来，而不需要为VPN连接支付额外的费用，在某个时候，我意识到端口转发可能是一种方法...很好——向前。</p><h1 id="2aeb" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">寻找正确的解决方案</h1><p id="827d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我已经将kubefwd作为最流行的解决方案之一进行了测试，但是在docker和Kubernetes中运行它比预期的要复杂得多。毕竟，我一直在寻找一种简单的方法来转发单个端口。有几个项目，其中一个是近三年前的，另一个是去年年底更新的，这可能会满足我的需求，尽管在运行它们时有一些安全问题以及更多的问题。</p><p id="f2e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过几个小时的尝试和破坏，我已经创建了<a class="ae ky" href="https://github.com/lukaszraczylo/docker-gcp-kubectl" rel="noopener ugc nofollow" target="_blank"> docker-gcp-kubectl </a>映像，它允许您在几乎没有任何配置的情况下，使用kubectl运行相对稳定的端口转发服务到您的GKE集群，使身份验证变得简单而轻松，最重要的是，它在Kubernetes环境中运行良好。</p><p id="9fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目的另一个优点是——您可以在GKE中运行任何kubectl命令，例如，从您的管道中运行，这使得它更加通用。</p><h1 id="815b" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">怎么用？</h1><p id="ca8f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">它在docker中的应用如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Docker和GKE Kubernetes集群之间的端口转发</figcaption></figure><p id="183f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes环境版本稍微复杂一点，涉及到(在我的例子中)装载共享存储，但是您可以很容易地用secrets替换它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">本地Kubernetes和GKE Kubernetes集群之间的端口转发</figcaption></figure><p id="475b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我认为这个解决方案非常稳定——在过去12小时内没有出现任何故障和问题，并且确实帮助我节省了GKE VPC和我的本地集群之间不必要的VPN连接成本。</p><p id="d621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赞美诗在你问之前——<strong class="lb iu">是的</strong>，它对AMD64和ARM64都有效(Raspberry Pi！)</p><h1 id="6be6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我拿它做什么？</h1><ul class=""><li id="f8e5" class="mw mx it lb b lc mp lf mq li my lm mz lq na lu nb nc nd ne bi translated">我使用这个映像将NATS(队列)端口从我的实时GKE集群转发到本地Raspberry Pi集群。</li><li id="9538" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">我正在使用multiarch构建管道来为AMD64和ARM64架构创建映像——正如<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/unified-microservices-builds-using-github-actions-3442c4ee175e">在我的另一篇文章</a>中所描述的。</li><li id="24af" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在两端部署微服务映像，无需额外成本即可创建混合集群。</li><li id="17ee" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为Prometheus创建了额外的监控端点，以支持Grafana和警报系统。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/8d4a5f7e10232962c07e93a2dc4ecc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajhiAVnUyAbpz0bueAK_tQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在我的本地rPI集群上运行的微服务的Grafana仪表板</figcaption></figure><p id="3ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇简短但内容丰富的笔记文章将为偶然发现它的人提供一个思路，如何不仅削减云基础架构的成本，而且使其更加健壮和独立于供应商。</p></div></div>    
</body>
</html>