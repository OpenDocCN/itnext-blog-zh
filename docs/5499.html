<html>
<head>
<title>Building Git in Elixir — Part 3 (Make History &amp; Store Executables)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中构建Git第3部分(创建历史和存储可执行文件)</h1>
<blockquote>原文：<a href="https://itnext.io/building-git-in-elixir-part-3-make-history-store-executables-e7dbb39e8e47?source=collection_archive---------8-----------------------#2021-03-17">https://itnext.io/building-git-in-elixir-part-3-make-history-store-executables-e7dbb39e8e47?source=collection_archive---------8-----------------------#2021-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b5bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/building-git-in-elixir-part-2-store-trees-initial-commit-9013ed02b75a">的前一篇文章</a>中，我关注于存储树和我们的第一次提交。在本文中，我将重点介绍创建提交历史和存储可执行文件。</p><h1 id="2c96" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一点理论</h1><p id="21c4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">Git通过将最新提交链接到其父提交来维护提交历史，从而构建提交历史。让我们来看看Git是如何做到这一点的。</p><p id="935c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们使用Git进行第一次提交时，它会输出如下内容—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/34018e1a387aeea22d6bbd438ccfbd1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffyI3whl6sWpHXead5gTyg.png"/></div></div></figure><p id="5a8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个输出告诉我们这是我们的<strong class="js iu">(根提交)</strong>，因为这是第一次提交。如果我们检查提交ID，我们可以看到以下详细信息—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi me"><img src="../Images/15d91f0afa26dc9d08ae4fec10e8860a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KprQ6NCGhiSlcfOi9JjRCA.png"/></div></div></figure><p id="3429" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们进行第二次提交并检查差异—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mf"><img src="../Images/9366782832a392656c5994f866b8b609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pjpe7gP2BBzimlPMmz04VA.png"/></div></div></figure><p id="b123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以看到Git在输出中不再说<strong class="js iu">(根提交)</strong>。此外，如果我们检查提交ID，我们可以看到它有一个新的<strong class="js iu">父</strong>条目，指向上一次(在本例中是第一次提交)提交的提交ID——</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/d0d6fbdea47df4cc76d977dc83316448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1urfeYBw3mEsp8RIQKE_sA.png"/></div></div></figure><p id="6137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是Git维护提交历史的方式——每次进行新的提交时，都会包含上一次提交的ID，但第一次提交除外，因为它没有上一次提交。</p><p id="ebf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文中我想关注的另一件事是git如何存储可执行文件。如果我们进行第三次提交并存储一个可执行文件，我们可以看到—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/c5aa66187a9b6b8e09be882021ec91bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U88PFLq3y7tY1KEX_eJr-A.png"/></div></div></figure><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mg"><img src="../Images/015b453504ba2de8693d4f5f857390f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4MKQTCQ3zNTrq5IOTFmaw.png"/></div></div></figure><p id="23ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们检查该树，我们可以看到可执行文件以模式<strong class="js iu"> 100755 </strong>存储，而不是<strong class="js iu"> 100644 </strong>(常规文件)—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mh"><img src="../Images/cbe812e814ceb435f0d9d54a3d2b1bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Yb2AX8DQS-Xl2-HjQzZ4Q.png"/></div></div></figure><h1 id="6b78" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">本文的重点</h1><p id="35e3" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本文中，重点是复制这种行为，以便<strong class="js iu"> egit commit </strong>可以—</p><ul class=""><li id="3c10" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">通过链接到父提交来创建历史</li><li id="5bf3" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">使用正确的模式存储可执行文件</li></ul><h1 id="681b" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">仙丹代码演练</h1><p id="1418" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这篇文章的代码可以在这里找到—<a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a></p><p id="55f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存储库中的<strong class="js iu"> README </strong>文件包含构建<strong class="js iu"> egit </strong>的指令，以及如何使用<strong class="js iu"> git init </strong>和更新的<strong class="js iu"> git commit </strong>命令。</p><h2 id="dde4" class="mw kq it bd kr mx my dn kv mz na dp kz kb nb nc ld kf nd ne lh kj nf ng ll nh bi translated">创造历史</h2><p id="3d0b" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">此特定更改的提交链接在此—<a class="ae ko" href="https://github.com/imeraj/elixir_git/commit/508cf2035c57550536bf1560ec44d65eb52492bc" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/elixir _ git/commit/508 cf 2035 c 57550536 BF 1560 EC 44d 65 EB 52492 BC</a></p><p id="ba4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以便创建提交历史并维护<strong class="js iu">。git/HEAD </strong>文件，引入了一个新的类型叫做<strong class="js iu"> Refs — </strong></p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3faa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="2cb3" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated"><strong class="js iu"> read_head </strong>(第22–31行)—从读取当前提交ID。<strong class="js iu"> git/HEAD </strong>并返回。如果这个文件不存在，它将返回<strong class="js iu"> nil </strong></li><li id="4ea3" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu"> update_head </strong>(第6-20行)——创建一个新文件<strong class="js iu">。git/HEAD.lock，</strong>在这个文件中写入新的提交ID，并将其重新命名为<strong class="js iu">。饭桶/人头。</strong>这样做是为了安全更新。<strong class="js iu"> git/HEAD </strong>并避免并发写入。</li></ul><p id="12f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个新类型，我更新了egit输出和存储提交的方式。<strong class="js iu"> commit.ex </strong>的新变化如下所示—</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d1e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="7faa" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">第11行—从<strong class="js iu">读取当前父ID。使用新<strong class="js iu">参考</strong>类型的git/HEAD </strong></li><li id="ec8e" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第34行—构建新的提交对象，传递新的<strong class="js iu">父</strong>参数</li><li id="1db2" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第37行—更新<strong class="js iu">。git/HEAD </strong>包含新的父提交ID</li><li id="3a13" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第39–45行—更新来自<strong class="js iu">提交</strong>命令的输出消息，考虑<strong class="js iu">父</strong>是否存在或为零</li></ul><p id="0c54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新后的<strong class="js iu">提交</strong>类型如下所示—</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="76fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里主要是<strong class="js iu">到_s </strong>()的功能发生了变化——</p><ul class=""><li id="a7f0" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated"><strong class="js iu">第14-29行</strong> —实现<strong class="js iu"> to_s </strong>()函数，该函数现在将父代存储为提交的一部分(第17-21行)</li></ul><h2 id="784c" class="mw kq it bd kr mx my dn kv mz na dp kz kb nb nc ld kf nd ne lh kj nf ng ll nh bi translated">存储可执行文件</h2><p id="f085" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">此特定更改的提交链接在此—<a class="ae ko" href="https://github.com/imeraj/elixir_git/commit/ae4ed41528c475525d5978b4ea996324d16c62fb" rel="noopener ugc nofollow" target="_blank">https://github . com/imeraj/elixir _ git/commit/ae4ed 41528 c 475525d 5978 B4 ea 996324d 16 c 62 FB</a></p><p id="71fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我想做的是将可执行文件存储在<strong class="js iu"> egit </strong>存储库中。到目前为止，我们已经使用模式“<strong class="js iu"> 100644 </strong>”存储了常规文件。可执行文件以“<strong class="js iu"> 100755 </strong>”模式存储。让我们来看看这些值是从哪里来的。</p><p id="e889" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们启动一个<strong class="js iu"> iex </strong>会话，并对一个常规文件执行<strong class="js iu">file . stat(&lt;filename&gt;)</strong>，我们可以看到—</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nk"><img src="../Images/a224784ca9fe44c7b29413b658c0d349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOJFLh9F_JeKxw8YVZvEAA.png"/></div></div></figure><p id="0ec0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> File.stat() </strong>显示模式<strong class="js iu"> 33188 </strong>。如果我们使用<strong class="js iu"> Integer.to_string() </strong>将其转换为八进制，它将输出“<strong class="js iu"> 100644 </strong>”。</p><p id="e264" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，对于一个可执行文件(egit——它是我的git版本的可执行文件),我们可以看到模式<strong class="js iu"> 33261 </strong>,它转换成八进制字符串“<strong class="js iu">100755”—</strong></p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nl"><img src="../Images/cc1db5140d8a841936717275c904774a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-fHD1wUShqIE0Va6JlNsw.png"/></div></div></figure><p id="f395" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Git以八进制存储文件模式。所以我要用同样的方法储存。</p><p id="55df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> workspace.ex </strong>已更新，增加了一个功能，如下所示</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8270" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="065f" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">第17–25行—实现<strong class="js iu"> stat_file(path) </strong>函数，该函数返回给定路径的文件状态信息</li></ul><p id="f734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如<strong class="js iu"> commit.ex </strong>的第21行所示(如上图所示)，每个<strong class="js iu">条目</strong>现在都构建了一个新的<strong class="js iu"> stat </strong>字段—</p><pre class="lt lu lv lw gt nm nn no np aw nq bi"><span id="6930" class="mw kq it nn b gy nr ns l nt nu">%Entry{name: path, oid: blob.oid, stat: Workspace.stat_file(path)}</span></pre><p id="5a0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新的<strong class="js iu">条目</strong>类型如下所示—</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e261" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="3022" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">第17–24行—实现<strong class="js iu">可执行文件？()</strong>给出文件模式的函数，确定是可执行文件还是普通文件。我不得不使用<strong class="js iu">逐位</strong>模块来实现这一点，因为我没有找到任何对此的直接库调用。</li><li id="86c0" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">第13–15行—实现<strong class="js iu"> mode() </strong>函数，该函数使用<strong class="js iu">可执行文件返回正确的存储模式。()</strong>功能。</li></ul><p id="6acd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">采油树</strong>类型已更新如下—</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8b39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里—</p><ul class=""><li id="6166" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">第19行—已更新以生成正确的模式调用<strong class="js iu"> Entry.mode() </strong>函数</li></ul><p id="3e3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个阶段，创建提交历史并将可执行文件存储在egit中的实现已经完成。</p><h1 id="fd21" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">带着埃吉特去兜风</h1><p id="284c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">对于本演示，我已经将可执行文件<strong class="js iu"> egit </strong>复制到当前工作目录中，这样我就可以在egit repo中将它作为可执行文件提交。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mh"><img src="../Images/ebae2778aaf27b2dcf4eff58f47b1f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74kv61Q3ITEPouG4N2XJWA.png"/></div></div></figure><p id="2d65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们可以看到的，提交消息的输出现在不同了。第二次提交不再说<strong class="js iu">(根提交)。</strong>此外，第二提交具有指向第一<strong class="js iu">提交的树</strong>的<strong class="js iu">父</strong>条目。</p><p id="4f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如<strong class="js iu"> git cat-file </strong>命令所示，第二个提交树有一个模式为<strong class="js iu"> 100755 </strong>的egit条目。</p><p id="6f83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> git log </strong>命令的输出如下所示</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mg"><img src="../Images/67a14776ab452ba6b9b86f1b9adbd948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZr9bhCFvAnnrknpIGZnNw.png"/></div></div></figure><p id="dcba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自<strong class="js iu"> git show </strong>命令的输出现在显示top commit有一个二进制文件</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mg"><img src="../Images/4471e0bb233d36ad9615f830e8435482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O79rMyo8V21dz__IsgOFkQ.png"/></div></div></figure><h1 id="67fb" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="465f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在本系列文章的第3部分中，我已经更新了<strong class="js iu"> egit commit </strong>命令，以创建提交历史并将可执行文件存储在egit repo中。还有，<strong class="js iu">。git/HEAD </strong>保持同步以反映最新的提交。在下一篇文章中，我将重点讨论如何存储嵌套树，以便我们能够正确地存储嵌套目录。</p><p id="e6ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nv">更多详细和深入的未来技术帖子请关注我这里或上</em><a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"><em class="nv">Twitter</em></a><em class="nv">。</em></p><h1 id="af69" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><ol class=""><li id="d126" class="mi mj it js b jt ln jx lo kb nw kf nx kj ny kn nz mo mp mq bi translated">【https://elixir-lang.org/getting-started/introduction.html T42】</li><li id="0941" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn nz mo mp mq bi translated"><a class="ae ko" href="https://elixir-lang.org/docs.html" rel="noopener ugc nofollow" target="_blank">https://elixir-lang.org/docs.html</a></li><li id="c7d5" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn nz mo mp mq bi translated"><a class="ae ko" href="https://git-scm.com/docs" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/docs</a></li><li id="1bb7" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn nz mo mp mq bi translated"><a class="ae ko" href="https://github.com/imeraj/elixir_git" rel="noopener ugc nofollow" target="_blank">https://github.com/imeraj/elixir_git</a></li></ol></div></div>    
</body>
</html>