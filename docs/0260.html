<html>
<head>
<title>Updating properties of an object in React state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更新处于反应状态的对象的属性</h1>
<blockquote>原文：<a href="https://itnext.io/updating-properties-of-an-object-in-react-state-af6260d8e9f5?source=collection_archive---------1-----------------------#2018-02-01">https://itnext.io/updating-properties-of-an-object-in-react-state-af6260d8e9f5?source=collection_archive---------1-----------------------#2018-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="ac74" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae ld" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fupdating-properties-of-an-object-in-react-state-af6260d8e9f5" rel="noopener ugc nofollow" target="_blank"> <em class="le">点击这里在LinkedIn </em> </a>上分享这篇文章</p><p id="6950" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">尽管如此，正如大多数人所知，<code class="fe lf lg lh li b">setState</code>是异步的，React足够聪明，可以在一个动作中处理多个<code class="fe lf lg lh li b">setState</code>:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="2fe6" class="lr ls iq li b gy lt lu l lv lw">clickHandler() {<br/>  this.setState({<br/>    a: 1<br/>  });<br/>  this.setState({<br/>    b: 2<br/>  });<br/>}</span><span id="9bce" class="lr ls iq li b gy lx lu l lv lw">render() {<br/>  console.log('render');<br/>  return &lt;button onClick={this.clickHandler}/&gt;;<br/>}</span></pre><p id="1f07" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">你会注意到，不仅<code class="fe lf lg lh li b">a</code>和<code class="fe lf lg lh li b">b</code>通过点击按钮得到更新，在控制台中，只有一个<code class="fe lf lg lh li b">"render"</code>被打印出来。</p><p id="a8ee" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果您有一个处于状态的对象，并且想要更新该对象的不同属性，它仍然以同样的方式工作吗？让我们看看如何在<code class="fe lf lg lh li b">setState</code>中更新一个对象。假设我们有一个对象，我们使用一个表单来编辑它。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="1347" class="lr ls iq li b gy lt lu l lv lw">this.state = {<br/>  todoList: {<br/>    day: '' // Monday, Tuesday, etc...<br/>    items: []<br/>  }<br/>}</span></pre><p id="b181" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在表单中，有一个下拉列表，用于选择从周一到周日的某一天。根据您选择的日期，将有另一个多选项目列表。这里的用例是，如果你选择了<code class="fe lf lg lh li b">Monday</code>，并且选择了一堆项目，那么你想选择另一天，比如说<code class="fe lf lg lh li b">Tuesday</code>。您刚刚为<code class="fe lf lg lh li b">Monday</code>选择的项目列表会发生什么变化？我们不能保留这份清单，因为它已经失效了，因为时间已经不多了。</p><p id="4a9a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">当然，我们需要做一些清理工作。最直接的方法是清空<code class="fe lf lg lh li b">items</code>列表。让我们看一下代码(这里将使用spread运算符和一些ES6，拜托，你必须知道)…</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="992b" class="lr ls iq li b gy lt lu l lv lw">onDaySelect(day) {<br/>  this.setState({<br/>    todoList: {<br/>      ...this.state.todoList,<br/>      day,<br/>      items: []<br/>    }<br/>  })<br/>}</span></pre><p id="3cdc" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">所以，我们将<code class="fe lf lg lh li b">day</code>和<code class="fe lf lg lh li b">items</code>合二为一<code class="fe lf lg lh li b">setState</code>。这里绝对没有问题。</p><p id="192e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果，todoList比这个例子要复杂得多。例如，该表单中有许多复选框和输入项。我希望有一个通用的方法来更新对象。</p><p id="9cdf" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里我用<code class="fe lf lg lh li b"><a class="ae ld" href="http://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">RamdaJS</a></code>作为例子:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="ffbe" class="lr ls iq li b gy lt lu l lv lw">setObjectByPath(fieldPath, value) {<br/>  this.setState({<br/>    todoList: R.set(R.lensPath(fieldPath), value, this.state.todoList)<br/>  })<br/>}</span></pre><p id="4a42" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这样，无论对象有多复杂，您都可以轻松地为属性设置一个值，即使它嵌套在对象或数组中。(此处使用<code class="fe lf lg lh li b">lensPath</code>，以便您可以设置类似<code class="fe lf lg lh li b">todoList.someObject.someNestedField</code>的内容。</p><p id="72e4" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">下面是我们在上面的例子中如何使用它:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="6fec" class="lr ls iq li b gy lt lu l lv lw">onDaySelect(day) {<br/>  this.setObjectByPath(['day'], day);<br/>}</span><span id="23fe" class="lr ls iq li b gy lx lu l lv lw">onItemsSelect(items) {<br/>  this.setObjectByPath(['items'], items);<br/>}</span><span id="0716" class="lr ls iq li b gy lx lu l lv lw">onSomeNestedFieldChange(value) {<br/>  this.setObjectByPath(['objectName', 'fieldName'], value);<br/>}</span></pre><p id="1ece" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">优雅！</p><p id="0d0c" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">所以，我们来套用一下<code class="fe lf lg lh li b">onDaySelect</code>中的上例。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="9fdd" class="lr ls iq li b gy lt lu l lv lw">onDaySelect(day) {<br/>  this.setObjectByPath(['day'], day); // 1<br/>  this.setObjectByPath(['items'], []); // 2<br/>}</span></pre><p id="dc83" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">你很快就会注意到，它不知何故不能正常工作。</p><p id="5929" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">起初，我认为React有问题，因为它没有为我更新这两个属性。事实上，第一条线从来不起作用。为什么？</p><p id="d82c" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我就跳过无聊的解释了。在<code class="fe lf lg lh li b">setObjectByPath</code>函数中，总是以<code class="fe lf lg lh li b">this.state.todoList</code>为原点。由于<code class="fe lf lg lh li b">setState</code>是异步的，当两个<code class="fe lf lg lh li b">setObjectByPath</code>被调用时，状态根本没有改变。想象一下<code class="fe lf lg lh li b">todoList</code>对象在更新前是这样的:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="d957" class="lr ls iq li b gy lt lu l lv lw">{day: 'Monday', items: [1,2,3]}</span></pre><p id="a31c" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">下面是我们调用<code class="fe lf lg lh li b">onDaySelect</code>函数时实际发生的情况:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="ba8e" class="lr ls iq li b gy lt lu l lv lw">{day: 'Monday', items: [1,2,3]} -&gt; {day: '<strong class="li ir"><em class="le">Tuesday</em></strong>', items: [1,2,3]}<br/>{day: 'Monday', items: [1,2,3]} -&gt; {day: 'Monday', items: <strong class="li ir"><em class="le">[]</em></strong>}</span></pre><p id="79e1" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">问题不在React上，是在我写的函数上！也许…</p><p id="dde0" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这意味着，如果您需要在<code class="fe lf lg lh li b">setState</code>中一次更改一个以上的属性，您就不能使用那个漂亮的通用<code class="fe lf lg lh li b">setObjectByPath</code>方法。有多逊？！同样的事情发生在<code class="fe lf lg lh li b">Redux</code>身上。</p><p id="9a17" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">与<code class="fe lf lg lh li b">Redux</code>不同，React很聪明，不需要总是将新状态的最终结果放在<code class="fe lf lg lh li b">setState</code>函数中。当你只把<code class="fe lf lg lh li b">a</code>放入<code class="fe lf lg lh li b">setState</code>时，你可以期望属性<code class="fe lf lg lh li b">b</code>仍然存在。而在<code class="fe lf lg lh li b">Redux</code>中，如果你只是在新的状态下返回<code class="fe lf lg lh li b">a</code>，就不要指望能再找到<code class="fe lf lg lh li b">b</code>了。这意味着，您需要处理<code class="fe lf lg lh li b">Redux</code>中的整个状态对象。这也意味着，您需要将所有特定的逻辑放在一个地方，并且不能委托给多个处理程序。</p><p id="63ae" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在<code class="fe lf lg lh li b">setObjectPath</code>中，它以这样的方式结束:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="9d74" class="lr ls iq li b gy lt lu l lv lw">setObjectPath(fieldPath, value) {<br/>  if (fieldPath[0] === 'day') {<br/>    this.setState({<br/>      R.compose(R.set(), R.set()) // sets <strong class="li ir"><em class="le">day</em></strong> and <strong class="li ir"><em class="le">items</em></strong> together<br/>    })<br/>  } else if // more other cases...<br/>}</span></pre><p id="1708" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">尽管如此，这种方法仍然比在每个<code class="fe lf lg lh li b">inputHandler</code>中到处都有非泛型<code class="fe lf lg lh li b">set</code>函数要好。</p><p id="37ce" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">那么，问题的解决方案是什么呢？</p><p id="6708" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi">…</p><p id="eccd" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">抱歉，我没有给你的。</p><p id="220d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我唯一能想到的是，把物体压平，摊到州上去，就像你给吐司涂花生酱一样:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="2991" class="lr ls iq li b gy lt lu l lv lw">this.state = {<br/>  day: '',<br/>  items: [],<br/>  someField: '',<br/>  someNestedField: ''<br/>  // ...<br/>}<br/>// no more todoList object</span></pre><p id="b0de" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我不能说这种做法是不优雅，还是丑陋，但我真的不喜欢。原因之一是，你需要在最后把所有的字段重新打包成一个对象。它不直观，增加了额外的复杂性。</p><p id="092d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">开放讨论~</p></div></div>    
</body>
</html>