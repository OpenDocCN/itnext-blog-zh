<html>
<head>
<title>TypeScript Generics — The !Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript泛型——The！休闲小站</h1>
<blockquote>原文：<a href="https://itnext.io/typescript-generics-the-easy-way-1a8aff7f4151?source=collection_archive---------1-----------------------#2020-07-19">https://itnext.io/typescript-generics-the-easy-way-1a8aff7f4151?source=collection_archive---------1-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="586e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">寻找一个伟大的(仅远程)反应开发？或者只是想聊聊天？访问LinkedIn上的<a class="ae ko" href="https://www.linkedin.com/in/bengrunfeld/" rel="noopener ugc nofollow" target="_blank">我的个人资料</a>并问好！😃</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/f10408d7af7cf4ea807a9b2888c01ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR-QaTWAIKZPTRz264N8DA.jpeg"/></div></div></figure><p id="91a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的TypeScript之旅中，最令人讨厌的部分可能是泛型。语法从一开始就把我搞糊涂了，而且这些概念并不像其他关于TypeScript的东西那样“自然地”有意义。</p><p id="fb8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我做了每一个理性拖延者会做的事情，试图避免他们的地狱…这是一个悲惨失败的策略。泛型无处不在，从像Apollo这样常用的库，到你需要参与并帮助的小项目，所以处理它们的唯一方法是学习它们，练习使用它们，并从本质上克服你对它们的厌恶。强行打开它——没有别的办法了。</p><p id="ec3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:我不会在本文中讨论类，所以如果你想将泛型应用于JS类，请参考<a class="ae ko" href="https://www.typescriptlang.org/docs/handbook/generics.html#generic-classes" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><p id="62e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型就像变量，只不过它们不是表示值，而是表示类型。例如</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="3836" class="lo lp it lk b gy lq lr l ls lt">function getAge&lt;T&gt;(age: T): T {<br/>  return age;<br/>}</span><span id="c2f2" class="lo lp it lk b gy lu lr l ls lt">const myAge = getAge&lt;number&gt;(40);</span><span id="345a" class="lo lp it lk b gy lu lr l ls lt">console.log(myAge);    // logs 40</span></pre><p id="36e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很丑，不是吗？如果代码的可读性是最重要的，那么<em class="lb">这个</em>是一个怎样的改进呢？嗯，你的猜测和我的一样好，所以让我们一起去喝打字稿吧…😕。</p><p id="29cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么上面的代码是怎么回事呢？首先，我们声明一个将<code class="fe lv lw lx lk b">age</code>作为参数的函数，并简单地返回它。你在开头看到的尖括号<code class="fe lv lw lx lk b">&lt;T&gt;</code>意味着这个函数采用了一种类型的<code class="fe lv lw lx lk b">T</code>。因为这是一个<em class="lb">变量</em>，所以您可以继续使用它，就像使用任何其他变量一样。所以我们用它来声明<code class="fe lv lw lx lk b">age</code>的类型是<code class="fe lv lw lx lk b">T</code>，然后函数返回一个类型为<code class="fe lv lw lx lk b">T</code>的值。</p><p id="b964" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，<code class="fe lv lw lx lk b">T</code>可以是任何有效的类型脚本<a class="ae ko" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank">基本类型</a>。此外，我们可以使用任何名称或字母，如<code class="fe lv lw lx lk b">U</code>或<code class="fe lv lw lx lk b">Name</code>。我们甚至可以使用小写字母，比如<code class="fe lv lw lx lk b">n</code>，尽管惯例是使用大写字母或首字母大写的单词，例如<code class="fe lv lw lx lk b">Key</code>。</p><p id="398a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们继续调用函数<code class="fe lv lw lx lk b">getAge</code>，现在<em class="lb"/>我们定义我们希望<code class="fe lv lw lx lk b">T</code>是什么——即<code class="fe lv lw lx lk b">number</code>。最后，我们退出<code class="fe lv lw lx lk b">myAge</code>,然后去拿一杯冰啤酒，在意识到我们已经正式进入“中年”后，对着它静静地哭泣…😭🍺🍺🍺</p><h2 id="911e" class="lo lp it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">类型推理</h2><p id="4dfc" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">TypeScript有一个称为<strong class="js iu">类型推断</strong>的特性，这意味着如果类型足够简单，您不必总是声明正在使用的类型。编译器可以算出来。所以在上面的例子中，我们实际上不需要指定<code class="fe lv lw lx lk b">number</code>，因为TypeScript会从我们给它的输入中计算出来。也就是说，我们可以像这样调用函数，但一切都是正常的，并且是类型安全的:</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="d6b8" class="lo lp it lk b gy lq lr l ls lt">const myAge = getAge(40);</span></pre><h2 id="b6f9" class="lo lp it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">粗箭头语法</h2><p id="2cef" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">如果你像我一样，你自然会尽可能地使用胖箭头语法来声明函数，因为它们真的很酷。不幸的是，您需要使用一种变通方法来让TypeScript使用粗箭头，所以上面的函数声明是这样写的:</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="2347" class="lo lp it lk b gy lq lr l ls lt">const getAge = &lt;T,&gt;(age: T): T =&gt; age;</span></pre><p id="2159" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意到<code class="fe lv lw lx lk b">T</code>后面的逗号<code class="fe lv lw lx lk b">,</code>了吗？又一次，丑陋，但是必要的(奇怪的是，这正是我的前妻曾经向她的朋友们描述我的方式…😕)</p><h2 id="cc77" class="lo lp it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">多类型变量——痛苦错误的教训</h2><p id="d7b8" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">所以以上可能开始有意义了，但是不要担心，TypeScript将很快增加一个新的复杂性层，使您保持不变。</p><p id="aef1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">带着你新找到的自信，你可能会尝试这样的事情，但结果却是直接面对一个冰冷的错误。</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="8a66" class="lo lp it lk b gy lq lr l ls lt">const divide = &lt;T, U&gt;(first: T, second: U): T =&gt; first / second;</span><span id="3a3e" class="lo lp it lk b gy lu lr l ls lt">const result = divide&lt;number, number&gt;(40, 2);</span><span id="88ef" class="lo lp it lk b gy lu lr l ls lt">// ERROR: Type 'number' is not assignable to type 'T'. 'T' could be instantiated with an arbitrary type which could be unrelated to 'number'.</span></pre><p id="4013" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的，所以返回值<code class="fe lv lw lx lk b">T</code>意味着你只能返回未掺杂和未修改的<code class="fe lv lw lx lk b">first</code>。嗯，还不算太糟，是吧？</p><p id="1254" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对自己傻笑，你认为你已经想通了，并指定了一个返回值<code class="fe lv lw lx lk b">number</code>，却发现TypeScript的人不太喜欢你，或者任何人…</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="4adc" class="lo lp it lk b gy lq lr l ls lt">const divide = &lt;T, U&gt;(first: T, second: U): number =&gt; first / second;</span><span id="5b10" class="lo lp it lk b gy lu lr l ls lt">const result = divide&lt;number, number&gt;(40, 2);</span><span id="e7aa" class="lo lp it lk b gy lu lr l ls lt">// ERROR: The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.</span></pre><p id="ed00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">什么？！？！但是我们在调用函数的时候指定了<code class="fe lv lw lx lk b">number</code>。这不就是泛型的全部意义吗？？拥有一个可以稍后设置的变量类型。</p><p id="5067" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解决方案</strong></p><p id="a0ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要在泛型上设置约束，因为否则你的程序会正常工作。嗯，我的意思是，否则TypeScript会有意义…嗯，我的意思是:TypeScript还会检查参数在您的函数中是如何使用的(就像令人毛骨悚然的老大哥)，如果它认为让事情过于一般化可能会导致错误，那么它会生成一个错误并吐出这个哑元。</p><p id="a09a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，你必须约束泛型允许的类型，使之与编译器认为你应该在函数中使用的类型一致——这意味着无论如何它都不再是泛型了。</p><p id="a304" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以基本上在这种情况下使用泛型是没有意义的，因为你最终还是要设置类型，就像普通的函数定义一样。我不知道——也许这对比我更伟大的人来说是有意义的。</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="8d07" class="lo lp it lk b gy lq lr l ls lt">const divide = &lt;T extends number, U extends number&gt;(<br/>    first: T,<br/>    second: U<br/>  ): number =&gt; first / second;</span><span id="db07" class="lo lp it lk b gy lu lr l ls lt">const result = divide&lt;number, number&gt;(40, 2);</span></pre><p id="7ea5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，由于类型推断，您可以省略<code class="fe lv lw lx lk b">number</code>定义，TypeScript会解决这个问题。例如</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="8fc0" class="lo lp it lk b gy lq lr l ls lt">const result = divide(40, 2);</span></pre><p id="59e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅供参考—在许多财务API中，由于浮点和Javascript，您必须处理表示为字符串的数字。如<code class="fe lv lw lx lk b">"0.000001"</code>。</p><p id="479e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TypeScript足够聪明，它能判断出如果你在字符串上使用<code class="fe lv lw lx lk b">parseInt</code>或<code class="fe lv lw lx lk b">parseFloat</code>，然后对它们执行数学运算，这是合法的操作，而不是上面那个讨厌的错误。也就是说，这段代码的工作原理是:</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="9667" class="lo lp it lk b gy lq lr l ls lt">const divide = &lt;T extends string, U extends string&gt;(<br/>    first: T,<br/>    second: U<br/>  ): number =&gt; parseFloat(first) / parseFloat(second);</span><span id="c639" class="lo lp it lk b gy lu lr l ls lt">const result = divide("0.000001", "0.00000005");</span></pre><h1 id="5cda" class="mu lp it bd ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh ni nj mn nk bi translated">通用接口</h1><p id="36c7" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">我们可以在接口中使用泛型来动态设置对象属性的类型。</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="d411" class="lo lp it lk b gy lq lr l ls lt">interface KeyVal&lt;K, V&gt; {<br/>    key: K;<br/>    value: V;<br/>  }</span><span id="7463" class="lo lp it lk b gy lu lr l ls lt">const keyval: KeyVal&lt;string, number&gt; = {<br/>    key: "MyKey",<br/>    value: 748129,<br/>  };</span><span id="b557" class="lo lp it lk b gy lu lr l ls lt">console.log(keyval);</span></pre><p id="0886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面可以看到，<code class="fe lv lw lx lk b">KeyVal</code>把<code class="fe lv lw lx lk b">K</code>和<code class="fe lv lw lx lk b">V</code>作为自变量(变量类型)，然后用它们来为<code class="fe lv lw lx lk b">key</code>和<code class="fe lv lw lx lk b">value</code>设置类型。它们变成的实际类型可以稍后在代码中指定。</p><h2 id="ecd1" class="lo lp it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">函数中的通用接口</h2><p id="da23" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">我们也可以在接口中使用泛型来声明函数的类型。</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="d30a" class="lo lp it lk b gy lq lr l ls lt">interface GenericDivision {<br/>    &lt;T extends number, U extends number&gt;(first: T, second: U): number;<br/>  }</span><span id="5a89" class="lo lp it lk b gy lu lr l ls lt">function division&lt;T extends number, U extends number&gt;(<br/>    first: T,<br/>    second: U<br/>  ): number {<br/>    return first / second;<br/>  }</span><span id="5547" class="lo lp it lk b gy lu lr l ls lt">const divide: GenericDivision = division;</span><span id="edcd" class="lo lp it lk b gy lu lr l ls lt">console.log(divide(20, 2))      // log 10</span></pre><p id="6f1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个返回混合值对象的工作代码示例:</p><pre class="kq kr ks kt gt lj lk ll lm aw ln bi"><span id="c275" class="lo lp it lk b gy lq lr l ls lt">interface KeyVal {<br/>    key: string;<br/>    value: number;<br/>  }</span><span id="b98f" class="lo lp it lk b gy lu lr l ls lt">interface GenericMakeKeyVal {<br/>    &lt;T extends string, U extends number&gt;(key: T, value: U): KeyVal;<br/>  }</span><span id="b5c2" class="lo lp it lk b gy lu lr l ls lt">function makeKeyVal&lt;T extends string, U extends number&gt;(<br/>    key: T,<br/>    value: U<br/>  ): KeyVal {<br/>    return {<br/>      key,<br/>      value,<br/>    };<br/>  }</span><span id="8068" class="lo lp it lk b gy lu lr l ls lt">let getKeyVal: GenericMakeKeyVal = makeKeyVal;</span><span id="f59e" class="lo lp it lk b gy lu lr l ls lt">console.log(getKeyVal("id", 12345));</span></pre><h1 id="e620" class="mu lp it bd ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh ni nj mn nk bi translated">结论</h1><p id="fbb4" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">在了解了它们之后，我必须承认我不喜欢泛型。就像我上面说的，一旦你想在一个泛型中操作任何参数，你就必须声明泛型的类型，就像你在一个普通的函数定义中一样——那么它们有什么意义呢？</p><p id="019a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如<strong class="js iu"> bugcatcher9000 </strong> <a class="ae ko" href="https://stackoverflow.com/questions/62980992/typescript-generics-error-left-hand-side-of-an-arithmetic-operation-must-be-of/62981068#62981068" rel="noopener ugc nofollow" target="_blank">在我的StackOverflow问题中评论</a>的那样，它们最有用的功能可能是声明泛型接口。</p><p id="5cfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，它们真的在任何地方都被使用，所以希望这篇文章能帮助你理解它们。</p><p id="dab3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">祝你好运！</p></div></div>    
</body>
</html>