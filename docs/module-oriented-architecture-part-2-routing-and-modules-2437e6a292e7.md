# 面向模块的体系结构第 2 部分:路由和模块

> 原文：<https://itnext.io/module-oriented-architecture-part-2-routing-and-modules-2437e6a292e7?source=collection_archive---------5----------------------->

刷新你的记忆:

 [## 面向模块的体系结构第 1 部分:耦合与解耦

### 我们的应用程序通常被分成更多的功能单元。我们努力遵循良好的软件工程实践来…

medium.com](https://medium.com/@poksi/module-oriented-architecture-part-1-coupling-and-decoupling-4443dd7f598a) 

# 在你的应用中分离关注点

我想在不同的层次上有很多方法，但是我想开始分离特性流、特性集群或者简称为**模块**的关注点是有意义的。

你可以很容易地想象一个简单的银行应用程序，它会有如下模块:

*   **登录**
*   **交易清单**
*   **支付**
*   …

现在，假设我们有如下接受标准

*   你想要通过深层链接独立地访问这些特性/模块。
*   这些模块/服务中的一些可能在彼此之间具有功能依赖性
*   您可能会为同一目的使用不同的模块(例如，使用基于密码的登录模块或基于 TouchID/FaceID/PIN 的模块)
*   您希望完全 ***封装每个模块中的所有功能，从而使 app 完全模块化，并将模块变成具有自己的通信约定/协议*** 的构建块。

现在，这是一个长长的愿望清单！

# 应用路由器拯救世界

这可能是我们将开始实现所有先前发现和愿望的地方。
什么是应用路由器？是一门课。甚至可能是一胎！！！
很矮很瘦。它存储的是“已注册”的类，这意味着它知道的类符合某些协议，这使得它们至少能够识别自己。应用路由器所做的只是:

*   正在接收有效的 URL 请求
*   查找模块，它将从 URL 响应主机
*   用代表函数/方法和潜在参数的路径调用这个模块
*   返回带有 URLResponse、最终响应字典和最终错误的回调

听起来几乎像 RESTful API 路由器，不是吗？嗯，差不多是了。但它更通用，更像一个 URL 路由器。所有这些现在甚至开始类似于微服务…

例如，我们这里有一些 Swift 语言的简单代码。请记住，还没有在语言语义上花太多心思来使代码尽可能的聪明。它只是用来表示概念，您的实际实现可以根据您的喜好而有所不同。

代码非常简单:我们有一个属性作为注册的 ModuleTypes 和函数的集合来打开模块，两者都在`ApplicationRouterType`中定义。

如果我们查看代码，特别是`func open(url: URL, callback: ModuleCallback?)`，我们可以看到，它主要做的是寻找匹配路由的注册模块，这应该是唯一的(我们显然没有实现这里的检查和潜在断言),并反映模块名称/函数和路径，这反映了模块内的方法/功能。好的，现在让我们做模块。

# 模块怎么样？

***到底是什么模块？***

Module 是一个简单的类，它代表一组类型之间的网关，这些类型执行一组任务，这些任务定义了应用程序级别的通用全局功能(我们可以称之为:服务)和:

*   应用程序的其余部分(像其他模块一样)
*   外部世界(如深层链接)
*   甚至应用中捆绑的其他技术(比如 React Native)。

听起来很吸引人。听起来就像一把瑞士刀……
协议`ModuleType`几乎定义了需要在其上工作的一切:

*   路由字符串，唯一标识模块并从 URL 映射到主机
*   路径的集合，它唯一地标识模块的所有函数，并从 URL 映射到路径
*   open 函数是模块的简单网关，提供路由、路径、参数，并以标准 URL 会话的形式返回响应。

我们可以看到，模块本身是由其路由和路径定义的。

# LoginModule 和 PaymentModule 类

如果我们看一下这两个类应该符合的 ModuleType，那么我们应该期待非常简单的实现，而且确实如此！

我们可以看到变量`route`和`paths`，它们被`ApplicationRouter`使用，如前所述，路径反映了模块的能力。您还可以找到`moduleRouter`，稍后它将被用作根据路径在模块内进行路由的手段，当通过`open`函数访问模块时，路径作为参数被传递。

# …还有一件事？

是的。我们的应用程序只包含模块吗？它可能主要只包含相互调用的模块。但是如果我们回顾一下我们描述它们的角色，模块看起来更像是服务，提供特定的功能。它们可以相互依赖，但更多的是作为一种功能，而不是一个特定的模块。毕竟，我们在*第 1 部分*中解释过，我们想要去耦架构。在上面的实际例子中，我们可以说，如果我们想要执行支付，我们需要让用户登录，但不一定要使用`LoginModule`，它可以是任何其他模块，它将为我们提供必要的令牌/凭证。有时可能还需要编排模块，甚至将它们排队。同样，我们可以发现与微服务的相似之处，但在我们的应用程序中，这将以非常简单的方式实现。

这就是为什么我们引入了一个名为`ApplicationServices`的类，它向我们应用程序的任何部分公开完整的服务。在我们的例子中，我们简单地从应用程序委托中调用`pay`服务，但是你可以得到一个想法，当然，这在许多其他场景中是如何工作的。

下面的代码示例是一个典型的表示，我们如何创建一个服务(在我们的例子中是`pay`，它使用一个`ApplicationRouter`来编排可用的需要的模块来交付它。

你可以看到模块不是直接通过它们的类型名称表示来调用的，而是简单而通用地通过它们的`route`来调用，在`URL`参数中指定为`host`。通过`path`可以访问特定的模块功能，如果需要参数，那么它们将作为简单的`[String: String]`字典在`parameters`参数中传递，就像其他 URL 一样。

就功能而言，上面的例子代表付费服务，我们需要为其提供一个`amount`、一个`username`和一个`password`。最后 2 个首先用于获得一个`paymentToken`，然后我们用令牌和`amount`调用`payments`主机/模块中的`/pay`路径。

我还应该在这里补充一下，我们在这里使用内部模式(`tandem`)，这有助于我们区分内部和外部 URL 位置。对于那些忘记如何设置它的人，它在 Info.plist 中的这些属性下:

![](img/bbeb279bd2fa5793663bad6d51a743db.png)

# 目标实现了吗？

看到这个代码示例，我想说我们的接受标准或多或少得到了满足。但是像往常一样，我们可能会得到一些额外的东西。我最喜欢的事实是，我们已经简化并大大减少了函数签名的数量，并使添加、扩展和替换函数及其参数更加灵活。我们使用的唯一函数实际上是`open`，其他的都是`String`，你只能想象重构的工作量是如何减少的。此外，想象一下单元测试的简化，它现在可以受益于更多的助手代码，并且实际测试代码的复杂性也将大大降低。

但是我最喜欢的 extra 肯定是 ***【无类型依赖】*** 。想象一下这种情况，你想把不同的模块存放在不同的仓库中。一个模块可能会有许多依赖的模块，而不是将相同的模块一次又一次地存放在不同的存储库/项目中，你只需要简单地:嗯，什么都不做！！:)当然，**项目会编译，因为模块是松散耦合的，没有引用具体的类型或者协议。想象一下测试是多么容易！不需要编写成千上万的 mock、子类化实际类型或实现实际协议，您只需创建一个通用模块 mock 并在模块回调中返回存根字典！**

胡萝卜加大棒。这种方法的缺点是我们在编译时失去了对模块名及其方法的类型检查。然而，我们已经在`ApplicationRouter`中实现了简单的`host`和`path`检查，所以我们在运行时`assert`。在我看来，这不是一个太大的权衡。

让我们在下一章看看这些模块是如何实现的。

[](https://medium.com/@poksi/module-oriented-architecture-part-3-modules-and-routing-241b06439a9f) [## 面向模块的体系结构第 3 部分:模块和路由

### 刷新你的记忆:

medium.com](https://medium.com/@poksi/module-oriented-architecture-part-3-modules-and-routing-241b06439a9f)