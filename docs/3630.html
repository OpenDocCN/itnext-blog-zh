<html>
<head>
<title>Thoughts on Map and Set in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于排版中地图和集合的思考</h1>
<blockquote>原文：<a href="https://itnext.io/thoughts-on-map-and-set-in-typescript-efd43c3bf2ad?source=collection_archive---------1-----------------------#2020-01-21">https://itnext.io/thoughts-on-map-and-set-in-typescript-efd43c3bf2ad?source=collection_archive---------1-----------------------#2020-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/492fc2edcd77879015bc2c77833c1e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-04cqI3Wmmc6281Ea2GgmA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com/photos/BYGLQ32Wjx8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@mimithian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>拍摄的照片</figcaption></figure><p id="c43a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用ES6 <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">映射</a>和<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">设置</a>引入到JavaScript中。它们最终为您的web应用程序带来了更复杂的数据结构。正因为如此，他们是一个非常受欢迎的语言补充。长久以来，阵列被迫解决存在的每一个问题(然而，我看不出这种情况会很快发生)。但是，在我看来，他们在执行方面确实没有达到目标。</p><h1 id="fc6e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">地图和布景快速介绍</h1><p id="3fea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们从头开始:什么是地图和集合？映射是一种保存键值对的数据结构。在这方面它有点像一个物体，但有一些主要的区别:</p><ul class=""><li id="7c2b" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">密钥不仅限于字符串、数字和符号</li><li id="8c6c" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">map是一个集合，意味着它有一个大小、一个顺序，并且可以被迭代。</li><li id="ebc1" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">映射被设计用来处理可选键，而不是必需键。这在使用TypeScript和确保类型安全时更为重要</li></ul><p id="a920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合是保证所有值都是唯一的集合。最好将它描述为一个键和值总是相同的映射。集合在检查值是否存在以及计算两个集合之间的差异或重叠方面非常有用。</p><h1 id="c40b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">哪里出了问题</h1><p id="109a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">基于以上几点，人们会觉得地图和布景都是语言的惊人补充。如果不是因为他们的界面如此斯巴达化，他们会的。让我们从地图开始。对于这个论点，我将介绍一个地图的用例示例:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">包含计数器动态集合的映射</figcaption></figure><p id="331c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比方说，我想增加某个键的计数器，当这个键没有被预置时，它应该变成1。在ES6地图上，这条线周围的某个地方:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">😢 😢 😢</figcaption></figure><p id="85a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您意识到map的全部目的是处理键值对时，这需要大量的代码！例如，在<a class="ae kc" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank"> immutable.js </a>中，这将通过一个更新调用来编写:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这就是使用map时键-值对应该有多简单</figcaption></figure><blockquote class="my mz na"><p id="b74f" class="kd ke nb kf b kg kh ki kj kk kl km kn nc kp kq kr nd kt ku kv ne kx ky kz la ij bi translated">注意:我确实喜欢immutable.js，但并不是说你应该在“普通的”地图和集合上使用它。不可变和可变数据结构是不同的概念，不仅仅是可互换的。</p></blockquote><p id="3fd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个大吝啬鬼的例子是在地图和集合上缺少变换方法。没有<code class="fe nf ng nh ni b">map</code>来转换集合中的每个值，也没有<code class="fe nf ng nh ni b">filter</code>从映射或集合中排除值。假设我们想要删除所有为零的计数器。对于ES6映射，我们需要一个带有新映射的for循环:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在函数式编程和lambda时代，for循环中的if语句</figcaption></figure><p id="f86c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而使用简单的过滤方法，这可以用一行和一个箭头函数来完成。对我来说，这是一个谜，为什么数组得到了所有这些方法，他们没有把它们放在集合和地图上。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如果它只是一个数组…</figcaption></figure><p id="8cad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想举的关于地图的最后一个例子是缺少一个<code class="fe nf ng nh ni b">merge</code>功能。映射的一个常见任务是将两个映射合并在一起，并以某种方式解决冲突的键(通常用后一个或给定的自定义合并覆盖)。对于ES6映射，这将再次需要for循环和一些if语句。人们可能希望用<code class="fe nf ng nh ni b">map.merge(otherMap)</code>简单地做到这一点。</p><p id="28c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述所有要点也适用于Set，因为它是一个非常类似于map的数据结构。他们这里的主要额外吝啬鬼是缺少一个<code class="fe nf ng nh ni b">merge</code>、<code class="fe nf ng nh ni b">except</code>和<code class="fe nf ng nh ni b">both</code>。在编写关注多组值之间的差异重叠的代码时，Set通常非常出色，但在JavaScript中却不是这样。</p><p id="eaf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后:记住映射和集合都是有序集合？除了将其转换为数组、对数组进行排序并重新创建地图或地图集之外，没有其他方法可以对它们进行排序。为什么要显式地实现一个有序地图，却不允许用户订购他们的地图呢？</p><h1 id="5f95" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何正确地做它</h1><p id="8680" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在所有的抱怨之后，是时候谈谈如何正确地做这件事了。首先:在设计标准库时，保持接口的一致性。如果我能以某种方式映射、过滤和减少一种类型的集合，我希望所有其他类型的行为都相似。集合、映射和数组都应该有可比较的接口。理想情况下，它们应该是一个<a class="ae kc" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1?view=netcore-3.1" rel="noopener ugc nofollow" target="_blank"> ICollection </a>接口，强制所有集合保持一致(对于内置和定制实现)。</p><p id="d0d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一点就是思考那些集合为什么存在。如果collection soul的目的是，比方说，处理键-值对，我希望有一切可以用它们的键来创建、删除和修改值。当一个集合主要用来处理唯一值的集合时，我希望所有的东西都能真正使用这个功能，而不必实现像<code class="fe nf ng nh ni b">merge</code>和<code class="fe nf ng nh ni b">except</code>这样的标准库函数。尤其是在像JavaScript这样被设计成易于使用的高级脚本语言中。</p><p id="6341" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文的最后，我提供了一个代码片段，实现了大部分提到的特性。其实大部分真的很容易。这只是一个痛苦，你必须考虑这些基本功能，而你的大脑应该专注于你试图解决的问题。</p><h1 id="9b60" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="13e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你对JavaScript中的Map和Set有什么看法？你经常使用它们吗？或者你和我一样，仍然在使用第三方库作为数据结构？在我看来，新的ES6数据结构还不够好，不够实用。我将用我提到的大多数特性的示例实现来签署这一篇。只是为了证明第一次做对并不是什么大事。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>