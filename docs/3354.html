<html>
<head>
<title>JavaScript Fundamentals: Array &amp; Object Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:数组和对象方法</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-fundamentals-array-object-methods-1f3f4adc025c?source=collection_archive---------12-----------------------#2019-11-26">https://itnext.io/javascript-fundamentals-array-object-methods-1f3f4adc025c?source=collection_archive---------12-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/43c74842f3af4cd02d2a2284381b7a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQ_Wb6hkY1X_PBwA1edwhg.png"/></div></div></figure><p id="a00a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将看看一些非常有用的数组和对象方法。当我们着手操作数组和对象时，这些方法的雄辩将帮助我们编写非常干净和可读的代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="5c4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="lg">想跟上网络发展的步伐吗？</em> <br/>🚀想要将最新消息直接发送到您的收件箱吗？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lh" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="65a4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe mg mh mi mj b">Object.assign()</code></h1><p id="5b9f" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">这种方法赋予我们将对象组合在一起的能力。</p><p id="0f6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">例如:</em> </strong></p><p id="82e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将两个独立的对象合并为一个:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="1245" class="mx lj it mj b gy my mz l na nb">const objectOne = {<br/>  firstName: 'Santa'<br/>}</span><span id="74ab" class="mx lj it mj b gy nc mz l na nb">const objectTwo = {<br/>  lastName: 'Claus'<br/>}</span><span id="3a11" class="mx lj it mj b gy nc mz l na nb">const objectCombined = Object.assign(objectOne, objectTwo);</span><span id="8216" class="mx lj it mj b gy nc mz l na nb">// objectCombined is: { firstName: 'Santa', lastName: 'Claus' }</span></pre><p id="1a39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">注意:</em>你也可以使用对象扩展语法——我们将在本文后面看到！</p><h1 id="4070" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">Object.create()</h1><p id="3f55" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">此方法将创建一个新对象，使用现有对象作为新创建对象的原型。</p><p id="ca1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="dcfe" class="mx lj it mj b gy my mz l na nb">let newObject = Object.create(obj);</span><span id="6405" class="mx lj it mj b gy nc mz l na nb">console.log(newObject);  <br/>//{}</span><span id="84ca" class="mx lj it mj b gy nc mz l na nb">newObject.name = “William”;</span><span id="1bf5" class="mx lj it mj b gy nc mz l na nb">console.log(newObject.speak());</span><span id="e5f8" class="mx lj it mj b gy nc mz l na nb">// My Name is William and this is year 2019</span></pre><p id="6223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中<strong class="kd iu"> <em class="lg"> obj </em> </strong>是创建<strong class="kd iu"> <em class="lg">新对象</em> </strong>的原型。所以通过继承，它可以使用我们原型的属性。这就是为什么我们可以使用<strong class="kd iu"> <em class="lg"> speak() </em> </strong>方法，而不用在<strong class="kd iu"> <em class="lg"> newObject </em> </strong>中声明它。</p><h1 id="094a" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">Object.entries()</h1><p id="8443" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">在这里，我们可以创建一个包含对象的键/值对的数组。本质上，它将对象转换为数组的数组。</p><p id="70ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">例如:</em> </strong></p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="bd20" class="mx lj it mj b gy my mz l na nb">let person = {<br/>  name:”William”,<br/>  age:30<br/>}</span><span id="e396" class="mx lj it mj b gy nc mz l na nb">let entries = Object.entries(person);</span><span id="66bc" class="mx lj it mj b gy nc mz l na nb">console.log(entries);</span><span id="1c02" class="mx lj it mj b gy nc mz l na nb">//[ [ 'name', 'William' ], [ 'age', 30 ] ]</span></pre><h1 id="f7f5" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">Object.keys()</h1><p id="0357" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">该方法返回给定对象的<strong class="kd iu"> <em class="lg">键</em> </strong>(或属性标签)的数组。</p><p id="9b35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="912a" class="mx lj it mj b gy my mz l na nb">const seasonalColors = {<br/>  winter: 'blue',<br/>  spring: 'green',<br/>  summer: 'yellow',<br/>  fall: 'brown'<br/>}</span><span id="b1bc" class="mx lj it mj b gy nc mz l na nb">const types = Object.keys(seasonalColors);</span><span id="ea49" class="mx lj it mj b gy nc mz l na nb">// 'types' is equal to ["winter", "spring", "summer", "fall"]</span></pre><h1 id="8d1f" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">Object.values()</h1><p id="42ae" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">该方法返回给定对象的<strong class="kd iu"> <em class="lg">值</em> </strong>的数组。</p><p id="0c3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="c79f" class="mx lj it mj b gy my mz l na nb">const seasonalColors = {<br/>  winter: 'blue',<br/>  spring: 'green',<br/>  summer: 'yellow',<br/>  fall: 'brown'<br/>}</span><span id="446b" class="mx lj it mj b gy nc mz l na nb">const colors = Object.values(seasonalColors);</span><span id="074d" class="mx lj it mj b gy nc mz l na nb">// 'colors' are equal to ["blue", "green", "yellow", "brown"]</span></pre><h1 id="5aca" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">Object.freeze()</h1><p id="596c" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">您可以使用此方法来防止修改现有的对象属性，或者向对象添加新的属性和值。本质上，函数<strong class="kd iu">冻结</strong>对象的任何进一步改变(键或值)。</p><p id="3bdd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="6cd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">冻结对象以防止<code class="fe mg mh mi mj b">name</code>属性被更改。</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="02c5" class="mx lj it mj b gy my mz l na nb">const frozenObject = {<br/>  name: 'Batman'<br/>}</span><span id="ea41" class="mx lj it mj b gy nc mz l na nb">Object.freeze(frozenObject);</span><span id="6b6f" class="mx lj it mj b gy nc mz l na nb">frozenObject.name = 'Superman';</span><span id="6640" class="mx lj it mj b gy nc mz l na nb">// frozenObject will remain equal to { name: 'Batman' }</span></pre><h1 id="3d4c" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">Object.seal()</code></h1><p id="8552" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">这个方法阻止任何新的属性被添加到一个对象中，但是它仍然允许现有的属性被改变。</p><p id="be65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="9348" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">密封一个对象以防止添加<code class="fe mg mh mi mj b">isBetter</code>属性。</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="670e" class="mx lj it mj b gy my mz l na nb">const sealedObject = {<br/>  name: 'Batman'<br/>}</span><span id="d1a6" class="mx lj it mj b gy nc mz l na nb">Object.seal(sealedObject);</span><span id="ae88" class="mx lj it mj b gy nc mz l na nb">sealedObject.name = 'Superman';<br/>sealedObject.isBetter = true;</span><span id="3b24" class="mx lj it mj b gy nc mz l na nb">// sealedObject will be equal to { name: 'Superman' }</span></pre><h1 id="6b24" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.map()</code></h1><p id="a49f" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">使用这种方法，我们可以通过操作另一个数组中的值来创建一个新的数组。然后返回新数组。</p><p id="29c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="93f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个将每个数字乘以<em class="lg"> 10 </em>的数组:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="5e18" class="mx lj it mj b gy my mz l na nb">let arr = [1,2,3,4];</span><span id="579b" class="mx lj it mj b gy nc mz l na nb">let multiply10 = arr.map((val, i, arr) =&gt; {<br/>  return val *10;<br/>});</span><span id="43a4" class="mx lj it mj b gy nc mz l na nb">multiply10 = [10,20,30,40]</span></pre><p id="2200" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">注:</em>同<strong class="kd iu">。map() </strong>我们只是定义我们想要发生的事情&amp;返回它——不需要循环！</p><h1 id="7935" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.filter()</code></h1><p id="22a3" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">使用这种方法，我们根据数组中的元素是否满足特定条件来创建一个新数组。</p><p id="664c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="970d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一组幸运数字(数字&gt; 3):</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="9f3a" class="mx lj it mj b gy my mz l na nb">const allNumbers = [1, 2, 3, 4, 5, 6];</span><span id="1849" class="mx lj it mj b gy nc mz l na nb">const luckyNumbers = allNumbers.filter( num =&gt; num &gt; 3);</span><span id="8b45" class="mx lj it mj b gy nc mz l na nb">// luckyNumbers will be equal to [4, 5, 6]</span></pre><h1 id="96b3" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.reduce()</code></h1><p id="137f" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">这个方法将把数组中的所有项减少到一个值。它对计算总数非常有用。返回值可以是任何类型(对象、数组、字符串、数字)。</p><p id="9db8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="b78f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将一个数组中的所有数字相加:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="82dd" class="mx lj it mj b gy my mz l na nb">const numbers = [10, 20, 20];</span><span id="be86" class="mx lj it mj b gy nc mz l na nb">const total = numbers.reduce( (accumulator, currentValue) =&gt; accumulator + currentValue);</span><span id="a935" class="mx lj it mj b gy nc mz l na nb">// total will be equal to 50</span></pre><h1 id="4a58" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.forEach()</code></h1><p id="0b64" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">使用这种方法，我们可以对给定数组中的每一项应用一个函数。</p><p id="8f21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="e01d" class="mx lj it mj b gy my mz l na nb">const poets = ['Ginsberg', 'Plath', 'Yeats'];</span><span id="36b5" class="mx lj it mj b gy nc mz l na nb">poets.forEach( poet =&gt; console.log(poet) );</span><span id="82b3" class="mx lj it mj b gy nc mz l na nb">// 'Ginsberg'<br/>// 'Plath'<br/>// 'Yeats'</span></pre><h1 id="8267" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.some()</code></h1><p id="1222" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">该方法检查数组中的任何<strong class="kd iu">项是否通过给定的条件。一个很好的用例是检查用户权限。</strong></p><p id="9ff9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">例如:</em> </strong></p><p id="ea9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查数组中是否至少有一个<code class="fe mg mh mi mj b">'teacher'</code>:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="fd37" class="mx lj it mj b gy my mz l na nb">const classReady = ['student', 'student', 'teacher', 'student'];</span><span id="c69b" class="mx lj it mj b gy nc mz l na nb">const containsTeacher = classReady.some( element =&gt; element === 'teacher');</span><span id="01b1" class="mx lj it mj b gy nc mz l na nb">// containsTeacher will equal true</span></pre><h1 id="28ce" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.every()</code></h1><p id="6c0c" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">这个方法与<code class="fe mg mh mi mj b">.some()</code>非常相似，但是它将检查<strong class="kd iu">数组中的所有</strong>项目是否都通过了一个条件。</p><p id="cea3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">例如:</em> </strong></p><p id="dbd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查<strong class="kd iu">的所有</strong>评级是否等于或大于3星。</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="d5a2" class="mx lj it mj b gy my mz l na nb">const ratings = [4, 5, 4, 3, 4];</span><span id="6b6d" class="mx lj it mj b gy nc mz l na nb">const goodOverallRating = ratings.every( rating =&gt; rating &gt;= 3 );</span><span id="479e" class="mx lj it mj b gy nc mz l na nb">// goodOverallRating will equal true</span></pre><h1 id="725d" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">.includes()</code></h1><p id="d39b" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">使用这种方法，我们可以检查一个数组是否包含某个值。这就像<code class="fe mg mh mi mj b">.some()</code>，然而它不是寻找一个通过的条件，而是检查给定数组中的一个特定值。</p><p id="7e62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">例如:</em> </strong></p><p id="3fb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查数组是否包含带有字符串<code class="fe mg mh mi mj b">‘no’</code>的项目。</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="bc1a" class="mx lj it mj b gy my mz l na nb">const responss = ['yes', 'maybe', 'no', 'yes'];</span><span id="4482" class="mx lj it mj b gy nc mz l na nb">const includesNo = responses.includes('no');</span><span id="608d" class="mx lj it mj b gy nc mz l na nb">// includesNo will equal true</span></pre><h1 id="c7a1" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><code class="fe mg mh mi mj b">Array.from()</code></h1><p id="9234" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">此方法基于另一个数组或字符串创建一个数组。然而，更常见的是使用<code class="fe mg mh mi mj b">.map()</code>方法。</p><p id="5a96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="3a2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从字符串创建数组:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="6f81" class="mx lj it mj b gy my mz l na nb">const newArray = Array.from('abcde');</span><span id="3a12" class="mx lj it mj b gy nc mz l na nb">// newArray will equal ['a', 'b', 'c', 'd', 'e']</span></pre><p id="44fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个数组，使另一个数组中的每一项的值加倍。</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="7652" class="mx lj it mj b gy my mz l na nb">const doubledValues = Array.from([2, 4, 6], number =&gt; number * 2);</span><span id="7429" class="mx lj it mj b gy nc mz l na nb">// doubleValues will equal [4, 8, 12]</span></pre><h1 id="45e8" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">阵列传播</h1><p id="ee08" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">我们可以使用扩展操作符(…)来扩展数组。这允许我们扩展数组中的元素。当把许多数组连接在一起时，这非常有用。</p><p id="a073" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">举例:</em> </strong></p><p id="7009" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组合两个给定的数组。</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="4342" class="mx lj it mj b gy my mz l na nb">const arrayOne = [1, 2, 3];<br/>const arrayTwo = [4, 5, 6];</span><span id="79cb" class="mx lj it mj b gy nc mz l na nb">const combinedArrays = [...arrayOne, ...arrayTwo];</span><span id="5788" class="mx lj it mj b gy nc mz l na nb">// combinedArrays is equal to [1, 2, 3, 4, 5, 6]</span></pre><p id="bd73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以使用spread with <code class="fe mg mh mi mj b">.slice()</code>来删除一个数组元素<em class="lg">而不改变原始数组</em>:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="85c0" class="mx lj it mj b gy my mz l na nb">const companies = ['mercedes', 'boeing', 'starbucks', 'honda'];</span><span id="220b" class="mx lj it mj b gy nc mz l na nb">const transport = [...companies.slice(0,2), ...companies.slice(3)];</span><span id="565a" class="mx lj it mj b gy nc mz l na nb">// transport will equal ['mercedes', 'boeing', 'honda']</span></pre><h1 id="4cfb" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">对象扩展</h1><p id="3b44" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">我们可以扩展一个对象，以允许添加新的属性和值而不发生变化(创建一个新对象)。它还可以用于将多个对象组合在一起。</p><p id="487b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">例如:</em> </strong></p><p id="47e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加新的对象属性和值，而不改变原始对象:</p><pre class="mp mq mr ms gt mt mj mu mv aw mw bi"><span id="e0da" class="mx lj it mj b gy my mz l na nb">const originalObject = {<br/>  name: 'Jonathan',<br/>  city: 'Toronto'<br/>};</span><span id="e00c" class="mx lj it mj b gy nc mz l na nb">const newObject = {<br/>  ...originalObject,<br/>  occupation: 'Chef'<br/>}</span><span id="fce0" class="mx lj it mj b gy nc mz l na nb">// newObject is equal to<br/>// { occupation: 'Chef', name: 'Jonathan', city: 'Toronto' }</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a669" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lg">你准备好让你的JavaScript技能更上一层楼了吗？今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lg">JavaScript精通完全指南</em> </a> <em class="lg">带你从零到英雄！</em></strong></p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated"><em class="nn">现已上市！👉</em><a class="ae lh" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="db30" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">结论</h1><p id="ee57" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">我们走吧！我们已经看到了许多数组和对象的方法，包括:<code class="fe mg mh mi mj b">.assign()</code>、<code class="fe mg mh mi mj b">.create()</code>、<code class="fe mg mh mi mj b">.entries()</code>、<code class="fe mg mh mi mj b">.keys()</code>、<code class="fe mg mh mi mj b">.values()</code>。<code class="fe mg mh mi mj b">freeze()</code>、<code class="fe mg mh mi mj b"> .seal()</code>、。<code class="fe mg mh mi mj b">map()</code>、<code class="fe mg mh mi mj b">.filter()</code>、<code class="fe mg mh mi mj b">.reduce()</code>、<code class="fe mg mh mi mj b">.forEach()</code>、<code class="fe mg mh mi mj b">.some()</code>、<code class="fe mg mh mi mj b">.every()</code>、<code class="fe mg mh mi mj b">.includes()</code>、<code class="fe mg mh mi mj b">.from(),</code>、&amp;数组/对象展开语法。😅</p><p id="98d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">掌握这些方法将极大地提高代码的可读性。以及在操作数组和对象时，为您提供一些很好的入门技巧！</p><p id="4a53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！可以<a class="ae lh" href="https://medium.com/@timothyrobards?source=post_page---------------------------" rel="noopener">跟着我</a>上媒。我也在<a class="ae lh" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="881f" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在<a class="ae lh" href="http://www.easeout.co" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在构建我的<a class="ae lh" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业者完整指南</a>。坏消息是它还不可用！但是如果你对它感兴趣，你可以<a class="ae lh" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用时会通知你</a>👍</p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>