<html>
<head>
<title>Nock it out of the park, HTTP mocking for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nock出公园，HTTP嘲讽React</h1>
<blockquote>原文：<a href="https://itnext.io/nock-it-out-of-the-park-http-mocking-for-react-42ec927f83e0?source=collection_archive---------1-----------------------#2019-02-24">https://itnext.io/nock-it-out-of-the-park-http-mocking-for-react-42ec927f83e0?source=collection_archive---------1-----------------------#2019-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9526" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><blockquote class="kp kq kr"><p id="8edf" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">Nock习惯于嘲笑对HTTP的调用。它使我们有可能指定要听什么URL和用什么来响应。这是一篇相当短的文章，展示了如何使用库<code class="fe kw kx ky kz b">nock</code>。</p></blockquote><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/4db88c09835d8b205d75fc74a3e3f9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRBwa3wJnUcLnMDX6UVvWQ.jpeg"/></div></div></figure><p id="3d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将涵盖:</p><ul class=""><li id="7692" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated"><strong class="js iu">设置</strong>，设置一个<code class="fe kw kx ky kz b">nock</code>并指定一个模拟响应</li><li id="c79f" class="lm ln it js b jt lv jx lw kb lx kf ly kj lz kn lr ls lt lu bi translated"><strong class="js iu">查询参数</strong>，看看我们如何用查询参数设置我们的<code class="fe kw kx ky kz b">nock</code></li><li id="2bb6" class="lm ln it js b jt lv jx lw kb lx kf ly kj lz kn lr ls lt lu bi translated"><strong class="js iu">验证</strong>，我们应该始终验证我们的<code class="fe kw kx ky kz b">nocks</code>在哪里命中。如果不是，那么事情就变了，我们需要改变我们的测试来反映这一点</li></ul><h1 id="bd59" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">为什么要嘲讽HTTP？</h1><p id="c80d" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">当我们测试任何东西时，我们应该孤立地进行，我们应该只关注于测试我们当前所在的模块。这意味着我们应该依靠某种对外部依赖性的嘲弄。不仅仅是外部依赖，还包括任何外部的东西，比如副作用，一些你无法控制的东西，比如HTTP调用。让一个HTTP调用真正通过可能会有很多问题，比如连接性和速率限制，最终它测试的东西很可能超出了您的测试范围。对于本文来说，这个问题的解决方案是库<a class="ae ko" href="https://github.com/nock/nock" rel="noopener ugc nofollow" target="_blank"> Nock </a>。</p><h1 id="25c8" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">方案</h1><p id="d18a" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">在下面的场景中，我们将看看如何测试一个需要显示产品列表的组件。列表数据来自HTTP调用。</p><p id="1f9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了能够运行这个场景，您应该首先创建一个React.js项目。最简单的方法就是运行CRA创建的React应用程序。所以让我们先这样做:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="c89b" class="nh mb it kz b gy ni nj l nk nl">npx create-react-app my-app</span></pre><p id="6cab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们有了一个项目，让我们来谈谈运行我们的测试场景和测试<code class="fe kw kx ky kz b">Nock</code>所需的文件。</p><p id="9ee8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有以下文件:</p><ul class=""><li id="dd79" class="lm ln it js b jt ju jx jy kb lo kf lp kj lq kn lr ls lt lu bi translated"><strong class="js iu"> products.js </strong>，可以为我们检索数据的服务</li><li id="2d3b" class="lm ln it js b jt lv jx lw kb lx kf ly kj lz kn lr ls lt lu bi translated"><strong class="js iu"> ProductsList.js </strong>，一个调用products.js上的方法来获取数据并呈现数据的组件</li></ul><p id="785c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看这两个模块是什么样子的:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="40b4" class="nh mb it kz b gy ni nj l nk nl">// products.js</span><span id="5924" class="nh mb it kz b gy nm nj l nk nl">export const getProducts = async () =&gt; { <br/>  const response = await fetch('http://myapi.com/products'); <br/>  const json = await response.json(); <br/>  console.log(json);</span><span id="f8aa" class="nh mb it kz b gy nm nj l nk nl">  return json.products; <br/>}</span></pre><p id="4381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面我们可以看到，我们对URL <code class="fe kw kx ky kz b">http://myapi.com/products</code>进行了一个<code class="fe kw kx ky kz b">fetch()</code>调用，然后我们转换响应并挖掘出数据<code class="fe kw kx ky kz b">products</code>。让我们来看看组件:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="979e" class="nh mb it kz b gy ni nj l nk nl">// ProductsList.js</span><span id="1780" class="nh mb it kz b gy nm nj l nk nl">import React from 'react'; <br/>import { getProducts } from '../products'; </span><span id="b799" class="nh mb it kz b gy nm nj l nk nl">const Products = ({ products }) =&gt; ( <br/>  &lt;React.Fragment&gt; <br/>  {products.map(p =&gt; &lt;div&gt;{product.name}&lt;/div&gt;)} <br/> &lt;/React.Fragment&gt; <br/>); </span><span id="a8ec" class="nh mb it kz b gy nm nj l nk nl">class ProductsContainer extends React.Component { <br/>  state = { products: [], } </span><span id="9f78" class="nh mb it kz b gy nm nj l nk nl">  async componentDidMount() { <br/>    const products = await getProducts(); <br/>    this.setState({ products }); <br/>  } </span><span id="ea30" class="nh mb it kz b gy nm nj l nk nl">  render() { <br/>   if (!this.state.products) return null;<br/>   else return ( &lt;Products products={this.state.products} /&gt; ); <br/>  } <br/>}<br/> <br/>export default ProductsContainer;</span></pre><p id="6fe5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，我们使用了<code class="fe kw kx ky kz b">product.js</code>模块，并在<code class="fe kw kx ky kz b">componentDidMount()</code>中调用了<code class="fe kw kx ky kz b">getProducts()</code>，当数据到达时，我们最终呈现了数据。</p><h1 id="09c5" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">测试它</h1><p id="d7dd" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">如果我们想测试<code class="fe kw kx ky kz b">ProductsList.js</code>模块，我们会想把重点放在模仿<code class="fe kw kx ky kz b">products.js</code>上，因为它是一个依赖。我们可以利用图书馆<code class="fe kw kx ky kz b">nock</code>来做这件事。让我们从安装<code class="fe kw kx ky kz b">nock</code>开始，就像这样:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="68ff" class="nh mb it kz b gy ni nj l nk nl">yarn add nock</span></pre><p id="e493" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们创建一个测试<code class="fe kw kx ky kz b">__tests__/ProductsList.spec.js</code>，并将其定义如下:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="f051" class="nh mb it kz b gy ni nj l nk nl">// __tests__/ProductsList.spec.js</span><span id="c1c5" class="nh mb it kz b gy nm nj l nk nl">import React from 'react'; <br/>import ReactDOM from 'react-dom'; <br/>import ProductsList from '../ProductsList'; <br/>import nock from 'nock'; </span><span id="0b53" class="nh mb it kz b gy nm nj l nk nl">it('renders without crashing', () =&gt; { <br/>  const div = document.createElement('div');<br/>  ReactDOM.render(&lt;ProductsList /&gt;, div);<br/>  ReactDOM.unmountComponentAtNode(div); <br/>});</span></pre><p id="f907" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先看看如果我们不设置<code class="fe kw kx ky kz b">nock</code>会发生什么:</p><p id="9780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最终得到以下结果:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nn"><img src="../Images/c3edfade436b3b4aa3fc38eee287e0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ORWG2tkD2EZhmDTb.png"/></div></div></figure><p id="7380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面可以看出，它试图执行一个网络请求。在运行测试时，我们不应该这样做。我们可以为此添加一个<code class="fe kw kx ky kz b">Jest</code>模拟，这肯定是解决它的一种方法，然后它会看起来像这样:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="4253" class="nh mb it kz b gy ni nj l nk nl">// __mocks__/products.js</span><span id="cd29" class="nh mb it kz b gy nm nj l nk nl">export const getProducts = async () =&gt; { <br/>  const products = await Promise.resolve([{ name: 'test' }]); <br/>  return products; <br/>}</span></pre><p id="3d65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是可行的，但是让我们看看如何用<code class="fe kw kx ky kz b">nock</code>来解决它。因为我们试图在节点环境中调用<code class="fe kw kx ky kz b">fetch()</code>，所以我们需要确保它设置正确。建议设置<code class="fe kw kx ky kz b">global.fetch</code>并将<code class="fe kw kx ky kz b">node-fetch</code>分配给它，如下所示:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="573a" class="nh mb it kz b gy ni nj l nk nl">global.fetch = require('node-fetch');</span></pre><p id="fe20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们将<code class="fe kw kx ky kz b">nock</code>添加到我们的测试中，就像这样:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="5231" class="nh mb it kz b gy ni nj l nk nl">import React from 'react'; <br/>import ReactDOM from 'react-dom'; <br/>import ProductsList from '../ProductsList'; <br/>import nock from 'nock'; </span><span id="a1dd" class="nh mb it kz b gy nm nj l nk nl">it('renders without crashing', () =&gt; { <br/>   const scope = nock('http://myapi.com') <br/>   .get('/products')<br/>   .reply(200, { products: [{ id: 1, name: 'nocked data' }] }, <br/>   { <br/>     'Access-Control-Allow-Origin': '*', <br/>     'Content-type': 'application/json' <br/>   }); </span><span id="c807" class="nh mb it kz b gy nm nj l nk nl">   const div = document.createElement('div');<br/>   ReactDOM.render(&lt;ProductsList /&gt;, div);<br/>   ReactDOM.unmountComponentAtNode(div); <br/>});</span></pre><p id="d093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意上面我们如何调用<code class="fe kw kx ky kz b">nock()</code>方法，首先给它<code class="fe kw kx ky kz b">baseUrl</code> <code class="fe kw kx ky kz b">http://myapi.com</code>，然后是路径<code class="fe kw kx ky kz b">/products</code>和HTTP动词<code class="fe kw kx ky kz b">get</code>，以及我们如何用<code class="fe kw kx ky kz b">reply()</code>定义响应的样子。我们还给了<code class="fe kw kx ky kz b">reply()</code>方法第二个参数，以确保<code class="fe kw kx ky kz b">CORS</code>运行良好。至此，我们的测试成功了。：</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi no"><img src="../Images/d10cdaa752dccab0a6b5b7ba1dab2ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FxRP0DmCEasAiI3j.png"/></div></div></figure><p id="eb23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切正常，我们成功地用nock模拟了我们的HTTP调用。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi np"><img src="../Images/35b2b258757762d20ac3ea89910c4891.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*EqjdEh-wRu75rdKkc5QQKg.gif"/></div></figure><h1 id="ab24" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">使用处理查询参数。查询()</h1><p id="61c7" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">如果我们有一个如下所示的URL会怎么样:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="ca80" class="nh mb it kz b gy ni nj l nk nl"><a class="ae ko" href="http://myapi.com/products?page=1&amp;pageSize=10;" rel="noopener ugc nofollow" target="_blank">http://myapi.com/products?page=1&amp;pageSize=10;</a></span></pre><p id="77d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何设置我们的<code class="fe kw kx ky kz b">nock</code>来匹配它呢？嗯，我们可以使用辅助方法<code class="fe kw kx ky kz b">query</code>来实现，就像这样:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="f8fe" class="nh mb it kz b gy ni nj l nk nl">nock('http://myapi.com') <br/>.get('/products') <br/>.query({ page: 1, pageSize: 10 })</span></pre><h1 id="c9c3" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">验证您的模拟</h1><p id="fdd3" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">这被认为是验证您设置的模拟正在被点击的最佳实践。为此，当我们像这样调用<code class="fe kw kx ky kz b">nock</code>时，我们可以在返回的引用上调用<code class="fe kw kx ky kz b">done()</code>:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="f8e2" class="nh mb it kz b gy ni nj l nk nl">const scope = nock('http://myapi.com') <br/>  .get('/products') <br/>  .reply(<br/>    200, <br/>    { products: [{ id: 1, name: 'nocked data' }] }, <br/>    { <br/>      'Access-Control-Allow-Origin': '*', <br/>      'Content-type': 'application/json' <br/>    }<br/>); </span><span id="79af" class="nh mb it kz b gy nm nj l nk nl">scope.done();</span></pre><p id="1e6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，当我们设置了一个模拟，但它不是真实的，会发生什么呢？让我们在测试中添加另一个调用，就像这样:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="b323" class="nh mb it kz b gy ni nj l nk nl">const users = nock('http://myapi.com') <br/>  .get('/users') <br/>  .reply(<br/>    200, <br/>    { products: [{ id: 1, name: 'user' }] }, <br/>    { <br/>      'Access-Control-Allow-Origin': '*', <br/>      'Content-type': 'application/json' <br/>    }<br/>);</span></pre><p id="3ae8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在看起来是这样的:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nq"><img src="../Images/2a9c597cbf5befb8f510be606bab8c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NKum6dq6JaG3xK1W.png"/></div></div></figure><h1 id="a008" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">阻止HTTP呼叫</h1><p id="6b39" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">你不应该让一个HTTP调用真正发生，所以一定要关闭这个能力。我们可以通过在<code class="fe kw kx ky kz b">setupTests.js</code>中添加以下行来实现:</p><pre class="lb lc ld le gt nd kz ne nf aw ng bi"><span id="21b7" class="nh mb it kz b gy ni nj l nk nl">import nock from 'nock'; <br/>nock.disableNetConnect();</span></pre><p id="a8cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经简要解释了什么是<code class="fe kw kx ky kz b">nock</code>以及如何在不同的情况下使用它。这只是处理HTTP调用的许多方法中的一种。</p><p id="a06d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以用<code class="fe kw kx ky kz b">nock</code>做更多的事情，我们仅仅触及表面。看看官方文件<a class="ae ko" href="https://www.npmjs.com/package/nock" rel="noopener ugc nofollow" target="_blank">诺克文件</a></p><h1 id="5101" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">摘要</h1><p id="35aa" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb na kd ke kf nb kh ki kj nc kl km kn im bi translated">好的，我们已经初步讨论了为什么拦截任何从HTPP打来的电话是个好主意。我们已经提到，我们可以使用正常的模仿，但我们选择了用库模仿更接近金属的方法。希望您已经看到使用nock是多么容易。</p><p id="2281" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，很高兴接受你对主题或改进的建议/Chris</p></div></div>    
</body>
</html>