<html>
<head>
<title>Porter: An Open Source Cloud Native Load Balancer in CNCF Landscape</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">porter:CNCF景观中的开源云本地负载均衡器</h1>
<blockquote>原文：<a href="https://itnext.io/porter-an-open-source-load-balancer-designed-for-bare-metal-kubernetes-clusters-870e1313b7f0?source=collection_archive---------1-----------------------#2020-07-09">https://itnext.io/porter-an-open-source-load-balancer-designed-for-bare-metal-kubernetes-clusters-870e1313b7f0?source=collection_archive---------1-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="820c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为裸机Kubernetes集群设计的负载均衡器Porter ，上周正式纳入CNCF景观。这标志着其母项目KubeSphere的一个重要里程碑，因为波特现在被CNCF视为最佳云本地实践之一的重要成员。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f794f10aa7f2252c23ea601607e39b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UIY4ursJgjY5x1pR"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">CNCF的搬运工</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lc"><img src="../Images/aa3ef944504df1a1a52d56c434bc3692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q91WB-zT5Zt996F7"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">CNCF景观</figcaption></figure><p id="55d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道我们可以使用Kubernetes集群中的LoadBalancer服务向外部公开后端工作负载。云提供商通常提供云负载平衡器插件，这需要将集群部署在特定的IaaS平台上。然而，许多企业用户经常在裸机上部署Kubernetes集群，尤其是当它用于生产环境时。对于本地裸机集群，Kubernetes不提供LB实现。Porter是一个开源负载平衡器，专门为裸机Kubernetes集群设计，是解决这一问题的绝佳方案。</p><h1 id="dd26" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">关于Kubernetes服务</h1><p id="52c7" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在Kubernetes集群中，网络代表了一个非常基本和重要的部分。对于大规模的节点和容器，如果要确保网络中的连通性和效率，则需要非常复杂和精细的设计。此外，需要在网络中自动分配和管理IP地址和端口，采用用户友好的方法直接快速访问需要的应用程序。</p><p id="18bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes在这方面做了很大的努力。通过CNI、服务、DNS和Ingress，它解决了服务发现和负载均衡的问题，提供了一种更简单的使用和配置方式。其中，服务是Kubernetes微服务的基础。通过Kubernetes中的kube-proxy，服务成为可能。</p><p id="fd76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该组件运行在每个节点上，监控API服务器中服务对象的变化，通过管理iptables实现网络转发。用户可以创建不同形式的服务，例如基于标签选择器、Headless或ExternalName的服务。Kube-proxy将为服务创建一个虚拟IP(或集群IP ),用于集群的内部访问。</p><h1 id="75bc" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">公开服务的三种方法</h1><p id="4546" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果需要在集群外部进行访问，或者向用户公开服务，Kubernetes服务提供了两种方法:NodePort和LoadBalancer。此外，Ingress也是公开服务的一个非常常见的选项。</p><h2 id="cdc2" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">节点端口</h2><p id="76da" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果服务类型设置为NodePort，kube-proxy将为服务申请一个大于3000的端口(默认情况下)。将为集群中的所有主机配置Iptables规则。通过这种方式，用户可以使用分配的端口通过集群中的任何节点访问服务。请看下图:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/f27e3aa2cbc9c564523e44b191a17652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ckl6yYLdJbpjAPD.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">节点端口</figcaption></figure><p id="4cd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点端口是公开服务最方便的方式，但它也有明显的缺点:</p><ol class=""><li id="8515" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">通过基于SNAT的访问，在Pod中看不到真实的IP。</li><li id="0a9c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">集群中的主机用作跳线服务器来访问后端服务，这意味着所有流量将首先流向服务器。这很容易导致性能瓶颈和单点故障，从而难以在生产环境中使用。</li><li id="7490" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">通常，NodePort使用很难记住的大端口号。</li></ol><p id="89e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初，节点端口不是为在生产环境中公开服务而设计的，这就是为什么默认情况下使用大端口号。</p><h2 id="47a4" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">负载平衡器</h2><p id="8a4e" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">负载平衡器是Kubernetes针对服务公开的首选解决方案。然而，如果没有云提供商提供的负载平衡器，这是无法实现的，这意味着Kubernetes集群必须部署在云中。负载平衡器的工作原理如下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nh"><img src="../Images/dccd3806c1a5d7d686ed4e0e4315a247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*spIFtaerd0njLdUZvCXnHg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">负载平衡器</figcaption></figure><p id="12f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">负载平衡器服务是通过云提供商提供的LB插件实现的。包Kubernetes.io/cloud-provider将选择合适的后端服务，并将其暴露给LB插件，从而创建一个负载平衡器。这意味着网络流量将分布在云服务中，避免了节点端口中可能出现的单点故障和性能瓶颈。如上所述，负载平衡器是Kubernetes对服务公开的首选解决方案，但它仅限于云提供商提供的Kubernetes服务。对于部署在裸机环境或非云环境中的Kubernetes集群，这种方法可能不适用。</p><h2 id="b872" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">进入</h2><p id="f645" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Kubernetes本身并不提供通过入口公开服务的方法。相反，Ingress在应用程序的帮助下同时公开多个服务，就像路由器一样。这个插件通过域识别不同的服务，并使用注释来控制服务对外公开的方式。它是这样工作的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ni"><img src="../Images/c9949cfdaf12970875b5946d1a24439b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zyueICARQReagBdg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">进入</figcaption></figure><p id="71bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相比节点端口和负载平衡器，入口是业务环境中使用最多的方法。原因包括:</p><ol class=""><li id="ca21" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">与kube-proxy的负载均衡方式相比，Ingress控制器的能力更强(例如流量控制和安全策略)。</li><li id="e58f" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">通过域识别服务更直接；节点端口中的大端口号也不需要用于入口。</li></ol><p id="2ed2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，对于入口，需要解决以下问题:</p><ol class=""><li id="8dfc" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">Ingress更多地用于L7，对L4的支持有限。</li><li id="b3ca" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">所有流量都将流向入口控制器，这需要一个LB来暴露入口控制器。</li></ol><p id="d0f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第一个问题，入口可以用于L4，但是入口的配置对于L4应用来说太复杂了。最佳做法是直接使用LB进行曝光。对于第二个问题，入口控制器可能暴露在具有节点端口(或主机网络)的测试环境中，而单点故障和性能瓶颈可能不可避免地发生，并且入口控制器的HA功能没有得到正确使用。</p><h2 id="113d" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">关于波特</h2><p id="0b84" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><a class="ae kl" href="https://porterlb.io/" rel="noopener ugc nofollow" target="_blank"> Porter </a>是KubeSphere开发团队基于边界网关协议(BGP)设计的一款开源云原生负载均衡工具。它的主要特点是:</p><ol class=""><li id="612f" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">ECMP路由负载平衡</li><li id="a5d4" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">BGP动态路由配置</li><li id="25df" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">第2层负载平衡</li><li id="79c1" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">VIP管理</li><li id="9dac" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">Kubernetes服务(v0.3.0)中的负载平衡分配</li><li id="57b7" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">带舵图的安装(v0.3.0)</li><li id="842c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">通过CRD的动态BGP服务器配置(v0.3.0)</li><li id="fe47" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">通过CRD的动态BGP对等配置(v0.3.0)</li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nj"><img src="../Images/ec227bd6a159954971dae1a382a8189b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ao0YseTSr56Gg3MU.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">搬运工</figcaption></figure><p id="686d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有波特代码都是开源的，文档可以在<a class="ae kl" href="https://github.com/kubesphere/porter" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中获得。欢迎明星使用。</p><h1 id="1e29" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">搬运工装置</h1><p id="e042" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">到目前为止，Porter已经在两个环境中进行了部署和测试，如下所示。点击下面的链接，你可以在GitHub中看到更多关于部署、测试和流程的细节。建议试一试:</p><ul class=""><li id="98a5" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk nk mz na nb bi translated"><a class="ae kl" href="https://github.com/kubesphere/porter/blob/master/doc/deploy_baremetal.md" rel="noopener ugc nofollow" target="_blank">在裸机Kubernetes集群上部署Porter</a></li><li id="a89c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated"><a class="ae kl" href="https://github.com/kubesphere/porter/blob/master/doc/porter-chart.md" rel="noopener ugc nofollow" target="_blank">使用舵图在Kubernetes上安装波特</a></li><li id="73d1" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated"><a class="ae kl" href="https://github.com/kubesphere/porter/blob/master/doc/simulate_with_bird.md" rel="noopener ugc nofollow" target="_blank">在QingCloud平台中使用模拟路由器进行测试</a></li></ul><h1 id="8043" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">原则</h1><h2 id="341a" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">ECMP</h2><p id="539c" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">等价多路径(ECMP)是指数据包可以通过多条等价路径转发到同一个目的地。当设备支持ECMP时，发送到目标IP或网段的三层流量可以通过不同的路径进行分配，从而实现网络负载平衡。此外，一旦某条路径出现故障，其他路径可以替代完成转发过程，充当路由冗余备份。请参考下图:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nl"><img src="../Images/aca563b043fe80e71160e5964ed69e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*68HTiQ4BDNDLdKqE.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">路由器</figcaption></figure><p id="b4c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在虚拟路由器的帮助下，ECMP可以根据哈希算法从现有的路由路径中为某个IP(服务的相应VIP)选择下一跳(Pod)。这就是负载平衡的实现方式。由于虚拟路由器一般都支持ECMP，所以Porter只需要检查Kubernetes API服务器，并将服务的后端Pod的相应信息传递给路由器。</p><h2 id="1163" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">边界网关协议(Border Gateway Protocol)</h2><p id="02f7" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">可以将一个Pod调度到Kubernetes中的其他节点。对于路由器来说，服务VIP的下一跳是不固定的，因为等价路由信息会经常更新。例如，Calico使用BGP(边界网关协议)来通告路由。BGP是一种常用的基本分散协议，用于在互联网上的自治系统之间交换路由信息。与其他路由协议不同，BGP使用L4来保证路由信息的更新安全。由于BGP是去中心化的，很容易建立一个高可用性的路由层来保证网络的连续性。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nm"><img src="../Images/d1bdb53e84b441f5ce00ce2023941e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ckg8755PMmHvqVcj.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">边界网关协议(Border Gateway Protocol)</figcaption></figure><p id="ad42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图简单演示了BGP如何在Porter中工作。左下角是一个双节点Kubernetes集群，其上有两个路由器(Leaf1和Leaf2)。这两个路由器连接到两个内核交换机(主干层)。用户在右侧，他们的路由器是Border1和Border2(也连接到Spine)。</p><p id="0a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">三层用户和Kubernetes服务器都是可达的。服务是在Kubernetes集群中创建的，也使用了Porter。Porter分配一个VIP(或其他手动分配的IP)1.1.1.1，通过BGP将信息发送到Leaf1和Leaf2。接入1.1.1.1的下一跳可以是节点1或节点2。同时，叶层也向主干层发送消息，主干层也根据其BGP知道访问1.1.1.1的下一跳可以是叶1或叶2。</p><p id="4d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照同样的逻辑，路由信息也将在Border上更新，这意味着用户访问1.1.1.1的路径是完整的。同时，由于图像中的每个层都具有HA，因此总共有16个(<code class="fe nn no np nq b">2*2*2*2</code>)路径可用于外部访问。流量可以分布在整个网络中，任何层的路由器中发生的任何停机都不会影响用户的访问。</p><h1 id="61e2" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">体系结构</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nr"><img src="../Images/263c5d3e915a83c8c8908f799019dca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2RJJuUS2mR_e6Ck3.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">体系结构</figcaption></figure><p id="5d8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Porter有两个组件:一个核心控制器和一个部署在每个节点上的代理。控制器的主要功能包括:</p><ol class=""><li id="bb8a" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">监控群集服务和相应的端点；获取吊舱的调度信息</li><li id="9b30" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">VIP存储和分配</li><li id="d756" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">建立BGP并通告路由</li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ns"><img src="../Images/04b01d04caaebc90b071ed70eb6cd335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kOynEiumm5ZFbP-0.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">逻辑</figcaption></figure><p id="bbb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图是波特核心控制器的工作原理。</p><p id="cbd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代理是一个轻量级组件，用于监控VIP资源，并为VIP的外部访问添加Iptables规则。默认情况下，内核转发表将丢弃任何对VIP的外部访问。</p><h1 id="18e6" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">云原生设计</h1><p id="d5d0" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">波特里的所有资源都是CRD的，包括VIP，BGPPeer和BGPConfig。习惯了Kubectl的用户会发现Porter非常好用。对于想要定制Porter的高级用户，可以直接调用Kubernetes API进行量身定制开发。Porter的核心控制器将很快支持高可用性(HA)。</p><h1 id="2df7" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">重要的</h1><p id="6b75" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">用户访问的VIP流量将到达BGP下的Kubernetes集群中的一个节点。这是因为Porter通告的路由也是节点，而不是外部不可访问的Pod IP。从节点到pod的路径由kube-proxy维护，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nt"><img src="../Images/e807b3cdbe1ae2ced5211aab57c3ff85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LjlgYwBC7fa9Wlbs.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">精灵</figcaption></figure><p id="e369" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SNAT过程之后，流量将被随机发送到一个pod。由于端口将根据服务端点的动态变化来调整路由，以确保下一跳节点中有可用的pod，因此我们可以更改默认设置的kube-proxy。您可以在服务中设置<strong class="jp ir">ExternalTrafficPolicy = local</strong>，结果如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a4293e8839db6ac5efe1d846b81878fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*Oz6OPDTjOke-EI4x.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">客户端节点单元</figcaption></figure><p id="2952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法有两个优点:</p><ol class=""><li id="5317" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">SourceIP不会经历NAT的过程</li><li id="3e27" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">流量将在本地传输，减少了网络中的一跳</li></ol><h1 id="3501" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">与MetalLB相比</h1><h2 id="bbf4" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">赞成的意见</h2><ul class=""><li id="4aa9" class="mt mu iq jp b jq mb ju mc jy nv kc nw kg nx kk nk mz na nb bi translated">支持大多数BGP功能和多种网络架构。</li><li id="2ced" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated">一个基于CRD控制器的Kubernetes友好工具，可以完全由kubectl控制。</li><li id="5265" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated">配置文件可以动态更新，无需重启。BGP配置会根据网络环境自动更新。可以动态地采用各种BGP特性。</li><li id="0b9a" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated">提供被动模式，支持DNAT。</li><li id="9bb4" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated">与印花布的冲突可以用更友好的方式处理。</li></ul><h2 id="4a62" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">骗局</h2><ul class=""><li id="df8b" class="mt mu iq jp b jq mb ju mc jy nv kc nw kg nx kk nk mz na nb bi translated">仅支持Linux。</li></ul><h2 id="bb8b" class="mg le iq bd lf mh mi dn lj mj mk dp ln jy ml mm lr kc mn mo lv kg mp mq lz mr bi translated">类似</h2><ul class=""><li id="34a2" class="mt mu iq jp b jq mb ju mc jy nv kc nw kg nx kk nk mz na nb bi translated">这两种工具都需要更多的测试。</li></ul><h1 id="2dd3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">未来计划</h1><ol class=""><li id="0e00" class="mt mu iq jp b jq mb ju mc jy nv kc nw kg nx kk my mz na nb bi translated">支持其他简单路由协议</li><li id="050c" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">更方便的VIP管理</li><li id="6fc8" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">BGP的政策支持</li><li id="a8ec" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">通过提供的UI集成到KubeSphere中</li></ol><h1 id="51db" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">相关资源</h1><ul class=""><li id="6f3a" class="mt mu iq jp b jq mb ju mc jy nv kc nw kg nx kk nk mz na nb bi translated"><a class="ae kl" href="https://www.youtube.com/watch?v=EjU1yAVxXYQ" rel="noopener ugc nofollow" target="_blank">kube con Shanghai:Porter——裸机Kubernetes的开源负载均衡器</a></li><li id="ea40" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk nk mz na nb bi translated"><a class="ae kl" href="https://porterlb.io/" rel="noopener ugc nofollow" target="_blank">波特网站</a></li></ul><h1 id="301f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">关于KubeSphere</h1><p id="23a8" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">KubeSphere 是一个基于Kubernetes的开源容器平台，其核心是应用程序。它提供全栈It自动化操作和简化的开发运维工作流。</p><p id="3153" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">KubeSphere已被全球数千家企业采用，如Aqara、新浪、奔来、Anchnet、华夏银行、极限视界、微众银行、Maxnerva、VNG公司和Radore。KubeSphere提供向导界面和各种企业级的运维功能，包括Kubernetes资源管理、DevOps (CI/CD)、应用生命周期管理、服务网格、多租户管理、监控、日志记录、警报、通知、存储和网络管理以及GPU支持。有了KubeSphere，企业能够快速建立一个强大且功能丰富的容器平台。</p><p id="5bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> KubeSphere网站</strong>:<a class="ae kl" href="https://kubesphere.io/" rel="noopener ugc nofollow" target="_blank">https://kubesphere.io/</a></p><p id="8a77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">KubeSphere GitHub</strong>:【https://github.com/kubesphere/kubesphere】T2</p></div></div>    
</body>
</html>