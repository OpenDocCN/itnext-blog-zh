<html>
<head>
<title>Divide &amp; Conquer and Sets: The 114 C++ algorithms series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分治和集合:114 C++算法系列</h1>
<blockquote>原文：<a href="https://itnext.io/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e?source=collection_archive---------3-----------------------#2022-03-14">https://itnext.io/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e?source=collection_archive---------3-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎阅读114 C++算法系列的第三篇文章。今天，我们将着眼于提供低计算复杂度但需要排序或分区范围的算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c0c3a1c2bad48e76abab310bf4334ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSI4bV7eHQ5E9lVn7VWszw.png"/></div></div></figure><p id="3391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们今天将讨论两类算法。在O(logn)时间内操作的分治算法和仅在排序范围上可行的线性算法。</p><h2 id="fb82" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">该系列:</h2><ul class=""><li id="fe08" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300">简介</a></li><li id="4b30" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">排序和分割算法</a></li><li id="8f1e" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">对排序或分区范围进行操作的算法</li><li id="f7c1" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/transformations-the-114-c-algorithms-series-deacdbd4c373">变换算法</a></li><li id="5f59" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324">左侧折叠和其他缩减</a></li><li id="dddd" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、副本和移动</a></li><li id="6c9c" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d">堆和堆</a></li><li id="a7f8" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/@simontoth/8a6ed951ad40" rel="noopener">搜索和最小值-最大值</a></li><li id="e5ab" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">结论(即将发布)</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="8d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然基于散列的容器使我们能够在O(1)平均时间内查找任何元素，但这种方法有两个缺点。首先，我们只能查找特定的元素，如果该元素不在容器中，我们会得到一个简单的查找失败。其次，我们的类型需要是可哈希的。</p><p id="24e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分而治之算法允许基于严格的弱排序来查找边界，并且即使在容器的特定值不存在时也能工作。此外，由于我们使用的是排序容器，一旦确定了边界，我们就可以轻松地访问相邻的值。</p><p id="299e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您没有阅读本系列的前一章，严格弱排序是满足这些约束的排序:自反:<em class="mo"> f(a，a) = false </em>，反对称:<em class="mo"> f(a，b) = true = &gt; f(b，a) = false </em>，传递:<em class="mo"> f(a，b) = true &amp; &amp; f(b，c) = true = &gt; f(a，c) = true 【T19</em></p><h1 id="65ff" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">下限，上限，等于范围</h1><p id="e51c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">C++提供了三种边界搜索算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/b80308371b005874cf17091f4e3e1cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G0HzzsyCsMVt8DrHStNM4A.png"/></div></div></figure><p id="0b90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些算法的不同之处在于它们要搜索的边界:</p><ul class=""><li id="5bb8" class="lq lr iq jp b jq jr ju jv jy nk kc nl kg nm kk lx ly lz ma bi translated">lower_bound返回不小于所提供值的第一个元素</li><li id="9128" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">upper_bound返回大于所提供值的第一个元素</li></ul><p id="0480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不存在这样的元素，两种算法都返回结束迭代器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e4d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你阅读了前一章，这段代码可能看起来很熟悉，因为我们使用std::partition来实现非常相似的行为。主要的区别是我们正在处理一个不可变的范围(第9行),我们期望这个范围已经排序了(在这个例子中是score)。当我们同时使用lower_bound和upper_bound时，得到的子范围将表示值的封闭范围，在本例中为[49，99](第11、12行)。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="7c56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对数行为仅适用于随机访问范围。对std::set、std::multiset、std::map或std::multimap使用lower_bound或upper_bound将导致线性搜索。</p><p id="344b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，所有这些容器都以方法的形式提供了下界和上界的O(logn)实现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="2664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">lower_bound和upper_bound的组合是equal_range，它返回两个界限。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/7c6b4be6d9a49f693bf24454975500c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HOaekuD-ZMozwWSvPX7gQ.png"/></div></div></figure><p id="d84e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过为相同的值调用lower_bound和upper_bound来模拟equal_range。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a3dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">括号语法(如果你不熟悉的话)是C++17的结构化绑定。结构化绑定允许我们将equal_range返回的std::pair分解成两个命名变量。</p><h1 id="aa18" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">分区点，二进制搜索</h1><p id="5114" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">尽管如此命名，partition_point的工作方式与upper_bound非常相似，但是它不是搜索特定的值，而是使用谓词进行搜索。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/ee070acc5cc1e73d7de0c4a9eca41063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4qc8VSbfB0G73xaCHnInA.png"/></div></div></figure><p id="db86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分区点将返回不满足所提供谓词的第一个元素。该算法只需要划分范围(相对于谓词)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="6817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，二分搜索法用作存在检查，返回布尔值，表明请求值是否存在于排序范围内。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/063fb6c7f8bcf8ac25c063c95814b33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vy2ZmXovX0llZR4663JF5Q.png"/></div></div></figure><p id="c666" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然功能上与调用equal_range并检查返回的范围是否为空相同，但binary_search通常会更快。这是因为binary_search算法必须实现为一次搜索，而equal_range允许两次。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f80a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于数字5出现在范围中，equal_range将返回一个非空范围，binary_search将返回TRUE。</p><h1 id="f8f7" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">c标准库:bsearch</h1><p id="7991" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">从C标准库中，C++继承了bsearch。该算法返回与所提供的键相等的元素之一，如果没有找到这样的元素，则返回nullptr。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="593c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与qsort一样，实际上没有理由在C++代码中使用bsearch。</p><p id="8d86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据具体的使用情况，前面提到的算法之一应该是合适的替代品。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="1589" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">包含</h1><p id="7ea2" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">我们要讲的第一个线性算法是std::includes。该算法确定一个范围是否是另一个范围的子范围。因为我们正在处理排序的范围，所以std::includes以线性时间运行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/084b3cb121fc0fb0bf7e18ef1c227cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lu0qkJB5x19IiiNJcYZtig.png"/></div></div></figure><p id="c879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们检查输入文本是否包含所有小写英文字母。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fd62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们使用另一个算法std::iota(第2行)以编程方式生成英文字母列表。iota算法生成连续增加的值来填充给定的范围。因此，我们将向量预分配给26个元素(第1行)。</p><h1 id="96cd" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">合并，就地_合并</h1><p id="b702" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">在线性时间中可行的另一个操作是合并两个排序的范围。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/74671e7f5e6ab065e0aa487b081fd4ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcCTJSD5xSMOqLVDTGMI5w.png"/></div></div></figure><p id="89b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用提供的输出迭代器存储合并操作的结果。请注意，输出范围不允许与任何一个输入范围重叠。</p><p id="8af1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">合并操作稳定。第一个范围中的相等元素将排在第二个范围中的相等元素之前。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="10b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并行版本要求输出是一个向前的范围(由forward_iterator表示)。因此，我们不能使用像std::back_inserter这样的包装器，必须将输出范围预先分配到足够的容量。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/2278eaec452804a8f2abff9a90b363c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cezCiSMOyvvgCa3fL0z0Qg.png"/></div></div></figure><p id="81a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为merge禁止输入和输出范围重叠，所以我们有一个替代的inplace_merge来服务这个用例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="7275" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">唯一，唯一_副本</h1><p id="7151" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">std::unique算法删除连续的重复值。典型的用例与排序范围结合使用。但是，这不是std::unique的要求。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/9f2b7f9bdeae15052f04d6560c49a483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cWu8F4WilEVNhNm9Ft3Jg.png"/></div></div></figure><p id="7690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为unique就地工作，并且不能调整基础范围的大小，所以它将范围的末尾留有未指定的值，并将迭代器返回到该子范围的开头(如果是范围版本，则返回子范围)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/471c07e1658f76823deafc6cd41eb3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZPt_6NTYmEyxi_etlmu6w.png"/></div></div></figure><p id="2e3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">unique的复制版本将唯一值输出到由迭代器表示的输出范围。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="b5c1" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">集合差，集合对称差，集合并，集合交</h1><p id="daff" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">最后一组需要排序范围的算法是集合运算。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/6471a743b83a0bfeba29b794f12b54d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wL8DjbFehSoXV3G896cJ8g.png"/></div></div></figure><p id="159b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有集合操作都以相同的方式工作，处理两个输入范围并将结果复制到结果范围中，其语义如下:</p><ul class=""><li id="3412" class="lq lr iq jp b jq jr ju jv jy nk kc nl kg nm kk lx ly lz ma bi translated">差异:元素出现在第一个范围内，而不是第二个范围内</li><li id="77b5" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">symmetric_difference:只出现在一个范围中的元素，而不是同时出现在两个范围中的元素</li><li id="3cfb" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">联合:在任一范围内存在的元素</li><li id="ee0d" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">交集:在两个范围中都存在的元素</li></ul><p id="4c53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要讨论同等元素的行为。如果我们在第一个范围中有<em class="mo"> m </em>个这样的元素，在第二个范围中有<em class="mo"> n </em>个这样的元素，那么得到的范围将包含:</p><ul class=""><li id="4804" class="lq lr iq jp b jq jr ju jv jy nk kc nl kg nm kk lx ly lz ma bi translated">差异:<em class="mo"> max(m-n，0) </em>元素</li><li id="693c" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">symmetric _ difference:<em class="mo">ABS(m-n)</em>，即:如果<em class="mo"> m &gt; n </em>，<em class="mo"> m-n </em>元素将从第一个范围复制；否则，<em class="mo"> n-m </em>元素将从第二个范围中复制</li><li id="b1c5" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">union: <em class="mo"> max(m，n) </em>，将从第一个范围中复制第一个<em class="mo"> m </em>元素，然后从第二个范围中复制<em class="mo"> max(n-m，0) </em>元素</li><li id="29e9" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">交集:<em class="mo"> min(m，n) </em>，将从第一个范围中复制元素</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="f020" class="mp ky iq bd kz mq mr ms lc mt mu mv lf mw mx my li mz na nb ll nc nd ne lo nf bi translated">感谢您的阅读</h1><p id="fbec" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">不要忘记关注，这样你就不会错过本系列的其他文章。例如，下一篇文章将讨论转换范围的算法。</p><p id="8213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae mb" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae mb" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>