<html>
<head>
<title>Docker 101: Fundamentals &amp; The Dockerfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 101:基础和Docker文件</h1>
<blockquote>原文：<a href="https://itnext.io/docker-101-fundamentals-the-dockerfile-b33b59d0f14b?source=collection_archive---------1-----------------------#2018-06-23">https://itnext.io/docker-101-fundamentals-the-dockerfile-b33b59d0f14b?source=collection_archive---------1-----------------------#2018-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/4fca6fdb380132f3128ba9f0c374f849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*j_zP74-cpvXRcs8dM_pkMQ.jpeg"/></div></figure><p id="6ce4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能和我一样，以前听说过Docker。您可能有同事或开发人员朋友对它赞不绝口，他们尽可能地“dockerize ”,并且在用普通人可以理解的术语解释Docker及其所有优点时，他们完全不知所措。今天，我将尝试为你揭开Docker的神秘面纱。</p><p id="c006" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这实际上是Docker上的一个三部分系列，因为Docker至少需要三个单独的帖子来介绍其三个最知名的产品:</p><ul class=""><li id="38cc" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">Docker(和docker文件)，</li><li id="468f" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">Docker编写，和</li><li id="7cfa" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">码头工人群</li></ul><p id="f7c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以让我们从头开始，我将解释Docker实际上是什么，用连我都理解的术语来解释。</p><h2 id="695b" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Docker是什么？</h2><p id="0532" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">Docker网站本身只是将Docker描述为:</p><blockquote class="me mf mg"><p id="ba5c" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated">“世界领先的软件容器化平台”——Docker，Docker概述</p></blockquote><p id="c932" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就清楚了，对吧？嗯……是的，不太好。关于码头工人的更好的描述可以在OpenSource.com找到。</p><blockquote class="me mf mg"><p id="2f7e" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated">Docker 是一个工具，旨在通过使用容器来简化应用程序的创建、部署和运行。容器允许开发人员将应用程序与它需要的所有部分打包在一起，比如库和其他依赖项，然后作为一个包发送出去。—OpenSource.com，什么是码头工人？</p></blockquote><p id="0909" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Docker真正做的是将应用程序代码从基础设施需求和需要中分离出来。它通过在一个称为“容器”的隔离环境中运行每个应用程序来实现这一点这意味着开发人员可以专注于在Docker容器中运行的实际代码，而不用担心它最终将在哪个系统上运行，devOps可以专注于确保在Docker容器中安装正确的程序，并减少所需的系统数量和部署后维护所述系统的复杂性。</p><p id="ddfe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个完美的下一个问题:为什么是Docker？</p><h2 id="707a" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">为什么是Docker？</h2><p id="f0c0" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">我不知道有多少次我听到一个开发人员(包括我自己)说，“它能在我的机器上工作，我不知道为什么它不能在你的机器上工作。”—任何开发人员</p><p id="2636" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是Docker的设计目的——当一个开发人员在他们的本地机器上为一个项目工作了几天(或几周)时，不可避免地会出现混乱，一旦部署到新的生命周期，应用程序就不会运行了。很可能是因为有许多安装的依赖项是运行应用程序所必需的，但它们没有保存在<code class="fe mm mn mo mp b">package.json</code>或<code class="fe mm mn mo mp b">build.gradle</code>中，也没有在<code class="fe mm mn mo mp b">manifest.yml</code>中指定。</p><p id="3db7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每一个Docker容器都是从一无所知的纯普通Linux机器开始的。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/67b19ed6d6828263403ef6fdacd3b3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*Px00s07K5J8W50ZkcP7vag.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">码头集装箱旋转起来就像琼恩·雪诺；它什么都不知道。</figcaption></figure><p id="859b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们告诉容器它需要知道的一切——为了运行应用程序，它需要下载和安装的所有依赖项。这个过程是用一个<code class="fe mm mn mo mp b">Dockerfile</code>完成的，但是我有点超前了。</p><p id="b0cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于本节，可以说，Docker消除了部署应用程序的猜测(和花费的调试时间),因为它总是作为一台全新的、隔离的机器启动，并且添加了完全相同的依赖项。每一个。单身。时间。</p><p id="82f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">没有安装了不同版本依赖项的环境。没有完全缺少依赖关系的环境。不要和Docker胡闹。</p><h2 id="8388" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Docker工具</h2><p id="2bf0" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">在深入Docker文件之前，我将快速浏览一下Docker的工具套件。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/34873d5dda598fd8b169c59a56a4f6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlNz_cp1Hxdh2RhJF0Dh_w.png"/></div></div></figure><p id="13e4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Docker提供了四个主要工具来完成任务:</p><ul class=""><li id="67d0" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><a class="ae ml" href="https://docs.docker.com/engine/" rel="noopener ugc nofollow" target="_blank"> Docker引擎</a></li><li id="5c63" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ml" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank"> Docker作曲</a></li><li id="9693" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ml" href="https://docs.docker.com/machine/overview/" rel="noopener ugc nofollow" target="_blank">对接机* </a></li><li id="563c" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ml" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank">码头工人群</a></li></ul><p id="b8e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">对接机引擎</strong>是对接机的</p><blockquote class="me mf mg"><p id="4cd7" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated">"强大的开源容器化技术与构建和容器化应用程序的工作流程相结合."— Docker，关于Docker引擎</p></blockquote><p id="6d36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它从单个<code class="fe mm mn mo mp b">Dockerfile</code>或<code class="fe mm mn mo mp b">docker-compose.yml</code>构建并执行Docker映像。当有人通过docker CLI使用Docker命令时，它会与该引擎进行对话，以完成需要完成的任务。</p><p id="88ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Docker撰写</strong></p><blockquote class="me mf mg"><p id="6a88" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated">“是一个用于定义和运行多容器Docker应用程序的工具”——Docker，Docker Compose概述</p></blockquote><p id="7933" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您有一个由多个微服务、数据库和其他依赖项组成的应用程序时，您可以使用这种方法。<code class="fe mm mn mo mp b">docker-compose.yml</code>允许您在一个地方配置所有这些服务，并使用一个命令启动它们。我将在后续的博客文章中更详细地介绍Docker Compose。</p><p id="1f64" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在过去的几年里，打卡机比现在更受欢迎。</p><blockquote class="me mf mg"><p id="4906" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated">" Docker Machine是一个工具，可以让你在虚拟主机上安装Docker引擎，并使用<code class="fe mm mn mo mp b">docker-machine</code>命令管理主机."—对接机，对接机概述</p></blockquote><p id="4690" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着Docker镜像在它们的本地平台上变得更加稳定，它已经被搁置了一段时间，但是在Docker历史的早期，它非常有用。关于Docker Machine，你现在需要知道的大概就是这些了。</p><p id="1474" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后一个工具<strong class="jw ir"> Docker Swarm </strong>，将在博客3中详细介绍。但是现在，码头工人蜂拥而至</p><blockquote class="me mf mg"><p id="b4e4" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated">创建了一组Docker引擎，您可以在其中部署应用程序服务。你不需要额外的编排软件来创建或管理一个群体”——Docker，群体模式概述</p></blockquote><p id="52db" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些是您将熟悉的工具，现在，我们可以讨论Dockerfile了。</p><h2 id="473d" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Dockerfile —一切开始的地方</h2><p id="e7fa" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">Docker是一个强大的工具，但是它的力量是通过使用名为<strong class="jw ir"> Dockerfiles </strong>的东西来利用的。</p><blockquote class="me mf mg"><p id="023d" class="ju jv mh jw b jx jy jz ka kb kc kd ke mi kg kh ki mj kk kl km mk ko kp kq kr ij bi translated"><code class="fe mm mn mo mp b">Dockerfile</code>是一个文本文档，包含用户可以在命令行上调用的所有命令，以组合一个图像。使用<code class="fe mm mn mo mp b">docker build</code>,用户可以创建一个连续执行几个命令行指令的自动化构建。- Docker，Docker文件参考</p></blockquote><p id="c765" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Docker映像由只读层组成，每一层代表一条Dockerfile指令。这些层是堆叠的，每一层都是前一层的变化的增量。</p><p id="9cda" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我上面所说的，当Docker容器启动时，它需要被告知做什么，它没有安装任何东西，它知道如何做任何事情。真的没有。</p><p id="04e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Dockerfile首先需要的是一个<strong class="jw ir">基础映像</strong>。基础映像告诉容器要安装什么作为它的操作系统——Ubuntu、RHEL、SuSE、Node、Java等等。</p><p id="b2ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，您将提供设置说明。这些都是Docker容器需要知道的事情:环境变量、要安装的依赖项、文件所在的位置等等。</p><p id="cebc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，你必须告诉容器做什么。通常，它将运行安装说明中指定的应用程序的特定安装和命令。接下来我将简要介绍最常见的Dockerfile命令，然后展示一些例子来帮助理解。</p><h2 id="caa4" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Dockerfile命令</h2><p id="342f" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">下面是在你编写docker文件时90%的时间都会用到的命令，以及它们的含义。</p><ul class=""><li id="259a" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">FROM</code> —初始化新的构建阶段，并为后续指令设置<a class="ae ml" href="https://docs.docker.com/engine/reference/glossary/#base-image" rel="noopener ugc nofollow" target="_blank"> <em class="mh">基础映像</em> </a>。因此，有效的<code class="fe mm mn mo mp b">Dockerfile</code>必须以<code class="fe mm mn mo mp b">FROM</code>指令开始。</li><li id="f797" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">RUN</code> —将在当前图像之上的新图层中执行任何命令，并提交结果。最终提交的图像将用于<code class="fe mm mn mo mp b">Dockerfile</code>中的下一步。</li><li id="9571" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">ENV</code> —将环境变量<code class="fe mm mn mo mp b">&lt;key&gt;</code>设置为值<code class="fe mm mn mo mp b">&lt;value&gt;</code>。该值将存在于构建阶段的所有后续指令的环境中，并且在许多情况下可以被内联替换。</li><li id="9916" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">EXPOSE</code> —通知Docker容器在运行时监听指定的网络端口。您可以指定端口是侦听TCP还是UDP，如果未指定协议，默认为TCP。这使得主机和外界可以访问隔离的Docker容器</li><li id="d9f8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">VOLUME</code> —创建一个具有指定名称的挂载点，并将其标记为包含来自本机主机或其他容器的外部挂载卷。</li></ul><p id="7823" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，现在已经定义了Dockerfile命令，让我们来看一些docker file样例。如果你想学习更多关于Docker命令的知识，我强烈推荐<a class="ae ml" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile文档</a>——它写得非常好。</p><h2 id="8831" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Dockerfile文件示例</h2><p id="9faa" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">这里有几个docker文件示例，包括解释每一行和每一层发生了什么的注释。</p><p id="4468" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">节点Dockerfile示例</strong></p><pre class="mr ms mt mu gt ne mp nf ng aw nh bi"><span id="faa2" class="lg lh iq mp b gy ni nj l nk nl"># creates a layer from the node:carbon Docker image<strong class="mp ir"><br/>FROM </strong>node:carbon</span><span id="4e6b" class="lg lh iq mp b gy nm nj l nk nl"># create the app directory for inside the Docker image<br/><strong class="mp ir">WORKDIR /</strong>usr<strong class="mp ir">/</strong>src<strong class="mp ir">/</strong>app</span><span id="a6ab" class="lg lh iq mp b gy nm nj l nk nl"># copy and install app dependencies from the package.json (and the package-lock.json) into the root of the directory created above<br/><strong class="mp ir">COPY </strong>package<strong class="mp ir">*</strong>.json .<strong class="mp ir">/<br/>RUN </strong>npm install</span><span id="17d7" class="lg lh iq mp b gy nm nj l nk nl"># bundle app source inside Docker image<br/><strong class="mp ir">COPY </strong>. .</span><span id="9f4a" class="lg lh iq mp b gy nm nj l nk nl"># expose port 8080 to have it mapped by Docker daemon<br/><strong class="mp ir">EXPOSE </strong>8080</span><span id="95ee" class="lg lh iq mp b gy nm nj l nk nl"># define the command to run the app (it's the npm start script from the package.json file)<br/><strong class="mp ir">CMD </strong>[ "npm", "start" ]</span></pre><p id="e2e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Java Dockerfile示例</strong></p><pre class="mr ms mt mu gt ne mp nf ng aw nh bi"><span id="3389" class="lg lh iq mp b gy ni nj l nk nl"># creates a layer from the openjdk:8-jdk-alpine Docker image<strong class="mp ir"><br/>FROM </strong>openjdk:8-jdk-alpine</span><span id="5370" class="lg lh iq mp b gy nm nj l nk nl"># create the directory for where Tomcat creates its working directories<br/><strong class="mp ir">VOLUME /</strong>tmp</span><span id="93e6" class="lg lh iq mp b gy nm nj l nk nl"># copy the project JAR file to the container renamed as 'app.jar'<br/><strong class="mp ir">COPY </strong>build<strong class="mp ir">/</strong>libs <strong class="mp ir">/</strong>app</span><span id="fe8a" class="lg lh iq mp b gy nm nj l nk nl"># execute that JAR in the entry point below<br/><strong class="mp ir">ENTRYPOINT </strong>["java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/java-example.jar"]</span></pre><p id="a085" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> Python Dockerfile示例</strong></p><pre class="mr ms mt mu gt ne mp nf ng aw nh bi"><span id="1b1c" class="lg lh iq mp b gy ni nj l nk nl">#<strong class="mp ir"> </strong>creates a layer from the <!-- -->ubuntu:16.04<!-- --> Docker image <br/><strong class="mp ir">FROM</strong> ubuntu:16.04</span><span id="d7c8" class="lg lh iq mp b gy nm nj l nk nl">#<strong class="mp ir"> </strong>adds files from the Docker client’s current directory<br/><strong class="mp ir">COPY</strong> . /app</span><span id="92c8" class="lg lh iq mp b gy nm nj l nk nl"># <!-- -->builds the application with <!-- -->make <br/><strong class="mp ir">RUN</strong> make /app</span><span id="e520" class="lg lh iq mp b gy nm nj l nk nl">#<strong class="mp ir"> </strong>specifies what command to run within the container<br/><strong class="mp ir">CMD</strong> python /app/app.py</span></pre><p id="e2b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">詹金斯文档示例</strong></p><pre class="mr ms mt mu gt ne mp nf ng aw nh bi"><span id="35e9" class="lg lh iq mp b gy ni nj l nk nl"># creates a layer from the jenkins:lts Docker image<strong class="mp ir"><br/>FROM </strong>jenkins<strong class="mp ir">/</strong>jenkins:lts</span><span id="aede" class="lg lh iq mp b gy nm nj l nk nl"> # sets user to root (because Docker always runs as root and Jenkins needs to know this)<br/>  <strong class="mp ir">USER </strong>root<br/> <br/> # add and install all the necessary dependencies<br/> <strong class="mp ir">RUN </strong>apt-get update <strong class="mp ir">&amp;&amp; </strong>\<br/> apt-get install <strong class="mp ir">-</strong>qy \<br/>   apt-utils \<br/>   libyaml-dev \<br/>   build-essential \<br/>   python-dev \<br/>   libxml2-dev \<br/>   libxslt-dev \<br/>   libffi-dev \<br/>   libssl-dev \<br/>   default-libmysqlclient-dev \<br/>   python-mysqldb \<br/>   python-pip \<br/>   libjpeg-dev \<br/>   zlib1g-dev \<br/>   libblas-dev\<br/>   liblapack-dev \<br/>   libatlas-base-dev \<br/>   apt-transport-https \<br/>   ca-certificates \<br/>   zip \<br/>   unzip \<br/>   gfortran <strong class="mp ir">&amp;&amp; </strong>\<br/> rm <strong class="mp ir">-</strong>rf <strong class="mp ir">/</strong>var<strong class="mp ir">/</strong>lib<strong class="mp ir">/</strong>apt<strong class="mp ir">/</strong>lists<strong class="mp ir">/*<br/> <br/> </strong># install docker<br/> <strong class="mp ir">RUN </strong>curl <strong class="mp ir">-</strong>fsSL get.docker.com <strong class="mp ir">-</strong>o get-docker.sh <strong class="mp ir">&amp;&amp; </strong>sh get-docker.sh<br/> <br/> # install docker compose<br/> <strong class="mp ir">RUN </strong>curl <strong class="mp ir">-</strong>L https:<strong class="mp ir">//</strong>github.com<strong class="mp ir">/</strong>docker<strong class="mp ir">/</strong>compose<strong class="mp ir">/</strong>releases<strong class="mp ir">/</strong>download<strong class="mp ir">/</strong>1.8.0<strong class="mp ir">/</strong>docker-compose-`uname <strong class="mp ir">-</strong>s`<strong class="mp ir">-</strong>`uname <strong class="mp ir">-</strong>m` <strong class="mp ir">&gt; /</strong>usr<strong class="mp ir">/</strong>local<strong class="mp ir">/</strong>bin<strong class="mp ir">/</strong>docker-compose <strong class="mp ir">&amp;&amp; </strong>\<br/>     chmod <strong class="mp ir">+</strong>x <strong class="mp ir">/</strong>usr<strong class="mp ir">/</strong>local<strong class="mp ir">/</strong>bin<strong class="mp ir">/</strong>docker-compose</span><span id="0636" class="lg lh iq mp b gy nm nj l nk nl"> # install pip for python<br/> <strong class="mp ir">RUN </strong>pip install cffi <strong class="mp ir">--</strong>upgrade<br/> <strong class="mp ir">RUN </strong>pip install pip2pi ansible<strong class="mp ir">==</strong>2.0<br/> <br/> # copy groovy executors and plugins for jenkins and run the plugins<br/> <strong class="mp ir">COPY </strong>executors.groovy <strong class="mp ir">/</strong>usr<strong class="mp ir">/</strong>share<strong class="mp ir">/</strong>jenkins<strong class="mp ir">/</strong>ref<strong class="mp ir">/</strong>init.groovy.d<strong class="mp ir">/</strong>executors.groovy<br/> <strong class="mp ir">COPY </strong>plugins.txt <strong class="mp ir">/</strong>usr<strong class="mp ir">/</strong>share<strong class="mp ir">/</strong>jenkins<strong class="mp ir">/</strong>ref<strong class="mp ir">/</strong>plugins.txt<br/> <strong class="mp ir">RUN /</strong>usr<strong class="mp ir">/</strong>local<strong class="mp ir">/</strong>bin<strong class="mp ir">/</strong>plugins.sh <strong class="mp ir">/</strong>usr<strong class="mp ir">/</strong>share<strong class="mp ir">/</strong>jenkins<strong class="mp ir">/</strong>ref<strong class="mp ir">/</strong>plugins.txt<br/> <br/> # add the jenkins user to the docker group so that sudo is not required to run docker commands<br/> <strong class="mp ir">RUN </strong>groupmod <strong class="mp ir">-</strong>g 1026 docker <strong class="mp ir">&amp;&amp; </strong>gpasswd <strong class="mp ir">-</strong>a jenkins docker<br/> <strong class="mp ir">USER </strong>jenkins</span></pre><p id="f175" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦你看到文件像这样分解，命令并不真的那么难或复杂。</p><h2 id="cad8" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">图像与容器</h2><p id="7102" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">Docker image和Docker container这两个术语有时可以互换使用，但它们不应该互换，它们指的是两种不同的东西。</p><p id="5a82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Docker <strong class="jw ir">映像</strong>是可执行包，包含运行应用程序所需的一切——代码、运行时、库、环境变量和配置文件。</p><p id="5e53" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Docker <strong class="jw ir"> containers </strong>是一个映像的运行时实例——映像在执行时在内存中变成的样子(也就是说，一个带有状态的映像，或者一个用户进程)。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nn"><img src="../Images/7899857ae3b211a4812433438b87af27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ef2uxCnIkF0PqLGxYqV2gA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">码头集装箱的例子。每一个都来自一个特定的Docker图像。</figcaption></figure><p id="2b07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">简而言之，Docker映像保存了Docker文件的快照，Docker容器是基于Docker映像中包含的指令的Docker映像的运行实现。</p><p id="eaaa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">明白了吗？酷毙了。</p><h2 id="3175" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">Docker引擎命令</h2><p id="f5cf" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">一旦编写了Docker文件，就可以构建Docker映像并运行Docker容器。所有这些都由我之前简单介绍过的Docker引擎负责。</p><p id="5e6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用户可以通过Docker CLI与Docker引擎交互，Docker CLI与Docker REST API对话，Docker REST API与长期运行的Docker守护进程(Docker引擎的核心)对话。下面是一幅插图。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bc8850e87674e2401b12a57cd52ec5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*MYX0ClbWoitxS0RNUVvj8A.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">CLI使用Docker REST API通过脚本或直接CLI命令来控制Docker守护进程或与之交互。许多其他Docker应用程序也使用底层API和CLI。</figcaption></figure><p id="4c1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是您在使用单个docker文件的大部分时间里将从命令行运行的命令。</p><ul class=""><li id="b8f3" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker build</code> —从Dockerfile文件构建图像</li><li id="3206" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker images</code> —显示该机器上的所有Docker图像</li><li id="d788" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker run</code> —启动容器并运行该容器中的任何命令</li><li id="b2a8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker run</code>有多种选择，包括</li><li id="6fe9" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">-p</code> —允许您指定主机和Docker容器中的端口</li><li id="eac7" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">-it</code>—在容器开始运行后打开一个交互终端</li><li id="3746" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">-v</code> —将卷绑定挂载到容器</li><li id="cbc8" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">-e</code> —设置环境变量</li><li id="ab51" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">-d</code> —以守护模式启动容器(它在后台进程中运行)</li><li id="4f5d" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker rmi</code> —删除一个或多个图像</li><li id="cc0a" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker rm</code> —移除一个或多个容器</li><li id="7b3a" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker kill</code> —终止一个或多个运行中的容器</li><li id="5d11" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker ps</code> —显示正在运行的容器列表</li><li id="1a1e" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker tag</code> —用别名标记图像，以便以后引用(有利于版本控制)</li><li id="4725" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><code class="fe mm mn mo mp b">docker login</code> —登录Docker注册表</li></ul><p id="609a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些命令可以以多得数不清的方式组合在一起，但这里有几个Docker命令的简单示例。</p><p id="d2e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mm mn mo mp b">docker build -t user1/node-example .</code></p><p id="fdeb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这告诉Docker:从根级别(<code class="fe mm mn mo mp b"> . </code>)的Docker文件中构建(<code class="fe mm mn mo mp b">build</code>)图像，并将其标记为<code class="fe mm mn mo mp b">user1/node-example</code>。不要忘记句号——这是Docker知道在哪里寻找Docker文件的方法。</p><p id="3b12" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mm mn mo mp b">docker run -p 3003:8080 -d user1/node-example</code></p><p id="0107" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这告诉Docker运行(<code class="fe mm mn mo mp b">run</code>)构建并标记为<code class="fe mm mn mo mp b">user1/node-example</code>的映像，公开主机上的端口3003，并在Docker容器中查找端口8080(<code class="fe mm mn mo mp b">-p 3003:8080</code>，并作为后台守护进程启动该进程(<code class="fe mm mn mo mp b">-d)</code>)。</p><p id="244f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是使用Docker CLI运行命令的简单之处。再一次，<a class="ae ml" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>做得很好。</p><h2 id="25af" class="lg lh iq bd li lj lk dn ll lm ln dp lo kf lp lq lr kj ls lt lu kn lv lw lx ly bi translated">结论和第二部分:Docker写作</h2><p id="2b97" class="pw-post-body-paragraph ju jv iq jw b jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr ij bi translated">现在你已经看到了Docker的冰山一角。它是一个轻量级的、隔离的运行时环境，被称为“容器”,在docker文件的帮助下，你可以按照你喜欢的任何方式启动和配置它。</p><p id="0314" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请继续关注这个三部分系列的<a class="ae ml" rel="noopener ugc nofollow" target="_blank" href="/docker-102-docker-compose-6bec46f18a0e">第二部分</a>，在这里我将深入介绍Docker Compose工具，它让您只需一个文件和一个启动命令就可以配置和运行多个应用程序。这真是酷毙了。</p><p id="95f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢您的阅读，我希望这能让您更好地了解Docker的基础知识及其强大功能。掌声非常感谢！</p><p id="8af5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</strong></p><ul class=""><li id="1b5a" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><a class="ae ml" href="https://medium.com/@paigen11/react-svg-images-and-the-webpack-loader-to-make-them-play-nice-2d177ae34d2b" rel="noopener"> React，SVG图像和Webpack加载器，使它们播放得更好</a></li><li id="7392" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ml" href="https://medium.com/@paigen11/javascript-array-methods-to-make-you-a-better-developer-4ce42052d54c" rel="noopener"> JavaScript数组方法让你成为更好的开发者</a></li><li id="efcf" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated"><a class="ae ml" href="https://medium.com/@paigen11/what-is-graphql-really-76c48e720202" rel="noopener">graph QL到底是什么？</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="8702" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">参考资料和更多资源:</strong></p><ul class=""><li id="ec32" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">https://www.docker.com/what-docker</li><li id="6a3a" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">Docker是什么？https://opensource.com/resources/what-docker</li><li id="5123" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">Dockerfile文档:<a class="ae ml" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/builder/</a></li><li id="9b20" class="ks kt iq jw b jx lb kb lc kf ld kj le kn lf kr kx ky kz la bi translated">码头工人运行参考:<a class="ae ml" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/run/</a></li></ul></div></div>    
</body>
</html>