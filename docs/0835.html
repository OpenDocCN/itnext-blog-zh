<html>
<head>
<title>Updating an SQL Database Schema using Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js更新SQL数据库模式</h1>
<blockquote>原文：<a href="https://itnext.io/updating-an-sql-database-schema-using-node-js-6c58173a455a?source=collection_archive---------0-----------------------#2018-06-06">https://itnext.io/updating-an-sql-database-schema-using-node-js-6c58173a455a?source=collection_archive---------0-----------------------#2018-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/16265db8c6e691c69a4cbdaf17622cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C11_TySd569To_hPQlwoyA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">数据库迁移</figcaption></figure><div class=""/><p id="81f9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">许多Node.js项目利用NoSQL数据库来满足持久层组件的需求。只要逻辑支持新的数据定义，NoSQL数据库的开发人员就不需要太担心影响应用程序的数据模型变化。</p><h2 id="e47d" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">问题是</h2><p id="921d" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">然而，许多项目仍然更适合使用关系数据库，如MySQL或Postgres。与NoSQL不同，关系数据库模式的更改需要在数据库服务器上进行管理，这与代码是分开的。这通常会导致以下问题:</p><ul class=""><li id="d354" class="mb mc ji kh b ki kj km kn kq md ku me ky mf lc mg mh mi mj bi translated">开发人员和系统之间的数据库模式状态变得不一致</li><li id="141e" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc mg mh mi mj bi translated">进行更改需要人工操作，并且实时应用程序可能会停机</li><li id="0107" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc mg mh mi mj bi translated">在团队中维护一个项目变得很困难，因为模式不容易共享</li></ul><h2 id="d3c0" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">解决方案</h2><p id="1826" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">数据库迁移是在各种状态之间转换数据的过程，无需任何人工干预。这个过程将允许我们跟踪模式更新之间的变化。</p><p id="b115" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将利用一个名为<a class="ae mp" href="https://github.com/db-migrate/node-db-migrate" rel="noopener ugc nofollow" target="_blank"> node-db-migrate </a>的开源框架。无论是构建简单的控制台应用程序还是复杂的API，该框架都可以用来管理数据库模式的更改。本文将使用一个简单的LoopBack 4应用程序来展示这个框架。</p><p id="1c4c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mp" href="https://medium.com/@miki_94094/getting-started-with-loopback-4-c5d12cd84d0a" rel="noopener"> <em class="mq">阅读此文开始使用LoopBack 4。</em> </a></p><h1 id="11c8" class="mr le ji bd lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh bi translated">入门指南</h1><p id="643b" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated"><em class="mq">本文假设您已经</em> <a class="ae mp" href="https://medium.com/@miki_94094/getting-started-with-loopback-4-c5d12cd84d0a" rel="noopener"> <em class="mq">创建了一个LoopBack 4应用程序</em> </a> <em class="mq">，或者已经在一个现有的Node.js项目中工作。</em></p><h2 id="ab9e" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">装置</h2><p id="71f3" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">node-db-migrate框架包括一个简洁的CLI工具，我们可以用它来管理数据库迁移脚本。我们可以使用以下命令在我们的计算机上全局安装它:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="951b" class="ld le ji nn b gy nr ns l nt nu">npm install -g db-migrate</span></pre><p id="5334" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mq">确保您位于Node.js应用程序的工作目录中。</em></p><p id="8a03" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将管理一个MySQL数据库模式。node-db-migrate有各种包，负责连接到各种数据库引擎，比如MySQL。为了使用node-db-migrate管理MySQL数据库，我们需要在项目中安装以下包:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="3a00" class="ld le ji nn b gy nr ns l nt nu">npm install --save db-migrate-mysql</span></pre><p id="937c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将安装db-migrate-mysql node_module并跟踪<em class="mq"> package.json </em>文件中的依赖版本。</p><h2 id="e441" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">配置</h2><p id="3bbc" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">我们需要告诉node-db-migrate框架如何连接我们的数据库。我已经安装了一个本地MySQL服务器，并创建了一个名为“payment_api”的模式。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/52963360dd47879af96b4fefe5b12dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVzkLMnfNFBVO4rSajYKlw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">使用UTF8排序规则在Mac上使用MySQL Workbench创建新模式</figcaption></figure><p id="f126" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mp" href="https://stackoverflow.com/questions/45141673/what-exactly-is-database-schema" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jj"> <em class="mq">模式</em> </strong> </a> <em class="mq">:描述数据库中对象的全部集合的定义。我们称之为MySQL服务器上的数据库。<br/> </em> <a class="ae mp" href="https://dev.mysql.com/doc/refman/8.0/en/charset-general.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh jj"> <em class="mq">排序规则</em> </strong> </a> <em class="mq">:排序规则是比较一个字符集中字符的一组规则。我们使用utf8默认排序规则，以便在我们的应用程序中支持广泛的字符集。</em></p><p id="7dcd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们在本地MySQL服务器上有了一个数据库模式，我们可以告诉node-db-migrate如何连接它。默认情况下，node-db-migrate将在项目的根目录中查找名为<em class="mq"> database.json </em>的文件。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/c051798c4160270dbfb67c759cd3eafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mYiSvtcZ-pTHvRjp-CgNA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">根项目目录中的新database.json文件</figcaption></figure><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="a894" class="ld le ji nn b gy nr ns l nt nu">{<br/>  "dev": {<br/>    "driver": "mysql",<br/>    "host": "localhost",<br/>    "port": "3306",<br/>    "user": "root",<br/>    "password": "root",<br/>    "database": "payment_api"<br/>  }<br/>}</span></pre><p id="0382" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mq"> database.json </em>文件包含一个json对象，该对象具有一个名为<strong class="kh jj"><em class="mq">【dev】</em></strong>的属性。根据node-db-migrate文档，默认情况下，框架将使用名为“dev”或“development”的对象。在运行我们的迁移时，这可能会被重写或传入。这在为具有不同配置的各种数据库实例配置迁移时也很有帮助，这将在以后的文章中看到。</p><p id="68bc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">配置属性是不言自明的。唯一值得一提的是<strong class="kh jj"> <em class="mq">【驱动】</em> </strong>属性。我们使用<strong class="kh jj"><em class="mq">【MySQL】</em></strong>作为属性值，这将向node-db-migrate框架表明它需要使用我们之前安装的<em class="mq"> db-migrate-mysql </em> npm包来连接数据库。</p><p id="427f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您错过了这一步，稍后您可能会看到以下错误消息:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="48ba" class="ld le ji nn b gy nr ns l nt nu">[ERROR] Error: No such driver found, please try to install it via npm install db-migrate-mysql or npm install -g db-migrate-mysql</span></pre><p id="4963" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mq">建议不要使用-g，而是使用-s标志来保存项目的package.json文件中的db-migrate-mysql依赖项。</em></p><h2 id="5091" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">创建新的迁移脚本</h2><p id="9cef" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">我们可以通过运行以下命令来创建新的迁移脚本:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="2596" class="ld le ji nn b gy nr ns l nt nu">db-migrate create user</span><span id="7950" class="ld le ji nn b gy nx ns l nt nu"><em class="mq">[INFO] Created migration at /projects/payment-api/migrations/20180606161337-user.js</em></span></pre><p id="03c6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">迁移脚本代表数据库的新版本或状态。调用上述命令后，将创建一个新目录，其中包含一个新的。js文件。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/e4dc657f17486908b43a1a1f9a18c9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8AY8S-hilB-PUefJbTevQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">新的迁移脚本(数据库模式版本)</figcaption></figure><p id="23cc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该文件以日期时间戳为前缀，后跟我们传递给db-migrate create命令<em class="mq">用户</em>的名称。</p><h2 id="27bb" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">探索迁移脚本</h2><p id="3df7" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">每个迁移框架通常都有两个函数，我们可以用来实现向上<em class="mq">和向下<em class="mq">的迁移</em>和</em>。</p><p id="82a1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mq"> Up </em>:包含向前移动数据库的代码，或者<em class="mq"> up，</em>到下一个数据库版本。<br/> <em class="mq">下移</em>:包含向后移动数据库的代码，或者<em class="mq">下移</em>，到先前的数据库版本，即<strong class="kh jj">回滚！</strong></p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="10b7" class="ld le ji nn b gy nr ns l nt nu">exports.up = function(db, callback) {<br/>  return null;<br/>};</span><span id="8925" class="ld le ji nn b gy nx ns l nt nu">exports.down = function(db, callback) {<br/>  return null;<br/>};</span></pre><p id="0c55" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这两个函数都传入一个已经连接的<em class="mq"> db </em>实例，该实例通过node-db-migrate框架使用的<em class="mq"> database.json </em>配置文件来处理。这些函数还传入第二个回调参数，这个参数在生成脚本后并不明显(只有在研究了文档后才明显)。我已经将它包含在上面的代码片段中。包含回调参数很重要，因为我们的迁移脚本是异步的。代码需要在完成数据库操作后回调到node-db-migrate框架。</p><h2 id="325f" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">创建新的用户表</h2><p id="ca51" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">让我们使用迁移脚本创建一个新表。<a class="ae mp" href="https://db-migrate.readthedocs.io/en/latest/API/SQL/" rel="noopener ugc nofollow" target="_blank">文档概述了所有可用的SQL操作函数</a>。我们将使用<em class="mq"> db#createTable </em>和<em class="mq"> db#dropTable </em>函数。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="0df3" class="ld le ji nn b gy nr ns l nt nu">exports.up = function(db, callback) {</span><span id="0aa9" class="ld le ji nn b gy nx ns l nt nu">  db.createTable('user', {<br/>    id: {<br/>      type: 'int',<br/>      primaryKey: true<br/>    },<br/>    full_name: {<br/>      type: 'string',<br/>      length: 40<br/>    },<br/>    dob: {<br/>      type: 'date'<br/>    },<br/>    email: {<br/>      type: 'string',<br/>      length: 50<br/>    },<br/>  }, function(err) {<br/>    if (err) return callback(err);<br/>    return callback();<br/>  });</span><span id="8008" class="ld le ji nn b gy nx ns l nt nu">};</span><span id="a5d0" class="ld le ji nn b gy nx ns l nt nu">exports.down = function(db, callback) {</span><span id="b130" class="ld le ji nn b gy nx ns l nt nu">  db.dropTable('user', callback);</span><span id="0c81" class="ld le ji nn b gy nx ns l nt nu">};</span></pre><p id="a86e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们向前移动数据库版本时，我们的代码应该创建一个新表，而当恢复时，应该删除该表。让我们来测试一下。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d9a4" class="ld le ji nn b gy nr ns l nt nu">db-migrate up</span><span id="7813" class="ld le ji nn b gy nx ns l nt nu">[INFO] Processed migration 20180606161337-user<br/>[INFO] Done</span></pre><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1a6fc671b92c8944e0984e394e8c563e.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*Vc2mpqUFQ007xOTrWYXdig.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">成功执行db-migrate up命令后的新用户表</figcaption></figure><h2 id="8c30" class="ld le ji bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">迁移表？</h2><p id="fcfe" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">node-db-migrate框架跟踪哪些脚本运行了一个<em class="mq">迁移</em>表。这将禁止同一个脚本运行两次。我们可以在表上运行一个简单的<em class="mq"> SELECT </em>查询来查看下面的结果。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a36efd01cc021c82be14ad194ce4fb38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*828gvR62XhLWSIrLs7K2Sg.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">跟踪我们的用户迁移脚本的单行</figcaption></figure><p id="2057" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">再次运行<em class="mq"> db-migrate up </em>将导致以下终端输出:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="de32" class="ld le ji nn b gy nr ns l nt nu">[INFO] No migrations to run<br/>[INFO] Done</span></pre><p id="53ce" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还可以尝试恢复我们的数据库更改，以测试出<em class="mq"> down </em>函数。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d62e" class="ld le ji nn b gy nr ns l nt nu">db-migrate down</span><span id="7ed8" class="ld le ji nn b gy nx ns l nt nu">[INFO] Defaulting to running 1 down migration.<br/>[INFO] Processed migration 20180606161337-user<br/>[INFO] Done</span></pre><p id="db2b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用户表应该已经被删除，我们的迁移表应该不包含任何行。太好了，我们可以直播了！</p><h1 id="a8dd" class="mr le ji bd lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh bi translated">新要求</h1><p id="7c3b" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">应用程序已经成功部署，一切都在运行。几周之后，应用程序显然需要将<em class="mq">全名</em>分成<em class="mq">名</em>和<em class="mq">姓</em>属性。</p><p id="26cd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在使用数据库迁移之前，可以使用以下开发过程来完成这一更改:</p><ol class=""><li id="0743" class="mb mc ji kh b ki kj km kn kq md ku me ky mf lc ob mh mi mj bi translated">登录到实时MySQL服务器</li><li id="298f" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc ob mh mi mj bi translated">运行几个SQL命令来添加、删除和/或更改表和列</li><li id="7da1" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc ob mh mi mj bi translated">部署新的应用程序代码</li><li id="a6a7" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc ob mh mi mj bi translated">重启服务器</li></ol><p id="7a7f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个简单的例子，只需要运行最少的SQL，但仍然为简单的人为错误敞开了大门。在已部署的服务器上完成这一更改后，每个团队成员还需要手动更新他们的数据库模式，然后才能继续他们的日常开发工作。很明显，这会很快导致一个不可维护的项目。</p><p id="e2c4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，我们使用node-db-migrate跟踪了我们的数据库模式。做出改变很简单:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="e2fd" class="ld le ji nn b gy nr ns l nt nu">db-migrate create update-user</span><span id="08b7" class="ld le ji nn b gy nx ns l nt nu">[INFO] Created migration at /payment-api/migrations/20180606164321-update-user.js</span></pre><p id="1dc5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们希望应用以下更改:</p><ol class=""><li id="51e7" class="mb mc ji kh b ki kj km kn kq md ku me ky mf lc ob mh mi mj bi translated">添加名为<em class="mq"> firstname </em>的新列</li><li id="fdb5" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc ob mh mi mj bi translated">添加一个名为<em class="mq">姓氏</em>的新列</li><li id="eb3c" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc ob mh mi mj bi translated">将所有现有数据从<em class="mq"> full_name </em>列移动到单独的<em class="mq"> firstname </em>和<em class="mq"> lastname </em>列<em class="mq">(这将在以后的文章中更详细地探讨，因为现在我们将只关注模式定义更新)。</em></li><li id="9e79" class="mb mc ji kh b ki mk km ml kq mm ku mn ky mo lc ob mh mi mj bi translated">删除名为<em class="mq"> full_name </em>的旧列</li></ol><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="617e" class="ld le ji nn b gy nr ns l nt nu">exports.up = function (db, callback) {</span><span id="b5ac" class="ld le ji nn b gy nx ns l nt nu">  db.addColumn('user', 'firstname', {<br/>    type: 'string',<br/>    length: 50<br/>  }, function(err) {<br/>    if (err) return callback(err);<br/>    <br/>    db.addColumn('user', 'lastname', {<br/>      type: 'string',<br/>      length: 50<br/>    }, function(err) {<br/>      if (err) return callback(err);</span><span id="9d29" class="ld le ji nn b gy nx ns l nt nu">      db.removeColumn('user', 'full_name', callback);<br/>    });<br/>  });</span><span id="587f" class="ld le ji nn b gy nx ns l nt nu">};</span><span id="5186" class="ld le ji nn b gy nx ns l nt nu">exports.down = function (db, callback) {</span><span id="fd0d" class="ld le ji nn b gy nx ns l nt nu">  db.addColumn('user', 'full_name', {<br/>    type: 'string',<br/>    length: 50<br/>  }, function(err) {<br/>    if (err) return callback(err);<br/>    <br/>    db.removeColumn('user', 'lastname', function(err) {<br/>      if (err) return callback(err);<br/>      db.removeColumn('user', 'firstname', callback)<br/>    });<br/>  });</span><span id="0781" class="ld le ji nn b gy nx ns l nt nu">};</span></pre><p id="61a0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="mq">为了简单起见，我们跳过了从</em> <strong class="kh jj"> <em class="mq">全名</em> </strong> <em class="mq">到</em> <strong class="kh jj"> <em class="mq">名字</em> </strong> <em class="mq">和</em> <strong class="kh jj"> <em class="mq">姓氏</em> </strong> <em class="mq">的实际数据迁移。这将在后面的文章中探讨。</em></p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="b084" class="ld le ji nn b gy nr ns l nt nu">db-migrate up</span><span id="83ae" class="ld le ji nn b gy nx ns l nt nu">[INFO] Processed migration 20180606161337-user<br/>[INFO] Processed migration 20180606164321-update-user<br/>[INFO] Done</span></pre><p id="dfc1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用户表现在应该反映了我们数据库的最新版本。</p><h1 id="591e" class="mr le ji bd lf ms mt mu li mv mw mx ll my mz na lo nb nc nd lr ne nf ng lu nh bi translated">结论</h1><p id="0181" class="pw-post-body-paragraph kf kg ji kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">本文探讨了开发人员在使用MySQL等关系数据库时面临的一些问题。这些问题可以通过简单的数据库迁移脚本来解决，在本例中由node-db-migrate框架管理。迁移脚本可以被签入到您最喜欢的版本控制系统中，并像我们跟踪代码版本更新一样被跟踪。</p></div></div>    
</body>
</html>