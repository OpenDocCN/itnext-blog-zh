<html>
<head>
<title>Using ‘kubectl explain’ for Custom Resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对自定义资源使用“kubectl explain”</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-kubectl-explain-9d703396cc8?source=collection_archive---------1-----------------------#2018-07-27">https://itnext.io/understanding-kubectl-explain-9d703396cc8?source=collection_archive---------1-----------------------#2018-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9cb9" class="pw-subtitle-paragraph jo ip iq bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">目标:探索是否可以使用“kubectl explain”来发现关于定制资源的静态信息</h2></div><p id="7617" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最近，我们一直致力于构建一个Kubernetes聚合API服务器，帮助发现集群中关于T2定制资源的信息。例如，关于自定义资源的静态信息可以是—可以对其执行哪些操作，或者公开哪些可配置的参数以及如何修改这些参数。关于自定义资源的动态信息的例子可以是——哪些本地Kubernetes资源包含自定义资源的特定实例及其状态。</p><p id="d113" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为了构建这个服务器，我们一直在研究“kubectl explain”命令的工作流，因为它似乎是一个很好的起点，可以用来研究我们是否可以使用它来支持发现定制资源的静态信息。这篇文章首先介绍了“kubectl explain”是如何工作的。然后，我们将分析它是否可以用于我们的用例。</p><p id="9cc6" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">库贝克解释输出源</strong></p><p id="ce25" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">kubectl explain 命令用于显示关于Kubernetes资源(如pod)的文档。</p><p id="1a1c" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">例子</p><p id="e62c" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"># kubectl解释窗格</p><p id="cade" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该命令输出显示的信息来自Pod的OpenAPI规范。所有类型的OpenAPI规范都是由主API服务器在启动时生成的，并由它在内存中维护。下面我们解释这个过程的细节。</p><h2 id="28fd" class="le lf iq bd lg lh li dn lj lk ll dp lm kp ln lo lp kt lq lr ls kx lt lu lv lw bi translated">库贝克的幕后解说</h2><p id="e009" class="pw-post-body-paragraph kg kh iq ki b kj lx js kl km ly jv ko kp lz kr ks kt ma kv kw kx mb kz la lb ij bi translated">kubectl explain的工作包括两个阶段。第一阶段发生在主API服务器启动时。在这个阶段，OpenAPI规范在内存中构建和维护，以服务于kubectl explain调用。第二阶段是实际的“kubectl explain”命令执行。在这个阶段，从服务器获取、解析和显示所请求资源的OpenAPI规范。</p><p id="bba2" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">阶段1:主API服务器启动并构建OpenAPI规范</strong></p><p id="81ac" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">此阶段分为两个步骤，如下图所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/d0e4572b1a89fe34ca7b17d0b80ad415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A48xZZcedyNUIRipw-IgnQ.jpeg"/></div></div></figure><p id="2dbe" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">第一步包括遍历注册的Kubernetes REST API资源端点，并为所有资源生成OpenAPI规范的内存表示。它始于genericapiserver.go的<a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go#L240" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> PrepareRun() </em> </a> <em class="ld">函数。</em>调用图包括kube-openapi/中的<a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/vendor/k8s.io/kube-openapi/pkg/builder/openapi.go#L196" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> buildPaths() </em> </a>方法../builder.go包。该方法使用注册到主API服务器的go-restful webservice端点，并构建OpenAPI规范的内存表示。有一种方法可以使用kubernetes/hack/update-OpenAPI-Spec . sh脚本将open API规范的内存表示下载为JSON文件。这将下载规范的json文件，并将其保存为kubernetes/api/openapi-spec文件夹中的swagger.json。</p><p id="41ed" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">第二步是让服务器准备好在一个众所周知的URL(例如/openapi/v2或/swagger.json)上提供生成的OpenAPI规范。</p><p id="5388" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">阶段2:执行“kubectl explain”命令来检索和解析OpenAPI规范</strong></p><p id="4b51" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在“kubectl explain”的输出中显示信息包括首先从众所周知的URL路径中检索它，然后解析它。下图显示了此过程中涉及的组件。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/0e7cb75d13fe59e400e39b43406a5ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RlBFtNcA6RMVOJ9EWPliyw.jpeg"/></div></div></figure><p id="1987" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">该过程从explain.go的<a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/explain.go#L73" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> NewCmdExplain()函数</em> </a>开始。它被传递一个对cmd util工厂对象的引用。factory_client_access.go包含<a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/util/factory_client_access.go#L175" rel="noopener ugc nofollow" target="_blank"> OpenAPISchema()函数</a>，它是使用<a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/discovery/discovery_client.go#L386" rel="noopener ugc nofollow" target="_blank"> client-go </a>检索OpenAPI规范的调用图的起点。然后使用<a class="ae lc" href="https://github.com/kubernetes/kubernetes/tree/master/pkg/kubectl/explain" rel="noopener ugc nofollow" target="_blank">解释包</a>中可用的各种函数解析检索到的规范。</p><h2 id="49de" class="le lf iq bd lg lh li dn lj lk ll dp lm kp ln lo lp kt lq lr ls kx lt lu lv lw bi translated">观察</h2><p id="e436" class="pw-post-body-paragraph kg kh iq ki b kj lx js kl km ly jv ko kp lz kr ks kt ma kv kw kx mb kz la lb ij bi translated">1)‘ku bectl explain’输出的一个问题是它没有显示一个对象的完整API路径。例如，“kubectl explain Pods”并没有显示Pods可以在api/core/v1/路径下访问。如果我们能得到这个完整的路径，那么使用‘kubectl get-raw’或curl命令就更容易了。</p><p id="7432" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这种信息在OpenAPI规范中是可用的，但是“kubectl explain”并没有显示出来。</p><p id="da3d" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果你已经下载了内存中的OpenAPI规范，你可以在swagger.json中的定义部分查找这个。Pod定义包含在“io.k8s.api.core.v1.Pod”下。显示为“kubectl explain”输出的信息是从该定义的描述字段中获得的。</p><p id="4db6" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">2)如果您想要更新一个本地Kubernetes资源(类型)的描述，您可以遵循这些步骤。</p><p id="2f71" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">-在适当的地方修改描述文本(对于Pod，在此处更改为<a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/api/core/v1/types.go#L3074" rel="noopener ugc nofollow" target="_blank"/></p><p id="3115" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">-运行kubernetes/hack/update-open API-spec . sh。</p><p id="efeb" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这个脚本启动主api服务器，它将生成OpenAPI规范，如上面的第1阶段部分所述。该脚本还将下载规范的json文件，并将其保存为kubernetes/api/openapi-spec文件夹中的swagger.json。</p><p id="405a" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">请注意，如果您正在使用Minikube，那么您的更改将不会反映在“kubectl explain”中。您必须从源代码运行Kubernetes集群，以使更改生效。您可以按照这里的<a class="ae lc" href="https://dzone.com/articles/easy-step-by-step-local-kubernetes-source-code-cha" rel="noopener ugc nofollow" target="_blank">所示的步骤</a>从源代码运行集群。</p><p id="45c8" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">3)<a class="ae lc" href="https://github.com/kubernetes/kube-openapi" rel="noopener ugc nofollow" target="_blank">kube-openapi库</a>包含用于构建open API规范的包和函数。该库提供了一个注释—“+k8s:openapi-gen = true”，建议用于为类型生成open API规范的<a class="ae lc" href="https://github.com/kubernetes/kube-openapi/issues/96" rel="noopener ugc nofollow" target="_blank">。一旦在类型上添加了这个注释，就可以使用kube-openapi包中的脚本来为该类型生成openapi规范文件。但是，Kubernetes的本地类型(如</a><a class="ae lc" href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/api/core/v1/types.go#L3076" rel="noopener ugc nofollow" target="_blank"> Pod </a>)上没有这种注释。本机类型的OpenAPI规范是在运行时通过解析API路径生成的，如上面的阶段1部分所述。</p><p id="8c65" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">结论</strong></p><p id="9ae9" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">似乎使用“kubectl explain”来发现自定义资源的静态信息的唯一方法是，该信息是否可以通过主API服务器的OpenAPI规范提供。这个规范是通过在主API服务器启动时遍历注册的API端点来构建的。该等级库之后不会重新生成。当使用自定义资源定义注册自定义资源时，主API服务器已经在运行。它不会重新启动，因此无法生成自定义资源的OpenAPI规范。当使用聚合API服务器方法使用APIService对象注册自定义资源时，类似的逻辑也适用。因此，似乎没有办法使用“kubectl explain”来发现关于定制资源的静态信息。</p><p id="64e2" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们正在考虑的一个选项是构建一个名为“explain”的自定义子资源，它可用于获取这些信息，如下所示:</p><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="19c1" class="le lf iq mp b gy mt mu l mv mw">kubectl get --raw <!-- -->/apis/kubediscovery.cloudark.io/v1/namespaces/default/Postgres/<br/>explain</span></pre><p id="c1b1" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里我们有“Postgres”作为自定义资源，我们将“explain”定义为它的子资源。</p><p id="33e3" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们的计划如下。我们将用“+k8s:openapi-gen=true”注释Postgres类型定义，并使用kube-openapi库中的脚本为Postgres类型生成openapi规范文件。我们将把这个文件作为一个ConfigMap加载，我们的“explain”子资源的自定义处理程序将检索这个文件，解析它，并显示所需的信息。</p><p id="ffba" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果你有任何其他想法/建议，我们渴望听到它们。</p><p id="6550" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你可以在Github <a class="ae lc" href="https://github.com/kubernetes/kube-openapi/issues/97" rel="noopener ugc nofollow" target="_blank">这里</a>追踪关于这个问题的讨论。</p><p id="9a23" class="pw-post-body-paragraph kg kh iq ki b kj kk js kl km kn jv ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae lc" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>