<html>
<head>
<title>Write clean(er) Components &amp; JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写清洁(er)组件和JSX</h1>
<blockquote>原文：<a href="https://itnext.io/write-clean-er-components-jsx-1e70491baded?source=collection_archive---------0-----------------------#2020-04-24">https://itnext.io/write-clean-er-components-jsx-1e70491baded?source=collection_archive---------0-----------------------#2020-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c9e37e1b576304026d0f99e3ae73159e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUwQGmM257dPpzJc3BErcQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卡莉·谢伊@ Unsplash—<a class="ae kc" href="https://unsplash.com/photos/1SAnrIxw5OY" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/1SAnrIxw5OY</a></figcaption></figure><p id="e076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我经常发现自己在忙着参加项目，因此不得不理解别人写的代码库。自然，代码伴随着许多错误和不良实践(在我看来)，我试图帮助人们理解如何做得更好。</p><p id="c9db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用React编码的困难之处在于，通常没有明确的最佳实践，存在相互矛盾的文章，并且很多内容都受到您是否真正理解JS本身的影响。有些人在深入理解JavaScript之前就做出了反应(这就是我们的行业和需求)。</p><h2 id="ccc7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">我决定写一个小指南，介绍我在真实项目中看到的案例和一些重构解决方案。</h2></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="7a94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说一个我经常看到的:</p><h1 id="d1ea" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">1.可选道具和空的{}物体</h1><p id="df91" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我遵循单一目的的组件哲学。这意味着我会避免复杂的数百行长的组件，并尽可能地将所有组件分解。</p><p id="962c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个简单的<code class="fe mx my mz na b">&lt;UserCard /&gt;</code>组件。<strong class="kf ir">该组件的唯一目的是接收一些用户对象并显示用户数据。</strong></p><p id="ecca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在项目中看到的:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0f29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个组件需要一个属性(用户),没有它它什么也做不了，但是这个属性不是必需的，默认值被设置为<code class="fe mx my mz na b">{}</code>,以避免一些<code class="fe mx my mz na b">Cannot access property 'name' of ...</code>错误。</p><p id="91ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这导致了混乱和非性能的ui，数据应该在空白的地方，因为访问一个不存在的对象的属性总是会给我们<code class="fe mx my mz na b">undefined</code>。<br/>如果你没有在<code class="fe mx my mz na b">UserCard</code>中提供任何后备值或任何框架加载(像LinkedIn或脸书所做的)，如果我们没有数据，就没有理由呈现这个组件——特别是如果里面有一些计算逻辑正在无缘无故地运行，没有值。</p><h2 id="1ca6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">那么什么是应该要求的，什么是不需要的呢？</h2><p id="7ce8" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">有时候你只需要停下来问问自己什么是最有意义的。</p><p id="0793" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个<code class="fe mx my mz na b">&lt;CurrencyConverter /&gt;</code>组件。它有三个支柱:</p><ul class=""><li id="20d6" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">值(我们要转换的数字)</li><li id="6c16" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">给定货币(我们要转换的货币)</li><li id="2636" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">目标货币(我们要转换到的货币)</li></ul><p id="1cf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以决定默认的<code class="fe mx my mz na b">givenCurrency</code>值为<code class="fe mx my mz na b">"EUR"</code>，因为我们位于德国，默认的<code class="fe mx my mz na b">targetCurrency</code>值为<code class="fe mx my mz na b">"USD"</code>，因为它是一种广泛使用的货币。</p><p id="9ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们的<code class="fe mx my mz na b">value</code>缺失，那么做任何转换都是没有意义的——那时根本不需要呈现组件。所以<code class="fe mx my mz na b">value</code>道具应该<strong class="kf ir">肯定是需要的。</strong></p><p id="55b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你应该使用类似的类比来问自己哪些道具是必需的，哪些不是，以防你还没有这样做。一个组件在那里做<em class="nv">某件事——</em><strong class="kf ir">不要让它白白渲染，万一少了什么东西</strong>。</p><h1 id="15ab" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">2.在父组件中调节渲染</h1><p id="6485" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">组件及其父组件应该是什么样子？</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1a13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们将把<code class="fe mx my mz na b">user</code>对象初始化为一个<code class="fe mx my mz na b">null</code>值。为什么？如果没有用户，运行像<code class="fe mx my mz na b">!user</code>这样的简单错误检查将返回<em class="nv">真</em>。对于空对象来说就不是这样了，你必须检查对象的键长度。我们通过不创建新的对象引用来节省一些内存空间，并且我们还对渲染进行了调整，使其仅在获得所需数据后才显示<code class="fe mx my mz na b">&lt;UserCard /&gt;</code>。</p><p id="ba94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有数据，也很容易显示微调器或消息。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5f54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">请记住，在父组件内部做这件事总是比在组件内部做更干净。</strong>我不知道有多少次，我看到一个带有某种逻辑的组件只是为了显示一个微调器或一条消息而被徒劳地执行。</p><p id="be47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">&lt;UserCard /&gt;</code>只负责显示用户数据。<code class="fe mx my mz na b">&lt;UserContainer /&gt;</code>有没有去取用户，决定渲染什么。这就是为什么<code class="fe mx my mz na b">&lt;UserContainer /&gt;</code>是显示后备值的正确位置。</p><h1 id="651a" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">3.别窝着了，早点回去吧</h1><p id="d106" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">即使在普通编程语言的范围内，嵌套的阅读和编辑也是一团糟——更不用说JSX了，它是JavaScript、HTML和<code class="fe mx my mz na b">{}</code>的混合。</p><p id="9a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您自己可能经常会发现看到类似的代码:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5ddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们怎样才能做得更好？</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们要对渲染进行调整——比如数据是否可用，页面是否加载——我们可以选择提前返回。</p><p id="d511" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就避免了嵌套，不要把HTML和JavaScript条件混在一起，代码对于来自不同背景或者没有技术背景的人来说也是可读的。</p><blockquote class="nw nx ny"><p id="d47e" class="kd ke nv kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">随着年龄和经验的增长，我越来越关心代码对任何人都是可读的。我们不仅仅是为电脑写的，也是为其他人写的。我们希望评审者理解我们的目标，而不用麻烦他们去破译我们的代码。我们希望我们的初级同事能够理解代码，捡起来并进一步研究它。如果从长远来看能节省我和其他人的时间，我愿意牺牲几行。</p></blockquote><h1 id="a5cb" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">4.尽量少用JSX写JavaScript</h1><p id="965a" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">正如我之前提到的，JSX有点棘手，因为它是多种语言的混合体。虽然高级开发人员理解组件内部发生的事情没有问题，但并不是每个人都这样。即使是我，作为一个大四学生，也经常发现别人的代码比它应该有的可读性差得多。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c4fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在处理一些外部<code class="fe mx my mz na b">&lt;Input /&gt;</code>的变化，用一个定制的处理器解析值，然后调用由<code class="fe mx my mz na b">&lt;CustomInput /&gt;</code>组件接收的<code class="fe mx my mz na b">onChange</code>属性。虽然这个例子可以工作，但是人们很容易迷失在<code class="fe mx my mz na b">return()</code>方法中。在现实世界中，有更多的元素和更复杂的JS逻辑，它们可以快速嵌套。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子长了2行，但是逻辑明显分开了。当我们返回我们的JSX时，我们没有必要用内联JavaScript逻辑使它变得沉重。<strong class="kf ir">在</strong> <code class="fe mx my mz na b">return()</code> <strong class="kf ir">里面应该很清楚你的HTML树是如何构造的——这使得在JSX内部使用嵌套对象和创建函数变得更加困难。</strong></p><h1 id="fe97" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">5.带有useEffect的useCallback</h1><p id="a38a" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">当钩子出现时，人们开始使用功能组件。他们需要在内部进行API调用，为此他们需要<code class="fe mx my mz na b">useEffect</code>生命周期挂钩。第一个版本的文档指出，提供空的依赖数组<code class="fe mx my mz na b">[]</code>将使钩子只在组件的挂载和卸载时运行。所以我们创建了自己的组件，并在<code class="fe mx my mz na b">useEffect</code>中到处使用<code class="fe mx my mz na b">[]</code>。然而，随后出现了<code class="fe mx my mz na b">exhaustive-deps</code>规则。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6fba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">人们很快就把它注释掉了，因为它对我们来说毫无意义。我们不习惯。但是现在，一年多过去了，这不是一个合理的借口，有些人仍然不停地评论这个规则，而不是试图理解它是如何工作的。</p><p id="2d3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">有些人没有意识到的是，方法</strong> <code class="fe mx my mz na b">handleUserFetch()</code> <strong class="kf ir">会在每次渲染时重新创建——或者组件中有多少次渲染。这就是为什么当我们需要调用一个<code class="fe mx my mz na b">useEffect</code>内部的方法时，我们使用<code class="fe mx my mz na b">useCallback</code>。这样我们就防止了<code class="fe mx my mz na b">handleUserFetch()</code>方法被重新创建(除非它的依赖关系改变),因此可以作为<code class="fe mx my mz na b">useEffect</code>钩子的依赖关系使用，而不会导致无限循环。</strong></p><p id="ac03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">演示的示例应该重写如下:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6f1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们提供<code class="fe mx my mz na b">handleUserFetch</code>作为useEffect的依赖项(因为它确实依赖于它),并将方法本身包装在<code class="fe mx my mz na b">useCallback</code>中。如果这个方法使用一个外部的<strong class="kf ir">参数</strong>，比如<code class="fe mx my mz na b">id</code>，比如<em class="nv">(在现实世界中可能会这样，因为你想获取一个特定的用户)</em>，<strong class="kf ir">这个参数将被列为方法的依赖项</strong>。如果参数改变了，唯一合理的是你想改变函数，然后再次调用它。</p><p id="d74f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你发现自己在<code class="fe mx my mz na b">useEffect</code>和<code class="fe mx my mz na b">useCallback</code>中循环，也许是时候看看<code class="fe mx my mz na b">useReducer</code>而不是<code class="fe mx my mz na b">useState</code>了，或者选择一个完全不同的方法。</p><p id="0aee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果您正在处理状态设置，您可以使用之前的状态作为函数的参数，如下所示:</p><pre class="nb nc nd ne gt oc na od oe aw of bi"><span id="a98f" class="lb lc iq na b gy og oh l oi oj">setUser(prevUser =&gt; {…})</span></pre><p id="2eea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您将当前状态作为处理<strong class="kf ir">状态更新</strong>的方法的依赖项来提供，您将为自己创建一个无限循环。</p><h1 id="8431" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">6.外包独立逻辑</h1><p id="a0f5" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">假设我们的组件内部有一个方法，它处理组件的一些变量，并为我们返回一个人工输出。示例:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1a18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着钩子的出现，很多人放弃了类组件，所以你经常会发现自己拥有一个结构相似的组件。</p><p id="2e7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个方法，就像前一个例子中的方法一样，在每次渲染时都会被重新创建——但是<strong class="kf ir">用</strong> <code class="fe mx my mz na b"><strong class="kf ir">useCallback</strong></code> <strong class="kf ir">包装这个方法是不必要的，因为我们不会在任何地方将它作为依赖项</strong>(一个useEffect钩子，或者一个子组件的<em class="nv"> prop </em>)提供。</p><p id="1649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们远离组件的范围，我们有一个函数<code class="fe mx my mz na b">getUserRole()</code>需要用户的角色作为输入，给我们一个用户最重要角色的人工输出。它不需要在组件内部定义(和重新创建)。</p><p id="3b07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件内部定义的许多逻辑可以外包，因为它并不真正与组件相关。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，函数可以在一个单独的文件中定义，并在任何需要的地方导入。尽早将逻辑从组件中抽象出来，可以让我们拥有更干净的组件和易于重用的实用功能。</p><blockquote class="nw nx ny"><p id="0e49" class="kd ke nv kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">也许我们希望在更多的地方显示用户最重要的角色——然后我们倾向于创建代码，在不同的地方返回用户的人类角色——甚至可能由不同的开发人员以不同的方式实现。缺乏这样的架构会使将来重构代码变得更加困难，比如角色发生了变化。这就是为什么我们应该尽早抽象，特别是如果我们在一个团队中工作，其他开发人员会在我们的代码上构建，甚至可能在没有很好理解它的情况下复制它。</p></blockquote><h1 id="31eb" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">7.放下内嵌样式</h1><p id="f943" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">一个我经常看到的。定义内联高级样式给了你两件事:</p><ul class=""><li id="316d" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">臃肿的代码</li><li id="3a29" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">无法在不使用<code class="fe mx my mz na b">!important</code>或一些适当的钻孔方法的情况下从外部改变CSS</li></ul><p id="c1e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CSS是<strong class="kf ir">不是</strong> JavaScript相关的语言。如果你来自React训练营，并且你第一次看到CSS被使用是在一个使用React的SPA中，这可能是你唯一一次使用它的经历。然而，CSS是一种与HTML协同工作的语言，根本不需要JS。<strong class="kf ir">你可以用JS动态地添加一个类到HTML标签中，并让CSS应用到这个类上</strong>。CSS对你所需要的一切都有现成的支持，而不需要嵌入到JavaScript中。</p><pre class="nb nc nd ne gt oc na od oe aw of bi"><span id="0436" class="lb lc iq na b gy og oh l oi oj">p { color: black }</span><span id="2621" class="lb lc iq na b gy ok oh l oi oj">p.accent { color: red }</span></pre><p id="e36e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每段都有黑色字体。每个有<code class="fe mx my mz na b">.accent</code>类的段落都有红色字体。</p><pre class="nb nc nd ne gt oc na od oe aw of bi"><span id="4b56" class="lb lc iq na b gy og oh l oi oj">#banner p.accent { color: blue }</span></pre><p id="533c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mx my mz na b">#banner</code>元素中带有类<code class="fe mx my mz na b">.accent</code>的段落是蓝色的。这一切都归结为理解CSS继承。如果我们内联定义<code class="fe mx my mz na b">p</code>颜色，我们将很难从外部接近它。这将引导我们创建做同样事情的不同组件——只是有不同的文本颜色。<strong class="kf ir">现在，当我们必须更改这些组件时，我们必须更改它们中的<em class="nv"> n </em>个，而不是一个。</strong></p><h2 id="cc27" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">膨胀的代码</h2><p id="1fae" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">让我给你链接一个工作的js fiddle:<a class="ae kc" href="https://jsfiddle.net/zonc3fvw/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/zonc3fvw/</a>。样式是内联的，代码如下所示:</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/d10a01baf1adc363badc2ad2d7e3142b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MOHX2YtVghAdKF8QYgM5g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">不太漂亮，是吗？</figcaption></figure><p id="b6fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们使用课堂方法:<a class="ae kc" href="https://jsfiddle.net/vzcLxwny/1/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/vzcLxwny/1/</a></p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/88fa19d437a8b4924f9233b0bbf1bcee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqgDoIR83KsCKhFw33y07Q.png"/></div></div></figure><p id="fc01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到的只是一个打理一切的CSS类。组件在我们的应用程序中呈现的次数越多，我们节省的空间就越多。我们也可以通过使用<strong class="kf ir">简单的CSS从外部改变<code class="fe mx my mz na b">&lt;Card /&gt;</code>的外观(<em class="nv">)，如果出于某种原因，设计者决定横幅卡中的标题应该是粉红色而不是黑色</em>。没有正确钻探，就没有反应。CSS的上下文改变以避免钻取，只是一个HTML类。</strong></p><blockquote class="nw nx ny"><p id="8271" class="kd ke nv kf b kg kh ki kj kk kl km kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated">注意:如果你喜欢CSS模块，也可以这样做，使用<code class="fe mx my mz na b">:global</code>前缀。也许我有一个<code class="fe mx my mz na b">.icon</code>类，我想改变<code class="fe mx my mz na b">button</code>中的<code class="fe mx my mz na b">.icon</code>的字体大小。我想保留所有其他的属性，所以创建一个新的组件只是复制98%的代码是没有意义的。</p></blockquote><p id="3cd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">曾经有人反驳我说<em class="nv">“你可以有条件地使用props来设计内联CSS的样式”</em>——你绝对可以。然而，你的组件不应该有10个处理CSS而不做其他事情的道具。这就是把JS和CSS混合在一起的地方，在这里你可以把自己挖得很深，以至于很难再爬上去。组件将变得臃肿，难以理解，难以编辑，你的CSS将变得越来越难以维护。</p><h1 id="c845" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">8.编写有效的HTML</h1><p id="872b" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我知道有人不喜欢，但是写HTML和CSS还是我们前端工程师的工作。React很有趣，hooks也是，Context也很棒，但最终我们会负责渲染HTML，让它看起来更好。</p><p id="2c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它的行为像一个按钮，它应该是一个<code class="fe mx my mz na b">button</code>，而不是一个可点击的div。如果它没有提交表单，那么它应该是<code class="fe mx my mz na b">type="button"</code>的。如果它应该根据文本大小扩展，它不应该有固定的宽度。</p><p id="e210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是40像素填充的，应该不是<code class="fe mx my mz na b">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</code>。</p><p id="e6fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是链接，应该是个<code class="fe mx my mz na b">&lt;a /&gt;</code>。</p><p id="5430" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对你们中的一些人来说，这是最基本的。但对其他人来说，却不是。如果你觉得自己精通React，但觉得自己的HTML技能有所欠缺，那就试着创建一个完全没有JS的网站——只有普通的HTML。通过HTML验证器运行它。这就是我们当年的做法(那时我10岁😄)</p><p id="e5dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将提供的一个例子是表单。我经常看到的是:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="974d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子有效..<em class="nv">不知何故</em>。这也是我经常在运送给客户的产品中看到的，当我看到它时，我总是有点发僵。</p><p id="e057" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在这个例子所做的是在<code class="fe mx my mz na b">&lt;input /&gt; </code>变更和<strong class="kf ir">提交</strong> <code class="fe mx my mz na b">&lt;button /&gt;</code>点击时更新<strong class="kf ir">名称</strong>值，它通过手动调用<code class="fe mx my mz na b">handleSubmit</code>提交数据。<strong class="kf ir">点击。</strong></p><p id="b58e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于普通用户来说没问题，但是对于使用<code class="fe mx my mz na b">Enter</code>键提交表单的人来说就不太好了。这对于HTML来说是不行的，因为它实际上并不知道表单正在被提交。我们有一个HTML &amp; JS支持，而不是设置奇怪的输入监听器:</p><pre class="nb nc nd ne gt oc na od oe aw of bi"><span id="5699" class="lb lc iq na b gy og oh l oi oj">&lt;form onsubmit="myFunction()"&gt;<br/>  Enter name: &lt;input type="text"&gt;<br/>  &lt;input type="submit"&gt;<br/>&lt;/form&gt;</span></pre><p id="f717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nv">盗自</em><a class="ae kc" href="https://www.w3schools.com/jsref/event_onsubmit.asp" rel="noopener ugc nofollow" target="_blank"><em class="nv">https://www.w3schools.com/jsref/event_onsubmit.asp</em></a></p><p id="dde1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React中使用<code class="fe mx my mz na b">onSubmit</code>的工作方式基本相同</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="dea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与前一个示例相比，我们必须更改的内容列表:</p><ul class=""><li id="b42c" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">输入需要包装在一个<code class="fe mx my mz na b">&lt;form /&gt;</code>元素中</li><li id="ad54" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">按钮需要是一个<code class="fe mx my mz na b">submit</code>类型=它寻找最近的父节点<code class="fe mx my mz na b">&lt;form /&gt;</code>并调用提交动作</li><li id="80ec" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">表单得到一个<code class="fe mx my mz na b">onSubmit</code>属性，这是提交动作(<em class="nv"> handleSubmit </em>)</li><li id="4169" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">提交动作(<em class="nv"> handleSubmit </em>)需要在收到事件时调用<code class="fe mx my mz na b">preventDefault()</code>。如果不这样做，页面将会刷新，就像传统的表单提交一样。</li></ul><p id="f4d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在表格<strong class="kf ir">正在提交</strong>。这是一个有效的表单，适用于任何提交触发器，而不仅仅是直接点击按钮。</p><h1 id="8b0c" class="mb lc iq bd ld mc md me lg mf mg mh lj mi mj mk lm ml mm mn lp mo mp mq ls mr bi translated">9.不要过度使用上下文</h1><p id="30b9" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">感觉现在有两个阵营Redux阵营和Context阵营。大多数教程都是为Redux编写的，这是初学者会找到和学习的第一个资源——对于他们的第一个项目来说，这通常是一个大材小用。误用Redux，它会咬你一口。很多人被咬了一口，转到了第二个阵营——语境一切。</p><p id="3ce7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">平衡永远是答案，这个案例也不例外。</p><p id="dcc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我见过很多应用程序利用了上下文<strong class="kf ir"/>——而且是以错误的方式。该应用程序被包装在15个不同的提供者中，这些提供者存储了一些状态和状态的设置者——现在让我们假设您有2个利用了<code class="fe mx my mz na b">SnackbarContext</code>的组件。其中一个显示Snackbar及其消息，另一个从外部触发Snackbar消息。</p><p id="54bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">现在，每次重新呈现带有消息的Snackbar时，我们的第二个组件也将重新呈现，该组件仅用于设置新的Snackbar消息。</strong>为什么？因为它与存储消息和消息设置器的上下文绑定在一起。现在我们还没有触及设置器，但是我们已经更新了消息，在提供者内部设置了一个新值，并且<strong class="kf ir">连接到它的一切</strong>都被重新呈现。用<code class="fe mx my mz na b">memo()</code>包装组件是行不通的——提供者的价值是不同的。</p><p id="3e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的应用程序中有100个地方都有这个。或者1000。这就是你想要的表现吗？</p><p id="3039" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时使用Redux是有意义的——特别是对于整个应用程序都需要并显示在不同屏幕上的数据——并且不需要从头到尾重新获取。我说Redux是作为一个<strong class="kf ir">状态管理——至于我自己，既然我发现了mobx-state-tree，我就不回去了。</strong></p><p id="4127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对上下文管理更感兴趣，因为这是另一个复杂的主题，您可以在本文底部找到一个演示文稿的链接。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="f4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你已经到达这里，谢谢你的阅读。我希望我能帮助你们中的一些人搞清楚什么是什么。我只有一个建议给你——质疑你的知识、你学到的方法和你的代码。思考并寻求自己是否能做得更好。跳出框框思考——忘记React和JavaScript，把项目作为一个整体来看，问问自己什么在架构方面最有意义。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="d63b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我想链接一些资源:</p><ul class=""><li id="ffa0" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><a class="ae kc" href="https://slides.com/djanoskova/react-context-api-create-a-reusable-snackbar#/" rel="noopener ugc nofollow" target="_blank">https://slides . com/djanoskova/react-Context-api-create-a-reusable-snack bar #/</a>—我为演示如何高效使用上下文而创建的上下文API演示</li><li id="dd4b" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">https://medium . com/@ ftangastani/mobx-state-tree-a-step-by-step-guide-for-react-apps-e 65716 a 219d 2—这是一篇非常棒的文章，以非常实用的方式展示了mobx-state-tree的基础知识</li><li id="6e72" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><a class="ae kc" href="https://github.com/facebook/react/issues/14920" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/issues/14920</a>—详尽的deps讨论</li></ul></div></div>    
</body>
</html>