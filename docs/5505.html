<html>
<head>
<title>How to create a ConfigSource for Quarkus that knows about existing properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为Quarkus创建了解现有属性的ConfigSource</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-a-configsource-for-quarkus-that-knows-about-existing-properties-1d6e95e7385e?source=collection_archive---------2-----------------------#2021-03-19">https://itnext.io/how-to-create-a-configsource-for-quarkus-that-knows-about-existing-properties-1d6e95e7385e?source=collection_archive---------2-----------------------#2021-03-19</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="66c9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们正在为短暂的环境(“Clowder”)构建一个机器，其中一个细节是该环境将提供不同的资源名称，而不是我们在application.properties中预期的名称</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gi gj km"><img src="../Images/4a2264028c088e6533b4703c399e57fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wtxtdt_LAIENYN89RT88AA.jpeg"/></div></div><figcaption class="ky kz gk gi gj la lb bd b be z dk translated">不是我们要求的名称(图片来自<a class="ae lc" href="https://pixabay.com/de/photos/scrabble-wort-schreiben-buchstaben-15546/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="1b2b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">例如，我们在application.properties中可能有以下条目</p><pre class="kn ko kp kq gu ld le lf lg aw lh bi"><span id="766f" class="li lj ir le b gz lk ll l lm ln"><strong class="le is">mp.messaging.outgoing.egress.topic</strong>=ingress</span></pre><p id="1023" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">因此，我们请求一个主题名称<em class="lo">入口</em>，但是环境可能为我们提供一个动态名称，例如<em class="lo">入口-123 </em>。这意味着我们需要动态地覆盖applications.properties中的设置</p><h2 id="82e8" class="li lj ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">关于微配置文件配置</h2><p id="42f9" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated"><a class="ae lc" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>在内部使用<a class="ae lc" href="https://github.com/eclipse/microprofile-config" rel="noopener ugc nofollow" target="_blank">Eclipse micro profile Config(MP-Config)</a>的<a class="ae lc" href="https://smallrye.io" rel="noopener ugc nofollow" target="_blank"> SmallRye </a>实现。MP-Config允许添加所谓的<a class="ae lc" href="https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc" rel="noopener ugc nofollow" target="_blank"> <em class="lo">配置源</em> </a>，这允许以可编程的方式从例如一个奇怪格式的文件或者甚至可能从一个中央存储库中提供配置对象。在一个以上的源具有某个键的情况下，配置引擎通过源的序数值确保确定的排序。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj ml"><img src="../Images/456f1b24c0bee71535d03b9885cf9bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*NcimyaFahfCOrxj0YQsNyQ.png"/></div></figure><p id="6df9" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">左边的例子显示了来自MicroProfile Config(黄色方框)和Quarkus(蓝色)的配置源。序数较高的源优先于序数较低的源。<br/>对键“A”的请求直接从系统属性配置源得到响应，从而覆盖application.properties中设置的值</p><p id="66ed" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">合乎逻辑的结论是添加一个序号大于250的配置源，它提供来自短暂环境的值，该环境以绿色显示，序号为270。对“c”的请求将由此源满足，而不是来自application.properties。</p><h2 id="57c0" class="li lj ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">棘手的部分</h2><p id="7ffd" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">在我们的例子中，仅仅添加一个新的源来读取和解析特殊文件的内容是不够的。这个特殊的文件没有我们需要的配置键，只有成对的请求值和替换值:</p><pre class="kn ko kp kq gu ld le lf lg aw lh bi"><span id="06c5" class="li lj ir le b gz lk ll l lm ln">"kafka": {<br/>  "topics": [<br/>    {<br/>      "name": "platform-tmp-12345",<br/>      "requestedName": "platform.notifications.ingress"<br/>    },<br/>    {<br/>      "name": "platform-tmp-666",<br/>      "requestedName": "platform.notifications.alerts"<br/>    }<br/>  ]<br/>},</span></pre><p id="071b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们要做的是在application.properties中找到给定键的配置值，然后在特殊文件中查找这个请求的名称，并返回新名称</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj mm"><img src="../Images/8d123f183cc765f540b4b29f9fb4e538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*NSQzI7QcHe0OXVheDk2FPg.png"/></div></figure><p id="539e" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">不幸的是，微配置文件配置中的配置源彼此并不了解。这意味着ClowderCS不能简单地调用<em class="lo"> getValue() </em>并从application.properties中获取值。</p><h2 id="6062" class="li lj ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">拯救SmallRye配置</h2><p id="1cd8" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">正如我在上面所写的，Quarkus正在使用<a class="ae lc" href="https://smallrye.io/docs/smallrye-config/index.html" rel="noopener ugc nofollow" target="_blank"> SmallRye实现</a>。这个实现允许通过一个<a class="ae lc" href="https://smallrye.io/docs/smallrye-config/config-sources/config-sources.html#_config_source_factory" rel="noopener ugc nofollow" target="_blank">工厂</a>构建新的配置源，这个工厂知道所有先前定义的配置源。这允许我在工厂中读取这些值，并将它们传递给我的新配置源:</p><pre class="kn ko kp kq gu ld le lf lg aw lh bi"><span id="b4c4" class="li lj ir le b gz lk ll l lm ln">@Override<br/>public Iterable&lt;ConfigSource&gt; <br/>      getConfigSources(ConfigSourceContext <strong class="le is">ctx</strong>) {<br/><br/>    Map&lt;String, ConfigValue&gt; <strong class="le is">exProp</strong> = new HashMap&lt;&gt;();<br/>    Iterator&lt;String&gt; stringIterator = <strong class="le is">ctx</strong>.iterateNames();<br/>    while (stringIterator.hasNext()) {<br/>        String key = stringIterator.next();<br/>        ConfigValue value = <strong class="le is">ctx</strong>.getValue(key);<br/>        <strong class="le is">exProp</strong>.put(key,value);<br/>    }<br/><br/>    return Collections.<em class="lo">singletonList</em>(<br/>          new ClowderConfigSource(..., <strong class="le is">exProp</strong>));</span></pre><p id="bb31" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">上下文<em class="lo"> ctx </em>允许迭代所有现有的键，并检索值，然后将这些值放入映射并传递。SmallRye Config确保非工厂定义的源在初始化发生前可用(<a class="ae lc" href="https://smallrye.io/docs/smallrye-config/index.html" rel="noopener ugc nofollow" target="_blank">完整文档</a>)。</p><p id="ec84" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在ConfigSource本身中，上面提到的转换就会发生。我不打算在这里讨论这个。完整的源代码可在<a class="ae lc" href="https://github.com/RedHatInsights/clowder-quarkus-config-source" rel="noopener ugc nofollow" target="_blank">https://github . com/red hat insights/clowder-quar kus-config-source</a>获得</p><p id="7a6f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">不过有一点要提的是，源代码中所有配置属性的可用性允许我们通过application.properties中的一个条目定义要读取的文件，然后可以通过environment或system属性再次覆盖它</p><pre class="kn ko kp kq gu ld le lf lg aw lh bi"><span id="b770" class="li lj ir le b gz lk ll l lm ln"><strong class="le is">%dev.clowder.file</strong>=/tmp/my-config.json<br/><strong class="le is">clowder.file</strong>=/prod/config.json<br/><strong class="le is">%test.clowder.file</strong>=src/test/resources/config.json</span></pre><p id="8ddb" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">(以%开头的条目是给定Quarkus 运行轮廓的<a class="ae lc" href="https://quarkus.io/guides/config#configuration-profiles" rel="noopener ugc nofollow" target="_blank">的覆盖)。</a></p><h2 id="f2b1" class="li lj ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">对应用程序透明</h2><p id="2f39" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">现在最后一部分是如何注册ConfigSource和ConfigSourceFactory。幸运的是，这是通过Java ServiceLoader接口实现的。名为<em class="lo">io . small rye . config . config source factory</em>的文件被放入<em class="lo"> META-INF/services/ </em>中，该文件提供了源代码的完全限定名称。</p><p id="0e47" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们将在多个应用程序中使用该源代码，并将其打包到自己的maven repo和jar文件中。Quarkus应用程序的开发人员必须做的唯一改变就是将这个jar包含到他们的应用程序中，这可以通过简单地添加一个依赖项来完成。</p><pre class="kn ko kp kq gu ld le lf lg aw lh bi"><span id="6620" class="li lj ir le b gz lk ll l lm ln">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.redhat.cloud.common&lt;/groupId&gt;<br/>  &lt;artifactId&gt;clowder-quarkus-config-source&lt;/artifactId&gt;<br/>  &lt;version&gt;0.1.1&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b78b" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">否则，它对他们是完全透明的。不需要修改任何一行代码。</p><h2 id="5dc9" class="li lj ir bd lp lq lr dn ls lt lu dp lv jz lw lx ly kd lz ma mb kh mc md me mf bi translated">大声喊出来</h2><p id="eb25" class="pw-post-body-paragraph jo jp ir jq b jr mg jt ju jv mh jx jy jz mi kb kc kd mj kf kg kh mk kj kk kl ik bi translated">非常感谢Roberto Cortez，他在开发过程中给了我很多帮助，并回答了我所有奇怪的问题。</p></div></div>    
</body>
</html>