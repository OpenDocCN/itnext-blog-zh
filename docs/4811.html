<html>
<head>
<title>Glorious Makefile: Building Your Static Website</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">辉煌的Makefile:构建您的静态网站</h1>
<blockquote>原文：<a href="https://itnext.io/glorious-makefile-building-your-static-website-4e7cdc32d985?source=collection_archive---------2-----------------------#2020-09-24">https://itnext.io/glorious-makefile-building-your-static-website-4e7cdc32d985?source=collection_archive---------2-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eb8dcdef38c63634129f15166705b7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8uQBZQrZAZ6Fx-xQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">托德·夸肯布什在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="496b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如今静态网站又开始流行了。它甚至还有一个名字:<a class="ae kc" href="https://jamstack.org/" rel="noopener ugc nofollow" target="_blank"> JAMStack </a>。经过多年的完善和发展，我们重新发现了一个事实:静态网站非常快。有时我们甚至高估了网站动态性的好处。即使我们需要它，也有很多好的前端javascript框架让我们下载JSON数据，只在浏览器中构建动态部分。</p><p id="1582" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，也有大量的工具来创建静态网站。你有<a class="ae kc" href="https://jekyllrb.com/" rel="noopener ugc nofollow" target="_blank">杰基尔</a><a class="ae kc" href="https://www.gatsbyjs.com/" rel="noopener ugc nofollow" target="_blank">盖茨比</a><a class="ae kc" href="https://gohugo.io/" rel="noopener ugc nofollow" target="_blank">雨果</a>等等。所有这些都是非常好的工具。但是今天我想向你展示如何用一个非常古老的学校工具来做这件事，这个工具叫做:<a class="ae kc" href="https://en.wikipedia.org/wiki/Make_(software)" rel="noopener ugc nofollow" target="_blank"> Make </a>。</p><p id="e369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不在乎解释，只是想看代码，你应该感到羞耻，但这里是要点。</p><h1 id="1ad5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么要制造？</h1><p id="5011" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几个原因。首先，Make是你可能已经拥有的经典工具之一。第一版于1976年发布。不需要安装一个新的工具，这反过来迫使你安装一个你不使用的编程语言。事实上，大多数Make都是建立在shell脚本之上的，您可能已经知道了。</p><p id="a4f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个原因是<strong class="kf ir">你会学到一些在很多情况下有用的东西</strong>，而不仅仅是建立静态网站。这是因为，虽然Make用法是为了特定目的，但是这个目的是非常通用的。您创建目标任务并组织它们之间的依赖关系。这是一个建立网站的虚拟例子:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="bd71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，如果你把它放在一个名为“Makefile”的目录中，那么在这个目录中，你可以使用命令<code class="fe mk ml mm mn b">make html</code>或<code class="fe mk ml mm mn b">make css</code>。但是你也可以使用命令<code class="fe mk ml mm mn b">make all</code>来构建HTML和CSS，因为在规范中，同一行冒号后面的是依赖关系。实际上我们甚至可以单独运行<code class="fe mk ml mm mn b">make</code>,因为没有参数，Make将默认它在文件中找到的第一个目标/任务。</p><p id="dd99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，Make的优点是它非常适合在每次迭代中只重建必要的东西。这是因为Make的工作方式是，对于每个目标，它比较依赖项和目标文件的修改时间，以了解目标是否需要构建。</p><p id="a776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">警告:为了让Make正常工作，您需要使用制表符来缩进。如果您使用空格，它将不起作用。如果在文本编辑器和展开标签中使用空格，请确保Makefiles有例外。下面是如何在Vim中设置它:</strong></p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="77b3" class="ms lc iq mn b gy mt mu l mv mw"><strong class="mn ir">autocmd</strong> FileType <strong class="mn ir">make</strong> setlocal <strong class="mn ir">noexpandtab tabstop=4 shiftwidth=4</strong></span></pre><h1 id="a81b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">制作一个静态网站项目</h1><p id="de07" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在让我们严肃起来。根据你的喜好随意改变任何东西，但是我们要做的是有2个目录，一个<code class="fe mk ml mm mn b">src</code>用于我们的源文件，一个<code class="fe mk ml mm mn b">build</code>用于我们生成的文件或静态资产。目录将会是完成的网站。</p><p id="91cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以添加这些目录和一个<code class="fe mk ml mm mn b">Makefile</code>，在其中您将从以下内容开始:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="6423" class="ms lc iq mn b gy mt mu l mv mw">SRC_DIR = src<br/>DST_DIR = build</span></pre><p id="0a4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你可以创建一些变量。注意，您可以在等号两边加上空格，这在shell脚本中是不可能的。</p><h1 id="60b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">制作一些CSS</h1><p id="d3a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们刚刚为两个主目录创建了占位符:源目录<em class="mx">和目的目录<em class="mx">和目的目录</em>。现在让我们再添加几个来构建我们的CSS文件。我们将认为我们所有的源文件都是SCSS文件，都在同一个层次上。我们的SCSS包含一个嵌套的<code class="fe mk ml mm mn b">includes</code>目录，文件以下划线开头。如果您不需要包含的文件，请随意简化代码。</em></p><p id="a425" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是目前为止的结构:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="cd9a" class="ms lc iq mn b gy mt mu l mv mw">./<br/>├── Makefile<br/>├── build/<br/>└── src/<br/>    └── scss/<br/>        ├── includes/<br/>        │   └── _inc.scss<br/>        └── main.scss</span></pre><p id="c9fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你显然可以有更多的SCSS文件和更多的包括。这是我们新的Makefile:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="a8ea" class="ms lc iq mn b gy mt mu l mv mw">SRC_DIR = src<br/>DST_DIR = build</span><span id="0192" class="ms lc iq mn b gy my mu l mv mw">CSS_DIR = $(DST_DIR)/css<br/>SCSS_DIR = $(SRC_DIR)/scss<br/>SCSS_INCLUDES_DIR = $(SCSS_DIR)/includes</span><span id="a387" class="ms lc iq mn b gy my mu l mv mw">SCSS_FILES = $(wildcard $(SCSS_DIR)/*.scss)<br/>CSS_FILES = $(patsubst $(SCSS_DIR)/%.scss, $(CSS_DIR)/%.css, $(SCSS_FILES))</span></pre><p id="a267" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，您可以看到如何基于以前的变量创建新的变量。名字只是被<code class="fe mk ml mm mn b"><strong class="kf ir">$(</strong>NAME<strong class="kf ir">)</strong></code> <strong class="kf ir"> </strong>包围。最复杂的部分是最后的两行。括号里的其实是宏。它们可以只是一个变量名，但是你也可以使用函数。<code class="fe mk ml mm mn b">wildcard</code>函数的作用与shell中的通配符相同，它将直接在SCSS目录中为您提供所有SCSS文件的数组。而<code class="fe mk ml mm mn b">patsubst</code>函数通过替换文件夹名和扩展名来生成要创建的CSS文件列表。它是这样工作的:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="c4ce" class="ms lc iq mn b gy mt mu l mv mw">$( patsubst pattern, replacement, text )</span></pre><p id="a040" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的文本是SCSS文件的列表。<code class="fe mk ml mm mn b">patsubst</code>应用于由空格分隔的每个“部分”(即本例中的每个文件名)。然后通过匹配原始模式中的占位符“%”，基于替换模式创建一个新列表。详见<a class="ae kc" href="https://www.gnu.org/software/make/manual/make.html#Functions" rel="noopener ugc nofollow" target="_blank">制作手册</a>。</p><p id="7090" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了CSS文件的列表，我们可以创建我们的第一个目标:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="00bc" class="ms lc iq mn b gy mt mu l mv mw">.PHONY: css<br/>css: $(CSS_FILES) ## Build all CSS files from SCSS</span></pre><p id="2dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要太担心第一线。您需要知道的是，大多数时候，默认情况下，要构建的目标被认为是文件或目录。稍后你会看到这个。但其他的只是一个动作的名字。典型的例子是“清洁”或“帮助”。其他的——比如这里——是代表一组文件的名称。这并不总是可能的，但你可能有一个名为“css”、“clean”或“help”的文件或目录。问题是，如果你运行它，它会寻找文件或目录，并检查“修改时间”，看看是否需要重新构建。</p><p id="65b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">带有<code class="fe mk ml mm mn b">.PHONY</code>的那一行告诉我们，具有指定名称的目标不是一个文件，并且没有“修改时间”可以检查。它应该总是被认为是“过时的”并运行。而当目标不在时。假冒，使检查的“修改时间”的文件。如果其中一个依赖项比目标更新，则重新构建目标，因为至少有一个依赖项在生成后发生了更改。</p><p id="eaaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免任何问题，通常总是声明<code class="fe mk ml mm mn b">.PHONY</code>任何不是文件的目标。</p><p id="b21d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，目标本身的行告诉您，您想要创建一个名为“css”的目标，它将所有CSS文件作为依赖项。这意味着要完成目标，必须创建所有的CSS文件。“#”后面的一切都只是注释。</p><p id="014a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们为这些CSS文件创建一个目标:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里发生了很多事情。首先要注意的是，模式替换也适用于目标。它是这样工作的:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="d230" class="ms lc iq mn b gy mt mu l mv mw"># Doing this</span><span id="6fff" class="ms lc iq mn b gy my mu l mv mw">$(CSS_DIR)/%.css: $(SCSS_DIR)/%.scss</span><span id="6500" class="ms lc iq mn b gy my mu l mv mw"># Is the same as doing this for every single <br/># CSS file in the directory.</span><span id="5188" class="ms lc iq mn b gy my mu l mv mw">$(CSS_DIR)/main.css: $(SCSS_DIR)/main.scss<br/>$(CSS_DIR)/resets.css: $(SCSS_DIR)/resets.scss<br/>$(CSS_DIR)/goodies.css: $(SCSS_DIR)/goodies.scss<br/># ...</span></pre><p id="e792" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，你在一行中写了许多规则/任务/目标。</p><p id="30b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加包含文件作为依赖项，因为我们不知道哪个SCSS文件使用哪个包含文件。因此，我们需要确保每次修改包含文件时都要重新构建CSS文件。这就是目标声明的工作方式。您是说，如果在构建目标之后修改了任何依赖项，那么您希望重新构建目标。</p><p id="4830" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后是Sass命令本身，这是构建目标的“配方”:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="0721" class="ms lc iq mn b gy mt mu l mv mw">sass --load-path=$(SCSS_INCLUDES_DIR) --style=compressed --scss $&lt; $@</span></pre><p id="6773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在食谱中，你可以使用已经有的宏，也可以使用一些特殊的宏。宏<code class="fe mk ml mm mn b">$@</code>是目标名称的占位符，在基于模式声明目标时很有用。宏<code class="fe mk ml mm mn b">$&lt;</code>是列表中第一个依赖项的占位符。本案中的SCSS档案。</p><p id="66a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我假设您不需要解释命令行参数。如果你有，你可以阅读<a class="ae kc" href="https://sass-lang.com/documentation/cli" rel="noopener ugc nofollow" target="_blank"> SASS命令行手册</a>。</p><p id="1f24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我在这里使用的是旧的基于Ruby的命令行。请注意，新的实现可能会有所不同。如果您使用不同的命令行参数，请阅读手册以确定命令行参数。</p><p id="20e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些都工作正常，但是它假设CSS文件的目录已经存在。让我们做一些更复杂的事情来确保在目录不存在时创建它。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a26b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为CSS目录本身创建一个目标。它没有依赖关系，因为它不需要任何东西。我们为CSS文件创建了一个新的依赖项。现在它需要目录存在。但是这个在“|”管道符号之后。管道符号后的从属关系意味着从属关系只需要存在。我们不需要检查一个“修改时间”。我总是看到这个特性用于目录。</p><p id="06ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果你有SCSS文件并运行<code class="fe mk ml mm mn b">make css</code>，你应该看到它为你构建了CSS文件。如果您第二次运行它而不更改任何文件，Make会告诉您一切都是最新的。到目前为止还不错。</p><p id="94df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，Make将打印它运行的所有命令。您可以在任何不想打印的命令前添加“@”。通常你不希望在运行之前打印一个<code class="fe mk ml mm mn b">echo</code>命令，因为它会打印两次。</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="7bda" class="ms lc iq mn b gy mt mu l mv mw">@echo Print only once please</span></pre><h1 id="e872" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">制作一些HTML</h1><p id="ba3b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我个人经常使用只有一个页面的简单设置，因为它是一个单页面应用程序。但是为了这个例子，让我们用<a class="ae kc" href="https://www.markdownguide.org/" rel="noopener ugc nofollow" target="_blank"> Markdown </a>文件构建许多HTML页面。</p><p id="cd7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个过程有点类似于我们对SCSS文件所做的。但是有一个主要的区别:它们可以在一个嵌套的层次结构中，而不仅仅是一个级别。至少这是我们正在建设的，因为这很有可能。</p><p id="4e18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从顶部的变量开始:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="0365" class="ms lc iq mn b gy mt mu l mv mw">MD_FILES = $(shell find $(SRC_DIR) -type f -name '*.md')<br/>HTML_FILES = $(patsubst $(SRC_DIR)/%.md, $(DST_DIR)/%.html, $(MD_FILES))</span></pre><p id="a9d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要子目录，因为HTML文件在根目录下。但是我们将使用一个新的宏函数来收集所有的降价文件。<code class="fe mk ml mm mn b">shell</code>宏函数非常简单，它需要一个shell命令来执行。这个程序使用命令<code class="fe mk ml mm mn b">find</code>获取所有可能嵌套的降价文件的列表。它们可以嵌套的事实是我们这次不使用<code class="fe mk ml mm mn b">wildcard</code>函数的原因，因为它不支持递归通配符，只支持Bourne Shell通配符。</p><p id="1eb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe mk ml mm mn b">patsubst</code>函数得到HTML文件的列表，就像我们对CSS文件所做的那样。一些目标的时间:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一切看起来很熟悉，因为过程与SCSS的一样，除了没有要创建的目录，我们使用<a class="ae kc" href="https://pandoc.org" rel="noopener ugc nofollow" target="_blank"> Pandoc </a>而不是<a class="ae kc" href="https://sass-lang.com" rel="noopener ugc nofollow" target="_blank"> Sass </a>。请注意<code class="fe mk ml mm mn b">--standalone</code>选项。如果你不这样做，Pandoc将不会创建一个有头和正文的独立的HTML文件，而是一个片段。</p><p id="c076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">去试试吧。运行<code class="fe mk ml mm mn b">make html</code>，它将创建你的HTML页面。</p><p id="4e0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好！现在，让我们为构建所有内容创建一个目标。这很容易。另一个名称及其从属关系:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="ec30" class="ms lc iq mn b gy mt mu l mv mw">.PHONY: all<br/>all: html css ## Build the whole website</span></pre><p id="0cf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以运行<code class="fe mk ml mm mn b">make all</code>了，它会构建所有的东西。我个人把这个作为第一目标，这样我就可以运行<code class="fe mk ml mm mn b">make</code>。如果它不在顶部，您仍然可以将其定义为默认目标，如下所示:</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="a763" class="ms lc iq mn b gy mt mu l mv mw">.DEFAULT_GOAL := all</span></pre><h1 id="d049" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">把它弄干净</h1><p id="ccc8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在是时候引入一个经典的Make目标来删除所有生成的文件并重新开始了:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0fa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是删除所有的HTML文件和整个CSS目录。当出现问题时，或者当您希望确保下次运行<code class="fe mk ml mm mn b">make</code>时一切都将重新构建时，通常会使用这种方法。</p><h1 id="0786" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">充分利用Pandoc</h1><p id="0f26" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">好的，我们有HTML文件，但是我们没有充分发挥Pandoc的潜力。你想创建带有页眉、页脚和所有内容的网页。让我们对其进行修改，并利用一些Pandoc特性:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0f89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们在源文件中添加了一个template.html文件。这样你就可以遵循你在动态网站上用过的模式。也就是说，每一页都要有一个模板，包括页眉和页脚之间的降价内容。</p><p id="54cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了做到这一点，我们使用Pandoc的模板语言。至少你将使用<code class="fe mk ml mm mn b">$body$</code>，它将包含你的降价文件的主体。请注意，我们已经删除了<code class="fe mk ml mm mn b">--standalone</code>选项，因为我们使用的是模板。</p><p id="5a14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要更多的变量，你可以根据你想做的事情以多种方式来实现。如果它是特定于构建的或全局的，那么您可以在命令行中使用类似于<code class="fe mk ml mm mn b">--variable today="$(date)"</code>的选项来传递它。但是如果你的变量是特定于Markdown文件的，比如页面的标题，你可以使用元数据。</p><p id="32f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，如果你看看<code class="fe mk ml mm mn b">--from</code>选项，不仅仅是“降价”，现在它是一个更长的选项，具有额外的功能。首先，它使用github口味的Markdown。但是也有<code class="fe mk ml mm mn b">yaml_metadata_block</code>，它允许你包含一个<a class="ae kc" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML </a>元数据块，很可能在减价页面的顶部。</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="8698" class="ms lc iq mn b gy mt mu l mv mw">---<br/>title: The Practice of Programming<br/>authors:<br/>  - Kernighan<br/>  - Pike<br/>---</span></pre><p id="3813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后所有这些都将在您的模板中可用。我们可以走得更远，有多个模板或包括，等等。但是我相信这足以让您开始并调整这个样板文件以满足您的需要。</p><p id="728b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多详情可以阅读<a class="ae kc" href="https://pandoc.org/MANUAL.html" rel="noopener ugc nofollow" target="_blank"> Pandoc手册</a>。</p><h1 id="753b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">制作一些网站地图</h1><p id="f8de" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">同样，您可以添加或改进许多东西，但一个明显的特性是创建一个“sitemap.xml”文件和一个“robots.txt”文件。让我们首先在顶部添加一个新变量来设置我们的域名。</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="cc33" class="ms lc iq mn b gy mt mu l mv mw">BASE_URL = "https://www.example.org"</span></pre><p id="43f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们希望确保在构建“all”目标时构建这些文件。换句话说，我们将把它们添加为依赖项</p><pre class="me mf mg mh gt mo mn mp mq aw mr bi"><span id="9084" class="ms lc iq mn b gy mt mu l mv mw"><strong class="mn ir">all</strong>: html css $(DST_DIR)/robots.txt $(DST_DIR)/sitemap.xml</span></pre><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ba0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">机器人的目标应该不难理解。我们只是使用一些“echo”命令来编写文件。我们使用BASE_URL变量来添加您的域名。</p><p id="ada3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网站地图稍微复杂一点。在开始和结束的urlset标记中，我们遍历所有的html文件并添加一个url标记。同样，我们将域名放在BASE_URL变量中，但问题是我们的html文件中有我们需要删除的构建/目标目录名。</p><p id="5552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先注意，make宏和bash变量都是以“$”开头的。为了做到这一点，你必须用一个双美元符号代替“$$”，这样make就知道它不是一个宏。那么花括号中的内容就是移除前缀的正常bash方式。但是这里的前缀是make宏/变量。唷…你看过电影《盗梦空间》吗？</p><h1 id="06de" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让它自我记录</h1><p id="4b37" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">作为一个奖励，这里有一个经典的目标，可以获得您想从命令行调用的所有目标的摘要。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="74af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是扫描Makefile中带有双尖号“##”的行，这就是为什么我们的目标后面的所有注释都有2个尖号，而不是普通命令的1个。然后，当您运行<code class="fe mk ml mm mn b">make help</code>时，它提取名称和注释以很好地显示它。</p><p id="9764" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是我想出来的。这是一个你可以在互联网上找到的巧妙的技巧。</p><h1 id="feac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让它完整</h1><p id="36c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">以下是整个Makefile的要点供参考:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>