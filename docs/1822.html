<html>
<head>
<title>Automate click through testing with Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用木偶师自动化点击测试</h1>
<blockquote>原文：<a href="https://itnext.io/automate-click-through-testing-with-puppeteer-2e80bc3391dc?source=collection_archive---------1-----------------------#2019-02-06">https://itnext.io/automate-click-through-testing-with-puppeteer-2e80bc3391dc?source=collection_archive---------1-----------------------#2019-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a44d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试是软件开发的基本步骤之一。然而，测试，尤其是通过应用程序点击的手动测试，是一项我们经常回避的乏味工作。但不一定非要这样。随着过去几年优秀工具的出现，我们现在有了在构建过程中自动化点击测试所需要的东西。在这篇文章中，我们将看看为什么手动或点击测试是重要的，以及如何将这个乏味和麻烦的任务变成一个有趣的任务来推动我们的开发。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3d8790d2fbb28f89edec90fc0e7c47e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hZyNfoF5AEkeFvMp.png"/></div></div></figure><p id="76a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不安的读者可以直接进入这篇文章附带的回购。</p><h1 id="01f7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么我们需要手动QA</h1><p id="85b4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">从开发者的角度来看；测试和QA，尤其是手动QA看起来像是不合理的负担，阻碍了我们的开发速度。虽然开发人员社区作为一个整体，以及大多数管理人员社区，正在慢慢恢复他们的理智，并看到为用户编写经过良好测试并能正常工作的代码比增加一个功能更有价值，但我们仍然不赞成将手动QA作为一个路障。</p><blockquote class="mb mc md"><p id="524d" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><em class="iq">手动测试运行经常会变成路障。</em></p></blockquote><p id="af3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是人工QA真的不是我们面临的问题。这是我们使用它的方式。最初，人工质量保证来自于这样一种认识，即在将网站交付给客户之前，确实应该有人点击完成的网站，以确保它确实可以工作。你可以对你的产品进行单元测试，用户和现实世界总是可以打破它。因此，我们尽力模拟真实世界的场景和使用人工QA的用户。</p><p id="8fe6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在DevOps运动中，我们意识到发布小块代码并经常这样做可以大大减少我们发布的bug数量，使我们的公司更有能力对用户需求和市场需求做出反应，并为我们自己创造一个良好的工作环境。在实现高发布速度的过程中，手动QA往往是一个很大的难点。因为不管出于什么原因，我们的组织需要对每个版本进行完整的人工QA运行。这诱使我们囤积特性，以便QA可以一次处理尽可能多的东西(如果你读过Phoenix项目，这是我们经常做的热处理)。我们完全忽略了正是这一点使得我们很难跟踪几十个提交中的哪一个引入了bug，并且通过这样做，我们通常会阻止开发几天，只是为了让一个发布发生。我们发明了复杂的程序，比如一周的代码冻结，来创建一个“稳定的测试环境”,但实际上，它往往是不稳定的。</p><blockquote class="mb mc md"><p id="dc37" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><em class="iq">编程和其他行业一样需要质量保证。</em></p></blockquote><p id="d372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，和其他行业一样，我们也需要人工QA。但现在是转移焦点的时候了。当我们看其他学科时，我们总是会看到手动QA，有一个人控制一切都是正确的，这很容易让人放心。在很长一段时间内，它们比机器更灵活，更像真实世界的用户。但是你看到质量保证发生在离开传统生产链的每一件成品上吗？当然不是，那会是浪费时间！当我们制造汽车时，我们不需要检查每一辆车。我们经常取出一个，以确保过程顺利进行，并相信其余的工作是一样的。</p><p id="53b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也是我们希望在软件开发中实现的操作模式。我们发布一个版本，然后制作几十个(甚至可能每天)。每隔一段时间，就会有人手动验证一个版本，这样，我们相信其余的工作会和这个一样好，因为我们信任我们的过程。</p><h1 id="75ec" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">建立信任</h1><p id="4d15" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">但是我们现在没有这种信任。经常有很多公司被部署出现严重错误的经历吓到了。不幸的是，他们引入了繁琐的程序，旨在防患于未然，而实际上这些程序会适得其反，拖慢公司的发展。我们有责任重建这种信任，并减轻他们目前承受的人工QA负担。我们可以通过自动化QA手动完成的流程来实现这一点。</p><blockquote class="mb mc md"><p id="12e0" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">为了从我们现在所处的位置到达我们想要的位置，这不会被手动QA运行和一天多次发布所阻碍，我们需要投资于自动化测试以及在组织内建立信任，相信我们的代码做了它应该做的事情。</p></blockquote><p id="11f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们将在这条道路上向前迈出一大步，实现网站点击测试的自动化。</p><h1 id="f2e5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">简单的web应用程序</h1><p id="a98d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">对于今天的测试，我们将看看下面的网站，这是一个简单的计数器应用程序。我们将能够点击一个“增量”按钮来将计数增加1。此外，我们将提供一个按钮来显示以前没有看到的消息，只是为了添加更多的动态行为供我们测试。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/6a2501a134009634cf9def851342ad0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/0*jAudZeFy0kca5ef-.png"/></div></figure><p id="1451" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是网站的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们有显示计数和一些按钮的HTML。然后我们在底部添加了一些内嵌的JavaScript来实现逻辑。我们希望该页面能够:</p><ol class=""><li id="f28c" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">当我们参观它的时候展示。</li><li id="f30d" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">单击“增量”按钮时，增加显示的计数。</li><li id="c31f" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">按下“显示消息”按钮时显示消息对话框。</li></ol><p id="b30d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传统上，我们现在需要手动点击。我们会把网站放在某个地方，或者在本地运行一个web服务器来查看。然后我们会检查它是否能打开，并逐一检查需求。让我们让计算机为我们做这件事。</p><h1 id="ebe9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">工具</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3d8790d2fbb28f89edec90fc0e7c47e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hZyNfoF5AEkeFvMp.png"/></div></div></figure><p id="d3c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<a class="ae kx" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，一个“令人愉快的JavaScript测试”框架作为我们的测试框架。但是您也可以使用任何提供断言的东西。当我们在这里使用Jest时，我们将以某种方式讨论事情，以便我们也可以将它们应用到其他工具。</p><p id="500d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">木偶师将是我们自动化浏览器和与之互动的工具。由Chromium团队编写的木偶师提供了一个与<a class="ae kx" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>的接口，可以与任何支持它的浏览器结合使用。我们将使用与它捆绑在一起的Chromium版本。</p><p id="e10b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，Jest在版本<em class="me"> 23.6.0 </em>中与木偶师<em class="me"> 1.11.0 </em>一起使用。</p><p id="c87d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，我们将使用<a class="ae kx" href="https://github.com/tapio/live-server/" rel="noopener ugc nofollow" target="_blank">实时服务器</a>作为本地web服务器。使用本地web服务器使我们独立于所使用的框架。我们将能够使用这种方法测试任何网站，因为无论你如何开发你的网站，无论是React、Angular、Vue还是其他年度框架，最终，你都会得到一个普通的旧网站。使用这种方法，我们可以测试它们。</p><p id="1757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还决定在我的代码中使用ES6模块语法，并包含Babel来使用<code class="fe mz na nb nc b">import</code>。</p><p id="2aa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将所有这些融入你的项目<code class="fe mz na nb nc b">npm i --save jest puppeteer live-server</code>。</p><h1 id="7f09" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试环境设置</h1><p id="c1df" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在我们已经准备好了工具带，是时候开始测试了。</p><p id="368d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前面我们说过，在进行手动测试之前，我们将在某个地方托管网站或运行本地web服务器，我们最好在运行测试之前在测试套件中这样做。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dbc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们记住了Puppeteer管理的浏览器以及一个系统进程，它通过将它们定义为顶级变量来运行我们所有测试的web服务器。现在，我们告诉Puppeteer启动一个浏览器，我们可以在其中观看正在运行的测试。我们也使用<code class="fe mz na nb nc b">slowMo</code>来降低浏览器的速度，稍后我们会让它成为可选的，但是第一次尝试的时候看到事情发生总是很好的。</p><p id="76df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遗憾的是，我们找不到一个好的可以编程管理的web服务器解决方案，并且live-server有一个关于编程关闭的公开问题(参见<a class="ae kx" href="https://github.com/tapio/live-server/issues/196" rel="noopener ugc nofollow" target="_blank">问题196 </a>)，因此我们需要将它作为子进程运行。这基本上就像在进行测试之前在另一个终端中运行命令<code class="fe mz na nb nc b">live-server --port=8282 --no-browser</code>。我们保留了一个引用，以便以后可以关闭服务器。</p><p id="0434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">beforeAll</code>是一个将在任何测试运行之前执行一次的块。因此，这是一个完美的地方，我们的一般设置。在这里，我们使用Puppeteer启动一个浏览器，并在使用它运行我们的测试之前等待它完成。</p><p id="2efc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们不能忘记在所有测试完成后关闭所有这些。因为Jest提供了将运行一次的<code class="fe mz na nb nc b">afterAll</code>，毕竟测试已经完成。这是关闭浏览器和网络服务器的最佳位置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0c65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们为所有测试启动和停止浏览器和web服务器时，我们希望为每个单独的测试创建一个干净的新标签。我们可以通过使用<code class="fe mz na nb nc b">beforeEach</code>并在<code class="fe mz na nb nc b">afterEach</code>进行清理来实现这一点。我们还将添加一个<code class="fe mz na nb nc b">let page</code>，在这里我们也可以记住浏览器，这样我们的测试就可以访问它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7368" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将为每个测试打开一个新的页面，并且总是存储在我们的测试可以访问的同一个名为<code class="fe mz na nb nc b">page</code>的变量中。并不是说对于你项目中的测试套件，你可能想也可能不想这样做。对于我们的网站来说，总是从头开始很好，我们可以通过简单地为每个测试打开一个新页面来实现这一点。</p><p id="aded" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到代码中广泛使用了<code class="fe mz na nb nc b">await</code>。我们将继续看到，与浏览器通信的所有操作本质上都是异步的。如果你不熟悉这种语法，Mozilla有很棒的关于<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> async </a>和<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">waiting</a>的文档。</p><h1 id="9a9a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试站点</h1><p id="1166" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在终于到了编写我们的第一个测试的时候了！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/15288c90b2a4854efe1cb501b16d3128.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/0*OR5u96lCraZNav1m.png"/></div></figure><p id="3a4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用<code class="fe mz na nb nc b">it</code>块，按照“它应该……”的约定来包装所有的测试在一个<code class="fe mz na nb nc b">describe</code>块内。简单回顾一下:这背后的想法是描述应用程序被测试的部分以及它应该做什么。我们的目标是得到描述性的测试，精确地告诉我们什么被破坏了，如果他们失败的话。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在手动测试中所做的那样，我们将首先确保我们能看到网站。为此，我们将检查标题是否存在。我们还可以检查标题中是否有特定的文本，但对我们来说，只要有任何标题就足够了。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1abc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个测试导航到我们想要测试的页面，在上面找到所有的<code class="fe mz na nb nc b">&lt;h1&gt;</code>元素，并期望在页面上找到一个h1元素。我们也决定在这里截图。这使得检查测试过程中的错误或调试测试变得更加容易。</p><p id="d6b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝贺您，您的第一个测试已经就绪，是时候运行它了。为此，我们将遵循节点约定，并向我们的<code class="fe mz na nb nc b">package.json</code>添加一个测试脚本。<code class="fe mz na nb nc b">"test": "jest"</code>对我们会起作用。现在你可以运行<code class="fe mz na nb nc b">npm test</code>了，一个浏览器会打开并截图。只要确保你有一个名为<code class="fe mz na nb nc b">screens</code>的文件夹，可以保存截图。</p><h1 id="a1c2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">选择元素</h1><p id="a0db" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上面验证了数字<em class="me"> 0 </em>，这是我们在测试过程中想要检查的三件事情。接下来是计数器本身和显示的消息。</p><ol class=""><li id="3d32" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">当我们参观✅时，它会向我们展示。</li><li id="88a3" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">单击“增量”按钮时，增加显示的计数。</li><li id="6094" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">按下“显示消息”按钮时显示消息对话框。</li></ol><p id="7bf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于计数器，我们将希望检查它是否从0开始，然后在我们单击一个按钮后它是否递增。检查初始值很简单，只需获取显示计数的<code class="fe mz na nb nc b">&lt;span&gt;</code>元素的内容。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/82c583c5ea4d8c7160fb1053aa84b1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*8MmJLYX1mvhIryAE.png"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ce51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次访问页面并截取屏幕截图，但这一次我们还提取了计数器的初始值。木偶师提供了许多与页面交互的方法。这里我们使用了<code class="fe mz na nb nc b">$eval</code>,它接受一个用于在页面上运行<code class="fe mz na nb nc b">querySelect</code>的元素选择器，并作为第二个参数接受一个函数，该函数将找到的元素作为它的输入。传递给<code class="fe mz na nb nc b">$eval</code>的函数在页面的上下文中进行计算，其结果成为<code class="fe mz na nb nc b">$eval</code>的返回值。你可以在<a class="ae kx" href="https://github.com/GoogleChrome/puppeteer/blob/v1.11.0/docs/api.md" rel="noopener ugc nofollow" target="_blank">官方文档</a>中查找完整的API。</p><p id="b62a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们找到一个由<code class="fe mz na nb nc b">[data-test="count-output"]</code>标识的元素，然后将它的<code class="fe mz na nb nc b">.innerHTML</code>转换成一个整数并返回。这暴露了自动化点击测试的一个关键部分。我们的测试需要找到与之交互和运行测试的元素。你也可以通过在网站上搜索某个文本来解决这个问题，但是对于文本频繁变化的网站以及输出，我们需要一种不同的方式来选择它们。</p><p id="047f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个很好的方法就是自定义<code class="fe mz na nb nc b">data-*</code>属性。自定义数据属性不会干扰web开发的其余部分。它们在这里正是为了某个元素需要某些特定信息的情况，否则无法提供这些信息。</p><p id="ce77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两种选择是类和id。虽然类不应该是唯一的，因此不能用来选择一个事物，但是id已经有了其他的含义。它们可能已经被使用了，并且是您不希望耦合到您的测试过程中的东西，因为这将阻止您在应用程序开发中充分利用它们。因此，我们在这里使用数据属性来识别测试感兴趣的元素。</p><h1 id="ef5a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">与元素交互</h1><p id="de66" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一旦我们可以在页面上找到元素，我们也可以与它们交互，例如，单击一个按钮来增加我们的计数器。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ce6c198794fdb4e78dcecb6539d6b04b.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/0*J5cMDKFFlLExlf-C.gif"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们获得了初始计数值，并验证了我们的预期，即单击“increment”按钮将使该值增加1。使用<code class="fe mz na nb nc b">page.$</code>我们可以得到一个<a class="ae kx" href="https://pptr.dev/#?product=Puppeteer&amp;version=v1.11.0&amp;show=api-class-elementhandle" rel="noopener ugc nofollow" target="_blank"> ElementHandle </a>，它为我们提供了一些方便的功能来与选中的元素进行交互，比如用<code class="fe mz na nb nc b">.click()</code>来点击它。</p><p id="870e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博文的<a class="ae kx" href="https://github.com/HoverBaum/jest-puppeteer-website-testing" rel="noopener ugc nofollow" target="_blank"> repo中，您可以找到另一个对计数器进行多次递增的测试。</a></p><p id="3bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们就可以从测试列表中检查出另一个项目。</p><ol class=""><li id="a7f9" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">当我们参观✅时，它会向我们展示。</li><li id="e4ab" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">当我们点击“增量”按钮时，✅增加显示的计数。</li><li id="cdd9" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">按下“显示消息”按钮时显示消息对话框。</li></ol><h1 id="e8ef" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">动态DOM内容</h1><p id="8a18" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们现在剩下的是动态添加到页面中的元素，我们也可以测试这些元素，就像我们示例网站中的消息一样。为此，我们只需执行将元素添加到页面的操作，然后查找它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/37489c1fc253bfc96cac1f4f8a945802.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/0*Cj2q4I_53iziYmo-.gif"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="43dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一次，我们没有使用Puppeteers build来支持点击事件，而是使用了一段JavaScript代码，在我们的页面上下文中评估点击按钮<code class="fe mz na nb nc b">e =&gt; e.click()</code>。同样，您可以在页面的上下文中传递任何要评估的代码。</p><p id="61ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这已经让我们在测试网站方面走得很远了。不要忘记，当测试你的实际站点时，你可以通过直接发送请求到你的后台来获得很多快捷方式，而不是一直通过你的UI来做所有的事情。在这样做之前，花点时间思考一下你想测试什么，并尽最大努力将测试彼此分离。一次测试失败不应该导致所有其他测试都失败。理想情况下，您希望一个测试自己失败，以方便找到问题。接下来，通过直接调用(或使用模拟后端)来自后端的测试来设置(或播种)数据和状态通常是好的。这样，即使在为当前测试失败的列表创建项目时，您也可以验证列表的显示。</p><ol class=""><li id="7bc3" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">当我们参观✅时，它会向我们展示。</li><li id="5905" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">当我们点击“增量”按钮时，✅增加显示的计数。</li><li id="df5a" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">当按下“显示消息”按钮时，✅显示一个消息对话框。</li></ol><p id="86c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜，所有测试都是绿色的！</p><h1 id="b3a7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使可视化成为可选的</h1><p id="6d7b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">早先我们硬编码显示一个延迟的浏览器来观察我们的测试发生。因为我们并不总是想这样做，所以让我们把它改为依赖于一个环境变量<code class="fe mz na nb nc b">SHOW_BROWSER</code>。有些情况下，我们可能不想得到可视化，特别是包括构建和部署我们的应用程序的管道，这些应用程序通常运行在我们不关心可视化而关心速度的系统上。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将简单地检查环境中是否包含一个名为<code class="fe mz na nb nc b">SHOW_BROWSER</code>的变量，并根据它来决定是否显示浏览器。现在要看到浏览器，你可以运行<code class="fe mz na nb nc b">env SHOW_BROWSER=t npm test</code>来用浏览器运行测试。你可以用任何你想要的东西代替<code class="fe mz na nb nc b">t</code>，只要<code class="fe mz na nb nc b">SHOW_BROWSER</code>有任何价值。您甚至可以将它转换成npm脚本<code class="fe mz na nb nc b">"test:visual": "env SHOW_BROWSER=t npm test</code>并运行<code class="fe mz na nb nc b">npm run test:visual</code>来使用它。</p><h1 id="c0c8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">局限性和良好的测试</h1><p id="cc27" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">与每一种方法一样，这种自动点击测试并不是万能的，它有一些限制。例如，木偶戏基本上只能在Chrome上运行。但是正如我们之前讨论的，自动化点击测试不应该取代人工QA运行，而是应该帮助他们。一旦我们实现了快速的开发迭代，这将给我们带来更少的错误，只要我们在所有浏览器中进行定期检查，在一个浏览器中为每个构建进行测试就可以了。总是假设开发人员在多种浏览器中检查他们的代码😉</p><p id="caca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会发现在测试中引入超时很有帮助。您会注意到何时使用它们，因为当默认超时不够长时，测试会失败，只需将您想要的超时作为第二个参数传递给<code class="fe mz na nb nc b">it()</code>。</p><h1 id="4dc7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">包扎</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/61d690c60eed58cdfd90c3bd2c8d250b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*puZb4kurLsjjmjrp.png"/></div></div></figure><p id="1318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标达到了，我们开始使用Jest和木偶师测试网站。我们看了一下自动化点击测试在软件开发的大环境中的位置，然后继续编写我们的第一个测试用例。用我们完成的代码检查<a class="ae kx" href="https://github.com/HoverBaum/jest-puppeteer-website-testing" rel="noopener ugc nofollow" target="_blank">回购。</a></p><p id="f799" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在出去，自动化你所有的测试🚀</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7455807f4379eb5e827c26520b2c6323.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/0*AV1gxUgR-JhxieOm.png"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="2bcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一集:使用Cypress可视化调试自动化测试的自动化测试(即将推出)</p><p id="2072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="9037" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk np mr ms mt bi translated">https://github.com/HoverBaum/jest-puppeteer-website-testing<a class="ae kx" href="https://github.com/HoverBaum/jest-puppeteer-website-testing" rel="noopener ugc nofollow" target="_blank"/></li><li id="0ecc" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk np mr ms mt bi translated">【https://jestjs.io/ T4】</li><li id="9f69" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk np mr ms mt bi translated"><a class="ae kx" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank">https://pptr.dev/</a></li></ul><p id="8035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初发表于:<a class="ae kx" href="https://hoverbaum.net/2019/01/29/Automate-click-through-testing-with-Puppeteer/" rel="noopener ugc nofollow" target="_blank">hoverbaum.net</a></p></div></div>    
</body>
</html>