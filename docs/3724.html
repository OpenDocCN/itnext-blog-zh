<html>
<head>
<title>Choosing The Right File Structure for Angular in 2020 and Beyond 📕!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为2020年及以后的Angular选择正确的文件结构📕！</h1>
<blockquote>原文：<a href="https://itnext.io/choosing-the-right-file-structure-for-angular-in-2020-and-beyond-a53a71f7eb05?source=collection_archive---------0-----------------------#2020-02-11">https://itnext.io/choosing-the-right-file-structure-for-angular-in-2020-and-beyond-a53a71f7eb05?source=collection_archive---------0-----------------------#2020-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8b127bfbe36e32d6c421417cca394538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wJDKbEvnWrrgcP84.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马丁·范·登·霍维尔在<a class="ae kc" href="https://unsplash.com/search/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a405" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">与本文相关的代码可在</em> <a class="ae kc" href="https://github.com/mathisGarberg/angular-ngxs-and-material-starter" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> GitHub </em> </a> <em class="lb">上获得。仍然需要一些补充，但是它遵循这里描述的相同模式。</em></p><p id="3cad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2018年我写过文章<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/choosing-a-highly-scalable-folder-structure-in-angular-d987de65ec7"> <strong class="kf ir">如何为你的Angular项目</strong> </a>定义一个高可扩展的文件夹结构。从那以后，两年过去了，棱角分明的风景发生了一些变化。我们已经看到了onPush变更检测、正在添加的providedIn装饰器、可导出的指令以及对Angular核心框架的其他几个更新，在撰写本文时，我们仍处于版本9。</p><p id="b905" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular团队的快速发布周期给我们带来了一些很棒的新特性，但这也意味着我们需要自己做一些结构上的改变。鉴于这些变化和原文章中的常见问题，我决定创建一篇新文章，回答所有这些问题。</p><p id="8e5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎为2020年及以后的Angular选择正确的文件结构！</p><h1 id="adfe" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">介绍</h1><p id="ab78" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当在一个有许多开发人员负责相同代码库的大型团队中工作时，对应用程序应该如何构造有一个共同的理解是至关重要的。为架构决策争论所花费的时间占据了我们日常工作的很大一部分，在解决这些问题的过程中，达成共识还有很长的路要走。</p><p id="216e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目标是通过为大中型应用程序提出一个可伸缩和可维护的结构来帮助那些开发人员。我们将在Angular文档的上下文中探索该结构，通过使用他们的声明来进一步强调这里的优势。</p><p id="625e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注意！几乎不可能找到适合每一个用例的结构。根据项目的不同，应用程序的结构会有很大的变化，这里没有蓝图。本文旨在通过</em> <strong class="kf ir"> <em class="lb">提出</em> </strong> <em class="lb">一个应该能很好地为大中型应用程序工作的结构来改进开发过程。</em></p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="ml mm mn"><p id="077a" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">要有近期的实施观和长远的眼光。从小处着手，但要记住应用程序的发展方向。</p><p id="79fe" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">该应用的所有代码都放在一个名为<code class="fe mr ms mt mu b">src</code>的文件夹中。</p><p id="4aa6" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">一定要构建应用程序，这样你可以快速定位代码，一眼就能识别代码，尽可能保持扁平的结构，尽量简洁，但不要以牺牲可读性为代价。</p><p id="45b5" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">请务必给文件命名，以便您可以立即知道它包含和代表什么。</p><p id="7869" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">尽可能长时间保持扁平的文件夹结构。</p></blockquote><p id="51ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular CLI中的<code class="fe mr ms mt mu b">ng new</code>命令为我们提供了应用程序根级别的初始框架结构，并且易于运行和构建。这种默认行为适用于新的应用程序，并且是结构的完美入口点。您应该使用角度示意图在适当的区域生成文件。</p><h1 id="3059" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">应用程序模块</h1><blockquote class="ml mm mn"><p id="b888" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">一定要在应用程序的根文件夹中创建一个NgModule，例如在<code class="fe mr ms mt mu b">/src/app</code>中。</p></blockquote><p id="a600" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Angular中，一切都被组织在模块中，每个应用程序都至少有一个模块，即应用程序根模块。app模块是应用的入口点，是Angular用来引导应用的模块。创建一个新应用程序时的设置指令产生一个最小的带有单个组件的<code class="fe mr ms mt mu b">AppModule</code>。随着应用程序的增长，您将会改进这个模块。</p><h1 id="7488" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">核心模块</h1><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="025d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mr ms mt mu b">CoreModule</code>承担了应用根模块的角色，但不是Angular在运行时引导的模块。这里给出的文件的共同点是我们只需要加载它们一次，而且是在运行时，这使得它们是单例的。该模块包含根范围的服务、静态组件，如导航栏和页脚、拦截器、保护、常量、枚举、实用程序和通用模型。为了防止在其他地方重新导入模块，我们应该在它的构造函数方法中添加一个module-import-guard。</p><h1 id="b2c8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">共享模块</h1><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="ml mm mn"><p id="de2f" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">在<code class="fe mr ms mt mu b">shared</code>文件夹中创建一个名为<code class="fe mr ms mt mu b">SharedModule</code>的特征模块；比如<code class="fe mr ms mt mu b">app/shared/shared.module.ts</code>定义了<code class="fe mr ms mt mu b">SharedModule</code>。</p><p id="5cab" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">当组件、指令和管道将被其他功能模块中声明的组件重用和引用时，请在共享模块中声明这些项目。</p><p id="c431" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">务必在<code class="fe mr ms mt mu b">SharedModule</code>中声明所有组件、指令和管道。</p><p id="8f6b" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">务必从<code class="fe mr ms mt mu b">SharedModule</code>中导出其他功能模块需要使用的所有符号。</p></blockquote><p id="4ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当处理大型应用程序时，Angular团队建议我们考虑模块的延迟加载。这减少了我们的应用程序的包大小，从而减少了初始构建时间，这也是SharedModule真正闪光的地方。</p><p id="2b78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SharedModule允许我们组织和简化代码。共享模块不应该依赖于应用程序的其他部分，因此也不应该依赖于任何其他模块。它应该包含所有可重用的模块，操作所需的惰性加载功能模块。您应该在这里添加常用的指令、管道和组件。许多第三方库可以作为NgModules获得，例如<a class="ae kc" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Material Design </a>，通过SharedModule公开它们可能是个好主意。</p><p id="29ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以轻松地在应用程序之间发布和共享这些组件。</p><h1 id="956c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">功能模块</h1><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="ml mm mn"><p id="f714" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">一定要为应用程序中所有不同的特性创建一个NgModule例如一个<code class="fe mr ms mt mu b"><em class="iq">Heroes</em></code>特征。所有功能区都在它们自己的文件夹中，有它们自己的NgModule。</p><p id="d833" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">务必将功能模块放在与功能区域相同的命名文件夹中；比如在<code class="fe mr ms mt mu b"><em class="iq">app/heroes</em></code>里。</p><p id="884e" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">命名特征模块文件，以反映特征区域和文件夹的名称；例如，<code class="fe mr ms mt mu b"><em class="iq">app/heroes/heroes.module.ts</em></code>。</p><p id="ec7e" class="kd ke lb kf b kg kh ki kj kk kl km kn mo kp kq kr mp kt ku kv mq kx ky kz la ij bi translated">务必命名反映特征区域、文件夹和文件名称的特征模块符号。比如<code class="fe mr ms mt mu b"><em class="iq">app/heroes/heroes.module.ts</em></code>定义了<code class="fe mr ms mt mu b"><em class="iq">HeroesModule</em></code>。</p></blockquote><p id="745c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初的角度应用程序只有一个模块，非常适合小型应用。但是随着应用程序的增长，您需要考虑将其细分为多个功能模块，其中一些可以延迟加载。这些模块应该只依赖于SharedModule，并且它们的功能应该局限于该模块。</p><p id="bc06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">功能模块提供专门针对特定应用程序功能的用户体验，如应用程序的用户或管理部分。我们将属于一起的组件、服务、模型和其他功能进行分组。它们通常有一个作为特征根的顶层组件和从它派生出来的私有支持子组件。它们可能由缺乏路由或需要显示一些初始内容的小型应用程序的根<code class="fe mr ms mt mu b">AppModule</code>导入，但也可以通过应用程序路由文件中的引用进行惰性加载。</p><p id="7704" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">领域特性模块很少有提供者，但是当它们有提供者时，所提供服务的生命周期应该与模块的生命周期相同。从Angular 6.0开始，创建单例的首选方式是在服务的<code class="fe mr ms mt mu b">@Injectable</code>装饰器上将<code class="fe mr ms mt mu b">providedIn</code>设置为<code class="fe mr ms mt mu b">root</code>。这告诉Angular在应用程序根中提供服务。但是我们也可以用这个</p><p id="6008" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个单体服务就是在服务的<code class="fe mr ms mt mu b">@<a class="ae kc" href="https://angular.io/api/core/Injectable" rel="noopener ugc nofollow" target="_blank">Injectable</a>()</code>装饰器上将<code class="fe mr ms mt mu b"><a class="ae kc" href="https://angular.io/api/core/Injectable#providedIn" rel="noopener ugc nofollow" target="_blank">providedIn</a></code>设置为<code class="fe mr ms mt mu b">root</code>。这告诉Angular在应用程序根中提供服务。我们可以通过使用模块上的<code class="fe mr ms mt mu b">providedIn</code>属性在特性的上下文中使用它，这会导致在其他地方使用它时出错。</p><p id="f5d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您还需要其他模块中的服务时，它可能属于CoreModule服务的声明。</p><h1 id="9419" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">风格</h1><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b3f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与我们如何避免随着应用程序的增长而膨胀<code class="fe mr ms mt mu b">AppModule</code>类似，对于<code class="fe mr ms mt mu b">styles.scss</code>文件也是如此。相反，你应该创建一个styles文件夹，其中包含mixins或css函数，负责它们自己的区域。然后，这些文件以适当的顺序导入到styles.scss文件中，将它们的全局样式提供给应用程序的其余部分。为可重用的css片段创建mixins，并将相关的逻辑放在一起。</p><h1 id="2d0f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">资产</h1><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">assets文件夹是Angular CLI使用<code class="fe mr ms mt mu b">ng new</code>命令为我们生成的，是存储我们所有媒体文件的最佳位置。将它与PathLocationStrategy结合使用，可以在整个应用程序中轻松地提供可引用的文件。该文件夹在构建时保持不变。</p><h1 id="4d89" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">超越！</h1><p id="661a" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">尽管上面描述的结构解决了很多问题，我们仍然忽略了一个大的方面，那就是Angular中的状态管理。这是因为有很多不同的方法来解决这个问题，并且一个解决方案可能不适用于另一个。<a class="ae kc" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular Material </a>和其他组件库的上下文是另一个将定义应用程序结构的大区域的区域。带有微前端的Nrwl 的出现也引起了广泛关注。你想看这类文章的某一点，请让我知道。</p><h1 id="3bb8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="33f8" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">选择合适的文件夹结构不是一件容易的事情。您需要与团队就适合应用程序的结构达成一致，什么可能适合一个需求，什么可能不适合另一个需求。有望在未来几年继续有效。为了确保一个好的、可维护的结构，你会做什么不同的事情？</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="8f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我叫Mathis Garberg，是挪威奥斯陆 <a class="ae kc" href="https://www.dfindconsulting.no/" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> Dfind咨询</em> </a> <em class="lb">的顾问。生活在挪威，需要一些角度的专业知识？随意伸手！</em></p><p id="e015" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看看我的其他角度的文章和/或订阅我更进一步，和/或如果你喜欢这个故事，一个👏总是受到赞赏。</p></div></div>    
</body>
</html>