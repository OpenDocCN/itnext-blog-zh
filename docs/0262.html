<html>
<head>
<title>npm install with cache in docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在docker中使用缓存安装npm</h1>
<blockquote>原文：<a href="https://itnext.io/npm-install-with-cache-in-docker-4bb85283fa12?source=collection_archive---------3-----------------------#2018-02-01">https://itnext.io/npm-install-with-cache-in-docker-4bb85283fa12?source=collection_archive---------3-----------------------#2018-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b46c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">添加一个新的</em> <code class="fe km kn ko kp b"><em class="kl">npm</em></code> <em class="kl">包然后运行</em> <code class="fe km kn ko kp b"><em class="kl">docker build</em></code> <em class="kl">真的很慢！以下是如何加快你的工作流程。</em></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/2bb55092161db53e5fb13bf6dfc40b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zowNpUJSA1OmsscHvlMc8w.jpeg"/></div></div></figure><p id="9ab1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fnpm-install-with-cache-in-docker-4bb85283fa12" rel="noopener ugc nofollow" target="_blank"> <em class="kl">点击这里在LinkedIn </em>上分享这篇文章</a></p><h1 id="f101" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">问题是</h1><p id="d7fa" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">除了通过层缓存机制，没有其他方法可以在docker构建之间持久化构建工件。您可以使用<code class="fe km kn ko kp b">VOLUME</code>动作指定一个或多个卷，但是它不是在构建时使用，而是在运行时使用。(也就是你做<code class="fe km kn ko kp b">docker run ...</code>的时候)。</p><p id="6c52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你正在使用<code class="fe km kn ko kp b">npm</code>进行开发，添加一个新包的时间会变得非常长！对于每个<code class="fe km kn ko kp b">docker build</code>,整个<code class="fe km kn ko kp b">node_modules</code>被完全重新安装，从互联网上重新获取，不参考任何本地缓存。</p><p id="a1fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将概述一种有帮助的技术。</p><h1 id="3bf5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">解决方案</h1><p id="c44b" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">首先，我承认在构建期间试图解决这个问题失败了，因为用docker在技术上是不可能的。有<a class="ae lc" href="https://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fgrammarly%2Frocker&amp;t=OWFiZTE3MmY2NjQ0YmFhNDgxMDcxZjRlZjk0NDA2YzZmZWRiNDBjMSxrQ1dZODhEZg%3D%3D&amp;b=t%3AaI2GQmymS14nkWtOZDdQcw&amp;p=http%3A%2F%2Ftimlesallen.tumblr.com%2Fpost%2F151774051780%2Fdocker-npm-cache&amp;m=1" rel="noopener ugc nofollow" target="_blank">工具</a>试图解决这个问题，但是它们必然会破坏与docker的兼容性(通过用缺失的功能扩展docker)。我不热衷于打破兼容性，所以我回避这些。</p><p id="a9c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">诀窍是转而采用一种制度，在这种制度下，你可以添加新的包，并在需要时在运行时<em class="kl">获取它们。这样，您可以在开发工作流程中快速迭代。</em></p><ol class=""><li id="bbf2" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">给你的<code class="fe km kn ko kp b">package.json</code>添加一个新的脚本，它将会同时<code class="fe km kn ko kp b">npm install</code>和<code class="fe km kn ko kp b">npm start</code>。(参见<a class="ae lc" href="https://gist.github.com/timlesallen/a7292bd1fb1674abb9a7fede9c08f7cd" rel="noopener ugc nofollow" target="_blank">要点</a>)</li><li id="8115" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">如果您使用的是<code class="fe km kn ko kp b">docker-compose</code>，请更改您的<code class="fe km kn ko kp b">docker.compose.yml</code>文件以使用该脚本。</li></ol><p id="8025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着当你添加一个新的包到你的<code class="fe km kn ko kp b">package.json</code>中时，你会把这些新的包安装到你的容器中，而不需要重新构建。</p><p id="ca16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，使用这种方法，您将获得“增量”(即，自从您上次<code class="fe km kn ko kp b">docker build</code>以来的新包，每次您启动一个新容器时都被拉下。</p><p id="6f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过告诉<code class="fe km kn ko kp b">docker-compose</code>创建一个卷，例如<code class="fe km kn ko kp b">npm-cache</code>，并将其映射到容器的<code class="fe km kn ko kp b">npm</code>缓存目录中，来减少这一步所需的时间。</p><p id="90fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要获得容器中的<code class="fe km kn ko kp b">npm</code>缓存目录的路径，只需执行<code class="fe km kn ko kp b">docker-compose run [servicename] npm get cache</code>。然后你可以将你的<code class="fe km kn ko kp b">docker-compose.yml</code>修改为<a class="ae lc" href="https://gist.github.com/timlesallen/a7292bd1fb1674abb9a7fede9c08f7cd" rel="noopener ugc nofollow" target="_blank">显示的</a>。</p><p id="4a05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(不要忘记将<code class="fe km kn ko kp b">/root/.npm</code>替换为您自己的映像的缓存位置，这是您之前执行<code class="fe km kn ko kp b">npm get cache</code>时得到的。</p><p id="136a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是全部了！</p></div></div>    
</body>
</html>