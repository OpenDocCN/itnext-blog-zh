<html>
<head>
<title>Migrating application to Spring Boot 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将应用程序迁移到Spring Boot 3</h1>
<blockquote>原文：<a href="https://itnext.io/migrating-application-to-spring-boot-3-e3129ebcf2a6?source=collection_archive---------0-----------------------#2022-12-11">https://itnext.io/migrating-application-to-spring-boot-3-e3129ebcf2a6?source=collection_archive---------0-----------------------#2022-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="611e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上周标志着Spring Boot新的主要版本的发布。</p><p id="b0e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我通常倾向于在物理条件允许的情况下尽快将我的应用程序迁移到新版本，但总是害怕迁移。这从来都不是直截了当的，尤其是当涉及到开源库或框架的时候。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3f5419966df56898f160df0b29737a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0MDeONbaCcRIBE_XO1kpg.png"/></div></div></figure><p id="72a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我花了上个周末的时间试图将一个相对简单的Spring Boot 2.x网络服务迁移到Spring Boot 3.x</p><p id="63a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所讨论的web服务是一个相当标准的应用程序，它使用Spring JPA与后端通信，JPA Security授权请求，并使用Rest和Websockets与客户端通信。</p><h1 id="1419" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么进展顺利</h1><p id="e487" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">官方的迁移指南在周末还没有发布，所以我主要使用<a class="ae ma" href="https://spring.io/blog/2022/05/24/preparing-for-spring-boot-3-0" rel="noopener ugc nofollow" target="_blank">这篇博客文章</a>作为指南以及Spring框架文档和谷歌搜索来尝试和解决任何迁移问题。</p><p id="c786" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好消息是切换到新版本就像改变org.springframework.boot gradle插件的版本一样简单。</p><p id="0d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不出所料，由于切换到Jakarta EE9，这立即导致了许多编译错误。</p><p id="476d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用IDE中的全局搜索和替换功能，替换以下软件包，相对容易地修复了此问题:</p><ul class=""><li id="d4c8" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">javax.servlet -&gt; jakarta.servlet</li><li id="6fd0" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">javax . persistence-&gt; Jakarta . persistence</li><li id="632d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">javax . annotations-&gt; Jakarta . annotations</li><li id="64e8" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">javax.transaction -&gt;雅加达. transaction</li></ul><p id="183b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我没有使用遗留属性文件，所以在这方面没有问题。</p><h1 id="963e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么不太顺利</h1><p id="0f04" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我遇到的第一个问题与WebSecurityConfigurerAdapter的删除有关。在Spring Security 5中，一个或多个安全配置类通常会继承WebSecurityConfigurerAdapter并覆盖configure方法。</p><p id="f4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Spring Security 6中，它现在是一个以HttpSecurity对象作为参数并返回SecurityFilterChain对象的Bean。</p><p id="9aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个相对简单的改变，而且，它大大简化了事情:以前，如果我想为应用程序的不同部分使用多种安全机制，我必须为每个配置创建许多静态类。现在，它只是主Web安全配置类中的一些beans。</p><p id="4984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个变化需要修改源代码:在Spring Security 5中，我们使用了。authorizeRequest对象的antMatchers方法。在Spring Security 6中，它被重命名为. requestMatchers。否则，一切都和以前一样，只是这个方法现在必须有一个调用，通过调用http.build()从http参数创建SecurityFilterChain对象。</p><p id="a973" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，我们修改了以下web安全配置</p><pre class="km kn ko kp gt mp mq mr bn ms mt bi"><span id="e379" class="mu ky iq mq b be mv mw l mx my"> @Configuration<br/> public static class WebSecurityConfig extends WebSecurityConfigurerAdapter {<br/>  public WebSecurityConfig() {<br/>   super(false);<br/>  }<br/><br/>  @Override<br/>  protected void configure(HttpSecurity http) throws Exception {<br/>   logger.info("Configure application security******************************************************");<br/>   http.cors()<br/>     .and()<br/>     .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)<br/>     .and()<br/>     .antMatcher("/ws/**")<br/>     .authorizeRequests(autorizeRequests -&gt; autorizeRequests<br/>       .antMatchers(HttpMethod.GET, "/ws/healthz", "/ws/ready", "/ws/version").permitAll()<br/>       .antMatchers(HttpMethod.GET,<br/>         "/ws/user/*",<br/>         "/ws/user/avatar/*",<br/>         "/ws/user/search").hasAnyAuthority("SCOPE_tmt:user")<br/>       .antMatchers(HttpMethod.POST,<br/>         "/ws/friend",<br/>         "/ws/user/trip",<br/>         "/ws/trip/*").hasAnyAuthority("SCOPE_tmt:user")<br/>     ).oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);<br/>   http.csrf().disable();<br/>   http.headers().frameOptions().disable();<br/>  }<br/> }</span></pre><p id="f172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变成了下面的一个:</p><pre class="km kn ko kp gt mp mq mr bn ms mt bi"><span id="62e2" class="mu ky iq mq b be mv mw l mx my">@Configuration<br/>@EnableWebSecurity<br/>public class WebSecurityConfig {<br/>...<br/> @Bean<br/> @Order(1)<br/> public SecurityFilterChain auth0FilterChain(HttpSecurity http) throws Exception {<br/>  logger.info("Configure application security******************************************************");<br/>  http.cors()<br/>    .and()<br/>    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)<br/>    .and()<br/>    .securityMatcher("/ws/**")<br/>    .authorizeHttpRequests(autorizeRequests -&gt; autorizeRequests<br/>      .requestMatchers(HttpMethod.GET, "/ws/healthz", "/ws/ready", "/ws/version").permitAll()<br/>      .requestMatchers(HttpMethod.GET,<br/>        "/ws/user/**",<br/>        "/ws/user/avatar/*",<br/>        "/ws/user/search").hasAnyAuthority("SCOPE_tmt:user")<br/>      .requestMatchers(HttpMethod.POST,<br/>        "/ws/friend",<br/>        "/ws/user/trip",<br/>        "/ws/trip/*").hasAnyAuthority("SCOPE_tmt:user")<br/>    ).oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);<br/>  http.csrf().disable();<br/>  http.headers().frameOptions().disable();<br/><br/>  return http.build();<br/> }<br/>...<br/>}</span></pre><p id="b6fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在处理网络安全变化时，最大的惊喜是它变得更加严格。因此，在以前的版本中，我可以定义以下规则:</p><pre class="km kn ko kp gt mp mq mr bn ms mt bi"><span id="e866" class="mu ky iq mq b be mv mw l mx my">.requestMatchers(HttpMethod.GET,<br/>      "/ws/user/*",</span></pre><p id="ba45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将处理/ws/user下的所有请求，例如/ws/user/1或/ws/user/1/details。</p><p id="b2fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">切换到Spring Security 6后，以前的配置不再有效。为了正确处理请求，它必须如下:</p><pre class="km kn ko kp gt mp mq mr bn ms mt bi"><span id="b138" class="mu ky iq mq b be mv mw l mx my">.requestMatchers(HttpMethod.GET,<br/>      "/ws/user/**",</span></pre><h1 id="f68e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="f251" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我个人感到惊喜的是，这是一次相当容易的经历。显然，这是一个相对简单的项目，更复杂的项目的移植可能不太容易，但总的来说，我喜欢Spring Framework的主要版本几乎没有突破性的变化。</p></div></div>    
</body>
</html>