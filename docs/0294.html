<html>
<head>
<title>Demystifying Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开可观察事物的神秘面纱</h1>
<blockquote>原文：<a href="https://itnext.io/demystifying-observables-979a63763eb1?source=collection_archive---------0-----------------------#2018-02-11">https://itnext.io/demystifying-observables-979a63763eb1?source=collection_archive---------0-----------------------#2018-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实用的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94eeeec4ecb5bbb4af763b00c57a8fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOcVSB4v7KEkfxVU3aQNKA.png"/></div></div></figure><p id="e63a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">反应式编程是当今最热门的话题之一。随着像RxJs这样的库和Angular这样的大框架采用它，它不断地继续增长。</p><p id="4ef5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据我的经验，很难向没有太多函数式编程经验的人解释可观测量。在大多数情况下，这需要一点思想转变。</p><p id="c991" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可观测量伴随着许多操作符和概念。人们经常因为反应式编程而过度紧张，因为他们从来没有完全理解可观测量是如何工作的。</p><p id="6d08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是好消息是。可观测量的主要概念并不像乍看上去那么复杂。事实上，它们与纯JavaScript函数有很多共同之处。什么？在我的博客上找到更多信息:</p><div class="lq lr gp gr ls lt"><a href="https://medium.com/@kevinkreuzer/observables-just-powerful-functions-a033c355b22c" rel="noopener follow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">可观察的，只是强大的功能？</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">反应式编程是当今最热门的话题之一。有了RxJs这样的库和React或…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">medium.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ks lt"/></div></div></a></div><p id="d4df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如标题所示，这篇博客试图揭开可观察事物的神秘面纱。在我看来，只有一种方法可以做到这一点；通过编写我们自己的自定义可观察对象。😎</p><p id="0757" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">写出我们自己的可观测数据听起来很复杂，但这不是火箭科学。事实上，你会惊讶地发现实现自己的基本可观察对象是多么容易。</p><h1 id="4217" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">我的可观察、冷漠和懒惰</h1><p id="fec9" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">大多数，但不是所有的可观测量都是懒惰的！也许你已经听说过冷和热这两个术语。</p><p id="d0fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简单起见，让我们把重点放在冷的主要部分——懒惰。他们不会做任何事，直到你告诉他们这样做。但是你如何告诉他们去做一些事情呢？</p><p id="e1eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们先来看看Observables构造函数。我们要用这个函数来创建一个发出1，2，3然后完成的可观察对象。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7dbc" class="nk mj it ng b gy nl nm l nn no">const example$ = new Rx.Observable(function(observer){<br/>  observer.next(1)<br/>  observer.next(2)<br/>  observer.next(3)<br/>  observer.complete()<br/>})</span><span id="0030" class="nk mj it ng b gy np nm l nn no">example$.subscribe(next =&gt; console.log(next), <br/>                   err=&gt;  console.error(err), <br/>                   () =&gt; console.log('Done'))</span><span id="7a96" class="nk mj it ng b gy np nm l nn no">// Output<br/>// 1<br/>// 2<br/>// 3<br/>// Done</span></pre><p id="185e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们调用构造函数并传入一个回调。猜猜这个回调叫什么？对，订阅！</p><blockquote class="nq"><p id="4e9e" class="nr ns it bd nt nu nv nw nx ny nz lp dk translated"><a class="ae oa" href="https://twitter.com/KevinKreuzer90" rel="noopener ugc nofollow" target="_blank"> <em class="ob">在Twitter </em> </a> <em class="ob">或medium上关注我，了解最新的博客帖子和有趣的前端内容！🐤</em></p></blockquote><p id="779a" class="pw-post-body-paragraph ku kv it kw b kx oc ju kz la od jx lc ld oe lf lg lh of lj lk ll og ln lo lp im bi translated">事实上，这就是我们之后要调用五行的同一个subscribe。为了更清楚地理解，让我们按以下方式重构上面的代码片段:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="ede1" class="nk mj it ng b gy nl nm l nn no">const subscribe = function(observer){<br/>  observer.next(1)<br/>  observer.next(2)<br/>  observer.next(3)<br/>  observer.complete()<br/>}</span><span id="d625" class="nk mj it ng b gy np nm l nn no">const observer = {<br/>  next: next =&gt; console.log(next),<br/>  error: err =&gt; console.error(err),<br/>  complete: () =&gt; console.log('Done')<br/>}</span><span id="bff4" class="nk mj it ng b gy np nm l nn no">const example$ = new Rx.Observable(subscribe)<br/>example$.subscribe(observer)</span></pre><p id="fb1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是要理解，我们在开始时传递的subscribe函数与我们在订阅流时将要调用的函数是相同的。但是这是如何工作的呢？</p><p id="5215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你读过我的另一篇关于“可观测量，只是强大的功能”的博文，你可能已经有了主意。</p><p id="a97e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们继续实现一个非常基本的可观察对象。同样，你会对它的代码之少感到震惊。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="bc2c" class="nk mj it ng b gy nl nm l nn no">class MyObservable {<br/><br/>    constructor(subscribe) {<br/>        this._subscribe <strong class="ng iu">= </strong>subscribe<br/>    }<br/><br/>    subscribe(observer) {<br/>        return this._subscribe(observer);<br/>    }<br/>}</span></pre><p id="4f36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MyObservable的构造函数接受subscribe回调，并将其分配给internal _subscribe字段。</p><p id="dd8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过调用public subscribe，我们可以用传入的Observer在内部调用_subscribe。通过这个函数调用，我们开始我们的可观察对象，告诉他用1，2，3调用我们的观察者的下一个，然后完成。</p><p id="0acf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！！现在，我们可以轻松地从顶部获取我们的代码片段，并交换Rx。用我们自己的习惯来观察。</p><p id="9b51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是等等。还记得我们如何传递三个函数而不是一个观察者对象吗？在我们目前的实现中，这还不可能。</p><h1 id="94c2" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">接受回调和观察者对象🤝</h1><p id="b5d5" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">为了接受回调和观察器，我们将实现一些小的转换逻辑。</p><p id="8d45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果用户传入三个函数，而不是一个回调函数，我们将把这些回调函数转换成一个Observer对象，然后传递给我们的内部subscribe函数。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="493c" class="nk mj it ng b gy nl nm l nn no">subscribe(next, error, complete) {<br/>    let observer;<br/>    if (typeof next <strong class="ng iu">=== </strong>'function') {<br/>        observer <strong class="ng iu">= </strong>{<br/>            next,<br/>            error<strong class="ng iu">: </strong>error <strong class="ng iu">|| </strong>function () {},<br/>            complete<strong class="ng iu">: </strong>complete <strong class="ng iu">|| </strong>function () {}<br/>        }<br/>    } else {<br/>        observer <strong class="ng iu">= </strong>next;<br/>    }<br/>    return this._subscribe(observer);<br/>}</span></pre><p id="ad79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将回调转换成可观察的对象非常简单。</p><blockquote class="oh oi oj"><p id="314f" class="ku kv ok kw b kx ky ju kz la lb jx lc ol le lf lg om li lj lk on lm ln lo lp im bi translated">如果第一个传入的值是一个函数，我们将在内部创建自己的观察器。如果用户没有传入一个错误或完整的函数，我们就给我们的可观察对象分配一个空函数。</p><p id="96bc" class="ku kv ok kw b kx ky ju kz la lb jx lc ol le lf lg om li lj lk on lm ln lo lp im bi translated">如果消费者决定传入一个观察者对象，我们不做任何转换，直接使用观察者对象。</p></blockquote><p id="c96c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">厉害！我们已经创建了一个非常基本的实现。🤠</p><p id="b87d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可观察的事物需要思维的转变，但它们不是纯粹的魔法。</p><h1 id="cf3a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">🧞‍ 🙏顺便说一下，点击👏🏻拍手声👏🏻按钮在左边(高达50倍)，如果你喜欢这篇文章。</h1><h1 id="47dc" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">掌声帮助其他人找到它，并鼓励我写更多的帖子</h1><p id="0a54" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">想知道如何测试你的可观测链？然后查看我的文章“关于RxJs marble测试和TestScheduler的发现”。</p><div class="lq lr gp gr ls lt"><a rel="noopener  ugc nofollow" target="_blank" href="/findings-about-rxjs-marble-testing-and-the-testscheduler-b23c6bdf6b49"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">关于RxJS marble测试和TestScheduler的发现</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">最近，我编写了一个定制的Rx操作符，用于重试失败的http请求。RxJS允许我们处理这种异步的方式…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">itnext.io</p></div></div><div class="mc l"><div class="oo l me mf mg mc mh ks lt"/></div></div></a></div></div></div>    
</body>
</html>