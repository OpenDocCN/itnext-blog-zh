<html>
<head>
<title>Build Your First Solidity Dapp With Web3.js and MetaMask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Web3.js和MetaMask构建你的第一个Solidity Dapp</h1>
<blockquote>原文：<a href="https://itnext.io/build-your-first-solidity-dapp-with-web3-js-and-metamask-b18d63196bb5?source=collection_archive---------1-----------------------#2021-07-18">https://itnext.io/build-your-first-solidity-dapp-with-web3-js-and-metamask-b18d63196bb5?source=collection_archive---------1-----------------------#2021-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbb280604eab6d8e219c26e0f8aea71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HJLIUKxSdYXJ-O_H.png"/></div></div></figure><p id="639f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，我在web3.js的<a class="ae kw" href="http://blog.adnansiddiqi.me/tag/solidity/" rel="noopener ugc nofollow" target="_blank"> Solidity系列</a>中计划了另一个主题，但是这篇文章可能会跑题，因此我正在讨论web3.js的基础知识以及如何与智能合同进行交互。我将使用我在这里创建的<a class="ae kw" href="http://blog.adnansiddiqi.me/develop-and-deploy-your-first-ethereum-smart-contract-with-python/" rel="noopener ugc nofollow" target="_blank">的同一个合同。基本上就是上一个帖子的web3.js版本。</a></p><p id="8a63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与其他关于使用NodeJs和React的基于web3.js的前端的帖子不同，我不会使用任何这样的东西，因为它不需要创建一个去中心化的应用程序的前端。你甚至根本不需要NodeJS。你可以使用你现有的技能，如PHP/Laravel、Django、Rails等，创建一个dApp，通过<em class="kx"> web3.js </em>与以太坊区块链对话。</p><p id="eea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将创建一个简单的基于HTML的界面，它将与我之前创建的智能契约进行交互。我们将学习如何与MetaMask交互，以及如何将MetaMask与Ganache连接。最后，该应用程序将像下面这样工作:</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/bf544cd924cf06b21e47ef17e7c717ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*U5Vwly9vWYwFqZFA.gif"/></div></figure><h1 id="9fe0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么是元掩码</h1><p id="844a" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">据MetaMask官方<a class="ae kw" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank">网站</a>:</p><blockquote class="mg mh mi"><p id="f13e" class="jy jz kx ka b kb kc kd ke kf kg kh ki mj kk kl km mk ko kp kq ml ks kt ku kv ij bi translated">区块链应用程序的加密钱包和网关</p></blockquote><p id="c0fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们从Chrome扩展开始，让网络应用与基于以太坊的区块链交互。用户通过创建一个新的钱夹或通过输入私钥创建一个现有的钱夹来与主网或测试网进行交互。</p><h1 id="c41a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">MetaMask和Ganache集成</h1><p id="f6bb" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在之前的帖子中，我已经告诉你如何设置Ganache。现在，我们必须将基于Ganache的区块链与MetaMask连接起来，这相当容易。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/dc37b76a60fec14aa39c2caa03566921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cj5rd8dtUH0zspD9.png"/></div></div></figure><p id="04d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RPC URL是由Ganache在其接口上提供的。<strong class="ka ir"> 1337 </strong>是Ganache的<em class="kx">链条ID </em>。</p><p id="474a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦连接了区块链节点，您就必须在MetaMask wallet中添加一个帐户。你所要做的就是从你的一个账户中导入密钥并标记它。出于开发目的，我在这里集成了我的第一个帐户。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/262f13c0b9d8790b4b4c056ac1905afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L8xKZAL1Izss4BsK.png"/></div></div></figure><p id="9dfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们开始编码。我们首先要做的事情之一是包含所有需要的库。除了<em class="kx"> web3.js </em>库之外，我还使用了<em class="kx"> Bootstrap </em>和<em class="kx"> Jquery </em>。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/115edb95ace3554e5b36d6e4431c38f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*6oFBceGFZ5Ozyn3r.png"/></div></figure><p id="b36e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我上面演示的同一个页面的结构。它包含灰显的元掩码图标，通知用户元掩码尚未安装。我们将编写代码来实现这一功能。</p><p id="ef37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个功能非常简单。当您添加<em class="kx">元掩码</em>时，它会全局暴露<code class="fe mp mq mr ms b">ethereum</code>对象。如果此对象可用，则意味着元掩码已启用。我正在使用jQuery来灰化/着色徽标。在我们调用它之前，我将使用jQuery的<code class="fe mp mq mr ms b">onready()</code>函数来调用它。</p><p id="9b4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行这段代码，它会产生以下结果</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/58e1b500e63dc039bb3e40955484783e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*8sTD4R4Q48qGCAKY.gif"/></div></figure><p id="99d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在上面看到的，当我删除扩展时，它禁用了按钮和徽标。</p><p id="59f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，下一步是编写<em class="kx">连接MetaMask </em>按钮的逻辑。为此，我在这里引入了一个新的函数<code class="fe mp mq mr ms b">conenct()</code>。我还将引入<code class="fe mp mq mr ms b">handleAccountsChanged</code>回调函数，它处理元掩码提供的<code class="fe mp mq mr ms b">eth_requestAccounts</code>方法的响应。</p><pre class="kz la lb lc gt mt ms mu mv aw mw bi"><span id="116d" class="mx le iq ms b gy my mz l na nb">function handleAccountsChanged(accounts) {<br/>            console.log('Calling HandleChanged')<br/>            <br/>            if (accounts.length === 0) {<br/>                console.log('Please connect to MetaMask.');<br/>                $('#enableMetamask').html('Connect with Metamask')<br/>            } else if (accounts[0] !== currentAccount) {<br/>                currentAccount = accounts[0];<br/>                $('#enableMetamask').html(currentAccount)<br/>                $('#status').html('')<br/>                <br/>                if(currentAccount != null) {<br/>                    // Set the button label<br/>                    $('#enableMetamask').html(currentAccount)<br/>                }<br/>            }<br/>            console.log('WalletAddress in HandleAccountChanged ='+walletAddress)<br/>        }</span><span id="5de8" class="mx le iq ms b gy nc mz l na nb">function connect() {<br/>            console.log('Calling connect()')<br/>            ethereum<br/>            .request({ method: 'eth_requestAccounts' })<br/>            .then(handleAccountsChanged)<br/>            .catch((err) =&gt; {<br/>            if (err.code === 4001) {<br/>                // EIP-1193 userRejectedRequest error<br/>                // If this happens, the user rejected the connection request.<br/>                console.log('Please connect to MetaMask.');<br/>                $('#status').html('You refused to connect Metamask')<br/>            } else {<br/>                console.error(err);<br/>            }<br/>            });<br/>        }</span></pre><p id="329d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">ethereum.request</code>是MetaMask提供的一个通用函数，用于执行不同的操作。在这里，我要求MetaMask返回所附的帐户。如果没有，它会弹出一个对话框来连接它。你可以在这里了解更多<a class="ae kw" href="https://docs.metamask.io/guide/ethereum-provider.html#methods" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/275153fa24f2e6b82868e4be0d073b03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*fA4ZQ767eIgodVa4.gif"/></div></figure><p id="7b86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面发生了很多事情。假设当我点击按钮时，您已经导入了钱包密钥，它会激活MetaMask界面，并要求您连接要在该网站上使用的钱包。你可以连接多个钱包，但现在，让我们依靠一个钱包。一旦它成功地连接了这个网站和钱包，我就在按钮上显示钱包地址。这个过程有点类似于典型的登录机制，在登录后显示一个欢迎说明。取消时，我显示一条消息，说明该网站的访问者拒绝连接他/她的MetaMask钱包。现在，无论您执行什么操作，都将使用您连接的钱包。</p><p id="525c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们已经连接了我们的钱包，现在剩下的唯一事情就是与智能合约进行交互。所以让我们开始写代码吧！</p><p id="03a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我刚刚注意到我还没有编写与Ganache交互的代码。为此，我们必须使用<em class="kx"> web3.js </em>库。我已经把它包含在我的HTML文件中了(<em class="kx">你不需要</em> <code class="fe mp mq mr ms b"><em class="kx">node</em></code> <em class="kx">或者</em> <code class="fe mp mq mr ms b"><em class="kx">npm</em></code> <em class="kx">来实现这个目的。毕竟，这是一个简单的JS库，我们可以保留老学校的一部分，但使用新技术</em>。</p><pre class="kz la lb lc gt mt ms mu mv aw mw bi"><span id="5605" class="mx le iq ms b gy my mz l na nb">let web3;<br/>let abi;</span><span id="9acc" class="mx le iq ms b gy nc mz l na nb">$.getJSON("build/contracts/FirstContract.json", function(result) {            <br/>    abi = result.abi<br/>});</span><span id="c827" class="mx le iq ms b gy nc mz l na nb">try {            <br/>      web3 = new Web3(new Web3.providers.HttpProvider("<a class="ae kw" href="http://localhost:7545" rel="noopener ugc nofollow" target="_blank">http://localhost:7545</a>"));<br/>} catch (error) {<br/>      alert(error)<br/>}</span></pre><p id="88b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了一些事情:在声明了所需的变量之后，我首先得到了契约的ABI。我们将在与智能合同例程交互时使用它。接下来，我将连接加纳切以太坊区块链。</p><p id="4b1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止还不错，现在我要添加一个函数，在这里命名为，<code class="fe mp mq mr ms b">getValue()</code>。这个函数将在页面加载时被调用。<code class="fe mp mq mr ms b">document.ready()</code>现在看起来如下:</p><pre class="kz la lb lc gt mt ms mu mv aw mw bi"><span id="9556" class="mx le iq ms b gy my mz l na nb">$( document ).ready(function() {<br/>            m = detectMetaMask()<br/>            if(m) {<br/>                $('#metaicon').removeClass('meta-gray')<br/>                $('#metaicon').addClass('meta-normal')<br/>                $('#enableMetamask').attr('disabled',false)<br/>                // connect() <br/>            } else {<br/>                $('#enableMetamask').attr('disabled',true)<br/>                $('#metaicon').removeClass('meta-normal')<br/>                $('#metaicon').addClass('meta-gray')<br/>            }</span><span id="a70b" class="mx le iq ms b gy nc mz l na nb">$('#enableMetamask').click(function() {<br/>                connect()<br/>            });</span><span id="9b5a" class="mx le iq ms b gy nc mz l na nb">try {            <br/>                web3 = new Web3(new Web3.providers.HttpProvider("<a class="ae kw" href="http://localhost:7545" rel="noopener ugc nofollow" target="_blank">http://localhost:7545</a>"));<br/>            } catch (error) {<br/>                alert(error)<br/>            }            <br/>            <br/>            //Fetch Value from Smart Contract<br/>            getValue()<br/>        })</span></pre><p id="5fdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mp mq mr ms b">getValue()</code>包含以下代码来与区块链交互。</p><pre class="kz la lb lc gt mt ms mu mv aw mw bi"><span id="e631" class="mx le iq ms b gy my mz l na nb">async function getValue() {<br/>            console.log('GetValue')<br/>            const contractFirst = new web3.eth.Contract(<br/>                        abi,<br/>                        contactAddress<br/>            );</span><span id="86b3" class="mx le iq ms b gy nc mz l na nb">contractFirst.methods.getValue().call().then(function (result) {                <br/>                $('#getValue').html(result)<br/>            });<br/>        }</span></pre><p id="0813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在创建<code class="fe mp mq mr ms b">eth.Contract</code>的实例，并在构造函数中传递<code class="fe mp mq mr ms b">abi</code>和<code class="fe mp mq mr ms b">contactAddress</code>。一旦它被建立，我在这里调用智能契约的<code class="fe mp mq mr ms b">getValue()</code>函数并在div中显示结果。</p><p id="fc7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我将编写按钮的<code class="fe mp mq mr ms b">click</code>事件将调用的<code class="fe mp mq mr ms b">setValue()</code>函数的逻辑，并将输入的值传递给智能契约。</p><pre class="kz la lb lc gt mt ms mu mv aw mw bi"><span id="1142" class="mx le iq ms b gy my mz l na nb">async function setValue() {<br/>            console.log('Set Value')<br/>            <br/>            input_value = $('#value').val()<br/>            <br/>            if(input_value.trim() == '') {<br/>                input_value = 0<br/>            }<br/>            if(!isNaN(input_value)) {<br/>                input_value = parseInt(input_value)   <br/>            }</span><span id="335d" class="mx le iq ms b gy nc mz l na nb">const contractFirst = new web3.eth.Contract(<br/>                        abi,<br/>                        contactAddress<br/>            );<br/>            <br/>            contractFirst.methods.setValue(input_value).send({from:currentAccount}).then(function (result) {<br/>                console.log(result);<br/>                $('#getValue').html(input_value)<br/>            });<br/>            <br/>        }</span></pre><p id="b0d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它与getValue() one非常相似。这里唯一的不同是我使用了<code class="fe mp mq mr ms b">send()</code>而不是<code class="fe mp mq mr ms b">call()</code></p><p id="e425" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我也在这里设置钱包地址。我这样做是因为当你在区块链传递一个值时，你实际上是在做一笔交易，因此它会从你的钱包中扣除油费。</p><p id="ab4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，所以当我单击设置值按钮时，它会返回以下JSON:</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/a835884491da10957f1ff22f21012372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y3ugI9dmPa-CGnIT.png"/></div></div></figure><p id="353a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以随时确认:</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/44778f1f48310ecefcb0e638672fb018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DO-WctD3-w5_x9dC.png"/></div></div></figure><p id="90fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，<em class="kx">事务哈希</em>是相同的。你可以看到<em class="kx"> 25 </em>是输入值。</p><h1 id="5ec8" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="49d7" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">所以在这篇(另一篇长)文章中，你学习了如何利用你现有的HTML/Javascript技能来编写dApps的前端。正如你在这里看到的，你不需要学习NodeJS或者React。因为它是一个HTML文件，所以我在Github上用名称<code class="fe mp mq mr ms b">contract_demo.html</code>提交了<a class="ae kw" href="https://github.com/kadnan/SolidityPythonTutorial/commit/f91655b774c86178c7da1cdde7b4a7c4ccab3e8c" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="dedb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于2021年7月18日</em><a class="ae kw" href="http://blog.adnansiddiqi.me/build-your-first-solidity-dapp-with-web3-js-and-metamask/" rel="noopener ugc nofollow" target="_blank"><em class="kx">http://blog . adnansiddiqi . me</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>