<html>
<head>
<title>Compressed 16-bit RISC-V instructions compared to AVR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与AVR相比，压缩的16位RISC-V指令</h1>
<blockquote>原文：<a href="https://itnext.io/compressed-16-bit-risc-v-instructions-compared-to-avr-1f58a0c1c90f?source=collection_archive---------0-----------------------#2022-05-21">https://itnext.io/compressed-16-bit-risc-v-instructions-compared-to-avr-1f58a0c1c90f?source=collection_archive---------0-----------------------#2022-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="38e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">由于AVR主要使用16位指令，因此与16位RISC-V指令进行比较会很有意思</h2></div><p id="6ab7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">ISC-V有压缩指令扩展<em class="ln"> C </em>，仅仅增加了400个门就能给RISC-V处理器提供16位指令。我认为将这27条指令与AVR微处理器的指令进行比较会很有趣，AVR微处理器是微控制器的知名处理器(用于Arduino)。这将与AVR的<a class="ae lo" href="http://www.avr-asm-tutorial.net/avr_en/overview/overview.html" rel="noopener ugc nofollow" target="_blank"> 78指令</a>的子集进行比较。</p><p id="3c5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的“备忘单”是通过在描述汇编指令的通用RISC-V和AVR符号之间找到一些折衷而制成的。我使用了AVR使用K来描述即时值的惯例。按照AVR惯例，寄存器被大写，如<code class="fe lp lq lr ls b">Rd</code>、<code class="fe lp lq lr ls b">Rr</code>、<code class="fe lp lq lr ls b">Rs1</code>和<code class="fe lp lq lr ls b">Rs2</code>。当访问内存位置<code class="fe lp lq lr ls b">K</code>的值时，AVR会写<code class="fe lp lq lr ls b">(K)</code>，但是我决定使用一种更像RISC-V的方式写<code class="fe lp lq lr ls b">M[K]</code>。在指令之间没有很好的映射的情况下，我要么跳过编写类似的指令，要么编写指令的组合。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="ab gu cl ly"><img src="../Images/68a7bddc339120b70243da16a3b83f01.png" data-original-src="https://miro.medium.com/v2/format:webp/1*AfRIeE2SLeXA9BsFdP0irg.png"/></div></figure><p id="660f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ln"> PDF可读性更好:</em> <a class="ae lo" href="http://blog.translusion.com/images/posts/RISC-V-vs-AVR-cheat-sheet.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> RISC-V和AVR指令集对比</em> </a> <em class="ln">。</em></p><p id="5727" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你只有16位来编码指令时，你必须做出许多妥协。我认为比较两种架构所做的一些妥协是很有趣的。</p><h2 id="27f6" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">RISC-V对寄存器使用的限制</h2><p id="5584" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">为了支持32个寄存器，需要留出5位来编码一个寄存器。如果你的指令做了很多事情，比如添加一个常数或者跳转到一个有偏移量的特定地址，那么你就没有多少位可以使用了。由于这个原因，AVR和RISC-V在使用16位指令时都不允许你寻址所有的寄存器。</p><p id="6561" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RV32C(RISC-V的压缩指令)只允许你直接指定8个最常用的寄存器<code class="fe lp lq lr ls b">s0</code>、<code class="fe lp lq lr ls b">s1</code>、<code class="fe lp lq lr ls b">a0</code>到<code class="fe lp lq lr ls b">a5</code>。这是因为只有3位被留出来指定寄存器。也有一些例外。<code class="fe lp lq lr ls b">MV</code>(移动)、<code class="fe lp lq lr ls b">ADD</code>、<code class="fe lp lq lr ls b">ADDI</code>(立即添加)、<code class="fe lp lq lr ls b">LWSP</code>(从SP加载字)和<code class="fe lp lq lr ls b">SWSP</code>(从SP存储字)提供对所有32个RISC-V寄存器的访问。</p><p id="4f9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些都是明智的选择，因为读写堆栈是非常常见的操作。这同样适用于复制和添加。<code class="fe lp lq lr ls b">a0</code>到<code class="fe lp lq lr ls b">a7</code>用于将参数传递给函数，但是大多数函数不会接受多达八个参数。五个应该够大部分了。</p><h2 id="a03a" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">寄存器使用的AVR限制</h2><p id="f885" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">使用AVR，您几乎可以将所有32个寄存器用作目的寄存器<code class="fe lp lq lr ls b">Rd</code>，这是AVR优于RV32C的一个优势。对于双操作数指令，如<code class="fe lp lq lr ls b">ADD</code>、<code class="fe lp lq lr ls b">AND</code>、<code class="fe lp lq lr ls b">OR</code>、<code class="fe lp lq lr ls b">MOV</code>和<code class="fe lp lq lr ls b">SUB</code>，源寄存器<code class="fe lp lq lr ls b">Rr</code>往往被限制为4位，总共有16个高位寄存器可供使用。</p><h2 id="e374" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">哪种指令集更好？</h2><p id="0001" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">这样的评估自然是相当主观的。如果我们只看16位指令，那么显然AVR指令更有能力。它们通常允许您访问更大范围的寄存器，并且有更多的16位指令可供使用。</p><p id="1567" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我选择了比较这两种指令集的道路，因为我感兴趣的是哪一种既能在内存有限的小型微控制器中运行良好，又能很容易地教给初学者。</p><p id="638e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得人们更难称之为赢家。RISC-V得益于具有更少但更通用的指令的设计。例如，RISC-V依赖于分支指令、加载和存储中的立即值和寄存器的组合，这使得它们都非常灵活。相反，AVR依赖于许多变体，例如带位移的加载，带后增量或前减量。分支是相对的、直接的和间接的。只是有更多的变量需要跟踪。</p><p id="6537" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，对于可以使用哪些寄存器，还有一些任意的限制。间接加载和存储只允许使用<code class="fe lp lq lr ls b">X</code>、<code class="fe lp lq lr ls b">Y</code>和<code class="fe lp lq lr ls b">Z</code>寄存器，它们实际上是寄存器对。</p><h2 id="15f1" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">RISC-V对汇编编码人员来说更容易</h2><p id="2efc" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">现在，RV32C有更多任意和复杂的限制，但一个关键的区别是，RISC-V汇编编码器需要关心这些限制。RISC-V汇编代码编写人员编写代码时，就好像所有32位指令都可用一样。只要有机会，汇编程序就会选择压缩的16位变量。如果我在RV32C允许的范围之外的寄存器中使用加载指令，那么汇编程序会自动为我选择一条32位指令。</p><p id="96b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，作为一名程序员，我只需要处理一个看起来非常干净和正交的指令集，而没有很多奇怪的边缘情况。那么，这是不是意味着RISC-V赢了？</p><h2 id="01f5" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">AVR更容易分析</h2><p id="ca3a" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">没那么快。AVR使得在重要的子程序中只用16位指令编程变得很容易。32位指令相对较少，可以轻松避开(<code class="fe lp lq lr ls b">CALL</code>、<code class="fe lp lq lr ls b">LDS</code>、<code class="fe lp lq lr ls b">STS</code>、<code class="fe lp lq lr ls b">JMP</code>)。这使得通过计算指令来判断一段代码将消耗多少时钟周期成为可能。如果您知道时钟频率，就可以很容易地计算出不同代码段需要多长时间。对于高级编码来说，这是无关紧要的，但对于时序很重要的低级微控制器编码来说，这种能力在我看来是一件好事。</p><p id="2f9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个优势是基于AVR的Arduino板的运行时钟频率低于闪存，因此这使得指令的执行速度非常可预测。您不需要处理高速缓存未命中、分支预测失误和流水线停顿。</p><h2 id="25ff" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">带ATmega328P或SiFive FE310的Arduino板？</h2><p id="dacc" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">比较这两种芯片的一个可用的方法是看一些硬件，这适合初学者进行微控制器开发和编程。那是我最感兴趣的领域。最原始和最著名的Arduino板是Arduino Uno R3。它运行在一个<a class="ae lo" href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" rel="noopener ugc nofollow" target="_blank"> ATmega328P </a>微控制器芯片上。我们可以将其与硬件兼容板进行比较，SparkFun的<a class="ae lo" href="https://www.sparkfun.com/products/15594" rel="noopener ugc nofollow" target="_blank"> RED-V RedBoard </a>基于<a class="ae lo" href="https://starfivetech.com/uploads/fe310-g002-datasheet-v1p2.pdf" rel="noopener ugc nofollow" target="_blank"> SiFive FE310-G002 </a>微控制器。</p><p id="ff3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于RISC-V的主板的一个主要缺点是价格昂贵。SparkFun的Arduino Uno R3售价为24美元，而RED-V RedBoard的售价为42美元，几乎是前者的两倍。另一方面，如果你比较规格，它会更有能力。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="ab gu cl ly"><img src="../Images/83b454a117430bf7326dcfdcc31a4f8e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hIMUfmeVkGY6hsT5BD5GQA.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">挑选和基于AVR或RISC-V的Arduino板的利弊</figcaption></figure><p id="1733" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在许多方面，与爱好者通常想要做的事情相比，它完全被压制了。它有将近1000倍的闪存。SRAM容量增加16倍。以高出20倍的时钟频率运行。因为它以如此高的频率运行，所以它使用SRAM作为缓存，因为闪存不够快。我认为这是负面的，因为处理缓存未命中意味着运行代码的时间更加不可预测。</p><p id="8722" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这款芯片所基于的SiFive的E3系列内核有一个锦囊妙计。他们支持他们所谓的<em class="ln">紧密集成内存</em> (TIM)。您可以将指令缓存和数据缓存配置为像常规内存一样工作。这提供了基于AVR的解决方案在时间上的可预测性。</p><p id="f417" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一些其他的负面因素。RISC-V板没有任何模拟输入。这些在许多项目中都很方便。业余爱好者的另一大优势是<a class="ae lo" href="https://www.sparkfun.com/products/10524" rel="noopener ugc nofollow" target="_blank"> ATmega328P可以在DIP封装中购买</a>。那是什么意思？你得到的微控制器本身是一个有28个引脚的芯片，你可以把它插在试验板上。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="ab gu cl ly"><img src="../Images/aaafc0a27624d783e4dcfecc1f548d52.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_yHHNaLgOEsN0mj-Zb8Y9Q.jpeg"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">Arduino板上的微控制器可以直接插入试验板，如图所示。</figcaption></figure><p id="5dc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于业余爱好者来说，这太棒了，因为你可以从很多地方买到这些用Arduino引导加载程序预编程的家伙。SparkFun仅售6.5美元。您可以在常规Arduino Uno R3板上交换这些芯片。这允许你在Arduino板上开发一个解决方案，当你完成后，你可以把它移到一个试验板上，得到一个便宜且更持久的解决方案。</p><h2 id="e32f" class="mb mc it bd md me mf dn mg mh mi dp mj kr mk ml mm kv mn mo mp kz mq mr ms mt bi translated">结论</h2><p id="f43a" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">比较这两种解决方案是一项持续的工作，随着我的进一步探索，我将会写更多关于这个主题的文章。目前我还没有下定决心。我认为RISC-V有一个非常引人注目的汇编代码指令集。在很多方面，我也更喜欢工具环境。我主要用macOS和Linux，远离Windows。AVR编程和工具都是以Windows为中心的。事实证明，为运行在macOS或Linux上的AVR处理器找到好的模拟器是很困难的。对于RISC-V，我发现了许多选择。</p><p id="4d64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别是，我想对<a class="ae lo" href="https://github.com/mortbopet" rel="noopener ugc nofollow" target="_blank">莫滕·博鲁普·彼得森</a>表示感谢，感谢他制作了令人敬畏的<a class="ae lo" href="https://github.com/mortbopet/Ripes" rel="noopener ugc nofollow" target="_blank"> Ripes模拟器。</a>它可以让你非常详细地了解RISC-V处理器是如何工作的，并且很容易上手。</p><p id="9217" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">米歇尔·波莱制作了一个AVR模拟器，名为<a class="ae lo" href="https://github.com/buserror/simavr" rel="noopener ugc nofollow" target="_blank"> simavr </a>，看起来真不错。唯一的问题是我还不知道如何运行它。这一直是我在macOS和Linux上使用AVR的问题。它们不容易使用，我正在寻找对初学者友好的工具。</p><p id="0c09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个理想的世界里，RISC-V微控制器生态系统要成熟得多。这将使选择变得更容易，但现在，我们有几个没有明确赢家的选择。让事情变得复杂的是，我们可以加入Arm，它实际上已经在Arduino生态系统中广泛使用。</p><p id="7a00" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我没有进一步探索ARM，因为现代ARM指令集相当复杂，而且在我看来对初学者并不友好。至少这是我的印象。也许，如果在拇指模式下运行，这不是一个问题。对于那些在AVR和基于Arm的板上都做过微控制器汇编编程的人来说，听听你的经历会很酷。</p></div></div>    
</body>
</html>