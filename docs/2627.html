<html>
<head>
<title>What is the Future of Container Image Building?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集装箱形象建设的前景如何？</h1>
<blockquote>原文：<a href="https://itnext.io/what-is-the-future-of-container-image-building-46fc92876d98?source=collection_archive---------2-----------------------#2019-06-27">https://itnext.io/what-is-the-future-of-container-image-building-46fc92876d98?source=collection_archive---------2-----------------------#2019-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4c2bf69b043ea5a26272e07481ac3c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cdlenZuMh4k6X2tc.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">发布在<a class="ae kc" href="https://blog.giantswarm.io/what-is-the-future-of-container-image-building/" rel="noopener ugc nofollow" target="_blank"> Giant Swarm的博客</a>上的原始文章</figcaption></figure><p id="2e28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从某种意义上说，自从Docker 1.0在2014年夏天发布以来，似乎没有任何时间，但从另一种意义上说，却感觉像过了一辈子。在接下来的4到5年中，云原生范式已经发展成为一个全面的行业，大大小小的企业都将自己的生存寄托在云原生带来的所谓好处上。</p><p id="de86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结出这一果实的种子是Docker对容器抽象的推广，它为开发人员提供了一种将应用程序定义为自给自足、不可变的包(容器映像)的机制。然而，尽管云原生技术领域的发展速度惊人，但自2014年夏天以来，我们定义容器映像的方式，以及我们将它们构建成可用工件的方式，却变化甚微。随着容器技术的发展和成熟，容器映像构建过程中的缺陷和限制慢慢暴露出来，这导致了云原生社区中的一些挫折。</p><p id="1dd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的一两年里，不同的项目涌现出来，试图解决一些或所有这些缺陷。在这一系列名为“容器图像构建的艺术状态”的文章中，我们将关注其中的一些项目和工具，看看它们是如何规避已知问题的。</p><p id="67b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在我们这样做之前，我们首先必须了解容器映像构建的基础，以及我们试图克服的缺陷。</p><h1 id="b2ad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Dockerfiles和API构建端点</h1><p id="8fa5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">历史上，容器映像是在docker文件中定义的，使用声明性指令集来生成文件系统内容和元数据，以通知容器运行时引擎如何运行派生的容器。然后使用Docker引擎的API端点构建容器映像，Docker引擎顺序执行每个Dockerfile指令来创建内容，或者记录与正在构建的映像相关的元数据。构建端点总是使用Docker客户机的docker build命令来执行。</p><p id="5bc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，创作容器图像需要我们使用一组适当的Dockerfile指令及其相关参数来定义图像，然后使用Docker引擎API来构建图像。简单，这有什么错呢？</p><h1 id="a476" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对Docker守护进程的依赖</h1><p id="3cac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个常见的问题是，使用Docker引擎API构建容器映像需要使用Docker守护进程。Docker守护进程包含许多功能，其中大部分与构建容器映像的任务完全无关。此外，对于它执行的许多其他功能，它需要以root权限运行，正如我们将在后面看到的，这带来了安全问题。如果手头的任务是制作容器映像，那么仅仅为了这个目的部署Docker守护进程是笨拙而低效的，并且对于CI/CD管道来说不是最佳的。有一种观点认为，容器映像构建体验应该是无梦的。</p><h1 id="49b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无效缓存</h1><p id="1c16" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Docker引擎很早就有了缓存功能。这意味着，如果从一个构建到下一个构建的Dockerfile指令的执行导致相同的命令被运行，或者相同的内容被添加到映像，那么将使用缓存的内容，而不是重新创建它。它大大加快了映像构建的速度，使整个过程更加高效。</p><p id="1561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，由于构建API的顺序性质，一旦缓存由于内容或Dockerfile指令的改变而无效，Dockerfile中的每个后续指令都将被再次执行。不管那些后续指令是否已经改变，都会发生这种情况。这意味着需要非常注意指令的顺序，以便最大限度地提高构建缓存的效率。</p><h1 id="449a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">顺序执行</h1><p id="0973" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正如我们所说的，低效的构建缓存使用是构建过程中顺序执行Dockerfile指令的副作用。如果仔细考虑了指令排序，那么指令的顺序执行是不成问题的。然而，当在API中引入<a class="ae kc" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段</a>构建时，构建执行的顺序性抑制了主要的潜在好处；不相关指令的并行执行。当然，这与构建所需的时间长度有关，在某些情况下，构建所需的时间可以大大减少。当在应用程序开发期间迭代映像构建时，这可能会大大延长该过程。</p><h1 id="0d2e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装临时内容</h1><p id="0e1f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通常，构建容器映像的过程依赖于或受益于临时提供的内容。换句话说，我们希望内容在构建过程中出现，但不希望它出现在最终产品中，因为这会不必要地增加图像的大小。例如，我们需要源代码来构建二进制文件，但不需要最终映像中的源代码。我们可以利用编译器<a class="ae kc" href="https://golang.org/cmd/go/#hdr-Build_and_test_caching" rel="noopener ugc nofollow" target="_blank">构建缓存</a>来加快构建，但是我们不希望缓存在映像本身中。</p><p id="ccd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多阶段构建可以帮助我们解决这个问题，但是更好的解决方案是在构建过程中需要的时候临时装载内容。尽管无数<a class="ae kc" href="https://github.com/moby/moby/issues/3156" rel="noopener ugc nofollow" target="_blank">请求</a>添加该功能的变体，但它从未进入Dockerfile指令语法，或作为docker build命令的命令行参数。</p><h1 id="90a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">建立秘密</h1><p id="1a50" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有时，我们需要使用秘密来访问需要客户端验证和授权的内容。例如，我们可能需要提供一个SSH密钥来从GitHub或类似的地方克隆一个存储库，这样我们就可以利用构建中的内容。在构建过程中，可以将秘密从主机复制到映像中，但这会带来秘密仍然嵌入在映像中的风险，以便任何有权访问映像的人随后进行审查。我们甚至可能会尝试使用环境变量，但是这种方法也容易被利用。</p><p id="6741" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有人提议添加一个构建特性来处理图像构建所需的秘密，但是没有一个提议能够合并到API中。最佳实践指南的承诺已经成为图像构建者的最佳选择。这对容器图像作者来说是一个巨大的挑战，需要使用一些新的技术作为解决方法。</p><h1 id="abd4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建权限</h1><p id="186b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Docker守护进程要求客户端要么拥有root访问权限，要么是<code class="fe me mf mg mh b">docker</code>组的成员，以便与API及其构建端点进行交互。这通常被认为是不可取的，甚至在一些对访问特权帐户有严格政策的组织中被禁止。实际上，这使得构建容器映像的任务非常困难。</p><p id="0a5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们希望在使用Docker作为容器运行时的Kubernetes集群中构建映像时，这一点会进一步扩展——可能作为CI/CD工作流的一部分。为了利用运行在Kubernetes节点上的Docker引擎API，我们必须将守护进程的套接字安装到一个“客户端”容器中，以便构建时可以访问它。从安全角度来看，这是危险的，因为它有效地给予了容器对节点的根访问权，并且完全绕过了Kubernetes抽象。另一个解决方案可能是避免在节点上使用Docker守护进程，而使用Docker-in-Docker (DinD)来提供一个自包含的映像构建环境。但是，这也有安全隐患，因为运行DinD的容器需要作为特权容器运行。</p><p id="4ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一段时间以来，获得“无根”构建一直是社区中的一个追求。</p><h1 id="c9ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="f540" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">尽管有这些限制，使用Docker的构建API端点和Dockerfile语法仍然是构建容器映像的主要方法。Docker Hub和Quay等公共图像注册中心托管的成千上万张图像及其相关的Docker文件就证明了这一点。但是这些限制也促使新的技术和工具出现，这些技术和工具旨在解决其中一些问题，并增强容器映像构建体验。这些工具是在社区支持下开放开发的，并且在功能上经常重叠。为了更好地理解容器图像构建的最新技术，本系列的下一篇文章将探讨提供了什么。</p><p id="8e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">准备好将您的云原生项目投入生产了吗？简单地请求你的大群邀请<a class="ae kc" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="0815" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由<a class="ae kc" href="https://twitter.com/puja108" rel="noopener ugc nofollow" target="_blank">Puja Abbas si</a>——开发者倡议@ <a class="ae kc" href="https://giantswarm.io/" rel="noopener ugc nofollow" target="_blank">巨型虫群</a>撰写</p><div class="mi mj gp gr mk ml"><a href="https://twitter.com/puja108" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ir gy z fp mq fr fs mr fu fw ip bi translated">Puja Abbassi (@puja108) |推特</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Puja Abbassi的最新推文(@puja108)。开发者关系&amp;产品@ GiantSwarm研究员；主题…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">twitter.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jw ml"/></div></div></a></div></div></div>    
</body>
</html>