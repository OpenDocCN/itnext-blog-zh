<html>
<head>
<title>Easy patterns: Chain Of Responsibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:责任链</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-chain-of-responsibility-9a84307ad837?source=collection_archive---------2-----------------------#2019-03-03">https://itnext.io/easy-patterns-chain-of-responsibility-9a84307ad837?source=collection_archive---------2-----------------------#2019-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b72dcd3a0fb719b8d44f37b355734c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*A-RUUrXZtJmW5ImF853Xsg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">责任链模式的结构</figcaption></figure><p id="d87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是easy patterns系列描述的延续，提出了一个名为责任链的行为模式，它通过添加一个或多个有机会以特定方式处理请求的处理对象来帮助避免请求发送者和接收者之间的耦合。</p><p id="9548" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也请参考其他模式文章:</p><h2 id="f002" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创作模式:</h2><blockquote class="lp lq lr"><p id="fa0f" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ka ir">简易工厂</strong> </a></p><p id="2004" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ka ir">工厂法</strong> </a></p><p id="8fab" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ka ir">建造者</strong> </a></p><p id="0e6b" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ka ir">单个</strong> </a></p><p id="73db" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ka ir">抽象工厂</strong> </a></p><p id="9d90" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ka ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结构模式:</h2><blockquote class="lp lq lr"><p id="4425" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ka ir">适配器</strong> </a></p><p id="5343" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ka ir">装饰者</strong> </a></p><p id="a7f3" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ka ir">桥</strong> </a></p><p id="2353" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ka ir">复合</strong> </a></p><p id="2cca" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ka ir">立面</strong> </a></p><p id="9d1e" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"> <strong class="ka ir">飞锤</strong> </a></p><p id="797a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ka ir">代理</strong> </a></p></blockquote><h2 id="c975" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">行为模式:</h2><blockquote class="lp lq lr"><p id="052a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ka ir">来访者</strong> </a></p><p id="8f4d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ka ir">调解员</strong> </a></p><p id="ee43" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ka ir">观察者</strong> </a></p><p id="2da6" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ka ir">纪念物</strong> </a></p><p id="e199" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ka ir">迭代器</strong> </a></p><p id="f257" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><strong class="ka ir">责任链</strong>(本文)</p><p id="ccf5" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ka ir">策略</strong> </a></p><p id="f43d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4"> <strong class="ka ir">状态</strong> </a></p></blockquote><h1 id="113c" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">主要本质</h1><p id="1d05" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">耦合减少是通过给多个对象一个处理请求的机会来实现的。链项接收请求，并在一些逻辑将请求传递给处理程序链中的下一个处理程序。</p><p id="b85c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">链中的第一个对象接收请求，并处理它或将其转发给链中的下一个候选对象，后者也会这样做。发出请求的对象不知道谁将处理它——请求有一个隐式接收者<strong class="ka ir"/>。</p><p id="6276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式包括两个主要角色:</p><ul class=""><li id="1e4f" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><strong class="ka ir">处理程序— </strong>定义处理请求的接口，处理请求本身并实现后继链接</li><li id="8f8a" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated"><strong class="ka ir">客户端</strong> —向链上的处理程序对象发起请求。</li></ul><h1 id="fcdb" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">使用示例</h1><p id="7c8c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在这个例子中，我们将创建一个咖啡机，它包含一组<strong class="ka ir">处理程序</strong>，这些处理程序接受要修改的咖啡杯项目和后续链接，以便将控制传递给集合中的下一个处理程序。每个咖啡杯项目都包含名为<code class="fe nh ni nj nk b">ingredientsToBeAdded</code>的内部属性，您可以将它想象成订单中的标签，这样咖啡师(我们示例中的咖啡机)就知道在咖啡中添加什么。<code class="fe nh ni nj nk b">setNewIngredients</code>方法会用一个新的咖啡杯替换一个咖啡杯，并设置新的配料加入其中，之后你可以用更新的配料设置再次<code class="fe nh ni nj nk b">processCoffee</code>。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="7990" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">利润</h1><p id="99c8" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">如果许多对象应该能够处理请求，而专门的处理程序事先不知道，那么责任链模式是有用的，它将在运行时确定。</p><p id="4be0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以不明确地确定请求的特定处理程序，而是为这个请求定义一组潜在的处理程序。这组处理程序请求的对象可以在运行时动态定义。它使对象不必知道哪个对象处理请求。一个对象只应该知道一个请求将被适当地处理。因此，责任链可以简化对象互连。</p><p id="7f7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">增加了为对象分配责任的灵活性。您可以通过在运行时添加或更改链来添加或更改处理请求的职责。</p><h1 id="3891" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">薄弱的地方</h1><p id="a188" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">责任链给处理特定请求的逻辑带来了一些复杂性。如果可以在运行时定义特定的处理程序集，那么可能会有多种结果(我们不能确定哪个具体的处理程序集会出现在特定的请求中)。所以，通过计划单元测试来预测一个特定的结果是很困难的。</p><p id="d6d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为请求没有明确的接收者，所以根本不能保证它会被处理。</p><p id="49ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">责任链的配置应该仔细。当链配置不正确时，请求也可能无法处理。</p><h1 id="7afe" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">结论</h1><p id="9b34" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">目前，这种模式已经在许多地方找到了一席之地。例如，在支付逻辑中，如果用户持有多张信用卡，您应该实施不同的策略。在这种情况下，我们可以有一套策略，每个策略将检查它是否可以应用于特定的银行卡。</p><p id="01d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，Express (NodeJS)或Redux(用于处理全局应用程序状态的lib)有一个特殊的地方来放置一个额外的逻辑，称为中间件。这些中间件功能接受当前状态对象和到后继者的链接(后继者将当前状态传递给中间件集中的下一个中间件处理器)。</p><p id="6f52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">责任链通常与<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158">复合</a>模式结合使用。在那里，一个组件的父组件可以作为它的后继组件。</p><p id="a1d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>