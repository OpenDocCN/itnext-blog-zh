<html>
<head>
<title>Virtual Filesystem in Go — Completing Filesystem Initialization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚拟文件系统正在运行—完成文件系统初始化</h1>
<blockquote>原文：<a href="https://itnext.io/virtual-filesystem-in-go-completing-filesystem-initialization-2470e3bd8243?source=collection_archive---------5-----------------------#2021-03-11">https://itnext.io/virtual-filesystem-in-go-completing-filesystem-initialization-2470e3bd8243?source=collection_archive---------5-----------------------#2021-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它远没有标题所暗示的那么花哨。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/65ac3b53f6b36ccf16ea9bdffb3286a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1ZwO-wKpUMXIiR4WYmRtw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">这是我在网上找的一碗拉面。这个周末我吃面条了。他们太棒了。</figcaption></figure><p id="ed53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个周末，我在一家高级餐厅吃了第一碗高级拉面。然后我品尝了一些绿茶冰淇淋。我起初不喜欢它，但后来喜欢上了它，但为时已晚，我已经离开了餐馆。我一直带着这份遗憾。</p><p id="efa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前进到文章。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="7dda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做到了，读者；我们终于完成了<code class="fe li lj lk ll b">initFilesystem()</code>。我终于完成了我说过我会做的事情(几乎是当我说我也会做的时候，但是5/10比0好)。我必须承认，这很振奋人心。运行它；信号提示要求我们的用户名，然后就有了；一个类似Unix的环境，里面有我们所有的文件和文件夹，完全可读。在我的Windows CMD中运行这个程序给人一种真正的Linux体验，它不是一个子系统，而是我的CMD中的Linux。我终于做出了独特的东西。</p><p id="c43a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这个开头令人难以忍受地沾沾自喜，但这段代码完全是一场混乱的递归和字符串连接的车祸，只有完全疯狂的人才会对推进它们的回购感到舒服。但是很管用！现在，这就够了。:D</p><p id="9d54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注视我们的文件系统！它活着！</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">顺便说一下，如果有人知道如何使这些在更高的质量，请让我知道:d。</figcaption></figure><p id="b997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们打开过去一周的创伤。</p><h2 id="74bf" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">initFilesystem终于到来了</h2><p id="a835" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated"><code class="fe li lj lk ll b">initFilesystem</code>终于奏效了。很多很多周以后。虽然才过了四年，但感觉我已经做了很久了。</p><p id="d52c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们绕场一周，穿过我经历的所有恐怖，来到这里。</p><p id="70bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:本周我决定通过添加大代码块的截图来给这些文章注入一些色彩。如果你感兴趣并且是这些的热心读者，请让我知道这是否有效。好了继续。</p><p id="b7c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/8fedb3b5db1b840fc39804367727f85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9UfC0q03hY6pQC8zzT3qQ.png"/></div></div></figure><p id="f45d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe li lj lk ll b">makeFilesystem</code>命令是对创建单个<code class="fe li lj lk ll b">fileSystem</code>对象的代码的重构。它采用的参数是要创建的目录的名称、目录的绝对路径和指向其父目录的指针(或者根目录的<code class="fe li lj lk ll b">nil</code>)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/a815f305e8383d830f1ce55858f41ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_bJhNbTN-K3Q1vL0yq4Pw.png"/></div></div></figure><p id="362d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe li lj lk ll b">testFIlesystemCreation</code>(实名TBA)中的第一段代码是这样的。</p><pre class="km kn ko kp gt mo ll mp mq aw mr bi"><span id="b934" class="lo lp iq ll b gy ms mt l mu mv">dirName == "." {<br/>  root = makeFilesystem(".", ".", nil)<br/>  fs := root<br/></span></pre><p id="2ff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的功能本质上是原始<code class="fe li lj lk ll b">initFilsystem</code>主代码体的压缩版本。它只是创建一个文件对象，设置根目录并创建我们将在导航中使用的<code class="fe li lj lk ll b">fs</code>。</p><p id="a044" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一位代码<code class="fe li lj lk ll b">files,_ := ioutil.ReadDir(dirNmae)</code>；读取当前目录级别的所有文件和目录。这给了我们一个这个级别的目录名列表，然后我们开始循环。</p><p id="c780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遍历for循环，您会注意到在<code class="fe li lj lk ll b">os.Stat</code>方法中它接受的参数；<code class="fe li lj lk ll b">dirName + "\\" + fileName.Name()</code>。这里发生的是，为了访问关于目标文件名的实际文件信息，我们需要它的相对路径，相对于我们开始运行程序的位置。</p><p id="1e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果目录<code class="fe li lj lk ll b">path/to/file/</code>中有一个文件<code class="fe li lj lk ll b">file1</code>，那么<code class="fe li lj lk ll b">fileName</code>中的<code class="fe li lj lk ll b">Name()</code>方法将只返回<code class="fe li lj lk ll b">file1</code>，因此<code class="fe li lj lk ll b">Stat</code>将在我们当前所在的目录中寻找<code class="fe li lj lk ll b">file1</code>，而不是它实际存储的目录。所以我们需要在前面加上它所在的目录名，在我们的例子中是<code class="fe li lj lk ll b">dirName</code>,由于令人困惑的递归原因，我很难解释清楚。</p><p id="b79f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:这段代码中使用的<code class="fe li lj lk ll b">\\</code>是Windows中如何形成路径的，我将在调试时添加一个检查来适应Linux/OSX系统。</p><p id="db3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在目标文件上运行<code class="fe li lj lk ll b">os.Stat</code>之后，我们能够提取关于文件的各种信息；如果你愿意，这是统计数据。我们可以获取任何信息，从时间戳到文件权限，到目标名称是文件还是目录，但是由于我们在版本1中，我们将只对最后一个细节感兴趣；目标文件是否确实是一个目录。</p><p id="e2e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们运行<code class="fe li lj lk ll b">fi.Mode()</code>，变量<code class="fe li lj lk ll b">mode</code>就会有这个信息。所以剩下的就是使用<code class="fe li lj lk ll b">IsDir</code>来检查目标文件是否是一个目录。如果它是一个文件，我们只需将它添加到<code class="fe li lj lk ll b">fileSystem</code>对象的<code class="fe li lj lk ll b">files</code>列表中。如果是一个目录，创建新的目录并递归调用<code class="fe li lj lk ll b">testFilesystemCreation</code>对我们刚刚创建的子目录做同样的事情。</p><p id="9063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe li lj lk ll b">initFilesystem</code>来说差不多就是这样了。终于起作用了。最终结果是一个意想不到的工作良好的文件系统，有一个shell与之交互。</p><h2 id="11b5" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">其他的事情</h2><p id="c73c" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">本周的更新中还有其他内容。对主shell循环的另一个新的新的新的变化和对<code class="fe li lj lk ll b">shell</code>对象处理它自己的内置的方式的一个重构。</p><p id="c83b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还增加了一些功能；这些也从单纯的调试支持升级到完全成熟的功能；这些实用程序是<code class="fe li lj lk ll b">cat</code>命令和<code class="fe li lj lk ll b">shell</code>自己的<code class="fe li lj lk ll b">usage/execute</code>功能。</p><p id="5dfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe li lj lk ll b">execute</code>对于<code class="fe li lj lk ll b">shell</code>的对象如下。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/0d39829d63c6e01cb4b4a86628bfe14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jupiq2rpa4MbyNLlYXovA.png"/></div></div></figure><p id="f390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而<code class="fe li lj lk ll b">usage</code>对它来说是；</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/2d26308223624dfa3e7715c2eb99f62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkwFZIi7NSIceZdJtQQ0yw.png"/></div></div></figure><p id="8e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些函数的行为基本上与您在<code class="fe li lj lk ll b">fileSystem</code>对象中找到的那些函数相同，但是有它们自己独特的实用程序和对其返回时间的更新(现在也返回一个布尔值)；</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/f491beab98bb1942769f5b16fed97607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzQAjgzmYe-EB_O_LGOSqw.png"/></div></div></figure><p id="d7d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们在主<code class="fe li lj lk ll b">shellLoop</code>中的新修改用法如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2903ed8871b88e9c00f38f9fa402ba99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*HzFXm1Vn06SLoFyf9fuASQ.png"/></div></figure><p id="115a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当有命令输入时，它会首先传递给<code class="fe li lj lk ll b">shell</code>的执行函数。如果它不是一个shell可执行文件，那么它将最终被传递给<code class="fe li lj lk ll b">fileSystem</code>的执行函数。如果不存在，将会抛出错误消息。正确的命令可以由<code class="fe li lj lk ll b">shell.execute()</code>或<code class="fe li lj lk ll b">fs.execute()</code>捕获，此时程序将运行，循环在该点结束。</p><h2 id="ac8d" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">添加CAT实用程序</h2><p id="0d1b" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这是本周最后一个大的增加。将文件内容转储到终端屏幕的能力。Linux和OSX用户将会识别语法；<code class="fe li lj lk ll b">cat filename</code>而Windows CMD用户会使用<code class="fe li lj lk ll b">type filename</code>作为他们的等价物。</p><p id="e3e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最初这只是为了调试，以确保文件及其正确的内容被复制到系统中的<code class="fe li lj lk ll b">file</code>结构中，但后来我决定为什么不这样做/实现起来有多难。</p><p id="6c45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然是著名的遗言。</p><p id="01de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe li lj lk ll b">cat</code>的代码如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/368f2f754b119747a51f887811bfa6e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoGFkkKvOew6ejYDehoA6A.png"/></div></div></figure><p id="7021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数使用了很多助手函数，我们不需要详细描述，因为它们的功能非常简单。基本的控制流程是传递给程序的参数是一个有效的文件。如果名字中有任何表示可能需要目录遍历的<code class="fe li lj lk ll b">/</code>，我们就使用旧的帮助函数<code class="fe li lj lk ll b">verifyPath</code>。这可以确保在尝试读取文件内容之前，文件名前面的路径已经存在。</p><p id="2813" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果路径存在，<code class="fe li lj lk ll b">verifyPath</code>将返回一个临时的<code class="fe li lj lk ll b">fileSystem</code>对象，指向我们试图转储的文件所在的目录。然后我们验证文件名是否存在于那个<code class="fe li lj lk ll b">fileSystem</code>对象的<code class="fe li lj lk ll b">files</code>数组中，如果存在，我们打印出它的内容。</p><p id="14bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里要注意的一点是，现在，你会注意到当<code class="fe li lj lk ll b">testFilesystemCreation</code>创建一个文件时，它只保存文件名和它的路径。里面没有储存任何东西。我仍然在确定在文件系统运行时将每个文件保存在内存中与在编辑完文件后只保存文件内容的权衡，确保我们只真正读取我们想要改变的内容。这样做的好处是加载文件系统很快，但保存虚拟副本可能需要更长时间，因为保存的副本无论如何都必须读取每个文件。</p><h2 id="be91" class="lo lp iq bd lq lr ls dn lt lu lv dp lw jy lx ly lz kc ma mb mc kg md me mf mg bi translated">结论——继续第5部分</h2><p id="232a" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">本周是具有挑战性的一周，我的心不在这篇文章上，主要是因为我贡献的使文件系统工作的代码很乱，我认为我可以做得更好，但在我个人的最后期限之前也无法找出如何做。我尝试了一种新的风格，希望能让阅读更大的代码块变得更容易忍受，但是请让我知道你的想法。</p><p id="9cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，唉，我觉得我们已经快完成版本1了。下一个巨大的挑战是找到一种可靠的方法来编辑文档；一种用于文件系统的文本编辑器。对于什么是虚拟文件系统，如果您不能编辑。还有一种文件格式标准，当我们完成时，我们保存图像并从中读取以加载该系统的版本。</p><p id="0cf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件格式？我是不是在暗示一个我很快就会发布的超级酷的小项目，它与逆向工程和二进制补丁有关？我猜你只能等着看:d。</p><p id="6eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你知道规矩。接下来是自述文件，要修复的错误和要进行的单元测试。有几件事我没注意到，只是事后才发现。本周的另一个灾难是，这里的一些代码可能与回购中的代码不一致，因为在编写本文的中途发生了许多热修复。</p><p id="f630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我想就是这样。</p><p id="11cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本作的工作当然:<a class="ae nc" href="https://github.com/AlysonBee/GoVirtualFilesystem/tree/master/src/04" rel="noopener ugc nofollow" target="_blank">https://github . com/alyson bee/govirtualfile system/tree/master/src/04</a></p></div></div>    
</body>
</html>