<html>
<head>
<title>Building a Decentralized Application with BEP-20 contract in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用BEP-20契约构建一个分散的应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-decentralized-application-with-bep-20-contract-in-solidity-d2c066447aa6?source=collection_archive---------1-----------------------#2021-08-03">https://itnext.io/building-a-decentralized-application-with-bep-20-contract-in-solidity-d2c066447aa6?source=collection_archive---------1-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4ae80a4ff2c14b8626bd9fdf97be0072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*beNNk4dNgWcVyjA6L7uWJg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">珀西·博尔默拍摄的图片</figcaption></figure><p id="79ca" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你已经找到了这篇文章，那么我猜你有兴趣了解更多关于如何使用区块链构建应用程序的知识。我们将介绍如何设置所使用的环境，构建一个可以使用BEP-20令牌的简单应用程序。令牌将有一个超级简单的赌注能力，奖励用户的赌注。本文将<strong class="kj iu">假设在</strong>之前很少或没有使用区块链和solidity的经验。</p><p id="741e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">本系列是四篇文章的第一篇，每篇都有自己的主题。</p><ol class=""><li id="4303" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le lk ll lm ln bi translated"><strong class="kj iu">【在Solidity中用BEP-20契约构建一个去中心化的应用】</strong> —这篇文章将帮助你理解Solidity的基础知识</li><li id="fee4" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><a class="ae lt" href="https://medium.com/@percybolmer1/creating-a-inheritable-staking-contract-in-solidity-7804ae2d7a32" rel="noopener"> <strong class="kj iu">【在实体中创建可继承的赌注契约】</strong> </a> —第二篇文章，我们将介绍更高级的实体物品，并实现赌注和奖励</li><li id="efdb" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><a class="ae lt" href="https://medium.com/@percybolmer1/using-a-smart-contract-in-an-web-application-78432ed68527" rel="noopener"> <strong class="kj iu">【在Web应用程序中使用智能合约】</strong> </a> —本系列的第三篇文章，我们将学习如何使用元掩码通过Web应用程序连接到区块链</li><li id="6ee3" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><a class="ae lt" href="https://medium.com/@percybolmer1/deploying-smart-contracts-to-binance-smart-chain-with-truffle-c57a7d1eb6ed" rel="noopener"> <strong class="kj iu">【将智能合约部署到币安松露智能连锁店】</strong> </a> —第四篇也是最后一篇文章，我们将学习如何将智能合约部署到真实网络中</li></ol><p id="1f55" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们开始深入研究代码之前，我想确保解释一些关于该技术的基本术语。</p><h2 id="fbcb" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">BEP-20</h2><p id="9767" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">BEP-20是在币安智能链上创建令牌时使用的标准。币安学院对此有很好的解释。从开发人员的角度来看，该标准要求币安智能链上的所有令牌都必须满足特定的接口。</p><p id="a4a7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">接口是需要在契约(令牌)中出现的一组功能。模板界面可以在<a class="ae lt" href="https://docs.binance.org/smart-chain/developer/BEP20Token.template" rel="noopener ugc nofollow" target="_blank">币安文档</a>中找到。</p><p id="637a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这些是BEP20接口中定义的功能。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0684" class="lu lv it mx b gy nb nc l nd ne">function totalSupply() external view returns (uint256);<br/>function decimals() external view returns (uint8);<br/>function symbol() external view returns (string memory);<br/>function name() external view returns (string memory);<br/>function getOwner() external view returns (address);<br/>function balanceOf(address account) external view returns (uint256);<br/>function transfer(address recipient, uint256 amount) external returns (bool);<br/>function allowance(address _owner, address spender) external view returns (uint256);<br/>function approve(address spender, uint256 amount) external returns (bool);<br/>function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span></pre><p id="c1f7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在你可能还不明白函数声明中的所有项意味着什么，但是不要担心。这就是你在这里的原因。币安文档提供了一个完整的BEP20实现，它可以被我们的令牌继承，所以它是即插即用的。但是我们将自己实现这些方法，因为我们想了解它是如何实现的以及它做了什么。</p><h2 id="78d9" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">与BEP-20相关的以太网</h2><p id="7be4" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">在研究BEP-20时，你们中的许多人可能会发现提到以太坊以及以太坊是如何工作的。这是因为币安智能链令牌是ERC-20接口(以太网标准令牌)的扩展。这使得币安智能链也可以在以太坊区块链上运行。你可以在币安学院了解更多。</p><h2 id="2c58" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">智能合同</h2><p id="d566" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">通常被称为在区块链上运行的代码。智能合同是我们使用Solidity来管理和执行应用程序的业务逻辑而编写的。</p><blockquote class="nf ng nh"><p id="c967" class="kh ki ni kj b kk kl km kn ko kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld le im bi translated">在区块链上运行的应用或程序— <a class="ae lt" href="https://academy.binance.com/en/articles/what-are-smart-contracts" rel="noopener ugc nofollow" target="_blank">币安学院</a></p></blockquote><h2 id="6e14" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">挑战</h2><p id="4c92" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">DeFI代表分散金融。与金融相关的应用程序运行在一个分散的区块链网络上。你可以阅读<a class="ae lt" href="https://www.investopedia.com/decentralized-finance-defi-5113835" rel="noopener ugc nofollow" target="_blank">拉克什·夏尔马</a>更深入的解释。就币安而言，它只是半分散的。</p><h2 id="d255" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">DApp</h2><p id="158c" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">分散应用程序(DApp)，意思是应用程序运行在分散的计算机系统上。例如币安智能合约。这里可以找到很棒的解释<a class="ae lt" href="https://www.investopedia.com/terms/d/decentralized-applications-dapps.asp" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="036a" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">固态</h2><p id="2a12" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">Solidity是区块链和智能合约中最常用的编程语言。在<a class="ae lt" href="https://docs.soliditylang.org/en/v0.8.4/index.html" rel="noopener ugc nofollow" target="_blank"> Soliditylang </a>可以获得solidity文档。</p><h1 id="b815" class="nm lv it bd lw nn no np lz nq nr ns mc nt nu nv mf nw nx ny mi nz oa ob ml oc bi translated">设置开发环境</h1><p id="4744" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">让我们从创建一个开发环境开始。创建一个目录作为开发的根文件夹。我将我的项目命名为dev-token。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="78fe" class="lu lv it mx b gy nb nc l nd ne">mkdir dev-token &amp;&amp; cd dev-token</span></pre><p id="c657" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将使用Ganache和Truffle来帮助我们开发智能合约。</p><p id="07ee" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu"> Truffle </strong>是一个在以太坊区块链上构建/测试/开发智能合约的框架。块菌可以帮助我们快速开始建造，也容易部署。块菌通过npm安装。如果你没有npm，<a class="ae lt" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">在这里下载</a>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7b17" class="lu lv it mx b gy nb nc l nd ne">npm install -g truffle</span></pre><p id="e686" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu"> Ganache </strong>用于本地模拟以太坊区块链。这可以用来在将智能合约部署到生产环境之前测试它们。它还创建了预填充钱包(100以太)的区块链，以便我们可以模拟和测试智能合约，而无需投资任何资金。</p><p id="2ec6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Ganache可以通过访问他们的网站下载</p><div class="od oe gp gr of og"><a href="https://www.trufflesuite.com/ganache" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">加纳切|松露套房</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">部署契约，开发您的分散式应用程序(dapps ),并对智能契约进行测试。可作为…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.trufflesuite.com</p></div></div><div class="op l"><div class="oq l or os ot op ou jz og"/></div></div></a></div><p id="88f6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们还需要一个额外的断言包来为第2篇文章中更高级的部分松露。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0e54" class="lu lv it mx b gy nb nc l nd ne">npm install truffle-assertions<br/>npm install chai</span></pre><h2 id="5900" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">建造你的第一个BEP-20令牌</h2><p id="d2bf" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">让我们开始初始化一个新的truffle项目，这将为我们创建一个模板应用程序。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cc00" class="lu lv it mx b gy nb nc l nd ne">truffle init</span></pre><p id="3826" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Truffle init会为我们创建一个模板应用程序，非常好看。您应该会看到一条消息，提示初始化成功。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/6dd5b490980974dbf2fe67e342aae5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MvpA8loF4x1Ak2T5h5khA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">成功创建后的松露初始化输出</figcaption></figure><p id="97d9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在，您应该会在项目文件夹中看到4个项目。</p><ul class=""><li id="09df" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le ow ll lm ln bi translated"><strong class="kj iu">合同</strong> —包含我们项目的智能合同的文件夹</li><li id="9612" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated"><strong class="kj iu">迁移</strong> —包含部署相关代码的文件夹</li><li id="ca3d" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated"><strong class="kj iu">测试</strong> —包含用于测试智能合约的代码的文件夹。</li><li id="c79e" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated"><strong class="kj iu"> truffle-config.js </strong> —项目的配置文件。我建议打开它，看看选项。有关于使用什么网络、编译和测试的配置。</li></ul><p id="0fde" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们从命名和创建我们将使用的令牌开始。将文件contracts/Migrations.sol重命名为适合您的令牌名称的任何名称。另外，删除里面的示例文本。我们将从头开始创建令牌。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c3d7" class="lu lv it mx b gy nb nc l nd ne">mv contracts/Migrations.sol contracts/DevToken.sol</span></pre><p id="9959" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将创建我们的第一个基本令牌，这将是一个简单的草案，我们将在以后添加更多的功能。让我们变得简单，创建一个超级简单的智能合同。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">要点显示了我们的DevToken示例的代码</figcaption></figure><p id="fb6b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可能会问，上面的代码发生了什么，我们将要学习。</p><p id="a5a5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">该文件以智能合同的许可证开始，在我的例子中，我使用的是MIT许可证。<br/>其次，我们需要指定solidity要使用的编译器版本，这是通过<strong class="kj iu"> pragma </strong>关键字来完成的。在撰写本文时，0.8.4是当前发布的版本。记得记下你使用的版本，因为这在我们编译时很重要。</p><p id="1b25" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们用关键字<strong class="kj iu"> contract </strong>定义我们的契约。我们还有一个构造函数，它将在创建令牌时被触发。现在，它不会做任何事情，但是这里我们将为智能合约添加所需项目的初始化。</p><p id="7b4b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们试着编译代码，看看是否一切正常。为此，您需要进入<strong class="kj iu"> truffle-config.js并更新编译器版本。</strong></p><p id="fe45" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">找到配置的编译器部分，取消注释并更改编译器中要使用的版本，以匹配我们的智能合约所使用的版本(0.8.4)。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oz"><img src="../Images/f99c1ce733ef91644bc78428bcbdffd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBtWxJJFAUBg9oUfcIRWBA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这是我当前的编译器配置</figcaption></figure><p id="7856" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">确保您在项目的根目录下，并运行以下命令</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="69b2" class="lu lv it mx b gy nb nc l nd ne">truffle compile</span></pre><p id="16ed" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您应该不会遇到任何错误，但是如果您遇到了，错误消息应该非常简单，并且可能与您的智能合同中的一个打字错误有关。</p><p id="7cd9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">既然智能合同已经编译好了，让我们在<strong class="kj iu"> migrations </strong>文件夹中创建一个部署脚本。将里面的文件重命名为适当的名称，尝试在名称中包含相关的智能合同，以便于导航。一旦这里有了很多迁移脚本，你会感谢我的。</p><p id="b001" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我已经把我的<strong class="kj iu">命名为1_deploy_devtoken.js </strong>。我们现在只使用一个超级简单的部署脚本。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">迁移—超级简单的迁移脚本</figcaption></figure><p id="0149" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将继续开发智能合同，让我们确保一切工作之前。Truffle migrate用于部署编译后的智能合同。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a52b" class="lu lv it mx b gy nb nc l nd ne">truffle migrate</span></pre><p id="4f13" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">什么，没用吗？这是正确的，因为truffle将默认使用本地以太网。您应该会看到类似图像的错误。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pa"><img src="../Images/92dd68b792e4716762d68ba0270161f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9e7Da2bkH39zMeY4iLXDow.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">显示我们无法连接到区块链网络的错误消息。</figcaption></figure><h2 id="9c41" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">设置本地测试网络(Ganache小型简介)</h2><p id="aa59" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">我们的下一步是部署它来创建区块链网络。我们将通过使用Ganache来使用本地网络。通过运行安装章节中下载的应用程序来启动Ganache。</p><p id="b61f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您应该会看到一个漂亮的闪屏，要求您创建一个工作区。选择新工作区。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/d4f3c07ecc6b4cad7ec58e739feb4dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rc4XUkYgLS7r9thRiuHZ9A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Ganache启动闪屏。</figcaption></figure><p id="ea48" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">给你的工作区取一个好听的名字，你也可以通过按“添加项目”来上传truffle-config.js，让Ganache更好地了解正在发生的事情。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/98bdb2368fd37d2348f0c9a85bbf4cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cU0i-VY1IfuOEy10XG1jQg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">ganache——用我们的truffle-config创建一个新的工作空间。</figcaption></figure><p id="04be" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">保存工作区，您现在应该看到使用默认ETH余额集创建的新地址。您可以更改网络ID和IP等，但为了避免麻烦，跳过这一步。如果你决定改变它，不要忘记更新你的truffle-config.js来匹配网络。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/2876077f62793a75a96f6c5154b492c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBsS8YsSKyIBoOC8IL2w8A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Ganache —网络帐户概述</figcaption></figure><p id="83b3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Ganache包含许多关于网络的信息，还在contracts选项卡中列出了所有可用的合同。</p><h2 id="146b" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">测试令牌</h2><p id="6c7f" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">让我们继续并重试块菌迁移。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="af09" class="lu lv it mx b gy nb nc l nd ne">truffle migrate</span></pre><p id="e135" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这一次，迁移应该成功了，您应该看到令牌已经部署，并且使用了一些ETH。记住这是以太坊网络的工作方式。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/da2f9fe7dbfc5e572272824a17bf5109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq8-vagQahPOmAR6J05rsg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">部署在本地以太网上的DevToken</figcaption></figure><p id="0b8c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您现在可以访问Ganache并转到Contracts选项卡，您应该在那里看到您的合同，并能够进入它以查看更多详细信息。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/14fca66f4dc3e11a48c487fdca2bac3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D26HolgX9stnYAKhKJqs_Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Ganache —智能合同详细概述</figcaption></figure><h2 id="000f" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">实现BEP20接口</h2><p id="fcd9" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">我们将从实现BEP20所需的所有功能开始，在此过程中，我将尝试解释每一件事及其含义。</p><p id="4ded" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们需要在合同中记录一些项目，我们不会一开始就添加所有内容，而是从一些值开始。很抱歉文字墙，但我不希望我们错过任何细节。我保证，一旦我们完成了基础部分，我们就会加快速度。这就是我们将要创建的，现在，请务必阅读代码，以便理解我下面的解释。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken.sol —开始，我们现在可以创建一个带有一些值的简单契约</figcaption></figure><p id="1ebe" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将需要能够提供一个<strong class="kj iu"> totalSupply </strong>，这意味着我们需要跟踪我们的合同总共包含多少令牌。</p><p id="5940" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们还需要提供<strong class="kj iu">小数</strong>，这是我们合同的小数精度。</p><p id="6538" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">符号</strong>是我们合同的简称，以及<strong class="kj iu">名称</strong>是合同的名称。</p><p id="7ff2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们希望跟踪合同中的所有账户余额也是有意义的。因此我们将创建一个<strong class="kj iu">映射</strong>，它使用一个<strong class="kj iu">地址</strong>作为查找键，并将账户余额作为值存储为uint256。</p><p id="65f5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">Solidity中的映射是键值映射</strong>。可以把它想象成其他语言的散列图。</p><p id="3c98" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">注意所有东西都有私有的<strong class="kj iu">修饰符</strong>？在solidity中，我们可以分配修饰符，给我们的变量一些访问限制。<strong class="kj iu"> Private </strong>意味着这些变量只能从契约内部访问。</p><p id="accf" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将更新构造函数来接受这些值，这样就可以在创建令牌时定义它们。如果使用字符串数据类型，将变量作为输入参数添加到构造函数中会触发错误。是时候学习一些存储数据的方法了。</p><h2 id="9973" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">Solidity中的内存使用</h2><p id="0ced" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">有三种方式告诉契约如何存储数据<strong class="kj iu">，存储、内存、回调。</strong>某些数据类型会要求您指定这一点。</p><p id="6fd2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">存储</strong>表示数据在合同有效期内存储在区块链上，<strong class="kj iu">内存</strong>在函数有效期内存储。<strong class="kj iu">回调</strong>是一个更复杂的数据位置，我们还不会讨论它。使用数据位置的成本也是按这个顺序来的，存储最贵，内存、回调较便宜。如果你想深入了解数据位置的内部工作方式，请阅读文档。</p><p id="fcc2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在构造函数中，我们还会将totalSupply添加到<strong class="kj iu"> msg.sender. </strong>您可能想知道那是谁，我第一次也是这样想的。Msg是一个变量，在你的所有函数中都可以访问，根据调用函数的人，这个值会发生变化。在可靠性中，有几个变量是所谓的<strong class="kj iu">特殊变量</strong>，它们在函数中总是可访问的。这些变量与请求的上下文密切相关。所以我们可以找到时间戳，油费，等等。我认为最常用的是<strong class="kj iu"> msg.sender </strong>，它是调用函数的地址。</p><h2 id="0288" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">固体和以太坊区块链的事件</h2><p id="5c41" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">我们添加的最后一个新东西是<strong class="kj iu">事件</strong>。事件是记录区块链(或EVM，真的)正在发生的事情的一种方式。因此，如果我们想要记录正在发生的事务，我们就必须<strong class="kj iu">发出</strong>(发送)事件。这与执行操作不同，这只是日志记录！但是事件还有一个非常有用的特性。我们的应用程序可以监听事件，因此这对于我们将在本系列的第3部分中构建的web UI非常重要。</p><p id="02f1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">通过调用<strong class="kj iu"> Emit </strong>关键字来发送事件。我们将在代码的后面阶段查看这一点。</p><p id="2286" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">事件真的很简单，你指定名称，它将包含的值。然后，您发出一个事件并设置所需的值。仅此而已。</p><p id="25c7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">由于我们更新了构造函数，我们还需要更改迁移脚本，以便赋值。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">1_initial_migration.js —用我们在构造函数中的值更新了要部署的迁移。</figcaption></figure><p id="81a9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">之后，让我们尝试在测试网络上重新部署智能契约。小注意，重新部署到一个真实的网络并不容易，我们不会在这里涵盖，所以请确保您测试您的合同正确！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="53e2" class="lu lv it mx b gy nb nc l nd ne">truffle migrate</span></pre><p id="bcd4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">重新部署后，打开Ganache并进入Contracts选项卡，找到您的令牌。您现在应该会看到更多的值，如供应量和最终余额。您还可以看到传输的事件。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/7eca491a13394dcbd454e3a9a519ba16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JVqnlrqFLKTUv8NqZyu5g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Ganache —在我们的活动中展示新部署的智能合同</figcaption></figure><h2 id="8ada" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">实现BEP20功能的时间到了</h2><p id="d63d" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">现在我们可以部署我们的简单令牌，让我们开始实现接口，这不会是很多工作，因为我们刚刚掌握了基础。</p><p id="dadd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们从最简单的部分开始，我们希望允许用户检索我们设置的变量。它们目前是私有的，所以让我们确保为它们创建一些Getters。getter是一个公共函数，可以从契约外部调用。</p><p id="9347" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这里没有太多新的，我们可以看一下函数的修饰符(是的，solidity中的函数可以有多个修饰符)。</p><p id="39c2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">外部</strong>是一个修饰符，告诉编译器可以从其他契约和事务中调用该函数。外部函数不能从它们所在的契约内部调用！</p><p id="57dd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">视图</strong>修饰符告诉编译器，函数承诺不以任何方式修改契约的状态，视图函数不能改变任何东西的值！这景色对我们的吸气剂有好处。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken.sol —实现我们的getter函数。</figcaption></figure><p id="6d8a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们为我们的令牌创建更多高级特性之前，我认为是时候开始<strong class="kj iu">编写单元测试</strong>了。测试对于确保智能合约按照我们想要的方式运行非常重要。有多种方法可以进行测试，例如，truffle附带了一个控制台，您可以通过键入来进入(您需要位于代码所在的目录中)。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d1b0" class="lu lv it mx b gy nb nc l nd ne">truffle migrate // Redploy first to update with our new functions<br/>truffle console</span></pre><p id="25a6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在那里你可以使用javascript来测试。我将展示一个超级简单的控制台示例，如何调用已部署契约的函数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d41a" class="lu lv it mx b gy nb nc l nd ne">// Wait until the token is deployed<br/>devToken = await DevToken.deployed()<br/>// Grab the total supply, use await to make sure we get the response<br/>let totalSupply = await devToken.totalSupply()<br/>// totalsupply will unusable amount, convert to number<br/>totalSupply.toNumber()</span></pre><p id="0c1a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们可以使用truffle编写一个单元测试，就像我们刚刚测试控制台一样，这比试图测试控制台中的所有功能要友好得多。</p><p id="9bd9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在<strong class="kj iu">测试</strong>文件夹中创建一个名为<strong class="kj iu"> DevToken.js </strong>的文件。Truffle允许我们用javascript和Solidity编写测试，我更喜欢用javascript，因为我发现它更容易。javascript测试必须遵循Mocha或Chai测试框架，你可以在<a class="ae lt" href="https://www.trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript" rel="noopener ugc nofollow" target="_blank"> truffles网站</a>上阅读更多关于测试的内容。</p><p id="558c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">语法很简单，我们从签订合同开始。每个测试都被语法识别</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5e3d" class="lu lv it mx b gy nb nc l nd ne">it(“name of test”, async accounts =&gt; { our test logic})</span></pre><p id="9552" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们使用与truffle控制台相同的语法，即javascript。<br/>第一个测试非常简单，获取总供应量并查看它是否与我们在迁移脚本中使用的相符。</p><p id="b519" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后我们使用<strong class="kj iu"> assert.equal(actual，expected，errormessage) </strong></p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken.js —初始电源测试</figcaption></figure><p id="584e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">转到您的控制台，使用以下命令运行truffle来执行测试。你必须位于你的项目的根。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c433" class="lu lv it mx b gy nb nc l nd ne">truffle test</span></pre><p id="925a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">太好了，修复任何最终的错误，它应该工作。<br/>让我们继续，我们现在将研究修改区块链状态的函数。</p><p id="03a5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将从增加<strong class="kj iu">燃烧</strong>和<strong class="kj iu">铸造</strong>代币的能力开始。造币厂是一个用于可靠性的术语，意思是创造新的代币。Burn 是相反的术语，它从合同中删除令牌。这非常像我们在创建令牌时在构造函数中所做的。</p><p id="f788" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu"> Mint </strong>将获取一个地址，并在该地址余额上创建代币，并增加总供应量。</p><p id="616a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">燃烧</strong>会做相反的事情，摧毁代币，减少总供应量。</p><p id="5bbb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将创建的第一个版本将可以从智能合约外部访问，这很容易通过添加<strong class="kj iu"> public </strong>修饰符来实现。我们将会在稍后创建更多<strong class="kj iu">安全的公共可用版本</strong>。因为它需要一些更高级的特性来保证它们的安全，这样任何人都不能创建令牌。</p><p id="14b6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们在这里介绍的新项目不多。</p><p id="a01b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">需要最重要的一个<strong class="kj iu">。Require有点像我们之前测试中的assert。<strong class="kj iu"> Require将确保我们的条件在继续</strong>之前得到满足。如果给定的条件为假，Require将取消带有错误消息集的功能。重要的是要知道require会在函数被触发时将函数中的任何改变恢复到状态。因此，您刻录令牌的图像，然后在函数的后面有另一个需要检查哪些触发器，刻录操作将被还原。</strong></p><p id="d4f1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">另外，请注意我们如何使用_balances映射提取用户的帐户余额。映射使用起来非常简单，因为我们可以使用地址键来访问值，而且也很便宜。</p><p id="1743" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我还添加了一个BEP20接口需要的函数，它是的<strong class="kj iu">balance，用于查询一个账户的余额。到目前为止，您应该不难理解这个函数是如何工作的。</strong></p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —铸造和燃烧，以便我们可以膨胀/收缩令牌</figcaption></figure><p id="6703" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们添加一些测试，这样我们就知道这些函数如我们所期望的那样工作。</p><p id="8831" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们的测试现在将只引入一个新东西，try-catch。这就是我们如何能够捕捉到任何由可靠性需求引发的错误。因此，每个因需求而退出的函数都应该包装在一个try-catch中。catch将把返回值存储在变量error中(您可以在catch(name)中给它取任何名字)。Error是一个包含几个值的变量，试着打印出来看看所有的值，我们要断言的值就是<strong class="kj iu">原因。</strong>这将是您在智能合约功能的<strong class="kj iu">需求</strong>中设置的错误信息。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —燃烧和铸造测试</figcaption></figure><p id="5492" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们添加同样需要的<strong class="kj iu">传输</strong>功能。这一次我们将只添加两个函数，它们将是同一个函数，但具有不同的修饰符。我想是时候把注意力放在修饰词上了。这些函数将从一个帐户获取令牌，并将它们插入另一个帐户。</p><p id="d5aa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们已经看到了<strong class="kj iu">公开</strong>和<strong class="kj iu">内部</strong>修改器。</p><p id="aba7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">像我们在测试中一样，公共函数可以从契约的外部和内部调用。内部函数不能从外部调用。我认为这很容易理解。不过我来对外介绍一下<strong class="kj iu">。</strong></p><p id="d1a7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu"> External是一个修饰语，意思是这个函数只能从契约外部调用</strong>。如果您认为函数永远不需要从契约内部调用，请使用此修饰符。现在你会问我，为什么，为什么把事情复杂化而不使用public？</p><p id="a026" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们很快就会明白一切，我们将创建两个<strong class="kj iu">转移</strong>方法，一个叫做<strong class="kj iu">转移</strong>，第二个叫做<strong class="kj iu">_转移</strong>。转让将是外部的，可从外部调用，_转让将是内部的，只能从合同内部获得。这样做的原因是因为我们可以假设transfer会从外部调用很多，因为人们会四处移动他们的令牌。<strong class="kj iu">外部花费比公共职能更少的汽油。</strong>所以有两个功能，一个是给用户发垃圾邮件，一个是内部通话。这种设置使得我们的契约比两个动作都使用公共函数要便宜得多。如果你想了解为什么它更便宜，这都与solidity在函数调用期间如何访问和存储数据有关。你可以阅读Solidity <a class="ae lt" href="https://docs.soliditylang.org/en/v0.7.4/types.html#reference-types" rel="noopener ugc nofollow" target="_blank">参考类型</a>来了解更多。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —转移和内部转移功能到位。</figcaption></figure><p id="656b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">除了使用两个不同的函数节省汽油之外，这些函数没有任何新的东西。是时候为这些功能添加测试了，我们将尝试将令牌从帐户0转移到帐户1。</p><p id="f878" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我想澄清的一件事是，我们的转移令牌本身没有必需的检查，但这是因为它们需要由_transfer触发的条件。</p><p id="b970" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们建立一个测试，以确保传输工作正常，我还想看看你是否注意到一些重要的事情。在我们以前的测试中，<strong class="kj iu">我们从来没有真正设置过转移过程中使用的账户</strong>。这是因为Truffle帮助了我们，但这次让我们确保它是测试期间使用的正确帐户。</p><p id="ad0b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这可以通过在我们的函数中设置<strong class="kj iu"> from </strong>参数来实现，这将把<strong class="kj iu"> msg.sender </strong>的值设置到from参数中的account集合中。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">dev token——转移测试以确保它按预期工作</figcaption></figure><p id="8f7f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">继续运行测试以确保一切正常。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b44a" class="lu lv it mx b gy nb nc l nd ne">truffle test</span></pre><p id="8ed4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们开始研究BEP20的最终功能之前，这些功能都与<strong class="kj iu">津贴</strong>有关。津贴意味着帐户所有者可以允许其他用户从所有者的帐户购买或使用X数量的令牌。</p><p id="d247" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">首先，我希望我们确保更改mint和burn函数，以应用与transfer和_transfer相同的模式，这意味着我们将添加一个<strong class="kj iu"> _burn </strong>和<strong class="kj iu"> _mint </strong>，并更改一些逻辑。不要恨我改东西，我要你学！</p><p id="e9a3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们现在这样做的原因是，我们现在也将在Solidity中研究<strong class="kj iu">继承</strong>。我们不希望任何人能够调用mint和burn函数，但是我们希望它们是公共的。我们现在将添加一些通常被称为仅拥有者修改器的东西。这意味着即使该函数是公共的，也只有智能合约的所有者才被允许使用它。</p><p id="3f6c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">找到burn和mint功能，将<strong class="kj iu">修改器从public改为internal </strong>。同样，将它们重命名为<strong class="kj iu"> _burn和_mint </strong></p><p id="025a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们将添加两个新的函数，burn和mint，这两个函数是公共的，只需将函数调用转发给它的_对应物。这是我应用的变化</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">增加了一个内部+公共铸造和燃烧</figcaption></figure><p id="f9c3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">尝试重新运行测试，一切都应该像以前一样工作，因为我们没有改变任何打破。剩下的就是实现一个所有者检查，这样这些函数就不会被其他人利用。</p><h2 id="aef7" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">智能协定中的继承</h2><p id="a025" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">为此，我们将创建一个新的智能契约，并将该契约作为DevToken的一部分进行继承。这很简单，所以不要害怕。</p><p id="d6fa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在contracts文件夹中创建一个名为<strong class="kj iu"> Ownable.sol </strong>的文件</p><p id="eda6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">正如DevToken.sol一样，我们应该用编译器版本和许可证来启动该文件。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1c21" class="lu lv it mx b gy nb nc l nd ne">// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.4;</span></pre><p id="020c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将创建一个名为<strong class="kj iu"> _owner的私有变量，</strong>私有意味着这个变量只能从声明它的契约中访问。所以只有Ownable契约能够修改_owner变量。</p><p id="1614" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这个契约中，我们唯一要做的新事情就是创建我们的修改器。修饰符将被称为<strong class="kj iu"> onlyOwner </strong>，它将执行一个标准的要求来检查<strong class="kj iu"> msg.sender == _owner。</strong>这意味着如果我们将<strong class="kj iu"> onlyOwner应用于我们的函数，那么这个检查将在函数被触发之前发生。</strong>这是一种设置函数需求的简单方法，无需重复代码来检查许多函数中的相同内容。</p><p id="86a5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">构造函数将把_owner赋给msg.sender。这将起作用，因为我们的构造函数在部署契约时被调用，所以它是所有者。</p><p id="aadd" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">请注意，在修饰符函数中，_；不是一个错别字，它必须在那里编译器让你通过。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">own able——限制用户访问的简单而有效的方法</figcaption></figure><p id="6805" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们再添加三个函数，因为令牌的所有者可能想要继续生活中的其他事情，或者让其他人拥有它。</p><p id="83d4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将添加功能放弃所有权，并转移到另一个地址。在这种情况下，没有什么新的东西需要你学习，它只是额外的代码，你应该能够自己遵循它。请注意这些函数是如何使用onlyOwner修饰符的！</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Ownable —允许所有权转移</figcaption></figure><p id="a904" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们想要测试这个契约，所以在test文件夹中创建一个Ownable.js。</p><p id="30d7" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">还要确保<strong class="kj iu">更新migrations/1 _ initial _ migration . js</strong>以部署我们新的Ownable合同(我们很快会再次删除它，稍后会解释)</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">1 _ initial _ migrations.js还部署可拥有的合同</figcaption></figure><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们自己的合同的测试功能。</figcaption></figure><p id="d174" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">运行测试，一切都应该检查出来，如果你按照我的名单。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2834" class="lu lv it mx b gy nb nc l nd ne">truffle test</span></pre><p id="fc61" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">是时候将Ownable继承到DevToken中了。实际上，继承意味着两个契约(或者将来更多)将合并成一个契约。这意味着在继承之后，我们将只有一个契约，即DevToken。<strong class="kj iu">这也是我们将再次从迁移中删除Ownable部署的原因。</strong></p><p id="0429" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">再次打开DevToken.sol，为了继承另一个契约，我们使用关键字<strong class="kj iu"> is。</strong>因此，我们将把DevToken契约更新为is Ownable。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —现在可拥有</figcaption></figure><p id="149d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">经过这次更改后，DevToken现在拥有了我们添加到Ownable智能契约中的所有功能。让我们在<strong class="kj iu"> 1_initial_migrations.js </strong>中移除own able的部署，并更新<strong class="kj iu"> Ownable.js </strong>中的测试，改为在DevToken契约上运行。</p><p id="2c5b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">测试中唯一需要更改的是artifacts.require行。<br/>与其让常量Ownable成为一个Ownable工件，不如让它要求DevToken。仅此而已！</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bb9d" class="lu lv it mx b gy nb nc l nd ne">// Replace this row <br/>const Ownable = artifacts.require("Ownable");<br/>// With this <br/>const Ownable = artifacts.require("DevToken");</span></pre><p id="e803" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">重新运行测试，并确保它的工作！</p><p id="0ec5" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">干得好，我们现在知道了如何创建自定义修饰符以及如何继承其他契约。</p><p id="e26a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们应用onlyOwner来保护mint和burn功能。如果我以前没有提到这一点，是的，一个函数可以有许多乘数。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —仅可从所有者处调用Burn &amp; Mint</figcaption></figure><h2 id="8f76" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">添加余量BEP20的最后部分</h2><p id="33ec" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">是时候添加BEP20需要的最终函数了。津贴意味着帐户1可以说“嘿，帐户2可以从我的帐户中访问X个令牌”。</p><p id="b455" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这里没有需要理解的新项目，只是有更多和以前一样的代码。所以我不会像到目前为止那样详细解释。你现在看到的每一段代码都应该与我们以前做过的事情相关。</p><p id="b047" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">代码中唯一困难的部分是变量，我们将使用它来存储允许的津贴，这是一个像余额一样的映射，但返回的值是另一个映射。所以一个以地址为键的映射，值也是另一个以地址为键的映射，但是金额是值。</p><p id="34c6" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">其思想是，外部映射将是所有者的地址，而存储为值的子映射将是支出者的映射。</p><p id="f697" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">[OwnerAccount][Spender]将是从映射中提取Spender的语法。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">dev token—_ allowments，映射中的映射。</figcaption></figure><p id="e424" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们首先添加一个可以用来记录批准的事件。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —在新批准时发出的批准事件</figcaption></figure><p id="c222" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我们将增加一些BEP20需要的功能。</p><ul class=""><li id="c7de" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le ow ll lm ln bi translated">津贴——从拥有者处返回消费者的代币数量</li><li id="b697" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated">批准—允许帐户在所有者帐户上花费X个代币</li><li id="e1f3" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated">转移自—使用允许将X个令牌从发件人转移到收件人</li><li id="2569" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated">getOwner —只需包装当前所有者()，需要BEP20</li></ul><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">dev token——津贴和与其相关的功能</figcaption></figure><p id="e828" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这些函数没有什么新的东西，所以我不会涉及细节，它们应该非常简单。</p><p id="2b9e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">唯一棘手的部分是从。请记住，第一个参数(spender)是持有令牌的帐户。因此，我们需要输入3个地址，消费方(代币所有者)、接收方和允许代表消费方消费的消息发送方。</p><p id="f025" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最后，让我们添加一些测试来确保功能按预期工作。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">DevToken —容差测试</figcaption></figure><h2 id="3170" class="lu lv it bd lw lx ly dn lz ma mb dp mc ks md me mf kw mg mh mi la mj mk ml mm bi translated">第一条的结论</h2><p id="b289" class="pw-post-body-paragraph kh ki it kj b kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la mr lc ld le im bi translated">第一篇文章到此结束。本系列还有两篇文章，你可以在我的<a class="ae lt" href="https://github.com/percybolmer/DevToken/tree/BEP20" rel="noopener ugc nofollow" target="_blank">库</a>的BEP-20分支中找到完整的代码。</p><ul class=""><li id="6d2f" class="lf lg it kj b kk kl ko kp ks lh kw li la lj le ow ll lm ln bi translated">开发环境的设置</li><li id="a598" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated">开始使用基本的可靠性语法</li><li id="36d6" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated">为我们的代码编写单元测试</li><li id="9424" class="lf lg it kj b kk lo ko lp ks lq kw lr la ls le ow ll lm ln bi translated">实现BEP20接口的智能合约</li></ul><p id="bb9a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">下一篇<a class="ae lt" href="https://medium.com/@percybolmer1/creating-a-inheritable-staking-contract-in-solidity-7804ae2d7a32" rel="noopener">文章</a>将涵盖更高级的坚固性主题，我们将考虑添加第三个合同用于<strong class="kj iu">赌注和基于时间的奖励</strong>等等。</p><p id="794f" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我希望你喜欢它，如果有任何问题，请随时联系我们。</p></div></div>    
</body>
</html>