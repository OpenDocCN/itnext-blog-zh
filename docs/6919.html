<html>
<head>
<title>React + Flutter = Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应+颤动=自然</h1>
<blockquote>原文：<a href="https://itnext.io/react-flutter-native-f616013b108a?source=collection_archive---------1-----------------------#2022-04-13">https://itnext.io/react-flutter-native-f616013b108a?source=collection_archive---------1-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7437" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战</h1><p id="4a2d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lj">在颤振顶部运行反应</em></p><p id="e28f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">目前网络上充斥着Flutter vs. React的本地文章和视频，它们给出了比较和意见，今天该学习哪一个。本文的目标是结束这场关于Flutter与React Native的争论，不是宣布谁是赢家，而是提供一个新的视角或可能性。</p><p id="98c1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">为什么React❤不振翅高飞——享受这两种框架呢？</em></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/1fb6026819a5b92f0506111f4222d98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*k_LSWQN3Wonr0QUX0V0P6A.png"/></div></figure><p id="88fe" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当已经了解React的人开始涉足web和浏览器之外的领域时，他自然会利用自己的知识，转向React Native。在玩了Flutter之后，我可以诚实地说，这是一个令人愉快的框架和开发环境。但是我放松进入Flutter的很大一部分原因是因为我最近完成了几个React web项目。设计原则和范例——小部件和组件、构建和呈现、状态、声明性UI——在这些框架之间感觉都很相似。甚至连Flutter的语言——Dart看到<em class="lj"> aysncs </em>和<em class="lj">等待</em>的时候都觉得javascripty。</p><p id="ecfe" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">从一个框架转移到另一个框架或者甚至学习两个框架并不一定意味着加倍的工作。</p><h2 id="81d6" class="lx jo iq bd jp ly lz dn jt ma mb dp jx kw mc md kb la me mf kf le mg mh kj mi bi translated"><em class="mj">反应+颤动=原生</em></h2><p id="e509" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上面的等式根本不是一个定理。本文附带的应用程序和源代码是我称之为<strong class="kn ir"> <em class="lj">的组装工作</em> </strong> : <em class="lj">组装、蹩脚、丑陋、愚蠢，但足以工作。</em>它展示了一个概念证明，其目的仅仅是为了检验一个假设。</p><p id="6278" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">挑战用一种更具体的说法:</p><p id="5d6c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">构建一个原生应用——Todo应用——用javascript和React编码，用Flutter渲染。</em></p><h1 id="902f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">动机</h1><p id="3007" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lj">终极代码编辑器</em></p><p id="237f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在疫情隔离期间，我编写了自己的文本编辑器。而我从那以后一直在尝试开发<em class="lj">终极代码编辑器</em> ( <a class="ae mk" href="http://www.munchyapps.com/" rel="noopener ugc nofollow" target="_blank">阿什拉代码</a>、<a class="ae mk" href="https://github.com/icedman/ashlar-text" rel="noopener ugc nofollow" target="_blank">阿什拉文本</a>、<a class="ae mk" href="https://github.com/icedman/tashlar" rel="noopener ugc nofollow" target="_blank">终端-阿什拉</a>、<a class="ae mk" href="https://levelup.gitconnected.com/build-a-text-editor-with-flutter-ui-under-1000-lines-of-code-5a9dd2a053da" rel="noopener ugc nofollow" target="_blank">编辑器-从头开始</a>、<a class="ae mk" href="https://github.com/icedman/flutter_editor" rel="noopener ugc nofollow" target="_blank">颤振编辑器</a>)。</p><p id="f3c0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">终极代码编辑器必须是真正的跨平台的。因此——颤动。<a class="ae mk" href="https://levelup.gitconnected.com/build-a-text-editor-with-flutter-ui-under-1000-lines-of-code-5a9dd2a053da" rel="noopener ugc nofollow" target="_blank">阅读我的另一篇文章</a>来理解我为什么这么认为。</p><p id="11b9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">更重要的是，<em class="lj">终极代码编辑器，</em>也必须是“可破解的”——就像Atom一样，或者用Visual Studio代码术语来说是“可扩展的”。它必须通过脚本语言支持插件或扩展系统。“可破解”和“可扩展”不仅指应用功能，也指用户界面。有了javascript，自然会想到React。</p><p id="689e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果我们能够运行我们的<em class="lj"> Todo应用程序——一个为<em class="lj">React+Flutter = Native</em>equation<em class="lj">，</em>而被</em>美化了的hello world，那么通过javascript和React让Flutter应用程序在功能和界面上都可扩展的想法就成为了可能。我们离创建<em class="lj">终极代码编辑器又近了一步。</em></p><p id="bdef" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">把<em class="lj">终极代码编辑器</em>换成自己的<em class="lj">“终极_____ app”。上述动机可能仍然适用。</em></p><h1 id="5119" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">战略</h1><ol class=""><li id="21d7" class="ml mm iq kn b ko kp ks kt kw mn la mo le mp li mq mr ms mt bi translated">为Flutter应用程序添加脚本功能—使用QuickJS</li><li id="4dca" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">添加创建Flutter小部件的动态或运行时方法—创建小部件生成器或工厂类；</li><li id="9eda" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">添加构建UI树的动态或运行时方法—创建树数据结构来模拟声明性UI；</li><li id="adc7" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated">使用React从脚本创建小部件和构建UI——在Flutter和QuickJS之间建立一座沟通桥梁</li></ol><h1 id="bcab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">QuickJS</h1><p id="4035" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae mk" href="https://github.com/icedman/ashlar-text" rel="noopener ugc nofollow" target="_blank"> Ashlar Text </a>实际上包含了一个支持React的<a class="ae mk" href="https://github.com/icedman/js-qt-native" rel="noopener ugc nofollow" target="_blank">脚本引擎</a>。但是它运行在Qt上并使用QtWebKit，这意味着Ashlar Text需要一个功能齐全的web浏览器(尽管从视图中隐藏)作为其脚本引擎。</p><p id="f60e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们想要便携、轻便、快如闪电的东西。</p><p id="ff7f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><a class="ae mk" href="https://bellard.org/quickjs/" rel="noopener ugc nofollow" target="_blank"> <em class="lj"> QuickJS </em> </a> <em class="lj">是法布里斯·贝拉开发的一个小型可嵌入的Javascript引擎</em>。(他还创造了ffmpeg，qemu，tinygl)。如果你正在寻找一个小的、快速的、跨平台的、稳定的脚本引擎，不用再找了——这个引擎是由一个天才维护的。</p><p id="94ac" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我之前的C++移植到Flutter的文章——<a class="ae mk" href="https://levelup.gitconnected.com/port-an-existing-c-c-app-to-flutter-with-dart-ffi-8dc401a69fd7" rel="noopener ugc nofollow" target="_blank">第一部分</a>和<a class="ae mk" href="https://levelup.gitconnected.com/port-an-existing-c-c-app-dungeon-crawler-rogue-to-flutter-with-dart-ffi-a701284aa289" rel="noopener ugc nofollow" target="_blank">第二部分</a>。可以帮助我们在Flutter应用程序中嵌入QuickJS。但是<a class="ae mk" href="https://pub.dev/packages/flutter_js" rel="noopener ugc nofollow" target="_blank"> Flutter JS </a>的维护者在软件包页面上写下了令人信服的论点，为什么他们的插件比其他任何脚本引擎都要好。我确信。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="7ef5" class="lx jo iq na b gy ne nf l ng nh">flutter pub add flutter_js</span></pre><h1 id="23f5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">声明式用户界面</h1><p id="94df" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在继续之前，我们需要知道Flutter和React都使用了<em class="lj">声明式UI </em>范例。我们需要对这两种框架的含义有一个直觉。</p><p id="1519" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在<em class="lj">声明式UI </em>中，我们定义了用户界面应该是什么样子。按钮部件应该有边框，文本在中间。我们还可以根据给定的状态定义按钮的外观。按下的按钮应该向下倾斜。禁用时，它应该是灰色的文本。</p><p id="3c15" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">CSS就是这样做的:</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="0215" class="lx jo iq na b gy ne nf l ng nh">&lt;style&gt;<br/>button {<br/>   border: 1;<br/>   bevel: raised;<br/>   textColor: white;<br/>}<br/>button.pressed {<br/>  bevel: down;<br/>}<br/>button.disabled {<br/>  textColor: grey;<br/>}<br/>&lt;/style&gt;</span><span id="1269" class="lx jo iq na b gy ni nf l ng nh">&lt;button onPressed={classNamed='pressed'} onClick={this.disabled=true}&gt;<br/>Click Me<br/>&lt;/button&gt;</span></pre><p id="5407" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">另一方面，在<em class="lj">命令式UI中，</em>用户界面看起来受代码影响(不仅仅是声明的)。用户界面是以编程方式操作的。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="e151" class="lx jo iq na b gy ne nf l ng nh">Button btn;<br/>btn.border = 1;<br/>btn.bevel = raised;<br/>btn.textColor = white;</span><span id="294c" class="lx jo iq na b gy ni nf l ng nh">btn.onPressed = () =&gt; {<br/>   this.bevel = down;<br/>}<br/>btn.onReleased = () =&gt; {<br/>   this.bevel = raised;<br/>}</span></pre><p id="826c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我说<em class="lj">直觉</em>是因为我们只需要记住在<em class="lj">声明式UI中，</em>无论是React还是Flutter，我们都处理<strong class="kn ir"> <em class="lj">状态</em> </strong>。在React和Flutter中，我们操纵<em class="lj">状态</em>，并把如何基于给定的<em class="lj">状态构建或呈现小部件或整个UI树的任务留给框架。</em></p><p id="12e3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我说<em class="lj">直觉</em>是因为要理解在Flutter and React中使用的<em class="lj">声明式UI </em>的内部工作原理需要几篇文章——部件树、虚拟DOM、渲染树、真实DOM。</p><p id="dc9c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为什么要在<em class="lj">声明式UI </em>上走这条弯路？… <strong class="kn ir"> <em class="lj">状态</em> </strong></p><p id="2e9d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">React维护一个虚拟DOM(文档对象模型)。Flutter维护一个小部件树。两者都有一个树状的数据结构来保存应用程序和用户界面状态。通过同步<em class="lj">反应状态</em>和<em class="lj">颤动状态</em>，我们可以利用颤动作为我们的反应渲染器。</p><h1 id="f464" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在运行时创建小部件和小部件树</h1><p id="b8d1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Flutter中，小部件树在设计时或编码时是固定的。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="2929" class="lx jo iq na b gy ne nf l ng nh">List&lt;String&gt; items = [];</span><span id="c276" class="lx jo iq na b gy ni nf l ng nh">Widget build(context) {<br/>   return Document(children: [<br/>      ...items.map((string) =&gt; Text(string))<br/>   ]);<br/>}</span></pre><p id="f926" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然而，<em class="lj">状态</em>是动态的。在上述情况下，<em class="lj">项</em>可能在运行时被操纵，从而不仅影响小部件的呈现，还影响小部件的子部件的呈现。</p><p id="d890" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们以上面的例子为例，应用<em class="lj">构建器模式</em>。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="4b64" class="lx jo iq na b gy ne nf l ng nh">class Element {<br/>  String type;<br/>  Json attributes;<br/>}</span><span id="64e3" class="lx jo iq na b gy ni nf l ng nh">...</span><span id="9440" class="lx jo iq na b gy ni nf l ng nh">List&lt;Element&gt; items = [];</span><span id="e227" class="lx jo iq na b gy ni nf l ng nh">Widget build(context) {<br/>   return Document(children: [<br/>      ...items.map((element) {<br/>           switch(element.type) {<br/>            case 'text':<br/>               return Text(element.attributes['text']);<br/>            case 'button':<br/>               return Button(element.attributes['text']);<br/>      })<br/>   ]);<br/>}</span></pre><p id="d425" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，我们可以创建一个数据结构，不仅包含我们的应用程序<em class="lj">状态</em>，还包含UI或小部件树的定义。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="a164" class="lx jo iq na b gy ne nf l ng nh">document = {<br/>    type: 'document',<br/>    items: [<br/>       {<br/>          type: 'text',<br/>          text: 'Hello World'<br/>       },<br/>       {<br/>          type: 'button',<br/>          text: 'Click Me'<br/>       }<br/>    ]<br/>}</span></pre><p id="1909" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在Flutter中，<em class="lj">文档</em>被存储为一个JSON——实际上是一个能够模拟JSON的<em class="lj">动态</em>变量。</p><h2 id="3c77" class="lx jo iq bd jp ly lz dn jt ma mb dp jx kw mc md kb la me mf kf le mg mh kj mi bi translated">注册表类</h2><p id="d315" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将有一个名为<em class="lj"> Registry </em>的类，它保存并提供一种方法来操作这个结构或<em class="lj">状态</em>。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="5c73" class="lx jo iq na b gy ne nf l ng nh">registry.createElement('root', 'document');</span><span id="9f2a" class="lx jo iq na b gy ni nf l ng nh">registry.createElement('text1', 'text', <em class="lj">state</em>: {'attributes': {'textContent': 'hello world','style': {'color': '#ff0000'} }});</span><span id="2f7a" class="lx jo iq na b gy ni nf l ng nh">registry.appendChild('root', 'text1');</span><span id="e0da" class="lx jo iq na b gy ni nf l ng nh">registry.updateElement('text1', {'attributes': {'textContent': 'hello flutter+react'}});</span></pre><p id="4c2b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">每个元素都创建有一个ID，每当进行更新时，该ID将用作参考。</p><p id="47c0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当我们开始弥补与javascript和React之间的差距时,<em class="lj">注册表</em>方法被特意设计成javascript开发人员熟悉的样子。</p><p id="743d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">实际上,<em class="lj"> Registry </em>类不仅仅操纵一个JSON文档。它维护了一个由<em class="lj">元素</em>组成的树形结构，每个元素都拥有自己的<em class="lj">状态——存储在JSON中的</em>。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="9d65" class="lx jo iq na b gy ne nf l ng nh">class Element {<br/>  String type;<br/>  Json attributes;<br/>  List&lt;Element&gt; items;<br/>}</span></pre><h2 id="1c02" class="lx jo iq bd jp ly lz dn jt ma mb dp jx kw mc md kb la me mf kf le mg mh kj mi bi translated">元素小部件</h2><p id="84cb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将有一个名为<em class="lj"> ElementWidget </em>的构建器小部件。它获取一个<em class="lj">元素</em>数据，根据<em class="lj">元素.类型.</em>构建一个小部件，并进一步构建<em class="lj">元素小部件</em>作为<em class="lj">元素的子元素。</em>物品<em class="lj">。</em></p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="ffa0" class="lx jo iq na b gy ne nf l ng nh">class ElementWidget extends StatelessWidget {<br/>   ElementWidget(this.element);<br/>   <br/>   Widget build() {<br/>      Widget buildMe = (element) =&gt; (switch(element.type) {<br/>            case 'text':<br/>               return Text(element.attributes['text']);<br/>            case 'button':<br/>               return Button(element.attributes['text'])<br/>      });</span><span id="8a77" class="lx jo iq na b gy ni nf l ng nh">     List&lt;Widget&gt; buildMyChildren = this.elements.items.map((child) =&gt; ElementWidget(child));</span><span id="09c1" class="lx jo iq na b gy ni nf l ng nh">     return Column(children: [ buildMe, ...buildMyChildren ];<br/>   }<br/>}</span></pre><p id="6a4b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们从我们的<em class="lj">注册表</em>构建<em class="lj">根</em>元素，开始递归<em class="lj">元素小部件</em>构建。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="3722" class="lx jo iq na b gy ne nf l ng nh">Scaffold(body: ElementWidget(element: Registry.findById('root')));</span></pre><h1 id="bbd0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">里程碑</h1><p id="76fd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">此时，我们已经实现了一种在运行时声明UI并操纵<em class="lj">状态</em>的方法。如果我们将我们的<em class="lj">注册表</em>类和方法<em class="lj"> createElement、removeElement、appendChild、updateElement、</em>暴露给QuickJS，我们将能够完全从javascript构建和操作UI。</p><p id="cdfb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">或者，我们可以实现一个XML解析器来读取一些UI标记语言甚至HTML。我们可以有自己的HTML渲染器。此外，我们可以让我们的HTML呈现器与启用了HttpRequests的QuickJS一起工作，并且我们可以拥有一个基本的web浏览器。</p><p id="4a94" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我们超越自我和失去焦点之前，让我们转移到这个<em class="lj">杂牌军</em>的javascript和React方面。</p><h1 id="6198" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">反应渲染器</h1><p id="3826" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">React可以存在于浏览器之外。这是可能的，因为React遵循了<em class="lj">声明式UI </em>范例。它操纵<em class="lj">状态</em>或虚拟DOM。最终，会有一个<em class="lj">渲染器</em>把虚拟的东西变成视觉的。但是<em class="lj">渲染器</em>与React是松散解耦的。</p><p id="a58a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">呈现器</em>可以是ReactDOM，它在浏览器中创建HTML元素。在浏览器之外，可以是ReactDOMServer，它在服务器端准备或预呈现应用程序。或者它可以是反应性的，根据具体情况创建原生Android小部件或原生iOS组件。</p><p id="43ae" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">或者，<em class="lj">渲染器</em>可以是我们自己用Flutter创建的东西。</p><h1 id="5a85" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战—重申</h1><p id="c237" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用Flutter创建一个React渲染器——并使用React Todo应用程序打招呼。</p><p id="4f50" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">react有一个名为<a class="ae mk" href="https://github.com/facebook/react/tree/main/packages/react-reconciler" rel="noopener ugc nofollow" target="_blank"><strong class="kn ir"><em class="lj">React-reconciler</em></strong></a><strong class="kn ir"><em class="lj"/></strong>的包——“一个用于创建自定义React渲染器的包”，带有“实验性的，使用风险自担”的<em class="lj">字样。我们正处于实验阶段——所以我们忽略了警告。</em></p><p id="b322" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj"> react-reconciler </em>位于react和我们的自定义渲染器之间。它就像一个虚拟DOM的监听器，等待createInstance、createTextInstance、appendChild、removeChild、commitUpdate等事件。</p><p id="6402" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">每当这些事件被触发时，我们通过QuickJs通知Flutter虚拟DOM的变化。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="a779" class="lx jo iq na b gy ne nf l ng nh">reconciler(hostConfig: {<br/>  createInstance: (type, props) {<br/>     sendMessage("onCreate", JSON.stringify({type,...props}));<br/>  },<br/>  commitUpdate: (element) {<br/>     sendMessage("onUpdate", JSON.stringify(element));<br/>  }<br/>});</span></pre><p id="e678" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">函数<em class="lj"> sendMessage </em>是一个<em class="lj"> flutter_js </em>公开函数。它允许从javascript向flutter发送消息。我们在Flutter中的自定义<em class="lj">呈现器</em>将通过创建、添加、删除<em class="lj">注册表</em>中的<em class="lj">元素</em>以及更新每个元素的状态来响应这些事件。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="cc0e" class="lx jo iq na b gy ne nf l ng nh">// in Flutter/Dart</span><span id="2d32" class="lx jo iq na b gy ni nf l ng nh">flutterJs.onMessage('onCreate', (<em class="lj">dynamic</em> <em class="lj">args</em>) {<br/>   registry.createElement('', '', <em class="lj">state</em>: <em class="lj">args</em>);<br/>});</span><span id="7b44" class="lx jo iq na b gy ni nf l ng nh">flutterJs.onMessage('onAppend', (<em class="lj">dynamic</em> <em class="lj">args</em>) {<br/>   registry.appendChild(<em class="lj">args</em>['parent'], <em class="lj">args</em>['child']);<br/>});</span><span id="1573" class="lx jo iq na b gy ni nf l ng nh">flutterJs.onMessage('onRemove', (<em class="lj">dynamic</em> <em class="lj">args</em>) {<br/>   registry.removeChild(<em class="lj">args</em>['parent'], <em class="lj">args</em>['child']);<br/>});</span><span id="a348" class="lx jo iq na b gy ni nf l ng nh">flutterJs.onMessage('onUpdate', (<em class="lj">dynamic</em> <em class="lj">args</em>) {<br/>   registry.updateElement(<em class="lj">args</em>['element'], <em class="lj">args</em>);<br/>});</span></pre><p id="2869" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们在javascript中定义React组件。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="563b" class="lx jo iq na b gy ne nf l ng nh">src/components<br/> ./button.js<br/> ./text.js</span><span id="d486" class="lx jo iq na b gy ni nf l ng nh">// The button<br/>export default class Button extends Component {<br/>   render() {<br/>     return (<br/>       &lt;button <em class="lj">style</em>={{ ...<em class="lj">this</em>.props.style }} <em class="lj">onClick</em>= {<em class="lj">this</em>.props.onClick}&gt;<br/>       {<em class="lj">this</em>.props.children}<br/>       &lt;/button&gt;<br/>     );<br/>    }<br/>}</span></pre><p id="fc49" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">另一方面，我们的<em class="lj"> ElementWidget </em>或builder Widget将处理一个“按钮”或任何类型来创建适当的Widget。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="fca1" class="lx jo iq na b gy ne nf l ng nh">Widget build() {<br/>      return (element) =&gt; (switch(element.type) {<br/>            case 'text':<br/>               return Text(element.attributes['text']);<br/>            <strong class="na ir">case 'button'</strong>:<br/>               return Button(element.attributes['text'])<br/>      });<br/>}</span></pre><p id="3728" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">要将UI事件从Flutter发送到JavaScript——点击或文本输入——我们只需启动一个脚本，传递<em class="lj"> element.id </em>、事件及其参数。还是那句话<em class="lj"> flutter_js </em>是我们的朋友。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="9c08" class="lx jo iq na b gy ne nf l ng nh">GestureDetector(<em class="lj">onTapDown</em>: (<em class="lj">details</em>) {<br/>   try {<br/>      final script = 'onEvent("${<em class="lj">element</em>?.<em class="lj">id</em>}", "onClick")';<br/>      JsEvalResult? jsResult = flutterJS.evaluate(script);<br/>   } catch (err, msg) {<br/>      print(err);<br/>   }<br/>},<br/><em class="lj">child</em>: child);</span></pre><h1 id="087b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战完成</h1><p id="47a1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们现在有了自己的用Flutter制作的React渲染器。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="2d05" class="lx jo iq na b gy ne nf l ng nh">&gt; git clone <a class="ae mk" href="https://github.com/icedman/react-qjs-native" rel="noopener ugc nofollow" target="_blank">https://github.com/icedman/react-qjs-native</a></span></pre><p id="a8a8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">该代码提供了三个自定义渲染器。第一个是用c++和quickjs编写的简单终端应用程序。这个应用程序仅仅打印出通过react-reconcile ler触发的事件。</p><p id="698b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了将React app打包成QuickJS可加载模块，使用了<strong class="kn ir"> <em class="lj"> rollupJS </em> </strong>。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="5c7d" class="lx jo iq na b gy ne nf l ng nh">&gt; yarn build // or npm build<br/>             // or yarn dev to keep watch of changes<br/>&gt; meson build<br/>&gt; ninja -C build<br/>&gt; build/react-qjs</span></pre><p id="ea91" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">另一个<em class="lj">呈现器</em>是浏览器DOM实现。这里使用了<strong class="kn ir"> <em class="lj"> parcelJS </em> </strong>在本地主机上封装并提供Todo应用。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="114a" class="lx jo iq na b gy ne nf l ng nh">&gt; yarn sample</span></pre><p id="491d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最后，我们有基于颤振的<em class="lj">渲染器</em>。</p><pre class="lq lr ls lt gt mz na nb nc aw nd bi"><span id="fb5f" class="lx jo iq na b gy ne nf l ng nh">&gt; yarn build // or yarn dev for hot reload<br/>&gt; flutter pub get<br/>&gt; flutter run -v // or flutter build apk for Android</span></pre><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="2f34" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="0fa8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我必须承认，我还没有完全沉浸在React Native中。所以我只能猜测说，如果<em class="lj"> React Native </em>是使用Flutter重新创建的，那么关于使用<em class="lj"> React Native还是Flutter </em>的争论将最终结束。我们将在React中编码，在Flutter中使用原生小部件或创建新部件，在Android、iOS(包括桌面Linux、Windows、macOS)上构建跨平台，而无需处理原生Android或原生iOS、Kotlin、Java或Swift。</p><p id="584e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个假设已经被证实了。<strong class="kn ir"> <em class="lj">反应过来+扑动=原生</em> </strong>都有可能。而且，Flutter可能会以一种最意想不到的方式挑战React Native通过使用React本身。</p></div></div>    
</body>
</html>