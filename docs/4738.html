<html>
<head>
<title>Firebase Cloud Functions: Verify Users Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firebase云功能:验证用户令牌</h1>
<blockquote>原文：<a href="https://itnext.io/firebase-cloud-functions-verify-users-tokens-d4e60e314d1a?source=collection_archive---------3-----------------------#2020-09-04">https://itnext.io/firebase-cloud-functions-verify-users-tokens-d4e60e314d1a?source=collection_archive---------3-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a818" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仅向经过身份验证的用户授予对Firebase云功能的访问权限。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/002b2380921e71ff43a0f13fa9f45924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSLn4cG8OsG63z4pbJqrXA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">奈杰尔·塔迪亚恩多在<a class="ae ky" href="https://unsplash.com/s/photos/you-shall-not-pass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我昨天通过声明一个新的<a class="ae ky" href="https://firebase.google.com/docs/functions/" rel="noopener ugc nofollow" target="_blank"> Firebase云函数</a>开始了对<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>的核心函数之一的重构，它可以通过<a class="ae ky" href="https://firebase.google.com/docs/functions/http-events" rel="noopener ugc nofollow" target="_blank"> HTTP请求</a>来触发。</p><p id="4ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我想保护它的访问，为了避免偷偷摸摸的请求，我按照我之前的一篇博文<a class="ae ky" href="https://medium.com/better-programming/protect-your-http-firebase-cloud-functions-adf23c45765e" rel="noopener">在一个人的帮助下保护它。</a></p><p id="6005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我测试了这个特性的第一步，我实际上注意到它不是我用例的正确解决方案。我不得不使用用户令牌授予访问权限。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4dd5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">验证用户在云函数中的令牌</h1><p id="ea7e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于那些知道解决方案的人来说，这可能听起来很傻，但实际上我花了相当多的时间来找到如何在Firebase Cloud函数中验证用户的令牌。</p><p id="301d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在尝试实现该解决方案时走错了路，因为我分别在后端实现它，如<a class="ae ky" href="https://developers.google.com/identity/sign-in/web/backend-auth" rel="noopener ugc nofollow" target="_blank">使用库<a class="ae ky" href="https://github.com/googleapis/google-auth-library-nodejs" rel="noopener ugc nofollow" target="_blank"> google-auth-library </a>向后端服务器</a>验证所示。我花时间实施该解决方案，并寻找在哪里可以找到我的项目所需的OAuth <code class="fe mz na nb nc b">CLIENT_ID</code>信息，最终在我尝试该过程时面临以下错误:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="62b3" class="nh md it nc b gy ni nj l nk nl">No pem found for envelope: {"alg":"RS256","kid":"...","typ":"JWT"}</span></pre><p id="7204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，经过多次尝试，我接受了失败，并在谷歌上寻找解决方案。幸运的是，对我来说，在一个<a class="ae ky" href="https://stackoverflow.com/questions/61937587/how-to-get-valid-token-from-react-firebase-f%c3%bcr-nodesjs-server-verification/61937783#comment112690479_61937783" rel="noopener ugc nofollow" target="_blank"> Stackoverflow问题</a>的结尾，由于<a class="ae ky" href="https://stackoverflow.com/users/8535518/will" rel="noopener ugc nofollow" target="_blank"> Will </a>的回答，我发现有一种更容易验证令牌的方法。</p><p id="327d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，如果我知道<a class="ae ky" href="https://firebase.google.com/docs/auth/admin/verify-id-tokens" rel="noopener ugc nofollow" target="_blank">管理文档</a>，我会发现Firebase是解决这一需求的内置方法。</p><blockquote class="nm nn no"><p id="80d1" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">Firebase Admin SDK有一个用于验证和解码ID令牌的内置方法。如果提供的ID标记具有正确的格式、未过期并且经过正确签名，则该方法返回解码后的ID标记。您可以从解码的令牌中获取用户或设备的uid。</p></blockquote><p id="00fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我发现了这块宝石，一旦我的大脑终于灵光一现，我就能够实现一个小的实用功能:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c87b" class="nh md it nc b gy ni nj l nk nl">import * as admin from 'firebase-admin';<br/>import * as functions from 'firebase-functions';<br/><br/>export async function verifyToken(<br/>                request: functions.Request): Promise&lt;boolean&gt; {<br/>  try {<br/>    const token: string | undefined = await getToken(request);<br/><br/>    if (!token) {<br/>      return false;<br/>    }<br/><br/>    const payload: admin.auth.DecodedIdToken = <br/>                   await admin.auth().verifyIdToken(token);</span><span id="7ab0" class="nh md it nc b gy nt nj l nk nl">    return payload !== null;<br/>  } catch (err) {<br/>    return false;<br/>  }<br/>}</span><span id="7323" class="nh md it nc b gy nt nj l nk nl">async function getToken(request: functions.Request): <br/>                       Promise&lt;string | undefined&gt; {<br/>  if (!request.headers.authorization) {<br/>    return undefined;<br/>  }<br/><br/>  const token: string = <br/>        request.headers.authorization.replace(/^Bearer\s/, '');<br/><br/>  return token;<br/>}</span></pre><p id="21e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我测试了<code class="fe mz na nb nc b">payload</code>是否不是<code class="fe mz na nb nc b">null</code>来认为令牌是有效的，但是我认为它可能是不需要的。方法<code class="fe mz na nb nc b">verifyIdToken</code>在无效时抛出一个错误。</p><p id="da30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您还可以注意到，我将用户令牌作为HTTP请求的<code class="fe mz na nb nc b">headers</code>进行传递，并以关键字<code class="fe mz na nb nc b">Bearer</code>为前缀。</p><p id="2c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，给定一个令牌ID <code class="fe mz na nb nc b">975dd9f6</code>，HTTP POST请求将如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="61b6" class="nh md it nc b gy ni nj l nk nl">#!/bin/sh<br/>curl -i<br/>     -H "Accept: application/json"<br/>     -H "Authorization: Bearer 975dd9f6"<br/>     -X POST https://us-central1-yolo.cloudfunctions.net/helloWorld</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5aae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">仅授权非匿名用户</h1><p id="af1e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">任何人都可以试用<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>，如果你只是想试一试，没有强制登录或预先登录。这对我们来说真的很重要，我们不是在追逐数据或用户数量，我们正在开发一个用于演示的编辑器，供用户使用或不使用😉。</p><p id="cc5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，如果用户想要公开分享他们的演示文稿，因为我们不想公开发布太多“这是一个测试”或“Yolo”卡片，如果可能的话，分别避免没有意义的公开内容，我们会将我们的“发布流程”(我们将演示文稿作为渐进式网络应用程序在线转换和部署的流程)限制为签名用户。</p><p id="e730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这些进程，我们使用Firebase提供的能力来使用匿名用户。</p><p id="d4a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么，除了验证令牌，我还添加检查这一信息。幸运的是，这也可以很容易地解决，因为由<code class="fe mz na nb nc b">verifyToken</code>函数提供的<code class="fe mz na nb nc b">payload</code>确实包含这样的信息。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e3ce" class="nh md it nc b gy ni nj l nk nl">const payload: admin.auth.DecodedIdToken = <br/>                   await admin.auth().verifyIdToken(token);</span><span id="4067" class="nh md it nc b gy nt nj l nk nl">return payload !== null &amp;&amp;<br/>       payload.firebase.sign_in_provider !== 'anonymous';</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="714f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带承载的呼叫功能</h1><p id="d61e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你感兴趣的话，下面是我如何在TypeScript和使用Firebase Auth的应用程序中为函数调用提供上面的<code class="fe mz na nb nc b">bearer</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b952" class="nh md it nc b gy ni nj l nk nl">import * as firebase from 'firebase/app';<br/>import 'firebase/auth';</span><span id="320f" class="nh md it nc b gy nt nj l nk nl">helloWorld(): Promise&lt;void&gt; {<br/>  return new Promise&lt;void&gt;(async (resolve, reject) =&gt; {<br/>    try {<br/>      const token: string = <br/>            await firebase.auth().currentUser.getIdToken();</span><span id="3a97" class="nh md it nc b gy nt nj l nk nl">      const functionsUrl: string = <br/>           'https://us-central1-yolo.cloudfunctions.net';</span><span id="c0f1" class="nh md it nc b gy nt nj l nk nl">      const rawResponse: Response = <br/>            await fetch(`${functionsUrl}/helloWorld`, {<br/>        method: 'POST',<br/>        headers: {<br/>          Accept: 'application/json',<br/>          'Content-Type': 'application/json',<br/>          Authorization: `Bearer ${token}`,<br/>        },<br/>        body: JSON.stringify({<br/>          something: 'a value'<br/>        }),<br/>      });<br/><br/>      if (!rawResponse || !rawResponse.ok) {<br/>        reject('Post failed etc.');<br/>        return;<br/>      }<br/><br/>      resolve();<br/>    } catch (err) {<br/>      reject(err);<br/>    }<br/>  });<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d0d7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">顶端的樱桃:CORS</h1><p id="8d34" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">因为我实现了第一个处理HTTP请求的函数，所以我必须处理CORS。快速的谷歌搜索和由<a class="ae ky" href="https://github.com/CoderTonyB" rel="noopener ugc nofollow" target="_blank"> CoderTonyB </a>提供的<a class="ae ky" href="https://gist.github.com/mediavrog/49c4f809dffea4e00738a7f5e3bbfa59#gistcomment-2585600" rel="noopener ugc nofollow" target="_blank">要点</a>提供了一个解决方案。</p><p id="0a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/expressjs/cors" rel="noopener ugc nofollow" target="_blank"> expressjs/cors </a>应安装在功能项目中。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0525" class="nh md it nc b gy ni nj l nk nl">npm i cors --save &amp;&amp; npm i @types/cors --save-dev</span></pre><p id="9333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在有效实现之前，应该使用一个处理程序来处理CORS请求。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c760" class="nh md it nc b gy ni nj l nk nl">import * as functions from 'firebase-functions';</span><span id="06da" class="nh md it nc b gy nt nj l nk nl">import * as cors from 'cors';</span><span id="6199" class="nh md it nc b gy nt nj l nk nl">export const helloWorld<strong class="nc iu"><em class="np"> </em></strong>= functions.https.onRequest(myHelloWorld);</span><span id="6533" class="nh md it nc b gy nt nj l nk nl">async function helloWorld(request: functions.Request,<br/>                          response: functions.Response&lt;any&gt;) {<br/>  const corsHandler = cors({origin: true});<br/><br/>  corsHandler(request, response, async () =&gt; {<br/>      response.send('Yolo');<br/>  });<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f58" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">拿走</h1><p id="acf0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">不用说，错误地开始一个新特性的开发并很快失去时间是很容易的。我很想说深呼吸或者休息一下是关键，但是偶尔会发生一些事情😉。然而，如果你有很棒的技巧和诀窍来避免这种情况，请告诉我，我很想听听这些！</p><p id="d512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对结果感到好奇，请关注我们的Twitter，因为我们可能会在下周为开发者发布一个超级酷的功能🚀。</p><p id="3b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远的地方！</p><p id="49c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>