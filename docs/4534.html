<html>
<head>
<title>Why You Should Use Multi-Stage Docker Builds in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该在生产中使用多阶段Docker构建</h1>
<blockquote>原文：<a href="https://itnext.io/using-multi-stage-docker-builds-for-speed-and-security-9d3a1cd9cd8c?source=collection_archive---------1-----------------------#2020-07-20">https://itnext.io/using-multi-stage-docker-builds-for-speed-and-security-9d3a1cd9cd8c?source=collection_archive---------1-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f895" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">速度和安全性结合在一起的情况并不常见，但是当它们结合在一起时，就可以确定一种模式是否值得采用。这就像一个汽车零件，看起来很好，让你的汽车更快——你怎么可能出错？在这篇文章中(有大量的例子)，我将向你展示什么是多阶段Docker构建，以及它们如何更快更安全！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/50f6ca645d2d29b6b72df8673621395a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*51xUkmBjIlFV00ng"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">包装Docker容器非常类似于一条装配线，多个阶段让我们可以灵活地在最终产品中包含或不包含什么。</figcaption></figure><p id="19d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可选地，对于本文中的源代码，<a class="ae le" href="https://github.com/blhagadorn/multi-stage-docker-example/tree/master" rel="noopener ugc nofollow" target="_blank">请参考这个GitHub资源库</a>。</p><h1 id="0953" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">docker文件如何工作</h1><p id="e99e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Docker容器通常是用一个<em class="mi"> Dockerfile </em>构建的，这是一组帮助你打包源代码、安装依赖项和构建应用程序(如果它编译了二进制文件)的指令。然而，很多时候你构建应用程序所需的东西并不是你运行应用程序所需的东西。让我们考虑一个来自<a class="ae le" href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/" rel="noopener ugc nofollow" target="_blank"> Nodejs网站</a>的标准节点docker文件。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="c0d9" class="mo lg it mk b gy mp mq l mr ms">// Node Sample Dockerfile - Single Stage</span><span id="5dd7" class="mo lg it mk b gy mt mq l mr ms">FROM node:12<br/>ADD . /app<br/>WORKDIR /app<br/>RUN npm install<br/>EXPOSE 8080<br/>CMD [ "node", "server.js" ]</span></pre><p id="615a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到，在我们开始处理目录和将文件复制到映像之前，我们从<code class="fe mu mv mw mk b">FROM node:12</code>开始。你看，Dockerfiles就像一个巨大的洋葱，第一个<code class="fe mu mv mw mk b">FROM</code>是洋葱的核心。它为您提供了二进制文件和Linux文件结构，您需要继续添加更多的层，这将最终成为您的最终应用程序。然而，内核里面是什么呢？让我们在<code class="fe mu mv mw mk b">node:12</code>图像内部运行一个bash shell来找出答案！</p><h1 id="e54b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">看看我们的第一层</h1><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="3f7f" class="mo lg it mk b gy mp mq l mr ms">$ docker run -it node:12 /bin/bash<br/># uname -a<br/>Linux c415d0a3fb27 4.19.76-linuxkit #1 SMP Tue May 26 11:42:35 UTC</span><span id="c8cf" class="mo lg it mk b gy mt mq l mr ms">// Ok so we're running Linux</span><span id="d81b" class="mo lg it mk b gy mt mq l mr ms"># ls<br/>bin  boot  dev etc  home  lib lib64  media  mnt  opt proc  root  run  sbin  srv  sys  tmp  usr  var<br/>// Standard file system in Linux</span><span id="14f8" class="mo lg it mk b gy mt mq l mr ms"># ls /bin<br/>ps  su rm kill ping sh sed stty chmod chown chgrp bash date pwd  ls which mv</span><span id="88ba" class="mo lg it mk b gy mt mq l mr ms"># ls /usr/local/bin<br/>docker-entrypoint.sh  node  nodejs  npm  npx  yarn  yarnpkg</span></pre><p id="b7e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe mu mv mw mk b">node:12</code>是开始构建我们的应用程序的好地方。它拥有我们创建文件系统、更改目录所有权所需的一切，当然还包含<code class="fe mu mv mw mk b">npm</code>，这样我们就可以安装我们的<code class="fe mu mv mw mk b">node_modules</code>依赖项。但是为什么我们需要<code class="fe mu mv mw mk b">rm</code>、<code class="fe mu mv mw mk b">kill</code>、<code class="fe mu mv mw mk b">mv</code>或者<code class="fe mu mv mw mk b">ping</code>？更有甚者，我们的应用程序调用<code class="fe mu mv mw mk b">node</code>来运行<code class="fe mu mv mw mk b">server.js</code>，为什么我们还需要我们的包管理器<code class="fe mu mv mw mk b">npm</code>，它可以安装任何东西？</p><p id="9d84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案很简单——拥有所有这些工具和完整Linux操作系统的感觉对于入门来说是非常好的——但是拥有所有这些二进制文件也是不安全的，而且拖着这么大的文件到处跑是很慢的。从这里开始，我们可以做两件事之一:( 1)通过删除所有我们不需要的东西，把所有东西都撕掉;( 2)只复制我们需要的东西，把它们移到第二个新的阶段。输入…多级Dockerfiles！</p><h1 id="97de" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">多级docker文件</h1><p id="59a0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在上一个例子中，我们看到了在构建和安装应用程序及其依赖项时，拥有一套庞大的工具是多么方便，但是我们知道，当最终的容器交付到我们的源目的地(最有可能是Kubernetes)时，我们不希望有所有这些臃肿的东西。下面是一个多阶段Dockerfile文件:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="81d8" class="mo lg it mk b gy mp mq l mr ms">// Node Sample Dockerfile - Multi-stage<br/></span><span id="4fcd" class="mo lg it mk b gy mt mq l mr ms">FROM node:12 <strong class="mk iu">AS stage1</strong><br/>ADD . /app<br/>WORKDIR /app<br/>RUN npm install</span><span id="2f07" class="mo lg it mk b gy mt mq l mr ms">#Second Stage us</span><span id="fe1b" class="mo lg it mk b gy mt mq l mr ms">FROM gcr.io/distroless/nodejs<br/>COPY --from=stage1 /app /app<br/>WORKDIR /app<br/>EXPOSE 8080<br/>CMD ["server.js"]</span></pre><p id="4f60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一阶段(<strong class="js iu">阶段1) </strong>我们使用<code class="fe mu mv mw mk b">node:12</code>图像开始。这为我们构建应用程序提供了一个很好的基础。然而，在我们将代码复制到<code class="fe mu mv mw mk b">/app</code>并运行<code class="fe mu mv mw mk b">npm install</code>之后，我们进入第二个阶段(第二个<code class="fe mu mv mw mk b">FROM</code>)并提取节点分布图(<em class="mi">gcr.io/distroless/nodejs</em>)。Distroless是一个惊人的最小docker图像——下面是来自他们的GitHub的一个很好的描述:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="7c33" class="mo lg it mk b gy mp mq l mr ms">"Distroless" images contain only your application and its runtime dependencies. They do not contain package managers, shells or any other programs you would expect to find in a standard Linux distribution.</span></pre><p id="5e05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们拉出发行版映像后，我们从第一阶段<code class="fe mu mv mw mk b">COPY</code>中提取<code class="fe mu mv mw mk b">/app</code>中的内容，这应该是我们的<code class="fe mu mv mw mk b">node_modules</code>以及我们的源代码<code class="fe mu mv mw mk b">server.js</code>。这里需要注意的重要部分是，新图像不包含<code class="fe mu mv mw mk b">bash</code>或您可能想要使用的任何其他工具<code class="fe mu mv mw mk b">exec</code>。虽然不便于调试，但攻击面已经大大减少了——这对于容器的生产部署来说是完美的。从外部来看，应用程序正在做和以前一样的事情(在本例中，在端口8080上提供web服务器)。</p><h1 id="996c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">调试容器</h1><p id="7693" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了避免无法调试容器的不便，<a class="ae le" href="https://github.com/GoogleContainerTools/distroless#debug-images" rel="noopener ugc nofollow" target="_blank"> Distroless为它们的图像提供了另一个</a> <code class="fe mu mv mw mk b">:debug</code>标签，其中包含shell访问(<a class="ae le" href="https://en.wikipedia.org/wiki/BusyBox" rel="noopener ugc nofollow" target="_blank">通过BusyBox shell </a>)。如果您的应用程序遇到了问题，您应该保留一个docker文件的调试版本，以便在需要将<code class="fe mu mv mw mk b">kubectl exec</code>或<code class="fe mu mv mw mk b">docker exec</code>放入容器时部署。下面有一个例子供参考(也在GitHub中):</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="11e0" class="mo lg it mk b gy mp mq l mr ms">// Node Sample Dockerfile - Multi-stage with Shell for Debugging</span><span id="af86" class="mo lg it mk b gy mt mq l mr ms">FROM node:12 AS stage1<br/>ADD . /app<br/>WORKDIR /app<br/>RUN npm install</span><span id="104f" class="mo lg it mk b gy mt mq l mr ms">#Second Stage us</span><span id="292a" class="mo lg it mk b gy mt mq l mr ms">FROM gcr.io/distroless/nodejs<strong class="mk iu">:debug</strong><br/>COPY --from=stage1 /app /app<br/>WORKDIR /app<br/>EXPOSE 8080<br/>CMD ["server.js"]</span></pre><h1 id="2df2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">大小呢？</strong></h1><p id="d385" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">好了，到目前为止，我们只是从安全角度讨论了两个over文件之间的技术差异。但是如题中所承诺的，大小呢？由于多阶段通过仅复制我们需要的东西来删除所有不必要的混乱，所以让我们检查各个图像的大小来验证这一说法:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/cc1ae10ac6cbf9bea96d4e81f1ae1bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxSFjPtRFIfJzd6wGbiUUA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们的多级在尺寸上缩小了92%!</figcaption></figure><p id="006c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哇！我们的新图像是<em class="mi"> 74.3MB </em>，相比之下<em class="mi"> 921MB </em>。较小的映像可以加快我们所有的构建和部署步骤，如果您在Kubernetes中，较小的映像是全面提高性能的最快方法之一。</p><h1 id="eaa0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="20ac" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">正如您所看到的，多阶段Dockerfile将您的构建分成两个部分— (1)应用程序代码的设置(如依赖项)和(2)应用程序运行时的设置。Dockerfiles开箱即用非常容易，但当我们优化安全性和速度时，部署生产就绪应用程序需要多阶段构建。同样，我们使用发行版映像来确保我们的最终映像包含运行我们的应用程序所需的内容，并且只包含<strong class="js iu">和</strong>！如果你想进一步讨论，请联系我在bryant.hagadorn@gmail.com的办公室，如果你喜欢阅读这类内容，请关注我的媒体。谢谢你。</p></div></div>    
</body>
</html>