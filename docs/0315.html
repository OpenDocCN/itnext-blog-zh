<html>
<head>
<title>GraphQL: How far are we gone …</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL:我们走了多远…</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-how-far-are-we-gone-77f5ae8fc2e5?source=collection_archive---------2-----------------------#2018-02-16">https://itnext.io/graphql-how-far-are-we-gone-77f5ae8fc2e5?source=collection_archive---------2-----------------------#2018-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">… ApolloGraphQL、Graphcool、urql、石墨烯…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5a08f6b57950258ce5829c3cec2a763a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ojHeuo43FiTfR9k2x8fc_Q.jpeg"/></div></div></figure><p id="5f1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fgraphql-how-far-are-we-gone-77f5ae8fc2e5" rel="noopener ugc nofollow" target="_blank"> <em class="ky">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="6b47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"> G </span> raphQL正变得迅速流行，工具每天都在开发。在本文中，我将试着从“<em class="ky">我自己的观点</em>来分析，并不要求绝对/完全了解所有可用的工具。一些最前沿的常用工具。最值得注意的是由<a class="ae kx" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> ApolloGraphQL </em> </a>、<a class="ae kx" href="https://www.graph.cool/" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> Graphcool </em> </a>和<a class="ae kx" href="https://github.com/FormidableLabs" rel="noopener ugc nofollow" target="_blank"><em class="ky">FormidableLabs</em></a><em class="ky">(urql)提供的工具。</em></p><p id="3060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些工具变得势不可挡，如果不把可能做同样事情的大量包堆在一起，要决定合适的工具可能有点困难。</p><p id="8cb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我可能有点偏见，因为我使用GraphQL的经验是在Javascript环境中(Node JS和React)。</p><p id="c659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管使用了脸书的React，我还没有尝试过使用<a class="ae kx" href="https://github.com/graphql/graphql-relay-js" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> Relay </em> </a>，从我看过的几篇评论来看，与其他工具相比，比如Apollo的客户端工具，它似乎有点复杂。</p><p id="21fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也没有直接使用过<a class="ae kx" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank"><em class="ky">GraphQL JS</em></a><em class="ky"/>，所以我要重点介绍的工具是那些利用了这些最初开发的技术并使在客户端和服务器端开发graph QL应用变得更加容易的工具。</p><p id="60ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常感谢参与创建这些工具的人们。</p><p id="4f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">脸书</strong></p><p id="3183" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前正在设计的大多数工具都严重依赖于facebook开发的库。</p><p id="379c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.npmjs.com/package/graphql" rel="noopener ugc nofollow" target="_blank"><em class="ky">graphql</em></a><em class="ky">(graph qljs)——</em>graph QL的JavaScript参考实现，graph QL是脸书创建的API的查询语言。</p><p id="dc82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以编程方式创建架构</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="f98a" class="ln lo iq lj b gy lp lq l lr ls"><strong class="lj ir">import</strong> { graphql, GraphQLSchema, GraphQLObjectType, GraphQLString } <strong class="lj ir">from</strong> 'graphql';</span><span id="7da9" class="ln lo iq lj b gy lt lq l lr ls">var schema <strong class="lj ir">=</strong> <strong class="lj ir">new</strong> GraphQLSchema({<br/>  query<strong class="lj ir">:</strong> <strong class="lj ir">new</strong> GraphQLObjectType({<br/>    name<strong class="lj ir">:</strong> 'RootQueryType',<br/>    fields<strong class="lj ir">:</strong> {<br/>      hello<strong class="lj ir">:</strong> {<br/>        type<strong class="lj ir">:</strong> GraphQLString,<br/>        resolve() {<br/>          <strong class="lj ir">return</strong> 'world';<br/>        }<br/>      }<br/>    }<br/>  })<br/>});</span></pre><p id="d973" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用模式语言创建模式</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="eef5" class="ln lo iq lj b gy lp lq l lr ls">var { graphql, buildSchema } = require('graphql');<br/><br/>// Construct a schema, using GraphQL schema language<br/>var schema = buildSchema(`<br/>  type Query {<br/>    hello: String<br/>  }<br/>`);</span></pre><p id="60c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lee Byron试图解释为什么以及何时以编程方式创建模式或使用模式语言。看看这个<a class="ae kx" href="https://github.com/graphql/graphql-js/issues/223#issuecomment-248647850" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="ky"> github讨论</em> </strong> </a>。</p><p id="7a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以使用这个包来运行对模式的查询。</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="cd5c" class="ln lo iq lj b gy lp lq l lr ls">var query <strong class="lj ir">=</strong> '{ hello }';</span><span id="3ced" class="ln lo iq lj b gy lt lq l lr ls">graphql(schema, query).then(result =&gt; {<br/>  console.log(result);  // Result: <em class="ky">data: { hello: "world" }</em><br/>}</span></pre><p id="263d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.npmjs.com/package/express-graphql" rel="noopener ugc nofollow" target="_blank"><em class="ky">express-graph QL</em></a>—graph QL HTTP服务器中间件。</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="da48" class="ln lo iq lj b gy lp lq l lr ls">const express <strong class="lj ir">=</strong> require('express');<br/>const graphqlHTTP <strong class="lj ir">=</strong> require('express-graphql');</span><span id="ff0c" class="ln lo iq lj b gy lt lq l lr ls">const app <strong class="lj ir">=</strong> express();</span><span id="6d63" class="ln lo iq lj b gy lt lq l lr ls">app.use('/graphql', graphqlHTTP({<br/>  schema<strong class="lj ir">:</strong> /* The defined schema */<br/>}));</span><span id="3f21" class="ln lo iq lj b gy lt lq l lr ls">app.listen(4000);</span></pre><p id="3c09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结合上面的两个库，我们可以创建一个模式并将其与服务器连接(connect，express，Restify)。</p><p id="f54f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.npmjs.com/package/graphiql" rel="noopener ugc nofollow" target="_blank"><em class="ky">graphiql</em></a><em class="ky">-</em>如果您想在不创建前端客户端应用程序的情况下测试您的服务器，那么这是一个完美的包。可以在express-graphql中将graphql设置为true来启用它。</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="8cf8" class="ln lo iq lj b gy lp lq l lr ls">...<br/>app.use('/graphql', graphqlHTTP({<br/>  schema<strong class="lj ir">:</strong> /* The defined schema */,<br/>  graphiql: true<br/>}));<br/>...</span></pre><p id="8e24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.apollographql.com" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Apollographql</strong></a></p><p id="016c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apollo社区已经成为GraphQL工具的顶级创造者之一。以下是一些工具及其使用案例。</p><p id="f3dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ky">服务器</em> </strong></p><p id="b010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/apollographql/graphql-tools" rel="noopener ugc nofollow" target="_blank"><em class="ky">【graph QL-tools</em></a>—graph QL的基础是一个使用<a class="ae kx" href="https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> GraphQL SDL(模式定义语言)</em> </a> <em class="ky">编写的模式。</em>模式定义需要与解析器连接，解析器提供方法<em class="ky"> getBooks </em>和<em class="ky"> createBook(…) </em>的实际实现，以创建可执行的模式。</p><p id="ca9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ky"> graphql-tools </em>就是能让我们做到这一点的工具。这个工具还有一些其他的功能，但是到目前为止这个功能还是很突出的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">GraphQL模式</figcaption></figure><p id="3c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/apollographql/apollo-server/" rel="noopener ugc nofollow" target="_blank"><em class="ky">apollo-server</em></a>—当graphql-tools创建模式时，Apollo-server需要将其连接到服务器(Express、connect、哈比神、Koa …)。这是一个非常大的软件包，我建议你不要安装它。最好的方法是使用它的<a class="ae kx" href="https://github.com/apollographql/apollo-server/tree/master/packages" rel="noopener ugc nofollow" target="_blank"> <em class="ky">变体</em> </a>取决于你的服务器，它采用<em class="ky">阿波罗-服务器- &lt;变体&gt;例如阿波罗-服务器-快递，阿波罗-服务器-koa，… </em></p><p id="b2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<strong class="jp ir"> executableSchema，</strong>我们现在可以如下连接到express服务器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="25a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了apollographql的上述工具，我们就可以使用graphql创建一个功能齐全的服务器端应用程序。</p><p id="4945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ky">客户端</em> </strong></p><p id="4e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apollo社区还提供了一些工具，可以在客户端与不同的框架、库或普通javascript一起使用。最值得注意的工具是<a class="ae kx" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"> <em class="ky">阿波罗-客户端</em> </a>和<a class="ae kx" href="https://github.com/apollographql/react-apollo" rel="noopener ugc nofollow" target="_blank"> <em class="ky">反应-阿波罗</em> </a>。</p><p id="71b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这两个工具有什么区别。来自<a class="ae kx" href="https://www.learnapollo.com/tutorial-react/react-01" rel="noopener ugc nofollow" target="_blank"><em class="ky">learnapollo</em></a><em class="ky">:</em></p><ul class=""><li id="afc4" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">核心包，公开了提供核心功能的普通JS Apollo客户端。</li><li id="dd03" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mf mg mh mi bi translated"><code class="fe mj mk ml lj b">react-apollo</code>——React集成公开了可用于包装其他React组件的<code class="fe mj mk ml lj b">ApolloProvider</code>，允许它们发送查询和变化</li></ul><p id="b7f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<a class="ae kx" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"> <em class="ky">阿波罗-客户端回购</em> </a>:</p><p id="b699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自Apollo Client是一个全功能的缓存GraphQL客户端，集成了React、Angular等等。</p><p id="9317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，react的集成是以react-apollo的形式提供的。其他一些框架集成仍在开发中。</p><p id="3e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于任何JS，尤其是React dev，下面的用例应该非常简单。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，对于Redux的粉丝来说，阿波罗1.x有一个Redux的实现，但在阿波罗2.0中它被放弃了，取而代之的是<a class="ae kx" href="https://www.npmjs.com/package/apollo-cache-inmemory" rel="noopener ugc nofollow" target="_blank"> <em class="ky">阿波罗缓存内存</em> </a>。(<a class="ae kx" href="https://github.com/apollographql/apollo-client/issues/2509#issuecomment-343963114" rel="noopener ugc nofollow" target="_blank"> <em class="ky">见此处为什么</em> </a>)。<em class="ky"> createReactInterface </em>也由<a class="ae kx" href="https://www.npmjs.com/package/apollo-link-http" rel="noopener ugc nofollow" target="_blank"><em class="ky">Apollo-link-http</em></a>中的<em class="ky"> HttpLink </em>取代。</p><p id="1d1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内存缓存可以按如下方式使用:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="8ba0" class="ln lo iq lj b gy lp lq l lr ls">...<br/>import { InMemoryCache } from 'apollo-cache-inmemory';<br/>import { ApolloClient } from 'apollo-client';</span><span id="8cbd" class="ln lo iq lj b gy lt lq l lr ls">// Create client that connects to the server<br/>const client = new ApolloClient({<br/>  link: HttpLink({ uri: 'https://api.graph.cool/simple/v1/__PROJECT_ID__'}),<br/>  cache: new InMemoryCache()<br/>})</span></pre><p id="770b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.npmjs.com/package/graphql-tag" rel="noopener ugc nofollow" target="_blank"><em class="ky"/></a><em class="ky">——</em>这个和react-apollo一起使用，在客户端解析graphql查询。下面的例子，一个来自<a class="ae kx" href="https://github.com/apollographql/react-apollo" rel="noopener ugc nofollow" target="_blank"> apollographql </a>的片段展示了如何使用来自<em class="ky"> react-apollo </em>和<a class="ae kx" href="https://www.npmjs.com/package/graphql-tag" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> graphql-tag </em> </a>的函数将一个功能组件连接到graphql。非常类似于Redux中的connect。</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="2b78" class="ln lo iq lj b gy lp lq l lr ls">import { graphql } from 'react-apollo';<br/>import gql from 'graphql-tag';<br/><br/>function TodoApp({ data: { todos, refetch } }) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={() =&gt; refetch()}&gt;Refresh&lt;/button&gt;<br/>      &lt;ul&gt;{todos &amp;&amp; todos.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}&lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default graphql(gql`<br/>  query TodoAppQuery {<br/>    todos {<br/>      id<br/>      text<br/>    }<br/>  }<br/>`)(TodoApp);</span></pre><p id="ef6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有<a class="ae kx" href="https://github.com/apollographql/apollo-ios" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> apollo-ios </em> </a>和<a class="ae kx" href="https://github.com/apollographql/apollo-ios" rel="noopener ugc nofollow" target="_blank"><em class="ky">Apollo-Android</em></a><em class="ky"/>面向原生手机app开发者的客户端工具。</p><p id="5dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我将谈到阿波罗号上的那些工具。关于阿波罗工具的完整教程可以在<a class="ae kx" href="https://www.learnapollo.com/" rel="noopener ugc nofollow" target="_blank"><em class="ky">learnapollo</em></a><em class="ky">(注:依赖阿波罗1.x) </em>找到。</p><p id="0f0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.graph.cool/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Graphcool </strong> </a></p><p id="c0c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Graphcool是另一个推动GraphQL福音的酷社区。他们开发了一些令人敬畏的工具，从<em class="ky"> graphql-framework </em>、<a class="ae kx" href="https://github.com/graphcool/graphql-playground" rel="noopener ugc nofollow" target="_blank">、<em class="ky"> graphql-playground </em>、</a><a class="ae kx" href="https://github.com/graphcool/graphql-yoga" rel="noopener ugc nofollow" target="_blank">、<em class="ky"> graphql-yoga </em>、</a>到超级令人敬畏的<em class="ky"> Prisma </em>。开发很快，在某个时候，社区对graphcool-framework和Prisma感到困惑。<a class="ae kx" href="https://www.graph.cool/forum/t/graphcool-framework-and-prisma/2237?u=nilan" rel="noopener ugc nofollow" target="_blank">下面就由</a>好好解释一下<a class="ae kx" href="https://github.com/marktani" rel="noopener ugc nofollow" target="_blank"> <em class="ky">尼兰</em> </a> <em class="ky"> </em>它们到底是什么以及它们有什么区别。</p><p id="63ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据我的观察，Graphcool的一些工具利用了Apollo的工具，我认为这在开源社区合作时是非常酷的。Graphcool的另一个好处是，在开发期间，它提供了一个免费的层服务来托管graphcool和Prisma应用程序。(救了我们这些付不起AWS的穷人)。那么，让我们来看看“<em class="ky">浅深度</em>”中的一些工具。</p><p id="725d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="ky"/>GraphLQL游乐场</strong></p><p id="55e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数人把它们称为GraphQL IDEs，我更喜欢GraphQL查询编辑器；这里的查询是指查询、变异或订阅。如果你玩过GraphQL，那么你可能已经和graph QL交互过了。GraphQL Playground非常相似，但有一些额外的功能。</p><p id="e502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ky"> Graphcool框架</em> </strong></p><p id="568f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Graphcool框架<a class="ae kx" href="https://github.com/graphcool/graphcool-framework/" rel="noopener ugc nofollow" target="_blank">是一种开源技术</a>，它提供了基于自以为是的堆栈的GraphQL后端解决方案。它使用graphcool CLI工具来搭建、管理和部署应用程序。使用Graphcool，可以在我们的数据库上直接生成API，我们可以直接从客户端应用程序访问它。目前，它只支持MySQL，但其他数据库的集成正在进行中。从<a class="ae kx" href="https://www.npmjs.com/package/graphcool" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="ky"> npm包</em> </strong> </a> <strong class="jp ir"> <em class="ky">，</em> </strong>我们可以轻松设置一个简单的应用程序，并在不到5分钟的时间内完成部署。</p><p id="e28e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://www.prismagraphql.com/docs" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="ky">棱镜</em> </strong> </a></p><p id="2f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像Graphcool Framework一样，Prisma也公开了整个数据库及其方法，但增加了一个应用层，我们可以在其中指定如何使用数据库方法。</p><p id="9bd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ky">棱镜装订</em> </strong></p><p id="e54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/graphcool/prisma-binding" rel="noopener ugc nofollow" target="_blank"> Prisma Binding </a>是一个非常强大的工具。当使用Prisma CLI创建应用程序时，它会公开一个数据库API，但除此之外，它还会使用<a class="ae kx" href="https://github.com/graphcool/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> graphql-yoga </a>创建一个GraphQL服务器，该服务器会自行公开另一个API。Prisma Binding所做的是使我们能够将这两个API结合起来，这样我们就可以用我们的服务器API创建我们自己的方法并调用数据库API。</p><p id="f478" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是为什么？当我们在正常情况下(REST)创建数据库时，我们不会将所有关于记录的字段/数据暴露给客户端，我们会过滤掉一些可能敏感的数据，如密码。通过Prisma绑定，我们可以定义自己的类型，从CRUD API中过滤掉我们不想要的类型。现在，客户不能直接访问我们的CRUD API，我们可以定义自己的认证系统，并包含所有我们喜欢的复杂功能。</p><p id="2e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/graphcool/graphql-yoga" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="ky"> GraphQL瑜伽</em> </strong> </a></p><p id="ec75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个工具是建立在<code class="fe mj mk ml lj b"><a class="ae kx" href="https://github.com/apollographql/apollo-server" rel="noopener ugc nofollow" target="_blank">apollo-server</a></code>、<code class="fe mj mk ml lj b"><a class="ae kx" href="https://github.com/apollographql/graphql-subscriptions" rel="noopener ugc nofollow" target="_blank">graphql-subscriptions</a></code>和其他一些工具之上的。使用yoga，我们可以很容易地设置一个已经设置了订阅的GraphQL服务器。</p><p id="2e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://github.com/FormidableLabs" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">可怕的实验室</strong> </a></p><p id="d023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在做一些研究的时候，我偶然发现了Apollo的一个工具:<a class="ae kx" href="https://www.npmjs.com/package/apollo-boost" rel="noopener ugc nofollow" target="_blank"> apollo-boost </a>。我还没有机会使用它，但是这里有一篇关于这个工具的很好的文章。那么，为什么阿波罗助推火箭如此强大呢？如果你读过那篇文章，你可能会知道它为什么被开发出来。</p><p id="7f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FormidableLabs开发了<a class="ae kx" href="https://github.com/FormidableLabs/urql" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="ky">urql</em></strong></a><strong class="jp ir"><em class="ky">，</em> </strong> GraphQL客户端，公开为一组ReactJS组件。仅仅浏览一下urql repo的自述文件就可以看出一些非常有希望的东西；如果你管理了react-apollo，那么这应该会容易一点。</p><p id="d0fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有很多像Graphene这样的工具为Python和JS提供了实现。请随意探索和使用它们。</p><p id="7f10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您开始使用GraphQL应用程序，我建议使用以下格式。</p><p id="11b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计算机网络服务器</p><ul class=""><li id="5fb8" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">使用apollo-server的一个变种设置一个应用程序，并使用PubSub自行配置订阅。</li><li id="039c" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mf mg mh mi bi translated">使用graphql-yoga轻松设置，并开始使用已经设置的订阅。</li><li id="cb28" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mf mg mh mi bi translated">graph QL(graph qljs)+express-graph QL</li></ul><p id="78c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户</p><ul class=""><li id="a66f" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">对于react应用程序，apollo-client + react-apollo运行良好。</li><li id="188f" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mf mg mh mi bi translated">React + urql。</li></ul><p id="1bb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于Graphcool Framework和Prisma，我会建议密切关注它们的更新，直到一切平衡。它们是正在快速发展变化的工具。由于这些变化，他们文档中的一些链接仍然是断开的，但这不应该阻止任何人使用它们。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="93db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会感谢你的掌声、评论、纠正、建议和积极的批评。</p></div></div>    
</body>
</html>