<html>
<head>
<title>Laravel: The hidden SetCacheHeaders Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:隐藏的SetCacheHeaders中间件</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-the-hidden-setcacheheaders-middleware-4cd594ba462f?source=collection_archive---------0-----------------------#2019-04-08">https://itnext.io/laravel-the-hidden-setcacheheaders-middleware-4cd594ba462f?source=collection_archive---------0-----------------------#2019-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="196f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远不要试图重新发明轮子。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d11e433edb5f4f31a743452cbe6f3435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwuKbYCVCKe2tHJ0kDFYLg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">找到你了！</figcaption></figure><p id="7389" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Laravel内部已经注册了很多有用的中间件，比如<a class="ae lu" href="https://laravel.com/docs/5.8/authentication#protecting-routes" rel="noopener ugc nofollow" target="_blank">认证机制</a>、<a class="ae lu" href="https://laravel.com/docs/5.8/authorization#via-middleware" rel="noopener ugc nofollow" target="_blank">授权</a>、一个<a class="ae lu" href="https://laravel.com/docs/5.8/routing#rate-limiting" rel="noopener ugc nofollow" target="_blank">节流器</a>，甚至还有一个负责使<a class="ae lu" href="https://laravel.com/docs/5.8/routing#route-model-binding" rel="noopener ugc nofollow" target="_blank">路由模型绑定</a>成为可能的中间件。实际上，您的中间件需求已经得到满足。除了一个。</p><p id="bff3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Laravel中，有一个中间件没有受到关注。叫<code class="fe lv lw lx ly b">SetCacheHeaders</code>，别名为<code class="fe lv lw lx ly b">cache.headers</code>。并且，在文档中没有提到它。我不是在开玩笑，伙计们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/c7797b03e8ed5804030bb267232f13a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JR8k896azWp2lEtypH5YMA.png"/></div></div></figure><h2 id="3c31" class="ma mb it bd mc md me dn mf mg mh dp mi lh mj mk ml ll mm mn mo lp mp mq mr ms bi translated">谁，何时，如何？</h2><p id="a207" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">快速浏览一下<a class="ae lu" href="https://laravel.com/api/5.6/" rel="noopener ugc nofollow" target="_blank"> api文档</a>和<a class="ae lu" href="https://github.com/laravel/framework/" rel="noopener ugc nofollow" target="_blank">源代码库</a>说这个中间件是在<a class="ae lu" href="https://github.com/laravel/framework/pull/22389" rel="noopener ugc nofollow" target="_blank">冗长的讨论</a>后<a class="ae lu" href="https://github.com/laravel/framework/commit/df06357d78629a479d341329571136d21ae02f6f#diff-cd155bc0da2b7d6ddf490bf346992653" rel="noopener ugc nofollow" target="_blank">于2017年圣诞节前</a>添加的，但是为什么没有人谈论它是个谜，因为它看起来非常……<em class="my">方便</em>。无论如何，写完这篇文章后，我对文档的<a class="ae lu" href="https://github.com/laravel/docs/pull/5114" rel="noopener ugc nofollow" target="_blank"> PR被接受了，所以</a><a class="ae lu" href="https://laravel.com/docs/5.8/responses#attaching-headers-to-responses" rel="noopener ugc nofollow" target="_blank">你现在应该在文档</a>里找到了。</p><p id="7726" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单地浏览一下中间件，我们就知道可以用它来<strong class="la iu">将缓存头添加到响应</strong>中，从而省去我们创建自己的中间件的工作。</p><h2 id="6e0c" class="ma mb it bd mc md me dn mf mg mh dp mi lh mj mk ml ll mm mn mo lp mp mq mr ms bi translated">在响应中缓存？你什么意思？</h2><p id="f322" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果你这样问，就意味着你不知道什么是HTTP缓存控制指令。</p><blockquote class="mz na nb"><p id="d344" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">简而言之，缓存控件是一种告诉浏览器应用程序发送的响应是否应该缓存以及在什么条件下缓存的方式，因此它可以决定是否应该再次接收完整的响应。</p></blockquote><p id="527b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个非常以浏览器为中心的机制，稍后你会明白为什么。在Google Developers 上有一篇<a class="ae lu" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching" rel="noopener ugc nofollow" target="_blank">非常好的文章，它将教你如何工作，你绝对应该读一读。我会等的。</a></p><p id="849a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">准备好了吗？既然我们知道了<em class="my"> HTTP缓存控件</em>是如何工作的，我们就可以理解这个中间件试图实现什么。或者跳过<em class="my">有用的</em>部分的下一节。</p><h1 id="d4b9" class="nf mb it bd mc ng nh ni mf nj nk nl mi jz nm ka ml kc nn kd mo kf no kg mr np bi translated">SetCacheHeaders中间件是如何工作的？</h1><p id="8ab9" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们检查一下<a class="ae lu" href="https://github.com/laravel/framework/blob/5.8/src/Illuminate/Http/Middleware/SetCacheHeaders.php" rel="noopener ugc nofollow" target="_blank">的源代码</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="53cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，在这个中间件的<code class="fe lv lw lx ly b">handle()</code>方法中有五个主要语句。试图用语言描述每个人做了什么:</p><ol class=""><li id="2469" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">它从检查请求是<code class="fe lv lw lx ly b">GET</code>还是<code class="fe lv lw lx ly b">HEAD</code>开始。你不能缓存一个<code class="fe lv lw lx ly b">POST</code>响应，因为这个方法意味着<em class="my">改变了</em>事情。</li><li id="86e1" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">检查是否向中间件传递了任何参数，并使用方便的<code class="fe lv lw lx ly b">parseOptions()</code>方法将它们解析成响应头。</li><li id="c326" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">如果已经设置了<code class="fe lv lw lx ly b">etag</code>选项，它将自动散列响应内容，以便可以快速与请求发送的<code class="fe lv lw lx ly b">etag</code>进行比较。</li><li id="157c" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">它将在<a class="ae lu" href="https://github.com/symfony/symfony/blob/3.3/src/Symfony/Component/HttpFoundation/Response.php#L952" rel="noopener ugc nofollow" target="_blank">响应</a>头中设置<code class="fe lv lw lx ly b">Cache-Control</code>选项。</li><li id="7581" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">最后，它将<a class="ae lu" href="https://github.com/symfony/symfony/blob/3.3/src/Symfony/Component/HttpFoundation/Response.php#L1079" rel="noopener ugc nofollow" target="_blank">检查响应是否未被修改</a>。如果不是，它将删除内容，只返回<code class="fe lv lw lx ly b">etag</code>，节省宝贵的千字节。</li></ol><p id="b355" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重点是第三点和第五点。浏览器将使用缓存响应的<code class="fe lv lw lx ly b">etag</code>向应用程序发出请求，如果最初的响应也是这样。您的应用程序将接收到<code class="fe lv lw lx ly b">etag</code>，<strong class="la iu">处理整个请求</strong>，最后，在响应的<code class="fe lv lw lx ly b">etag</code>中再次散列内容。通过比较这两个<code class="fe lv lw lx ly b">etag</code>,应用程序可以知道它是否应该再次发送整个响应，或者只发送同一个<code class="fe lv lw lx ly b">etag</code>,告诉浏览器内容没有改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/1a1dc26658cdab971925ae390a123843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzpyVSLtjSkp48KhsAiiPA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">etag在此应用程序中如何工作的艺术表现。</figcaption></figure><p id="afaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">强调“处理整个请求”是关键部分。除非整个响应就绪，否则应用程序或浏览器不会知道内容是否已经更改，这意味着:<strong class="la iu">您的所有应用程序逻辑将从头到尾运行</strong>。如果你需要一个更主动的缓存，你可以把目光投向令人敬畏的<a class="ae lu" href="https://github.com/spatie/laravel-responsecache" rel="noopener ugc nofollow" target="_blank"> Spatie的响应缓存</a>。</p><p id="780b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就我个人而言，我认为缓存控件是一个利基标题。如果我想实现这种技术，最好在服务器中缓存响应，然后添加<code class="fe lv lw lx ly b">etag</code>以节省两端的时间。</p><h1 id="a007" class="nf mb it bd mc ng nh ni mf nj nk nl mi jz nm ka ml kc nn kd mo kf no kg mr np bi translated">使用SetCacheHeaders中间件</h1><p id="38af" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">既然我们知道了这个中间件是做什么的，就很容易使用它了。让我们用一个简单的真实世界的例子，比如我的永恒播客应用程序。</p><blockquote class="mz na nb"><p id="efd3" class="ky kz my la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">我是我的播客应用程序，主页上有一个很大的最新发布的播客列表，根据用户认证和订阅的播客而有所不同。我的指标显示，每次播客发布之间至少有5分钟。</p></blockquote><p id="783d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看Google的<a class="ae lu" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en#defining_optimal_cache-control_policy" rel="noopener ugc nofollow" target="_blank">流程图，看看使用什么缓存控制策略</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/02de929b78b889891aacfbd3cd148b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*ao3Ye3EczqvBelmH.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">谷歌开发者——谷歌(2019)</figcaption></figure><p id="26f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，我们明白了:</p><ul class=""><li id="fc80" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt oi ny nz oa bi translated">如果最新发布的播客仍然是相同的，那么<code class="fe lv lw lx ly b">no-cache</code>和<code class="fe lv lw lx ly b">etag</code>将允许用户刷新页面(甚至在到期时间之前),而无需下载整个页面。</li><li id="494e" class="ns nt it la b lb ob le oc lh od ll oe lp of lt oi ny nz oa bi translated"><code class="fe lv lw lx ly b">private</code>表示主页是针对每个用户的，应该只在用户设备中缓存，而不是在代理服务器中缓存。</li><li id="e886" class="ns nt it la b lb ob le oc lh od ll oe lp of lt oi ny nz oa bi translated"><code class="fe lv lw lx ly b">max-age=300</code>将设置5分钟的到期时间，因为过了这个时间之后肯定会有新的播客发布。</li></ul><pre class="kj kk kl km gt oj ly ok ol aw om bi"><span id="2036" class="ma mb it ly b gy on oo l op oq">Route::get('/', 'PodcastController@index')<br/>    -&gt;middleware('cache.headers:no-cache,private,max-age=300;etag');</span></pre><p id="ac5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已。不需要创建自己的中间件或侵入Apache或NGINX，这是现成可用的。</p></div></div>    
</body>
</html>