<html>
<head>
<title>The Art of Type Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型编程的艺术</h1>
<blockquote>原文：<a href="https://itnext.io/the-art-of-type-programming-cfd933bdfff7?source=collection_archive---------2-----------------------#2021-03-11">https://itnext.io/the-art-of-type-programming-cfd933bdfff7?source=collection_archive---------2-----------------------#2021-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="df08" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">把复杂的事情变简单，把简单的事情变琐碎。</p></blockquote></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="7f32" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">typescript中的类型会很快失控，比如要合并两个对象(<a class="ae lc" href="https://github.com/type-challenges/type-challenges/blob/master/questions/599-medium-merge/README.md" rel="noopener ugc nofollow" target="_blank"> 599-medium-merge </a>)，解决方法可以是:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/be5a6e06970bcb9d6bb34597107af3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJz8qTvS2dZxcZCMBkA1Eg.png"/></div></div></figure><p id="710b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">或者查找两个对象的差异(<a class="ae lc" href="https://github.com/type-challenges/type-challenges/blob/master/questions/645-medium-diff/README.md" rel="noopener ugc nofollow" target="_blank">645-中等差异</a>):</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/25ef2662119987a294859b51a2fe6d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B78gvkfsQdzn_ulMvv1Efw.png"/></div></div></figure><h1 id="6922" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">类型编程vs类型体操</h1><p id="ed1f" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb jx ij bi translated">是的，我们可以实现Merge，Diff，然后忘记它们，只要它能工作，我们就不会再担心这些了。因此，在创建类型的过程中，使用了一些技巧，像嵌套的三元表达式(条件类型)这样的复杂代码被故意忽略了。</p><p id="bb6f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">太好了，它能工作了！</p><p id="de3b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">我们在日常编程中不做的，是我们在类型编程中一直在做的，或者更准确地说，是类型体操。</p><p id="3928" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">在本文中，我想建议我们将类型编程视为真正的编程。</p><p id="db01" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated"><a class="ae lc" href="https://github.com/mistlog/typetype" rel="noopener ugc nofollow" target="_blank">在下面的例子中使用了TypeType </a>，这是一种为typescript类型生成而设计的编程语言。</p><h1 id="95ba" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">类型语句-&gt;类型表达式</h1><p id="fce8" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb jx ij bi translated">在typetype中，我们不使用三元表达式作为条件类型，而是使用传统的if &amp; else。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/369caa9ede88df05d9d0804ba9fe5aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qaPfsXfZX8cTnPQBkwcH9w.png"/></div></div></figure><p id="ea61" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">“类型函数”用于声明类型的函数，type in和type out，在typescript中称为“泛型”，但在本质上，它是类型的函数，我们将明确这一点。</p><p id="1041" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">“^{…}”称为块表达式，在这个块中，语句将被翻译成typescript中的类型表达式。在本例中，“if语句”将被翻译为“条件类型”。</p><p id="16e6" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">你可以在操场上看到它的动作:<a class="ae lc" href="https://mistlog.github.io/typetype-playground/" rel="noopener ugc nofollow" target="_blank">https://mistlog.github.io/typetype-playground/</a>。</p><p id="4122" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">为了实现“isNumberString ”,我们现在有了另一个选择:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/427830d7c5c1fb34149b7198f2f484c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ll1KOgWPfke528-rln1rDQ.png"/></div></div></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/dd24b7ada9d53c91bf00ca510bf69a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAleceLp3svxK5wi_Rk4kA.png"/></div></div></figure><p id="9367" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">映射类型表示为“for in语句”:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/052aaec445fe3dd07351014d4c113e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxO24bEpo3fhbZAR68ot6w.png"/></div></div></figure><p id="c47d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">那么，Merge和Diff的解可以是:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/1fe152da7b79815d3c15b97cb88a095b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y40LVjY5in6VDjD_SNGktw.png"/></div></div></figure><h1 id="e57e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">没有诡计</h1><p id="0a1a" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb jx ij bi translated">我们不使用技巧来合并对象，而是使用直观的<a class="ae lc" href="https://github.com/mistlog/typetype#object-spread" rel="noopener ugc nofollow" target="_blank">对象扩展</a>语法。例如，在<a class="ae lc" href="https://github.com/mistlog/typetype-examples/blob/main/examples/url-parser-2/url-parser-2.type" rel="noopener ugc nofollow" target="_blank"> url-parser-2 </a>中:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/651e60f4df9875021e9885172f907ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*panWUr2GrPysRxJQDD3jvw.png"/></div></div></figure><p id="5c7a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">对象扩展被转换为对象$assign:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/eb52dd9fcdbdbbe0b83d85aab318ed0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XCr0dNeVNc4ItW2H2_WbqA.png"/></div></div></figure><p id="3fdb" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb jx ij bi translated">然后，我们对其进行填充，使其在全球范围内可用:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/61475fe10dfbf43c8a80a17859ea4e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whrAkzydxrSwKniJobSU_Q.png"/></div></div></figure><h1 id="04ac" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最后</h1><p id="1c3b" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb jx ij bi translated">当我们把类型编程当作普通编程时，它并没有什么特别之处。上面可以看到，只是“if else”或者嵌套“if else”和“for in”。</p><ul class=""><li id="28af" class="ms mt iq kh b ki kj km kn kq mu ku mv ky mw jx mx my mz na bi translated">回购:<a class="ae lc" href="https://github.com/mistlog/typetype" rel="noopener ugc nofollow" target="_blank">https://github.com/mistlog/typetype</a></li><li id="84b3" class="ms mt iq kh b ki nb km nc kq nd ku ne ky nf jx mx my mz na bi translated">(40+例):【https://github.com/mistlog/typetype-examples】T2</li></ul></div></div>    
</body>
</html>