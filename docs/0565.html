<html>
<head>
<title>GraphQL Interfaces (and Union Types) with Prisma and Yoga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL与Prisma和Yoga的接口(和联合类型)</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-interfaces-and-union-types-with-prisma-and-yoga-7224f9e1d9ad?source=collection_archive---------4-----------------------#2018-04-02">https://itnext.io/graphql-interfaces-and-union-types-with-prisma-and-yoga-7224f9e1d9ad?source=collection_archive---------4-----------------------#2018-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e5aabe9f1ed29763fafbaa1c66b0d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDxzpMJNK7Z2HJGK."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克林特·王茂林在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="kd ke kf"><p id="63d2" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fgraphql-interfaces-and-union-types-with-prisma-and-yoga-7224f9e1d9ad%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><h1 id="6e88" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">GraphQL是什么？</h1><p id="4150" class="pw-post-body-paragraph kg kh iq kj b kk md km kn ko me kq kr mf mg ku kv mh mi ky kz mj mk lc ld le ij bi translated">GraphQL是一种API查询语言，来自脸书团队，最近已经接管了互联网。它的优势在于围绕强类型API契约构建，该契约详尽地定义了API中的数据及其模式、如何请求数据等等。它支持具有受控水合作用的深度嵌套查询，并允许API客户机将来自不同来源或模型的数据组合成一个查询。使用GraphQL，您可以准确地获得您想要的数据，以您想要的方式格式化，并且在一个查询中，解决了传统REST APIs的几个问题。此外，API契约概念支持各种强大的开发工具，下面我将介绍其中的一些。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="14e3" class="lf lg iq bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated">我的GraphQL堆栈</h1><ul class=""><li id="2136" class="mx my iq kj b kk md ko me mf mz mh na mj nb le nc nd ne nf bi translated"><a class="ae kc" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir"> Prisma </strong> </a>，由<a class="ae kc" href="https://twitter.com/graphcool" rel="noopener ugc nofollow" target="_blank"> Graphcool </a>的神奇团队开发，是一种GraphQL ORM，它获取你在<a class="ae kc" href="https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51" rel="noopener ugc nofollow" target="_blank"> SDL(模式定义语言)</a>中定义的数据模式，并为其生成数据库和API。为(嵌套的)CRUD操作生成的API的广泛性是惊人的。您可以在他们的云中部署您的数据库服务，或者在您的基础设施上使用docker。最重要的是，Prisma附带了<a class="ae kc" href="https://www.prisma.io/docs/reference/prisma-bindings/overview-oobi0eicho" rel="noopener ugc nofollow" target="_blank">绑定</a>，为在Prisma服务之上构建GraphQL服务器提供了一个便利层。</li><li id="8463" class="mx my iq kj b kk ng ko nh mf ni mh nj mj nk le nc nd ne nf bi translated"><a class="ae kc" href="https://github.com/graphcool/graphql-yoga" rel="noopener ugc nofollow" target="_blank"><strong class="kj ir">【graph QL-yoga】</strong></a>，也是由Graphcool(这些家伙是上🔥)，是构建GraphQL服务器最简单的方法。它基于或兼容大多数用于用Javascript构建GraphQL服务器的事实上的标准库，但它从改善开发人员体验的角度出发，通过使用合理的默认值和更具声明性的配置方法，使一切设置更容易。它或多或少涵盖了整个GraphQL规范，甚至包括对订阅的WebSockets支持。</li><li id="5679" class="mx my iq kj b kk ng ko nh mf ni mh nj mj nk le nc nd ne nf bi translated"><a class="ae kc" href="https://github.com/graphcool/graphql-playground" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir"> GraphQL游乐场</strong> </a>，也由graph cool(wuut？😱)，是一个基于web的GraphQL client / IDE，它通过自省API契约来加速您的开发工作流，从而为它提供一个自动的交互式文档，以及一个具有自动完成功能的查询接口，并根据您的模式进行验证。它包含了漂亮的小特性，是任何GraphQL的首选工具。</li><li id="80a0" class="mx my iq kj b kk ng ko nh mf ni mh nj mj nk le nc nd ne nf bi translated">由<a class="ae kc" href="https://twitter.com/apollographql" rel="noopener ugc nofollow" target="_blank"> Apollo </a>的天才们开发的<a class="ae kc" href="https://www.apollographql.com/client" rel="noopener ugc nofollow" target="_blank"> <strong class="kj ir"> Apollo客户端</strong> </a>可能是目前最好的GraphQL客户端。它与每一个主要的前端平台兼容，专注于在UI组件中获取数据，而不需要为获取数据做任何准备。我喜欢React的声明式数据获取方法，以及它支持的高级数据加载特性。例如缓存、加载、乐观UI、分页等。devtools对您的开发人员体验也是一个很好的补充。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="60b2" class="lf lg iq bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated">现在谈谈界面…</h1><h2 id="adab" class="nl lg iq bd lh nm nn dn ll no np dp lp mf nq nr lt mh ns nt lx mj nu nv mb nw bi translated">一些背景</h2><p id="f833" class="pw-post-body-paragraph kg kh iq kj b kk md km kn ko me kq kr mf mg ku kv mh mi ky kz mj mk lc ld le ij bi translated">GraphQL模式规范支持<a class="ae kc" href="https://graphql.org/learn/schema/#interfaces" rel="noopener ugc nofollow" target="_blank">接口</a>和<a class="ae kc" href="https://graphql.org/learn/schema/#union-types" rel="noopener ugc nofollow" target="_blank">联合类型</a>。接口是一种抽象类型，它包含一组特定的字段，类型必须包含这些字段才能实现接口，而联合类型允许在不共享任何结构的情况下对几种类型进行分组。</p><p id="2f11" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">对于任何重要的数据结构，您很可能需要利用这些结构来建模您的数据。问题是:</p><ol class=""><li id="1720" class="mx my iq kj b kk kl ko kp mf nx mh ny mj nz le oa nd ne nf bi translated">Prisma还不支持接口或联合类型。它们中的每一个都有未解决的问题—参见<a class="ae kc" href="https://github.com/graphcool/prisma/issues/83" rel="noopener ugc nofollow" target="_blank">接口</a>和<a class="ae kc" href="https://github.com/graphcool/prisma/issues/165" rel="noopener ugc nofollow" target="_blank">联合类型</a>。</li><li id="3c0f" class="mx my iq kj b kk ng ko nh mf ni mh nj mj nk le oa nd ne nf bi translated">graphql-yoga支持这两者，但是它们的用法还没有被记录下来，这使得实际上很难实现任何东西。不久前我打开了<a class="ae kc" href="https://github.com/graphcool/graphql-yoga/issues/121" rel="noopener ugc nofollow" target="_blank">的一个问题</a>想知道更多，这篇文章把我带到了这里。</li></ol><h2 id="2822" class="nl lg iq bd lh nm nn dn ll no np dp lp mf nq nr lt mh ns nt lx mj nu nv mb nw bi translated">我的方法</h2><p id="dd41" class="pw-post-body-paragraph kg kh iq kj b kk md km kn ko me kq kr mf mg ku kv mh mi ky kz mj mk lc ld le ij bi translated">由于Prisma目前只支持类型和枚举，我们必须找到一种方法来建模我们的数据，而不使用Prisma中的接口。然而，我们可以使用GraphQL服务器上的接口(graphql-yoga ),以便面向客户端的API被适当地构造，并且用户可以使用<a class="ae kc" href="https://graphql.org/learn/queries/#inline-fragments" rel="noopener ugc nofollow" target="_blank">内联片段</a>跨类型请求数据。</p><p id="2d57" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">这给我们留下了两个选择:</p><ol class=""><li id="daee" class="mx my iq kj b kk kl ko kp mf nx mh ny mj nz le oa nd ne nf bi translated">将所有带有可选类型特定字段的数据存储在Prisma中的一个类型(接口)下，然后在应用服务器中的原始类型之间拆分数据。</li><li id="aa4e" class="mx my iq kj b kk ng ko nh mf ni mh nj mj nk le oa nd ne nf bi translated">在Prisma上存储每个原始类型的数据，并在应用服务器上拼接查询内容。</li></ol><p id="43ed" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">选项2的问题是您失去了分页的一致性。如何获得界面的最后20项？每种基本类型需要多少个？你可以做20个，把它们分类，然后拿走20个，但这在我看来很不雅。</p><p id="6c58" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">所以我选了选项1，我们来看看怎么实现。我将按照文档中使用的模式<a class="ae kc" href="https://graphql.org/learn/schema/#interfaces" rel="noopener ugc nofollow" target="_blank">给出代码片段。</a></p><h2 id="a9e9" class="nl lg iq bd lh nm nn dn ll no np dp lp mf nq nr lt mh ns nt lx mj nu nv mb nw bi translated">Prisma解决方案</h2><p id="6596" class="pw-post-body-paragraph kg kh iq kj b kk md km kn ko me kq kr mf mg ku kv mh mi ky kz mj mk lc ld le ij bi translated">基本上，我们希望将所有基本类型合并为一个单一的“接口”类型。特定于类型的字段必须是可选的，因为它们不会对每个条目都可用，并且它们以基本类型的名称为前缀，以确保它们是唯一的。在文档中，我们有:</p><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GraphQL文档中的接口示例</figcaption></figure><p id="340a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">我们的解决方案是:</p><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">带有模拟界面的Prisma的datamodel.graphql文件</figcaption></figure><h2 id="0b16" class="nl lg iq bd lh nm nn dn ll no np dp lp mf nq nr lt mh ns nt lx mj nu nv mb nw bi translated">在graphql-yoga中映射接口</h2><p id="7969" class="pw-post-body-paragraph kg kh iq kj b kk md km kn ko me kq kr mf mg ku kv mh mi ky kz mj mk lc ld le ij bi translated">根据需要，我们在面向客户端API的模式中声明了与文档中相同的接口和基本类型。我们还复制了Prisma生成的<code class="fe oh oi oj ok b">dbCharacters</code>查询的模式，作为面向客户端的API的<code class="fe oh oi oj ok b">characters</code>查询。这可能会更好。然而，返回类型被更改为我们的接口，因此返回的项应该被映射到一个基本类型，在这个基本类型上可以使用特定于类型的内联片段。</p><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">src/schema.graphql</figcaption></figure><p id="4553" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">为了将Prisma返回的条目映射到原始类型，我们需要在resolvers对象的根处为我们的接口提供一个类型解析器。我已经将接口解析器的声明分离到一个单独的文件中，并通过将<a class="ae kc" href="https://developer.mozilla.org/my/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">对象析构为</a>导入到解析器对象中。参见<code class="fe oh oi oj ok b">interfaces.js</code>文件中的<code class="fe oh oi oj ok b">__resolveType</code>示例。这是一个展示如何解析类型的简单示例。您将根据数据的特定业务逻辑来实现您的。</p><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">src/resolvers/index.js</figcaption></figure><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">src/resolvers/interfaces.js</figcaption></figure><p id="76e0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated">最后要做的是实现接口的客户端API。它由Prisma的相应API支持，但是我们需要在两个模式之间转换I/o。<code class="fe oh oi oj ok b">characters</code>查询的解析器在<code class="fe oh oi oj ok b">Query.js</code>文件中实现，这非常经典。实现细节如下:</p><ol class=""><li id="fa12" class="mx my iq kj b kk kl ko kp mf nx mh ny mj nz le oa nd ne nf bi translated">我们必须确保在查询中为原始类型选择的所有字段都是从Prisma请求的。为此，我在<code class="fe oh oi oj ok b">interfaces.js</code>中编写了一个名为<code class="fe oh oi oj ok b">makeSelection</code>的实用函数，它从解析器获取<code class="fe oh oi oj ok b">info</code>对象并解析查询AST ( <code class="fe oh oi oj ok b">GraphQLResolveInfo</code>)以生成发送给Prisma的字符串选择。这将修改选择，以确保嵌套在内联片段(如<code class="fe oh oi oj ok b">...on Droid { primaryFunction }</code>)中的所有字段将作为普通前缀字段从Prisma中查询，如<code class="fe oh oi oj ok b">droid_primaryFunction</code>。在检查<code class="fe oh oi oj ok b">info</code>对象并将其映射到要发送给Prisma的预期选择时，这个方法的代码几乎是反复试验的。<em class="ki">免责声明</em>:该代码仅涵盖我一直需要的查询，可能需要添加以涵盖所有用例。还要注意，我不是ASTs专家，所以可能有更好的方法，如果你知道的话，请在评论中提出建议。</li><li id="db87" class="mx my iq kj b kk ng ko nh mf ni mh nj mj nk le oa nd ne nf bi translated">我们必须将从Prisma收到的对象格式化回它们在客户端API模式中的预期形式。我使用了另一个名为<code class="fe oh oi oj ok b">formatPrimitiveFields</code>的实用函数，也可以在<code class="fe oh oi oj ok b">interfaces.js</code>中找到，它接受一个字段，比如<code class="fe oh oi oj ok b">droid_primaryFunction</code>，并删除了原始类型前缀。</li></ol><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">src/resolvers/Query.js</figcaption></figure><figure class="ob oc od oe gt jr"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">src/resolvers/interfaces.js</figcaption></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="b045" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated"><em class="ki">本文没有直接讨论联合类型，但是它们非常类似于接口的</em> <code class="fe oh oi oj ok b"><em class="ki">__resolveType</em></code> <em class="ki">方法。</em></p><p id="d368" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated"><em class="ki">代码片段是为node 8及以上编写的。</em></p><p id="4864" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr mf kt ku kv mh kx ky kz mj lb lc ld le ij bi translated"><em class="ki">如果您使用的是</em> <strong class="kj ir"> <em class="ki"> Apollo客户端</em> </strong> <em class="ki">，请注意，内联片段中的接口和联合在开箱即用时无法正确解析。您需要基于api模式设置一个定制的片段匹配器。这在</em>  <em class="ki">的</em> <a class="ae kc" href="https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher" rel="noopener ugc nofollow" target="_blank"> <em class="ki">中有详细的解释。</em></a></p></div></div>    
</body>
</html>