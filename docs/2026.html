<html>
<head>
<title>Customizing gRPC Generated Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">定制gRPC生成的代码</h1>
<blockquote>原文：<a href="https://itnext.io/customizing-grpc-generated-code-5909a2551ca1?source=collection_archive---------3-----------------------#2019-03-18">https://itnext.io/customizing-grpc-generated-code-5909a2551ca1?source=collection_archive---------3-----------------------#2019-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="962a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">gRPC是一个强大的框架，在服务之间提供快速有效的通信。gRPC是什么以及如何使用它超出了本文的范围。如果您有兴趣开始使用gRPC，我建议您阅读位于<a class="ae ko" href="https://grpc.io/docs/guides/" rel="noopener ugc nofollow" target="_blank">此处</a>的gRPC文档。</p><p id="0bb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">gRPC的核心组件是客户机/服务器应用程序的代码生成。该代码由协议编译器从<em class="kp">中生成。proto </em>文件。虽然生成的代码遵循了一些好的实践，比如不可变对象和构建器模式，但是对于生成的代码，您可能喜欢也可能不喜欢其他的决定。</p><p id="b524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从表面上看，gRPC似乎是我们的完美解决方案。但是我们遇到了几个问题，不是直接与gRPC或Protobuf有关，而是与在生成的代码中特别做出的选择有关。</p><p id="8418" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们试图使用gRPC将现有的Java应用程序迁移到微服务。不幸的是，我们现有的代码在我们的域对象中明智地使用了<em class="kp"> null </em>。(这是否是个好主意无关紧要。这就是我们所拥有的，我们没有时间去重构它。)从表面上看，这似乎不是一个问题，直到我们开始使用gRPC生成的代码。</p><p id="be8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个简单的例子。假设我有一个现有的Java域对象雇员:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="bd38" class="kz la it kv b gy lb lc l ld le">@Value<br/><strong class="kv iu">public class </strong>Employee {<br/>    String <strong class="kv iu">name</strong>;<br/>    BigDecimal <strong class="kv iu">salary</strong>;<br/>    BigDecimal <strong class="kv iu">bonus</strong>;<br/>}</span></pre><p id="5de8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们现有的模型中，如果员工没有奖金，我们会将字段<em class="kp">留空</em>。</p><p id="e7cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个域对象的原型定义如下:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="93a0" class="kz la it kv b gy lb lc l ld le">import <strong class="kv iu">"google/type/money.proto"</strong>;<br/><br/>message Employee {<br/>    string name = 1;<br/>    google.type.Money salary = 2;<br/>    google.type.Money bonus = 3;<br/>}</span></pre><p id="52e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的域对象有了一个protobuf模型。让我们开始使用它。作为产品化阶段，我们采用的模式是在原始域对象和新的原型对象之间构建代理接口和转换器。这允许我们在很少甚至没有重构的情况下将现有代码转换为使用protobuf。</p><p id="6906" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="e0b4" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">public class </strong>EmployeeTransformer {<br/><br/>    <strong class="kv iu">public </strong>Employee toEmployee(EmployeeProto employeeProto) {<br/>        <strong class="kv iu">return </strong>Employee.<em class="kp">newBuilder</em>()<br/>                .name(employeeProto.getName())<br/>                .salary(toBigDecimal(employeeProto.getSalary()))<br/>                .bonus(toBigDecimal(employeeProto.getBonus()))<br/>                .build();<br/>    }<br/><br/>    <strong class="kv iu">public </strong>EmployeeProto toEmployeeProto(Employee employee) {<br/>        <strong class="kv iu">return </strong>EmployeeProto.<em class="kp">newBuilder</em>()<br/>                .setSalary(toMoney(employee.getSalary()))<br/>                .setBonus(toMoney(employee.getBonus()))<br/>                .build();<br/>    }</span><span id="2076" class="kz la it kv b gy lf lc l ld le">    ...<br/>}</span></pre><p id="c282" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来不错，对吧？</p><p id="56a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为优秀的开发人员，我们应该编写一些测试用例:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="8e72" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">def "test toEmployeeProro"</strong>(EmployeeProto input, Employee expected) {<br/>    <strong class="kv iu">given</strong>:<br/>    EmployeeTransformer transformer = <strong class="kv iu">new </strong>EmployeeTransformer()<br/><br/>    <strong class="kv iu">expect</strong>:<br/>    transformer.toEmployeeProto(expected) == input<br/><br/>    <strong class="kv iu">where</strong>:<br/>    input                                | expected<br/>    <em class="kp">createEmployeeProto</em>(<strong class="kv iu">"bob"</strong>, 45, 100)  | <em class="kp">createEmployee</em>(<strong class="kv iu">"bob"</strong>, 45, 100)<br/>    <em class="kp">createEmployeeProto</em>(<strong class="kv iu">"bob"</strong>, 45, 0)    | <em class="kp">createEmployee</em>(<strong class="kv iu">"bob"</strong>, 45, 0)<br/>    <em class="kp">createEmployeeProto</em>(<strong class="kv iu">"bob"</strong>, 45, <strong class="kv iu">null</strong>) | <em class="kp">createEmployee</em>(<strong class="kv iu">"bob"</strong>, 45, <strong class="kv iu">null</strong>)<br/>}</span></pre><p id="2b6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行这个规范，一切都很好吧？不对！</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="39a8" class="kz la it kv b gy lb lc l ld le">Condition failed with Exception:</span><span id="5b4f" class="kz la it kv b gy lf lc l ld le">transformer.toEmployeeProto(expected) == input<br/>|           |               |<br/>|           |               Employee(name=bob, salary=45, bonus=null)<br/>|           java.lang.NullPointerException<br/>com.efenglu.jprotoc.example.EmployeeTransformer@7c83dc97</span></pre><p id="17bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，太奇怪了。</p><p id="38fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看，当奖金为空值时，我们得到了一个NPE，因为我们用空值调用了集合。</p><p id="ef2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为:</p><h2 id="72ea" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">Protobuf不允许空值</h2><p id="2389" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">它有也没有。Protobuf不允许你设置一个字段为空。它将在带有空值的调用集上抛出一个NPE。</p><p id="bb41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，我们的另一个规格呢:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="89d6" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">def "test toEmployee"</strong>(EmployeeProto input, Employee expected) {<br/>    <strong class="kv iu">given</strong>:<br/>    EmployeeTransformer transformer = <strong class="kv iu">new </strong>EmployeeTransformer()<br/><br/>    <strong class="kv iu">expect</strong>:<br/>    transformer.toEmployee(input) == expected<br/><br/>    <strong class="kv iu">where</strong>:<br/>    input                                | expected<br/>    <em class="kp">createEmployeeProto</em>(<strong class="kv iu">"bob"</strong>, 45, 100)  | <em class="kp">createEmployee</em>(<strong class="kv iu">"bob"</strong>, 45, 100)<br/>    <em class="kp">createEmployeeProto</em>(<strong class="kv iu">"bob"</strong>, 45, 0)    | <em class="kp">createEmployee</em>(<strong class="kv iu">"bob"</strong>, 45, 0)<br/>    <em class="kp">createEmployeeProto</em>(<strong class="kv iu">"bob"</strong>, 45, <strong class="kv iu">null</strong>) | <em class="kp">createEmployee</em>(<strong class="kv iu">"bob"</strong>, 45, <strong class="kv iu">null</strong>)<br/>}</span></pre><p id="31bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这怎么公平:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="1bd9" class="kz la it kv b gy lb lc l ld le">Condition not satisfied:</span><span id="1520" class="kz la it kv b gy lf lc l ld le">transformer.toEmployee(input) == expected<br/>|           |          |      |  |<br/>|           |          |      |  Employee(name=bob, salary=45, bonus=null)<br/>|           |          |      false<br/>|           |          name: "bob"<br/>|           |          salary {<br/>|           |            currency_code: "USD"<br/>|           |            units: 45<br/>|           |          }<br/>|           Employee(name=bob, salary=45, bonus=0)<br/>com.efenglu.jprotoc.example.EmployeeTransformer@198b6731</span></pre><p id="ab07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们期望得到一个空值，但得到的是0。为什么？</p><h2 id="10a9" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">Protobuf不允许空值</h2><p id="f510" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">当没有设置字段时，Protobuf将返回一个默认对象。因此，该值为0，而不是空值。</p><figure class="kq kr ks kt gt md gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/e195f3e215ce277bae38a0dd56a3514c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*f7CaAqKTP3gYnx2xDanSmQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated"><a class="ae ko" href="https://xkcd.com/386/" rel="noopener ugc nofollow" target="_blank">https://xkcd.com/386/</a></figcaption></figure><p id="45bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，本文并不打算讨论使用空值/非空值等的优点。让我们向前看，想出如何处理我们已经失去的牌。</p><ol class=""><li id="99db" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">我们有一个期望空值的域模型</li><li id="59d6" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">我们有一个不允许空值的传输框架</li></ol><p id="71a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从表面上看，这似乎是一个棘手的问题。但不完全是。虽然protobuf不直接支持null上的概念，但它确实提供了一个<em class="kp">has</em>概念。<em class="kp"> has </em> boolean意在告诉你一个值是否已经被设置。我们可以用这个来<em class="kp">传送</em>我们的空值概念。</p><p id="ab8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们修改代码，使用哈希函数，避免NPE函数。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="b26b" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">public class </strong>EmployeeTransformerHas {<br/><br/>    <strong class="kv iu">public </strong>Employee toEmployee(EmployeeProto employeeProto) {<br/>        <strong class="kv iu">final </strong>Employee.EmployeeBuilder builder = Employee.<em class="kp">newBuilder</em>()<br/>                .name(employeeProto.getName());<br/>        <strong class="kv iu">if </strong>(employeeProto.hasSalary()) {<br/>            builder.salary(toBigDecimal(employeeProto.getSalary()));<br/>        }<br/>        <strong class="kv iu">if </strong>(employeeProto.hasBonus()) {<br/>            builder.bonus(toBigDecimal(employeeProto.getBonus()));<br/>        }<br/>        <strong class="kv iu">return </strong>builder.build();<br/>    }<br/><br/>    <strong class="kv iu">public </strong>EmployeeProto toEmployeeProto(Employee employee) {<br/>        <strong class="kv iu">final </strong>EmployeeProto.Builder builder = EmployeeProto.<em class="kp">newBuilder</em>()<br/>                .setName(employee.getName());<br/>        <strong class="kv iu">if </strong>(employee.getSalary() != <strong class="kv iu">null</strong>) {<br/>            builder.setSalary(toMoney(employee.getSalary()));<br/>        }<br/>        <strong class="kv iu">if </strong>(employee.getBonus() != <strong class="kv iu">null</strong>) {<br/>            builder.setBonus(toMoney(employee.getBonus()));<br/>        }<br/>        <strong class="kv iu">return </strong>builder.build();<br/>    }<br/>   <br/>    ...<br/>}</span></pre><p id="c4f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我们的测试现在通过了，但是transformer代码非常难看。</p><p id="a6c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，虽然transformer为现有的域对象提供了帮助，但我们更希望我们的客户端能够本地使用protobuf。一旦我们的程序员开始使用代码，他们将不得不手工编写所有这些检查。如果我们能以某种方式支持set上的null和get上的null就好了。</p><p id="b5cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进入协议插件。</p><h1 id="4721" class="my la it bd lg mz na nb lj nc nd ne lm nf ng nh lp ni nj nk ls nl nm nn lv no bi translated">协议插件扩展点</h1><p id="4277" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">Protoc有一个扩展点机制，允许你在生成代码的同时插入代码。这将允许我们添加具有我们想要的行为的助手/实用工具方法。</p><p id="aceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先是一些坏消息。</p><p id="0c80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不直接为protoc编译器编辑原始C代码，您就不能更改任何现有的生成代码。所以不能直接把set方法改成接受null，或者把get方法改成返回null。</p><p id="4b93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您<strong class="js iu">可以</strong>做的是向生成的类添加新方法。比如添加一个<em class="kp"> setOrClear </em>方法和一个<em class="kp"> nullGet </em>方法。</p><p id="d84a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们的项目，我们决定添加一个<em class="kp"> setOrClear </em>和一个<em class="kp"> optionalGet </em>方法。</p><h2 id="ff25" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">setOrClear</h2><p id="0cdd" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">为生成的接受空值的构建器提供setOrClear方法。</p><ul class=""><li id="58ee" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn np mq mr ms bi translated">如果提供的值为null，构建器将在相关字段上调用clear。</li><li id="b7c7" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">如果提供的值为非空，构建器将使用提供的值在关联字段上调用set。这避免了用空值调用set时通常会引发的NPE。</li></ul><p id="e0f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="abe9" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">public </strong>Builder setOrClearBonus(com.google.type.Money value) {<br/>   <strong class="kv iu">if </strong>(value != <strong class="kv iu">null</strong>) {<br/>     <strong class="kv iu">return </strong>setBonus(value);<br/>   } <strong class="kv iu">else </strong>{<br/>     clearBonus();<br/>   }<br/>   <strong class="kv iu">return this</strong>;<br/>}</span></pre><h2 id="3e68" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">optionalGet</h2><p id="2892" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">添加一个方法<em class="kp"> optional{Field} </em>，该方法将在一个<a class="ae ko" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank"> java.util.Optional </a>对象中包装一个消息类型的所有非原始字段。</p><ul class=""><li id="ad3d" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn np mq mr ms bi translated">当<em class="kp">有{字段} </em>返回假时，可选为空</li><li id="e7fb" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">当<em class="kp">有{Field} </em>返回true时，可选包含调用<em class="kp"> get{Field}的值。</em></li></ul><p id="7800" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="ab7b" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">public </strong>java.util.Optional&lt;com.google.type.Money&gt; optionalBonus() {<br/>   <strong class="kv iu">if </strong>(hasBonus()) {<br/>     <strong class="kv iu">return </strong>java.util.Optional.<em class="kp">of</em>(getBonus());<br/>   } <strong class="kv iu">else </strong>{<br/>     <strong class="kv iu">return </strong>java.util.Optional.<em class="kp">empty</em>();<br/>   }<br/>}</span></pre><p id="d702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过组合<em class="kp"> setOrClear </em>和<em class="kp"> optional </em>，我们觉得这是两全其美的选择。我们可以设置空值，但仍然提供非空返回类型。</p><h2 id="22b1" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">但是…</h2><p id="beb1" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">其他一些坏消息。这种方法要求开发人员调用正确的方法。<em class="kp"> set </em>仍然抛出NPE，get仍然返回一个默认值。这并不理想，但是对于那些习惯了预期的Protobuf行为的人来说也是有用的。</p><p id="ad47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，这些新方法只适用于你编译的原型。所以如果你重用别人预先打包好的原型定义，你就不会得到这些新方法。</p><h1 id="7aee" class="my la it bd lg mz na nb lj nc nd ne lm nf ng nh lp ni nj nk ls nl nm nn lv no bi translated">创建插件</h1><p id="3412" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">我们如何编写这个神奇的插件。你可以用C写它，并使用一些现有的协议库代码。然而，我们是一家Java商店，维护C代码并不是一个真正的选择。</p><p id="065c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢天谢地，protoc实际上并不关心你的插件是用什么写的。protoc所做的就是调用插件可执行文件，并传入一个描述我们想要生成的protobuf的protobuf字符串。</p><p id="7e5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很meta，也很酷。</p><p id="7d46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Salesforce提供了一个maven插件来帮助我们。这允许我们用Java编写我们的插件作为一个常规的maven工件。</p><p id="cedb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整代码库的链接在文章末尾，但是让我们先关注几个部分。</p><h2 id="baec" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">步骤1:设置maven模块</h2><p id="c70a" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">这里没什么特别的。我们只需要一个普通的maven jar模块。请确保我们依赖Salesforce jprotoc</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="31b3" class="kz la it kv b gy lb lc l ld le">&lt;<strong class="kv iu">dependency</strong>&gt;<br/>    &lt;<strong class="kv iu">groupId</strong>&gt;com.salesforce.servicelibs&lt;/<strong class="kv iu">groupId</strong>&gt;<br/>    &lt;<strong class="kv iu">artifactId</strong>&gt;jprotoc&lt;/<strong class="kv iu">artifactId</strong>&gt;<br/>    &lt;<strong class="kv iu">version</strong>&gt;0.9.0&lt;/<strong class="kv iu">version</strong>&gt;<br/>&lt;/<strong class="kv iu">dependency</strong>&gt;</span></pre><h2 id="6391" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">步骤2:创建您的扩展点主类</h2><p id="884e" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">正如我们前面提到的，protoc将所有扩展都视为可执行程序，因此我们需要创建一个具有标准主入口点的Java类:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="e3bd" class="kz la it kv b gy lb lc l ld le"><strong class="kv iu">public class </strong>JProtoc <strong class="kv iu">extends </strong>com.salesforce.jprotoc.Generator {<br/><br/>    <strong class="kv iu">public static void </strong>main(String[] args) {<br/>        com.salesforce.jprotoc.ProtocPlugin.<em class="kp">generate</em>(<strong class="kv iu">new </strong>JProtoc());<br/>    }<br/>    ...<br/>}</span></pre><p id="40df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止够简单了。</p><p id="95dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来覆盖超级<em class="kp">生成</em>的方法:</p><h2 id="d99d" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">产生</h2><figure class="kq kr ks kt gt md"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="883b" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn np mq mr ms bi translated">我们正在返回一个文件对象流。这些代表由协议生成的文件</li><li id="c4d3" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">我们通过检查要生成的原型是否在要生成的文件列表中来过滤它。您将获得所有的原型文件，甚至是导入的文件，所以一定要过滤掉这些文件。(除非您想为它们生成代码)</li><li id="df27" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">然后我们调用另一个方法在<em class="kp"> handleProtoFile </em>中生成我们的代码</li></ul><h2 id="4d26" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">handleProtoFile</h2><figure class="kq kr ks kt gt md"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7096" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没什么特别的。请注意，java包可能来自两个不同的位置。要么隐式等于proto包，要么显式带有proto选项。</p><h2 id="ec96" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">handleMessageType</h2><figure class="kq kr ks kt gt md"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2128" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们要进入正题了。</p><p id="6f1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先构建我们将要添加代码的类的文件名。</p><p id="19fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在这里并不正确，因为我假设您使用的是多文件选项。如果没有这一点，所有的原型类和内部类都应该被区别对待。</p><p id="da7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们调用其他子方法来为我们插入的代码构建字符串。这没什么特别的，只是在小胡子模板中插入值。详情请查看完整代码。</p><p id="47f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里真正的问题是我们如何生成文件对象。</p><p id="fc76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意我们是如何设置文件名、想要插入的内容和<strong class="js iu">插入点的。</strong></p><p id="c642" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">插入点是注释中的一个特殊字符串，它出现在协议生成的代码中。有几个不同的插入点。我们使用的是<strong class="js iu"> builder_scope </strong>和<strong class="js iu"> class_scope </strong>插入点。</p><p id="a724" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="1af0" class="kz la it kv b gy lb lc l ld le"><em class="kp">// @@protoc_insertion_point(class_scope:com.efenglu.protobuf.EmployeeProto)</em></span></pre><h2 id="96b6" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">构建者_范围</strong></h2><p id="e896" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">在内部生成器类的末尾插入代码。这是我们想要添加我们的<em class="kp"> setOrClear </em>方法的地方。</p><h2 id="34d5" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak"> class_scope </strong></h2><p id="422a" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">在消息类型的java类的末尾插入代码。这是我们想要添加我们的<em class="kp"> optionalGet </em>方法的地方。</p><p id="95b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存在其他插入点。打开生成的proto文件，搜索<em class="kp">protocol _ insertion _ point</em>，看看有什么可用的。</p><h2 id="b730" class="kz la it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated">第三步:使用插件</h2><p id="f378" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">使用新插件非常容易。</p><p id="b2e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用maven proto Buffers插件配置Maven项目以构建Proto文件:</p><div class="ns nt gp gr nu nv"><a href="https://www.xolstice.org/protobuf-maven-plugin/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Maven协议缓冲插件-简介</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">Maven协议缓冲插件使用协议缓冲编译器(protoco)工具从。原型…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.xolstice.or</p></div></div></div></a></div><p id="9ead" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我们如何挂接新插件:</p><figure class="kq kr ks kt gt md"><div class="bz fp l di"><div class="nq nr l"/></div></figure><ul class=""><li id="30aa" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn np mq mr ms bi translated">os-maven-plugin:帮助我们为构建系统下载正确的协议二进制文件</li><li id="4547" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">protobuf-maven-plugin:挂接协议二进制文件和我们的自定义协议插件</li></ul><p id="4407" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意<em class="kp">protocol plugin</em>元素。这里我们已经连接了我们的协议插件。我们为插件指定maven工件，并在工件中指定可执行类。<a class="ae ko" href="https://www.xolstice.org/protobuf-maven-plugin/compile-mojo.html" rel="noopener ugc nofollow" target="_blank"> protobuf-maven-plugin </a>有很好的文档更详细地举例说明了它的用法。</p><p id="8ad2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样我们就有了新的自定义方法。</p><h1 id="5fa5" class="my la it bd lg mz na nb lj nc nd ne lm nf ng nh lp ni nj nk ls nl nm nn lv no bi translated">以巨大的力量…</h1><p id="3cf0" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">使用这种方法，您基本上可以将任何想要的东西添加到生成的原型代码中。但是在这样做之前，有几件事情需要考虑。</p><ul class=""><li id="0111" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn np mq mr ms bi translated">这只添加到您的代码中</li><li id="046d" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">这不是人们所期望的</li><li id="2514" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn np mq mr ms bi translated">你能用别的方法做它吗？</li></ul><p id="1127" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这有所帮助。使用protoc plugin框架还有几个其他的挑战，比如从proto文件中添加注释，处理、<em class="kp">映射</em>和<em class="kp">重复</em>类型、字段名称的冲突。但这应该能让你开始。</p><p id="81ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关本文引用的完整源代码，请查看Github repo:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/efenglu/jprotoc" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">埃丰卢/jprotoc</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">用Java编写的协议插件的示例用例。通过在…上创建一个帐户，为efenglu/jprotoc开发做出贡献</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj me nv"/></div></div></a></div></div></div>    
</body>
</html>