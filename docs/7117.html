<html>
<head>
<title>Monotonic Stack — Identify Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单调堆栈—识别模式</h1>
<blockquote>原文：<a href="https://itnext.io/monotonic-stack-identify-pattern-3da2d491a61e?source=collection_archive---------0-----------------------#2022-06-17">https://itnext.io/monotonic-stack-identify-pattern-3da2d491a61e?source=collection_archive---------0-----------------------#2022-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="165d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="7f17" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">单调堆栈是其元素单调递增或递减的堆栈。它包含了典型堆栈所具有的所有特性，并且其元素都是单调递减或递增的。</p><p id="871c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">以下是单调堆栈的特征:</p><ul class=""><li id="f20f" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">这是数组情况下的一系列查询</li><li id="c107" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">最小值/最大值元素</li><li id="8209" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">当一个元素从单调堆栈中弹出时，它将不再被使用。</li></ul><p id="1e6a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单调堆栈问题主要是<strong class="kn ir">上一个/下一个更小/更大的</strong>问题。当一个新的项目被推入堆栈时，它在弹出元素的同时保持单调性。</p><p id="c905" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单调堆栈如下所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/82808dc36de0493331047512da3b2604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEmUOmoLMcy1pCEV3JS5EQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图1:单调堆栈</figcaption></figure><p id="63f1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单调堆栈的基本伪代码:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ms"><img src="../Images/c08eca60ef6135ea51c10f11722d164d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5J5tA65f3HuN53YWpUCfmA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图2:单调堆栈</figcaption></figure><p id="1324" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单调堆栈的概念:</p><blockquote class="mt mu mv"><p id="5e58" class="kl km mw kn b ko lj kq kr ks lk ku kv mx ll ky kz my lm lc ld mz ln lg lh li ij bi translated">继续<strong class="kn ir">推动</strong>堆栈中的元素，直到它位于小于堆栈顶部的元素上，当它达到这样的数目时，它继续弹出堆栈，直到它或者是<strong class="kn ir">空</strong>或者是它的<strong class="kn ir">顶部</strong>小于它的当前元素。因此，堆栈中的所有元素都是从下到上递增的。</p></blockquote><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi na"><img src="../Images/a4165b9f0a9610f3097e0d3999ff2489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HC8mM4Kv66ms3iFevERzIg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图3:单调递增堆栈</figcaption></figure><p id="ab97" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">代码示例</strong></p><p id="0c7b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">将下面的数组转换成单调堆栈:</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="96cb" class="ng jo iq nc b gy nh ni l nj nk">nums = [2, 3, 7, 11, 5, 17, 19]</span></pre><p id="21b5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">解决方案:</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="cd7e" class="ng jo iq nc b gy nh ni l nj nk">def monotonicStack(nums):<br/>    n = len(nums)<br/>    stack = []<br/>    <br/>    for i in range(n):<br/>        while len(stack) &gt; 0 and stack[-1] &gt;= nums[i]:<br/>            stack.pop()<br/>        <br/>        stack.append(nums[i])<br/>    <br/>    return stack</span><span id="211f" class="ng jo iq nc b gy nl ni l nj nk">if __name__ == '__main__':<br/>    result = monotonicStack(nums)<br/>    print(result)</span></pre><p id="97ab" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">作为单调堆栈输出:</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="0311" class="ng jo iq nc b gy nh ni l nj nk">[2, 3, 5, 17, 19]</span></pre><h1 id="6756" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">函数的单调性</h1><p id="be5a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果一个函数在其整个定义域内递增或递减，则称之为单调函数。</p><p id="3161" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单调函数的真实示例:</p><ul class=""><li id="1cfc" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">生物的年龄是随时间单调递增的函数。而人生剩下的时间是时间上的单调递减函数。</li></ul><p id="b96d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">单调递增函数:</p><p id="02e3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果x1 &lt; x2 and f(x1) &lt; f(x2) then function is called as increasing function.</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d91c44256ee8a6f6d3968de1c7496ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*8VEWKXqRqep-xqPNccREJA.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Figure 3: Monotonically increasing functions</figcaption></figure><p id="57e9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">Monotonically decreasing functions:</p><p id="8a7f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">If x1 &lt; x2 and f(x1) &gt; f(x2)那么函数被称为递减函数。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b9ac44f0a23b9a036384fee1f3c8bbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*5Hgb2nHhHk5zGxSb9IoQPg.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">图4:单调递减函数</figcaption></figure><h1 id="11ef" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">单调堆栈相关问题及解决方案</h1><p id="58ea" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是与单调堆栈相关的问题列表。</p><h2 id="3094" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">下一个更大的元素</h2><p id="3069" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">获取每个数组元素的下一个更大的元素。</p><p id="2f1e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">示例:</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="508a" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input: </strong>nums = [2, 7, 3, 5, 4, 6, 8]<br/><strong class="nc ir">Output: </strong>[7, 8, 5, 6, 6, 8, -1]</span></pre><p id="584a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案:</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="1068" class="ng jo iq nc b gy nh ni l nj nk">def getNextGreaterElements(nums):<br/>    n = len(nums)<br/>    stack = []<br/>    result = [-1] * n<br/>    <br/>    for i in range(n):<br/>        while len(stack) &gt; 0 and nums[stack[-1]] &lt; nums[i]:<br/>            result[stack[-1]] = nums[i]<br/>            stack.pop()<br/>        <br/>        stack.append(i)<br/>    <br/>    return result<br/>            <br/>getNextGreaterElements(nums)</span></pre><h2 id="0c90" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">下一个更大的元素I</h2><p id="2599" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">数组中某个元素<code class="fe nz oa ob nc b">x</code>的<strong class="kn ir">下一个更大的元素</strong>是同一数组中<code class="fe nz oa ob nc b">x</code>右边<strong class="kn ir">的<strong class="kn ir">第一个更大的元素</strong>。</strong></p><p id="d71f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">给你两个<strong class="kn ir">不同的0索引</strong>整数数组<code class="fe nz oa ob nc b">nums1</code>和<code class="fe nz oa ob nc b">nums2</code>，其中<code class="fe nz oa ob nc b">nums1</code>是<code class="fe nz oa ob nc b">nums2</code>的子集。</p><p id="20a1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">对于每个<code class="fe nz oa ob nc b">0 &lt;= i &lt; nums1.length</code>，找到索引<code class="fe nz oa ob nc b">j</code>使得<code class="fe nz oa ob nc b">nums1[i] == nums2[j]</code>，并确定<code class="fe nz oa ob nc b">nums2</code>中<code class="fe nz oa ob nc b">nums2[j]</code>的下一个更大元素的<strong class="kn ir">。如果没有下一个更大的元素，那么这个查询的答案是<code class="fe nz oa ob nc b">-1</code>。</strong></p><p id="060a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回长度为 <code class="fe nz oa ob nc b">nums1.length</code> <em class="mw">的<em class="mw">数组</em> <code class="fe nz oa ob nc b">ans</code> <em class="mw">，使得</em> <code class="fe nz oa ob nc b">ans[i]</code> <em class="mw">是如上所述的</em> <strong class="kn ir"> <em class="mw">下一个更大的元素</em> </strong> <em class="mw">。</em></em></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="a9da" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> nums1 = [4,1,2], nums2 = [1,3,4,2]<br/><strong class="nc ir">Output:</strong> [-1,3,-1]</span><span id="a25f" class="ng jo iq nc b gy nl ni l nj nk"><strong class="nc ir">Explanation:</strong> The next greater element for each value of nums1 is as follows:<br/>- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.<br/>- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.<br/>- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.</span></pre><p id="d499" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="f660" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def nextGreaterElement(self, nums1, nums2):<br/>        """<br/>        :type nums1: List[int]<br/>        :type nums2: List[int]<br/>        :rtype: List[int]<br/>        """<br/>        stack = []<br/>        d = {}<br/>        <br/>        for i in range(len(nums2)):<br/>            d[nums2[i]] = -1<br/>            <br/>        for i in range(len(nums2)):<br/>            while len(stack) &gt; 0 and nums2[i] &gt; stack[-1]:<br/>                item = stack.pop()<br/>                d[item] = nums2[i]<br/>                <br/>            stack.append(nums2[i])<br/>            <br/>        for i in range(len(nums1)):<br/>            nums1[i] = d[nums1[i]]<br/>        <br/>        return nums1</span></pre><h2 id="3f9d" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">下一个更大的元素II</h2><p id="f30a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个循环整数数组<code class="fe nz oa ob nc b">nums</code>(即<code class="fe nz oa ob nc b">nums[nums.length - 1]</code>的下一个元素是<code class="fe nz oa ob nc b">nums[0]</code>)，为 <code class="fe nz oa ob nc b">nums</code>中的每个元素返回<em class="mw"/><strong class="kn ir"><em class="mw">下一个更大的数字</em> </strong> <em class="mw">。</em></p><p id="5b7c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">数字<code class="fe nz oa ob nc b">x</code>的<strong class="kn ir">下一个更大的数字</strong>是数组中下一个遍历顺序的第一个更大的数字，这意味着您可以循环搜索以找到它的下一个更大的数字。如果不存在，返回<code class="fe nz oa ob nc b">-1</code>这个数。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="2afa" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> nums = [1,2,1]<br/><strong class="nc ir">Output:</strong> [2,-1,2]</span><span id="2f01" class="ng jo iq nc b gy nl ni l nj nk"><strong class="nc ir">Explanation</strong>: The first 1's next greater number is 2; <br/>The number 2 can't find next greater number. <br/>The second 1's next greater number needs to search circularly, which is also 2.</span></pre><p id="77d2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="2694" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def nextGreaterElements(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: List[int]<br/>        """<br/>        n = len(nums)<br/>        stack = []<br/>        result = [-1] * n<br/>        <br/>        for i in range(2*n-1):<br/>            index = i % n<br/>            <br/>            while stack and stack[-1][1] &lt; nums[index]:<br/>                resIndex, _ = stack.pop()<br/>                result[resIndex] = nums[index]<br/>            <br/>            stack.append([index, nums[index]])<br/>        <br/>        return result</span></pre><h2 id="20cc" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">使数组非递减的步骤</h2><p id="dcc1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个<strong class="kn ir"> 0索引的</strong>整数数组<code class="fe nz oa ob nc b">nums</code>。在一个步骤中，<strong class="kn ir">移除</strong>所有元件<code class="fe nz oa ob nc b">nums[i]</code>，其中<code class="fe nz oa ob nc b">nums[i - 1] &gt; nums[i]</code>用于所有<code class="fe nz oa ob nc b">0 &lt; i &lt; nums.length</code>。</p><p id="de36" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="mw">执行的步数，直到</em> <code class="fe nz oa ob nc b">nums</code> <em class="mw">变成</em> <strong class="kn ir"> <em class="mw">非递减</em> </strong> <em class="mw">数组</em>。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="1321" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]<br/><strong class="nc ir">Output:</strong> 3</span><span id="86ec" class="ng jo iq nc b gy nl ni l nj nk"><strong class="nc ir">Explanation:</strong> The following are the steps performed:<br/>- Step 1: [5,<strong class="nc ir">3</strong>,4,4,7,<strong class="nc ir">3</strong>,6,11,<strong class="nc ir">8</strong>,<strong class="nc ir">5</strong>,11] becomes [5,4,4,7,6,11,11]<br/>- Step 2: [5,<strong class="nc ir">4</strong>,4,7,<strong class="nc ir">6</strong>,11,11] becomes [5,4,7,11,11]<br/>- Step 3: [5,<strong class="nc ir">4</strong>,7,11,11] becomes [5,7,11,11]<br/>[5,7,11,11] is a non-decreasing array. Therefore, we return 3.</span></pre><p id="975b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="315c" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def totalSteps(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        n = len(nums)<br/>        dp = [0] * n<br/>        res = 0<br/>        stack = []<br/>    <br/>        for i in range(n-1, -1, -1):<br/>            while stack and nums[i] &gt; nums[stack[-1]]:<br/>                dp[i] = max(dp[i] + 1, dp[stack.pop()])<br/>                res = max(res, dp[i])<br/>            stack.append(i)<br/>            <br/>        return res</span></pre><h2 id="b5b1" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">收集雨水</h2><p id="57d1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定代表高程图的非负整数<code class="fe nz oa ob nc b">n</code>，其中每个条形的宽度为<code class="fe nz oa ob nc b">1</code>，计算雨后它可以收集多少水。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="11c7" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]<br/><strong class="nc ir">Output:</strong> 6<br/><strong class="nc ir">Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span></pre><p id="a5de" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="e413" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def trap(self, height):<br/>        """<br/>        :type height: List[int]<br/>        :rtype: int<br/>        """<br/>        stack = []<br/>        total = 0<br/>        <br/>        for i in range(len(height)):<br/>            while len(stack) &gt; 0 and height[stack[-1]] &lt; height[i]:<br/>                poppedIdx = stack.pop()<br/>                <br/>                if len(stack) == 0:<br/>                    break<br/>                    <br/>                heightVal = min(height[stack[-1]], height[i]) - height[poppedIdx]<br/>                length = i - stack[-1] - 1<br/>                total += heightVal * length<br/>            <br/>            stack.append(i)<br/>        <br/>        return total</span></pre><h2 id="d827" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">直方图中最大的矩形</h2><p id="eaf4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe nz oa ob nc b">heights</code>表示直方图的条形高度，其中每个条形的宽度为<code class="fe nz oa ob nc b">1</code>，返回<em class="mw">直方图中最大矩形的面积</em>。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="bad6" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> heights = [2,1,5,6,2,3]<br/><strong class="nc ir">Output:</strong> 10<br/><strong class="nc ir">Explanation:</strong> The above is a histogram where width of each bar is 1.<br/>The largest rectangle is shown in the red area, which has an area = 10 units.</span></pre><p id="1819" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="f9ec" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def largestRectangleArea(self, heights):<br/>        """<br/>        :type heights: List[int]<br/>        :rtype: int<br/>        """<br/>        maxArea = 0<br/>        stack = []<br/>        start = 0<br/>        <br/>        for i, h in enumerate(heights):<br/>            start = i<br/>            <br/>            while stack and stack[-1][1] &gt; h:<br/>                index, height = stack.pop()<br/>                maxArea = max(maxArea, height * (i - index))<br/>                start = index<br/>            <br/>            stack.append((start, h))<br/>        <br/>        for i, h in stack:<br/>            maxArea = max(maxArea, h * (len(heights) -i))<br/>            <br/>        return maxArea</span></pre><h2 id="fbbd" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">删除重复的字母</h2><p id="cfdf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个字符串<code class="fe nz oa ob nc b">s</code>，去掉重复的字母，使每个字母出现一次，并且只出现一次。你必须确保你的结果是所有可能结果中按字典顺序最小的。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="e161" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> s = "bcabc"<br/><strong class="nc ir">Output:</strong> "abc"</span></pre><p id="8d8c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="ea91" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def removeDuplicateLetters(self, s):<br/>        """<br/>        :type s: str<br/>        :rtype: str<br/>        """<br/>        d = {char: indx for indx, char in enumerate(s)}<br/>        <br/>        res = []<br/>        <br/>        for indx, char in enumerate(s):<br/>            if char not in res:<br/>                <br/>                while res and indx &lt; d[res[-1]] and char &lt; res[-1]:<br/>                    res.pop()<br/>                    <br/>                res.append(char)<br/>        <br/>        return "".join(res)</span></pre><h2 id="721c" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">删除K位数字</h2><p id="c405" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定代表非负整数<code class="fe nz oa ob nc b">num</code>和整数<code class="fe nz oa ob nc b">k</code>的字符串num，返回从 <code class="fe nz oa ob nc b">num</code>中移除 <code class="fe nz oa ob nc b">k</code> <em class="mw">位后的最小可能整数<em class="mw">。</em></em></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="7816" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> num = "1432219", k = 3<br/><strong class="nc ir">Output:</strong> "1219"<br/><strong class="nc ir">Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</span></pre><p id="6646" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="ab72" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def removeKdigits(self, num, k):<br/>        """<br/>        :type num: str<br/>        :type k: int<br/>        :rtype: str<br/>        """<br/>        num=list(num)<br/>        stack,i=[num[0]],1<br/>        <br/>        while i&lt;len(num):<br/>            while stack and k&gt;0 and num[i]&lt;stack[-1]:<br/>                stack.pop()<br/>                k-=1<br/>                <br/>            stack.append(num[i])<br/>            i+=1<br/>            <br/>        while k&gt;0:<br/>            stack.pop()<br/>            k-=1<br/>        stack="".join(stack)<br/>        return stack.lstrip("0") if stack!="" and int(stack)!=0 else "0"</span></pre><h2 id="c1a0" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">132模式</h2><p id="54ab" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个<code class="fe nz oa ob nc b">n</code>整数<code class="fe nz oa ob nc b">nums</code>的数组，一个<strong class="kn ir"> 132模式</strong>是三个整数<code class="fe nz oa ob nc b">nums[i]</code>、<code class="fe nz oa ob nc b">nums[j]</code>和<code class="fe nz oa ob nc b">nums[k]</code>的子序列，使得<code class="fe nz oa ob nc b">i &lt; j &lt; k</code>和<code class="fe nz oa ob nc b">nums[i] &lt; nums[k] &lt; nums[j]</code>。</p><p id="83e0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<code class="fe nz oa ob nc b">true</code> <em class="mw">如果</em> <code class="fe nz oa ob nc b">nums</code> <em class="mw">中有</em><strong class="kn ir"><em class="mw"/></strong><em class="mw">，否则返回</em> <code class="fe nz oa ob nc b">false</code> <em class="mw">。</em></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="0d27" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> nums = [1,2,3,4]<br/><strong class="nc ir">Output:</strong> false<br/><strong class="nc ir">Explanation:</strong> There is no 132 pattern in the sequence.</span></pre><p id="612f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="c910" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def find132pattern(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: bool<br/>        """<br/>        if len(nums) &lt; 3:<br/>            return False<br/>        <br/>        right = float("-inf")<br/>        stack = []<br/>        <br/>        for i in range(len(nums)-1, -1, -1):<br/>            if nums[i] &lt; right:<br/>                return True<br/>            else:<br/>                while stack and stack[-1] &lt; nums[i]:<br/>                    right = stack.pop()<br/>            <br/>            stack.append(nums[i])<br/>        <br/>        return False</span></pre><h2 id="e703" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">每日气温</h2><p id="f36e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe nz oa ob nc b">temperatures</code>代表每天的温度，返回一个数组<em class="mw"/><code class="fe nz oa ob nc b">answer</code><em class="mw">，这样</em> <code class="fe nz oa ob nc b">answer[i]</code> <em class="mw">就是在</em> <code class="fe nz oa ob nc b">ith</code> <em class="mw">天之后你必须等待的天数，以获得更温暖的温度</em>。如果没有未来的某一天这是可能的，保留<code class="fe nz oa ob nc b">answer[i] == 0</code>代替。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="2fbf" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> temperatures = [73,74,75,71,69,72,76,73]<br/><strong class="nc ir">Output:</strong> [1,1,4,2,1,1,0,0]</span></pre><p id="0236" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="8165" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def dailyTemperatures(self, temperatures):<br/>        """<br/>        :type temperatures: List[int]<br/>        :rtype: List[int]<br/>        """<br/>        # Monotonic Stack<br/>        n = len(temperatures)<br/>        stack = []<br/>        result = [0] * n<br/>        <br/>        for i in range(n-1, -1, -1):<br/>            while stack and temperatures[i] &gt;= stack[-1][0]:<br/>                stack.pop(-1)<br/>            <br/>            if len(stack) == 0:<br/>                result[i] = 0<br/>            else:<br/>                result[i] = stack[-1][1] - i<br/>            <br/>            stack.append((temperatures[i], i))<br/>            <br/>        return result</span></pre><h2 id="32ab" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">在线股票跨度</h2><p id="b30d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">设计一个算法，收集一些股票的每日报价，并返回该股票当天价格的跨度。</p><p id="a0fd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">股票今天价格的<strong class="kn ir">跨度</strong>定义为股票价格小于或等于今天价格的最大连续天数(从今天开始向后)。</p><ul class=""><li id="a5a0" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated">例如，如果一只股票在接下来的<code class="fe nz oa ob nc b">7</code>天的价格是<code class="fe nz oa ob nc b">[100,80,60,70,60,75,85]</code>，那么这只股票的跨度就是<code class="fe nz oa ob nc b">[1,1,1,2,1,4,6]</code>。</li></ul><p id="0f2a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">实现<code class="fe nz oa ob nc b">StockSpanner</code>类:</p><ul class=""><li id="eaed" class="lo lp iq kn b ko lj ks lk kw lq la lr le ls li lt lu lv lw bi translated"><code class="fe nz oa ob nc b">StockSpanner()</code>初始化类的对象。</li><li id="9ef5" class="lo lp iq kn b ko lx ks ly kw lz la ma le mb li lt lu lv lw bi translated">假定今天的价格为<code class="fe nz oa ob nc b">price</code>，则<code class="fe nz oa ob nc b">int next(int price)</code>返回股票价格的<strong class="kn ir">跨度</strong>。</li></ul><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="5a31" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input</strong><br/>["StockSpanner", "next", "next", "next", "next", "next", "next", "next"]<br/>[[], [100], [80], [60], [70], [60], [75], [85]]<br/><strong class="nc ir">Output</strong><br/>[null, 1, 1, 1, 2, 1, 4, 6]</span></pre><p id="348e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="3608" class="ng jo iq nc b gy nh ni l nj nk">class StockSpanner(object):</span><span id="50ce" class="ng jo iq nc b gy nl ni l nj nk">def __init__(self):<br/>        self.stack = []</span><span id="6c56" class="ng jo iq nc b gy nl ni l nj nk">def next(self, price):<br/>        """<br/>        :type price: int<br/>        :rtype: int<br/>        """<br/>        span = 1<br/>        <br/>        if len(self.stack) == 0:<br/>            self.stack.append([price, span])<br/>            return 1<br/>        <br/>        while self.stack and self.stack[-1][0] &lt;= price:<br/>            span += self.stack[-1][1]<br/>            self.stack.pop()<br/>        <br/>        self.stack.append([price, span])<br/>        <br/>        return span</span><span id="df08" class="ng jo iq nc b gy nl ni l nj nk"># Your StockSpanner object will be instantiated and called as such:<br/># obj = StockSpanner()<br/># param_1 = obj.next(price)</span></pre><h2 id="a50c" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">子阵列最小值之和</h2><p id="78ae" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组arr，求<code class="fe nz oa ob nc b">min(b)</code>的和，其中<code class="fe nz oa ob nc b">b</code>覆盖<code class="fe nz oa ob nc b">arr</code>的每个(相邻)子数组。由于答案可能较大，返回答案<strong class="kn ir">模</strong>T5】。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="6d28" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> arr = [3,1,2,4]<br/><strong class="nc ir">Output:</strong> 17<br/><strong class="nc ir">Explanation:</strong> <br/>Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. <br/>Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.<br/>Sum is 17.</span></pre><p id="30e7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="08c6" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def sumSubarrayMins(self, arr):<br/>        """<br/>        :type arr: List[int]<br/>        :rtype: int<br/>        """<br/>        su = 0<br/>        n = len(arr)<br/>        arr.append(0)<br/>        stack = [-1]<br/>        <br/>        for i, num in enumerate(arr):<br/>            while stack and arr[stack[-1]] &gt; num: # (i)<br/>                idx = stack.pop()<br/>                su += arr[idx] * (i - idx) * (idx - stack[-1])<br/>                <br/>            stack.append(i)<br/>            <br/>        return su % (10**9 + 7)</span></pre><h2 id="951d" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">不同字符的最小子序列</h2><p id="befc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个字符串<code class="fe nz oa ob nc b">s</code>，返回 <code class="fe nz oa ob nc b">s</code> <em class="mw">的字典序最小的子序列<em class="mw">，该子序列包含</em> <code class="fe nz oa ob nc b">s</code> <em class="mw">的所有不同字符</em>。</em></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="cfd4" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> s = "bcabc"<br/><strong class="nc ir">Output:</strong> "abc"</span></pre><p id="1d52" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="ba75" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def smallestSubsequence(self, s):<br/>        """<br/>        :type s: str<br/>        :rtype: str<br/>        """<br/>        stack = []<br/>        d = {}<br/>        <br/>        for i in range(len(s)):<br/>            d[s[i]] = i<br/>            <br/>        for i in range(len(s)):<br/>            if s[i] not in stack:<br/>                while stack and i &lt; d[stack[-1]] and ord(s[i]) &lt; ord(stack[-1]):<br/>                    stack.pop()<br/>            <br/>                stack.append(s[i])<br/>    <br/>        return (''.join(stack))</span></pre><h2 id="ce83" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">商店中有特别折扣的最终价格</h2><p id="fed7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定数组<code class="fe nz oa ob nc b">prices</code>，其中<code class="fe nz oa ob nc b">prices[i]</code>是商店中<code class="fe nz oa ob nc b">ith</code>商品的价格。商店中的物品有特别折扣，如果您购买了<code class="fe nz oa ob nc b">ith</code>物品，那么您将获得相当于<code class="fe nz oa ob nc b">prices[j]</code>的折扣，其中<code class="fe nz oa ob nc b">j</code>是<strong class="kn ir">最小</strong>指数，如<code class="fe nz oa ob nc b">j &gt; i</code>和<code class="fe nz oa ob nc b">prices[j] &lt;= prices[i]</code>，否则您将得不到任何折扣。</p><p id="9ebe" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="mw">返回一个数组，其中</em> <code class="fe nz oa ob nc b"><em class="mw">ith</em></code> <em class="mw">元素是考虑到特殊折扣，你将为商店的</em> <code class="fe nz oa ob nc b"><em class="mw">ith</em></code> <em class="mw">商品支付的最终价格。</em></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="3324" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> prices = [8,4,6,2,3]<br/><strong class="nc ir">Output:</strong> [4,2,4,2,3]<br/><strong class="nc ir">Explanation:</strong> <br/>For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. <br/>For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. <br/>For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. <br/>For items 3 and 4 you will not receive any discount at all.</span></pre><p id="3efa" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="359e" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def finalPrices(self, prices):<br/>        """<br/>        :type prices: List[int]<br/>        :rtype: List[int]<br/>        """<br/>        stack = []<br/>        l = len(prices)<br/>        <br/>        for i in range(0, l):<br/>            while stack and prices[stack[-1]] &gt;= prices[i]:<br/>                p = stack.pop()<br/>                prices[p] -= prices[i]<br/>                <br/>            stack.append(i)<br/>        <br/>        return prices</span></pre><h2 id="dab9" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">使数组非递减的步骤</h2><p id="f782" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给你一个<strong class="kn ir"> 0索引的</strong>整数数组<code class="fe nz oa ob nc b">nums</code>。一步，<strong class="kn ir">移除</strong>所有元件<code class="fe nz oa ob nc b">nums[i]</code>其中<code class="fe nz oa ob nc b">nums[i - 1] &gt; nums[i]</code>为所有<code class="fe nz oa ob nc b">0 &lt; i &lt; nums.length</code>。</p><p id="6269" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回<em class="mw">执行的步数，直到</em> <code class="fe nz oa ob nc b">nums</code> <em class="mw">变成</em> <strong class="kn ir"> <em class="mw">非递减</em> </strong> <em class="mw">数组</em>。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="58f3" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]<br/><strong class="nc ir">Output:</strong> 3<br/><strong class="nc ir">Explanation:</strong> The following are the steps performed:<br/>- Step 1: [5,<strong class="nc ir">3</strong>,4,4,7,<strong class="nc ir">3</strong>,6,11,<strong class="nc ir">8</strong>,<strong class="nc ir">5</strong>,11] becomes [5,4,4,7,6,11,11]<br/>- Step 2: [5,<strong class="nc ir">4</strong>,4,7,<strong class="nc ir">6</strong>,11,11] becomes [5,4,7,11,11]<br/>- Step 3: [5,<strong class="nc ir">4</strong>,7,11,11] becomes [5,7,11,11]<br/>[5,7,11,11] is a non-decreasing array. Therefore, we return 3.</span></pre><p id="abf5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="9fa5" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def totalSteps(self, nums):<br/>        """<br/>        :type nums: List[int]<br/>        :rtype: int<br/>        """<br/>        n = len(nums)<br/>        dp = [0] * n<br/>        res = 0<br/>        stack = []<br/>    <br/>        for i in range(n-1, -1, -1):<br/>            while stack and nums[i] &gt; nums[stack[-1]]:<br/>                dp[i] = max(dp[i] + 1, dp[stack.pop()])<br/>                res = max(res, dp[i])<br/>            stack.append(i)<br/>            <br/>        return res</span></pre><h2 id="0e9a" class="ng jo iq bd jp no np dn jt nq nr dp jx kw ns nt kb la nu nv kf le nw nx kj ny bi translated">要排序的最大块</h2><p id="6404" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个长度为<code class="fe nz oa ob nc b">n</code>的整数数组<code class="fe nz oa ob nc b">arr</code>，它表示范围<code class="fe nz oa ob nc b">[0, n - 1]</code>中整数的排列。</p><p id="a0f8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们将<code class="fe nz oa ob nc b">arr</code>分成一定数量的<strong class="kn ir">块</strong>(即分区)，并单独对每个块进行排序。将它们连接起来后，结果应该等于排序后的数组。</p><p id="db38" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">返回我们可以对数组进行排序的最大块数。</p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="3433" class="ng jo iq nc b gy nh ni l nj nk"><strong class="nc ir">Input:</strong> arr = [4,3,2,1,0]<br/><strong class="nc ir">Output:</strong> 1<br/><strong class="nc ir">Explanation:</strong><br/>Splitting into two or more chunks will not return the required result.<br/>For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.</span></pre><p id="d364" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">解决方案</strong></p><pre class="md me mf mg gt nb nc nd ne aw nf bi"><span id="1355" class="ng jo iq nc b gy nh ni l nj nk">class Solution(object):<br/>    def maxChunksToSorted(self, arr):<br/>        """<br/>        :type arr: List[int]<br/>        :rtype: int<br/>        """<br/>        stack=[]<br/>        stack.append(arr[0])<br/>        top=1<br/>        largest=0<br/>        <br/>        for i in range(1,len(arr)): #scan left to right from 1 to l-1<br/>            if(arr[i]&gt;stack[top-1]): # if element on top of stack &lt; arr[i] push element in stack and increment top of stack as well <br/>                stack.append(arr[i])<br/>                top+=1</span><span id="4fb1" class="ng jo iq nc b gy nl ni l nj nk">else:<br/>                while((top)&gt;0 and arr[i]&lt;stack[top-1]): #if top of stack &gt; arr[i], run loop till stack &gt;arr[i]<br/>                    if(stack[top-1]&gt;largest): #keeping track of largest element we pop so we can replace pop elements with single largest element<br/>                        largest=stack[top-1]<br/>                    stack.pop() #poping element from stack while stack[top-1]&gt;arr[i] and top&gt;0<br/>                    top-=1<br/>                stack.append(largest) #pushing largest element in stack<br/>                top+=1<br/>        return len(stack)</span></pre><h1 id="41c1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂度</h1><p id="b6e9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">单调的基于堆栈的解决方案的时间复杂度是<strong class="kn ir"> O(n) </strong>，因为while循环只是一个接一个地弹出堆栈元素，并且由于每个元素都被推入一次，所以推入堆栈的元素不能超过n个。因此嵌套的while循环也不会执行超过n次。内部循环在覆盖n个元素之前不会被视为嵌套循环。</p><h1 id="4fd1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="d7b3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">单调堆栈是一种特殊形式的堆栈，其中所有项目都按升序或降序排序</p></div></div>    
</body>
</html>