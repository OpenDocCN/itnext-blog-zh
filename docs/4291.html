<html>
<head>
<title>Custom Decorators in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">棱角分明的定制装饰</h1>
<blockquote>原文：<a href="https://itnext.io/custom-decorators-in-angular-c54da873b3b3?source=collection_archive---------0-----------------------#2020-06-01">https://itnext.io/custom-decorators-in-angular-c54da873b3b3?source=collection_archive---------0-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/d7618681dcf5f5555a2394537dbafa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*fdkW7Ao1GUnwLx-8A4Ew-g.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">释放原力！</figcaption></figure><p id="a661" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你多久遇到一次类似的情况？</p><ul class=""><li id="c928" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">通过<code class="fe li lj lk ll b">ngOnchanges</code>跟踪组件属性变化。</li><li id="4574" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">调用<code class="fe li lj lk ll b">unsubscribe</code>避免内存泄漏。</li><li id="4753" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">角度区域之外的复杂计算。</li><li id="2805" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">处理和记录错误。</li><li id="86a7" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">使用<em class="lr">存储API。</em></li></ul><p id="3767" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例行的动作，不时地重复，导致代码的重复，并随着项目的增长留下<em class="lr">臭味</em>的苦涩余味。</p><p id="e06e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将通过我们团队在Angular中使用decorators的成果为例来强调上述问题的解决方案。让我们更详细地看看它们。</p><h1 id="9d3b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">跟踪更改</h1><p id="f810" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">我敢肯定，在开发哑组件的过程中，当您需要对输入属性的变化做出反应时，您会反复遇到这种情况。所以这个看似普通的动作会导致过多的代码重复，同时污染和膨胀<code class="fe li lj lk ll b">ngOnChanges</code>钩子。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="7e9e" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent implements OnChanges {<br/>    @Input() value1: string;<br/>    @Input() value2: string;</span><span id="6ccc" class="nd lt it ll b gy ni nf l ng nh">    ngOnChanges(changes: SimpleChanges): void {<br/>        if(changes['value1'] &amp;&amp; changes['value1'].currentValue) {<br/>            this.makeChangesVal1(changes['value1'].currentValue);<br/>        }<br/>        if(changes['value2'] &amp;&amp; changes['value2'].currentValue) {<br/>           this.makeChangesVal2(changes['value2'].currentValue); <br/>        } <br/>    }<br/>}</span></pre><p id="5a29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免这种情况，将使用我们的自定义装饰器标记<code class="fe li lj lk ll b">ngOnChanges</code> hook，并向其传递必要的参数。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="dd91" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent implements OnChanges {<br/>    @Input() value1: string;<br/>    @Input() value2: string;</span><span id="3872" class="nd lt it ll b gy ni nf l ng nh">    @TrackChanges&lt;string&gt;('value1', 'makeChangesVal1')<br/>    @TrackChanges&lt;string&gt;('value2', 'makeChangesVal2', ChangesStrategy.<em class="lr">First</em>)<br/>    ngOnChanges(changes: SimpleChanges): void {}<br/>}</span></pre><p id="419b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个想法是将条件放入装饰器中，使代码更容易阅读。同时，我们可以通过指定<code class="fe li lj lk ll b">strategy</code>参数来增加确定我们应该如何准确跟踪变更的能力。</p><p id="754c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们更详细地考虑一下。有以下输入参数:</p><ul class=""><li id="dabf" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><em class="lr"> key: string </em> —跟踪属性的名称</li><li id="719d" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><em class="lr"> methodName: string </em> —将对指定属性的更改做出反应的方法的名称</li><li id="9676" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><em class="lr">策略:变化策略</em> —确定我们是否对所有变化做出反应(可能的值为每个、第一、非第一)</li></ul><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="df31" class="nd lt it ll b gy ne nf l ng nh">export function TrackChanges&lt;Type&gt;(key: string, methodName: string, strategy: ChangesStrategy = ChangesStrategy.<em class="lr">Each</em>): Function {<br/>  return function(targetClass, functionName: string, descriptor): Function {<br/>    const source = descriptor.value;</span><span id="d6f4" class="nd lt it ll b gy ni nf l ng nh">    descriptor.value = function(changes: SimpleChanges): Function {</span><span id="7b63" class="nd lt it ll b gy ni nf l ng nh">      if (changes &amp;&amp; changes[key] &amp;&amp; changes[key].currentValue !== undefined) {<br/>        const isFirstChange = changes[key].firstChange;</span><span id="3045" class="nd lt it ll b gy ni nf l ng nh">        if (strategy === ChangesStrategy.<em class="lr">Each </em>||<br/>           (strategy === ChangesStrategy.<em class="lr">First </em>&amp;&amp; isFirstChange) ||<br/>           (strategy === ChangesStrategy.<em class="lr">NonFirst </em>&amp;&amp; !isFirstChange)) {<br/>          targetClass[methodName].call(this, changes[key].currentValue as Type);<br/>        }<br/>      }</span><span id="c5a1" class="nd lt it ll b gy ni nf l ng nh">      return source.call(this, changes);<br/>    };</span><span id="d92c" class="nd lt it ll b gy ni nf l ng nh">    return descriptor;<br/>  };<br/>}</span></pre><p id="1839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nj" href="https://stackblitz.com/edit/angular-ivy-changes-decorator?embed=1&amp;file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lr">查看斯塔克布里茨</em> </a></p><h1 id="2e05" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">外部计算</h1><p id="6985" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">如你所知，有几个事件触发了变化检测机制:</p><ul class=""><li id="e12e" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">所有浏览器事件(点击、鼠标悬停、击键等。)</li><li id="a90c" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated"><code class="fe li lj lk ll b">setTimeout()</code>和<code class="fe li lj lk ll b">setInterval()</code></li><li id="a50d" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">Ajax请求</li></ul><blockquote class="nk"><p id="90ac" class="nl nm it bd nn no np nq nr ns nt ky dk translated">每次事件发生时，NgZone都会通知Angular，从而触发新的变化检测周期</p></blockquote><p id="01d1" class="pw-post-body-paragraph kb kc it kd b ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky im bi translated">例如，您想通过使用<em class="lr"> scrollTo </em>滚动到指定坐标来突出显示一个块。您可以使用<code class="fe li lj lk ll b">runOutsideAngular</code>来触发角度区域之外的事件，从而优化变化检测。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="3918" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent {</span><span id="a6ae" class="nd lt it ll b gy ni nf l ng nh">    constructor(private ngZone: NgZone) {<br/>        this.drawChart();<br/>    }</span><span id="41b1" class="nd lt it ll b gy ni nf l ng nh">    highlightBlock(top = 100): void {<br/>        this.zone.runOutsideAngular(() =&gt; {<br/>            <strong class="ll iu"><em class="lr">window</em></strong>.scrollTo({<br/>                behavior: 'smooth',<br/>                top<br/>            });<br/>        });<br/>    }</span><span id="57cf" class="nd lt it ll b gy ni nf l ng nh">    drawChart(): void {<br/>        this.zone.runOutsideAngular(() =&gt; {<br/>            // drawing logic<br/>        });<br/>    }<br/>}</span></pre><p id="2b13" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种方法是使用装饰器，使代码更干净，更具声明性。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="7836" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent {</span><span id="5df8" class="nd lt it ll b gy ni nf l ng nh">    constructor(private ngZone: NgZone) {<br/>        this.drawChart();<br/>    }</span><span id="0fe4" class="nd lt it ll b gy ni nf l ng nh">    @OutsideZone<br/>    highlightBlock(top = 100): void {<br/>        <strong class="ll iu"><em class="lr">window</em></strong>.scrollTo({<br/>            behavior: 'smooth',<br/>            top<br/>        });<br/>    }</span><span id="443e" class="nd lt it ll b gy ni nf l ng nh">    @OutsideZone<br/>    drawChart(): void {<br/>        // drawing logic<br/>    }<br/>}</span></pre><p id="7a67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的项目中，我们正在处理足够数量的各种图形和地图，试图将所有不需要更新UI的计算放在角度区域之外，从而提高性能。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="f612" class="nd lt it ll b gy ne nf l ng nh">export function OutsideZone(targetClass, functionName: string, descriptor) {</span><span id="d26e" class="nd lt it ll b gy ni nf l ng nh">  const source = descriptor.value;</span><span id="64cb" class="nd lt it ll b gy ni nf l ng nh">  descriptor.value = function(...data): Function {</span><span id="86ba" class="nd lt it ll b gy ni nf l ng nh">    if (!this.ngZone) {<br/>            throw new Error("Class with 'OutsideZone' decorator should have 'ngZone' class property with 'NgZone' class.");<br/>        }</span><span id="3ed5" class="nd lt it ll b gy ni nf l ng nh">    return this.ngZone.runOutsideAngular(() =&gt; source.call(this,  ...data));</span><span id="d201" class="nd lt it ll b gy ni nf l ng nh">  };</span><span id="c1f5" class="nd lt it ll b gy ni nf l ng nh">  return descriptor;</span><span id="5a38" class="nd lt it ll b gy ni nf l ng nh">}</span></pre><p id="d8b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值得注意的是，该实现包括检查<em class="lr"> ngZone </em>的存在。换句话说，要使用这个装饰器，需要注入<code class="fe li lj lk ll b">NgZone</code>。</p><blockquote class="nk"><p id="0a3e" class="nl nm it bd nn no nz oa ob oc od ky dk translated">我们不能将实例变量作为参数传递给decorator，因为decorator是在声明类时调用的，而此时我们没有可以传递的实例。</p></blockquote><p id="e346" class="pw-post-body-paragraph kb kc it kd b ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky im bi translated"><a class="ae nj" href="https://stackblitz.com/edit/angular-ivy-outside-zone-decorator?embed=1&amp;file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lr">堆栈视图</em> </a></p><h1 id="ecfd" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">访问存储API</h1><p id="1885" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">有时我们必须处理<em class="lr"> Web存储API </em>。这可以用不同的方式来组织:有人直接从他们需要获取值的同一个地方访问<em class="lr">存储API </em>，有人使用各种抽象然后调用它们，等等。无论如何，这需要太多额外的代码。让我们看看装饰方法。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="2721" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent {</span><span id="8374" class="nd lt it ll b gy ni nf l ng nh">    @Storage&lt;number&gt;('pagination_size', StorageType.<em class="lr">Local</em>, <strong class="ll iu"><em class="lr">20</em></strong>)<br/>    currentItemsPerPage: number;<br/>}</span></pre><p id="ae63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个属性装饰器。这里我们处理的是<code class="fe li lj lk ll b"><a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">defineProperty</a></code>方法和修改<code class="fe li lj lk ll b">decriptor</code>的能力。通过定义我们的访问器属性，我们获得了更多的灵活性和对真实属性值的控制，然后我们引入了获取/设置值的所有必要逻辑。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="470b" class="nd lt it ll b gy ne nf l ng nh">export function Storage&lt;Type&gt;(key: string, storageType: StorageType = StorageType.<em class="lr">Local</em>, defaultValue: Type = null): Function {<br/>  return (target: object, propName: string) =&gt; {<br/>    let _val: Type = target[propName];</span><span id="c6b1" class="nd lt it ll b gy ni nf l ng nh"><strong class="ll iu"><em class="lr">    Object</em></strong>.defineProperty(<br/>      target,<br/>      propName, {<br/>        get(): Type | unknown {<br/>          if (!isNull(_val)) {<br/>            return _val;<br/>          }</span><span id="05d8" class="nd lt it ll b gy ni nf l ng nh">          let item = StorageService.<em class="lr">getItem</em>(key);<br/>          if (isNull(item)) {<br/>            item = defaultValue;<br/>            _val = defaultValue;<br/>            StorageService.<em class="lr">setItem</em>(key, item, storageType === StorageType.<em class="lr">Local</em>);<br/>          }</span><span id="a577" class="nd lt it ll b gy ni nf l ng nh">          return item;<br/>        },<br/>        set(item: Type): void {<br/>          _val = item;<br/>          StorageService.<em class="lr">setItem</em>(key, item, storageType === StorageType.<em class="lr">Local</em>);<br/>        }<br/>      }<br/>    );<br/>  };<br/>}</span></pre><p id="17a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想特别关注一下<code class="fe li lj lk ll b">StorageService</code>。在当前的实现中，我们的装饰者完全不知道这个服务是什么，它是如何安排的，以及它在哪里写数据。它只执行纯粹的“装饰”/“装饰者”任务。这是本质，是一种抽象，可以根据你的需要随时替换。</p><p id="1192" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nj" href="https://stackblitz.com/edit/angular-storage-decorator?embed=1&amp;file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lr">堆栈视图</em> </a></p><h1 id="700d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">错误处理</h1><blockquote class="nk"><p id="bd58" class="nl nm it bd nn no nz oa ob oc od ky dk translated">无法读取未定义的属性“X”</p></blockquote><p id="033e" class="pw-post-body-paragraph kb kc it kd b ke nu kg kh ki nv kk kl km nw ko kp kq nx ks kt ku ny kw kx ky im bi translated">我们中有多少人发现了这一点，处理包含大量嵌套或复杂数据结构或者两者兼有的“繁重”后端API 响应？</p><p id="e097" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了避免这种情况，通常使用<em class="lr"> if…else </em>链或<em class="lr"> try…catch </em>结构。当它增长时，这变成了一个逻辑和大量检查的大杂烩，方法变得臃肿，在支持和理解上变得不方便。应用装饰器:</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="34dd" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent {</span><span id="4a69" class="nd lt it ll b gy ni nf l ng nh">    @Safe()<br/>    getData(): object { ... }</span><span id="ff7f" class="nd lt it ll b gy ni nf l ng nh">    @Safe({ returnValue: [] })<br/>    getData(): string[] { ... }<br/>}</span></pre><p id="d7f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们将原始方法包装在一个<em class="lr"> try…catch </em>块中，同时允许我们添加对各种错误的跟踪和处理。首先，调用本机方法。如果出现错误，我们会按照您需要的方式进行处理，并返回默认值，该值可以作为参数传递给装饰器。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="803f" class="nd lt it ll b gy ne nf l ng nh">export function Safe&lt;T&gt;(params: SafeDecoratorParams&lt;T&gt; = {}): Function {<br/>  return function(target: object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;): TypedPropertyDescriptor&lt;Function&gt; {<br/>    const originalMethod = descriptor.value;<br/>    const logLevel = params.logLevel || SafeDecoratorLogLevel.<em class="lr">Default</em>;</span><span id="c70a" class="nd lt it ll b gy ni nf l ng nh">    descriptor.value = function SafeWrapper(): SafeDecoratorParams&lt;T&gt; | false {<br/>      try {<br/>        return originalMethod.apply(this, arguments);<br/>      } catch (error) {<br/>        if (logLevel === SafeDecoratorLogLevel.<em class="lr">Console</em>) { <strong class="ll iu"><em class="lr">console</em></strong>.error(error); }</span><span id="0d95" class="nd lt it ll b gy ni nf l ng nh">        if (logLevel === SafeDecoratorLogLevel.<em class="lr">Sentry</em>) {<br/>          if (!this.errorHandler) {<br/>            throw new <strong class="ll iu"><em class="lr">Error</em></strong>(<br/>              "Class with 'Safe' decorator and logLevel 2 should have 'errorHandler' class property with 'ErrorHandler' class."<br/>            );<br/>          } else {<br/>            this.errorHandler.handleError(error);<br/>          }<br/>        }</span><span id="6124" class="nd lt it ll b gy ni nf l ng nh">        return params.returnValue !== undefined ? params.returnValue : false;<br/>      }<br/>    };</span><span id="2f78" class="nd lt it ll b gy ni nf l ng nh">    return descriptor;<br/>  };<br/>}</span></pre><p id="0852" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果，我们得到了一个干净简单的结构，避免了许多检查和方法的增加，以及跟踪和响应各种错误的能力。</p><p id="876f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nj" href="https://stackblitz.com/edit/angular-ivy-save-decorator?embed=1&amp;file=src/app/app.component.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lr">堆栈视图</em> </a></p><h1 id="7d7e" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">取消订阅</h1><p id="e65c" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">几乎总有你需要退订的流。令人痛苦的熟悉情况，不是吗？</p><p id="1a92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">订阅一个流，一个<code class="fe li lj lk ll b">Subscription</code>被创建并继续存在，直到它<em class="lr">完成</em>或者直到我们<em class="lr">手动取消订阅</em>。但是如果有两个，三个，五个流呢…？当我们使用多重订阅时，这可能会变得相当混乱。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="5de2" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>export class TestComponent implements OnDestroy {</span><span id="95d2" class="nd lt it ll b gy ni nf l ng nh">    subscription1: Subscription;<br/>    subscription2: Subscription;</span><span id="7e6e" class="nd lt it ll b gy ni nf l ng nh">    constructor() {<br/>        this.subscription1 = this.getData1().subscribe();<br/>        this.subscription2 = this.getData2().subscribe();<br/>    }</span><span id="0493" class="nd lt it ll b gy ni nf l ng nh">    ngOnDestroy(): void {<br/>        this.subscription1.unsubscribe();<br/>        this.subscription2.unsubscribe();<br/>    }</span><span id="c036" class="nd lt it ll b gy ni nf l ng nh">    getData1(): Observable&lt;unknown[]&gt; {...}<br/>    getData2(): Observable&lt;unknown[]&gt; {...}<br/>}</span></pre><p id="d381" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们使用我们的装饰器来自动化这个过程:</p><ol class=""><li id="8411" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky oe lf lg lh bi translated">用<code class="fe li lj lk ll b">@TakeUntilDestroy</code>标记组件</li><li id="17cf" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky oe lf lg lh bi translated">实施<code class="fe li lj lk ll b">ngOnDestroy</code>挂钩</li><li id="dc21" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky oe lf lg lh bi translated">在我们装饰类的主体中创建<code class="fe li lj lk ll b">componentDestroy</code>属性</li><li id="c436" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky oe lf lg lh bi translated">此外，当您需要取消订阅时，可以结合使用<code class="fe li lj lk ll b">takeUntil</code>操作符和<code class="fe li lj lk ll b">componentDestroy</code>调用</li></ol><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="646d" class="nd lt it ll b gy ne nf l ng nh">@Component({<br/>  selector: 'app-test',<br/>  templateUrl: './test.component.html'<br/>})<br/>@<!-- -->TakeUntilDestroy<br/>export class TestComponent implements OnDestroy {</span><span id="6a45" class="nd lt it ll b gy ni nf l ng nh">    private componentDestroy: () =&gt; Observable&lt;unknown&gt;;</span><span id="e8bf" class="nd lt it ll b gy ni nf l ng nh">    constructor() {<br/>        this.getData1()<br/>            .pipe(takeUntil(this.componentDestroy()))<br/>            .subscribe();<br/>        this.getData2()<br/>            .pipe(takeUntil(this.componentDestroy()))<br/>            .subscribe();<br/>    }</span><span id="7be1" class="nd lt it ll b gy ni nf l ng nh">    ngOnDestroy(): void {}</span><span id="ca55" class="nd lt it ll b gy ni nf l ng nh">    getData1(): Observable&lt;unknown[]&gt; {...}<br/>    getData2(): Observable&lt;unknown[]&gt; {...}<br/>}</span></pre><p id="92d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就实现而言，一切看起来都很简单。装饰者创建了一个Subject — <code class="fe li lj lk ll b">_takeUntilDestroy$</code>，它将继续管理我们的退订。下一点是覆盖<code class="fe li lj lk ll b">ngOnDestroy</code>钩子，其中我们最初将控制转移到原始方法，然后在我们的主题上调用<code class="fe li lj lk ll b">next()</code>和<code class="fe li lj lk ll b">complete()</code>。一旦这些方法奏效，<code class="fe li lj lk ll b">takeUntil</code>就会触发并取消订阅。</p><pre class="mv mw mx my gt mz ll na nb aw nc bi"><span id="9e0a" class="nd lt it ll b gy ne nf l ng nh">export function TakeUntilDestroy(constructor: Function): void {<br/>  const originalDestroy = constructor.prototype.ngOnDestroy;</span><span id="51ad" class="nd lt it ll b gy ni nf l ng nh">  if (typeof originalDestroy !== 'function') {<br/>    <strong class="ll iu"><em class="lr">console</em></strong>.warn(`${constructor.name} is using @TakeUntilDestroy but does not implement OnDestroy`);<br/>  }</span><span id="8bbd" class="nd lt it ll b gy ni nf l ng nh">  constructor.prototype.componentDestroy = function(): object {<br/>    this._takeUntilDestroy$ = this._takeUntilDestroy$ || new Subject();</span><span id="289b" class="nd lt it ll b gy ni nf l ng nh">    return this._takeUntilDestroy$.asObservable();<br/>  };</span><span id="583b" class="nd lt it ll b gy ni nf l ng nh">  constructor.prototype.ngOnDestroy = function(...args): void {<br/>    if (typeof originalDestroy === 'function') {<br/>      originalDestroy.apply(this, args);<br/>    }</span><span id="048b" class="nd lt it ll b gy ni nf l ng nh">    if (this._takeUntilDestroy$) {<br/>      this._takeUntilDestroy$.next();<br/>      this._takeUntilDestroy$.complete();<br/>    }<br/>  };<br/>}</span></pre><p id="e50c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae nj" href="https://stackblitz.com/edit/angular-take-until-destroy-decorator?embed=1&amp;file=src/app/hello.component.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lr">查看StackBlitz </em> </a></p><h1 id="87ff" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="6d6e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">装饰器是真正强大的工具，可以给你的代码带来美丽、优雅和纯洁。</p><p id="9414" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们研究了一些对我们任何人都有用的最常见和最有趣的场景。当然，你不应该仅仅局限于这些。在更多的情况下，这种力量是有用的:</p><ul class=""><li id="2033" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">贮藏</li><li id="dfa7" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">排除故障</li><li id="e0ac" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">扩展第三方库功能。</li><li id="aa2b" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">与服务器交互的服务。</li><li id="ef68" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">用户设置的操作。</li><li id="97f7" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">用户权限的请求和验证。</li><li id="ac6c" class="kz la it kd b ke lm ki ln km lo kq lp ku lq ky le lf lg lh bi translated">暂时隐藏未来的功能。</li></ul><p id="be9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">祝您在使用和编写您的decorators时好运！</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><div class="mv mw mx my gt om"><a href="https://stackblitz.com/edit/angular-custom-decorators?embed=1&amp;file=src/app/app.component.ts&amp;view=editor" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">角度-定制-装饰者StackBlitz</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">stackblitz.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa jv om"/></div></div></a></div></div></div>    
</body>
</html>