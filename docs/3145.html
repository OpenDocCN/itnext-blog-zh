<html>
<head>
<title>React Native Collapsible Headers — Expert Knowledge Revealed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React本机可折叠标题—显示专业知识</h1>
<blockquote>原文：<a href="https://itnext.io/react-native-collapsible-headers-explained-78584ff133d8?source=collection_archive---------0-----------------------#2019-10-12">https://itnext.io/react-native-collapsible-headers-explained-78584ff133d8?source=collection_archive---------0-----------------------#2019-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">近年来，可折叠标题模式在应用程序中变得非常流行，但重要的问题是…我们如何在React Native中实现这一点？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/3cccc358b48a0e0a06bc8c61052a7563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*TpbdLxGQQNVcaV4ueRBQrg.gif"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">革命(左)-现在奖励我(右)</figcaption></figure><p id="f1e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要担心，因为今天您将学习纯JavaScript的可折叠标题的秘方。混合香料、一些糖和少许盐，🧂全“酱”码<a class="ae kx" href="https://gist.github.com/lukebrandonfarrell/866f208718c1326035df4e694c17b2da" rel="noopener ugc nofollow" target="_blank">可在本文末尾获得。</a></p><p id="bb29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要在react本地组件中定义三个常量，理论上，这些常量可以根据高级可折叠头的用户设置而动态变化，但在我们的示例中，这些值是常量。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="235a" class="ld le iq kz b gy lf lg l lh li">const H_MAX_HEIGHT = 150;<br/>const H_MIN_HEIGHT = 52;<br/>const H_SCROLL_DISTANCE = H_MAX_HEIGHT - H_MIN_HEIGHT;</span></pre><ul class=""><li id="fded" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><code class="fe ls lt lu kz b">H_MAX_HEIGHT</code>将用于配置我们的页眉的最大高度。</li><li id="a395" class="lj lk iq jp b jq lv ju lw jy lx kc ly kg lz kk lo lp lq lr bi translated"><code class="fe ls lt lu kz b">H_MIN_HEIGHT</code>将用于配置我们的页眉可以折叠的最小高度。</li><li id="007a" class="lj lk iq jp b jq lv ju lw jy lx kc ly kg lz kk lo lp lq lr bi translated"><code class="fe ls lt lu kz b">H_SCROLL_DISTANCE</code>是割台的最大高度和最小高度之间的距离，将与<code class="fe ls lt lu kz b">scrollOffsetY</code>一起用于插值。</li></ul><p id="14dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用钩子来构建这个头，因为它极大地简化了代码，如果你没有使用钩子，那么你可以通过使用<code class="fe ls lt lu kz b">this.state</code>中的<code class="fe ls lt lu kz b">Animated</code> API将它转换成一个类组件。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="78bd" class="ld le iq kz b gy lf lg l lh li">const scrollOffsetY = useRef(new Animated.Value(0)).current;</span></pre><p id="ab17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们设置了一个引用来跟踪我们的<code class="fe ls lt lu kz b">scrollOffsetY</code>作为一个动画值。然后下面的代码使用<code class="fe ls lt lu kz b">scrollOffsetY</code>(这个值随着我们的滚动视图的移动而更新)并从最大高度到最小高度进行插值。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="2756" class="ld le iq kz b gy lf lg l lh li">const headerScrollHeight = scrollOffsetY.interpolate({<br/>    inputRange: [0, <!-- -->H_SCROLL_DISTANCE<!-- -->],<br/>    outputRange: [<!-- -->H_MAX_HEIGHT<!-- -->, <!-- -->H_MIN_HEIGHT<!-- -->],<br/>    extrapolate: "clamp"<br/>});</span></pre><p id="7ddf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为我们从<code class="fe ls lt lu kz b">0</code>开始<code class="fe ls lt lu kz b">scrollOffsetY</code>，我们希望以页面滚动的相同速度在最大和最小高度之间制作标题动画，这可能很难理解，下图说明了这个概念。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ma"><img src="../Images/d70d985fb741981667d9c9edc966e136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7Ca0936AHqQeBiOAMfM4w.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">动画值图表</figcaption></figure><p id="63d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成可折叠标题，我们必须将上面定义的值应用到组件中。首先是标题组件，它是<code class="fe ls lt lu kz b">absolute</code>并且有一个由我们的动画<code class="fe ls lt lu kz b">headerScrollHeight</code>控制的动态高度。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="f277" class="ld le iq kz b gy lf lg l lh li">&lt;Animated.View<br/>  style={{<br/>    position: "absolute",<br/>    left: 0,<br/>    right: 0,<br/>    top: 0,<br/>    height: headerScrollHeight,<br/>    width: "100%",<br/>    overflow: "hidden",<br/>    zIndex: 999,<br/>    // STYLE<br/>    borderBottomColor: "#EFEFF4",<br/>    borderBottomWidth: 2,<br/>    padding: 10,<br/>    backgroundColor: "blue"<br/>   }}<br/>&gt;<br/>  &lt;Image<br/>    source={{ uri: "<a class="ae kx" href="https://via.placeholder.com/300" rel="noopener ugc nofollow" target="_blank">https://via.placeholder.com/300</a>" }}<br/>    style={{ flex: 1 }}<br/>    resizeMode={"contain"}<br/>  /&gt;<br/>&lt;/Animated.View&gt;</span></pre><p id="37e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构建了我们的header组件之后，我们需要在我们的<code class="fe ls lt lu kz b">&lt;ScrollView /&gt;</code>中为<code class="fe ls lt lu kz b">&lt;View /&gt;</code>添加一个填充。这定义了我们的滚动视图内容应该从哪一点开始，这应该是页眉的初始高度，这是最大高度。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="1a85" class="ld le iq kz b gy lf lg l lh li">&lt;ScrollView ...<br/>  &lt;View style={{ paddingTop: H_MAX_HEIGHT }}&gt;<br/>   ... // rest of content</span></pre><p id="e9ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将一个<code class="fe ls lt lu kz b">Animated.event</code>附加到我们的<code class="fe ls lt lu kz b">ScrollView</code>上来更新<code class="fe ls lt lu kz b">scrollOffsetY</code>(记住这个值将被插入来激活我们的标题)。我们需要使用<code class="fe ls lt lu kz b">scrollEventThrottle</code>事件每16毫秒触发一次<code class="fe ls lt lu kz b">onScroll</code>事件，而不是默认的每次滚动后触发。降低<code class="fe ls lt lu kz b">scrollEventThrottle</code>(1–16)将会给你一个更平滑的标题，但是会花费你的应用更多的资源。</p><pre class="km kn ko kp gt ky kz la lb aw lc bi"><span id="6652" class="ld le iq kz b gy lf lg l lh li">&lt;ScrollView        <br/>   onScroll={Animated.event([<br/>     { nativeEvent: { contentOffset: { y: scrollOffsetY }}}              <br/>    ])<br/>   }<br/>   scrollEventThrottle={16}<br/>/&gt;</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/cd0f3ed4a91a08df38f60afa1667c9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/1*lYXIVpnYrtP1PooleClq6g.gif"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">最终的结果…好吃！</figcaption></figure><p id="e909" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下链接是在应用程序的组件中实现可折叠头的完整源代码。与你的朋友分享这个食谱，用对家人的爱来烹饪它，或者把它带到工作中🥙</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated"><a class="ae kx" href="https://gist.github.com/lukebrandonfarrell/866f208718c1326035df4e694c17b2da" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/lukebrandonfarrell/866 f 208718 c 1326035 df 4 e 694 c 17 B2 da</a></figcaption></figure></div></div>    
</body>
</html>