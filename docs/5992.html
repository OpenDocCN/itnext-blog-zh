<html>
<head>
<title>Simplifying Kafka Connectors Configuration with an Integration Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用集成语言简化Kafka连接器配置</h1>
<blockquote>原文：<a href="https://itnext.io/simplifying-kafka-connectors-configuration-with-an-integration-language-6cb62279a0f4?source=collection_archive---------6-----------------------#2021-07-19">https://itnext.io/simplifying-kafka-connectors-configuration-with-an-integration-language-6cb62279a0f4?source=collection_archive---------6-----------------------#2021-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b884" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前一篇关于使用Knative和Kubernetes API对象配置Kafka源和汇的文章中，你可能会告诉自己“满脸都是YAML”。事实上，Kubernetes自成立以来最令人头疼的问题之一就是YAML问题。一旦你开始用Kubernetes对象声明你的应用程序的期望状态，你会得到很多很多的YAML。</p><p id="cf41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个很棒的。关于T2 github上Kubernetes的声明式应用程序管理的文档最初是由谷歌的布莱安·葛兰特写的。在该文档中，您可以了解到在Kubernetes中管理应用程序的许多不同方法，以及解决或至少处理“面对大量yaml”挑战的许多不同方法。在那个文档中，你还会找到一个惊人的电子表格的链接，我上次检查过，它有<strong class="jp ir"> 127个工具</strong>用于管理Kubernetes应用程序。</p><p id="2c3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想向你展示我们在TriggerMesh的工作，它不是一个管理k8s应用程序的工具，而是一个以事件驱动机制为核心的各种应用程序之间集成的创作工具。想想把卡夫卡的源头连接到溪流，定义转化，连接到汇点。它确实有一些我认为很棒的东西</p><ul class=""><li id="5a11" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">简化事件驱动系统的设计</li><li id="b15b" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">基于更友好的基于HCL的语法生成复杂的YAML</li></ul><p id="a930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入Kafka流的表示之前，让我们绕一个“企业集成模式”的弯路</p><h1 id="0d16" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">企业集成模式</strong></h1><p id="226a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">企业集成并不新鲜，但从云原生世界的角度来看，如果不是颠覆性的，进行一些现代化的时机已经成熟。<a class="ae kl" href="https://www.enterpriseintegrationpatterns.com/" rel="noopener ugc nofollow" target="_blank">企业集成</a>模式已经描述过，下图显示了每个主要组件中的不同模式:源、通道、路由器、转换器、目标。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/3ade37a7b272b1c1635e77b25f0cdb68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5W5-mL1adrbl8zLa.png"/></div></div></figure><blockquote class="mp mq mr"><p id="3553" class="jn jo ms jp b jq jr js jt ju jv jw jx mt jz ka kb mu kd ke kf mv kh ki kj kk ij bi translated">我们在TriggerMesh开始做的是创建一种描述语言，以声明的方式表示集成的设计，抽象出用于实现模式的API对象。</p></blockquote><p id="df90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将具有源和汇/目标的Kafka流视为一个集成，然后我们可以考虑用TriggerMesh集成语言来表示这个流。下面先睹为快，我们计划在月底发布。</p><h1 id="514e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">TriggerMesh集成语言</h1><p id="aecf" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">在TriggerMesh，我们有很多人使用像<strong class="jp ir">这样的平台，我们也很喜欢Hashicorp配置语言(即<a class="ae kl" href="https://github.com/hashicorp/hcl" rel="noopener ugc nofollow" target="_blank"> HCL </a>)。所以我们决定用HCL写我们的TriggerMesh集成语言(TIL)。这样做简化了编写集成所需的所有YAML的创作。</strong></p><p id="a7db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/sending-messages-to-kafka-cfb5a246f5eb">关于向卡夫卡发送数据的帖子</a>中，我们看到了YAML对于一个<code class="fe mw mx my mz b">KafkaSink</code>对象:</p><pre class="me mf mg mh gt na mz nb nc aw nd bi"><span id="d85f" class="ne lb iq mz b gy nf ng l nh ni">apiVersion: eventing.knative.dev/v1alpha1<br/>kind: KafkaSink<br/>metadata:<br/> name: my-kafka-topic<br/>spec:<br/> auth:<br/>   secret:<br/>     ref:<br/>       name: kafkahackathon<br/> bootstrapServers:<br/> — pkc-456q9.us-east4.gcp.confluent.cloud:9092<br/> topic: hackathon</span></pre><p id="9810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着<strong class="jp ir">倾斜到</strong>，这变成了<strong class="jp ir"> : </strong></p><pre class="me mf mg mh gt na mz nb nc aw nd bi"><span id="26ac" class="ne lb iq mz b gy nf ng l nh ni">target “kafka” “my_kafka_topic” {<br/> topic = “hackathon”<br/> bootstrap_servers = [“pkc-419q3.us-east4.gcp.confluent.cloud:9092”]<br/> auth = secret_name(“kafkahackathon”)<br/>}</span></pre><p id="0198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们不需要知道什么是T1，什么是T2。我们只需要知道这是我们集成的目标端点，这是类型<code class="fe mw mx my mz b">kafka</code></p><p id="0672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，对于一个如本帖<a class="ae kl" href="https://sebgoa.medium.com/consuming-kafka-messages-in-kubernetes-9e43050d6eb4" rel="noopener">中所描述的<code class="fe mw mx my mz b">Kafkasource</code>来说，完整的YAML消费来自卡夫卡的信息会是这样的</a></p><pre class="me mf mg mh gt na mz nb nc aw nd bi"><span id="0ce6" class="ne lb iq mz b gy nf ng l nh ni">apiVersion: sources.knative.dev/v1beta1<br/>kind: KafkaSource<br/>metadata:<br/> name: my-kafka<br/>spec:<br/> bootstrapServers:<br/> — pkc-q.us-east4.gcp.confluent.cloud:9092<br/> net:<br/>   sasl:<br/>     enable: true<br/>     password:<br/>       secretKeyRef:<br/>         key: password<br/>         name: kafkahackathon<br/>     type:<br/>       secretKeyRef:<br/>         key: sasl.mechanism<br/>         name: kafkahackathon<br/>     user:<br/>       secretKeyRef:<br/>         key: user<br/>         name: kafkahackathon<br/>…<br/> sink:<br/>   ref:<br/>     apiVersion: v1<br/>     kind: Service<br/>     name: display<br/> topics:<br/> — hackathon</span></pre><p id="a6c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">到</strong>这变成了:</p><pre class="me mf mg mh gt na mz nb nc aw nd bi"><span id="8374" class="ne lb iq mz b gy nf ng l nh ni">source “kafka” “my_kafka” {<br/> bootstrap_servers = [“pkc-q3.us-east4.gcp.confluent.cloud:9092”]<br/> topics = [“hackathon”]<br/> sasl_auth = secret_name(“kafkahackathon”)<br/> tls = secret_name(“kafkahackathon”)<br/> to = target.sockeye<br/>}</span></pre><h1 id="17d1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">GitHub Kafka源和作为Kafka接收器的微服务</h1><p id="dc4f" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">有了TIL，您将能够以声明的方式声明一个消息流，并在Kubernetes中管理它(假设所需的Kafka和TriggerMesh控制器已经就绪)。</p><p id="75dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，GitHub事件源将其所有事件发送到Kafka流，并从Kafka流消费，以Kubernetes上的无服务器工作负载为目标，其声明如下:</p><pre class="me mf mg mh gt na mz nb nc aw nd bi"><span id="46e7" class="ne lb iq mz b gy nf ng l nh ni">source “github” “git_source” {<br/> owner_and_repository = “sebgoa/transform”<br/> event_types = [“push”, “issues”]<br/> tokens = secret_name(“github-secret”)</span><span id="b6d0" class="ne lb iq mz b gy nj ng l nh ni">to = target.my_kafka_topic<br/>}</span><span id="5f23" class="ne lb iq mz b gy nj ng l nh ni">target “kafka” “my_kafka_topic” {<br/> topic = “hackathon”<br/> bootstrap_servers = [“pkc-4q3.us-east4.gcp.confluent.cloud:9092”]<br/> auth = secret_name(“kafkahackathon”)<br/>}</span><span id="9370" class="ne lb iq mz b gy nj ng l nh ni">source "kafka" "my_kafka" {<br/>  bootstrap_servers = ["pkc-4q3.us-east4.gcp.confluent.cloud:9092"]<br/>  topics = ["hackathon"]<br/>  sasl_auth =  secret_name("kafkahackathon")<br/>  tls = secret_name("kafkahackathon")<br/>  to = target.mymicroservice<br/>}</span><span id="41f3" class="ne lb iq mz b gy nj ng l nh ni">target "container" "mymicroservice" {<br/>    image = "docker.io/n3wscott/sockeye:v0.7.0"<br/>    public = true<br/>}</span></pre><p id="df9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，通过将此定义存储在文件<code class="fe mw mx my mz b">kafka.hcl</code>中，您可以使用我们的CLI生成YAML，并将其应用于您的k8s集群</p><pre class="me mf mg mh gt na mz nb nc aw nd bi"><span id="007b" class="ne lb iq mz b gy nf ng l nh ni">til generate kafka.hcl | kubectl apply -f-</span></pre><h1 id="77be" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="b5dc" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">首先，我们通过采用云原生声明来简化企业集成的编写。第二，我们通过向人们提供用HCL编写的描述语言来解决描述企业集成时的YAML难题，该描述语言:</p><ul class=""><li id="556c" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">将已知的集成模式定义为顶级组件(例如，源、目标、转换等等)</li><li id="6340" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">抽象Kubernetes对象(本机和自定义)</li><li id="536f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">可以在您的GitOps管道中使用</li><li id="c796" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">简化Kafka连接器配置</li></ul><p id="171c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们快完成了，请继续关注发布，如果你想尝试一下，请联系我。</p></div></div>    
</body>
</html>