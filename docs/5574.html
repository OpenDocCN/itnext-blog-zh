<html>
<head>
<title>Working with kubernetes configmaps, part 2: Watchers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用kubernetes配置图，第2部分:观察器</h1>
<blockquote>原文：<a href="https://itnext.io/working-with-kubernetes-configmaps-part-2-watchers-b6dd0e583d71?source=collection_archive---------0-----------------------#2021-04-07">https://itnext.io/working-with-kubernetes-configmaps-part-2-watchers-b6dd0e583d71?source=collection_archive---------0-----------------------#2021-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/54d56ecde4ff5875d61e8ccf536ae753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKIx2O3p_6aPcpQYpVHeQQ.png"/></div></div></figure><h1 id="4d4e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="ac42" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在我的上一篇文章《使用kubernetes配置图，第1部分:卷挂载》中，我讨论了从容器中的卷挂载加载kubernetes配置图的机制，以及用于创建配置图的方法如何转化为数据的呈现方式。</p><p id="3681" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这篇文章中，我将讨论一个处理配置图的具体策略，即使用一个<strong class="ky ir">观察器</strong>。Kubernetes API资源都支持一个<a class="ae lu" href="https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes" rel="noopener ugc nofollow" target="_blank">观察提要</a>，它允许API客户端监控他们感兴趣的资源，被告知变化，然后相应地采取行动(以他们希望的任何方式)。因此，监视这种资源的客户机代码就是这里的<strong class="ky ir">观察器</strong>，在下面的讨论中，我将展示一些使用观察器来处理配置图的具体例子，这些例子比通过卷安装来使用配置图要动态得多。</p><p id="1df1" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在我们继续之前，让我澄清一下，您完全可以为挂载的configmap实现一个观察器。<a class="ae lu" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#mounted-configmaps-are-updated-automatically" rel="noopener ugc nofollow" target="_blank"> kubelet保持挂载更新</a>(有一点点延迟，在默认配置中最多两分钟)，您当然可以像监视任何其他文件一样监视挂载文件系统中的文件的变化。</p><p id="1ce6" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是使用kubernetes(甚至在混合使用knative时更是如此)鼓励的核心模式之一是事件驱动编程。然而，监视文件的更改更像是一个监视问题——监视代码必须知道文件的状态，然后基本上轮询文件的任何更改。例如，它变大了还是变小了，或者计算出的校验和发生了变化？在事件驱动的模型中，客户端更多地扮演被动的角色——“我想知道任何事件，只要让我知道它们何时发生。”这使我们能够编写更简单、更轻便的代码，并专注于我们真正关心的问题，而不是如何检测例如给定类型的资源的变化。</p><p id="a619" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">幸运的是，kubernetes(如上所述)本身提供了对事件驱动模型的支持，使用这种模型来消费configmaps让我们编写的代码不仅比监视文件更改的代码更简单，而且更加健壮和容错。在本文和后续的文章中，我将展示三个例子来说明如何做到这一点——第一个例子，这里介绍的，将使用golang 的标准<a class="ae lu" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> kubernetes客户端库，第二个和第三个(将在本系列的下一篇文章中讨论)将使用我在第1部分中使用的</a><a class="ae lu" href="https://pkg.go.dev/knative.dev/pkg/configmap" rel="noopener ugc nofollow" target="_blank"> knative configmap包</a>的不同部分。</p><h1 id="b365" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在哪里可以找到样本</h1><p id="aaac" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我将在这里展示的所有示例(代码和配置)都可以在我位于https://github.com/ScarletTanager/configmap-watcher-example<a class="ae lu" href="https://github.com/ScarletTanager/configmap-watcher-example" rel="noopener ugc nofollow" target="_blank">的GitHub repo中找到。如果您认为合适，您可以自由复制/使用该代码的任何部分。我们将要编写的应用程序的完整源代码位于</a><a class="ae lu" href="https://github.com/ScarletTanager/configmap-watcher-example/blob/main/watch/watch.go" rel="noopener ugc nofollow" target="_blank">https://github . com/scarlet manager/config map-watcher-example/blob/main/watch/watch . go</a>。</p><p id="77b4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">对于其中的每个示例，我将使用以下命令从上述存储库的根目录创建配置映射:</p><p id="47be" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><code class="fe ma mb mc md b">kubectl create cm clusters-config --from-env-file=configs/clusters.properties</code></p><p id="5dbd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这将生成一个起始配置图(我们在示例中对其进行了修改),其数据部分如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="030e" class="mm jz iq md b gy mn mo l mp mq">data:<br/>  cluster1.endpoint: <a class="ae lu" href="https://foo.com" rel="noopener ugc nofollow" target="_blank">https://foo.com</a><br/>  cluster2.endpoint: <a class="ae lu" href="https://bar.com" rel="noopener ugc nofollow" target="_blank">https://bar.com</a><br/>  cluster3.endpoint: <a class="ae lu" href="https://foobar.com" rel="noopener ugc nofollow" target="_blank">https://foobar.com</a><br/>  cluster4.endpoint: <a class="ae lu" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a><br/>  cluster5.endpoint: <a class="ae lu" href="https://take.me.to.funkytown" rel="noopener ugc nofollow" target="_blank">https://take.me.to.funkytown</a><br/>  current.target: cluster1.endpoint</span></pre><h1 id="48e6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">不仅仅是配置图</h1><p id="b6e7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您曾经使用过kubernetes API，无论是直接通过编写自己的客户端库还是使用<a class="ae lu" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>库，您可能已经知道观察器不是特定于远程配置图的。事实上，您可以修改本文中的大部分代码，使其适用于几乎所有受支持的kubernetes资源类型。我在这里是在特定于configmap的上下文中讨论该模式的，但是我接下来要说的几乎所有内容都同样适用于pod、服务、服务帐户等。</p><h1 id="d5af" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用client-go构建观察器</h1><p id="cf55" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们从一个基本目的开始:构建一个简单的REST端点，它像这样返回一个JSON有效负载:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7e1e" class="mm jz iq md b gy mn mo l mp mq">{"current_endpoint": "https://somehost.domain"}</span></pre><p id="1a4f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">其中<code class="fe ma mb mc md b">somehost.domain</code>是通过<code class="fe ma mb mc md b">data[data["current.target"]]</code>访问时我们的configmap生成的URL。在我之前的文章中，我们通过使用<code class="fe ma mb mc md b">configmap.Load()</code>从一个卷装载一次configmap来完成这个任务，但是这一次我们将使用一种不同的方法。我们从一些基本的管道开始:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3029" class="mm jz iq md b gy mn mo l mp mq">package main</span><span id="8bfa" class="mm jz iq md b gy mr mo l mp mq">import (<br/>  "fmt"<br/>  "io/ioutil"<br/>  "net/http"<br/> <br/>  "k8s.io/client-go/kubernetes"<br/>  "k8s.io/client-go/rest"<br/>)</span><span id="8aeb" class="mm jz iq md b gy mr mo l mp mq">const (<br/>  NS_FILE          = "/var/run/secrets/kubernetes.io/serviceaccount/namespace"<br/>  CM_NAME          = "clusters-config"<br/>  DEFAULT_ENDPOINT = "<a class="ae lu" href="https://wazanga.partytime" rel="noopener ugc nofollow" target="_blank">https://wazanga.partytime</a>"<br/>)</span><span id="2533" class="mm jz iq md b gy mr mo l mp mq">var (<br/>  namespace string<br/>)</span><span id="1ef6" class="mm jz iq md b gy mr mo l mp mq">func init() {<br/>  nsBytes, err := ioutil.ReadFile(NS_FILE)<br/>  if err != nil {<br/>    panic(fmt.Sprintf("Unable to read namespace file at %s", NS_FILE))<br/>  }</span><span id="171c" class="mm jz iq md b gy mr mo l mp mq">  namespace = string(nsBytes)<br/>}</span></pre><p id="5102" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们已经声明了我们的导入，我们还设置了一些常量，其中最重要的是<code class="fe ma mb mc md b">DEFAULT_ENDPOINT</code>，我们将其定义为<code class="fe ma mb mc md b">https://wazanga.partytime</code>。我们还声明了一个变量<code class="fe ma mb mc md b">namespace</code>，然后我们用kubernetes名称空间的值来填充这个变量，我们的代码在这个名称空间中执行。这都是很标准的东西。</p><p id="46cd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">接下来，我们开始填充我们的<code class="fe ma mb mc md b">main()</code>函数:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="be97" class="mm jz iq md b gy mn mo l mp mq">func main() {<br/>  var (<br/>    currentEndpoint string<br/>  )</span><span id="e6e8" class="mm jz iq md b gy mr mo l mp mq">  // Let's make sure we don't forget to set a default<br/>  currentEndpoint = DEFAULT_ENDPOINT</span><span id="9bcd" class="mm jz iq md b gy mr mo l mp mq">  // Get things set up for watching - we need a valid k8s client<br/>  clientCfg, err := rest.InClusterConfig()<br/>  if err != nil {<br/>    panic("Unable to get our client configuration")<br/>  }</span><span id="ad10" class="mm jz iq md b gy mr mo l mp mq">  clientset, err := kubernetes.NewForConfig(clientCfg)<br/>  if err != nil {<br/>    panic("Unable to create our clientset")<br/>  }</span></pre><p id="8124" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以在这里，我们将变量<code class="fe ma mb mc md b">currentEndpoint</code>初始化为<code class="fe ma mb mc md b">DEFAULT_ENDPOINT</code>的值(我在前面已经指出了)，然后创建一个配置为从集群内部运行的kubernetes客户端。我们正在使用股票kubernetes客户端库，<a class="ae lu" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go。对于大多数kubernetes客户端用例来说，这是您可能会用到的库，没有理由不在这里使用它。要配置客户端从集群外部进行身份验证，请参见这些说明</a><a class="ae lu" href="https://github.com/kubernetes/client-go/tree/master/examples/out-of-cluster-client-configuration" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a56b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，我们将通过注册http处理程序并启动监听器来完成程序的其余部分:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b410" class="mm jz iq md b gy mn mo l mp mq">  http.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {<br/>    body := []byte(fmt.Sprintf(`{"current_endpoint": "%s"}`, currentEndpoint))<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Write(body)<br/>  })</span><span id="8a8f" class="mm jz iq md b gy mr mo l mp mq">  fmt.Printf("Listening on port 8080\n")<br/>  http.ListenAndServe(":8080", nil)<br/>}</span></pre><p id="49a2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，如果我们运行这个，我们将在输出中得到<code class="fe ma mb mc md b">DEFAULT_ENDPOINT</code>的值，也就是<code class="fe ma mb mc md b">https://wazanga.partytime</code>。原因应该很明显(先不说这实际上还不会编译，因为我们没有对<code class="fe ma mb mc md b">clientset</code>变量做任何事情)。但这实际上不是我们想要的—我们想要从配置图中获取端点值。</p><h1 id="e81a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加观察器(事件处理)循环</h1><p id="1807" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，让我们添加观察器代码。我们需要更多的进口商品，最终我们得到了这些:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="bc0d" class="mm jz iq md b gy mn mo l mp mq">import (<br/>  "context"<br/>  "fmt"<br/>  "io/ioutil"<br/>  "net/http"<br/>  "sync"</span><span id="b3e6" class="mm jz iq md b gy mr mo l mp mq">  corev1 "k8s.io/api/core/v1"<br/>  metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"<br/>  "k8s.io/apimachinery/pkg/watch"<br/>  "k8s.io/client-go/kubernetes"<br/>  "k8s.io/client-go/rest"<br/>)</span></pre><p id="b5d2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然后，在<code class="fe ma mb mc md b">main()</code>的主体中，我们为<code class="fe ma mb mc md b">sync.Mutex</code>添加了一个新变量:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="16ab" class="mm jz iq md b gy mn mo l mp mq">func main() {<br/>  var (<br/>    currentEndpoint string<br/>    mutex           *sync.Mutex<br/>  )</span></pre><p id="de74" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">接下来，我们在goroutine中添加一行来启动我们的监视器，并在读取变量时使用我们的<code class="fe ma mb mc md b">sync.Mutex</code>来锁定<code class="fe ma mb mc md b">currentEnvironment</code>变量:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9536" class="mm jz iq md b gy mn mo l mp mq">mutex = &amp;sync.Mutex{} <br/>go watchForChanges(clientset, namespace, &amp;currentEndpoint, mutex)</span><span id="ea10" class="mm jz iq md b gy mr mo l mp mq"> http.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {<br/>   mutex.Lock() // ADDED THIS<br/>   body := []byte(fmt.Sprintf(`{"current_endpoint": "%s"}`, currentEndpoint))<br/>   mutex.Unlock() // AND ADDED THIS</span></pre><p id="ccaf" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">对于我们的watcher代码，我们传入kubernetes客户端、我们的名称空间、指向我们的<code class="fe ma mb mc md b">currentEnvironment</code>变量的指针和我们的互斥体，因为我们将在不同的goroutine中写入一个共享变量。</p><p id="d26a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们的watcher函数是一个简单的循环，它创建一个<code class="fe ma mb mc md b">watch.Interface</code>(这是变量<code class="fe ma mb mc md b">watcher</code>的值)的实例，然后阻塞，直到<code class="fe ma mb mc md b">updateCurrentEndpoint()</code>返回，然后无限重复相同的过程。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ac76" class="mm jz iq md b gy mn mo l mp mq">func watchForChanges(clientset *kubernetes.Clientset, namespace string, endpoint *string, mutex *sync.Mutex) {<br/>  for {<br/>    watcher, err := clientset.CoreV1().ConfigMaps(namespace).Watch(<br/>      context.TODO(),<br/>      metav1.SingleObject(metav1.ObjectMeta{<br/>        Name: CM_NAME, Namespace: namespace}))<br/>    if err != nil {<br/>      panic("Unable to create watcher")<br/>    }<br/>    updateCurrentEndpoint(watcher.ResultChan(), endpoint, mutex)<br/>  }<br/>}</span></pre><p id="60d6" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这种模式(可以用其他方式实现)是一个非常重要的方面——kubernetes观察器打开一个HTTP连接，向kubernetes API服务器发出GET调用。显然，API服务器不会永远保持连接打开，它会在某个时候关闭连接(该值可由集群管理员配置，但对于我们这些编写客户端代码的人来说，只需假设它会在以分钟为单位的某个时间间隔关闭)。所以你的代码<em class="ms">必须</em>能够检测到连接已经关闭并以某种方式重新打开。</p><p id="70ea" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">查看<code class="fe ma mb mc md b">updateCurrentEndpoint()</code>的实现将展示我们如何做到这一点，以及我们如何处理收到的事件。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="15a2" class="mm jz iq md b gy mn mo l mp mq">func updateCurrentEndpoint(eventChannel &lt;-chan watch.Event, endpoint *string, mutex *sync.Mutex) {<br/>  for {<br/>    event, open := &lt;-eventChannel<br/>    if open {<br/>      switch event.Type {<br/>      case watch.Added:<br/>        fallthrough<br/>      case watch.Modified:<br/>        mutex.Lock()<br/>        // Update our endpoint<br/>        if updatedMap, ok := event.Object.(*corev1.ConfigMap); ok {<br/>          if endpointKey, ok := updatedMap.Data["current.target"]; ok {<br/>            if targetEndpoint, ok := updatedMap.Data[endpointKey]; ok {<br/>              *endpoint = targetEndpoint<br/>            }<br/>          }<br/>        }<br/>        mutex.Unlock()<br/>      case watch.Deleted:<br/>        mutex.Lock()<br/>        // Fall back to the default value<br/>        *endpoint = DEFAULT_ENDPOINT<br/>        mutex.Unlock()<br/>      default:<br/>        // Do nothing<br/>      }<br/>    } else {<br/>      // If eventChannel is closed, it means the server has closed the connection<br/>      return<br/>    }<br/>  }<br/>}</span></pre><p id="baea" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">首先要注意的是参数列表——第一个参数<code class="fe ma mb mc md b">eventChannel</code>是类型<code class="fe ma mb mc md b">&lt;-chan watch.Event</code> —意味着一个只读通道，我们将从该通道接收<code class="fe ma mb mc md b">watch.Event</code>实例。我们通过<code class="fe ma mb mc md b">watcher.ResultChan()</code>获得这个通道kubernetes客户端通过HTTP连接在后台接收到API服务器的事件提要，然后将各个事件写入这个通道。关键的是，<em class="ms">每当服务器关闭HTTP连接时，客户端都会检测到这一点并关闭通道</em>。这意味着我们可以很容易地检测到服务器是否已经关闭了我们的连接(这将意味着我们需要创建一个新的观察器，并从中获得一个新的事件通道)，这就是我们实际上所做的事情。返回的第一个值是事件(如果存在)，第二个值是布尔值，只要通道打开，该值就为<code class="fe ma mb mc md b">true</code>，如果通道关闭，则为<code class="fe ma mb mc md b">false</code>。</p><p id="e361" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因此，如果通道关闭，我们只需从<code class="fe ma mb mc md b">updateCurrentEndpoint()</code>返回，这将使我们在<code class="fe ma mb mc md b">watchForChanges()</code>中循环另一个循环迭代，从而创建一个新的观察器(带有一个新的API连接)并获得一个新的通道。</p><p id="4c71" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">事件处理的核心在<code class="fe ma mb mc md b">switch</code>块中。每个事件都属于类型<code class="fe ma mb mc md b"><a class="ae lu" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#Event" rel="noopener ugc nofollow" target="_blank">watch.Event</a></code>——它有两个字段。一个字段<code class="fe ma mb mc md b">Type</code>反映了生成事件的操作—允许的值有:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="df8b" class="mm jz iq md b gy mn mo l mp mq">const (<br/>	Added    <a class="ae lu" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#EventType" rel="noopener ugc nofollow" target="_blank">EventType</a> = "ADDED"<br/>	Modified <a class="ae lu" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#EventType" rel="noopener ugc nofollow" target="_blank">EventType</a> = "MODIFIED"<br/>	Deleted  <a class="ae lu" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#EventType" rel="noopener ugc nofollow" target="_blank">EventType</a> = "DELETED"<br/>	Bookmark <a class="ae lu" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#EventType" rel="noopener ugc nofollow" target="_blank">EventType</a> = "BOOKMARK"<br/>	Error    <a class="ae lu" href="https://pkg.go.dev/k8s.io/apimachinery/pkg/watch#EventType" rel="noopener ugc nofollow" target="_blank">EventType</a> = "ERROR"<br/>)</span></pre><p id="5135" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们关心其中的三个— <code class="fe ma mb mc md b">Added</code>、<code class="fe ma mb mc md b">Modified</code>和<code class="fe ma mb mc md b">Deleted</code>。第一次创建资源时，会生成类型为<code class="fe ma mb mc md b">Added</code>的事件。Kubernetes保留资源事件历史，其中包括这个初始事件，这样当我们的程序第一次启动时，我们会自动得到配置映射的存在和当前状态的通知——这样我们就不必在事件处理程序循环之外读取当前内容。</p><p id="a73f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们用一个真实的例子来测试一下。我们已经在文章的开头创建了configmap，所以让我们开始我们的程序并结束它的端点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ef8c" class="mm jz iq md b gy mn mo l mp mq">$ curl https://basic-watcher.us-south.codeengine.appdomain.cloud/config<br/>{"current_endpoint": "https://foo.com"}</span></pre><p id="8ef5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因此，即使配置图是在我们的程序开始之前创建的，kubernetes也保留了事件，当我们的观察器开始从事件提要中读取时，我们收到了事件，就好像配置图是新创建的一样。</p><p id="74c3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">请记住，事件不是永远可用的——需要在一个窗口内检索它们，因此在实际应用中，您可能希望在启动时强制读取配置图。</p><p id="9a55" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们通过一个<code class="fe ma mb mc md b">fallthrough</code>同样地处理<code class="fe ma mb mc md b">Added</code>和<code class="fe ma mb mc md b">Modified</code>——在每种情况下，我们从configmap的<code class="fe ma mb mc md b">Data</code>部分解析出我们需要的值。当然，我们用<code class="fe ma mb mc md b">mutex.Lock()...mutex.Unlock()</code>包围这个部分是为了防止任何潜在的数据竞争。让我们通过使用<code class="fe ma mb mc md b">kubectl edit cm clusters-config</code>编辑配置图，将<code class="fe ma mb mc md b">current.target</code>的值更改为<code class="fe ma mb mc md b">cluster4.endpoint</code>，来展示我们动态检测配置图更改的能力，这<em class="ms">将</em>导致我们的应用程序返回<code class="fe ma mb mc md b"><a class="ae lu" href="https://free.willy" rel="noopener ugc nofollow" target="_blank">https://free.willy</a></code>作为当前端点值:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b5d9" class="mm jz iq md b gy mn mo l mp mq">$ curl https://basic-watcher.us-south.codeengine.appdomain.cloud/config<br/>{"current_endpoint": "<strong class="md ir">https://foo.com</strong>"}<br/>$ kc edit cm clusters-config<br/>configmap/clusters-config edited<br/>$ curl https://basic-watcher.us-south.codeengine.appdomain.cloud/config<br/>{"current_endpoint": "<strong class="md ir">https://free.willy</strong>"}</span></pre><p id="8c57" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">果然，当我编辑配置图，然后卷曲我的应用程序的端点时，更改会立即反映出来，不需要重启应用程序。这提供了许多实用性和便利性，允许应用处理例如动态的配置改变，而不需要进一步的操作员干预、现有请求处理的中断、存储器中状态的丢失等。</p><p id="8f41" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们处理的第三种类型的事件是<code class="fe ma mb mc md b">Deleted</code>——在这种情况下，我们通过将端点的值恢复为原始(在这种情况下，硬编码)默认值来处理配置图的删除:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="acb0" class="mm jz iq md b gy mn mo l mp mq">$ curl https://basic-watcher.us-south.codeengine.appdomain.cloud/config<br/>{"current_endpoint": "<strong class="md ir">https://free.willy</strong>"}<br/>$ kc delete cm clusters-config<br/>configmap "clusters-config" deleted<br/>$ curl https://basic-watcher.33d0tay1up0.us-south.codeengine.appdomain.cloud/config<br/>{"current_endpoint": "<strong class="md ir">https://wazanga.partytime</strong>"}</span></pre><p id="4c78" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这里您可以看到这种行为——其效果是通过使用一组固定的默认值，允许应用程序处理资源的删除(或者根本不存在的资源),从而在我的应用程序中构建弹性。另一种可能更现实的处理<code class="fe ma mb mc md b">Deleted</code>事件的方法是缓存当前活动的配置——例如，如果有人意外删除了配置图，然后从某个旧的(修改前)状态恢复它，您可能不希望丢失这些修改，因此您可以确定由于删除而缓存的配置不会被后续的<code class="fe ma mb mc md b">Added</code>事件覆盖。您只需要花时间找出对您的应用程序和操作环境有意义的流程。</p><h1 id="74d9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">那么我应该只写观察器而不是从卷装载中读取吗？</h1><p id="4757" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">简而言之，没有。我开始考虑为特定的情况编写一个观察器，在这种情况下，我知道我的应用程序需要动态地处理configmap更改(或者更好地说，这看起来是解决我的问题的最简单/最好的方法)。如果你确实有这样的情况，那么观察器可以是一个强大的工具。</p><p id="7250" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这种模式的另一个关键优势是<em class="ms">不局限于配置图</em>。您可以将它用于任何kubernetes API资源——pods、secrets等等。在许多情况下，这些都不是您可以装载的资源，因为卷装载几乎如此容易(甚至根本不可能)。因此，理解观察器(以及您可能出错的地方，比如忘记处理关闭的连接)可以在您的kubernetes应用程序中打开许多可能性。</p><p id="eb60" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是对于许多只需要从配置图中读取的应用程序来说，这是多余的——我敢打赌，大多数应用程序可以在启动时从卷挂载中读取配置图，将配置存储在内存中，然后不再处理卷挂载。这是一种简单得多的编码模式，并且它还具有明确(在配置映射和机密的情况下)您的应用程序所依赖的资源的优势，因为那些依赖关系在部署YAML中被清楚地表达。</p><p id="3c8f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">但是如果您发现需要动态处理kubernetes资源的变化，我希望这篇文章证明是有用的，至少作为一个起点。在第三部分中，我将展示如何通过使用由<code class="fe ma mb mc md b">knative.dev/pkg/configmap</code>及其子包提供的watcher实现来<em class="ms">极大地</em>简化这段代码，在那篇或后续文章中，我希望得到一些Python中的例子。</p></div></div>    
</body>
</html>