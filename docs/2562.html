<html>
<head>
<title>Node.js Build scalable architecture with plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js用插件构建可扩展架构</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-build-scalable-architecture-with-plugins-ffc9bbdf7829?source=collection_archive---------1-----------------------#2019-06-15">https://itnext.io/node-js-build-scalable-architecture-with-plugins-ffc9bbdf7829?source=collection_archive---------1-----------------------#2019-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c4511a9e8dc48ad8aecf852ecf220431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VP6wsuz_2prB60iUstiI_g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@echaparro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃德加·恰帕罗</a>在<a class="ae kf" href="https://unsplash.com/search/photos/organized?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="fb63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何服务器工程师的理想架构都是一组高度模块化和可重用的组件。然而，事实证明这种架构很难实现。当您的代码库不断增长时，尤其如此。一个可能有助于扩展代码的技巧是将可重用组件分成插件。在这篇简短的博文中，我想回顾一下使用这种方法的好处和原因。</p><h1 id="fb6d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是插件？</h1><p id="0d4e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">插件是以可扩展和可重用的方式扩展主应用程序功能的组件。Node.js如此受欢迎的原因之一不仅仅是因为它卓越的架构，还因为它的大量插件包，由社区创建，为我们提供了几乎任何我们可能需要的功能。</p><h1 id="5a4b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分发插件</h1><h2 id="77d4" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">公共插件</h2><p id="4503" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如前所述，绝大多数插件都是以npm包的形式发布的，可以安装到项目的<code class="fe mt mu mv mw b">node_modules</code>文件夹中。所有的公共插件都是通过npm发布的，任何人都可以使用。这种插件最突出的例子之一是<a class="ae kf" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> express </a>。</p><h2 id="bb15" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">私有插件</h2><p id="6cae" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">但是，插件不一定需要是公共的。插件也可以只为私人使用而编写，在组织内部，甚至是一个单独的项目。分发和共享私有插件有不同的方式:</p><ul class=""><li id="3ed0" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nc nd ne nf bi translated"><strong class="ki iu">版本控制系统</strong> —您可以简单地将您的插件添加到您的团队所使用的版本控制中。</li><li id="d12c" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><strong class="ki iu">私有npm包</strong> —许多组织使用npm来打包他们的插件，并且只在组织内部共享。</li></ul><p id="0246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然内部插件可能使用主应用程序的依赖关系，但插件拥有自己的依赖关系图和<code class="fe mt mu mv mw b">package.json</code>也是有益的。这是一个示例图:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fffa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们的项目中有三个<code class="fe mt mu mv mw b">package.json</code>文件:一个用于主应用程序，两个用于<code class="fe mt mu mv mw b">node_modules</code>文件夹中的每个插件。以下是您可能希望采用这种方法的三个原因:</p><ol class=""><li id="913e" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nr nd ne nf bi translated"><strong class="ki iu"> NPM </strong> —我们可以利用NPM将我们的插件作为私有包分发。</li><li id="4267" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nr nd ne nf bi translated"><strong class="ki iu">依赖关系图</strong> —这些插件有自己的依赖关系图，这使得维护项目的依赖关系和解决冲突更加容易。</li><li id="cc9d" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nr nd ne nf bi translated"><strong class="ki iu">更容易导入</strong> —导入这些插件要容易得多。我们不需要使用相对路径(<code class="fe mt mu mv mw b">require('../../utils/moduleA')</code>)，只需要提供插件的名称(<code class="fe mt mu mv mw b">require('pluginA')</code>)。</li></ol><h1 id="db95" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么要把你的代码组织成插件？</h1><h2 id="ad82" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">更好的结构</h2><p id="83c4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">那么为什么要使用插件呢？除了前面的考虑之外，将应用程序的部分功能分离到一个插件中的主要原因之一是整体架构。通过把你的代码分成插件，你把你的代码分成既可重用又松散耦合的单元。它迫使你考虑封装，考虑插件的哪些部分应该暴露给主应用程序。总的来说，它使您的应用程序更具可伸缩性。</p><h2 id="198e" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">无服务器架构</h2><p id="c3ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">无服务器架构可以说是web开发的未来。虽然这种体系结构提供了比传统服务器更好的可伸缩性，但是存在在无服务器功能之间共享公共组件的问题。</p><p id="e5f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无服务器架构中的功能通常是执行特定计算或任务的相对较小的代码片段。它通常被设置为独立的微服务，默认情况下不与项目中的其他功能共享代码。</p><p id="4a00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，由于每个函数都是独立的服务，所以在函数之间共享公共代码可能会很麻烦。原因是当部署时，每个功能运行在一个单独的环境中。</p><p id="bd18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是打包你的插件并把它们作为npm模块分发的好处。你所需要做的就是将你的插件发布为一个私有包，并根据需要安装在你的函数中。</p><h1 id="e9fe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">编写插件</h1><p id="981d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们看看如何编写一个插件来扩展简单的无服务器功能。想象一下这种项目结构。</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b841" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里需要注意一些事情:</p><ul class=""><li id="98b5" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nc nd ne nf bi translated"><code class="fe mt mu mv mw b">serverlessF</code>文件夹包含我们的无服务器功能。这是一个简单的Node.js应用程序。</li><li id="1c5c" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><code class="fe mt mu mv mw b">utils</code>文件夹是为我们项目中多个功能共享的代码准备的。它由不同的插件组成，每个插件都有自己的package.json。</li><li id="7178" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><code class="fe mt mu mv mw b">pluginA</code>作为私有包发布，由我们的无服务器功能安装。</li></ul><p id="fe51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个验证第三方令牌的简单插件的示例代码:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的插件公开了一个验证令牌的函数。这里一个有趣的技巧是第一行。如果你看上面的图表，你会注意到我们的lambda函数包含了<code class="fe mt mu mv mw b">fetch.js</code>,对于我们的目的来说，它用于向第三方API发出各种获取请求。使用<code class="fe mt mu mv mw b">module.parent.require('./fetch')</code>,我们能够通过模仿来自安装插件的父应用程序的<code class="fe mt mu mv mw b">require</code>调用，在我们的插件中使用那个模块。</p><p id="3210" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然使用<code class="fe mt mu mv mw b">module.parent.require</code>看起来像是一个巧妙的技巧，但是很多时候建议不要依赖它。原因是它在我们的无服务器功能和插件之间创建了紧密耦合。如果我们将<code class="fe mt mu mv mw b">fetch.js</code>移动到不同的子文件夹，我们的插件会崩溃。更好的方法是使用依赖注入为我们的插件提供一个<code class="fe mt mu mv mw b">fetch</code>服务的实例:</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c0f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意</strong>:在编写插件时，避免硬连线依赖和创建紧密耦合尤为重要，否则插件的目的就落空了。你可以在这里阅读更多关于模块接线和依赖<a class="ae kf" href="https://isamatov.com/node-module-wiring-dependencies/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h1 id="7862" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7f02" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">作为一个小小的免责声明，你不必把你的应用程序的每一部分都分成一个插件，因为那样会增加不必要的复杂性。然而，如果你有一个很大的依赖图和/或一组内聚模块，将它们分成插件可能是值得的。此外，将代码打包成插件是在无服务器功能之间共享公共代码的好方法。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="54eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nz">原载于2019年6月15日</em><a class="ae kf" href="https://isamatov.com/node-build-scalable-architecture-with-plugins/" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://isamatov.com</em></a><em class="nz">。</em></p></div></div>    
</body>
</html>