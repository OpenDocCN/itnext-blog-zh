<html>
<head>
<title>Async way to the future</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通向未来的异步方式</h1>
<blockquote>原文：<a href="https://itnext.io/async-way-to-the-future-e299b4e0551b?source=collection_archive---------0-----------------------#2017-08-14">https://itnext.io/async-way-to-the-future-e299b4e0551b?source=collection_archive---------0-----------------------#2017-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2f399f38d6a74b5beefeb8ff265e7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I5Zr32SJK0Aic3Ru7EU1KQ.png"/></div></div></figure><p id="09fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从JS中的异步操作开始，只是为了认识到异步一直在发生。所以，欢迎来到延时操作的美好世界。</p><p id="6ce1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript程序几乎总是被分成几个部分，第一部分现在运行，下一部分稍后运行，以响应一个事件。尽管程序是一部分一部分地执行的，但它们都共享程序范围和状态。每当有事件要运行时，<a class="ae kw" href="https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank"> <em class="kx">事件循环</em> </a>就会运行，直到队列为空。In queue包含用户交互处理程序、定时器事件、输入/输出操作等代码块。</p><p id="b14a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在具体的时刻，一次只能从队列中处理一个事件。当一个事件正在执行时，它可能会引发一些后续事件。但是从高层次的角度来看，这些事件似乎是同时运行的，这被称为并发。在许多语言中，这个问题是通过同步和锁定代码的敏感部分来解决的。如此复杂的行为往往需要某种形式的交互协调来防止这种“竞态条件”。</p><h2 id="3e83" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">复试</h2><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/abe0f2a2b0cf527764cbd743d9df01ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5y5SQxnhTF_9Z873HOgbJw.png"/></div></div></figure><p id="a7a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调是JS中异步的基本单位。回调是描述现在应该做什么，以及在某种情况下以后应该做什么的最简单的方式。这种方法有几个缺点，尤其是在大型项目中。</p><ol class=""><li id="96ac" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">我们的大脑以顺序的、阻塞的、单线程的语义方式思考，但是回调以一种相当非线性的方式表达异步流，这使得对这样的代码进行正确的推理更加困难。我们需要一种方法，像我们的大脑一样，以更加同步、有序、阻塞的方式来表达异步。</li><li id="698c" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">回调受到<em class="kx">控制反转的影响。它通常将控制权交给某个第三方库来调用你的程序的延续。这给我们带来了一系列令人不安的信任问题，比如回调被调用的次数是否比我们预期的要多。</em></li></ol><p id="383b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调是我们长期做大事的武器，但是<em class="kx">未来</em>需要更加复杂和易于维护的模式。</p><p id="1d75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们能取消反转控制 的<a class="ae kw" href="https://msdn.microsoft.com/en-us/library/ff921087.aspx" rel="noopener ugc nofollow" target="_blank"> <em class="kx">反转会怎么样呢？如果我们不是将程序的延续交给另一方，而是期望它返回给我们一种能力，让我们知道它的任务何时完成，然后我们的代码可以决定下一步做什么，会怎么样？</em></a></p><h2 id="b470" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">承诺</h2><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/ddcb137769166fc99753ac559ecf895b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGf7lcMcOtw9LQC42CPRPg.png"/></div></div></figure><p id="6d0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">promise——它是一个特殊的对象，包含关于自身状态的信息。最初，它具有<em class="kx">挂起</em>状态，在— <em class="kx">满足</em>或<em class="kx">拒绝</em>之后(取决于包含逻辑)。因此，您可以添加两种类型的回调:</p><pre class="ls lt lu lv gt ml mm mn mo aw mp bi"><span id="d188" class="ky kz iq mm b gy mq mr l ms mt"> Promise         +----------+<br/>+-------+        |fulfilled |<br/>|pending|   =&gt;   +----------+<br/>+-------+        | rejected |<br/>                 +----------+</span></pre><p id="773a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">承诺创建的主要语法</p><pre class="ls lt lu lv gt ml mm mn mo aw mp bi"><span id="9e01" class="ky kz iq mm b gy mq mr l ms mt">var promise = new Promise(function(resolve, reject) {<br/>  // This function will be executed automatically<br/>  //<!-- --> It's body may contain any async code. After successful<br/>  // completion <em class="kx">resolve</em> should be called, after error - <em class="kx">reject</em>.<br/>}).then(<br/>  onFulfilled, // callback triggered if <em class="kx">resolve</em> action<br/>  onRejected // callback triggered if <em class="kx">reject</em> action<br/>);</span></pre><p id="655a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们并没有摆脱回调，只是将回调的编排重定向到一个位于我们和另一个实用程序之间的可信中介机制。</p><p id="364d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Promise链向我们展示了在聚合数据序列中表达异步流的更好方式。这是我们大脑计划和维持延迟操作的一种常见方式。</p><p id="4666" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这不是结束。承诺成为了非常有趣的异步模式的基础，比如<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> <em class="kx">异步/await </em> </a>。</p><h2 id="6f46" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">异步函数</h2><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/74f83d66036cd8b22ce98644ccedf048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EXcdtjTajDmfvE3v96hJsw.png"/></div></div></figure><p id="212c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多关于用async/await代替promises的传言。我们应该在开发过程中使用它吗？</p><p id="94c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">规格<strong class="ka ir"> ES2015 </strong>内的所有特性可在<a class="ae kw" href="http://es6-features.org/#Constants" rel="noopener ugc nofollow" target="_blank"> <em class="kx">此处</em> </a>查看。这个规范命名为ES6。有时人们认为ES6中没有的东西都是ES7特性的一部分。是对周围事物的错误理解。你可以在这里找到关于ES2016 <a class="ae kw" href="http://2ality.com/2016/01/ecmascript-2016.html" rel="noopener ugc nofollow" target="_blank">包含哪些内容的信息。所以一般只包含两个主要特性:<em class="kx">取幂运算符</em> <strong class="ka ir"> ** </strong>和<em class="kx">array . prototype . includes</em>。而且完全没有提到这个列表中的<em class="kx"> async/await </em>。</a></p><p id="87da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，async/await一般是什么？一般来说——这是一个<strong class="ka ir">承诺</strong>。</p><p id="1b9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你将一个函数标记为async时，它的返回值是一个承诺值。每一件东西，里面都标有await，应该返回承诺值。这一时刻对于理解async/await主要原理至关重要。</p><pre class="ls lt lu lv gt ml mm mn mo aw mp bi"><span id="0928" class="ky kz iq mm b gy mq mr l ms mt">export function getPayload = <strong class="mm ir">async</strong> (url) =&gt; {<br/>  const {payload, success} = <strong class="mm ir">await</strong> fetch(url);<br/>  if (success) {<br/>    dispatch({type: 'SUCCESS'});<br/>  } else {<br/>    dispatch({type: 'FAILURE'});<br/>  }<br/>}</span></pre><h2 id="2d64" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">它是如何工作的</h2><p id="096c" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">这里的要点是定义一个带有异步标志的函数，它不仅适用于一般函数，也适用于箭头函数、类、静态函数。主体中提到的wait标志表示主代码应该等待，直到某个事件发生。它应该是异步标记之前的承诺，应该被解决或拒绝。只有在这段主代码继续运行之后。Await的作用与<code class="fe na nb nc mm b">.then</code>函数对Promise的作用完全相同。但是这种方法的主要好处是我们不需要任何回调来处理返回值。这给人一种使用同步代码的感觉。</p><p id="ce01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种同步的外观让你感觉很自然，你在家里就可以到处使用<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank"><em class="kx"/></a><em class="kx"/><em class="kx">(这其实是真的)。这是捕捉错误的唯一方法。</em></p><h2 id="1285" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated"><a class="ae kw" href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" rel="noopener ugc nofollow" target="_blank">为什么更好？</a></h2><ol class=""><li id="e014" class="lw lx iq ka b kb mv kf mw kj nd kn ne kr nf kv mb mc md me bi translated"><strong class="ka ir">简洁干净</strong>。我们不必编写<code class="fe na nb nc mm b">.then</code>，创建一个匿名函数来处理响应，或者给一个我们不需要使用的变量起一个名字<code class="fe na nb nc mm b">data</code>。我们也避免嵌套我们的代码。</li><li id="0b02" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><strong class="ka ir">错误处理</strong>。Async/await使得用同一个构造处理同步和异步错误成为可能，古老的<code class="fe na nb nc mm b">try/catch</code>。</li><li id="521b" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><strong class="ka ir">条件句。</strong>构造条件逻辑要干净得多，在回调中实现它。所有筑巢的地狱。</li><li id="4cb8" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><strong class="ka ir">中间值。</strong>只需放入一个断点，就可以方便地操作中间异步数据。而且你可以确定代码会在那里停止(不是作为承诺的箭头函数回调)。</li><li id="112d" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><strong class="ka ir">错误堆栈。</strong>从承诺链返回的错误堆栈没有给出错误发生的线索。更糟糕的是，这是一种误导。然而，来自async/await的错误堆栈指向包含错误的函数。</li><li id="d37b" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><strong class="ka ir">调试。</strong>有时，使用开发者工具按钮，如步入、步出、步出等，是捕捉bug的好机会。您可以通过async/away方法充分利用它们。但是当你用承诺的时候它们就没用了。</li></ol><p id="57ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果呢？…</p><h2 id="8a97" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated"><strong class="ak">等待失踪</strong></h2><pre class="ls lt lu lv gt ml mm mn mo aw mp bi"><span id="6378" class="ky kz iq mm b gy mq mr l ms mt"><strong class="mm ir">async</strong> function get(a) {<br/>  return a;<br/>}<br/>get('hi'); // 'hi'<br/>// behaves completely in sync way, just returns a</span></pre><h2 id="8b79" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">顺序</h2><pre class="ls lt lu lv gt ml mm mn mo aw mp bi"><span id="e05b" class="ky kz iq mm b gy mq mr l ms mt"><strong class="mm ir">async</strong> function getResult() {<br/>  const names = <strong class="mm ir">await</strong> getNames(); // wait till resolve<br/>  const statuses = <strong class="mm ir">await</strong> getStatusesFor(names); // wait till resolve<br/>  return statuses;<br/>}<br/>getResult();<br/>// first waits for resolving getNames continue to run<br/>// then resolving getStatusesFor, after resolving returns result<br/>// such code will be executed step by step</span></pre><h2 id="02d8" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">平行的</h2><pre class="ls lt lu lv gt ml mm mn mo aw mp bi"><span id="6790" class="ky kz iq mm b gy mq mr l ms mt"><strong class="mm ir">async</strong> getAggregatedData() {<br/>  const [names, profiles] = <strong class="mm ir">await</strong> Promise.all([getNames(), getProfiles()]);<br/>  return {names, profiles};<br/>}</span></pre><h2 id="bff3" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">现代浏览器</h2><figure class="ls lt lu lv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/2aebb95a964029edce6fa0ddaf9fe20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXO3w55nWOS8E51lTrXULw.png"/></div></div></figure><p id="841e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在现代浏览器中，大约93%-99%的ES2015实现已经完成(Safari现在是<a class="ae kw" href="https://kangax.github.io/compat-table/es6/" rel="noopener ugc nofollow" target="_blank">和</a>的领导者)。当你开始一个新项目时，这是一个好兆头。但是，不幸的是，对于async/await实现，您总是需要使用外部工具(如Babel)来编译这样的代码。有时这会增加多余的复杂性。使用<a class="ae kw" href="https://medium.com/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435" rel="noopener"> <em class="kx">生成器</em> </a>可以有效解决大多数异步问题。但这是一个不同的故事。</p><h2 id="d7a0" class="ky kz iq bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">NodeJS</h2><p id="f97c" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">它是在v.7.6中正式引入的。所以，是时候开箱即用了:)</p></div></div>    
</body>
</html>