<html>
<head>
<title>Outside-In or Inside-Out? London or Chicago School? — Part 1: Greenfield Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从外向里还是从内向外？伦敦还是芝加哥学校？—第1部分:绿地项目</h1>
<blockquote>原文：<a href="https://itnext.io/outside-in-or-inside-out-london-or-chicago-school-part-1-greenfield-projects-d324390a0dbd?source=collection_archive---------6-----------------------#2020-04-26">https://itnext.io/outside-in-or-inside-out-london-or-chicago-school-part-1-greenfield-projects-d324390a0dbd?source=collection_archive---------6-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b5bd85ea83640eae23858821f1504365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*37rsO6AasJc20yuI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">查尔斯·波斯蒂奥在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3981" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然标题可能有点误导，但本文并不是要解释软件开发中的这两种方法，而是一组来自创建大型应用程序或大型重构的经验的观点。如果你有兴趣重温一下关于<strong class="kf ir">伦敦</strong>和<strong class="kf ir">经典(芝加哥)</strong>学校的知识，你可以在这里找到一些有用的信息和链接:<a class="ae kc" href="https://softwareengineering.stackexchange.com/questions/166409/tdd-outside-in-vs-inside-out" rel="noopener ugc nofollow" target="_blank">https://software engineering . stack exchange . com/questions/166409/TDD-outside-in-vs-inside-out</a></p><h1 id="f0a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一款全新的应用</h1><p id="3ca4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我将向你展示，在构建一个应用程序时，你如何应用London和Classic两个原则，并指出两者的优缺点。虽然这将显示在应用程序的一个比例上，但它并没有描述以一种均匀分层的方式编写整个应用程序的原理。这个概念假设你理解模块化的方法，并且你理解从API到视图层或者相反的场景、组件、epic的构建原理。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/632b55ba6a573cb235383d4c859d83a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*LYGqz01fwBAxx9FGcN37lA.png"/></div></figure><p id="66ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将讨论构建模块的原则。我的首选方法是一如既往的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/module-oriented-architecture-4b54c8976415"> <strong class="kf ir">面向模块的架构(MOA) </strong> </a>。</p><p id="e539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将开始一段旅程，从内部和外部开始，浏览应用程序的相同<strong class="kf ir">干净层:</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/fef8a9f2a153c8a8345cb1aba4b246d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*3TRlglqSR9u-6TKHyrC2Fg.png"/></div></figure><h1 id="d2ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从里到外</h1><p id="1e54" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">了解了你的<strong class="kf ir">域逻辑</strong>和<strong class="kf ir">域模型</strong>，你可能总会被诱惑从内部的<strong class="kf ir">开始。当公司希望利用现有的后端服务来数字化他们的业务时，这是常见的情况，这些后端服务与定制的客户端或有时与他们现有的网络存在一起工作。</strong></p><h2 id="d2e4" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">好人</h2><ul class=""><li id="6138" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated"><strong class="kf ir">从</strong>开始非常清晰简单，了解后端通信层后，您可以从通用网络层(如果需要)开始，应用TDD以及存根API响应</li><li id="ef43" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir">递增复杂性</strong>，易于遵循</li><li id="06cb" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">您能够从开发的非常早期阶段测试集成</li></ul><h2 id="5453" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">坏事</h2><ul class=""><li id="94f5" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated">在<strong class="kf ir">用例</strong>和<strong class="kf ir">视图</strong>之间的某个地方，你将开始捕捉并试图解决从<strong class="kf ir">领域逻辑</strong>和<strong class="kf ir">视图</strong> (UX)返回的概念差异，在那里产品所有者占主导地位。</li><li id="b690" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">因为底层将总是准备、测试和工作的，所以你不会总是为它们创建模拟，从而维护任何更高的组件的独立可测试性，这将特别影响这种潜在行为测试。因此，<strong class="kf ir">你可能不得不调试所有层，而不是在实际层上捕捉问题</strong></li><li id="7ce8" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">很多时候，变化会变得很深，很多时候，整个概念也必须改变。<strong class="kf ir">当较低层发生变化时，它们将需要一堆接口的变化直到顶层</strong>，导致同一层中许多痛苦的横向变化</li><li id="2a6b" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">将变更的实施转移到底层和备份可能<strong class="kf ir">严重影响预期的交付进度和成本</strong></li><li id="b367" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir">每一次重构之旅都会无意中降低代码的质量</strong></li><li id="de73" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">你可能会得到一些根本不需要的代码(<strong class="kf ir"> YAGNI </strong>)</li></ul><h2 id="34ab" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">丑陋的</h2><ul class=""><li id="197c" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated">你可能很晚才发现，如果没有巨大的努力和成本，用户特性是不可实现的</li></ul><h1 id="c113" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">由外向内</h1><p id="1f39" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当你从UX、从与用户相关的商业规则、从产品的角度出发时，从外部、从下往上开始是很自然的。</p><h2 id="858c" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">好人</h2><ul class=""><li id="3458" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated">你将从用户需求开始，也就是说，从产品开始，从应用程序应该如何工作开始</li><li id="1983" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">沿着这些层，你总是能够向下模仿松耦合连接，从而<strong class="kf ir">保持每一层都处于完全可测试的状态</strong>并且保持高度的模块化，这意味着组件级的可维护性和可变性</li><li id="ab1b" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">TDD将会像由内向外的方法一样流畅，但是<strong class="kf ir">在它之上，你将能够从一开始就应用所有层的完整BDD </strong></li><li id="6b7c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">随着API的每一步发展，你会更容易、更快地发现是否需要改变。这给了API更多的时间来适应(或被另一个通常来自中间件的API所取代),并且API的改变不需要任何代码的改变，就像从内向外改变一样</li><li id="f7a9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">因此，将不会有太多的上下摆动层的变化</li><li id="18a0" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">开发人员将改善用户需求和API功能之间的联系，如果已经存在的话</li><li id="a562" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir"> API可以根据产品需求进行定制，而不是相反</strong></li></ul><h2 id="2e2e" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">坏事</h2><ul class=""><li id="1218" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated">任何一层的最终变化都不可能完全避免</li><li id="ec51" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">尽管深入各层会花费大量的时间，但是开发人员仍然需要根据现有的API评估用户需求，并在需要时引入潜在的变化</li><li id="5855" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir">通常需要更好的开发人员，在TDD、BDD和应用模拟方面非常熟练</strong></li></ul><h2 id="431b" class="mk lc iq bd ld ml mm dn lh mn mo dp ll ko mp mq lp ks mr ms lt kw mt mu lx mv bi translated">丑陋的</h2><ul class=""><li id="23e1" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated">如果你自己想到了什么，请告诉我…</li></ul><h1 id="73ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">判决？</h1><p id="1268" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，我会说答案很简单:Outside-In是一个强有力的赢家。但是你真的需要它的所有这些优点吗？有没有这样的例子，在不太需要技能的情况下，由内向外也能做得很好？无论如何，这里肯定有一些:</p><ul class=""><li id="197b" class="mw mx iq kf b kg kh kk kl ko nk ks nl kw nm la nb nc nd ne bi translated">项目相对较小</li><li id="a07a" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">项目由领域逻辑决定</li><li id="6c78" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">你需要从头开始重构</li></ul><p id="86c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，我相信实际的项目和案例研究可以给出更好的答案，也许可以提供一个不能简单地用一句话来概括的结论。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><h1 id="652c" class="lb lc iq bd ld le nu lg lh li nv lk ll lm nw lo lp lq nx ls lt lu ny lw lx ly bi translated">现有项目怎么样？</h1><p id="7450" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">绝对的！我们可能并不总是拥有从头开始应用的奢侈。事实上，对于大多数工程师来说，他们会加入一个团队，这个团队开发一个应用程序，并且已经维护它很多年了。</p><p id="1c57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在<a class="ae kc" href="https://medium.com/@poksi/outside-in-or-inside-out-part-2-refactoring-existing-projects-dcf7f2ef4d2a" rel="noopener"> <strong class="kf ir">第二部分</strong> </a>中了解一下这种情况下的方法和做法。</p></div></div>    
</body>
</html>