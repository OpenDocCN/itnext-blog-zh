<html>
<head>
<title>Easy Modular Monolith — Part 5— JWT Authentication/Authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简易模块化整体结构—第5部分— JWT认证/授权</h1>
<blockquote>原文：<a href="https://itnext.io/easy-modular-monolith-part-5-jwt-authentication-authorization-f7a0a275226f?source=collection_archive---------1-----------------------#2021-11-11">https://itnext.io/easy-modular-monolith-part-5-jwt-authentication-authorization-f7a0a275226f?source=collection_archive---------1-----------------------#2021-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="36d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di">在</span> ModularMonolith中，我们将使用<strong class="jp ir"> JSON Web Token </strong>和<strong class="jp ir"> Asp核心身份</strong>实现<strong class="jp ir">认证</strong>和<strong class="jp ir">授权</strong>。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/8c0f99b78df88495328adfeaf88f14db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRy34ot5nZdvAvMHyEmH7g.jpeg"/></div></div></figure><h2 id="f4b7" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">在我们开始一个小理论之前:</h2><p id="cf7f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">认证</strong>—是关于确认你的ID。如果你去银行，你必须出示你的身份证来证明你是你——在我们的系统中也是一样的。我们将通过发送用户名和密码来实现这一点——如果它们与我们系统中的匹配，您将获得一个访问令牌。</p><p id="9960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">授权</strong> —这是关于你拥有什么样的特权/角色。基于此，您将获得(或不获得)对系统某些部分的访问权。</p><h2 id="7fc1" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">完整示例:</h2><p id="7cf3" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你来办公室用<strong class="jp ir">你的id磁卡(身份证明)</strong>通过正门(<strong class="jp ir">认证</strong>)。当你在公司时，基于你在公司的角色(软件开发人员/测试人员等。)，您将可以访问分配给您的职位的资源(工具/系统/)。如果你试图访问你的角色之外的资源，那么你将被拒绝(你不能进入你老板的办公室——你的卡不允许你绕过门)<strong class="jp ir">授权</strong>)。</p><h2 id="1776" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">JSON Web令牌:</h2><blockquote class="me mf mg"><p id="03ba" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">JSON Web Token (JWT)是一个开放标准(RFC 7519 ),它定义了一种紧凑的自包含方式，以JSON对象的形式在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。jwt可以使用秘密(使用<strong class="jp ir"> HMAC </strong>算法)或使用<strong class="jp ir"> RSA </strong>或<strong class="jp ir"> ECDSA </strong>的公钥/私钥对进行签名。</p></blockquote><h2 id="2908" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated"><a class="ae ml" href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&amp;tabs=visual-studio" rel="noopener ugc nofollow" target="_blank">ASP.NET核心身份</a>:</h2><p id="4644" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">是一个框架，它:</p><blockquote class="me mf mg"><p id="e062" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated">管理用户、密码、配置文件数据、角色、声明、令牌、电子邮件确认等。</p></blockquote><h1 id="11a4" class="mm lh iq bd li mn mo mp ll mq mr ms lo mt mu mv lr mw mx my lu mz na nb lx nc bi translated">体系结构</h1><p id="3b65" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">要求:</strong></p><ul class=""><li id="e7e9" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">用户能够注册一个新账户。</li><li id="719b" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">用户能够使用用户/密码登录。(<strong class="jp ir">认证</strong>)</li><li id="b37e" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">基于他的角色，用户应该能够访问一些受保护的资源。(<strong class="jp ir">授权</strong>)</li></ul><h2 id="1b21" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">实施:</h2><p id="4aa1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">首先，让我们创建一个新模块，负责处理我们系统中的所有用户帐户。它的结构将和其他的几乎一样。<br/>在这个模块中，目前我们还没有一个领域项目。我们没有它，因为<strong class="jp ir"> Asp核心标识</strong>为我们处理我们试图实现的功能所需的所有域对象。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0b174248a6bf5a8dd2b0784df8749347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*PuiIIktvtTyn6Pq0DS07WQ.png"/></div></figure><h2 id="5cd1" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">大幅改进:</h2><p id="7138" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">到目前为止，只有经过身份验证的用户才能访问我们的资源端点，让我们改进我们的Swagger文档页面，使发送经过身份验证的请求更加容易。它将包含一个新的“<strong class="jp ir">授权</strong>”按钮，这将允许我们把一个JWT令牌放在那里，该令牌将在每个请求的标题中自动发送。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ns"><img src="../Images/e50e26b19158374e0f67edd3f7c6da7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8Sqy5w5lEuJ1ZNyrX-Slw.png"/></div></div></figure><p id="a68e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">负责这个额外按钮的代码在<strong class="jp ir">第47行</strong>中定义(代码如下)。<br/>没有火箭科学:<br/>首先，我们需要添加安全定义，告诉Swagger通过HTTP头发送JWT。之后，我们应该添加SecurityRequirements，告诉Swagger我们希望将我们的定义全局应用到它的每个端点。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ec94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，斯瓦格准备好了。</p><p id="17b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为身份验证的准备，我们需要启用它。很简单——<strong class="jp ir">第89行和第90行</strong>这样做。</p><h2 id="16db" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">证明</h2><p id="730d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了提供身份验证(通过用户名和密码登录)，我们将使用一个名为<strong class="jp ir"> ASP核心身份的框架的一部分。</strong> <br/>整个框架可用于交付完整的账户管理功能(包括登录/注册视图等前端部分)。<br/>在我们的场景中——由于ModularMonolith是WebApi，我们将只使用它的一部分。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第21行</strong>定义了我们身份功能的注册。重要的是，我们使用<strong class="jp ir"> AddIdentityCore </strong>而不是它的完整版本AddIdentity，它注册的比我们需要的多得多(角色/cookie认证模式等)。</p><p id="c77f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将注册<strong class="jp ir"> UserManager </strong>类，该类提供了几个重要的方法，如:</p><ul class=""><li id="a542" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">用户群</li><li id="b7a5" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">验证用户名和密码</li></ul><p id="673a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第24行</strong>中，我们有一个大的“配置”方法，围绕用户帐户的要求设置一些基本的东西。当我们尝试调用注册用户方法时，这些选项将被验证。如果验证失败，我们将收到一条错误消息。</p><p id="ea69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第45行</strong>注册将要使用的认证模式。在我们的例子中，按照JWT的方式，我们注册了JWTBearer模式。<br/> <strong class="jp ir">第50行</strong>注册一个中间件，该中间件将验证用<strong class="jp ir">【Authorize】</strong>属性修饰的每个请求。</p><h2 id="2095" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">注册用户帐户</h2><p id="0f3c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">注册Asp核心身份基本组件后，让我们转到一个允许我们创建用户帐户的命令。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="444c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常简洁的命令处理程序——它所做的只是调用UserManager类的Create方法。因此，我们可以得到一个成功的结果或验证错误。这些验证错误反映了我们在注册Asp核心身份时选择的设置。如果有任何错误，我们抛出我们的自定义异常，它将包装所有的身份错误，然后作为一个用户友好的消息。</p><h2 id="1689" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">注册</h2><p id="721a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Login命令更复杂，因为它不仅使用Identity来验证我们的用户，还使用JWTService来生成授权令牌。<br/>我们来看看:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fa7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们试图找到一个用户。如果它存在，我们会尝试验证它的密码。如果匹配，我们生成一个带有声明的JWToken(我们应该返回哪一个取决于业务需求。)添加声明非常简单，您所要做的就是在列表中添加一个新项目。<br/>如果一切正常，我们返回一个JWT令牌，稍后将用于验证对<strong class="jp ir">【授权】</strong>端点的访问。</p><h2 id="df4a" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated"><strong class="ak"> JWT服务</strong></h2><p id="73da" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">JWT代币一代的核心在于JWT服务。由于这是一个实践教程，我不会在这里深入理论。最重要的部分是，要生成安全令牌，我们需要一些东西来签名。</p><p id="c87d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的示例中，我们将使用对称密钥对令牌进行签名(一个密钥用于签名和验证)。在我们的例子中，这是一个很好的解决方案，因为只有一个服务——ModularMonolith——负责创建和验证每个令牌。</p><p id="77ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在其他情况下，我会推荐非对称密钥，因为它们在分布式系统中更安全。</p><p id="5ee9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的示例中，令牌的颁发者和受众是相同的，因为ModularMonolith是令牌的颁发者，但同时，它也是令牌的受众，因为它将验证令牌。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="044a" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">验证改进</h2><p id="4c97" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了能够将<strong class="jp ir"> Asp核心标识</strong>附加到我们的异常处理管道，我们必须对我们的<strong class="jp ir">exceptionlogginmiddleware</strong>做一点修改。<br/>首先让我们创建一个新的类，它将负责在出错时返回扩展消息。</p><p id="9f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它与基本集合的区别在于，它包含一个额外的集合来存储验证消息。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="af18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将创建一种新的AppException类型。姑且称之为<strong class="jp ir"> ValidationException </strong>。每次我们想要返回额外的消息时，我们都会使用这个基类。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c6f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是它的一种用法:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0d69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为构造函数中的参数，我们将接受<strong class="jp ir"> IdentityError </strong>列表，该列表是在尝试注册新帐户时返回的<strong class="jp ir"> ASP核心标识</strong>类，并且存在任何错误。</p><p id="78c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切准备就绪，让我们更新<strong class="jp ir">exceptionlogginmiddleware</strong>来处理我们的新异常类型。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3c1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第6行中，我们添加了一个新的语句，现在将检查我们试图处理的异常是否是ValidationExcception。如果是，那么我们返回新的<strong class="jp ir"> ValidationErrorMessage </strong>类，它将以用户友好的格式包含所有验证错误。</p><p id="6b04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理异常类型的顺序在这里很重要，因为<strong class="jp ir"> ValidationException </strong>属于<strong class="jp ir"> AppException </strong>类型——如果我们在<strong class="jp ir"> ValidationException </strong>之前处理它，我们就永远不会得到扩展的错误消息。</p><h2 id="39ad" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">入口点—用户控制器</h2><p id="c09a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这个很简单。它包含两种方法——一种用于注册新用户，另一种用于登录。<br/>看一看:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="b4d5" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated"><strong class="ak">如何保护端点？</strong></h2><p id="7deb" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">很简单:<br/> <strong class="jp ir">【授权】</strong>属性会为我们做好一切。<br/>我们可以在整个控制器上添加这个属性，将授权应用于控制器中的所有方法，或者如果我们想保护一些方法而不保护其他方法，可以将授权应用于控制器中的方法。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dc65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【Authroize】</strong>属性更加强大，可以用于基于角色/策略的授权。这个主题将是未来文章的一部分。</p><h2 id="a7d6" class="lg lh iq bd li lj lk dn ll lm ln dp lo jy lp lq lr kc ls lt lu kg lv lw lx ly bi translated">摘要</h2><p id="85fc" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">尽管整篇文章很长，但是实现认证/授权很简单。我们的新用户模块现在包含:</p><ul class=""><li id="8c7b" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">注册</li><li id="d983" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">注册</li><li id="9b84" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">JWT发电服务</li><li id="fab7" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">JWT令牌验证中间件</li></ul><p id="fe0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这四个功能足以提供对带有端点的ModularMonolith的安全访问。</p><h1 id="1837" class="mm lh iq bd li mn mo mp ll mq mr ms lo mt mu mv lr mw mx my lu mz na nb lx nc bi translated">完整代码可在此处获得:</h1><p id="8826" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><a class="ae ml" href="https://github.com/Ridikk12/ModularMonolith/tree/authentication" rel="noopener ugc nofollow" target="_blank">https://github . com/ridikk 12/ModularMonolith/tree/authentic ation</a></p><h1 id="be36" class="mm lh iq bd li mn mo mp ll mq mr ms lo mt mu mv lr mw mx my lu mz na nb lx nc bi translated">上一个:</h1><div class="nv nw gp gr nx ny"><a href="https://ridikk12.medium.com/easy-modular-monolith-part-4-global-exception-handling-8355cc4905d4" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">简易模块化整体结构—第4部分—全局异常处理</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">全局异常处理是我们将在模块化应用程序中实现的下一个特性。它将允许我们…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">ridikk12.medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om le ny"/></div></div></a></div><h1 id="9ab1" class="mm lh iq bd li mn mo mp ll mq mr ms lo mt mu mv lr mw mx my lu mz na nb lx nc bi translated">在下一部分:</h1><ul class=""><li id="29f5" class="nd ne iq jp b jq lz ju ma jy on kc oo kg op kk ni nj nk nl bi translated">模块之间的直接通信。</li></ul><h1 id="940b" class="mm lh iq bd li mn mo mp ll mq mr ms lo mt mu mv lr mw mx my lu mz na nb lx nc bi translated">将来(此列表可能会更改):</h1><ul class=""><li id="e01c" class="nd ne iq jp b jq lz ju ma jy on kc oo kg op kk ni nj nk nl bi translated">发件箱改进。</li><li id="e574" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">域事件。</li><li id="b186" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">单元/集成测试。</li><li id="3e3a" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">存储配置。</li><li id="79c9" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">模块之间的直接通信。</li><li id="ee8d" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">数据库方法(多个数据源)。</li><li id="6272" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">准备微服务(用RabbitMq代替MediatR)。</li><li id="c842" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">迁移到微服务。</li></ul><h1 id="882f" class="mm lh iq bd li mn mo mp ll mq mr ms lo mt mu mv lr mw mx my lu mz na nb lx nc bi translated">参考资料:</h1><div class="nv nw gp gr nx ny"><a href="https://jwt.io/introduction" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">JWT。IO - JSON Web令牌简介</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">新:免费获得JWT手册，深入学习jwt！JSON Web Token (JWT)是一个开放标准(RFC 7519 ),它…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">jwt.io</p></div></div><div class="oh l"><div class="oq l oj ok ol oh om le ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&amp;tabs=visual-studio" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">ASP.NET核心的身份介绍</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">由里克安德森ASP.NET核心身份:是一个API，支持用户界面(UI)登录功能。管理用户…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">docs.microsoft.com</p></div></div><div class="oh l"><div class="or l oj ok ol oh om le ny"/></div></div></a></div></div></div>    
</body>
</html>