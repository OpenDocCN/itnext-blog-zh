<html>
<head>
<title>Create Go based Docker Multiarch Images The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以简单的方式创建基于Go的Docker多架构图像</h1>
<blockquote>原文：<a href="https://itnext.io/create-go-based-docker-multiarch-images-the-easy-way-74a35cf62c0?source=collection_archive---------2-----------------------#2022-04-29">https://itnext.io/create-go-based-docker-multiarch-images-the-easy-way-74a35cf62c0?source=collection_archive---------2-----------------------#2022-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="292d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不使用多阶段Dockerfile</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a6a5c33c9b0ee2e581fb8a0b112e1109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGvXMTEFlBMzIlhy9EN0xg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由Renee French创建的原始地鼠图像，使用由Maria Letta创建的地鼠图像</figcaption></figure><p id="2b84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章是写给那些使用Docker和Go的人的。准确地说……对那些在Docker中使用Go的人来说。</p><p id="5b2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章的目的是给你一个想法，如何在不使用多阶段Docker文件的情况下，尽可能小和尽可能快地制作多架构Docker图像。</p><p id="95a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目标是让您的Docker图像就像下面的<strong class="js iu"> Postgres </strong>的图像一样，您可以看到8种不同的架构。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi le"><img src="../Images/994e43ecc4060e67dd0a4764937d945f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJpDov-Jy9xINlBeehLAwQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">截图来自DockerHub，Postgres图片</figcaption></figure><p id="3e65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的主要思想是预先构建二进制文件，然后使用尽可能简单的Dockerfile。从那个docker文件开始构建将会非常快，并且你的图像将会尽可能的小。<br/>这样做的原因:你<strong class="js iu">能</strong>让你的二进制文件尽可能的小，看看下面的文章就知道了。</p><div class="lf lg gp gr lh li"><a rel="noopener  ugc nofollow" target="_blank" href="/shrinking-go-executable-9e9c17b47a41"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">收缩Go可执行文件</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">使用Go 1.18和UPX</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">itnext.io</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw ky li"/></div></div></a></div><p id="1edb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将这篇文章分为两个主要部分:二进制准备和docker映像构建。</p><p id="1775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为该方法使用了<code class="fe lx ly lz ma b">buildx</code>命令，所以您需要事先运行<code class="fe lx ly lz ma b">docker buildx create</code>(前提是您之前没有运行过它)。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="fde2" class="mi mj it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">二元制备</h1><p id="2939" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">以您喜欢的方式构建您的二进制文件，并将它们放入适当的目录中。通过<em class="nl">正确的目录</em>我的意思是:如果你想让你的Docker镜像成为一个<code class="fe lx ly lz ma b">linux/amd64</code>镜像，你需要把二进制文件放到<code class="fe lx ly lz ma b">linux/amd64</code>目录中。</p><p id="bfb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关键是将二进制文件生成到与Docker OS/ARCH描述相匹配的目录中。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2c88" class="mi mj it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">Docker形象大厦</h1><p id="f820" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">然后，您的Docker文件将使用这种“匹配”来生成带有适当的二进制文件的Docker映像。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="524d" class="mi mj it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">如何用最简单的方法做这件事</h1><p id="353c" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">为了使它尽可能自动化，你可以使用一个简单的名为<code class="fe lx ly lz ma b">create.sh</code>的脚本。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="54d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用目录名作为二进制文件和Docker映像的名称，因此你可以在第<strong class="js iu">行</strong>中看到脚本正在获取实际的目录名。<br/>在<strong class="js iu">第2行和第3行</strong>你可以看到脚本正在为<code class="fe lx ly lz ma b">amd64</code>和<code class="fe lx ly lz ma b">arm64</code>生成两个二进制文件，并将它们放入适当的目录，匹配Docker平台架构(来自第9行)。<br/>在<strong class="js iu">第5行和第6行</strong>上，该脚本使用UPX使那些构建的二进制文件尽可能小(参见本文开头的链接文章)。<br/> <strong class="js iu">第8行</strong>删除之前的Docker图像。<br/> <strong class="js iu">第9行</strong>，最后创建合适的Docker多arch映像，并将其推送到DockerHub。</p><p id="183a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Dockerfile文件非常简单。它只是复制正确的二进制文件，仅此而已。</p><p id="4b8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，<code class="fe lx ly lz ma b">system_service</code>是目录的名称和生成的二进制文件的名称。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8853" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你运行这个脚本时，它会使用docker文件并为你做好一切。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="d1cf" class="mi mj it bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">摘要和两个现实世界例子的链接。</h1><p id="7f0d" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">通过使用这种方法，您可以利用您的机器的能力(构建二进制文件，使它们更小，等等。)并使整个过程尽可能快，你的图像尽可能小。</p><p id="1a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nl">例如(截至2022年4月)，Alpine linux没有针对arm64的UPX，因此在使用多阶段Dockerfile时，您不能使用UPX。</em></p><h1 id="e1a8" class="mi mj it bd mk ml no mn mo mp np mr ms mt nq mv mw mx nr mz na nb ns nd ne nf bi translated">例子</h1><p id="5c93" class="pw-post-body-paragraph jq jr it js b jt ng jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj nk kl km kn im bi translated">这是一个使用这种方法的服务的Github存储库(这个脚本有几行代码，比如用正确的版本更新文件等等。，但那是我内部的事情)。</p><div class="lf lg gp gr lh li"><a href="https://github.com/petrjahoda/system_service" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">GitHub-petrjahoda/system _ service</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">Go服务会在第一次运行时自动创建数据库，检查数据库大小和磁盘可用空间。发送电子邮件，当…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="nt l lt lu lv lr lw ky li"/></div></div></a></div><p id="511d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是使用相同方法的第二个Github库。但是在这种情况下，我们讨论的是作为服务运行的web服务器，所以您需要将必要的目录(html、css、…)复制到映像中。docker文件“更丰富”，它使用alpine(不是从头开始)，因为软件使用时区数据。</p><div class="lf lg gp gr lh li"><a href="https://github.com/petrjahoda/system_webservice" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">GitHub-petrjahoda/system _ web service</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="nu l lt lu lv lr lw ky li"/></div></div></a></div><p id="7d04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我只创建linux映像，所以我的docker文件中没有TARGETOS。</p><p id="29b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你发现一个问题，怪癖或者废话，请在评论里告诉我。</p></div></div>    
</body>
</html>