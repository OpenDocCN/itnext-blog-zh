<html>
<head>
<title>Hardening Docker and Kubernetes with seccomp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用seccomp强化Docker和Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111?source=collection_archive---------0-----------------------#2021-01-15">https://itnext.io/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111?source=collection_archive---------0-----------------------#2021-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="55f2" class="pw-subtitle-paragraph ju is it bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h2></div><p id="b438" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">关于容器安全性有很多误解——很多人认为容器在默认情况下是安全的，但不幸的是这并不正确。有相当多的工具可以帮助你提高容器的安全性，从而提高Docker和Kubernetes的安全性。强化它们的方法之一是应用适当的<code class="fe jq jr js jt b">seccomp</code>轮廓。如果您不知道<code class="fe jq jr js jt b">seccomp</code>是什么，那么请继续阅读，看看它是什么，以及如何使用它来保护您的Docker和Kubernetes免受安全威胁！</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/9d39e65576e5f8796ee9d5aea8233f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZ23J0M1zXOV9wcFJEnx5g.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">照片由<a class="ae ly" href="https://unsplash.com/@mana5280?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> mana5280 </a>在<a class="ae ly" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="7b7a" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">seccomp到底是什么？</h1><p id="ae77" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">如果你使用Docker或Kubernetes已经有一段时间了，你可能听说过术语<code class="fe jq jr js jt b">seccomp</code>，但是很有可能，你还没有真正深入了解这个晦涩的工具，对吗？</p><p id="f90c" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">最简单和最容易理解的<code class="fe jq jr js jt b">seccomp</code>定义可能是<em class="mw">“系统调用防火墙”</em>。<code class="fe jq jr js jt b">seccomp</code>本质上是一种限制进程进行系统调用的机制，因此，就像我们可以阻止来自某些IP的数据包一样，我们也可以阻止进程向CPU发送系统调用。</p><p id="aa86" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这很酷，但这如何帮助我们使系统更加安全呢？Linux内核有很多系统调用(几百个)，但是大多数都不是任何给定进程所需要的。如果进程受到威胁并被骗去使用这些系统调用，那么它会导致整个系统出现严重的安全问题。因此，限制系统调用进程可以大大减少内核的攻击面。</p><p id="e688" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在，如果你正在运行Docker的最新版本(1.10或更高版本)，那么你已经在使用<code class="fe jq jr js jt b">seccomp</code>。您可以使用<code class="fe jq jr js jt b">docker info</code>或查看<code class="fe jq jr js jt b">/boot/config-*</code>进行检查:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="79e3" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">嗯，太好了！我们已经有了<code class="fe jq jr js jt b">seccomp</code>，一切都很安全，我们不需要搞乱这些，对吗？嗯，不完全是这样——有相当多的理由让你想把手弄脏并更深入地研究<code class="fe jq jr js jt b">seccomp</code>...</p><h1 id="ed67" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">为什么要创造一个呢？</h1><p id="7dd4" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">Docker中的默认<code class="fe jq jr js jt b">seccomp</code>配置文件可能通常是<em class="mw">“足够好”</em>，如果您没有使用它的经验，那么<em class="mw">“改进”</em>或以其他方式定制它可能不是对您时间的最佳利用。然而，有一些原因可能会给你足够的动力来改变默认的<code class="fe jq jr js jt b">seccomp</code>配置文件:</p><p id="1085" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">不时会发现安全漏洞。这是不可避免的，进一步限制默认<code class="fe jq jr js jt b">seccomp</code>配置文件可能会降低安全漏洞影响您的应用程序的机会。一个这样的事件是<a class="ae ly" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-0728" rel="noopener ugc nofollow" target="_blank"> CVE 2016-0728 </a>，该事件允许用户使用<code class="fe jq jr js jt b">keyctl()</code> syscall提升权限。这次事件之后，这个系统调用现在被默认<code class="fe jq jr js jt b">seccomp</code>配置文件阻止，但是将来可能会有更多这样的漏洞...</p><p id="b3db" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">限制<code class="fe jq jr js jt b">seccomp</code>概要文件的另一个原因是，如果某个子系统有安全缺陷，攻击者将无法从您的容器中利用它，因为相关的系统调用已经被阻塞。这个子系统可以是依赖项、库或系统中你无法控制的部分。您可能也没有办法修复该子系统中的问题，为了防止该问题被利用，您需要在不同的层阻止它，例如在<code class="fe jq jr js jt b">seccomp</code>配置文件中。</p><p id="e1ae" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">当您处理PII数据或构建任务关键型应用程序(如医疗保健或电网中使用的软件)时，潜在的漏洞和安全漏洞变得更加重要。在这些情况下，任何微小的安全改进都很重要，定制<code class="fe jq jr js jt b">seccomp</code>配置文件可能是值得的。</p><p id="2861" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">除了所有这些特定的原因，限制容器可以使用的系统调用限制了可以使用的攻击媒介，例如Docker上游映像中的后门或应用程序中可利用的bug。</p><h1 id="4889" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">自定义配置文件</h1><p id="6a60" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">现在，如果我们确定我们有一个很好的理由去改变<code class="fe jq jr js jt b">seccomp</code>档案，我们实际上该如何去做呢？编写<code class="fe jq jr js jt b">seccomp</code>过滤器的一种方法是使用BPF语言。使用这种语言并不简单或方便。幸运的是，我们不必使用它——相反，我们可以编写JSON，由<code class="fe jq jr js jt b">libseccomp</code>编译成profile。此类配置文件的简单/最小示例如下所示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d646" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">通常，最好使用白名单而不是黑名单，并明确列出允许的系统调用和禁止的其他系统调用。这正是上面的配置文件所做的——默认情况下，它将使用动作<code class="fe jq jr js jt b">SCMP_ACT_ERRNO</code>,这将导致所有系统调用的<code class="fe jq jr js jt b">Permission denied</code>。对于我们想要允许的，我们列出它们的名字并指定<code class="fe jq jr js jt b">SCMP_ACT_ALLOW</code>动作。</p><p id="4d77" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这些JSON概要文件可以使用相当多的选项，并且可能会变得非常复杂，所以上面的概要文件实际上是将其精简到最低限度。要了解真实的简介，你可以点击这里查看码头工人简介<a class="ae ly" href="https://github.com/docker/labs/blob/master/security/seccomp/seccomp-profiles/default.json" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3ed3" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在我们已经对<code class="fe jq jr js jt b">seccomp</code>概要文件有了更多的了解，让我们来玩一下Docker。在我们尝试应用任何自定义概要文件之前，让我们先做一点实验，覆盖<code class="fe jq jr js jt b">seccomp</code>的默认设置:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="19b9" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">上面我们可以看到如果我们完全禁用<code class="fe jq jr js jt b">seccomp</code>会发生什么——任何系统调用都是可用的，这允许容器中的用户——除了别的以外——重启主机。本例中的<code class="fe jq jr js jt b">— security-opt seccomp=…</code>用于禁用<code class="fe jq jr js jt b">seccomp</code>。这也是应用自定义概要文件的方法，所以让我们构建并应用我们自己的自定义概要文件。</p><p id="929d" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">从头开始并不是一个好主意，所以我们将修改现有的Dockers配置文件(如上所述)，我们将通过删除<code class="fe jq jr js jt b">chmod</code>、<code class="fe jq jr js jt b">fchmod</code>和<code class="fe jq jr js jt b">fchmodat</code> syscall对其进行一点限制，这实际上拒绝了使用<code class="fe jq jr js jt b">chmod</code>命令的权限。这可能不是最合理的改变或<em class="mw">“改进”</em>但出于演示目的，它工作得很好:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d603" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">在这个代码片段中，我们从<code class="fe jq jr js jt b">no-chmod.json</code>加载自定义概要文件，并尝试<code class="fe jq jr js jt b">chmod</code>整个<code class="fe jq jr js jt b">/etc</code>。我们可以看到这在容器中导致了什么——任何运行<code class="fe jq jr js jt b">chmod</code>的尝试都会导致<code class="fe jq jr js jt b">Operation not permitted</code>。</p><p id="092e" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">有了这个简单的<em class="mw"> "no </em> <code class="fe jq jr js jt b"><em class="mw">chmod</em></code> <em class="mw"> " </em>配置文件，挑选应该阻塞哪些系统调用就变得非常简单。然而，总的来说，选择什么可以或不可以被阻止并不容易。您可以做出有根据的猜测，但是您可能会因为阻塞系统调用而同时阻塞太多和不够，这将阻止您的应用程序正确运行，而且还会错过一些可以并且应该被阻塞的系统调用。</p><p id="fe59" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">选择阻塞哪个系统调用的唯一可行方法是调用跟踪。跟踪系统调用的一种方法是使用<code class="fe jq jr js jt b">strace</code>:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a676" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">上面的命令给出了一个命令使用的所有系统调用的列表(在这个例子中是<code class="fe jq jr js jt b">chmod</code>，从中我们可以选择阻止/允许什么。如果这个<code class="fe jq jr js jt b">strace</code>命令对你来说有点太复杂，那么<code class="fe jq jr js jt b">strace -c ls</code>也可以工作，它输出一些额外的信息，比如时间和通话次数。我们显然不能阻止所有这些，因为那会使我们的容器不可用，所以最好是查找每一个，例如使用这个<a class="ae ly" href="https://filippo.io/linux-syscall-table/" rel="noopener ugc nofollow" target="_blank"> syscall表</a>。</p><h1 id="a7ca" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">Kubernetes怎么样？</h1><p id="7777" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">在标题和介绍中，我也提到了Kubernetes，但是到目前为止我们只讨论了Docker。那么，Kubernetes世界<code class="fe jq jr js jt b">seccomp</code>周围是什么情况呢？不幸的是，在Kubernetes <code class="fe jq jr js jt b">seccomp</code>中，默认情况下不使用，因此系统调用不会被过滤，除了一些非常危险的调用。因此，使用Docker，您可以不配置任何配置文件，只使用默认值，但在Kubernetes中，确实无法防止一些安全问题被利用。</p><p id="f3c8" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们如何“解决”这个问题？这取决于您使用的Kubernetes版本——对于1.19之前的版本，您需要对您的pod应用注释。这看起来会像这样:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a37b" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">对于1.19(我们将在这里重点介绍)和更高版本，<code class="fe jq jr js jt b">seccomp</code>配置文件是GA特性，您可以在pod的<code class="fe jq jr js jt b">securityContext</code>中使用<code class="fe jq jr js jt b">seccompProfile</code>部分。此类pod的定义如下所示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="901c" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">现在我们知道如何在Kubernetes上解决它，所以是时候做一个小小的演示了。为此，我们需要一个集群——这里我将使用<em class="mw">种类</em>(Docker中的Kubernetes)来建立一个最小的本地集群。此外，在启动集群之前，我们还需要所有的<code class="fe jq jr js jt b">seccomp</code>配置文件，因为这些文件需要在集群节点上可用。因此，集群本身的定义如下:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d95f" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这定义了将本地<code class="fe jq jr js jt b">profiles</code>目录挂载到<code class="fe jq jr js jt b">/var/lib/kubelet/seccomp/profiles</code>节点的单节点集群。我们在这个<code class="fe jq jr js jt b">profiles</code>目录中放什么呢？出于此示例的目的，我们将使用3个配置文件:Dockers默认配置文件和以前使用的配置文件，另外还有一个所谓的<em class="mw">“审计”</em> / <em class="mw">“投诉”</em>配置文件。</p><p id="4e01" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们将从审计概况开始。这个不允许/阻止任何系统调用，而是当它们被一些命令/程序使用时，将它们记录到<code class="fe jq jr js jt b">syslog</code>日志中。这对于调试和探索应用程序的行为以及发现可以或不可以阻塞的系统调用非常有用。这个概要文件的定义实际上只有一行，如下所示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="deae" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">显然，我们还需要一个豆荚。这个pod将有一个Ubuntu容器，它运行<code class="fe jq jr js jt b">ls</code>来触发一些系统调用，然后休眠，所以它不会终止和重启:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="29af" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">解决这个问题后，让我们构建集群并应用第一个概要文件:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="de9f" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们在带有我们的<em class="mw">种类</em>集群定义、<code class="fe jq jr js jt b">pods</code>目录和<code class="fe jq jr js jt b">profiles</code>目录的目录中执行上面的例子。我们首先使用<code class="fe jq jr js jt b">kind</code>命令从定义中创建集群。然后，我们应用使用<code class="fe jq jr js jt b">audit.yaml</code>配置文件的<code class="fe jq jr js jt b">audit-seccomp</code> pod。最后，我们检查<code class="fe jq jr js jt b">syslog</code>消息，查看<code class="fe jq jr js jt b">audit-seccomp</code> pod记录的审计消息。这些消息中的每一条都包含<code class="fe jq jr js jt b">syscall=...</code>，它指定了syscall ID(对于<code class="fe jq jr js jt b">x86_64</code>架构)，可以翻译成每行末尾注释中的名称。</p><p id="0e86" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">既然我们已经确认了<code class="fe jq jr js jt b">seccomp</code>如预期的那样工作，我们可以应用真实的概要文件(Dockers默认)。为此，我们将使用不同的pod:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9368" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们在这里做了一些改变。也就是说，我们更改了指定<code class="fe jq jr js jt b">RuntimeDefault</code>类型的<code class="fe jq jr js jt b">seccompProfile</code>部分，我们还将图像更改为<a class="ae ly" href="https://github.com/genuinetools/amicontained" rel="noopener ugc nofollow" target="_blank">一个包含的</a>部分，这是一个容器自检工具，它会告诉我们哪些系统调用被阻塞，以及一些其他有趣的安全信息。</p><p id="b7ce" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">应用此pod后，我们可以在日志中看到以下内容:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7244" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">这表明Dockers默认配置文件将阻塞上述61个系统调用。如果我们不包括类型为<code class="fe jq jr js jt b">RuntimeDefault</code>的<code class="fe jq jr js jt b">seccompProfile</code>部分，它将只有22(如果你不相信我，你可以自己测试😉).在我看来，这是很大的安全改进，只需要很少的实际努力。</p><p id="6e72" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">如果我们认为缺省值不够好，或者我们需要做一些修改，我们可以部署我们的定制概要文件。在这里，我们将使用<em class="mw">“无</em><code class="fe jq jr js jt b"><em class="mw">chmod</em></code><em class="mw">”</em>配置文件和以下pod进行演示:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a388" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">此窗格与之前显示的<em class="mw">“审计”</em>窗格非常相似。我们只是将<code class="fe jq jr js jt b">localhostProfile</code>切换为指向不同的文件，并将容器参数更改为包含<code class="fe jq jr js jt b">chmod</code>命令，这样我们就可以看到并确认我们修改后的<code class="fe jq jr js jt b">seccomp</code>概要文件如预期那样工作:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5075" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">日志显示了预期的结果— <code class="fe jq jr js jt b">seccomp</code>概要文件阻止了对测试文件进行<code class="fe jq jr js jt b">chmod</code>的尝试，并返回了<code class="fe jq jr js jt b">Operation not permitted</code>。这表明，根据我们的喜好或需要调整配置文件是非常简单的。</p><p id="16e7" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">但是在修改这些类型的默认配置文件时要小心——如果您最终阻塞过多，并且您的pod/container无法启动，那么pod将处于<code class="fe jq jr js jt b">Error</code>状态，但是您将在日志中看不到任何内容，在<code class="fe jq jr js jt b">kubectl describe pod …</code>的事件中也看不到任何有用的内容，所以在调试<code class="fe jq jr js jt b">seccomp</code>相关问题时要记住这一点。</p><h1 id="c2f5" class="lz ma it bd mb mc md me mf mg mh mi mj kd mk ke ml kg mm kh mn kj mo kk mp mq bi translated">结论</h1><p id="8a59" class="pw-post-body-paragraph km kn it ko b kp mr jy kr ks ms kb ku kv mt kx ky kz mu lb lc ld mv lf lg lh im bi translated">即使读完这篇文章，修改或创建自己的<code class="fe jq jr js jt b">seccomp</code>个人资料可能也不是你的首要任务之一。然而，重要的是要意识到这个强大的工具，并能够在需要时使用它——例如在Kubernetes中——默认情况下它没有被强制执行，这很容易成为大的安全问题。出于这个原因，我建议——至少——启用<em class="mw">“审计”</em>概要文件，这样您就可以监视正在使用的系统调用，并使用这些信息来创建您自己的概要文件，或者验证默认的概要文件是否适用于您的应用程序。</p><p id="6b78" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">此外，如果你从这篇文章中得到什么，那么可能是，<code class="fe jq jr js jt b">seccomp</code>是一个重要的安全层，你应该<em class="mw">永远不要</em>运行你的容器<code class="fe jq jr js jt b">uncontained</code>。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="820e" class="pw-post-body-paragraph km kn it ko b kp kq jy kr ks kt kb ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><em class="mw">本文原帖</em><a class="ae ly" href="https://martinheinz.dev/blog/41?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_41" rel="noopener ugc nofollow" target="_blank"><em class="mw">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a href="https://towardsdatascience.com/analyzing-docker-image-security-ed5cf7e93751" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">分析Docker图像安全性</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">码头集装箱远没有你想象的那么安全…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ls nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">你不用再用Docker了</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">Docker不是唯一的集装箱工具，可能会有更好的替代工具…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ls nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://towardsdatascience.com/deploy-any-python-project-to-kubernetes-2c6ad4d41f14" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">将任何Python项目部署到Kubernetes</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">是时候深入Kubernetes，使用这个成熟的项目模板将您的Python项目带到云中了！</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ls nj"/></div></div></a></div></div></div>    
</body>
</html>