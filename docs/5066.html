<html>
<head>
<title>Differences in methods of collecting Kotlin Flows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">收集科特林流方法的差异</h1>
<blockquote>原文：<a href="https://itnext.io/differences-in-methods-of-collecting-kotlin-flows-3d1d4efd1c2?source=collection_archive---------0-----------------------#2020-12-02">https://itnext.io/differences-in-methods-of-collecting-kotlin-flows-3d1d4efd1c2?source=collection_archive---------0-----------------------#2020-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ad9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你们中的一些人可能最近开始使用Kotlin Flow，JetBrains的新框架来处理可观察的流。</p><p id="5003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经从网上的许多文章中知道，为了收集流量，你有两个主要的选择。你可以使用<code class="fe kl km kn ko b">.collect()</code>，或者<code class="fe kl km kn ko b">.launchIn()</code>。(出于本文的目的，我们避免其他终端运营商，如<code class="fe kl km kn ko b">.toList()</code>等)</p><p id="5ca5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种方法有什么区别？</p><p id="2daf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些显而易见的问题，其中一个非常微妙，不是每个人都能立即发现的，如果你想让你的代码像预期的那样运行，你应该注意这一点。</p><h2 id="2c17" class="kp kq iq bd kr ks kt dn ku kv kw dp kx jy ky kz la kc lb lc ld kg le lf lg lh bi translated">明显的差异</h2><p id="c88c" class="pw-post-body-paragraph jn jo iq jp b jq li js jt ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ij bi translated">首先，如果我们看一下这两个方法的方法签名，我们会知道<code class="fe kl km kn ko b">.collect()</code>是暂停方法，而<code class="fe kl km kn ko b">.launchIn()</code>不是:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="72af" class="kp kq iq ko b gy lv lw l lx ly">public suspend fun collect(collector: FlowCollector&lt;T&gt;)</span><span id="2417" class="kp kq iq ko b gy lz lw l lx ly">public fun &lt;T&gt; Flow&lt;T&gt;.launchIn(scope: CoroutineScope): Job</span></pre><p id="e755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际的区别是，你只能从另一个挂起函数或协程调用<code class="fe kl km kn ko b">collect()</code>方法。比如像这样:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="574c" class="kp kq iq ko b gy lv lw l lx ly">coroutineScope.launch {<br/>    flowOf(1, 2, 3)<br/>        .collect { println(it) }<br/>}</span></pre><p id="fcc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而<code class="fe kl km kn ko b">.launchIn()</code>可以在任何常规函数中这样调用:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="91fc" class="kp kq iq ko b gy lv lw l lx ly">flowOf(1, 2, 3)<br/>    .onEach { println(it) }<br/>    .launchIn(coroutineScope)</span></pre><p id="efbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kl km kn ko b">.launchIn()</code>方法，您还会得到一个<code class="fe kl km kn ko b">Job</code>作为返回值，因此您可以通过取消作业来取消流程:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="524f" class="kp kq iq ko b gy lv lw l lx ly">val job = <em class="ma">flowOf</em>(1, 2, 3)<br/>    .<em class="ma">onEach </em><strong class="ko ir">{ </strong><em class="ma">println</em>(<strong class="ko ir">it</strong>) <strong class="ko ir">}<br/>    </strong>.<em class="ma">launchIn</em>(coroutineScope)<br/><br/>job.cancel()</span></pre><p id="0e33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种方法之间还有一个区别，可能不太明显，但还是回到了这个事实上，即<code class="fe kl km kn ko b">.collect()</code>是一个暂停函数。</p><h2 id="d5af" class="kp kq iq bd kr ks kt dn ku kv kw dp kx jy ky kz la kc lb lc ld kg le lf lg lh bi translated">更微妙的区别</h2><p id="f037" class="pw-post-body-paragraph jn jo iq jp b jq li js jt ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ij bi translated">让我们在这里做一个小测验。你认为这段代码的输出会是什么？</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="7040" class="kp kq iq ko b gy lv lw l lx ly">runBlocking {<br/>    flowOf(1, 2, 3)<br/>        .onEach { delay(100) }<br/>        .collect { println(it) }</span><span id="632c" class="kp kq iq ko b gy lz lw l lx ly">    flowOf("a", "b", "c")<br/>        .collect { println(it) }<br/>}</span></pre><p id="c87d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于第一个<code class="fe kl km kn ko b">Flow</code>和第二个<code class="fe kl km kn ko b">Flow</code>中的每次发射都有延迟，因此会立即发射和打印，可能会出现以下输出:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="0fa2" class="kp kq iq ko b gy lv lw l lx ly">a<br/>b<br/>c<br/>1<br/>2<br/>3</span></pre><p id="5cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，最终的输出实际上是这样的:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="86cf" class="kp kq iq ko b gy lv lw l lx ly">1<br/>2<br/>3<br/>a<br/>b<br/>c</span></pre><p id="c172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？</p><h2 id="37b3" class="kp kq iq bd kr ks kt dn ku kv kw dp kx jy ky kz la kc lb lc ld kg le lf lg lh bi translated">收集是一个暂停功能</h2><p id="930c" class="pw-post-body-paragraph jn jo iq jp b jq li js jt ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ij bi translated">这种行为的原因是，<code class="fe kl km kn ko b">.collect()</code>是一个暂停功能。它挂起协程，直到完成自己的工作。因此，在我们的代码被截取的情况下，协程在每次出现延迟时都被挂起，并且协程不会继续执行任何其他代码，直到第一个流被收集。这意味着，在第一个流完成之前，根本不会收集第二个流。</p><p id="a0eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，所以在实际场景中，这很可能不是你想要的。您可能希望在输出中首先看到字母a、b、c，然后才是1、2、3。</p><p id="b63d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么如何才能做到这一点呢？我们可以使用<code class="fe kl km kn ko b">.launchIn()</code></p><h2 id="0ce1" class="kp kq iq bd kr ks kt dn ku kv kw dp kx jy ky kz la kc lb lc ld kg le lf lg lh bi translated">但是为什么会起作用呢？</h2><p id="d3a0" class="pw-post-body-paragraph jn jo iq jp b jq li js jt ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ij bi translated">让我们看看<code class="fe kl km kn ko b">.launchIn()</code>方法的实现:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="f33f" class="kp kq iq ko b gy lv lw l lx ly">public fun &lt;T&gt; Flow&lt;T&gt;.launchIn(scope: CoroutineScope): Job =     scope.<em class="ma">launch </em><strong class="ko ir">{<br/>    </strong>collect() <em class="ma">// tail-call<br/></em><strong class="ko ir">}</strong></span></pre><p id="b5e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的代码可以看出，<code class="fe kl km kn ko b">.launchIn()</code>确实在内部调用了<code class="fe kl km kn ko b">.collect()</code>方法。然而，它收集流量在一个<code class="fe kl km kn ko b">scope.launch {}</code>块。这段代码意味着在参数中指定的协程范围内启动了一个新的子协程。</p><p id="304d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在这段代码中:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="b28e" class="kp kq iq ko b gy lv lw l lx ly">runBlocking {<br/>    flowOf(1, 2, 3)<br/>        .onEach { delay(100) }<br/>        .onEach { println(it) }<br/>        .launchIn(this)</span><span id="29af" class="kp kq iq ko b gy lz lw l lx ly">    flowOf("a", "b", "c")<br/>        .onEach { println(it) }<br/>        .launchIn(this)<br/>}</span></pre><p id="0eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当第一个流被收集时，由<code class="fe kl km kn ko b">runBlocking {}</code>启动的协程不被挂起。相反，在阻塞协程的范围内启动了一个新的子协程(通过<code class="fe kl km kn ko b">runBlocking {}</code>启动)，这个新的子协程将被挂起。</p><p id="f303" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着第二个流没有被阻止收集。这意味着，输出是你所期望的:</p><pre class="ln lo lp lq gt lr ko ls lt aw lu bi"><span id="825e" class="kp kq iq ko b gy lv lw l lx ly">a<br/>b<br/>c<br/>1<br/>2<br/>3</span></pre><h2 id="4536" class="kp kq iq bd kr ks kt dn ku kv kw dp kx jy ky kz la kc lb lc ld kg le lf lg lh bi translated">结论</h2><p id="1e4d" class="pw-post-body-paragraph jn jo iq jp b jq li js jt ju lj jw jx jy lk ka kb kc ll ke kf kg lm ki kj kk ij bi translated">所以总之，我建议在收集你的流量时更喜欢用<code class="fe kl km kn ko b">.launchIn()</code>而不是<code class="fe kl km kn ko b">.collect()</code>，以避免意外的错误。只有当你绝对确定，你不介意并且将来也不会介意它挂起你的协程时，才使用<code class="fe kl km kn ko b">.collect()</code>(例如，因为协程被启动来收集这一个特定的流，并且不会在其中执行任何其他的东西，甚至将来你也不想在协程中添加任何其他的东西)。</p></div></div>    
</body>
</html>