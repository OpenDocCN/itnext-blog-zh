<html>
<head>
<title>Coordinator Pattern’s Issues &amp; What is RouteComposer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调模式的问题&amp;什么是RouteComposer</h1>
<blockquote>原文：<a href="https://itnext.io/coordinator-patterns-issues-what-is-routecomposer-8b50a0477917?source=collection_archive---------1-----------------------#2019-04-09">https://itnext.io/coordinator-patterns-issues-what-is-routecomposer-8b50a0477917?source=collection_archive---------1-----------------------#2019-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="17f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在继续关于我们使用的<a class="ae kl" href="https://github.com/ekazaev/route-composer" rel="noopener ugc nofollow" target="_blank"> RouteComposer </a>库的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/going-deeper-into-the-routecomposer-configuration-3a54661bb16a">文章</a>的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/composition-of-uiviewcontrollers-and-navigation-between-them-and-not-only-15b825da5ac">系列</a>。在本文中，我想谈谈协调模式。我写这篇文章是因为之前一篇文章中关于协调模式的讨论。</p><p id="6f41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近引入的协调模式在iOS开发人员社区中越来越受欢迎，总的来说，原因很明显。UIKit 提供的开箱即用工具是一堆相当不标准的东西。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/50a34ae92ebb14911c6a030d07bf8483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Bz3sly_HIDDgPWO4Ju0X8w.png"/></div></figure><p id="b120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我以前提出过在堆栈中构建视图控制器时处理碎片的问题。为了避免重复，如果你想阅读更多，你可以这样做<a class="ae kl" href="https://habr.com/ru/post/421097/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">老实说，甚至苹果公司也意识到，当他们把视图控制器放在应用程序开发的中心时，他们没有提出任何明智的方法来将它们集成在一起或在它们之间传输数据。在向在Xcode中实现代码完成的同一批开发人员提供了这个问题的解决方案之后(<em class="ku">开玩笑</em>)，苹果在某个时候向我们展示了故事板和片段。</p><p id="19bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后来，苹果意识到他们是唯一一个开发由2个或更少屏幕组成的应用程序的公司。在下一次迭代中，他们提供了将故事板分成几个部分的机会，因为当故事板达到一定大小时，Xcode开始崩溃。Segues随着这个概念在几个迭代中发生了变化，这些迭代不一定相互兼容。他们的支持被紧密地编织到大规模的UIViewController类中，最终，我们得到了这个:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="kv kw l"/></div></figure><p id="7c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码中强制类型转换的数量惊人。以及故事板本身中的纯字符串常量，Xcode没有提供任何有意义的方法来跟踪它们。在使用故事板导航的过程中，最轻微的改变任何东西的愿望都可以让你毫不费力地编译项目，尽管它会在Xcode没有任何警告的情况下带着欢快的噼啪声崩溃到运行时。你看到的不是你得到的。</p><p id="48e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">人们可以争论故事板中这些灰色箭头的优点，据说是向某人展示屏幕之间的联系。然而，根据我的经验，并且我特意采访了来自不同公司的几位iOS开发人员，一旦他们的项目增长超过5–6个屏幕，开发人员就试图找到更可靠的解决方案，并最终开始在他们的头脑中保留控制器堆栈的结构。这意味着如果你需要添加对iPad的支持，另一种导航模式，或者对推送通知的支持，那么一切都会变得很糟糕。</p><p id="91d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从那以后，人们已经做了一些尝试来解决这个问题——有些变成了独立的框架，有些变成了独立的架构模式。</p><p id="f297" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到协调模式。由于显而易见的原因，你在维基百科上找不到任何描述。它不是标准的编程/设计模式。相反，这是一种抽象，它建议您隐藏所有这些“丑陋”的代码，创建新的控制器视图并将其插入堆栈，存储对控制器容器的引用，并在控制器之间推送数据。我找到的最有用的文章是raywenderlich.com的文章。协调员模式在2015年NSSpain会议之后开始流行，当时它被介绍给了公众。你可以在这里找到更多细节<a class="ae kl" href="http://khanlou.com/2015/01/the-coordinator/" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到<a class="ae kl" href="http://khanlou.com/2015/10/coordinators-redux/%5D" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7e51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续之前，我将简要描述一下它是什么。</p><p id="b132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有的解释中，协调者模式大致符合这幅图:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/bc22f53c211247c7912338e8b2c923af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*VUS7-VQV0jMGCn5NUV_1jQ.png"/></div></figure><p id="34c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，协调器是一个协议:</p><blockquote class="ky kz la"><p id="bed9" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">礼宾协调员{</p><p id="c159" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">func start()</p><p id="cd79" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi">}</p></blockquote><p id="6ed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有“丑陋”的代码都应该隐藏在启动函数中。此外，协调员可能有到儿童协调员的链接。也就是说，它们具有某种组合的可能性，例如，您可以用一个实现替换另一个实现。听起来很优雅，对吧？</p><p id="911e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，它很快变得相当不雅:</p><ol class=""><li id="c1f9" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">一些实现建议您将协调器从某种创造性的模式转换成某种更智能的模式，遵循视图控制器的堆栈，<strong class="jp ir">使自己成为容器视图控制器</strong>的代表。以UINavigationController的协调者为例，点击“后退”按钮或向后滑动并删除子协调者。自然，只有一个对象可以是委托，这限制了控制容器视图控制器本身的能力。最后，我们要么与协调者一起构建该逻辑，要么创建协调者的委托来将该逻辑传递给其他人。</li><li id="76ea" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">通常，创建下一个控制器<strong class="jp ir">的逻辑取决于业务逻辑</strong>。例如，要进入下一个屏幕，用户必须登录到系统中。很明显，这是一个异步过程，涉及到用登录表单显示一些中间屏幕，登录过程本身可能成功也可能失败。为了避免将协调器变成大规模协调器(类似于大规模视图控制器)，我们需要一个分解。也就是说，需要创建一个协调者的协调者。</li><li id="eb89" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">协调器面临的另一个问题是，它们本质上只是UINavigationController、UITabBarController等容器视图控制器的fasades。必须有人给他们<strong class="jp ir">提供这些控制器</strong>的参考。如果所有事情都或多或少地与子协调者明确了，那么链的初始协调者就不是那么简单了。此外，当您更改导航模式时，例如对于A / B测试，重构和修改这样的协调器会导致另外一个令人头疼的问题。尤其是当容器视图控制器的类型改变时。</li><li id="1bc9" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">当应用程序开始支持构建视图控制器的<strong class="jp ir">外部事件</strong>时，所有这些变得更加复杂。这包括推送通知或通用链接(用户点击电子邮件中的链接，并继续到应用程序的适当屏幕)。还有其他不确定性，协调器模式对此没有确切的答案。您需要准确地知道用户在哪个屏幕上，以便向他们显示外部事件请求的下一个屏幕。<br/>最简单的例子是由3个屏幕组成的聊天应用:<br/> <em class="ku"> 1。聊天列表。<br/> 2。聊天本身被推入聊天列表导航控制器的导航中。<br/> 3。可以模式化显示的设置屏幕。当用户收到推送通知并点击它时，他们可以在这些屏幕中的一个上。不确定性从这里开始；如果他们在聊天列表中，您需要推送与该特定发送者的聊天屏幕；如果他们已经在聊天屏幕中，那么你需要切换它；并且如果他们已经在与请求的发送者聊天，那么什么也不做并且更新它。但是，如果用户在设置屏幕上，可能需要关闭它并执行前面的步骤。但是如果你不关闭它，只在设置上方显示聊天模式呢？如果设置在另一个选项卡中，而不是在模态选项卡中呢？所有这些if/else要么开始抹黑协调员，要么以意大利面条的形式去找另一个超级协调员。此外，视图控制器堆栈的活动迭代将涉及尝试确定用户此刻的位置，或者尝试构建监控其状态的应用程序，这本身并不是简单基于控制器堆栈性质的简单任务。</em></li><li id="5261" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">蛋糕上的樱桃是<strong class="jp ir"> UIKit故障</strong>。一个普通的例子:<em class="ku"> UITabBarController </em>，它有<em class="ku"> UINavigationController </em>，在第二个选项卡中还有一些其他的<em class="ku"> UIViewController </em>。用户在第一个选项卡中引发了一些事件，要求您切换选项卡并将另一个视图控制器推入第二个选项卡的<em class="ku"> UINavigationController </em>。你需要按照那个特定的顺序来做，因为如果用户从来没有打开过第二个标签页，并且之前没有调用过<em class="ku"> UINavigationController </em>的<em class="ku"> viewDidLoad </em>，那么push方法将会失败，在控制台中只会留下一个模糊的消息。所以在上述例子中，协调者不能简单地成为事件的收听者；它们必须按照一定的顺序工作。这意味着他们必须互相了解。这已经与协调员的第一次发言相矛盾；协调器不知道关于父协调器的任何事情，并且只与子协调器相关联。这也限制了它们的互换性。</li></ol><p id="cc93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个列表还可以继续下去，但是总的来说，协调模式显然是一个相当有限的、可伸缩性很差的解决方案。如果你不带玫瑰色的眼镜来看它，那么它只是将通常由庞大的UIViewController编写的一部分逻辑分解成另一个类的另一种方式。所有试图使协调器模式不仅仅是一种工厂模式并引入另一种逻辑的尝试都没有好结果。</p><p id="0e3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得一提的是，有一些基于这种模式的库，它们取得了不同程度的成功，使得这种模式在一定程度上弥补了所列出的缺点。我会指出<a class="ae kl" href="https://github.com/quickbirdstudios/XCoordinator" rel="noopener ugc nofollow" target="_blank">x坐标</a>和<a class="ae kl" href="https://github.com/RxSwiftCommunity/RxFlow" rel="noopener ugc nofollow" target="_blank"> RxFlow </a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/eb145cddd540c23650442f83362df642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suvoRHigj4X3OHJXTZDqpw.png"/></div></div></figure></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9e2e" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated"><strong class="ak">我们做了什么？</strong></h1><p id="c0f5" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">我们已经参与了一个项目，这个项目是我们从另一个团队获得支持和开发的——协调者和他们简化的“曾祖母”<em class="ku">路由器</em>——在架构方法<em class="ku"> VIPER </em>中。我们回到了以前在我们公司的另一个大型项目中运行良好的方法。这种方法没有任何名称。它基本上位于表面。当我们有空闲时间时，我们把它隔离到一个单独的库<a class="ae kl" href="https://github.com/ekazaev/route-composer" rel="noopener ugc nofollow" target="_blank"> RouteComposer </a>。它完全取代了我们的协调员，并被证明更加灵活。</p><p id="6309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是什么方法？这种方法依赖于视图控制器的堆栈(树)。而不是创建需要监控的额外实体。并且不保存或跟踪应用的状态。</p><p id="9bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更仔细地看看<em class="ku"> UIKit </em>实体，并弄清楚我们的底线是什么，以及您可以使用什么:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi km"><img src="../Images/51b88c06f62131658f10d7c9fa2a83c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ES_kRhxZ_oelalSdsnG_lg.png"/></div></div></figure><ol class=""><li id="2dd0" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">控制器视图栈</strong>是一种树。有一个根视图控制器，它有子视图控制器。模式化呈现的视图控制器是子视图控制器的特例，因为它们也与呈现的视图控制器相关联。这些都是现成的。</li><li id="0e50" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">我们需要创建视图控制器的实体。它们都有不同的构造函数，可以使用Xib文件或故事板创建，它们有不同的输入参数。但是它们都需要被创造，这一事实将它们联系在一起。所以知道如何创建控制器的模式<strong class="jp ir">工厂</strong>将适合我们。每个工厂生产一个视图控制器实体，它很容易被详尽的单元测试覆盖，并且不依赖于其他的。</li><li id="e429" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">让我们把视图控制器分成2类:<br/> <em class="ku"> 1。只需查看控制器。<br/> 2。</em> <strong class="jp ir"> <em class="ku">容器视图控制器</em> </strong> <em class="ku"> s. </em> <br/>容器视图控制器与简单视图控制器的不同之处在于，它们可以包含子视图控制器，这些子视图控制器也是容器或简单视图控制器。这些视图控制器是现成可用的:<em class="ku"> UINavigationController </em>、<em class="ku"> UITabBarController </em>等等，但是也可以有用户创建的自定义视图控制器。如果抽象一下，可以在所有容器中找到以下属性:<br/> <em class="ku"> 1。他们有一个包含所有控制器的列表。<br/> 2。一个或多个控制器当前可见。<br/> 3。他们可能会被要求使这些控制器之一可见。这是<em class="ku"> UIKit </em>中容器视图控制器的唯一区别。他们只是有不同的方法来达到这三个目标。</em></li><li id="bec9" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">为了嵌入由所述工厂创建的视图控制器，使用父视图控制器的方法:<em class="ku">uinavigationcontroller . pushviewcontroller(…)</em>，<em class="ku">uitabbarcontroller . selectedviewcontroller =…</em>，<em class="ku">uiview controller . present(…)</em>。<br/>您可能会注意到，您总是需要两个视图控制器用于该流程:一个已经在堆栈(树)中，另一个需要构建到堆栈中。让我们把它们包装成一个包装器，称之为<strong class="jp ir">动作</strong>。每个动作都很容易用详尽的单元测试来覆盖，而且每个动作都是相互独立的。</li><li id="0639" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">从上面可以看出，通过使用这些实体，我们可以构建一个配置链，如<em class="ku">工厂</em> → <em class="ku">动作</em> → <em class="ku">工厂</em> → <em class="ku">动作</em> → <em class="ku">工厂</em>，运行它之后，您可以构建一个具有任何复杂视图的树。我们只需要指定起点。这些起始点通常是属于UIWindow的<em class="ku"> rootViewController </em>或者是树的最高叶子<em class="ku">当前视图控制器</em>。也就是说，这个配置正确的写法是:<br/> <strong class="jp ir">启动视图控制器</strong> → <strong class="jp ir">动作</strong> → <strong class="jp ir">出厂</strong>→<strong class="jp ir">……</strong>→<strong class="jp ir">出厂</strong>。</li><li id="2823" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">此外，我们将需要一个知道如何运行和构建所提供的配置链的实体。姑且称之为<strong class="jp ir">路由器</strong>。路由器不拥有状态，也不保存任何引用。它有一个传递配置的方法，并按顺序执行配置步骤。</li><li id="df97" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">让我们通过向链中添加<strong class="jp ir">拦截器</strong>来为配置增加一些额外的责任。我们将需要三种类型的拦截器:1。在导航开始前启动。在这里，我们可以将用户身份验证的任务交给系统和其他异步逻辑。2.在创建控制器视图时执行，以便在其中设置一些值。3.执行导航后，在这里您可以放置各种分析任务。每个实体都很容易被单元测试覆盖，并且不知道如何在配置中使用它。它只有一个责任，并履行它。复杂导航的配置可能如下所示:<br/> <strong class="jp ir">【导航前任务…】</strong>→<strong class="jp ir">起始视图控制器</strong> → <strong class="jp ir">动作</strong> → <strong class="jp ir">(工厂+【上下文任务…】)</strong>→<strong class="jp ir">…</strong>→<strong class="jp ir">(工厂+【上下文任务…]) </strong> → <strong class="jp ir">【导航后任务…】</strong>。<br/>也就是说，所有任务将由路由器顺序执行，执行小的、容易阅读的原子实体。</li><li id="508c" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">还有最后一个任务没有被配置解决——即导航应该开始时应用程序的状态。如果我们不需要构建整个视图控制器链，而只需要构建其中的一部分，会怎么样？这可能是因为用户已经手动构建了一部分。这个问题总是可以通过一个带有控制器视图的树来明确地回答。如果链的一部分已经建立，它已经在树中。<br/>因此，如果链中的每个工厂都可以回答它是否已建成的问题，那么路由器将能够了解链的哪个部分需要完成。当然这不是一个工厂任务，所以进入了另一个原子实体— <strong class="jp ir"> Finder </strong>。<br/>那么任何配置看起来都是这样的:<br/> <strong class="jp ir">【导航前任务…】</strong>→<strong class="jp ir">起始视图控制器</strong> → <strong class="jp ir">动作</strong>→<strong class="jp ir">(Finder/Factory+【context Task…】)</strong>→<strong class="jp ir">…</strong>→<strong class="jp ir">(Finder/Factory+【context Task…])</strong>→<strong class="jp ir">【导航后任务…】</strong>。<br/>如果路由器开始反向读取配置，那么其中一个发现器会告诉路由器已经建立了相应的工厂，路由器会从这个点开始向前建立链。如果它们都没有在树中找到相应的视图控制器，那么就需要从初始控制器开始构建整个链。</li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/957065a99f53983de7528f8e261eb0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*CyRNLBTCZGlXF707NVUuqA.gif"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">路由器运行配置链的方式</figcaption></figure><p id="caf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们希望配置是严格类型化的。因此，每个实体只使用一种类型的控制器视图；一种数据。配置完全依赖于Swift与<strong class="jp ir">关联类型</strong>协同工作的能力。我们希望信任编译器，而不是运行时。开发人员可能会有意弱化输入，但反之则不然。</p><p id="9d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种配置的一个例子是:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="kv kw l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">在UINavigationController内部从最顶层的视图控制器模式化地呈现产品视图控制器</figcaption></figure><p id="6607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述项目涵盖了整个库并描述了方法。剩下的工作就是为用户点击按钮或外部事件发生时路由器将执行的链提供配置。如果这些是不同类型的设备，例如iPhone或iPad，那么我们可以使用多态性提供不同的配置。如果我们有一个A / B测试，我们可以做同样的事情。我们不需要考虑应用程序在导航开始时的状态，我们只需要确保配置最初是正确编写的，并且我们确信路由器会以某种方式构建它。</p><p id="05aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所描述的方法比某种抽象或模式更复杂，但是我们还没有遇到这样的任务。当然，<a class="ae kl" href="https://github.com/ekazaev/route-composer" rel="noopener ugc nofollow" target="_blank"> RouteComposer </a>需要学习和理解它是如何工作的。然而，这比学习AutoLayout或RunLoop的基础知识要容易得多。</p><p id="ade2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该库以及所提供的路由器的实现没有使用Objective C运行时的任何调整，并且完全遵循UIKit的所有概念。它只是有助于将合成过程分成几个步骤，并按照给定的顺序执行它们。用iOS版本9到13测试的库。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="f99c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你。我很乐意回答你的任何问题。</p><p id="233d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你喜欢这个库，别忘了在<a class="ae kl" href="https://github.com/ekazaev/route-composer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上给它一颗星！</p><h1 id="8c29" class="me mf iq bd mg mh nm mj mk ml nn mn mo mp no mr ms mt np mv mw mx nq mz na nb bi translated">证明书</h1><h2 id="d090" class="nr mf iq bd mg ns nt dn mk nu nv dp mo jy nw nx ms kc ny nz mw kg oa ob na oc bi translated">即ai</h2><blockquote class="ky kz la"><p id="983a" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><em class="iq">在领先的同步中风护理服务Viz.ai，我们开始更换整个导航系统，我们知道我们需要解决复杂和动态的导航场景。协调器和其他流控制库不能满足我们的需求，并导致混合应用程序逻辑和导航，或者创建大量的协调器类。RouteComposer非常适合我们，实际上，正如这个库的创建者所说，它是您当前使用的任何协调器代码的替代品。</em></p><p id="779e" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">这个库的关注点分离非常漂亮，就像任何天才的东西一样，它像魔法一样工作。它确实有一个小的学习曲线，但它的回报远远超过协调器和流控制器，并且一旦实现它，将会为您节省大量的编码。</p><p id="ac6e" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><em class="iq">它让应用程序中的导航变得简单，就像说“用y转到x”一样简单，不用担心当前的状态或堆栈。我真心推荐。</em></p><p id="b477" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq"> Elazar Yifrach，资深iOS开发者@ Viz.ai </em> </strong></p></blockquote><h2 id="15f2" class="nr mf iq bd mg ns nt dn mk nu nv dp mo jy nw nx ms kc ny nz mw kg oa ob na oc bi translated">哈得孙湾公司</h2><blockquote class="ky kz la"><p id="1efe" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><em class="iq">在我们的iOS应用中，我们希望为用户提供无缝体验，以保证无论用户何时点击推送通知或电子邮件中的链接，他们都会无缝地进入应用中所需的视图，而不管应用的状态如何。</em></p><p id="4ac7" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><em class="iq">我们在代码中尝试了一种编程式导航方法，也尝试了依赖一些其他的库。然而，他们似乎都没有成功。RouteComposer不是我们的首选，因为它看起来太复杂了。谢天谢地，这被证明是一个奇妙而优雅的解决方案。我们不仅开始用它来处理外部深度链接，还开始用它来处理应用程序内部的导航。当不同的用户有不同的导航模式时，它也是一个很好的UI A/B测试工具。它节省了我们大量的时间，我们真的很喜欢它背后的逻辑。</em></p><p id="e0f2" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><em class="iq">库的创建者反应非常迅速，帮助我们解决了所有问题。我会全力推荐它！</em></p><p id="98c7" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir"><em class="iq">Alexandra Mikhailouskaya，高级首席工程师@哈德逊湾公司</em> </strong></p></blockquote><h2 id="8095" class="nr mf iq bd mg ns nt dn mk nu nv dp mo jy nw nx ms kc ny nz mw kg oa ob na oc bi translated">英国广播公司</h2><blockquote class="ky kz la"><p id="606a" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><em class="iq">我们最近进行了第五次也是最大一次应用更新，包括从头开始重新构建用户导航。在我们的一位高级开发人员建议我们试用RouteComposer之前，我们从现有的(六个文件长的)协调器的简单迁移开始。概念验证很有挑战性，但Eugene让我负责将RouteComposer改造成我们现有的企业级代码库，当所有部分都到位时，结果就是简单性本身。</em></p><p id="ffa3" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">我们的其他开发人员已经接受了RouteComposer来代替segues、unwind segues、手动推送、弹出和模态拖放，由此产生的围绕我们应用程序的导航令人愉快。</p><p id="e3db" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">非常感谢尤金的帮助。</p><p id="2eb2" class="jn jo ku jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq"> skooter Martin，高级专业移动工程师@ B.W.A. </em> </strong></p></blockquote></div></div>    
</body>
</html>