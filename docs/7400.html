<html>
<head>
<title>Front-end Testing Principles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前端测试原则</h1>
<blockquote>原文：<a href="https://itnext.io/front-end-testing-principles-c4a3b51aa7e5?source=collection_archive---------0-----------------------#2022-09-12">https://itnext.io/front-end-testing-principles-c4a3b51aa7e5?source=collection_archive---------0-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="671a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写前端测试可能非常困难。你有那么多事情要考虑，要做出选择，要走的路。在这篇文章中，我们将研究5个原则来编写更好的测试，并给你充分的信心来将新特性推向生产。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/a9e7b3c0d9b4b871012b27dbc2508c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qo1bB3actSbi2da6-6LtSQ.png"/></div></div></figure><p id="fcfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始之前，有必要提一下这篇文章:</p><ul class=""><li id="992a" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">特别关注<strong class="jp ir">前端测试</strong>(即React应用程序及其与组件的交互)。</li><li id="a82c" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">高度基于React社区(<a class="ae lm" href="https://kentcdodds.com/" rel="noopener ugc nofollow" target="_blank">https://kentcdodds.com/</a>)内著名开发人员<a class="ae lm" href="https://medium.com/u/db72389e89d8?source=post_page-----5fddfd463feb-----------------------------------" rel="noopener">肯特·c·多兹</a>所写的内容。</li></ul><h1 id="81be" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">一)导言</h1><p id="b3bd" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在上一篇文章中，我们回答了“我们为什么要编写测试”这个问题以及定义了一个测试策略:“测试奖杯”。</p><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/front-end-testing-strategy-5fddfd463feb"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">前端测试策略</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">定义测试的公共层及其权衡，以便提出有效的策略。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">itnext.io</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh kw mt"/></div></div></a></div><p id="09b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候来看看与这一理念完全匹配的5条原则了。</p><h1 id="7981" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">二)原则</h1><h2 id="31f4" class="ni lo iq bd lp nj nk dn lt nl nm dp lx jy nn no mb kc np nq mf kg nr ns mj nt bi translated">1.用你的用户使用软件的方式来测试你的软件</h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1e8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望编写可维护的测试，让您对您的组件为您的用户工作充满信心。<br/>对于前端，我们的测试只需要关注两个目标:</p><ul class=""><li id="05fa" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">在浏览器中与组件交互的最终用户。</li><li id="3176" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">在代码中呈现和使用你的组件的<strong class="jp ir">开发者</strong>。</li></ul><p id="71cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要你的测试服务于这两者，那么它们就有存在的理由。</p><p id="3e58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们经常引入第三个用户，即<strong class="jp ir">测试用户。</strong>这个用户<strong class="jp ir"> </strong>通常测试我们的消费者和我们的企业都不关心的东西(例如:测试实现细节)。<br/>但是，通过这种方式进行测试，你只是为一个用户获得了信心，他:</p><ul class=""><li id="05a8" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">不像<strong class="jp ir">最终用户</strong>那样支付账单。</li><li id="1d55" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">不像<strong class="jp ir">开发者用户</strong>那样影响系统的其余部分。</li></ul><p id="e3ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，您现在必须记住第三个用户，并确保考虑到影响测试用户的更改。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="7cb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong> <a class="ae lm" href="https://kentcdodds.com/blog/avoid-the-test-user" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹——避开测试用户</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="c300" class="ni lo iq bd lp nj nk dn lt nl nm dp lx jy nn no mb kc np nq mf kg nr ns mj nt bi translated">2.避免测试实现细节</h2><p id="c165" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated"><strong class="jp ir">测试用户</strong>倾向于测试所谓的“实现细节”。</p><p id="bf20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和实施细节会导致:</p><ul class=""><li id="8f1f" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">假阴性:当我们重构应用程序代码时可能会出错。</li><li id="d3ea" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">误报:当我们破坏应用程序代码时，可能不会失败。</li></ul><p id="9ae6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么在大多数情况下<strong class="jp ir">我们想要避免它们</strong>，这将使我们的测试:</p><ul class=""><li id="dfbd" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">更接近我们的用户(最终用户和开发者)如何使用我们的组件。这让我们相信我们的应用程序正在按预期工作。</li><li id="ae2a" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">更有弹性。你的组件的重构不会破坏我们的测试，因此不会拖我们团队和我们的后腿。</li></ul><p id="ea21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的测试应该更加关注你的用户能够遇到的真实用例。</p><blockquote class="od oe of"><p id="e1a9" class="jn jo kl jp b jq jr js jt ju jv jw jx og jz ka kb oh kd ke kf oi kh ki kj kk ij bi translated"><strong class="jp ir">如何确定一个实施细节？<br/> </strong> —如果我们的测试做了我们代码的消费者没有做的事情，那么它就是在测试实现细节。(通过示例公开私有函数)。<br/> —如果一个内部重构(对实现而不是功能的改变)破坏了你的测试，那么它是在测试实现细节</p><p id="479c" class="jn jo kl jp b jq jr js jt ju jv jw jx og jz ka kb oh kd ke kf oi kh ki kj kk ij bi translated"><strong class="jp ir">“实现细节”示例:<br/> </strong> —组件内部状态<br/> —组件内部方法<br/> —组件生命周期方法<br/> —子组件</p></blockquote><p id="3be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的是，仍然有一些情况需要测试实现细节。例如，在React中，我们可以考虑一个带有大量内部逻辑的自定义钩子，它可以在整个应用程序中共享。</p><p id="e2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是那些应该是稀有的和精选的。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="4116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong> <a class="ae lm" href="https://kentcdodds.com/blog/testing-implementation-details" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹—避免实现细节</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="d24e" class="ni lo iq bd lp nj nk dn lt nl nm dp lx jy nn no mb kc np nq mf kg nr ns mj nt bi translated">3.编写更少、更长的测试</h2><p id="222a" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">许多人阅读一个组件的需求列表，并将它们转化为单独的测试用例。也许你读过所谓的“每个测试最佳实践只有一个断言”但是这个规则最初被创建是因为测试框架没有给你提供你需要的上下文信息来确定是什么导致了你的测试失败。</p><p id="52ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，由于我们惊人的工具，识别哪个断言导致了失败变得很简单。如果你想让事情更清楚，你可以在断言上面添加一个代码注释来解释你所做的断言的重要性。</p><p id="cc46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要担心考试时间长。当你考虑你的两个用户并避免测试用户时，那么你的测试通常会涉及多个动作和断言，这是一件好事。不要武断地将你的断言分成单独的测试块，没有好的理由这样做。</p><blockquote class="od oe of"><p id="d90b" class="jn jo kl jp b jq jr js jt ju jv jw jx og jz ka kb oh kd ke kf oi kh ki kj kk ij bi translated"><strong class="jp ir">如何确定自己的测试？<br/> </strong>为一个手动测试人员设想一个测试用例工作流，并尝试让你的每个测试用例都包含该工作流的所有部分。</p></blockquote></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="17c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">资源: <a class="ae lm" href="https://kentcdodds.com/blog/write-fewer-longer-tests" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹——编写更少更长的测试</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="0e79" class="ni lo iq bd lp nj nk dn lt nl nm dp lx jy nn no mb kc np nq mf kg nr ns mj nt bi translated">3.在编写测试时，要考虑到易于理解和可维护性</h2><p id="d9ec" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">AHA编程原则代表“避免草率的抽象”。它说当你开始写抽象的时候，你不应该教条，而是在感觉正确的时候写抽象，并且不要害怕重复代码，直到你到达那里。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/15e99c42b5b10559cc1f09765845c8ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ieqq7yrenH2zrv9m"/></div></div></figure><blockquote class="od oe of"><p id="41c7" class="jn jo kl jp b jq jr js jt ju jv jw jx og jz ka kb oh kd ke kf oi kh ki kj kk ij bi translated">在抽象的光谱中间找到一个最佳点是开发可维护代码的关键。</p></blockquote><p id="7145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那个原则完全可以应用于编写可维护的测试。作为一个提醒，您编写一个测试，以确信您今天在生产中推出的代码不会在以后发生变化的情况下崩溃。但是测试也应该是你或者任何其他开发人员的助手，他们将来可能会回到测试中来，很容易理解被测试组件的目的(就功能和关键特性而言)。通过这种方式，您希望<strong class="jp ir">让您的测试易于理解并且具有高度可维护性</strong>。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="86d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong> <a class="ae lm" href="https://kentcdodds.com/blog/aha-testing" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹——啊哈测试</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="183b" class="ni lo iq bd lp nj nk dn lt nl nm dp lx jy nn no mb kc np nq mf kg nr ns mj nt bi translated">4.孤立地编写测试</h2><p id="5b07" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">隔离测试意味着运行一个测试的副作用不应该影响其他测试的结果。我们应该能够以任何顺序独立地执行它们，而不会改变所获得的结果。</p><p id="1a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，测试隔离是测试的一个重要原则，因为当它没有得到很好的尊重时，它是不可靠的测试(每次运行测试都不能产生相同的结果)的最主要原因之一。</p><blockquote class="od oe of"><p id="ce27" class="jn jo kl jp b jq jr js jt ju jv jw jx og jz ka kb oh kd ke kf oi kh ki kj kk ij bi translated">由于测试应该是独立的，并且它们的执行顺序无关紧要，Jest可以并行运行它们，这大大减少了总的执行时间。</p></blockquote><p id="481b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">孤立地编写我们的测试将指导我们以更好的方式编写测试，以提高它们的可靠性，简化代码，并增加信心。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="1ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong> <a class="ae lm" href="https://kentcdodds.com/blog/test-isolation-with-react" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹—测试隔离</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><h2 id="68a5" class="ni lo iq bd lp nj nk dn lt nl nm dp lx jy nn no mb kc np nq mf kg nr ns mj nt bi translated">5.小心嘲笑</h2><p id="4886" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">模拟被认为是一种权宜之计，它允许我们测试某些很难或者懒得测试的东西(例如:测试信用卡服务，我们不想玩产品的数据和服务，所以不想玩真钱)。</p><p id="d988" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，当我们嘲笑某事时，我们是在做交易。我们通常用信心换取实用性。即使我们有信心我们的代码能与我们的假版本的服务一起工作，我们也不能100%有信心我们的代码能在生产中与真实版本一起工作。</p><p id="88f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">肯定有一些模拟的地方(特别是，当我们谈论不同级别的测试时)，但是我们需要意识到我们做出了权衡。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="9d5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">资源:</strong> <a class="ae lm" href="https://kentcdodds.com/blog/the-merits-of-mocking" rel="noopener ugc nofollow" target="_blank">肯特·c·多兹——测试嘲讽</a></p><h1 id="fec7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">三)结论</h1><p id="af0c" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">正如我所说的，前端测试具有挑战性。为了编写相关的测试，你必须把自己从开发者的思维模式中分离出来，试着像一个真正的用户那样思考，把UI作为一个整体来考虑。因为其他开发人员会跟着你添加他们自己的代码和测试，所以你也需要非常注意可维护性和可理解性。</p><p id="72a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，编写测试的主要目的是增加您对应用程序的信心。您希望确保实现的功能今天能按预期工作，并且将来不会中断。为了编写测试而编写测试(或者匹配任意的最小代码覆盖率)是没有价值的，并且经常导致时间和金钱的浪费。<br/>我希望这些原则能在你的旅途中有所帮助。</p><p id="6f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>