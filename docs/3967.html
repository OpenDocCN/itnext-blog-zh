<html>
<head>
<title>RESTful API development with Node.js and Express: Getting started with coding ( Part — 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js和Express进行RESTful API开发:编码入门(第2部分)</h1>
<blockquote>原文：<a href="https://itnext.io/restful-api-development-with-node-js-and-express-getting-started-with-coding-part-2-7c79e27fafbb?source=collection_archive---------3-----------------------#2020-04-03">https://itnext.io/restful-api-development-with-node-js-and-express-getting-started-with-coding-part-2-7c79e27fafbb?source=collection_archive---------3-----------------------#2020-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c9b37ac8f8c8424cb023c07715ef7a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KXayOyV9xKRRmuYIUlyqtg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:Unsplash图片作者:阿迪·戈尔茨坦</figcaption></figure><p id="aa0f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是用Node.js和Express开发RESTful API的第二部分。我希望您已经完成了第一部分并创建了您的项目环境。如果你没有看过第一部分，可以在这里查看<a class="ae la" href="https://medium.com/@humayun.ashid/restful-api-development-with-node-js-9b14dde70c90" rel="noopener">。在这一部分，我们将开始构建我们的RESTful API。</a></p><p id="558f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你会发现所有来自Github的代码:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7f4e" class="lk ll iq lg b gy lm ln l lo lp"><a class="ae la" href="https://github.com/humayun-rashid/first-rest-api-medium.git" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/first-rest-api-medium.git</a></span></pre><p id="bd60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将首先创建一个具有首选名称的新目录。在我的例子中，我将其命名为“first-rest-API”。打开终端，键入以下命令创建一个新目录，并导航到新创建的目录。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b5f2" class="lk ll iq lg b gy lm ln l lo lp">$ sudo mkdir rest-API-project<br/>$ cd rest-API-project</span></pre><p id="4853" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导航到目录后，可以通过将以下命令写入目录来打开visual studio代码。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="dc77" class="lk ll iq lg b gy lm ln l lo lp">$ code .</span></pre><p id="8d9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，您可以在Github中创建一个存储库，使用您喜欢的项目名称，比如“first-rest-api”。如果您已经按照上一篇文章安装了git，那么您应该能够通过下面的命令克隆存储库。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c488" class="lk ll iq lg b gy lm ln l lo lp">$ git clone "git repo url"</span></pre><p id="2afc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后导航到该目录，通过运行以下命令启动visual studio代码。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8065" class="lk ll iq lg b gy lm ln l lo lp">$ cd rest-API-project<br/>$ code .</span></pre><h2 id="cc8a" class="lk ll iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">由NPM初始化生成Package.json</h2><p id="bbc7" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">我们现在将通过生成“package.json”文件开始开发RESTful API，该文件将包含所有的依赖项。在开发过程中添加更多依赖项时，该文件将被更新。要生成“package.json ”,请在终端中运行以下命令，该命令将请求一些问题的答案以生成文件。要自动填充，可以在命令末尾添加问题“-y”。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3e9e" class="lk ll iq lg b gy lm ln l lo lp">$ npm init<br/>$ npm init -y</span></pre><p id="d7ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将在项目的根目录中创建一个“package.json”文件，如下所示。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="eb4c" class="lk ll iq lg b gy lm ln l lo lp">{<br/>  "name": "first-rest-api-medium",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "git+<a class="ae la" href="https://github.com/humayun-rashid/first-rest-api-medium.git" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/first-rest-api-medium.git</a>"<br/>  },<br/>  "keywords": [],<br/>  "author": "",<br/>  "license": "ISC",<br/>  "bugs": {<br/>    "url": "<a class="ae la" href="https://github.com/humayun-rashid/first-rest-api-medium/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/first-rest-api-medium/issues</a>"<br/>  },<br/>  "homepage": "<a class="ae la" href="https://github.com/humayun-rashid/first-rest-api-medium#readme" rel="noopener ugc nofollow" target="_blank">https://github.com/humayun-rashid/first-rest-api-medium#readme</a>"<br/>}</span></pre><h2 id="f681" class="lk ll iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">安装Express Framework和Nodemon</h2><p id="e479" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">下一步，我们需要将Express安装到我们的项目目录中，并将其保存在“package.json”的依赖项列表中。如果需要仅用于开发，也可以将依赖项保存为“开发依赖项”。将依赖项安装为开发依赖项的目的是，不要求软件包用户在生产中安装它。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c5be" class="lk ll iq lg b gy lm ln l lo lp">$ npm install express — save</span></pre><p id="e275" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要临时安装Express而不将其添加到依赖项列表中，请执行以下操作:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b988" class="lk ll iq lg b gy lm ln l lo lp">$ npm install express — no-save</span></pre><p id="a657" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们将安装一个非常酷的工具nodemon，它允许node.js应用程序在每次发生更改时自动重启。使用“-g”编写下面的命令，这将允许将软件包安装为全局的，以便可以从任何地方使用它。与nodemon的本地安装相关的问题是，nodemon在您的系统路径中不可用，而nodemon的本地安装可以通过从npm脚本中调用它来运行。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="027e" class="lk ll iq lg b gy lm ln l lo lp">$ npm install -g nodemon</span></pre><p id="ef8e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也可以在终端中使用以下命令将Nodemon安装为开发依赖项。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d03d" class="lk ll iq lg b gy lm ln l lo lp">$ npm install — save-dev nodemon</span></pre><h2 id="f758" class="lk ll iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">创建基本服务器</h2><p id="9225" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">开始编码吧！首先，我们将在项目根目录下创建一个文件，并将其命名为“server.js”。在终端中运行以下命令，或者从visual studio代码创建它。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9282" class="lk ll iq lg b gy lm ln l lo lp">$ sudo touch server.js</span></pre><p id="9f49" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们将开始在“server.js”中编写代码。首先，我们将导入“快速”模块。对于导入模块，我们将使用“require”功能。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4a76" class="lk ll iq lg b gy lm ln l lo lp">require(“express”)</span></pre><p id="451d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导入的模块需要在变量中。变量可以声明为var、let或const。您可以在此找到有关变量声明的详细信息:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4589" class="lk ll iq lg b gy lm ln l lo lp"><a class="ae la" href="https://dev.to/sarah_chima/var-let-and-const--whats-the-difference-69e" rel="noopener ugc nofollow" target="_blank">https://dev.to/sarah_chima/var-let-and-const--whats-the-difference-69e</a></span></pre><p id="5ffb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用const声明的变量保持常数值，但用var声明的变量可以更新。我们将把“express”导入到一个常量变量中。然后，将通过“app”变量创建导入模块的实例。“app”是express的一个实例。您可以设置环境变量“PORT”来告诉您的web服务器监听哪个端口。所以process.env.PORT || 3000的意思是:环境变量PORT中的任何内容，如果那里什么都没有，则为3000。因此，您传递app.listen或app.set('port '，…)，这使您的服务器能够接受来自环境的参数，即在哪个端口上侦听。如果您将3000硬编码传递给app.listen()，您将始终在端口3000上进行侦听，这可能只是针对您的，也可能不是，这取决于您的要求以及您运行服务器的环境的要求。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1680" class="lk ll iq lg b gy lm ln l lo lp">const express = require(‘express’); // importing Express<br/>const app = express(); // instance of express<br/>const port = process.env.PORT || 3000; // Defining port by environmental parameter or 3000</span><span id="c075" class="lk ll iq lg b gy mm ln l lo lp">// Create a routing <br/>app.get(‘/’,function(req,res){<br/> res.send(‘Server is running.’)<br/>})</span><span id="53b0" class="lk ll iq lg b gy mm ln l lo lp">// App is listening to user-defined port or 300 and printing the information to the console.<br/>app.listen(port, function(req,res){<br/> console.log(`Server is listening on port ${port}!`)<br/>})</span></pre><p id="e4a8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用以下命令运行服务器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="dbad" class="lk ll iq lg b gy lm ln l lo lp">$ node server.js</span></pre><p id="49dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，转到下面的URL来访问服务器。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="213c" class="lk ll iq lg b gy lm ln l lo lp"><a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="e414" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过访问这个URL，我们将通过web客户端发送一个GET请求。这就是路由的概念。我们将在本节稍后讨论这一点。现在，如果我们要进行更改，我们必须通过按ctrl + c停止服务器，然后使用上面的命令再次启动服务器。为了避免通过运行相同的命令反复运行服务器，我们将使用nodemon。</p><p id="9c01" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">转到package.json，将脚本中的test替换为以下内容:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c08d" class="lk ll iq lg b gy lm ln l lo lp">"scripts": {<br/>"devStart": "nodemon server.js"<br/>}</span></pre><p id="48d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，您可以通过使用以下命令使用nodemon启动服务器。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d58a" class="lk ll iq lg b gy lm ln l lo lp">$ npm start devStart</span></pre><p id="217c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，您可以运行以下命令直接启动服务器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8319" class="lk ll iq lg b gy lm ln l lo lp">$ nodemon server.js</span></pre><p id="e014" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，只要您对代码进行更改，服务器就会自动重启。目前，我们的服务器运行在端口3000。我们还可以通过env设置或导出端口参数来定义我们的端口。如果您只想运行一次，请运行以下命令。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1c89" class="lk ll iq lg b gy lm ln l lo lp">$ PORT=1234 node server.js</span></pre><p id="3812" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您不必重启服务器，因为nodemon会自动重启。要永久设置端口，请使用以下命令。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="06a2" class="lk ll iq lg b gy lm ln l lo lp">$ export PORT=3000<br/>$ node server.js</span></pre><p id="2540" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于Windows，请使用以下命令。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="39fd" class="lk ll iq lg b gy lm ln l lo lp">$ set PORT=3000</span></pre><p id="9085" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于Windows PowerShell:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e80d" class="lk ll iq lg b gy lm ln l lo lp">$ env:PORT = 3000</span></pre><p id="f3bf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">设置env参数的另一种方法是通过dotenv包。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6ca6" class="lk ll iq lg b gy lm ln l lo lp">npm install dotenv</span></pre><p id="57c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将这一行添加到服务器的开头。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="723f" class="lk ll iq lg b gy lm ln l lo lp">require(‘dotenv’).config()</span></pre><p id="a77c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在项目的根目录下创建一个. env文件。增加</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1167" class="lk ll iq lg b gy lm ln l lo lp">PORT = 3000</span></pre><p id="4ac3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创造。gitignore因为不想导入。env到git。</p><p id="741e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，我们的基本服务器正在运行。但是目前还没有配置路由。我们将讨论路由并配置一些端点。</p><h2 id="3772" class="lk ll iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">按指定路线发送</h2><p id="fd10" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">路由是指确定应用程序如何响应客户端对特定端点的请求，这是一个URI(或路径)和一个特定的HTTP请求方法(GET、POST等)。每个路由可以有一个或多个处理函数，当路由匹配时执行这些函数。路线定义采用以下结构:</p><p id="cae6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">路线定义采用以下结构:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="21f4" class="lk ll iq lg b gy lm ln l lo lp">app.METHOD(PATH, HANDLER)</span></pre><p id="1b5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">方法是一个HTTP请求方法，小写。PATH是服务器上的路径。处理程序是匹配路由时执行的功能。写下以下代码，使用GET、POST、PUT和DELETE方法创建路由。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="821f" class="lk ll iq lg b gy lm ln l lo lp">require('dotenv').config()<br/>const express = require('express'); <br/>const app = express(); // instance of express<br/>const port = process.env.PORT || 3000; </span><span id="fe66" class="lk ll iq lg b gy mm ln l lo lp">// GET request</span><span id="09a1" class="lk ll iq lg b gy mm ln l lo lp">app.get('/', function (req, res) {<br/>res.status(200).send('Server is up and running.')<br/>})</span><span id="13a8" class="lk ll iq lg b gy mm ln l lo lp">// POST request</span><span id="72bd" class="lk ll iq lg b gy mm ln l lo lp">app.post('/', function (req, res) {<br/>res.status(200).send('This is a POST request')<br/>})</span><span id="5ecf" class="lk ll iq lg b gy mm ln l lo lp">// PUT Request</span><span id="d150" class="lk ll iq lg b gy mm ln l lo lp">app.put('/', function (req, res) {<br/>res.status(200).send('This is a PUT request')<br/>})</span><span id="19b0" class="lk ll iq lg b gy mm ln l lo lp">// PATCH Request</span><span id="359b" class="lk ll iq lg b gy mm ln l lo lp">app.patch('/', function (req, res) {<br/>res.status(200).send('This is a PATCH request')<br/>})</span><span id="e683" class="lk ll iq lg b gy mm ln l lo lp">// DELETE Request</span><span id="2a8b" class="lk ll iq lg b gy mm ln l lo lp">app.delete('/', function (req, res) {<br/>res.status(200).send('This is a DELETE request')<br/>})</span><span id="2905" class="lk ll iq lg b gy mm ln l lo lp">// App is listening to user-defined port or 300 and printing the information to the console.</span><span id="9dc7" class="lk ll iq lg b gy mm ln l lo lp">app.listen(port, function (req, res) {<br/>console.log(`Server is listening on port ${port}!`)<br/>})</span></pre><p id="8dff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要测试您的路由，您需要有POSTMAN或任何其他API端点测试工具。但是为了简单起见，我将使用REST Client，visual studio代码中的一个扩展来测试端点。您可以通过快速打开(<code class="fe mn mo mp lg b">Ctrl+P</code>)并粘贴以下命令，在VS编辑器中安装它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4c47" class="lk ll iq lg b gy lm ln l lo lp">ext install humao.rest-client</span></pre><p id="ff68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们创建一个扩展名为rest的新文件。我正在创建一个test.rest来测试端点。现在写下以下内容开始测试。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="512e" class="lk ll iq lg b gy lm ln l lo lp">### GET Request<br/>GET <a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span><span id="5b21" class="lk ll iq lg b gy mm ln l lo lp">### POST Request<strong class="lg ir"><br/></strong>POST <a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span><span id="5655" class="lk ll iq lg b gy mm ln l lo lp">### DELETE Request<strong class="lg ir"><br/></strong>DELETE <a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span><span id="3841" class="lk ll iq lg b gy mm ln l lo lp">### PUT Request<strong class="lg ir"><br/></strong>PUT <a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span><span id="7041" class="lk ll iq lg b gy mm ln l lo lp">### PATCH Request<strong class="lg ir"><br/></strong>PATCH <a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="0248" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请求上方应该有一个“发送请求”。你需要按下它来测试你的端点。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/b6ac968f531057f4dd4adbf834f495ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJi0UxUHXf8S3QoENFEMHQ.png"/></div></div></figure><p id="611d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果请求成功，您应该会看到类似如下的输出:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9808" class="lk ll iq lg b gy lm ln l lo lp">HTTP/1.1 200 OK <br/>X-Powered-By: Express <br/>Content-Type: text/html; <br/>charset=utf-8 <br/>Content-Length: 25 <br/>ETag: W/"19-mtGkfbkTqxz/NZr8uVnRPTJZzm8" <br/>Date: Fri, 03 Apr 2020 21:18:53 GMT <br/>Connection: close  </span><span id="6e79" class="lk ll iq lg b gy mm ln l lo lp"><strong class="lg ir">Server is up and running.</strong></span></pre><p id="2fb3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果端点不工作，它应该返回类似如下的404错误:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cf5e" class="lk ll iq lg b gy lm ln l lo lp">HTTP/1.1 404 <br/>Not Found X-Powered-By: Express <br/>Content-Security-Policy: default-src 'none' <br/>X-Content-Type-Options: nosniff Content-Type: text/html; charset=utf-8 Content-Length: 140 <br/>Date: Fri, 03 Apr 2020 21:20:29 GMT <br/>Connection: close  <br/>&lt;!DOCTYPE html&gt; <br/>&lt;html lang="en"&gt; <br/>&lt;head&gt; &lt;meta charset="utf-8"&gt; <br/>&lt;title&gt;Error&lt;/title&gt;<br/> &lt;/head&gt; <br/>&lt;body&gt; &lt;pre&gt;<strong class="lg ir">Cannot GET</strong> /r&lt;/pre&gt; &lt;/body&gt; <br/>&lt;/html&gt;</span></pre><h2 id="e4aa" class="lk ll iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">文件夹结构</h2><p id="ff0b" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">我们刚刚编写的代码工作得很好，但是为了使它标准化，我们不应该把我们所有的代码放在一个脚本中，随着时间的推移，它将是一个包含大量编码的大文件，你会发现很难编写更多的功能。为了解决这个问题，我们将把代码分成几个脚本。在我们的server.js中，我们将保持服务器处理代码，我们将创建一个包含所有路由的不同脚本。该脚本可以作为模块导出，并在server.js中调用，所有端点都应该像之前一样工作。让我们创建一个名为“routes”的新目录，并创建一个名为“routes.js”的文件。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9f9b" class="lk ll iq lg b gy lm ln l lo lp">mkdir routes<br/>touch routes/routes.js</span></pre><p id="b0b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们开始在routes.js中编写代码。首先，我们将像以前一样导入express，然后创建express的一个实例，但不是在带有“express()”的“app”变量中，而是我们将如下使用:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3242" class="lk ll iq lg b gy lm ln l lo lp">const express = require(‘express’);<br/>const router = express.Router();</span></pre><p id="65a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们从服务器中取出路由代码，并将它们放在routes.js中。我们将替换我们的应用程序。方法。最后，我们需要将其导出为模块。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="170b" class="lk ll iq lg b gy lm ln l lo lp">// GET request</span><span id="e713" class="lk ll iq lg b gy mm ln l lo lp">router.get(‘/’, function (req, res) {<br/>res.status(200).send(‘Server is up and running.’)<br/>})</span><span id="0203" class="lk ll iq lg b gy mm ln l lo lp">// POST request</span><span id="8d82" class="lk ll iq lg b gy mm ln l lo lp">router.post(‘/’, function (req, res) {<br/>res.status(200).send(‘This is a POST request’)<br/>})</span><span id="b487" class="lk ll iq lg b gy mm ln l lo lp">// PUT Request</span><span id="1e09" class="lk ll iq lg b gy mm ln l lo lp">router.put(‘/’, function (req, res) {<br/>res.status(200).send(‘This is a PUT request’)<br/>})</span><span id="e1c8" class="lk ll iq lg b gy mm ln l lo lp">// PATCH Request</span><span id="f450" class="lk ll iq lg b gy mm ln l lo lp">router.patch(‘/’, function (req, res) {<br/>res.status(200).send(‘This is a PATCH request’)<br/>})</span><span id="9ecf" class="lk ll iq lg b gy mm ln l lo lp">// DELETE Request</span><span id="522f" class="lk ll iq lg b gy mm ln l lo lp">router.delete(‘/’, function (req, res) {<br/>res.status(200).send(‘This is a DELETE request’)<br/>})</span><span id="18b3" class="lk ll iq lg b gy mm ln l lo lp">module.exports = router;</span></pre><p id="8b5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们可以使用routes.js作为模块，并可以从我们的server.js调用该模块。为此，让我们将下面两行添加到server.js中:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="32ad" class="lk ll iq lg b gy lm ln l lo lp">const router = require(‘./routes/routes’)<br/>app.use(‘/’,router)</span></pre><p id="9a7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在服务器中将没有路由。server.js的最终代码如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e80c" class="lk ll iq lg b gy lm ln l lo lp">require(‘dotenv’).config()</span><span id="ce6d" class="lk ll iq lg b gy mm ln l lo lp">const express = require(‘express’); // importing Express<br/>const app = express(); // instance of express<br/>const port = process.env.PORT || 3000; // Defining port by environmental parameter or 3000</span><span id="0cc8" class="lk ll iq lg b gy mm ln l lo lp">const router = require(‘./routes/routes’)<br/>app.use(‘/’,router)</span><span id="3734" class="lk ll iq lg b gy mm ln l lo lp">// App is listening to user-defined port or 300 and printing the information to the console.</span><span id="d094" class="lk ll iq lg b gy mm ln l lo lp">app.listen(port, function (req, res) {<br/>console.log(`Server is listening on port ${port}!`)<br/>})</span></pre><p id="1301" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用test.rest测试端点。它应该返回200个http代码，所有端点都应该工作正常。</p><h2 id="da5c" class="lk ll iq bd lq lr ls dn lt lu lv dp lw kn lx ly lz kr ma mb mc kv md me mf mg bi translated">将您的代码推送到Github</h2><p id="6c63" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">现在您已经完成了编码和测试。让我们将您的代码推送到您的github。我假设您已经安装了git，否则您可以通过以下命令来安装:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1643" class="lk ll iq lg b gy lm ln l lo lp">$ sudo apt install git</span><span id="ab44" class="lk ll iq lg b gy mm ln l lo lp">$ git config — global user.name “username”</span><span id="bec4" class="lk ll iq lg b gy mm ln l lo lp">$ git config — global user.email “email”</span></pre><p id="eafc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">运行以下命令将您的代码推送到github(它可能会要求您提供git用户名和密码) :</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="730f" class="lk ll iq lg b gy lm ln l lo lp">$ git add .</span><span id="6783" class="lk ll iq lg b gy mm ln l lo lp">$ git ommit -m “Your commit message”</span><span id="7e81" class="lk ll iq lg b gy mm ln l lo lp">$ git push</span></pre><p id="2a1c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">祝贺您第一次开发rest api！我很喜欢写这前两部分，我希望你也喜欢阅读和创建你的第一个API。在下一部分中，我将讨论一些更重要的话题。如果你在阅读这篇文章的过程中遇到任何困难，可以问我任何问题。</p></div></div>    
</body>
</html>