<html>
<head>
<title>Angular — Tips and tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">棱角——技巧和窍门</h1>
<blockquote>原文：<a href="https://itnext.io/angular-tips-and-tricks-ec7f548670c1?source=collection_archive---------0-----------------------#2018-06-27">https://itnext.io/angular-tips-and-tricks-ec7f548670c1?source=collection_archive---------0-----------------------#2018-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6f69727a298f7d36033522357bdb8119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*p2bB2nGlksPyJwvh-PJClg.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片来源:<a class="ae jy" href="http://gatewayacademyindia.com/blog/gate/tips-and-tricks-to-crack-gate-exam/" rel="noopener ugc nofollow" target="_blank">http://gatewayacademyindia . com/blog/gate/tips-and-tricks-to-crack-gate-exam/</a></figcaption></figure><blockquote class="jz"><p id="b4d1" class="ka kb iq bd kc kd ke kf kg kh ki kj dk translated"><em class="kk">这篇文章旨在展示一些可以在Angular中使用的技巧，使代码更加整洁</em>并提高应用程序的性能。</p></blockquote><p id="b509" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh kj ij bi translated">最近，我在Angular中完成了一个项目，在这个过程中，我学到了一些东西，可能会为其他开发人员提供一些有用的指导。所以，如果你是第一次潜入<strong class="kn ir"> Angular </strong>或者只是在寻找一个更好的方法来管理你的Angular项目，这里有一些你可能想在这个过程中记住的提示和技巧。</p><ol class=""><li id="78ab" class="li lj iq kn b ko lk ks ll kw lm la ln le lo kj lp lq lr ls bi translated"><strong class="kn ir">取消订阅RxJS observables <br/> </strong>每次组件或指令被销毁时，对observables的订阅仍然有效。所以重要的是取消订阅它来释放系统中的内存，否则，你会有内存泄漏。<br/>有许多方法，但我更喜欢使用<strong class="kn ir"> takeUntil </strong>函数:</li></ol><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="501b" class="mc md iq ly b gy me mf l mg mh"><em class="mi">import </em>{ Component, OnDestroy, OnInit } <em class="mi">from </em>"@angular/core";<br/><em class="mi">import </em>{ Observable, Subject, interval } <em class="mi">from </em>"rxjs";<br/><em class="mi">import </em>{ takeUntil } <em class="mi">from </em>"rxjs/operators";<br/><br/>@Component({<br/>    selector: "app-test",<br/>    template: `&lt;div&gt;Test&lt;/div&gt;`<br/>})<br/><em class="mi">export class </em>TestComponent implements OnDestroy, OnInit {<br/>    private destroyed$ = <em class="mi">new </em>Subject&lt;<em class="mi">void</em>&gt;();<br/><br/>    private ticks$ = interval(1000);<br/><br/>    public ngOnInit() {<br/>        <em class="mi">this</em>.ticks$<br/>            .pipe(takeUntil(<em class="mi">this</em>.destroyed$))<br/>            .subscribe(data =&gt; console.log(data));<br/>    }<br/><br/>    public ngOnDestroy() {<br/>        <em class="mi">this</em>.destroyed$.next();<br/>        <em class="mi">this</em>.destroyed$.complete();<br/>    }<br/>}</span></pre><p id="940f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">你可以在这里阅读更多关于<strong class="kn ir"> takeUntil </strong>函数:<a class="ae jy" href="http://reactivex.io/documentation/operators/takeuntil.html" rel="noopener ugc nofollow" target="_blank">http://reactivex.io/documentation/operators/takeuntil.html</a></p><p id="092b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">如果你喜欢decorators，你可以看看这个包，它提供了一个声明性的方法来取消订阅组件被破坏时的observables:<a class="ae jy" href="https://github.com/NetanelBasal/ngx-take-until-destroy" rel="noopener ugc nofollow" target="_blank">https://github.com/NetanelBasal/ngx-take-until-destroy</a></p><p id="df4f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><em class="mi"> PS:如果你正在使用</em><strong class="kn ir"><em class="mi">async pipe</em></strong><em class="mi">就不用担心退订了，因为它</em> <strong class="kn ir"> <em class="mi"> </em> </strong> <em class="mi">会自动退订。此外，take(n)、takeWhile(谓词)、first()和first(谓词)之外的方法会自行取消订阅。</em></p><p id="f9a8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> 2。使用类型脚本别名创建更性感的导入</strong></p><p id="65e0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">当代码库开始增长时，您将看到如下导入:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="090c" class="mc md iq ly b gy me mf l mg mh">import { MyComponent } from '../../../../../../shared/components/mycomponent'</span></pre><p id="563d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">这是非常烦人的，因为你不知道你需要写多少点-点-斜线才能到达正确的位置。实际上，Typescript编译器允许使用<a class="ae jy" href="https://www.typescriptlang.org/docs/handbook/module-resolution.html" rel="noopener ugc nofollow" target="_blank">路径映射</a>，所以我们可以像这样导入我们的文件:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="87f2" class="mc md iq ly b gy me mf l mg mh">import { MyComponent } from '@shared/components/mycomponent'</span></pre><p id="6604" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">我们需要做的就是在<code class="fe mm mn mo ly b">tsconfig.json</code>文件的<code class="fe mm mn mo ly b">compilerOptions</code>部分定义<code class="fe mm mn mo ly b">paths</code>和<code class="fe mm mn mo ly b">baseUrl</code>属性。重要的是要知道所有的<code class="fe mm mn mo ly b">paths</code>都是相对于<code class="fe mm mn mo ly b">baseUrl.</code>来解析的</p><p id="4237" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">示例:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9103" class="mc md iq ly b gy me mf l mg mh">{<br/>    "compilerOptions": {<br/>    ...<br/>    "baseUrl": "./src",<br/>        "paths": {<br/>            "@shared/*":["app/modules/shared/*"],<br/>            "@core/*":["app/modules/core/*"]<br/>        }<br/>    ...<br/>    }<br/>}</span></pre><p id="5b42" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> 3。在*ngFor中使用track by</strong></p><p id="b24d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">当我们使用<strong class="kn ir"> *ngFor </strong>指令时，DOM的变化由对象标识来跟踪。这对于大多数情况来说没问题，但是随着不可变实践和Redux的引入，我们每次都有新的对象。这意味着每次<strong class="kn ir"> *ngFor </strong>都会在DOM中渲染列表，但是我们知道DOM操作代价很大。</p><p id="83bb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">当我们将<strong class="kn ir"> trackBy </strong>与* <strong class="kn ir"> ngFor </strong>一起使用时，它开始由给定标识而不是由对象标识跟踪的变更传播。</p><p id="ddc2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">示例:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="832d" class="mc md iq ly b gy me mf l mg mh">&lt;div *ngFor="let post of posts;trackBy:trackByFn"&gt;&lt;/div&gt;</span><span id="99de" class="mc md iq ly b gy mp mf l mg mh">...</span><span id="074c" class="mc md iq ly b gy mp mf l mg mh">identify(index,item){<br/>    return item.id;<br/>}</span></pre><p id="cd7e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">更多关于<strong class="kn ir"> trackBy </strong>的信息可以在这里找到<strong class="kn ir">:</strong><a class="ae jy" href="https://netbasal.com/angular-2-improve-performance-with-trackby-cc147b5104e5" rel="noopener ugc nofollow" target="_blank">https://net basal . com/angular-2-improve-performance-with-track by-cc 147 b 5104 e 5</a></p><p id="ce9b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> 4。使用接口代替类</strong></p><p id="7ffa" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">有时我们需要一些服务器数据的模型或定义。这些接口可用于此目的，而不会给最终输出带来额外开销。与类不同，接口在构建创建期间被完全移除，因此它们不会向我们的最终包添加任何不必要的代码。</p><p id="d240" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> 5。清除生产中的所有控制台日志</strong></p><p id="1445" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">在开发过程中，我们写了很多<code class="fe mm mn mo ly b">console.logs</code>来调试我们的应用程序，有时我们会显示一些我们不想让用户看到的信息。我们可以使用几行用于生产构建的代码非常简单地删除它。</p><p id="2c71" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">在<code class="fe mm mn mo ly b">main.js</code>中添加此内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="64aa" class="mc md iq ly b gy me mf l mg mh"><em class="mi">import </em>{ environment } <em class="mi">from </em>'./environments/environment';<br/><br/><em class="mi">if </em>(environment.production) {<br/>    <em class="mi">// Remove console logs in production<br/>    </em>window.console.log = () =&gt; {<br/>    };<br/>    enableProdMode();<br/>}</span></pre><p id="63c2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">6。使用和<code class="fe mm mn mo ly b"><a class="ae jy" href="https://www.npmjs.com/package/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank">webpack-bundle-analyzer</a></code>检查您的包</p><p id="2d8d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">分析bundle这是提升app性能的一个好的开始。可视化webpack输出有助于您理解包的组成，了解哪些模块占用了其中的空间，并识别不必要的依赖关系。</p><p id="6c98" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">这就是观想的样子:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/32c44fff422110094f27e11d34ee68b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dusVhPiL44VDoS4gJHMWSg.gif"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">(来自<a class="ae jy" href="https://github.com/webpack-contrib/webpack-bundle-analyzer" rel="noopener ugc nofollow" target="_blank">github.com/webpack-contrib/webpack-bundle-analyzer</a>的屏幕记录)</figcaption></figure><p id="3a44" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">关于这个工具的更多信息，你可以在这里阅读:<a class="ae jy" href="https://alligator.io/angular/bundle-size/" rel="noopener ugc nofollow" target="_blank">https://alligator.io/angular/bundle-size/</a></p><p id="c3ab" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> 7。不要偷懒加载默认路由</strong></p><p id="54a6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">延迟加载模块这是一个很好的特性，可以帮助我们减少启动时间，按需加载代码。我们不需要在启动时加载所有东西，我们只需要在应用加载时加载用户期望看到的内容。一个不好的做法是延迟加载默认路由。</p><p id="813f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">假设我们有以下配置:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="231a" class="mc md iq ly b gy me mf l mg mh">const routes: Routes = [<br/>  { path: '', redirectTo: '/mymodule', pathMatch: 'full' },<br/>  { path: 'mymodule', loadChildren: './mymodule.module#MyModule' }<br/>];</span></pre><p id="777a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">当用户打开应用程序时，他将被重定向到<code class="fe mm mn mo ly b">/mymodule </code>路由，这将触发<code class="fe mm mn mo ly b">MyModule.</code>的延迟加载。这将触发一个额外的HTTP调用来下载<code class="fe mm mn mo ly b">mymodule.module</code>，并将执行一些不必要的操作(解析和评估JavaScript VM)。结果，这会降低初始页面呈现的速度。因此，将默认页面路由声明为非懒惰是一个很好的做法。</p><p id="1d14" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> 8。使用自定义错误处理程序捕获所有错误</strong></p><p id="1b1f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir"> Angular </strong>提供了一个内置的<strong class="kn ir">全局异常处理</strong>服务，这样当一个错误发生时，这个服务将捕获它，并将错误细节打印在控制台中。我们可以扩展这个异常处理程序来添加一些额外的功能，比如出于分析或其他原因将错误发送到您的后端服务器。</p><p id="9f8f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><em class="mi">扩展Angular的错误处理程序</em></p><p id="ccfc" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">扩展Angular的错误处理程序这是一个简单的任务。我们需要做的就是创建一个扩展Angular的<code class="fe mm mn mo ly b">ErrorHandler</code>并覆盖<code class="fe mm mn mo ly b">handleError</code>方法的类。</p><p id="0821" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">示例:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="df27" class="mc md iq ly b gy me mf l mg mh"><em class="mi">import </em>{ErrorHandler} <em class="mi">from </em>'@angular/core';<br/><br/><em class="mi">export class App</em>ErrorHandler <em class="mi">extends </em>ErrorHandler {<br/>    constructor(){<br/>        <em class="mi">super</em>(<em class="mi">false</em>);<br/>    }<br/><br/>    public handleError(error: any): <em class="mi">void </em>{<br/>        <em class="mi">// Add your logic here.<br/>        super</em>.handleError(error);<br/>    }<br/>}</span></pre><p id="786e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">之后，我们应该在<code class="fe mm mn mo ly b">app.module.ts:</code>中注册我们的自定义<code class="fe mm mn mo ly b">AppErrorHandler</code></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b197" class="mc md iq ly b gy me mf l mg mh"><a class="ae jy" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>    declarations: [ AppComponent ],<br/>    imports: [ BrowserModule ],<br/>    bootstrap: [ AppComponent ],<br/>    providers: [<br/>        {provide: ErrorHandler, useClass: AppErrorHandler}<br/>    ]<br/>})</span></pre><p id="f699" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">更多信息可以在这里找到:<a class="ae jy" href="https://www.loggly.com/blog/angular-exception-logging-made-simple/" rel="noopener ugc nofollow" target="_blank">https://www . log Gly . com/blog/angular-exception-logging-made-simple/</a></p><p id="a7b4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir">奖金</strong>:</p><p id="7129" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated"><strong class="kn ir">将您的console.log参数包装在一个对象文字中，以打印变量名及其值。</strong> <br/> <code class="fe mm mn mo ly b">console.log(isLoggedIn) <br/>console.log({ isLoggedIn })</code></p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mv"><img src="../Images/8ac9e1bbf47b3e17b6ffee99441b63a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDMs1yKoVtDrEivHULR8Qg.jpeg"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">来源:<a class="ae jy" href="https://twitter.com/DaniStefanovic/status/1011923716085821440" rel="noopener ugc nofollow" target="_blank">https://Twitter . com/DaniStefanovic/status/1011923716085821440</a></figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="ee29" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw mj ky kz la mk lc ld le ml lg lh kj ij bi translated">感谢阅读这篇文章，我希望你喜欢它！如果你有一些其他的技巧和诀窍分享，写在评论里吧。</p></div></div>    
</body>
</html>