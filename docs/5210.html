<html>
<head>
<title>Level-up your TypeScript game with decorators and transformers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用装饰者和变形金刚升级你的打字游戏</h1>
<blockquote>原文：<a href="https://itnext.io/level-up-your-typescript-game-with-decorators-and-transformers-333cfdaf284a?source=collection_archive---------2-----------------------#2021-01-13">https://itnext.io/level-up-your-typescript-game-with-decorators-and-transformers-333cfdaf284a?source=collection_archive---------2-----------------------#2021-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/19fe27d5d36e79fbe72eab2b74b8ed38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EQyOhPY9HPVkTj7OA66kA.jpeg"/></div></div></figure><p id="8838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">立刻:TypeScript是一种令人惊叹的编程语言。它让您可以编写更好的代码，在设计时发现大多数(如果不是全部)错误，而不是在运行时爆发(尽管如此，还是要对您的错误处理给予一些爱，永远💖)这是一种真正成熟的语言，在全球范围内以及在<a class="ae kw" href="https://cloudsoft.io" rel="noopener ugc nofollow" target="_blank">云软</a>的工程师中受到了广泛关注。</p><p id="4505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我想和你分享两个可以极大地增强你的开发工作流程的特性。这些是:</p><ol class=""><li id="925a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">TypeScript的一个众所周知但未被充分利用的特性:<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">decorator</strong></a>。</li><li id="e899" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">TypeScript的一个未知且不公开的特性:<strong class="ka ir"> transformers </strong>。</li></ol><p id="bb82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还将向您展示这些功能联合使用时所释放的真正酷的东西。好了，我们走吧！</p><h1 id="235b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">打字稿装饰工，他们是什么？</h1><p id="00d1" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果你熟悉编程，有一个同义词你可能已经知道:<strong class="ka ir">注释</strong>。Decorators不是一个TypeScript特性，但实际上来自JavaScript，是一个<a class="ae kw" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank"> stage 2 proposal </a>。它们的核心只是JavaScript函数，可以“挂钩”到类、方法、访问器、属性或参数。</p><p id="7942" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当由TypeScript传输时，decorators包装这些资源来执行元操作。例如，假设您希望以同样的方式初始化几个类，但是您也需要为其中的几个类覆盖这个初始化。编写一个装饰器来注释你的类，让你可以做到这一点，而且不会有什么麻烦:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行此示例将输出:</p><blockquote class="mu mv mw"><p id="15e9" class="jy jz mx ka b kb kc kd ke kf kg kh ki my kk kl km mz ko kp kq na ks kt ku kv ij bi translated">给猎鹰9号加了100吨燃料。准备发射🚀<br/>给星舰加250吨燃料。准备发射🚀</p></blockquote><p id="1399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你看一下transpiled的JavaScript代码，构造函数被decorator函数包装，这就是如何设置<code class="fe nb nc nd ne b">fuel</code>属性的。因为这些方法只是包装器，所以它们几乎只在运行时使用。但是如果我告诉你你也可以在编译时使用decorators呢？</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nf mt l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">不会吧，真的吗？</figcaption></figure><p id="b0ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没错，基于decorators，您可以在编译时执行任意操作，这就是令人兴奋的地方！剧透:如果你用过Angular，那就是装饰师<code class="fe nb nc nd ne b">@Component</code>和<code class="fe nb nc nd ne b">@Inject</code>在幕后发生的事情。</p><h1 id="14d4" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">看打字变形金刚</h1><p id="9c3d" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">对于熟悉Java的人来说，您可以将转换器视为注释处理器。虽然，这些功能更强大——在我看来也更酷——因为它们不仅可以生成内容，还可以访问和更新正在处理的文件的<a class="ae kw" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>。</p><p id="bd58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然转换器对于TypeScript编译器来说是一个完全有效的概念，但是API并没有公开。所以要使用它，你需要自己的 <code class="fe nb nc nd ne b"><em class="mx">tsc</em></code> <em class="mx">编译器的包装器，或者像</em> <code class="fe nb nc nd ne b"><em class="mx">ttypescript</em></code> <em class="mx">这样的节点模块，或者使用</em> <code class="fe nb nc nd ne b"><em class="mx">webpack</em></code> <em class="mx">。</em></p><p id="fcaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本转换器是一个递归函数，它将AST节点作为参数，并返回一个AST节点。返回的节点可以是同一个节点(没有修改)，也可以是不同的节点，或者是从AST中删除的节点。</p><p id="2441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，下面的例子是一个身份转换器，它递归地进入每个节点，并直接返回它。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3cb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是只要有一点点想象力，你就能看到它有多强大。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nk mt l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">变形一切！</figcaption></figure><h1 id="c63c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">无限的可能性</h1><p id="276c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">那么你能用它做什么呢？很高兴你这么问。</p><p id="f72f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我举的最突出的例子是我们为一个客户开发和维护的一个大的、现实生活中的ServiceNow范围的应用程序(也就是插件的ServiceNow术语)。现在，我已经看到人们在逃跑，一提到服务就像看到了一群僵尸一样尖叫。现在:别担心，我不会谈论这个。嗯……不完全是，但是我必须和你分享一些背景，这样你就能理解为什么我想出了一个包含这两个特性的技术解决方案。</p><h1 id="9b15" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">语境</h1><p id="814f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我保证，我会长话短说。让我从30，000英尺的高度给你一个概述，而不是一头扎进ServiceNow的世界。当你为ServiceNow开发一个作用域应用的时候，你必须使用他们的“IDE”，也就是所谓的“Studio”。一个限定了作用域的应用程序由“应用程序文件”组成，大多数时候，这些文件是附加了元数据的JavaScript脚本。ServiceNow使用一个定制的Rhino引擎来执行这些介于ES5和ES6规范之间的脚本，因此JavaScript在过去几年中带来的大多数酷东西都不能开箱即用，或者需要<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Glossary/Polyfill" rel="noopener ugc nofollow" target="_blank">polyfill</a>。</p><p id="cd88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作用域应用程序可以进行版本控制，尽管因为每个应用程序文件实际上都是ServiceNow DB上的一条记录，所以最终在git上的实际文件是这些记录的序列化，以XML文件的形式。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nl mt l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">哇，这比预期的要难说…</figcaption></figure><p id="21ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，你还听得见我吗？太好了，对你来说是个好消息:现在🥳部分的服务结束了</p><p id="f86d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过仅使用studio开始了我们在作用域应用程序世界中的开发之旅。然而，我们很快就遇到了障碍，我刚才解释的后果是:</p><ol class=""><li id="b82f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">拉请求是一场噩梦:我们必须比较序列化代码+来自数据库记录元数据(例如时间戳、ACL等)的噪音。</li><li id="9fc8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">没有办法对我们的代码进行单元测试。</li><li id="488a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">作为开发人员，我们不能使用我们选择的IDE，因此没有内联帮助，没有代码完成，什么都没有。</li></ol><p id="687e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们接下来做的事情可能有点疯狂，但这是解决上面3点的最明智的方法:<strong class="ka ir">我们创建了另一个git repo来存储这些脚本，并将几乎所有内容转换成TypeScript </strong>。</p><p id="ee60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有的发展都发生在这个“新的”git回购中，并且仍然在发生。我们的代码现在结构良好，更加健壮，经过测试，并且由于TypeScript，我们可以享受IDE提供的所有开发助手。</p><p id="ad57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这种工作方式引入了一个主要缺点:对于类型脚本文件中的任何更改，transpiled JavaScript版本都需要手动复制粘贴到“Studio”中正确的“应用程序文件”上。这不仅乏味而且非常容易出错。随着时间的推移，我们想出了一个过程来减少错误并尽早发现它们，但该过程仍然是手动的，远远不够理想。</p><p id="db1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">肯定有更好的方法🤔</p><h1 id="51b0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">技术上令人敬畏的方式</h1><p id="907d" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我带着以下问题开始了我的探索:</p><blockquote class="nm"><p id="ad02" class="nn no iq bd np nq nr ns nt nu nv kv dk translated">如果我们有办法知道从TypeScript中更新哪个“应用程序文件”会怎么样？</p><p id="a72e" class="nn no iq bd np nq nr ns nt nu nv kv dk translated">如果它可以自动部署呢？</p><p id="5943" class="nn no iq bd np nq nr ns nt nu nv kv dk translated">实现这一目标需要什么？</p></blockquote><p id="0098" class="pw-post-body-paragraph jy jz iq ka b kb nw kd ke kf nx kh ki kj ny kl km kn nz kp kq kr oa kt ku kv ij bi translated">你知道这是怎么回事，对吧？以显而易见为代价，我使用了打字稿<strong class="ka ir">装饰</strong>和<strong class="ka ir">变形金刚</strong>来做以下事情:</p><ol class=""><li id="5a95" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">每个TypeScript文件都用一个<code class="fe nb nc nd ne b">@Deployable</code>装饰器进行了注释，该装饰器将表名、列名以及记录的ID作为参数。这是为了知道要更新什么记录以及在哪里更新。</li><li id="de89" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在编译项目时，一个定制的转换器会寻找任何<code class="fe nb nc nd ne b">@Deployable</code>decorator，执行一个快速验证来检查一切是否正常，然后存储TypeScript和JavaScript文件的路径，以及来自(1)的参数。</li><li id="a6a8" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在编译结束时,( 2)的对象被序列化为JSON，并被写入磁盘的输出文件夹中。</li></ol><p id="36c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但你是来找代码的，不是吗？这就是:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">@Deployable注释目前正在我们的项目中使用。</figcaption></figure><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="68c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，转换器会寻找任何<code class="fe nb nc nd ne b">@Deployable</code>装饰者。但是，decorators只能应用于类、方法、属性和参数。我们的代码库还包含脚本，这些脚本是我也需要部署的<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生命函数</a>。解决方案是在评论中寻找<code class="fe nb nc nd ne b">@Deployable</code>装饰者。当转换器遇到一个时，它会动态创建一个<code class="fe nb nc nd ne b">Node</code>,并将其解析为一个常规节点。</p><p id="4b6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要注意，当转换器遇到注释时，它会返回<code class="fe nb nc nd ne b">undefined</code>。这有效地从AST中移除了装饰器，意味着transpiled版本与没有装饰器的TypeScript脚本相同。</p><p id="254e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在<code class="fe nb nc nd ne b">yargs</code>的帮助下，我施了一点魔法，在我们的项目中创建了一个小的CLI工具来封装上面的逻辑，并把一切都打包好。这意味着通过一个命令，该工具将:</p><ol class=""><li id="016f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">与<code class="fe nb nc nd ne b">master</code>分支相比，获取已更改文件的列表。</li><li id="53d6" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">使用我的自定义transformer + decorator编译项目。</li><li id="0be2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">从转换器中读取输出JSON，并进行迭代。</li><li id="6fa0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">对于每个条目，查询ServiceNow实例以用新的transpiled版本更新记录。</li></ol><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/0a3b62c7fe5908c5eae27b27f1ee2838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9LkVI_4Ldo92db3sG6JFeA.gif"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">🪄，这一定是魔法！</figcaption></figure><h1 id="bcc0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="57ee" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">凭借一点创造力和不到300行代码，TypeScript decorators和transformers将一个容易出错且冗长的过程变成了一个非常简单的过程。用一个我称之为优雅的解决方案解决了我们最大的瓶颈之一，这是一个快速、可靠而且非常酷的解决方案。</p><p id="0aad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这不是唯一的用例。您可以使用这些来:</p><ul class=""><li id="a119" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv oc ld le lf bi translated">生成文档。</li><li id="58a1" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv oc ld le lf bi translated">基于decorators生成模型类。</li><li id="2220" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv oc ld le lf bi translated">初始化实例和行为。</li><li id="75f5" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv oc ld le lf bi translated">执行静态分析。</li><li id="d2c0" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv oc ld le lf bi translated">等等。</li></ul><p id="d6eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你对如何使用这个有其他的想法吗？它能解决你组织中的问题吗？我很想听听你的想法！</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="4a6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mx">最初发布于2020年1月13日</em><a class="ae kw" href="https://cloudsoft.io/blog/level-up-your-typescript-game" rel="noopener ugc nofollow" target="_blank"><em class="mx">https://cloud soft . io</em></a><em class="mx">。</em></p></div></div>    
</body>
</html>