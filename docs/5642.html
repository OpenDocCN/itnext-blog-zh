<html>
<head>
<title>The webworkers driven UI framework neo.mjs version 2 release announcement</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">webworkers驱动的UI框架neo.mjs第2版发布公告</h1>
<blockquote>原文：<a href="https://itnext.io/the-webworkers-driven-ui-framework-neo-mjs-version-2-release-announcement-b91b476d6f16?source=collection_archive---------0-----------------------#2021-04-23">https://itnext.io/the-webworkers-driven-ui-framework-neo-mjs-version-2-release-announcement-b91b476d6f16?source=collection_archive---------0-----------------------#2021-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="90fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新产品的概念必须是颠覆性的，否则就没什么必要。但是，使用它们的方式应该尽可能一致。</p><p id="41c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个框架来说，这意味着关于如何使用它的API应该坚如磐石，尤其是在涉及到新版本的时候。从<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a> v1迁移到v2是小菜一碟。</p><p id="bdc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文假设您还不熟悉这个项目，所以我们也将介绍一些基础知识。</p><h1 id="5006" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">内容</h1><ol class=""><li id="e935" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">花瓶角色</li><li id="20ee" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">设计目标</li><li id="0869" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">版本2中有什么新内容？</li><li id="6a5f" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">统计数字</li><li id="9eac" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">如何设置我的第一个neo.mjs应用程序？</li><li id="6c05" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">如何从v1迁移到v2？</li><li id="f59b" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">学neo.mjs有多难？</li><li id="a639" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">什么时候该用neo.mjs？</li><li id="60b5" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">什么是配置系统？</li><li id="e56b" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">路标</li><li id="3a59" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">最后的想法</li><li id="056f" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">特别感谢</li></ol><h1 id="b132" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.花瓶角色</h1><p id="b36d" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">让我们看看不使用<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a>难以实现的用例:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a2fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个扩展到多个浏览器窗口的单页应用程序。该应用程序可以在不需要后端的情况下进行通信。</p><p id="1ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">桌面浏览器是强制性的，最好在Chrome或Edge上，也可以在Firefox上运行:【neo.mjs/dist/production/apps/sharedcovid/<a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/apps/sharedcovid/index.html#country=Germany" rel="noopener ugc nofollow" target="_blank"/></p><p id="7d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了对性能有一个印象，尝试螺旋:使用魔法鼠标或触控板，您可以水平滚动。</p><p id="d210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致本地每秒30.000次dom操作。螺旋是有意构建的，以强调浏览器→每个项目是一个dom节点(没有画布，svg，webGL)。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mk mj l"/></div></figure><p id="2cc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">drop上的基本情况是:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="8dd9" class="mq kn iq mm b gy mr ms l mt mu">dialog.unmount();</span><span id="725d" class="mq kn iq mm b gy mv ms l mt mu">dialog.appName = 'SharedDialog2'; // name of the other window app</span><span id="21bf" class="mq kn iq mm b gy mv ms l mt mu">dialog.mount();</span></pre><p id="5793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我们正在重用同一个对话框JS实例。</p><div class="mw mx gp gr my mz"><a href="https://medium.com/geekculture/web-based-multi-screen-apps-including-drag-drop-5e161da6507b" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">基于网络的多屏幕应用，包括拖放</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">我对这个话题很感兴趣，因为我们将要谈论的技术为新一代的…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn no mz"/></div></div></a></div><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0bb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以轻松地将复杂的依赖关系惰性加载到应用程序工作人员中。</p><p id="e17e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也适用于分销/生产。更好的是，我们确实可以在不同的应用程序之间进行分割。意思是:你可以用很少的开销在同一个页面上添加多个应用。</p><div class="mw mx gp gr my mz"><a href="https://medium.com/swlh/cross-app-bundling-a-different-approach-for-micro-frontends-e4f212b6a9a" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">跨应用捆绑——微前端的一种不同方法</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">捆绑分布式版本的应用程序代码一直是一个挑战，尤其是在您想要共享代码的情况下…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="np l nk nl nm ni nn no mz"/></div></div></a></div><h1 id="17b5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.设计目标</h1><p id="8193" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">neo.mjs概念具有颠覆性:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/f8275763b766c57c6bba974ef13f9886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5Ia7BWzIyC9KSmCf_4zzQ.png"/></div></div></figure><ol class=""><li id="1811" class="lk ll iq jp b jq jr ju jv jy nw kc nx kg ny kk lr ls lt lu bi translated">多线程:框架的大部分部分以及您自己的应用程序代码都在app worker内部运行。这使得主线程大部分时间处于空闲状态，从而带来惊人的渲染性能，尤其是在动态操作DOM时。</li><li id="d4df" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">可扩展性和可伸缩性:您几乎可以扩展和更改任何东西。你只会得到你实际使用的代码。你可以偷懒加载模块，甚至可以获得跨应用拆分块。</li><li id="35ab" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">建立在web标准之上:只要最新的ECMAScript x特性在所有主流浏览器中可用，neo.mjs就会使用它们。</li><li id="40bc" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">“将UI开发带回浏览器”<br/> neo.mjs是极少数不在node内部进行UI开发的项目之一，在更改代码时，您不需要任何构建或编译。开发模式可以直接在浏览器中运行框架和应用程序代码。目前仍然局限于Chromium，因为Safari(即将推出)和Firefox还不支持在worker范围内使用JS模块。调试真实代码已经为我节省了很多时间。</li><li id="2493" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">dist/production(基于webpack)必须在所有主流浏览器中运行。</li><li id="7c23" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">基于持久json的虚拟dom结构。根本没有模板。您也可以用基于json的格式定义组件树。JS这边说了算。您可以控制是否要销毁实例，或者是否要保留实例以供以后重用。</li><li id="625e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">使用虚拟dom引擎是可选的，您可以手动构造增量更新，以防您确切地知道应该改变什么来进一步提升性能。</li><li id="9d3b" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">您可以在neo.mjs docs应用程序中获得自己的应用程序代码的文档视图</li></ol><h1 id="6760" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.版本2中有什么新内容？</h1><p id="9120" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a> v2版本主要是为您提供新的方法，使您的应用程序的状态管理更容易，以及增强您的前端架构。</p><p id="d0cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写了两篇独立的文章来详细介绍视图模型的实现:</p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/enhance-your-frontend-state-management-with-view-models-7bf49e1a0991"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用视图模型增强您的前端状态管理</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">您很可能使用过MobX、Redux或React上下文API。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">itnext.io</p></div></div><div class="ni l"><div class="nz l nk nl nm ni nn no mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://tobiasuhlig.medium.com/enhance-your-frontend-state-management-with-view-models-part2-5a9384bd863c" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用视图模型增强您的前端状态管理—第2部分</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">设计目标&amp;谈基于模板文字的视图模型实现。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">tobiasuhlig.medium.com</p></div></div><div class="ni l"><div class="oa l nk nl nm ni nn no mz"/></div></div></a></div><p id="221f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从基于字符串的绑定格式化程序到包含模板文字的函数，使用视图模型的方式得到了改进。</p><p id="4e0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为第一个突破性的变化之一，我利用这个机会最终完成了期待已久的版本2的发布。</p><p id="f8ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于多窗口应用程序来说，视图模型变得非常强大，因为您可以将一个应用程序(窗口)中主容器的父模型指向另一个应用程序(窗口)中的视图模型。<strong class="jp ir">这是跨浏览器窗口访问数据的一种非常好的方式。</strong></p><p id="2da8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要使用视图模型或视图控制器来创建定制组件，即使它们很复杂并且使用多个视图(比如日历或表格实现)。</p><p id="8e09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于v2，view控制器的内部工作方式发生了变化。以前，只有拥有自己控制器的组件才触发<code class="fe ob oc od mm b">parseConfig()</code>，它们向下解析它们的项目，直到找到一个拥有自己控制器的项目。在v2中，每个组件都将在父树中最近的控制器上触发<code class="fe ob oc od mm b">parseConfig()</code>,并且只有顶层被解析。优点:您现在可以动态添加包含基于字符串的侦听器的新组件。</p><p id="e050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我一直努力保持项目依赖关系(npm包)是最新的。现在随着<a class="ae kl" href="https://nodejs.org/en/blog/release/v16.0.0/" rel="noopener ugc nofollow" target="_blank">节点v16版本</a>的发布，一些事情需要改变。</p><p id="822c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">neo.mjs仍然在使用node-sass (libsass ),因为基于c的编译器听起来很迷人。dart-sass更名为sass，并成为官方标准:</p><div class="mw mx gp gr my mz"><a href="https://sass-lang.com/install" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">安装Sass</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">有许多应用程序可以让您在几分钟之内在Mac、Windows和…上使用Sass</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">sass-lang.com</p></div></div></div></a></div><p id="a623" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好消息</strong>:开关工作非常流畅，我们可以继续使用最新的scss功能。</p><p id="a0fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">node-sass和<a class="ae kl" href="https://github.com/webpack/webpack-dev-server" rel="noopener ugc nofollow" target="_blank"> webpack-dev-server </a>都依赖于一个名为“fibers”的包。这个在node v16+已经不能用了。</p><p id="8036" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">切换到</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="2a90" class="mq kn iq mm b gy mr ms l mt mu">"webpack-dev-server": "4.0.0-beta.2"</span></pre><p id="aa77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除了最后一个“纤程”依赖，所以我们现在应该很好。</p><h1 id="0020" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.统计数字</h1><p id="c0ae" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">出于好奇，几天前我检查了提交的数量:</p><p id="6d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank">neom js/neo</a>5196<br/><a class="ae kl" href="https://github.com/neomjs" rel="noopener ugc nofollow" target="_blank">neom js</a>/* 6347<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/.github/NEOMJS_HISTORY.md" rel="noopener ugc nofollow" target="_blank">pre GA</a>3720</p><p id="a292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，neo.mjs生态系统总共有<strong class="jp ir"> 10.067次提交</strong>。</p><p id="9e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">sloc应用程序物理17133，来源:11054 <br/> sloc构建脚本物理2036，来源:1709 <br/> sloc示例物理11005，来源:8805 <br/> sloc资源/scss物理6697，来源:5842 <br/> sloc src物理42032，来源:22393</p><p id="3c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是为了得到一个印象。</p><h1 id="4bf9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.如何设置我的第一个neo.mjs应用程序？</h1><p id="01d3" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">neo.mjs命令行界面为您提供了:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mk mj l"/></div></figure><ol class=""><li id="0ccd" class="lk ll iq jp b jq jr ju jv jy nw kc nx kg ny kk lr ls lt lu bi translated">打开您的终端(或cmd)。</li><li id="bffa" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">输入一个文件夹来存储你的项目<br/>(我在这个演示中只使用了桌面)</li><li id="b24d" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">输入“npx neo-app”</li><li id="693f" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">你可以在所有问题上按回车键</li><li id="0801" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">在IDE中打开新生成的工作区文件夹</li><li id="6f74" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">可选:将其部署到存储库(例如GitHub)</li><li id="dceb" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">打开MainContainer.mjs文件</li><li id="b584" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">变更代码</li><li id="419f" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">重新加载浏览器窗口(开发模式不需要任何构建)</li></ol><p id="9daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多信息请点击此处:</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/create-app" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">neomjs/create-app</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用一行程序创建一个新的neo.mjs应用程序(工作区): npx neo-app可以在macOS、Linux和Windows 10上运行。如果错误…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="oe l nk nl nm ni nn no mz"/></div></div></a></div><p id="a7ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果npx neo-app在您的本地环境中不工作，默认输出存储在此处:</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/workspace" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">neom js/工作空间</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">此存储库包含npx neo-app的默认输出。如果npx脚本有任何问题，请感觉…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="of l nk nl nm ni nn no mz"/></div></div></a></div><p id="dcf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">选项2: </strong></p><p id="c05a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以分叉<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neomjs/neo </a>库。package.json包含一个“create-app”程序，它将在框架的apps文件夹中创建一个新的应用程序外壳。</p><p id="dec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想同时处理应用程序代码和框架代码，这种方法尤其有用。</p><h1 id="e33f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">6.如何从v1迁移到v2？</h1><p id="8617" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我仍然记得将一个客户端项目从Sencha ExtJS版本2迁移到版本3。这是一次超级激烈的冲刺，用了整整6周。我自己并不需要处理角度迁移，但是我听说过很多关于早期版本重写的故事。</p><p id="fef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/in/richwaters/" rel="noopener ugc nofollow" target="_blank"> Rich Waters </a>我在设计<a class="ae kl" href="https://github.com/neomjs/neo" rel="noopener ugc nofollow" target="_blank"> neo.mjs </a> API的时候就牢记了这一点。</p><p id="9219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">从v1到v2的迁移可以在10分钟内完成。</strong></p><p id="929e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的应用是1.5以上版本，只需运行<code class="fe ob oc od mm b">npm update</code>和<code class="fe ob oc od mm b">build-all</code>程序。</p><p id="1042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于早期版本，有两种策略:</p><p id="422e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一种(<strong class="jp ir">推荐</strong>)是用同一个app名字运行<code class="fe ob oc od mm b">npx neo-app</code>。然后，您可以用旧的应用程序文件夹替换应用程序文件夹的内容，运行<code class="fe ob oc od mm b">build-all</code>就完成了。</p><p id="f7ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个策略是运行<code class="fe ob oc od mm b">npx neo-app</code>，手动调整旧应用外壳的内容。具体来说:删除node_modules、dist和docs文件夹。手动复制npx输出的新文档文件夹。在您的package.json中调整neo.mjs版本(例如^2.0.4).运行npm安装。运行<code class="fe ob oc od mm b">build-all</code>。</p><p id="e8a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保您的app.mjs文件使用以下格式:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="3aba" class="mq kn iq mm b gy mr ms l mt mu">import MainContainer from './view/MainContainer.mjs';<br/><br/>const onStart = () =&gt; <strong class="mm ir"><em class="og">Neo</em></strong>.app({<br/>    mainView: MainContainer,<br/>    name    : 'MyApp'<br/>});<br/><br/>export {onStart as onStart};</span></pre><h1 id="1aab" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">7.学neo.mjs有多难？</h1><p id="ab83" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我花了相当多的时间让朋友和以前的同事跟上进度。</p><p id="53bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我得到的反馈是，与其他库/框架相比，达到“飞翔”的程度需要更长的时间。根据你的技能水平，可能需要一两个星期。</p><p id="cc76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我也得到了反馈，即<strong class="jp ir">一旦你达到这一点，neo.mjs就更容易掌握</strong>，你可以做得更多。</p><p id="a067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于v1，我们有一个关于如何创建covid演示应用程序的系列教程(2部分)。为v2重写它们可能会有所帮助。我这边有很多工作要做，所以如果你需要的话，请给我一个ping:</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/neo/issues/1817" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">重写“如何创建webworkers驱动的多线程应用程序-第1部分”第1817期neomjs/neo</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">最新的框架和生态系统增强包含了一些变化和改进。“加快速度”…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div></div></a></div><p id="6567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，每个开发人员都问我:<br/>“鸢，窗口和window.document都没有定义，这是怎么回事？”</p><p id="fe07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，你的应用程序代码确实在一个web worker内部运行。</p><div class="mw mx gp gr my mz"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">Web Workers API</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Web Workers使得在独立于主执行线程的后台线程中运行脚本操作成为可能…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="oh l nk nl nm ni nn no mz"/></div></div></a></div><p id="3c53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些例外:例如，你不能直接从一个工人内部操纵DOM，或者使用窗口对象的一些缺省方法和属性</p><p id="9a72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">德语中有一个奇妙的词“Kindersicherung”。<br/>含义:“防止儿童伤害自己的机制”</p><p id="8d17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某种程度上，这适用于Javascript devs和真正的dom。</p><p id="3acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于大多数用例，您真的不需要它，您可以坚持使用虚拟dom。</p><div class="mw mx gp gr my mz"><a href="https://medium.com/dataseries/your-benefits-of-working-with-json-based-virtual-dom-7318a983da9e" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用基于JSON的虚拟DOM的好处</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">许多以前的同事和朋友找到我，问我:“你是如何做到如此高效和快速的……</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="oi l nk nl nm ni nn no mz"/></div></div></a></div><p id="d6d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正有帮助的是查看您生成的应用程序文件:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oj mj l"/></div></figure><p id="32a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">索引文件将<strong class="jp ir">而不是</strong>包含你的应用程序文件，而是主线程起点(这个将创建工人设置)。在dist/production中，主线程文件<strong class="jp ir">只有42KB </strong>。</p><p id="07c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦设置就绪，应用程序工作人员将导入您指定了<code class="fe ob oc od mm b">appPath</code>的app.mjs文件。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oj mj l"/></div></figure><p id="1eca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您愿意，您可以在这里创建多个应用程序，并将它们呈现到一个现有页面的不同div节点中。</p><p id="3e48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序工作人员将使用它能找到的所有app.mjs文件作为动态导入。这就是我们如何获得跨应用程序分割块。</p><p id="f504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近收到一个问题:“我想在我的index.html文件中直接添加一个加载微调器，并在主视图渲染后使用我的neo.mjs应用程序将其删除。它在我们的虚拟世界之外。我能做到吗？”</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="6e0c" class="mq kn iq mm b gy mr ms l mt mu"><strong class="mm ir"><em class="og">Neo</em></strong>.currentWorker.sendMessage('main', {<br/>    action: 'updateDom',<br/>    appName: this.appName,<br/>    deltas: {<br/>        action: 'removeNode',<br/>        id    : 'my-loading-spinner'<br/>    }<br/>});</span></pre><p id="6913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以手动创建增量更新并将其发送到main。一旦这个异步操作完成，如果你想做什么，你可以使用<code class="fe ob oc od mm b">promiseMessage()</code>。小心使用！</p><p id="4cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你也可以创建你自己的主线程插件，例如与其他库一起工作。示例:</p><p id="e24e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/neomjs/neo/tree/dev/src/main/addon" rel="noopener ugc nofollow" target="_blank"> src/main/addon </a></p><p id="7c3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回购自述底部提到:<br/>欢迎加入<a class="ae kl" href="https://join.slack.com/t/neotericjs/shared_invite/enQtNDk2NjEwMTIxODQ2LWRjNGQ3ZTMzODRmZGM2NDM2NzZmZTMzZmE2YjEwNDM4NDhjZDllNWY2ZDkwOWQ5N2JmZWViYjYzZTg5YjdiMDc" rel="noopener ugc nofollow" target="_blank"> neo.mjs Slack频道</a>！</p><p id="858b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我的时间有限，但我会尽力给你指明正确的方向。</p><h1 id="931c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">8.什么时候该用neo.mjs？</h1><p id="8cc7" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我的一句名言是:<br/>“开车去超市不需要跑车。”</p><p id="379c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于相当简单且大多是静态的网站或应用程序，neo.mjs可能不太适合。</p><p id="60a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的应用程序越大越复杂，使用这个框架能为你产生的价值就越多。</p><p id="2157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也适用于创建复杂的(自定义)组件，如螺旋，缓冲网格，日历。</p><p id="149c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，一个很好的用例是一个银行/交易应用程序，您希望使用web sockets通过实时更新来敲打dom。</p><p id="eafa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想基于<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank"> SharedWorkers </a>创建多窗口应用，使用neo.mjs的好处是巨大而独特的。</p><p id="7258" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这个框架仍然专注于桌面应用程序，但是它的总体设置也可以在移动领域大放异彩。还有更多工作要做(见:10。路线图)。</p><h1 id="5f6f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">9.什么是配置系统？</h1><p id="f4ea" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">经常出现的一个问题是:</p><p id="8e13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“为什么会有静态的getConfig()方法？<br/>配置和类字段是一回事吗？”</p><p id="9e69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们快速看一下下面的例子:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="oj mj l"/></div></figure><p id="757f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ob oc od mm b">className</code>实际上可能是一个类字段，因为值不会改变。它也可以是静态的。它不是静态的原因是为了调试的目的:如果您将一个组件树登录到控制台并点击条目，看到<code class="fe ob oc od mm b">className</code>对了解您正在处理的内容非常有帮助。</p><p id="29a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">配置系统有什么好处？</strong></p><p id="26cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们定义一个带有下划线的配置，比如这里的<code class="fe ob oc od mm b">a_</code>，我们可以选择使用<code class="fe ob oc od mm b">beforeGetA()</code>、<code class="fe ob oc od mm b">beforeSetA()</code>和<code class="fe ob oc od mm b">afterSetA()</code>。显然同样适用于<code class="fe ob oc od mm b">b_</code>。</p><p id="764a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，我们将a &amp; b定义为空值。我们在afterSet()方法中使用了<code class="fe ob oc od mm b">this.down()</code>,这在构造项目之前是不可用的。</p><p id="5133" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了保持逻辑简洁，我使用<code class="fe ob oc od mm b">onConstructed()</code>来调用:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="faff" class="mq kn iq mm b gy mr ms l mt mu">this.set({<br/>    a: 5,<br/>    b: 5<br/>});</span></pre><p id="5f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ob oc od mm b">afterSetA()</code>会将标签1的文本配置设置为<code class="fe ob oc od mm b">value + this.b</code>。</p><p id="dd43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ob oc od mm b">afterSetB()</code>会将标签2的文本配置设置为<code class="fe ob oc od mm b">value + this.a</code>。</p><p id="2dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→我们正在处理交叉依赖</p><p id="d175" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们已经通过<code class="fe ob oc od mm b">get()</code>和<code class="fe ob oc od mm b">set()</code>定义了a &amp; b，我们将在真正的setters内部调用自定义的afterSet()方法。</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="55fd" class="mq kn iq mm b gy mr ms l mt mu">Object.assign(this, {<br/>    a: 5,<br/>    b: 5<br/>});</span></pre><p id="3fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，<strong class="jp ir"> a </strong>将首先被赋值，afterSet()调用将label1文本设置为<strong class="jp ir"> 5 </strong> (5+null)。</p><p id="5390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后<strong class="jp ir"> b </strong>会被赋值，afterSet()调用会将label2文本设置为<strong class="jp ir"> 10 </strong> (5+5)。</p><p id="61ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe ob oc od mm b">this.set()</code>的不同之处在于，我们可以立即访问两个新值。<code class="fe ob oc od mm b">this.a</code>和<code class="fe ob oc od mm b">this.b</code>都是非常聪明的吸气剂。</p><p id="2fce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">label1和label2都将得到<strong class="jp ir"> 10 </strong> (5+5)作为它们的文本。</p><p id="8c38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击按钮将触发:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="5ea3" class="mq kn iq mm b gy mr ms l mt mu">this.set({<br/>    a: 10,<br/>    b: 10<br/>});</span></pre><p id="1f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，两个标签文本的值都是<strong class="jp ir"> 20 </strong> (10+10)。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ok"><img src="../Images/261c29dba1bfe46fdbcc4bbf83f96744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3CtGIjVcT8nnR9SUmchTw.png"/></div></div></figure><p id="dd9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">试试看:<a class="ae kl" href="https://neomjs.github.io/pages/node_modules/neo.mjs/dist/production/examples/core/config/index.html" rel="noopener ugc nofollow" target="_blank">dist/production/examples/core/config/index . html</a>(在线演示)</p><p id="9bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置值确实以前导下划线存储。如果您想进行静默更新(不触发beforeSet()和afterSet())，您可以使用<code class="fe ob oc od mm b">this._a = 7</code>。</p><p id="eca1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二个好处</strong>是<code class="fe ob oc od mm b">component.Base</code>扩展了<code class="fe ob oc od mm b">this.set()</code>的逻辑</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="65a1" class="mq kn iq mm b gy mr ms l mt mu">myButton.set({<br/>    iconCls: 'fas fa-globe',<br/>    text   : 'Hello world!'<br/>});</span></pre><p id="f1df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ob oc od mm b">afterSetIconCls()</code>以及<code class="fe ob oc od mm b">afterSetText()</code>自身被执行触发重新渲染(将vdom对象传递给vdom工作器以检查增量更新)。</p><p id="3641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用<code class="fe ob oc od mm b">this.set()</code>更改两个配置，将只有1次增量更新检查。</p><p id="8d22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们扩展类时，配置系统的第三个好处是适用的。</p><p id="4387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/tab/Container.mjs#L36" rel="noopener ugc nofollow" target="_blank">标签。容器</a>正在使用一个<code class="fe ob oc od mm b">activeIndex_</code>配置。您可以使用:</p><pre class="md me mf mg gt ml mm mn mo aw mp bi"><span id="9338" class="mq kn iq mm b gy mr ms l mt mu">class MyTabContainer extends TabContainer {<br/>    static <em class="og">getConfig</em>() {return {<br/>        //...<em class="og"><br/>        </em>activeIndex: 2<br/>    }}<br/>}</span></pre><p id="00d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不会覆盖<code class="fe ob oc od mm b">get()</code>和<code class="fe ob oc od mm b">set()</code>逻辑，但会在实例化时分配新值。</p><p id="cc5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有点过时，但这里有更多的输入:</p><div class="mw mx gp gr my mz"><a href="https://codeburst.io/javascript-classes-state-management-v2-2df7663de580" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">Javascript类:状态管理v2</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">在撰写了文章《Javascript classes:状态管理》之后，我从Nige White那里得到了很多建议(真了不起！)就去了……</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">codeburst.io</p></div></div><div class="ni l"><div class="ol l nk nl nm ni nn no mz"/></div></div></a></div><p id="3a2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">【题外话】那么，neo.mjs为什么还不使用类字段呢？</strong></p><div class="mw mx gp gr my mz"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">公共类字段</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">静态和实例公共字段都是可写、可枚举和可配置的属性。因此，不像他们…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">developer.mozilla.org</p></div></div><div class="ni l"><div class="om l nk nl nm ni nn no mz"/></div></div></a></div><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi on"><img src="../Images/efde592d4b5f4ec475c9e1d3cca603c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ditG_N-5fXSTCvwFYKMyw.png"/></div></div></figure><p id="ec0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">浏览器支持还不错，但仍是第3阶段的提案。</p><p id="a3ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然它在neo.mjs开发模式下运行良好，但我们仍然需要构建dist/production输出。Webpack在第4阶段之前不会支持它。更准确地说，<a class="ae kl" href="https://github.com/acornjs/acorn" rel="noopener ugc nofollow" target="_blank"> acorn解析器</a>没有。有一个扩展:<a class="ae kl" href="https://github.com/acornjs/acorn-stage3" rel="noopener ugc nofollow" target="_blank"> acorn-stage3 </a>，可以处理。然而，在Webpack内部使用acorn-stage3替换acorn npm包感觉非常棘手，尤其是在您通过“npx neo-app”创建新的neo.mjs应用程序的情况下。开放的想法在这一点上。</p><h1 id="bfe1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">10.路标</h1><p id="ac8a" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我对这个项目已经取得的进展感到高兴。</p><p id="c5c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我想补充的事情还不止这些。</p><p id="0f5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然v2已经发布，构建下一个项目/冲刺的优先级就显得很重要了。<strong class="jp ir">你有机会产生影响！</strong></p><p id="f280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">含义:如果有你想看的特定项目，给相关的功能请求添加一条评论:<br/><a class="ae kl" href="https://github.com/neomjs/neo/issues" rel="noopener ugc nofollow" target="_blank">https://github.com/neomjs/neo/issues</a></p><p id="22b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还没有票吗？创建一个！就这么简单。</p><p id="18f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人认为最好是进一步完善桌面方面的东西，因为大多数大而复杂的应用程序仍然存在。一旦这样做了，我们就可以专注于移动。不过，这并不是一成不变的。</p><p id="ed57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样:以下项目列表是<strong class="jp ir">而不是</strong>订购的。</p><p id="a8ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主题构建</strong>:CSS输出仍然是一个整体，不支持Javascript方面真正令人印象深刻的分割块。我喜欢按文件来分解输出。要做到这一点，我们需要一个使用的应用程序&amp;框架组件的依赖树。理想情况下类似于JS分割块，这样我们可以根据需要延迟加载微小的css文件。史诗。</p><p id="f74c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">主题化</strong>:并不是所有的尺寸都是基于em的。我们需要调整剩余的px值。</p><p id="8880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缓冲网格</strong>:虽然表格的实现很简洁，包括锁定的列和粘性的标题，但是对于“大数据”来说还不够。只有渲染你看到的行(加一)才能产生很大的影响。史诗。</p><p id="1751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">网格编辑</strong>:“记录”是JS对象的超级轻量级扩展，用来获取变更事件。如果您更改记录的值，表格视图将会更新。表格视图&amp;缓冲网格的单元格编辑器将会很棒。</p><p id="c854" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">日历</strong>:当前状态仍然是“预览预览”。这令人印象深刻，因为演示确实从真实的dom中删除了非活动视图，同时我们仍然可以改变它们的状态并重用相同的JS实例。</p><p id="07d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更复杂的视图模型示例</strong>:到目前为止，所有演示应用都不需要视图模型。让一个大的演示应用程序使用它们会很有帮助。</p><p id="191b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">核心。可观察到的</strong>:框架仍然在使用一个早期的从未完成的版本。它足以添加侦听器和触发事件，但是它不支持框架的当前状态。史诗。</p><p id="3eeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MessageBus (PubSub) </strong>:作为视图模型的一种替代，拥有一种额外的通信方式会很好。我可能没有时间让它进化到MobX那样的程度。</p><p id="3e31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据工人:Rich有一个概念，商店应该存在于这个线程中。这个想法是ajax调用/套接字连接从这里开始，然后本地过滤&amp;排序也在这里发生(以减轻应用程序工作人员的负担),只将需要的数据发送给应用程序工作人员。它更复杂:对于包含少量数据的商店，这个概念没有意义，所以我们需要完善这个概念。史诗。</p><p id="12e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">套接字连接:我们仍然需要它的一个实现。</p><p id="327d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">查看模型v3 </strong>:我们讨论过支持“双向绑定”。Imo仅与表单字段相关，它可以删除一些锅炉板代码。要做到这一点，配置设置者需要触发一个更改事件(或使用MessageBus)来让虚拟机知道更改。棘手的问题，因为我们需要小心不要创建大量没有接收者的变更事件。</p><p id="6e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">对公共类字段的支持</strong>:一旦它们进入stage4并在基于webpack (acorn parser)的构建中工作，我很乐意添加它们。破变→ neo.mjs v3。史诗。</p><p id="3af3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">增强表单域组件</strong>:这里肯定有改进的空间。史诗。</p><p id="3291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">滑块组件&amp;滑块字段</strong>:现在有了一个漂亮的拖拽&amp;实现，添加它会很好。</p><p id="b000" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">颜色选择器字段</strong>:需要滑块组件。</p><p id="dac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">移动</strong>:我们需要增强移动使用的组件，或者创建新的组件。我们还需要更多的例子。Epic++</p><p id="0639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更多延迟加载的例子</strong>:有了cross app split chunks，我们应该重构covid或者真实世界的app，根据需要从一个空的viewport和延迟加载模块开始。史诗。</p><p id="0821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虚拟dom worker v2 :更准确地说是vdom。助手v2。增量更新的结果确实令人印象深刻。然而，增量更新算法包含了太多的树结构生成，可以得到改进。史诗。</p><p id="0c18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Docs app v2 </strong>:我们仍然需要在dist/prod中启用延迟加载示例应用。在这一点上有许多方面可以得到加强。Epic++。</p><p id="a6ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">网站app v2 </strong>:由于越来越多的例子进入框架，例子列表已经不够用了。网站应用程序通常可以使用重新设计，但我作为设计师的能力有限。</p><p id="ced8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> GitHub Pages </strong>:在某种程度上，我想完全改变逻辑。现在，我们获取neo.mjs repo，并展示其中的示例和应用程序。更好的做法是将repos的内容放在neomjs/*中，并使用自己的neo.mjs版本进行部署。然后，我们可以将更多示例&amp;演示应用程序移出框架“核心”回购。Epic++。</p><p id="d770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更多测试</strong>:我在等待<a class="ae kl" href="https://www.bryntum.com/products/siesta/" rel="noopener ugc nofollow" target="_blank">布林图姆的《午睡》</a>的下一个主要发布。一旦更多的贡献者加入到项目中，进行更多的用户交互测试将变得越来越重要。不是真正的“单元测试”，而是加载示例应用程序并模拟用户来验证业务逻辑在更改代码时不会中断。Epic++。</p><p id="e9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个列表是<strong class="jp ir">不</strong>完整的，但是我在这里做了一个删减。甚至没有提到长期目标，如创建一个运行neo核心的中间件(这将是惊人的)。如果您是Javascript专家，您很可能知道这个范围的大小，以“小时”→月、年为单位。</p><p id="2ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">虽然我可以独立完成每个项目，但更多的贡献者可以真正在这里产生影响。</strong></p><p id="e6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记，我仍然需要润色核心的部分，写博客文章，而且不可能把我的全部时间投入到这个项目中(下一节将详细介绍)。</p><h1 id="5318" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">11.最后的想法</h1><p id="f4db" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">即使您认为自己是Javascript专家，如果您深入研究neo.mjs代码库，也很可能会学到很多东西。我会说你可以达到一个全新的水平，然后“飞起来”。</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">近地天体</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序，而无需使用…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="oo l nk nl nm ni nn no mz"/></div></div></a></div><p id="ec3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到所有的在线例子、博客部分和文档:<br/><a class="ae kl" href="https://neomjs.github.io/pages/" rel="noopener ugc nofollow" target="_blank">https://neomjs.github.io/pages/</a></p><p id="1b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我绝对是那种认为“代码不言自明”的人，更喜欢用行动而不是语言来说服别人。</p><p id="88e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我得到的反馈是:“<strong class="jp ir">人爱的是人，不是产品。</strong></p><p id="4952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不得不承认，这句话包含着智慧和真理。</p><p id="6b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想更多地了解我，请随意查看我的LinkedIn个人资料。</p><p id="c702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之:当年我是Sencha ExtJS的专家。在完成客户项目后，我加入了Sencha专业服务团队2.5年。那是一段令人惊奇的时光！由于团队成员限制在8人左右，我实际上一直在全球各地飞来飞去，帮助那些已经完全着火的客户项目(并行修复框架和应用相关的问题)。每小时的费用非常高，所以对客户的期望水平也很有挑战性。我喜欢自己的“摇钱树”角色，也感谢有机会深入许多客户项目。这对于我了解UI开发行业真正需要什么帮助很大。</p><p id="b0f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后来，我在一个大型项目上帮助PlayStation团队工作了4年多，从早期的初始阶段一直到发布。我的角色包括负责客户端架构以及实现具有挑战性的部分。</p><p id="a1d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这让我节省了一些钱，这些钱是我为了让neo.mjs项目达到现在的水平而完全烧掉的。</p><p id="1f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开源还被认为是“慈善”，这是个问题。</p><p id="bd75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公司(尤其是在德国)对接触新技术非常犹豫，不管它有多好。我甚至没有提到赞助或官方政府项目。</p><p id="01ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">neo.mjs的商业模式是业务即服务(BaaS)，这意味着整个代码库都可以免费使用(麻省理工学院许可)。如果您的公司确实需要支持方面的帮助或需要一些neo.mjs专家参与，例如设置原型应用程序，欢迎您与我们联系。</p><p id="75ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我非常乐意全力推动这个框架为你产生更多的价值，但是只要这个项目不在一个可持续的水平上，这是根本不可能的。</p><p id="e1b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问候&amp;快乐编码，<br/>托拜厄斯</p><h1 id="5e00" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">12.特别感谢</h1><p id="0e19" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/in/richwaters/" rel="noopener ugc nofollow" target="_blank">富水</a>，该项目的另一位联合创始人。我仍然很难过，里奇真的消失了，好几年没有他的消息了。</p><p id="ac7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/in/durlabh/" rel="noopener ugc nofollow" target="_blank">杜拉赫·贾因</a>成为该项目的第一个也是唯一一个赞助商！</p><p id="7494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/in/gerard-horan-6671b7/" rel="noopener ugc nofollow" target="_blank">杰拉德·霍兰</a>，我以前的PlayStation导师<a class="ae kl" href="https://www.linkedin.com/in/patsheridan/" rel="noopener ugc nofollow" target="_blank">，帕特·谢里丹</a> (Modus Create)，以及<a class="ae kl" href="https://www.linkedin.com/in/hylecampbell/" rel="noopener ugc nofollow" target="_blank"> Hyle Campbell </a>(我以前在Sencha的团队领导)。没有你对这个项目的关注和你的士气支持，我早就放弃了！</p><p id="6193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还大大的一句“谢谢！”致许多朋友&amp;来自前Sencha社区的前同事！太多了，无法一一列举，但我希望当你读到这里时，你知道我指的是你:)</p></div></div>    
</body>
</html>