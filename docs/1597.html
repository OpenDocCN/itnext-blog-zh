<html>
<head>
<title>Easy patterns: Flyweight</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单模式:轻量级</h1>
<blockquote>原文：<a href="https://itnext.io/easy-patterns-flyweight-dab4c018f7f5?source=collection_archive---------4-----------------------#2018-12-06">https://itnext.io/easy-patterns-flyweight-dab4c018f7f5?source=collection_archive---------4-----------------------#2018-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/14bf79920850f20566b9930604126b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2IDQYmGM8uVqR4mjHYlBQ.png"/></div></div></figure><p id="2079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是easy patterns系列描述的延续，介绍了一个名为Flyweight的结构模式，它解决了使用相似逻辑共享复杂对象的问题，以保持性能和内存使用的优化。</p><p id="cd30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也请参考其他模式文章:</p><h2 id="f002" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创作模式:</h2><blockquote class="lp lq lr"><p id="fa0f" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-simple-factory-b946a086fd7e"> <strong class="ka ir">简易工厂</strong> </a></p><p id="2004" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-factory-method-5f27385ac5c"> <strong class="ka ir">工厂法</strong> </a></p><p id="8fab" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-builder-d85655bcf8aa"> <strong class="ka ir">构建器</strong> </a></p><p id="0e6b" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-singleton-283356fb29bf"> <strong class="ka ir">单个</strong> </a></p><p id="73db" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-abstract-factory-2325cb398fc6"> <strong class="ka ir">抽象工厂</strong> </a></p><p id="9d90" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-prototype-e03ec6962f89"> <strong class="ka ir">原型</strong> </a></p></blockquote><h2 id="b2ad" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结构模式:</h2><blockquote class="lp lq lr"><p id="4425" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-adapter-9b5806cb346f"> <strong class="ka ir">适配器</strong> </a></p><p id="5343" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-decorator-eaa96c0550ea"> <strong class="ka ir">装饰者</strong> </a></p><p id="a7f3" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-bridge-28d50dc25f9f"> <strong class="ka ir">桥</strong> </a></p><p id="2353" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158"> <strong class="ka ir">复合</strong> </a></p><p id="2cca" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-facade-8cb185f4f44f"> <strong class="ka ir">立面</strong> </a></p><p id="9d1e" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-flyweight-dab4c018f7f5"><strong class="ka ir"/></a><em class="iq">(本文)</em></p><p id="52c9" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-proxy-45fc3a648020"> <strong class="ka ir">代理</strong> </a></p></blockquote><h2 id="c975" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">行为模式:</h2><blockquote class="lp lq lr"><p id="052a" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-visitor-b8ef57eb957"> <strong class="ka ir">来访者</strong> </a></p><p id="8f4d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-mediator-e0bf18fefdf9"> <strong class="ka ir">调解员</strong> </a></p><p id="ee43" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-observer-63c832d41ffd"> <strong class="ka ir">观察者</strong> </a></p><p id="2da6" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-memento-ce966cec7478"> <strong class="ka ir">纪念品</strong> </a></p><p id="e199" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-iterator-f5c0dd85957"> <strong class="ka ir">迭代器</strong> </a></p><p id="f257" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-chain-of-responsibility-9a84307ad837"> <strong class="ka ir">责任链</strong> </a></p><p id="e67d" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-strategy-ecb6f6fc0ef3"> <strong class="ka ir">策略</strong> </a></p><p id="2200" class="jy jz ls ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-state-ec87a1a487b4"> <strong class="ka ir">状态</strong> </a></p></blockquote><h1 id="fbf6" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">主要本质</h1><p id="8692" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">flyweight——它是一个共享对象，可以同时在多个上下文中使用。例如，每个表格渲染器都有几种对象类型，如行和单元格。让我们想象一个画面，当你有一个表，里面有两行和两列。每个实例都有自己的类:对于行，它是行类，对于单元格，它是单元格类。在这样的配置中，您必须实例化六个对象(2x行类和4x单元类)来描述这样的表内容。看起来像个计划，对吧？</p><p id="c06d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您的表格内容随着时间的推移急剧增加，现在您有一个500行8列的表格。所以，让我们做一些计算:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0eee" class="kw kx iq my b gy nc nd l ne nf">const rowNumber = 500;<br/>const columnNumber = 8;</span><span id="d9bf" class="kw kx iq my b gy ng nd l ne nf">const getRowClassNumber = rowNumber =&gt; rowNumber;<br/>const getCellClassNumber = (rowNumber, columnNumber) =&gt; rowNumber * columnNumber;</span><span id="87c1" class="kw kx iq my b gy ng nd l ne nf">getRowClassNumber(rowNumber); // 500<br/>getCellClassNumber(rowNumber, columnNumber); // 500 * 8</span><span id="d99f" class="kw kx iq my b gy ng nd l ne nf">// Result<br/>// 500 + 500 * 8 === 4500!!!</span></pre><p id="f292" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果就是这样。基本上，使用这种方法，我们需要使用4500个类实例来描述这种表格的每一行和每一个单元格…</p><p id="61ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是让我们假设我们知道在某个时间点用户只能看到10行内容。因此，实际上我们只能在可见区域重用实例。在这种情况下，我们需要的实例数量:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="5743" class="kw kx iq my b gy nc nd l ne nf">const rowNumber = 10;<br/>const columnNumber = 8;</span><span id="57b7" class="kw kx iq my b gy ng nd l ne nf">const getRowClassNumber = rowNumber =&gt; rowNumber;<br/>const getCellClassNumber = (rowNumber, columnNumber) =&gt; rowNumber * columnNumber;</span><span id="1802" class="kw kx iq my b gy ng nd l ne nf">getRowClassNumber(rowNumber); // 10<br/>getCellClassNumber(rowNumber, columnNumber); // 10 * 8</span><span id="de68" class="kw kx iq my b gy ng nd l ne nf">// Result<br/>// 10 + 10 * 8 === 90</span></pre><p id="724c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上我们减少了50倍的内存消耗。</p><p id="5b42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">怎样才能做出这样的可共享的类实例？答案是让他们成为轻量级选手。Flyweights不能对它们运行的环境做出假设。主要概念是将他们的内部状态分为内在的和外在的。内在状态由独立于flyweight上下文的信息组成(共享它)。外在状态取决于flyweight的上下文。</p><p id="0a04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模式包括三个主要角色:</p><ul class=""><li id="9f36" class="nh ni iq ka b kb kc kf kg kj nj kn nk kr nl kv nm nn no np bi translated"><strong class="ka ir">客户端</strong> —维护对flyweight的引用</li><li id="9431" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated"><strong class="ka ir">flyweights factory</strong>—创建和管理flyweight</li><li id="6cc7" class="nh ni iq ka b kb nq kf nr kj ns kn nt kr nu kv nm nn no np bi translated"><strong class="ka ir"> Flyweight </strong> —实现Flyweight接口，并在内部添加内部状态</li></ul><h1 id="03f5" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">使用示例</h1><p id="cfc3" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">让我们创建一个包含内容的表格。一旦滚动了1个位置，我们不会创建新的行和单元格实例，但会用新的内容更新现有的实例。诸如此类…在当前的例子中，我没有使用巨大的模拟数据来渲染，而是在运行中生成新的内容。内在状态保持渲染方法，链接到DOM等。外部状态保存有关当前单元格内容的信息，该信息将在滚动位置更改后立即更新。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="bad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的表的主要编制者是一个表类</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d78d" class="kw kx iq my b gy nc nd l ne nf">/**<br/>* Class presenting a table<br/>*/<br/>class Table {<br/>  /**<br/>  * Create a table<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {String} selector - table selector<br/>  */<br/>  constructor(selector) {<br/>    this.$table = document.querySelector(selector);<br/>  }<br/>  <br/>  /**<br/>  * Add flyweight rows into the table<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Array} - array of rows flyweight to add<br/>  */<br/>  addRows(rows) {<br/>    this.rows = rows;<br/>    this.rows.forEach(row =&gt; this.$table.appendChild(row.render()));<br/>  }<br/>  <br/>  /**<br/>  * Update flyweight rows extrinsic state with a new content<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Array} data - new data for rows<br/>  */<br/>  updateTableData(data) {<br/>    this.rows.forEach((row, idx) =&gt; row.updateRowData(data[idx]));<br/>  }<br/>}</span></pre><p id="4dc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在实例化时，它接受一个选择器来获得到DOM的链接。<code class="fe nx ny nz my b">.addRows</code>方法接受flyweight行的数组在表中呈现。<code class="fe nx ny nz my b">.updateTableData</code>方法将每一行的外在状态更新到对应的实际滚动位置。</p><p id="b089" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">row flyweight类看起来像</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2f07" class="kw kx iq my b gy nc nd l ne nf">/**<br/>* Class presenting a row flyweight<br/>*/<br/>class Row {<br/>  /**<br/>  * Create a row<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Array} cellItems - cell items to render<br/>  **/<br/>  constructor(cellItems) {<br/>    this.cellItems = cellItems;<br/>  }<br/>  <br/>  /**<br/>  * Update row data with new extrinsic state data<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {Array} newData - new data array to be updated<br/>  */<br/>  updateRowData(newData) {<br/>    this.cellItems.forEach((item, idx) =&gt; {<br/>      item.updateContent(newData[idx]);<br/>    });<br/>  }<br/>  <br/>  /**<br/>  * Render the row<br/>  * <a class="ae lw" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> {DOMElement} row - row element<br/>  */<br/>  render() {<br/>    const row = document.createElement('tr');<br/>    this.cellItems.forEach(item =&gt; row.appendChild(item.render()));<br/>    <br/>    return row;<br/>  }<br/>}</span></pre><p id="ef35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它接受单元格flyweight项数组，因此Row类能够依次更新其外部状态。可通过接受新数据数组的<code class="fe nx ny nz my b">.updateRowData</code>方法进行更新。<code class="fe nx ny nz my b">.render</code>方法只是将每个单元格的内容作为子元素添加到行容器中。</p><p id="fc41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">cell flyweight类看起来像</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="23e2" class="kw kx iq my b gy nc nd l ne nf">/**<br/>* Class presenting a cell flyweight<br/>*/<br/>class Cell {<br/>  /**<br/>  * Create a cell<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {String} content - content of a cell<br/>  **/<br/>  constructor(content) {<br/>    this.content = content;<br/>  }<br/>  <br/>  /**<br/>  * Update content of a cell<br/>  * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {String} content - content of a cell<br/>  */<br/>  updateContent(content) {<br/>    this.content = content;<br/>    this.cell.innerText = content;<br/>  }<br/>  <br/>  /**<br/>  * Render the cell<br/>  * <a class="ae lw" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> {DOMElement} cell - cell element<br/>  */<br/>  render() {<br/>    const cell = document.createElement('td');<br/>    this.cell = cell;<br/>    cell.innerText = this.content;<br/>    <br/>    return cell;<br/>    <br/>  }<br/>}</span></pre><p id="5f01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它接受要在表格单元格内呈现的内容。<code class="fe nx ny nz my b">.updateContent</code>方法接受新的内容作为新的外在状态传递。<code class="fe nx ny nz my b">.render</code>方法只是用从当前外部状态传递的内容创建新的DOM节点。</p><h1 id="a56f" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">利润</h1><p id="297c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">共享的flyweights越多，节省的存储就越多。最严重的情况发生在当对象使用大量的内在和外在状态时，并且外在状态可以被计算而不是被存储。</p><p id="7427" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当处理大量的内容时，这是一个巨大的好处，可以与用户进行实时交互。</p><h1 id="fedc" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">薄弱的地方</h1><p id="3b4e" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">Flyweights可能会引入一些与转移、查找和计算现有状态相关的运行时成本。然而，对于内存分配的节省来说，这是一个公平的报酬，随着更多的轻量级共享，内存分配也会增加。</p><p id="2fdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，当内存比运行时限制便宜时，外部状态的计算可能是一种开销。</p><p id="6fb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从代码阅读的角度来看，计算给代码增加了一点复杂性(与庞大且组织良好的静态数据结构形成对比)。</p><h1 id="0bae" class="lx kx iq bd ky ly lz ma lb mb mc md le me mf mg lh mh mi mj lk mk ml mm ln mn bi translated">结论</h1><p id="5e9c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">Flyweight模式通常与<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/easy-patterns-composite-8b28aa1f158">复合</a>模式一起使用，以保持系统中的逻辑层次结构。</p><p id="831a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">优点是使用Flyweight模式来实现状态和策略模式对象。</p><p id="7216" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您觉得这篇文章有帮助，请点击👏按钮并在下面随意评论！</p></div></div>    
</body>
</html>