<html>
<head>
<title>fp-ts in action🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实践中的fp-ts🚀</h1>
<blockquote>原文：<a href="https://itnext.io/fp-ts-in-action-d7d5f41c4858?source=collection_archive---------0-----------------------#2021-01-29">https://itnext.io/fp-ts-in-action-d7d5f41c4858?source=collection_archive---------0-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">👊2021年第一帖！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/dbcb14274541ab5c5a47ade439431054.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*IUs5HHqGSrpkxE8hd-6PBw.png"/></div></figure><p id="3655" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我决定在一个副业项目中采用fp-ts lib。</p><p id="1352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是<code class="fe kt ku kv kw b"><strong class="jp ir">F</strong><a class="ae kx" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">p-ts</strong></a><strong class="jp ir">?</strong></code></p><p id="124f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是一个库，提供了类型化函数语言的抽象，使得在TypeScript中开发时应用函数模式变得容易。</p><p id="eb0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我采用fp-ts的动机是:</p><ul class=""><li id="2e7a" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">我被Haskell和Rust这样的语言迷住了，想在代码中使用一些熟悉的<a class="ae kx" href="https://dev.to/gcanti/functional-design-algebraic-data-types-36kf" rel="noopener ugc nofollow" target="_blank"> ADTs </a>(选项/也许，只是/一些，要么/结果，无)。</li><li id="d0ca" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">我喜欢错误处理方法。</li><li id="00cb" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">我想弄清楚，在享受函数式风格的同时，它是否真的能改进我的typescript项目。</li></ul><h2 id="9026" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">简单的启动</h2><p id="2d71" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我已经阅读<a class="ae kx" href="https://gcanti.github.io/fp-ts/learning-resources/" rel="noopener ugc nofollow" target="_blank"> fp-ts文档和帖子</a>有一段时间了，所以剩下的就是选择一个简单的项目代码，将其一般化一点，并开始使用fp-ts:)</p><p id="c998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择了一个简单的程序来获取我在google-sheets表中管理的数据，如下所示:</p><ul class=""><li id="89ab" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">从私有本地文件中读取工作表凭据</li><li id="6ac6" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">鉴定</li><li id="5689" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">运行并行获取所有表的fetchTables(每个表都有自己的路由)</li></ul><p id="a8b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:<a class="ae kx" href="https://grossbart.github.io/fp-ts-recipes/#/basics" rel="noopener ugc nofollow" target="_blank">以下食谱</a>超级有用📓</p><p id="2292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回顾一下fetchTable函数sig:</p><pre class="km kn ko kp gt mk kw ml mm aw mn bi"><span id="557f" class="lm ln iq kw b gy mo mp l mq mr">function fetchTable&lt;T&gt;(sheets: Sheets, range: any, spreadsheetId: any): Promise&lt;T&gt; </span></pre><p id="5a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kt ku kv kw b">fetchTable</code>接受3个参数并返回包装在承诺中的某个T类型的值。</p><p id="8782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有一种更好的方式来写这个函数，来表达失败的可能性。</p><p id="04c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">fp-ts引入<strong class="jp ir">要么:</strong></p><p id="eeb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://dev.to/gcanti/getting-started-with-fp-ts-either-vs-validation-5eja" rel="noopener ugc nofollow" target="_blank"/><code class="fe kt ku kv kw b"><a class="ae kx" href="https://dev.to/gcanti/getting-started-with-fp-ts-either-vs-validation-5eja" rel="noopener ugc nofollow" target="_blank">Either&lt;E, A&gt;</a></code><a class="ae kx" href="https://dev.to/gcanti/getting-started-with-fp-ts-either-vs-validation-5eja" rel="noopener ugc nofollow" target="_blank">类型表示一个计算可能会因类型</a> <code class="fe kt ku kv kw b"><a class="ae kx" href="https://dev.to/gcanti/getting-started-with-fp-ts-either-vs-validation-5eja" rel="noopener ugc nofollow" target="_blank">E</a></code> <a class="ae kx" href="https://dev.to/gcanti/getting-started-with-fp-ts-either-vs-validation-5eja" rel="noopener ugc nofollow" target="_blank">的错误而失败，或因类型</a> <code class="fe kt ku kv kw b"><a class="ae kx" href="https://dev.to/gcanti/getting-started-with-fp-ts-either-vs-validation-5eja" rel="noopener ugc nofollow" target="_blank">A</a></code>的值而成功</p><p id="6b8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重构函数来使用它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="f4e0" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated"><strong class="ak">任务</strong>和<strong class="ak">任务任一:</strong></h2><p id="049a" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated"><strong class="jp ir">任务</strong>:异步计算，产生给定类型的值，并且**从不失败* *例如:</p><pre class="km kn ko kp gt mk kw ml mm aw mn bi"><span id="0ea5" class="lm ln iq kw b gy mo mp l mq mr">const task1: Task&lt;string&gt; = () =&gt; <strong class="kw ir"><em class="mu">Promise</em></strong>.resolve('task1')</span></pre><p id="da1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加错误处理:</p><p id="f7ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">任务任一</strong>:可能失败的异步计算</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="89eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> tryCatch </strong>从一个可能抛出。readCreds()是一个在成功时执行的函数，fail()将在失败时运行。</p><h2 id="b4ea" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">管道:</h2><p id="b8c0" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">在从左到右的函数链序列中使用时，第一个参数可以是初始值，然后我们以无指针的方式传递函数。</p><h2 id="ece7" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">提取全部作为任务序列</h2><p id="fc62" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">序列可以是一系列任务，下面的实用指南很好地解释了这一点。</p><p id="2f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回顾一下代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b3e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第5行中，我们定义了一个内部异步函数，它最终在auth成功的情况下处理我们的fetch调用(第21行)。</p><p id="7b2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到表fetch调用作为任务被映射到一个任务类型列表中(第8 + 9行)。</p><p id="96cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任务被传递给由<strong class="jp ir"> array.sequence </strong>返回的函数，该函数返回一个异步函数(第11行)。</p><p id="07bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用管道将承诺列表作为初始值，并用折叠函数将结果处理为错误情况或成功情况(第12–21行)。</p><p id="3f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码可以在这里找到<a class="ae kx" href="https://github.com/LironHazan/fts-utils" rel="noopener ugc nofollow" target="_blank"/>，如果你觉得有用的话，请随意使用《⭐️》!</p><p id="1651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个帖子就说到这里，</p><h2 id="ada0" class="lm ln iq bd lo lp lq dn lr ls lt dp lu jy lv lw lx kc ly lz ma kg mb mc md me bi translated">结束想法:</h2><p id="ca98" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">我必须说，我在采用fp-ts的时候很开心，但是在写作开始流畅之前还有一个小的学习曲线要通过:)</p><p id="835c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于我是否会在未来的项目中采用它，就个人而言，有一次可能会，在fp-ts提供的范畴理论的上下文中有一些非常酷的抽象和类型，在这篇文章中没有提到，我也很想利用它们。</p><p id="475f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个精彩的系列:</p><div class="mv mw gp gr mx my"><a href="https://dev.to/gcanti/getting-started-with-fp-ts-semigroup-2mf7" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">fp-ts入门:半群</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">由于半群是函数式编程的一个基本抽象，这篇博文将会比…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">开发到</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kr my"/></div></div></a></div><p id="2517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读🙏</p><p id="8b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯，勒荣。</p></div></div>    
</body>
</html>