<html>
<head>
<title>Acceptance Test Driven Development with React/Redux — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React/Redux的验收测试驱动开发—第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/acceptance-test-driven-test-with-react-redux-part-3-903e1e58e706?source=collection_archive---------4-----------------------#2018-03-09">https://itnext.io/acceptance-test-driven-test-with-react-redux-part-3-903e1e58e706?source=collection_archive---------4-----------------------#2018-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bd0ffcad5539110ee79179fd2f02ce7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M9GtVugIVtr1u80e."/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">"佳能相机部件的零件拆卸或等待安排在良好的状态."在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@madebyvadim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vadim Sherbakov </a></figcaption></figure><p id="3a5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">更新1 </em> </strong> : <em class="lb">本文是一个系列的一部分，查看完整系列:</em> <a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-1-7ae8cb4fab00" rel="noopener">第一部分</a>、<em class="lb"> </em> <a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-2-127949a6e47e" rel="noopener">第二部分</a>、<a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-test-with-react-redux-part-3-903e1e58e706" rel="noopener">第三部分</a>、<a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-4-5db545953ed3" rel="noopener">第四部分</a>和<a class="ae kc" href="https://medium.com/@juntao.qiu/acceptance-test-driven-development-with-react-redux-part-5-995577d28eff" rel="noopener">第五部分</a>。</p><p id="d68d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb">更新2 </em> </strong>:我出版了一本名为<a class="ae kc" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank"> <em class="lb">用验收测试驱动开发构建React应用</em> </a>的书，涵盖了更多关于ATDD和React的话题和实践，<a class="ae kc" href="https://leanpub.com/build-react-app-with-atdd" rel="noopener ugc nofollow" target="_blank">请查看</a>！</p><p id="7b16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的第一个要求是制定一个书单。从验收测试的角度来看，我们需要做的就是确保页面包含一个图书列表，我们不需要担心我们将使用什么技术来实现页面，只要测试通过，页面是动态生成的还是静态的HTML并不重要。</p><h1 id="5d22" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">书单</h1><p id="973b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们需要在<code class="fe mf mg mh mi b">e2e.test.js</code>中添加一个测试用例，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="ba97" class="mr ld iq mi b gy ms mt l mu mv">expect(result).toEqual('Bookish')<br/>   })<br/>+<br/>+  test('Book List', async () =&gt; {<br/>+    await page.goto(`${appUrlBase}/`)<br/>+    await page.waitForSelector('.books')<br/>+    const books = await page.evaluate(() =&gt; {<br/>+      return [...document.querySelectorAll('.book .title')].map(el =&gt; el.innerText)<br/>+    })<br/>+<br/>+    expect(books.length).toEqual(2)<br/>+  })<br/> })<br/> <br/> afterAll(() =&gt; {</span></pre><p id="ec76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们期望有一个包含几个<code class="fe mf mg mh mi b">.book</code>元素的<code class="fe mf mg mh mi b">.books</code>容器，而<code class="fe mf mg mh mi b">.book</code>包含一个<code class="fe mf mg mh mi b">.title</code>元素。现在，如果我们运行测试，它将失败。根据<code class="fe mf mg mh mi b">TDD</code>原理，我们可以快速实现，修改<code class="fe mf mg mh mi b">App.js</code>如下:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="f488" class="mr ld iq mi b gy ms mt l mu mv">return (<br/>       &lt;div className="App"&gt;<br/>         &lt;h1&gt;Bookish&lt;/h1&gt;<br/>+        &lt;div className="books"&gt;<br/>+          &lt;div className="book"&gt;<br/>+            &lt;h2 className="title"&gt;&lt;/h2&gt;<br/>+          &lt;/div&gt;<br/>+          &lt;div className="book"&gt;<br/>+            &lt;h2 className="title"&gt;&lt;/h2&gt;<br/>+          &lt;/div&gt;<br/>+        &lt;/div&gt;<br/>       &lt;/div&gt;<br/>     );<br/>   }</span></pre><h1 id="a3a3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">图书名称</h1><p id="b574" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">很好，测试现在通过了，如你所见，我们已经通过测试用<em class="lb">驱动了</em>HTML结构，现在我们可以添加另一个期望:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="7c0f" class="mr ld iq mi b gy ms mt l mu mv">})<br/> <br/>     expect(books.length).toEqual(2)<br/>+    expect(books[0]).toEqual('Refactoring')<br/>+    expect(books[1]).toEqual('Domain-driven design')<br/>   })<br/> })</span></pre><p id="266d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要通过测试，最简单的方法仍然是使用硬代码:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8596" class="mr ld iq mi b gy ms mt l mu mv">&lt;div className="books"&gt;<br/>           &lt;div className="book"&gt;<br/>-            &lt;h2 className="title"&gt;&lt;/h2&gt;<br/>+            &lt;h2 className="title"&gt;Refactoring&lt;/h2&gt;<br/>           &lt;/div&gt;<br/>           &lt;div className="book"&gt;<br/>-            &lt;h2 className="title"&gt;&lt;/h2&gt;<br/>+            &lt;h2 className="title"&gt;Domain-driven design&lt;/h2&gt;<br/>           &lt;/div&gt;<br/>         &lt;/div&gt;<br/>       &lt;/div&gt;</span></pre><p id="f2b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了，我们的测试又通过了。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7c590029257746dd9eb38cfac6a12540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uMjRqOq-Jj5tzqnM5I7UA.png"/></div></div></figure><p id="bfec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在该看一下代码了，看看有没有代码味，有就做相应的重构。首先，我们发现将所有的<code class="fe mf mg mh mi b">.book</code>放在方法<code class="fe mf mg mh mi b">render</code>中可能不是一个好主意，我们可以使用for循环来生成这个HTML。</p><h1 id="96b3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">重构</h1><p id="dd33" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们可以定义一个名为<code class="fe mf mg mh mi b">renderBooks</code>的新函数，然后使用<code class="fe mf mg mh mi b">map</code>来生成列表</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9378" class="mr ld iq mi b gy ms mt l mu mv">renderBooks(books) {<br/>    return (&lt;div className="books"&gt;<br/>      {<br/>        books.map(book =&gt; {<br/>          return (&lt;div className="book"&gt;<br/>            &lt;h2 className="title"&gt;{book.name}&lt;/h2&gt;<br/>          &lt;/div&gt;)<br/>        })<br/>      }<br/>    &lt;/div&gt;)<br/>  }</span></pre><p id="75c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当调用它时，我们需要传递一个book对象数组:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="b20e" class="mr ld iq mi b gy ms mt l mu mv">render() {<br/>    const books = [{ name: 'Refactoring' }, { name: 'Domain-driven design' }]<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;h1&gt;Bookish&lt;/h1&gt;<br/>        {this.renderBooks(books)}<br/>      &lt;/div&gt;<br/>    );<br/>  }</span></pre><p id="ee42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的测试仍然通过。也就是说，我们使我们的内部实现变得更好，但不修改外部行为，这只是TDD提供的好处之一:重构更容易、更安全。</p><h1 id="60cf" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">再次重构</h1><p id="539c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在的代码比以前更简洁明了，但还可以做得更好。通过应用<code class="fe mf mg mh mi b">Componentization</code>，抽象的粒度应该基于<code class="fe mf mg mh mi b">component</code>而不是<code class="fe mf mg mh mi b">function</code>。例如，现在我们使用函数<code class="fe mf mg mh mi b">renderBooks</code>将传递的数组呈现给图书列表，我们应该抽象出一个名为<code class="fe mf mg mh mi b">BookList</code>的组件，并创建一个文件<code class="fe mf mg mh mi b">BookList.js</code>，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="2582" class="mr ld iq mi b gy ms mt l mu mv">import React from 'react'</span><span id="1ff3" class="mr ld iq mi b gy mx mt l mu mv">function BookList({books}) {<br/>  return (&lt;div className="books"&gt;<br/>    {<br/>      books.map(book =&gt; {<br/>        return (&lt;div className="book"&gt;<br/>          &lt;h2 className="title"&gt;{book.name}&lt;/h2&gt;<br/>        &lt;/div&gt;)<br/>      })<br/>    }<br/>  &lt;/div&gt;)<br/>}</span><span id="e0b8" class="mr ld iq mi b gy mx mt l mu mv">export default BookList</span></pre><p id="fa3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以像使用<code class="fe mf mg mh mi b">div</code>或<code class="fe mf mg mh mi b">h1</code>内置组件一样使用这个定制组件:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="79e0" class="mr ld iq mi b gy ms mt l mu mv">render() {<br/>    const books = [{ name: 'Refactoring' }, { name: 'Domain-driven design' }]<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;h1&gt;Bookish&lt;/h1&gt;<br/>        &lt;BookList books={books} /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</span></pre><p id="c161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过进行这种重构，我们的代码变得更具声明性，也更容易理解。此外，我们的测试仍然是<code class="fe mf mg mh mi b">green</code>。</p><h1 id="9952" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">网络</h1><p id="9e92" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">一般来说，书单的数据不会硬编码在代码中。在现实生活中，这些数据存储在远程的某个地方，需要在应用程序启动时获取。为了让我们的应用程序以这种方式工作，我们至少应该完成以下任务:</p><ul class=""><li id="aae8" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">配置一个模拟服务器来提供我们需要的书籍数据</li><li id="82cb" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">使用客户端网络库<code class="fe mf mg mh mi b">axios</code>从模拟服务器获取数据</li><li id="97d8" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">使用获取的数据来呈现我们的组件</li></ul><h1 id="1e09" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">模拟服务器</h1><p id="2be2" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">模拟服务器在开发过程中被广泛使用，这里我们将介绍<code class="fe mf mg mh mi b">json-server</code>作为我们的模拟服务器。这是一个非常轻量级且易于上手的包。</p><p id="ec1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要在全球范围内安装它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="224e" class="mr ld iq mi b gy ms mt l mu mv">npm install json-server --global</span></pre><p id="9dcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并创建一个名为<code class="fe mf mg mh mi b">mock-server</code>的空文件夹</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="98ba" class="mr ld iq mi b gy ms mt l mu mv">mkdir -p mock-server<br/>cd mock-server</span></pre><p id="265c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用以下内容创建一个<code class="fe mf mg mh mi b">db.json</code>文件:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="2b46" class="mr ld iq mi b gy ms mt l mu mv">{<br/>  "books": [{ "name": "Refactoring" }, { "name": "Domain-driven design" }]<br/>}</span></pre><p id="d60c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该文件定义了<code class="fe mf mg mh mi b">route</code>和该<code class="fe mf mg mh mi b">route</code>的数据，现在我们可以通过以下方式启动服务器:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c7d1" class="mr ld iq mi b gy ms mt l mu mv">json-server --watch db.json --port 8080</span></pre><p id="491f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您打开浏览器访问<code class="fe mf mg mh mi b">http://localhost:8080/books</code>，您应该会看到类似这样的内容:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="1e73" class="mr ld iq mi b gy ms mt l mu mv">[<br/>  {<br/>    "name": "Refactoring"<br/>  },<br/>  {<br/>    "name": "Domain-driven design"<br/>  }<br/>]</span></pre><p id="4d95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，您可以使用<code class="fe mf mg mh mi b">curl</code>从命令行获取它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="421d" class="mr ld iq mi b gy ms mt l mu mv">$ curl http://localhost:8080/books</span><span id="ceb1" class="mr ld iq mi b gy mx mt l mu mv">[<br/>  {<br/>    "name": "Refactoring"<br/>  },<br/>  {<br/>    "name": "Domain-driven design"<br/>  }<br/>]</span></pre><p id="90e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的模拟服务器已经启动并运行，应用程序现在可以通过HTTP获取这些数据。</p><h1 id="e867" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">异步请求</h1><p id="0ccb" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">回到应用程序文件夹<code class="fe mf mg mh mi b">bookish-react</code>，为了发送请求并获取数据，我们需要将<code class="fe mf mg mh mi b">axios</code>安装到我们的项目中:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="bb8f" class="mr ld iq mi b gy ms mt l mu mv">yarn add axios</span></pre><p id="50d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来获取<code class="fe mf mg mh mi b">App.js</code>中的数据:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="77c6" class="mr ld iq mi b gy ms mt l mu mv">class App extends Component {<br/>+  constructor(props) {<br/>+    super(props)<br/>+    this.state = {<br/>+      books: []<br/>+    }<br/>+  }<br/>+<br/>+  componentDidMount() {<br/>+    axios.get('http://localhost:8080/books').then(res =&gt; {<br/>+      this.setState({<br/>+        books: res.data<br/>+      })<br/>+    })<br/>+  }<br/>+<br/>   render() {<br/>-    const books = [{ name: 'Refactoring' }, { name: 'Domain-driven design' }]<br/>+    const {books} = this.state<br/>     return (<br/>       &lt;div className="App"&gt;</span></pre><p id="a52c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到来自模拟服务器的控制台日志，到达了<code class="fe mf mg mh mi b">books</code> API:</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/eef6ae56aa06f6386ab0c30c01e8713d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztgcepkD7IPvkuTqxb5KhQ.png"/></div></div></figure><h1 id="39fb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">安装和拆卸</h1><p id="48bc" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在让我们看看代码和测试，有一个隐含的假设:测试知道实现将返回2本书。唯一的问题是这个假设使得测试看起来不那么直接:为什么我们期待的是<code class="fe mf mg mh mi b">expect(books.length).toEqual(2)</code>，而不是<code class="fe mf mg mh mi b">3</code>？为什么那两本书是<code class="fe mf mg mh mi b">Refactoring</code>和<code class="fe mf mg mh mi b">Domain-driven design</code>？这种假设应该避免，或者应该在测试中明确定义。</p><p id="e2ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每次测试运行之前，我们应该创建一些fixture数据，并在每次测试之后清除它们。</p><p id="b7e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上<code class="fe mf mg mh mi b">json-server</code>提供了一种程序化的启动方式。以编程的方式，我们可以通过一些代码来定义模拟服务器的行为。</p><p id="166e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这么办吧。在文件夹<code class="fe mf mg mh mi b">mock-server</code>中，创建一个名为<code class="fe mf mg mh mi b">server.js</code>的文件，并在其中添加一些<code class="fe mf mg mh mi b">middlewares</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="207f" class="mr ld iq mi b gy ms mt l mu mv">server.use((req, res, next) =&gt; {<br/>  if(req.method === 'DELETE' &amp;&amp; req.query['_cleanup']) {<br/>    const db = router.db<br/>    db.set(req.entity, []).write()<br/>    res.sendStatus(204)<br/>  } else {<br/>    next()  <br/>  }<br/>})</span></pre><p id="19ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数可以基于HTTP请求方法和查询字符串执行一些操作。如果请求是一个<code class="fe mf mg mh mi b">DELETE</code>方法，并且查询字符串中有一个<code class="fe mf mg mh mi b">_cleanup</code>参数，那么我们将清理请求所请求的实体。比如说。当您使用<code class="fe mf mg mh mi b">DELETE</code>访问<code class="fe mf mg mh mi b">http://localhost:8080/books?_cleanup=true</code>时，该功能会将<code class="fe mf mg mh mi b">books</code>置空。</p><p id="552a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，您可以通过以下命令启动服务器:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9dcc" class="mr ld iq mi b gy ms mt l mu mv">node server.js</span></pre><p id="2c7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模拟服务器代码的完整版本<a class="ae kc" href="https://github.com/abruzzi/react-tdd-mock-server" rel="noopener ugc nofollow" target="_blank">存放在这里</a>。一旦我们有了这个中间件，我们就可以在我们的测试设置和拆卸挂钩中使用它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="bb95" class="mr ld iq mi b gy ms mt l mu mv">afterEach(() =&gt; {<br/>    return axios.delete('http://localhost:8080/books?_cleanup=true').catch(err =&gt; err)<br/>  })</span><span id="e77f" class="mr ld iq mi b gy mx mt l mu mv">  beforeEach(() =&gt; {<br/>    const books = [<br/>      {"name": "Refactoring", "id": 1},<br/>      {"name": "Domain-driven design", "id": 2}<br/>    ]</span><span id="c625" class="mr ld iq mi b gy mx mt l mu mv">    return books.map(item =&gt; axios.post('http://localhost:8080/books', item, {headers: { 'Content-Type': 'application/json' }}))<br/>  })</span></pre><p id="590e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每次测试之前，我们通过将两本书<code class="fe mf mg mh mi b">POST</code>到URL: <code class="fe mf mg mh mi b">http://localhost:8080/books</code>来将它们插入到模拟服务器中，并且在每次测试之后，我们通过将<code class="fe mf mg mh mi b">DELETE</code>请求发送到端点<code class="fe mf mg mh mi b">'http://localhost:8080/books?_cleanup=true'</code>来清理它们。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="5198" class="mr ld iq mi b gy ms mt l mu mv">beforeEach(() =&gt; {<br/>    const books = [<br/>      {"name": "Refactoring", "id": 1},<br/>      {"name": "Domain-driven design", "id": 2},<br/>      {"name": "Building Micro-service", "id": 3}<br/>    ]</span><span id="ba50" class="mr ld iq mi b gy mx mt l mu mv">    return books.map(item =&gt; axios.post('http://localhost:8080/books', item, {headers: { 'Content-Type': 'application/json' }}))<br/>  })</span></pre><p id="e945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以随意修改设置中的数据，比如说，添加另一本书<code class="fe mf mg mh mi b">Building Micro-service</code>，并期望在测试中得到<code class="fe mf mg mh mi b">3</code>本书:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6094" class="mr ld iq mi b gy ms mt l mu mv">test('Book List', async () =&gt; {<br/>    await page.goto(`${appUrlBase}/`)<br/>    await page.waitForSelector('.books')<br/>    const books = await page.evaluate(() =&gt; {<br/>      return [...document.querySelectorAll('.book .title')].map(el =&gt; el.innerText)<br/>    })</span><span id="b443" class="mr ld iq mi b gy mx mt l mu mv">    expect(books.length).toEqual(3)<br/>    expect(books[0]).toEqual('Refactoring')<br/>    expect(books[1]).toEqual('Domain-driven design')<br/>    expect(books[2]).toEqual('Building Micro-service')<br/>  })</span></pre><h1 id="3fac" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">装载指示器</h1><p id="e967" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们的应用程序正在远程获取数据，不能保证数据会立即返回。如果我们的用户在一些高遗留环境中使用这个应用程序，我们希望有一些指示器显示，使用户体验更好。此外，当根本没有网络连接(或超时)时，我们需要显示一些错误消息。</p><p id="eaf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始将它添加到代码中之前，让我们想象一下如何模拟这两种场景:</p><ul class=""><li id="64b7" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">缓慢的请求</li><li id="3b3f" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">失败请求</li></ul><p id="c712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，这两个场景都不容易模拟，即使我们可以做到，我们也必须将测试与代码紧密耦合。让我们仔细考虑一下我们想要做什么:组件有3种状态(加载、错误、成功)，所以如果我们可以测试这3种状态下的行为，那么我们就可以确保我们的组件是好的。</p><h1 id="c720" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">首先重构</h1><p id="1410" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了让测试更容易编写，我们需要先做一点重构。看一看<code class="fe mf mg mh mi b">App.js</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6934" class="mr ld iq mi b gy ms mt l mu mv">import BookList from './BookList'</span><span id="e8a4" class="mr ld iq mi b gy mx mt l mu mv">class App extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      books: []<br/>    }<br/>  }</span><span id="24f8" class="mr ld iq mi b gy mx mt l mu mv">  componentDidMount() {<br/>    axios.get('http://localhost:8080/books').then(res =&gt; {<br/>      this.setState({<br/>        books: res.data<br/>      })<br/>    })<br/>  }</span><span id="f402" class="mr ld iq mi b gy mx mt l mu mv">  render() {<br/>    const {books} = this.state<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;h1&gt;Bookish&lt;/h1&gt;<br/>        &lt;BookList books={books} /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="53ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们像这样做一些方法提取会怎么样:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="5015" class="mr ld iq mi b gy ms mt l mu mv">constructor(props) {<br/>     super(props)<br/>     this.state = {<br/>-      books: []<br/>+      books: [],<br/>+      loading: true,<br/>+      error: null<br/>     }<br/>   }<br/> <br/>   componentDidMount() {<br/>     axios.get('http://localhost:8080/books').then(res =&gt; {<br/>       this.setState({<br/>-        books: res.data<br/>+        books: res.data,<br/>+        loading: false<br/>+      })<br/>+    }).catch(err =&gt; {<br/>+      this.setState({<br/>+        loading: false,<br/>+        error: err<br/>   componentDidMount() {<br/>     axios.get('http://localhost:8080/books').then(res =&gt; {<br/>       this.setState({<br/>-        books: res.data<br/>+        books: res.data,<br/>+        loading: false<br/>+      })<br/>+    }).catch(err =&gt; {<br/>+      this.setState({<br/>+        loading: false,<br/>+        error: err<br/>       })<br/>     })<br/>   }<br/> <br/>   render() {<br/>-    const {books} = this.state<br/>+    const {loading, error, books} = this.state<br/>+<br/>+    if(loading) {<br/>+      return &lt;div className="loading" /&gt;<br/>+    }<br/>+<br/>+    if(error) {<br/>+      return &lt;div className="error" /&gt;<br/>+    }<br/>+<br/>     return (<br/>       &lt;div className="App"&gt;<br/>         &lt;h1&gt;Bookish&lt;/h1&gt;</span></pre><p id="0ef4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Emm，这是可行的，但缺点是我们将网络请求和渲染耦合在一起，这使得单元测试非常困难。所以我们把网络分开渲染一下:</p><h1 id="d7da" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">容器组件</h1><p id="3f60" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们可以将网络相关内容提取到一个名为<code class="fe mf mg mh mi b">BookListContainer</code>的单独文件中，完全没有渲染逻辑:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6360" class="mr ld iq mi b gy ms mt l mu mv">import React, { Component } from 'react';</span><span id="0cc7" class="mr ld iq mi b gy mx mt l mu mv">import axios from 'axios'<br/>import BookList from './BookList'</span><span id="9cea" class="mr ld iq mi b gy mx mt l mu mv">class BookListContainer extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      books: []<br/>    }<br/>  }</span><span id="5b60" class="mr ld iq mi b gy mx mt l mu mv">  componentDidMount() {<br/>    axios.get('http://localhost:8080/books').then(res =&gt; {<br/>      this.setState({<br/>        books: res.data<br/>      })<br/>    })<br/>  }</span><span id="8f6e" class="mr ld iq mi b gy mx mt l mu mv">  render() {<br/>    return &lt;BookList {...this.state} /&gt;<br/>  }<br/>}</span><span id="2674" class="mr ld iq mi b gy mx mt l mu mv">export default BookListContainer</span></pre><p id="db3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">App.js</code>相应简化如下:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="df16" class="mr ld iq mi b gy ms mt l mu mv">import React, {Component} from "react";<br/>import "./App.css";<br/>import BookListContainer from "./BookListContainer";</span><span id="4d88" class="mr ld iq mi b gy mx mt l mu mv">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;Bookish&lt;/h1&gt;<br/>      &lt;BookListContainer /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="064a" class="mr ld iq mi b gy mx mt l mu mv">export default App;</span></pre><p id="03b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们就可以对上面提到的3种状态进行<code class="fe mf mg mh mi b">BookList</code>组件的单元测试了。让我们从驱动<code class="fe mf mg mh mi b">BookList</code>组件的单元测试开始:</p><h1 id="6c83" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">单元测试</h1><p id="9f4e" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在我们添加任何单元测试之前，我们需要添加一些包:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="2908" class="mr ld iq mi b gy ms mt l mu mv">yarn add enzyme enzyme-adapter-react-16 --dev</span></pre><p id="dca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mf mg mh mi b">src</code>文件夹下创建一个<code class="fe mf mg mh mi b">setupTests.js</code>，在该文件中配置<code class="fe mf mg mh mi b">enzyme</code>，内容为:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c2aa" class="mr ld iq mi b gy ms mt l mu mv">import Enzyme from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';</span><span id="cedb" class="mr ld iq mi b gy mx mt l mu mv">Enzyme.configure({ adapter: new Adapter() });</span></pre><p id="5a9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些允许我们做单元测试，而不用担心配置酶的东西。为了处理<code class="fe mf mg mh mi b">loading</code>和<code class="fe mf mg mh mi b">error</code>的情况，我们可以在单元测试或者更高级别的测试中覆盖它们。考虑到测试金字塔理论，我们应该把它们放在单元测试中:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="e53e" class="mr ld iq mi b gy ms mt l mu mv">import React from 'react'<br/>import {shallow} from 'enzyme'<br/>import BookList from './BookList'</span><span id="c279" class="mr ld iq mi b gy mx mt l mu mv">describe('BookList', () =&gt; {<br/>  it('Shows a loading bar when loading', () =&gt; {<br/>    const props = {<br/>      loading: true<br/>    }<br/>    const wrapper = shallow(&lt;BookList {...props}/&gt;)<br/>    expect(wrapper.find('.loading').length).toEqual(1)<br/>  })<br/>})</span></pre><p id="312b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mf mg mh mi b">enzyme</code>提供的<code class="fe mf mg mh mi b">shallow</code>来渲染<code class="fe mf mg mh mi b">BookList</code>。由于我们还没有它，测试会失败，我们可以快速实现如下:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c386" class="mr ld iq mi b gy ms mt l mu mv">function BookList({loading, books}) {<br/>  if(loading) {<br/>    return &lt;div className="loading" /&gt;<br/>  }</span><span id="249f" class="mr ld iq mi b gy mx mt l mu mv">  return (&lt;div className="books"&gt;<br/>    {<br/>      books.map(book =&gt; {<br/>        return (&lt;div className="book"&gt;<br/>          &lt;h2 className="title"&gt;{book.name}&lt;/h2&gt;<br/>        &lt;/div&gt;)<br/>      })<br/>    }<br/>  &lt;/div&gt;)<br/>}</span></pre><p id="6df7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于网络错误的情况:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="0c72" class="mr ld iq mi b gy ms mt l mu mv">it('Shows a error bar when error occurs', () =&gt; {<br/>    const props = {<br/>      error: {<br/>        "message": "Something went wrong"<br/>      }<br/>    }<br/>    const wrapper = shallow(&lt;BookList {...props}/&gt;)<br/>    expect(wrapper.find('.error').length).toEqual(1)<br/>  })</span></pre><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f3ca0072256d8c614c8585bbcceefdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGUFihPOUYNzLDExasBajA.png"/></div></div></figure><p id="99ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以添加一个<code class="fe mf mg mh mi b">happy-path</code>来确保我们的组件在成功场景中呈现:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="0732" class="mr ld iq mi b gy ms mt l mu mv">it('Shows a list of books', () =&gt; {<br/>    const props = {<br/>      books: [<br/>        {name: "Refactoring"},<br/>        {name: "Building Micro-service"}<br/>      ]<br/>    }<br/>    const wrapper = shallow(&lt;BookList {...props}/&gt;)<br/>    expect(wrapper.find('.book .title').length).toEqual(2)<br/>  })</span></pre><p id="0801" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能想知道我们已经在<code class="fe mf mg mh mi b">Acceptance test</code>测试过这个案例，这是重复吗？嗯，<em class="lb">是</em>和<em class="lb">否</em>，单元测试中的案例可以作为文档，它指定了组件需要什么参数，字段名和类型。例如，在<code class="fe mf mg mh mi b">props</code>中，我们明确表示<code class="fe mf mg mh mi b">BookList</code>需要一个带有<code class="fe mf mg mh mi b">books</code>字段的对象，它是一个数组。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行测试后，我们可以在控制台中看到一条警告:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="906f" class="mr ld iq mi b gy ms mt l mu mv">Warning: Each child in an array or iterator should have a unique "key" prop.<br/>    <br/>    Check the top-level render call using &lt;div&gt;. See https://fb.me/react-warning-keys for more information.<br/>        in div (at BookList.js:15)</span></pre><p id="b775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着当呈现一个列表时，<code class="fe mf mg mh mi b">React</code>需要为每个条目提供一个唯一的<code class="fe mf mg mh mi b">key</code>，就像<code class="fe mf mg mh mi b">id</code>一样。我们可以通过以下方式快速修复它:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="63a6" class="mr ld iq mi b gy ms mt l mu mv">it('Shows a list of books', () =&gt; {<br/>    const props = {<br/>      books: [<br/>        {name: "Refactoring", id: 1},<br/>        {name: "Building Micro-service", id: 2}<br/>      ]<br/>    }<br/>    const wrapper = shallow(&lt;BookList {...props}/&gt;)<br/>    expect(wrapper.find('.book .title').length).toEqual(2)<br/>  })</span></pre><p id="8d47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们的<strong class="kf ir">最终</strong>版本的<code class="fe mf mg mh mi b">BookList</code>是:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="10ff" class="mr ld iq mi b gy ms mt l mu mv">import React from 'react'</span><span id="1480" class="mr ld iq mi b gy mx mt l mu mv">function BookList({loading, error, books}) {<br/>  if(loading) {<br/>    return &lt;div className="loading" /&gt;<br/>  }</span><span id="492f" class="mr ld iq mi b gy mx mt l mu mv">  if(error) {<br/>    return &lt;div className="error" /&gt;<br/>  }</span><span id="7c68" class="mr ld iq mi b gy mx mt l mu mv">  return (&lt;div className="books"&gt;<br/>    {<br/>      books.map(book =&gt; {<br/>        return (&lt;div className="book" key={book.id}&gt;<br/>          &lt;h2 className="title"&gt;{book.name}&lt;/h2&gt;<br/>        &lt;/div&gt;)<br/>      })<br/>    }<br/>  &lt;/div&gt;)<br/>}</span><span id="f7d2" class="mr ld iq mi b gy mx mt l mu mv">export default BookList</span></pre><p id="4846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有单元测试都通过了，酷！</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e628d9de007dcfd1b19ddefaae667d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcHSzwtwWeN3od3uWemtdA.png"/></div></div></figure><p id="628f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们修改<code class="fe mf mg mh mi b">BookList</code>的用法，添加<code class="fe mf mg mh mi b">loading</code>和<code class="fe mf mg mh mi b">error</code>属性:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="1e67" class="mr ld iq mi b gy ms mt l mu mv">class BookListContainer extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      books: [],<br/>      loading: true,<br/>      error: null<br/>    }<br/>  }</span><span id="21ea" class="mr ld iq mi b gy mx mt l mu mv">  componentDidMount() {<br/>    axios.get('http://localhost:8080/books').then(res =&gt; {<br/>      this.setState({<br/>        books: res.data,<br/>        loading: false<br/>      })<br/>    }).catch(err =&gt; {<br/>      this.setState({<br/>        loading: false,<br/>        error: err<br/>      })<br/>    })<br/>  }</span><span id="4703" class="mr ld iq mi b gy mx mt l mu mv">  render() {<br/>    return &lt;BookList {...this.state} /&gt;<br/>  }<br/>}</span></pre><h1 id="e8a1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">注意</h1><p id="a2fe" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">有时，我们可能会发现对某些代码编写测试非常困难:有许多外部依赖。然后我们需要先做重构，把依赖项提取出来，然后添加测试。</p><p id="178d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一件事是，如果一个测试意外终止，那么在它之后的测试将会失败。这是因为我们在<code class="fe mf mg mh mi b">beforeEach</code>中插入了一些数据，但是由于测试终止，清理阶段没有执行，所以您可能需要通过以下方式手动清理:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="3f35" class="mr ld iq mi b gy ms mt l mu mv">curl http://localhost:8080/books?_cleanup=true -X DELETE</span></pre><p id="887f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复位<code class="fe mf mg mh mi b">books</code>后，再次运行测试应该没问题。</p></div></div>    
</body>
</html>