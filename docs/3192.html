<html>
<head>
<title>Build FFmpeg WebAssembly version (= ffmpeg.wasm): Part.3 ffmpeg.wasm v0.1 — Transcoding avi to mp4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建FFmpeg WebAssembly版本(= FFmpeg . wasm):part . 3 FFmpeg . wasm v 0.1—将avi代码转换为mp4</h1>
<blockquote>原文：<a href="https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-3-ffmpeg-js-v0-1-0-transcoding-avi-to-mp4-f729e503a397?source=collection_archive---------4-----------------------#2019-10-21">https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-3-ffmpeg-js-v0-1-0-transcoding-avi-to-mp4-f729e503a397?source=collection_archive---------4-----------------------#2019-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8c0c378d4f8e771bf56ebf20e4685f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bJYwDAe6Hj59mpHZr46olQ.png"/></div></figure><blockquote class="jx jy jz"><p id="fe5f" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2020/9更新:调整段落结构，使其更具可读性。</p></blockquote><p id="ec9c" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">以前的故事:<a class="ae lc" href="https://medium.com/@jeromewus/build-ffmpeg-webassembly-version-ffmpeg-js-part-2-compile-with-emscripten-4c581e8c9a16" rel="noopener">构建FFmpeg WebAssembly版本(= ffmpeg.wasm): Part.2用Emscripten编译</a></p><p id="e7d9" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">在这一部分，您将学习:</p><ol class=""><li id="2c5b" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky li lj lk ll bi translated">使用优化的参数构建FFmpeg的库版本。</li><li id="bed5" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">与ffmpeg.wasm互动</li><li id="a242" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">管理脚本文件系统。</li><li id="a278" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">开发具有转码功能的ffmpeg.wasm v0.1。</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1f49" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用优化的参数构建FFmpeg的库版本。</h1><p id="e11e" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">在第3部分中，我们的目标是创建一个基本的ffmpeg.wasm v0.1来将avi转码为mp4。由于我们在第2部分只创建了FFmpeg的基本版本，现在我们需要用一些参数进一步优化。</p><ol class=""><li id="f18a" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky li lj lk ll bi translated"><code class="fe nb nc nd ne b">-O3</code>:优化代码并减少代码大小(从30 MB减少到15 MB)(更多详情<a class="ae lc" href="https://emscripten.org/docs/optimizing/Optimizing-Code.html" rel="noopener ugc nofollow" target="_blank">此处</a>)</li><li id="37e9" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated"><code class="fe nb nc nd ne b">-s PROXY_TO_PTHREAD=1</code>:让我们的程序在使用pthread时有反应(更多细节<a class="ae lc" href="https://emscripten.org/docs/porting/pthreads.html#additional-flags" rel="noopener ugc nofollow" target="_blank">这里</a>)</li><li id="28f0" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated"><code class="fe nb nc nd ne b">-o wasm/dist/ffmpeg-core.js</code>:将ffmpeg.js重命名为ffmpeg-core.js <br/>(从这里我们称之为ffmpeg-core.js，因为我们将创建一个ffmpeg.js库来包装ffmpeg-core.js并提供用户友好的API。)</li><li id="0e79" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated"><code class="fe nb nc nd ne b">-s EXPORTED_FUNCTIONS="[_main, _proxy_main]"</code>:将main()和proxy_main()(由PROXY_TO_PTHREAD添加)C函数导出到JavaScript世界</li><li id="0cb1" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated"><code class="fe nb nc nd ne b">-s EXTRA_EXPORTED_RUNTIME_METHODS="[FS, cwrap, setValue, writeAsciiToMemory]"</code>:用于操作函数、文件系统和指针的额外函数，查看与代码和<a class="ae lc" href="https://emscripten.org/docs/api_reference/preamble.js.html" rel="noopener ugc nofollow" target="_blank"> preamble.js </a>交互的<a class="ae lc" href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html" rel="noopener ugc nofollow" target="_blank">了解更多详情。</a></li></ol><blockquote class="jx jy jz"><p id="152f" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有关这些参数的更多细节，您可以查看emscripten github存储库中的<a class="ae lc" href="https://github.com/emscripten-core/emscripten/blob/1.39.18/src/settings.js" rel="noopener ugc nofollow" target="_blank"> src/settings.js </a>。</p></blockquote><p id="af84" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">有了这些新的论点，让我们更新我们的<code class="fe nb nc nd ne b">build.sh</code>:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="df44" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">接下来我们试着和ffmpeg.wasm互动一下。</p><h1 id="d275" class="ly lz it bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">与ffmpeg.wasm互动</h1><p id="94e9" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">为了确保我们的ffmpeg.wasm正常工作，让我们尝试在ffmpeg.wasm中实现以下命令:</p><pre class="nf ng nh ni gt nq ne nr ns aw nt bi"><span id="40fb" class="nu lz it ne b gy nv nw l nx ny">$ ffmpeg -hide_banner</span></pre><p id="4721" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">使用<code class="fe nb nc nd ne b">-hide_banner</code>参数，ffmpeg隐藏了关于其版本和构建参数的细节，典型的输出如下所示:</p><pre class="nf ng nh ni gt nq ne nr ns aw nt bi"><span id="a621" class="nu lz it ne b gy nv nw l nx ny">Hyper fast Audio and Video encoder<br/>usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...</span><span id="628f" class="nu lz it ne b gy nz nw l nx ny">Use -h to get full help or, even better, run 'man ffmpeg'</span></pre><p id="d518" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">首先，让我们用下面的代码创建一个名为<code class="fe nb nc nd ne b">ffmpeg.js</code>的文件:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f107" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">上面代码的执行需要Node中的额外参数。JS:</p><pre class="nf ng nh ni gt nq ne nr ns aw nt bi"><span id="9044" class="nu lz it ne b gy nv nw l nx ny">$ node --experimental-wasm-threads --experimental-wasm-bulk-memory ffmpeg.js</span></pre><p id="1884" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">功能说明:</p><ul class=""><li id="bb13" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky oa lj lk ll bi translated"><code class="fe nb nc nd ne b">onRuntimeInitialized</code>:由于WebAssembly需要一些时间来启动，你需要等待这个函数被调用后才能使用这个库。</li><li id="ff8d" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky oa lj lk ll bi translated"><code class="fe nb nc nd ne b">cwrap</code>:JavaScript世界中C函数的包装函数。这里我们将proxy_main() / main()函数包装在<code class="fe nb nc nd ne b">fftools/ffmpeg.c</code>中。函数签名是<code class="fe nb nc nd ne b">int main(int argc, char **argv)</code>，很明显<code class="fe nb nc nd ne b">int</code>映射到<code class="fe nb nc nd ne b">number</code>，由于<code class="fe nb nc nd ne b">char **argv</code>是C语言中的指针，我们也可以将其映射到<code class="fe nb nc nd ne b">number</code>。</li></ul><p id="f1ae" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">然后我们需要把参数传递给它。<code class="fe nb nc nd ne b">$ ffmpeg -hide_banner</code>的等价自变量是<code class="fe nb nc nd ne b">main(2, ["./ffmpeg", "-hide_banner"])</code>。第一个参数很简单，但是我们如何传递一个字符串数组呢？让我们将问题分解为两部分:</p><ol class=""><li id="cbc6" class="ld le it kd b ke kf ki kj kz lf la lg lb lh ky li lj lk ll bi translated">我们需要将JavaScript中的string转换成C中的char数组</li><li id="495d" class="ld le it kd b ke lm ki ln kz lo la lp lb lq ky li lj lk ll bi translated">我们需要将JavaScript中的数字数组转换成C中的指针数组</li></ol><p id="41d0" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">第一部分比较容易，因为我们有一个来自Emscripten的名为<code class="fe nb nc nd ne b">writeAsciiToMemory()</code>的实用函数来帮助我们，下面是一个使用该函数的示例:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ceab" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">第二部分比较复杂，我们需要用C语言创建一个32位整数的指针数组，因为指针是32位整数。我们需要在这里使用<code class="fe nb nc nd ne b">setValue</code>来创建我们需要的数组:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d1e5" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">合并上面的所有片段，现在我们可以与ffmpeg.wasm交互并生成预期的结果:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b14b" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">现在，我们可以轻松地与ffmpeg.wasm进行交互，但如何将视频文件传递给它呢？这是下一节的重点:文件系统。</p><h1 id="0e67" class="ly lz it bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">管理脚本文件系统。</h1><p id="cd59" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">在Emscripten中，有一个虚拟文件系统来支持C中的标准文件读/写，因此我们需要在将参数传递给ffmpeg.wasm之前将视频文件写入这个文件系统。</p><blockquote class="jx jy jz"><p id="c56f" class="ka kb kc kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae lc" href="https://emscripten.org/docs/api_reference/Filesystem-API.html" rel="noopener ugc nofollow" target="_blank">文件系统API </a>中找到更多细节。</p></blockquote><p id="23f7" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">很多时候，完成任务只需要2个FS函数:<code class="fe nb nc nd ne b">FS.writeFile()</code>和<code class="fe nb nc nd ne b">FS.readFile()</code>。</p><p id="4131" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">对于所有写入或读取文件系统的数据，它必须是JavaScript中的Uint8Array类型，记住在使用数据之前要进行类型转换。</p><p id="38a7" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">对于本教程，我们先用一个名为<code class="fe nb nc nd ne b">flame.avi</code>(这里可以下载<a class="ae lc" href="https://github.com/ffmpegwasm/testdata/raw/master/flame.avi" rel="noopener ugc nofollow" target="_blank">)的文件，用<code class="fe nb nc nd ne b">fs.readFileSync()</code>读取，用<code class="fe nb nc nd ne b">FS.writeFile()</code>写入Emscripten文件系统。</a></p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="46bc" class="ly lz it bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">开发具有转码功能的ffmpeg.wasm v0.1。</h1><p id="e978" class="pw-post-body-paragraph ka kb it kd b ke mw kg kh ki mx kk kl kz my ko kp la mz ks kt lb na kw kx ky im bi translated">现在我们能够将参数传递给ffmpeg.wasm并将文件保存到文件系统，让我们将它们组合在一起，让我们的ffmpeg.wasm v0.1工作起来。</p><p id="d362" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">我们需要注意的最后一个细节是，上面的<code class="fe nb nc nd ne b">ffmpeg()</code>实际上是异步运行的，所以为了获得输出文件，我们需要使用一个<code class="fe nb nc nd ne b">setInterval()</code>来解析日志文件，以了解转换是否完成。</p><p id="fcd2" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">综上所述，现在我们有了第一个ffmpeg.wasm，可以将avi文件转码为mp4文件，不会出现任何问题:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a294" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">你可以访问这里的知识库，详细了解它是如何工作的:<a class="ae lc" href="https://github.com/ffmpegwasm/FFmpeg/tree/n4.3.1-p3" rel="noopener ugc nofollow" target="_blank">https://github.com/ffmpegwasm/FFmpeg/tree/n4.3.1-p3</a></p><p id="a725" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">并且可以在这里随意下载构建神器:<a class="ae lc" href="https://github.com/ffmpegwasm/FFmpeg/releases/tag/n4.3.1-p3" rel="noopener ugc nofollow" target="_blank">https://github.com/ffmpegwasm/FFmpeg/releases/tag/n4.3.1-p3</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="29d3" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">请注意，目前它只是Node.js版本，但我们将在<a class="ae lc" href="https://medium.com/@jeromewus/build-ffmpeg-webassembly-version-ffmpeg-js-part-4-ffmpeg-js-v0-2-web-worker-and-libx264-d0596f1beb4e" rel="noopener">构建FFmpeg WebAssembly版本(= FFmpeg . wasm):part . 4 FFmpeg . wasm v 0.2-添加Libx264 </a>中开发一个浏览器版本</p><p id="eaf1" class="pw-post-body-paragraph ka kb it kd b ke kf kg kh ki kj kk kl kz kn ko kp la kr ks kt lb kv kw kx ky im bi translated">期待在第四部分见到你😃</p></div></div>    
</body>
</html>