<html>
<head>
<title>Advanced React pattern -Compound Component [UI libraries love it]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级反应模式-复合组件[UI库喜欢它]</h1>
<blockquote>原文：<a href="https://itnext.io/compound-component-advanced-pattern-react-libraries-love-fea7a730bb73?source=collection_archive---------1-----------------------#2021-04-04">https://itnext.io/compound-component-advanced-pattern-react-libraries-love-fea7a730bb73?source=collection_archive---------1-----------------------#2021-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7407dde4753c03f48ee64a1db9e7846d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S3RIdivKzltIpKWa"/></div></div></figure><p id="cd95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我们来看看一个流行的React模式——复合组件。这种模式允许以清晰和声明性的方式编写复杂的组件。事实证明，它非常有用，几乎所有流行的React UI库，如<a class="ae kz" href="https://material-ui.com/components/menus/" rel="noopener ugc nofollow" target="_blank">材质UI </a>、<a class="ae kz" href="https://react.semantic-ui.com/collections/menu/#types-basic" rel="noopener ugc nofollow" target="_blank">语义UI </a>、<a class="ae kz" href="https://isamatov.com/chakra-ui-react/" rel="noopener ugc nofollow" target="_blank"> Chakra UI </a>以及许多其他库，最终都采用了它。</p><p id="f4c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将包括构建复合组件的老方法和使用钩子和上下文API的新版本。</p><p id="2b76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将使用<a class="ae kz" href="https://emotion.sh/docs/introduction" rel="noopener ugc nofollow" target="_blank"> Emotion </a>样式库和TypeScript编写组件。</p><h1 id="bbef" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是复合组件模式？</h1><p id="9d1d" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如前所述，复合组件模式允许为复杂组件编写声明性的灵活API。您使用多个松散耦合的子组件来构建组件。它们中的每一个都执行不同的任务，但是它们都共享相同的隐式状态。当这些子组件放在一起时，就构成了我们的复合组件。</p><p id="aad1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">毫无疑问，您以前在使用UI库时遇到过复合组件。看一下这个片段:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5c8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结构看着眼熟吗？这就是复合组件的API的典型外观。</p><p id="8a8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是手风琴组件的高级结构:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/60a256df9665b41a2b11376e3db888df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/0*uDRX19z0VA2EV77-"/></div></figure><p id="0e41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">顺便提一下，很多UI库使用<code class="fe mk ml mm mn b">.</code>作为它们的复合组件API，如下所示:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0fc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法完全是可选的，您可以按照自己喜欢的方式编写组件。它不会以任何显著的方式影响最终结果。</p><h1 id="f9ad" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么要使用复合组件模式？</h1><p id="9386" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">重申一下，以这种方式构建复杂组件的主要优点是使用起来非常容易。由于隐式状态，复合组件的内部工作对客户端是隐藏的。同时，客户可以按照自己喜欢的方式灵活地重新安排和定制子组件。</p><p id="643f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们是如何声明性地列出Accordion的内容，而不必干预其内部状态的。</p><p id="e381" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mn b">Accordion</code>将处理所有的内部状态逻辑，包括点击时收缩和展开项目。我们所要做的就是按照我们想要的顺序列出这些项目。</p><p id="42dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以让我们最后一次回顾一下使用复合组件模式的优点:</p><ol class=""><li id="f83e" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated">组件的API是声明性的。</li><li id="eda0" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">您的子组件是松散耦合的。这使得重新排序、添加和删除子组件变得容易，而不会影响它的兄弟组件。</li><li id="b120" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">更容易设计和改变组件的设计。</li></ol><p id="98f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然你已经被说服试一试了，让我们从教程开始吧。我们会做我们一直在谈论的手风琴。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/f76c66ec3f652fcf1a5bf83c83fc1520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WJHgZN6hpIaOiEQu"/></div></div></figure><p id="b751" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，我们将讨论新旧方法。</p><h1 id="9f9d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">旧方法</h1><p id="bb0d" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><strong class="kd iu">助手方法</strong></p><p id="21aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在孩子之间共享状态的老方法涉及到使用两个React方法:<code class="fe mk ml mm mn b">React.Children.map</code>和<code class="fe mk ml mm mn b">cloneElement</code>。让我们简单介绍一下。</p><p id="1cc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mn b">React.Children.map</code>允许你迭代组件的<code class="fe mk ml mm mn b">children</code>属性，就像你迭代数组一样。根据官方文件:</p><blockquote class="nd ne nf"><p id="d6c2" class="kb kc ng kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated">"对包含在设置为thisArg的子级中的每个直接子级调用函数。如果children是一个数组，它将被遍历，并将为数组中的每个children调用该函数。</p></blockquote><p id="bc9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mn b">cloneElement</code>让你创建任何反应元素的副本，并传递任何你喜欢的附加道具。根据文件:</p><blockquote class="nd ne nf"><p id="92b3" class="kb kc ng kd b ke kf kg kh ki kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ky im bi translated">"以元素为起点，克隆并返回一个新的React元素."</p></blockquote><p id="8694" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">手风琴</strong></p><p id="2ed2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mn b">Accordion</code>是与其所有子组件共享状态的父组件。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="dd07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们一起使用<code class="fe mk ml mm mn b">React.Children.map</code>和<code class="fe mk ml mm mn b">cloneElement</code>来迭代<code class="fe mk ml mm mn b">children</code>属性。对于每个子元素，我们克隆元素并传递额外的属性<code class="fe mk ml mm mn b">openItem</code>和<code class="fe mk ml mm mn b">setOpenItem</code>，我们将使用它们来设置当前活动的项目。</p><p id="3267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">符合项</strong></p><p id="d3e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mk ml mm mn b">AccordionItem</code>有趣的是它既是父母又是孩子。它是<code class="fe mk ml mm mn b">Accordion</code>组件的子组件，但也是<code class="fe mk ml mm mn b">AccordionHeader</code>和<code class="fe mk ml mm mn b">AccordionPanel</code>组件的父组件。它还使用<code class="fe mk ml mm mn b">cloneElement</code>将从<code class="fe mk ml mm mn b">Accordion</code>收到的道具传递给它的子节点。</p><p id="7361" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码如下:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fbb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">符合标题</strong></p><p id="ae66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该组件将注册<code class="fe mk ml mm mn b">onClick</code>事件，这将允许我们收缩/扩展每个项目。为此，我们使用从<code class="fe mk ml mm mn b">AccordionItem</code>接收的<code class="fe mk ml mm mn b">setOpenItem</code>方法。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fdc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">符合面板</strong></p><p id="809a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该组件负责显示AccordionItem的内容。它根据<code class="fe mk ml mm mn b">openItem</code>属性的值收缩或扩展。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="5a4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已就是这么回事。这种实现是可行的，但是它限制了我们如何构造孩子。例如，如果您尝试使用一些其他元素作为<code class="fe mk ml mm mn b">Accordion</code>的子元素，我们的API将会中断，如下所示:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="cd96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">错误如下:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/1afd6f9201d30a9f80b6963b652f7290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IkUBGq6o2w6wg6RH"/></div></div></figure><p id="e912" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因是<code class="fe mk ml mm mn b">React.Children.map</code>只能在<code class="fe mk ml mm mn b">Accordion</code>的直接子元素上迭代，所以在<code class="fe mk ml mm mn b">div</code>中嵌套子元素是行不通的。</p><p id="57f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以做得更好。让我们看看使用上下文API的新实现。</p><h1 id="3700" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">更新的方法</h1><p id="3d48" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，很多代码都是相似的。主要区别在于，我们使用上下文API并创建一个提供者，而不是使用<code class="fe mk ml mm mn b">React.Children.Map</code>和<code class="fe mk ml mm mn b">cloneElement</code>来共享道具。</p><p id="5682" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">手风琴</strong></p><p id="26aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们对<code class="fe mk ml mm mn b">Accordion</code>的新实现:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a9bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建<code class="fe mk ml mm mn b">AccordionContext</code>并使用<code class="fe mk ml mm mn b">AccordionContext.Provider</code>来传递<code class="fe mk ml mm mn b">openItem</code>和<code class="fe mk ml mm mn b">setOpenItem</code>道具。另外，请注意我们如何用<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>包装<code class="fe mk ml mm mn b">value</code>以防止多余的重新渲染。</p><p id="1906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">根据项目</strong></p><p id="d48d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是<code class="fe mk ml mm mn b">AccordionItem</code>的代码:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e0cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们不再需要传递从手风琴接收到的道具。但是我们仍然在这里使用<code class="fe mk ml mm mn b">cloneElement</code>来传递<code class="fe mk ml mm mn b">id</code>道具。</p><p id="4bb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">折叠面板&amp;折叠头</strong></p><p id="8385" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些子元素现在使用<code class="fe mk ml mm mn b">useContext</code>钩子直接从上下文中拉出共享状态。下面是它们的实现:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f713" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总的来说，这个实现代码更少，性能更好。这是因为<code class="fe mk ml mm mn b">cloneElement</code>会导致轻微的性能损失。</p><p id="bcf6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，主要的优势是我们为Accordion提供了一个更加灵活的API，之前中断的示例代码现在也可以正常工作了。</p><p id="92ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">结论</strong></p><p id="96c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用复合组件模式构建组件是一种享受。使用这种模式，您可以更好地应对设计和功能需求的不断变化。构建软件时经常发生的事情。我希望这篇文章对你有用！</p><p id="5b1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢Ken C. Todds的这篇伟大的文章解释了这个概念。</p><p id="1f1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是<a class="ae kz" href="https://codesandbox.io/s/compound-component-with-context-krvr7" rel="noopener ugc nofollow" target="_blank">链接</a>到CodeSandbox，包含本教程的完整代码。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="b286" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ng">原载于2021年4月4日</em><a class="ae kz" href="https://isamatov.com/compound-components-react/" rel="noopener ugc nofollow" target="_blank"><em class="ng">【https://isamatov.com】</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>