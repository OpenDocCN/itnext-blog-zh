<html>
<head>
<title>NoSQL does not mean !Relational</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NoSQL不是指！有关系的</h1>
<blockquote>原文：<a href="https://itnext.io/nosql-does-not-mean-relational-8aac79ce6b9c?source=collection_archive---------3-----------------------#2021-04-16">https://itnext.io/nosql-does-not-mean-relational-8aac79ce6b9c?source=collection_archive---------3-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都遇到过一些文章、推文和博客文章，建议您应该使用SQL(例如，MySQL)来处理所有与关系相关的事情。这不是真的。我们使用的大多数(如果不是全部)数据都有某种关系。让我们看看我们是如何在MySQL和Google Cloud Firestore中创建和引用关系数据的。我将使用一个有<code class="fe kl km kn ko b">users</code>、<code class="fe kl km kn ko b">restaurants</code>、<code class="fe kl km kn ko b">dishes</code>和<code class="fe kl km kn ko b">orders</code>的订餐应用程序来展示MySQL和文档数据库的数据模型之间的差异</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/39b6656fefb7659420eb2adb19a7af04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JxSZCsCL2D2dI-I3mUjYA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">https://undraw.co</figcaption></figure><h1 id="1b57" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">模型</h1><p id="630a" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">首先，我们需要理解数据中的关系。然后我们可以开始构建我们的模式。不管我们使用SQL还是NoSQL，重要的是考虑你的数据，设想查询它，并建立一个合适的模型。也就是说，让我们看看我们的数据模型</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="ed7b" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">SQL Model</strong></span><span id="48bb" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">App_User<br/></strong>  - id<br/><strong class="ko ir">  </strong>- given_name<br/>  - surname<br/>  - email<br/>  - phone</span><span id="19e7" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">App_Restaurant<br/></strong>  - id<br/><strong class="ko ir">  </strong>- name<br/>  - address<br/>  - city<br/>  - state<br/>  - postal_code<br/>  - phone</span><span id="9299" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">App_Dish<br/></strong>  - id<br/><strong class="ko ir">  </strong>- name<br/>  - description<br/>  - price<br/>  - app_restaraunt_id</span><span id="62a5" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">App_Order<br/></strong>  - id<br/><strong class="ko ir">  </strong>- user_id<br/>  - restaurant_id<br/>  - order_total</span><span id="80b3" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">App_Order_Item<br/></strong>  - order_id<br/><strong class="ko ir">  </strong>- dish_id<br/>  - quantity<br/>  - price_at_order<br/>  - special_requests (e.g., no onions)</span></pre><p id="9290" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些关系细分如下:</p><ul class=""><li id="cb93" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">一家餐厅</strong> <code class="fe kl km kn ko b">has_many</code> <strong class="jp ir">菜肴</strong></li><li id="97a4" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">某餐厅</strong> <code class="fe kl km kn ko b">has_many</code> <strong class="jp ir">点菜</strong></li><li id="bd8b" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">发出用户</strong> <code class="fe kl km kn ko b">has_many</code> <strong class="jp ir">命令</strong></li><li id="42e6" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">某餐厅</strong> <code class="fe kl km kn ko b">has_many</code> <strong class="jp ir">顾客:用户</strong> <code class="fe kl km kn ko b">through</code> <strong class="jp ir">订单</strong></li><li id="e510" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">点菜</strong> <code class="fe kl km kn ko b">has_many</code> <strong class="jp ir">菜品</strong> <code class="fe kl km kn ko b">through</code> <strong class="jp ir">点菜_物品</strong></li></ul><p id="f1ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这个模型在Firestore这样的文档数据库中会是什么样子。在Firestore中，他们将文档存储在集合中，而不是像SQL那样存储在表中。简单点说，集合=表。</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="8f8d" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">Document Model - Firestore</strong></span><span id="1c0b" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">users {<br/>  </strong>id<strong class="ko ir"> </strong>{<br/>    givenName,<br/>    surname,<br/>    email,<br/>    phone,<br/>  }<br/><strong class="ko ir">}</strong></span><span id="99f0" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">restaurants {<br/></strong>  id {<br/>    name,<br/>    address,<br/>    city,<br/>    state,<br/>    postalCode,<br/>    phone,<br/>  }<br/>  <br/>  <strong class="ko ir">dishes (</strong>sub-collection)<br/>    id {<br/>      name,<br/>      description,<br/>      price<br/>    }</span><span id="c130" class="mm lg iq ko b gy mr mo l mp mq">  <strong class="ko ir">orders (</strong>sub-collection)<br/>    id {<br/>      customerName,<br/>      customerId,<br/>      items: [<br/>        {dishId, name, price, quantity, specialRequest},<br/>      ],<br/>      orderTotal<br/>    }<br/><strong class="ko ir">}</strong></span><span id="f745" class="mm lg iq ko b gy mr mo l mp mq">// users &amp; restaurants are collections<br/>// dishes &amp; orders are sub-collections</span></pre><p id="5670" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文档模型中，我们利用子集合以及订单中项目的数组。我们可以在文档存储中对此进行不同的建模，并将所有内容作为顶级集合，但是我更喜欢在这个用例中使用子集合。</p><p id="e160" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数送餐应用程序会向您展示一个餐馆列表，我们如何使用SQL和文档存储来展示餐馆列表呢</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="f29f" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">SQL Query</strong><br/>SELECT * from App_Restaurant;</span><span id="0c40" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">Document Query</strong><br/>firestore.collection('restaurants').get();</span></pre><p id="18df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经向用户展示了餐馆列表，我们想向他们展示他们提供的菜肴。</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="d0a2" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">SQL Query</strong><br/>SELECT * from App_Dish WHERE app_restaurant_id = restaurant_id;</span><span id="b923" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">Document Query</strong><br/>firestore<br/>  .collection(`restaurants/${restaurantId}/dishes)<br/>  .get();</span></pre><p id="1c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，文档模型看起来非常类似于API route <code class="fe kl km kn ko b">restaurants/${restaurantId}/dishes</code>。接下来，我们需要保存用户的订单——他们通常会选择一个项目，并指定数量和任何特殊要求(例如，不要添加洋葱)。让我们看看SQL与文档数据库的对比</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="efb9" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">SQL</strong><br/>-- start an order <br/>INSERT INTO App_Order (user_id, restaurant_id, order_total) VALUES (user_id, restaurant_id, 0);</span><span id="f856" class="mm lg iq ko b gy mr mo l mp mq">-- add items to an order<br/>INSERT INTO App_Order_Item (order_id, dish_id, quantity, price_at_order, special_requests) VALUES (order_id, dish_id, quantity, price_at_order, special_requests);</span><span id="bfa8" class="mm lg iq ko b gy mr mo l mp mq"><strong class="ko ir">Document DB<br/></strong>// start an order<br/>firestore<br/>  .collection(`restaurants/${restaurantId}/orders)<br/>  .add({<br/>    customerName, <br/>    customerId, <br/>    items: [{<br/>      dishId,<br/>      name,<br/>      price,<br/>      quantity,<br/>      specialRequest<br/>    }], <br/>    orderTotal<br/>  });</span><span id="4fe9" class="mm lg iq ko b gy mr mo l mp mq">// add items to an order<br/>firestore<br/>  .collection(`restaurants/${restaurantId}/orders)<br/>  .update({<br/>    items: [<br/>      ...items,<br/>      {dishId, name, price, quantity, specialRequest}<br/><em class="ng">      // or you could pass the new array</em><br/>    ]<br/>  })</span><span id="9c70" class="mm lg iq ko b gy mr mo l mp mq">// or user the firestore arrayUnion method<br/>firestore<br/>  .collection(`restaurants/${restaurantId}/orders)<br/>  .update({<br/>    items: firebase.firestore.FieldValue.arrayUnion({<br/>      dishId,<br/>      name,<br/>      price,<br/>      quantity,<br/>      specialRequest<br/>    })<br/>  })</span></pre><p id="ba43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一些用户、餐馆、菜肴和订单，是时候看看我们如何查询数据了。</p><p id="bc58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了向餐馆显示他们的订单、每个订单的商品以及订购它的顾客姓名，我们需要执行几个查询，其中包括获取相关数据的连接。</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="232f" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">SQL</strong><br/>-- Restaurant Orders with user name and phone<br/><strong class="ko ir">SELECT</strong> order.id, order.restaurant_id, order.user_id, item.quantity, item.special_requests, item.price_at_order, dish.name, user.given_name<br/><strong class="ko ir">FROM</strong> App_Order order<br/><strong class="ko ir">JOIN</strong> App_Order_Item item <strong class="ko ir">ON</strong> order.id = item.order_id<br/><strong class="ko ir">JOIN</strong> App_User user <strong class="ko ir">ON</strong> order.user_id = user.id<br/><strong class="ko ir">JOIN</strong> App_Dish dish <strong class="ko ir">ON</strong> item.dish_id = dish.id<br/><strong class="ko ir">WHERE</strong> order.restaurant_id = restaurant_id;</span></pre><p id="c7fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用了一个基本的连接查询来显示获取我们需要的所有数据所需的代码量。</p><p id="339d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看如何在Firestore中查询餐厅订单，包括商品和用户信息</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="1a51" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">Firestore<br/></strong>firestore<br/>  .collection(`restaurants/${restaurantId}/orders`)<br/>  .get();</span></pre><p id="bac0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于非规范化数据和子集合的使用，我们有一个非常快速的访问模式。</p><p id="abc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，假设用户想查看他们的订单历史，而不考虑餐馆</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="c54d" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">SQL<br/></strong>-- Grab orders regardless of restaurant<br/><strong class="ko ir">SELECT</strong> dish.name, restaurant.name, order.order_total <br/><strong class="ko ir">FROM</strong> App_Order order<br/><strong class="ko ir">JOIN</strong> App_Order_Item item <strong class="ko ir">ON</strong> order.id = item.order_id<br/><strong class="ko ir">JOIN</strong> App_Dish dish <strong class="ko ir">ON</strong> item.dish_id = dish.id<br/><strong class="ko ir">JOIN</strong> App_Restaurant restaurant <strong class="ko ir">ON</strong> order.restaurant_id = restaurant.id<br/><strong class="ko ir">WHERE</strong> order.user_id = user_id</span></pre><p id="8266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次执行SQL查询并连接多个表中的数据，以显示用户请求的信息。下面是我们如何在Firestore上做同样的事情</p><pre class="kq kr ks kt gt mi ko mj mk aw ml bi"><span id="5681" class="mm lg iq ko b gy mn mo l mp mq"><strong class="ko ir">Firestore<br/></strong>firestore<br/>  .collectionGroup('orders')<br/>  .where('customerId', '==', user.id)<br/>  .get();</span></pre><p id="ac07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，Firestore查询再次变得更加简单。它还使用Firestore的一个奇妙的查询功能，称为<a class="ae nh" href="https://firebase.google.com/docs/firestore/query-data/queries#collection-group-query" rel="noopener ugc nofollow" target="_blank">集合组查询</a>。</p><p id="c07d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公平地说，我们可以对SQL存储中的数据进行反规范化以使查询更容易，或者我们可以使用数组/映射等。但是，这篇文章的目的是展示如何使用文档数据库来建模关系数据并简化访问模式。</p><p id="9b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae nh" href="https://nowims.com" rel="noopener ugc nofollow" target="_blank"> Now IMS </a>，我们更倾向于使用Firestore作为我们的主数据库，因为它具有高度可扩展性，提供对连接设备的实时同步，并提供强大的SLA，并且托管在我们认为最好的云上— <a class="ae nh" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云</a>。</p><p id="a5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望这有助于您理解如何利用文档数据库不仅对关系数据建模，而且简化您的访问模式和开发。我们的下一篇文章将关注非规范化关系数据。</p></div></div>    
</body>
</html>