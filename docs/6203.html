<html>
<head>
<title>React antipatterns to avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对反模式做出反应以避免</h1>
<blockquote>原文：<a href="https://itnext.io/react-antipatterns-to-avoid-350929bdebf0?source=collection_archive---------0-----------------------#2021-09-19">https://itnext.io/react-antipatterns-to-avoid-350929bdebf0?source=collection_archive---------0-----------------------#2021-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/580909f3cf2fcb4f76e703c1e4834657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gviFUCryTO0bXNt8B8a9bA.png"/></div></div></figure><p id="140b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是React应用程序中最常见的一些反模式以及如何修复它们。如果您没有学会在早期识别和预防这些反模式，那么它们将会使您的代码库成为一场噩梦。</p><h1 id="3b89" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">把一切都放在Redux中</h1><p id="f3bd" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Redux很牛逼。它在幕后优化性能，并让我们轻松地进入应用程序的全局状态。</p><p id="d8ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是，一旦新开发人员学会了Redux，他们就开始像使用魔杖一样使用它来解决他们的所有问题。<br/>这种方法有几个缺点:</p><ul class=""><li id="a979" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">你的代码失去了意图。如果所有东西都在Redux中，就不清楚你的代码应该是局部的还是全局的。做出改变更加棘手，因为你对应用程序中会受到影响的部分不太有信心。</li><li id="b557" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">当您对频繁事件使用Redux时，性能会下降，比如跟踪表单输入。由于Redux影响应用程序的全局状态，它肯定会导致更多的重新渲染。</li></ul><p id="4786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">经验法则:只对真正的全局数据使用Redux，比如用户会话或应用主题。对于其他任何事情，我喜欢为应用程序的特定部分创建上下文。</strong></p><h1 id="450e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">将所有内容存储为一个状态</h1><p id="7572" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">新开发人员遇到的另一个问题是没有充分利用<a class="ae mq" href="https://isamatov.com/react-derived-state/" rel="noopener ugc nofollow" target="_blank">派生状态</a>的概念。</p><p id="5091" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很多变量都可以即时计算。例如，假设您有一组复选框项目。不需要在状态中存储<code class="fe mr ms mt mu b">checkedCount</code>。您可以通过遍历项目数组并在每次渲染时过滤选中的项目来获得<code class="fe mr ms mt mu b">checkedCount</code>。</p><p id="d7ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">经验法则:在状态中存储一个变量之前，问自己:“我能不能基于我已经存储的其他数据导出这个变量？”</strong></p><h1 id="aa25" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">到处使用spread运算符传递道具</h1><p id="9827" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我在React应用程序中见过很多这样的技巧。</p><p id="27dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您使用<code class="fe mr ms mt mu b">{...props}.</code>将道具传递给子组件，这看起来很简洁，您可能认为您在使代码更加简洁。但事实是，随着时间的推移，您的代码将更难预测和理解。</p><p id="6ebd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您开始使用spread operator到处传递道具时，并不能立即清楚您的子组件实际上需要哪些道具。重构变得几乎不可能。即使很小的重构努力也会打开一个蠕虫罐。此外，在组件树中跟踪bug要困难得多。</p><p id="8d1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">经验法则:通常避免使用spread操作符传递道具。</strong>有一次它被证明是正当的，那就是编写一个容器组件或HOC来呈现和增强其子组件。</p><h1 id="3ab9" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在组件内部声明组件</h1><p id="d313" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在另一个组件中声明组件如下所示:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/54d4b48b1edb3cbf6ea62115abcd9a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WF4KcHpJx0oIcYGUolFyMw.png"/></div></div></figure><p id="ea54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在它们的父组件内部编写组件是一个坏主意，原因有二:</p><ul class=""><li id="6c13" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">您的代码变得紧密耦合。您的内部组件依赖于其父组件的闭包范围。</li><li id="51aa" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">性能下降。父组件将在每次渲染时重新创建子组件的声明函数。</li></ul><p id="23d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">经验法则:避免在父组件内部声明组件。</strong></p><h1 id="cef4" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">向组件传递太多信息</h1><p id="ea0b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">不告诉你的组件你知道多少是好的。在决定要传递多少数据时，尽量记住智能组件和表示组件之间的区别。</p><p id="9965" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">表示组件是只输出HTML的组件。它们不持有状态，也不处理任何行为逻辑。</p><p id="6f40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">智能组件通常处理状态，并通过发出API请求、改变redux等方式向表示组件提供数据和行为。</p><p id="2f41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于表示组件，您应该只传递它呈现所需的数据。表示组件不应该决定是否呈现它们的内容。这种逻辑应该由智能组件来处理。</p><p id="0ae1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，看一下这段代码:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/fe07a4356d9caf67049a9b94a48756b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4vQhStViP_yR_zlTZP5xg.png"/></div></div></figure><p id="b0c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您检查父组件时，不清楚我们的子组件是否有条件呈现逻辑。我们可以通过重新呈现条件逻辑并让我们的父组件决定是否呈现其子组件来澄清这段代码。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/453c2ca03ca2dcf40fa3ad32b9dd68e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mkg2JcvkhKRhRwR5UB6C2A.png"/></div></div></figure><p id="5866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果可能的话，只将原语传递给表示组件。这样做可以简化以后的性能优化。假设你像这样传递整个<code class="fe mr ms mt mu b">user</code>对象:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/c295ad5ef50579e38648583b575bfc99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWJ7VAcwreXYl1APeSqkng.png"/></div></div></figure><p id="08af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，您可以传递用户的名字、姓氏和日期:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/6e08c6677833caa219b6e4f094228770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFOWIsB3KqRb-usoD2GBfA.png"/></div></div></figure><p id="85d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使得使用<code class="fe mr ms mt mu b">React.memo</code>减少重新渲染的次数更加容易。原因是React基于引用比较对象道具，而原语基于值比较。</p><p id="c0b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总而言之，向组件传递太多信息存在以下问题:</p><ul class=""><li id="ac92" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">更难区分智能组件和表示性组件。应用程序的主要逻辑应该由智能组件来处理，而表示组件只输出HTML。</li><li id="2d0a" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">性能恶化。当你给组件传递太多的道具时，它会在每次这些道具改变时重新渲染，导致多余的重新渲染。</li></ul><h1 id="5ace" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">过度优化性能</h1><p id="cac8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">有时候，开发人员在任何真正的问题出现之前就开始优化他们的代码。这是一种糟糕的做法，原因很简单:</p><ul class=""><li id="f62b" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">复杂和过度设计的代码。试图在问题出现之前解决问题是使代码过于复杂的最可靠的方法。</li><li id="e840" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">浪费时间。你可以开发新的功能，解决重要的问题。</li></ul><p id="dc90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据我的经验，智能地分离智能组件和表示组件可以解决React应用程序中大约90%的性能问题。</p><h1 id="9e00" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">巨大的组件树</h1><p id="3adb" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">最后但同样重要的是大型组件树。</p><p id="de91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常，当您没有花时间正确地分离代码的逻辑部分和表示部分时，就会出现这个问题。</p><p id="dfce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，看看这个组件:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/a3b2080bc92c1e32b274685df6771fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v_opO6l27-BXN-hbNd6lg.png"/></div></div></figure><p id="d7a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">恶心吧。很难理解这里发生了什么。我们有几个需要改进的地方:</p><ul class=""><li id="df2a" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">将长条件语句重构为单独的变量。</li><li id="0377" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">将树分成更小的表示组件。</li><li id="0f33" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">将箭头函数处理程序移出组件树。</li></ul><p id="6800" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们应用这些，看看组件现在是什么样子:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/0c4a48744164bdbb5b662f406c238c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aqtI6Olyn9_yo9rBVUpD1Q.png"/></div></div></figure><p id="1780" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个组件树看起来好多了。</p><p id="b5d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">经验法则:保持组件树的整洁，这样更容易看到组件应该在什么时候呈现什么。</p><h1 id="01b2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="5176" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这篇文章中，我们讨论了React反模式以及如何避免它们。通过从一开始就避免这些反模式，您将来就不需要花太多时间来重构代码。在这里查看我的帖子，了解更多关于编写干净的React代码的<a class="ae mq" href="https://isamatov.com/simple-tips-for-writing-clean-react-components/" rel="noopener ugc nofollow" target="_blank">技巧</a>。</p><p id="7c6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="fde5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ni">原载于2021年9月19日</em><a class="ae mq" href="https://isamatov.com/react-antipatterns/" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://isamatov.com</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>