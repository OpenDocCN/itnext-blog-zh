<html>
<head>
<title>How to Use TensorBoard?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TensorBoard？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-tensorboard-5d82f8654496?source=collection_archive---------0-----------------------#2018-06-09">https://itnext.io/how-to-use-tensorboard-5d82f8654496?source=collection_archive---------0-----------------------#2018-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="92c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TensorFlow相对于许多其他可用库的两个主要优势是灵活性和可视化。想象一下，如果您可以将代码中发生的事情可视化(在这种情况下，代码代表我们为模型创建的计算图形)，那么深入理解和观察图形的内部工作将会非常方便。不仅如此，它还有助于修复那些不能正常工作的东西。TensorFlow提供了一种使用TensorBoard实现这一点的方法！</p><p id="71b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TensorBoard </strong>是任何标准TensorFlow安装都附带的可视化软件。用谷歌的话说:</p><blockquote class="kl km kn"><p id="cb1f" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">“你将在许多事情上使用TensorFlow进行计算(如训练大规模深度神经网络)，它们可能会很复杂，令人困惑。为了更容易理解、调试和优化TensorFlow程序，我们加入了一套名为TensorBoard的可视化工具。”</p></blockquote><p id="2878" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">张量流程序的范围可以从非常简单的问题到超级复杂的问题(使用成千上万的计算)，它们都有两个基本的组成部分，运算和张量。正如前面的教程中所解释的，其思想是创建一个由一组操作组成的模型，将数据输入到模型中，张量将在操作之间流动，直到获得一个输出张量，即您的结果。TensorBoard为我们提供了一套web应用程序，帮助我们检查和理解TensorFlow运行和图形。目前，它提供了五种类型的可视化:标量、图像、音频、直方图和图形。</p><p id="6c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完全配置后，TensorBoard窗口将类似于:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/157abd77f7d65e75dc53a7b040e2f934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MgGFuTog6ZMC_RQp.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li"> <em class="lj">图一。</em> </strong>张量板出场</figcaption></figure><p id="0a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建TensorBoard是为了帮助我们理解您的模型中的张量流，以便我们可以调试和优化它。它通常用于两个主要目的:</p><p id="708d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。可视化图表</strong></p><p id="b403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。撰写总结以可视化学习</strong></p><p id="7a1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在本教程中介绍TensorBoard的主要用法。尽早并经常学习使用TensorBoard将使TensorFlow的工作变得更加愉快和富有成效。</p><h1 id="0435" class="lk ll iq bd li lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1.可视化图表</h1><p id="648a" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">虽然功能强大，但张量流计算图可能会变得极其复杂。可视化图形可以帮助我们理解和调试它。这是一个来自TensorFlow网站的可视化工作的例子。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mm"><img src="../Images/af47a8893fcfa7e2b0d07b95b440494e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xGvVs5I3T2pmH6wE.gif"/></div></div></figure><p id="aa2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ko">图二。</em> </strong>张量流图可视化(来源:张量流网站)</p><p id="cd06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让我们的TensorFlow程序<strong class="jp ir">被TensorBoard激活</strong>，我们需要添加几行代码。这会将张量流操作导出到一个名为<strong class="jp ir">事件文件</strong>(或事件日志文件)的文件中。TensorBoard能够读取该文件，并给出模型图及其性能的一些见解。</p><p id="0b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们写一个简单的TensorFlow程序，用TensorBoard可视化它的计算图。</p><h2 id="7ab2" class="mn ll iq bd li mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">示例1:</h2><p id="f427" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">让我们创建两个常量并将它们相加。常数张量可以简单地用它们的值来定义:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="1259" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">5</strong></span></pre><p id="8cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用TensorBoard可视化程序，我们需要编写程序的日志文件。要编写事件文件，我们首先需要使用以下代码为这些日志创建一个<strong class="jp ir">编写器</strong>:</p><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="ebad" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">writer = tf.summary.FileWriter([logdir], [graph])</strong></span></pre><p id="d251" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<strong class="jp ir">【日志目录】</strong>是我们想要存储那些日志文件的文件夹。我们也可以选择[logdir]作为有意义的东西，比如。/graphs。第二个参数<strong class="jp ir">【图表】</strong>是我们正在编写的程序的图表。有两种方法可以得到图表:</p><ol class=""><li id="ef4f" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">使用<strong class="jp ir"> tf.get_default_graph() </strong>调用图形，返回程序的默认图形</li><li id="5bda" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">将其设置为<strong class="jp ir"> sess.graph </strong>，返回会话的图形(注意，这需要我们创建一个会话)。</li></ol><p id="facb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在下面的例子中看看这两种方法；然而，第二种方式更常见。无论哪种方式，都要确保仅在定义了图形之后才创建编写器。否则，在TensorBoard上可视化的图形将是不完整的。</p><p id="3186" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将作者添加到第一个示例中，并可视化图表。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="2fa8" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">5</strong></span></pre><p id="5174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们执行这段代码，TensorFlow会在您的当前目录(在您的Python代码文件旁边)中创建一个包含<strong class="jp ir">事件文件</strong>的目录。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ny"><img src="../Images/2a4e516176e0fcc72096f3bb2c641c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FdNRPaLRqQAElcOr.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li"> <em class="lj">图3。</em> </strong>创建了包含事件文件的目录</figcaption></figure><p id="1596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，为了可视化图形，我们需要进入终端并确保当前的工作目录与我们运行Python代码的目录相同。例如，这里我们可以使用以下命令切换到目录:</p><p id="d685" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">$ CD ~/桌面/tensorboard</p><p id="fdf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后运行:</p><p id="d2b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">$ tensor board-logdir = "。/graphs”—端口6006</p><p id="1648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">替换。/graphs '与目录的名称，以防您选择将其命名为其他名称。这将在命令行上生成一个链接。控制点击(ctrl+左键)链接以打开TensorBoard窗口，TensorBoard使用web浏览器向我们显示可视化效果(或者简单地将其复制到您的浏览器中，或者直接打开您的浏览器并转到<a class="ae nz" href="http://localhost:6006/" rel="noopener ugc nofollow" target="_blank"> http://localhost:6006/ </a>)。该链接会将我们引导到TensorBoard页面，它应该类似于:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oa"><img src="../Images/e235a3bee3884ed4fde980bd1e532765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dlyXef0-621A8IW2.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li">图4<em class="lj">。</em> </strong> TensorBoard页面可视化示例1中生成的图形</figcaption></figure><p id="8572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图中的图表向我们展示了模型的各个部分。图中的“Const”和“Const_1”对应a和b，节点“Add”对应c，代码中给出的名称(a、b、c)只是<strong class="jp ir"> Python-names </strong>，它们只是在编写代码时帮助我们进行访问。这些名称对TensorFlow和TensorBoard没有任何意义。为了让TensorBoard理解我们的操作的名称，我们必须明确地命名它们。</p><p id="ec27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再修改一次代码来添加名字:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="dc56" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">5</strong></span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ob"><img src="../Images/3af29dfa3c7690b5513f3907dcc3507d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L-3EHi0cRmPEPcmb.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li">图五<em class="lj">。</em> </strong> TensorBoard页面，可视化示例1中生成的带有修改名称的图形</figcaption></figure><p id="9739" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">*注意:</strong>如果我们用同一个[logdir]多次运行我们的代码，那么在我们的[logdir]中将会生成多个事件文件。TF将只显示图形的最新版本，并显示多个事件文件的警告。可以通过删除我们不再需要的事件文件来删除警告，或者我们可以将它们保存在不同的[logdir]文件夹中。</p><h1 id="e3bc" class="lk ll iq bd li lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.写总结来形象化学习</h1><p id="4a0e" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">到目前为止，我们只关注如何在TensorBoard中可视化图形。还记得TensorBoard在文章前面提到的其他可视化类型吗(标量、图像和直方图)。在这一部分中，我们将使用一个称为<strong class="jp ir"> summary </strong>的特殊操作来可视化模型参数(如神经网络的权重和偏差)、度量(如损失或精度值)和图像(如网络的输入图像)。</p><p id="3354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Summary </strong>是一个特殊的操作TensorBoard，它接受一个常规张量并将汇总的数据输出到你的磁盘(即在事件文件中)。基本上，有三种主要类型的摘要:</p><p id="3205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。tf.summary.scalar: </strong>用于写入单个标量值张量(如分类损失或精度值)</p><p id="fdb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。tf.summary.histogram: </strong>用于绘制非标量张量所有值的直方图(可用于可视化神经网络的权重或偏差矩阵)</p><p id="c74a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。tf.summary.image: </strong>用于绘制图像(如网络的输入图像，或自动编码器或GAN生成的输出图像)</p><p id="0c0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的部分中，让我们更详细地看一下上面提到的每一种汇总类型。</p><h1 id="67e6" class="lk ll iq bd li lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.1.tf.summary.scalar:</h1><p id="2ab3" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">它是用来写一个随时间或迭代而变化的标量张量的值。对于神经网络(例如用于分类任务的简单网络)，它通常用于监控损失函数或分类精度的变化。</p><p id="3c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们运行一个简单的例子来理解这一点。</p><h2 id="593b" class="mn ll iq bd li mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">示例2:</h2><p id="1db0" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">从标准正态分布<em class="ko"> N(0，1) </em>中随机选取100个值，并一个接一个地绘制它们。</p><p id="f996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种方法是简单地创建一个变量，从正态分布(mean=0，std=1)初始化它，然后在会话中运行一个for循环，初始化100次。代码如下，代码中解释了编写摘要所需的步骤:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="3d5c" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">Done with writing the scalar summary</strong></span></pre><p id="f578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们拉起TensorBoard并检查结果。像以前一样，您需要打开终端并键入:</p><p id="da3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">$ tensor board-logdir = "。/graphs”—端口6006</p><p id="a618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此处<em class="ko">”。/graphs" </em>是我们保存事件文件的目录名。在TensorBoard中，我们发现一个名为<strong class="jp ir">“标量”</strong>的新选项卡，紧挨着前面讨论过的<strong class="jp ir">“图形”</strong>选项卡(比较图5和图6)。整个窗户看起来像:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oc"><img src="../Images/5ad4a3dca35e43b18ca5db6ab932133d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S5pJwtp09BsSmcek.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li"> <em class="lj">图六。</em> </strong> TensorBoard页面可视化书写的标量摘要。</figcaption></figure><p id="d68a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图中，绘图面板的名称为“My_first_scalar_summary ”,与我们在代码中定义的名称相同。x轴和y轴显示了100步和相应的值(来自标准法线距离的随机值。)的变量。</p><h1 id="cdeb" class="lk ll iq bd li lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.2.tf.summary .直方图:</h1><p id="e331" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">如果我们想观察一个值随时间或迭代的变化，直方图就派上了用场。它用于绘制非标量张量值的直方图。这为我们提供了张量值的直方图(和分布)如何随时间或迭代而变化的视图。在神经网络的情况下，它通常用于监控权重和偏置分布的变化。这对于检测网络参数的不规则行为非常有用(例如，当我们的权重异常爆炸或收缩时)。</p><p id="7db8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们回到前面的例子，并添加直方图总结。</p><h2 id="8cde" class="mn ll iq bd li mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">示例3:</h2><p id="a14b" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">继续前面的示例，添加一个大小为30x40的矩阵，其条目来自标准正态分布。将该矩阵初始化100次，并绘制其条目随时间的分布图。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="908e" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">Done writing the summaries</strong></span></pre><p id="e205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TensorBoard中，顶部菜单增加了两个新标签:“分布”和“直方图”。结果将如下所示:</p><p id="be38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TensorBoard中，顶部菜单增加了两个新标签:“分布”和“直方图”。结果将如下所示:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi od"><img src="../Images/35b0f0faecdfa54d961000f7f14ffb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b6KOARtYtp5GuLrR.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li">图7<em class="lj">。</em> </strong> (a)标量汇总，(100步内2D张量值的分布和直方图</figcaption></figure><p id="72f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图中,“Distributions”选项卡包含一个图，该图显示了张量值(y轴)到步长(x轴)的分布。你可能会问什么是浅色和深色？</p><p id="2c26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是图表上的每一条线代表数据分布中的一个百分点。例如，最下面的线(非常浅的那条)显示了最小值是如何随着时间变化的，中间的线显示了中值是如何变化的。从上到下阅读，各行有如下含义:[最大值，93%，84%，69%，50%，31%，16%，7%，最小值]</p><p id="50eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些百分位数也可以被视为正态分布的标准偏差边界:[最大值，μ+1.5σ，μ+σ，μ+0.5σ，μ，μ-0.5σ，μ-σ，μ-1.5σ，最小值]，因此从内向外读取的彩色区域分别具有宽度[σ，2σ，3σ]。</p><p id="fe52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，在直方图面板中，每个图表显示数据的时间“切片”，其中每个切片是给定步骤中张量的直方图。它的组织结构是最旧的时间步长在后面，最近的时间步长在前面。</p><p id="fefa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在任何步骤轻松监控直方图上的值。只需在图上移动光标，查看直方图上的x-y值(图8 (a))。您也可以将直方图模式从“偏移”更改为“叠加”(见图8- (b))，以查看相互叠加的直方图。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi od"><img src="../Images/c33dfc201193b531a9eb139a7a7f1625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uGPdO5b5M_I8_4lU.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li"> <em class="lj">图8。</em> </strong> (a)直方图上的监控值，(b)重叠直方图</figcaption></figure><p id="63a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如代码中提到的，我们需要运行每个摘要(例如<strong class="jp ir">sess . run(【scalar _ summary，histogram _ summary】)</strong>)，然后使用我们的writer将每个摘要写入磁盘。在实践中，我们可以使用任意数量的汇总来跟踪模型中的不同参数。这使得运行和编写摘要的效率非常低。解决方法是合并图表中的所有摘要，并在您的会话中立即运行它们。这可以用<strong class="jp ir"> tf.summary.merge_all() </strong>方法来完成。让我们将其添加到示例3中，代码更改如下:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="3513" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">Done writing the summaries</strong></span></pre><h1 id="1b0b" class="lk ll iq bd li lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2.2.tf.summary.image:</h1><p id="e834" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">顾名思义，这种类型的总结用于将张量写成图像并可视化。在神经网络的情况下，这通常用于跟踪输入到网络的图像(比如每一批)或输出中生成的图像(比如自动编码器中的重建图像；或者由生成性广告系列网络的生成器模型产生的假图像)。然而，一般来说，这可以用来绘制任何张量。例如，我们可以将大小为30x40的权重矩阵想象成30x40像素的图像。</p><p id="62d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用以下方式创建图像摘要:</p><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="9e93" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">tf.summary.image(name, tensor, max_outputs=3)</strong></span></pre><p id="1f6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<strong class="jp ir"> name </strong>是生成的节点(即操作)的名称，tensor是要作为图像摘要写入的所需张量(我们稍后将讨论其形状)，max_outputs是从<strong class="jp ir"> tensor </strong>生成图像的最大元素数。但是……这意味着什么呢？答案在于<strong class="jp ir">张量</strong>的形状。</p><p id="7412" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们提供给tf.summary.image的<strong class="jp ir">张量</strong>必须是形状为<strong class="jp ir">【batch_size，height，width，channels】</strong>的四维张量，其中batch _ size是批中图像的数量，高度和宽度决定图像的大小，最后，通道是:1:对于灰度图像。3:适用于RGB(即彩色)图像。4:对于RGBA图像(其中A代表α；参见<a class="ae nz" href="https://en.wikipedia.org/wiki/RGBA_color_space" rel="noopener ugc nofollow" target="_blank"> RGBA </a>。</p><p id="2673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个非常简单的例子来理解它的基本思想。</p><h2 id="209b" class="mn ll iq bd li mo mp dn lp mq mr dp lt jy ms mt lx kc mu mv mb kg mw mx mf my bi translated">示例4:</h2><p id="262f" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">让我们定义两个变量:</p><ol class=""><li id="b68a" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">大小为30x10的3个<strong class="jp ir">灰度</strong>图像大小为10x10</li><li id="2f22" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">尺寸为50x30的5张<strong class="jp ir">彩色</strong>图像尺寸为10x10</li></ol><p id="07fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并在TensorBoard中将它们绘制成图像。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mz na l"/></div></figure><pre class="kt ku kv kw gt nb nc nd ne aw nf bi"><span id="446c" class="mn ll iq nc b gy ng nh l ni nj"><strong class="nc ir">Done writing the summaries</strong></span></pre><p id="d329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在像以前一样打开TensorBoard，切换到<strong class="jp ir">图像</strong>选项卡。图像应该类似于:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi od"><img src="../Images/3b21797d166cff57ae37ef8103f441ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cLM7NmShUdFr4ILx.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><strong class="bd li"> <em class="lj">图9。</em> </strong>在张量板上生成图像</figcaption></figure><p id="11a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们同样可以将任何大小的任何其他图像添加到我们的摘要中，并在TensorBoard中绘制它们。</p><p id="6e6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读这篇几乎很长的教程。在下一个教程中，我将运行一个简单的神经网络，并使用TensorBoard可视化它的图形和性能。</p><p id="e076" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我在Medium上的第一篇文章。所以请不要犹豫，用你的掌声鼓励我，并通过在下面留下评论给我你的反馈。</p></div></div>    
</body>
</html>