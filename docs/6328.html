<html>
<head>
<title>Kotlin and FaaS, an impossible union?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林和FaaS，不可能的结合？</h1>
<blockquote>原文：<a href="https://itnext.io/kotlin-faas-impossible-union-12b0938e2db4?source=collection_archive---------9-----------------------#2021-10-17">https://itnext.io/kotlin-faas-impossible-union-12b0938e2db4?source=collection_archive---------9-----------------------#2021-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/552530d384857a028983fea01be9315c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yf39gfgBYSwz1iPS6aC32g.jpeg"/></div></div></figure><p id="c925" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前段时间，我看了一个帖子，描述了如何在<a class="ae kw" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>上运行一个无服务器的Kotlin函数。虽然内容在技术上是正确的，但我认为概念本身是非常错误的。这样的帖子可能会导致人们做出不明智的决定:“因为我们能”很难成为一个成功的策略。在这篇文章中，我想首先解释为什么JVM平台对FaaS来说是个坏主意。然后，我将继续提出使用Kotlin的替代方案。</p><p id="1d46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我故意选择不链接到最初的帖子，以避免给它任何可信度。如果你想看，谷歌是你的朋友。</p><h1 id="3a9a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">语义学</h1><p id="82e2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在做任何事情之前，我们应该首先解决FaaS和无服务器的语义。虽然这些术语有时会互换使用，但我将在本文中使用以下定义。在所有情况下，看看人们在维基百科上达成的共识总是值得的:</p><blockquote class="ma mb mc"><p id="d997" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq">无服务器计算是一种云计算执行模式，云提供商运行服务器，动态管理机器资源的分配。定价基于应用程序消耗的实际资源量，而不是预先购买的容量单位。</em></p><p id="ea56" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">【https://en.wikipedia.org/wiki/Serverless_computing】—<a class="ae kw" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a></p><p id="2651" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq">功能即服务(FaaS)是云计算服务的一个类别，它提供了一个平台，允许客户开发、运行和管理应用功能，而无需构建和维护通常与开发和启动应用相关的基础设施。</em></p><p id="3e33" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq">——</em><a class="ae kw" href="https://en.wikipedia.org/wiki/Function_as_a_service" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://en.wikipedia.org/wiki/Function_as_a_service</em></a></p></blockquote><p id="0322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据以上定义:</p><ul class=""><li id="2ed3" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">无服务器是关于资源的管理:<br/>你需要动态地处理它，属性是<strong class="ka ir">弹性</strong>。</li><li id="abd7" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">FaaS是关于代码的大小:<br/>大小的演变从一个成熟的应用程序到微服务再到<strong class="ka ir">一个功能</strong>。原帖提到了。</li></ul><p id="5a9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，FaaS意味着没有服务器。</p><h1 id="7b43" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JVM和FaaS</h1><p id="a68f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">JVM平台是一项优秀的技术。特别是，抽象层允许JVM将<em class="md">字节码</em>编译成适应工作负载的本机代码。这就是为什么即使C/C++编译的应用程序更接近裸机，JVM也能够在性能方面与其竞争——甚至获胜。</p><p id="6251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这种优化是有代价的:JVM需要时间预热，<em class="md">，例如，</em>，将类加载到内存中。这就是JVM上的性能测试需要几轮预热的原因。因此，JVM非常适合长时间运行的流程，与整个生命周期流程相比，启动时间可以忽略不计。应用服务器是这种用例的典型代表:一旦启动，就应该运行很长时间，比如说几天，非常保守。在这方面，一分钟的启动时间没有任何意义。</p><p id="171d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是FaaS:在JVM上下文中，FaaS意味着JVM启动，函数运行，然后一切都被丢弃。在这种情况下，启动时间对总的执行时间有很大的影响。此外，JVM没有时间将<em class="md">字节码</em>编译成本地代码:它保持“冷”状态。</p><p id="3867" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些人建议保持JVM运行，以便以后重用，从而避免支付启动时间的成本。实现这一点非常简单:只需比FaaS提供者丢弃底层JVM的速度更快地向函数发送请求。然而，它只是挫败了无服务器的目的，因为弹性属性现在已经不存在了。</p><p id="bd5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它适用于Kotlin、Java、Scala、Groovy、Clojure和其他所有运行在JVM之上的语言。尽管我喜欢科特林，但这是不可行的:任何人都不需要FaaS方法提供的弹性——或者更糟，没有线索。在大多数情况下，这类似于构建微服务架构:YAGNI。</p><h1 id="e275" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">两全其美</h1><p id="bae9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">然而，并非所有的希望都破灭了。有很多方法既能使用科特林，又能从FaaS中获益。既然FaaS的问题是JVM，为什么不删除它呢？有两种简单的方法可以实现这一点:</p><ul class=""><li id="7c59" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">使用Graal的本机映像:<br/> GraalVM是不同技术的组合。其中有<a class="ae kw" href="https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/README.md" rel="noopener ugc nofollow" target="_blank"> SubstrateVM </a>:它允许将一个JAR(或一个类)转换成本地可执行文件。然后，您可以将生成的应用程序包装到Docker容器中，该容器必须与您选择的FaaS框架兼容。这是这种方法的一个例子。</li><li id="ed39" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">Transpile to JavaScript: <br/>另一种方法是将Kotlin转换成JavaScript。JavaScript不需要JVM平台来运行。然后，代码可以如上所述包装到一个容器中，或者直接打包到一个ZIP存档中。后一种选择可以在专有基础设施上运行，比如AWS功能。</li></ul><p id="19d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两种方法都需要一个坚实的构建管道，从Kotlin开始，到Docker容器(或ZIP)结束。与最初的设计一样，他们既需要单元测试来测试代码是否正确，也需要集成测试来测试最终的工件是否如预期的那样工作。</p><h1 id="d877" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="38f0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">人们需要了解大多数技术的背景。你(可能)不需要微服务，FaaS，或任何炒作曲线现在的趋势。然而，通过理解它们的利弊，你将能够在适当的时候利用它们。</p><p id="1278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就目前而言，对FaaS使用JVM是不明智的。这并不意味着你不能使用Kotlin。</p><ul class=""><li id="f79e" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><a class="ae kw" href="https://thenatureofsoftware.se/posts/openfaas_graalvm_native/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS原生Kotlin函数</a></li><li id="f3d5" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><a class="ae kw" href="https://medium.com/@napperley/binary-as-a-function-a0d6490efb27" rel="noopener">二元函数</a></li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="a781" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">原载于</em> <a class="ae kw" href="https://blog.frankel.ch/kotlin-faas-impossible-union/" rel="noopener ugc nofollow" target="_blank"> <em class="md">一个Java极客</em></a><em class="md">2021年10月16日</em></p></div></div>    
</body>
</html>