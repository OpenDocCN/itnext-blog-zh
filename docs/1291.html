<html>
<head>
<title>SEO Friendly SPAs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SEO友好的温泉</h1>
<blockquote>原文：<a href="https://itnext.io/seo-friendly-spas-d3c461a56217?source=collection_archive---------0-----------------------#2018-08-31">https://itnext.io/seo-friendly-spas-d3c461a56217?source=collection_archive---------0-----------------------#2018-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa89c0e732c36be52e22df38e9d1a438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Lgji4Inkh1LaCLCtNHdJw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">SEO是为你的网站获得有机流量的关键。</figcaption></figure><p id="792e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">搜索引擎优化的增强对于增加营销网站、博客和其他应用的流量非常有用。但是越来越多的这些网站/应用程序是使用单页应用程序(spa)构建的，或者是完全在客户端浏览器中呈现的网站。</p><p id="4959" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">搜索引擎优化(SEO)是一门学科，专注于使网站在Google、Bing和Yahoo等搜索引擎的有机(非付费)搜索结果中出现得更高。它还发展到包括Twitter、脸书和Instagram等社交媒体。然而，SEO包含的不仅仅是制作搜索友好的URL和关键字，并将其添加到这些平台上。它包括一切，从你如何链接到你的网站，到网页上的文字本身，以及你在头部包含的元标签。事实上，整本书都是关于这个主题的，公司的存在只是为了帮助你进行SEO。记住这一点，大多数SEO特定的主题将不在这里讨论。相反，我将主要关注使用JavaScript在SPA中可以做的事情，以使您的网站更加SEO友好。Google &amp; Bing的网站管理员指南提供了一些关于SEO的简单建议。因此，在继续之前，请查看一下这些资源。</p><p id="97fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谷歌网站管理员指南:</p><p id="9d5b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://support.google.com/webmasters/answer/35769?hl=en" rel="noopener ugc nofollow" target="_blank">https://support.google.com/webmasters/answer/35769?hl=en</a></p><p id="afa5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Bing的网站管理员指南:</p><p id="90fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.bing.com/webmaster/help/webmaster-guidelines-30fba23a" rel="noopener ugc nofollow" target="_blank">https://www . bing . com/web master/help/web master-guidelines-30 FBA 23 a</a></p><h2 id="f94e" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">单页应用和搜索引擎优化</h2><p id="80c4" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">spa和传统网站不一样。在互联网的早期，网站只是一个由大学、政府机构或企业的计算机提供的HTML文件。它们很容易搜索，因为所有内容都直接嵌入在文件中，就像在文字处理器中阅读文档一样。它有一个清晰的层次结构，也很像一个文档。网站使用的文档对象模型(DOM)甚至反映了这一点。例如，<code class="fe lz ma mb mc b">&lt;h1&gt;</code>到<code class="fe lz ma mb mc b">&lt;h6&gt;</code>标签是标题，用于文档的开始部分。一个<code class="fe lz ma mb mc b">&lt;p&gt;</code>标签是一个段落，通常在一个<code class="fe lz ma mb mc b">&lt;section&gt;</code>内有多个包含内容的段落。一个<code class="fe lz ma mb mc b">&lt;table&gt;</code>用于表格数据。如果你需要更多关于HTML本身的信息，请阅读MDN的<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML" rel="noopener ugc nofollow" target="_blank">HTML简介</a>。关于DOM如何使用JavaScript与它交互的更多信息，请阅读MDN的对DOM的介绍。</p><p id="a12d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">服务器端呈现是后来添加的，作为在提供给客户端之前将内容加载到页面中的一种方式。这使得人们可以写博客和新闻网站，并最终开始创建应用程序来满足各种业务需求。随着应用程序变得越来越复杂，人们不得不开始使用HTML来表达不太像文档的东西。这就产生了对SEO的需求，以便让搜索引擎在这些网站和应用程序中找到内容。</p><p id="8690" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，随着JavaScript框架变得越来越流行，网站发生了更大的变化。无限滚动、通过Ajax和其他XHR库加载HTML后异步加载数据，以及客户端呈现DOM元素等功能使得搜索引擎很难抓取页面。SPAs甚至可以更新整个页面，而无需向服务器发出另一个请求，甚至无需更改URL。</p><p id="fd14" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在水疗已经很普遍，搜索引擎知道如何消费它们。谷歌创建了Angular.js，微软采用了它，脸书也用React.js做了同样的事情。他们还重新设计了他们的搜索功能，以便能够完全加载和抓取水疗中心。但这并不意味着你可以简单地建立一个并让它出现在搜索引擎中。无需深入了解SEO如何工作的基础知识，这里有一些事情你可以做，以确保你的SPA将与搜索引擎一起工作。</p><h2 id="8c92" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">漂亮的网址</h2><p id="b8d1" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">许多客户端框架使用散列(包含<code class="fe lz ma mb mc b">#</code>的URL，如<code class="fe lz ma mb mc b">http(s)://www.example.com/#about</code>)和散列值(<code class="fe lz ma mb mc b">http(s)://www.example.com/#!key=value</code>)来处理它们的路由。在功能上，SPA的行为方式与普通网站相同。使用JavaScript路由器或其他方式，URL会发生变化，内容也会更新。即使你可能认为抓取你的网站的机器人可能不在乎你是否使用散列，使用你的网站的用户将会看到一个看起来更干净更友好的URL。</p><p id="cde9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，一些爬行器，如Google的，将带有hashbangs <code class="fe lz ma mb mc b">#!</code>的URL解释为一个指示器，指示存在一个替代的传统URL，在加载时提供相同的页面状态。出于这个原因，建议通过使用像PushState这样的技术，只使用哈希<code class="fe lz ma mb mc b">http(s)://www.example.com/#/pagename</code>或HTML5风格的无哈希路由，如<code class="fe lz ma mb mc b">http(s)://www.example.com/pagename</code>。PushState是一种通过JavaScript改变浏览器中显示的URL而无需重新加载页面的方式。它这样改变历史对象:<code class="fe lz ma mb mc b">window.history.pushState(data, "Page Title", "/new-url")</code>。你最终得到一个漂亮的网址。</p><p id="17ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一个常用的URL技巧是查询字符串。将查询字符串用于类别、搜索词和其他参数是完全可以接受的。它可以与上面提到的任何URL操作技术结合使用。搜索引擎可以区分出<code class="fe lz ma mb mc b">http(s)://www.example.com/?category=people</code>和<code class="fe lz ma mb mc b">http(s)://www.example.com/?category=cars</code>，尤其是如果每个URL都被定义并鼓励在你的站点地图中被索引。</p><h2 id="9aa2" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">网站地图</h2><p id="6918" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">搜索引擎使用网站地图来更好地理解你的网站内容。你可能并不总是需要一个。例如，如果你的网站很小，并且链接良好。然而，如果你的网站很大或者链接很差，很有可能网络爬虫会忽略新的或者最近更新的页面。</p><p id="e3f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如果你的网站有一个很大的内容页面的档案，这些内容页面是孤立的或者相互之间没有很好的链接，那么网站地图可能是一个很好的策略。例如，如果您的站点页面不通过链接自然地相互引用，您可以在站点地图中列出它们，以确保网络爬虫不会忽略这些页面。此外，如果您的网站是新的，很少有外部链接，网络爬虫可能找不到它。或者如果您使用元数据，如视频或图像内容。爬网程序通常会从一个页面跟踪到另一个页面，如果没有其他网站链接到您的页面或内容，可能无法发现它们。在这种情况下，网站地图是有益的。</p><p id="6212" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要让一个机器人使用你的站点地图，你必须创建并托管一个名为<code class="fe lz ma mb mc b">sitemap.xml</code>的文件。这里不讨论sitemap.xml的内容和结构。在<a class="ae la" href="https://www.xml-sitemaps.com/" rel="noopener ugc nofollow" target="_blank">了解更多关于站点地图-搜索控制台帮助</a>的信息。</p><p id="205c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您的站点是静态托管的，您可以简单地将sitemap.xml放在根级别。如果您使用的是Express之类的服务器端框架，您可以通过这种方式托管文件:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="6691" class="lb lc iq mc b gy ml mm l mn mo">app.get('/sitemap.xml', (req, res, next) =&gt; {<br/>    res.sendFile('public/sitemap.xml')<br/>})</span></pre><p id="28c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据您的框架，还有其他方法来托管文件。例如，使用Express，你可以使用<code class="fe lz ma mb mc b">express.static</code>提供<code class="fe lz ma mb mc b">public</code>文件夹中的所有内容。更多信息参见<a class="ae la" href="https://expressjs.com/en/starter/static-files.html" rel="noopener ugc nofollow" target="_blank">在Express </a>中提供静态文件。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f73c" class="lb lc iq mc b gy ml mm l mn mo">app.use(express.static(__dirname + '/public'))</span></pre><p id="58b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了告诉机器人你的站点地图文件，你需要在一个名为<code class="fe lz ma mb mc b">robots.txt</code>的文件中引用它:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="cb9f" class="lb lc iq mc b gy ml mm l mn mo">// robots.txt<br/>Sitemap: /sitemap.xml</span></pre><p id="fa86" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">确保您也在根位置或者在像Express这样的框架中提供这个文件:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="d4c7" class="lb lc iq mc b gy ml mm l mn mo">app.get('/robots.txt, (req, res, next) =&gt; {<br/>    res.sendFile('public/robots.txt')<br/>})</span></pre><p id="9e35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，如果你正在使用<code class="fe lz ma mb mc b">express.static</code>，只要把它放在你的<code class="fe lz ma mb mc b">/public</code>文件夹中。有很多方法可以做到这一点，这取决于服务器(Apache，Nginx，Express等。).</p><p id="9664" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">僵尸工具会一直查看这个文件的根URL。确保在<code class="fe lz ma mb mc b">http(s)://www.example.com/robots.txt</code>供应。</p><p id="96d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，还有一些工具可以为您动态呈现您的站点地图。Node的一个流行选择是NPM包<a class="ae la" href="https://www.npmjs.com/package/sitemap" rel="noopener ugc nofollow" target="_blank">站点地图</a>。</p><h1 id="336b" class="mp lc iq bd ld mq mr ms lg mt mu mv lj mw mx my lm mz na nb lp nc nd ne ls nf bi translated">贮藏</h1><p id="cefd" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">另一个提高搜索引擎优化的简单方法是加快页面加载速度。现代的网络爬虫关心加载时间，并且将具有相似内容的较快的页面优先于较慢的页面。由于JavaScript框架在页面和所有资源下载完成后才呈现(有时甚至等待Ajax/XHR调用完成)，因此它们通常比预先呈现的服务器端页面要慢。我推荐使用谷歌的PageSpeed Insights来测试你的页面。</p><p id="16bb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">加快页面加载速度的一种方法是缓存内容，尤其是当内容不经常变化时。这在Express中很容易处理。</p><p id="fd30" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你把你的文件存放在一个静态文件夹中，你可以简单地使用Express.static:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4a49" class="lb lc iq mc b gy ml mm l mn mo">const cacheTime = 86400000*10 // 10 days</span><span id="a518" class="lb lc iq mc b gy ng mm l mn mo">app.use(express.static(__dirname + '/public', { maxAge: cacheTime }))</span></pre><p id="b5d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，如果您正在使用<code class="fe lz ma mb mc b">sendFile</code>，您可以在那里设置缓存:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="fb0b" class="lb lc iq mc b gy ml mm l mn mo">app.get('/robots.txt, { maxAge: cacheTime }, (req, res) =&gt; {<br/>    res.sendFile('public/robots.txt')<br/>})</span></pre><p id="a857" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您将文件托管在CDN上，您将需要在那里配置缓存规则。纯静态页面推荐这样，可以试试亚马逊CloudFront，CloudFlare或者其他cdn。但是，如果您正在使用Node，这可能是一个非常简单且可伸缩的解决方案。我建议在<a class="ae la" href="https://expressjs.com/en/api.html" rel="noopener ugc nofollow" target="_blank">Express 4 . x——API参考</a>查看更多规则。</p><p id="47d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，使用gzip或deflate来压缩你的内容可以大大加快速度。在express中，这很容易通过使用<code class="fe lz ma mb mc b">compression</code>来实现。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="2045" class="lb lc iq mc b gy ml mm l mn mo">$ npm install compression</span><span id="5969" class="lb lc iq mc b gy ng mm l mn mo">const compression = require('compression')<br/>const express = require('express')</span><span id="c5b0" class="lb lc iq mc b gy ng mm l mn mo">const app = express()</span><span id="c3df" class="lb lc iq mc b gy ng mm l mn mo">// compress all responses<br/>app.use(compression())</span><span id="379a" class="lb lc iq mc b gy ng mm l mn mo">// add all routes</span></pre><p id="ff31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">参见<a class="ae la" href="https://github.com/expressjs/compression" rel="noopener ugc nofollow" target="_blank">文档</a>进行配置。</p><h2 id="fbf6" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">预渲染</h2><p id="e153" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">有一些工具可以在将页面发送给客户端之前对其进行预渲染。这也加快了加载速度，提高了你的搜索引擎优化和整体用户体验。使用这种方法，您可以在部署应用程序之前运行应用程序，捕获页面输出并用捕获的输出替换您的HTML文件。通常，这是通过诸如PhantomJS之类的无头浏览器(没有图形用户界面的web浏览器)来实现的。</p><p id="7aee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">预渲染是一个很好的选择，因为没有额外的服务器负载，因此比服务器端渲染更快更便宜。这也是一个更简单的产品设置，并允许您编写更简单的应用程序代码(不需要同构代码)。因此，它不容易出错，可以更容易地缓存更长时间。此外，它不需要Node.js生产服务器。</p><p id="e5f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">预渲染并不总是一个好的选择。例如，对于显示不断变化的数据(这些数据必须在加载时动态加载)的页面，或者对于具有特定于用户的内容的页面，它就不太适用。通常，满足这些要求的页面对于预渲染来说不太重要。只有您希望快速提供的常用页面才应该预先呈现。否则，服务器端呈现(SSR)可能是更好的选择。(有关SSR的更多信息，请参见下一节。)</p><p id="4830" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个如何使用Webpack的<code class="fe lz ma mb mc b">prerender-spa-plugin</code>预渲染应用程序的例子。一个常用的JS bundler，它有许多其他使用插件的功能。根据您的需要，您可以找到许多与其他语言、bundlers或框架兼容的其他工具。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4682" class="lb lc iq mc b gy ml mm l mn mo">$ npm install --save-dev prerender-spa-plugin</span></pre><p id="72c6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">预渲染插件创建一个PhantomJS实例并运行应用程序。然后，它拍摄DOM的快照，并将快照输出到Webpack构建文件夹中的HTML文件。它为每条路线重复这一过程，所以如果你有许多页面，构建应用程序可能需要相当长的时间。</p><p id="286a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个使用预渲染插件的简单Webpack配置的简单示例。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1acc" class="lb lc iq mc b gy ml mm l mn mo">// webpack.conf.js <br/>const path = require('path')<br/>const PrerenderSpaPlugin = require('prerender-spa-plugin')<br/> <br/>module.exports = {<br/>  // ... <br/>  plugins: [<br/>    new PrerenderSpaPlugin(<br/>      // Absolute path to compiled SPA <br/>      path.join(__dirname, './public'),<br/>      // List of routes to prerender <br/>      [ '/', '/about', '/contact' ]<br/>    )<br/>  ]<br/>}</span></pre><p id="46f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个例子中，创建了一个pre-render插件的新实例，您让它知道输出到哪个文件夹，以及在生成HTML文件时您希望PhantomJS浏览器访问的路径列表。这是设置插件时仅有的两个必需选项。你也可以选择传递一个更高级的配置给插件。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="b0ac" class="lb lc iq mc b gy ml mm l mn mo">// webpack.conf.js <br/>const path = require('path')<br/>const PrerenderSpaPlugin = require('prerender-spa-plugin')<br/> <br/>module.exports = {<br/> <br/>  // ... <br/> <br/>  plugins: [<br/>    new PrerenderSpaPlugin(<br/>      // Absolute path to compiled SPA <br/>      path.join(__dirname, './public'),<br/>      // List of routes to prerender <br/>      [ '/', '/about', '/contact' ],<br/>      // (OPTIONAL)<br/>      {<br/>          // options go here<br/>      }<br/>    )<br/>  ]<br/>}</span></pre><p id="a24a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除非您依赖异步呈现的内容，比如在Ajax/XHR请求之后，否则这些选项都不是必需的。在捕获页面内容之前，已经执行了所有同步脚本。以下每个选项都是可选<code class="fe lz ma mb mc b">options</code>对象的一部分。</p><p id="5c07" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您想等到页面中触发特定的JavaScript事件:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1447" class="lb lc iq mc b gy ml mm l mn mo">captureAfterDocumentEvent: 'custom-post-render-event'</span></pre><p id="62af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后在您的JavaScript文件中分派一个事件:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="9199" class="lb lc iq mc b gy ml mm l mn mo">document.dispatchEvent(new Event('custom-post-render-event'))</span></pre><p id="545f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以等待，直到用document.querySelector检测到特定的HTML元素。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a85f" class="lb lc iq mc b gy ml mm l mn mo">captureAfterElementExists: '#content'</span></pre><p id="2414" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">或者，您也可以等到脚本执行完毕几毫秒后再执行。需要注意的是，当依赖于网络通信或其他具有高度可变定时的操作时，这可能会产生不可靠的结果。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="73a1" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>captureAfterTime: 5000</span></pre><p id="36f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你喜欢，你甚至可以组合策略。例如，如果您有时只想等待一个事件触发，您可以通过组合使用<code class="fe lz ma mb mc b">captureAfterTime</code>和<code class="fe lz ma mb mc b">captureAfterDocumentEvent</code>来创建一个超时。当组合策略时，页面内容将在第一个触发的策略之后被捕获。</p><p id="2f2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以简单地忽略JavaScript错误，而不是大声疾呼失败(默认)。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="48bc" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>ignoreJSErrors: true</span></pre><p id="eb0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要更改索引文件的路径，而不是静态根目录中的默认index.html:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="c1ad" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>indexPath: path.resolve('/public/path/to/index.html')</span></pre><p id="faac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为PhantomJS偶尔会遇到间歇性问题，所以默认情况下，插件会自动重试10次页面捕获。如果你愿意，你可以提高或降低这个限制。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3ed4" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>maxAttempts: 10</span></pre><p id="3722" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您必须防止幻像从传递给它的URL导航出去，并防止加载嵌入的iframes(例如Disqus和Soundcloud embeds)，这对SEO来说并不理想，可能会引入JavaScript错误。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="bafb" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>navigationLocked: true</span></pre><p id="2c68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的选项公开了幻像的配置选项，在极少数情况下，您需要为特定系统或应用程序进行特殊设置。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="705c" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>// http://phantomjs.org/api/command-line.html#command-line-options <br/>phantomOptions: '--disk-cache=true',</span><span id="0cd3" class="lb lc iq mc b gy ng mm l mn mo">// http://phantomjs.org/api/webpage/property/settings.html <br/>phantomPageSettings: {<br/>  loadImages: true<br/>},</span><span id="b516" class="lb lc iq mc b gy ng mm l mn mo">// http://phantomjs.org/api/webpage/property/viewport-size.html <br/>phantomPageViewportSize: {<br/>  width: 1280,<br/>  height: 800<br/>}</span></pre><p id="2f76" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以在预渲染后手动转换每个页面的HTML，例如，在无法通过路由解决方案处理的边缘情况下设置页面标题和元数据。</p><p id="b5ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该函数的上下文参数包含两个属性:</p><ul class=""><li id="8526" class="nh ni iq ke b kf kg kj kk kn nj kr nk kv nl kz nm nn no np bi translated"><code class="fe lz ma mb mc b">html</code> -预渲染后得到的HTML</li><li id="04be" class="nh ni iq ke b kf nq kj nr kn ns kr nt kv nu kz nm nn no np bi translated"><code class="fe lz ma mb mc b">route</code> -当前正在处理的路线(例如“/”、“关于”或“/联系”)</li></ul><p id="f295" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论返回什么，都将打印到预渲染文件中。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3a53" class="lb lc iq mc b gy ml mm l mn mo">lang: javascript<br/>postProcessHtml: context =&gt; {<br/>    const titles = {<br/>        '/': 'Home',<br/>        '/about': 'Our Story',<br/>         '/contact': 'Contact Us'<br/>     }<br/>     return context.html.replace(<br/>         /&lt;title&gt;[^&lt;]*&lt;\/title&gt;/i,<br/>         '&lt;title&gt;' + titles[context.route] + '&lt;/title&gt;'<br/>     )<br/>}</span></pre><p id="7993" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用这个插件将允许你使用你所使用的JS库创建简单的HTML页面。例如，React、Vue、Angular、Riot或任何其他，它们可以使用Express或您喜欢的任何服务器托管在您的服务器上的目录中。</p><p id="2586" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，预渲染插件仅适用于使用HTML5历史API (PushState)的路由策略。没有散列(bang)URL将使用这种方法。所以确保你设置了你的JS路由器来使用像<code class="fe lz ma mb mc b">http(s)://www.example.com/contact</code>这样的URL。此外，当DOM准备好的时候，您应该总是加载您的SPA，方法是将您的标签放在DOM事件<code class="fe lz ma mb mc b">DOMContentLoaded</code>中。</p><p id="a1ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是请记住，如果您计划运行动态变化的页面，这些页面是数据密集型的，并且根据数据不断变化，那么这不是一个好的选择。例如，如果您想要基于用户信息动态生成数据。相反，服务器端呈现对于这样的站点来说是一个更可行的选择。</p><h2 id="86ab" class="lb lc iq bd ld le lf dn lg lh li dp lj kn lk ll lm kr ln lo lp kv lq lr ls lt bi translated">服务器端渲染</h2><p id="b62f" class="pw-post-body-paragraph kc kd iq ke b kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ly kx ky kz ij bi translated">上述方法最适合用于只需渲染一次而非动态的应用程序。例如，营销网站、产品主页或销售应用程序。</p><p id="050c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有关使用JavaScript框架进行服务器端渲染的更多信息，请查看<a class="ae la" href="https://reactjs.org/docs/react-dom-server.html" rel="noopener ugc nofollow" target="_blank"> ReactDomServer </a>和<a class="ae la" href="https://vuejs.org/v2/guide/ssr.html" rel="noopener ugc nofollow" target="_blank"> Vue服务器端渲染</a>。此外，现在大多数其他JS框架都有SSR解决方案。比如我最喜欢的两个SSR框架是<a class="ae la" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> NextJS </a>和<a class="ae la" href="https://www.gatsbyjs.org/" rel="noopener ugc nofollow" target="_blank"> GatsbyJS </a>。此外，为Express 使用SSR <a class="ae la" href="https://expressjs.com/en/guide/using-template-engines.html" rel="noopener ugc nofollow" target="_blank">模板引擎总是有效的，这也是我们为Aurelius </a>主页所做的。我们目前使用的是快速的<a class="ae la" href="https://markojs.com/docs/express/" rel="noopener ugc nofollow" target="_blank"> MarkoJS，它易于使用并且速度非常快。</a></p><p id="56ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请随时发表评论，让我知道你对这个水疗SEO指南的看法。如果有任何你想看到的补充或问题，请告诉我，我会尽力帮助你。如果我得到足够的反馈，我可能会专门跟进SSR。</p></div></div>    
</body>
</html>