<html>
<head>
<title>Implement NodeJS environment variables in a modern Webpack app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在现代Webpack应用程序中实现NodeJS环境变量</h1>
<blockquote>原文：<a href="https://itnext.io/implement-nodejs-environment-variables-in-a-modern-webpack-app-df20c27fe5f0?source=collection_archive---------1-----------------------#2018-03-08">https://itnext.io/implement-nodejs-environment-variables-in-a-modern-webpack-app-df20c27fe5f0?source=collection_archive---------1-----------------------#2018-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e122dadfc783932f47e7006b741a4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeVFYc1lgQXUNaxYe962-Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">斯蒂芬·昆泽在<a class="ae kc" href="https://unsplash.com/search/photos/greece?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9bca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开始构建一个现代的web应用程序时，我们通常并不关心伸缩性。这包括所有不同的环境，我们将在未来安装这个应用程序。我们想把事情做完，然后开始玩我们的代码库。</p><p id="6d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可能从最基本的开始，即区分我们的应用程序在三个主要环境中的设置:</p><ol class=""><li id="dc3e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">开发:我们开发新功能的地方</li><li id="04e1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">生产:当我们构建一个包，并把它放在一个生产服务器上，这样我们的客户就可以玩我们的酷应用程序了</li><li id="3216" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">测试:我们在本地或者在持续集成系统中运行单元测试</li></ol><p id="a158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道你们中的一些人可能会想，现在开始制作是否为时过早。老实说，不是，因为你可能需要从一开始就设置一个临时服务器，这样其他团队成员就可以跟踪你的进度，并定期检查这个全新项目的真实情况。这就是应用了大量优化的类似产品的捆绑包需要使用的地方，对吗？</p><p id="b221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，显然我们将使用Webpack来组织我们的代码库，并建立这3个主要的环境设置。我的典型webpack设置为每个环境提供了一个专用的配置文件，使用一个不言自明的名称，如webpack.development.config.js等。</p><p id="a94a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免重复我自己，我喜欢先创建一个webpack.base.config.js文件，以便在那里放置一些通用设置。然后我通过使用<a class="ae kc" href="https://www.npmjs.com/package/webpack-merge" rel="noopener ugc nofollow" target="_blank"> webpack-merge </a>包来扩展它。所有这些配置文件都放在名为webpack的app文件夹旁边的一个单独的文件夹中。多独特对吗？</p><p id="ac3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，让我们看看ReactJS应用程序的简单webpack.base.config.js到底是什么样子的:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="dfe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…我是这样在我的webpack.development.config.js中扩展它的:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="131e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经准备好了一些基本的东西，让我们创建npm脚本并在那里实现我们的webpack配置文件:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="fcae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上都是很基本的东西。我们有一个脚本在开发环境中引导我们的webpack-dev-server，另一个脚本为生产环境构建我们的包，最后一个脚本用Jest运行一些单元测试。设置Jest超出了本文的范围，但这是引导Jest并运行单元测试套件的典型脚本。</p><p id="d9da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们已经取得了很大的进步，但是我们实际上还没有传递任何关于每个脚本运行环境的变量。计划很简单。为了保持整洁，我们将在编译时通过<code class="fe lv lw lx ly b"><a class="ae kc" href="https://webpack.js.org/plugins/define-plugin/" rel="noopener ugc nofollow" target="_blank">webpack.DefinePlugin</a></code>在webpack.base.config.js文件中定义环境变量，其余的配置文件将继承它们，因为它们扩展了这个基本配置文件。但是我们如何为每个npm脚本传递不同的变量呢？</p><p id="15c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的方法是使用一个名为<a class="ae kc" href="https://www.npmjs.com/package/cross-env" rel="noopener ugc nofollow" target="_blank"> cross-env </a>的超级漂亮的包(它使我们避免了由Windows操作系统引起的潜在问题)，并在运行每个脚本之前声明我们需要的环境变量。</p><p id="f98a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们需要指定的第一个也是最重要的变量是什么呢？你完全正确，是时候在每个脚本运行之前声明<code class="fe lv lw lx ly b">NODE_ENV</code>了:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="4b97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们做到了，但是webpack知道了吗？嗯，不。记住我们上面说的。我们需要修复我们的webpack.base.config.js并利用DefinePlugin:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="9ccd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，webpack确切地知道我们在每种情况下所处的环境，并使用<code class="fe lv lw lx ly b">NODE_ENV</code>,尤其是在生产构建中，来优化我们的捆绑包。</p><p id="985a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NodeJS中的<a class="ae kc" href="https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env" rel="noopener ugc nofollow" target="_blank"> process.env </a>是一个对象，包含关于用户环境的非常有用的信息。因此，正如您看到的，cross-env为每个案例传递了正确的<code class="fe lv lw lx ly b">NODE_ENV</code>值，webpack从中读取该值。如果你想知道我们为什么需要<code class="fe lv lw lx ly b">JSON.stringify()</code>的原因是webpack在那里直接进行文本替换，所以我们需要传递一个带引号的文本值，如果你像我一样感到懒惰，那么<code class="fe lv lw lx ly b">JSON.stringify()</code>可以很好地完成这项工作:-)</p><p id="5ba2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们已经通过cross-env将<code class="fe lv lw lx ly b">NODE_ENV</code>传递给了我们的脚本，我们可以让它们更短一些。仔细想想，我们并不真的需要配置文件的全名。我们可以在webpack文件夹中创建一个index.js文件，这样做:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="1828" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…并相应地更改我们的npm脚本:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="0c37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们直接从<code class="fe lv lw lx ly b">./webpack</code>文件夹中请求一个配置文件，而不是每次都声明完整路径。</p><p id="49f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，我们设法让这一切变得非常动态，现在我们可以专注于真正的开发了。</p><p id="b7c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个月过去了，我们开始有一些基于客户环境等的额外要求。这个应用程序将被安装在一对夫妇的客户内部网，这些都有一些专门的需求。每个安装将使用一个API，每个客户端使用不同的IP。嗯，我们需要在编译时在我们的webpack包中传递这个IP。但是我们如何做到这一点呢？嗯，是时候在我们的代码库中使用更多的环境变量了，所以<code class="fe lv lw lx ly b">.env</code>文件开始讨论了。</p><p id="2513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lv lw lx ly b">.env</code>是一个文件，我们在其中声明了一些特定于环境的键值对设置，比如so <code class="fe lv lw lx ly b">KEY=VALUE</code>。git系统绝对应该忽略这个文件，以避免不必要的覆盖。</p><p id="5283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个用API解决这个问题的例子:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="4553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个环境中使用一个特定的<code class="fe lv lw lx ly b">API_URL</code>来安装我们的应用程序是非常常见的，而<code class="fe lv lw lx ly b">.env</code>是放置这种设置的合适地方。</p><p id="8cee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们创建了我们的<code class="fe lv lw lx ly b">.env</code>文件，现在是时候找到一种方法来读取它的内容并将其传递给webpack。为了实现这一点，我们将使用一个名为<a class="ae kc" href="https://www.npmjs.com/package/env-cmd" rel="noopener ugc nofollow" target="_blank"> env-cmd </a>的非常酷的包，与我们使用cross-env的方式类似。让我们相应地更新我们的package.json，看看情况如何:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="18b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…然后更新webpack.base.config.js:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="834a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷。现在我们可以在典型的<a class="ae kc" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>设置中使用这个特定于环境的<code class="fe lv lw lx ly b">API_URL</code>变量，如下所示:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="4630" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。只要我们每次相应地更新webpack.base.config.js，我们就可以添加任意多的特定于环境的变量。</p><p id="f4b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于测试环境，我们通过使用webpack.development.config.js使事情变得非常简单。如果您真的需要，可以随意创建一个专用的配置文件来满足您的需要。如你所见，这种模式是可扩展的。干杯！！</p></div></div>    
</body>
</html>