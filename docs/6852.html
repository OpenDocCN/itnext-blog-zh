<html>
<head>
<title>Benchmarking to the Bottom — Iterating Lists in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">底部基准测试——迭代列表。网</h1>
<blockquote>原文：<a href="https://itnext.io/benchmarking-your-way-to-the-bottom-iterating-lists-7ab4e6d2dbf6?source=collection_archive---------3-----------------------#2022-03-21">https://itnext.io/benchmarking-your-way-to-the-bottom-iterating-lists-7ab4e6d2dbf6?source=collection_archive---------3-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c67" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">中访问列表值时找到迭代列表的最快方法。NET使用<a class="ae kf" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank">BenchmarkDotNet</a>验证大规模性能。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/61fad17c4f925a99c0c40e8a7d584b98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGPokFhrLsYa_k66iYxMiA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">BenchmarkDotNet —一个强大的。用于基准测试的. NET库</figcaption></figure><p id="9e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近花了一些时间查看一个旧系统，想知道如何让它性能更好。有许多方法可以使这样的系统更快、性能更好，但是我想避免大规模的重构，以将风险降到最低。具体来说，我关注的是那些可以累积起来产生更大影响的小项目。最明显的是整个系统的升级，但当这不是一个选项时，这些小变化可能是一个工程师必须做出的改变。</p><p id="67ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做这项工作已经激发了我的兴趣，首先，我想知道哪种方式是做这些日常小事的最佳方式。我正在慢慢构建一个小的任务系列。它可能会消耗不同的库来完成一个任务，或者直接比较每天的任务。无论哪种方式，都可以学到教训，获得乐趣。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="306f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">迭代和访问列表</h1><p id="4760" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">今天我决定看看你可以迭代一个<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1" rel="noopener ugc nofollow" target="_blank">列表</a>的许多不同方法。我一直在做的应用程序有许多长列表的实例，这些长列表由于各种原因而被迭代。这让我想知道如何最快地完成<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1" rel="noopener ugc nofollow" target="_blank">列表</a>中的所有项目。</p><p id="9639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我第一次运行时，我忽略了将被迭代的项赋给一个变量。单纯地迭代<a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1" rel="noopener ugc nofollow" target="_blank">列表</a>而不访问条目会导致错误的结果。<strong class="ky ir">两组结果</strong>都将在结果中列出。</p><p id="c1e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是通过<a class="ae kf" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>使用和测试的方法。</p><ul class=""><li id="e3bb" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement" rel="noopener ugc nofollow" target="_blank">为</a></li><li id="81c0" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement" rel="noopener ugc nofollow" target="_blank"> ForEach </a></li><li id="abe5" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.foreach" rel="noopener ugc nofollow" target="_blank"> LINQ ForEach </a></li><li id="7e1e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.getenumerator" rel="noopener ugc nofollow" target="_blank">获取枚举器</a></li><li id="b1fe" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1" rel="noopener ugc nofollow" target="_blank">跨度为</a></li><li id="3717" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1" rel="noopener ugc nofollow" target="_blank"> Span ForEach </a></li></ul><h1 id="cc85" class="lz ma iq bd mb mc nk me mf mg nl mi mj jw nm jx ml jz nn ka mn kc no kd mp mq bi translated">理论</h1><p id="18d4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我最近读到过<code class="fe np nq nr ns b">for</code>循环实际上比<code class="fe np nq nr ns b">foreach</code>循环要快。我预计我会发现在<code class="fe np nq nr ns b">List</code>上表现会稍微好一点。为了涵盖遍历列表的多种不同方式，我已经将LINQ和<code class="fe np nq nr ns b">for</code>作为其他选项。我预计LINQ会稍微慢一点，我以前从未用过<code class="fe np nq nr ns b">Span</code>，所以我不知道会发生什么。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0d37" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置</h1><p id="bf1d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用<a class="ae kf" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>创建一个控制台应用程序使得运行这个基准测试变得非常简单。为了确保涵盖旧系统，这些测试将在两个<strong class="ky ir">中运行。NET Framework 4.8 </strong>和<strong class="ky ir">。NET 6.0 </strong>因为这是当前对. NET的长期支持版本。一个用于旧世界，一个用于新世界。</p><p id="4226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前提很简单。创建一个100和10，000深的字符串<code class="fe np nq nr ns b">List</code>。然后运行测试来迭代每一项，并重复这样做，直到<a class="ae kf" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>乐意给我们一个结果。这应该给我们一个合理的假设，最快的方式去做这件事。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">迭代列表的设置方法</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a7aa" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">方法</h1><p id="7082" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接下来是为我想要测试的每种类型的<code class="fe np nq nr ns b">list</code>迭代创建一个方法。每种方法都做一件事来使它成为一个均匀的基准。每个方法将遍历列表中的每个项目，访问列表中的项目并将其赋给一个变量。一旦所有的项目都被处理，它将完成并记录完成任务所用的时间。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">迭代列表的测试方法</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1e77" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结果</h1><p id="aff9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对我们来说幸运的是，<a class="ae kf" href="https://benchmarkdotnet.org/" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a>包括一个排名栏，可以清楚地显示哪一轮测试是赢家。当您阅读这些结果时，您可以使用Mean列来比较每个测试之间的运行时间差异。其中一些有明显的赢家，而其他的差别可以忽略不计。</p><h2 id="7183" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lf oa ob ml lj oc od mn ln oe of mp og bi translated">。NET Framework 4.8 —迭代和访问</h2><pre class="kh ki kj kk gt oh ns oi oj aw ok bi"><span id="a6b6" class="nv ma iq ns b gy ol om l on oo">| Rank | Method        | N     |        Mean |<br/>| ---: | ------------- | ----- | ----------: |<br/>|    1 | For           | 100   |    344.8 ns |<br/>|    2 | ForEachLinq   | 100   |    559.9 ns |<br/>|    3 | ForEach       | 100   |    659.4 ns |<br/>|    3 | GetEnumerator | 100   |    659.5 ns |<br/>|    4 | For           | 10000 | 33,562.8 ns |<br/>|    5 | ForEachLinq   | 10000 | 53,895.5 ns |<br/>|    6 | GetEnumerator | 10000 | 63,317.0 ns |<br/>|    6 | ForEach       | 10000 | 63,356.6 ns |</span></pre><h2 id="8ea2" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lf oa ob ml lj oc od mn ln oe of mp og bi translated">。NET 6.0 —迭代和访问</h2><pre class="kh ki kj kk gt oh ns oi oj aw ok bi"><span id="c994" class="nv ma iq ns b gy ol om l on oo">| Rank | Method        | N     |        Mean |<br/>| ---: | ------------- | ----- | ----------: |<br/>|    1 | SpanForEach   | 100   |    144.3 ns |<br/>|    2 | SpanFor       | 100   |    176.3 ns |<br/>|    3 | ForEach       | 100   |    251.0 ns |<br/>|    3 | GetEnumerator | 100   |    251.0 ns |<br/>|    3 | For           | 100   |    251.4 ns |<br/>|    4 | ForEachLinq   | 100   |    352.1 ns |<br/>|    5 | SpanForEach   | 10000 | 12,260.4 ns |<br/>|    6 | SpanFor       | 10000 | 16,088.1 ns |<br/>|    7 | ForEach       | 10000 | 24,109.4 ns |<br/>|    7 | GetEnumerator | 10000 | 24,111.0 ns |<br/>|    7 | For           | 10000 | 24,113.8 ns |<br/>|    8 | ForEachLinq   | 10000 | 34,713.9 ns |</span></pre><p id="99a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果被格式化为清晰明了的显示，完整的输出你可以在GitHub 上查看<a class="ae kf" href="https://github.com/stphnwlsh/Benchmarking/actions" rel="noopener ugc nofollow" target="_blank">动作的输出。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="311e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">思想</h1><h2 id="c51d" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lf oa ob ml lj oc od mn ln oe of mp og bi translated">。NET框架4.8</h2><p id="95cf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在运行基准测试之后，让我吃惊的是<code class="fe np nq nr ns b">foreach</code>的表现有多差。它与最差的<code class="fe np nq nr ns b">GetEnumerator</code>不相上下，被LINQ <code class="fe np nq nr ns b">foreach</code>超越。我肯定不会在任何旧系统中使用它。如果能有一些<code class="fe np nq nr ns b">Span</code>结果进行比较就更好了，但是这个特性不可用。NET框架。这里明确的选择是将所有的<code class="fe np nq nr ns b">List</code>迭代重构为<code class="fe np nq nr ns b">for</code>循环，过上幸福的生活。</p><h2 id="4efd" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lf oa ob ml lj oc od mn ln oe of mp og bi translated">。NET 6.0</h2><p id="677a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">的。净结果令我相当惊讶。我开始运行这个并不太了解<code class="fe np nq nr ns b">Span</code>，现在我准备做一些研究来了解更多。当访问该项目时，<code class="fe np nq nr ns b">Span</code>似乎比<code class="fe np nq nr ns b">for</code>和<code class="fe np nq nr ns b">foreach</code>更有优势，为了性能提升，似乎值得重构整个代码库。这里的关键结果是，<code class="fe np nq nr ns b">List</code>的任何迭代都应该将列表转换为<code class="fe np nq nr ns b">Span</code>。除此之外，当迭代一个<code class="fe np nq nr ns b">Span</code>时，在<code class="fe np nq nr ns b">for</code>和<code class="fe np nq nr ns b">foreach</code>之间有一些不同，但是我不确定是否值得改变所有这些。</p><h2 id="83de" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lf oa ob ml lj oc od mn ln oe of mp og bi translated">停止使用LINQ FOREACH语句</h2><p id="07b4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这两部影片中，他们都是性能杀手。NET 6.0 和<strong class="ky ir">。NET Framework 4.8 </strong>比其他版本慢得多。立即重构它们。对于被很多人使用的东西来说，这实在是太可怜了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a76a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">密码</h1><p id="98e7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">所有这些代码都是开源的。你可以在<a class="ae kf" href="https://github.com/stphnwlsh/Benchmarking" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到我的基准测试工作。结果是运行基准测试的GitHub动作的输出，您应该能够在该存储库中找到详细的输出。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><pre class="kh ki kj kk gt oh ns oi oj aw ok bi"><span id="3c5a" class="nv ma iq ns b gy ol om l on oo"><strong class="ns ir">Connect or Support?</strong></span><span id="4550" class="nv ma iq ns b gy op om l on oo">If you like this, or want to checkout my other work, please connect with me on <a class="ae kf" href="https://www.linkedin.com/in/stphnwlsh" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae kf" href="https://twitter.com/stphnwlsh" rel="noopener ugc nofollow" target="_blank">Twitter</a> or <a class="ae kf" href="https://github.com/stphnwlsh" rel="noopener ugc nofollow" target="_blank">GitHub</a>, and consider supporting me at <a class="ae kf" href="https://www.buymeacoffee.com/stphnwlsh" rel="noopener ugc nofollow" target="_blank">Buy Me a Coffee</a>.</span></pre></div></div>    
</body>
</html>