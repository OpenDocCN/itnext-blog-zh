<html>
<head>
<title>How to use custom Storage Classes in Kubernetes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Kubernetes中使用自定义存储类？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-custom-storage-classes-in-kubernetes-edc568acfdfe?source=collection_archive---------2-----------------------#2019-09-30">https://itnext.io/how-to-use-custom-storage-classes-in-kubernetes-edc568acfdfe?source=collection_archive---------2-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7d05922fd8120222262f47d2c6774c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*eSCMesxcnB0AlOxxGDJaDQ.png"/></div></figure><p id="99ce" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大多数Kubernetes产品都提供了现成的默认存储类，以简化动态存储供应过程。</p><p id="6751" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，如果您有定制需求呢？在本文中，我们将了解如何创建自己的存储类来满足您的需求。示例场景基于一个<a class="ae ks" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>，但是应该适用于任何Kubernetes提供商。</p><blockquote class="kt ku kv"><p id="84dd" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">代码在</em> <a class="ae ks" href="https://github.com/abhirockzz/kubernetes-custom-storageclass" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub </em> </a>上有</p></blockquote><p id="4a74" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/tutorial-basics-of-kubernetes-volumes-part-2-b2ea6f397402">“教程:Kubernetes卷的基础知识(第2部分)”</a>博客文章探讨了Kubernetes存储类，并提供了一个利用默认值<code class="fe la lb lc ld b">StorageClass</code>的示例。要使用Kubernetes集群中的默认存储类触发动态配置，只需<strong class="jw ir">从您的<code class="fe la lb lc ld b">PersistentVolumeClaim</code>中排除</strong>属性<code class="fe la lb lc ld b">storageClass</code>。例如，<a class="ae ks" href="https://azure.microsoft.com/services/storage/disks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务</a>包含两个预播种的存储类，</p><p id="706f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以通过运行<code class="fe la lb lc ld b">kubectl get storageclass</code>命令进行检查</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="3567" class="lm ln iq ld b gy lo lp l lq lr">NAME                PROVISIONER                AGE<br/>default (default)   kubernetes.io/azure-disk   6d10h<br/>managed-premium     kubernetes.io/azure-disk   6d10h</span></pre><ul class=""><li id="7919" class="ls lt iq jw b jx jy kb kc kf lu kj lv kn lw kr lx ly lz ma bi translated"><code class="fe la lb lc ld b">default</code>存储类:提供由标准硬盘支持的标准<a class="ae ks" href="https://docs.microsoft.com/azure/virtual-machines/windows/disks-types?WT.mc_id=medium-blog-abhishgu#standard-hdd" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a></li><li id="8f7a" class="ls lt iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated"><code class="fe la lb lc ld b">managed-premium</code>存储类:提供由高级固态硬盘支持的高级<a class="ae ks" href="https://docs.microsoft.com/azure/virtual-machines/windows/disks-types?WT.mc_id=medium-blog-abhishgu#premium-ssd" rel="noopener ugc nofollow" target="_blank"> Azure磁盘</a></li></ul><p id="907c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是<code class="fe la lb lc ld b">default</code>存储类规范的样子(这是通过在我的AKS集群上执行<code class="fe la lb lc ld b">kubectl get sc/default</code>获得的一个微调版本)</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="30b4" class="lm ln iq ld b gy lo lp l lq lr">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  labels:<br/>    kubernetes.io/cluster-service: "true"<br/>  name: default<br/>parameters:<br/>  cachingmode: ReadOnly<br/>  kind: Managed<br/>  storageaccounttype: Standard_LRS<br/>provisioner: kubernetes.io/azure-disk<br/>reclaimPolicy: Delete<br/>volumeBindingMode: Immediate</span></pre><h1 id="b73b" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">好吧，那又怎样？</h1><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/68ddb2d6075d8793d5986df91633af76.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*UPA5ZdBKXoDJkwqM.gif"/></div></figure><p id="e3b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我之所以强调这一点，是因为我希望您注意以下属性、它们的值以及它们的含义</p><ul class=""><li id="69e8" class="ls lt iq jw b jx jy kb kc kf lu kj lv kn lw kr lx ly lz ma bi translated"><code class="fe la lb lc ld b">volumeBindingMode: Immediate</code> -该设置意味着一旦<code class="fe la lb lc ld b">PersistentVolumeClaim</code>被创建，就触发<code class="fe la lb lc ld b">PersistentVolume</code>创建，然后是存储介质(在本例中为Azure磁盘)供应。</li><li id="69d3" class="ls lt iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated"><code class="fe la lb lc ld b">reclaimPolicy: Delete</code> -通过这个设置，一旦删除了一个<code class="fe la lb lc ld b">PersistentVolumeClaim</code>，它也会触发相应的<code class="fe la lb lc ld b">PersistentVolume</code>和Azure磁盘的移除。如果您打算保留这些数据用于备份、其他应用等，您将会大吃一惊。</li></ul><blockquote class="kt ku kv"><p id="5039" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq"/><code class="fe la lb lc ld b"><em class="iq">reclaimPolicy: Delete</em></code><em class="iq"/><code class="fe la lb lc ld b"><em class="iq">volumeBindingMode: Immediate</em></code><em class="iq">都是默认设置</em></p></blockquote><h1 id="0f55" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">覆盖volumeBindingMode</h1><p id="4a93" class="pw-post-body-paragraph ju jv iq jw b jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ij bi translated">有效值包括<code class="fe la lb lc ld b">Immediate</code>和<code class="fe la lb lc ld b">WaitForFirstConsumer</code>。用<code class="fe la lb lc ld b">WaitForFirstConsumer</code>覆盖默认值将会延迟<code class="fe la lb lc ld b">PersistentVolume</code>的绑定和供应，直到使用<code class="fe la lb lc ld b">PersistentVolumeClaim</code>的<code class="fe la lb lc ld b">Pod</code>(也就是您的应用程序)被创建。</p><h1 id="9fa4" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">覆盖回收策略</h1><p id="e454" class="pw-post-body-paragraph ju jv iq jw b jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ij bi translated">仍然覆盖默认值<code class="fe la lb lc ld b">Retain</code>，在<code class="fe la lb lc ld b">PersistentVolumeClaim</code>移除后删除<code class="fe la lb lc ld b">PersistentVolume</code>，但确保实际存储介质未被清除。</p><blockquote class="kt ku kv"><p id="ff04" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">注意</em> <code class="fe la lb lc ld b"><em class="iq">Recycle</em></code> <em class="iq">是</em> <code class="fe la lb lc ld b"><em class="iq">reclaimPolicy</em></code>的弃用选项</p></blockquote><h1 id="6501" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">动手操作:创建和使用自定义存储类</h1><p id="6d88" class="pw-post-body-paragraph ju jv iq jw b jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ij bi translated">要跟进，您需要:</p><ul class=""><li id="08c5" class="ls lt iq jw b jx jy kb kc kf lu kj lv kn lw kr lx ly lz ma bi translated">一个<a class="ae ks" href="https://docs.microsoft.com/azure/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">微软Azure账户</a>——去注册一个免费账户吧！</li><li id="80ba" class="ls lt iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated"><a class="ae ks" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Kubernetes服务(AKS)集群</a> —本博客将指导您创建一个集群</li><li id="c8cd" class="ls lt iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated">Azure CLI或Azure Cloud Shell——如果你还没有安装Azure CLI ，你可以选择安装它(应该很快！)或者直接从你的浏览器使用<a class="ae ks" href="https://azure.microsoft.com/features/cloud-shell/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure云壳</a>。</li><li id="a56f" class="ls lt iq jw b jx mb kb mc kf md kj me kn mf kr lx ly lz ma bi translated"><code class="fe la lb lc ld b"><a class="ae ks" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">kubectl</a></code>与您的AKS集群交互(如果您使用Azure Cloud Shell，则不需要)</li></ul><h2 id="e857" class="lm ln iq bd mh nj nk dn ml nl nm dp mp kf nn no mt kj np nq mx kn nr ns nb nt bi translated">Kubernetes集群设置</h2><p id="7c38" class="pw-post-body-paragraph ju jv iq jw b jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ij bi translated">你只需要一个命令就可以在Azure上建立一个Kubernetes集群。但是，在此之前，我们必须创建一个资源组</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="947f" class="lm ln iq ld b gy lo lp l lq lr">export AZURE_SUBSCRIPTION_ID=[to be filled]<br/>export AZURE_RESOURCE_GROUP=[to be filled]<br/>export AZURE_REGION=[to be filled] (e.g. southeastasia)</span></pre><p id="8c7a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">切换到您的订阅并调用<code class="fe la lb lc ld b">az group create</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="655e" class="lm ln iq ld b gy lo lp l lq lr">az account set -s $AZURE_SUBSCRIPTION_ID<br/>az group create -l $AZURE_REGION -n $AZURE_RESOURCE_GROUP</span></pre><p id="72dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您现在可以调用<code class="fe la lb lc ld b">az aks create</code>来创建新的集群</p><blockquote class="kt ku kv"><p id="49a3" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated">为了简单起见，下面的命令创建了一个单节点集群。根据您的要求随意更改规格</p></blockquote><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="4aad" class="lm ln iq ld b gy lo lp l lq lr">export AKS_CLUSTER_NAME=[to be filled]</span><span id="b2ab" class="lm ln iq ld b gy nu lp l lq lr">az aks create --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --node-count 1 --node-vm-size Standard_B2s --node-osdisk-size 30 --generate-ssh-keys</span></pre><p id="e868" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用<code class="fe la lb lc ld b">az aks get-credentials</code>获取AKS集群凭证——因此，<code class="fe la lb lc ld b">kubectl</code>现在将指向您的新集群。你可以证实这一点</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="3e59" class="lm ln iq ld b gy lo lp l lq lr">az aks get-credentials --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME<br/>kubectl get nodes</span></pre><blockquote class="kt ku kv"><p id="bddc" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">如果您对使用</em><a class="ae ks" href="https://azure.microsoft.com/services/kubernetes-service/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"><em class="iq">Azure</em></a><em class="iq">学习Kubernetes和Containers感兴趣，一个很好的起点是使用文档中的</em> <a class="ae ks" href="https://docs.microsoft.com/azure/aks/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">快速入门、教程和代码示例</em> </a> <em class="iq">来熟悉该服务。我也强烈推荐查看一下</em> <a class="ae ks" href="https://azure.microsoft.com/resources/kubernetes-learning-path/?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> 50天Kubernetes学习路径</em> </a> <em class="iq">。高级用户可能希望参考</em> <a class="ae ks" href="https://docs.microsoft.com/azure/aks/best-practices?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Kubernetes最佳实践</em> </a> <em class="iq">或观看一些</em> <a class="ae ks" href="https://azure.microsoft.com/resources/videos/index/?services=kubernetes-service&amp;WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> <em class="iq">视频</em> </a> <em class="iq">以了解演示、主要特性和技术会议。</em></p></blockquote><h1 id="3ed5" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">测试一下…</h1><p id="5a40" class="pw-post-body-paragraph ju jv iq jw b jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ij bi translated">创建存储类并确认其已创建</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="a1c4" class="lm ln iq ld b gy lo lp l lq lr">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-custom-storageclass/master/custom-storage-class.yaml<br/>    kubectl get sc</span></pre><blockquote class="kt ku kv"><p id="3ec9" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">为了简单起见，YAML文件直接从</em><a class="ae ks" href="https://github.com/abhirockzz/kubernetes-custom-storageclass" rel="noopener ugc nofollow" target="_blank"><em class="iq">GitHub repo</em></a><em class="iq">中引用，但是你也可以将文件下载到你的本地机器上，以同样的方式使用它。</em></p></blockquote><p id="3970" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您应该会看到新的存储类</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="eeb0" class="lm ln iq ld b gy lo lp l lq lr">NAME                            PROVISIONER                AGE<br/>azuredisk-custom-storageclass   kubernetes.io/azure-disk   4s<br/>default (default)               kubernetes.io/azure-disk   2d10h<br/>managed-premium                 kubernetes.io/azure-disk   2d10h</span></pre><p id="46d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建<code class="fe la lb lc ld b">PersistentVolumeClaim</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="8a01" class="lm ln iq ld b gy lo lp l lq lr">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-custom-storageclass/master/pvc.yaml<br/>    kubectl get pvc/app-pvc</span></pre><p id="5baa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您会注意到<code class="fe la lb lc ld b">STATUS</code>是<code class="fe la lb lc ld b">Pending</code>，这意味着它还没有与<code class="fe la lb lc ld b">PersistentVolume</code>相关联。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="0a90" class="lm ln iq ld b gy lo lp l lq lr">NAME      STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS                    AGE<br/>app-pvc   Pending                                      azuredisk-custom-storageclass   10s</span></pre><p id="afc4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创造一个<code class="fe la lb lc ld b">Deployment</code>(将创造一个<code class="fe la lb lc ld b">Pod</code>)</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="80f7" class="lm ln iq ld b gy lo lp l lq lr">kubectl apply -f <a class="ae ks" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-custom-storageclass/master/deployment.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-custom-storageclass/master/deployment.yaml</a></span></pre><blockquote class="kt ku kv"><p id="56a8" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><code class="fe la lb lc ld b"><em class="iq">Pod</em></code> <em class="iq">会在一段时间内过渡到</em> <code class="fe la lb lc ld b"><em class="iq">Running</em></code> <em class="iq">状态</em></p></blockquote><p id="0d88" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦到了<code class="fe la lb lc ld b">Running</code>，再次检查<code class="fe la lb lc ld b">PersistentVolumeClaim</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="c479" class="lm ln iq ld b gy lo lp l lq lr">kubectl get pvc/app-pvc</span></pre><p id="dd66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe la lb lc ld b">STATUS</code>会变成<code class="fe la lb lc ld b">Bound</code>。作为<code class="fe la lb lc ld b">Pod</code>创建的结果，使用<code class="fe la lb lc ld b">PersistentVolumeClaim</code> ( <code class="fe la lb lc ld b">azuredisk-custom-storageclass</code>)中提到的<code class="fe la lb lc ld b">StorageClass</code>分析存储请求并触发动态配置。因此，Azure磁盘是随着<code class="fe la lb lc ld b">PersistentVolume</code>的创建及其与<code class="fe la lb lc ld b">PersistentVolumeClaim</code>的关联一起提供的。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="b641" class="lm ln iq ld b gy lo lp l lq lr">NAME      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS                    AGE<br/>app-pvc   Bound    pvc-83020049-e107-11e9-93ab-025752f370d3   1Gi        RWO            azuredisk-custom-storageclass   4m53s</span></pre><blockquote class="kt ku kv"><p id="05ff" class="ju jv kw jw b jx jy jz ka kb kc kd ke kx kg kh ki ky kk kl km kz ko kp kq kr ij bi translated"><em class="iq">这一切发生在</em> <strong class="jw ir"> <em class="iq">之后</em> </strong> <em class="iq">我们的app被部署，多亏了</em> <code class="fe la lb lc ld b"><em class="iq">WaitForFirstConsumer</em></code> <em class="iq">设置为</em> <code class="fe la lb lc ld b"><em class="iq">volumeBindingMode</em></code> <em class="iq">属性。</em></p></blockquote><p id="cb8e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用<code class="fe la lb lc ld b">kubectl get pv</code>进行确认</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="c467" class="lm ln iq ld b gy lo lp l lq lr">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS                    REASON   AGE<br/>pvc-83020049-e107-11e9-93ab-025752f370d3   1Gi        RWO            Retain           Bound    default/app-pvc          azuredisk-custom-storageclass            4m46s</span></pre><p id="0fd1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当然，还会创建一个Azure磁盘。为了检查，</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="8319" class="lm ln iq ld b gy lo lp l lq lr">AKS_NODE_RESOURCE_GROUP=$(az aks show --resource-group $AZURE_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query nodeResourceGroup -o tsv)</span><span id="7eb7" class="lm ln iq ld b gy nu lp l lq lr">az disk list -g $AKS_NODE_RESOURCE_GROUP</span></pre><p id="1fa6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe la lb lc ld b">tags</code>部分看起来类似于</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="e85c" class="lm ln iq ld b gy lo lp l lq lr">"tags": {<br/>      "created-by": "kubernetes-azure-dd",<br/>      "kubernetes.io-created-for-pv-name": "pvc-83020049-e107-11e9-93ab-025752f370d3",<br/>      "kubernetes.io-created-for-pvc-name": "app-pvc",<br/>      "kubernetes.io-created-for-pvc-namespace": "default"<br/>}</span></pre><h1 id="50d7" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">删除应用程序和永久卷声明</h1><p id="e038" class="pw-post-body-paragraph ju jv iq jw b jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ni kp kq kr ij bi translated">让我们删除应用程序和<code class="fe la lb lc ld b">PersistentVolumeClaim</code>。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="bb65" class="lm ln iq ld b gy lo lp l lq lr">kubectl delete -f deployment.yaml<br/>kubectl delete -f pvc.yaml</span></pre><p id="d19f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用<code class="fe la lb lc ld b">kubectl get pv</code>检查<code class="fe la lb lc ld b">PersistentVolume</code>——你会看到<code class="fe la lb lc ld b">STATUS</code>现在已经变成了<code class="fe la lb lc ld b">Released</code>(从<code class="fe la lb lc ld b">Bound</code>)。确认Azure磁盘仍然存在</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="278a" class="lm ln iq ld b gy lo lp l lq lr">az disk list -g $AKS_NODE_RESOURCE_GROUP</span></pre><p id="bd9d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">确实如此。原因是我们通过使用自定义存储类将<code class="fe la lb lc ld b">reclaimPolicy</code>设置为<code class="fe la lb lc ld b">Retain</code>覆盖了默认行为</p><p id="3043" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完成后，您可以删除资源组，这将依次删除AKS集群和关联的Azure磁盘</p><h1 id="078d" class="mg ln iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">打扫卫生</h1><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="da85" class="lm ln iq ld b gy lo lp l lq lr">az group delete --name $AZURE_RESOURCE_GROUP --yes --no-wait</span></pre><p id="b081" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个博客到此为止。我真的希望你觉得有用！😃请在<a class="ae ks" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上喜欢、关注并联系我，以获得反馈/建议，或者随时发表评论👇👇</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>