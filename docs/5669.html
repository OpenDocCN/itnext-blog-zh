<html>
<head>
<title>Explode an Array into a deeply nested Object with this simple, recursive function.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用这个简单的递归函数将一个数组分解成一个深度嵌套的对象。</h1>
<blockquote>原文：<a href="https://itnext.io/explode-an-array-into-a-deeply-nested-object-with-this-simple-recursive-function-4094ac1eeb8b?source=collection_archive---------1-----------------------#2021-04-28">https://itnext.io/explode-an-array-into-a-deeply-nested-object-with-this-simple-recursive-function-4094ac1eeb8b?source=collection_archive---------1-----------------------#2021-04-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/30857ea7485bb4d230e34f676a5c3aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxcfV0olAQipKhRvNbSpnA.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">堪培拉的秋天是我一年中最喜欢的时候。(图片由作者提供)</figcaption></figure><div class=""/><div class=""><h2 id="ccc7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">因为递归规则。</h2></div><p id="82a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">从API获取数据时，一个非常常见的模式是在应用程序中索引该数据，这样您就可以在不搜索的情况下回读它。</p><h1 id="6993" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">一个例子</h1><p id="aa9b" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">假设您有一个API，它返回一个项目列表，比如。</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="a103" class="na lv jj mw b gz nb nc l nd ne">const ITEMS = [<br/>  {<br/>    title: 'The One',<br/>    contract: '1',<br/>    author: 'alice'<br/>  },<br/>  {<br/>    title: 'It Takes Two',<br/>    contract: '2',<br/>    author: 'alice'<br/>  },<br/>  {<br/>    title: '3x a lady',<br/>    contract: '1',<br/>    author: 'beck'<br/>  },<br/>  {<br/>    title: 'Four on the Floor',<br/>    contract: '1',<br/>    author: 'candice'<br/>  },<br/>  {<br/>    title: "In de'Pipe Going Five by Five",<br/>    contract: '3',<br/>    author: 'candice'<br/>  }<br/>]</span></pre><p id="faaf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">在你的应用程序中，你会发现你经常需要通过<code class="fe nf ng nh mw b">author</code>和<code class="fe nf ng nh mw b">contract</code>来查找特定的<code class="fe nf ng nh mw b">item</code>。一种天真的方法可能是这样的</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="09c9" class="na lv jj mw b gz nb nc l nd ne">const getItemBy = (author, contract)<br/>  =&gt; ITEMS.find(<br/>    item =&gt; author === item.author &amp;&amp; contract === item.contract<br/>  )</span></pre><p id="25b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如果你只是偶尔查一下<code class="fe nf ng nh mw b">item</code>，这没什么。但是如果你需要一直这样做，它会变得有点慢，要一直搜索整个T4。</p><p id="5145" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">相反，如果你能写一个函数，比如</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="5689" class="na lv jj mw b gz nb nc l nd ne">const getItemBy = (author, contract) =&gt; ITEMS_INDEX[author][contract]</span></pre><p id="c07a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">或者更安全</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="5ed6" class="na lv jj mw b gz nb nc l nd ne">const getItemBy = (author, contract )<br/>  =&gt; ITEMS_INDEX[author] ? ITEMS_INDEX[author][contract] : undefined</span></pre><p id="ee41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">在这种情况下,<code class="fe nf ng nh mw b">ITEMS_INDEX</code>需要这样的结构</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="f803" class="na lv jj mw b gz nb nc l nd ne">const ITEMS_INDEX = {<br/>  alice: {<br/>    '1': {<br/>      title: 'The One',<br/>      contract: '1',<br/>      author: 'alice'<br/>    },<br/>    '2': {<br/>      title: 'It Takes Two',<br/>      contract: '2',<br/>      author: 'alice'<br/>    },<br/>  },<br/>  beck: {<br/>    '1': {<br/>      title: '3x a lady',<br/>      contract: '1',<br/>      author: 'beck'<br/>    },<br/>  },<br/>  candice: {<br/>    '1': {<br/>      title: 'Four on the Floor',<br/>      contract: '1',<br/>      author: 'candice'<br/>    },<br/>    '3': {<br/>      title: "In de'Pipe Going Five by Five",<br/>      contract: '3',<br/>      author: 'candice'<br/>    }<br/>  }<br/>}</span></pre><h1 id="95a1" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">创建索引</h1><p id="29aa" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">为了以一种灵活的方式从<code class="fe nf ng nh mw b">ITEMS</code>构建<code class="fe nf ng nh mw b">ITEMS_INDEX</code>。</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="efbf" class="na lv jj mw b gz nb nc l nd ne">const ITEMS_ARRAY = explode(ITEMS, 'author', 'contract')</span></pre><h2 id="0801" class="na lv jj bd lw ni nj dn ma nk nl dp me lh nm nn mg ll no np mi lp nq nr mk ns bi translated">一把钥匙</h2><p id="9fe5" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">用一个键分解一组项目很容易。</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="1e3f" class="na lv jj mw b gz nb nc l nd ne">const explodeOne = (array, key)<br/>  =&gt; array.reduce((acc, item) =&gt; ({<br/>    ...acc,<br/>    [item[key]]: item<br/>  }), {})</span></pre><p id="3d69" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">所以<code class="fe nf ng nh mw b">explodeOne(array, 'author')</code>会给你一个对象，其中的条目是由它们的作者来定义的，但是在这个例子中，每个作者可以有多个条目，通过条目的<code class="fe nf ng nh mw b">contract</code>来区分。</p><h2 id="0f28" class="na lv jj bd lw ni nj dn ma nk nl dp me lh nm nn mg ll no np mi lp nq nr mk ns bi translated">许多钥匙</h2><p id="94cc" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">如果你需要多个键，就像我们上面的例子，你需要使用<em class="nt">递归</em>。</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="c496" class="na lv jj mw b gz nb nc l nd ne">const <em class="nt">explode</em> = (array, key, ...rest)<br/>  =&gt; array.<em class="nt">reduce</em>((acc, item) =&gt; ({<br/>    ...acc,<br/>    [item[key]]: rest.length ? {<br/>      ...acc[item[key]],<br/>      ...<em class="nt">explode</em>([item], ...rest)<br/>    } : item<br/>  }), {})</span></pre><h2 id="a5db" class="na lv jj bd lw ni nj dn ma nk nl dp me lh nm nn mg ll no np mi lp nq nr mk ns bi translated">这是怎么回事？</h2><p id="0d0f" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">这里使用了许多方便的Javascript特性。</p><ol class=""><li id="c261" class="nu nv jj la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#rest_syntax_parameters" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> Rest语法</em> </a> <em class="nt"> </em>处理任意数量的按键<code class="fe nf ng nh mw b">(array, key, ...rest)</code>、</li><li id="3540" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt nz oa ob oc bi translated"><a class="ae od" rel="noopener ugc nofollow" target="_blank" href="/map-and-reduce-a-primer-9e18a6b7e587"> <em class="nt">一个数组缩减器</em> </a>循环遍历数组并构造我们的最终对象，</li><li id="ae37" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt nz oa ob oc bi translated"><a class="ae od" href="https://codeburst.io/computed-property-names-ftw-61000332fff1" rel="noopener" target="_blank"><em class="nt">Computed properties</em></a><code class="fe nf ng nh mw b">[item[key]: ...</code>意思是你可以在事先不知道的情况下，在一个对象中引用或者创建一个属性，</li><li id="eedc" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt nz oa ob oc bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank"> <em class="nt">对象展开批注</em> </a> <code class="fe nf ng nh mw b">{ ...acc, ...<em class="nt">explode</em>([item], ...rest) }</code>，以及</li><li id="9a24" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt nz oa ob oc bi translated"><em class="nt">递归</em>，即我们在<code class="fe nf ng nh mw b"><em class="nt">explode</em></code>函数中再次调用<code class="fe nf ng nh mw b">explode</code>来处理特定<code class="fe nf ng nh mw b">item</code>的下一个键。</li></ol><h2 id="08e4" class="na lv jj bd lw ni nj dn ma nk nl dp me lh nm nn mg ll no np mi lp nq nr mk ns bi translated">逐行解释</h2><p id="00d6" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><code class="fe nf ng nh mw b">const <em class="nt">explode</em> = (array, key, ...rest)</code>将函数<code class="fe nf ng nh mw b"><em class="nt">explode</em></code>定义为接受参数<code class="fe nf ng nh mw b">array</code>，还有一个<code class="fe nf ng nh mw b">key</code>，以及可选的一组其他键，我们称之为<code class="fe nf ng nh mw b">rest</code>。如果没有更多的键，那么<code class="fe nf ng nh mw b">rest = []</code>。</p><p id="0441" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">该功能将把<code class="fe nf ng nh mw b">array</code>、<em class="nt">还原为<code class="fe nf ng nh mw b">object</code>。数组<em class="nt"> reducer </em>返回一个不断扩展的对象，<code class="fe nf ng nh mw b">acc</code>(accumulator的缩写)，在每一遍中，添加<code class="fe nf ng nh mw b">...acc</code>，即对象中已经存在的内容，加上一个带有一些相关数据的新键<code class="fe nf ng nh mw b">[item[key]]</code>。在我们的例子中，如果<code class="fe nf ng nh mw b">item</code>是<code class="fe nf ng nh mw b">{ title: 'The One', contract: '1', author: 'alice', data: 'one' }</code>并且<code class="fe nf ng nh mw b">key</code>是“作者”，那么<code class="fe nf ng nh mw b">{ [item[key]]: ... }</code>将是<code class="fe nf ng nh mw b">{ alice: ... }</code>。</em></p><p id="f4aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">因为Alice可以是多个项目的作者，有不同的合同，如果有更多的键(即<code class="fe nf ng nh mw b">rest.length !== 0</code>)，我们需要确保<code class="fe nf ng nh mw b">[item[key]]</code>处的对象包括之前已经在<code class="fe nf ng nh mw b">acc[item[key]]</code>中的任何内容，然后我们想要<code class="fe nf ng nh mw b"><em class="nt">explode</em></code>只使用键的<code class="fe nf ng nh mw b">rest</code>的单个<code class="fe nf ng nh mw b">item</code>。</p><p id="b1c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如果<code class="fe nf ng nh mw b">rest</code>中没有更多的钥匙，我们只需插入<code class="fe nf ng nh mw b">item</code>本身。</p><h2 id="72eb" class="na lv jj bd lw ni nj dn ma nk nl dp me lh nm nn mg ll no np mi lp nq nr mk ns bi translated">利益</h2><p id="72f5" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated"><code class="fe nf ng nh mw b"><em class="nt">explode</em></code>函数为您提供了一种非常简单的方法来索引以非优化格式提供的数据。许多API将返回<code class="fe nf ng nh mw b">key, value</code>对的数组，将这些数组转换成一个对象，用提供的键进行键控，可以节省您以后的大量工作。</p><h1 id="138f" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">增强:读者的一个练习</h1><p id="5da2" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt in bi translated">如果我们已经有了一个有效的<code class="fe nf ng nh mw b">author</code>和<code class="fe nf ng nh mw b">contract</code>，那么我们真正需要在索引中存储的就是标题。</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="721b" class="na lv jj mw b gz nb nc l nd ne">const TITLES_INDEX = {<br/>  alice: {<br/>    '1': 'The One',<br/>    '2': 'It Takes Two'<br/>  },<br/>  beck: {<br/>    '1': '3x a lady'<br/>  },<br/>  candice: {<br/>    '1': 'Four on the Floor',<br/>    '3': "In de'Pipe Going Five by Five"<br/>  }<br/>}</span><span id="bc00" class="na lv jj mw b gz oj nc l nd ne">const <em class="nt">getTitle</em> = (author, contract)<br/>  =&gt; TITLES_INDEX[author]<br/>    ? TITLES_INDEX[author][contract]<br/>    : undefined</span></pre><p id="91b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">你会对上面的<code class="fe nf ng nh mw b">explode</code>函数做什么修改来生成<code class="fe nf ng nh mw b">TITLES_INDEX</code>？</p><p id="493f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">请在回复中张贴您的答案。</p><h1 id="288a" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">链接</h1><ul class=""><li id="6729" class="nu nv jj la b lb mm le mn lh ok ll ol lp om lt on oa ob oc bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#rest_syntax_parameters" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Spread _ syntax # rest _ syntax _ parameters</a></li><li id="3856" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt on oa ob oc bi translated">【https://itnext.io/map-and-reduce-a-primer-9e18a6b7e587 T4】</li><li id="1f70" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt on oa ob oc bi translated"><a class="ae od" href="https://codeburst.io/computed-property-names-ftw-61000332fff1" rel="noopener" target="_blank">https://code burst . io/computed-property-names-ftw-61000332 fff 1</a></li><li id="babd" class="nu nv jj la b lb oe le of lh og ll oh lp oi lt on oa ob oc bi translated"><a class="ae od" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Spread _ syntax # Spread _ in _ object _ literals</a></li></ul></div></div>    
</body>
</html>