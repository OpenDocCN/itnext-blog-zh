<html>
<head>
<title>Node.js configuration and secrets management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js配置和机密管理</h1>
<blockquote>原文：<a href="https://itnext.io/node-js-configuration-and-secrets-management-acd84375ca7?source=collection_archive---------0-----------------------#2018-03-30">https://itnext.io/node-js-configuration-and-secrets-management-acd84375ca7?source=collection_archive---------0-----------------------#2018-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/36ccfd422ce17964fa372b4ee2c31fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAFAiAxqZVrOVLBTo9tf6w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/xrVDYZRGdw4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米勒·佩龙</a>在<a class="ae kc" href="https://unsplash.com/search/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><blockquote class="kd ke kf"><p id="9196" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><a class="ae kc" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fnode-js-configuration-and-secrets-management-acd84375ca7%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="afe1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在过去的几年里，我参与了许多Node.js项目，其中一个反复出现的问题是人们管理配置和秘密的方式。</p><p id="f5d3" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">首先，这些是我试图通过配置/机密管理实现的主要方面。</p><h2 id="a09d" class="li lj iq bd lk ll lm dn ln lo lp dp lq lf lr ls lt lg lu lv lw lh lx ly lz ma bi translated">灵活性</h2><p id="40c8" class="pw-post-body-paragraph kg kh iq kj b kk mb km kn ko mc kq kr lf md ku kv lg me ky kz lh mf lc ld le ij bi translated">允许软件开发人员更改配置。大多数情况下，管理配置是运营部门的职责，但这会增加不必要的开销，并减慢调试/修复过程。很多时候是开发人员定义配置选项，因此他们最了解正确的配置值。考虑以下情况:</p><p id="9317" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">Scala (Akka)内置的应用程序使用<code class="fe mg mh mi mj b">typesafe-config</code>进行服务器配置，并使用它指定线程池/调度程序选项。在某一点上，应用程序已经开始面临严重的性能问题。由于运营部门对应用程序的内部架构没有足够的了解(他们不了解线程池，更不知道哪些参与者/未来在哪些池中运行)，修复流程如下所示:</p><ol class=""><li id="79eb" class="mk ml iq kj b kk kl ko kp lf mm lg mn lh mo le mp mq mr ms bi translated">软件工程师将在本地重现该问题</li><li id="ce64" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le mp mq mr ms bi translated">软件工程师会找到问题的原因，经过一番试验后，会为线程池提出正确的设置</li><li id="9f18" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le mp mq mr ms bi translated">软件工程师将联系运营部门，以相应地更改生产配置</li></ol><p id="ac16" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在这个过程中，步骤3是不必要的。此外，如果建立了适当的CI/CD渠道，并且实施了适当的开发实践，步骤3将不会通过同行评审或者以任何方式被跟踪</p><p id="9374" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">更普遍的情况是，开发人员需要提高特定服务的调试级别。为什么不给开发者一个自己动手的选项呢？</p><p id="d007" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">鉴于存在同行评审，这可能会像任何其他代码更改一样被破坏</p><h2 id="0f1f" class="li lj iq bd lk ll lm dn ln lo lp dp lq lf lr ls lt lg lu lv lw lh lx ly lz ma bi translated">安全性</h2><p id="4c6f" class="pw-post-body-paragraph kg kh iq kj b kk mb km kn ko mc kq kr lf md ku kv lg me ky kz lh mf lc ld le ij bi translated">秘密值(数据库密码、API访问密钥等)不应出现在回购协议中。句号。</p><p id="40f4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这一点与“灵活性”有点矛盾，但对于大多数配置库来说，这很容易解决。怎么会？在repo中有所有非秘密值，然后在部署过程中注入秘密值(我更喜欢使用ENV变量)</p><h2 id="7552" class="li lj iq bd lk ll lm dn ln lo lp dp lq lf lr ls lt lg lu lv lw lh lx ly lz ma bi translated">冗长</h2><p id="c138" class="pw-post-body-paragraph kg kh iq kj b kk mb km kn ko mc kq kr lf md ku kv lg me ky kz lh mf lc ld le ij bi translated">避免为每个环境重新定义整个配置非常有用。大多数配置系统都允许通过定义配置文件的处理顺序来做到这一点。它们通常从最通用的配置文件开始，然后用更具体的配置文件覆盖配置值。如果图书馆允许这样做，我随时都可以接受</p><p id="a259" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">示例:您的数据库连接池设置在所有环境中都是相同的(假设最小值:2，最大值:10)。但是对于生产环境，您需要更积极的池(最小值:10，最大值:80)。他们说你会用<code class="fe mg mh mi mj b">config</code>做那件事</p><p id="8b81" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir"> default.js: </strong></p><pre class="my mz na nb gt nc mj nd ne aw nf bi"><span id="62a5" class="li lj iq mj b gy ng nh l ni nj"><strong class="mj ir">const </strong>config = {<br/>  database: {<br/>    client: 'mysql',<br/>    connection: {<br/>      host: 'localhost',<br/>      user: '',<br/>      password: '',<br/>      database: '',<br/>    },<br/>    pool: {<br/>      min: 2,<br/>      max: 10,<br/>    },<br/>  },<br/>}<br/><br/>module.exports = config;</span></pre><p id="9ff6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir"> production.js: </strong></p><pre class="my mz na nb gt nc mj nd ne aw nf bi"><span id="1777" class="li lj iq mj b gy ng nh l ni nj"><strong class="mj ir">const </strong>config = {<br/>  database.pool: {<br/>     min: 10,<br/>     max: 80,<br/>  },<br/>}<br/><br/>module.exports = config;</span></pre><h2 id="b41b" class="li lj iq bd lk ll lm dn ln lo lp dp lq lf lr ls lt lg lu lv lw lh lx ly lz ma bi translated">简单</h2><blockquote class="kd ke kf"><p id="11fe" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">一个设计师知道他已经达到了完美，不是当没有什么可以添加的时候，而是当没有什么可以拿走的时候。</p><p id="8f2a" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">安托万·德·圣埃克苏佩里</p></blockquote><p id="416c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">当然，至少有一些解决上述问题的方案。问题是，您真的想在基础架构中安装额外的组件来解决这个问题吗？额外的组件带来了复杂性的增加，这导致了错误率的增加、调试时间和反应时间的增加</p><p id="2333" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我用过的一些解决方案:</p><ol class=""><li id="490f" class="mk ml iq kj b kk kl ko kp lf mm lg mn lh mo le mp mq mr ms bi translated">hashi corp Vault——适合秘密管理，但有点大材小用，除非你在几十个场景中有超过9000个微服务</li><li id="1620" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le mp mq mr ms bi translated">配置管理的主厨/傀儡/负责人——根据我的经验，这些都是设置服务器的很好的工具，但是当涉及到定制软件配置时，总会出现问题</li><li id="c77f" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le mp mq mr ms bi translated">共识系统——动物园管理员/etcd/consul。有些人用它们来存储所有的配置，并让应用程序与它们交互。大多数时候，当人们已经有了这些系统中的一个时，他们就会这么做(例如，运行Kubernetes的人有现成的<code class="fe mg mh mi mj b">etcd</code>)。</li></ol><p id="25a3" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我已经完成了大部分的成功案例。有一个著名的俄罗斯习语“用显微镜敲钉子”，我总是觉得那正是我正在做的</p><h2 id="9873" class="li lj iq bd lk ll lm dn ln lo lp dp lq lf lr ls lt lg lu lv lw lh lx ly lz ma bi translated">我的路</h2><p id="5d0f" class="pw-post-body-paragraph kg kh iq kj b kk mb km kn ko mc kq kr lf md ku kv lg me ky kz lh mf lc ld le ij bi translated">在节点中。JS有一个很好的<a class="ae kc" href="https://www.npmjs.com/package/config" rel="noopener ugc nofollow" target="_blank">配置库</a>为我做了所有的诡计和欺骗。项目结构:</p><p id="9c19" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe mg mh mi mj b">/<br/> — package.json<br/> — /src<br/> — /config<br/> — — /local.js<br/> — — /default.js<br/> — — /development.js<br/> — — /production.js<br/> — — /&lt;otherenv&gt;.js<br/> — — /custom-environment-variables.js</code></p><p id="c430" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">文件内容如下:</p><ul class=""><li id="5450" class="mk ml iq kj b kk kl ko kp lf mm lg mn lh mo le nk mq mr ms bi translated">local.js —包含完整的配置，应该放在<code class="fe mg mh mi mj b">.gitignore</code>下，永远不要出现在repo上</li><li id="b4e5" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le nk mq mr ms bi translated">default.js —包含由所有环境共享的顶级通用配置密钥，保密值为空白</li><li id="cf11" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le nk mq mr ms bi translated"><env.js> —包含特定环境的特定覆盖。使用<code class="fe mg mh mi mj b">NODE_ENV</code>环境变量定义环境</env.js></li><li id="8711" class="mk ml iq kj b kk mt ko mu lf mv lg mw lh mx le nk mq mr ms bi translated">custom-environment-variables . js—将秘密配置密钥映射到稍后在运行时注入的env变量</li></ul><p id="5003" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我通常和Kubernetes一起使用，Kubernetes允许<a class="ae kc" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">存储秘密值</a>，并以一种方便的方式使用环境变量注入它们</p><p id="44b1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">回购的例子是这里的<a class="ae kc" href="https://github.com/schikin/example-node-config" rel="noopener ugc nofollow" target="_blank">和</a></p><p id="aaff" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">快乐黑客和不要重新发明轮子！</p></div></div>    
</body>
</html>