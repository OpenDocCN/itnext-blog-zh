<html>
<head>
<title>GraphQL with Elixir/Phoenix and Absinthe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL配灵药/凤凰和苦艾酒</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-with-elixir-phoenix-and-absinthe-6b0ffd260094?source=collection_archive---------2-----------------------#2018-02-21">https://itnext.io/graphql-with-elixir-phoenix-and-absinthe-6b0ffd260094?source=collection_archive---------2-----------------------#2018-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3e94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来自脸书的<strong class="js iu"> GraphQL </strong>凭借其所有的优点成为REST ( <strong class="js iu">代表性状态转移)</strong>的有力竞争者。在本文中，我们将重点关注使用苦艾酒库为Phoenix Web应用程序编写查询和变异。假设读者已经熟悉GraphQL的概念以及与REST相比的相对优势。如果没有，我建议先在这里复习一下概念<a class="ae ko" href="http://graphql.org" rel="noopener ugc nofollow" target="_blank">。此外，Arnaud Lauret有一篇关于GraphQL与REST比较的优秀文章</a><a class="ae ko" href="https://apihandyman.io/and-graphql-for-all-a-few-things-to-think-about-before-blindly-dumping-rest-for-graphql/" rel="noopener ugc nofollow" target="_blank">这里</a>我认为这是每个人的必读之作。</p><p id="6079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我有意省略了认证部分。但是大多数web应用程序都有一些身份验证机制来保护查询和突变免受未授权用户的攻击。这可能是未来文章的一部分。但是对于本文，范围是集中在使用苦艾酒编写查询(GET等价于REST)和突变(POST等价于REST)。</p><h1 id="6516" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">我们需要什么</strong></h1><p id="ee2c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们需要的是—</p><ol class=""><li id="ef77" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated"><a class="ae ko" href="http://phoenixframework.org" rel="noopener ugc nofollow" target="_blank"> Phoenix Web框架</a> —用于编写Web应用</li><li id="51d4" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><a class="ae ko" href="http://absinthe-graphql.org" rel="noopener ugc nofollow" target="_blank">苦艾酒</a> — GraphQL编写查询/突变的灵丹妙药工具包</li><li id="5ad4" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><a class="ae ko" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank">GraphQL</a>—一个用于探索graph QL的浏览器内集成开发环境。你可以把它想象成休息的邮递员。我们将在这里使用来自<a class="ae ko" href="https://github.com/skevy/graphiql-app" rel="noopener ugc nofollow" target="_blank">的mac应用</a>，它是GraphiQL的一个包装器。</li></ol><h1 id="5a63" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">应用概述:</strong></h1><p id="5c66" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们将使用的Phoenix应用程序是一个简单的博客应用程序，Phoenix 1.3有两个模式，分别在帐户和博客上下文中定义用户和帖子。完整的代码可以在github <a class="ae ko" href="https://github.com/imeraj/Phoenix_Playground/tree/master/1.3/blog_app_gql" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="310e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">添加依赖关系</strong></h1><p id="abdb" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">首先，我们需要在<strong class="js iu"> mix.exs </strong>中添加一些依赖项，使GraphQL在Phoenix app中可用—</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d959" class="mp kq it ml b gy mq mr l ms mt">defp deps <strong class="ml iu">do<br/>  </strong>[<br/>   {:absinthe, "~&gt; 1.3.1"},<br/>   {:absinthe_plug, "~&gt; 1.3.0"},<br/>   {:absinthe_ecto, "~&gt; 0.1.3"}<br/>  ]<br/><strong class="ml iu">end</strong></span></pre><h1 id="3963" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为GraphQL构建应用程序</h1><p id="7751" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们需要一些东西来构建应用程序的GraphQL部分，它们是—</p><p id="44cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">i. GraphQL模式—放在<strong class="js iu"> web/schema/schema.ex </strong>文件夹中</p><p id="0b80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二。自定义类型—我们已经定义了一些自定义类型，用于放置在<strong class="js iu"> web/schema/types.ex </strong>中的模式</p><p id="02ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三。解析器—模式将每个查询或变异映射到一个解析器函数，以处理业务逻辑。解析器放在它们自己的文件中——在我们的简单例子中，放在<strong class="js iu">accounts/user _ resolver . ex</strong>和<strong class="js iu"> blog/post_resolver.ex </strong>中。</p><p id="321d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们需要修改路由器，以便能够在<strong class="js iu"> router.ex </strong>中使用GraphQL客户端进行查询</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="27d7" class="mp kq it ml b gy mq mr l ms mt">forward("/graphql",  Absinthe.Plug,          schema: BlogAppGql.Web.Schema)<br/>forward("/graphiql", Absinthe.Plug.GraphiQL, schema: BlogAppGql.Web.Schema)</span></pre><h1 id="7e9e" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">编写GraphQL查询</strong></h1><p id="5f72" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们现在已经准备好编写我们的查询了，我们可以认为它等同于REST中的GET请求。</p><p id="eb5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将GraphQL模式和解析器映射定义如下—</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d02e" class="mp kq it ml b gy mq mr l ms mt">defmodule BlogAppGql.Web.Schema <strong class="ml iu">do<br/>  </strong>use Absinthe.Schema<br/>  import_types(BlogAppGql.Web.Schema.Types)<br/><br/>  query <strong class="ml iu">do<br/>    </strong>field :blog_posts, list_of(:blog_post) <strong class="ml iu">do<br/>      </strong>resolve(&amp;BlogAppGql.Web.Blog.PostResolver.all/2)<br/>    <strong class="ml iu">end<br/><br/>    </strong>field :blog_post, type: :blog_post <strong class="ml iu">do<br/>      </strong>arg(:id, non_null(:id))<br/>      resolve(&amp;BlogAppGql.Web.Blog.PostResolver.find/2)<br/>    <strong class="ml iu">end<br/><br/>    </strong>field :accounts_users, list_of(:accounts_user) <strong class="ml iu">do<br/>      </strong>resolve(&amp;BlogAppGql.Web.Accounts.UserResolver.all/2)<br/>    <strong class="ml iu">end<br/><br/>    </strong>field :accounts_user, :accounts_user <strong class="ml iu">do<br/>      </strong>arg(:email, non_null(:string))<br/>      resolve(&amp;BlogAppGql.Web.Accounts.UserResolver.find/2)<br/>    <strong class="ml iu">end<br/><br/>    mutation do<br/>      field :create_post, type: :blog_post do<br/>        arg(:title, non_null(:string))<br/>        arg(:body, non_null(:string))<br/>        arg(:accounts_user_id, non_null(:id))<br/><br/>        resolve(&amp;BlogAppGql.Web.Blog.PostResolver.create/2)<br/>      end<br/><br/>      field :update_post, type: :blog_post do<br/>        arg(:id, non_null(:id))<br/>        arg(:post, :update_post_params)<br/><br/>        resolve(&amp;BlogAppGql.Web.Blog.PostResolver.update/2)<br/>      end<br/><br/>      field :delete_post, type: :blog_post do<br/>        arg(:id, non_null(:id))<br/>        resolve(&amp;BlogAppGql.Web.Blog.PostResolver.delete/2)<br/>      end<br/>    end<br/>  <br/>  end<br/>end</strong></span></pre><p id="a369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将在后面的部分讨论粗体部分(“突变”)。</p><p id="dc52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于查询部分，我们定义了四个查询。让我们选择一个查询并分析各个部分——</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="261b" class="mp kq it ml b gy mq mr l ms mt">field :accounts_user, <strong class="ml iu">:accounts_user</strong> <strong class="ml iu">do<br/>      </strong>arg(:email, non_null(:string))<br/>      resolve(&amp;BlogAppGql.Web.Accounts.UserResolver.find/2)<br/><strong class="ml iu">end</strong></span></pre><p id="d7bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们定义了一个查询来检索使用电子邮件地址的特定用户。</p><ul class=""><li id="1abf" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn mu ly lz ma bi translated">arg —是传入的参数，它是非空字符串</li><li id="6ac1" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn mu ly lz ma bi translated">BlogAppGql。Web.Accounts.UserResolver.find/2——是解析器函数，它将处理检索用户的BI部分。</li><li id="92a6" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn mu ly lz ma bi translated">accounts_user(上面的粗体字)—是我们自定义的解析类型。如前所述，在<strong class="js iu"> types.ex </strong>中定义如下—</li></ul><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6f43" class="mp kq it ml b gy mq mr l ms mt">object :accounts_user <strong class="ml iu">do<br/>  </strong>field(:id, :id)<br/>  field(:name, :string)<br/>  field(:email, :string)<br/>  field(:posts, list_of(:blog_post), resolve: assoc(:blog_posts))<br/><strong class="ml iu">end</strong></span></pre><p id="9b0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回顾一下上面定义的另一个查询—</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="53eb" class="mp kq it ml b gy mq mr l ms mt">field :blog_posts, list_of(:blog_post) <strong class="ml iu">do<br/>      </strong>resolve(&amp;BlogAppGql.Web.Blog.PostResolver.all/2)<br/><strong class="ml iu">end</strong></span></pre><p id="8e78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，resolved type是在<strong class="js iu"> types.ex </strong>中定义的blog_post类型列表</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bb1a" class="mp kq it ml b gy mq mr l ms mt">object :blog_post <strong class="ml iu">do<br/>  </strong>field(:id, :id)<br/>  field(:title, :string)<br/>  field(:body, :string)<br/>  field(:user, :accounts_user, resolve: assoc(:accounts_user))<br/><strong class="ml iu">end</strong></span></pre><p id="4d87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦定义了查询，我们需要编写解析器函数。我将在这里展示一个用于<strong class="js iu">帐户_用户</strong>的帐户。其他的可以在github代码库中找到。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ce9f" class="mp kq it ml b gy mq mr l ms mt">defmodule BlogAppGql.Web.Accounts.UserResolver <strong class="ml iu">do<br/>  </strong>alias BlogAppGql.Accounts<br/><br/>  def all(_args, _info) <strong class="ml iu">do<br/>    </strong>{:ok, Accounts.list_users()}<br/>  <strong class="ml iu">end<br/><br/>  </strong>def find(%{email: email}, _info) <strong class="ml iu">do<br/>    </strong>case Accounts.get_user_by_email(email) <strong class="ml iu">do<br/>      nil </strong>-&gt; {:error, "User email #{email} not found!"}<br/>      user -&gt; {:ok, user}<br/>    <strong class="ml iu">end<br/>  end<br/>end</strong></span></pre><p id="ba32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这部分是stragihtforward——列出所有用户或使用电子邮件地址检索特定用途。</p><p id="1c26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们使用GraphiQL浏览器来运行它。您需要在端口4000上运行服务器。</p><p id="f9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行一个查询来检索使用电子邮件地址的用户—</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/c0e35c9074524d72c193d42f269dbf9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWACNK_N0oLzPbM7koXFZg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">使用电子邮件地址检索用户</figcaption></figure><p id="2e87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用电子邮件地址运行accountsUser query来检索id、email和name字段。请注意，客户端中的查询名称是<strong class="js iu">驼峰式大小写</strong>。在最右边的部分，你可以看到GraphQL自动生成的文档，这使得编写查询和变异变得很容易。GraphQL还支持定义变量，我们将在稍后编写突变时展示这些变量。</p><p id="cdff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行另一个查询来列出所有的博客帖子—</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/070da738c9af43e218227cb428be1f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiMmwK-DnButrj4BxtU0TA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">列出所有博客文章</figcaption></figure><h1 id="f932" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">编写GraphQL突变</h1><p id="e0d4" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">一旦理解了如何编写查询，编写突变就很容易了。这里，我们定义了三种突变—</p><ol class=""><li id="5414" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">创建帖子—创建博客帖子</li><li id="a6d0" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">update_post —更新博客文章</li><li id="22d5" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">delete_post —删除博客文章</li></ol><p id="7e06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简洁起见，我将只解释update_post。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="aee9" class="mp kq it ml b gy mq mr l ms mt">field :update_post, type: :blog_post do<br/>        arg(:id, non_null(:id))<br/>        arg(:post, :update_post_params)<br/><br/>        resolve(&amp;BlogAppGql.Web.Blog.PostResolver.update/2)<br/>end</span></pre><p id="3ded" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，update post接受两个参数作为输入——一个非null id和一个update_post_params类型的post参数，它保存要更新的输入参数值。它是在类型中定义的。例如—</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="3539" class="mp kq it ml b gy mq mr l ms mt">input_object :update_post_params <strong class="ml iu">do<br/> </strong>field(:title, :string)<br/> field(:body, :string)<br/> field(:accounts_user_id, :id)<br/><strong class="ml iu">end</strong></span></pre><p id="1de2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与以前的类型定义不同的是，它被定义为input_object而不是object。</p><p id="c68f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相应的解析器功能定义如下—</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e519" class="mp kq it ml b gy mq mr l ms mt">def update(%{id: id, post: post_params}, _info) <strong class="ml iu">do<br/>  </strong>case find(%{id: id}, _info) <strong class="ml iu">do<br/>    </strong>{:ok, post} -&gt; post |&gt; Blog.update_post(post_params)<br/>    {:error, _} -&gt; {:error, "Post id #{id} not found"}<br/>  <strong class="ml iu">end<br/>end</strong></span></pre><p id="5ce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用GraphiQL来运行一些突变—</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/5059c869fd89f0dfd6a771cbdd50101b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LnHV34nMQG910EVXxzNjg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">创建一篇博客文章</figcaption></figure><p id="8489" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，方法现在从GET改为POST。</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nh"><img src="../Images/7b6b261686974a5dbb7d3958a3fd746a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLXuOnJTz455WN1GsdFo2Q.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">更新博客文章</figcaption></figure><p id="7c0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们已经定义了一个查询参数来指定要更新的博客文章的id。</p><p id="3889" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，您可以使用其他客户端，特别是如果您正在开发与GraphQL服务器交互的移动应用程序，<a class="ae ko" href="https://www.apollographql.com" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL客户端</a>非常好。</p><p id="18fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望这篇文章能够提供一个坚实的概述，介绍如何使用苦艾酒为Phoenix Web应用程序编写GraphQL服务器。</p><p id="d77a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ni">更多详细和深入的未来技术帖子请关注我这里或点击</em> <a class="ae ko" href="https://twitter.com/meraj_enigma" rel="noopener ugc nofollow" target="_blank"> <em class="ni"> twitter </em> </a> <em class="ni">。</em></p></div></div>    
</body>
</html>