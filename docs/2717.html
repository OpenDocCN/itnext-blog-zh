<html>
<head>
<title>LinkedList in Swift — Code a LinkedList Data Structure in Swift Playgrounds.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的LinkedList—在Swift Playgrounds中编写linked list数据结构。</h1>
<blockquote>原文：<a href="https://itnext.io/linkedlist-in-swift-code-a-linkedlist-data-structure-in-swift-playgrounds-97fe2ed9b8f1?source=collection_archive---------1-----------------------#2019-07-18">https://itnext.io/linkedlist-in-swift-code-a-linkedlist-data-structure-in-swift-playgrounds-97fe2ed9b8f1?source=collection_archive---------1-----------------------#2019-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1a5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目标:在Swift 5和Xcode Playgrounds中创建一个LinkedList。</p><p id="35a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我叫马克斯韦尔·尼尔森，你可以在<a class="ae kl" href="http://maxcodes.io" rel="noopener ugc nofollow" target="_blank"> maxcodes.io </a>或<a class="ae kl" href="http://maxnelson.io" rel="noopener ugc nofollow" target="_blank"> maxnelson.io </a>上找到我</p><h1 id="e6d0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">什么是链接列表？</h1><p id="257a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">LinkedList是节点的集合，每个节点包含数据以及指向集合中上一个和下一个节点的指针。这与数组不同，链表的数据不是按照节点在内存中的物理位置排序的，而是按照它所连接的其他节点排序的。</p><h1 id="91ba" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">节点如何连接？</h1><p id="ec93" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">节点通过指针连接到其他节点。下面是一个单链表的图表，显示了通过指向节点对象的指针连接的每个节点。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/9c6bcea126c038ed80035515e2044148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NogQw64qXZ0xhNqSUgn_oA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">单向链表，指针指向链表中的下一个节点</figcaption></figure><p id="257e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们将创建一个<strong class="jp ir">双向链表</strong>，它的节点不仅包含一个<strong class="jp ir">下一个节点指针</strong>，还包含一个<strong class="jp ir">前一个节点指针。</strong>这个图表展示了双向链表的样子。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/0f14f3caaf7d6588989735f1ae3499a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOdTYTA-VLpSVS2PvCXaRQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">指向链表中下一个节点和上一个节点的双向链表</figcaption></figure><h1 id="1f34" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">头和尾巴</h1><p id="eee1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">第一个和最后一个节点分别称为头和尾。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/81d64453a57b0d382b4c64dc02e46928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7NocQuitDciVu0gfSO6OBg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">-链表图，显示了具有零指针的头节点和尾节点</figcaption></figure><ul class=""><li id="1571" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">头的前一个节点指针为零，因为在它之前没有节点。</li><li id="f24c" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">尾的下一个节点指针为零，因为没有节点跟在它后面。</li></ul><h1 id="2437" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">性能*** </strong></h1><p id="dbdc" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><em class="mt">在本文中了解链表与数组相比的性能:</em><a class="ae kl" href="https://beginnersbook.com/2013/12/difference-between-arraylist-and-linkedlist-in-java/" rel="noopener ugc nofollow" target="_blank">https://beginnersbook . com/2013/12/difference-between-ArrayList-and-linked list-in-Java/</a></p><h1 id="5b6d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">开始编码吧。</h1><p id="2984" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">周密计划的行动方案</p><ul class=""><li id="0be7" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">步骤1 —创建节点类</li><li id="d814" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤2 —创建一个LinkedList类</li><li id="dab6" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤3-提供最后一个节点</li><li id="4a9a" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤4 —添加附加节点的功能</li><li id="c3a3" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤5 —获取链表中的数字节点</li><li id="d768" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤6 —打印链表中的每个节点值</li><li id="4a41" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤7—从指定的索引中提取节点</li><li id="52e7" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤8 —在特定索引处插入一个节点</li><li id="00af" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">步骤9-删除特定索引处的节点</li></ul><h1 id="6e73" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤1-创建节点结构</h1><p id="0c1e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">节点有三个属性</p><ul class=""><li id="b59b" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">一个<strong class="jp ir">值</strong></li><li id="11d9" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">指向列表中下一个节点<strong class="jp ir">的指针</strong></li><li id="9830" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">指向列表中<strong class="jp ir">前一个</strong>节点的指针</li></ul><p id="e575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">仿制药</strong></p><p id="70d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望我们的列表能够使用任何类型，换句话说，我们希望我们的列表是通用的。所以在定义我们的节点结构时，我们确保通过在node后面写<strong class="jp ir"> &lt; T &gt; </strong>来给它一个泛型类型。<a class="ae kl" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank">关于仿制药的更多信息可在Swift文档中找到。</a></p><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="e448" class="mz kn iq mv b gy na nb l nc nd">public class Node&lt;T&gt; {<br/>  var value: T<br/>  var next: Node?<br/>  weak var previous: Node?<br/><br/>  public init(value: T) {<br/>    self.value = value<br/>  }<br/>}</span></pre><p id="de4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意事项</p><ul class=""><li id="08de" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">值的类型是T，所以无论我们给它什么类型。</li><li id="176b" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">下一个和前一个节点是可选的，因为头部没有前一个节点，尾部没有下一个节点。</li></ul><h1 id="8b24" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤2-创建一个链表类</h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="4b5b" class="mz kn iq mv b gy na nb l nc nd">public class LinkedList&lt;T&gt; {<br/><br/>  private var head: Node?<br/><br/>  public var isEmpty: Bool {<br/>    return head == nil<br/>  }<br/><br/>  public var first: Node? {<br/>    return head<br/>  }<br/>}</span></pre><p id="b632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将LinkedList声明为一个泛型类，在标题后面加上<t>，这样我们就可以在链表中使用任何值。在本教程中，我们将使用字符串。</t></p><p id="ba3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在类中，我们提供了一个可选的Node类型的变量head。这将是声明时链表中的第一个值。</p><p id="ab4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还提供了一个布尔变量"<strong class="jp ir"> <em class="mt"> isEmpty </em> " </strong>，如果没有head，它就返回nil。如果head有一个值，那么我们列表确实不是空的，条件检查将返回false。</p><h1 id="fedd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">步骤3——提供最后一个节点来跟踪尾部。</strong></h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="d4cb" class="mz kn iq mv b gy na nb l nc nd">public var last: Node? {<br/>    guard var node = head else {<br/>      return nil<br/>    }<br/>  <br/>    while let next = node.next {<br/>      node = next<br/>    }<br/>    return node<br/>  }</span></pre><p id="04a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过首先检查头部是否有值来访问列表中的最后一个节点。通过这样做，如果头是零，我们可以立即沟通，确实没有最后一个节点，甚至没有一个头开始。</p><p id="31e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果head有值，那么我们需要检查它的下一个节点，看它是否有值，如果有，检查它的下一个值，看它是否有值，以此类推，直到最后一个节点上没有下一个值。</p><p id="778a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当while循环失败时，我们将知道我们已经到达了列表的末尾，我们可以返回最后一个节点。</p><h1 id="4445" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤4 —追加节点</h1><p id="7e64" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们可以添加数据到我们的列表中。</p><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="6752" class="mz kn iq mv b gy na nb l nc nd">public func append(value: T) {<br/>    let newNode = Node(value: value)<br/>    if let lastNode = last {<br/>      newNode.previous = lastNode<br/>      lastNode.next = newNode<br/>    } else {<br/>      head = newNode<br/>    }<br/>  }</span></pre><ul class=""><li id="c96e" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">根据传入的值创建一个新节点</li><li id="0a26" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">检查我们是否有最后一个节点</li><li id="53d8" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果我们有最后一个节点，它的上一个现在等于最后一个节点，它的下一个现在等于新节点。</li></ul><p id="3c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请看这张图，以便更好地理解这里发生了什么。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/26d228857a23cea6d448acd1395194de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNMYKjqLJHGVfWuQPK9zMA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">追加新节点</figcaption></figure><h1 id="81b0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤5 —计算节点数</h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="f2f3" class="mz kn iq mv b gy na nb l nc nd">public var count: Int {<br/>    guard var node = head else {<br/>      return 0<br/>    }<br/>  <br/>    var count = 1<br/>    while let next = node.next {<br/>      node = next<br/>      count += 1<br/>    }<br/>    return count<br/>  }</span></pre><ul class=""><li id="09e4" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">首先检查head是否有值，如果没有，我们简单地返回0</li><li id="b49c" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果head有一个值，那么我们自动知道至少有一个值，所以当我们声明count时，我们从1开始</li><li id="25eb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">使用while循环遍历LinkedList，直到没有node.next，就像我们在查找最后一个节点时到达列表末尾一样。</li><li id="5221" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">当node.next不再有值时，我们知道我们已经到达了尾部，并且我们有了完整的列表计数，返回计数。</li></ul><h1 id="c95b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">第6步—打印我们列表的内容</h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="27dd" class="mz kn iq mv b gy na nb l nc nd">public var print: String {<br/>   var s = "["<br/>   var node = head<br/>   while node != nil {<br/>       s += "\(node!.value)"<br/>       node = node!.next<br/>       if node != nil { s += ", " }<br/>   }<br/>   return s + "]"<br/>}</span></pre><ul class=""><li id="dc4c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">创建一个名为print的公共变量。</li><li id="f676" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将当前节点设置为我们的头节点</li><li id="f7e4" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">使用while循环遍历我们的列表。虽然node不为零，但它必须有一个值，将该值添加到我们的字符串中</li><li id="dbcb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">一旦node.next有了一个值，我们知道我们已经到达了列表的末尾，我们可以继续返回节点的字符串。</li></ul><h1 id="3f71" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤7 —获取给定索引处的节点</h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="d68d" class="mz kn iq mv b gy na nb l nc nd">public func node(atIndex index: Int) -&gt; Node {<br/>    if index == 0 {<br/>        return head!<br/>    } else {<br/>        var node = head!.next<br/>        for _ in 1..&lt;index {<br/>            node = node?.next<br/>            if node == nil { //(*1)<br/>                break<br/>            }<br/>        }<br/>        return node!<br/>    }<br/>}</span></pre><ul class=""><li id="b2c8" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">检查索引是否为0，如果是，那么就返回头。</li><li id="b0a2" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果index不为0，那么使用for循环来遍历我们的节点，直到我们到达索引，如果它不为0，那么返回该节点。</li><li id="cea8" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果其他方法都失败了，只需返回节点</li></ul><h1 id="3512" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤8—在特定索引处插入新节点</h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="2daa" class="mz kn iq mv b gy na nb l nc nd">public func insert(value: T, atIndex index: Int) {<br/>   let newNode = Node(value: value)<br/>   if index == 0 {<br/>       newNode.next = head<br/>       head?.previous = newNode<br/>       head = newNode<br/>   } else {<br/>       let previousNode = self.node(atIndex: index-1)<br/>       let nextNode = previousNode.next<br/><br/>       newNode.previous = previousNode<br/>       newNode.nextNode = previousNode.next<br/>       previousNode.next = newNode<br/>       nextNode?.previous = newNode<br/>   }<br/>}</span></pre><ul class=""><li id="2e40" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">取我们想要插入的值，并用它创建一个Node实例。</li><li id="9670" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果索引为0，只需将新节点的下一个节点设置为我们的头</li><li id="bf4e" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">取头部，设置它在新节点之前</li><li id="62eb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">让头部成为我们的新节点</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><ul class=""><li id="afc5" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果索引不为0，则获取插入位置前一个空格的节点，并将previousNode设置为等于它。</li><li id="7aeb" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">然后用previousNode.next获取它的下一个节点，并设置next Node等于它。</li><li id="7390" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">取newNode的previous，并将其设置为等于previousNode</li><li id="4891" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">获取新节点的下一个节点，并将其设置为等于前一个节点的下一个节点</li><li id="92ec" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">获取前一个节点的下一个节点，并将其分配给新节点</li><li id="3c63" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">获取nextNode的前一个节点，并将其分配给newNode</li></ul><h1 id="8434" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤9-删除给定索引处的节点</h1><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="d4be" class="mz kn iq mv b gy na nb l nc nd">public func remove(node: Node) -&gt; T {<br/>    let previousNode = node.previous<br/>    let nextNode = node.next<br/><br/>    if let previousNode = previousNode {<br/>        previousNode.next = nextNode<br/>    } else {<br/>        head = nextNode<br/>    }<br/>    nextNode?.previous = previousNode<br/><br/>    node.previous = nil<br/>    node.next = nil<br/>    return node.value<br/>}</span><span id="7c01" class="mz kn iq mv b gy nl nb l nc nd">public func removeAt(_ index: Int) -&gt; T {<br/>    let nodeToRemove = node(atIndex: index)<br/>    return remove(node: nodeToRemove)<br/>}</span></pre><ul class=""><li id="995f" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">接受要移除的节点，并将previousNode设置为节点的previous</li><li id="0f71" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">对nextNode分别做同样的事情</li><li id="650c" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果前一个节点存在，则获取它的下一个节点，并将其分配给我们要删除的节点的下一个节点</li><li id="e95a" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果我们要删除的节点的previousNode不存在，那么将head设置为等于下一个节点，因为它的previousNode是头，所以它现在是头</li><li id="f8d5" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">将nextNode的previous设置为要删除的节点的previous节点</li><li id="5f5d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">获取我们要删除的节点，并释放对其他节点的所有引用</li><li id="d37e" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">返回值告诉我们刚刚删除了哪个</li></ul><p id="e78e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在使用该函数之前，我们需要从我们提供的值中获取节点，因为我们不能只创建节点并将其传入</p><ul class=""><li id="c3f0" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">获取我们试图移除的节点的索引，并获取该索引处的节点</li><li id="9e93" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">用我们刚刚写的方法删除节点</li></ul><h1 id="1637" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">那都是乡亲。</strong></h1><p id="a49a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我知道我是否错过了什么，我会尽快更新这篇文章。</p><p id="06a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想在Swift中构建<a class="ae kl" href="https://www.udemy.com/swiftdatastructures/?couponCode=MEDIUMSPECIAL" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">通用数据结构，在我最新的课程中，将从头开始介绍LinkedList和Array类开发</strong> </a>。<a class="ae kl" href="https://www.udemy.com/swiftdatastructures/?couponCode=MEDIUMSPECIAL" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="mt">这里有打折优惠券代码！</em> </strong> </a></p></div></div>    
</body>
</html>