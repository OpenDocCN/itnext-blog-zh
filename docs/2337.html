<html>
<head>
<title>Sidecar for a Code Splitting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于代码分割的边车</h1>
<blockquote>原文：<a href="https://itnext.io/sidecar-for-a-code-splitting-65c1fb205dfd?source=collection_archive---------10-----------------------#2019-05-07">https://itnext.io/sidecar-for-a-code-splitting-65c1fb205dfd?source=collection_archive---------10-----------------------#2019-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0af74feda3405df9100700c41adb84f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDodx7sbmwyAH_xfgltRNg.png"/></div></div></figure><p id="1252" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码分割。代码拆分无处不在。但是为什么呢？仅仅因为现在有太多的javascript，而且不是所有的都在同一时间使用。</p><p id="f0f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JS是一个很<em class="kw">重</em>的东西。不是为你的iPhone Xs或全新的i9笔记本电脑，而是为数百万(可能数十亿)速度较慢的设备拥有者。或者至少是你的手表。</p><p id="e634" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以- JS是不好的，但是如果我们<strong class="ka ir">禁用它</strong>会发生什么呢-问题会消失...对于一些网站来说，和基于React的网站一起消失。但是不管怎样，有些网站不需要JS也能工作...我们应该向他们学习一些东西...</p><h1 id="8edb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码分割</h1><p id="1a95" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">今天，我们有两条路可走，两条让它变得更好或不变得更糟的路:</p><h1 id="2124" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">1.少写代码</h1><p id="9264" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">那是你能做的最好的事情。虽然<code class="fe ma mb mc md b">React Hooks</code>让你发布更少的代码，像<code class="fe ma mb mc md b">Svelte</code>这样的解决方案让你生成的代码比<em class="kw">通常的</em>要少，但这并不容易做到。</p><p id="6d31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不仅是关于代码，也是关于<em class="kw">功能</em>——为了保持代码“紧凑”，你必须保持它“紧凑”。如果application bundle要做这么多事情(并且有20种语言版本)，就没有办法保持它的小。</p><p id="54c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有办法写出<em class="kw">短小健全的</em>代码，也有办法写出相反的实现——<em class="kw">血淋淋的企业</em>。你知道，两者都是合法的。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ee01d9bbd34153240966180f47178d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58NAbEK82UcGU-LVzz46qQ.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">苗条是一种享受</figcaption></figure><p id="0cbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但主要问题是代码本身。一个简单的react应用程序可以轻松绕过“推荐”的250kb。你可能会花一个月的时间优化它，让它变得更小。“小”优化有据可查，非常有用——只要用<code class="fe ma mb mc md b">size-limit</code>得到<code class="fe ma mb mc md b">bundle-analyzer</code>,然后恢复原状。<br/>有许多库，它们争夺每一个字节，试图让你保持在你的极限内——<a class="ae mn" href="https://preactjs.com/" rel="noopener ugc nofollow" target="_blank">preact</a>和<a class="ae mn" href="https://github.com/storeon/storeon" rel="noopener ugc nofollow" target="_blank"> storeon </a>等等。</p><p id="cf30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们的应用程序超过了200kb。更接近<strong class="ka ir"> 100Mb </strong>。删除千字节没有意义。即使删除兆字节也没有意义。</p><blockquote class="mo mp mq"><p id="5ec4" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">过一段时间后，你就不可能再让你的应用程序变小了。它会慢慢变大。</p></blockquote><h1 id="62c8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">2.无船代码</h1><p id="731e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">或者，<code class="fe ma mb mc md b">code split</code>。换句话说——<strong class="ka ir">投降</strong>。拿你的100mb包，做20个5mb包。老实说——如果你的应用程序变大了，这是唯一可能的处理方法——用它创建一个小应用程序包。</p><blockquote class="mo mp mq"><p id="2d05" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">既然我们正在讨论它，你可能希望确保自己了解2019年React代码拆分的最新和最大进展。或者只是阅读一些实现细节。</em></p></blockquote><div class="mu mv gp gr mw mx"><a rel="noopener  ugc nofollow" target="_blank" href="/react-code-splitting-in-2019-9a5d2776c502"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">2019年反应代码拆分</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">都2019年了！每个人都认为他们知道代码分解。所以——让我们仔细检查一下！</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">itnext.io</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jw mx"/></div></div></a></div><p id="ff0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在有一件事你应该知道:无论你选择哪个选项，它都是一个实现细节，而我们正在寻找更可靠的东西。</p><h1 id="64c8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关于代码分割的真相</h1><p id="b3e3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">关于代码拆分的真相是，其本质是<strong class="ka ir">时间分隔</strong>。你不仅仅是<em class="kw">分割</em>你的代码，你还以一种方式分割它，你将<strong class="ka ir">在单个时间点尽可能少地使用</strong>。</p><p id="751f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只是不要发布你现在不需要的代码。摆脱它。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/6249a6846f1c72a34408547571a84396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OAWo6dJ8lqjfhYOzZLknA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">摆脱它！</figcaption></figure><p id="3bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说起来容易，做起来难。我有几个沉重的，但没有充分分裂的应用程序，其中任何一个页面加载了大约50%的东西。有时<code class="fe ma mb mc md b">code splitting</code>变成了<code class="fe ma mb mc md b">code separation</code>，我的意思是——你可以将代码移动到不同的块中，但是仍然要全部使用。回想一下<em class="kw">“不要发布你现在不需要的代码”</em>，我<em class="kw">需要</em> 50%的代码，这才是真正的问题。</p><blockquote class="mo mp mq"><p id="a504" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">有时仅仅在这里加上</em> <code class="fe ma mb mc md b"><em class="iq">import</em></code> <em class="iq">并不够。直到不是</em> <strong class="ka ir"> <em class="iq">时间</em> </strong> <em class="iq">分离，而仅仅是</em> <strong class="ka ir"> <em class="iq">空间</em> </strong> <em class="iq">分离——这根本无关紧要。</em></p></blockquote><p id="8357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有3种常见的代码拆分方式:</p><ol class=""><li id="e753" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated">只是动态<code class="fe ma mb mc md b">import</code>。这几天很少单独使用。更多的是关于跟踪一个<em class="kw">状态</em>的问题。</li><li id="276c" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><code class="fe ma mb mc md b">Lazy</code>组件，当您可能推迟React组件的渲染和加载时。如今大概90%的“反应代码分割”。</li><li id="7521" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><em class="kw">懒</em> <code class="fe ma mb mc md b">Library</code>，其实就是<code class="fe ma mb mc md b">.1</code>，不过会通过React渲染道具给你一个库码。在<a class="ae mn" href="https://github.com/theKashey/react-imported-component#library-level-code-splitting" rel="noopener ugc nofollow" target="_blank">反应导入组件</a>和<a class="ae mn" href="https://www.smooth-code.com/open-source/loadable-components/docs/library-splitting/" rel="noopener ugc nofollow" target="_blank">可加载组件</a>中实现。相当有用，但不太为人所知。</li></ol><h1 id="8100" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">组件级代码拆分</h1><p id="c9e7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这个是最受欢迎的。作为每路由代码分割或每组件代码分割。要做到这一点并最终保持良好的感知效果并不容易。从<code class="fe ma mb mc md b">Flash of Loading Content</code>开始就是死亡。</p><p id="f2bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的技巧是:</p><ul class=""><li id="8a95" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">加载<code class="fe ma mb mc md b">js chunk</code>和<code class="fe ma mb mc md b">data</code>为并行路线。</li><li id="464e" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">使用<code class="fe ma mb mc md b">skeleton</code>在页面加载之前显示类似页面的内容(如脸书)。</li><li id="4471" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated"><code class="fe ma mb mc md b">prefetch</code>组块，你甚至可以使用<a class="ae mn" href="https://github.com/guess-js/guess" rel="noopener ugc nofollow" target="_blank"> guess-js </a>进行更好的预测。</li><li id="5128" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">使用一些延迟、加载指示器、<code class="fe ma mb mc md b">animations</code>和<code class="fe ma mb mc md b">Suspense</code>(将来)来软化过渡。</li></ul><p id="8551" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且，你知道，那都是感性表现。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/569b17a74d7183eb5c798315cc735337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Wc3x4mwsFmozK9w0dJj0A.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated"><em class="od">图片来自</em> <a class="ae mn" href="https://blog.angularindepth.com/https-medium-com-thomasburleson-animated-ghosts-bfc045a51fba" rel="noopener ugc nofollow" target="_blank"> <em class="od">用幽灵元素改良的UX</em></a></figcaption></figure><h1 id="336b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">那听起来不太好</h1><p id="ccd3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你知道，我可以称自己为代码分解专家，但我也有自己的失败。</p><p id="f065" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我可能无法减少包的大小。有时我可能无法提高结果性能，只要<code class="fe ma mb mc md b">the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *。这叫做<strong class="ka ir">装载波</strong>。</p><ul class=""><li id="d16d" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">没有SSR或预渲染。适当的SSR是目前的游戏改变者。</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/ebada71f02b0fa3d6bb90efc5e9056b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhoQa9838eFBKM3h7D6eLA.jpeg"/></div></div></figure><p id="ea3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上周我经历了两次失败:</p><ul class=""><li id="3db7" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">我已经在<a class="ae mn" href="https://github.com/mui-org/material-ui/issues/15450" rel="noopener ugc nofollow" target="_blank">一库比对</a>中输了；即使我的图书馆更好，😉它比另一个大得多。我失败了。少写代码。</li><li id="6f11" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">优化一个小网站，由我的妻子在React。它使用基于路由的组件拆分，但是<code class="fe ma mb mc md b">header</code>和<code class="fe ma mb mc md b">footer</code>被保留在主包中，以使转换更“可接受”。就这么几件事，<strong class="ka ir">互相紧耦合</strong>把bundle side暴涨到320 kb(gzip之前)。没有什么重要的东西，也没有什么我真的可以拿走的东西。<strong class="ka ir">千刀万剐</strong>。我的<strong class="ka ir">出货失败代码</strong>。</li></ul><blockquote class="mo mp mq"><p id="b9fc" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq"> React-Dom占20%，core-js占10%，react-router，jsLingui，react-powerplug...20%的自有代码...我们已经做完了。</em></p></blockquote><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/463f9d4f1e3bd32070f163ef71eeb8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bpEgbwFT2cIhRUW-T-qvw.png"/></div></div></figure><h1 id="bc0d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决方案</h1><p id="abe5" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我已经开始思考如何解决我的问题，以及为什么<em class="kw">常见的解决方案对于我的用例</em>不能正常工作。</p><blockquote class="mo mp mq"><p id="1ce6" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">我做了什么？我列出了所有重要的位置，没有这些位置应用程序根本无法运行，并试图理解为什么我还有其他的位置。</em></p></blockquote><p id="6c44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个惊喜。但是我的问题出在CSS上。在普通的CSS转换中。</p><p id="ecca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是代码</p><ul class=""><li id="9c42" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">一个<em class="kw">控制</em>变量- <code class="fe ma mb mc md b">componentControl</code>，最终将被设置为<code class="fe ma mb mc md b">DisplayData</code>应该显示的内容。</li><li id="9083" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">一旦设定值- <code class="fe ma mb mc md b">DisplayData</code>变得可见，改变<code class="fe ma mb mc md b">className</code>，从而触发花式过渡。同时<code class="fe ma mb mc md b">FocusLock</code>被激活，使<code class="fe ma mb mc md b">DisplayData</code>成为<strong class="ka ir">模态</strong>。</li></ul><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="00e2" class="ok ky iq md b gy ol om l on oo">&lt;FocusLock<br/> enabled={componentControl.value} <br/> // ^ it's "disabled". When it's disabled - it's dead.<br/>&gt;<br/>  {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;}<br/>  // ^ it's does not exists. Also dead<br/>  &lt;DisplayData<br/>    data={componentControl.value}<br/>    visible={componentControl.value !== null}<br/>    // ^ would change a className basing on visible state<br/>  /&gt;<br/>  // ^ that is just not visible, but NOT dead<br/>&lt;/FocusLock&gt;</span></pre><p id="d068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想将这段代码作为一个整体进行拆分，但这是我做不到的，原因有两个:</p><ol class=""><li id="0a78" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated">一旦需要，信息应该立即可见，没有任何延迟。业务需求。</li><li id="e892" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated">信息“铬”应该存在之前，属性处理过渡。</li></ol><p id="62ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<a class="ae mn" href="https://github.com/reactjs/react-transition-group" rel="noopener ugc nofollow" target="_blank">CSS转换组</a>或<a class="ae mn" href="https://github.com/theKashey/recondition" rel="noopener ugc nofollow" target="_blank">修复</a>可以部分解决该问题。但是，你知道，修复<em class="kw">一个代码</em>添加<em class="kw">另一个代码</em>听起来很奇怪，即使实际上<em class="kw">足够了</em>。我的意思是添加更多的代码可以帮助删除更多的代码。但是...但是...</p><blockquote class="mo mp mq"><p id="e8e7" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">应该有更好的办法！</em></p></blockquote><p id="7c5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TL；博士——这里有两个关键点:</p><ul class=""><li id="aae9" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated"><code class="fe ma mb mc md b">DisplayData</code>必须被<strong class="ka ir">挂载</strong>，并且之前存在于DOM中。</li><li id="8f19" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated"><code class="fe ma mb mc md b">FocusLock</code>也应该存在在先，不会导致<code class="fe ma mb mc md b">DisplayData</code>重新挂载，但是<strong class="ka ir">一开始不需要</strong>的大脑。</li></ul></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="1df1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们改变我们的思维模式</p><h1 id="113e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">蝙蝠侠和罗宾</h1><p id="ed72" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">假设我们的代码是蝙蝠侠和罗宾。蝙蝠侠可以对付大多数的坏人，但是当他不能的时候，他的伙伴罗宾会来拯救他..</p><blockquote class="mo mp mq"><p id="6ed5" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">蝙蝠侠将再次投入战斗，罗宾将稍后到达。</p></blockquote><p id="7bf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是蝙蝠侠:</p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="59ac" class="ok ky iq md b gy ol om l on oo">+&lt;FocusLock<br/>- enabled={componentControl.value} <br/>+&gt;<br/>-  {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;}<br/>+  &lt;DisplayData<br/>+    data={componentControl.value}<br/>+    visible={componentControl.value !== null}<br/>+  /&gt;<br/>+&lt;/FocusLock&gt;</span></pre><p id="a09c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是他的伙伴，罗宾:</p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="ca37" class="ok ky iq md b gy ol om l on oo">-&lt;FocusLock<br/>+ enabled={componentControl.value} <br/>-&gt;<br/>+  {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;}<br/>-  &lt;DisplayData<br/>-    data={componentControl.value}<br/>-    visible={componentControl.value !== null}<br/>-  /&gt;<br/>-&lt;/FocusLock&gt;</span></pre><p id="c829" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">蝙蝠侠和罗宾可以组成一个<em class="kw">团队</em>，但他们实际上是两个不同的人。</p><p id="6be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且别忘了——我们还在讨论<strong class="ka ir">代码拆分</strong>。并且，在代码分割方面，助手在哪里？罗宾在哪里？</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b945b6bb394a61d68c75f043f8172db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*g2bw-HIVhiinsdIaHKTiuA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated"><em class="od">在边车里。罗宾正等在一辆</em> <strong class="bd kz"> <em class="od">边车的大块</em> </strong> <em class="od">。</em></figcaption></figure><h1 id="2468" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">边车</h1><ul class=""><li id="9c9c" class="nn no iq ka b kb lv kf lw kj ox kn oy kr oz kv ob nt nu nv bi translated"><code class="fe ma mb mc md b">Batman</code>这些都是你的顾客必须尽快看到的视觉材料。最好是立刻。</li><li id="0a80" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">这里是所有的逻辑和奇特的交互功能，它们可能在一秒钟后可用，但不是在一开始。</li></ul><p id="9579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最好称之为<strong class="ka ir">垂直代码分割</strong>，其中代码分支平行存在，与常见的<strong class="ka ir">水平代码分割</strong>相反，其中代码分支被<em class="kw">切割</em>。</p><p id="cf2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae mn" href="https://github.com/respond-framework/rudy" rel="noopener ugc nofollow" target="_blank">一些地方</a>，这三人组被称为<code class="fe ma mb mc md b">replace reducer</code>或其他方式来延迟加载redux逻辑和副作用。</p><p id="8e91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在其他一些国家，它被称为<code class="fe ma mb mc md b">"3 Phased" code splitting</code>。</p><blockquote class="mo mp mq"><p id="ea8f" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">这只是另一种关注点分离，只适用于这样的情况，你可以延迟加载组件的某个部分，但不能延迟加载另一个部分。</p></blockquote><div class="mf mg mh mi gt ab cb"><figure class="pa jr pb pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/f64c9f260e6727bf701c72c7a7d08596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MHxMaoU0L4sLTkWwS2j3xw.jpeg"/></div></figure><figure class="pa jr pb pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/5a87bfb9479a6b007ddc9e9905d463ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*44LbejTMagYToBWy1sb8-g.jpeg"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk pg di ph pi translated">" loadAfter "，" lazyLoad "，" loadForInteractivity "</figcaption></figure></div><blockquote class="mo mp mq"><p id="e826" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">图片来自</em> <a class="ae mn" href="https://developers.facebook.com/videos/2019/building-the-new-facebookcom-with-react-graphql-and-relay/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">建筑新facebook.com用React、GraphQL和Relay </em> </a> <em class="iq">，其中</em> <code class="fe ma mb mc md b"><em class="iq">importForInteractions</em></code> <em class="iq">，或者</em> <code class="fe ma mb mc md b"><em class="iq">importAfter</em></code> <em class="iq"> </em> <strong class="ka ir"> <em class="iq">都是</em> </strong> <code class="fe ma mb mc md b"><strong class="ka ir"><em class="iq">sidecar</em></strong></code> <em class="iq">。</em></p></blockquote><p id="d433" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一个<strong class="ka ir">有趣的</strong>观察——虽然<code class="fe ma mb mc md b">Batman</code>对顾客来说更有价值，只要是顾客可能<em class="kw">看到</em>的东西，他总是在状态...而<code class="fe ma mb mc md b">Robin</code>，你知道，他可能有点<em class="kw">超重</em>，需要更多的字节来生活。</p><p id="3989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，对于顾客来说，蝙蝠侠是可以忍受的，他以更低的成本提供了更多的价值。你是我的英雄蝙蝠！</p><h1 id="fc8b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么可以移到边车:</h1><ul class=""><li id="4c81" class="nn no iq ka b kb lv kf lw kj ox kn oy kr oz kv ob nt nu nv bi translated"><code class="fe ma mb mc md b">useEffect</code>、<code class="fe ma mb mc md b">componentDidMount</code>和朋友居多。</li><li id="54fe" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">喜欢所有的<em class="kw">模态</em>效果。即<code class="fe ma mb mc md b">focus</code>和<code class="fe ma mb mc md b">scroll</code>锁。你可以先展示一个模态，然后<strong class="ka ir">才</strong>让模态<em class="kw">模态</em>，即“锁定”客户的注意力。</li><li id="2f31" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">表格。将所有逻辑和验证转移到边车上，并阻止表单提交，直到逻辑加载完毕。客户可能开始填写表格，而不知道这只是<code class="fe ma mb mc md b">Batman</code>。</li><li id="01d7" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">一些动画。我这一整<code class="fe ma mb mc md b">react-spring</code>。</li><li id="9f9a" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">一些视觉上的东西。比如<a class="ae mn" href="https://github.com/theKashey/React-stroller" rel="noopener ugc nofollow" target="_blank">自定义滚动条</a>，它可能会在一秒钟后显示精美的滚动条。🤷‍♂️设计师🤷‍♂️</li></ul><p id="4aea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，不要忘记——卸载到sidecar的每一段代码，也卸载被删除的代码使用的core-js poly-和ponyfills之类的东西。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pj"><img src="../Images/e9f6d994b4c8dd5f21becc60c307e64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RbyFK3E3g63BFHFsHG4hQ.jpeg"/></div></div></figure><p id="3882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码分割可以比我们今天的应用程序更加智能。我们必须意识到有两种<em class="kw">代码</em>要分割:1)视觉方面2)交互方面。后者可以稍后出现。<code class="fe ma mb mc md b">Sidecar</code>让两个任务的分割变得天衣无缝，让<em class="kw">感觉一切都加载得更快了</em>。它会的。</p><h1 id="4f95" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最古老的编码分割方法</h1><p id="387c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">虽然可能还不太清楚什么时候以及什么是<code class="fe ma mb mc md b">sidecar</code>，但我会给出一个简单的解释:</p><blockquote class="mo mp mq"><p id="46a7" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><code class="fe ma mb mc md b"><em class="iq">Sidecar</em></code> <em class="iq">是</em> <strong class="ka ir"> <em class="iq">所有你的剧本</em> </strong> <em class="iq">。Sidecar是我们今天得到所有前端东西之前进行代码分割的方式。</em></p></blockquote><p id="01c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我说的是服务器端渲染(<strong class="ka ir"> SSR </strong>)，或者只是普通的<strong class="ka ir"> HTML </strong>，我们昨天都已经习惯了。<code class="fe ma mb mc md b">Sidecar</code>当页面包含的HTML和逻辑分别位于可嵌入的外部脚本中时，事情就像以前一样简单了(关注点分离)。</p><p id="91d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有HTML、<strong class="ka ir">加上</strong> CSS、<strong class="ka ir">加上</strong>一些内联的脚本、<strong class="ka ir">加上</strong>其余的脚本提取到一个<code class="fe ma mb mc md b">.js</code>文件中。</p><p id="bb7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">HTML</code> + <code class="fe ma mb mc md b">CSS</code> + <code class="fe ma mb mc md b">inlined-js</code>是<code class="fe ma mb mc md b">Batman</code>，而外部脚本是<code class="fe ma mb mc md b">Robin</code>，该网站能够在没有罗宾的情况下运行，老实说，部分没有蝙蝠侠(他将在双腿(内联脚本)骨折的情况下继续战斗)。这只是昨天的事，许多“非现代和酷”的网站今天也是如此。</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="8657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你的应用支持SSR——尝试<strong class="ka ir">禁用js </strong>,让它在没有它的情况下也能工作。这样就能清楚地知道什么东西可以搬到边车里。<br/>如果你的应用程序是一个客户端专用的SPA——试着想象一下，如果SSR存在，它将如何工作。</p><blockquote class="mo mp mq"><p id="8603" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">举个例子——</em><a class="ae mn" href="https://theurge.com/en-au/" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">，在React中写的，是全功能</em> <strong class="ka ir"> <em class="iq">而没有</em> </strong> <em class="iq"> </em> <strong class="ka ir"> <em class="iq">任何js</em></strong><em class="iq"/><strong class="ka ir"><em class="iq">启用</em> </strong> <em class="iq">。</em></p></blockquote><p id="469e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多东西你可以卸到一个边车。例如:</p><ul class=""><li id="5958" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">评论。您可以将代码发布到<code class="fe ma mb mc md b">display</code>注释，而不是<code class="fe ma mb mc md b">answer</code>，只要它可能需要更多的代码(包括WYSIWYG编辑器)，这在最初是不需要的。延迟一个<em class="kw">评论框</em>，甚至只是将代码加载隐藏在动画后面，比延迟一整页要好。</li><li id="ead4" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">视频播放器。运送没有“控制”的“视频”。一秒钟后加载，他们的客户可能会尝试与它互动。</li><li id="482e" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">图片库，像<code class="fe ma mb mc md b">slick</code>。用<strong class="ka ir">画</strong>它没什么大不了的，但是动画制作和管理起来要困难得多。很清楚什么可以被移到边车。</li></ul><blockquote class="mo mp mq"><p id="c9be" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">想想什么对你的应用程序是必不可少的，什么不太重要...</em></p></blockquote><h1 id="9c06" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实施细节</h1><h1 id="e09f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">(二)组件代码拆分</h1><p id="e6b4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最简单的形式<code class="fe ma mb mc md b">sidecar</code>很容易实现——只要把所有东西都移到一个子组件中，你就可以用一种“旧”的方式进行代码拆分。这几乎是智能组件和非智能组件之间的一个分离，但是这次智能组件并不包含非智能组件——它是相反的。</p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="910b" class="ok ky iq md b gy ol om l on oo">const SmartComponent = React.lazy( () =&gt; import('./SmartComponent'));<br/><br/>class DumbComponent extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>       &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside<br/>       &lt;TheActualMarkup /&gt;           // &lt;-- the "real" stuff is here<br/>      &lt;/React.Fragment&gt;<br/>  } <br/>}</span></pre><p id="aa70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也需要将<em class="kw">初始化</em>代码移动到一个哑代码中，但是你仍然能够对代码中最重的<em class="kw">部分进行代码分割。</em></p><blockquote class="mo mp mq"><p id="f3b7" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">你现在能看到一个</em> <code class="fe ma mb mc md b"><em class="iq">parallel</em></code> <em class="iq">或者</em> <code class="fe ma mb mc md b"><em class="iq">vertical</em></code> <em class="iq">的分码图案吗？</em></p></blockquote><h1 id="51d0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用边车</h1><p id="51dd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><a class="ae mn" href="https://developers.facebook.com/videos/2019/building-the-new-facebookcom-with-react-graphql-and-relay/" rel="noopener ugc nofollow" target="_blank">用React、GraphQL和Relay </a>建造新的facebook.com，我已经在这里提到过，有一个<code class="fe ma mb mc md b">loadAfter</code>或<code class="fe ma mb mc md b">importForInteractivity</code>的概念，这很像sidecar的概念。</p><p id="0c87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，我不建议创建类似于<code class="fe ma mb mc md b">useSidecar</code>的东西，只要你可能有意尝试在里面使用<code class="fe ma mb mc md b">hooks</code>，但是这种形式的代码分割会打破挂钩的<em class="kw">规则。</em></p><p id="18bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请选择更具声明性的组件方式。您可能会在<code class="fe ma mb mc md b">SideCar</code>组件中使用<code class="fe ma mb mc md b">hooks</code>。</p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="0be0" class="ok ky iq md b gy ol om l on oo">const Controller = React.lazy( () =&gt; import('./Controller'));<br/>const DumbComponent = () =&gt; {<br/> const ref = useRef();<br/> const state = useState();<br/><br/> return (<br/>  &lt;&gt;<br/>   &lt;Controller componentRef={ref} state={state} /&gt;<br/>   &lt;TheRealStuff ref={ref} state={state[0]} /&gt;<br/>  &lt;/&gt;<br/> )<br/>}</span></pre><h1 id="12a2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">预取</h1><p id="bd42" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">别忘了——你可以使用<a class="ae mn" href="https://medium.com/webpack/link-rel-prefetch-preload-in-webpack-51a52358f84c" rel="noopener">装载优先级提示</a>来预载或预取<code class="fe ma mb mc md b">sidecar</code>并使其更加透明和不可见。</p><p id="ae2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的东西——预取脚本会通过<strong class="ka ir">网络</strong>加载它，但不会执行(并消耗CPU)，除非它确实需要。</p><h1 id="1892" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">苏维埃社会主义共和国</h1><p id="05ec" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">与<em class="kw">正常的</em>代码分割不同，SSR不需要任何特殊动作。<code class="fe ma mb mc md b">Sidecar</code>可能不是SSR流程的一部分，在<code class="fe ma mb mc md b">hydration</code>步骤之前不需要。它可以被“故意”推迟。</p><p id="dbcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此——随意使用<code class="fe ma mb mc md b">React.lazy</code>(理想的是没有 <code class="fe ma mb mc md b">Suspense</code>的<strong class="ka ir">，这里你不需要任何回切(加载)指示器)，或者任何其他库，有SSR支持，但是没有SSR支持更好，在SSR过程中跳过边车块。</strong></p><h1 id="37e2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不好的部分</h1><p id="5a4a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">但是这个想法也有一些不好的地方</p><h1 id="0d10" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">蝙蝠侠不是一个产品名称</h1><p id="4934" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">虽然<code class="fe ma mb mc md b">Batman</code> / <code class="fe ma mb mc md b">Robin</code>可能是一个很好的概念，而且<code class="fe ma mb mc md b">sidecar</code>与技术本身非常匹配，但是对于<code class="fe ma mb mc md b">maincar</code>来说没有“好”的名字。没有所谓的<code class="fe ma mb mc md b">maincar</code>，显然<code class="fe ma mb mc md b">Batman</code>、<code class="fe ma mb mc md b">Lonely Wolf</code>、<code class="fe ma mb mc md b">Solitude</code>、<code class="fe ma mb mc md b">Driver</code>、<code class="fe ma mb mc md b">Solo</code>不能用来命名非边车零件。</p><p id="4702" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">脸书使用了<code class="fe ma mb mc md b">display</code>和<code class="fe ma mb mc md b">interactivity</code>，这对我们来说可能是最好的选择。</p><blockquote class="mo mp mq"><p id="0899" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">如果你有一个好名字给我，请在评论中留下</p></blockquote><h1 id="95b9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">树摇晃</h1><p id="241c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">更多的是从bundler的角度来分离关注点。假设你有<code class="fe ma mb mc md b">Batman</code>和<code class="fe ma mb mc md b">Robin</code>。和<code class="fe ma mb mc md b">stuff.js</code></p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="9e1e" class="ok ky iq md b gy ol om l on oo">export * from `./batman.js`<br/>export * from `./robin.js`</span></pre><p id="7f77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后你可以尝试基于<em class="kw">组件的</em>代码分割来实现sidecar</p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="e57a" class="ok ky iq md b gy ol om l on oo">//main.js<br/>import {batman} from './stuff.js'<br/><br/>const Robin = React.lazy( () =&gt; import('./sidecar.js'));<br/><br/>export const Component = () =&gt; (<br/>  &lt;&gt;<br/>   &lt;Robin /&gt;  // sidecar<br/>   &lt;Batman /&gt; // main content<br/>  &lt;/&gt;<br/>)<br/><br/>// and sidecar.js... that's another chunk as long as we `import` it<br/>import {robin} from './stuff.js'<br/>.....</span></pre><p id="74cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，上面的代码可以工作，但是不能“工作”。</p><ul class=""><li id="a734" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">如果你只使用来自<code class="fe ma mb mc md b">stuff.js</code>的<code class="fe ma mb mc md b">batman</code>-树摇动将只保留它。</li><li id="6940" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">如果你只使用<code class="fe ma mb mc md b">stuff.js</code>中的<code class="fe ma mb mc md b">robin</code>-树抖动将只保留它。</li><li id="f5a2" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated"><strong class="ka ir">但是</strong>如果你同时使用两者，即使是在不同的块中——两者都将被捆绑在<code class="fe ma mb mc md b">stuff.js</code>的第一个事件<strong class="ka ir">中，即<strong class="ka ir">主捆绑包</strong>。</strong></li></ul><blockquote class="mo mp mq"><p id="7925" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">树摇不是代码分裂友好。您必须通过文件来分离关注点。</em></p></blockquote><h1 id="cb83" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">取消导入</h1><p id="af6b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">另一件被大家遗忘的事情是javascript的成本。这在jQuery时代很常见，在这个时代，<code class="fe ma mb mc md b">jsonp</code>有效负载加载脚本(使用<code class="fe ma mb mc md b">json</code>有效负载)，获取有效负载，<strong class="ka ir">移除</strong>脚本。</p><blockquote class="mo mp mq"><p id="4ad6" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">如今我们所有的脚本都将永远被导入，即使不再需要。</p></blockquote><p id="d1f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像我之前说的——JS太多了，迟早有一天，有了<em class="kw">连续导航</em>你会把它全部载入。我们应该找到一种方法来取消导入不再需要的块，清除所有内部缓存并释放内存，以使web更加可靠，而不是因为内存不足异常而崩溃应用程序。</p><p id="605a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大概<code class="fe ma mb mc md b">un-import</code> (webpack <a class="ae mn" href="https://github.com/theKashey/wipeWebpackCache" rel="noopener ugc nofollow" target="_blank">可以做到</a>)的能力是我们应该坚持使用<em class="kw">基于组件的</em> API的原因之一，只要它能给我们处理<code class="fe ma mb mc md b">unmount</code>的能力。</p><p id="328a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止——ESM模块标准没有关于这类东西的内容——也没有关于缓存控制的内容，也没有关于撤销导入操作的内容。</p><h1 id="7e59" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建支持边盘的库</h1><p id="4b28" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">到目前为止，只有一种方法可以创建支持<code class="fe ma mb mc md b">sidecar</code>的库:</p><ul class=""><li id="c82b" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ob nt nu nv bi translated">将您的组件拆分成几个部分</li><li id="83c8" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">通过<code class="fe ma mb mc md b">index</code>暴露一个<code class="fe ma mb mc md b">main</code>部分和<code class="fe ma mb mc md b">connected</code>部分(不破坏API)</li><li id="2df8" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">通过一个单独的入口点暴露一个<code class="fe ma mb mc md b">sidecar</code>。</li><li id="2a39" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">在目标代码中-导入<code class="fe ma mb mc md b">main</code>零件和<code class="fe ma mb mc md b">sidecar</code> -树摇动应该切割一个<code class="fe ma mb mc md b">connected</code>零件。</li></ul><p id="655b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次树摇动应该正常工作，唯一的问题是如何命名<code class="fe ma mb mc md b">main</code>部分。</p><pre class="mf mg mh mi gt og md oh oi aw oj bi"><span id="2049" class="ok ky iq md b gy ol om l on oo">//main.js<br/>export const Main = ({sidecar, ...props}) =&gt; (<br/>  &lt;div&gt;<br/>    {sidecar} <br/>    ....<br/>  &lt;/div&gt;<br/>);<br/><br/>// connected.js<br/>import Main from './Component';<br/>import Sidecar from './Sidecar';<br/><br/>export const Connected = props =&gt; (<br/>  &lt;Main<br/>    sidecar={&lt;Sidecar /&gt;}<br/>    {...props}<br/>  /&gt;<br/>);<br/><br/>//index.js<br/>export * from './Main';<br/>export * from './Connected';<br/><br/>//sidecar.js<br/>import * from './Sidecar';<br/><br/>// -------------------------<br/><br/>//your app BEFORE<br/>import {Connected} from 'library'; //<br/><br/>// -------------------------<br/><br/>//your app AFTER, compare to `connected.js`<br/>import {Main} from 'library';<br/>const Sidecar = React.lazy(import( () =&gt; import('library/sidecar')));<br/>// ^ all the difference ^<br/><br/>export SideConnected = props =&gt; (<br/>  &lt;Main<br/>    sidecar={&lt;Sidecar /&gt;}<br/>    {...props}<br/>  /&gt;<br/>);<br/><br/>// ^ you will load only Main, Sidecar will arrive later.</span></pre><p id="b8ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理论上<code class="fe ma mb mc md b">dynamic import</code>可以用在node_modules内部，使得<em class="kw">组装过程</em>更加透明。</p><blockquote class="mo mp mq"><p id="e91b" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated"><em class="iq">反正——无非是</em> <code class="fe ma mb mc md b"><em class="iq">children</em></code> <em class="iq"> / </em> <code class="fe ma mb mc md b"><em class="iq">slot</em></code> <em class="iq">的模式，所以常见于React。</em></p></blockquote><h1 id="f964" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">今后</h1><p id="94e2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe ma mb mc md b">Facebook</code>证明了这个想法是正确的。如果你还没有看过<a class="ae mn" href="https://dev.to/thekashey/(https://developers.facebook.com/videos/2019/building-the-new-facebookcom-with-react-graphql-and-relay/)" rel="noopener ugc nofollow" target="_blank">的那个视频</a>——现在就看。我刚刚从一个稍微不同的角度解释了同样的想法(并在F8会议前一周开始写这篇文章)。</p><p id="5da0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，它需要对您的代码库进行一些代码更改。它需要更明确的关注点分离来实际分离它们，并让代码不是水平地而是垂直地分离，为更大的用户体验运送更少的T4代码。</p><p id="6c12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">Sidecar</code>，大概是除了守旧派SSR之外，处理大代码库的唯一办法。当您拥有大量代码时，这是交付最少量代码的最后机会。</p><blockquote class="mo mp mq"><p id="e923" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">它可以使一个大的应用程序变得更小，一个小的应用程序变得更小。</p></blockquote><p id="d1da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">10年前，媒体网站在300毫秒内“准备就绪”，而几毫秒后<em class="kw">真的</em>准备就绪了吗？今天，秒甚至超过10秒是常见的数字。真可惜。</p><p id="e317" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们停下来，想一想——我们怎样才能解决这个问题，让UX再次变得伟大...</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pk"><img src="../Images/b061695e8a7e9da25b9845af9bd47e81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwgsvdaHCHkbapaS4idCUQ.jpeg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">我喜欢这张照片</figcaption></figure><h1 id="5f17" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">全部的</h1><ul class=""><li id="16cb" class="nn no iq ka b kb lv kf lw kj ox kn oy kr oz kv ob nt nu nv bi translated">1.组件代码分割是一个最强大的工具，它让你能够完全分割某些东西，但是这是有代价的——除了一个空白页或者一段时间的框架之外，你可能不会显示任何东西。那是水平分离。</li><li id="14b5" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">2.当组件拆分不起作用时，库代码拆分会有所帮助。那是水平分离。</li><li id="0c96" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ob nt nu nv bi translated">3.代码，卸载到sidecar将完成图片，并可能让您提供更好的用户体验。但是也需要一些工程上的努力。那是垂直分离。</li></ul><p id="cd33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我们来聊聊这个</strong>。</p><h1 id="0539" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">停下来。那么你试图解决的问题呢？</h1><p id="9fd9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这只是第一部分。<strong class="ka ir">我们现在处于最后阶段</strong>，还需要几周的时间来写下这个提议的第二部分。同时...</p><div class="mf mg mh mi gt ab cb"><figure class="pa jr pl pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/f03fe518f84f9090561423ce0963379a.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*f4df3QgmMum1E5C-ZvQI4w.png"/></div></figure><figure class="pa jr pm pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/2603e7b2e4367f7ce5ed08001f6a8bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*Jex4LKew2Bx9IOlYP01t9w.png"/></div></figure><figure class="pa jr pn pc pd pe pf paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/87187746c32ae1f7fed749d916352f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*Lf69591_Y5_bGj1I64kHbA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk po di pp pi translated">找你自己的边车！</figcaption></figure></div></div></div>    
</body>
</html>