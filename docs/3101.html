<html>
<head>
<title>Algorithms to Efficiently Solve Dynamic Connectivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效解决动态连通性的算法</h1>
<blockquote>原文：<a href="https://itnext.io/algorithms-to-efficiently-solve-dynamic-connectivity-9ad1d6c9c3c9?source=collection_archive---------4-----------------------#2019-10-03">https://itnext.io/algorithms-to-efficiently-solve-dynamic-connectivity-9ad1d6c9c3c9?source=collection_archive---------4-----------------------#2019-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7f50cddd5a67ec525f7c2d3f100aefac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Z4PynGLCsUubQQxwBGczA.jpeg"/></div></div></figure><p id="a295" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>和<a class="ae kz" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图论</a>中，<strong class="kd iu">动态连接</strong>结构是一种维护图的连接组件信息的结构。</p><p id="47b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它允许一个更大的<strong class="kd iu"><em class="la"/></strong>超集中的项目属于一个公共的<strong class="kd iu"> <em class="la">子集</em> </strong>，并有效地回答了问题<em class="la">‘A到B之间有连接路径吗？’</em></p><p id="4c02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动态连接问题适用于许多真实世界的应用。社交网络中的朋友、数码照片中的像素、网络中的计算机、互联网上的网页、计算机芯片上的晶体管或变量名等价物(不同的变量指向同一个对象)都是动态连接的例子。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lb"><img src="../Images/5ee8e03ad2b9a038e2bb4383ca95663f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KU54OjJV7s8HNhS86Xrafg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">动态连接允许我们有效地回答问题<strong class="bd lk"><em class="ll">‘是否有一条路径连接p和q？’在这种情况下，答案是肯定的。</em></strong></figcaption></figure><p id="50bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动态连接引入了以下<strong class="kd iu">抽象</strong>:</p><ul class=""><li id="010e" class="lm ln it kd b ke kf ki kj km lo kq lp ku lq ky lr ls lt lu bi translated">一组对象。</li><li id="2c78" class="lm ln it kd b ke lv ki lw km lx kq ly ku lz ky lr ls lt lu bi translated">一个<code class="fe ma mb mc md b">union</code>方法，允许你通过 用并集<strong class="kd iu"> <em class="la">替换包含两个项目的集合来<strong class="kd iu"> <em class="la">连接两个对象。</em> </strong></em></strong></li><li id="3df3" class="lm ln it kd b ke lv ki lw km lx kq ly ku lz ky lr ls lt lu bi translated">一个<code class="fe ma mb mc md b">find</code>方法，允许您通过回答问题“两个对象是否在同一个集合中？”来确定<strong class="kd iu"> <em class="la">。</em> </strong></li></ul><p id="4318" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动态连接还引入了以下<strong class="kd iu">假设</strong>:</p><ul class=""><li id="458b" class="lm ln it kd b ke kf ki kj km lo kq lp ku lq ky lr ls lt lu bi translated"><em class="la">连接到</em>是<strong class="kd iu">re flexive:</strong>每个对象都是<em class="la">始终连接到自身</em>。</li><li id="e8b6" class="lm ln it kd b ke lv ki lw km lx kq ly ku lz ky lr ls lt lu bi translated"><em class="la">连接到</em>是<strong class="kd iu">s对称:</strong>如果<strong class="kd iu"> p </strong>连接到<strong class="kd iu"> q </strong>，那么<strong class="kd iu"> q </strong>连接到<strong class="kd iu"> p </strong>。</li><li id="2822" class="lm ln it kd b ke lv ki lw km lx kq ly ku lz ky lr ls lt lu bi translated"><em class="la">连接到</em>是<strong class="kd iu">t及物:</strong>如果<strong class="kd iu"> p </strong>连接到<strong class="kd iu"> q </strong>并且<strong class="kd iu"> q </strong>连接到<strong class="kd iu"> r </strong>，那么<strong class="kd iu"> p </strong>连接到<strong class="kd iu"> r </strong>。</li></ul><p id="f13a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，动态连接断言人们可以从图中添加和删除项目，并且图可以变得非常大(因此标题为“动态”)。</p><h2 id="f036" class="me mf it bd lk mg mh dn mi mj mk dp ml km mm mn mo kq mp mq mr ku ms mt mu mv bi translated">所以，我们的问题定义是:</h2><p id="e07a" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">有了正式的定义，让我们试着解决这个问题:</p><p id="216e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">给定一个子集中大量相连的组件，我们如何设计一个有效的数据结构，使我们能够将大量的项目连接在一起(我们的</em> <code class="fe ma mb mc md b"><em class="la">union</em></code> <em class="la">方法)，并有效地确定项目是否相连(我们的</em> <code class="fe ma mb mc md b"><em class="la">find</em></code> <em class="la">方法)？</em></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="1778" class="ni mf it bd lk nj nk nl mi nm nn no ml np nq nr mo ns nt nu mr nv nw nx mu ny bi translated">★联合查找竞争者1:快速查找</h1><p id="df05" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated"><strong class="kd iu">快速查找</strong>被认为是解决联合查找问题的<strong class="kd iu">急切</strong>的方法。</p><p id="05fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编程中，<strong class="kd iu">快速查找</strong>由两个数组表示:</p><p id="61cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">—第一个数组是图中的项目集(大小为<strong class="kd iu"> N </strong>)。</p><p id="787c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">—第二个数组是图中每个项目的一组整数id(也是大小<strong class="kd iu"> N </strong>)。</p><p id="3a79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速查找保持不变，即所有连接的项目必须具有相同的id[]值。</p><pre class="lc ld le lf gt nz md oa ob aw oc bi"><span id="e3e2" class="me mf it md b gy od oe l of og"><strong class="md iu">i    </strong> 0 1 <em class="la">2 3 4</em> <strong class="md iu">5 6</strong> 7 8 <em class="la">9</em><br/><strong class="md iu">id[i]</strong> 0 1 <em class="la">9 9</em> <em class="la">9</em> <strong class="md iu">6 6</strong> 7 8 <em class="la">9</em></span></pre><p id="5bcd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">因为id[0] = id[5] = id[6] = 6 </em>所以0、5和6是相连的</p><p id="607e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">因为id[2] = id[3] = id[4] = id[9] = 9 </em>，所以2、3、4和9相互连接</p><p id="c465" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的<code class="fe ma mb mc md b">find(p, q)</code>方法检查p和q是否有相同的id。我们的<code class="fe ma mb mc md b">union(p, q)</code>方法(如果我们正在合并包含p和q的组件)，将需要把id为[p]的所有条目都改成id[q]。</p><pre class="lc ld le lf gt nz md oa ob aw oc bi"><span id="710b" class="me mf it md b gy od oe l of og"><strong class="md iu">i    </strong> 0 1 <em class="la">2 </em><strong class="md iu"><em class="la">3</em></strong><em class="la"> 4</em> 5<strong class="md iu"> 6</strong> 7 8 <em class="la">9</em><br/><strong class="md iu">id[i]</strong> 5 5 <em class="la">9 </em><strong class="md iu"><em class="la">9</em></strong> <em class="la">9</em> 6 <strong class="md iu">6</strong> 7 8 <em class="la">9</em></span></pre><figure class="lc ld le lf gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/13a32675418223f2ff7c9ec9f4a1f46a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EH_NiRDPJDIFN-Ys8vGiaA.png"/></div></figure><p id="4ea2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用快速查找，如果我们合并上面的第3项和第6项，id[i] = 9(这是3的id值)的所有条目都需要更改为6(这是6的id值)。这意味着我们需要更改id[2]、id[3]、id[4]和id[9]。</p><p id="3e7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为此，<code class="fe ma mb mc md b">union(p, q)</code>需要扫描每个输入对的整个<code class="fe ma mb mc md b">id[]</code>数组。</p><p id="237e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这代表了这个算法的一个主要缺陷:许多值可能会改变，这意味着快速查找太慢。</p><p id="a751" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们使用快速查找来合并<strong class="kd iu"> 1 </strong>和<strong class="kd iu"> 6 </strong>，如下所示，我们需要在<code class="fe ma mb mc md b">union</code>命令中更改总共5个id值。</p><pre class="lc ld le lf gt nz md oa ob aw oc bi"><span id="f7f1" class="me mf it md b gy od oe l of og"><strong class="md iu">i    </strong> 0 1 <em class="la">2 3 4</em> 5<strong class="md iu"> 6</strong> 7 8 <em class="la">9</em><br/><strong class="md iu">id[i]</strong> 5 5 <strong class="md iu"><em class="la">5 5</em> <em class="la">5</em></strong> 5<strong class="md iu"> 5</strong> 7 8 <strong class="md iu"><em class="la">5</em></strong></span></pre><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/6d991c8b8ec88fb553e9fb08fb666387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3p7jnihr_MlgdTH4VaRrg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">在合并1和6之前。</figcaption></figure><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/f67a6e951a5db5cbbcdbd608a7f6c93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZ0A0h5pCRwPXfeqCtD9eA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">1和6合并后。合并花费了<strong class="bd lk">五个联合操作</strong>。结论:快速查找算法中的联合操作可能意味着更新许多节点的id值，以将两个节点连接在一起。</figcaption></figure><p id="91aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…如果我们将2与7合并，可能会有八个id值更改。这意味着虽然<code class="fe ma mb mc md b">find</code>方法非常快(因此得名快速查找),但是<code class="fe ma mb mc md b">union</code>方法<strong class="kd iu">太昂贵</strong>:一个快速查找算法可能需要~MN个步骤来处理N个对象上的M个联合命令。如果M和N很大，这将是不可接受的慢。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">快速查找的Java实现</figcaption></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="113d" class="ni mf it bd lk nj nk nl mi nm nn no ml np nq nr mo ns nt nu mr nv nw nx mu ny bi translated">题外话:测量算法性能</h1><p id="f89e" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">我们用来衡量union-find算法有效性的方法很简单:我们计算<strong class="kd iu">数组访问</strong>的次数，即数组条目被访问以进行读取或写入的次数。这种测量算法计算次数的方法允许我们对不同的算法进行“排序”或相互比较。以最少数量的读/写操作实现预期结果的算法被认为是最有效的。本质上，有效的算法是那些“聪明而不费力”的算法:它们最大限度地减少了通过数据结构迭代来读取和/或写入数据的需要，从而节省了计算时间和空间资源的利用。</p><p id="4e8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">算法研究是一门非常成熟的学科。得出的结论是，低效的算法根本无法扩展。与某些流行的观念相反，人们不能将计算机资源投入到一个低效的算法上，并希望它能在大量的数据上高效运行。为什么？拥有一台速度极快的计算机可能会让你解决一个比普通计算机所能解决的问题大1000倍的问题，但是如果所使用的算法效率低下，那么由此产生的时间和/或空间需求将会比普通计算机慢1000倍。这意味着随着所解决的问题<strong class="kd iu">的增长</strong>，低效的算法表现<strong class="kd iu">更差</strong>。</p><blockquote class="om"><p id="50a0" class="on oo it bd op oq or os ot ou ov ky dk translated">问题越大，低效的算法就变得越慢。</p></blockquote><p id="914f" class="pw-post-body-paragraph kb kc it kd b ke ow kg kh ki ox kk kl km oy ko kp kq oz ks kt ku pa kw kx ky im bi translated">在快速查找的情况下，我们的<code class="fe ma mb mc md b">union()</code>方法需要(n + 3)(n-1) ~ n^2 <br/>数组访问(称为<strong class="kd iu"> <em class="la">二次时间</em> </strong>算法)。现代计算机每秒可以处理数亿条指令，所以这组项目的成本并不显著，但如果有数百万或数十亿个潜在关联的项目要处理，这根本就行不通。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pb"><img src="../Images/a21e8ffc2e089616dfc1ed384b9c83e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2d6GI51oorJcleSL1bmDA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">基于运算与元素的算法复杂度总结。从https://www.bigocheatsheet.com/<a class="ae kz" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">取回</a></figcaption></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="bfe0" class="ni mf it bd lk nj nk nl mi nm nn no ml np nq nr mo ns nt nu mr nv nw nx mu ny bi translated">★联盟-寻找竞争者2:快速联盟</h1><p id="334c" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">好了，继续。我们的下一个竞争者，<strong class="kd iu">快速联合</strong>，被认为是解决联合查找问题的<strong class="kd iu">懒惰</strong>方法。</p><p id="dbbe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在编程中，快速查找由两个数组表示:</p><p id="a7da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">—第一个数组是图中的项目集(大小为<strong class="kd iu"> N </strong>)。</p><p id="e3d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">—第二个数组是图形中每个项目的一组整数id(也是size <strong class="kd iu"> N </strong>)。</p><p id="b546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速联合的比喻是一片树林。每个子集是一个<strong class="kd iu">树</strong>，包含指向一个<strong class="kd iu">单根</strong>的节点。</p><p id="ac41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">树节点的id[]值包含到另一个项目的id[]值的链接。这又指向另一个的id[]值，依此类推。最终，当以这种方式跟踪链接的id[]值时，我们会遇到一个id[]值为<strong class="kd iu">并指向自身</strong>的项目。这是<strong class="kd iu">根</strong>。</p><p id="3464" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两个项目被认为是在同一个组件<strong class="kd iu">中，当且仅当这个过程引导它们到同一个根</strong>。</p><p id="d750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此,<code class="fe ma mb mc md b">union(p, q)</code>方法将根据链接找到p和q的根，然后通过将这些根中的一个链接到另一个来改变其中一个组件。选择重命名哪个组件是<strong class="kd iu">任意的</strong>。</p><p id="28d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">综上，快速并集的解释是id[i]是I的父。</p><pre class="lc ld le lf gt nz md oa ob aw oc bi"><span id="2f47" class="me mf it md b gy od oe l of og"><strong class="md iu">i    </strong> 0 1 <em class="la">2 3 4</em> 5<strong class="md iu"> </strong>6 7 8 <em class="la">9</em><br/><strong class="md iu">id[i]</strong> 2 2 <em class="la">2 9</em> <em class="la">0</em> 3<strong class="md iu"> </strong>4 2 9 <em class="la">9</em></span></pre><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/a4a1be1cba2e57aece05525511adcde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWPXeP_OCQfBxuK_MsVSqA.png"/></div></div></figure><p id="275d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ma mb mc md b">find(p, q)</code>因此检查p和q <strong class="kd iu">是否有相同的根</strong>。</p><p id="7eb2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ma mb mc md b">union(p, q)</code>将q的根的id设置为p的根的id。因此，将2与9连接会产生以下union命令:</p><pre class="lc ld le lf gt nz md oa ob aw oc bi"><span id="0620" class="me mf it md b gy od oe l of og"><strong class="md iu">i    </strong> 0 1 <em class="la">2 3 4</em> 5<strong class="md iu"> </strong>6 7 8 <em class="la">9</em><br/><strong class="md iu">id[i]</strong> 2 2 <strong class="md iu"><em class="la">9</em></strong><em class="la"> 9</em> <em class="la">0</em> 3<strong class="md iu"> </strong>4 2 9 <em class="la">9</em></span></pre><p id="e86f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是为什么它被称为快速联合:<strong class="kd iu">只有一个值改变</strong>！</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pd"><img src="../Images/2fa1f7caf4ddadd329c75c919ca074c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3iUhCwFJ4v_FtHeoSGnQQ.png"/></div></div></figure><p id="5269" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看看quick-union，很明显它比quick-find 更有效，因为union操作可能要快得多。</p><p id="a7d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我们的树有可能长得很高。这是因为我们可能会以<strong class="kd iu">大量的项目都在同一个子集</strong>中结束(视觉上，这将显示为长而高的树)。在这个场景中，我们的<code class="fe ma mb mc md b">find()</code>操作可能需要线性或二次时间，因为我们需要走很长的路来确定两个节点的公共根。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/e686247910ea065b2b0ce196e89b16ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hh76E-qN9hQH3mw9eK2w3w.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">在这个例子中，<strong class="bd lk">确定5和7是否连接，</strong>我们的<strong class="bd lk">查找</strong>操作需要<strong class="bd lk">六个</strong>步骤，因为我们已经用快速联合算法生成了又长又高的树。当多个节点以这种方式连接时，可能会导致<strong class="bd lk">查找操作</strong>不可接受的缓慢性能。</figcaption></figure><p id="9aa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的结论是快接接头<strong class="kd iu">也太慢。</strong></p><p id="f6d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，总结一下我们现在的情况:<strong class="kd iu">快速查找</strong>有平的树，但是保持平的代价太大，因为<code class="fe ma mb mc md b">union</code>需要N步。<strong class="kd iu">快速接头</strong>更好，但有一个缺点:树会变高，这意味着<code class="fe ma mb mc md b">find</code>太贵，需要N步。对于庞大的数据集，两者都无法有效扩展。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">快速联合的Java实现</figcaption></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="e608" class="ni mf it bd lk nj nk nl mi nm nn no ml np nq nr mo ns nt nu mr nv nw nx mu ny bi translated">★联合查找竞争者3:加权快速联合</h1><p id="fe75" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">幸运的是，对快速接头有一个简单的修改，允许我们保证长而高的树(因此昂贵的<code class="fe ma mb mc md b">find()</code>操作)不会发生。</p><p id="3f0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于<code class="fe ma mb mc md b">union()</code>方法，我们不是任意地将第二棵树连接到第一棵树，而是跟踪每棵树的大小，并且* <strong class="kd iu">总是</strong> *将较小的<strong class="kd iu">树连接到较大的</strong>树。这需要跟踪每棵树的节点数，但使算法更有效。由于2^k项目树的高度是k，加权快速联合<strong class="kd iu">保证了对数性能</strong>。这使得它成为这里研究的三种算法中唯一适用于巨大实际问题的算法。对数算法为什么特别？假设我们引用的是以2为底的对数(最常见于处理二进制数据的算法)，这意味着如果我们将问题规模从1，000增加到1，000，000(100万)，我们算法中的数组访问操作的数量将从10增加到20。如果我们将问题规模增加到1，000，000，000(10亿)，那么我们算法中的数组访问操作的数量将增加到30。这是一个可扩展的算法！</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/625f0155e488aafbc5601da2f112f3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUlBJHwzbnNlWJu3eemjSA.png"/></div></div></figure><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pg"><img src="../Images/360e19bd5fcbcbbbbc4b80c9f9b36055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8LdIOIs792TS5b23KgUAA.png"/></div></div></figure><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">加权快速联合的Java实现</figcaption></figure><h1 id="b959" class="ni mf it bd lk nj ph nl mi nm pi no ml np pj nr mo ns pk nu mr nv pl nx mu ny bi translated">证据就在测试中</h1><p id="d24b" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">让我们在实际场景中比较这三种联合查找算法。使用空格分隔的。txt文件，包含31，830个已连接的号码(代表已连接组件的id)。我遍历了整个数据集，在每次迭代中检查两个id是否已经连接，如果没有使用<code class="fe ma mb mc md b">union</code>命令来连接它们。我在数据集上使用了<strong class="kd iu">快速查找</strong>、<strong class="kd iu">快速联合</strong>和<strong class="kd iu">加权快速联合</strong>算法，并比较了各种算法联合数据所需的运行时间。从下面的截图来看，很明显加权快速联合是最快的。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pm"><img src="../Images/b99c863e49e42070d8e43bac78812caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bt2CXmtPs8CAOGf-NCOV4g.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">一致决定赢家:加权快速联合</figcaption></figure></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="15ab" class="ni mf it bd lk nj nk nl mi nm nn no ml np nq nr mo ns nt nu mr nv nw nx mu ny bi translated">一个实际的动态连接问题</h1><p id="a4e6" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated"><em class="la">问题:给定一个</em> <strong class="kd iu"> <em class="la">社交网络</em> </strong> <em class="la">包含</em> <strong class="kd iu"> <em class="la"> n </em> </strong> <em class="la">成员和一个包含</em> <strong class="kd iu"> <em class="la"> m </em> </strong> <em class="la">时间戳的日志文件，在这些时间戳下，成对的成员形成友谊，设计一个算法来确定所有成员被连接的最早时间(即每个成员都是朋友的朋友的朋友的朋友……的朋友的朋友)。</em></p><p id="7d8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">假设日志文件按时间戳排序，友谊是等价关系。</em></p><p id="4458" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">你的算法的运行时间应该是</em><strong class="kd iu"><em class="la">m log n</em></strong><em class="la">或者更好，并使用与</em> <strong class="kd iu"> <em class="la"> n </em> </strong> <em class="la">成比例的额外空间。</em></p><p id="c237" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案:我们将使用加权快速联合来解决这个问题。连接的朋友由管道分隔的字符串列表表示，这些字符串表示用户成为朋友的时间戳以及两个用户的id值。有100个(代表我们问题中的<strong class="kd iu"> <em class="la"> n </em> </strong>)用户，我在这100个用户之间创建了2000个随机连接的列表(代表我们问题中的<strong class="kd iu"> <em class="la"> m </em> </strong>)。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pn"><img src="../Images/b227475e7483483813a3e57349538b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TnJ2qepct8BcVtV96odmhQ.png"/></div></div></figure><p id="43b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码遍历2000个列表项，检查用户是否连接(使用<code class="fe ma mb mc md b">find</code>方法)，如果没有，连接它们(使用<code class="fe ma mb mc md b">union</code>方法)。在每次迭代结束时，它会检查不相交(非连接)成员的数量。如果非连通项的数量为零，我们就打破循环，因为现在我们知道每个成员都是朋友的朋友的朋友…朋友的朋友。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h1 id="5876" class="ni mf it bd lk nj ph nl mi nm pi no ml np pj nr mo ns pk nu mr nv pl nx mu ny bi translated">参考</h1><div class="po pp gp gr pq pr"><a href="http://researchhubs.com/post/computing/algorithm-1/dynamic-connectivity.html" rel="noopener  ugc nofollow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">动态连接</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">现在，我们讨论动态连通性问题，即union find的问题模型。想法是这样的。他们…</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">researchhubs.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf jz pr"/></div></div></a></div><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="qg ol l"/></div></figure><div class="po pp gp gr pq pr"><a href="https://www.bigocheatsheet.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd iu gy z fp pw fr fs px fu fw is bi translated">了解你的复杂性！</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">你好。这个网页涵盖了计算机科学中常用算法的空间和时间复杂性。当…</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">www.bigocheatsheet.com</p></div></div><div class="qa l"><div class="qh l qc qd qe qa qf jz pr"/></div></div></a></div></div></div>    
</body>
</html>