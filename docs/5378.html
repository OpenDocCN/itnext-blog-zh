<html>
<head>
<title>Breaking down and fixing Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解和修复Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/breaking-down-and-fixing-kubernetes-4df2f22f87c3?source=collection_archive---------1-----------------------#2021-02-21">https://itnext.io/breaking-down-and-fixing-kubernetes-4df2f22f87c3?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4538f988fa9badc1f8c15935527f7740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sNzXNN7Ky0uwfhxN.png"/></div></div></figure><p id="1b00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Kubernetes </strong>是一个用于容器编排和其他一切的伟大平台。最近，Kubernetes在功能性、安全性和弹性方面遥遥领先。Kubernetes架构允许您轻松应对各种故障，并始终保持运行。今天，我们将中断集群、删除证书、重新加入活动节点，并在不中断已在运行的服务的情况下完成所有这些花哨的工作。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/ef15ebc5436110262d5e937013a9b217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*hQ4zEuW6x2IjPvzRD26wZA.png"/></div></figure><p id="d69a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们开始吧。主控制平面Kubernetes仅由几个组件组成:</p><ul class=""><li id="3b0e" class="li lj iq ka b kb kc kf kg kj lk kn ll kr lm kv ln lo lp lq bi translated"><strong class="ka ir"> etcd </strong> —用作数据库</li><li id="2cdf" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated"><strong class="ka ir"> kube-apiserver </strong> —我们集群的API和核心</li><li id="71ca" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated"><strong class="ka ir">kube-controller-manager</strong>—对Kubernetes资源执行操作</li><li id="d81c" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated"><strong class="ka ir">kube-调度器</strong> —主调度器</li><li id="09c6" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated"><strong class="ka ir">kube lets</strong>——它们是节点上的起始容器</li></ul><p id="e371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些组件中的每一个都受到客户端和服务器的一组TLS证书的保护。它们用于在组件之间进行身份验证和授权。除了某些情况，它们并不存储在Kubernetes数据库中的某个地方，而是以常规文件的形式出现:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="6869" class="mb mc iq lx b gy md me l mf mg"># tree /etc/kubernetes/pki/<br/>/etc/kubernetes/pki/<br/>├── apiserver.crt<br/>├── apiserver-etcd-client.crt<br/>├── apiserver-etcd-client.key<br/>├── apiserver.key<br/>├── apiserver-kubelet-client.crt<br/>├── apiserver-kubelet-client.key<br/>├── ca.crt<br/>├── ca.key<br/>├── CTNCA.pem<br/>├── etcd<br/>│   ├── ca.crt<br/>│   ├── ca.key<br/>│   ├── healthcheck-client.crt<br/>│   ├── healthcheck-client.key<br/>│   ├── peer.crt<br/>│   ├── peer.key<br/>│   ├── server.crt<br/>│   └── server.key<br/>├── front-proxy-ca.crt<br/>├── front-proxy-ca.key<br/>├── front-proxy-client.crt<br/>├── front-proxy-client.key<br/>├── sa.key<br/>└── sa.pub</span></pre><p id="30de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件在主服务器上被描述和运行为来自<code class="fe mi mj mk lx b">/etc/kubernetes/manifests</code>目录的<a class="ae mh" href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/" rel="noopener ugc nofollow" target="_blank">静态pods </a></p><p id="3c94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将不详细讨论这一点，因为这是一个单独文章的好主题。在我们的例子中，我们主要感兴趣的是如何从所有这些东西中得到一个工作的集群。但是首先，让我们稍微抽象一下，想象我们有上面的Kubernetes组件，它们以某种方式相互通信。</p><p id="221d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常情况下，基本情况是这样的:</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/7553a4e6e76c41296929194b768f1390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V1fW6pOaWZz7qxhG.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">(箭头表示客户端到服务器的连接)</figcaption></figure><p id="7e14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于通信，他们需要TLS证书，这也可以带到一个单独的抽象级别。所以让我们依靠你的部署工具，它可以是<strong class="ka ir"> kubeadm </strong>，<strong class="ka ir"> kubespray </strong>或者其他任何东西。在本文中，我们将使用kubeadm ,因为它是最常见的Kubernetes部署工具，也经常在其他解决方案中使用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="0408" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们已经部署了一个集群。让我们从最有趣的开始:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="9a61" class="mb mc iq lx b gy md me l mf mg">rm -rf /etc/kubernetes/</span></pre><p id="dacd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在主节点上，该目录包含:</p><p id="a00f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-一套用于etcd的证书和CA(在<code class="fe mi mj mk lx b">/etc/kubernetes/pki/etcd</code>上)</p><p id="e15f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes的一套证书和证书(在<code class="fe mi mj mk lx b">/etc/kubernetes/pki</code>上)</p><p id="7ab8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-用于集群管理、kube控制器管理、kube调度和kubelet的Kubeconfigs(每个都有一个base64编码的CA证书，用于<code class="fe mi mj mk lx b">/etc/kubernetes/*.conf</code>上的集群)</p><p id="a09d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">etcd、kube-apiserver、kube-scheduler和kube-controller-manager的一组静态清单(在<code class="fe mi mj mk lx b">/etc/kubernetes/manifests</code>上)</p><p id="9af2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们一下子失去了一切。</p><h1 id="aeb5" class="mq mc iq bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">固定控制平面</h1><p id="24cc" class="pw-post-body-paragraph jy jz iq ka b kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr nr kt ku kv ij bi translated">为了避免混淆，让我们也确保我们所有的控制面板也停止:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="93cd" class="mb mc iq lx b gy md me l mf mg">crictl rm $(crictl ps -aq)</span></pre><blockquote class="ns nt nu"><p id="55b6" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:默认情况下，kubeadm不会覆盖现有的证书和kubeconfigs，为了重新颁发它们，您必须首先手动删除旧的。</p></blockquote><p id="cfdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从恢复etcd开始。如果您有一个仲裁(3个或更多主节点)，etcd集群将无法访问，直到大多数节点联机。</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="4695" class="mb mc iq lx b gy md me l mf mg">kubeadm init phase certs etcd-ca</span></pre><p id="3218" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的命令将为我们的etcd集群生成一个新的CA。由于所有其他证书都必须由其签名，我们还会将其和私钥复制到其他主节点:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="decb" class="mb mc iq lx b gy md me l mf mg">/etc/kubernetes/pki/etcd/ca.{key,crt}</span></pre><p id="bed1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们在所有控制平面节点上为它重新生成其余的etcd证书和静态清单:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="3e2e" class="mb mc iq lx b gy md me l mf mg">kubeadm init phase certs etcd-healthcheck-client<br/>kubeadm init phase certs etcd-peer<br/>kubeadm init phase certs etcd-server<br/>kubeadm init phase etcd local</span></pre><p id="5d02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个阶段，您应该已经有了一个工作的etcd集群:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="cc7e" class="mb mc iq lx b gy md me l mf mg"># crictl ps<br/>CONTAINER ID        IMAGE               CREATED             STATE               NAME                ATTEMPT             POD ID<br/>ac82b4ed5d83a       0369cf4303ffd       2 seconds ago       Running             etcd                0                   bc8b4d568751b</span></pre><p id="6968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们做同样的任务，但是对于Kubernetes服务，<strong class="ka ir">在一个</strong>主节点上执行:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="ac9f" class="mb mc iq lx b gy md me l mf mg">kubeadm init phase certs all<br/>kubeadm init phase kubeconfig all<br/>kubeadm init phase control-plane all<br/>cp -f /etc/kubernetes/admin.conf ~/.kube/config</span></pre><p id="109e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述命令将为Kubernetes生成所有SSL证书，以及Kubernetes服务的静态pods清单和kubeconfigs。</p><p id="8b68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果使用kubeadm加入kubeletes，还需要更新kube-public名称空间中的cluster-info配置，因为它仍然包含旧CA的散列。</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="c646" class="mb mc iq lx b gy md me l mf mg">kubeadm init phase bootstrap-token<!-- --> </span></pre><p id="443e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于其他实例上的所有证书也必须由单个CA签名，让我们将其复制到<strong class="ka ir">其他控制平面节点</strong>，并在每个节点上重复上述命令<strong class="ka ir">。</strong></p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="90a6" class="mb mc iq lx b gy md me l mf mg">/etc/kubernetes/pki/{ca,front-proxy-ca}.{key,crt}<br/>/etc/kubernetes/pki/sa.{key,pub}</span></pre><p id="9cf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，作为手动复制证书的替代方法，您也可以使用Kubernetes API，例如下面的命令:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="d296" class="mb mc iq lx b gy md me l mf mg">kubeadm init phase upload-certs --upload-certs</span></pre><p id="b9f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将加密证书并上传到Kubernetes，持续2小时，因此您可以按如下方式注册masters:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="7af2" class="mb mc iq lx b gy md me l mf mg">kubeadm join phase control-plane-prepare all kubernetes-apiserver:6443 --control-plane --token cs0etm.ua7fbmwuf1jz946l     --discovery-token-ca-cert-hash sha256:555f6ececd4721fed0269d27a5c7f1c6d7ef4614157a18e56ed9a1fd031a3ab8 --certificate-key 385655ee0ab98d2441ba8038b4e8d03184df1806733eac131511891d1096be73<br/>kubeadm join phase control-plane-join all</span></pre><p id="737a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，Kubernetes API有另一个配置，它保存前端代理客户机的CA证书。它用于认证从apiserver到webhooks和聚合层服务的请求。幸运的是，kube-apiserver会自动更新它。</p><p id="3c79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，您可能希望手动将其从旧证书中清除:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="459a" class="mb mc iq lx b gy md me l mf mg">kubectl get cm -n kube-system extension-apiserver-authentication -o yaml</span></pre><p id="5ce7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，在这个阶段我们已经有了一个完全工作的控制平面。</p><h1 id="e354" class="mq mc iq bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated">修理工人</h1><p id="d157" class="pw-post-body-paragraph jy jz iq ka b kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr nr kt ku kv ij bi translated">该命令将列出集群中的所有节点，尽管目前所有节点的状态都是<code class="fe mi mj mk lx b">NotReady</code>:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="71f6" class="mb mc iq lx b gy md me l mf mg">kubectl get node</span></pre><p id="1229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为他们仍然使用旧的证书，并期待来自旧CA签名的apiserver的请求。为了解决这个问题，我们将使用kubeadm，并将节点重新加入集群。</p><p id="cbf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然主节点可以访问主CA，但它们可以在本地加入:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="c597" class="mb mc iq lx b gy md me l mf mg">systemctl stop kubelet<br/>rm -rf /var/lib/kubelet/pki/ /etc/kubernetes/kubelet.conf<br/>kubeadm init phase kubeconfig kubelet<br/>kubeadm init phase kubelet-start</span></pre><p id="7731" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是要加入工人节点，我们必须生成一个新的令牌:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="0bd1" class="mb mc iq lx b gy md me l mf mg">kubeadm token create --print-join-command</span></pre><p id="545b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并对它们中的每一个运行以下命令:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="67d4" class="mb mc iq lx b gy md me l mf mg">systemctl stop kubelet<br/>rm -rf /var/lib/kubelet/pki/ /etc/kubernetes/pki/ /etc/kubernetes/kubelet.conf <br/>kubeadm join phase kubelet-start kubernetes-apiserver:6443  --token cs0etm.ua7fbmwuf1jz946l     --discovery-token-ca-cert-hash sha256:555f6ececd4721fed0269d27a5c7f1c6d7ef4614157a18e56ed9a1fd031a3ab8</span></pre><blockquote class="ns nt nu"><p id="3376" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>您不需要删除主节点上的<code class="fe mi mj mk lx b">/etc/kubernetes/pki/</code>目录，因为它已经包含了所有需要的证书。</p></blockquote><p id="4128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述过程会将您的所有kubelets重新加入集群。它不应该影响任何已经在上面运行的容器。然而，如果您在集群中有许多节点，但没有同时执行，您可能会面临这样的情况:当<strong class="ka ir">控制器-管理器</strong>开始从未就绪节点重新创建容器，并尝试在活动节点上重新调度它们。</p><p id="c9bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了防止这种情况，我们可以暂时停止主服务器上的控制器管理器窗格:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="a94a" class="mb mc iq lx b gy md me l mf mg">rm /etc/kubernetes/manifests/kube-controller-manager.yaml<br/>crictl rmp $(crictl ps --name kube-controller-manager -q)</span></pre><p id="3e59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要最后一个命令只是为了确保控制器管理器真的停止了。一旦集群中的所有节点都加入进来，您就可以为控制器管理器生成一个静态清单。</p><p id="9c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，在所有主节点上运行以下命令:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="db2f" class="mb mc iq lx b gy md me l mf mg">kubeadm init phase control-plane controller-manager</span></pre><blockquote class="ns nt nu"><p id="2a67" class="jy jz nv ka b kb kc kd ke kf kg kh ki nw kk kl km nx ko kp kq ny ks kt ku kv ij bi translated">请注意，您需要在已经生成加入令牌的阶段执行这些步骤。否则，加入过程将在尝试从cluster-info configmap读取令牌时挂起。</p></blockquote><p id="05e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果kubelets被配置为请求由您的CA签名的证书(选项<code class="fe mi mj mk lx b">serverTLSBootstrap: true</code>，您还需要批准您的kubelets的CSR</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="57b0" class="mb mc iq lx b gy md me l mf mg">kubectl get csr<br/>kubectl certificate approve &lt;csr&gt;</span></pre><h1 id="ddb5" class="mq mc iq bd mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm bi translated"><strong class="ak">修复服务账户</strong></h1><p id="012c" class="pw-post-body-paragraph jy jz iq ka b kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr nr kt ku kv ij bi translated">还有一件事，自从我们失去了<code class="fe mi mj mk lx b">/etc/kubernetes/pki/sa.key</code>。该密钥用于为集群中的所有ServiceAccounts签署jwt令牌。因此，我们必须为它们每个重新创建令牌。</p><p id="0800" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以通过从所有具有<code class="fe mi mj mk lx b">kubernetes.io/service-account-token</code>类型的秘密中移除<strong class="ka ir">令牌</strong>字段来非常简单地完成:</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="486f" class="mb mc iq lx b gy md me l mf mg">kubectl get secret --all-namespaces | awk '/kubernetes.io\/service-account-token/ { print "kubectl patch secret -n " $1 " " $2 " -p {\\\"data\\\":{\\\"token\\\":null}}"}' | sh -x</span></pre><p id="8c22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，kube-controller-manager将自动生成用新密钥签名的新令牌。</p><p id="6f08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，并不是所有的微服务都能够动态更新令牌，最有可能的是，您需要手动重启所有使用它的容器</p><pre class="le lf lg lh gt lw lx ly lz aw ma bi"><span id="940e" class="mb mc iq lx b gy md me l mf mg">kubectl get pod --field-selector 'spec.serviceAccountName!=default' --no-headers --all-namespaces | awk '{print "kubectl delete pod -n " $1 " " $2 " --wait=false --grace-period=0"}'</span></pre><p id="9f62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，此命令将生成一个命令列表，使用非默认的serviceAccount删除所有pod。我建议从<code class="fe mi mj mk lx b">kube-system</code>命名空间开始，因为那里安装了kube-proxy和CNI插件。它们对于处理微服务之间的通信至关重要。</p><p id="da29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，可以认为集群恢复过程已经完成。感谢关注！在下一篇文章的<a class="ae mh" rel="noopener ugc nofollow" target="_blank" href="/breaking-down-and-fixing-etcd-cluster-d81e35b9260d">中，我们将进一步了解如何备份和恢复etcd集群。</a></p></div></div>    
</body>
</html>