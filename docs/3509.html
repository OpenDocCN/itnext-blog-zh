<html>
<head>
<title>Expressions and IQueryables in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的表达式和IQueryables</h1>
<blockquote>原文：<a href="https://itnext.io/expressions-and-iqueryables-in-typescript-5b954080d07a?source=collection_archive---------1-----------------------#2019-12-30">https://itnext.io/expressions-and-iqueryables-in-typescript-5b954080d07a?source=collection_archive---------1-----------------------#2019-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/e5ba5388d49804eb744d6c830d3c7b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZNCXZ5_-KPwxxdeM"/></div></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">照片由<a class="ae kk" href="https://unsplash.com/@imgix?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> imgix </a>在<a class="ae kk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="52c7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi lj translated"><span class="l lk ll lm bm ln lo lp lq lr di"> W </span>在现代(web)开发中，我们已经看到越来越多更好的方法将我们的应用程序与外部数据源连接起来。我们已经看到REST是如何占领世界的，GraphQL成为一个主要的流行词，OData被SAP和Navision这样的大公司采用。虽然查询数据的协议已经大规模增长，但我们还没有看到JavaScript方面的强劲增长。当然，有各种各样的库围绕一个协议包装了一些stringbuilder，但是它们中的大多数并没有比过去十年中优秀的老式SOAP客户端生成器走得更远。</p><p id="3115" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我将展示一种查询外部数据源的方式，这种方式接近于LINQ和C#的IQueryables。我们将使用表达式树来描述我们的查询，就像它们是一种真正的语言一样，并为各种数据提供者提供通用的连接器。所有这些将导致一个客户端，在那里我们像在TypeScript中编写普通谓词和lambdas一样编写查询。</p><h1 id="f657" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">抽象语法树</strong></h1><p id="39c8" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">我们客户机的主干将是查询的抽象语法树。在本文中，我将把自己限制在如下所示的过滤操作上，以免让读者陷入代码中(每个以前使用过表达式树的人都应该能够确认这些东西可能非常庞大)。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">在本文的剩余部分，我将使用这个谓词作为例子</figcaption></figure><p id="e66e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">AST存在于一个包含其他表达式的表达式中。对于我们的例子，我们可以将表达式类型定义为树中所有不同表达式的有区别的并集。其定义如下所示。在这里你可以看到我们有3个表达式，它们都在一个左表达式和一个右表达式上操作。这些被称为二进制表达式。我们还有一个用于访问谓词参数属性的表达式类型，即索引表达式。最后，我们有一个包含值的表达式。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">AST只是一个表达式，对于我们的例子&amp;&amp;</figcaption></figure><p id="e905" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于这些表达式，我们可以创建构造函数，这样我们可以更容易地创建表达式树，并避免嵌套对象声明的圣诞树:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0abc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用这些构造函数，我们可以创建如下所示的示例表达式。正如你所看到的，当树变大时，很快就变得难以阅读，这与用常规编程语言编写表达式的方式相去甚远。为了实现我们针对外部系统编写代码的目标，就像我们只是编写普通的日常代码行一样，我们需要做更多的工作。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="77f6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从下一章开始，我将把重点放在创建公共接口上，我们将根据它来编写我们的表达式。在这里，我们将看到如何创建一个真正的表达式生成器。</p><h1 id="beff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">访问<strong class="ak">属性</strong></h1><p id="1a3e" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">如果我们仔细看看我们的示例表达式，我们会发现它从我们当前测试谓词所针对的项目中选择一个属性开始:<code class="fe mx my mz na b">b =&gt; b.Id …</code>。如果这是普通的JavaScript，<code class="fe mx my mz na b">b</code>将是集合中传递给<code class="fe mx my mz na b">filter</code>函数的实际对象。但是我们的实体存在于服务器上，所以我们不能把它们都取出来，然后一个一个地测试它们(我们可以，但是这会破坏构建它的整个目的)。所以我们需要一个类似于<code class="fe mx my mz na b">Blog</code>的东西，但实际上是构建AST的节点来访问属性。我们想要实现的是<code class="fe mx my mz na b">b =&gt; b.Id</code>返回实际上与<code class="fe mx my mz na b">createIndexExpression(‘Id’)</code>相同。然后，我们可以使用该节点继续构建表达式，直到得到我们想要的谓词。</p><p id="48b5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为此，我们可以使用JavaScript中的<code class="fe mx my mz na b">Proxy</code>特性，它允许我们通过一种方法捕获与对象的所有交互。为此，我们需要创建一个带有<code class="fe mx my mz na b">get</code>方法的处理程序，当我们访问我们假装的事物的属性时，将调用该方法。使用这个处理程序，我们可以创建所需类型的代理:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ec68" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们运行<code class="fe mx my mz na b">fakeBlog.Id</code>，我们将为<code class="fe mx my mz na b">id</code>字段获得一个带有‘Id’的索引表达式。有了这些，我们就可以通过访问项目的一个属性来创建表达式树了。下一步是将这个表达式包装在一个构建器中，这样我们就可以重新创建<code class="fe mx my mz na b">b =&gt; b.Id.Equals …</code>。</p><h1 id="165d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">表达式生成器</strong></h1><p id="5905" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">构建器的任务是允许我们用一个新的表达式来构建当前的表达式。所有二进制表达式将把当前AST放在新AST的左边，并从它们的输入中为右边创建一个新表达式。注意，所有不同的节点只有一个构建器。这是因为我们没有基于当前类型创建不同实例所需的运行时类型信息。对于等号(<code class="fe mx my mz na b">==</code>)运算符，表达式生成器可能如下所示:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6034" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们之前制作的代理将表达式包装在这个构建器中，我们可以编写<code class="fe mx my mz na b">b =&gt; b.Id.equals(1)</code>，它将返回一个以<code class="fe mx my mz na b">==</code>为根节点的实际表达式树！这一概念可应用于我们希望支持的所有行动，并导致以下结果:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d5eb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">处理程序定义将被更新以使用构建器，如下所示:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f9b2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，我们可以用一种方便的方式编写表达式，就像我们在日常编程语言中所习惯的那样。文章开头的示例表达式现在可以写成这样:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk">❤❤❤</figcaption></figure><h1 id="08c6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">类型安全表达式树</strong></h1><p id="f548" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">在我们当前的实现中，我们允许创建像<code class="fe mx my mz na b">b =&gt; b.Id.includes(‘foo’)</code>这样不可能的表达式。这个表达式并不代表一个有效的谓词，它完全是无意义的。如果我们不允许构造这样的表达式，构建器使用起来会方便得多。首先，我们为表达式可以计算的每种类型的值创建接口:<code class="fe mx my mz na b">boolean</code>、<code class="fe mx my mz na b">string</code>和<code class="fe mx my mz na b">number</code>。(例如，<code class="fe mx my mz na b">==</code>会产生一个布尔值，如果我们运行它，那么<code class="fe mx my mz na b">==</code>的计算结果就是这个值)。之后，我们重写了<code class="fe mx my mz na b">Fake</code>类型，以正确地将模型的属性映射到表示它们类型的构建器:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5ae4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">注意，操作符的返回类型也是类型特定的接口，以确保我们不能使用equals来比较a <code class="fe mx my mz na b">StringExprBuilder</code>和<code class="fe mx my mz na b">BoolExprBuilder</code>。更新后的<code class="fe mx my mz na b">Fake</code>类型如下:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="0eae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">IQueryable</strong></h1><p id="2e50" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">我们图书馆面向公众的界面将是<code class="fe mx my mz na b">IQueryable&lt;T&gt;</code>。它将数据源包装在这个接口中，并公开构建查询的方法。在我们的例子中，这将限于<code class="fe mx my mz na b">where</code>和<code class="fe mx my mz na b">toArray</code>。它将是异步的，因为数据源可能是外部的，并将通过HTTP进行查询。<code class="fe mx my mz na b">IQueryable</code>也是懒惰的，这意味着它将在内部存储查询，直到<code class="fe mx my mz na b">toArray</code>被调用并被迫执行查询。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b4ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以创建的这个接口的实现分为两大类:外部的和内存中的。外部数据源的实现是像OData和GraphQL这样的协议的实现。内存中的实现将是JavaScript中数组和其他数据集合的实现。我将向您展示两个示例:一个用于OData，一个用于数组。</p><h1 id="11e3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> OData IQueryable </strong></h1><p id="5e1c" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">对于OData，我们需要将AST编译成查询的过滤操作。这是通过一个递归函数完成的，该函数将表达式树的每个节点转换为一个字符串:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cfd3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有了它，我们可以为OData模型实现<code class="fe mx my mz na b">IQueryable</code>接口。在queryable中，我们有一个数组，其中包含传递给<code class="fe mx my mz na b">where</code>函数的所有表达式。当我们调用<code class="fe mx my mz na b">toArray</code>时，我们用and操作符将它们组合成一个查询字符串。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6d04" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用它来运行我在本文开始时介绍的谓词看起来像这样:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="ed05" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">内存中IQueryable</h1><p id="537d" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">对于<code class="fe mx my mz na b">IQueryable</code>的内存版本，我们需要一点运行时间来运行TypeScript中的表达式。这也是一个递归函数，但这次我们返回表达式的结果，而不是编译后的字符串:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8d95" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样我们可以在<code class="fe mx my mz na b">IQueryable</code>接口中包装一个数组。这里，我们还将保留我们在OData中引入的查询的惰性。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2bf0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用它看起来像这样，如下所示。请注意，通过我们强大的抽象，我们可以同时使用数组和OData端点，就好像它们是同一个东西一样。基于这两个例子，人们可以很容易地想象这对其他数据提供者是如何工作的。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="5358" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">结论</strong></h1><p id="31ce" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">在本文中，我展示了TypeScript中的一些概念和特性，可以用来利用查询语言中的最新发展。在这篇文章中，我把自己限制在<code class="fe mx my mz na b">where</code>，但是同样的原则也适用于选择属性、扩展关系等。当然，还有很多数据提供者可以用于我没有提到的地方。</p><h1 id="86bc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">资源</h1><p id="5a68" class="pw-post-body-paragraph kl km iq kn b ko mq kq kr ks mr ku kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">该项目的完整源代码可以在<a class="ae kk" href="https://github.com/WimJongeneel/ts-iqueryable" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。对于那些对扩展其他查询操作符的概念感兴趣的人，我可以推荐这篇文章:</p><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/type-safe-client-side-queries-in-typescript-3906eb14250e"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">TypeScript中的类型安全客户端查询</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">用于客户端编程的静态类型语言(如TypeScript)的引入极大地促进了客户端编程的发展。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">itnext.io</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ke ne"/></div></div></a></div></div></div>    
</body>
</html>