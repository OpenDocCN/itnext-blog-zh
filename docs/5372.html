<html>
<head>
<title>Database operational excellence with PostgreSQL 12</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 12数据库卓越运营</h1>
<blockquote>原文：<a href="https://itnext.io/database-operational-excellence-with-postgresql-12-3e7b74737495?source=collection_archive---------4-----------------------#2021-02-19">https://itnext.io/database-operational-excellence-with-postgresql-12-3e7b74737495?source=collection_archive---------4-----------------------#2021-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a490" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Ubuntu 20.10上的备份和恢复、复制和切换来掌握PostgreSQL-12数据库集群的end-2-end说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21b96c79d51b8f736b0662e984db63b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyjlV0dbQPQZ5sm0NfBljg.png"/></div></div></figure><p id="15c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di">P</span>T15】ostgreSQL号称<em class="lz">“世界上最先进的开源数据库”</em>理由非常充分。它的核心技术能力、性能和操作选项在所有商业巨头中首屈一指，非常适合需要存储和管理数据的初创企业或成熟企业。</p><p id="c6cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文从安装、配置、通过<a class="ae ma" href="https://www.pgbarman.org/" rel="noopener ugc nofollow" target="_blank"> barman 2.11 </a>进行备份和恢复、在<a class="ae ma" href="https://releases.ubuntu.com/20.10/" rel="noopener ugc nofollow" target="_blank"> Ubuntu 20.10 </a>上使用<a class="ae ma" href="https://repmgr.org/" rel="noopener ugc nofollow" target="_blank"> repmgr 5.0.0 </a>进行复制&amp;切换等方面对这款出色的数据库产品提供了一个非常全面的视角。然而，本文关注的是“把事情做好”，所以它关注的是相关的步骤&amp;命令，而不是背景和详细的解释。走吧，我们有很多要谈的！</p><h1 id="5804" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">介绍</h1><p id="d0c7" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们将使用三台物理或虚拟机，<code class="fe my mz na nb b">database-1</code>、<code class="fe my mz na nb b">database-2</code>和一台<code class="fe my mz na nb b">backup</code>机器，每台机器都运行在ubuntu 20.10上，并连接到安装在<code class="fe my mz na nb b">/backup</code>上的附加存储</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/e1af90b7350ee625e1c54dc8ed55bd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rohu-rxozKphO2d89IskVg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">高层基础架构</figcaption></figure><h1 id="e8b1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">装置</h1><h2 id="1084" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">初始基础设施设置</h2><p id="4cdf" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">确保在每台机器上都正确配置了DNS本教程不会引用任何IP，而只会引用主机名。</p><h2 id="ef8a" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">Postgres安装</h2><ul class=""><li id="6b37" class="nt nu it kw b kx mt la mu ld nv lh nw ll nx lp ny nz oa ob bi translated">安装几个好友<code class="fe my mz na nb b">sudo apt -y install vim bash-completion wget joe</code></li><li id="f4b6" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">现在更新您的apt包定义<code class="fe my mz na nb b">apt-get update</code></li><li id="5210" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">安装postgresql 12 <code class="fe my mz na nb b">apt install postgresql</code></li><li id="ff9d" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">安装酒保cli <code class="fe my mz na nb b">apt install barman-cli</code></li><li id="cf25" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">检查运行服务的状态<code class="fe my mz na nb b">systemctl status postgresql.service</code></li><li id="d262" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">检查postgres连接<code class="fe my mz na nb b">su - postgres</code></li><li id="363b" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">给postgres用户一个更强的密码<code class="fe my mz na nb b">psql -c "alter user postgres with password 'MyStrongAdminP@ssw0rd'"</code></li><li id="2e01" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在操作系统级别执行相同的操作(使用相同的密码)。作为根用户执行<code class="fe my mz na nb b">passwd postgres</code></li><li id="7eae" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">之后重启机器</li><li id="9eb9" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">对机器重复这些步骤:<code class="fe my mz na nb b">database-2</code></li><li id="cede" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在两台数据库服务器上，以用户<code class="fe my mz na nb b">postgres</code>的身份，创建文件<code class="fe my mz na nb b">~/.bash_rc</code>并添加以下内容</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="d829" class="nh mc it nb b gy ol om l on oo">PATH=$PATH:/usr/lib/postgresql/12/bin<br/>alias l='ls -al --color=auto'</span></pre><ul class=""><li id="8ea7" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">也将这些行添加到您的<code class="fe my mz na nb b">root</code>用户到两台服务器上的<code class="fe my mz na nb b">~/.bashrc</code></li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="370e" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">Postgres配置</h2><ul class=""><li id="b689" class="nt nu it kw b kx mt la mu ld nv lh nw ll nx lp ny nz oa ob bi translated">这样配置<code class="fe my mz na nb b">/etc/postgresql/12/main/postgresql.conf</code>:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="f093" class="nh mc it nb b gy ol om l on oo"># listen to any device and IP the machine has<br/>listen_addresses = '*'</span><span id="a87f" class="nh mc it nb b gy oz om l on oo"># turn archive mode on and configure barman rsync archiving of WAL<br/>archive_mode = on<br/>archive_command = 'rsync -a %p barman@backup:/backup/barman/database-1/incoming/%f'<br/>wal_level = replica</span><span id="773c" class="nh mc it nb b gy oz om l on oo"># comment out the include_dir as this will prevent the server to startup during recovery<br/># include_dir = 'conf.d'</span></pre><ul class=""><li id="c316" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">编辑<code class="fe my mz na nb b">/etc/postgres/12/main/pg_hba.conf</code>并添加以下几行(这已经包括我们稍后为repmgr需要的复制配置)</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="b278" class="nh mc it nb b gy ol om l on oo">host all all &lt;your-c-net&gt; trust<br/>host repmgr repmgr &lt;your-c-net&gt; trust<br/>host replication repmgr &lt;your-c-net&gt; trust</span></pre><ul class=""><li id="4e6d" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">此时，创建您想要的任何初始数据库结构</li></ul><h2 id="f3eb" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">PostgreSQL资源</h2><div class="pa pb gp gr pc pd"><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-20-04" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">如何在Ubuntu 20.04 | DigitalOcean上安装和使用PostgreSQL</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">关系数据库管理系统是许多网站和应用程序的关键组件。他们提供了…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">www.digitalocean.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ks pd"/></div></div></a></div></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="c20b" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">通过酒保设置备份和恢复</h1><ul class=""><li id="da2b" class="nt nu it kw b kx mt la mu ld nv lh nw ll nx lp ny nz oa ob bi translated">在ubuntu 20.10上启动您的全新备份服务器</li><li id="b6b3" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">backup</code>上安装酒吧招待<code class="fe my mz na nb b">apt-get install barman barman-cli</code></li><li id="23f5" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">分别在<br/> <code class="fe my mz na nb b">database-1</code>和<code class="fe my mz na nb b">backup</code>为postgres和barman用户创建私钥</li><li id="184f" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-1</code>上，切换到postgres用户<code class="fe my mz na nb b">su - postgres</code>并生成一个密钥对:<code class="fe my mz na nb b">ssh-keygen -b 2048 -t rsa -N "" -C "postgres@database-1"</code></li><li id="a04e" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-2</code>上，切换到postgres用户<code class="fe my mz na nb b">su - postgres</code>并生成一个密钥对:<code class="fe my mz na nb b">ssh-keygen -b 2048 -t rsa -N "" -C "postgres@database-2"</code></li><li id="7d8e" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">backup</code>上，切换到酒保用户<code class="fe my mz na nb b">su - barman</code>并创建一个密钥对:<code class="fe my mz na nb b">ssh-keygen -b 2048 -t rsa -N "" -C "barman@backup"</code></li><li id="f28f" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">将postgres和barman的公钥分别附加到<br/> <code class="fe my mz na nb b">~/.ssh/authorized_keys</code></li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="e68e" class="nh mc it nb b gy ol om l on oo">on database-1 as postgres : cat &lt;database-2.server id_rsa.pub&gt; &gt;&gt; ./ssh/authorized_keys<br/>on database-1 as postgres : cat &lt;backup.server id_rsa.pub&gt; &gt;&gt; ./ssh/authorized_keys</span><span id="9734" class="nh mc it nb b gy oz om l on oo">on database-2 as postgres : cat &lt;database-1.server id_rsa.pub&gt; &gt;&gt; ./ssh/authorized_keys<br/>on database-2 as postgres : cat &lt;backup.server id_rsa.pub&gt; &gt;&gt; ./ssh/authorized_keys</span><span id="c733" class="nh mc it nb b gy oz om l on oo">on backup as postgres : cat &lt;database-1.server id_rsa.pub&gt; &gt;&gt; ./ssh/authorized_keys<br/>on backup as postgres : cat &lt;database-2.server id_rsa.pub&gt; &gt;&gt; ./ssh/authorized_keys</span></pre><ul class=""><li id="7a2b" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在每台机器上，使用各自的用户名和完整主机名连接到其他机器:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="a6ea" class="nh mc it nb b gy ol om l on oo">from database-1 as postgres user : ssh barman@backup<br/>from database-1 as postgres user : ssh postgres@database-2</span><span id="42c0" class="nh mc it nb b gy oz om l on oo">from database-2 as postgres user : ssh barman@backup<br/>from database-2 as postgres user : ssh postgres@database-1</span><span id="c851" class="nh mc it nb b gy oz om l on oo">from backup as barman user : ssh postgres@database-1<br/>from backup as barman user : ssh postgres@database-2</span><span id="59d9" class="nh mc it nb b gy oz om l on oo">this will add the respective hosts to the known_hosts file, which is necessary to make barman function properly</span></pre><ul class=""><li id="9a22" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">backup</code>上将文件<code class="fe my mz na nb b">/etc/barman.conf</code>移动到<code class="fe my mz na nb b">/etc/barman.conf.orig</code>并用以下内容重新创建:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="37d3" class="nh mc it nb b gy ol om l on oo">[barman]<br/>barman_home = /backup/barman<br/>barman_user = barman<br/>log_file = /backup/barman/barman.log<br/>compression = gzip<br/>reuse_backup = link<br/>backup_method = rsync<br/>archiver = on<br/>immediate_checkpoint = true<br/>basebackup_retry_times = 3<br/>basebackup_retry_sleep = 30<br/>last_backup_maximum_age = 1 DAYS</span><span id="9aac" class="nh mc it nb b gy oz om l on oo">[database-1]<br/>description = "database-1"<br/>ssh_command = ssh postgres@database-1<br/>conninfo = host=database-1 user=postgres port=5432<br/>retention_policy_mode = auto<br/>retention_policy = RECOVERY WINDOW OF 7 days<br/>wal_retention_policy = main<br/>backup_options = exclusive_backup</span><span id="096a" class="nh mc it nb b gy oz om l on oo">[database-2]<br/>description = "database-2"<br/>ssh_command = ssh postgres@database-2<br/>conninfo = host=database-2 user=postgres port=5432<br/>retention_policy_mode = auto<br/>retention_policy = RECOVERY WINDOW OF 7 days<br/>wal_retention_policy = main<br/>backup_options = exclusive_backup</span></pre><ul class=""><li id="7f9d" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">设置WAL传入—在<code class="fe my mz na nb b">backup</code>上用<code class="fe my mz na nb b">barman show-server database-1 | grep incoming_wals_directory</code>获取该目录:应该是<code class="fe my mz na nb b">incoming_wals_directory: /backup/barman/database-1/incoming</code></li><li id="1287" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">确保该路径与<code class="fe my mz na nb b">archive_command</code>中的postgresql.conf相同</li><li id="5c34" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">列出所有可用的备份服务器:<code class="fe my mz na nb b">barman list-server</code></li><li id="d132" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">检查WAL存档和我们服务器的所有其他部分:<code class="fe my mz na nb b">barman check database-1</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/c337288ef4a7326940ba3f635fabf056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fg5jXRuHsXkVrvIHqL4Eiw.png"/></div></div></figure><ul class=""><li id="1646" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">用<br/>和<code class="fe my mz na nb b">barman switch-wal --force --archive database-1</code>测试WAL存档</li><li id="78a3" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">如果你看到这一行<code class="fe my mz na nb b">WAL archive: FAILED (please make sure WAL shipping is setup)</code>:可能数据库还没有产生任何WAL文件，或者它们已经被删除，或者rsync失败。查看PostgreSQL日志以了解更多信息。但是如果rsync工作正常，基本上如果没有数据写入数据库，服务器就不会产生任何WAL文件，因此没有什么需要备份的。WAL文件是在产生一定量的数据后创建的。我建议你创建一个表格，并插入一些数据。您可以使用<code class="fe my mz na nb b">barman switch-wal --force --archive database-1</code>强制关闭当前WAL文件</li><li id="4cf8" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">建立基地备份:<code class="fe my mz na nb b">barman backup database-1</code></li><li id="4f7b" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">列出单台服务器的所有现有备份<code class="fe my mz na nb b">barman list-backup database-1</code></li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="1dab" class="nh mc it nb b gy ol om l on oo">barman@backup:~$ barman list-backup database-1</span><span id="b752" class="nh mc it nb b gy oz om l on oo">database-1 20210209T115342 - Tue Feb  9 11:53:45 2021 - Size: 70.7 MiB - WAL Size: 0 B<br/>database-1 20210209T114450 - Tue Feb  9 11:44:53 2021 - Size: 70.7 MiB - WAL Size: 32.3 KiB<br/>database-1 20210209T114054 - Tue Feb  9 11:40:58 2021 - Size: 70.7 MiB - WAL Size: 32.2 KiB</span></pre><ul class=""><li id="46d9" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">使用<code class="fe my mz na nb b">barman show-backup server-a 20210209T115342</code>从特定备份中获取更多详细信息</li><li id="b8ef" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">使用cron计划备份:</li><li id="f1a5" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated"><code class="fe my mz na nb b">barman cron</code>每分钟(在服务器的基础上同时执行WAL归档操作，这也在那些服务器上强制执行保留策略)</li><li id="8104" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">每天午夜执行数据库备份</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="77c4" class="nh mc it nb b gy ol om l on oo">*  *    * * *   barman  /usr/bin/barman cron<br/>0  0    * * *   barman  /usr/bin/barman backup database-1</span></pre><ul class=""><li id="2e94" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">删除<code class="fe my mz na nb b">backup</code>上的<code class="fe my mz na nb b">/etc/cron.d</code></li></ul><h2 id="ba0c" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">酒保资源</h2><div class="pa pb gp gr pc pd"><a href="https://www.digitalocean.com/community/tutorials/how-to-back-up-restore-and-migrate-postgresql-databases-with-barman-on-centos-7" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">如何在CentOS 7 | DigitalOcean上使用Barman备份、恢复和迁移PostgreSQL数据库</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">PostgreSQL是一个开源数据库平台，因其易用性而受到web和移动应用程序开发人员的欢迎</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">www.digitalocean.com</p></div></div><div class="pm l"><div class="py l po pp pq pm pr ks pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://stackoverflow.com/questions/51472352/postgresql-how-to-take-incremental-backup-with-barman/51552776" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">Postgresql:如何用Barman进行增量备份</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">我后来发现这个伟大的教程解释了一步一步的过程。这是迄今为止最有帮助的一个。我是…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">stackoverflow.com</p></div></div><div class="pm l"><div class="pz l po pp pq pm pr ks pd"/></div></div></a></div><h2 id="b1f5" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">有用的酒保命令</h2><p id="b854" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated"><code class="fe my mz na nb b">barman check database-1</code> -检查特定服务器的酒保配置<br/> <code class="fe my mz na nb b">barman status database-1</code> -显示特定服务器的状态<br/> <code class="fe my mz na nb b">barman backup database-1</code> -为特定服务器创建备份<br/> <code class="fe my mz na nb b">barman backup --reuse=link main</code> -强制增量备份<br/> <code class="fe my mz na nb b">barman list-backup database-1</code> -列出特定服务器上所有可用的备份<br/> <code class="fe my mz na nb b">barman show-backup database-1 &lt;timestamp&gt;</code> -显示备份内容<br/> <code class="fe my mz na nb b">barman show-backup database-1 latest</code> -显示最新可用的备份</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="0714" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">灾难后恢复备份</h1><ul class=""><li id="7cca" class="nt nu it kw b kx mt la mu ld nv lh nw ll nx lp ny nz oa ob bi translated">连接到您的数据库模式<code class="fe my mz na nb b">database-1</code>并删除一些数据、表格或数据库来模拟灾难</li><li id="6071" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">关闭<code class="fe my mz na nb b">database-1</code> : <br/> <code class="fe my mz na nb b">systemctl stop postgresql.service</code>上的目标postgres服务器</li><li id="23c1" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">backup</code>作为用户<code class="fe my mz na nb b">barman</code>检查最新的酒保备份<code class="fe my mz na nb b">barman show-backup database-1 latest</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/23cf2163d6122f908de4cde5424bff8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0o62AKikyAUs4aquPlImw.png"/></div></div></figure><ul class=""><li id="5dbd" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">记下备份ID和备份结束时间</li><li id="5b65" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">仍然在<code class="fe my mz na nb b">backup</code>上，以用户<code class="fe my mz na nb b">postgres</code>的身份运行以下命令来恢复该备份</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="9def" class="nh mc it nb b gy ol om l on oo">barman recover \\<br/>  --target-time "2021-02-10 19:44:39.214745+00:00" \\<br/>  --remote-ssh-command "ssh postgres@database-1" \\<br/>  database-1 20210210T194412 /var/lib/postgresql/12/main</span></pre><ul class=""><li id="aa1c" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">预计备份结束时会显示消息:<strong class="kw iu">您的PostgreSQL服务器已成功准备好进行恢复！</strong></li><li id="773e" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">作为<code class="fe my mz na nb b">postgres</code>用户，在<code class="fe my mz na nb b">database-1</code>上以恢复模式启动postgres</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="935a" class="nh mc it nb b gy ol om l on oo"># start postgresql manually to initiate the recovery<br/>/usr/lib/postgresql/12/bin/pg_ctl -D /var/lib/postgresql/12/main start</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/243f15f7d5f415f1b65db5066debcc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbXcZc_qxRZuGxnqdZjGiw.png"/></div></div></figure><ul class=""><li id="d625" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">重启第二个数据库框<code class="fe my mz na nb b">database-2</code></li><li id="e94d" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">您从备份中还原了数据库服务器</li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="a08b" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">Postgres群集硬重置</h1><p id="3780" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">如果数据库备份无法恢复、损坏，并且我们必须在不重新安装数据库容器的情况下硬重置pg集群，请使用此过程。<strong class="kw iu">注意！！！这将删除你所有的数据</strong></p><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="67e9" class="nh mc it nb b gy ol om l on oo"># list all existing pg clusters in the system<br/>pg_lsclusters  </span><span id="d709" class="nh mc it nb b gy oz om l on oo"># drop the cluster (based on version and custer identifier)<br/>pg_dropcluster 12 main</span><span id="2774" class="nh mc it nb b gy oz om l on oo"># recreate the cluster<br/>pg_createcluster 12 main</span></pre><ul class=""><li id="c301" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">现在按照上面的过程配置<code class="fe my mz na nb b">/etc/postgres/...</code>中的PostgresQL集群，因为所有最后的配置都被删除了</li><li id="6a4a" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">如果Postgres服务器在恢复后没有启动，请使用以下命令获取详细的启动日志</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="d9ec" class="nh mc it nb b gy ol om l on oo">/usr/lib/postgresql/12/bin/postgres -d 3 -D /var/lib/postgresql/12/main/ -c config_file=/etc/postgresql/13/main/postgresql.conf</span></pre></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="3c25" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">安装和配置代表经理</h1><p id="e8ba" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们将使用repmgr来配置postgres节点<code class="fe my mz na nb b">database-1</code>和<code class="fe my mz na nb b">database-2</code>之间的复制</p><ul class=""><li id="a534" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在两个数据库机器上，安装repmgr <code class="fe my mz na nb b">apt-get install postgresql-12-repmgr</code></li><li id="85c0" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-1</code>(我们的主节点)上，创建一个repmgr用户和数据库，作为<code class="fe my mz na nb b">postgres</code>用户执行:<code class="fe my mz na nb b">createuser --superuser repmgr</code> <code class="fe my mz na nb b">createdb --owner=repmgr repmgr</code></li><li id="c9d5" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">更改repmgr用户的默认搜索路径:<br/> <code class="fe my mz na nb b">psql -c "ALTER USER repmgr SET search_path TO repmgr, public;"</code></li><li id="ab7b" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">编辑<code class="fe my mz na nb b">/etc/postgresql/12/main/postgresql.conf</code>并添加下面一行<code class="fe my mz na nb b">shared_preload_libraries = 'repmgr'</code>这将在PostgreSQL启动时加载repmgr扩展。</li><li id="86e0" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-1</code>上创建repmgr默认配置文件<code class="fe my mz na nb b">touch /etc/repmgr.conf</code>并添加以下内容:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="5c14" class="nh mc it nb b gy ol om l on oo">node_id=1<br/>node_name=database-1<br/>conninfo='host=database-1 user=repmgr dbname=repmgr port=5432'<br/>data_directory='/var/lib/postgresql/12/main'<br/>barman_host=backup<br/>barman_server=database-1<br/>restore_command='/usr/bin/barman-wal-restore -U barman backup database-1 %f %p'<br/>pg_bindir='/usr/lib/postgresql/12/bin'<br/>log_file='/backup/barman/repmgr.log'</span></pre><ul class=""><li id="2430" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-1</code>上，编辑<code class="fe my mz na nb b">/etc/default/repmgrd</code>并应用以下内容:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="16fc" class="nh mc it nb b gy ol om l on oo"># disable repmgrd by default so it won't get started upon installation<br/># valid values: yes/no<br/>REPMGRD_ENABLED=yes</span><span id="095d" class="nh mc it nb b gy oz om l on oo"># configuration file (required)<br/>REPMGRD_CONF=/etc/repmgr.conf</span><span id="529d" class="nh mc it nb b gy oz om l on oo"># additional options<br/>#REPMGRD_OPTS=""</span><span id="0d09" class="nh mc it nb b gy oz om l on oo"># user to run repmgrd as<br/>#REPMGRD_USER=postgres</span><span id="4671" class="nh mc it nb b gy oz om l on oo"># repmgrd binary<br/>#REPMGRD_BIN=/usr/bin/repmgrd</span><span id="ca70" class="nh mc it nb b gy oz om l on oo"># pid file<br/>#REPMGRD_PIDFILE=/var/run/repmgrd.pid</span></pre><ul class=""><li id="5ffa" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-2</code>上创建repmgr默认配置文件<code class="fe my mz na nb b">touch /etc/repmgr.conf</code>并添加以下内容:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="7c9c" class="nh mc it nb b gy ol om l on oo">node_id=2<br/>node_name=database-2<br/>conninfo='host=database-2 user=repmgr dbname=repmgr port=5432 connect_timeout=2'<br/>data_directory='/var/lib/postgresql/12/main'<br/>log_file='/backup/barman/repmgr.log'</span></pre><ul class=""><li id="7ae4" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在<code class="fe my mz na nb b">database-2</code>上，编辑<code class="fe my mz na nb b">/etc/default/repmgrd</code>并应用以下内容:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="82fc" class="nh mc it nb b gy ol om l on oo"># disable repmgrd by default so it won't get started upon installation<br/># valid values: yes/no<br/>REPMGRD_ENABLED=yes</span><span id="f306" class="nh mc it nb b gy oz om l on oo"># configuration file (required)<br/>REPMGRD_CONF="/etc/repmgr.conf"</span><span id="d319" class="nh mc it nb b gy oz om l on oo"># additional options<br/>#REPMGRD_OPTS=""</span><span id="dc19" class="nh mc it nb b gy oz om l on oo"># user to run repmgrd as<br/>#REPMGRD_USER=postgres</span><span id="e5fc" class="nh mc it nb b gy oz om l on oo"># repmgrd binary<br/>#REPMGRD_BIN=/usr/bin/repmgrd</span><span id="6d09" class="nh mc it nb b gy oz om l on oo"># pid file<br/>#REPMGRD_PIDFILE=/var/run/repmgrd.pid</span></pre><ul class=""><li id="9dd4" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">为了让复制工作，<code class="fe my mz na nb b">database-1</code>需要接受来自<code class="fe my mz na nb b">database-2</code>的复制连接。副本正在请求复制信息，而不是相反。在<code class="fe my mz na nb b">/etc/postgresql/12/main/pg_hba.conf</code>中的<code class="fe my mz na nb b">database-1</code>上，确保存在以下配置(您应该已经有了)</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="8bf6" class="nh mc it nb b gy ol om l on oo">host all all &lt;your-c-net&gt; trust<br/>host repmgr repmgr &lt;your-c-net&gt;trust<br/>host replication repmgr &lt;your-c-net&gt; trust</span></pre><ul class=""><li id="d0b2" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">作为<code class="fe my mz na nb b">database-1</code>上的<code class="fe my mz na nb b">postgres</code>用户，向repmgr <code class="fe my mz na nb b">/usr/bin/repmgr -f /etc/repmgr.conf primary register</code>注册主节点<code class="fe my mz na nb b">database-1</code></li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="e9b5" class="nh mc it nb b gy ol om l on oo">INFO: connecting to primary database...<br/>NOTICE: attempting to install extension "repmgr"<br/>NOTICE: "repmgr" extension successfully installed<br/>NOTICE: primary node record (ID: 1) registered</span></pre><ul class=""><li id="6c97" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">检查组合仪表的状态<code class="fe my mz na nb b">/usr/bin/repmgr -f /etc/repmgr.conf cluster show</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/2a5f232e8f555f386f2618fe92a1bd7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmFkd8yFYN7PujToQZ2asA.png"/></div></div></figure><ul class=""><li id="af15" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">从<code class="fe my mz na nb b">root</code>开始在<code class="fe my mz na nb b">database-1</code>重复运行:<code class="fe my mz na nb b">/etc/init.d/repmgrd start</code></li><li id="5a08" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">设置第二个节点，切换到<code class="fe my mz na nb b">database-2</code>并停止postgresql <code class="fe my mz na nb b">/etc/init.d/postgresql stop</code></li><li id="81c4" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">作为用户执行<code class="fe my mz na nb b">postgres</code> : <code class="fe my mz na nb b">/usr/bin/repmgr -h database-1 -U repmgr -d repmgr -p 5432 -F -f /etc/repmgr.conf standby clone --dry-run</code></li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="1e84" class="nh mc it nb b gy ol om l on oo">INFO: all prerequisites for "standby clone" are met</span></pre><ul class=""><li id="e8e0" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">一旦成功，执行克隆操作<code class="fe my mz na nb b">/usr/bin/repmgr -h database-1 -U repmgr -d repmgr -p 5432 -F -f /etc/repmgr.conf standby clone</code></li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="468c" class="nh mc it nb b gy ol om l on oo">NOTICE: standby clone (using pg_basebackup) complete<br/>NOTICE: you can now start your PostgreSQL server<br/>HINT: for example: pg_ctl -D /var/lib/postgresql/12/main start<br/>HINT: after starting the server, you need to register this standby with "repmgr standby register"</span></pre><ul class=""><li id="6aa5" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在此阶段，PostgreSQL没有在备用节点中运行，尽管备用节点从主节点复制了Postgres数据目录(包括主节点数据目录中存在的任何PostgreSQL配置文件)。</li><li id="df8d" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">现在在辅助节点上启动postgresql服务<code class="fe my mz na nb b">/etc/init.d/postgresql start</code></li><li id="de73" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">作为用户<code class="fe my mz na nb b">postgres</code>，向repmgr <code class="fe my mz na nb b">/usr/bin/repmgr -f /etc/repmgr.conf standby register</code>注册第二个节点</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="17d6" class="nh mc it nb b gy ol om l on oo">INFO: connecting to local node "database-2" (ID: 2)<br/>INFO: connecting to primary database<br/>WARNING: --upstream-node-id not supplied, assuming upstream node is primary (node ID 1)<br/>INFO: standby registration complete<br/>NOTICE: standby node "database-2" (ID: 2) successfully registered</span></pre><ul class=""><li id="243d" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">现在检查repmgr集群设置:<br/> <code class="fe my mz na nb b">/usr/bin/repmgr -f /etc/repmgr.conf cluster show --compact</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/7d0fdf890a1f972b6db7a744847c0963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0cuydJFsntBzd6n7iY7vA.png"/></div></div></figure><ul class=""><li id="458f" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">您现在可以测试复制:在主服务器<code class="fe my mz na nb b">database-1</code>上创建数据库、表、记录，并检查<code class="fe my mz na nb b">database-2</code>上的即时更改→您将意识到repmgr使辅助服务器保持完美同步。干得好！</li></ul><h2 id="6a30" class="nh mc it bd md ni nj dn mh nk nl dp ml ld nm nn mn lh no np mp ll nq nr mr ns bi translated">Repmgr资源</h2><div class="pa pb gp gr pc pd"><a href="https://www.2ndquadrant.com/en/blog/how-to-automate-postgresql-12-replication-and-failover-with-repmgr-part-1/" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">如何使用repmgr自动化PostgreSQL 12复制和故障转移—第1部分</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">repmgr是来自2ndQuadrant的开源工具集，是PostgreSQL相关技术和…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">www.2ndquadrant.com</p></div></div><div class="pm l"><div class="qe l po pp pq pm pr ks pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://repmgr.org/docs/4.0/repmgr-command-reference.html" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">repmgr命令参考</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">编辑描述</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">repmgr.org</p></div></div></div></a></div></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="32dd" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">手动转换配置</h1><ul class=""><li id="6506" class="nt nu it kw b kx mt la mu ld nv lh nw ll nx lp ny nz oa ob bi translated">目标是使用repmgr从主服务器切换到辅助服务器，然后再切换回来</li><li id="16b2" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">切换<code class="fe my mz na nb b">sudo -u postgres /usr/bin/repmgr -f /etc/repmgr.conf cluster show --compact</code>前检查集群设置</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/7d0fdf890a1f972b6db7a744847c0963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0cuydJFsntBzd6n7iY7vA.png"/></div></div></figure><ul class=""><li id="927e" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">执行切换，在<code class="fe my mz na nb b">database-2</code> : <br/> <code class="fe my mz na nb b">/usr/bin/repmgr standby switchover -f /etc/repmgr.conf</code></li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="36c7" class="nh mc it nb b gy ol om l on oo">NOTICE: executing switchover on node "database-2" (ID: 2)<br/>NOTICE: local node "database-2" (ID: 2) will be promoted to primary; current primary "database-1" (ID: 1) will be demoted to standby<br/>NOTICE: stopping current primary node "database-1" (ID: 1)<br/>NOTICE: issuing CHECKPOINT<br/>DETAIL: executing server command "/usr/lib/postgresql/12/bin/pg_ctl  -D '/var/lib/postgresql/12/main' -W -m fast stop"<br/>INFO: checking for primary shutdown; 1 of 60 attempts ("shutdown_check_timeout")<br/>INFO: checking for primary shutdown; 2 of 60 attempts ("shutdown_check_timeout")<br/>NOTICE: current primary has been cleanly shut down at location 0/25000028<br/>NOTICE: promoting standby to primary<br/>DETAIL: promoting server "database-2" (ID: 2) using pg_promote()<br/>NOTICE: waiting up to 60 seconds (parameter "promote_check_timeout") for promotion to complete<br/>NOTICE: STANDBY PROMOTE successful<br/>DETAIL: server "database-2" (ID: 2) was successfully promoted to primary<br/>INFO: local node 1 can attach to rejoin target node 2<br/>DETAIL: local node's recovery point: 0/25000028; rejoin target node's fork point: 0/250000A0<br/>NOTICE: setting node 1's upstream to node 2<br/>WARNING: unable to ping "host=database-1 user=repmgr dbname=repmgr port=5432"<br/>DETAIL: PQping() returned "PQPING_NO_RESPONSE"<br/>NOTICE: starting server using "/usr/lib/postgresql/12/bin/pg_ctl  -w -D '/var/lib/postgresql/12/main' start"<br/>WARNING: unable to ping "host=database-1 user=repmgr dbname=repmgr port=5432"<br/>DETAIL: PQping() returned "PQPING_NO_RESPONSE"<br/>WARNING: unable to ping "host=database-1 user=repmgr dbname=repmgr port=5432"<br/>DETAIL: PQping() returned "PQPING_NO_RESPONSE"</span></pre><ul class=""><li id="c590" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">在ubuntu上，你可能会遇到命令<code class="fe my mz na nb b">/usr/lib/postgresql/12/bin/pg_ctl -w -D '/var/lib/postgresql/12/main' start</code>的问题，所以你会看到几次<code class="fe my mz na nb b">PQping() returned "PQPING_NO_RESPONSE"</code>直到它超时。为了弥补这一点，在尝试与<code class="fe my mz na nb b">/etc/init.d/postgresql start</code>重新连接期间，在<code class="fe my mz na nb b">database-1</code>上手动启动postgres</li><li id="f507" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">现在检查repmgr集群设置:<code class="fe my mz na nb b">sudo -u postgres /usr/bin/repmgr -f /etc/repmgr.conf cluster show --compact</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/76b9e8190845da14f46ac2975cbaafd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*orT9m4TKxhvWr0Or4G3gaw.png"/></div></div></figure><ul class=""><li id="13ba" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">您会看到您的repmgr集群现在以<code class="fe my mz na nb b">database-2</code>为主集群运行</li><li id="a710" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">作为用户<code class="fe my mz na nb b">postgres</code> : <code class="fe my mz na nb b">/usr/bin/repmgr standby switchover -f /etc/repmgr.conf</code>在<code class="fe my mz na nb b">database-1</code>上执行切回</li><li id="7494" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">同样，在ubuntu上的这个场景中，postgres可能不会在<code class="fe my mz na nb b">database-2</code>上正确返回，在这种情况下，postgres也以<code class="fe my mz na nb b">/etc/init.d/postgres start</code>开始<code class="fe my mz na nb b">root</code></li><li id="8a0d" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">检查repmgr集群设置:<code class="fe my mz na nb b">sudo -u postgres /usr/bin/repmgr -f /etc/repmgr.conf cluster show --compact</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/2f541557224822bdc5a1ab3ac24dde9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iF5u2XwfHip6eTb4F9-5Jg.png"/></div></div></figure><ul class=""><li id="5a13" class="nt nu it kw b kx ky la lb ld op lh oq ll or lp ny nz oa ob bi translated">警告消息表明，当用户<code class="fe my mz na nb b">postgres</code>运行:<code class="fe my mz na nb b">repmgr standby follow</code>时，我们必须在<code class="fe my mz na nb b">database-2</code>跟踪主服务器</li><li id="b5ac" class="nt nu it kw b kx oc la od ld oe lh of ll og lp ny nz oa ob bi translated">我们现在已经在集群上来回切换了主repmgr节点</li></ul></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="800f" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">清除repmgr配置并重新开始</h1><ul class=""><li id="81fd" class="nt nu it kw b kx mt la mu ld nv lh nw ll nx lp ny nz oa ob bi translated">在某些情况下，删除当前可能损坏的repmgr配置并重新开始可能更容易。在主节点上，作为用户<code class="fe my mz na nb b">postgres</code>:</li></ul><pre class="kj kk kl km gt oh nb oi oj aw ok bi"><span id="e863" class="nh mc it nb b gy ol om l on oo">psql -c "delete from repmgr.events;" repmgr<br/>psql -c "delete from repmgr.monitoring_history;" repmgr<br/>psql -c "delete from repmgr.nodes;" repmgr<br/>psql -c "delete from repmgr.voting_term;" repmgr</span></pre></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h1 id="a2fc" class="mb mc it bd md me ps mg mh mi pt mk ml jz pu ka mn kc pv kd mp kf pw kg mr ms bi translated">最后的想法</h1><p id="2332" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">恭喜您，您现在已经设置了PostgreSQL的备份和完整复制，并且能够在主数据库节点和辅助数据库节点之间切换，不会对您的数据造成任何风险。</p><p id="fc4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了您现在拥有的，我建议使用<code class="fe my mz na nb b">pg_dumpall | gzip &gt; backup.gz</code>基于静态时间表(例如，每周日)进行完整的纯文本备份，因为您可能需要以纯文本格式完整转储您的整个数据库集群内容，以便在不同的操作系统、PostgreSQL版本甚至不同的数据库产品上使用</p><p id="b380" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要记住，本文并没有介绍应用层如何处理切换。选项是使用负载平衡工具来实际决定客户机应该连接哪个数据库服务器，或者在应用层上创建和配置这种能力。</p><p id="069d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">祝你邮购愉快！</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="8ff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lz">如果你喜欢这个故事，并想在medium上阅读成千上万个这样的故事，你可以成为medium会员，每月仅需5美元。如果你愿意支持我的写作，请使用我下面的推荐链接，我将免费获得你的一部分会员资格。</em></p><p id="4f2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">【https://medium.com/@thomas.reinecke/membership】T5<a class="ae ma" href="https://medium.com/@thomas.reinecke/membership" rel="noopener">T6</a></p></div></div>    
</body>
</html>