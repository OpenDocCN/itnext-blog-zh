<html>
<head>
<title>Getting started with Kafka and Rust: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡与鲁斯特入门:第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-kafka-and-rust-part-1-e0074961ec6b?source=collection_archive---------4-----------------------#2021-04-06">https://itnext.io/getting-started-with-kafka-and-rust-part-1-e0074961ec6b?source=collection_archive---------4-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e030" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个实践指南，教你如何使用Rust编程语言与Kafka进行交互</h2></div><p id="1bf9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个由两部分组成的系列，帮助您开始了解Rust和Kafka。我们将使用<a class="ae lb" href="https://github.com/fede1024/rust-rdkafka/" rel="noopener ugc nofollow" target="_blank"> rust-rdkafka </a>机箱，它本身基于<a class="ae lb" href="https://github.com/edenhill/librdkafka" rel="noopener ugc nofollow" target="_blank"> librdkafka </a> ( <code class="fe lc ld le lf b">C</code>库)。</p><p id="9325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将介绍Kafka生产者API。</p><blockquote class="lg lh li"><p id="e6e6" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">更新:零件2在<a class="ae lb" href="https://abhishek1987.medium.com/getting-started-with-kafka-and-rust-part-2-129c372dc1ad" rel="noopener"> <em class="iq">这里有</em> </a></p></blockquote><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/42459b85abd4a1a45b1822e0a94c954a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IMZh2DM_D5wLdXex.png"/></div></div></figure><h1 id="8fc2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">初始设置</h1><p id="7725" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">确保你安装了一个Kafka代理——本地安装就足够了。当然，你也需要安装<a class="ae lb" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">Rust</a>——你需要<a class="ae lb" href="https://github.com/fede1024/rust-rdkafka#minimum-supported-rust-version-msrv" rel="noopener ugc nofollow" target="_blank">1.45或更高版本</a></p><p id="64b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始之前，克隆GitHub repo:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="4424" class="na ma iq lf b gy nb nc l nd ne">git clone https://github.com/abhirockzz/rust-kafka-101<br/>cd part1</span></pre><p id="e297" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查<code class="fe lc ld le lf b">Cargo.toml</code>文件:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="4c1c" class="na ma iq lf b gy nb nc l nd ne">...<br/>[dependencies]<br/>rdkafka = { version = "0.25", features = ["cmake-build"] }<br/>...</span></pre><p id="c981" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">上注</strong> <code class="fe lc ld le lf b"><strong class="kh ir">cmake-build</strong></code> <strong class="kh ir">特征</strong></p><p id="2737" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">rust-rdkafka</code>提供了几种解决<code class="fe lc ld le lf b">librdkafka</code>依赖的方法。我选择了<code class="fe lc ld le lf b">static</code>链接，其中<code class="fe lc ld le lf b">librdkafka</code>是编译的。您可以选择<code class="fe lc ld le lf b">dynamic</code>链接来引用本地安装的版本。</p><blockquote class="lg lh li"><p id="9efe" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">更多请参考此链接</em><a class="ae lb" href="https://github.com/fede1024/rust-rdkafka/blob/master/rdkafka-sys/README.md#features" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a></p></blockquote><p id="ba64" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，让我们从基础开始。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="de4a" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">简单生产者</h1><p id="41ae" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">下面是一个基于<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html" rel="noopener ugc nofollow" target="_blank"> BaseProducer </a>的简单生成器:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nr"><img src="../Images/644698542a708201db52117cfa4aac0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBaW8knso4tw7GuOmyQaAw.png"/></div></div></figure><p id="c031" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始生成消息的<code class="fe lc ld le lf b">send</code>方法——它是在紧密的<code class="fe lc ld le lf b">loop</code>中完成的，中间有一个<code class="fe lc ld le lf b">thread::sleep</code>(<em class="lj">而不是</em>您在生产中会做的事情)以便更容易跟踪/遵循结果。键、值(<code class="fe lc ld le lf b">payload</code>)和目的地Kafka主题以<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseRecord.html" rel="noopener ugc nofollow" target="_blank"> BaseRecord </a>的形式表示</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/466618202529e3bc8c7cd38445832f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TxGZW-UyRAgqRItsJUnwg.png"/></div></div></figure><blockquote class="lg lh li"><p id="3b2d" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">你可以在</em>文件中查看整个代码<code class="fe lc ld le lf b"><em class="iq">src/1_producer_simple.rs</em></code></p></blockquote><h2 id="8779" class="na ma iq bd mb nt nu dn mf nv nw dp mj ko nx ny ml ks nz oa mn kw ob oc mp od bi translated">要测试生产者是否在工作…</h2><p id="53e7" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">运行程序:</p><ul class=""><li id="da1b" class="oe of iq kh b ki kj kl km ko og ks oh kw oi la oj ok ol om bi translated">只需将文件<code class="fe lc ld le lf b">src/1_producer_simple.rs</code>重命名为<code class="fe lc ld le lf b">main.rs</code></li><li id="8e97" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">执行<code class="fe lc ld le lf b">cargo run</code></li></ul><p id="3b43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到以下输出:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="250d" class="na ma iq lf b gy nb nc l nd ne">sending message<br/>sending message<br/>sending message<br/>...</span></pre><p id="673b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">到底怎么回事？</strong>要解决这个问题——使用Kafka CLI消费者(或任何其他消费者客户端，例如<code class="fe lc ld le lf b">kafkacat</code>)连接到您的Kafka主题(在上面的示例中，我使用<code class="fe lc ld le lf b">rust</code>作为Kafka主题的名称)。您应该会看到消息不断流入。</p><p id="fbb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="e939" class="na ma iq lf b gy nb nc l nd ne">&amp;KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="6f67" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">生产者回拨</h1><p id="e90b" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们现在是盲目飞行！除非我们明确地创建一个消费者来查看我们的消息，否则我们不知道它们是否被发送到卡夫卡那里。让我们通过实现一个<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/trait.ProducerContext.html" rel="noopener ugc nofollow" target="_blank"> ProducerContext </a> (trait)来挂钩到生产事件来解决这个问题——这就像一个回调。</p><p id="11a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先为<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/client/trait.ClientContext.html" rel="noopener ugc nofollow" target="_blank"> ClientContext </a>特征创建一个<code class="fe lc ld le lf b">struct</code>和一个空实现(这是强制性的)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi os"><img src="../Images/4247bd50e7eef248139ef96e5ad28807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZKYf5JH5jOO5lp-ccCVCA.png"/></div></div></figure><p id="4b52" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在到了主要部分，我们在<code class="fe lc ld le lf b">ProducerContext</code>特征中实现了<code class="fe lc ld le lf b">delivery</code>功能。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ot"><img src="../Images/c16af4743a06167df2d34b4919f13a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klTzK7ahWyjYi_M8UnVfaQ.png"/></div></div></figure><p id="a8f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对照<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/type.DeliveryResult.html" rel="noopener ugc nofollow" target="_blank"> DeliveryResult </a>(毕竟是一个<code class="fe lc ld le lf b">Result</code>)来说明成功(<code class="fe lc ld le lf b">Ok</code>)和失败(<code class="fe lc ld le lf b">Err</code>)场景。我们所做的只是简单地记录这两种情况下的消息，因为这只是一个例子。在这里你可以做任何你想做的事情(但是不要发疯！)</p><blockquote class="lg lh li"><p id="886a" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">我们忽略了</em><a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/trait.ProducerContext.html#associatedtype.DeliveryOpaque" rel="noopener ugc nofollow" target="_blank"><em class="iq">delivery opaque</em></a><em class="iq">，它是</em> <code class="fe lc ld le lf b"><em class="iq">ProducerContext</em></code> <em class="iq"> trait </em>的关联类型</p></blockquote><p id="e525" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要确保插入我们的<code class="fe lc ld le lf b">ProducerContext</code>实现。我们通过使用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/config/struct.ClientConfig.html#method.create_with_context" rel="noopener ugc nofollow" target="_blank"> create_with_context </a>方法(而不是<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/config/struct.ClientConfig.html#method.create" rel="noopener ugc nofollow" target="_blank"> create </a>)来做到这一点，并确保为<code class="fe lc ld le lf b">BaseProducer</code>提供正确的类型。</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="a8e2" class="na ma iq lf b gy nb nc l nd ne">let producer: BaseProducer&lt;ProduceCallbackLogger&gt; = ClientConfig::new().set(....)<br/>...<br/>.create_with_context(ProduceCallbackLogger {})<br/>...</span></pre><h2 id="9d86" class="na ma iq bd mb nt nu dn mf nv nw dp mj ko nx ny ml ks nz oa mn kw ob oc mp od bi translated">“回调如何被调用”？</h2><p id="b289" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">好了，我们已经实现了，但是我们需要一种方法来<em class="lj">触发</em>它！方法之一是在生产者上调用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html#method.flush" rel="noopener ugc nofollow" target="_blank"> flush </a>。所以，我们可以这样写我们的生产者:</p><ul class=""><li id="59e1" class="oe of iq kh b ki kj kl km ko og ks oh kw oi la oj ok ol om bi translated">添加<code class="fe lc ld le lf b">producer.flush(Duration::from_secs(3));</code>，以及</li><li id="ec55" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">评论<code class="fe lc ld le lf b">sleep</code>(只是暂时的)</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/291ca7c003b0c5768609709a219da44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUXeKEPmdTnOQu3O1ZvSCA.png"/></div></div></figure><h2 id="23b7" class="na ma iq bd mb nt nu dn mf nv nw dp mj ko nx ny ml ks nz oa mn kw ob oc mp od bi translated">坚持住，我们可以做得更好！</h2><p id="bf46" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><code class="fe lc ld le lf b">send</code>方法是非阻塞的(默认)，但是通过在每个<code class="fe lc ld le lf b">send</code>之后调用<code class="fe lc ld le lf b">flush</code>，我们现在已经将它转换为同步调用- <em class="lj">，而不是从性能角度推荐的</em>。</p><p id="99cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.ThreadedProducer.html" rel="noopener ugc nofollow" target="_blank">螺纹加工器</a>来改善这种情况。它负责在后台线程中调用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/base_producer/struct.BaseProducer.html#method.poll" rel="noopener ugc nofollow" target="_blank"> poll </a>方法，以确保交付回调通知被交付。这样做非常简单——只需将类型从<code class="fe lc ld le lf b">BaseProducer</code>改为<code class="fe lc ld le lf b">ThreadedProducer</code>！</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="9f8d" class="na ma iq lf b gy nb nc l nd ne"># before: BaseProducer&lt;ProduceCallbackLogger&gt;<br/># after: ThreadedProducer&lt;ProduceCallbackLogger&gt;</span></pre><p id="bb55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们不再需要调用<code class="fe lc ld le lf b">flush</code>。</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="b1aa" class="na ma iq lf b gy nb nc l nd ne">...<br/>//producer.flush(Duration::from_secs(3));<br/>//println!("flushed message");<br/>thread::sleep(Duration::from_secs(3));<br/>...</span></pre><blockquote class="lg lh li"><p id="a3b1" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">该代码在</em> <code class="fe lc ld le lf b"><em class="iq">src/2_threaded_producer.rs</em></code>中可用</p></blockquote><h2 id="fd52" class="na ma iq bd mb nt nu dn mf nv nw dp mj ko nx ny ml ks nz oa mn kw ob oc mp od bi translated">再次运行程序</h2><ul class=""><li id="38a4" class="oe of iq kh b ki mr kl ms ko ou ks ov kw ow la oj ok ol om bi translated">将文件<code class="fe lc ld le lf b">src/2_threaded_producer.rs</code>重命名为<code class="fe lc ld le lf b">main.rs</code>并</li><li id="9a95" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">执行<code class="fe lc ld le lf b">cargo run</code></li></ul><p id="54d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="f904" class="na ma iq lf b gy nb nc l nd ne">sending message<br/>sending message<br/>produced message with key key-1 in offset 6 of partition 2<br/>produced message with key key-2 in offset 3 of partition 0<br/>sending message<br/>produced message with key key-3 in offset 7 of partition </span></pre><p id="a035" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如预期的那样，您应该能够看到生产者事件回调，这表明消息确实被发送到了Kafka主题。当然，你可以直接连接到主题并仔细检查，就像之前一样:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="0641" class="na ma iq lf b gy nb nc l nd ne">&amp;KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning</span></pre><blockquote class="lg lh li"><p id="4b50" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">为了尝试一个失败场景，尝试使用一个不正确的主题名，并注意</em> <code class="fe lc ld le lf b"><em class="iq">delivery</em></code> <em class="iq">实现的</em> <code class="fe lc ld le lf b"><em class="iq">Err</em></code> <em class="iq">变体是如何被调用的。</em></p></blockquote></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="0331" class="lz ma iq bd mb mc nm me mf mg nn mi mj jw no jx ml jz np ka mn kc nq kd mp mq bi translated">发送JSON消息</h1><p id="526b" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">到目前为止，我们只是发送<code class="fe lc ld le lf b">String</code>作为键和值。JSON是一种常用的消息格式，让我们看看如何使用它。</p><p id="8cd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要发送将使用这个<code class="fe lc ld le lf b">struct</code>表示的<code class="fe lc ld le lf b">User</code>信息:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6166a9ef22973c20416ca74854deb101.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*sssCKKdHRLobP4aRtuozZg.png"/></div></figure><p id="bb9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<a class="ae lb" href="https://docs.serde.rs/serde_json/" rel="noopener ugc nofollow" target="_blank"> serde_json </a>库将其序列化为json。我们所需要的就是使用serde  — <code class="fe lc ld le lf b">Deserialize</code>和<code class="fe lc ld le lf b">Serialize</code>中的<a class="ae lb" href="https://serde.rs/derive.html" rel="noopener ugc nofollow" target="_blank">自定义派生</a></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oy"><img src="../Images/17d635a0a57c2099beac3a09c75ab152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFaDD1Ry48CB4-6u26TKuQ.png"/></div></div></figure><p id="9617" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更改生产者循环:</p><ul class=""><li id="690b" class="oe of iq kh b ki kj kl km ko og ks oh kw oi la oj ok ol om bi translated">创建一个<code class="fe lc ld le lf b">User</code>实例</li><li id="1629" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">使用<a class="ae lb" href="https://docs.serde.rs/serde_json/fn.to_string_pretty.html" rel="noopener ugc nofollow" target="_blank"> to_string_pretty </a>将其序列化为JSON字符串</li><li id="923b" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">包括在有效载荷中</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oz"><img src="../Images/73e5df3c7d397bb29b38415bf4869180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjFL-GnMTVNWpUrm56TSzw.png"/></div></div></figure><blockquote class="lg lh li"><p id="6376" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">你也可以用</em><a class="ae lb" href="https://docs.serde.rs/serde_json/fn.to_vec.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">to _ vec</em></a><em class="iq">(而不是</em> <code class="fe lc ld le lf b"><em class="iq">to_string()</em></code> <em class="iq">)将其转换成一个</em> <code class="fe lc ld le lf b"><em class="iq">Vec</em></code> <em class="iq">的字节(</em> <code class="fe lc ld le lf b"><em class="iq">Vec&lt;u8&gt;</em></code> <em class="iq"> ) </em></p></blockquote><h2 id="22e5" class="na ma iq bd mb nt nu dn mf nv nw dp mj ko nx ny ml ks nz oa mn kw ob oc mp od bi translated">要运行该程序…</h2><ul class=""><li id="3e49" class="oe of iq kh b ki mr kl ms ko ou ks ov kw ow la oj ok ol om bi translated">将文件<code class="fe lc ld le lf b">src/3_JSON_payload.rs</code>重命名为<code class="fe lc ld le lf b">main.rs</code>，并且</li><li id="23b0" class="oe of iq kh b ki on kl oo ko op ks oq kw or la oj ok ol om bi translated">执行<code class="fe lc ld le lf b">cargo run</code></li></ul><p id="f4ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从话题消费:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="6ce1" class="na ma iq lf b gy nb nc l nd ne">&amp;KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning</span></pre><p id="1835" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该看到带有<code class="fe lc ld le lf b">String</code>键(例如<code class="fe lc ld le lf b">user-34</code>)和JSON值的消息:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="541f" class="na ma iq lf b gy nb nc l nd ne">{<br/>  "id": 34,<br/>  "email": "user-34@foobar.com"<br/>}</span></pre><h2 id="2125" class="na ma iq bd mb nt nu dn mf nv nw dp mj ko nx ny ml ks nz oa mn kw ob oc mp od bi translated">有没有更好的办法？</h2><p id="e0cb" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">是啊！如果您习惯于Kafka Java客户端中的声明式序列化/反序列化方法(可能其他客户端也是如此)，您可能不喜欢这种“显式”方法。为了客观地看待问题，在Java中应该这样做:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pa"><img src="../Images/af6b6ad5180dc1d7025823d8f4167615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ay1I_XvWAaLOU86XWZ_JmA.png"/></div></div></figure><blockquote class="lg lh li"><p id="2019" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">请注意，您只需配置</em> <code class="fe lc ld le lf b"><em class="iq">Producer</em></code> <em class="iq">来使用</em> <code class="fe lc ld le lf b"><em class="iq">KafkaJsonSchemaSerializer</em></code> <em class="iq">并且</em> <code class="fe lc ld le lf b"><em class="iq">User</em></code> <em class="iq">类被序列化为JSON </em></p></blockquote><p id="d517" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">rust-rdkafka</code>提供了与<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/message/trait.ToBytes.html" rel="noopener ugc nofollow" target="_blank"> ToBytes </a>特征相似的东西。它看起来是这样的:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pb"><img src="../Images/23fb530084652d7e49906a05615a6ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CttyC-Fa0XBWaO8tt3Iktg.png"/></div></div></figure><p id="cf53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不言自明，对吗？<code class="fe lc ld le lf b">String</code>、<code class="fe lc ld le lf b">Vec&lt;u8&gt;</code>等已有实现。因此，您可以使用这些类型作为键或值，而无需任何额外的工作——这正是我们刚才所做的。但问题是我们使用的<em class="lj">方式</em>是“显式的”,即我们将<code class="fe lc ld le lf b">User</code>结构转换成JSON字符串并传递它。</p><p id="d5b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">如果我们能将</strong> <code class="fe lc ld le lf b"><strong class="kh ir">ToBytes</strong></code> <strong class="kh ir">实现为</strong> <code class="fe lc ld le lf b"><strong class="kh ir">User</strong></code> <strong class="kh ir">会怎么样？</strong></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pc"><img src="../Images/334f8160cc0916270d6c651df2721b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzKG5DExVprWaenpRBuVAg.png"/></div></div></figure><p id="c12c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将看到一个编译器错误:</p><pre class="lo lp lq lr gt mw lf mx my aw mz bi"><span id="09b0" class="na ma iq lf b gy nb nc l nd ne">cannot return value referencing local variable `b`<br/>returns a value referencing data owned by the current function</span></pre><blockquote class="lg lh li"><p id="7bff" class="kf kg lj kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated"><em class="iq">其他背景请参考本【GitHub问题】(</em><a class="ae lb" href="https://github.com/fede1024/rust-rdkafka/issues/128" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github.com/fede1024/rust-rdkafka/issues/128</em></a><em class="iq">)。我很乐意看到一个可以与</em> <code class="fe lc ld le lf b"><em class="iq">ToBytes</em></code> <em class="iq">一起工作的例子——如果你对此有意见，请留言！</em></p></blockquote><p id="c8d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TL；DR就是最好坚持“显式”的做事方式，除非你有一个“不涉及分配并且不会失败”的<code class="fe lc ld le lf b">ToBytes</code>实现。</p><h1 id="993b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">包裹</h1><p id="658c" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">第一部分到此为止！第2部分将涵盖围绕卡夫卡消费者的主题。</p></div></div>    
</body>
</html>