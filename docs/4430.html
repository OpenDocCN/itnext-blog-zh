<html>
<head>
<title>TDD lesson 5 — Extending legacy code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDD第5课——扩展遗留代码</h1>
<blockquote>原文：<a href="https://itnext.io/tdd-lesson-5-extending-legacy-code-b0c507ee989e?source=collection_archive---------1-----------------------#2020-06-29">https://itnext.io/tdd-lesson-5-extending-legacy-code-b0c507ee989e?source=collection_archive---------1-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/aece6b8a7438d8350536c6e93e6dc65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BosuWolL_QBDCgMG6ox_uw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">蒂姆·埃文斯在<a class="ae jg" href="/s/photos/safe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="cb49" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于我在<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/acceptance-test-driven-development-in-net-core-with-specflow-dcb17fb7a893?source=friends_link&amp;sk=e7d7a00242242e63922e0688ba4db51d">之前关于TDD </a>的帖子，TDD可以很好地用于绿地项目，一个项目从它开始，让你攫取所有的好处，但是绿地项目是一种奢侈品，在我们的职业生涯中不会有太多的时间，有时我们将不得不扩展遗留代码库。我们如何安全地做到这一点？</p><p id="3729" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章将向您的TDD工具箱添加另一项技术，在扩展遗留应用程序之前添加测试覆盖。</p><h1 id="f8f5" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">扩展遗留代码库的两种方法</h1><h2 id="b409" class="mc lf jj bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">编辑和祈祷</h2><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/b94f010fdd721923d74031b502c4e546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZWa0zRL44quoSi9sIcx1A.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Josh Frenette 在<a class="ae jg" href="/s/photos/careful?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bd52" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“编辑并祈祷”在这种情况下，你更改代码并希望你没有破坏它，在这种方法中，你非常仔细地分析代码，查看更改的最小步骤以获得新的行为，并在更改后，进行一系列手动测试以检查回归和新功能。你也可以称之为“精心编辑”。</p><p id="2e78" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做的一个缺点是，因为你总是修改最小值，你不是在重构代码库，让它进入一个更好的状态。</p><h2 id="4a1d" class="mc lf jj bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">覆盖和修改</h2><p id="1ede" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">您可以使用的另一种方法是“覆盖和修改”，您可以在现有代码中添加测试，现在您有了一个安全网，可以更加自信地进行更改。您现在可以自由重构了。</p><p id="d007" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了生成这些测试，我们将使用一种称为Golden Master tests的技术，基本上我们将输入输入到现有系统并存储其结果，这样我们可以验证以后的行为是否仍然相同。</p><h1 id="26a7" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">行会玫瑰形</h1><p id="d120" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我们将与K <a class="ae jg" href="https://github.com/emilybache/GildedRose-Refactoring-Kata" rel="noopener ugc nofollow" target="_blank"> ata </a>一起工作，但是不要担心代码，因为我将提取一些内容，这样我们可以一起浏览。</p><p id="38e4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑这些要求:</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5192" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷，要求看起来不太难，它只是添加这个“变戏法”的项目，这里是现有的实现:</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2102" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当容易阅读，是吗？</p><p id="71a9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将如何继续修改代码？你能简单地添加一个条件吗，如果名字等于“被召唤”产生新的行为并返回它？这是一种方法，你甚至可以通过“仔细编辑的方法”来做到这一点，但这将使代码库处于这种糟糕的状态。</p><p id="028a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以一种更安全的方式来做这件事，让我们覆盖现有的行为，重构它，这样我们就可以很容易地添加我们的新行为。</p><blockquote class="na"><p id="ef60" class="nb nc jj bd nd ne nf ng nh ni nj ld dk translated">这是我鼓励开发人员考虑的一点，不要急于添加功能，而是问问自己，这些代码是否易于扩展，或者重构是否可以使扩展更加简单？</p></blockquote><h2 id="fb2b" class="mc lf jj bd lg md nk dn lk mf nl dp lo kr nm mi ls kv nn mk lw kz no mm ma mn bi translated">第一步——盖住它</h2><p id="a18d" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我将和老师一起做这个练习。net core版本，位于“csharpcore”下，来自guild Rose<a class="ae jg" href="https://github.com/emilybache/GildedRose-Refactoring-Kata" rel="noopener ugc nofollow" target="_blank">Kata GitHub</a>。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7f3bdb4fb59209fbb8fb04c2ca704072.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*9hqFICMIWco4ySeQj9fr1g.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">GuildedRose解决方案资源管理器</figcaption></figure><p id="9f90" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">形已经为你设置好了，你只需要学习你的第一个金主测试，这是批准文件的样子:</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="79f3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是使用一个名为<a class="ae jg" href="https://approvaltests.com/" rel="noopener ugc nofollow" target="_blank"> ApprovalTests </a>的包，它将捕获程序的输出，将其存储在一个文件中，然后用它来进行比较。因此，第一次运行测试时，您应该会看到一个如下所示的“diff”屏幕:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/88dbb67050e26d1531005a87c1cd7d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_sQonxxgyrTBp3OLkL14A.png"/></div></div></figure><p id="d6cb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该测试正在生成一个名为<em class="nr"> ApprovalTests的文件。ThirtyDays.received.txt </em>，然后与<em class="nr">approval tests . thirty days . approved . txt .</em>做一个简单的字符串比较</p><p id="7892" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是批准的文件还不存在，这是您验证输出的地方，通过将接收到的文件的内容放入批准的。我建议你复制收到的文件，然后简单地重新命名。</p><p id="789f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你的批准测试应该通过了。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/134c8b21b53cb6790dfd43b74c18773a.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*a0oCLrahm180tTIdUDduqg.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">批准测试通过</figcaption></figure><p id="ebde" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们这样做的全部目的是创建我们的安全网，所以让我们看看我们能在多大程度上依赖我们的测试。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/92bf8ae8fd7063a1beba9cb759a60d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6hhUm5VZyNdcv-kT"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">一个热爱安全网安装工作的人</figcaption></figure><p id="fabd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">突变测试</strong></p><p id="c2a2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将故意打破以前的逻辑，看看测试是否失败，简单的事情，如反转if，注释代码部分，等等。如果测试之后仍然是绿色的，那就是一个遗漏的覆盖率。尝试一下:</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="406d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如所料，我们的程序开始给出不同的输出，测试失败:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/4d3e9fb3f1e486e4d3278a5819725219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yfi4h0ypyJ04-NwF9k9I9A.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">received.txt和approved.txt之间的批准测试差异</figcaption></figure><h2 id="86e5" class="mc lf jj bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">步骤2——重构</h2><p id="acd6" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">很好，现在我们有了安全网，我们可以自由重构了。我们如何使它更容易扩展？</p><p id="d5aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在讨论重构的主要目标之前，我将从几件简单的事情开始:</p><ul class=""><li id="deaf" class="nv nw jj ki b kj kk kn ko kr nx kv ny kz nz ld oa ob oc od bi translated">删除“Items[i]”的重复项，只将该项用作变量。</li><li id="a026" class="nv nw jj ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">把<em class="nr">里面的所有东西都换成</em>的另一种方法，以减少嵌套，嵌套是罪恶的，尽量把它保持到最小。</li></ul><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cb1d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道这并没有带来很大的不同，但它是下一次重构的基础。</p><p id="3787" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我看到这样的需求，不同类型的对象有不同的行为，我立刻想到一个策略模式:</p><blockquote class="oj ok ol"><p id="e12a" class="kg kh nr ki b kj kk kl km kn ko kp kq om ks kt ku on kw kx ky oo la lb lc ld im bi translated">在<a class="ae jg" href="https://en.wikipedia.org/wiki/Computer_programming" rel="noopener ugc nofollow" target="_blank">计算机编程</a>中，<strong class="ki jk">策略模式</strong>(也称为<strong class="ki jk">策略模式</strong>)是一种<a class="ae jg" href="https://en.wikipedia.org/wiki/Behavioral_design_pattern" rel="noopener ugc nofollow" target="_blank">行为</a> <a class="ae jg" href="https://en.wikipedia.org/wiki/Design_pattern_(computer_science)" rel="noopener ugc nofollow" target="_blank">软件设计模式</a>，它允许在运行时选择一种<a class="ae jg" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>。代码不是直接实现单个算法，而是接收运行时指令，以决定使用哪一组算法。</p></blockquote><p id="fe86" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例类图:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/51e7eb475a63d09026988d03277117db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NorYHa8otDQ4efImyOn8dA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">此场景的策略模式的类图</figcaption></figure><p id="0f48" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从重构开始，我寻找最简单的产品类型来实现，在我看来是Sulfuras，因为它什么也不做。</p><p id="2f83" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过为Sulfuras实现工厂和行为，我现在可以执行Sulfuras策略，更新质量并返回它。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1d54" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在Sulfuras不再运行在以前的代码上，我们可以在现有代码上寻找任何定制的实现并进行清理。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/cdf8dbb0b37ea69cba190381dfaad2b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkZ1gWHRDGJb8u-cWaiw8A.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">示例<a class="ae jg" href="https://github.com/RaphaelYoshiga/GildedRose-Refactoring-Kata/commit/0b2dbd2f0a070bcb4a07c89b168d589d984a09f7" rel="noopener ugc nofollow" target="_blank">提交</a>。</figcaption></figure><p id="c8e4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对陈年布里干酪和音乐会重复这一过程，我们得到:</p><blockquote class="oj ok ol"><p id="be52" class="kg kh nr ki b kj kk kl km kn ko kp kq om ks kt ku on kw kx ky oo la lb lc ld im bi translated">注意:我已经重命名为QualityUpdateStrategy，因为我认为它更好地描述了它。</p></blockquote><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b6eb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它已经好多了，但现在剩下的是GuildedRose。如果工厂不知道产品，这是默认行为，因此我们可以简化:</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="1307" class="mc lf jj bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">第三步——扩展它</h2><p id="ba64" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">现在我们已经有了策略模式，添加另一个策略是小菜一碟:</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="34b8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，将它添加到工厂中，现在解决方案可以处理变出来的项目。</p><h2 id="6284" class="mc lf jj bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">步骤4 —更新现有的认证测试</h2><p id="81ae" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">添加了想象的行为后，您还可以确保它包含在批准测试中。批准测试的产品列表在Program.cs上，所以如果您添加一个魔法物品，您将看到新产品及其行为。</p><p id="51e8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用新产品运行测试会生成不同的输出:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/4f85de66de93ec524b0c6544bc1456cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6QQWcXZWTTk94DPwLU01Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">添加新产品的审批流程</figcaption></figure><p id="cda3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重复批准received.txt到approved.txt之间的过程，并提交新的approved.txt文件。</p><h1 id="2301" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8df3" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">我们通过两种方式来扩展遗留系统，“编辑和祈祷”和“覆盖和修改”。我想说的是，这两种方法都有其用武之地，所以金主是你武器库中的一项伟大技术。此外，我们还看到了如何使用策略模式使代码更具可读性、可扩展性和可维护性。测试愉快。</p></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><h2 id="205b" class="mc lf jj bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">来源:</h2><ul class=""><li id="4f8c" class="nv nw jj ki b kj mt kn mu kr oz kv pa kz pb ld oa ob oc od bi translated"><a class="ae jg" href="https://github.com/emilybache/GildedRose-Refactoring-Kata" rel="noopener ugc nofollow" target="_blank">原始回购</a>。</li><li id="bfb4" class="nv nw jj ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated"><a class="ae jg" href="https://github.com/RaphaelYoshiga/GildedRose-Refactoring-Kata/tree/refactor/csharpcore" rel="noopener ugc nofollow" target="_blank">我与重构最终结果的分歧</a>。</li></ul></div></div>    
</body>
</html>