<html>
<head>
<title>Uploading Files to Digital Ocean Spaces with VueJS &amp; Node / Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用VueJS &amp; Node / Express将文件上传到数字海洋空间</h1>
<blockquote>原文：<a href="https://itnext.io/uploading-files-to-digital-ocean-spaces-with-vuejs-node-express-5d2361553518?source=collection_archive---------5-----------------------#2019-02-11">https://itnext.io/uploading-files-to-digital-ocean-spaces-with-vuejs-node-express-5d2361553518?source=collection_archive---------5-----------------------#2019-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近在我的最新项目中，我想整合文件上传。过去我使用React、Node和亚马逊S3来做这件事，但这次我使用Vue (w/ Vue CLI 3) &amp;运行一个数字海洋盒子。虽然设置它很容易，但有几个问题让我疯狂地搜索Stack Overflow/Github——在本文中，我想我会概述我所经历的过程/代码，所以希望你能学到一些东西并节省时间；)到最后，你将可以从Vue应用程序上传文件到数字海洋空间。</p><h1 id="e953" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">技术堆栈</h1><p id="3d72" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在我们开始之前——这里是我在(Ubuntu 18.0.4)服务器上使用的主要技术:</p><ul class=""><li id="90d0" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">节点10</li><li id="592b" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">快递4.16.14</li><li id="f133" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">Multer 1.4.1和Multer S3 2.9.0</li><li id="e84f" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">AWS SDK (JavaScript)</li></ul><p id="8a3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而客户端:</p><ul class=""><li id="815b" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">带有Vue CLI 3的Vue 2.5.21</li><li id="0448" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">15年3月1日</li><li id="c15b" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">Vuex 3.0.1</li><li id="4c10" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">Axios 0.18</li></ul><h1 id="351d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">让我们从客户端开始。</h1><p id="1dfc" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我将假设您已经建立了一个Vue项目，如果您没有使用Vuetify，大部分代码仍然适用，只是标记略有不同。对于这篇文章，我将使用上传个人资料图片/头像的例子，但它适用于任何类型的文件上传！</p><p id="4e64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使人们能够上传文件，你需要某种组件，我选择在用户点击他们当前的个人资料图片时打开一个模态。在该模式中，我包含了当前用户的个人资料图片，以及3个按钮:上传、保存和取消:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/6e78cdf62806cfff851dadbf7d78b998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*rnVzNodhniLGKYANBEBvQA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">在这里，我使用v-if指令显示用户的旧个人资料图片，直到新图片加载到客户端</figcaption></figure><p id="ec2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到上传按钮不同于取消和保存——它是一个叫做<em class="ms">的组件，你可以在这里找到它:https://github.com/doritobandito/vuetify-upload-button<a class="ae mt" href="https://github.com/doritobandito/vuetify-upload-button" rel="noopener ugc nofollow" target="_blank"/></em></p><p id="8b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我之所以使用这个组件，是因为Vuetify目前还没有一个专门的上传组件，它包含了一些方便的默认设置。单击local按钮将打开本地文件系统对话框，让您选择一个文件——在本例中是一个图像(您可以添加额外的代码来限制客户机和服务器上的文件类型和大小)。</p><p id="d15b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦文件被选中，upload按钮上的:fileChangedCallback将被触发。回调被命名为fileChanged，并在模板的方法中定义:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d1a2359f8ac4fa7884c940c5b2078596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*zW5NcC6lyR46vINwM_Cc7A.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">当用户从他们的本地目录中选择一个文件时，fileChanged被触发</figcaption></figure><p id="45db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UploadButton自动获取文件数据并将其提供给回调。你必须自己定义回调代码，当第一次使用UploadButton时，我没有意识到我必须包含FileReader API，这是一个本地Web API:<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/FileReader</a></p><p id="8a41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FileReader API处理读取存储在用户计算机上的文件内容，并且可以处理File和Blob对象。值得阅读一下MDN页面，以便对它在幕后做了什么有一个基本的了解！</p><p id="8eca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FileReader API是异步的，所以我们向“load”事件添加一个eventListener，并在文件被读取时提供一个回调——这里我添加了一个arrow函数，然后将图像和文件保存到我的模板的数据对象中。更新数据会触发模板上的v-if块，并在模态中显示新图像，向用户反馈他们选择的图像就是他们想要的。</p><p id="ea94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，用户可以1。)取消操作2。)添加新图像或3。)将新图像保存到他们的个人资料中。我使用的命名约定可能不是最好的，将来可能会改变，但这是它的基本要点:)我们感兴趣的是当用户单击Save按钮时会发生什么——调用@click回调，名为<em class="ms"> uploadImage </em>。当uploadImage被调用时，我们做两件事:</p><ol class=""><li id="7d3b" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk mv lu lv lw bi translated">将模板数据的“加载”属性更改为true以触发任何加载动画</li><li id="c052" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk mv lu lv lw bi translated">将文件发送到我们的Vuex商店</li></ol><p id="1209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢将我的Vuex存储拆分成多个模块，使其更易于管理，因此这里我将一个动作分派给“File/uploadFile”——这将在一个我称为“File”的Vuex模块中触发该动作。你想叫它什么都可以。当动作成功返回时，它会将“loading”切换回false &amp;还会自动关闭模态，但这取决于您。让我们看看在这两个步骤之间会发生什么..</p><h1 id="4723" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">与来自Vue的Express REST API通信</h1><p id="462b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在文件模块中，动作被触发，并调用我在Vue应用程序中命名的‘File API’。我喜欢在我的Vue项目中有一个专门的部分来与服务器交互——有些人可能会称之为“服务”,再说一次，因为我们正在使用JavaScript，所以选择最终取决于你——找到一个你喜欢的约定并坚持下去。文件模块如下所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5aa836b62a26709985c97332f2e377b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*wmioHLEIQNvyCBXKvLgePw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">我们在顶部导入“fileAPI ”,并从动作中调用它</figcaption></figure><p id="f91e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于对服务器的调用将是异步的，所以我将uploadFile操作设为异步，允许我们等待服务器上完成上传和处理，然后让客户端知道什么时候完成了(或者出错了！).fileAPI也非常简单——它使用Axios向服务器发出HTTP请求，然后处理响应:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8bf63530cfcb4715e1121beed9542745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*-M4vL7_AOpl4s8wgUjtn7w.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">“HTTP”模块只是Axios的一个包装器，用于处理定制的auth头</figcaption></figure><p id="09cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，如果你使用的是普通的Axios，那么它会显示<em class="ms"> HTTP </em>。帖子上会说<em class="ms"> Axios </em>。发帖代替。这里有几件事需要注意。因为我们通过网络发送特定类型的数据，所以我们想让我们的服务器知道“Content-Type”头，并创建一种Multer能够在文件发送时为我们处理的数据类型。为此，我们使用了FormData接口:【https://developer.mozilla.org/en-US/docs/Web/API/FormData】的<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank"/></p><p id="5fa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FormData接口将从图像文件中创建一个FormData对象，将其分配给我们将在服务器端使用的键“file”。</p><p id="5a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，深呼吸，我们已经完成了将近一半，我们成功地从用户的电脑上抓取了一个文件，并通过网络将其发送到服务器，现在我们必须处理请求，将文件发送到我们的数字海洋空间，确保一切按计划进行，并让客户知道！</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="beab" class="kl km iq bd kn ko nf kq kr ks ng ku kv kw nh ky kz la ni lc ld le nj lg lh li bi translated">在Express服务器上处理文件上传</h1><p id="5cfe" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我将再次忽略设置节点/快速服务器的基础知识，并假设您已经完成了设置。在这里，我们将检查请求的处理，处理文件，发送给数字海洋空间，然后响应客户端。</p><p id="774a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">路线&amp;控制器</strong></p><p id="e9e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在服务器上，我已经分离了路由和控制器，所以我首先处理路由，然后将它传递给控制器(在运行完我想要用来过滤请求的任何中间件之后)。因此，对于路由api.domain.com/upload/media，我有以下处理程序:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3ce00af8cc4bf4941da2b00280fc516f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*eNp9jtlLyQJHo29l3ENUcQ.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">路由处理器将把请求传递给uploadController(在auth之后)</figcaption></figure><p id="c7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">uploadController是真正完成工作的地方，所以让我们来看看它。这里有几个部分，所以我将把它分成几个部分:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7fd9da68729b1f76a68e91e8f9696f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*fYqo-TvWqgGtbBXQfAgbMA.png"/></div></figure><p id="0cca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于数字海洋空间与AWS S3 API兼容，我们可以使用AWS SDK来建立与空间的连接。当你在数字海洋创建一个空间的时候，你的终点就已经决定了——如果你还没有这样做的话，这里有一个指南:<a class="ae mt" href="https://www.digitalocean.com/docs/spaces/how-to/create/" rel="noopener ugc nofollow" target="_blank">https://www.digitalocean.com/docs/spaces/how-to/create/</a></p><p id="46de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要Multer和Multer S3来处理从客户端发送的表单数据，需要path模块来处理文件扩展名(默认情况下Multer不处理)。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6a6866cce1131299a0ac689bf5bd2e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*LQBIbtDi_koGkRA0RRX6bQ.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">将您的秘密和API密钥存储在流程变量中</figcaption></figure><p id="302d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">存储密钥</strong></p><p id="f4d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，当在服务器上存储秘密信息时，最好不要将文件签入版本控制，而是直接在服务器上处理它们。有几种方法可以做到这一点，包括dotenv(<a class="ae mt" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank">https://github.com/motdotla/dotenv</a>)，将它们设置在你的package.json中，或者使用类似于http://pm2.keymetrics.io/docs/usage/environment/PM2的过程管理器</p><p id="67e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，因为我们使用的是AWS SDK，所以这些键被称为AWS_ACCESS_example，但是当使用数字海洋空间时，这些键将是您的空间凭证。此外，您可能会遇到一些教程，建议您将AWS机密存储在用户文件夹中——我对此并不在意，而是将它们保存在本地的dotenv上，并在服务器上单独处理它们。</p><p id="1356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">发送文件到空间&amp;处理响应</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4c265cb9ca55221b5ab085517de7b6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*mBzzjjzTE3juMmsze_VoGw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">我使用了一个名为“haikunate”的模块来创建独特的、人类可读的文件名</figcaption></figure><p id="d900" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们使用Multer &amp; Multer S3添加我们的凭证，定义一个名称，并从表单数据中选择“文件”属性。在定义文件名时，我在试图直接将它添加到回调中时遇到了一点问题，所以我在调用回调之前定义了它(这花了我30分钟的时间才弄明白为什么没有应用自定义名称……)。</p><p id="331e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里还有一个问题，我花了一点时间才弄明白。uploadMedia控制器接收请求对象(req ),将其传递给“upload”Multer函数，并在我们传递给“upload”的回调中接收req对象。当req对象最初返回时，我不确定如何获取我上传的文件的名称——因此正如您所看到的，关于上传文件的信息在req.files[0]对象中location属性为您提供了完整的上传URL。这是很有必要的，因为你可能会想把这个网址保存到一个数据库中，例如保存到一个用户档案中。我在一个单独的控制器中实现了这一点，该控制器使用MongoDB数据库(通过Mongoose接口)将URL保存到用户集合中。我将把它粘贴到这里，这样您就可以看到我在成功地将文件发送到数字海洋后是如何处理它的了:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4540e4c913e25feda2c3b1383b07f0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*g556MJmdJ1feFIaq0aQfOw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">控制器/userController.js</figcaption></figure><p id="8dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在userController中，我有用户ID和“头像”(文件URL)。由于数据库写入是异步的，所以我使用了异步箭头函数，并运行一个快速查询，通过ID定位用户，然后将文档中的avatar属性设置为新的文件URL。我使用new: true选项返回更新的文档(在本例中实际上没有必要)，使用。lean()方法返回一个普通的JSON对象，并且只从更新后的用户中选择_id &amp; avatar属性。</p><p id="830b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到，我已经在uploadController中向客户端发送了一个响应——这是一个急切的更新，因为成功响应是在我更新数据库中的用户之前发送的，但是在这样一个简单的操作中，我可以这样做——对于更复杂的上传/更大或更多的文件，您可能希望在确认和发送成功响应之前发送一个关于上传进度的更新流。在我的userEvents文件中，我实际上使用socket.io向用户的朋友广播头像更新，因此更新不仅传播给用户，还传播给他们的所有联系人。</p><p id="4b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">提醒客户端</strong></p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi np"><img src="../Images/87ebe0299c158d588391f9eed9692a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndWBQ7bT2VMjEIpHzrpEVA.png"/></div></div></figure><p id="3ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重申一下——一旦服务器完成了它的工作，它就以HTTP状态200进行响应，Axios处理该响应并将其传递回文件模块中的动作，该动作以原始模式返回对初始调用的“真”响应:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/aea0a3dba7dfbf1f2cb4cfcde98553aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*GWY4BpcodQs4O7iqgjRR3Q.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">我们可以将“then”调用链接到处理承诺解决方案的操作上</figcaption></figure><h1 id="a380" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">成功！</h1><p id="42d3" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">就这样——我们完成了从客户端到服务器的往返，通过数字海洋空间，更新了数据库中的用户，并成功返回到客户端。有相当多的准备工作要做，但是一旦底层代码设置好了，就非常简单了。</p><p id="26dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了反映更新后的用户头像，你需要在你的商店中处理它(我有一个用户商店)，然后它会在你的Vue应用中更新用户头像URL。</p><p id="7120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，你可以对此进行改进——例如，你可以包括上传进度通知，在文件上传到服务器后对其进行额外的处理，或者在用户上传视频或音乐文件时想办法将数据流回。</p><p id="894f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这给了你一个良好的工作基础，并在这个过程中节省了你一点时间！如果你想澄清，如果你发现了任何错误，或者你有更好的方法来处理Vue上传，请在评论中告诉我:)</p><p id="e8b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯！</p><p id="340b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">##我在Twitter、Github、LinkedIn和大多数其他地方都是/jacobedawson——随时联系。</p></div></div>    
</body>
</html>