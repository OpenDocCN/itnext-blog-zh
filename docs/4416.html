<html>
<head>
<title>Using AWS NLB manually targeting an EKS Service exposing UDP traffic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS NLB手动定位暴露UDP流量的EKS服务</h1>
<blockquote>原文：<a href="https://itnext.io/using-aws-nlb-manually-targeting-an-eks-service-exposing-udp-traffic-17053ecd8f52?source=collection_archive---------0-----------------------#2020-06-26">https://itnext.io/using-aws-nlb-manually-targeting-an-eks-service-exposing-udp-traffic-17053ecd8f52?source=collection_archive---------0-----------------------#2020-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="9e8f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">EKS 1.16遇到的问题</h1><p id="70de" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们尝试为UDP流量创建一个类型为<a class="ae lj" href="https://aws.amazon.com/elasticloadbalancing/" rel="noopener ugc nofollow" target="_blank">网络负载平衡器</a> (NLB)的服务，我们会得到以下错误:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="fb65" class="lt jo iq lp b gy lu lv l lw lx">Error creating load balancer (will retry): failed to ensure load balancer for service default/test: Only TCP LoadBalancer is supported for AWS ELB</span></pre><p id="404b" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">这是因为UDP对NLB的支持比kubernetes内部开发的用于创建NLB负载平衡器的功能更近<a class="ae lj" href="https://hackmd.io/Pzw60ReSRuarZcwyZUxCfA" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7b60" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">本期报告了该错误:<a class="ae lj" href="https://github.com/kubernetes/kubernetes/issues/79523" rel="noopener ugc nofollow" target="_blank"> #79523 </a>，目前正在由AWS进行调查。</p><p id="3c6c" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">我们将解决这一实际限制</p><h1 id="bf9b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用节点端口Kubernetes服务</h1><p id="014d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">同时，我们可以手动配置一个NLB来指向我们的EKS实例，并配置一个Kubernetes <strong class="kn ir"> NodePort </strong>服务来代替<strong class="kn ir">负载平衡器</strong>。</p><p id="c768" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">在节点端口模式下，每个实例将监听每个EC2实例上的预定义端口(范围在30000–32767之间), Kubernetes会将流量转发到相关的Kubernetes pods:</p><figure class="lk ll lm ln gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi md"><img src="../Images/f80584665eb944799c10f061de891741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9GHtA1tRTjqsAMZx.png"/></div></div></figure><h1 id="9eb0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">示例:使用NLB公开kube-dns</h1><p id="875d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，我们将通过手动创建的NLB来展示Kubernetes core-dns pods。我们选择core-dns，它在端口53上公开一个UDP服务。</p><h1 id="b46e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创建kubernetes节点端口服务</h1><p id="a5a2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这些pod有标签<code class="fe ml mm mn lp b">k8s-app: kube-dns</code>,因此我们可以创建一个新的NodePort类型的服务:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="d381" class="lt jo iq lp b gy lu lv l lw lx">cat &lt;&lt; EOF &gt; service-kube-dns-nodeport.yaml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: service-kube-dns-nodeport<br/>  namespace: kube-system<br/>  labels:<br/>    app.kubernetes.io/name: service-kube-dns-nodeport<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - name: dns-udp<br/>      port: 53<br/>      targetPort: 53<br/>      nodePort: 30053<br/>      protocol: UDP<br/>    - name: dns-tcp<br/>      port: 53<br/>      targetPort: 53<br/>      nodePort: 30054<br/>      protocol: TCP<br/>  selector:<br/>    k8s-app: kube-dns<br/>EOF</span></pre><p id="410c" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">让我们将服务定义应用于EKS集群。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="91e6" class="lt jo iq lp b gy lu lv l lw lx">k apply -f service-kube-dns-nodeport.yaml</span></pre><p id="e9b5" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">我们已经定义了一个UDP端口30053，它将监听每个实例，并转发到端口53上的kube-dns pods。</p><p id="cd02" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">我们还定义了一个TCP端口30054，NLB将在配置healthcheck端口时使用该端口。</p><blockquote class="mo mp mq"><p id="4746" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">此服务必须部署在</em><strong class="kn ir"><em class="iq">kube-system</em></strong><em class="iq">名称空间中，因为coredns-pods部署在那里。</em></p></blockquote><h2 id="54fc" class="lt jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">(可选)对服务进行内部测试</h2><p id="4362" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个阶段，我们已经创建了Kubernetes服务，它已经在监听每个实例。在创建NLB之前，我们可以检查它是否在Kubernetes集群内部工作:</p><p id="c0f2" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">我们可以使用一个特定的kubernetes pod<a class="ae lj" href="https://raw.githubusercontent.com/allamand/eksutils/master/eksutils-pod.yaml" rel="noopener ugc nofollow" target="_blank">eks utils-pod</a>来调试kubernetes中的东西。</p><p id="6d74" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">在默认名称空间中创建eksutils pod:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2b84" class="lt jo iq lp b gy lu lv l lw lx">kubectl apply -f <a class="ae lj" href="https://raw.githubusercontent.com/allamand/eksutils/master/eksutils-pod.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/allamand/eksutils/master/eksutils-pod.yaml</a></span></pre><p id="1e93" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">然后，我们可以在pod内部进行连接，看看我们是否能够基于内部服务进行dns解析。</p><p id="5f9b" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">在下面的例子中，对于每个Kubernetes节点，我请求metrics名称空间中的grafana服务。将它更改为指向集群中现有的服务。它还检查TCP端口30054上的连接</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1877" class="lt jo iq lp b gy lu lv l lw lx">$ kubectl exec -n default -ti eksutils-pod zsh<br/>eksutils@eksutils-pod $ for x in $(k get nodes -o wide | awk '{print $6}' | grep -v INTERNAL); do echo $x ; dig @$x -p 30053 grafana.metrics.svc.cluster.local ; telnet $x 30054 ; done</span></pre><p id="0ed0" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">这将在端口30053 UDP上的每个节点上，在metrics名称空间中对grafana服务进行dns查找，并尝试在端口30054 TCP上连接每个端口。</p><h1 id="c2ec" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创建网络负载平衡器</h1><p id="ce9f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在EKS集群的同一个vpc中获取实例的子网</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="7d5d" class="lt jo iq lp b gy lu lv l lw lx">VPC_ID=vpc-027f50fc9d05149f0<br/>aws ec2 describe-instances --filters Name=network-interface.vpc-id,Values=$VPC_ID \<br/> --query 'Reservations[*].Instances[*].SubnetId' --output text | sort | uniq -c<br/>   5 subnet-0378859fcc9e53fa6<br/>   5 subnet-055b4b800624d3b99</span></pre><blockquote class="mo mp mq"><p id="6ed6" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">注意:只有当您的EKS集群有一个专用的vpc时，才可以这样做。如果不是这样，您需要过滤以仅匹配您想要的实例。</em></p></blockquote><p id="5eba" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">首先，使用工作节点的子网创建NLB</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8982" class="lt jo iq lp b gy lu lv l lw lx">NLB_NAME=kube-dns-nlb<br/>aws elbv2 create-load-balancer --name $NLB_NAME\<br/>  --type network \<br/>  --subnets subnet-0378859fcc9e53fa6 subnet-055b4b800624d3b99</span></pre><h2 id="a440" class="lt jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">为您的NLB创建目标群体</h2><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c394" class="lt jo iq lp b gy lu lv l lw lx">TG_NAME=kube-dns-tg<br/>aws elbv2 create-target-group --name $TG_NAME --protocol UDP --port 30053 --vpc-id $VPC_ID \<br/>  --health-check-protocol TCP \<br/>  --health-check-port 30054 \<br/>  --target-type instance</span></pre><h2 id="6050" class="lt jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">在目标组中注册实例</h2><p id="260a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们希望将属于EKS集群的每个节点添加为NLB目标组的目标。获取实例列表</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="86f9" class="lt jo iq lp b gy lu lv l lw lx">INSTANCES=$(kubectl get nodes -o json | jq -r ".items[].spec.providerID"  | cut -d'/' -f5)<br/>IDS=$(for x in `echo $INSTANCES`; do echo Id=$x ; done | tr '\n' ' ')<br/>echo $IDS</span></pre><p id="227a" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">注册实例:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="cc28" class="lt jo iq lp b gy lu lv l lw lx">TG_ARN=$(aws elbv2 describe-target-groups --query 'TargetGroups[?TargetGroupName==`kube-dns-tg`].TargetGroupArn' --output text)</span><span id="7fb7" class="lt jo iq lp b gy ng lv l lw lx">aws elbv2 register-targets --target-group-arn $TG_ARN --targets $(echo $IDS)</span></pre><h2 id="6a63" class="lt jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">为目标组创建一个监听器</h2><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9ace" class="lt jo iq lp b gy lu lv l lw lx">LB_ARN=$(aws elbv2 describe-load-balancers --names $NLB_NAME --query 'LoadBalancers[0].LoadBalancerArn' --output text)<br/>echo $LB_ARN</span><span id="d9a2" class="lt jo iq lp b gy ng lv l lw lx">aws elbv2 create-listener --load-balancer-arn $LB_ARN \<br/>  --protocol UDP --port 53 \<br/>  --default-actions Type=forward,TargetGroupArn=$TG_ARN</span></pre><p id="0165" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">检查监听器</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e3e1" class="lt jo iq lp b gy lu lv l lw lx">aws elbv2 describe-listeners --load-balancer-arn $LB_ARN</span></pre><p id="4f61" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">检查目标的健康状况</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e067" class="lt jo iq lp b gy lu lv l lw lx">aws elbv2 describe-target-health --target-group-arn $TG_ARN</span></pre><blockquote class="mo mp mq"><p id="e842" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">应该是不健康的，直到我们配置实例的SG。</em></p></blockquote><h1 id="980d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">配置实例安全组</h1><p id="b62a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了允许运行状况检查，我们需要允许NLB的IP访问实例的安全组中的端口30054</p><p id="b753" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">从所有实例的实例id中获取安全组</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e9e7" class="lt jo iq lp b gy lu lv l lw lx">SGs=$(for x in $(echo $INSTANCES); do aws ec2 describe-instances --filters Name=instance-id,Values=$x \<br/> --query 'Reservations[*].Instances[*].SecurityGroups[0].GroupId' --output text ; done | sort | uniq)</span></pre><p id="29a5" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">向安全组添加规则</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="eb40" class="lt jo iq lp b gy lu lv l lw lx">for x in $(echo $SGs); do <br/>  echo SG=$x; <br/>  aws ec2 authorize-security-group-ingress --group-id $x --protocol tcp --port 30054 --cidr 192.168.0.0/16; </span><span id="8bbc" class="lt jo iq lp b gy ng lv l lw lx">  aws ec2 authorize-security-group-ingress --group-id $x --protocol udp --port 30053 --cidr 0.0.0.0/0 ; <br/>done</span></pre><blockquote class="mo mp mq"><p id="6922" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">您可以使用</em>打开真实的NLB Ip地址，而不是从192.168.0.0/16打开</p><p id="d85b" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><code class="fe ml mm mn lp b"><em class="iq">NLB_NAME_ID=$(aws elbv2 describe-load-balancers --names $NLB_NAME --query 'LoadBalancers[0].LoadBalancerArn' --output text | awk -F":loadbalancer/" '{print $2}') aws ec2 describe-network-interfaces \ --filters Name=description,Values="ELB $NLB_NAME_ID" \ --query 'NetworkInterfaces[*].PrivateIpAddresses[*].PrivateIpAddress' --output text</em></code></p></blockquote><h1 id="07ab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">测试一下</h1><p id="ef62" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一旦目标正常，您就可以测试访问了。找到您的NLB的URL并测试它的访问(确保您的端口53可以访问互联网)</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="208f" class="lt jo iq lp b gy lu lv l lw lx">LB_DNS=$(aws elbv2 describe-load-balancers --name $NLB_NAME --query 'LoadBalancers[0].DNSName' --output text</span><span id="c0bc" class="lt jo iq lp b gy ng lv l lw lx">echo $LB_DNS</span></pre><p id="a900" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">用dig测试我们新公开域名服务器:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4696" class="lt jo iq lp b gy lu lv l lw lx">$ dig @$LB_DNS grafana.metrics.svc.cluster.local<br/>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @kube-dns-nlb-a688e8ddf1200136.elb.us-east-1.amazonaws.com grafana.metrics.svc.cluster.local<br/>; (2 servers found)<br/>;; global options: +cmd<br/>;; Got answer:<br/>;; WARNING: .local is reserved for Multicast DNS<br/>;; You are currently testing what happens when an mDNS query is leaked to DNS<br/>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 53980<br/>;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1<br/>;; WARNING: recursion requested but not available</span><span id="6f98" class="lt jo iq lp b gy ng lv l lw lx">;; OPT PSEUDOSECTION:<br/>; EDNS: version: 0, flags:; udp: 4096<br/>;; QUESTION SECTION:<br/>;grafana.metrics.svc.cluster.local. IN	A</span><span id="b13a" class="lt jo iq lp b gy ng lv l lw lx">;; ANSWER SECTION:<br/>grafana.metrics.svc.cluster.local. 5 IN	A	10.100.165.230</span><span id="5509" class="lt jo iq lp b gy ng lv l lw lx">;; Query time: 98 msec<br/>;; SERVER: 54.164.194.190#53(54.164.194.190)<br/>;; WHEN: Wed May 13 19:27:47 CEST 2020<br/>;; MSG SIZE  rcvd: 111</span></pre><p id="c8ad" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">我们可以看到，我们能够请求我们公开的DNS服务器。</p><h1 id="4fb7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在我们的负载平衡器中自动创建目标</h1><h1 id="dc86" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">缩放实例</h1><p id="4be8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您添加一些EKS实例，您将需要在您的NLB目标组中添加这些实例，以便能够在这些实例上分散负载。</p><p id="1457" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">当缩小规模时，旧实例将变得不健康，它们将自动从目标组中取消注册和消失，因此在这种情况下不需要采取特定的操作。</p><p id="df2d" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">我们想找到一种方法来自动化的插件在NLB的新目标时，我们正在做一个扩展。</p><blockquote class="mo mp mq"><p id="e190" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">我们可以配置Amazon EC2 Auto Scaling，以便在我们的Auto Scaling组进行扩展时向CloudWatch Events发送事件。</em></p></blockquote><figure class="lk ll lm ln gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nh"><img src="../Images/8a46cdbd43c7dfb7cca4d4b6704d203b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DbnwBhhCuk7O_WT1.png"/></div></div></figure><p id="d09b" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">这里的想法是，每当我们的EKS集群的自动扩展组创建一个实例时，这些实例就会自动添加到NLB目标组中。</p><h2 id="35a5" class="lt jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">创建一个Lambda函数来自动添加NLB中的实例</h2><p id="a1f0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建Lambda函数，将通过自动缩放组添加的实例添加到NLB目标组</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="2c5e" class="lt jo iq lp b gy lu lv l lw lx">import json<br/>import boto3<br/>from pprint import pprint</span><span id="c9f9" class="lt jo iq lp b gy ng lv l lw lx">LbName="kube-dns-nlb" #&lt;- change accoring to your setup</span><span id="88c0" class="lt jo iq lp b gy ng lv l lw lx">print('Loading function')</span><span id="b316" class="lt jo iq lp b gy ng lv l lw lx">elb = boto3.client('elbv2')</span><span id="d6eb" class="lt jo iq lp b gy ng lv l lw lx">def find_lb_arn(name):<br/>    # describe load balancer name<br/>    lbs_list_response = elb.describe_load_balancers(Names=[name])<br/>    if lbs_list_response['ResponseMetadata']['HTTPStatusCode'] == 200:<br/>        print ("LBs list: " + ' '.join(p for p in [lb['LoadBalancerName']<br/>                                       for lb in lbs_list_response['LoadBalancers']]))<br/>        #We have only 1 lb    <br/>        lbArn = lbs_list_response['LoadBalancers'][0]['LoadBalancerArn']<br/>    else:<br/>        print ("Describe lbs failed")<br/>    return lbArn<br/></span><span id="25cf" class="lt jo iq lp b gy ng lv l lw lx">def lambda_handler(event, context):<br/>    print("AutoScalingEvent()")<br/>    print("Debug Event data = " + json.dumps(event, indent=2))<br/>    <br/>    target_id = event['detail']['EC2InstanceId']<br/>    print("We are going to add InstanceID = " + target_id)<br/>    <br/>    #Find load balancer arn<br/>    lbArn = find_lb_arn(LbName)<br/>    print ("lbArn="+lbArn)<br/>    <br/>    # Register targets<br/>    targets_list = [dict(Id=target_id)]<br/>  <br/>    describe_tg_response = elb.describe_target_groups(LoadBalancerArn=lbArn)<br/>    #pprint(describe_tg_response)<br/>    tgId = describe_tg_response['TargetGroups'][0]['TargetGroupArn']<br/>    print ("tgID = " + tgId)</span><span id="d206" class="lt jo iq lp b gy ng lv l lw lx">    #Register target in targetGroup<br/>    reg_targets_response = elb.register_targets(TargetGroupArn=tgId, Targets=targets_list)<br/>    if reg_targets_response['ResponseMetadata']['HTTPStatusCode'] == 200:<br/>        print ("Successfully registered targets")<br/>    else:<br/>        print ("Register targets failed")</span></pre><blockquote class="mo mp mq"><p id="5f77" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">您需要将</em> <strong class="kn ir"> <em class="iq"> LbName </em> </strong> <em class="iq">参数化为您想要将实例添加到</em>中的NLB的名称</p></blockquote><p id="ea2e" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">为我们的Lambda函数创建角色</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="a51d" class="lt jo iq lp b gy lu lv l lw lx">NAME=add-instance-to-nlb<br/>ACCOUNT_ID=$(aws sts get-caller-identity --output text --query 'Account')<br/>ASSUMEPOLICY=$(echo -n '{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Effect": "Allow",<br/>      "Principal": {<br/>        "Service": "lambda.amazonaws.com"<br/>      },<br/>      "Action": "sts:AssumeRole"<br/>    }<br/>  ]<br/>}')</span><span id="a886" class="lt jo iq lp b gy ng lv l lw lx">echo ACCOUNT_ID=$ACCOUNT_ID<br/>echo ASSUMEPOLICY=$ASSUMEPOLICY</span><span id="42d4" class="lt jo iq lp b gy ng lv l lw lx">LAMBDA_ROLE_ARN=$(aws iam create-role \<br/>  --role-name $NAME \<br/>  --description "Role to allow Lambda function to manage NLB targets" \<br/>  --assume-role-policy-document "$ASSUMEPOLICY" \<br/>  --output text \<br/>  --query 'Role.Arn')<br/>echo $LAMBDA_ROLE_ARN</span></pre><p id="b01b" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">将策略附加到角色</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="64cb" class="lt jo iq lp b gy lu lv l lw lx">aws iam attach-role-policy \<br/>  --role-name $NAME \<br/>  --policy-arn arn:aws:iam::aws:policy/ElasticLoadBalancingFullAccess</span><span id="f6f5" class="lt jo iq lp b gy ng lv l lw lx">LAMBDA_POLICY=$(echo -n '{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": "logs:CreateLogGroup",<br/>            "Resource": "arn:aws:logs:us-east-1:'; echo -n "$ACCOUNT_ID"; echo -n ':*"<br/>        },<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "logs:CreateLogStream",<br/>                "logs:PutLogEvents"<br/>            ],<br/>            "Resource": [<br/>                "arn:aws:logs:us-east-1:'; echo -n "$ACCOUNT_ID"; echo -n ':log-group:/aws/lambda/'; echo -n "$NAME"; echo -n ':*"<br/>            ]<br/>        }<br/>    ]<br/>}')<br/>echo $LAMBDA_POLICY</span><span id="3ba2" class="lt jo iq lp b gy ng lv l lw lx">LAMBDA_POLICY_ARN=$(aws iam create-policy \<br/>  --policy-name AWSLambdaBasicExecutionRole-$NAME \<br/>  --policy-document "$LAMBDA_POLICY" \<br/>  --output text \<br/>  --query 'Policy.Arn')<br/>echo $LAMBDA_POLICY_ARN</span><span id="d631" class="lt jo iq lp b gy ng lv l lw lx">aws iam attach-role-policy \<br/>  --role-name $NAME \<br/>  --policy-arn $LAMBDA_POLICY_ARN</span></pre><p id="045f" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">创建lambda函数(我已经用前面的Lambda代码创建了一个zip文件)</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c645" class="lt jo iq lp b gy lu lv l lw lx">aws lambda create-function \<br/>    --function-name $NAME \<br/>    --runtime python3.7 \<br/>    --zip-file fileb://~/environment/add-instance-to-nlb.zip \<br/>    --handler add-instance-to-nlb.lambda_handler \<br/>    --role $LAMBDA_ROLE_ARN</span></pre><p id="d952" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">用json测试来测试这个函数</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e65d" class="lt jo iq lp b gy lu lv l lw lx">{<br/>  "version": "0",<br/>  "id": "12345678-1234-1234-1234-123456789012",<br/>  "detail-type": "EC2 Instance Launch Successful",<br/>  "source": "aws.autoscaling",<br/>  "account": "123456789012",<br/>  "time": "yyyy-mm-ddThh:mm:ssZ",<br/>  "region": "us-west-2",<br/>  "resources": [<br/>      "auto-scaling-group-arn",<br/>      "instance-arn"<br/>  ],<br/>  "detail": {<br/>      "StatusCode": "InProgress",<br/>      "Description": "Launching a new EC2 instance: i-12345678",<br/>      "AutoScalingGroupName": "my-auto-scaling-group",<br/>      "ActivityId": "87654321-4321-4321-4321-210987654321",<br/>      "Details": {<br/>          "Availability Zone": "us-west-2b",<br/>          "Subnet ID": "subnet-12345678"<br/>      },<br/>      "RequestId": "12345678-1234-1234-1234-123456789012",<br/>      "StatusMessage": "",<br/>      "EndTime": "yyyy-mm-ddThh:mm:ssZ",<br/>      "EC2InstanceId": "i-1234567890abcdef0",<br/>      "StartTime": "yyyy-mm-ddThh:mm:ssZ",<br/>      "Cause": "description-text"<br/>  }<br/>}</span></pre><blockquote class="mo mp mq"><p id="6a06" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><em class="iq">你应该有一个正常的错误说明:</em></p><p id="b64f" class="kl km mr kn b ko ly kq kr ks lz ku kv ms ma ky kz mt mb lc ld mu mc lg lh li ij bi translated"><code class="fe ml mm mn lp b"><em class="iq">The following targets are not valid instances: 'i-1234567890abcdef0'"</em></code></p></blockquote><h2 id="fe1d" class="lt jo iq bd jp mv mw dn jt mx my dp jx kw mz na kb la nb nc kf le nd ne kj nf bi translated">创建云观察器规则</h2><p id="2372" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">用您需要的自动缩放组的名称修改以下事件模式规则。在我的例子中，我有3个自动扩展组与我的eks集群相关联。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9867" class="lt jo iq lp b gy lu lv l lw lx">EVENT_PATTERN=$(echo -n '{<br/>  "source": [<br/>    "aws.autoscaling"<br/>  ],<br/>  "detail-type": [<br/>    "EC2 Instance Launch Successful"<br/>  ],<br/>  "detail": {<br/>    "AutoScalingGroupName": [<br/>      "eksctl-eksworkshop-eksctl-nodegroup-ng-spot-NodeGroup-1MCQMJAIUZCSS",<br/>      "eks-f8b8de05-e964-8e64-5043-60449f530a2b",<br/>      "eks-48b909fd-3aa4-c200-dcc0-cb8c5b637736"<br/>    ]<br/>  }<br/>}')<br/>echo $EVENT_PATTERN</span></pre><p id="9876" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">创建云观察规则</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="8c81" class="lt jo iq lp b gy lu lv l lw lx">aws events put-rule \<br/>  --name $NAME \<br/>  --event-pattern "$EVENT_PATTERN"</span></pre><p id="4bc7" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">获取Lambda arn</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1a9c" class="lt jo iq lp b gy lu lv l lw lx">LAMBDA_ARN=$(aws lambda get-function --function-name $NAME --query 'Configuration.FunctionArn' --output text)<br/>echo $LAMBDA_ARN</span></pre><p id="0b1a" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">创建云观察事件规则目标</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="13a8" class="lt jo iq lp b gy lu lv l lw lx">RULE_TARGET=$(echo -n '[<br/>  {<br/>    "Id": "1", <br/>    "Arn": "'; echo -n "$LAMBDA_ARN"; echo -n '"<br/>  }<br/>]')<br/>echo $RULE_TARGET</span></pre><p id="727d" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">将目标添加到事件规则中</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e980" class="lt jo iq lp b gy lu lv l lw lx">aws events put-targets \<br/>  --rule $NAME \<br/>  --targets "$RULE_TARGET"</span></pre><p id="2bc4" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">添加由事件触发的Lambda权限</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e1b0" class="lt jo iq lp b gy lu lv l lw lx">aws lambda add-permission \<br/>  --function-name $NAME \<br/>  --statement-id autoscaling-event-rule \<br/>  --action 'lambda:InvokeFunction' \<br/>  --principal events.amazonaws.com \<br/>  --source-arn $(aws events describe-rule --name $NAME --query 'Arn' --output text)</span></pre><p id="50f0" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">或者使用控制台:</p><h1 id="f07d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">测试</h1><p id="850e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，您可以在ASG中测试向外扩展或缩放，或者只是终止一些实例，每次在相应的ASGs中创建新实例时，ASG都会向lambda发送一个事件，lambda会在NLB目标组中注册新实例。</p><p id="d9b7" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">如果需要使用cli手动添加实例，请选中此项</p><h1 id="fd4d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">看看哪些操作会对我们的目标配置产生影响</h1><h1 id="240d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">升级节点组的版本</h1><p id="e442" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">升级节点组的版本时，EKS将启动每个实例的滚动升级。这将导致每个旧实例在被删除时从NLB中消失，新实例将由我们的Cloudwatch Event + Lambda函数自动添加</p><h1 id="42ad" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">清除</h1><p id="f13b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">删除目标组</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="77b7" class="lt jo iq lp b gy lu lv l lw lx">aws elbv2 delete-target-group --target-group-arn $TG_ARN</span></pre><p id="2454" class="pw-post-body-paragraph kl km iq kn b ko ly kq kr ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li ij bi translated">删除负载平衡器</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e73e" class="lt jo iq lp b gy lu lv l lw lx">aws elbv2 delete-load-balancer --load-balancer-arn $LB_ARN</span></pre></div></div>    
</body>
</html>