<html>
<head>
<title>Laravel: You can declare your Gates in your Controller</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可以在你的控制器中声明你的门</h1>
<blockquote>原文：<a href="https://itnext.io/laravel-you-can-declare-your-gates-and-policies-in-your-controller-2b596f3dd373?source=collection_archive---------3-----------------------#2019-07-29">https://itnext.io/laravel-you-can-declare-your-gates-and-policies-in-your-controller-2b596f3dd373?source=collection_archive---------3-----------------------#2019-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1594" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">是时候精简您的AuthServiceProvider了</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b6dbf843875d215ef03cacab06b2aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5sZadoQT6uUXXi_l"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@tianshu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">天枢刘</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="0be2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不知道的话，<a class="ae kv" href="https://laravel.com/docs/5.8/authorization#writing-gates" rel="noopener ugc nofollow" target="_blank"> Laravel包含了授权机制</a>来优雅地授权一个经过身份验证的用户执行特定的操作或资源。</p><p id="e70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提醒一下，这里有一些基础知识:<a class="ae kv" href="https://laravel.com/docs/5.8/authorization#gates" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">盖茨</strong> </a>可以操作任何逻辑，比如授权一个用户查看管理仪表板，如果他是“管理员”的话。同时，<a class="ae kv" href="https://laravel.com/docs/5.8/authorization#creating-policies" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">策略</strong> </a>专门作用于资源的CRUD操作:创建、检索、更新和删除。例如，只允许文章作者更新自己的出版物，而拒绝其他用户。</p><p id="87b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要声明它们，你通常要去你的<code class="fe ls lt lu lv b">AuthServiceProvider</code>并定义你的应用程序使用的每个门和策略。您可以从数组(对于策略)中完成，如果您有很多数组，甚至可以为门创建自己的数组。否则，如文档所述，手动注册它们是安全的。</p><p id="ac05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我只是做了一些方便的事情，因为我有很多门和策略。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6f95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，我们已经定义了我们的政策和入口。如果你看到<code class="fe ls lt lu lv b">$gates</code>数组，有很多被定义为<code class="fe ls lt lu lv b">see-something</code>。根据用户的“角色”，他可以看到<strong class="ky ir">仪表板</strong>、<strong class="ky ir">图库</strong>和<strong class="ky ir">系统配置</strong>。这些仅用于特定的控制器。</p><p id="97b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Welp，我们不需要定义<code class="fe ls lt lu lv b">AuthServiceProvider</code>中的每个门。虽然建议这样做，因为它允许您集中授权，使其在全球范围内可用，但有时最好在您的控制器中声明它，然后就到此为止，特别是如果它只是一个简单的基于Closure的gate，您只使用一次。</p><h1 id="2b6c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">是的，把它放在构造函数里就行了</h1><p id="4626" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">以同样的方式在控制器中声明一个中间件，您可以使用Gate facade来定义一个门——是的，听起来很奇怪。当控制器被实例化时，<code class="fe ls lt lu lv b">__construct</code>方法将在其他任何事情之前运行，并且由于我们正在使用<a class="ae kv" href="https://laravel.com/docs/5.8/container#automatic-injection" rel="noopener ugc nofollow" target="_blank">自动注入</a>，门将被自动解析，因此我们可以在方法内部使用它并定义我们的门。</p><p id="9c26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在你的方法中，你只是照常进行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a5da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个简单的例子，但是如果你有多个门，或者你只在一个控制器中使用一个特定的门，就像我在这个例子中所做的那样，它可以让你的<code class="fe ls lt lu lv b">AuthServiceProvider</code>变得更小。</p><p id="1b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您可以将授权中间件设置为只处理某些方法，或者排除它们。</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="72cb" class="mz lz iq lv b gy na nb l nc nd">$this-&gt;middleware('can:see-dashboard')-&gt;except('otherMethod');</span></pre><p id="2854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果Gate需要可选参数，这种排除就非常方便。由于我们不能在触及方法逻辑之前添加参数，从中间件中排除该方法将允许您在直接使用授权助手时放置参数。</p><pre class="kg kh ki kj gt mv lv mw mx aw my bi"><span id="8c66" class="mz lz iq lv b gy na nb l nc nd">public function changeOwner(Request $request, Article $article)<br/>{<br/>    $this-&gt;authorize('can-change-owner', $article);</span><span id="91d0" class="mz lz iq lv b gy ne nb l nc nd">    // ... Change ownerage of the Article<br/>}</span></pre><h1 id="7752" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">何时*不*使用这种方法</h1><p id="6602" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">正如您所猜测的，门位于控制器内部。这意味着门<strong class="ky ir">将只在控制器</strong>内部工作，完全分散。</p><p id="6794" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望从多个点调用相同的授权逻辑，比如在vie中，您可能希望使用经典的方法来定义门，因为它们将在引导时可用，并且在应用程序内部全局可用:控制器、控制台、内部作业、侦听器，只要您能想到的。</p><p id="378b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，您也可以使用<code class="fe ls lt lu lv b">Gate::authorizeForUser()</code>，并手动发布应该(或不应该)被授权执行该特定操作的用户。</p><p id="729d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你的应用中不需要过多考虑关卡。</p></div></div>    
</body>
</html>