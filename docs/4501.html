<html>
<head>
<title>Go Tutorial: TDD with Go and PostgreSQL [Part II]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go教程:使用Go和PostgreSQL的TDD第二部分]</h1>
<blockquote>原文：<a href="https://itnext.io/go-tutorial-tdd-with-go-and-postgresql-part-ii-489c929f02c9?source=collection_archive---------1-----------------------#2020-07-14">https://itnext.io/go-tutorial-tdd-with-go-and-postgresql-part-ii-489c929f02c9?source=collection_archive---------1-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div class="gh gi jr"><img src="../Images/99822f5ee94b0d91f528ad3c29e40c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*Gbi_XNOkPFbWkIkJC7LnBQ.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">戈朗</figcaption></figure><h1 id="1b3c" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><em class="jq">带Go和PostgreSQL的TDD</em></h1><h2 id="5e11" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">介绍</h2><p id="9223" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated"><em class="mk">注意:这是一个分为3部分的教程:</em></p><ol class=""><li id="56fd" class="ml mm it lr b ls mn lw mo lf mp li mq ll mr mj ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/@juancurti.it/go-tutorial-getting-started-part-i-f992a711ba49?source=your_stories_page---------------------------" rel="noopener">T5】安装GoT7】</a></li><li id="8bd7" class="ml mm it lr b ls mx lw my lf mz li na ll nb mj ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/@juancurti.it/go-tutorial-tdd-with-go-and-postgresql-part-ii-489c929f02c9?source=your_stories_page---------------------------" rel="noopener"> <em class="mk"> TDD带Go和PostgreSQL </em> </a></li><li id="ae76" class="ml mm it lr b ls mx lw my lf mz li na ll nb mj ms mt mu mv bi translated"><a class="ae mw" href="https://medium.com/@juancurti.it/go-tutorial-database-queries-on-go-with-postgresql-part-iii-c8907729c2f?source=your_stories_page---------------------------" rel="noopener"> <em class="mk">使用PostgreSQL进行数据库查询</em> </a></li></ol><h1 id="4575" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">我们要建造什么？</h1><p id="99a7" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">这个项目的范围是从头开始(从创建git存储库开始)构建一个REST API和Go的例子，包括路由、数据库获取(PostgreSQL ),并通过测试驱动开发开始。</p><h2 id="fc49" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">用Docker启动PostgreSQL</h2><p id="b1d9" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">首先，我们需要在您的机器上安装PostgreSQL。我更喜欢在PostgreSQL中使用Docker容器。安装数据库本身是一个不同的主题，因此我将简要解释如何使用PostgreSQL数据库启动Docker容器:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5f91" class="la kd it nh b gy nl nm l nn no">docker run -d -p 5432:5432 --name my-postgres -e POSTGRES_PASSWORD=12345 postgres</span></pre><p id="9432" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">要访问数据库和终端，我们使用以下命令:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="fd1d" class="la kd it nh b gy nl nm l nn no">sudo docker exec -it my-postgres bash<br/>psql -U postgres</span></pre><p id="802f" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">如果我们想本地连接到PostgreSQL命令行，我们使用:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="4ce9" class="la kd it nh b gy nl nm l nn no">psql -h localhost -p 5432 -U postgres -W</span></pre><h2 id="6cfe" class="la kd it bd ke lb lc dn ki ld le dp km lf lg lh kq li lj lk ku ll lm ln ky lo bi translated">我们一起去吧</h2><p id="0b15" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">我们将开始创建Git库，包括Go .gitignore。我将使用Github.com作为个人选择。</p><figure class="nc nd ne nf gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/e939ff3d956aa45b3a16de601e6d14b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TB04Vo8PW9uuVenJq6OUAg.png"/></div></div></figure><p id="96cc" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">下一步是克隆我们的git存储库，在我的例子中:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="027d" class="la kd it nh b gy nl nm l nn no">git clone <a class="ae mw" href="https://github.com/juancurti/go_tdd_tutorial.git" rel="noopener ugc nofollow" target="_blank">https://github.com/juancurti/go_tdd_tutorial.git</a></span></pre><p id="d685" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">然后，我们需要初始化我们的Go存储库，需要在我们的根文件夹中。这将创建一个go.mod。键入以下命令，用您自己的命令替换GITREPOSITORY，不带“https://”前缀:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7873" class="la kd it nh b gy nl nm l nn no">go mod init github.com/GITREPOSITORY</span></pre><figure class="nc nd ne nf gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nx"><img src="../Images/4d96b0faee714d3493c9e7235fcb59e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvByYoVLxA4YZ3Sup9mG3w.png"/></div></div></figure><p id="d9fe" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">现在我们需要获取将要使用的Go模块，在本例中是Gorilla Mux和PostgreSQL。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="5d36" class="la kd it nh b gy nl nm l nn no">go get -u github.com/gorilla/mux <br/>go get -u github.com/lib/pq</span></pre><figure class="nc nd ne nf gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ny"><img src="../Images/70e3eb2409e8fa1ef047f20389f2f51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9q4QUUgcYGib-IS-Nf8RbQ.png"/></div></div></figure><p id="433f" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">让我们首先为我们的应用程序创建一个app.go文件。在这个文件中，我们将定义一个结构(App)来保存对路由器和数据库的引用。为了有用和可测试，我们的应用程序结构需要两个方法来初始化和运行应用程序。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="edea" class="la kd it nh b gy nl nm l nn no">package main</span><span id="2def" class="la kd it nh b gy nz nm l nn no">import (<br/> “database/sql”</span><span id="7bd8" class="la kd it nh b gy nz nm l nn no">“github.com/gorilla/mux”<br/> _ “github.com/lib/pq”<br/>)</span><span id="6b6c" class="la kd it nh b gy nz nm l nn no">type App struct {<br/> Router *mux.Router<br/> DB *sql.DB<br/>}</span><span id="b790" class="la kd it nh b gy nz nm l nn no">func (a *App) Initialize(user, password, dbname string) { }<br/>func (a *App) Run(addr string) {}</span></pre><p id="d7c3" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">Initialize方法获取与PostgreSQL数据库建立连接所需的参数，而Run方法启动应用程序。<br/>我们还将创建一个main.go文件，这是应用程序的入口点，代码如下:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="44a8" class="la kd it nh b gy nl nm l nn no">package main</span><span id="0fd0" class="la kd it nh b gy nz nm l nn no">import “os”</span><span id="868f" class="la kd it nh b gy nz nm l nn no">func main() {<br/> a := App{}<br/> a.Initialize(<br/>   os.Getenv(“APP_DB_USERNAME”),<br/>   os.Getenv(“APP_DB_PASSWORD”),<br/>   os.Getenv(“APP_DB_NAME”),<br/> )<br/> a.Run(“:8001”)<br/>}</span></pre><p id="4d5f" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">为了保护我们的代码，大多数程序员都会同意，我们必须避免暴露代码中的凭证，这些凭证将被推送到Github，并(可能)可供数百万人使用。我们将使用环境变量。然后，我们将在终端中键入以下命令来导出我们的凭据:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="d9f5" class="la kd it nh b gy nl nm l nn no">export APP_DB_USERNAME=postgres<br/>export APP_DB_PASSWORD=<br/>export APP_DB_NAME=postgres</span></pre><p id="0545" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">最后，创建一个CRUD应用程序，我们需要一些被请求的东西。出于教程的需要，我们将使用通用的“产品”。为此，我们将添加一个包含以下内容的model.go文件:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7705" class="la kd it nh b gy nl nm l nn no">package main</span><span id="4cce" class="la kd it nh b gy nz nm l nn no">import (<br/> “database/sql”<br/>)</span><span id="d5bc" class="la kd it nh b gy nz nm l nn no">type product struct {<br/> ID int `json:”id”`<br/> Name string `json:”name”`<br/> Price float64 `json:”price”`<br/>}</span><span id="0ad4" class="la kd it nh b gy nz nm l nn no">func (p *product) getProduct(db *sql.DB) error {<br/> return errors.New(“Not implemented”)<br/>}</span><span id="0eee" class="la kd it nh b gy nz nm l nn no">func (p *product) updateProduct(db *sql.DB) error {<br/> return errors.New(“Not implemented”)<br/>}</span><span id="9887" class="la kd it nh b gy nz nm l nn no">func (p *product) deleteProduct(db *sql.DB) error {<br/> return errors.New(“Not implemented”)<br/>}</span><span id="fdad" class="la kd it nh b gy nz nm l nn no">func (p *product) createProduct(db *sql.DB) error {<br/> return errors.New(“Not implemented”)<br/>}</span><span id="e146" class="la kd it nh b gy nz nm l nn no">func getProducts(db *sql.DB, start, count int) ([]product, error) {<br/> return nil, errors.New(“Not implemented”)<br/>}</span></pre><p id="2293" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">现在我们已经创建了基础模型，我们可以开始编写测试了。为了在开发过程中开始测试，我们可以针对数据库开始运行测试，特别是确保它被正确设置。我们将在main_test.go文件中使用TestMain函数，并使用“a”变量来表示我们想要测试的应用程序。我们将编写以下代码，然后我将解释我们刚刚编写的内容:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7606" class="la kd it nh b gy nl nm l nn no">package main</span><span id="1889" class="la kd it nh b gy nz nm l nn no">import (<br/> “os”<br/> “testing”<br/> “log”<br/>)</span><span id="67f1" class="la kd it nh b gy nz nm l nn no">var a App</span><span id="d1f0" class="la kd it nh b gy nz nm l nn no">func TestMain(m *testing.M) {<br/> a.Initialize(<br/> os.Getenv(“APP_DB_USERNAME”),<br/> os.Getenv(“APP_DB_PASSWORD”),<br/> os.Getenv(“APP_DB_NAME”),<br/>)</span><span id="9700" class="la kd it nh b gy nz nm l nn no">ensureTableExists()<br/> code := m.Run()<br/> clearTable()<br/> os.Exit(code)<br/>}</span><span id="9de8" class="la kd it nh b gy nz nm l nn no">func ensureTableExists() {<br/> if _, err := a.DB.Exec(tableCreationQuery); err != nil {<br/> log.Fatal(err)<br/> }<br/>}</span><span id="93cd" class="la kd it nh b gy nz nm l nn no">func clearTable() {<br/> a.DB.Exec(“DELETE FROM products”)<br/> a.DB.Exec(“ALTER SEQUENCE products_id_seq RESTART WITH 1”)<br/>}</span><span id="eac0" class="la kd it nh b gy nz nm l nn no">const tableCreationQuery = `CREATE TABLE IF NOT EXISTS products<br/>(<br/> id SERIAL,<br/> name TEXT NOT NULL,<br/> price NUMERIC(10,2) NOT NULL DEFAULT 0.00,<br/> CONSTRAINT products_pkey PRIMARY KEY (id)<br/>)`</span></pre><p id="f21f" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">在函数“ensureTableExists”上，我们确保我们想要测试的表是可用的。为了做到这一点，我们在创建SQL脚本时创建了一个常量。我们所有的测试都是通过调用m.Run()来执行的，之后我们调用clearTable()来清理数据库。</p><p id="3fce" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">最后，我们需要在app.go中实现App的Initialize方法，建立与数据库的连接，初始化路由器。<br/>我们需要先添加“fmt”和“log ”,以便开始初始化方法。</p><p id="1095" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">针对以下内容替换app.go上的导入:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="9ce7" class="la kd it nh b gy nl nm l nn no">import (<br/>    "database/sql"<br/>    "fmt"<br/>    "log"</span><span id="65b8" class="la kd it nh b gy nz nm l nn no">    "github.com/gorilla/mux"<br/>    _ "github.com/lib/pq"<br/>)</span></pre><p id="f9e3" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">并替换以下初始化方法:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="9837" class="la kd it nh b gy nl nm l nn no">func (a *App) Initialize(user, password, dbname string) {<br/> connectionString := fmt.Sprintf(“user=%s password=%s dbname=%s sslmode=disable”, user, password, dbname)</span><span id="7bfc" class="la kd it nh b gy nz nm l nn no">var err error<br/> a.DB, err = sql.Open(“postgres”, connectionString)<br/> if err != nil {<br/> log.Fatal(err)<br/> }</span><span id="efc7" class="la kd it nh b gy nz nm l nn no">a.Router = mux.NewRouter()<br/>}</span></pre><p id="7db0" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">此时，如果我们执行以下命令，我们应该会看到“没有要运行的测试”:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="7798" class="la kd it nh b gy nl nm l nn no">go test -v</span></pre><figure class="nc nd ne nf gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oa"><img src="../Images/d84bb9de2e2ee29b99801136f68e1f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INlTkngO3dycOIstWO4H0Q.png"/></div></div></figure><h1 id="80eb" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为API编写测试</h1><p id="97a7" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">为了开始处理请求，我们需要实现“net/http”库。为此，在main_test.go中，我们将其添加到导入中，如下所示:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="054c" class="la kd it nh b gy nl nm l nn no">import (<br/> “os”<br/> “testing”<br/> “log”</span><span id="c0ec" class="la kd it nh b gy nz nm l nn no">"net/http"<br/>"net/http/httptest"<br/>)</span></pre><p id="4823" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">让我们首先用一个空表测试对/products端点的响应:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="9bc2" class="la kd it nh b gy nl nm l nn no">func TestEmptyTable(t *testing.T) {<br/>    clearTable()<br/><br/>    req, _ := http.NewRequest("GET", "/products", nil)<br/>    response := executeRequest(req)<br/><br/>    checkResponseCode(t, http.StatusOK, response.Code)<br/><br/>    if body := response.Body.String(); body != "[]" {<br/>        t.Errorf("Expected an empty array. Got %s", body)<br/>    }<br/>}</span></pre><p id="b904" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">该测试从products表中删除所有记录，并向/products端点发送GET请求。我们使用两个助手方法，executeRequest和checkResponseCode:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="914f" class="la kd it nh b gy nl nm l nn no">func executeRequest(req *http.Request) *httptest.ResponseRecorder {<br/>    rr := httptest.NewRecorder()<br/>    a.Router.ServeHTTP(rr, req)<br/><br/>    return rr<br/>}</span><span id="33d2" class="la kd it nh b gy nz nm l nn no">func checkResponseCode(t *testing.T, expected, actual int) {<br/>    if expected != actual {<br/>        t.Errorf("Expected response code %d. Got %d\n", expected, actual)<br/>    }<br/>}</span></pre><p id="6cad" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">如果您再次运行测试，您应该得到以下结果:</p><figure class="nc nd ne nf gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ob"><img src="../Images/18d3c91abc86fc2a56847546ad098db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NNUOwNj66YuKHBxsoWj1A.png"/></div></div></figure><p id="75e5" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">现在我们可以添加另一个测试了！这个函数将在获取一个不存在的产品时检查响应<strong class="lr iu">(注意，在这种情况下，我们需要添加encoding/json模块，就像我们对net/http) </strong>所做的一样)。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="c69b" class="la kd it nh b gy nl nm l nn no">func TestGetNonExistentProduct(t *testing.T) {<br/>    clearTable()<br/><br/>    req, _ := http.NewRequest("GET", "/product/11", nil)<br/>    response := executeRequest(req)<br/><br/>    checkResponseCode(t, http.StatusNotFound, response.Code)<br/><br/>    var m map[string]string<br/>    json.Unmarshal(response.Body.Bytes(), &amp;m)<br/>    if m["error"] != "Product not found" {<br/>        t.Errorf("Expected the 'error' key of the response to be set to 'Product not found'. Got '%s'", m["error"])<br/>    }<br/>}</span></pre><p id="e334" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">然后，我们添加另一个测试来创建一个产品(<strong class="lr iu">实现字节模块</strong>)(注意，当使用解组时，整数被转换为浮点数，所以当我们比较id和1时，我们需要使用1.0)</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f7b2" class="la kd it nh b gy nl nm l nn no">func TestCreateProduct(t *testing.T) {<br/> clearTable()</span><span id="50b9" class="la kd it nh b gy nz nm l nn no">var jsonStr = []byte(`{“name”:”test product”, “price”: 11.22}`)<br/> req, _ := http.NewRequest(“POST”, “/product”, bytes.NewBuffer(jsonStr))<br/> req.Header.Set(“Content-Type”, “application/json”)</span><span id="1eed" class="la kd it nh b gy nz nm l nn no">response := executeRequest(req)<br/> checkResponseCode(t, http.StatusCreated, response.Code)</span><span id="d21b" class="la kd it nh b gy nz nm l nn no">var m map[string]interface{}<br/> json.Unmarshal(response.Body.Bytes(), &amp;m)</span><span id="a3e3" class="la kd it nh b gy nz nm l nn no">if m[“name”] != “test product” {<br/> t.Errorf(“Expected product name to be ‘test product’. Got ‘%v’”, m[“name”])<br/> }</span><span id="1c08" class="la kd it nh b gy nz nm l nn no">if m[“price”] != 11.22 {<br/> t.Errorf(“Expected product price to be ‘11.22’. Got ‘%v’”, m[“price”])<br/> }</span><span id="a575" class="la kd it nh b gy nz nm l nn no">if m[“id”] != 1.0 {<br/> t.Errorf(“Expected product ID to be ‘1’. Got ‘%v’”, m[“id”])<br/> }<br/>}</span></pre><p id="3cc9" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">为了测试获取产品，我们将使用稍后将在<strong class="lr iu">中使用的helper函数实现一个测试(注意，我们将使用strconv模块，我们需要像以前一样导入它)</strong>:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="0c39" class="la kd it nh b gy nl nm l nn no">func TestGetProduct(t *testing.T) {<br/>    clearTable()<br/>    addProducts(1)<br/><br/>    req, _ := http.NewRequest("GET", "/product/1", nil)<br/>    response := executeRequest(req)<br/><br/>    checkResponseCode(t, http.StatusOK, response.Code)<br/>}</span><span id="d691" class="la kd it nh b gy nz nm l nn no">func addProducts(count int) {<br/>    if count &lt; 1 {<br/>        count = 1<br/>    }<br/><br/>    for i := 0; i &lt; count; i++ {<br/>        a.DB.Exec("INSERT INTO products(name, price) VALUES($1, $2)", "Product "+strconv.Itoa(i), (i+1.0)*10)<br/>    }<br/>}</span></pre><p id="2f23" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">要测试产品的更新:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f519" class="la kd it nh b gy nl nm l nn no">func TestUpdateProduct(t *testing.T) {<br/><br/>    clearTable()<br/>    addProducts(1)<br/><br/>    req, _ := http.NewRequest("GET", "/product/1", nil)<br/>    response := executeRequest(req)<br/>    var originalProduct map[string]interface{}<br/>    json.Unmarshal(response.Body.Bytes(), &amp;originalProduct)<br/><br/>    var jsonStr = []byte(`{"name":"test product - updated name", "price": 11.22}`)<br/>    req, _ = http.NewRequest("PUT", "/product/1", bytes.NewBuffer(jsonStr))<br/>    req.Header.Set("Content-Type", "application/json")<br/><br/>    response = executeRequest(req)<br/><br/>    checkResponseCode(t, http.StatusOK, response.Code)<br/><br/>    var m map[string]interface{}<br/>    json.Unmarshal(response.Body.Bytes(), &amp;m)<br/><br/>    if m["id"] != originalProduct["id"] {<br/>        t.Errorf("Expected the id to remain the same (%v). Got %v", originalProduct["id"], m["id"])<br/>    }<br/><br/>    if m["name"] == originalProduct["name"] {<br/>        t.Errorf("Expected the name to change from '%v' to '%v'. Got '%v'", originalProduct["name"], m["name"], m["name"])<br/>    }<br/><br/>    if m["price"] == originalProduct["price"] {<br/>        t.Errorf("Expected the price to change from '%v' to '%v'. Got '%v'", originalProduct["price"], m["price"], m["price"])<br/>    }<br/>}</span></pre><p id="5598" class="pw-post-body-paragraph lp lq it lr b ls mn lu lv lw mo ly lz lf np mb mc li nq me mf ll nr mh mi mj im bi translated">最后，为了测试产品的删除:</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="91bb" class="la kd it nh b gy nl nm l nn no">func TestDeleteProduct(t *testing.T) {<br/>    clearTable()<br/>    addProducts(1)<br/><br/>    req, _ := http.NewRequest("GET", "/product/1", nil)<br/>    response := executeRequest(req)<br/>    checkResponseCode(t, http.StatusOK, response.Code)<br/><br/>    req, _ = http.NewRequest("DELETE", "/product/1", nil)<br/>    response = executeRequest(req)<br/><br/>    checkResponseCode(t, http.StatusOK, response.Code)<br/><br/>    req, _ = http.NewRequest("GET", "/product/1", nil)<br/>    response = executeRequest(req)<br/>    checkResponseCode(t, http.StatusNotFound, response.Code)<br/>}</span></pre><h1 id="5775" class="kc kd it bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="1681" class="pw-post-body-paragraph lp lq it lr b ls lt lu lv lw lx ly lz lf ma mb mc li md me mf ll mg mh mi mj im bi translated">这一章是关于编写测试方法的。在下一部分中，我们将实现数据库查询并通过所有这些测试。编写测试可能是乏味的工作，但是为了避免不必要的错误和人为错误，这是非常必要的。</p></div></div>    
</body>
</html>