<html>
<head>
<title>Automated Delivery of ASP.NET Core Apps on On-Prem Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在本地Kubernetes上自动交付ASP.NET核心应用</h1>
<blockquote>原文：<a href="https://itnext.io/automated-delivery-of-asp-net-core-apps-on-on-prem-kubernetes-1d6327ee1454?source=collection_archive---------0-----------------------#2018-02-13">https://itnext.io/automated-delivery-of-asp-net-core-apps-on-on-prem-kubernetes-1d6327ee1454?source=collection_archive---------0-----------------------#2018-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7c72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将了解如何在本地Kubernetes集群上自动部署ASP.NET核心应用程序。我们的工作将基于<a class="ae kl" href="https://meteatamel.wordpress.com/" rel="noopener ugc nofollow" target="_blank"> Mete Atamel </a>的优秀博客“<a class="ae kl" href="https://meteatamel.wordpress.com/2017/08/15/deploying-asp-net-core-apps-on-app-engine/" rel="noopener ugc nofollow" target="_blank">在应用引擎</a>上部署ASP.NET核心应用”。我们的贡献将是a)展示如何针对Kubernetes部署的公共云和私有云，以及b)通过基于Jenkins的基本CI/CD自动交付您的软件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d03b8f8af21d10d2321db353f3ad9380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mc7yK4uGKGiiC84lUQ-XrA.png"/></div></div></figure><p id="c5d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fautomated-delivery-of-asp-net-core-apps-on-on-prem-kubernetes-1d6327ee1454" rel="noopener ugc nofollow" target="_blank"> <em class="ky">点击这里在LinkedIn上分享这篇文章</em> </a></p><h2 id="e267" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">我们将使用什么</h2><ul class=""><li id="345f" class="ls lt iq jp b jq lu ju lv jy lw kc lx kg ly kk lz ma mb mc bi translated">一台Ubuntu 16.04机器</li><li id="7c33" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">git命令行客户端(由<code class="fe mi mj mk ml b">sudo apt install git</code>安装)</li><li id="9aee" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">互联网接入</li><li id="5d00" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">$0，是的，这将是一篇“看看你能免费做多少事”的博文</li></ul><h2 id="e311" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">快速大纲</h2><ul class=""><li id="0f20" class="ls lt iq jp b jq lu ju lv jy lw kc lx kg ly kk lz ma mb mc bi translated">在Ubuntu机器上创建一个ASP.NET核心应用，并将代码推送到GitHub。</li><li id="b3ab" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">将应用程序打包到Docker容器中，并上传到Docker Hub</li><li id="6bbe" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">旋转Kubernetes星团，规范分布。在这里，我们将在本地部署该集群，但是您可以使用您可以访问的任何私有或公共云。</li><li id="7d03" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">在Kubernetes集群上部署应用程序并公开它。</li><li id="8ea3" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">在Kubernetes旁边部署Jenkins，并自动交付您的应用。</li></ul><p id="aac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不要浪费时间了，我们还有很长的路要走。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="65fe" class="mt la iq bd lb mu mv mw le mx my mz lh na nb nc lk nd ne nf ln ng nh ni lq nj bi translated">ASP。Linux上的NET核心应用程序</h1><p id="b642" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy nk ka kb kc nl ke kf kg nm ki kj kk ij bi translated"><a class="ae kl" href="https://www.microsoft.com/net/learn/get-started/linuxubuntu" rel="noopener ugc nofollow" target="_blank">正在安装。在Ubuntu 16.04上运行. NET就像添加一个库并获得dotnet-sdk-2.1.4一样简单:</a></p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="2044" class="kz la iq ml b gy nr ns l nt nu">$ curl <a class="ae kl" href="https://packages.microsoft.com/keys/microsoft.asc" rel="noopener ugc nofollow" target="_blank">https://packages.microsoft.com/keys/microsoft.asc</a> | gpg --dearmor &gt; microsoft.gpg <br/>$ sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg<br/>$ sudo sh -c 'echo "deb [arch=amd64] <a class="ae kl" href="https://packages.microsoft.com/repos/microsoft-ubuntu-xenial-prod" rel="noopener ugc nofollow" target="_blank">https://packages.microsoft.com/repos/microsoft-ubuntu-xenial-prod</a> xenial main" &gt; /etc/apt/sources.list.d/dotnetdev.list'<br/>$ sudo apt-get install apt-transport-https <br/>$ sudo apt-get update <br/>$ sudo apt-get install dotnet-sdk-2.1.4</span></pre><p id="7e43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以创建我们的应用程序了。这将是Mete的<a class="ae kl" href="https://codelabs.developers.google.com/codelabs/cloud-kubernetes-aspnetcore" rel="noopener ugc nofollow" target="_blank"> codelab </a>中描述的模板razor应用程序，我们甚至不会费心去改变应用程序的名称！</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="e886" class="kz la iq ml b gy nr ns l nt nu">$ mkdir -p ~/workspace/dotnet<br/>$ cd ~/workspace/dotnet<br/>$ dotnet new razor -o HelloWorldAspNetCore<br/>$ cd HelloWorldAspNetCore<br/>$ dotnet run</span></pre><p id="160d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会在<code class="fe mi mj mk ml b"><a class="ae kl" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http:<em class="ky">//localhost:5000</em></a></code>时在浏览器上看到该应用程序</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5b40a442baf1bf91a815d2827313cfaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iziMyIj_F_bQQVnJjG6Hg.png"/></div></div></figure><p id="9ee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的代码将会放在一个公共的github库上，所以如果你还没有一个帐号的话，就创建一个吧(<a class="ae kl" href="https://github.com/" rel="noopener ugc nofollow" target="_blank">https://github.com</a>)。单击“新建存储库”按钮创建一个名为<em class="ky"> HelloWorldAspNetCore </em>的公共存储库。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c632745a0cf92c0fbe688ed5a6542180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ng9bxdWQ7XwRUMnoCwuNLg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">为我们的代码创建一个存储库。</figcaption></figure><p id="6b66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在项目的根目录下添加一个. gitignore文件，并推送我们的代码:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="7bfa" class="kz la iq ml b gy nr ns l nt nu">$ cd ~/workspace/dotnet/HelloWorldAspNetCore<br/>$ wget <a class="ae kl" href="https://raw.githubusercontent.com/OmniSharp/generator-aspnet/master/templates/gitignore.txt" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/OmniSharp/generator-aspnet/master/templates/gitignore.txt</a><br/>$ mv <a class="ae kl" href="https://raw.githubusercontent.com/OmniSharp/generator-aspnet/master/templates/gitignore.txt" rel="noopener ugc nofollow" target="_blank">gitignore.txt</a> .gitignore<br/>$ git init<br/>$ git add .<br/>$ git commit -m "Initial commit"<br/>$ git remote add origin <a class="ae kl" href="https://github.com/ktsakalozos/HelloWorldAspNetCore.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ktsakalozos/HelloWorldAspNetCore.git</a><br/>$ git push -u origin master</span></pre><p id="7a49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你现在可以放松了！使用github，您的代码是安全的。</p><h1 id="c854" class="mt la iq bd lb mu nz mw le mx oa mz lh na ob nc lk nd oc nf ln ng od ni lq nj bi translated">将您的应用程序打包到Docker容器中</h1><p id="491a" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy nk ka kb kc nl ke kf kg nm ki kj kk ij bi translated"><a class="ae kl" href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce" rel="noopener ugc nofollow" target="_blank">安装docker </a>将需要添加各自的存储库并获取docker-ce:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="05a0" class="kz la iq ml b gy nr ns l nt nu">$ sudo apt-get install apt-transport-https ca-certificates curl \<br/>    software-properties-common<br/>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br/>$ sudo add-apt-repository \<br/>   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \<br/>   $(lsb_release -cs) \<br/>   stable"<br/>$ sudo apt-get update<br/>$ sudo apt-get install docker-ce<br/>$ sudo usermod -a -G docker $USER<br/>$ newgrp docker</span></pre><p id="bf92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在设置docker的过程中，我们也可以注册Docker Hub并创建一个存储库来存储我们的图像。前往https://hub.docker.com的<a class="ae kl" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">创建一个账户。我会在这里等待:)。</a></p><p id="553c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">登录Docker Hub后，单击“创建存储库”按钮，创建一个新的公共存储库。这是我们推广docker形象的地方。对于本博客的其余部分，docker用户是“kjackal ”,存储库被命名为“hello-dotnet”。这将很快对你更有意义。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c7c6501c71c0965cdebedb37905f1c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6vye5mOGtTcsIA4fLi8tQ.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">新docker存储库表单。</figcaption></figure><p id="1607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要打包我们的应用程序，我们首先需要让dotnet编译我们的代码，并将所有依赖项收集到一个文件夹中，以便以后部署。这通过以下方式完成:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="f398" class="kz la iq ml b gy nr ns l nt nu">$ dotnet publish -c Release</span></pre><p id="3be2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的docker容器应该在<code class="fe mi mj mk ml b">bin/Release/netcoreapp2.0/publish/</code>下打包所有东西。我们在项目的根目录下创建一个“Dockerfile ”,包含以下内容:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="e4ec" class="kz la iq ml b gy nr ns l nt nu">$ cd <!-- -->~/workspace/dotnet/HelloWorldAspNetCore/<br/>$ cat ./Dockerfile<br/>FROM gcr.io/google-appengine/aspnetcore:2.0<br/>ADD ./<!-- -->bin/Release/netcoreapp2.0/publish/<!-- --> /app<br/>ENV ASPNETCORE_URLS=http:<em class="ky">//*:${PORT}</em><br/>WORKDIR /app<br/>ENTRYPOINT [ "dotnet", "HelloWorldAspNetCore.dll"]</span></pre><p id="5c3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建容器并测试其工作情况:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="9306" class="kz la iq ml b gy nr ns l nt nu">$ docker build -t kjackal/hello-dotnet:v1 .<br/>$ docker run -p 8080:8080  kjackal/hello-dotnet:v1</span></pre><p id="cca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该在<a class="ae kl" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>看到输出。</p><p id="2f54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候将第一个版本推送到Docker Hub了:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="d6e1" class="kz la iq ml b gy nr ns l nt nu">$ docker login<br/>$ docker push kjackal/hello-dotnet:v1</span></pre><p id="9ab0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Dockerfile应该是代码的一部分，因此我们提交它并将其推送到git存储库:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="98d6" class="kz la iq ml b gy nr ns l nt nu">$ git add Dockerfile<br/>$ git commit -m "Adding dockerfile"<br/>$ git push origin master</span></pre><h1 id="c9e1" class="mt la iq bd lb mu nz mw le mx oa mz lh na ob nc lk nd oc nf ln ng od ni lq nj bi translated">部署Kubernetes集群</h1><p id="2495" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy nk ka kb kc nl ke kf kg nm ki kj kk ij bi translated">对于本地Kubernetes部署，我们将采用Canonical的解决方案。原因是(除了我有偏见之外)，Canonical提供了一个无缝、轻松的过渡，从运行在笔记本电脑上的玩具部署过渡到部署在私有、公共云甚至裸机上的成熟的生产级Kubernetes。</p><p id="205a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博客中，我们展示了如何在您的本地主机(笔记本电脑/台式机)上部署Kubernetes和Jenkins只要确保您至少有8GB的RAM。我们首先需要让LXD运转起来。LXD是一种真正强大的容器，基于与Docker相同的技术。与Docker相反，LXD容器更像虚拟机。让我们简化一下，假设从现在开始，LXD容器是即时启动且没有性能开销的虚拟机！</p><p id="c2ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码片段中，我们安装了LXD。初始化(<code class="fe mi mj mk ml b">/snap/bin/lxd init</code>)时，确保使用默认设置，但<em class="ky">不启用ipv6 </em>。当被问及<em class="ky">“应该使用什么IPv6地址(CIDR子网表示法，“自动”或“无”)[默认=自动]？”</em>回复<em class="ky">【无】</em>。</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="8d63" class="kz la iq ml b gy nr ns l nt nu">$ sudo snap install lxd<br/>$ sudo usermod -a -G lxd $USER <br/>$ newgrp lxd<br/>$ /snap/bin/lxd init</span></pre><p id="9ad3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时我们可以使用<a class="ae kl" href="https://jujucharms.com/" rel="noopener ugc nofollow" target="_blank">或者</a>来部署Kubernetes。召唤本质上是一个坐在Juju上面的巫师。</p><p id="40ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如Tim 在<a class="ae kl" href="https://hackernoon.com/kubernetes-1-7-on-ubuntu-the-easy-way-bcd851d4ed35" rel="noopener ugc nofollow" target="_blank">中提到的，安装Kubernetes with dream-up非常简单:</a></p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="5fac" class="kz la iq ml b gy nr ns l nt nu">$ sudo snap install conjure-up --classic<br/>$ conjure-up</span></pre><p id="b679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Canonical Kubernetes有两种口味:</p><ol class=""><li id="1f50" class="ls lt iq jp b jq jr ju jv jy oe kc of kg og kk oh ma mb mc bi translated">kubernetes-core是一个安装在两台机器上的精简版本，在我们的例子中，两台LXD容器运行在本地主机上。</li><li id="9edc" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk oh ma mb mc bi translated"><em class="ky"> canonical-kubernetes </em>是完整的生产级部署，具有HA和<a class="ae kl" href="https://medium.com/@kwmonroe/monitor-your-kubernetes-cluster-a856d2603ec3" rel="noopener">监控</a>等特性。</li></ol><p id="e8f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将选择kubernetes-core；在下一个屏幕上，选择localhost作为云提供商。遵循向导的步骤，直到最后，并等待部署完成。对于无头部署，您可以执行<code class="fe mi mj mk ml b">conjure-up kubernetes-core localhost</code>。</p><p id="da7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看我们的部署状态，请查看:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="2182" class="kz la iq ml b gy nr ns l nt nu">$ juju status</span></pre><p id="e23a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入一个LXD的容器/机器，我们使用juju ssh，例如:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="d84e" class="kz la iq ml b gy nr ns l nt nu">$ juju ssh kubernetes-master/0</span></pre><p id="0f0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在/home/ubuntu下的kubernetes-master中，您可以找到一个用于访问集群的配置文件。我们可以使用以下命令获取该文件:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="a4e5" class="kz la iq ml b gy nr ns l nt nu">$ juju scp kubernetes-master/0:config .</span></pre><p id="ce48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dream-up已经在本地复制了Kubernetes的配置，并为我们安装了kubectl。多好啊！</p><h1 id="44b6" class="mt la iq bd lb mu nz mw le mx oa mz lh na ob nc lk nd oc nf ln ng od ni lq nj bi translated">自动化部署流程，CI/CD</h1><p id="eed2" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy nk ka kb kc nl ke kf kg nm ki kj kk ij bi translated">我们将展示几个Jenkins jobs来自动化构建、打包和部署我们的应用程序的过程。这里的目的是展示发生在引擎盖下的一切，而不是隐藏在华而不实的UI后面。</p><p id="a1be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一台詹金斯机器。</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="f1c4" class="kz la iq ml b gy nr ns l nt nu">$ juju deploy jenkins</span></pre><p id="04df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将Jenkins部署在我们的Kubernetes集群旁边。这需要一些时间，您可以用<code class="fe mi mj mk ml b">juju status</code>来检查部署的进度。</p><p id="0280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要为Jenkins设置一个密码，并公开它，这样我们就可以在端口8080上访问它的UI。在使用LXD容器的localhost部署中不需要公开Jenkins，但是为了完整起见，我们在这里展示了它。</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="ac82" class="kz la iq ml b gy nr ns l nt nu">$ juju config jenkins password='your_secure_password'<br/>$ juju expose jenkins</span></pre><p id="ed3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始创建我们的工作之前，我们需要对Jenkins进行更多的配置。我可以事先告诉你，我们的工作需要sudo运行，而不要求密码。最简单的方法是在Jenkins机器中编辑/etc/sudoers。下面是我们如何用Juju在sudoers文件中添加一行:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="b3ce" class="kz la iq ml b gy nr ns l nt nu">$ juju run --unit jenkins/0 -- 'sudo echo "jenkins ALL=(ALL) NOPASSWD: ALL" &gt;&gt; /etc/sudoers'</span></pre><p id="06ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也知道詹金斯的工作需要和库伯内特人谈谈。为此，Jenkins需要kubeconfig文件。我们从kubernetes-master获取文件，并将其放在Jenkins机器的/var/tmp下:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="dec6" class="kz la iq ml b gy nr ns l nt nu">$ juju scp kubernetes-master/0:config .<br/>$ juju scp config  jenkins/0:/var/tmp/</span></pre><p id="c922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一部分配置，我保证！我们知道我们的应用程序将在端口31576上使用Kubernetes节点端口公开。我们需要确保没有防火墙阻挡该端口，并且请求可以到达该端口:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="f13e" class="kz la iq ml b gy nr ns l nt nu">$ juju run --application kubernetes-worker -- open-port 31576</span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="3596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在准备创建我们的三个主要工作:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/044887bedd612ff2c1cb6f9b06d64ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCeuHWGZVYOjBTCPrPDJBw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">我们将创造三个就业机会</figcaption></figure><ul class=""><li id="8ce7" class="ls lt iq jp b jq jr ju jv jy oe kc of kg og kk lz ma mb mc bi translated">詹金斯的第一项工作是“安装依赖项”。这项工作只是一个shell脚本，它安装了a)与kubernetes对话，b)构建我们的ASP.NET应用程序，以及c)将所有内容打包到docker容器中所需的所有软件包。将以下内容放在shell脚本作业中，并运行一次:</li></ul><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="a5f6" class="kz la iq ml b gy nr ns l nt nu">echo "Installing kubectl"<br/>sudo snap install kubectl --classic</span><span id="0db3" class="kz la iq ml b gy oi ns l nt nu">echo "Installing dotnet"<br/>curl <a class="ae kl" href="https://packages.microsoft.com/keys/microsoft.asc" rel="noopener ugc nofollow" target="_blank">https://packages.microsoft.com/keys/microsoft.asc</a> | gpg --dearmor &gt; microsoft.gpg <br/>sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg<br/>sudo sh -c 'echo "deb [arch=amd64] <a class="ae kl" href="https://packages.microsoft.com/repos/microsoft-ubuntu-xenial-prod" rel="noopener ugc nofollow" target="_blank">https://packages.microsoft.com/repos/microsoft-ubuntu-xenial-prod</a> xenial main" &gt; /etc/apt/sources.list.d/dotnetdev.list'<br/>sudo apt-get install apt-transport-https -y <br/>sudo apt-get update<br/>sudo apt-get install dotnet-sdk-2.1.4 -y</span><span id="a6dc" class="kz la iq ml b gy oi ns l nt nu">echo "Installing docker"<br/>sudo apt-get install apt-transport-https ca-certificates  curl \<br/>    software-properties-common -y<br/>curl -fsSL <a class="ae kl" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add -<br/>sudo add-apt-repository \<br/>   "deb [arch=amd64] <a class="ae kl" href="https://download.docker.com/linux/ubuntu" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu</a> \<br/>   $(lsb_release -cs) \<br/>   stable"<br/>sudo apt-get update<br/>sudo apt-get install docker-ce -y</span></pre><ul class=""><li id="9de3" class="ls lt iq jp b jq jr ju jv jy oe kc of kg og kk lz ma mb mc bi translated">詹金斯的第二份工作是在Kubernetes启动服务。它使用我们在上面创建的v1映像创建一个部署，并确保记录所有操作(— record param)。这个部署是使用节点端口31576公开的。将以下内容放入Jenkins作业并运行一次，记住要更新docker用户名(kjackal):</li></ul><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="e1c9" class="kz la iq ml b gy nr ns l nt nu">sudo /snap/bin/kubectl --kubeconfig=/var/tmp/config run hello-dotnet \<br/>    --image=kjackal/hello-dotnet:v1 --port=8080 --record</span><span id="1a75" class="kz la iq ml b gy oi ns l nt nu">echo "apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hello-dotnet<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - port: 8080<br/>      nodePort: 31576<br/>      name: http<br/>  selector:<br/>    run: hello-dotnet" &gt; /tmp/expose.yaml</span><span id="9203" class="kz la iq ml b gy oi ns l nt nu">sudo /snap/bin/kubectl --kubeconfig=/var/tmp/config apply -f /tmp/expose.yaml</span></pre><p id="0150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mi mj mk ml b">juju status</code>找到一个kubernetes工人的IP，打开浏览器http://&lt;kubernetes-worker-IP&gt;:31576。你的申请由Kubernetes提供！但是我们还没有完成。</p><ul class=""><li id="37e6" class="ls lt iq jp b jq jr ju jv jy oe kc of kg og kk lz ma mb mc bi translated">让我们创建第三个作业(“构建和发布”)，从GitHub中提取代码，编译它，将它放入一个容器中，并部署该容器。在下面的代码片段中替换存储库和docker用户名。然后创建一个Jenkins作业:</li></ul><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="653a" class="kz la iq ml b gy nr ns l nt nu">rm -rf HelloWorldAspNetCore<br/>git clone <a class="ae kl" href="https://github.com/ktsakalozos/HelloWorldAspNetCore.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ktsakalozos/HelloWorldAspNetCore.git</a><br/>cd HelloWorldAspNetCore<br/>dotnet publish -c Release<br/>sudo docker login -u kjackal -p ${DOCKER_PASS}<br/>sudo docker build -t kjackal/hello-dotnet:${DOCKER_TAG} .<br/>sudo docker push kjackal/hello-dotnet:${DOCKER_TAG}<br/>sudo /snap/bin/kubectl --kubeconfig=/var/tmp/config set image deployment/hello-dotnet hello-dotnet=kjackal/hello-dotnet:${DOCKER_TAG}</span></pre><p id="94c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要两个参数:${DOCKER_TAG}是一个字符串，${DOCKER_PASS}保存用户的DOCKER密码(本例中为kjackal)。您必须勾选复选框，表明这是一个参数化作业，并添加两个参数。我们准备好了！触发作业并等待其完成。您的代码应该能够找到我们的Kubernetes集群。</p><p id="e8bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你不相信我？看看我们部署的首次展示历史。</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="211a" class="kz la iq ml b gy nr ns l nt nu">$ kubectl rollout history deployment/hello-dotnet</span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h2 id="06ac" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">从GitHub发布</h2><p id="bee3" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy nk ka kb kc nl ke kf kg nm ki kj kk ij bi translated">到目前为止一切看起来都很好。每次我们想要发布时，我们将登录到Jenkins并触发“构建和发布”作业…让我们试试不同的东西。让我们通过创建一个标签来触发代码的释放。</p><p id="0e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Jenkins上创建一个“从Github发布”作业，并让它每5分钟定期运行一次:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/c6aac90babbc0295a7b1cde458b4b2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TK1VcIm5je4owTgrgTuJoA.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">每5分钟触发一次作业</figcaption></figure><p id="8987" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望该作业寻找新的标记，如果检测到新的标记，就执行通常的编译、打包、部署循环。下面是一个这样的工作:</p><pre class="kn ko kp kq gt nn ml no np aw nq bi"><span id="2f78" class="kz la iq ml b gy nr ns l nt nu">#!/bin/bash</span><span id="3978" class="kz la iq ml b gy oi ns l nt nu">REPO="<a class="ae kl" href="https://github.com/ktsakalozos/HelloWorldAspNetCore.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ktsakalozos/HelloWorldAspNetCore.git</a>"<br/>rm -rf ./HelloWorldAspNetCore<br/>git clone $REPO<br/>cd HelloWorldAspNetCore</span><span id="a378" class="kz la iq ml b gy oi ns l nt nu"># Initialise tags list<br/>if [ ! -f /var/tmp/known-tags  ]; then<br/>  git tag &gt; /var/tmp/known-tags<br/>  echo "Initialising. List of preexisting git tags:"<br/>  cat /var/tmp/known-tags<br/>  exit 1<br/>fi</span><span id="ee06" class="kz la iq ml b gy oi ns l nt nu">mv /var/tmp/known-tags /var/tmp/know-tags.old<br/>git tag &gt; /var/tmp/known-tags<br/>diff /var/tmp/known-tags /var/tmp/know-tags.old<br/>if [ $? == '0' ]; then<br/>  echo "No new git tags detected."<br/>  exit 2<br/>fi</span><span id="ea1b" class="kz la iq ml b gy oi ns l nt nu"># We have new tags<br/>last_tag=$(grep -v -f /var/tmp/know-tags.old /var/tmp/known-tags | tail -n 1)<br/>git checkout tags/${last_tag}<br/>echo "Buidling ${last_tag}"<br/>dotnet publish -c Release<br/>sudo docker login -u kjackal -p &lt;replace_with_docker_password&gt;<br/>sudo docker build -t kjackal/hello-dotnet:${last_tag} .<br/>sudo docker push kjackal/hello-dotnet:${last_tag}<br/>sudo /snap/bin/kubectl --kubeconfig=/var/tmp/config set image deployment/hello-dotnet hello-dotnet=kjackal/hello-dotnet:${last_tag}</span></pre><p id="9f28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保您运行此作业一次，以便它得到初始化。之后，每隔5分钟，该作业将查看可用的标记，如果没有新的标记出现，该作业将失败。</p><p id="25e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建一个新的标签/版本。进入你的GitHub库点击releases——如下所示——并填写发布表单。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ok"><img src="../Images/35649f25cac042759a8f3157185899a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6gE8oYug0F8Xm9qRC4gLg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">这里是你找到你的版本的地方。</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ol"><img src="../Images/aace5055843e858f9e3edd646d45c7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUyFFSO4FkvPU4zFYQ3QBA.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">Github上的发布表单</figcaption></figure><p id="68b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在5分钟内，你的释放将到达Kubernetes！而不需要你登录到詹金斯。自动地！</p><p id="6232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几点需要注意:</p><ol class=""><li id="d4d9" class="ls lt iq jp b jq jr ju jv jy oe kc of kg og kk oh ma mb mc bi translated">可能会有Jenkins插件。但是我们说过，我们将会看到隐藏在引擎盖下的东西，而不是躲在GUI后面。</li><li id="0146" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk oh ma mb mc bi translated">你应该把你的Jenkins作业和你的代码放在GitHub上。</li></ol><h1 id="641d" class="mt la iq bd lb mu nz mw le mx oa mz lh na ob nc lk nd oc nf ln ng od ni lq nj bi translated">从这里去哪里</h1><p id="0011" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy nk ka kb kc nl ke kf kg nm ki kj kk ij bi translated">到目前为止，您已经看到了在任何Kubernetes集群上交付. NET应用程序的基本但功能齐全的CI/CD的各个部分。上面显示的每个步骤都可以根据您的需求进行改进和定制。</p><ul class=""><li id="7c37" class="ls lt iq jp b jq jr ju jv jy oe kc of kg og kk lz ma mb mc bi translated">ASP.NET应用程序通常会有自动化测试。您可能希望在您的配置项中运行这些测试。Travis是一个很好的工具，根据你项目的规模和性质，它可能是免费的。或者，你可以设置Jenkins运行这些测试，并报告结果。</li><li id="ab29" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">如果您打算分发您的应用程序，而不是将其作为您托管的服务提供，请查看<a class="ae kl" href="https://github.com/kubernetes/helm" rel="noopener ugc nofollow" target="_blank"> Helm </a>。</li><li id="4a0d" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">尝试不同的发布策略，找到最适合你需求的一个。确保你通读了<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy" rel="noopener ugc nofollow" target="_blank"> Kubernetes的部署策略</a>。</li><li id="db1b" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">你可以考虑使用Kubernetes 的<a class="ae kl" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">自动缩放功能。</a></li><li id="c3ef" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">这里的库本内特斯集群是在LXD集装箱上。您应该使用私有云(例如Openstack)或公共云。使用<a class="ae kl" href="https://hackernoon.com/kubernetes-1-7-on-ubuntu-the-easy-way-bcd851d4ed35" rel="noopener ugc nofollow" target="_blank">召唤</a>和<a class="ae kl" href="http://Juju" rel="noopener ugc nofollow" target="_blank"> Juju </a>集群部署流程保持不变，与目标云无关。你没有借口。</li><li id="e5be" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">最后，当您迁移到云时，请确保您部署的是Kubernetes的规范发行版，而不是kubernetes-core。您将获得具有HA特性的更健壮的部署，<a class="ae kl" href="https://medium.com/@kwmonroe/monitor-your-kubernetes-cluster-a856d2603ec3" rel="noopener">日志记录和监控</a>。</li></ul><h1 id="227f" class="mt la iq bd lb mu nz mw le mx oa mz lh na ob nc lk nd oc nf ln ng od ni lq nj bi translated">资源</h1><ul class=""><li id="48d1" class="ls lt iq jp b jq lu ju lv jy lw kc lx kg ly kk lz ma mb mc bi translated"><a class="ae kl" href="https://meteatamel.wordpress.com/" rel="noopener ugc nofollow" target="_blank">Mete Atamel</a><a class="ae kl" href="https://meteatamel.wordpress.com/2017/09/11/deploying-asp-net-core-apps-on-kubernetescontainer-engine/" rel="noopener ugc nofollow" target="_blank">https://Mete Atamel . WordPress . com/2017/09/11/Deploying-ASP-net-Core-apps-on-kubernetescontainer-Engine/</a></li><li id="9383" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">ASP。网芯<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/" rel="noopener ugc nofollow" target="_blank">https://docs.microsoft.com/en-us/aspnet/core/</a></li><li id="59cb" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">。净安装<a class="ae kl" href="https://www.microsoft.com/net/learn/get-started/linuxubuntu" rel="noopener ugc nofollow" target="_blank">https://www.microsoft.com/net/learn/get-started/linuxubuntu</a></li><li id="010e" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">Docker安装<a class="ae kl" href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/installation/Linux/docker-ce/Ubuntu/# install-docker-ce</a></li><li id="0c8d" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">Juju:工作原理【https://jujucharms.com/how-it-works T2】</li><li id="148c" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">https://jujucharms.com/docs/stable/getting-started<a class="ae kl" href="https://jujucharms.com/docs/stable/getting-started" rel="noopener ugc nofollow" target="_blank">的juju Docs</a></li><li id="8a9c" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">朱珠<a class="ae kl" href="https://jujucharms.com/" rel="noopener ugc nofollow" target="_blank">https://jujucharms.com/</a></li><li id="be64" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">“Kubernetes 1.7 on Ubuntu，the Easy Way”作者Tim Van Steen burgh<a class="ae kl" href="https://hackernoon.com/kubernetes-1-7-on-ubuntu-the-easy-way-bcd851d4ed35" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/Kubernetes-1-7-on-Ubuntu-the-Easy-Way-BCD 851d 4 ed 35</a></li><li id="3164" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">《监控你的Kubernetes集群》作者凯文·门罗<a class="ae kl" href="https://medium.com/@kwmonroe/monitor-your-kubernetes-cluster-a856d2603ec3" rel="noopener">https://medium . com/@ kw Monroe/Monitor-your-Kubernetes-Cluster-a856d 2603 ec3</a></li><li id="829d" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">Kubernetes部署策略<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/Deployment/# strategy</a></li><li id="300c" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">kubernetes Horizontal Pod Autoscale<a class="ae kl" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/run-application/Horizontal-Pod-Autoscale/</a></li><li id="4389" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">https://travis-ci.org/</li><li id="363d" class="ls lt iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">掌舵<a class="ae kl" href="https://github.com/kubernetes/helm" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes/helm</a></li></ul></div></div>    
</body>
</html>