<html>
<head>
<title>Integration Testing with TestCafe &amp; BrowserStack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TestCafe &amp; BrowserStack进行集成测试</h1>
<blockquote>原文：<a href="https://itnext.io/using-testcafe-with-browserstack-ea180520feb?source=collection_archive---------1-----------------------#2018-02-25">https://itnext.io/using-testcafe-with-browserstack-ea180520feb?source=collection_archive---------1-----------------------#2018-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/13469767c5fa86002168426a12c6584a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*8Nv32udTl0GRSaXXwhhAfg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">via <a class="ae jy" href="https://devexpress.github.io/testcafe" rel="noopener ugc nofollow" target="_blank"> TestCafe </a></figcaption></figure><p id="e5e5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><a class="ae jy" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fusing-testcafe-with-browserstack-ea180520feb" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="5b18" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我最近被分配了为一个工作项目设置集成测试的任务。我们在两个开源解决方案之间做决定，分别是<a class="ae jy" href="http://nightwatchjs.org/" rel="noopener ugc nofollow" target="_blank"> Nightwatch </a>和<a class="ae jy" href="https://devexpress.github.io/testcafe/" rel="noopener ugc nofollow" target="_blank"> TestCafe </a>。最终我们选择了TestCafe，因为<a class="ae jy" href="https://dzone.com/articles/testcafe-e2e-testing-tool" rel="noopener ugc nofollow" target="_blank">它不是基于Selenium </a>的，后者允许更简单的设置和更少的工具。它还提供了对ES6语法的开箱即用支持，以及一个<a class="ae jy" href="https://github.com/DevExpress/testcafe-react-selectors" rel="noopener ugc nofollow" target="_blank">便捷插件</a>，用于扩展其内置选择器以轻松测试React组件。这里有一篇关于使用TestCafe vs Nightwatch的利弊的文章。</p><p id="7f14" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">BrowserStack是一个基于云的测试服务，它允许你启动几乎任何相关的浏览器，而不需要虚拟机。他们还为开源项目提供免费计划。我已经使用BrowserStack一段时间来手动检查我们的应用程序的跨浏览器兼容性问题，这显然不是最好的解决方案。幸运的是，TestCafe通过一个简单的插件<a class="ae jy" href="https://github.com/DevExpress/testcafe-browser-provider-browserstack" rel="noopener ugc nofollow" target="_blank">test cafe-browser-provider-BrowserStack</a>提供了与browser stack自动化API的集成，这允许我们在整个支持的浏览器矩阵中运行自动化测试。</p><h2 id="1ab1" class="ky kz iq bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">使用TestCafe的CLI和BrowserStack</h2><p id="4c62" class="pw-post-body-paragraph jz ka iq kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ij bi translated">在一个或多个BrowserStack云浏览器中运行测试非常简单。首先安装TestCafe和BrowserStack插件:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a050" class="ky kz iq mb b gy mf mg l mh mi">npm install --save-dev testcafe testcafe-browser-provider-browserstack</span></pre><p id="9d8d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">接下来，用shell配置中的<code class="fe mj mk ml mb b">BROWSERSTACK_USERNAME</code>和<code class="fe mj mk ml mb b">BROWSERSTACK_ACCESS_KEY</code>设置环境变量。</p><p id="9d55" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">最后，向您的package.json添加一个脚本:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="331a" class="ky kz iq mb b gy mf mg l mh mi">"scripts": {<br/>  "test:e2e": "testcafe 'browserstack:firefox@58.0:OS X HighSierra,browserstack:ie@11:Windows 10' e2e-tests/*.js --app 'commandToStartApp'"<br/>}</span></pre><p id="8693" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行<code class="fe mj mk ml mb b">npm run test:e2e</code>并前往您的<a class="ae jy" href="https://www.browserstack.com/automate" rel="noopener ugc nofollow" target="_blank">浏览器堆栈自动化仪表板</a>查看您的测试。上面的命令将运行Firefox 58和IE 11中“e2e测试”目录下的所有测试。关于使用CLI设置TestCafe的更深入的解释，请查看Markus Oberleher的文章。</p><h2 id="c40c" class="ky kz iq bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">浏览器堆栈并行工作进程限制</h2><p id="6586" class="pw-post-body-paragraph jz ka iq kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ij bi translated">我得到的第一个教训是，BrowserStack只根据您的计划提供一定数量的并行工作器。我们的开源计划碰巧给了我们5个，但是我天真地用10多个浏览器运行了上面显示的命令。令我恐惧的是，我意识到如果你让TestCafe让大量浏览器排队，它会使你所有的BrowserStack实例崩溃，无论你在automate仪表板上疯狂地点击多少次“停止会话”都救不了你。TestCafe期望所有指定的浏览器都被连接起来，并自动并行运行您的测试。那么，我们如何才能利用我们分配的5名员工，而不把一切都搞砸呢？</p><p id="5708" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">TestCafe不支持连续运行测试，所以我需要提出自己的解决方案。我没有使用CLI界面，而是创建了一个使用TestCafe节点API的脚本。</p><h2 id="b247" class="ky kz iq bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">通过BrowserStack使用TestCafe的节点API</h2><p id="b3d5" class="pw-post-body-paragraph jz ka iq kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ij bi translated">在下面的要点中，我编写了一个异步函数来创建一个新的服务器实例。这个函数将浏览器作为一个字符串，<code class="fe mj mk ml mb b">'browserstack:firefox@58.0:OS X HighSierra'</code>，或者可选地作为一个字符串数组，例如</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="29d3" class="ky kz iq mb b gy mf mg l mh mi">[<br/>   <!-- -->"browserstack:safari@11.0:OS X High Sierra",<br/>   "browserstack:safari@10.1:OS X Sierra",<br/>   "browserstack:edge@16.0:Windows 10",<br/>   "browserstack:edge@15.0:Windows 10",<br/>   "browserstack:ie@11.0:Windows 10"<br/>]</span></pre><p id="373c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">同样的道理也适用于<code class="fe mj mk ml mb b">testFiles</code>参数，它可以是你想要的测试文件的路径或者路径数组。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dbdc" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在让我们使用这个函数为每批浏览器创建一个新的TestCafe实例。在这种情况下，我有10个浏览器需要测试。我最多有5个并行工作器可用，所以这意味着我需要将浏览器分成2批，每批将被传递给一个新的TestCafe实例。下面你会看到一个定义我们支持的浏览器矩阵的数组，以及一个循环遍历这些批处理的<code class="fe mj mk ml mb b">startTests</code>函数。如果您的BrowserStack计划只支持1个并行工作器，那么您可以在该数组中定义所有浏览器，而不必将它们分成子数组。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6a6c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在，如果你运行这个，你会看到第一批浏览器将启动，只有当这些完成后，第二批才会启动。</p><p id="52ba" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您可能已经注意到，我们在上面只定义了一个测试:<code class="fe mj mk ml mb b">e2e-tests/mytest.js</code>。您可能想要运行一整套测试，如果我们可以使用glob模式来获取所有的测试文件，而不是硬编码一个路径数组，那就太好了。不幸的是，TestCafe节点API <a class="ae jy" href="https://github.com/DevExpress/testcafe/issues/980" rel="noopener ugc nofollow" target="_blank">不支持glob模式</a>，所以我们需要创建一个简单的助手函数来完成这项工作。首先:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0c1b" class="ky kz iq mb b gy mf mg l mh mi">npm install --save-dev glob glob-promise</span></pre><p id="fe41" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然后我们编写助手函数，并像这样更新我们的脚本:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a46b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">现在我们有了一个脚本，它将根据分配给我们的工作线程来批量初始化我们的BrowserStack工作线程，并获取我们想要运行的测试文件。让我们更新我们包中的“测试:e2e”脚本。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fef8" class="ky kz iq mb b gy mf mg l mh mi">"scripts": {<br/>  "test:e2e": "node scripts/startTests.js"<br/>}</span></pre><h2 id="32c2" class="ky kz iq bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">使用BrowserStack节点API</h2><p id="0225" class="pw-post-body-paragraph jz ka iq kb b kc lr ke kf kg ls ki kj kk lt km kn ko lu kq kr ks lv ku kv kw ij bi translated">但是我们还有一个问题。如果两个开发人员在这个repo中工作，并且碰巧同时运行集成测试，会怎么样？或者我们可能希望将这个脚本工作到我们的CI/CD管道中，并且需要注意不要同时在本地运行该命令。在某种程度上，我们又回到了起点——没有任何措施来防止我们的BrowserStack工作人员过载。</p><p id="193b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为了解决这个问题，我将利用<a class="ae jy" href="https://github.com/scottgonzalez/node-browserstack" rel="noopener ugc nofollow" target="_blank"> BrowserStack节点API </a>。在运行我们的测试之前，我们可以使用它来找出当前有多少正在运行的会话可用。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b3c7" class="ky kz iq mb b gy mf mg l mh mi">npm install --save-dev browserstack </span></pre><p id="1c7d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">接下来，除了前面设置的环境变量(<code class="fe mj mk ml mb b">BROWSERSTACK_USERNAME</code>和<code class="fe mj mk ml mb b">BROWSERSTACK_ACCESS_KEY</code>)之外，我们还需要添加一个环境变量，即访问BrowserStack帐户的密码:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3a0b" class="ky kz iq mb b gy mf mg l mh mi">export BROWSERSTACK_PASSWORD=abc123</span></pre><p id="773d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">然后我们在下面添加助手函数。我们用我们的凭证创建一个新的客户机，然后使用<code class="fe mj mk ml mb b">getApiStatus</code>方法来获取我们正在运行的会话的状态。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d246" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><code class="fe mj mk ml mb b">getRunningBrowserstackSessions</code>将返回类似这样的响应:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e19d" class="ky kz iq mb b gy mf mg l mh mi">{ <br/>   used_time: 214457,<br/>   total_available_time: ‘Unlimited Testing Time’,<br/>   running_sessions: 0,<br/>   sessions_limit: 5 <br/>}</span></pre><p id="1f08" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我将简单地更新我们的<code class="fe mj mk ml mb b">startTests</code>函数，以警告我们没有足够的可用工人，并在执行任何操作之前退出脚本。查看下面的最终脚本:</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="2ac6" class="ky kz iq bd la lb lc dn ld le lf dp lg kk lh li lj ko lk ll lm ks ln lo lp lq bi translated">还要注意几个“陷阱”</h2><ul class=""><li id="ec03" class="mo mp iq kb b kc lr kg ls kk mq ko mr ks ms kw mt mu mv mw bi translated"><a class="ae jy" href="https://www.browserstack.com/question/663" rel="noopener ugc nofollow" target="_blank"> BrowserStack Safari在测试localhost URL</a>时有问题，这就是为什么我没有像在文档中那样在createTestCafe()工厂函数<a class="ae jy" href="http://devexpress.github.io/testcafe/documentation/using-testcafe/programming-interface/createtestcafe.html" rel="noopener ugc nofollow" target="_blank">中将“localhost”指定为主机名。否则Safari只会无限期挂起。</a></li><li id="a0b9" class="mo mp iq kb b kc mx kg my kk mz ko na ks nb kw mt mu mv mw bi translated">这与编写实际的测试有关，但是我犯的一个错误是<a class="ae jy" href="https://github.com/DevExpress/testcafe/issues/2005" rel="noopener ugc nofollow" target="_blank">在http://localhost:3000之后的页面夹具中遗漏了一个尾随/ </a>。如果你使用散列路由器，这会把事情弄糟，并抛出一些疯狂的，不一致的错误。</li></ul><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2cdf" class="ky kz iq mb b gy mf mg l mh mi">fixture`My first test`.page`http://localhost:3000<strong class="mb ir">/</strong>`</span></pre><p id="2206" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">希望这篇文章能帮助你避免我在使用这些工具时犯的一些错误。测试愉快！</p></div></div>    
</body>
</html>