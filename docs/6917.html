<html>
<head>
<title>Flutter: Up your testing game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振:你的测试游戏</h1>
<blockquote>原文：<a href="https://itnext.io/up-your-testing-game-ae40cb5d4449?source=collection_archive---------1-----------------------#2022-04-12">https://itnext.io/up-your-testing-game-ae40cb5d4449?source=collection_archive---------1-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3a97186529d05f09a9356804ed7ff73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SjuJ3VC1VF5gWxy4nPz8A.png"/></div></div></figure><p id="a943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们将看看Flutter的测试框架提供的一个伟大的工具，它给了我们更多的能力来准确地测试我们的小部件。</p><p id="8725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常情况下，使用<code class="fe kw kx ky kz b">find.byType</code>、<code class="fe kw kx ky kz b">find.text</code>和<code class="fe kw kx ky kz b">find.byKey</code>可以非常简单地测试小部件。其中每一个都很容易使用，你选择哪一个取决于你到底要测试什么，但是有一些场景，像这样的基本测试不会产生有价值的结果。</p><p id="26f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下面的小部件为例:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="49ca" class="li lj iq kz b gy lk ll l lm ln">class SampleWidget extends StatelessWidget {<br/>  final bool complete;<br/>  <br/>  const SampleWidget({required this.complete, Key? key}) : super(key: key);</span><span id="f63f" class="li lj iq kz b gy lo ll l lm ln"><a class="ae lp" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(context) {<br/>    return complete<br/>        ? Icon(Icons.check_circle, color: AppTheme.strongBlue)<br/>        : Icon(Icons.circle_outlined, color: AppTheme.strongBlue);<br/>  }<br/>}</span></pre><h1 id="33d4" class="lq lj iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">简单用例(图标)</h1><p id="87a7" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">就我个人而言，我通常不会测试我的所有小部件，上面是一个非常简单的用例的样本，它会让我考虑编写测试，虽然它非常基本，但这个小部件本身确实提出了一些逻辑，在这个小部件内做出了一个决定，虽然这并不复杂，但它的目的是说明测试的理想场景。</p><p id="5535" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的小部件中没有我可以寻找的文本，我没有为单独的图标提供任何键，它们都是图标，所以使用它们的类型不会在准确的测试中产生。</p><p id="6e53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我把测试写成这样:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="0cf3" class="li lj iq kz b gy lk ll l lm ln">testWidgets('Should render the check_circile_icon', (tester) async {<br/>  await tester.pumpApp(const SampleWidget(complete: true));<br/>    <br/>  await tester.pumpAndSettle();</span><span id="806f" class="li lj iq kz b gy lo ll l lm ln">  final iconFinder = find.byType(Icon);</span><span id="66a2" class="li lj iq kz b gy lo ll l lm ln">  expect(iconFinder, findsOneWidget);<br/>});</span><span id="bbab" class="li lj iq kz b gy lo ll l lm ln">testWidgets('Should render the circle_outlined icon', (tester) async {<br/>   await tester.pumpApp(const SampleWidget(complete: false));<br/>      <br/>   await tester.pumpAndSettle();</span><span id="fbfa" class="li lj iq kz b gy lo ll l lm ln">   final iconFinder = find.byType(Icon);</span><span id="e08c" class="li lj iq kz b gy lo ll l lm ln">   expect(iconFinder, findsOneWidget);<br/> });</span></pre><p id="7e06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们都肯定会通过，如果你在哪里看覆盖率报告，那也会显示100%的测试覆盖率，但是测试作为一个整体是非常没有价值的，当它运行逻辑时，逻辑肯定是工作的，你的测试不能证明这一点。</p><p id="609f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你打算花时间写测试(我希望你这样做)，测试应该总是提供覆盖报告之外的价值，测试行覆盖，淡化了单元测试你的代码的价值和目的。</p><p id="8834" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<code class="fe kw kx ky kz b">find.byWidgetPredicate</code>派上用场的地方，它将允许您编写与上面相同的测试，同时能够唯一地识别各个图标。</p><p id="ca3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">find.byWidgetPredicate</code>是一个基于函数的查找，它提供小部件作为它的函数参数，这允许你使用小部件的属性来专门定位同一个小部件的唯一实例。</p><p id="e707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们看下一个例子，我已经更新了<code class="fe kw kx ky kz b">iconFinder</code>来使用<code class="fe kw kx ky kz b">find.byWidgetPredicate</code>查找而不是<code class="fe kw kx ky kz b">find.byType</code>:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="2f05" class="li lj iq kz b gy lk ll l lm ln">testWidgets('Should render the circle_outlined icon', (tester) async {<br/>      await tester.pumpApp(const SampleWidget(complete: false));<br/>      <br/>      await tester.pumpAndSettle();</span><span id="5d85" class="li lj iq kz b gy lo ll l lm ln">  final iconFinder = find.byWidgetPredicate((widget) =&gt; widget is     Icon &amp;&amp; widget.icon ==                              Icons.circle_outlined,<br/>   );</span><span id="a94d" class="li lj iq kz b gy lo ll l lm ln">  expect(textFinder, findsOneWidget);<br/>});</span></pre><p id="a65e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，在函数体中，我们正在寻找一个小部件，它是一个<code class="fe kw kx ky kz b">Icon</code>(因此是一个类型比较)，并且该图标小部件的图标属性与<code class="fe kw kx ky kz b">IconData</code> <code class="fe kw kx ky kz b">Icons.circle_outlined</code>匹配。</p><p id="c90e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，如果出于某种原因，有人出于某种奇怪的原因将<em class="ms">错误的</em>图标更改为<code class="fe kw kx ky kz b">Icons.menu</code>，那么<code class="fe kw kx ky kz b">find.byWidgetPredicate</code>查找将会失败。如果我们使用了<code class="fe kw kx ky kz b">find.byType</code>或者甚至<code class="fe kw kx ky kz b">find.byKey</code>，假设我们提供了惟一的键，测试应该会通过。</p><p id="6908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">小部件测试中的<code class="fe kw kx ky kz b">find.byWidgetPredicate</code>查找允许您编写近乎防弹的测试。</p><h1 id="0779" class="lq lj iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">更好的用例(RichText)</h1><p id="b008" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">上面是一个非常简单的例子，但是在Flutter中，如果一个人想要写一行文本，但是有一个单独的单词，一个风格不同的短语，无论是<strong class="ka ir">粗体</strong>还是<em class="ms">斜体</em>，我们都必须使用<code class="fe kw kx ky kz b">RichText</code>小部件和一系列<code class="fe kw kx ky kz b">TextSpan</code>来实现想要的结果。</p><p id="2742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举个例子:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4306" class="li lj iq kz b gy lk ll l lm ln">RichText(<br/>        text: TextSpan(<br/>          children: [<br/>            const TextSpan(<br/>              text: "Required",<br/>              style: TextStyle(<br/>                fontWeight: FontWeight.bold,<br/>                color: Colors.black,<br/>              ),<br/>            ),<br/>            TextSpan(<br/>              text: " 70%",<br/>              style: const TextStyle(<br/>                color: Colors.black,<br/>              ),<br/>            ),<br/>          ],<br/>        ),<br/>      )</span></pre><p id="a4fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这个特定的小部件我可能不会实际测试，但它是在更复杂的场景中使用<code class="fe kw kx ky kz b">find.byWidgetPredicate</code>的另一个很好的例子。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="65db" class="li lj iq kz b gy lk ll l lm ln">final requiredScoreFinder = find.byWidgetPredicate(<br/>      (widget) =&gt;<br/>          widget is RichText &amp;&amp;<br/>          widget.text.toPlainText().contains("70%"),<br/>    );</span></pre><p id="ffa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于上面的小部件，您可以像上面的示例一样定位它，因为<code class="fe kw kx ky kz b">RichText</code>小部件实际上将文本分成多个部分，<code class="fe kw kx ky kz b">find.text</code>将不起作用。</p><p id="c112" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用<code class="fe kw kx ky kz b">contains</code>进行部分查找，或者您可以简单地使用严格等式，contains对于较长的句子可能更简单。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="eaa5" class="li lj iq kz b gy lk ll l lm ln">final requiredScoreFinder = find.byWidgetPredicate(<br/>      (widget) =&gt;<br/>          widget is RichText &amp;&amp;<br/>          widget.text.toPlainText() == "Results 70%",<br/>    );</span></pre><p id="9102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你现在所看到的，<code class="fe kw kx ky kz b">find.byWidgetPredicate</code>可能是你的测试工具箱中一个非常强大的工具，它将允许你编写更好、更精确的测试。</p><p id="83ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望您对此感兴趣，如果您有任何问题、评论或改进，请随时发表评论。享受你的颤振发展之旅:D</p><p id="7d1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢，一个赞会很棒，如果你真的喜欢，一杯咖啡会很棒。</p><p id="4a2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。</p><p id="da0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望继续单元测试的话题，请看:</p><div class="mt mu gp gr mv mw"><a rel="noopener  ugc nofollow" target="_blank" href="/automated-unit-testing-with-github-actions-1305759fc726"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">使用GitHub动作的自动化单元测试</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">今天我们将讨论一个非常简单的方法，你可以用GitHub的动作来自动化单元测试…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">itnext.io</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jw mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://medium.com/geekculture/unit-testing-datetime-now-with-the-help-of-dart-extensions-d2b0c9f991bf" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">借助Dart扩展对DateTime.now()进行单元测试</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">当需要使用DateTime.now()时，快速演练Flutter中的单元测试</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk jw mw"/></div></div></a></div></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="b35f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ms">原载于2022年4月12日</em><a class="ae lp" href="https://remelehane.dev/posts/up-your-testing-game/" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://remelehane . dev</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>