<html>
<head>
<title>Talking to Postgres with Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Clojure与Postgres对话</h1>
<blockquote>原文：<a href="https://itnext.io/talking-to-postgres-with-clojure-3b2b24ebfb3?source=collection_archive---------2-----------------------#2021-09-27">https://itnext.io/talking-to-postgres-with-clojure-3b2b24ebfb3?source=collection_archive---------2-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ff68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">纯Clojure，没有JDBC！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8e5d9cebee81d827225d973bb322d03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MVgJdSFV3vUfDQEN"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">福蒂斯·福托普洛斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="9445" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">灵感</h2><p id="88ed" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我看了下面这个视频，视频来自<a class="ae le" href="https://twitter.com/tpolecat" rel="noopener ugc nofollow" target="_blank"> Rob Norris </a>关于构建<a class="ae le" href="https://github.com/tpolecat/skunk" rel="noopener ugc nofollow" target="_blank">Skunk</a>——一个Postgres的纯Scala驱动程序:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="243e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…然后被吹走了！我喜欢这种简单的方法和不依赖JDBC驱动的纯Scala。我立刻想尝试在Clojure中构建类似的东西。所以让我带你走过我旅程的起点！</p><p id="705c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于那些在家学习的人来说，这里有一个有用的Docker编写文件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf me l"/></div></figure><h2 id="abb0" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">bytebufferssocket</h2><p id="9b73" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">从与Skunk类似的方法开始，我们创建了一个SocketChannel来读写字节缓冲区。我们将使用异步通道，即<code class="fe mg mh mi mj b">in-ch</code>和<code class="fe mg mh mi mj b">out-ch</code>，而不是在对象上使用读写方法来发送/接收数据。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf me l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">缓冲袋唱片</figcaption></figure><p id="6b3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">客户机和Postgres之间最基本的消息有两种类型；前端和后端。前端消息是发送给Postgres的消息，后端消息是从Postgres接收的消息。</p><p id="7a63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">后端消息都有一个5字节的头。第一个字节作为消息类型，接下来的4个字节是一个代表整个消息长度的<code class="fe mg mh mi mj b">Int32</code>值，<strong class="js iu">包括长度本身</strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/7476e9aef7f021b467f18b5957c48abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4dcwKMyb6JmRncVR9nN8w.png"/></div></div></figure><p id="f802" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了将接收到的字节缓冲区(来自Postgres的后端消息)发送给下游侦听器，我们需要:</p><ul class=""><li id="7eca" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">阅读标题</li><li id="62d7" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">确定总消息长度，</li><li id="8099" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">然后读入剩余的消息负载。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf me l"/></div></figure><p id="c6a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们有了完整的消息，我们就可以通过异步通道将它传递到下游。知道了这一点，我们就可以构建一个<code class="fe mg mh mi mj b">init-buffer-socket</code>函数，用一对<code class="fe mg mh mi mj b">go-loop</code>来设置我们的<code class="fe mg mh mi mj b">ByteBufferSocket</code>，以处理如下消息:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf me l"/></div></figure><p id="6c7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从端口和主机名创建、连接并最终关闭一个<code class="fe mg mh mi mj b">SocketChannel</code>，然后将该<code class="fe mg mh mi mj b">SocketChannel</code>包装在我们的<code class="fe mg mh mi mj b">ByteBufferSocket</code>类中，并构建以下实用函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf me l"/></div></figure><p id="4e61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于具有用户“jimmy”和数据库名称“world”的Postgres数据库，我们可以发送以下字节数组<code class="fe mg mh mi mj b">startup-bytes</code> ( <a class="ae le" href="https://www.postgresql.org/docs/current/protocol-flow.html#id-1.10.5.7.3" rel="noopener ugc nofollow" target="_blank">启动消息</a>下面的字节是提前生成的🤓)并打印出响应:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mf me l"/></div></figure><p id="598a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从Postgres得到以下消息！</p><pre class="kp kq kr ks gt mz mj na nb aw nc bi"><span id="8d9b" class="lf lg it mj b gy nd ne l nf ng">(82 0 0 0 12 0 0 0 5 -112 46 -47 -14)</span></pre><p id="d721" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个字节，<code class="fe mg mh mi mj b">82</code>告诉我们这是一个认证请求消息。消息长度<code class="fe mg mh mi mj b">0 0 0 12</code>是一个<code class="fe mg mh mi mj b">Int32</code>，即12，这意味着剩余的有效载荷是8个字节长。规范告诉我们接下来的4个字节，<code class="fe mg mh mi mj b">0 0 0 5</code>是一个<code class="fe mg mh mi mj b">Int32</code>(也就是数字5)。这又告诉我们该请求是<a class="ae le" href="https://www.postgresql.org/docs/current/protocol-message-formats.html" rel="noopener ugc nofollow" target="_blank"> AuthenticationMD5Password后端消息</a>，最后4个字节<code class="fe mg mh mi mj b">-112 46 -47 -14</code>是salt。</p><p id="e5e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以基本上Postgres希望我们发送用户名和密码，用MD5散列加密，使用上面的盐！</p><p id="439b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nh">注意:上面请求的PasswordMessage可以用SQL计算如下:</em></p><pre class="kp kq kr ks gt mz mj na nb aw nc bi"><span id="d0ac" class="lf lg it mj b gy nd ne l nf ng">concat('md5', <br/>  md5(concat(<br/>    md5(concat(password, username)), <br/>  random-salt)))</span></pre><p id="c2b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在大约~70行的Clojure中，我们可以来回发送数据到Postgres！围绕解析消息和远离字节数组还有很多工作要做，所以请继续关注未来的博客文章。与此同时，如果你想了解更多，请前往我在Clunk GitHub 页面上的<a class="ae le" href="https://github.com/duanebester/clunk/tree/experimental" rel="noopener ugc nofollow" target="_blank">实验分支！</a></p></div></div>    
</body>
</html>