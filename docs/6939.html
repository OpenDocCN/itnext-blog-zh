<html>
<head>
<title>Supply Chain Security with Cosign and Kyverno for On-premise Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Cosign和Kyverno为内部Kubernetes提供供应链安全性</h1>
<blockquote>原文：<a href="https://itnext.io/supply-chain-security-with-cosign-and-kyverno-for-on-premise-kubernetes-2fa40ceef3c0?source=collection_archive---------3-----------------------#2022-04-18">https://itnext.io/supply-chain-security-with-cosign-and-kyverno-for-on-premise-kubernetes-2fa40ceef3c0?source=collection_archive---------3-----------------------#2022-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5511a7b19a92bef052aa0af1fd676131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvE2iuis1NdtuIUCpEkGqQ.jpeg"/></div></div></figure><p id="a9a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于任何认真采用云的人来说，供应链安全正变得越来越重要。本文探讨了私有注册表中的容器映像如何被验证为它所声称的那样，并由验证策略强制执行。</p><h2 id="f57f" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">工具和环境</h2><p id="aafe" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我将使用<a class="ae lx" href="https://github.com/sigstore/cosign" rel="noopener ugc nofollow" target="_blank"> Sigstore的Cosign </a>工具来签署容器图像，并使用<a class="ae lx" href="https://kyverno.io" rel="noopener ugc nofollow" target="_blank"> Kyverno </a>策略引擎来验证图像。目标Kubernetes环境是OpenShift(版本4.10)。</p><p id="2728" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与使用Cosign和Kyverno时处理常见的公共可用图像注册中心不同，我的探索将主要集中在本地容器注册中心，这是来自OpenShift的私有注册中心。</p><h2 id="9a2a" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">容器图像</h2><p id="9a9d" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">一个toy Golang Web处理程序应用程序被用来演示这个过程。构建图像的多阶段Dockerfile文件如下所示。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="65cc" class="kz la it md b gy mh mi l mj mk">FROM golang as builder<br/>WORKDIR /build<br/>COPY ./src /build</span><span id="e4ed" class="kz la it md b gy ml mi l mj mk">RUN CGO_ENABLED=0 go build -o serving *.go</span><span id="871b" class="kz la it md b gy ml mi l mj mk">FROM alpine<br/>WORKDIR /app<br/>COPY --from=builder /build/serving /app</span><span id="6f7c" class="kz la it md b gy ml mi l mj mk">ENTRYPOINT ["./serving"]</span></pre><p id="f91d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用Buildah工具构建并将映像推送到OpenShift的私有注册表中。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8e96" class="kz la it md b gy mh mi l mj mk">buildah build-using-dockerfile -f ./Dockerfile -t myimg:v1.0 .</span><span id="d549" class="kz la it md b gy ml mi l mj mk">buildah push --tls-verify=false --creds=anyone:$(oc whoami -t) myimg:v1.0 docker://default-route-openshift-image-registry.apps.dev-ocp410.ibmcloud.io.cpak/cosign-exp/myimg:v1.0</span></pre><h2 id="0532" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">用连署签署图像</h2><p id="027d" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">从Github版本中获取最新的Cosign工具。如下创建密钥对，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9447" class="kz la it md b gy mh mi l mj mk">COSIGN_PASSWORD=password cosign generate-key-pair</span></pre><p id="00f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一对密钥，<code class="fe mm mn mo md b">cosign.pub and cosign.key</code>文件被创建。</p><p id="2622" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">登录OCP私人登记处，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ca18" class="kz la it md b gy mh mi l mj mk">cosign login default-route-openshift-image-registry.apps.dev-ocp410.ibmcloud.io.cpak -u any -p $(oc whoami -t)</span></pre><p id="3262" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用私钥对图像签名，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f2c1" class="kz la it md b gy mh mi l mj mk">COSIGN_PASSWORD=password cosign sign --key cosign.key --allow-insecure-registry default-route-openshift-image-registry.apps.dev-ocp410.ibmcloud.io.cpak/cosign-exp/myimg:v1.0</span></pre><p id="6d05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，注册表的证书是自签名的，我们添加了允许不安全的注册表标志以跳过错误消息。</p><p id="2a77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们检查OpenShift图像流，</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/cfdf12aeda0cf81216ad17ce2e4beec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZZh4kIsHm1UJtTrf5bgSw.png"/></div></div></figure><p id="71ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个特殊的图像标签作为连署签名。</p><p id="06e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以用公钥来验证它，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8b60" class="kz la it md b gy mh mi l mj mk">COSIGN_PASSWORD=password <strong class="md iu">cosign verify</strong> --key cosign.pub --allow-insecure-registry default-route-openshift-image-registry.apps.dev-ocp410.ibmcloud.io.cpak/cosign-exp/myimg:v1.0</span><span id="a610" class="kz la it md b gy ml mi l mj mk">Verification for default-route-openshift-image-registry.apps.dev-ocp410.ibmcloud.io.cpak/cosign-exp/myimg:v1.0 --<br/>The following checks were performed on each of these signatures:<br/>  - The cosign claims were validated<br/>  - The signatures were verified against the specified public key</span><span id="0ff0" class="kz la it md b gy ml mi l mj mk">[{"critical":{"identity":{"docker-reference":"default-route-openshift-image-registry.apps.dev-ocp410.ibmcloud.io.cpak/cosign-exp/myimg"},"image":{"docker-manifest-digest":"sha256:0e1a2dcd81a34dcaf21e5e082177883a49322a96f71d32d147cd1f3ea0a249a7"},"type":"cosign container image signature"},"optional":null}]</span></pre><p id="f445" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们如何确保映像在运行前得到验证和确认？我们用Kyverno政策强制执行。</p><h2 id="8ddd" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">部署Kyverno并验证</h2><p id="800a" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">标准Kyverno部署很简单。我们使用舵图方法。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="63ef" class="kz la it md b gy mh mi l mj mk">helm repo add kyverno <a class="ae lx" href="https://kyverno.github.io/kyverno/" rel="noopener ugc nofollow" target="_blank">https://kyverno.github.io/kyverno/</a><br/>helm repo update<br/>helm install kyverno kyverno/kyverno -n kyverno --create-namespace</span></pre><p id="5287" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦pod运行并准备就绪，我们就可以执行下面的Kyverno策略来验证图像是否由我们签名。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="e354" class="kz la it md b gy mh mi l mj mk">apiVersion: kyverno.io/v1<br/>kind: Policy<br/>metadata:<br/>  name: verify-image-in-namespace<br/>  namespace: cosign-exp<br/>spec:<br/>  validationFailureAction: enforce<br/>  background: false<br/>  rules:<br/>    - name: verify-image<br/>      match:<br/>        any:<br/>        - resources:<br/>            kinds:<br/>              - Pod<br/>      verifyImages:<br/>        - image: "image-registry.openshift-image-registry.svc*"<br/>          key: |-<br/>            -----BEGIN PUBLIC KEY-----<br/>           MFkwEwYHKoZIzj...SKIPPED...<br/>            -----END PUBLIC KEY-----</span></pre><p id="019a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个名称空间策略，在该名称空间内，所有来自私有注册中心的图像，通过匹配<code class="fe mm mn mo md b">image-registry.openshift-image-registry.svc*</code>，必须用另一对用于签名图像的公钥进行验证。</p><p id="7197" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，因为我们的目标是集群内使用，所以容器注册中心将是OpenShift内部名称，<code class="fe mm mn mo md b">image-registry.openshift-image-registry.svc:5000</code></p><p id="6ab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在部署应用程序，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="9597" class="kz la it md b gy mh mi l mj mk">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: cosign-exp-app<br/>  labels:<br/>    app: cosign-exp-app<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: cosign-exp-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: cosign-exp-app<br/>    spec:<br/>      containers:<br/>      - name: cosign-exp-app<br/>        image: image-registry.openshift-image-registry.svc:5000/cosign-exp/myimg:v1.0<br/>        ports:<br/>        - containerPort: 8080</span></pre><p id="787f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于映像已经签名，我们希望部署能够成功。然而，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ad8b" class="kz la it md b gy mh mi l mj mk">Error from server: error when creating "cosign-exp-app.deploy.yaml": admission webhook "mutate.kyverno.svc-fail" denied the request:</span><span id="8c4c" class="kz la it md b gy ml mi l mj mk">resource Deployment/cosign-exp/cosign-exp-app was blocked due to the following policies</span><span id="e66b" class="kz la it md b gy ml mi l mj mk">verify-image-in-namespace:<br/>  autogen-verify-image: 'image verification failed for image-registry.openshift-image-registry.svc:5000/cosign-exp/myimg:v1.0:<br/>    Get "<a class="ae lx" href="https://image-registry.openshift-image-registry.svc:5000/v2/" rel="noopener ugc nofollow" target="_blank">https://image-registry.openshift-image-registry.svc:5000/v2/</a>": x509: certificate<br/>    signed by unknown authority'</span></pre><p id="e004" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们使用的是私有注册中心，所以证书是由OpenShift内部CA签名的，Kyverno不知道这个CA。</p><h2 id="684e" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">修复错误</h2><p id="a18f" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">不像Cosign现在支持带有命令标志的私有CA。嵌入式联合签名功能尚不支持私有根CA，正如本<a class="ae lx" href="https://github.com/kyverno/kyverno/issues/2396" rel="noopener ugc nofollow" target="_blank">未决问题#2396 </a>所指出的。</p><p id="a91f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过将私有根CA添加到系统信任的CA中来解决这个问题。</p><p id="9150" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当在集群内部使用私有注册表时，其证书由OpenShift CA签名，该证书可以如下提取:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="5917" class="kz la it md b gy mh mi l mj mk">oc -n openshift-service-ca get secret signing-key -o jsonpath='{.data.tls\.crt}' | base64 -d &gt; service-ca.crt</span></pre><p id="6208" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用service-ca.crt，我们可以通过扩展映像从系统更新受信任的ca，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="a170" class="kz la it md b gy mh mi l mj mk">FROM ubuntu as certBase</span><span id="4433" class="kz la it md b gy ml mi l mj mk">ADD service-ca.crt /usr/local/share/ca-certificates/<br/>#notice the trailing slash</span><span id="c2da" class="kz la it md b gy ml mi l mj mk">RUN apt update &amp;&amp; apt install -y ca-certificates &amp;&amp; update-ca-certificates</span><span id="6922" class="kz la it md b gy ml mi l mj mk">FROM ghcr.io/kyverno/kyverno:v1.6.2<br/>USER root<br/>COPY --from=certBase /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/<br/>USER 10001</span></pre><p id="15f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建并将其作为<code class="fe mm mn mo md b">image-registry.openshift-image-registry.svc:5000/kyverno/my-kyverno:v1.0</code>推入OpenShift私有注册表</p><h2 id="4873" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">私有注册表的配置</h2><p id="52b9" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">除了根CA证书之外，我们还需要对私有注册中心进行一些进一步的配置。需要注册表验证。</p><p id="43c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于OpenShift，我们可以创建一个服务帐户，并为映像访问分配适当的RBAC权限。然后，它的令牌可以用于注册表身份验证。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f91e" class="kz la it md b gy mh mi l mj mk">kubectl -n kyverno create sa sa-image-verifier</span></pre><p id="78d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">绑定以下现成的ClusterRole，system:image-puller，for image</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="da2c" class="kz la it md b gy mh mi l mj mk">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: kyverno-image-verifier<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: system:image-puller<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: sa-image-verifier<br/>  namespace: kyverno</span></pre><p id="cfcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Kyverno名称空间中创建密码，将令牌值作为密码，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="01de" class="kz la it md b gy mh mi l mj mk">kubectl -n kyverno create secret docker-registry <strong class="md iu">regcred-for-kyverno </strong>--docker-server=image-registry.openshift-image-registry.svc:5000 \<br/>--docker-username=token \<br/>--docker-password=$(oc -n kyverno sa get-token sa-image-verifier)</span></pre><h2 id="f92d" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">更新Kyverno头盔版本</h2><p id="48c3" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">通过所有这些更新，创建以下值YAML文件，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2a28" class="kz la it md b gy mh mi l mj mk">image:<br/>  repository: image-registry.openshift-image-registry.svc:5000/kyverno/my-kyverno<br/>  tag: v1.0</span><span id="afab" class="kz la it md b gy ml mi l mj mk">initImage:<br/>  repository: ghcr.io/kyverno/kyvernopre<br/>  tag:  v1.6.2 #default the same as image.tag, so need to set the correct tag</span><span id="4161" class="kz la it md b gy ml mi l mj mk">extraArgs:<br/>  - --imagePullSecrets=regcred-for-kyverno</span></pre><p id="f907" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更新头盔版本，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2107" class="kz la it md b gy mh mi l mj mk">helm upgrade --install -n kyverno kyverno kyverno/kyverno -f values.yaml</span></pre><h2 id="e01d" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">验证测试</h2><p id="d99e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">让我们测试没有签名的映像部署。使用oc命令删除特殊标记，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6d82" class="kz la it md b gy mh mi l mj mk">oc delete istag myimg:sha256-0e1a2dcd81a34dcaf21e5e082177883a49322a96f71d32d147cd1f3ea0a249a7.sig</span></pre><p id="9173" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mq">联合签名清理不适用于OCP私人注册中心。</em></p><p id="8864" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">部署失败，</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="595f" class="kz la it md b gy mh mi l mj mk">Error from server: error when creating "cosign-exp-app.deploy.yaml": admission webhook "mutate.kyverno.svc-fail" denied the request:</span><span id="e9be" class="kz la it md b gy ml mi l mj mk">resource Deployment/cosign-exp/cosign-exp-app was blocked due to the following policies</span><span id="d3e5" class="kz la it md b gy ml mi l mj mk">verify-image-in-namespace:<br/>  autogen-verify-image: 'image verification failed for image-registry.openshift-image-registry.svc:5000/cosign-exp/myimg:v1.0:<br/>    signature mismatch'</span></pre><p id="efc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新提交映像并重新部署，部署成功。</p><h2 id="7eae" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">结论</h2><p id="124e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">通过一些特殊的设置和修复，可以使用Cosign和Kyverno工具来管理私有图像的供应链安全性。</p></div></div>    
</body>
</html>