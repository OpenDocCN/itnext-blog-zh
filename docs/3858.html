<html>
<head>
<title>Adding security layers to your App on OpenShift - Update: Welcome Vault Agent Injector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在OpenShift上向您的应用添加安全层-更新:欢迎使用Vault代理注入器</h1>
<blockquote>原文：<a href="https://itnext.io/adding-security-layers-to-your-app-on-openshift-update-welcome-vault-agent-injector-46cab161c366?source=collection_archive---------0-----------------------#2020-03-13">https://itnext.io/adding-security-layers-to-your-app-on-openshift-update-welcome-vault-agent-injector-46cab161c366?source=collection_archive---------0-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，保护你的应用程序是必须的，但是如果你没有在一开始就考虑它，那么在不修改代码的情况下引入它是很困难的。幸运的是，像<a class="ae kl" href="http://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>这样的容器和平台带来的新的云原生模式提供了简单的方法来解决安全问题，而无需接触代码。</p><p id="bc6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是对本系列的第3部分和第4部分的更新，在这里我们已经了解了如何在<a class="ae kl" href="http://www.kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>上轻松部署<a class="ae kl" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>并从我们的<code class="fe km kn ko kp b">fruits-catalog</code>应用程序中使用它来保护数据库凭证等敏感信息。</p><p id="4921" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">时间飞逝…从这个系列开始，Vault与Kubernetes的集成已经有了很大的改进！我们将在这一部分看到——这是对以前部分的更新——由于有了<a class="ae kl" href="https://www.vaultproject.io/docs/platform/k8s/injector/" rel="noopener ugc nofollow" target="_blank"> Vault Agent Injector </a>，现在将我们的应用程序连接到Vault进行秘密注入是多么简单和优雅。</p><blockquote class="kq kr ks"><p id="8e7e" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">这部分由Hashicorp的<a class="ae kl" href="https://medium.com/@nehrman" rel="noopener"> Nicolas Ehrman </a>实现并校对。感谢Nico的帮助和建议！</p></blockquote><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/2782f91f5faba0bd8b1717aa627fa4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DejNIEf1l1Hzi8KY4cDOnA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">更新-欢迎Vault Agent Injector Kubernetes集成</figcaption></figure><p id="ce06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kt">这篇文章是一个更大的系列文章的一部分，讲述了如何给现有的应用程序增加安全层。到目前为止公布的其他部分有:</em></p><ul class=""><li id="eed5" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-1-deployment-and-tls-ingress-9ef752835599" rel="noopener"> <em class="kt">第1部分—部署和TLS入口</em> </a></li><li id="5d39" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-2-8320018bcdd1" rel="noopener"> <em class="kt">第二部分——使用钥匙锁进行认证和授权</em> </a></li><li id="b246" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener"> <em class="kt">第三部分——金库秘密管理</em> </a></li><li id="a4ef" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener"> <em class="kt">第四部——带金库的动态秘密</em> </a></li><li id="248f" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-5-mutual-tls-with-istio-a8800c2e4df4" rel="noopener"> <em class="kt">第5部分——与Istio </em> </a>的相互TLS</li><li id="68c3" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-6-pki-as-a-service-with-vault-and-cert-e6dbbe7028c7" rel="noopener"> <em class="kt">第6部分—使用保管库和证书管理器的PKI服务</em> </a></li><li id="f6af" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated"><em class="kt">更新—欢迎保险库代理注入器(此帖子)</em></li></ul><h1 id="7d0a" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">我们想在这部分实现什么？</h1><p id="4a46" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">还记得本系列的第3和第4部分吗？通过丰富我们的配置的部署配置，我们在应用程序容器旁边添加了一个<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> Init容器</a>和一个<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods" rel="noopener ugc nofollow" target="_blank"> Sidecar容器</a>，以便最初从Vault获取和更新数据库凭证。</p><p id="4af8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们除了编辑“手边的”部署和添加基本的容器(这些容器执行奇特的API调用和文件处理命令，以便在正确的位置提供应用程序配置文件)之外，没有其他选择。现在这变得容易多了，这要感谢库代理注入器，它是一个Kubernetes的本地对象，通过在我们的<code class="fe km kn ko kp b">fruits-catalog</code> pod中注入库代理来为我们完成这些修改。</p><p id="8165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将在我们的Vault实例旁边部署这些注入器，以便使它集成我们的应用程序启动流程，如下所述:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ne"><img src="../Images/c6130e2fc668d82b7048a3e83d338cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r192QFjjIfcZJ9AHTB5JfQ.png"/></div></div></figure><p id="a15e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用这个注入器改造我们的架构和启动流程，这样我们就会得到这个相关点:</p><ol class=""><li id="015c" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk nf lt lu lv bi translated">在<code class="fe km kn ko kp b">DeploymentConfig</code>创建时，根据规范注释的存在，<code class="fe km kn ko kp b">vault-agent-injector</code>将放置一个变异钩子。所以每次我们创建一个<code class="fe km kn ko kp b">fruits-catalog</code>容器，一个<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank">初始容器</a>和/或一个<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods" rel="noopener ugc nofollow" target="_blank">端容器</a>将被注入到我们的容器中，以检索管理到保险库中的秘密，</li><li id="e2d7" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">我们还将获得一个由Kubernetes颁发的特定令牌——以及相关的证书——在启动时注入到我们的应用程序Pod中，</li><li id="1d1d" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">由名为<code class="fe km kn ko kp b">vault-agent-init</code>的Vault代理注入器注入的<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> Init容器</a>将使用该特定令牌对Vault进行认证调用，</li><li id="0fc7" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">Vault将能够根据Kubernetes APIs检查这个调用的有效性。如果成功，Vault将允许应用程序访问存储在Vault中的机密，</li><li id="91b6" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk nf lt lu lv bi translated">最后，从Vault中检索到的秘密将通过一个共享文件系统提供给我们的主Spring Boot容器:一个配置文件将在<code class="fe km kn ko kp b">/deployment/config</code>上创建，这样在这个文件中找到的值将覆盖来自部署配置的值。</li></ol><p id="f6c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了另一个名为<code class="fe km kn ko kp b">vault-agent</code>的边车容器被注入并负责租约更新之外，这个过程在动态机密的情况下保持完全相同。</p><p id="bddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当pod被删除时——由于重新调度或应用程序缩减——变异挂钩负责在保险库端停止所获得的凭证租用。</p><h1 id="3648" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">如何应用？</h1><p id="6869" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">现在让我们看看如何部署和配置它…如果您已经阅读了本系列的第一部分，您可能已经克隆了包含所有资源和资产的<a class="ae kl" href="https://github.com/lbroudoux/secured-fruits-catalog-k8s" rel="noopener ugc nofollow" target="_blank"> my GitHub repository </a>。如果没有，我敦促你这样做；-)</p><blockquote class="kq kr ks"><p id="2a4e" class="jn jo kt jp b jq jr js jt ju jv jw jx ku jz ka kb kv kd ke kf kw kh ki kj kk ij bi translated">在开始动手操作之前，我们假设您已经部署并配置了Vault来使用Kubernetes身份验证。如何做到这一点在本系列的<a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener">第3部分</a>中有详细介绍。</p></blockquote><p id="ee19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一项任务是部署存储库代理注入器。Hashicorp现在提供了一种便捷的方式来部署保险库和保险库代理注入器，方法是使用一个简单的舵图(此处记录为<a class="ae kl" href="https://www.vaultproject.io/docs/platform/k8s/helm/" rel="noopener ugc nofollow" target="_blank"/>)。如果您已经阅读了前面的部分，我们已经部署了Vault，所以我提供了一个简单方便的YAML文件，用于添加Vault代理注入器。但在此之前，我们必须创建一个ServiceAccount并为OpenShift设置正确的权限:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="7228" class="nk mc iq kp b gy nl nm l nn no">$ oc create sa vault-agent-injector -n fruits-catalog</span><span id="5f6e" class="nk mc iq kp b gy np nm l nn no">$ oc adm policy add-scc-to-user anyuid -z vault-agent-injector -n fruits-catalog</span><span id="1db7" class="nk mc iq kp b gy np nm l nn no">$ oc apply -f k8s/vault-agent-deployment.yml -n fruits-catalog</span></pre><p id="ba42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就差不多完成了！最后要做的事情是更新我们的<code class="fe km kn ko kp b">DeploymentConfig</code>,在这里我们可以删除所有之前添加的容器，只放置这个se tof注释:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="db2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看所有这些<code class="fe km kn ko kp b">vault.hashicorp.com/*</code>的注解。大多数都很简单，有一个值得我们注意:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="64d7" class="nk mc iq kp b gy nl nm l nn no">vault.hashicorp.com/agent-inject-template-application.properties: |          <br/>  {{- with secret "database/creds/fruit-catalog-role" -}}           <br/>  spring.data.mongodb.uri=mongodb://{{ .Data.username }}:{{ .Data.password }}@mongodb/sampledb<br/>  {{- end }}</span></pre><p id="08dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确实是一个<a class="ae kl" href="https://github.com/hashicorp/consul-template" rel="noopener ugc nofollow" target="_blank">领事模板</a>的表情，有助于判断:</p><ul class=""><li id="a4c7" class="ln lo iq jp b jq jr ju jv jy lp kc lq kg lr kk ls lt lu lv bi translated">生成的文件的名称。这里<code class="fe km kn ko kp b">application.properties</code>，</li><li id="52d4" class="ln lo iq jp b jq lw ju lx jy ly kc lz kg ma kk ls lt lu lv bi translated">该文件的内容。这里有一个简单的行，包含到数据库的连接链:<code class="fe km kn ko kp b">spring.data.mongodb.uri=mongdb://user:password@mongodb/sampledb</code></li></ul><p id="2325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这种模板符号比我们使用的shell命令要简单得多。为了方便起见，我为静态秘密(第3部分)和动态秘密(第4部分)放置了现成的资源文件。因此，这只是用以下资源替换现有资源的问题:</p><pre class="ky kz la lb gt ng kp nh ni aw nj bi"><span id="1664" class="nk mc iq kp b gy nl nm l nn no">$ oc replace -f k8s/fruits-catalog-static-secret-with-agent-deployment.yml</span><span id="e097" class="nk mc iq kp b gy np nm l nn no"># OR for dynamic secrets...</span><span id="3b01" class="nk mc iq kp b gy np nm l nn no">$ oc replace -f k8s/fruits-catalog-dynamic-secret-with-agent-deployment.yml</span></pre><h1 id="3acd" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">检查它是否按预期工作</h1><p id="f8bb" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">除了记录在<a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-3-secret-management-with-vault-8efd4ec29ec4" rel="noopener">第3部分</a>和<a class="ae kl" href="https://medium.com/@lbroudoux/adding-security-layers-to-your-app-on-openshift-part-4-dynamic-secrets-with-vault-b5fe1fc7709b" rel="noopener">第4部分</a>中的程序外，此处不再赘述😉</p><h1 id="3f85" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论</h1><p id="bd2c" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">在这次更新中，我们看到了现在将管理委托给Hashicorp Vault以及将我们的数据库凭证注入到我们的应用程序中是多么简单和优雅。从一个有点糟糕和容易出错的情况来看，Vault Agent Injector所取得的进步现在正在将这种集成模式转变为一种优雅且非常容易设置的模式！</p><p id="c2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用云原生模式，如由Kubernetes <a class="ae kl" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">许可控制器</a>创建的由声明性注释触发的<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> Init </a>和<a class="ae kl" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#understanding-pods" rel="noopener ugc nofollow" target="_blank"> Sidecar </a>容器，再加上生命周期挂钩，您现在拥有了短暂的凭证，它们只存在于pod的生命周期中。使用<a class="ae kl" href="https://github.com/hashicorp/consul-template" rel="noopener ugc nofollow" target="_blank">咨询模板</a>，整个过程变得简单且高度可配置。</p><p id="0cfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读，敬请关注！</p></div></div>    
</body>
</html>