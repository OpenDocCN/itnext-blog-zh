<html>
<head>
<title>Running kubectl Commands From Within a Pod</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Pod中运行kubectl命令</h1>
<blockquote>原文：<a href="https://itnext.io/running-kubectl-commands-from-within-a-pod-b303e8176088?source=collection_archive---------0-----------------------#2020-02-05">https://itnext.io/running-kubectl-commands-from-within-a-pod-b303e8176088?source=collection_archive---------0-----------------------#2020-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="689d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">镜像自</em><a class="ae km" href="https://trstringer.com/kubectl-from-within-pod/" rel="noopener ugc nofollow" target="_blank">https://trstringer.com/kubectl-from-within-pod/</a>。</p><p id="3533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常在内部pod中使用来自<em class="kl">的Kubernetes资源。该平台显然是一个很好的调度器和指挥器，但是您可能需要定制逻辑来从Kubernetes资源中做出决策，或者为Kubernetes资源做出决策。</em></p><p id="0a59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将使用一个简单的例子。假设您需要列出所有的pods，但是您需要从集群中的pods完成这项工作(可能您必须根据资源的状态以编程方式做出决策)。这是一个简单的docker文件，用于示例图像…</p><h1 id="184a" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Dockerfile文件</h1><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="c9e7" class="lu ko iq lq b gy lv lw l lx ly">FROM debian:buster</span><span id="c5d3" class="lu ko iq lq b gy lz lw l lx ly">RUN apt update &amp;&amp; \<br/>      apt install -y curl &amp;&amp; \<br/>      curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl &amp;&amp; \<br/>      chmod +x ./kubectl &amp;&amp; \<br/>      mv ./kubectl /usr/local/bin/kubectl</span><span id="9fbf" class="lu ko iq lq b gy lz lw l lx ly">CMD kubectl get po</span></pre><p id="e9c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一种创建包含<code class="fe ma mb mc lq b">kubectl</code> bin的docker图像的方法。最后，从这个映像创建的任何容器都会运行<code class="fe ma mb mc lq b">kubectl get po</code>。</p><p id="d31a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的直觉可能是创建一个具有以下配置的pod</p><h1 id="6dd1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">pod.yaml</h1><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="7709" class="lu ko iq lq b gy lv lw l lx ly">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: internal-kubectl<br/>spec:<br/>  containers:<br/>    - name: internal-kubectl<br/>      image: trstringer/internal-kubectl:latest</span></pre><p id="346f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试运行这个pod ( <code class="fe ma mb mc lq b">$ kubectl apply -f pod.yaml</code>)，您会在日志中看到以下错误…</p><blockquote class="md me mf"><p id="cd42" class="jn jo kl jp b jq jr js jt ju jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj kk ij bi translated">来自服务器的错误(禁止):pods被禁止:用户" system:service account:default:default "无法在命名空间" default "中列出API组""中的资源" pods "</p></blockquote><p id="d495" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除非另有说明(如上所述)，否则pods将在<code class="fe ma mb mc lq b">default</code>服务帐户下运行，这对于每个名称空间都是现成的。从错误消息中可以看出，<code class="fe ma mb mc lq b">default</code>没有列出pod的正确权限。</p><p id="c6f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阻止我们的潜在力量是<a class="ae km" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>，我们需要正确配置它。告诉Kubernetes我们希望这个pod有一个可以列出pod的身份的方法是通过一些不同资源的组合…</p><h1 id="fe72" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">service-account.yaml</h1><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="eae3" class="lu ko iq lq b gy lv lw l lx ly">apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: internal-kubectl</span></pre><p id="3b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望分配给pod的身份对象将是一个服务帐户。但是它本身没有权限。这就是角色出现的地方。</p><h1 id="2145" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">role.yaml</h1><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="ea44" class="lu ko iq lq b gy lv lw l lx ly">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: Role<br/>metadata:<br/>  name: modify-pods<br/>rules:<br/>  - apiGroups: [""]<br/>    resources:<br/>      - pods<br/>    verbs:<br/>      - get<br/>      - list<br/>      - delete</span></pre><p id="e48d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的角色指定了我们希望能够获取、列出和删除窗格。但是，我们需要一种方法将我们的新服务客户与我们的新角色联系起来。角色绑定是这方面的桥梁…</p><h1 id="673d" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">角色绑定. yaml</h1><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="f7b6" class="lu ko iq lq b gy lv lw l lx ly">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: RoleBinding<br/>metadata:<br/>  name: modify-pods-to-sa<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: internal-kubectl<br/>roleRef:<br/>  kind: Role<br/>  name: modify-pods<br/>  apiGroup: rbac.authorization.k8s.io</span></pre><p id="3665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个角色绑定将我们的服务帐户连接到拥有我们需要的权限的角色。现在，我们只需修改pod配置，以包括服务帐户…</p><h1 id="cdc9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">pod.yaml(新)</h1><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9451" class="lu ko iq lq b gy lv lw l lx ly">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: internal-kubectl<br/>spec:<br/>  serviceAccountName: internal-kubectl<br/>  containers:<br/>    - name: internal-kubectl<br/>      image: trstringer/internal-kubectl:latest</span></pre><p id="dbf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过指定<code class="fe ma mb mc lq b">spec.serviceAccountName</code>，这将我们从使用<code class="fe ma mb mc lq b">default</code>服务帐户更改为具有正确权限的新帐户。运行我们的新pod，我们应该会看到正确的输出…</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="f111" class="lu ko iq lq b gy lv lw l lx ly">$ kubectl logs internal-kubectl<br/>NAME               READY   STATUS    RESTARTS   AGE<br/>internal-kubectl   1/1     Running   1          5s</span></pre><p id="ace1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽情享受吧！</p></div></div>    
</body>
</html>