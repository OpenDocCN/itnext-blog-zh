<html>
<head>
<title>Creating an infinite grid on iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS上创建无限网格</h1>
<blockquote>原文：<a href="https://itnext.io/creating-an-infinite-grid-on-ios-2bd6db28c581?source=collection_archive---------2-----------------------#2018-08-10">https://itnext.io/creating-an-infinite-grid-on-ios-2bd6db28c581?source=collection_archive---------2-----------------------#2018-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ee20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近遇到了一个StackOverflow问题(<a class="ae kl" href="https://stackoverflow.com/questions/51544588/drawing-an-infinite-grid-in-ios" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/51544588/drawing-an-infinite-grid-in-ios</a>)，其中的挑战是使用标准的UIScrollView和/或UIKit在iOS上创建一个无限网格。我是这样解决的。</p><h1 id="ab46" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">定义需求</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/40d1e9a9b1bfcf47df886cff54af7726.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*uYxRGU04u2g8Lk-Qh9-HDw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">iPhone会显示一个无限网格</figcaption></figure><ul class=""><li id="e6a6" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">必须只使用UIKit本机类</li><li id="3aa1" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">滚动应该有预期的滚动视图的感觉</li><li id="d50a" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">用户必须有这样的印象，他们可以永远滚动</li><li id="1248" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">必须是内存高效的</li><li id="39ef" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">内容必须以平铺方式生成，以便构建网格</li><li id="6650" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">初始坐标应该是可指定的</li></ul><h1 id="5231" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">了解制约因素</h1><p id="dcd8" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在我们开始之前，我们必须了解限制因素是什么。</p><ul class=""><li id="ca9a" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">UIScrollView要求在任一时间点都有一组有限子视图。</li><li id="533a" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">当你到达一个滚动视图的末尾时，滚动视图停止或反弹，我们需要它继续无限滚动。</li><li id="1804" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">在启用反弹的情况下，试图滚动越过scrollview的边缘会有一些“弹性”感觉，并且在某些时候scrollview会反弹回其内容限制内；我们不能依靠滚动通过滚动视图的边缘来达到我们的目的。</li><li id="cc1d" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">移动设备上的内存分配是有限的，如果一个应用程序试图分配太多的内存(想想太多的网格块)，该应用程序将被iOS终止。</li><li id="206c" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">UIViews有一个最大大小，我们不能创建一个容器视图放入scrollview并使其无限大。</li></ul><h1 id="861d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">入门，设置滚动视图</h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/5f7071aeea42fd3b0e836895e2af3467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yeWN_YcfPPHJUMci6t20mQ.png"/></div></div></figure><p id="8b9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先向视图控制器添加一个UIScrollView，并对约束进行布局，使ScrollView覆盖整个安全区域。然后我们定义一个小的UIView(大小不重要！)并将前导、尾随、底部和顶部约束设置为0。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/31195c7a3abf2aa298cfd27dbb3b2213.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*KUugAJ0LDLPC-zr2GGGmJw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">带有小参考视图的基本滚动视图</figcaption></figure><p id="f19e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行代码时，您会看到一个根本不滚动的scrollview，但在我们做更多工作之前，让我们看看这个非常简单的应用程序目前使用了多少内存:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/1315acda4efdaf949c12b1ad3641fad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*ff66OLAL4Af-zsEJ1haVig.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">内存要求，仅基本滚动视图+参考视图</figcaption></figure><h1 id="3d7b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">让我看一些滚动！</h1><p id="3c2f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">有多种方法来配置我们的scrollview在我们的例子中，我们将把我们的引用视图更改为一个“GridView”自定义类，并从该视图中执行所有的网格控制。让我们在项目中添加一个新文件，名为GridView.swift:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，基本代码</figcaption></figure><p id="a69b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在Interface Builder中将引用视图类更改为GridView:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi my"><img src="../Images/c546120b7b465feb08d9d7b24d7d93f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHeNCPWvXxfbWRe3ZIsZ_Q.png"/></div></div></figure><p id="9e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保您连接了我们为顶部、底部、左侧和右侧布局约束定义的IBOutlets，以及我们的项目scrollview。让我们看看这是如何运行的:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e73f3feb43fd08db23170753abee1887.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*Hhgk-WGEBqjuVOllSOWNRg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">带有大滚动区的滚动视图</figcaption></figure><p id="2153" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美！我们现在有一个非常大的滚动区域，但不是很有用，让我们确保理解我们介绍的代码。</p><p id="7d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们添加了一个值为10000000.0的“<strong class="jp ir">arbitraylargeoffset</strong>；顾名思义，这个值是任意的，几乎可以设置为任何值。该值控制用户在到达scrollview的末尾之前可以在参考视图的任意一侧滚动多远。</p><p id="02f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于UIScrollView不为可滚动区分配像素缓冲区，因此我们可以在不影响内存使用的情况下使该值变得很大。这个值越大，在我们变“魔术”之前，用户就越能够连续滚动。理论上，如果这个值足够大，在这种情况发生之前，用户会厌倦连续滚动。将这个值临时更改为1000.0范围内的值，应该可以让您了解为什么这个数字需要很大。</p><p id="6a60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了正确设置这个大的可滚动区域，我们接入了<strong class="jp ir"> awakeFromNib() </strong>函数来执行我们的自定义<strong class="jp ir">definescrollabearea()</strong>函数，并将所有布局约束更新为我们的任意值。我们还执行了<strong class="jp ir"> centreOurReferenceView() </strong>函数，因此我们从屏幕上可见的参考视图开始。</p><h1 id="83ad" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">添加我们的网格</h1><p id="5b1a" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在我们的例子中，让我们假设当网格第一次建立时，屏幕中心的初始坐标是(0，0)。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/97a0a2cd22c5b4fd14637a53c2d0ed90.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*dFmO6BdJvCLI3C2fwGRJoQ.jpeg"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">网格初始坐标</figcaption></figure><p id="3740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在视图中添加网格块时，我们需要跟踪哪些坐标在屏幕上可见，哪些“块”与哪些坐标相关联，以及滚动视图中心的可见坐标。</p><p id="c4eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们创建一个名为GridTile的自定义UIView类:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">一个非常简单的瓷砖</figcaption></figure><p id="ccac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的简单图块将简单地显示一个UILabel，其中包含分配给图块的坐标。让我们也用几行代码更新我们的GridView.swift文件:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，图块分配代码</figcaption></figure><p id="c0a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后更新我们的<strong class="jp ir"> awakeFromNib() </strong>来调用我们刚刚添加的<strong class="jp ir">allocateinitiatiles()</strong>函数:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，更新了awakeFromNib()</figcaption></figure><p id="682d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行我们的示例代码，我们现在获得:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/61cdab166dcacc5a2f2e1efbfceeed8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*YqNsh2kdEzhkKOub_sTcIg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">测试allocateTile(位于:)函数</figcaption></figure><p id="02e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，GridTile.swift代码相对简单，它是一个自定义视图，带有显示坐标的UILabel as子视图。在现实世界的例子中，这些可以是地图块，或者任何需要显示在无限网格中的东西。</p><p id="17dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为我们在GridView.swift中添加的代码的一部分，我们有<strong class="jp ir"> allocateTile(at:) </strong>，顾名思义，它将在指定的坐标上分配一个新的网格块。该函数使用<strong class="jp ir"> frameForTile(at:) </strong>函数来计算该图块在网格中的放置位置。</p><p id="4669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> frameForTile(at:) </strong>中的计算故意比实际情况复杂一些。这样做的目的是为了将网格块的大小从我们在界面构建器中定义的参考视图大小中分离出来。继续更改'<strong class="jp ir"> tileSize </strong>'变量，看看这会如何影响瓷砖的放置。</p><h1 id="cc77" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">部分自动化电网建设</h1><p id="9af8" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">到目前为止，我们已经手动调用了<strong class="jp ir"> allocateTile(at:) </strong>函数来生成一个3x3的网格，让我们自动执行这个操作，这样我们就可以快速地重新调整网格大小。我们来更新<strong class="jp ir">allocateinitiatiles()</strong>函数，增加<strong class="jp ir"> populateGridInBounds(…) </strong>函数。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swfit，populateGridInBounds(…)</figcaption></figure><p id="cdcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动我们的示例代码，我们现在有:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1a421f4d273a18d254810aa664dc610d.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*nAjlNtV4oLYrYO6H5WRUIw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">测试populateGridInBounds(…)</figcaption></figure><p id="4051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们尝试将每个方向的网格大小增加到50块。使用我们的新功能，这真的很简单:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mz"><img src="../Images/e80495901c20c72b47b4fddb03881b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgVvecdPoQKgza7BcdZQmw.png"/></div></div></figure><p id="6b8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果，正如所料，一个101 x 101的可滚动网格！</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7243683f2ce9286c62b2abc01a7d0844.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*6St2BE5l9x3sEl9cbPS6xw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">测试我们新的可滚动网格</figcaption></figure><h1 id="8954" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">完事了吗？</h1><p id="1419" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">不幸的是，远非如此。在本教程的开始，我提到这应该是内存有效的。让我们来看看我们刚刚创造的怪物:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8f88cf1de3ab60df33f0f6e6eed62431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*kb_MbCuoB6luYHiYXnkXgA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">101 x 101网格的内存消耗超过350MB</figcaption></figure><p id="d1ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">呀！我们现在为我们的简单网格使用了超过350MB的内存！？</p><p id="0a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，还记得我们作为子视图添加到GridTile中的UILabel()吗？这些UILabel中的每一个都会生成一个内存缓冲区来呈现将被发送到移动显示器的标签文本。我们刚刚分配了10，201个标签，每个标签使用10，000个像素的内存缓冲区。这个解决方案不能扩展到我们的“无限”网格。</p><h1 id="c986" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">观察scrollview内容偏移量</h1><p id="c5cc" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">为了开始解决内存需求问题，我们首先需要确定我们在网格中的位置，这样我们就可以确保只分配我们需要的网格块，并释放不再需要的网格块。</p><p id="c107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉键值观察并想学习，请访问苹果开发者档案:<a class="ae kl" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" rel="noopener ugc nofollow" target="_blank">https://Developer . Apple . com/library/archive/documentation/Cocoa/Conceptual/Key Value Observing/Key Value Observing . html</a></p><p id="7b5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用一些额外的代码更新我们的GridView.swift:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，观察scrollview内容偏移量</figcaption></figure><p id="9656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且再次更新<strong class="jp ir"> awakeFromNib() </strong>:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，final awakeFromNib()</figcaption></figure><p id="2f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，当GridView被实例化时，我们将GridView作为键值观察器添加到scrollview，请求在<strong class="jp ir"> contentOffset </strong>变量被更新时得到通知。由于每次拖动scrollview都会更新<strong class="jp ir"> contentOffset </strong>，因此将调用<strong class="jp ir">observe value(forkey path:…)</strong>函数，这样我们就可以更新网格。</p><p id="ca79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当前的<strong class="jp ir"> adjustGrid(for:) </strong>函数尚未更新网格；当拖动scrollview时，它当前跟踪在scrollview中心可见的坐标。坐标现在应该打印在控制台中:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/c2328564ed1301e8c2bc72fcb56a6e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6iFG3XYWIY6_E8ZVmS8Lg.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">控制台日志显示中心坐标更新</figcaption></figure><h1 id="5adf" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">动态网格扩展</h1><p id="60ef" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在我们可以检测中心坐标何时改变，让我们实现动态分配新的网格块。让我们首先用下面的代码替换<strong class="jp ir"> allocateTile(at:) </strong>函数:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，检查现有图块的新allocateTile(at:)函数</figcaption></figure><p id="8e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当请求分配图块时，代码将首先检查图块是否已经存在；如果有，那就没别的事可做了。更新<strong class="jp ir"> adjustGrid(for:) </strong>函数的时间:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，针对动态扩展更新了adjustGrid(for:)</figcaption></figure><p id="bf60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新后的<strong class="jp ir"> adjustGrid(for:) </strong>函数现在可以计算填充屏幕宽度和高度所需的图块数量，并自动请求在计算出的坐标内填充网格。既然我们现在可以动态地做到这一点，让我们也更新我们的<strong class="jp ir"> allocateInitialTiles() </strong>函数:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">使用adjustGrid(for:)函数的GridView.swift，final allocateInitialTiles()</figcaption></figure><p id="002f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看这个是什么样子的:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/cc7a1bb70903be740db12f3fff3eb81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*zrJSPr0FbzZtLeiFSX_kHA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">网格从空白开始，然后正确填充</figcaption></figure><p id="a4e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，网格在最初创建时似乎是空的，然后随着中心坐标的变化，网格会正确填充。代码中的一个快速调查显示，我们手动将中心坐标设置为(0，0)，因此当allocateInitialTiles()函数调用adjustGrid(for:)函数时，代码假定没有任何操作，因为中心坐标是相同的。我们只需要将中心坐标设置为某个非零值:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nd"><img src="../Images/6eb3e8962d61c0616d122a5726328b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwXXoJu5j_BFESiq9rMQBw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">将中心坐标的初始值更新为非零值</figcaption></figure><p id="b6da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再次运行代码…</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/3a21499f0a45610cf96453ff2541dfb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*TsbYjoY6WeGu0GLrIVuy4A.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">网格正确地动态填充</figcaption></figure><p id="e7ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功！我们的下一步是删除不需要的图块，否则当用户滚动无限网格时，我们的内存使用量会不断增加，直到iOS终止我们的应用程序。</p><h1 id="5c41" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">动态网格图块取消分配</h1><p id="63d7" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们将创建一个clearGridOutsideBounds(…)函数，它将与populateGridInBounds(…)函数成对运行。将以下代码添加到GridView.swift中:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，clearGridOutsideBounds(…)函数</figcaption></figure><p id="f9a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，让我们完成adjustGrid(for:)函数:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，最终adjustGrid(for:)函数</figcaption></figure><p id="9a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试我们的代码更改，我们可以看到网格被正确显示，我们的控制台日志显示动态分配和取消分配按要求发生:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ne"><img src="../Images/d331648573e72812dcac133d282ac4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJFYqiMUAK2EKMHebgZPBQ.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">带有动态分配/取消分配详细信息的控制台日志</figcaption></figure><p id="627f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过滚动一会儿并检查使用了多少内存来确认我们的内存需求得到了满足:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6a0da72f9e94855a33fa798aa630e689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*XRo1mxvStm5GFUpGGtkjBg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">动态分配时的内存需求</figcaption></figure><h1 id="b4b0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">让我们的网格变得无限</h1><p id="efa6" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">虽然我们的<strong class="jp ir"> abritraryLargeNumber </strong>很大，但它可能会诱惑我们认为我们已经完成了，但一个专注的用户最终将能够到达我们的滚动视图的末端。这可以通过将arbitraryLargeNumber设置为10000.0，然后滚动到滚动视图的顶部来轻松测试:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/61e002570909af8b015e9e0f22c9a275.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*SSp6z9N6Z_qrB93Dh52y6w.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">滚动视图到达顶部并弹跳</figcaption></figure><p id="d9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户到达滚动视图的顶部时，滚动视图反弹，我们的无限滚动视图只是一个非常大的有限滚动视图。</p><p id="7678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过添加一些scrollview委托方法来解决这个问题，仍然在GridView.swift中，但是在我们的GridView类定义之外，让我们添加:</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">网格视图。Swift，scrollview委托实施</figcaption></figure><p id="6a87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新我们的observeScrollview()</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">GridView.swift，最终observeScrollview()函数</figcaption></figure><p id="d45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终的结果是，每当scrollview不再活跃时，它就会被重置到中心位置。视觉上，唯一的变化是滚动视图指示器被重置为中间，灰色参考视图被重新定位在靠近中心的区域。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/fff2fd612f318884ec4ae38985e30241.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*p7aAPi-38bXmWBuH2GgATg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">最终无限网格实现</figcaption></figure><p id="e0c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要完成无限网格实现，应该隐藏scrollview指示器，并且应该将参考视图背景色设置为UIColor.clear。</p><h1 id="18c7" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">源代码</h1><p id="392e" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">这个项目的源代码托管在GitHub上:【https://github.com/freshcode/Infinite-Grid-Swift T2】</p><h1 id="dd4b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">关于作者</h1><p id="a364" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">戴夫·普瓦里耶是一名高级软件开发人员，目前正在<a class="ae kl" href="http://idfusion.com" rel="noopener ugc nofollow" target="_blank"> ID Fusion软件公司</a>开发一些非常有趣的iOS应用程序。</p><p id="d7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的移动应用软件开发需要帮助吗？请访问我们在http://idfusion.com的网站</p></div></div>    
</body>
</html>