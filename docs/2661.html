<html>
<head>
<title>[ReadingKoa] Day Two — Read and Understand Koa Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[阅读Koa]第二天—阅读并理解Koa核心</h1>
<blockquote>原文：<a href="https://itnext.io/readingkoa-day-two-read-and-understand-koa-core-a6afd24e012c?source=collection_archive---------4-----------------------#2019-07-06">https://itnext.io/readingkoa-day-two-read-and-understand-koa-core-a6afd24e012c?source=collection_archive---------4-----------------------#2019-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ed2c4e799b2bb9557b0ce77802eea08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-J2kHzhMp_L_w9abllpn6g.jpeg"/></div></div></figure><h1 id="21b3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="0926" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将阅读来自<strong class="ky ir"> Koa </strong>的结构和所有源代码——一个带有异步中间件的新web框架。如果你不知道Koa的中间件是如何工作的，你可以先看看这篇文章:</p><div class="lu lv gp gr lw lx"><a href="https://medium.com/@alickwong/how-koa-middleware-works-f4386b5573c" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">Koa中间件如何工作</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Koa中的中间件不同于Express，Koa使用洋葱模型。这个惊人的框架Koa只包含四个…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jw lx"/></div></div></a></div><p id="38f3" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们将涵盖Koa中的所有文件，其中仅包含四个文件(令人惊讶):</p><ul class=""><li id="a5c2" class="mr ms iq ky b kz mm ld mn lh mt ll mu lp mv lt mw mx my mz bi translated">应用程序. js</li><li id="8f72" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">上下文. js</li><li id="4810" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">请求. js</li><li id="b569" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">响应. js</li></ul><h1 id="0702" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">文件1:应用程序文件(application.js)</h1><p id="d0c4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是Koa的切入点。这是我们初始化koa服务器的方法:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="c76d" class="no jz iq nk b gy np nq l nr ns">const Koa = require('koa');<br/>const app = new Koa();<br/>app.listen(3000);</span></pre><p id="704d" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe nt nu nv nk b">new Koa()</code>实际实例化一个新的应用对象，这里是<code class="fe nt nu nv nk b">application.js</code>中的构造函数:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="a49e" class="no jz iq nk b gy np nq l nr ns">module.exports = class Application extends Emitter {<br/>  constructor() {<br/>    super();</span><span id="00f8" class="no jz iq nk b gy nw nq l nr ns">    this.proxy = false;<br/>    this.middleware = [];<br/>    this.subdomainOffset = 2;<br/>    this.env = process.env.NODE_ENV || 'development';<br/>    this.context = Object.create(context); // from File 2: context.js<br/>    this.request = Object.create(request); // from File 3: request.js<br/>    this.response = Object.create(response); // from File 4: response.js<br/>    if (util.inspect.custom) {<br/>      this[util.inspect.custom] = this.inspect;<br/>    }<br/>  }</span></pre><h2 id="0a59" class="no jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">关于发射器</h2><p id="0824" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe nt nu nv nk b">new Koa()</code>初始化一个<code class="fe nt nu nv nk b">Application</code>对象，该对象扩展了<code class="fe nt nu nv nk b">Emitter</code>。在扩展了<code class="fe nt nu nv nk b">Emitter</code>类之后，它将公开一个<code class="fe nt nu nv nk b">eventEmitterObject.on()</code>函数，该函数允许将一个或多个函数附加到由对象发出的命名事件上。这意味着我们可以像这样将事件附加到Koa:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="6713" class="no jz iq nk b gy np nq l nr ns">const app = new Koa();</span><span id="6c9a" class="no jz iq nk b gy nw nq l nr ns">app.on('event', (data) =&gt; {<br/>  console.log('an event occurred! ' + data); // an event occurred! 123<br/>});<br/>app.emit('event', 123);</span></pre><p id="11d5" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">当EventEmitter对象发出一个事件时，所有附加到该特定事件的函数都会被同步调用。被调用的侦听器返回的任何值都将被忽略并将被丢弃。</p><p id="64db" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><a class="ae oi" href="https://nodejs.org/api/events.html" rel="noopener ugc nofollow" target="_blank">事件| Node.js v12.4.0文档</a></p><h2 id="29b4" class="no jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">关于Object.create()</h2><p id="589d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们还可以在构造函数中看到<code class="fe nt nu nv nk b">Object.create()</code>，它只是创建了一个新的对象，使用一个现有的对象作为新创建对象的原型。以下是一些例子:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="7d63" class="no jz iq nk b gy np nq l nr ns">const person = {<br/>  isHuman: false,<br/>  printIntroduction: function () {<br/>    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);<br/>  }<br/>};</span><span id="2f46" class="no jz iq nk b gy nw nq l nr ns">const me = Object.create(person);</span><span id="6a72" class="no jz iq nk b gy nw nq l nr ns">me.name = "Matthew"; // "name" is a property set on "me", but not on "person"<br/>me.isHuman = true; // inherited properties can be overwritten</span><span id="9528" class="no jz iq nk b gy nw nq l nr ns">me.printIntroduction(); // "My name is Matthew. Am I human? true"</span></pre><p id="3efb" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><a class="ae oi" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank"> Object.create() </a></p><h2 id="a10f" class="no jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">启动服务器</h2><p id="f36e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">说完了<code class="fe nt nu nv nk b">new Koa()</code>，我们可以调查一下<code class="fe nt nu nv nk b">app.listen(300)</code>。如果我们使用<code class="fe nt nu nv nk b">app.listen(3000);</code>启动服务器，下面的代码将被执行:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="e244" class="no jz iq nk b gy np nq l nr ns">listen(...args) {<br/>  debug('listen');<br/>  // Step 1: call callback(), create a http server<br/>  const server = http.createServer(this.callback());<br/>  // Step 5: http server created, start listen to port<br/>  return server.listen(...args);<br/>}</span><span id="7e29" class="no jz iq nk b gy nw nq l nr ns">callback() {<br/>  // Step 2: prepare middlewares<br/>  const fn = compose(this.middleware);</span><span id="91a3" class="no jz iq nk b gy nw nq l nr ns">  if (!this.listenerCount('error')) this.on('error', this.onerror);</span><span id="b63f" class="no jz iq nk b gy nw nq l nr ns">  const handleRequest = (req, res) =&gt; {<br/>    // Step 3: createContext, we will talk more about this<br/>    const ctx = this.createContext(req, res);<br/>    // Step 4: handleRequest, we will talk more about this<br/>    return this.handleRequest(ctx, fn);<br/>  };</span><span id="ffd9" class="no jz iq nk b gy nw nq l nr ns">  return handleRequest;<br/>}</span></pre><p id="6208" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">如果您想知道如何在没有Koa的情况下启动http服务器，这里有一个我们直接使用http包创建服务器的正常方法:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="2351" class="no jz iq nk b gy np nq l nr ns">const http = require('http');<br/>http.createServer(function (req, res) {<br/>  res.writeHead(200, {'Content-Type': 'text/plain'});<br/>  res.write('Hello World!');<br/>  res.end();<br/>}).listen(8080);</span></pre><h2 id="019f" class="no jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">关于createContext(向代码添加了注释)</h2><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="3c2f" class="no jz iq nk b gy np nq l nr ns">createContext(req, res) {<br/>    // create new object by using this.context as <!-- -->prototype<br/>    <!-- -->const context = Object.create(this.context);<br/>    // create new object, make sure request and response object can be access inside context object<br/>    const request = context.request = Object.create(this.request);<br/>    const response = context.response = Object.create(this.response);<br/>    // make sure context, request, response, app object can access each other<br/>    context.app = request.app = response.app = this;<br/>    context.req = request.req = response.req = req;<br/>    context.res = request.res = response.res = res;<br/>    request.ctx = response.ctx = context;<br/>    // again make sure response object can be accessed inside request object<br/>    request.response = response;<br/>    response.request = request;<br/>    context.originalUrl = request.originalUrl = req.url;<br/>    context.state = {};<br/>    // return context object, this is the ctx object we can use in middleware<br/>    return context;<br/>  }</span></pre><h2 id="d10d" class="no jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">关于handleRequest(在代码中添加了注释)</h2><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="373c" class="no jz iq nk b gy np nq l nr ns">handleRequest(ctx, fnMiddleware) {<br/>    const res = ctx.res;<br/>    res.statusCode = 404;<br/>    const onerror = err =&gt; ctx.onerror(err);<br/>    // when all middleware have been finish, call respond()<br/>    const handleResponse = () =&gt; respond(ctx);<br/>    // if res from http package throw error, call onerror function<br/>    onFinished(res, onerror);<br/>    // middleware part have been covered in the last post, we dont discuss here<br/>    return fnMiddleware(ctx).then(handleResponse).catch(onerror);<br/>  }</span></pre><h2 id="b058" class="no jz iq bd ka nx ny dn ke nz oa dp ki lh ob oc km ll od oe kq lp of og ku oh bi translated">响应(在代码中添加了注释)</h2><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="53e8" class="no jz iq nk b gy np nq l nr ns">// Just attach ctx.body to res, not really special here<br/>function respond(ctx) {<br/>  if (false === ctx.respond) return;</span><span id="6b36" class="no jz iq nk b gy nw nq l nr ns">  if (!ctx.writable) return;</span><span id="393a" class="no jz iq nk b gy nw nq l nr ns">  const res = ctx.res;<br/>  let body = ctx.body;<br/>  const code = ctx.status;</span><span id="1047" class="no jz iq nk b gy nw nq l nr ns">  // ignore body<br/>  if (statuses.empty[code]) {<br/>    // strip headers<br/>    ctx.body = null;<br/>    return res.end();<br/>  }</span><span id="1c25" class="no jz iq nk b gy nw nq l nr ns">  if ('HEAD' == ctx.method) {<br/>    if (!res.headersSent &amp;&amp; isJSON(body)) {<br/>      ctx.length = Buffer.byteLength(JSON.stringify(body));<br/>    }<br/>    return res.end();<br/>  }</span><span id="d1fc" class="no jz iq nk b gy nw nq l nr ns">  // if body does not exist, return <br/>  if (null == body) {<br/>    if (ctx.req.httpVersionMajor &gt;= 2) {<br/>      body = String(code);<br/>    } else {<br/>      body = ctx.message || String(code);<br/>    }<br/>    if (!res.headersSent) {<br/>      ctx.type = 'text';<br/>      ctx.length = Buffer.byteLength(body);<br/>    }<br/>    return res.end(body);<br/>  }</span><span id="b169" class="no jz iq nk b gy nw nq l nr ns">  // If body is buffer, return body directly<br/>  if (Buffer.isBuffer(body)) return res.end(body);<br/>  if ('string' == typeof body) return res.end(body);<br/>  if (body instanceof Stream) return body.pipe(res);</span><span id="ea05" class="no jz iq nk b gy nw nq l nr ns">  // JSON encrypt the body<br/>  body = JSON.stringify(body);<br/>  if (!res.headersSent) {<br/>    ctx.length = Buffer.byteLength(body);<br/>  }<br/>  res.end(body);<br/>}</span></pre><h1 id="5683" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">文件2:上下文(context.js)</h1><p id="4e09" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个文件使用了一个名为delegate的包来导出context.js中的方法，我已经写了一篇文章来理解这个包是如何工作的:</p><div class="lu lv gp gr lw lx"><a href="https://medium.com/@alickwong/npm-package-study-delegates-6-million-weekly-download-a-single-js-file-package-6d53a2795d15" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">NPM软件包研究—代表(每周600万次下载，一个js文件包)</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">介绍</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="oj l mi mj mk mg ml jw lx"/></div></div></a></div><p id="cd34" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">下面是<code class="fe nt nu nv nk b">context.js</code>的底部:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="d972" class="no jz iq nk b gy np nq l nr ns">delegate(proto, 'response')<br/>  .method('attachment')<br/>  .method('redirect')<br/>.....</span><span id="0b43" class="no jz iq nk b gy nw nq l nr ns">delegate(proto, 'request')<br/>  .method('acceptsLanguages')<br/>  .method('acceptsEncodings')<br/>  .access('querystring')</span></pre><p id="42f7" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">这意味着当你访问<code class="fe nt nu nv nk b">ctx.querystring</code>时，它实际上是在访问<code class="fe nt nu nv nk b">ctx.request.querystring</code>，而<code class="fe nt nu nv nk b">ctx.request</code>是在<code class="fe nt nu nv nk b">createContext</code>被调用时分配的。</p><p id="22d0" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">所以这个<code class="fe nt nu nv nk b">delegate</code>主要是通过在中间件中使用<code class="fe nt nu nv nk b">ctx</code>让你轻松访问<code class="fe nt nu nv nk b">response</code>和<code class="fe nt nu nv nk b">request</code>里面的方法(因为所有的中间件都有<code class="fe nt nu nv nk b">ctx</code>作为输入)。这里有一个在<a class="ae oi" href="https://medium.com/@alickwong/how-koa-middleware-works-f4386b5573c" rel="noopener"> day one </a>帖子中提到的中间件的例子:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="69b4" class="no jz iq nk b gy np nq l nr ns">// Here is the ctx<br/>app.use(async (ctx, next) =&gt; {<br/>  console.log(3);<br/>  ctx.body = 'Hello World';<br/>  await next();<br/>  console.log(4);<br/>});</span></pre><h1 id="7f5f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">文件3:请求(request.js)</h1><p id="85a7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是<code class="fe nt nu nv nk b">ctx.request</code>的原型。这个文件主要让你访问来自<code class="fe nt nu nv nk b">this.req</code>的http请求的所有数据，比如头、ip、主机、url等....以下是一些例子:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="5373" class="no jz iq nk b gy np nq l nr ns">get(field) {<br/>    const req = this.req;<br/>    switch (field = field.toLowerCase()) {<br/>      case 'referer':<br/>      case 'referrer':<br/>        return req.headers.referrer || req.headers.referer || '';<br/>      default:<br/>        return req.headers[field] || '';<br/>    }<br/>  },</span></pre><h1 id="507b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">文件4:响应(response.js)</h1><p id="dafd" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是<code class="fe nt nu nv nk b">ctx.response</code>的原型。这个文件主要让你访问<code class="fe nt nu nv nk b">this.res</code>中的数据，比如响应头和体，下面是部分源代码:</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="48e3" class="no jz iq nk b gy np nq l nr ns">set(field, val) {<br/>    if (this.headerSent) return;</span><span id="ad78" class="no jz iq nk b gy nw nq l nr ns">    if (2 == arguments.length) {<br/>      if (Array.isArray(val)) val = val.map(v =&gt; typeof v === 'string' ? v : String(v));<br/>      else if (typeof val !== 'string') val = String(val);<br/>      this.res.setHeader(field, val);<br/>    } else {<br/>      for (const key in field) {<br/>        this.set(key, field[key]);<br/>      }<br/>    }<br/>  },</span></pre><h1 id="7e30" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">顺便说一下</h1><p id="6bbc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢阅读！如果这篇文章可以帮助你理解Koa，请给我一些掌声=]这对我是一个很大的支持。</p><h1 id="a778" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><p id="cbe9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae oi" href="https://koajs.com/#introduction" rel="noopener ugc nofollow" target="_blank">Koa—node . js的下一代web框架</a></p></div></div>    
</body>
</html>