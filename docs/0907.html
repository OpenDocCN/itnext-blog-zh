<html>
<head>
<title>Building RESTful Web APIS with Dart, Aqueduct, and PostgreSQL–Bonus content</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dart、Aqueduct和PostgreSQL构建RESTful Web APIS额外内容</h1>
<blockquote>原文：<a href="https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-bonus-content-2fc086b7259a?source=collection_archive---------4-----------------------#2018-06-15">https://itnext.io/building-restful-web-apis-with-dart-aqueduct-and-postgresql-bonus-content-2fc086b7259a?source=collection_archive---------4-----------------------#2018-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2a047f3e8efc0eabde1b4406baa0b19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CH0HOcrcL4aM-KM-iUjVYw.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="ce4c" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">请注意:从Dart 2开始，导水管的API发生了变化，导致了突破性的变化。本文基于Dart v1的Aqueduct 2.5.0。</em> </strong></p><p id="ee8d" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh jc"> <em class="ld">我把这个更新为新的视频系列:</em></strong><a class="ae le" href="http://bit.ly/aqueduct-tutorial" rel="noopener ugc nofollow" target="_blank"><strong class="kh jc"><em class="ld">http://bit.ly/aqueduct-tutorial</em></strong></a></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="9554" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">从我们离开的地方继续，我们现在已经为我们的工作API编写了一些测试，搭建了我们的项目，设置了一些路线并集成了一个关系数据库。</p><p id="e489" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本文是系列文章的一部分，涵盖:</p><ul class=""><li id="7fd4" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-3cc9b931f777"> <strong class="kh jc">第1部分:设置并运行示例</strong> </a></li><li id="0e57" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-2-routing-with-crud-operations-629fe58114fa"> <strong class="kh jc">第二部分:用CRUD操作实现路由</strong> </a></li><li id="1742" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-3-postgres-90ff70742675"> <strong class="kh jc">第3部分:将Web APIs连接到PostgreSQL数据库</strong> </a></li><li id="c038" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-dart-aqueduct-and-postgresql-part-4-testing-de3618515639"> <strong class="kh jc">第4部分:编写自动化测试</strong> </a></li><li id="8e76" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc lk ll lm ln bi translated"><strong class="kh jc">*奖励内容* </strong> DB迁移和模型关系<em class="ld">(我们在这里</em>😄<em class="ld"> ) </em></li></ul><p id="95c1" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在这个额外的部分中，我们将介绍Aqueduct的数据库迁移工具，以及在对我们当前的应用程序模型进行修改时，它是如何提供帮助的。到目前为止，我们只使用了<code class="fe lt lu lv lw b">Book</code>模型，这是为了简化事情。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="2271" class="lx ly jb bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">1.创建迁移文件</h1><p id="d4db" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">Aqueduct的迁移工具对于创建和执行迁移文件非常有用。这些文件包含基于当前应用程序模型创建和修改数据库表的SQL命令。</p><p id="58a2" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在我们项目的根目录中，让我们通过运行下面的命令来生成我们的迁移文件:</p><pre class="na nb nc nd gt ne lw nf ng aw nh bi"><span id="1d7f" class="ni ly jb lw b gy nj nk l nl nm">aqueduct db generate</span></pre><p id="3493" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这将在<code class="fe lt lu lv lw b">migrations/00000001_Initial.migration.dart</code>创建一个迁移文件。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/4e3ab0450f6acc9acb62df26ff895233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGYNdCjX37oks9ZPksoR6g.png"/></div></div></figure><p id="e318" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">打开该文件详细描述了基于<code class="fe lt lu lv lw b">lib/model</code>中的模型定义构建数据库表的步骤，在本例中是<code class="fe lt lu lv lw b">book.dart</code>。</p><h1 id="f21b" class="lx ly jb bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">2.创建作者模型</h1><p id="8775" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">我们当前的<code class="fe lt lu lv lw b">Book</code>模型的作者被设置为类型为<code class="fe lt lu lv lw b">String</code>的实例属性，它转化为数据库中的<strong class="kh jc"> _book </strong>表中的一列。</p><p id="510f" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在这种简单的情况下是可行的，但是如果我们需要指定多个作者呢？当然，我们可以使用逗号作为分隔符，在处理每个作者时将它们分开，但是如果我们希望每个作者都有一个简短的描述呢？将所有信息存储在一个数据库列中当然不是什么好事！</p><p id="1074" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">理想情况下，我们希望捕获这个<code class="fe lt lu lv lw b">author</code>属性作为它自己的实体，这样我们就可以随着应用程序的增长来分离这个问题。</p><p id="4c9e" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们用我们的<code class="fe lt lu lv lw b">Author</code>模型创建<code class="fe lt lu lv lw b">lib/model/author.dart</code>:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d54f" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这类似于<code class="fe lt lu lv lw b">lib/model/book.dart</code>，除了我们现在已经建立了一个一对多的关系，一本书有许多作者。我们有一个<code class="fe lt lu lv lw b">book</code>属性，并使用<code class="fe lt lu lv lw b">@ManagedRelationship()</code>注释来设置这种关系。</p><p id="56de" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">第一个参数(#authors)是一个符号，表示我们的<code class="fe lt lu lv lw b">Book</code>模型上的属性，它标记了这种关系。让我们修改我们的<code class="fe lt lu lv lw b">Book</code>模型，使其具有这个属性:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="15cc" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们的<code class="fe lt lu lv lw b">authors</code>属性是一个<code class="fe lt lu lv lw b">ManagedSet&lt;T&gt;</code>类型，意味着包含一组作者的书。这意味着当我们运行我们的应用程序时，将创建一个名为<strong class="kh jc"> author </strong>的新表，其中包含列<code class="fe lt lu lv lw b">id</code>、<code class="fe lt lu lv lw b">name</code>和<code class="fe lt lu lv lw b">book_id</code>。后者是一个外键，指向<strong class="kh jc"> _book </strong>表上的相关行id。</p><p id="2945" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">让我们通过运行<code class="fe lt lu lv lw b">aqueduct db generate</code>来更新我们的迁移目录。这将在先前的文件旁边生成另一个<code class="fe lt lu lv lw b">migration/*.migration.dart</code>文件。它在初始迁移文件的基础上添加了SQL命令，用于:</p><ol class=""><li id="97a5" class="lf lg jb kh b ki kj km kn kq lh ku li ky lj lc nv ll lm ln bi translated">建天华<strong class="kh jc">_作者</strong>表</li><li id="bb40" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc nv ll lm ln bi translated">删除我们的<strong class="kh jc">book</strong>表中的<code class="fe lt lu lv lw b">_author</code>列</li><li id="f745" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc nv ll lm ln bi translated">在作者表中添加一个<code class="fe lt lu lv lw b">book_id</code>列</li></ol><p id="a85a" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了应用这些更改，在项目根中创建一个<code class="fe lt lu lv lw b">database.yaml</code>文件，详细信息如下:</p><pre class="na nb nc nd gt ne lw nf ng aw nh bi"><span id="9a1d" class="ni ly jb lw b gy nj nk l nl nm"><strong class="lw jc">username</strong>: "dartuser"<br/><strong class="lw jc">password</strong>: "dbpass123"<br/><strong class="lw jc">host</strong>: "localhost"<br/><strong class="lw jc">port</strong>: 5432<br/><strong class="lw jc">databaseName</strong>: "fave_reads"</span></pre><p id="8302" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">然后运行下面的命令将数据库升级到更新的模式:</p><pre class="na nb nc nd gt ne lw nf ng aw nh bi"><span id="4cc9" class="ni ly jb lw b gy nj nk l nl nm">aqueduct db upgrade</span></pre><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/7ac8c040ec4454763173358f9f5de4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_PeaYSP9ybBUzgY3It-Zw.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">数据库升级示例</figcaption></figure><p id="d3ba" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><em class="ld">这假设您要迁移到的数据库中没有任何预先存在的表，即</em> <strong class="kh jc"> <em class="ld"> _book </em> </strong> <em class="ld">和</em><strong class="kh jc"><em class="ld">_ author</em></strong><em class="ld">表不存在，否则将抛出异常。</em></p><h1 id="3f87" class="lx ly jb bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">3.修改测试</h1><p id="4093" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">我们的测试设置需要修改，以包含我们管理的作者集:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="775b" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在随后的循环中，我们创建两个查询来插入书籍和作者，两个查询是因为模型数据放在不同的表中:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="10c2" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这允许我们修改我们的第一个单元测试的断言:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3d2a" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">测试的全部变化是<a class="ae le" href="https://github.com/graphicbeacon/favereads/blob/master/test/books_controller_test.dart" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><h1 id="e174" class="lx ly jb bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">4.让测试通过</h1><p id="fb78" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">在<code class="fe lt lu lv lw b">lib/controller/books_controller.dart</code>中，将<code class="fe lt lu lv lw b">getAllBooks()</code>方法修改如下:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9570" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里，我们使用<code class="fe lt lu lv lw b">join</code>方法从与每本书相关的_ <strong class="kh jc">作者</strong>表中提取行数据。</p><p id="3223" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">向<code class="fe lt lu lv lw b">http://localhost:8000/books</code>发送GET请求将返回下面的JSON响应:</p><pre class="na nb nc nd gt ne lw nf ng aw nh bi"><span id="7d71" class="ni ly jb lw b gy nj nk l nl nm">{<br/>  "<strong class="lw jc">id</strong>": 1,<br/>  "<strong class="lw jc">title</strong>": "Dart: Scalable Application Development",<br/>  "<strong class="lw jc">year</strong>": 2016,<br/>  "<strong class="lw jc">authors</strong>": [{<br/>    "id": 1,<br/>    "<strong class="lw jc">name</strong>": "Dave Mitchells"<br/>    "book": {<br/>      "id": 1<br/>    }<br/>  }]<br/>}</span></pre><p id="ab03" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们的<code class="fe lt lu lv lw b">addBook()</code>抢答器方法现修改如下:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cdf6" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这需要以下格式的有效负载:</p><pre class="na nb nc nd gt ne lw nf ng aw nh bi"><span id="25ac" class="ni ly jb lw b gy nj nk l nl nm">{<br/>  "<strong class="lw jc">title</strong>": "Dart: Scalable Application Development",<br/>  "<strong class="lw jc">year</strong>": 2016,<br/>  "<strong class="lw jc">authors</strong>": [{<br/>    "name": "Dave Mitchells"<br/>  }]<br/>}</span></pre><p id="ff2f" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这里的可以看到全部的变化<a class="ae le" href="https://github.com/graphicbeacon/favereads/blob/master/lib/controller/books_controller.dart" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="784b" class="lx ly jb bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">结论</h1><p id="40b8" class="pw-post-body-paragraph kf kg jb kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc ij bi translated">查看下面的进一步阅读材料，更详细地了解数据库迁移和模型关系。一如既往，欢迎反馈。让我知道你喜欢什么，不喜欢什么，接下来你想看什么。</p><p id="6084" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这个系列到此结束。源代码是github 上的<a class="ae le" href="https://github.com/graphicbeacon/favereads" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="85a5" class="pw-post-body-paragraph kf kg jb kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">感谢您坚持阅读本系列，并关注我的更多Dart和Aqueduct教程。</p><h1 id="c005" class="lx ly jb bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">进一步阅读</h1><ol class=""><li id="27e2" class="lf lg jb kh b ki mv km mw kq ob ku oc ky od lc nv ll lm ln bi translated"><a class="ae le" href="http://aqueduct.io/docs/db/db_tools" rel="noopener ugc nofollow" target="_blank">数据库迁移和工具</a></li><li id="bded" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc nv ll lm ln bi translated"><a class="ae le" href="http://aqueduct.io/docs/db/modeling_data" rel="noopener ugc nofollow" target="_blank">建模数据</a></li><li id="0a98" class="lf lg jb kh b ki lo km lp kq lq ku lr ky ls lc nv ll lm ln bi translated"><a class="ae le" href="http://aqueduct.io/docs/tut/model-relationships-and-joins/#more-on-joins-and-relationships" rel="noopener ugc nofollow" target="_blank">高级数据库查询</a></li></ol></div></div>    
</body>
</html>