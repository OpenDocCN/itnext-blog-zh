<html>
<head>
<title>All About B Trees and Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于B树和数据库的一切</h1>
<blockquote>原文：<a href="https://itnext.io/all-about-b-trees-and-databases-8c0697856189?source=collection_archive---------0-----------------------#2021-09-17">https://itnext.io/all-about-b-trees-and-databases-8c0697856189?source=collection_archive---------0-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1cec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">B树如何增强您的数据库处理数据密集型工作负载的能力。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/770240c22e3db27ef27267c18b14afba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f_PKRubW6rQGb9LF"/></div></div></figure><p id="c9f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近一直在看<a class="ae ln" href="https://www.goodreads.com/book/show/44647144-database-internals" rel="noopener ugc nofollow" target="_blank"> <em class="lo">数据库内部</em> </a> (Alex Petrov，2019)。这是一本关于数据库<em class="lo">存储引擎</em>实现的优秀书籍，存储引擎是数据库的组成部分，以高效可靠的方式从磁盘中存储和检索数据。这本书的一个重要部分讨论了各种B树数据结构的实现和优化。</p><p id="ba33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">b树是数据库使用的最主要的数据结构。最著名的例子是Postgres、Mysql和Oracle数据库。在深入研究B树之前，我们应该首先关注二分搜索法树。</p><h1 id="e265" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">二叉树</h1><p id="f593" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">二叉树是一种用于以有序方式存储数据的数据结构。树中的每个节点都由一个键、一个与该键相关联的值和两个指向子节点的指针(因此命名为binary)来标识。规则是左侧子节点必须小于其直接父节点，右侧子节点必须大于其直接父节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/6529ba4d06592751e019b5d9ab72cf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*8i77nF2bOdnGDT9LwcZ3Eg.png"/></div></figure><p id="2dd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样，通过查看每个节点的值和相应的下降，我们可以很容易地找到元素。如果搜索到的值小于当前值，则下降到左边的子节点；如果更大，就下降到右边。</p><h1 id="3173" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">调整资金组合</h1><p id="a735" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">当插入一个新元素时，我们需要找到正确的位置，并在那里插入一个新的节点。这可能会导致树失去平衡。在最坏的情况下，它可能看起来像右边的情况，类似于链表而不是树。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mn"><img src="../Images/4e554d84a031cf4d9b6d4f3197880311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sU_hsOdtsrtbQHIOo-scAg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">二叉树理想和最坏情况</figcaption></figure><p id="b47e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在理想情况下，通过避免检查未选择的路径，跟随右侧或左侧节点平均将搜索复杂度降低一半。当有一个不平衡的树时，需要遍历更多的节点，这大大降低了搜索的速度。</p><p id="f4ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从数学上讲，当寻找一个元素时，它在树形式上的复杂度为O(log₂ N ),在链表形式上的复杂度为O(N)。树越浅，搜索就越快。</p><p id="7eab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">树将被重新平衡，而不是在一个树枝上添加新元素并使其变长，而另一个树枝保持空白。如下所示，这是通过旋转节点来实现的，向左或向右。较小的项目在左边，较大的项目在右边的规则被保留，但是高度变小，使得搜索更快。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/f1511508e3722accc4432d37c9f0ae84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRgLxzLlKzTOqJf8uDQX2Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">树旋转</figcaption></figure><h1 id="3212" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">磁盘限制</h1><p id="36bb" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">存储引擎必须将树提交到磁盘，以使数据库系统能够承受崩溃和断电。</p><p id="8699" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数据以页帧的形式存储在磁盘上。数据连续存放在磁盘上，大小通常为4kb(由底层CPU架构定义)。这是可以以编程方式写入或读取的最小数据量。</p><p id="35fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">平衡搜索树不适合在磁盘上维护:</p><ul class=""><li id="dcaf" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated">一个原因是地点。元素是按随机顺序输入的，因此不能保证节点彼此靠近，并且可能分布在不同的页面上，从而导致过多的磁盘访问。</li><li id="5df6" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">第二个原因是树高。由于二叉树节点只有2个子节点，树的高度增长相对较快。对于每一级，我们必须比较并下降到下面的节点，依次是额外的磁盘访问。</li></ul><p id="148a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">磁盘访问是昂贵的，所以当设计驻留在磁盘上的数据结构时，它们必须保持最小。</p><h1 id="e3d5" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">b树</h1><p id="ebbe" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">b树是一种自平衡的树数据结构，它维护排序的数据并允许搜索，但它推广了二叉查找树，允许节点有两个以上的子节点。</p><p id="5b92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更正式地说，每个节点都有介于<em class="lo"> k </em>到<em class="lo"> 2k </em>之间的键-值对和<em class="lo"> k+1 </em>到2 <em class="lo"> k+1 </em>的子指针，除了根节点之外，它只有少至<em class="lo"> 2 </em>的子指针，即使当<em class="lo"> k </em>是一个大数字时也是如此。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/31bed276c7c2ebe74c042fd29af72b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUs-6D8xFh7_PxvCgZd3rg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">b树</figcaption></figure><p id="f5d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过解决前面的两个问题，b树适用于存储系统。</p><ul class=""><li id="3064" class="mt mu iq kt b ku kv kx ky la mv le mw li mx lm my mz na nb bi translated">每个节点的大小相当于一个磁盘页面。键、值和指针的总大小匹配4kb。由于键和值在同一个磁盘页上彼此相邻，所以局部性增加了，因此需要更少的磁盘访问。</li><li id="40c8" class="mt mu iq kt b ku nc kx nd la ne le nf li ng lm my mz na nb bi translated">由于每个节点中有更多的子节点，树的高度变得更小(也称为更高的扇出)。</li></ul><h1 id="d7ee" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">搜索、插入和删除</h1><h2 id="9c9a" class="ni lq iq bd lr nj nk dn lv nl nm dp lz la nn no mb le np nq md li nr ns mf nt bi translated">搜索</h2><p id="cb6a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">使用二分搜索法来搜索B树。该算法从根节点开始，遍历所有键，直到找到第一个大于搜索值的键。然后，我们使用相应的子指针下降到相关的子树，并重复这个过程，直到找到值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c65d55439d6032ef9c6a64a9b2420820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AkLNXyS7VlIPe6OO.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">b树节点</figcaption></figure><p id="f110" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">范围扫描也是可能的，方法是找到扫描的起始键，然后跟踪兄弟指针，直到找到最后一个节点。这不是最佳选择，因为值分布在许多节点上。更好的方法是使用B+树，它是B-树的一种改进。</p><h2 id="01d2" class="ni lq iq bd lr nj nk dn lv nl nm dp lz la nn no mb le np nq md li nr ns mf nt bi translated">插入</h2><p id="2664" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">插入是通过执行搜索并在正确的索引处插入值来完成的。如果节点有太多的值，插入可能会导致树失去平衡(<em class="lo"> n </em> &gt; <em class="lo"> 2k </em>)。</p><p id="5f8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，将使用节点分割来平衡树。拆分是通过分配一个新的节点，将一半的键-值对转移到那里，并将它的第一个键和指向该节点的指针添加到父节点来完成的。如果它是一个非叶节点，那么拆分点之后的所有子指针也将被移动。</p><p id="a4ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个键和相应的指针被移动到父项，从而增加了它的占用率。这可能会再次导致溢出，因此必须沿着树向上递归重复重新平衡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/fb3cd612dc7863b47134022217162544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98vwm5DH80XqM3nyYL9ROA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">b树分裂</figcaption></figure><h2 id="f08a" class="ni lq iq bd lr nj nk dn lv nl nm dp lz la nn no mb le np nq md li nr ns mf nt bi translated">删除</h2><p id="b981" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">删除时，定位目标节点和删除索引。移除后，一个节点会因为值太少而失去平衡(<em class="lo"> n </em> &lt; <em class="lo"> k </em>)。可以通过合并节点或旋转来解决。</p><p id="428b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以向右或向左旋转，这取决于哪个节点有备用项目。例如，右旋转是通过将分隔符从父节点复制到下溢节点的开始，并用其左兄弟节点的最后一个元素替换分隔符来完成的。当旋转非叶节点时，左兄弟的最后一个子指针被移动到不平衡节点的开始。当执行向左旋转时，采用类似的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/043451328e9e488d4eeee438bc0ef874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTygG8hA8eAWHLQK4pgZUQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">b树旋转</figcaption></figure><p id="f5b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果没有兄弟节点可以腾出一个元素(有<em class="lo"> k </em>个元素)，那么有缺陷的节点必须与一个兄弟节点合并。合并会导致父级丢失分隔符元素，因此父级可能会变得不足，需要重新平衡。再平衡可能会一直持续到根本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/bbb8f7efc1d54b33aea56c26604e67a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gf3eRF6MlbEpHSPbG_mw6g.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">b树合并</figcaption></figure><h1 id="7862" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">摘要</h1><p id="8326" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">这篇文章介绍了数据结构应该如何适应磁盘存储。我们首先解释了二叉树，以及它们为什么由于子树少和位置低而不适合磁盘。另一方面，B-tree通过在每个节点中有更多的项，在磁盘上使键和值更近，树更浅来解决它。</p><p id="a910" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们讲述了如何实现查找、插入和删除操作，并在它们失去平衡时使用拆分、合并和重新平衡来重新平衡它们，从而将树深度保持在最小。</p><p id="8fe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">亚历克斯·彼得罗夫和他的书<strong class="kt ir">数据库内幕</strong>功不可没。图片和我大部分关于B树的知识都来自他的书。</p><p id="b104" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个帖子的灵感来自于我用Go写的内存B树实现。可以去看看<a class="ae ln" href="https://github.com/amit-davidson/btree" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div></div>    
</body>
</html>