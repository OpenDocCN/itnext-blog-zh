<html>
<head>
<title>Lossless Backpressure in RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS中的无损背压</h1>
<blockquote>原文：<a href="https://itnext.io/lossless-backpressure-in-rxjs-b6de30a1b6d4?source=collection_archive---------1-----------------------#2018-12-15">https://itnext.io/lossless-backpressure-in-rxjs-b6de30a1b6d4?source=collection_archive---------1-----------------------#2018-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/26317545ebe3f1a2f3a60e5869b890cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*etwyYu1X9R9Y4F_5"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@kees_streefkerk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kees Streefkerk </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><div class=""><h2 id="660b" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">将Node.js流转换为RxJS管道</h2></div><p id="26de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">TL；dr </strong>我想出了一个无损的方法，用RxJS处理异步迭代器、生成器和Node.js流中的反压力。</p><p id="4095" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">这篇文章是我帮助那些无法利用一套技能应对各种情况(如RxJS和背压)的人的方式。RxJS是一个非常棒的流库，您不应该在它的基础上学习迭代器、生成器和Node.js流，特别是如果您已经精通了最伟大的流库之一。我的目标是让RxJS开发人员最终将这个功能添加到RxJS中，就像他们添加WebSocketSubject一样。</em></p><h1 id="b3a6" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">什么是背压？</h1><p id="8737" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当你的消费者比你的生产者慢时，反压力就产生了。</p><p id="b281" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">背压的几个例子是鼠标移动事件、窗口大小调整事件和解析文件。所有这些都可能导致发生比您的用户能够处理的事件更多的事件，或者在读取文件的情况下，对您的机器来说有太多的内存来处理。</p><p id="793e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要处理这些问题，您可以使用有损或无损方法。有损方法包括采样、节流和去抖动。而无损方法包括缓冲和暂停。</p><p id="ac88" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无损背压在读取文件时非常重要；例如，因为您不希望在处理文件时丢失文件的某些部分。另一方面，像鼠标移动这样的事件可能会有损失，因为您的监视器一秒钟只能更新这么多次，而鼠标移动事件发出的频率要高得多。</p><h1 id="caa4" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">IxJS与RxJS</h1><p id="04eb" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">RxJS是一个推送库，生产者向消费者抛出数据。在同一伞下还有另一个名为IxJS的库。很长一段时间，我都不明白为什么有两个独立的库做着本质上相同的事情，直到我意识到IxJS是一个拉库，旨在支持同步和异步迭代器。尽管RxJS支持通过<code class="fe mp mq mr ms b">from</code> observable的迭代器，但它并没有赋予您处理背压的能力。</p><p id="e5bc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理解拉数据和推数据之间的区别很重要，因为这会改变您处理背压的方式。</p><p id="cbab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从管道的角度来看，迭代器和观察器本质上是一样的，但是当你开始考虑为什么你需要其中一个的时候，你对库的选择就开始起作用了。</p><p id="f4a4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为你不需要IxJS，但是两者都有它们的位置。虽然拥有一个类似于RxJS的完整迭代器库对于特定的工作流来说是非常好的，但是在RxJS中拥有控制迭代器的能力可能会更好。我创建了许多web应用程序，我发现只引入RxJS(正常用例)比同时引入RxJS和IxJS更能节省库空间。在单个库上训练一个开发团队也比在一堆不同的库中容易得多。</p><h1 id="56c8" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">问题是</h1><p id="bfc2" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">迭代器要求您在准备处理下一组数据时通过请求获取数据来获取数据。这样做的好处是可以显著减少内存占用，因为在处理完上一个值之后，您只需要获取下一个值。如果您通过<code class="fe mp mq mr ms b">pipe</code>方法而不是使用事件处理程序来创建转换，那么您也可以访问Node.js流中的类似机制。</p><p id="c527" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，迭代器和Node.js流有能力处理无损背压，但是RxJS没有(不像IxJS ),而且最重要的是，RxJS不能开箱即用地处理Node.js流。</p><p id="6eb0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，可测量和可观察之间有很多相似之处。例如，iterables实现迭代器，而observables实现观察者。两者都是生产者，但是迭代器等待消费者请求下一个值，而观察者一旦得到下一个值就给消费者。它们是一样的，但是颠倒了。</p><p id="6173" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为可观察对象是单向数据流，所以没有办法回调可观察对象并告诉它像可迭代对象那样处理更多数据。如果我们能够利用观察器，那么我们就能够使用两次推送来模拟IxJS拉库。已经有一个专门为此目的设计的工具:subject。</p><p id="388e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像生成器是可迭代对象的更高级版本一样，主体是更高级的可观察对象。生成器允许你控制迭代器，而主语允许你控制观察者。正如主体既是观察者又是可观察对象，生成器既是迭代器又是可迭代的。这是我们向RxJS添加拉取功能的关键。</p><h1 id="ecd9" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">RxJS中的迭代器支持被破坏</h1><p id="2ab6" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">RxJS本身支持迭代器，但是实现被破坏了，因为它没有考虑背压:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4d37" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我在生成器的管道中放置了1秒钟的延迟。我们可以假设这个延迟是一个AJAX调用。</p><p id="0167" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于RxJS处理迭代器的方式，我们看到一堆传入的值被循环遍历并推入流中，即使流的速度跟不上。如果我们有一个非常大的集合，当我们的管道努力处理所有的值时，它将全部被加载到内存中。</p><p id="6143" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们假设这是一个高级生成器，它需要AJAX调用的返回值，然后才能继续下一个产出。如果是这种情况，就没有办法把一个值返回给生成器；相信我，我试过了。</p><h1 id="ef27" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">这个想法</h1><p id="9cf9" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">真正让RxJS与生成器一起工作的唯一方法是使用subjects。这是最接近的转换。这给了你传入参数的能力，当你准备好接受另一个值时告诉它。</p><p id="fd5d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要的是一种利用迭代器等待获取下一个值的能力的方法，直到你提出请求。</p><p id="9384" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我为生成器创建了一个包装函数，将它们转换成主题。下面是一个更简单的例子:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bf46" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关键是等待，直到我们在我们的订户中点击<code class="fe mp mq mr ms b">next</code>。此时，我们可以向迭代器请求另一个值。所以我们不会遇到内存泄漏，迭代器有一个<code class="fe mp mq mr ms b">done</code>属性，表示我们应该<code class="fe mp mq mr ms b">complete</code>我们的可观察对象。</p><p id="6f52" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个例子不是灵丹妙药。它没有解决将值传递回生成器的问题，但这是一个快速解决方法。因为生成器上的第一个<code class="fe mp mq mr ms b">next</code>调用不能传递值，所以我们可以在不传递值的情况下调用它。这个例子也有问题，因为它没有处理生成器可以输出单个值并立即结束的情况。</p><h1 id="c044" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">迭代器背压的正确处理</h1><p id="e2db" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">根据最初的想法，我们可以把它推广到一个函数中:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1529" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当您在<code class="fe mp mq mr ms b">iterator$</code>上调用我们的自定义<code class="fe mp mq mr ms b">push</code>方法时，它会将该值传递给生成器，生成器会返回一个新值。然后，新值通过流传递。如果你使用过<code class="fe mp mq mr ms b">WebSocketSubject</code>，这是相同类型的实现，除了我没有重载<code class="fe mp mq mr ms b">next</code>方法。</p><p id="4fce" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一次将数据放入生成器，另一次将值放入流。这就是为什么一个拉力可以通过两个推力来满足，让一个主体可以模仿一个发电机，但是有更多的功能。</p><p id="adaa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们对照我们最初的可观察管道来试试<code class="fe mp mq mr ms b">createIteratorSubject</code>:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="27e9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以处理背压。迭代器只在我们需要时计算下一个值。除了使用<code class="fe mp mq mr ms b">subscribe</code>方法，还可以使用<code class="fe mp mq mr ms b">tap</code>获得相同的结果。</p><h1 id="fcfd" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">Node.js流转换</h1><p id="435f" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Node.js有自己的流处理器，RxJS不支持。有几个库可以增加兼容性，但我认为它们没有抓住要点。它们也不能处理背压的情况，这也是我使用Node.js流的原因。</p><p id="8b8c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看如何创建一个简单的转换流，它将小说中的每个字母都大写，然后输出到一个新文件中:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1fbc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您曾经做过大量的Node.js开发，那么您会遇到很多这种类型的代码。每个<code class="fe mp mq mr ms b">pipe</code>函数只能接受一个流。最常见的是转换流，如果您曾经使用过Gulp，那么有一大堆转换流可以满足您的任何需求。</p><p id="938f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不过，我非常了解RxJS，但是我不知道我是如何开始做我在Node.js转换流中习惯的许多疯狂的事情的。老实说，我花了令人尴尬的长时间才弄清楚如何编写一个定制的转换流，甚至首先弄清楚Node.js流是如何工作的。我记得就在3年前我还在使用Gulp，即使在那时，做任何定制的东西都不是直觉。</p><p id="cfcf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我创建了自己的RxJS实现，类似于迭代器示例，而不是必须学习一种完全不同的流方法——无论如何，我都必须学习这种方法来撰写本文。</p><h1 id="06ef" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">RxJS控制Node.js流</h1><p id="1029" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在向您展示实现之前，我想先看一下用法，因为它有一些不同之处:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="52a0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们像以前一样将<code class="fe mp mq mr ms b">transformStream$.next</code>传递给订户的<code class="fe mp mq mr ms b">next</code>道具。这使得我们只有在处理完这个块之后才能得到另一个块，但是在处理转换流时还有更多。</p><p id="4fc6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想将该值传递给下一个Node.js流(我们的写流),我们还需要调用<code class="fe mp mq mr ms b">transformStream$.push</code>。在这种情况下，任何时候我们想向文件中写入一段文本，我们都会调用<code class="fe mp mq mr ms b">transformStream$.push</code>，然后使用<code class="fe mp mq mr ms b">transformStream$.next</code>来请求下一个值，因为我们已经完成了处理。</p><p id="6ffb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多原因使您希望将这些分成两种不同的方法，但这超出了本文的范围。</p><p id="4540" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的目标是，当我们处理完最后一个块时，我们只接受一个传入的块，这就是我们所看到的。很漂亮吧？我们所有的转换流现在可以合并到一个单一的RxJS可观察管道中，而不是一堆非常复杂的<code class="fe mp mq mr ms b">pipe</code>方法。</p><p id="143f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你需要在你的管道末端有一个写流，这样它才能完成处理，所以我试着在<code class="fe mp mq mr ms b">transformStream$</code>中调用<code class="fe mp mq mr ms b">writeStream.write(value)</code>和<code class="fe mp mq mr ms b">writeStream.end()</code>，但是我不能让它工作，因为它实际上会写超过几兆字节的数据，也不会结束流。正因为如此，我在<code class="fe mp mq mr ms b">transformStream$.stream</code>上公开了原始的Node.js流。您可以创建自己的写流，但是对于这个例子，我将写回另一个文件，因为这是一个正常的用例。</p><p id="37f4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们看一下实现:</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ddf0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次在我们的<code class="fe mp mq mr ms b">transformStream</code>对象中调用<code class="fe mp mq mr ms b">transform</code>时，它给我们调用<code class="fe mp mq mr ms b">callback</code>函数的能力，该函数要求另一个值。使用<code class="fe mp mq mr ms b">chunk$</code>，我们能够控制调用<code class="fe mp mq mr ms b">callback</code>函数。注意<code class="fe mp mq mr ms b">take(1)</code>的使用。呼叫回拨后，需要立即取消订阅此即时订阅；否则，您将会以内存泄漏而告终。</p><p id="ec41" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还订阅了<code class="fe mp mq mr ms b">push$</code>，它允许我们在调用<code class="fe mp mq mr ms b">transformStream$.push</code>时将值推入Node.js流。这就是大写值被传递到写流的方式。</p><p id="ef38" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个重要部分是倾听触发所有3个科目完成的<code class="fe mp mq mr ms b">finish</code>事件。这是另一种情况，如果没有正确关闭，您可能会发现内存泄漏。</p><h1 id="d345" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">结论</h1><p id="7393" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在能够编写这些背压助手之前，我花了很多时间做研究，开发出一个干净的API，并找到了大量的在线示例。我知道<em class="lr">我将</em>在未来使用这些实现，而不是弄清楚如何弄乱生成器或试图记住关于Node.js流的一切，当我可能需要再次使用它们的时候。</p><p id="76ad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对我来说，真正学好一件事意味着更容易继续使用这件事，即使它不是每个用例的最佳解决方案。虽然我坚信在工作中使用正确的工具，但我相信我已经展示了RxJS可以是管理背压时的正确工具。当我每天都在使用它时，它更容易使用，也更容易记住。</p><h1 id="0483" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你对更多与RxJS相关的话题感兴趣，你应该看看我的其他文章:</p><ul class=""><li id="1105" class="mz na jg kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><a class="ae jd" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="8598" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae jd" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="f14a" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/handling-cache-and-ajax-race-conditions-4cb152db8764">处理缓存和AJAX竞争条件</a></li><li id="b18e" class="mz na jg kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3">把暴风雨的云变成晴朗的云</a></li></ul></div></div>    
</body>
</html>