<html>
<head>
<title>Derived state — Underrated Pro tip for simplifying React state management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">派生状态—简化反应状态管理的Pro提示被低估</h1>
<blockquote>原文：<a href="https://itnext.io/derived-state-underrated-pro-tip-for-simplifying-react-state-management-8416aa552ecc?source=collection_archive---------4-----------------------#2021-08-29">https://itnext.io/derived-state-underrated-pro-tip-for-simplifying-react-state-management-8416aa552ecc?source=collection_archive---------4-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ce9c5d86e9cac711efccc968264dbb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bb3pMbtzTl-djHXE6xmKjw.png"/></div></div></figure><p id="29fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我看来，状态管理是构建和扩展web应用程序最具挑战性的部分。我甚至认为开发人员主要是通过编写良好的状态管理机器来获得报酬的。使用UI库和NPM包，所有其他部分都可以外包或自动化(通常都是这样)。</p><p id="3b28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我想介绍一种被称为“派生状态”的状态管理技术，我认为这种技术被低估了。在许多情况下，它可以简化您的状态管理逻辑。“派生状态”技术与库无关，您可以将其应用于Redux、MobX和React的内置状态管理挂钩。</p><h1 id="88d6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">派生状态是什么？</h1><p id="bf8f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这个想法是倾向于在您的状态中存储尽可能少的数据。解决这个问题的方法是避免存储那些可以即时推导或计算的状态变量。</p><p id="fb21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计算变量而不是将它们存储在状态中，这样在发生变化时更容易保持数据同步。</p><h1 id="b45a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">派生状态的示例</h1><p id="df53" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们看一个例子。假设您有一个歌曲选择器，其中包含每首歌曲的复选框。歌曲也按流派分组。我们希望能够选择一首单独的歌曲以及整个流派:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/ff8d59c5efbc80aec8bbd19789bca549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*-6N1wIPJGMTPSjQETMK1OA.png"/></div></figure><p id="11a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您首先想到的可能是创建两个状态变量:一个用于存储选定的歌曲，另一个用于存储流派。看起来很简单，但是这是最好的方法吗？我们<em class="mh">真的需要两个变量吗？</em></p><p id="093c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们实际上可以根据单首歌曲复选框的值来导出流派复选框的值。下面是它的样子:</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/3654b9de13918fc885cbf6b898201dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JeQyODK8OSGGgRGCtWzsaw.png"/></div></div></figure><p id="49ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mj mk ml mm b">isGenreChecked</code>方法和<code class="fe mj mk ml mm b">songSelections</code>对象动态计算流派复选框的值。仅当选择了某个流派下的所有歌曲时，才会检查该流派。当用户点击一个流派复选框时，我们需要做的就是选择/取消选择该流派下的所有项目。</p><h1 id="2d57" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么使用这种技术？</h1><p id="3822" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">那么为什么这种方法更好呢？正如我前面提到的，保持我们的状态同步要容易得多。原因是我们只有一个真实的来源——我们选择的歌曲。拥有一个您需要跟踪的状态变量，而所有其他变量都是从它派生出来的，这简化了状态突变。</p><p id="538b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，当取消选中一首歌曲时，我们不再需要担心更新其父流派的状态。在新的渲染，应用程序将重新计算流派的状态，并自动取消选中它。</p><h1 id="ba73" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">性能问题</h1><p id="cc52" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">您可能会担心在每次渲染时重新计算状态变量的值的性能问题。根据派生状态计算的复杂性，可能确实存在性能开销。</p><p id="cd01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果有明显的性能下降，您可以投资优化您的应用程序。例如，您可以使用<a class="ae mn" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>钩子包装您的计算值，以避免重新计算派生变量，除非它的底层状态已经改变。</p><h1 id="d6ce" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="b19f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在这篇文章中，我们介绍了一种叫做“派生状态”的状态管理优化技术“派生状态”通过减少需要存储在状态中的变量数量来帮助您简化代码。</p><p id="7d64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下次构建状态管理部分时，可以考虑使用这种技术，看看某些状态变量是否可以动态计算，而不是存储在状态中。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="2497" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mh">原载于2021年8月29日</em><a class="ae mn" href="https://isamatov.com/react-derived-state/" rel="noopener ugc nofollow" target="_blank"><em class="mh">【https://isamatov.com】</em></a><em class="mh">。</em></p></div></div>    
</body>
</html>