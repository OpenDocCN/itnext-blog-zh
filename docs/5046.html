<html>
<head>
<title>AKS Performance: Resource Requests and Limits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AKS性能:资源请求和限制</h1>
<blockquote>原文：<a href="https://itnext.io/aks-performance-resource-requests-and-limits-f76ac255fae1?source=collection_archive---------2-----------------------#2020-11-24">https://itnext.io/aks-performance-resource-requests-and-limits-f76ac255fae1?source=collection_archive---------2-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="1739" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我需要多少，我能用多少</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/680fb2defd6b436a0d4dad9487498c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjXtb-Pb3GnwM2nC-suoOg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片来自<a class="ae lf" href="http://blog.kubecost.com/" rel="noopener ugc nofollow" target="_blank">http://blog.kubecost.com/</a></figcaption></figure><p id="534a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">Kubernetes可以为您做的最重要的事情之一是帮助确保工作负载在能够处理其资源需求的节点上运行。设置适当的请求和限制有助于防止节点饱和，这将不可避免地导致性能下降。</p><h1 id="3c3d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">资源请求</h1><blockquote class="jn jo jp"><p id="fa64" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">K8s将向托管在节点上的pod保证的资源量的定义</p></blockquote><p id="8f80" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><code class="fe mh mi mj mk b">Resource Requests</code>定义K8s将保证给pod的资源量。在某种程度上，您可以将该定义视为成功创建pod的最低要求。让我们看一个yaml中的例子:</p><pre class="kq kr ks kt gt ml mk mm mn aw mo bi"><span id="c7f4" class="mp lk iq mk b gy mq mr l ms mt">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: SuperAppOfAwesome<br/>spec:<br/>  containers:<br/>  - name: appofawesome<br/>    image: ubuntu<br/>    <strong class="mk ir">resources:<br/>      requests:<br/>        memory: "256Mi"<br/>        cpu: "1000m"</strong><br/>      limits:<br/>        memory: "512Mi"<br/>        cpu: "1500m"</span></pre><blockquote class="jn jo jp"><p id="9cc7" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这里的CPU单元是使用millicpu设置的，因此1000m个vCPU/内核。500万是半个核心，250万是四分之一，以此类推</p></blockquote><p id="cda7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我们可以看到，在容器的规范下，我们已经设置了resources标记并定义了我们的限制，要求最少256MB内存和1个CPU内核。当部署时，这将确保调度器在考虑到那些资源请求需求的情况下找到能够托管pod的家。如果K8s找不到合适的宿主会怎样？该pod不会被安排在任何位置，并将显示为“待定”状态。</p><p id="6ff5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">不同的应用程序会有不同的需求，那么我们如何确定我们的应用程序需要什么才能成功运行呢？这里的简短回答基本上是使用历史使用模式来帮助定义需求。这实质上意味着运行pod并记录其资源消耗，无论是手动还是使用Prometheus或datadog等监控工具。使用历史数据进行模式分析的原因是试图找到使用百分比，并相应地分配请求。</p><p id="5598" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">例如，如果我们的应用平均使用1.5个内核和128MB内存，但每天有一次15分钟的峰值达到2个内核和256MB内存，我们可以很好地理解我们需要1.5个内核和128MB内存才能成功。</p><p id="a7d8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在以后的文章中，我将一步一步地展示我们如何手动确定应该为一个工作负载设置什么样的请求，我会立即进行设计……因为在转向更自动化的解决方案之前，我可以看到手动完成，并且这可能是有用的。在同一篇文章中，我可能还会展示如何用Prometheus和/或datadog来做这件事。</p><p id="b822" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在我们继续讨论极限之前，我想再提几件事。通过以这种方式定义资源，您用<code class="fe mh mi mj mk b">Guaranteed</code> K8s QoS类设置了pod。这一点很重要，因为无论出于何种原因，系统需要获取一个pod来重新获得关键功能的资源，这个特定的QoS类别都被认为是最重要的，不会在不太重要的pod之前被取消。你可以在这里阅读更多关于QoS等级<a class="ae lf" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/resource-qos.md" rel="noopener ugc nofollow" target="_blank">的信息，但基本上如果你不设置任何资源或限制，你的QoS就是尽力而为，如果需要的话，K8s会先干掉那个pod及其容器。</a></p><blockquote class="mu"><p id="ab36" class="mv mw iq bd mx my mz na nb nc nd ko dk translated">我应该在这里指出，您可以为pod中的每个容器设置不同的资源请求，这实际上会导致您的QoS等级发生变化，所以请务必查看<a class="ae lf" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/resource-qos.md" rel="noopener ugc nofollow" target="_blank">文档</a>，以确保您设置的是您所期望的。</p></blockquote><h1 id="3ce6" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu ne lw lx ly nf ma mb mc ng me mf mg bi translated">限制</h1><blockquote class="jn jo jp"><p id="b342" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">不要超过这个限度…否则！</p></blockquote><p id="9139" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我相信你可以根据它的名字猜出这是什么。这将允许您对pod设置限制，并防止它们使用过多的CPU/内存。有些人会说，这是您需要在几乎每个pod上设置的最重要的东西，至少您希望让您的pod占用一个节点可用的所有资源。</p><p id="7b46" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">是的，你没看错。如果不设置限制，pod可能会消耗节点的所有可用CPU和内存，并阻止部署其他pod。设置限制允许您微调和控制您的pod能够消耗的上限… <_> _&gt; …让我们看看之前的清单:</_></p><pre class="kq kr ks kt gt ml mk mm mn aw mo bi"><span id="4cb2" class="mp lk iq mk b gy mq mr l ms mt">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: SuperAppOfAwesome<br/>spec:<br/>  containers:<br/>  - name: appofawesome<br/>    image: ubuntu<br/>  <strong class="mk ir">  </strong>resources:<br/>      requests:<br/>        memory: "256Mi"<br/>        cpu: "1000m"<br/>      <strong class="mk ir">limits:<br/>        memory: "512Mi"<br/>        cpu: "1500m"</strong></span></pre><p id="a864" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">您可以在这里看到，我将内存限制设置为512兆，将CPU限制设置为1500兆，这也是CPU的1.5兆核心。这将防止圆荚体消耗超过我们定义的量。但是这是怎么做到的，如果吊舱试图超过它的极限会发生什么呢？在AKS中，我们的容器编排器正在使用cgroups，这些限制将由内核监控和执行。但是，违反CPU和内存限制的处理方式非常不同。</p><p id="b85f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">CPU限制是通过使用<a class="ae lf" href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt" rel="noopener ugc nofollow" target="_blank">完全公平调度器</a>来控制的。对于大多数Linux容器编排来说，AK包括在内，因为它们使用docker。基本上，CFS cgroup使用<code class="fe mh mi mj mk b">quota</code>和<code class="fe mh mi mj mk b">period</code>设置来控制CPU带宽。当配额在一个周期内用完时，它会受到限制，并在下一个周期恢复。这很有趣，请点击上面的链接了解更多信息。这意味着你的性能可能会受到很大的影响，所以如果你重视性能，你应该避免这种情况。CPU上的节流通常是不正确的限制，但不排除一些失控的进程—总是检查以确保:)</p><p id="ae71" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">另一方面，内存并没有这么大。K8和内核不会简单地限制pod请求和消耗内存的能力。它会杀了它。除此之外还有更多，但现在知道这些并不十分重要。请理解，试图请求超过其限制的pod可能会被终止/终止。</p><h1 id="13e5" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="eab6" class="pw-post-body-paragraph jq jr iq jt b ju nh jw jx jy ni ka kb lg nj ke kf lh nk ki kj li nl km kn ko ij bi translated">希望这有助于您理解使用适当的资源请求和限制来设置pod以确保适当的性能和稳定性的重要性。使用<code class="fe mh mi mj mk b">requests</code>保证最少数量的资源给吊舱。使用<code class="fe mh mi mj mk b">limits</code>有助于防止pod消耗过多的节点资源。</p><p id="2561" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在以后的文章中，我将告诉你如何找到你的请求和限制可以/应该设置在什么位置，以及如何识别和处理违反限制的pod。</p><p id="f453" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">尽管如此，下一篇文章——我将在发布后添加who的链接——将讨论<a class="ae lf" href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" rel="noopener ugc nofollow" target="_blank">资源配额的</a>,以及它们对于帮助控制和限制多个团队使用的集群的资源使用的重要性。</p></div></div>    
</body>
</html>