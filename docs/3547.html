<html>
<head>
<title>Deploying TLS certificates for local development and production using Kubernetes, cert-manager, mkcert and Let’s Encrypt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubernetes、cert-manager、mkcert和Let's Encrypt为本地开发和生产部署TLS证书</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-tls-certificates-for-local-development-and-production-using-kubernetes-cert-manager-9ab46abdd569?source=collection_archive---------0-----------------------#2020-01-07">https://itnext.io/deploying-tls-certificates-for-local-development-and-production-using-kubernetes-cert-manager-9ab46abdd569?source=collection_archive---------0-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c6c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近在我的项目中，我深入研究了如何在生产中以及开发环境中在我们面向客户端的基础设施上启用TLS。</p><p id="efbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是这样处理这件事的！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/41f4f40b77506267f53084297f08890d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKUrAaSIYxLR0IAbz93Lmg.jpeg"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="2da8" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">宗旨</h1><p id="e5f1" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">作为我的项目中安全通信的第一次迭代，我的主要目标只是在我们的Kubernetes集群的边缘(即入口级别)放置TLS终端，并在生产中向客户端提供Let's Encrypt证书。</p><p id="ec55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我有更多的时间时，我肯定会回来实现完整的端到端加密，但是，正如俗话所说:“你必须在跑之前学会走路”:)</p><p id="5502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我为第一次迭代设定了两个子目标:</p><ul class=""><li id="877b" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">为地方发展启用TLS</li><li id="1f95" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">为所有生产和类似生产的环境(例如，试运行和生产)启用TLS。</li></ul><p id="1d41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了让开发环境尽可能真实，我希望两种情况都有一个类似的解决方案，但是我真的不能花一整个月的时间来实现某些东西。</p><p id="e860" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个要求是完全自动化/可复制性(即，能够轻松删除/重新创建所有内容)。</p><h1 id="4abd" class="lh li it bd lj lk my lm ln lo mz lq lr ls na lu lv lw nb ly lz ma nc mc md me bi translated">证书管理器</h1><p id="9ebf" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">经过一些初步的研究，并且因为我们已经“深入”到Kubernetes，我的选择已经决定了<a class="ae nd" href="https://cert-manager.io/" rel="noopener ugc nofollow" target="_blank"> cert-manager </a>一个由<a class="ae nd" href="https://twitter.com/JetstackHQ" rel="noopener ugc nofollow" target="_blank"> Jetstack </a>的优秀人员创建的开源解决方案(向他们致敬！).</p><p id="6149" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">cert-manager自动管理和发放来自不同来源的TLS证书<em class="ne"/>。</p><p id="0f26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦<a class="ae nd" href="https://cert-manager.io/docs/installation/" rel="noopener ugc nofollow" target="_blank">安装了</a>(使用helm或项目提供的<a class="ae nd" href="https://github.com/jetstack/cert-manager/releases/download/v0.12.0/cert-manager.yaml" rel="noopener ugc nofollow" target="_blank"> yaml文件非常容易)，cert-manager的控制器就会监视它所支持的自定义资源定义(CRD)，例如"</a><a class="ae nd" href="https://cert-manager.io/docs/concepts/issuer/" rel="noopener ugc nofollow" target="_blank">颁发者</a>或"<a class="ae nd" href="https://cert-manager.io/docs/concepts/certificate/" rel="noopener ugc nofollow" target="_blank">证书</a>"资源类型。</p><h1 id="b660" class="lh li it bd lj lk my lm ln lo mz lq lr ls na lu lv lw nb ly lz ma nc mc md me bi translated">证书管理器部署步骤</h1><p id="7bf2" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">实际上，cert-manager的部署过程是这样的:</p><ol class=""><li id="7ee2" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn nf mq mr ms bi translated">为证书管理器创建一个名称空间(例如，kubectl创建名称空间证书管理器)</li><li id="f379" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn nf mq mr ms bi translated">安装证书管理器</li><li id="63b7" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn nf mq mr ms bi translated">创建一个或多个发行者(例如，每个名称空间一个，一个全局的，等等)</li><li id="09c1" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn nf mq mr ms bi translated">创建证书资源</li><li id="5a45" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn nf mq mr ms bi translated">让魔法流动吧</li></ol><p id="5159" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，看看cert-manager 的<a class="ae nd" href="https://cert-manager.io/docs/" rel="noopener ugc nofollow" target="_blank">官方文档，他们在那里做了一件非常棒的工作！</a></p><p id="297a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要安装cert-manager，最简单的方法是使用kubectl:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="e1b0" class="nl li it nh b gy nm nn l no np">kubectl apply --validate=false -f <a class="ae nd" href="https://github.com/jetstack/cert-manager/releases/download/v0.12.0/cert-manager.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/jetstack/cert-manager/releases/download/v0.12.0/cert-manager.yaml</a></span></pre><h1 id="7886" class="lh li it bd lj lk my lm ln lo mz lq lr ls na lu lv lw nb ly lz ma nc mc md me bi translated">证书管理器颁发者</h1><p id="18e3" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated"><a class="ae nd" href="https://cert-manager.io/docs/concepts/issuer/" rel="noopener ugc nofollow" target="_blank">发布者</a>是cert-manager中可以发布证书(因此得名)的元素，开箱即可支持多种类型，例如:</p><ul class=""><li id="fc7d" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated"><a class="ae nd" href="https://cert-manager.io/docs/configuration/selfsigned/" rel="noopener ugc nofollow" target="_blank">自签名</a>:简单的自签名发行人</li><li id="1be0" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated"><a class="ae nd" href="https://cert-manager.io/docs/configuration/ca/" rel="noopener ugc nofollow" target="_blank"> CA </a>:代表证书颁发机构(CA)的颁发者，有权访问相应的私有/公共密钥来颁发新证书</li><li id="363f" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">ACME :最酷的类型，支持ACME协议，因此兼容<a class="ae nd" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>！</li></ul></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="d546" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">作战计划</h1><p id="7a90" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">计划如下:</p><ul class=""><li id="c94e" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">通过使用<a class="ae nd" href="https://github.com/FiloSottile/mkcert" rel="noopener ugc nofollow" target="_blank"> mkcert </a>生成的自签名证书，使用CA发行者进行本地开发，允许我们使用可信证书(使用mkcert轻松添加到本地信任存储中)进行TLS支持的本地开发</li><li id="532a" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">在生产和类似生产的环境中使用ACME发行者，使用“让我们加密”来获取证书</li><li id="5ac6" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">将证书存储在K8S秘密中</li><li id="18ce" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">使用我的<a class="ae nd" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> NGINX入口</a>到<a class="ae nd" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#tls" rel="noopener ugc nofollow" target="_blank">TLS配置选项</a>中的那些秘密</li></ul></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="054d" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">瞬间达到顶点</h1><p id="d96d" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">ACME代表“<strong class="js iu">A</strong>automatic<strong class="js iu">C</strong>certificate<strong class="js iu">M</strong>M<strong class="js iu">E</strong>n environment”是一个很酷的协议(我想？)标准化得益于Let's Encrypt，它允许ca和“申请人”(即证书申请人)自动执行所有权/控制权验证和证书颁发流程。ACME现在在<a class="ae nd" href="https://tools.ietf.org/html/rfc8555" rel="noopener ugc nofollow" target="_blank"> RFC8555 </a>中定义。</p><p id="71ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不知道ACME协议的所有细节，但一个重要的部分是所有权的验证，这可以通过两种主要方式完成:使用http01或dns01挑战。这些挑战旨在验证证书申请中DNS域的所有权/控制权。</p><p id="32ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">http01挑战要求申请人通过在一个特定的URL上公开一个具有特定内容的文件来证明所有权(详情请查看RFC ),该URL可通过端口80由Let's Encrypt访问。</p><p id="0b05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，dns01挑战要求通过添加特定的dns记录来证明所有权。</p><p id="bc84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我选择http01是因为它在Kubernetes集群中实现起来更加简单，并且是独立的，而dns01挑战则要求我与dns区域进行交互，并处理DNS复制延迟和其他微妙之处:)</p><p id="fe3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在实践中，当然有一些试验和错误涉及到让整个事情工作，但一切都很容易按照计划进行。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="c308" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">HTTPS地方发展组织</h1><p id="984a" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">对于本地开发来说，这真是轻而易举，因为mkcert使得动态创建自签名根CA证书并将其添加到主机的不同信任存储区变得非常简单:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="b470" class="nl li it nh b gy nm nn l no np"><strong class="nh iu">echo</strong> "Creating self-signed CA certificates for TLS and installing them in the local trust stores"</span><span id="ba1f" class="nl li it nh b gy nq nn l no np">CA_CERTS_FOLDER=$(pwd)/.certs</span><span id="64dd" class="nl li it nh b gy nq nn l no np"># This requires mkcert to be installed/available<br/><strong class="nh iu">echo</strong> ${CA_CERTS_FOLDER}<br/>rm -rf ${CA_CERTS_FOLDER}<br/>mkdir -p ${CA_CERTS_FOLDER}<br/>mkdir -p ${CA_CERTS_FOLDER}/${ENVIRONMENT_DEV}</span><span id="1640" class="nl li it nh b gy nq nn l no np"># The CAROOT env variable is used by mkcert to determine where to read/write files</span><span id="fd8d" class="nl li it nh b gy nq nn l no np"># Reference: <a class="ae nd" href="https://github.com/FiloSottile/mkcert" rel="noopener ugc nofollow" target="_blank">https://github.com/FiloSottile/mkcert</a><br/>CAROOT=${CA_CERTS_FOLDER}/${ENVIRONMENT_DEV} mkcert -install</span></pre><p id="c5d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，在这个步骤执行之后，一个单独的伪根CA证书就可用了，然后通过mkcert -install将它添加到本地信任存储中。就这么简单！</p><p id="235b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是在目标名称空间中创建一个秘密，包含证书和私钥:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="cb7a" class="nl li it nh b gy nm nn l no np"><strong class="nh iu">echo</strong> "Creating K8S secrets with the CA private keys (will be used by the cert-manager CA Issuer)"</span><span id="480a" class="nl li it nh b gy nq nn l no np">kubectl -n some-namespace create secret tls my-ca-tls-secret --key=${CA_CERTS_FOLDER}/${ENVIRONMENT_DEV}/rootCA-key.pem --cert=${CA_CERTS_FOLDER}/${ENVIRONMENT_DEV}/rootCA.pem</span></pre><p id="dae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您希望每个环境有不同的根CA证书，那么复制它是非常简单的</p><p id="654d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是CA颁发者定义:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="56e6" class="nl li it nh b gy nm nn l no np"># Certificate Issuer (CA)</span><span id="4e0e" class="nl li it nh b gy nq nn l no np">apiVersion: cert-manager.io/v1alpha2<br/>kind: Issuer<br/>metadata:<br/>name: tls-ca-issuer<br/>namespace: some-namespace<br/>labels: ...<br/>annotations: ...</span><span id="f689" class="nl li it nh b gy nq nn l no np">spec:<br/>  ca:<br/>    secretName: my-ca-tls-secret</span></pre><p id="bb1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我选择为每个名称空间定义一个颁发者，因为在生产环境中，我希望限制每个颁发者服务的DNS域，以避免开发环境为生产域请求证书。</p><p id="470c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为简单部署的替代方案，cert-manager还支持ClusterIssuer资源类型，这几乎是相同的。</p><p id="e63c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个issuer定义可以像任何其他Kubernetes资源一样进行部署，我们亲爱的朋友kubectl apply:)</p><p id="f7b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，CA发行者需要知道在哪里可以找到CA密钥，这是通过secretName指定的。</p><p id="c64f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备就绪后(假设cert-manager已经安装到集群中)，就可以交付证书了！</p><p id="fca2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个例子:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="ab32" class="nl li it nh b gy nm nn l no np"># Reference: https://cert-manager.io/docs/usage/certificate/</span><span id="d8a0" class="nl li it nh b gy nq nn l no np">apiVersion: cert-manager.io/v1alpha2<br/>kind: Certificate<br/>metadata:<br/>  name: my-tls-certificate<br/>  namespace: some-namespace<br/>labels: ...</span><span id="2a23" class="nl li it nh b gy nq nn l no np">spec:<br/>  secretName: my-app-tls-secret<br/>  dnsNames:<br/>    - my-app.dev.local<br/>  issuerRef:<br/>    name: tls-ca-issuer<br/>    # Alternative: ClusterIssuer if there is a cluster-wide issuer available<br/>    kind: Issuer</span></pre><p id="f8b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦应用到集群上，cert-manager将检测到它，并将证书(基本上是各种CSR)对象传递给发行者，发行者将依次处理其余的事情。“其余的”后面有相当多的细节需要了解，但我不会在这里深究那些细节。最后，如果一切顺利，那么发行者会将新生成的证书保存在my-app-tls-secret secret中。</p><p id="73fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦有了这些，接下来就是使用它的问题了，使用ingress-nginx也很容易:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="b6ef" class="nl li it nh b gy nm nn l no np">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>namespace: some-namespace<br/>metadata: ...<br/>labels: ...<br/>annotations: ...<br/>spec:<br/>  tls:<br/>    # Hosts list must match those in the certificate<br/>    - hosts:<br/>      - my-app.dev.local<br/>    secretName: my-app-tls-secret<br/>  ...</span></pre><p id="4766" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果证书可用，那么NGINX将使用它并执行<a class="ae nd" href="https://kubernetes.github.io/ingress-nginx/examples/tls-termination/" rel="noopener ugc nofollow" target="_blank"> TLS终止</a>。</p><p id="cde7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为拼图的最后一块，我简单地将条目添加到我的hosts文件中，这样my-app.local DNS名称就可以工作了，而不必摆弄DNSmasq之类的东西。</p><p id="1377" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是HTTPS当地的发展，干净而简单。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="76bf" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">生产设置</h1><p id="4e13" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">对于生产，设置非常相似。变化的主要是发行者，它是一个ACME发行者:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="bbd1" class="nl li it nh b gy nm nn l no np"># Certificate Issuer (ACME)<br/>apiVersion: cert-manager.io/v1alpha2<br/>kind: Issuer<br/>metadata:<br/>  name: tls-acme-issuer<br/>namespace: some-namespace<br/>labels: ...<br/>annotations: ...<br/>spec:<br/>  acme:<br/>    # Production URL: https://acme-v02.api.letsencrypt.org/directory<br/>    server: <a class="ae nd" href="https://acme-staging-v02.api.letsencrypt.org/directory" rel="noopener ugc nofollow" target="_blank">https://acme-staging-v02.api.letsencrypt.org/directory</a><br/>    email: &lt;valid mail for certificate expiry notifications, API changes, etc&gt;<br/>    # Where to store the Let's Encrypt account key<br/>    privateKeySecretRef:<br/>      name: acme-tls-issuer-account-secret-key<br/>    # Use the HTTP01 challenge<br/>    # Reference: <a class="ae nd" href="https://cert-manager.io/docs/configuration/acme/http01/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/configuration/acme/http01/</a><br/>    solvers:<br/>    - http01:<br/>      ingress:<br/>        class: nginx<br/>    # This issuer is configured to only provide certificates<br/>    # for these specific DNS names<br/>    # Reference: <a class="ae nd" href="https://cert-manager.io/docs/configuration/acme/#adding-multiple-solver-types" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/configuration/acme/#adding-multiple-solver-types</a><br/>    selector:<br/>      dnsNames:<br/>      - my-app.dev.local</span></pre><p id="12f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没有更多的东西需要了解:</p><ul class=""><li id="a5fb" class="mk ml it js b jt ju jx jy kb mm kf mn kj mo kn mp mq mr ms bi translated">服务器是ACME端点，在这种情况下，让我们加密的登台环境</li><li id="8798" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">privateKeySecretRef是秘密的名称，cert-manager将在其中存储它将创建的帐户的私钥，以便与Let's Encrypt ACME endpoint交互(值得备份！)</li><li id="c9e0" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">解决者定义如何处理ACME挑战；在这种情况下使用http01“方法”</li><li id="be90" class="mk ml it js b jt mt jx mu kb mv kf mw kj mx kn mp mq mr ms bi translated">选择器允许更多的选择；在这种情况下，我将限制该发行者可以处理的DNS名称。我认为这是一种非常简洁方法，可以限制每个发行者的权限</li></ul><p id="5fad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更棘手的部分是实际生产基础设施的ACME挑战，目前托管在<a class="ae nd" href="https://www.digitalocean.com/" rel="noopener ugc nofollow" target="_blank">数字海洋</a>上。</p><p id="e8ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初，我在负载平衡器级别以及NGINX入口上启用了代理协议，以便在集群中获得真实的客户端IP，但我最终禁用了它，因为它给ACME on Digital Ocean带来了麻烦。</p><p id="91f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经尝试了各种解决方法(包括一些负载平衡器注释)，但似乎没有一个适合我的情况。</p><p id="0a54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我想前进，所以我现在接受了这个缺点，但是肯定有解决的办法。也许改天我会再写一篇关于数字海洋负载平衡器的文章..；-)</p><p id="00e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我最终还是选择了我最初选择的http01 ACME解算器，因为如果没有很好地实现，替代方案(dns01)似乎更加危险。</p><p id="e23f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我排除故障的过程中，我很高兴地发现在Kubernetes Slack的#cert-manager频道中有超级友好/乐于助人的人:【http://slack.kubernetes.io/<a class="ae nd" href="http://slack.kubernetes.io/" rel="noopener ugc nofollow" target="_blank"/>。再次感谢他们的宝贵帮助！</p><p id="9c2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在官方文档中还有一个关于故障排除的有用页面:<a class="ae nd" href="https://cert-manager.io/docs/faq/acme/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/faq/acme/</a></p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="4605" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">关于让我们加密速率限制</h1><p id="a93c" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">上一节我没有坚持那一点，但是值得知道的是，Let's Encrypt在制作上有相当严格的速率限制。</p><p id="ff70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很有道理，因为他们的目标是向尽可能多的人/组织交付尽可能多的证书，但你必须知道这些速率限制，否则当被禁一周时，你可能会遇到麻烦的生产问题:)</p><p id="6984" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">详情请看以下页面:<a class="ae nd" href="https://letsencrypt.org/docs/rate-limits/" rel="noopener ugc nofollow" target="_blank">https://letsencrypt.org/docs/rate-limits/</a></p><p id="c853" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般的建议是在更加友好的试运行环境中执行所有的测试。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="561d" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">那都是乡亲们！</h1><p id="2387" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">还有很多细节需要讨论，但这应该能让你对整个过程有一个很好的了解。</p><p id="a3ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我对这个解决方案以及整个解决方案的简单明了非常满意。</p><p id="0040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Let's Encrypt非常棒，支持全球数百万个网站，并提供A+级证书。</p><p id="5dcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还非常喜欢这样一个事实，即我可以拥有一个相对真实的开发环境，这使得使用服务工作者之类的东西没有太多的麻烦。</p><p id="89bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我当然可以改进很多部分，比如像<a class="ae nd" href="https://github.com/smallstep/step-issuer" rel="noopener ugc nofollow" target="_blank">这样的事情，但是我现在没有足够的时间去做。</a></p><p id="9869" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天到此为止！</p></div></div>    
</body>
</html>