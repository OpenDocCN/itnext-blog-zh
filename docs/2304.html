<html>
<head>
<title>Express + Knex + Objection = Painless API with DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Express + Knex + Objection =带DB的无痛API</h1>
<blockquote>原文：<a href="https://itnext.io/express-knex-objection-painless-api-with-db-74512c484f0c?source=collection_archive---------0-----------------------#2019-05-04">https://itnext.io/express-knex-objection-painless-api-with-db-74512c484f0c?source=collection_archive---------0-----------------------#2019-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2aa4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在连接到数据库时不对您的代码(和您自己)生气</h2></div><h1 id="119f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="e57a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我们将在Node.js上为简单的用户/消息数据库构建一个API系统。</p><p id="5763" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最终代码可以在<a class="ae ly" href="https://github.com/Fodark/express-knex-objection" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="2abc" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">介绍</h2><p id="20ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于其通用性质，Node.js没有提供一种开箱即用的简单方法来连接到数据库，当然有像<a class="ae ly" href="https://www.npmjs.com/package/pg" rel="noopener ugc nofollow" target="_blank"> pg </a>或<a class="ae ly" href="https://www.npmjs.com/package/mongoose" rel="noopener ugc nofollow" target="_blank">mongose</a>这样的包来直接与数据库交互，但是如果您的应用程序足够大，通过这些包管理连接和查询会很容易成为一种痛苦。</p><p id="aaea" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们需要的是:</p><ul class=""><li id="f85a" class="ml mm iq kz b la lt ld lu lg mn lk mo lo mp ls mq mr ms mt bi translated">Node.js(任何最新版本都可以)</li><li id="f304" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated"><code class="fe mz na nb nc b">pg</code>用于访问PostgreSQL数据库，或其他DBMS的任何等效物</li><li id="6cd6" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated"><code class="fe mz na nb nc b">knex</code> SQL构建器</li><li id="651e" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated"><code class="fe mz na nb nc b">objection</code>给车型下定义(见后文)</li><li id="944f" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated"><code class="fe mz na nb nc b">express</code>定义我们的端点</li></ul><p id="d311" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">可选，要展开项目:</p><ul class=""><li id="49bd" class="ml mm iq kz b la lt ld lu lg mn lk mo lo mp ls mq mr ms mt bi translated"><code class="fe mz na nb nc b">body-parser</code>管理帖子请求</li></ul><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi nd"><img src="../Images/dfd9aa0749b307ffe644e1da2b88ae71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBc9LVzT0otzWRW1eiHbrA.jpeg"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">你不希望你的代码看起来像这样，对吗？</figcaption></figure><h1 id="707a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Knex.js</h1><p id="556a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是推出第一个套餐的恰当时机；<a class="ae ly" href="https://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex.js </a>允许在一个单独的文件(名为<code class="fe mz na nb nc b">knexfile.js</code>)中轻松定义连接属性，并且可以针对您的开发/测试/生产服务器进行不同的配置。在这个文件中，您还可以定义迁移(创建哪些表)和种子(数据库填充)文件夹，因此您不必手动跟踪您的表和数据。</p><p id="c815" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">安装完这个包(<code class="fe mz na nb nc b">npm install -g knex</code>)之后，您可以在控制台中键入<code class="fe mz na nb nc b">knex init</code>来生成默认的配置文件，在使它适应您的DB之后，它应该是这样的:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">knex配置文件示例</figcaption></figure><p id="ef16" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然后，您可以创建一个模块，将连接导出到数据库，我称之为<code class="fe mz na nb nc b">knex.js</code></p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="76ec" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">首先，我们了解我们所处的环境，生产服务器通常会导出这个变量，它可以在<code class="fe mz na nb nc b">process.env.NODE_ENV</code>中找到，否则我们就在开发服务器中。接下来，我们从之前定义的<code class="fe mz na nb nc b">knexfile</code>中获取相关配置，然后在导出时将其传递给库，很容易。</p><p id="dcd6" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我通常将这个文件放在一个<code class="fe mz na nb nc b">db</code>文件夹中，与下一个主题迁移和种子放在一起。</p><h2 id="0312" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">迁移</h2><p id="b3d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Knex的一个很大的优点是它的迁移工具可以让你更容易管理数据库的表。它创建带有时间戳的顺序文件，在这些文件中，您可以定义应该创建哪个表和哪些列；它还管理表的变更，因此您可以添加/删除列，而无需接触原始的迁移文件。</p><p id="5997" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果你在全局范围内安装了Knex，你可以在不进入<code class="fe mz na nb nc b">.node_modules</code>文件夹的情况下访问bin，所以如果你输入如下内容:</p><p id="714d" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><code class="fe mz na nb nc b">knex migrate:make users</code></p><p id="4fdb" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">它将在您的迁移文件夹中创建一个新文件，导出两个函数，第一个用于表的创建/更改，第二个用于恢复更改(如果您需要的话)。Knex不知道您使用的是哪个数据库(除了特定的列类型)，所以如果您使用PostgreSQL/MySQL/SQLite/[…]的话，您可以用相同的类型独立地编写相同的列</p><p id="dea3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">典型的迁移如下所示:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ae36" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">在<code class="fe mz na nb nc b">up</code>函数中，我们定义了表的名称和字段，而在<code class="fe mz na nb nc b">down</code>中，我们说如果我们想要恢复更改，应该删除表。</p><p id="cf1c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">约束是可能的，比如not null、唯一性和类似的，但我不会在这里讨论它们，你可以在knex <a class="ae ly" href="https://knexjs.org/" rel="noopener ugc nofollow" target="_blank">网站</a>上找到它们。</p><p id="7930" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">现在，如果一切配置正确，运行<code class="fe mz na nb nc b">knex migrate:latest</code>应该会在您的数据库中创建表，万岁！</p><h2 id="3d29" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">种子</h2><p id="9b0d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与迁移一样，我们可以创建种子，因此我们可以一致地填充数据库。该命令类似于迁移命令，我们可以键入</p><p id="af7a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><code class="fe mz na nb nc b">knex seed:make users</code></p><p id="44f9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">并且将在knexfile中指定的seeds文件夹中创建一个标准种子文件。最终它将是这样的，每个条目都被定义为一个JSON对象，其字段的名称与迁移中的字段名称相同:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="915f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这个函数是做什么的？首先，它删除表中的每个条目，然后用我们的数据填充表。</p><p id="98f8" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">怎么跑？只需输入【knex就会做到！</p><h2 id="ec7f" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">额外的</h2><p id="ea4f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在repo中，您可以找到messages表的迁移和种子文件，还可以看到如何在knex中创建外键；此表稍后将用于显示异议特征。</p><h2 id="a4f4" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">边注</h2><p id="bf51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">种子文件是按顺序执行的，所以如果你有像表<code class="fe mz na nb nc b">messages</code>中的<code class="fe mz na nb nc b">author_id</code>这样的约束，你应该确保一个顺序，我通常在种子文件中放一个数字，像<code class="fe mz na nb nc b">01_users.js</code>、<code class="fe mz na nb nc b">02_messages.js</code>等等。</p><h1 id="b9fd" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Objection.js</h1><p id="05e6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae ly" href="https://vincit.github.io/objection.js/" rel="noopener ugc nofollow" target="_blank">异议</a>是基于Knex构建的ORM，它允许为我们的数据库定义模型，我们将在后面看到，以及其他功能，如急切加载、模式验证等……<br/>我们将使用它进行模型和急切加载，这允许我们不必编写复杂的连接查询来获取表之间的相关行。</p><h2 id="2c08" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">模型</h2><p id="158b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们要定义的第一件事是我们的模型，它代表我们数据库中的表。我通常将它们存储在<code class="fe mz na nb nc b">models</code>文件夹中，以组织我的代码。</p><p id="bd79" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">使用异议模型所需的最低结构如下:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="0e97" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">它只是告诉Objection我们数据库中的表名。</p><p id="9c20" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">但是酷的东西是渴望加载的，假设我们想要得到用户写的每一条消息，通常你会写这样的查询:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1160" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你可能会说这并不复杂，但是假设你想在用户对象中使用它们来响应用户，这很容易变得一团糟！</p><p id="cbc0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这就是异议模型显示其优势的地方，我们可以轻松地定义表之间的关系，然后使用它们来获得相关行的子集。</p><p id="1908" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">所以，如果我们想得到一个用户的消息，我们可以这样定义一个关系:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b702" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们基本上是在说两个表之间有什么关系(一个用户有许多消息)，哪个模块保存另一个表，哪个字段使这种关系成为可能。</p><p id="e645" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">第2–4行将模型绑定到我们在上一节中定义的数据库连接。</p><p id="8737" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">类似于消息模型:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3544" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">定义反向关系不是强制性的，但拥有它可能是有用的。</p><p id="ed2e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">是的，现在我们已经正确设置了数据库并定义了模型，最后一件事是为这些资源设置API！</p><h1 id="d730" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">应用程序接口</h1><p id="fb63" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于这最后一部分，我们将使用最广为人知的Node框架<a class="ae ly" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> Express，</a>。</p><h2 id="bf18" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">基础</h2><p id="381b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，让我们创建一个简单的<code class="fe mz na nb nc b">app.js</code>文件，它启动一个监听端口的服务器。</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="00f0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们正在导入<code class="fe mz na nb nc b">express</code>，并定义服务器应该监听传入请求的端口，然后创建一个新的应用程序，我们将在其中附加端点，并最终让它监听端口。</p><p id="8149" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">耶，如果你用<code class="fe mz na nb nc b">node app.js</code>开始这个程序，你应该会看到<code class="fe mz na nb nc b">Listening on port: 3000</code>或者类似的，很好！</p><h2 id="0934" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">端点</h2><p id="df54" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，我们希望有一些端点为我们的资源服务，所以让我们创建一个文件夹<code class="fe mz na nb nc b">api</code>来存放我们的文件，通常每个资源一个。例如，在<code class="fe mz na nb nc b">users.js</code>中，我们可以编写这样的代码来获取数据库中的每个用户:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b425" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这是怎么回事？我们使用Express router来响应<code class="fe mz na nb nc b">/users</code>上的<code class="fe mz na nb nc b">GET</code>请求，并且我们使用Objection模型来轻松地检索表中的每一行，从Objection返回的JSON对象可以直接提供给用户。</p><p id="4f92" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">为了测试它，我们还需要一件事，在我们的应用程序中包括端点，我们的<code class="fe mz na nb nc b">app.js</code>将看起来像这样:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fb3e" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">很好，我们说:将在<code class="fe mz na nb nc b">/api/users</code>中定义的路线附加到基本url <code class="fe mz na nb nc b">/api</code>，启动<code class="fe mz na nb nc b">node app.js</code>并让浏览器指向</p><p id="a4ef" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><code class="fe mz na nb nc b">localhost:3000/api/users</code></p><p id="d06a" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">你会看到与用户的JSON，再次欢呼！</p><h2 id="5595" class="lz kg iq bd kh ma mb dn kl mc md dp kp lg me mf kr lk mg mh kt lo mi mj kv mk bi translated">急切装载</h2><p id="fffc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">到目前为止一切顺利，但是我们还没有使用我们之前讨论过的急切加载，让我们假设我们想要设置一个端点来获取单个用户，当我们获取单个用户时，我们甚至想要查看他的消息:通常您会设置一个复杂的联合查询，将用户与消息连接起来，但是如果有异议，我们只需要多两行！让我们看看如何:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4e63" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">耶！首先，我们使用URL中传递的ID使用<code class="fe mz na nb nc b">where</code>子句进行过滤，然后，使用关键字<code class="fe mz na nb nc b">eager</code>使用模型中定义的关系名称来获取用户的消息，尝试一下，指向:</p><p id="5acf" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><code class="fe mz na nb nc b">localhost:3000/api/users/1</code></p><p id="09aa" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">您将看到一个包含消息对象的子字段messages，简单！</p><h1 id="ed99" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结尾(？)</h1><p id="86d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们完了，但真的完了吗？不完全是，对传递给URL的ID没有控制，我们不能处理其他3个动作(POST、PUT和DELETE ),但这对本文来说太多了。</p><p id="4fe9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这个例子可以扩展到更多的表、端点、测试等等。<br/> Objection还允许在使用急切加载时过滤掉字段，所以如果您有像<code class="fe mz na nb nc b">password</code>这样的字段，显然您不想返回给用户，您可以从查询中删除它们。<br/>关于异议，我要说的最后一件很酷的事情是可以将多个急切加载链接在一起。<br/>假设我们给用户附上了图片，给消息附上了评论，您可以像这样轻松地通过一次加载检索到所有内容:</p><figure class="ne nf ng nh gt ni"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6578" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好了，现在真的结束了！</p><p id="4aa0" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我希望这篇概述有助于您了解Node中的数据库管理！喜欢就鼓掌，分享！</p></div></div>    
</body>
</html>