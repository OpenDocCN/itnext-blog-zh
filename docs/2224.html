<html>
<head>
<title>Functional Reactive Programming in Scala from Scratch (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中的函数式反应式编程(第1部分)</h1>
<blockquote>原文：<a href="https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-1-9f9db0c47478?source=collection_archive---------4-----------------------#2019-04-18">https://itnext.io/functional-reactive-programming-in-scala-from-scratch-part-1-9f9db0c47478?source=collection_archive---------4-----------------------#2019-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fb99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一系列的文章中，我们想从头开始为Scala中的函数式反应式编程开发一个小框架。这是这个系列的第一部分。剩下的部分可以在这里找到:<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629">第二部分</a>，<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-3-d999dca5fa69">第三部分</a>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/af672f2fcf36c479172c17976f0e4532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W97dFrSemwvcCYm1"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="4d6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自从<a class="ae ko" href="https://www.reactivemanifesto.org" rel="noopener ugc nofollow" target="_blank">反应式宣言</a>发表以来，反应式编程经历了相当多的炒作。已经为基本上每一种主要的编程语言开发了一堆库来促进反应式编程。其中最突出的是针对Javascript、Python、Scala和其他一些语言的ReactiveX库。</p><p id="e508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这些库很棒，但是不要将它们与<em class="lf">功能性</em>反应式编程混淆。正如ReactiveX本身的文档中所述:</p><blockquote class="lg lh li"><p id="3e08" class="jq jr lf js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">它有时被称为“功能反应式编程”，但这是一个误称。ReactiveX可能是功能性的，也可能是反应性的，但“功能性反应性编程”是不同的动物。</p></blockquote><p id="3438" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ReactiveX和Functional Reactive Programming等反应式库之间的主要区别在于，这些库大多只查看<em class="lf">事件</em>，而不查看<em class="lf">行为</em>。事件是随着时间推移而发出的离散值，如鼠标点击。行为是始终有当前值的连续值，例如鼠标位置。</p><p id="7240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(鼠标点击本身没有值，它只是一个每当用户点击某个地方时被触发的事件。另一方面，鼠标位置总是有一个当前值——但是它不会在特定的时间点被“触发”。)</p><p id="d9b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对这一切感到困惑，看看我的文章<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/demystifying-functional-reactive-programming-67767dbe520b">揭开函数式反应式编程的神秘面纱</a>吧，这篇文章详细讨论了我刚刚提到的所有这些术语。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="f547" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一系列文章中，我们将为Scala中的函数式反应式编程开发一个小框架，一步一步来，完全从头开始。我们要看的代码是Martin Odersky和Ingo Maier的Scala的简化版本。React在用Scala反对观察者模式的论文<a class="ae ko" href="https://infoscience.epfl.ch/record/176887/files/DeprecatingObservers2012.pdf" rel="noopener ugc nofollow" target="_blank">中也有描述。反应</a></p><p id="8687" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我写这篇文章的灵感来自于观看马丁·奥德斯基关于函数式编程的在线课程的<a class="ae ko" href="https://www.coursera.org/lecture/progfun2/lecture-4-2-functional-reactive-programming-pEsTy" rel="noopener ugc nofollow" target="_blank">视频</a>，在视频中他简短地解释了Scala.React的部分内容。然而，如果你不是马丁·奥德斯基，你可能会发现这个视频很难理解。代码中有相当多的内容不会立即呈现在眼前。这一系列的文章将试图更温和地解释这些概念。我相信提议的编程框架会产生非常优雅的代码，即使您在日常工作中不使用它，也有很多东西可以从中学习。</p><p id="e70e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">包含这里讨论的所有代码的笔记本可以在<a class="ae ko" href="https://github.com/timo-stoettner/frp-scala" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="e44d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">(注意:我假设对Scala有一些基本的了解。然而，我将尝试解释即将出现的更高级的语言特性，因此如果您不是Scala专家，也应该能够理解。)</em></p><h1 id="a937" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">动机</h1><p id="bd3e" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">反应式编程通常用电子表格来解释。想象一个单元格包含另外两个单元格的总和。如果您更改一个单元格的值，包含总和的单元格也会立即更新—它<em class="lf">对另一个单元格的更新做出</em>反应。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/b9843c01e8c2e61ea8088d1ec8d7b6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*3ybgqfAQcxGrgXJ0WdenQw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">电子表格:两个单元格的总和</figcaption></figure><p id="1bf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据经典的功能反应式编程，单元的值是<em class="lf">行为</em>。它们包含随时间变化的值。总和是时间的<em class="lf">函数</em>,取决于其他两个单元格的值。</p><p id="131c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">行为有时也被称为<em class="lf">信号</em>。在下文中，我也称它为<em class="lf">信号</em>,因为我觉得用这个词更合适。(一个信号并不只是以它想要的方式“表现”,而是反映了一个可能反过来依赖于其他信号的值。)还有，Scala。React也称之为信号。</p><p id="eafe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们将看到一个非常相似但稍微简单的例子，不要把事情复杂化。我们将看一个银行账户类的例子，让你存钱和取钱。然后，合并器会汇总你告诉它所依赖的银行账户，这样你就可以随时知道你的总余额。(合并器类似于电子表格示例中的求和单元格。)</p><p id="15d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说得够多了，让我们来看一些代码。我们追求的是能够编写如下所示的代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b142" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类只是让你存钱和取钱，并跟踪你银行账户的余额。<code class="fe mz na nb nc b">consolidated</code>函数返回一个<code class="fe mz na nb nc b">Signal</code>，对您传递给它的<code class="fe mz na nb nc b">BankAccount</code>的余额求和。</p><p id="1ce4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很优雅，不是吗？最后，只要你愿意，你就可以简单地打电话给<code class="fe mz na nb nc b">total()</code>，获得你两个银行账户的当前价值。你不必像在<a class="ae ko" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>中那样跟踪观察者和主题。实际上，你会有一个连续的值(如FRP的“行为”)，它依赖于其他值并自动更新。</p><p id="355a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们要如何实现这些神秘的<code class="fe mz na nb nc b">Signal</code>和<code class="fe mz na nb nc b">Var</code>呢？让我们开始吧。</p><h1 id="45f1" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">理解<code class="fe mz na nb nc b">Var</code></h1><p id="cafe" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">首先，为了简单起见，让我们忽略这样一个事实，即我们想要以上面显示的方式合并不同的银行账户。我们只看一下<code class="fe mz na nb nc b">BankAccount</code>这个职业本身。我们如何实现<code class="fe mz na nb nc b">Var</code>来让下面的代码工作？</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然理解这段代码中发生的事情应该很简单，但是如果你对scala有基本的了解，这里有很多scala的语法糖的例子。不了解它们，您可能很难实现<code class="fe mz na nb nc b">Var</code>。所以让我们快速浏览一下。</p><h2 id="33e3" class="nd lu it bd lv ne nf dn lz ng nh dp md kb ni nj mh kf nk nl ml kj nm nn mp no bi translated"><code class="fe mz na nb nc b">apply</code>在伴物体中</h2><p id="18a2" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">正如您可能知道的，如果您在一个类的伴随对象中定义了一个<code class="fe mz na nb nc b">apply</code>方法，那么您可以创建一个没有<code class="fe mz na nb nc b">new</code>关键字的类的实例。伴随对象被定义为与它“伴随”的类同名的对象。要使语句<code class="fe mz na nb nc b">val balance = Var(0)</code>工作，您需要执行以下操作:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5919" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们只定义了类<code class="fe mz na nb nc b">Var</code>，它接受一个整数和一个带有apply方法的compantion对象，该方法返回一个<code class="fe mz na nb nc b">Var</code>的实例。此外，我们为<code class="fe mz na nb nc b">Var</code>添加了一个变量<code class="fe mz na nb nc b">curVal</code>，以便能够在以后更改该类的值。</p><h2 id="641a" class="nd lu it bd lv ne nf dn lz ng nh dp md kb ni nj mh kf nk nl ml kj nm nn mp no bi translated">b) <code class="fe mz na nb nc b">apply</code>作为类方法</h2><p id="b611" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">当添加一个方法<code class="fe mz na nb nc b">apply</code>到一个类(不是它的伴随对象)时，类的实例可以像方法一样被调用。编译器自动将其转换成对classes <code class="fe mz na nb nc b">apply</code>方法的调用。举个例子，</p><p id="c969" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">balance()</code></p><p id="9b8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将被编译器转换成</p><p id="0f69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">balance.apply()</code>。</p><p id="1544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些知识，添加使我们能够通过调用<code class="fe mz na nb nc b">balance()</code>来检索<code class="fe mz na nb nc b">balance</code>的当前值的功能就变得非常简单了:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3f00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当我们将<code class="fe mz na nb nc b">balance</code>定义为<code class="fe mz na nb nc b">Var</code>的实例并调用<code class="fe mz na nb nc b">balance()</code>时，我们将检索存储在<code class="fe mz na nb nc b">curVal</code>中的当前值。</p><p id="3634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">(实际上，</em><code class="fe mz na nb nc b"><em class="lf">apply</em></code><em class="lf">)-trick对同伴对象的工作方式和对类方法完全一样。当你调用</em> <code class="fe mz na nb nc b"><em class="lf">Var()</em></code> <em class="lf">时，编译器会将此转换为</em> <code class="fe mz na nb nc b"><em class="lf">Var.apply()</em></code> <em class="lf">。由于没有实例就不能调用类方法，这就调用了伴随对象的</em> <code class="fe mz na nb nc b"><em class="lf">apply</em></code> <em class="lf">方法。当调用</em> <code class="fe mz na nb nc b"><em class="lf">balance()</em></code> <em class="lf">时，这就唤起了该类的</em> <code class="fe mz na nb nc b"><em class="lf">apply</em></code> <em class="lf">方法，即</em> <code class="fe mz na nb nc b"><em class="lf">balance</em></code> <em class="lf">是的一个实例。)</em></p><h2 id="8725" class="nd lu it bd lv ne nf dn lz ng nh dp md kb ni nj mh kf nk nl ml kj nm nn mp no bi translated">c) <code class="fe mz na nb nc b">update</code>作为类方法</h2><p id="cab0" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">正如我们所见，scala编译器将<code class="fe mz na nb nc b">balance()</code>转换为<code class="fe mz na nb nc b">balance.apply()</code>。同样，这条线</p><p id="ef21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">balance() = 5</code></p><p id="97f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">被转换成</p><p id="cc08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">balance.update(5)</code>。</p><p id="03bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能已经不知不觉地用了这个语法糖很多次了。当有一些数组<code class="fe mz na nb nc b">arr</code>时，代码<code class="fe mz na nb nc b">arr(1) = 5</code>被转换成<code class="fe mz na nb nc b">arr.update(1,5)</code></p><p id="8311" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">了解了这一点，让线<code class="fe mz na nb nc b">balance() = curBalance + x</code>工作起来应该是相当直截了当的。使上面的BankAccount类工作的完整代码如下:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="75cf" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">理解信号</h1><p id="9e28" class="pw-post-body-paragraph jq jr it js b jt mr jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj mv kl km kn im bi translated">在这个例子中，到目前为止，我已经忽略了<code class="fe mz na nb nc b">Signal</code>的实现。你可能已经注意到，函数<code class="fe mz na nb nc b">consolidated</code>应该返回一个<code class="fe mz na nb nc b">Signal</code>，到目前为止我们只涉及了<code class="fe mz na nb nc b">Var</code>。</p><p id="ad1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，<code class="fe mz na nb nc b">Var</code>应该是<code class="fe mz na nb nc b">Signal</code>的子类。我们所追求的是，我们希望能够用<code class="fe mz na nb nc b">Signal</code>定义一个不可变的信号(一个总是有相同值的信号)，以及一个其值可以用<code class="fe mz na nb nc b">Var</code>改变的信号。</p><p id="ae17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以在定义了<code class="fe mz na nb nc b">val s = Signal(3)</code>之后，无论如何<code class="fe mz na nb nc b">s</code>的值都将保持为3。然而，正如我们已经看到的，我们可以像这样更新<code class="fe mz na nb nc b">Var</code>余额，将其值更改为20:</p><pre class="kq kr ks kt gt np nc nq nr aw ns bi"><span id="6907" class="nd lu it nc b gy nt nu l nv nw">val balance = Var(0)<br/>balance() = 20</span></pre><p id="f7b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(注意balance本身是用<code class="fe mz na nb nc b">val</code>定义的不可变值。只有<code class="fe mz na nb nc b">Var</code>实例的私有变量发生变化，而我们不能给<code class="fe mz na nb nc b">Var</code>的新实例赋值<code class="fe mz na nb nc b">balance</code>本身。)</p><p id="38c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问自己:如果一个<code class="fe mz na nb nc b">Signal</code>是不可变的，那么它有什么用处呢？难道<code class="fe mz na nb nc b">consolidated</code>不应该在每次更新余额时自动更新吗？</p><p id="2623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，<code class="fe mz na nb nc b">consolidated</code>的值是它所依赖的<code class="fe mz na nb nc b">BankAccount</code> s值的<em class="lf">函数</em>。功能不应该改变。只有这个函数返回的值会随着时间而改变。如果这还不清楚，希望以后会变得更清楚。</p><p id="5a81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么回到我们对<code class="fe mz na nb nc b">Var</code>的定义，我们如何扩展上面的实现来更新<code class="fe mz na nb nc b">balance</code>？让我们来看看:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f3c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里所做的是，我们基本上只是从上面获取了<code class="fe mz na nb nc b">Var</code>的实现，并将其命名为<code class="fe mz na nb nc b">Signal</code>。为了反映你不能从类外(或子类)修改信号的事实，我们在<code class="fe mz na nb nc b">update</code>方法中添加了<code class="fe mz na nb nc b">protected</code>关键字。最后，<code class="fe mz na nb nc b">Var</code>扩展了<code class="fe mz na nb nc b">Signal</code>并且<code class="fe mz na nb nc b">update</code>方法在没有<code class="fe mz na nb nc b">protected</code>关键字的情况下被覆盖，以便能够从外界使用该方法。</p><p id="33cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来不错，对吧？现在我们有了所有需要的构件。我们已经定义了<code class="fe mz na nb nc b">Signal</code> s和<code class="fe mz na nb nc b">Var</code> s，类型检查器很满意。所以让我们试一试吧！</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8a79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，不幸的是，这还没完全实现。</p><p id="628e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事情是这样的:函数<code class="fe mz na nb nc b">consolidated</code>检索每个账户的余额，将它们相加，并返回一个带有计算结果的信号。如果你看一下<code class="fe mz na nb nc b">Signal</code>的类定义，<code class="fe mz na nb nc b">initVal</code>就是按值调用。这意味着它的整数值是在初始化时计算的，并且永远保持不变。代码片段中的以下微小变化说明了这一点:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5cee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，在定义<code class="fe mz na nb nc b">total</code>之前，我们在银行账户<code class="fe mz na nb nc b">a</code>的余额上加了20。因此<code class="fe mz na nb nc b">total()</code>等于20，不管我们之后可能对账户余额做什么改变。</p><p id="a31b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的下一部分<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/functional-reactive-programming-in-scala-from-scratch-part-2-3d1559a11629">中，我们将看看如何解决这个问题，敬请关注！如果到目前为止您有任何意见或建议，我将非常感谢您的反馈。</a></p></div></div>    
</body>
</html>