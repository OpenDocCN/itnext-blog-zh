<html>
<head>
<title>How to Avoid N+1 Problem in Apollo Federation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免阿波罗联邦中的N+1问题</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-avoid-n-1-problem-in-apollo-federation-8b4f37729fc4?source=collection_archive---------3-----------------------#2019-09-14">https://itnext.io/how-to-avoid-n-1-problem-in-apollo-federation-8b4f37729fc4?source=collection_archive---------3-----------------------#2019-09-14</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="d676" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果你使用了<a class="ae km" href="https://graphql.org" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>，你很可能遇到或听说过N+1问题。</p><figure class="ko kp kq kr gu ks gi gj paragraph-image"><div class="gi gj kn"><img src="../Images/694efd231fb029c9e4b722f1644f1034.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*ehCNN3gYxUq3s8n2"/></div></figure><h1 id="5081" class="kv kw ir bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">这是什么？</h1><p id="ec91" class="pw-post-body-paragraph jo jp ir jq b jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl ik bi translated">当我们执行下面的查询来获取前100篇评论和相应的作者姓名时，我们首先进行一次调用来从数据库中检索100条评论记录，然后对于每篇评论，我们对数据库进行另一次调用来获取给定作者ID的用户详细信息。</p><p id="4ad0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">查询</strong></p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="0053" class="md kw ir lz b gz me mf l mg mh">{<br/>  top100Reviews {<br/>    body<br/>    author {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="5e30" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">模式</strong></p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="36c9" class="md kw ir lz b gz me mf l mg mh">const typeDefs = gql`<br/>  type User {<br/>    id: ID!<br/>    name: String<br/>  }</span><span id="a5d7" class="md kw ir lz b gz mi mf l mg mh">  type Review {<br/>    id: ID!<br/>    body: String<br/>    author: User<br/>    product: Product<br/>  }</span><span id="6804" class="md kw ir lz b gz mi mf l mg mh">  type Query {<br/>    top100Reviews: [Review]<br/>  }<br/>`;</span></pre><p id="6b07" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">解析器</strong></p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="8e8c" class="md kw ir lz b gz me mf l mg mh">const resolver = {<br/>  Query: {<br/>    top100Reviews: () =&gt; get100Reviews(),<br/>  },<br/>  Review: {<br/>    author: (review) =&gt; getUser(review.authorId),<br/>  },<br/>};</span></pre><p id="de8f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">要打很多电话。也是很大的网络开销。</p><p id="e5b4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><a class="ae km" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank"> DataLoader </a>可以通过<strong class="jq is">将用户详细信息的每个单独加载合并</strong>到单个调用中来帮助您减少开销。我们需要做的只是提供一个批处理函数的实现。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="6d74" class="md kw ir lz b gz me mf l mg mh"><strong class="lz is">const DataLoader = require('dataloader');<br/>const userLoader = new DataLoader(ids =&gt; batchGetUsers(ids));</strong></span><span id="852e" class="md kw ir lz b gz mi mf l mg mh">const resolvers = {<br/>  Query: {<br/>    top100Reviews: () =&gt; get100Reviews(),<br/>  },<br/>  Review: {<br/>    author: (review) =&gt; <strong class="lz is">userLoader.load</strong>(review.authorId),<br/>  },<br/>};</span></pre><p id="bb0f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">当每个<code class="fe mj mk ml lz b">userLoader.load(review.authorId)</code>被调用时，它被分批并最终调用<code class="fe mj mk ml lz b">batchGetUsers()</code>。因此，不需要100次单独调用数据库来获取用户详细信息，同样的事情只需一次调用就可以完成。</p><h1 id="0730" class="kv kw ir bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">N+1和阿波罗联邦有什么关系？</h1><p id="213e" class="pw-post-body-paragraph jo jp ir jq b jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl ik bi translated">Apollo中查询规划器部分地但不是全部地为您处理N+1。以<a class="ae km" href="https://github.com/apollographql/federation-demo" rel="noopener ugc nofollow" target="_blank">联邦演示</a>为例，我们有一个<strong class="jq is">用户服务</strong>，它只处理用户。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="0d1c" class="md kw ir lz b gz me mf l mg mh">// User service</span><span id="8a20" class="md kw ir lz b gz mi mf l mg mh">const typeDefs = gql`<br/>  type User @key(fields: "id") {<br/>    id: ID!<br/>    name: String<br/>    username: String<br/>  }<br/>`;</span><span id="b75a" class="md kw ir lz b gz mi mf l mg mh">const resolvers = {<br/>  User: {<br/>    __resolveReference(object) {<br/>      return getUser(object.id);<br/>    }<br/>  }<br/>};</span></pre><p id="4de0" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">另一个<strong class="jq is">评论服务</strong>只处理评论，尽管在<code class="fe mj mk ml lz b">Review</code>中我们引用了<code class="fe mj mk ml lz b">User</code>类型，我们知道它将由用户服务处理。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="2753" class="md kw ir lz b gz me mf l mg mh">// Review service</span><span id="31e7" class="md kw ir lz b gz mi mf l mg mh">const typeDefs = gql`<br/>  type Review @key(fields: "id") {<br/>    id: ID!<br/>    body: String<br/>    author: User<br/>    product: Product<br/>  }<br/><br/>  extend type User @key(fields: "id") {<br/>    id: ID! @external<br/>  }</span><span id="7bb5" class="md kw ir lz b gz mi mf l mg mh">  extend type Product @key(fields: "upc") {<br/>    upc: String! @external<br/>  }</span><span id="9b43" class="md kw ir lz b gz mi mf l mg mh">  extend type Query {<br/>    top100Reviews: [Review]<br/>  }<br/>`;</span><span id="722b" class="md kw ir lz b gz mi mf l mg mh">const resolvers = {<br/>  Review: {<br/>    author(review) {<br/>      return { __typename: "User", id: review.authorId };<br/>    }<br/>  },<br/>  // ...<br/>};</span></pre><p id="3290" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在网关处，这些独立的模式被联合成一个单一的模式，如果我们像以前一样执行相同的查询，<code class="fe mj mk ml lz b">top100Reviews</code>查询被委托给<strong class="jq is">审查服务</strong>并由其解析，而解析<code class="fe mj mk ml lz b">author</code>被委托给<strong class="jq is">用户服务</strong>。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="049c" class="md kw ir lz b gz me mf l mg mh">{<br/>  top100Reviews {<br/>    body<br/>    author {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="f774" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">起初，我们可能会怀疑解析<code class="fe mj mk ml lz b">author</code>会多次调用<strong class="jq is">用户服务</strong>，但事实并非如此。我们可以通过在<strong class="jq is">上下文</strong>选项中记录传入的请求体来验证声明。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="c240" class="md kw ir lz b gz me mf l mg mh">// User service</span><span id="73b3" class="md kw ir lz b gz mi mf l mg mh">const server = new ApolloServer({<br/>  schema: buildFederatedSchema([{ typeDefs, resolvers}]),<br/>  <strong class="lz is">context: ({ req }) =&gt; {<br/>    console.log(JSON.stringify(req.body, null, 2));<br/>  },</strong><br/>});</span></pre><p id="60c6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我们看到查询规划器将所有的用户id批处理到一个数组中，并将一个由<strong class="jq is">表示的数组</strong>发送给负责解析引用的<strong class="jq is">用户服务</strong>。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="848e" class="md kw ir lz b gz me mf l mg mh">{<br/>  "query": "query ($representations: [_Any!]!) {\n  _entities(representations: $representations) {\n    ... on User {\n      name\n    }\n  }\n}",<br/>  "variables": {<br/>    <strong class="lz is">"representations": [<br/>      {<br/>        "__typename": "User",<br/>        "id": "1"<br/>      },<br/>      {<br/>        "__typename": "User",<br/>        "id": "2"<br/>      },<br/>      {<br/>        "__typename": "User",<br/>        "id": "1"<br/>      },<br/>      {<br/>        "__typename": "User",<br/>        "id": "2"<br/>      },<br/></strong>      // ... too long to list them all<br/>    ]<br/>  }<br/>}</span></pre><p id="3a8c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">然后，<strong class="jq is">用户服务</strong>将映射每个单独的ID，并调用<code class="fe mj mk ml lz b">__resolveReference()</code>来解析每个用户ID。尽管网关不会多次调用<strong class="jq is">用户服务</strong>，但是由于<code class="fe mj mk ml lz b">getUser()</code>，解析引用仍然需要多次调用数据库。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="3c73" class="md kw ir lz b gz me mf l mg mh">// User service</span><span id="d385" class="md kw ir lz b gz mi mf l mg mh">const resolvers = {<br/>  User: {<br/>    __resolveReference(object) {<br/>      return <strong class="lz is">getUser(object.id)</strong>;  // <strong class="lz is">Bad</strong><br/>    }<br/>  }<br/>};</span></pre><h1 id="aa79" class="kv kw ir bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">解决方案</h1><p id="2a02" class="pw-post-body-paragraph jo jp ir jq b jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl ik bi translated">我们可以通过使用相同的<code class="fe mj mk ml lz b">userLoader.load()</code>而不是<code class="fe mj mk ml lz b">getUser()</code>来解决这个问题。数据加载器批量处理所有用户id，并高效地对数据库进行一次调用。</p><pre class="ko kp kq kr gu ly lz ma mb aw mc bi"><span id="12c9" class="md kw ir lz b gz me mf l mg mh">// User service</span><span id="04d1" class="md kw ir lz b gz mi mf l mg mh">const resolvers = {<br/>  User: {<br/>    __resolveReference(object) {<br/>      return <strong class="lz is">userLoader.load(object.id);</strong>  // <strong class="lz is">Good</strong><br/>    }<br/>  }<br/>};</span></pre><h1 id="ff1e" class="kv kw ir bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">摘要</h1><p id="be8b" class="pw-post-body-paragraph jo jp ir jq b jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh lx kj kk kl ik bi translated">我们解释了N+1查询的缺陷以及如何使用数据加载器解决这个问题。我们还发现，Apollo Gateway通过批处理引用有效地处理了对服务的委托，但是我们的解析器仍然需要显式地使用数据加载器来避免对数据库的多次调用。</p></div></div>    
</body>
</html>