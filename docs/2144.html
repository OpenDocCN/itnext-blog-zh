<html>
<head>
<title>NGRX — from the beginning, part III, NGRX Store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NGRX —从头开始，第三部分，NGRX商店</h1>
<blockquote>原文：<a href="https://itnext.io/ngrx-from-the-beginning-part-iii-ngrx-store-d094ac72e1fa?source=collection_archive---------4-----------------------#2019-04-06">https://itnext.io/ngrx-from-the-beginning-part-iii-ngrx-store-d094ac72e1fa?source=collection_archive---------4-----------------------#2019-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ebe77b1f517d2de81c50ad19c11dccb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbGcoZEqfHlBHyeaajlgbA.jpeg"/></div></div></figure><p id="2651" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><blockquote class="kx ky kz"><p id="1e64" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> NGRX是模式Redux的一个实现。它是为框架Angular做的，用RxJS </em>增加了打字稿和反应性</p></blockquote><p id="a066" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是系列文章的一部分:</p><ul class=""><li id="a5df" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/ngrx-from-the-beginning-part-i-a76c3c690ac7"> NGRX —从头开始</a>，第一部分，发布-订阅，</li><li id="4a5a" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/ngrx-from-the-beginning-part-ii-redux-6305b481c55"> NGRX —从头开始，第二部分</a>，第二部分重复</li><li id="653d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第三部分，NGRX商店，<strong class="ka ir">我们在这里</strong></li><li id="9d46" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX——从第四部分开始，NGRX store，用枚举和接口改进它，正在进行中</li><li id="b07b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第五部分，NGRX效果，<em class="la">进行中</em></li><li id="a2d3" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">NGRX —从头开始，第六部分，NGRX实体，<em class="la">进行中</em></li></ul><p id="f2d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你阅读这一部分时不知道Redux或Pub-Sub是什么，我建议你先阅读第一部分和第二部分。我们不会解释Reducer或Action之类的东西，也不会解释我们如何<em class="la">发送</em>消息，因为那会让这篇文章太长。</p><p id="dc8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将介绍</p><ul class=""><li id="c705" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">设置并安装</strong>，我们将解释如何搭建一个项目并安装必要的依赖项，我们还将添加我们的第一个状态属性和缩减函数</li><li id="e1a1" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">显示数据</strong>，这里我们将介绍如何注入商店服务以及如何在我们的标记中显示来自商店的数据</li><li id="5c01" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">更改状态</strong>，在我们展示了如何显示数据之后，我们将在这里关注如何更改数据，或者如Redux所指，如何调度一个动作</li></ul><h1 id="2bf0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置和安装</h1><p id="3db8" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好的，我们需要做以下事情:</p><ol class=""><li id="97d4" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">搭建一个有棱角的工程</li><li id="3cc0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">安装@ngrx/store</li><li id="b51b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">设置@ngrx/store</li></ol><h1 id="524b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">安装</h1><p id="fbb5" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，首先，让我们通过在终端中键入以下命令来创建一个Angular项目:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="cd7a" class="nf lt iq nb b gy ng nh l ni nj">ng new NameOfMyProject cd NameOfMyProject</span></pre><p id="f10c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此后，我们留在航站楼，进入:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="2fd2" class="nf lt iq nb b gy ng nh l ni nj">npm install @ngrx/store</span></pre><p id="7139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这安装了我们的库，我们准备好配置我们的项目到<code class="fe nk nl nm nb b">@ngrx/store</code>。</p><h1 id="928b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">建立</h1><p id="7107" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好，我们有一个项目，让我们设置它。我们需要做两件事:</p><ol class=""><li id="115f" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">导入<code class="fe nk nl nm nb b">StoreModule</code></li><li id="855d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">调用<code class="fe nk nl nm nb b">StoreModule.forRoot()</code>,并为其提供一个由多个状态、缩减器对组成的对象</li></ol><p id="d74d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们打开<code class="fe nk nl nm nb b">app.module.ts</code>，进入:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e37d" class="nf lt iq nb b gy ng nh l ni nj">import { StoreModule } from '@ngrx/store';</span></pre><p id="cddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们给<code class="fe nk nl nm nb b">StoreModule.forRoot()</code>打电话。如上所述我们需要给它一个由若干状态组成的对象，还原成对，就像这样:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d0f9" class="nf lt iq nb b gy ng nh l ni nj">{ <br/>  state: stateReducer, <br/>  secondState: secondStateReducer <br/>  ... <br/>}</span></pre><p id="8485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们了解了整体形状，那么让我们用实际代码展示一下它可能是什么样子:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="11c1" class="nf lt iq nb b gy ng nh l ni nj">const counterReducer = (state = 0, action) =&gt; { <br/>  switch (action.type) { <br/>    case 'INCREMENT': return state + 1; <br/>    default: return state; <br/>  } <br/>}</span></pre><p id="b6c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在同一个文件<code class="fe nk nl nm nb b">app.module.ts</code>中，我们需要将我们的<code class="fe nk nl nm nb b">StoreModule</code>添加到我们的<code class="fe nk nl nm nb b">imports</code>列表中，就像这样:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="4dae" class="nf lt iq nb b gy ng nh l ni nj">imports: [ <br/>  BrowserModule, <br/>  AppRoutingModule, <br/>  StoreModule.forRoot({ <br/>    counter: counterReducer <br/>  }) <br/>]</span></pre><p id="1ac8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们现在给<code class="fe nk nl nm nb b">StoreModule.forRoot()</code>提供了一个包含<code class="fe nk nl nm nb b">counter</code>、<code class="fe nk nl nm nb b">counterReducer</code>对的对象。</p><h1 id="1496" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">显示数据</h1><p id="d7a8" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好了，这包括了让@ngrx/store工作所需的最基本的设置。然而，我们不能在这一点上显示我们的数据。为了显示数据，我们需要将<code class="fe nk nl nm nb b">Store</code>服务注入到旨在显示数据的组件的构造函数中。让我们进入<code class="fe nk nl nm nb b">app.component.ts</code>并添加所需的导入:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="1ab8" class="nf lt iq nb b gy ng nh l ni nj">import { Store } from '@ngrx/store';</span></pre><p id="9f34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及组件类构造函数所需的注入:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="cc19" class="nf lt iq nb b gy ng nh l ni nj">constructor(private store: Store&lt;any&gt;) {}</span></pre><p id="6aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一点上，你可能会对使用<code class="fe nk nl nm nb b">any</code>作为<code class="fe nk nl nm nb b">Store</code>的模板参数感到疑惑，让我们暂时把它放在一边，然后再稍微改进一下。</p><h1 id="bd4e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">选择数据</h1><p id="2887" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好的，如果我们使用方法<code class="fe nk nl nm nb b">pipe()</code>和操作符<code class="fe nk nl nm nb b">select()</code>,<code class="fe nk nl nm nb b">Store</code>服务会让我们从它的内部状态中选择数据，就像这样:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3ed2" class="nf lt iq nb b gy ng nh l ni nj">import { Store, select } from '@ngrx/store'; </span><span id="a751" class="nf lt iq nb b gy nn nh l ni nj">@Component({ <br/>  ... <br/>}) <br/>export class AppComponent { <br/>  counter$; </span><span id="ee8b" class="nf lt iq nb b gy nn nh l ni nj">  constructor(private store: Store&lt;any&gt;) { <br/>    this.counter$ = this.store.pipe( <br/>      select('counter') <br/>    ) <br/>  } <br/>}</span></pre><p id="9767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从<code class="fe nk nl nm nb b">@ngrx/store</code>导入了<code class="fe nk nl nm nb b">select()</code>操作符，并且我们还将<code class="fe nk nl nm nb b">pipe()</code>调用的结果赋给了一个变量<code class="fe nk nl nm nb b">counter$</code>。<code class="fe nk nl nm nb b">counter$</code>是可观察的，这意味着我们可以使用<code class="fe nk nl nm nb b">async</code>管道来显示内容。现在让我们转到我们的<code class="fe nk nl nm nb b">app.component.html</code>文件，键入以下内容:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="645a" class="nf lt iq nb b gy ng nh l ni nj">My counter: {{ counter$ | async }}</span></pre><p id="7798" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保存安润你的项目，你的浏览器现在应该显示<code class="fe nk nl nm nb b">My counter: 0</code></p><h1 id="0e82" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">带有功能选择器</h1><p id="3017" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">到目前为止一切正常，但是让我们回到如何在<code class="fe nk nl nm nb b">AppComponent</code>构造函数中注入我们的<code class="fe nk nl nm nb b">Store</code>服务。我们给了它模板参数<code class="fe nk nl nm nb b">any</code>。我们肯定可以改善这一点，但如何改善呢？想法是给它一个表示你的商店状态的接口。目前，您的商店状态如下所示:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="895c" class="nf lt iq nb b gy ng nh l ni nj">{ counter }</span></pre><p id="04c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们创建一个与此相对应的接口，即:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="5857" class="nf lt iq nb b gy ng nh l ni nj">// app-state.ts </span><span id="ecd3" class="nf lt iq nb b gy nn nh l ni nj">export interface AppState { <br/>  counter: number; <br/>}</span></pre><p id="4e8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们声明了唯一的状态属性<code class="fe nk nl nm nb b">counter</code>并且声明了它的类型。好了，下一步是使用<code class="fe nk nl nm nb b">AppState</code>作为我们的商店模板，所以让我们更新<code class="fe nk nl nm nb b">app.component.ts</code>。首先，添加这个导入:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="658b" class="nf lt iq nb b gy ng nh l ni nj">import { AppState } from './app-state';</span></pre><p id="e87b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们用<code class="fe nk nl nm nb b">AppState</code>代替<code class="fe nk nl nm nb b">any</code>:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6fdd" class="nf lt iq nb b gy ng nh l ni nj">constructor(private store: Store&lt;AppState&gt;){}</span></pre><p id="6220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以做得更多，我们可以通过从接受字符串的<code class="fe nk nl nm nb b">select()</code>方法切换到接受函数的方法来利用这一点，就像这样:</p><p id="128a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这个:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9109" class="nf lt iq nb b gy ng nh l ni nj">this.counter$ = this.store.pipe( <br/>  select('counter') <br/>)</span></pre><p id="9a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变成了:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="5324" class="nf lt iq nb b gy ng nh l ni nj">this.counter$ = this.store.pipe( <br/>  select(state =&gt; state.counter)<br/>)</span></pre><p id="278d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你问这个有什么了不起的？现在，如果我们试图从不存在的状态中选择一个属性，我们会得到编译器的帮助，只有<code class="fe nk nl nm nb b">state.counter</code>是有效的选择。同样，如果我们的状态是嵌套的，这是我们能够到达像<code class="fe nk nl nm nb b">state.products.data</code>这样的状态的唯一方法，例如，如果我们有一个状态<code class="fe nk nl nm nb b">products</code>。</p><h1 id="d15c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">改变状态</h1><p id="ec7f" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">好的，很好，我们可以从我们的商店显示一个状态属性，改变它怎么样？为此，我们有一个<code class="fe nk nl nm nb b">dispatch()</code>方法，允许我们向商店发送消息。该消息采用动作对象的形式。好了，让我们构建一下我们的UI。进入<code class="fe nk nl nm nb b">app.component.html</code>并添加以下内容:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="103d" class="nf lt iq nb b gy ng nh l ni nj">// app.component.html &lt;button </span><span id="7184" class="nf lt iq nb b gy nn nh l ni nj">(click)="increment()"&gt;Increment&lt;/button&gt;</span></pre><p id="4014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，转到<code class="fe nk nl nm nb b">app.component.ts</code>并添加方法<code class="fe nk nl nm nb b">increment()</code>，就像这样:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="247f" class="nf lt iq nb b gy ng nh l ni nj">@Component({}) export class AppComponent { <br/>  increment() { <br/>    // add dispatch call here } <br/>  }<br/>}</span></pre><p id="dfbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，我们需要做以下事情来向商店发送消息:</p><ul class=""><li id="e787" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">构造一个消息类型为<code class="fe nk nl nm nb b">INCREMENT</code>的动作对象</li><li id="f594" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">在商店服务实例上调用<code class="fe nk nl nm nb b">dispatch()</code></li></ul><p id="1aa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好，要构造一个对象，我们可以使用一个对象文字，就像这样:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="04de" class="nf lt iq nb b gy ng nh l ni nj">const action = { type: 'INCREMENT' };</span></pre><p id="3078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用消息增量的原因在于我们如何构造<code class="fe nk nl nm nb b">counterReducer</code>函数，让我们快速看一下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c9c8" class="nf lt iq nb b gy ng nh l ni nj">const counterReducer = (state = 0, action) =&gt; { <br/>  switch (action.type) { <br/>    case 'INCREMENT': return state + 1; <br/>    default: return state; <br/>  } <br/>}</span></pre><p id="7c46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很明显，它期望消息具有属性<code class="fe nk nl nm nb b">type</code>，并且消息类型值为<code class="fe nk nl nm nb b">INCREMENT</code>。好的，看起来不错，让我们打电话给<code class="fe nk nl nm nb b">dispatch()</code>:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="fdc5" class="nf lt iq nb b gy ng nh l ni nj">@Component({}) <br/>export class AppComponent { <br/>  // constructor omitted for brevity <br/>  increment() { <br/>    const action = { type: 'INCREMENT' };<br/>    this.store.dispatch(action); <br/>  } <br/>}</span></pre><p id="759b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用<code class="fe nk nl nm nb b">increment()</code>将导致我们的消息被发送到商店，调用<code class="fe nk nl nm nb b">counterReducer()</code>并将我们的<code class="fe nk nl nm nb b">counter</code>值更新1。你自己试试。</p><h1 id="a091" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="b3ac" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">这就是我们计划在这一部分讨论的全部内容。我们已经展示了如何安装<code class="fe nk nl nm nb b">@ngrx/store</code>以及如何在<code class="fe nk nl nm nb b">StoreModule.forRoot()</code>中设置状态、减速器对。此外，我们还展示了如何从<code class="fe nk nl nm nb b">Store</code>服务中选择数据，以及如何使用提到的<code class="fe nk nl nm nb b">Store</code>服务及其<code class="fe nk nl nm nb b">dispatch()</code>方法来更新数据。在下一部分中，我们将看到一个更丰富的例子，看看我们如何使用枚举和内置接口来改进，敬请关注:)</p></div></div>    
</body>
</html>