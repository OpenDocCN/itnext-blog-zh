<html>
<head>
<title>Comparing Dart’s loops — which is the fastest?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较Dart的循环，哪个最快？</h1>
<blockquote>原文：<a href="https://itnext.io/comparing-darts-loops-which-is-the-fastest-731a03ad42a2?source=collection_archive---------0-----------------------#2021-07-25">https://itnext.io/comparing-darts-loops-which-is-the-fastest-731a03ad42a2?source=collection_archive---------0-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/26fea9642cc0cc40023a8f42bf80029c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNv0s08sZklOdM34Q1MQ0Q.jpeg"/></div></div></figure><p id="1e6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">art是一种用来编写Flutter应用程序的语言，它有许多不同的循环，可以遍历列表或运行一些代码指定的次数。在循环中有<em class="lf">和</em>循环、<em class="lf">为</em> <strong class="ka ir"> </strong>循环、<em class="lf">为……<em class="lf"> forEach </em>方法。<em class="lf">绘制</em>方法及更多。在本文中，我们将测试这些不同的循环方法，看看哪种是最快的！</em></p><p id="1f28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这些测试，我们将使用由<a class="ae lg" href="https://pub.dev/publishers/tools.dart.dev" rel="noopener ugc nofollow" target="_blank"> tools.dart.dev </a>提供的<a class="ae lg" href="https://pub.dev/packages/benchmark_harness" rel="noopener ugc nofollow" target="_blank"> benchmark_harness </a>包。</p><h1 id="9430" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">优化</h1><p id="dbf7" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">对于或<em class="lf">的<em class="lf">有一些优化，而</em>循环已经在JavaScript等其他语言中使用，例如:缓存列表的长度和颠倒循环的顺序。</em></p><h1 id="f4b5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">缓存长度</h1><p id="8597" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">缓存列表的长度包括在循环之前将我们将要循环的列表的长度设置为一个变量。以下是一个长度未缓存的<em class="lf"> while </em>循环的示例:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="86ed" class="mt li iq mp b gy mu mv l mw mx">var count = 0;</span><span id="3e5e" class="mt li iq mp b gy my mv l mw mx">num eachElement = 0;</span><span id="78ef" class="mt li iq mp b gy my mv l mw mx">while (count &lt; <strong class="mp ir">list.length</strong>) {</span><span id="9dc8" class="mt li iq mp b gy my mv l mw mx">  eachElement = pow(list[count], 3);</span><span id="ca4a" class="mt li iq mp b gy my mv l mw mx">  count++;</span><span id="126d" class="mt li iq mp b gy my mv l mw mx">}</span></pre><p id="faec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个带有缓存长度的<em class="lf"> while </em>循环的例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="23ca" class="mt li iq mp b gy mu mv l mw mx">var count = 0;</span><span id="a159" class="mt li iq mp b gy my mv l mw mx">num eachElement = 0;</span><span id="84be" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">var length = list.length;</strong></span><span id="f2ec" class="mt li iq mp b gy my mv l mw mx">while (count &lt; <strong class="mp ir">length</strong>) {</span><span id="cf4f" class="mt li iq mp b gy my mv l mw mx">  eachElement = pow(list[count], 3);</span><span id="16c1" class="mt li iq mp b gy my mv l mw mx">  count++;</span><span id="e135" class="mt li iq mp b gy my mv l mw mx">}</span></pre><p id="0695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们在循环之前缓存列表的长度时，列表的长度只计算一次，而不是在每次迭代时重新计算。然而，当我们不缓存长度时，每次迭代都会计算长度。对于包含大量元素的列表，这应该会显著提高性能。</p><h1 id="cbed" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">颠倒顺序</h1><p id="e1ff" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">颠倒循环的顺序包括将迭代器设置为列表的长度减1(因为列表从0开始计数)，然后向后迭代(例如，每次迭代后从迭代器中减去1)，直到迭代器等于0。下面是一个循环的<em class="lf">示例，具有常规顺序:</em></p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0bcb" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="128a" class="mt li iq mp b gy my mv l mw mx">for (var i = 0; i &lt; <strong class="mp ir">list.length</strong>; i++) {</span><span id="a078" class="mt li iq mp b gy my mv l mw mx">  eachElement = pow(list[i], 3);</span><span id="1606" class="mt li iq mp b gy my mv l mw mx">}</span></pre><p id="121e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是一个顺序相反的循环的<em class="lf">示例:</em></p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="72fa" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="1664" class="mt li iq mp b gy my mv l mw mx">for (var i = <strong class="mp ir">list.length - 1</strong>; i &gt;= 0; i--) {</span><span id="bf36" class="mt li iq mp b gy my mv l mw mx">  eachElement = pow(list[i], 3);</span><span id="dc49" class="mt li iq mp b gy my mv l mw mx">}</span></pre><p id="d953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似于缓存列表的长度，颠倒循环的顺序缓存列表的长度作为迭代器的初始值。因此，对于包含大量元素的列表来说，这应该会带来显著的性能提升。</p><h1 id="e781" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">基准</h1><p id="8a96" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">为了测量每个循环的性能，它必须遍历一个包含3000000个整数的列表，每个整数都是它自己在列表中的索引。对于列表中的每个元素，循环必须设置一个名为<em class="lf">的变量eachElement </em>为元素的立方值。</p><p id="2f8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该程序将在每个循环中运行10次，并记录完成操作的平均时间。然后，我将整个基准测试重复了3次，得出了平均结果。</p><p id="9f96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们看看哪个循环和优化组合是最快的！</p><h1 id="5a01" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">While循环</h1><ol class=""><li id="ad8e" class="mz na iq ka b kb mf kf mg kj nb kn nc kr nd kv ne nf ng nh bi translated">无缓存长度:</li></ol><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1890" class="mt li iq mp b gy mu mv l mw mx">var count = 0;</span><span id="acf7" class="mt li iq mp b gy my mv l mw mx">num eachElement = 0;</span><span id="4b77" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">while (count &lt; list.length) {</strong></span><span id="ccc9" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(list[count], 3);</strong></span><span id="2551" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  count++;</strong></span><span id="da3c" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="cded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成该测试大约需要9.14毫秒。</p><p id="4e16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.带缓存长度:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fc39" class="mt li iq mp b gy mu mv l mw mx">var count = 0;</span><span id="4df6" class="mt li iq mp b gy my mv l mw mx">num eachElement = 0;</span><span id="703b" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">var length = list.length;</strong></span><span id="662e" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">while (count &lt; length) {</strong></span><span id="de80" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(list[count], 3);</strong></span><span id="dce8" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  count++;</strong></span><span id="c90c" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="6c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成该测试大约需要9.65毫秒。</p><p id="0f97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.顺序相反:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c5c4" class="mt li iq mp b gy mu mv l mw mx">var count = list.length - 1;</span><span id="3181" class="mt li iq mp b gy my mv l mw mx">num eachElement = 0;</span><span id="62ff" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">while (count &gt;= 0) {</strong></span><span id="e34a" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(list[count], 3);</strong></span><span id="a658" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  count--;</strong></span><span id="62a3" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="f9a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个测试花了大约14.57毫秒完成。</p><h1 id="49eb" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">对于循环</h1><ol class=""><li id="3143" class="mz na iq ka b kb mf kf mg kj nb kn nc kr nd kv ne nf ng nh bi translated">无缓存长度:</li></ol><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9c9e" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="ec20" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">for (var i = 0; i &lt; list.length; i++) {</strong></span><span id="31de" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(list[i], 3);</strong></span><span id="f0ec" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="7e4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这项测试花了大约9.08毫秒完成。</p><p id="1be0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.带缓存长度:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4779" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="4d84" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">var length = list.length;</strong></span><span id="d683" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">for (var i = 0; i &lt; length; i++) {</strong></span><span id="b29a" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(list[i], 3);</strong></span><span id="734f" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="7785" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这项测试花了大约9.01毫秒完成。</p><p id="405f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.顺序相反:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="713a" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="c60e" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">for (var i = list.length - 1; i &gt;= 0; i--) {</strong></span><span id="70c1" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(list[i], 3);</strong></span><span id="3346" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="1cc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个测试花了大约14.27毫秒完成。</p><h1 id="79b5" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">对于…在循环中</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="533f" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="faad" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">for (var element in list) {</strong></span><span id="7f07" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(element, 3);</strong></span><span id="1d23" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}</strong></span></pre><p id="bfc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成该测试大约需要22.70毫秒。</p><h1 id="c287" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">。forEach方法</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="34ff" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="dc07" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">list.forEach((element) {</strong></span><span id="1aaa" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(element, 3);</strong></span><span id="29e5" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">});</strong></span></pre><p id="c811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个测试花了大约142.27毫秒完成。</p><h1 id="cfca" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">。地图方法</h1><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="bb57" class="mt li iq mp b gy mu mv l mw mx">num eachElement = 0;</span><span id="2429" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">list.map((e) {</strong></span><span id="6db5" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">  eachElement = pow(e, 3);</strong></span><span id="f674" class="mt li iq mp b gy my mv l mw mx"><strong class="mp ir">}).toList();</strong></span></pre><p id="86cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个测试花了大约487.77毫秒完成。</p><h1 id="5208" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结果呢</h1><p id="a751" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">我把这些测试的结果整理成一个柱状图。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e8590f77cb4150c93b73466e680e056a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*5qERUkpTcjKWcWpt8pY1Kg.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">带结果的条形图</figcaption></figure><p id="9272" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这个图中我们可以看到，循环的<em class="lf">用缓存的长度是最快的，而<em class="lf">。使用<em class="lf">时，地图</em>方法最慢(慢很多)。forEach </em>方法为倒数第二。</em></p><p id="9655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其余环路的性能几乎相同；然而，似乎顺序相反的循环的<em class="lf"> while </em>和<em class="lf">比其他循环的性能稍差。</em></p><h1 id="6de9" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="ea0a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">总之，<em class="lf"> while </em>或<em class="lf"> for </em>循环中的任何一个都可以使用，每个循环之间的性能差异最小(除了反向循环)。</p><p id="0e05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中使用的基准测试代码和包含结果的电子表格可从<a class="ae lg" href="https://github.com/XuanHanTan/dart-loops-benchmarks" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="277a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章与通常的颤振文章略有不同，我希望你喜欢阅读它！让我知道你对结果的想法，以及我是否应该在评论区发布更多的基准测试文章。如果你觉得这篇文章有用，也请鼓掌！</p></div></div>    
</body>
</html>