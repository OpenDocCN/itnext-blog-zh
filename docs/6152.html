<html>
<head>
<title>Build a scalable front-end with Rush monorepo and React — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rush monorepo和React构建可扩展的前端—第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/build-a-scalable-front-end-with-rush-monorepo-and-react-part-1-dd50ae38ad3e?source=collection_archive---------1-----------------------#2021-09-03">https://itnext.io/build-a-scalable-front-end-with-rush-monorepo-and-react-part-1-dd50ae38ad3e?source=collection_archive---------1-----------------------#2021-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d07e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">回购设置+导入项目+更漂亮</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/08a040bdf352aca3b84a1c5383b1ff42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciIztKJETR7pHahGedSX5A.jpeg"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="04d9" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这是博客系列“用Rush monorepo和React构建可伸缩前端”的第一部分</p><ul class=""><li id="3d2c" class="mc md iq lg b lh li ll lm lp me lt mf lx mg mb mh mi mj mk bi translated"><a class="ae ml" href="https://medium.com/@alexandrubereghici/build-a-scalable-front-end-with-rush-monorepo-and-react-part-1-dd50ae38ad3e" rel="noopener">第1部分</a> : Monorepo设置，导入保留git历史的项目，<br/>添加更漂亮的</li><li id="3db7" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://medium.com/@alexandrubereghici/build-a-scalable-front-end-with-rush-monorepo-and-react-part-2-d7f1c19c1797" rel="noopener">第2部分</a>:用Webpack和react-scripts创建构建工具包</li><li id="75ea" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://medium.com/@alexandrubereghici/build-a-scalable-front-end-with-rush-monorepo-and-react-part-3-b90430f15af7" rel="noopener">第3部分</a>:添加共享ESLint配置，并与lint-staged一起使用</li><li id="a8be" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://medium.com/@alexandrubereghici/build-a-scalable-front-end-with-rush-monorepo-and-react-part-4-d0939bfb8b8a" rel="noopener">第4部分</a>:用Github动作和Netlify设置部署工作流。</li><li id="4f5d" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://medium.com/@alexandrubereghici/build-a-scalable-front-end-with-rush-monorepo-and-react-part-5-355f5391fd27" rel="noopener">第5部分</a>:添加VSCode配置，获得更好的开发体验。</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="3fda" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在多存储库项目结构中，当您需要从一个项目到另一个项目重用一些代码时，这只是一个时间问题。采用monorepo架构可以帮助团队共享和贡献代码。</p><p id="40d0" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我不会在本文中讨论选择这种方法的利弊，因为有大量的资源讨论这个主题，相反，我将重点讨论使用Rush.js和React实现可伸缩的monorepo。</p><h1 id="d8d4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">工具</h1><p id="82c3" class="pw-post-body-paragraph le lf iq lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb ij bi translated">我们将使用以下工具:</p><ul class=""><li id="c5b7" class="mc md iq lg b lh li ll lm lp me lt mf lx mg mb mh mi mj mk bi translated"><a class="ae ml" href="https://rushjs.io/" rel="noopener ugc nofollow" target="_blank">冲</a></li><li id="4aa8" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">反应</a></li><li id="2dcd" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a></li><li id="959d" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a></li><li id="9e84" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">网络包</a></li><li id="ede0" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">更漂亮</a></li><li id="e168" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://github.com/okonet/lint-staged" rel="noopener ugc nofollow" target="_blank">皮棉阶段</a></li><li id="2d2b" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><a class="ae ml" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a></li><li id="0f21" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated">网络生活</li></ul><h1 id="9b83" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">目标</h1><p id="2de2" class="pw-post-body-paragraph le lf iq lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb ij bi translated">在实施monorepo之前，让我们定义一下我们希望使用这些工具实现的目标:</p><ul class=""><li id="eeb7" class="mc md iq lg b lh li ll lm lp me lt mf lx mg mb mh mi mj mk bi translated">多种应用</li><li id="3021" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated">应用程序之间的代码共享</li><li id="f747" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated">共享工具和配置</li><li id="e152" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated">代码质量的强制规则</li><li id="73ad" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated">开发的自动化工作流程</li></ul><h1 id="9d76" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="4f1e" class="pw-post-body-paragraph le lf iq lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb ij bi translated">如果你有兴趣只是看看代码，你可以在这里找到它:<a class="ae ml" href="https://github.com/abereghici/rush-monorepo-boilerplate" rel="noopener ugc nofollow" target="_blank">https://github.com/abereghici/rush-monorepo-boilerplate</a></p><p id="f8c9" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">如果你想看一个在真实的大型项目中使用Rush的例子，你可以看看由Bentley Systems开发的开源项目<a class="ae ml" href="https://github.com/imodeljs/imodeljs" rel="noopener ugc nofollow" target="_blank"> ITwin.js </a>。</p><h1 id="cfb0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">向导</h1><h2 id="1f6d" class="mw jo iq bd jp mx my dn jt mz na dp jx lp nb nc kb lt nd ne kf lx nf ng kj nh bi translated">创建新的存储库</h2><p id="f626" class="pw-post-body-paragraph le lf iq lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb ij bi translated">我假设您已经为这个项目创建了一个空的Github存储库。<br/>让我们在本地克隆它，让魔法开始吧！</p><h2 id="3528" class="mw jo iq bd jp mx my dn jt mz na dp jx lp nb nc kb lt nd ne kf lx nf ng kj nh bi translated">初始化紧急单报告</h2><p id="c228" class="pw-post-body-paragraph le lf iq lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb ij bi translated">在项目文件夹中，运行以下命令:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="3af8" class="mw jo iq nj b gy nn no l np nq">npm install -g @microsoft/rush</span><span id="17df" class="mw jo iq nj b gy nr no l np nq">rush init</span></pre><p id="c5ed" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在这个命令之后，您会看到创建了一堆文件和文件夹。你可以在这里查看配置文件参考<a class="ae ml" href="https://rushjs.io/pages/advanced/config_files/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c82c" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">此时，我们可以删除不必要的文件并创建我们的第一个提交。</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="da5c" class="mw jo iq nj b gy nn no l np nq">rm -rf .travis.yml<br/><br/>git add .<br/>git commit -m "Initial commit"<br/>git push origin master</span></pre><p id="d730" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">导入现有项目而不丢失git历史记录</p><p id="0c21" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">如果您丢失了项目的所有历史记录，您不会真的想要执行到monorepo的迁移。如果所有东西都指向合并项目的提交，那么您将不能恢复到以前的提交，或者运行<code class="fe ns nt nu nj b">git blame</code>或<code class="fe ns nt nu nj b">git bisect</code>。</p><p id="b5d9" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们可以复制monorepo中的所有项目，并用一个git命令保存每个项目的git历史:<code class="fe ns nt nu nj b">git subtree</code>。</p><p id="4ffe" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">假设我们想要将下面的项目导入到我们的mono repo<a class="ae ml" href="https://github.com/abereghici/react-app" rel="noopener ugc nofollow" target="_blank">https://github.com/abereghici/react-app</a>中。我们将使用命令<code class="fe ns nt nu nj b">git subtree add</code>来完成</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="165f" class="mw jo iq nj b gy nn no l np nq">git subtree add --prefix apps/react-app \<br/> https://github.com/abereghici/react-app master</span></pre><p id="e394" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">让我们解码这个命令的参数:</p><ul class=""><li id="41a0" class="mc md iq lg b lh li ll lm lp me lt mf lx mg mb mh mi mj mk bi translated"><code class="fe ns nt nu nj b">apps/react-app</code>用于指定monorepo内部的路径，项目将被导入到该路径。</li><li id="c2e3" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><code class="fe ns nt nu nj b">https://github.com/abereghici/react-app</code>是我们想要导入的项目的远程存储库URL。</li><li id="de19" class="mc md iq lg b lh mm ll mn lp mo lt mp lx mq mb mh mi mj mk bi translated"><code class="fe ns nt nu nj b">master</code>是项目将从其中导入的分支。</li></ul><p id="5ed7" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">现在，如果您运行<code class="fe ns nt nu nj b">git log</code>，您将在我们的monorepo中看到<code class="fe ns nt nu nj b">react-app</code>项目的历史。</p><p id="56b2" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">打开<code class="fe ns nt nu nj b">apps/react-app/package.json</code>，用<code class="fe ns nt nu nj b">@monorepo/react-app</code>更改项目名称。</p><p id="ae1e" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">最后一步是在rush配置文件中注册<code class="fe ns nt nu nj b">@monorepo/react-app</code>项目。打开<code class="fe ns nt nu nj b">rush.json</code>文件，在项目清单下添加一个条目，如下所示:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="4572" class="mw jo iq nj b gy nn no l np nq">"projects": [<br/>    {<br/>      "packageName": "@monorepo/react-app",<br/>      "projectFolder": "apps/react-app",<br/>      "reviewCategory": "production"<br/>    }<br/>  ]</span></pre><p id="ecc8" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这告诉Rush它应该管理这个项目。接下来，运行<code class="fe ns nt nu nj b">rush update</code>来安装<code class="fe ns nt nu nj b">react-app</code>项目的依赖项。该命令可以在包含<code class="fe ns nt nu nj b">rush.json</code>文件的repo文件夹的任何子文件夹中启动。</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="9970" class="mw jo iq nj b gy nn no l np nq">rush update<br/>git add .<br/>git commit -m "Imported react-app project"<br/>git push origin master</span></pre><h2 id="52fa" class="mw jo iq bd jp mx my dn jt mz na dp jx lp nb nc kb lt nd ne kf lx nf ng kj nh bi translated">添加更漂亮</h2><p id="1cff" class="pw-post-body-paragraph le lf iq lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb ij bi translated">我们希望monorepo中的所有代码文件具有一致的语法和格式。因此，我们将更好地应用于整个存储库。我们将在<code class="fe ns nt nu nj b">git commit</code>期间运行它。</p><p id="fd5e" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">让我们在repo的根目录下创建一个配置文件。漂亮允许这个配置文件有许多不同的名字，但是我们将使用<code class="fe ns nt nu nj b">.prettierrc.js</code></p><p id="7d77" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><code class="fe ns nt nu nj b">&lt;repo root&gt;/.prettierrc.js</code></p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="215f" class="mw jo iq nj b gy nn no l np nq">module.exports = {<br/>  arrowParens: 'avoid',<br/>  bracketSpacing: true,<br/>  htmlWhitespaceSensitivity: 'css',<br/>  insertPragma: false,<br/>  jsxBracketSameLine: false,<br/>  jsxSingleQuote: false,<br/>  printWidth: 80,<br/>  proseWrap: 'preserve',<br/>  quoteProps: 'as-needed',<br/>  requirePragma: false,<br/>  semi: true,<br/>  singleQuote: true,<br/>  tabWidth: 2,<br/>  trailingComma: 'es5',<br/>  useTabs: false,<br/>};</span></pre><p id="db9d" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">你还需要制作一个<code class="fe ns nt nu nj b">.prettierignore</code>文件来告诉漂亮的人跳过哪些文件。建议<code class="fe ns nt nu nj b">.prettierignore</code>扩展<code class="fe ns nt nu nj b">.gitignore</code>中使用的相同模式。</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="01b3" class="mw jo iq nj b gy nn no l np nq">cp .gitignore .prettierignore</span></pre><p id="dff2" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">一旦设置好配置，接下来我们需要手动调用Prettier来重新格式化所有现有的源文件。</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="be2b" class="mw jo iq nj b gy nn no l np nq"><em class="nv"># See what files Prettier will format</em><br/><em class="nv"># check the output and modify .prettierignore rules if needed</em><br/>npx prettier . --list-different<br/><br/><em class="nv"># When you are ready, this will format all the source files</em><br/>npx prettier . --write</span></pre><p id="dc60" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">为了加速<code class="fe ns nt nu nj b">git commit</code> hook上的漂亮进程，我们将使用<code class="fe ns nt nu nj b">prettier-quick</code>来计算提交文件的子集并格式化它们。</p><p id="6ed3" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">让我们创建一个rush自动安装程序，在这里我们将列出所有的格式依赖项。</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="4418" class="mw jo iq nj b gy nn no l np nq"><em class="nv"># This creates the common/autoinstallers/rush-prettier/package.json file:</em><br/>rush init-autoinstaller --name rush-prettier</span></pre><p id="b5d5" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">安装依赖项:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="652b" class="mw jo iq nj b gy nn no l np nq">cd common/autoinstallers/rush-prettier<br/><br/><em class="nv"># Install the dependencies.</em><br/><em class="nv"># You can also manually edit the "dependencies" in the package.json file</em><br/> pnpm install prettier<br/> pnpm install pretty-quick<br/><br/><em class="nv"># update the auto-installer</em><br/>rush update-autoinstaller --name rush-prettier</span></pre><p id="f573" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">接下来，我们将创建一个调用<code class="fe ns nt nu nj b">pretty-quick</code>工具的rush beauty定制命令。将此添加到<code class="fe ns nt nu nj b">config/rush/command-line.json</code>文件的“命令”部分:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="2f8e" class="mw jo iq nj b gy nn no l np nq">. . .<br/>  "commands": [<br/>    {<br/>      "name": "prettier",<br/>      "commandKind": "global",<br/>      "summary": "Used by the pre-commit Git hook. This command invokes Prettier to reformat staged changes.",<br/>      "safeForSimultaneousRushProcesses": true,<br/><br/>      "autoinstallerName": "rush-prettier",<br/><br/>      <em class="nv">// This will invoke common/autoinstallers/rush-prettier/node_modules/.bin/pretty-quick</em><br/>      "shellCommand": "pretty-quick --staged"<br/>    }<br/>    . . .</span></pre><p id="02e3" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">保存这些更改后，让我们通过运行<code class="fe ns nt nu nj b">rush prettier</code>来测试我们的定制命令。</p><p id="deea" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">最后一步是添加一个Git钩子，每当执行<code class="fe ns nt nu nj b">git commit</code>时，它会自动调用rush beauty。让我们在<code class="fe ns nt nu nj b">common/git-hooks</code>文件夹中创建一个名为<code class="fe ns nt nu nj b">pre-commit</code>的文件:</p><p id="6b1f" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><code class="fe ns nt nu nj b">common/git-hooks/pre-commit</code></p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="e9c9" class="mw jo iq nj b gy nn no l np nq"><strong class="nj ir">#!/bin/sh</strong><br/><em class="nv"># Called by "git commit" with no arguments.  The hook should</em><br/><em class="nv"># exit with non-zero status after issuing an appropriate message if</em><br/><em class="nv"># it wants to stop the commit.</em><br/><br/><em class="nv"># Invoke the "rush prettier" custom command to reformat files whenever they</em><br/><em class="nv"># are committed. The command is defined in common/config/rush/command-line.json</em><br/><em class="nv"># and uses the "rush-prettier" autoinstaller.</em><br/>node common/scripts/install-run-rush.js prettier || exit $?</span></pre><p id="1e76" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">运行<code class="fe ns nt nu nj b">rush install</code>安装大钩。</p><p id="8e0d" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们完了！现在每次提交时，我们都会被自动美化。</p><p id="378e" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">让我们进入<a class="ae ml" href="https://medium.com/@alexandrubereghici/build-a-scalable-front-end-with-rush-monorepo-and-react-part-2-d7f1c19c1797" rel="noopener">下一部分</a>，在这里我们将学习如何使用Webpack和jest创建构建工具。</p><h2 id="7298" class="mw jo iq bd jp mx my dn jt mz na dp jx lp nb nc kb lt nd ne kf lx nf ng kj nh bi translated">那里见！</h2></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="3255" class="pw-post-body-paragraph le lf iq lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><em class="nv">原载于</em><a class="ae ml" href="https://bereghici.dev/blog/build-a-scalable-front-end-with-rush-monorepo-and-react--repo-setup+import-projects+prettier" rel="noopener ugc nofollow" target="_blank"><em class="nv">https://bereghici . dev</em></a><em class="nv">。</em></p></div></div>    
</body>
</html>