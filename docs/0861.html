<html>
<head>
<title>Data structures in JS: Hash Tables App with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中的数据结构:带有React的哈希表应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/data-structures-in-js-hash-tables-app-with-react-b28b02a9e6b5?source=collection_archive---------6-----------------------#2018-06-10">https://itnext.io/data-structures-in-js-hash-tables-app-with-react-b28b02a9e6b5?source=collection_archive---------6-----------------------#2018-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/388a7424ab92174bd0ce7903641197d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJeZ92LEDnd6Adya_XgR0w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">哈希表React应用的屏幕截图</figcaption></figure><p id="6e4d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这一系列文章中，我想展示为什么经典数据结构对JS开发人员有用。在这种情况下，我将使用一个典型的链表散列表。</p><ul class=""><li id="4951" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/data-structures-in-js-hash-tables-app-with-react-b28b02a9e6b5">第1部分(散列表)</a></li><li id="eba0" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/@alonso.oliverio/data-structures-in-js-part-2-double-linked-lists-150facd7a90d" rel="noopener">第二部分(双向链表)</a></li><li id="0eac" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/@alonso.oliverio/data-structures-in-js-binary-trees-react-app-5443b951a46b" rel="noopener">第三部(二叉树)</a></li></ul><p id="6adb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae lj" href="https://github.com/boxgames1/hash-tables-app" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到关于本文的所有文档和代码。</p><p id="2c14" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个<strong class="ke ir">散列表</strong>是一个具有静态大小的简单数组。每个数组包含一个链表。列表包含不重复的元素。</p><p id="f340" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在哈希表中，每次你对一个条目进行操作(插入、删除或查找)时，他都会被传递到哈希函数，该函数返回条目应该被放置的桶的索引。这意味着您节省了大量的迭代，因为您知道在哪个存储桶中对每个输入执行您的操作。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/12455be6728ed3b62a0ccb7cc14cce54.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*JIVtpHUlQNIJo6LTgv24Ww.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">哈希函数示例</figcaption></figure><p id="22c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了解释列表是如何工作的，我更喜欢从组成它们的节点开始。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="90f1" class="lz ma iq lv b gy mb mc l md me">class LListNode {</span><span id="2799" class="lz ma iq lv b gy mf mc l md me">  constructor(value, next) {</span><span id="1649" class="lz ma iq lv b gy mf mc l md me">    this.value = value;</span><span id="b6be" class="lz ma iq lv b gy mf mc l md me">    this.next = next;</span><span id="0aba" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="4157" class="lz ma iq lv b gy mf mc l md me">    // getters and setters….</span><span id="7217" class="lz ma iq lv b gy mf mc l md me">}</span></pre><p id="17b7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很简单吧？一个<strong class="ke ir">链表节点</strong>只是由它的值和下一个元素组成。</p><p id="89ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">链表是一个节点链，从一个头节点开始。(我没有展示所有的方法，但是你可以在<a class="ae lj" href="https://github.com/boxgames1/hash-tables-app" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中查看它们)</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="99bb" class="lz ma iq lv b gy mb mc l md me">class LList {</span><span id="baea" class="lz ma iq lv b gy mf mc l md me">  constructor(values) {</span><span id="2a02" class="lz ma iq lv b gy mf mc l md me">    let current;</span><span id="aee6" class="lz ma iq lv b gy mf mc l md me">    this.header = new LListNode(null, null);</span><span id="c9ca" class="lz ma iq lv b gy mf mc l md me">    current = this.header;</span><span id="c650" class="lz ma iq lv b gy mf mc l md me">    for (const value of values) {</span><span id="71d7" class="lz ma iq lv b gy mf mc l md me">      let newNode = new LListNode(value, null);</span><span id="59e6" class="lz ma iq lv b gy mf mc l md me">      current.setNext(newNode);</span><span id="7495" class="lz ma iq lv b gy mf mc l md me">      current = newNode;</span><span id="a597" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="ae0d" class="lz ma iq lv b gy mf mc l md me">}<br/>  // Cost: O(1)</span><span id="fd47" class="lz ma iq lv b gy mf mc l md me">  begin() {</span><span id="9f5c" class="lz ma iq lv b gy mf mc l md me">    return LListIterator[Symbol.iterator](this.header.getNext(), this);</span><span id="f90f" class="lz ma iq lv b gy mf mc l md me">  }<br/>  // Cost: O(n)</span><span id="8cb8" class="lz ma iq lv b gy mf mc l md me">  clone(node) {</span><span id="f78f" class="lz ma iq lv b gy mf mc l md me">    if (node === null) return null;</span><span id="8db8" class="lz ma iq lv b gy mf mc l md me">    else return new LListNode(node.getValue(), this.clone(node.getNext()));</span><span id="5790" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="955e" class="lz ma iq lv b gy mf mc l md me">  // Cost: O(1) </span><span id="3387" class="lz ma iq lv b gy mf mc l md me">  insert(pos, val) {</span><span id="8169" class="lz ma iq lv b gy mf mc l md me">    const newNode = new LListNode(val, pos.current().getNext());</span><span id="fdf4" class="lz ma iq lv b gy mf mc l md me">    pos.current().setNext(newNode);</span><span id="e421" class="lz ma iq lv b gy mf mc l md me">    pos.next();</span><span id="59df" class="lz ma iq lv b gy mf mc l md me">    return pos;</span><span id="0dce" class="lz ma iq lv b gy mf mc l md me">  }<br/>}</span></pre><p id="dfdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">列表只有header元素作为类数据。每个方法都从那个节点开始迭代。</p><p id="2b6f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> insert </strong>方法需要一个插入新节点的位置。位置中的节点现在指向新节点，而新节点指向作为参数传递的下一个位置。erase方法的工作原理非常相似，但是开销为O(n ),而不是O(1 ),因为它需要访问前一个节点，在这种类型的列表中，开销为O(n)。</p><p id="f9ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">克隆</strong>方法从该数据结构的架构中获益，使用简单的递归算法链接每个节点以形成新列表。</p><p id="3e34" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Begin </strong>返回指向第一项的迭代器(头的下一项)。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/49771c0d63f2e5f0dda6f8f88edd284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ReSYwX-z-n4jWPCRSxqBw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">链表数据结构</figcaption></figure><p id="cf85" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">列表迭代器应该访问每个列表的下一个节点，直到到达null。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="26d8" class="lz ma iq lv b gy mb mc l md me">const LListIterator = {</span><span id="6666" class="lz ma iq lv b gy mf mc l md me">  [Symbol.iterator]: (node, llist) =&gt; {</span><span id="b731" class="lz ma iq lv b gy mf mc l md me">    let current = node;</span><span id="31ad" class="lz ma iq lv b gy mf mc l md me">    if (node === null) current = llist.header;</span><span id="96a4" class="lz ma iq lv b gy mf mc l md me">      return {</span><span id="0ccc" class="lz ma iq lv b gy mf mc l md me">        next: () =&gt; {</span><span id="cf07" class="lz ma iq lv b gy mf mc l md me">          if (current === null || current.getNext() === null) {</span><span id="fa4b" class="lz ma iq lv b gy mf mc l md me">            return {</span><span id="e556" class="lz ma iq lv b gy mf mc l md me">              done: true</span><span id="4359" class="lz ma iq lv b gy mf mc l md me">            };</span><span id="fcfe" class="lz ma iq lv b gy mf mc l md me">          }</span><span id="b64e" class="lz ma iq lv b gy mf mc l md me">          current = current.getNext();</span><span id="9e2e" class="lz ma iq lv b gy mf mc l md me">          return {</span><span id="a7a9" class="lz ma iq lv b gy mf mc l md me">            value: current,</span><span id="1f39" class="lz ma iq lv b gy mf mc l md me">            done: false</span><span id="d92b" class="lz ma iq lv b gy mf mc l md me">          };</span><span id="29f9" class="lz ma iq lv b gy mf mc l md me">        }</span><span id="2517" class="lz ma iq lv b gy mf mc l md me">      };</span><span id="7760" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="06f2" class="lz ma iq lv b gy mf mc l md me">  };</span></pre><p id="ba6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在检查一下<strong class="ke ir">散列表</strong>是如何工作的。它有3个元素作为数据:</p><ul class=""><li id="c6cb" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">元素:计算表格中元素的总数</li><li id="0593" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">大小:表中的静态桶数</li><li id="ea4b" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">桶:包含链接列表的数组</li></ul><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="31ae" class="lz ma iq lv b gy mb mc l md me">class HashTable {</span><span id="2ca0" class="lz ma iq lv b gy mf mc l md me">  constructor(size) {</span><span id="17ab" class="lz ma iq lv b gy mf mc l md me">    this.elements = 0;</span><span id="54ce" class="lz ma iq lv b gy mf mc l md me">    this.size = size;</span><span id="fee1" class="lz ma iq lv b gy mf mc l md me">    this.buckets = [];</span><span id="82dc" class="lz ma iq lv b gy mf mc l md me">    for (let i = 0; i &lt; size; i++) {</span><span id="cc0c" class="lz ma iq lv b gy mf mc l md me">      this.buckets.push(new LList([]));</span><span id="3826" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="d95d" class="lz ma iq lv b gy mf mc l md me">  }<br/>  find(item) {</span><span id="f4a9" class="lz ma iq lv b gy mf mc l md me">    let pos = this.hashFunction(item);</span><span id="ae53" class="lz ma iq lv b gy mf mc l md me">    return this.buckets[pos].find(item);</span><span id="a2c6" class="lz ma iq lv b gy mf mc l md me">  }<br/>  erase(item) {</span><span id="bad1" class="lz ma iq lv b gy mf mc l md me">    const pos = this.hashFunction(item);</span><span id="08ec" class="lz ma iq lv b gy mf mc l md me">    const list = this.buckets[pos];</span><span id="504d" class="lz ma iq lv b gy mf mc l md me">    const itemToErase = list.find(item);</span><span id="e956" class="lz ma iq lv b gy mf mc l md me">    if (itemToErase !== list.end()) {</span><span id="3fee" class="lz ma iq lv b gy mf mc l md me">      list.erase(itemToErase);</span><span id="63f1" class="lz ma iq lv b gy mf mc l md me">      this.elements--;</span><span id="112b" class="lz ma iq lv b gy mf mc l md me">    }</span><span id="0bd9" class="lz ma iq lv b gy mf mc l md me">  }</span><span id="2d82" class="lz ma iq lv b gy mf mc l md me">}</span></pre><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/af488fc57f70213df8c32df7b12a1a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*sGFGB54s-4FolQaS5vYENA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">哈希表数据结构</figcaption></figure><p id="8d56" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，哈希表迭代器深入到每个桶中。这意味着，如果你在bucket 0中，它将充当一个链表迭代器，直到到达Bucket 0列表的最后一项，然后它将获得next并遍历bucket 1列表。</p><p id="b01d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该零件的代码可在<a class="ae lj" href="https://github.com/boxgames1/hash-tables-app" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到</p><h2 id="65c1" class="lz ma iq bd mi mj mk dn ml mm mn dp mo kn mp mq mr kr ms mt mu kv mv mw mx my bi translated">使用这种数据结构的真正价值是什么？</h2><p id="4f08" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">首先，使用前面提到的散列表有一个前提。它存储不重复的值。有很多真实的例子，你没有重复的值。例如:从具有唯一id的关系数据库中检索数据。您可以在一个节点中存储您想要的任何内容，因此您可以轻松地创建一个函数来查找属性</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="fa36" class="lz ma iq lv b gy mb mc l md me">const hTable = new HashTable(10);<br/>hTable.insert({<br/>  id: 1,<br/>  value: "Cat" <br/>});<br/>hTable.insert({<br/>  id: 56,<br/>  value: "Dog" <br/>});<br/>const value = hTable.findById(56); // This function is not implemented in the repo</span></pre><p id="5071" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ne">真实例子:</em></p><p id="d2c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在一个典型的<strong class="ke ir">数组</strong>中，如果你有1000个元素，你需要找到一个特定的元素，你必须遍历所有的元素。这是O(n)成本，所以O(1000)。</p><p id="afaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们创建一个有100个桶的散列表，总共有1000个元素，就像前面的数组一样。根据列表和存储桶，您将拥有(平均)10个元素。哈希函数的开销是O(1 ),正如你所看到的,<strong class="ke ir">在哈希表中查找元素的开销比在数组</strong>中查找要好得多(~ 100倍aprox ),因为你必须遍历平均10个元素，而不是10个。</p><h2 id="12ed" class="lz ma iq bd mi mj mk dn ml mm mn dp mo kn mp mq mr kr ms mt mu kv mv mw mx my bi translated">React哈希表应用程序</h2><p id="0f83" class="pw-post-body-paragraph kc kd iq ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">为了检查这个数据结构的行为，我创建了一个简单的React应用程序来显示实时变化。请随意叉回购，并作出您的改进。</p><p id="817a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是在heroku部署的应用程序的链接:</p><div class="nf ng gp gr nh ni"><a href="https://floating-citadel-43507.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">哈希表React App @boxgames1</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">编辑描述</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">floating-citadel-43507.herokuapp.com</p></div></div></div></a></div><p id="92f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae lj" href="https://github.com/boxgames1/hash-tables-app" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到关于本文的所有文档和代码。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/boxgames1/hash-tables-app" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">box games 1/哈希表-应用程序</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">这个简单的React应用程序展示了哈希表的行为和性能</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jw ni"/></div></div></a></div><p id="6aab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在twitter上联系我<a class="ae lj" href="https://twitter.com/Oliver_AP" rel="noopener ugc nofollow" target="_blank"> (@Oliver_ap) </a></p></div></div>    
</body>
</html>