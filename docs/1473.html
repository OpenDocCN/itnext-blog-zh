<html>
<head>
<title>Solve AWS Lambda timeout limitations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决AWS Lambda超时限制</h1>
<blockquote>原文：<a href="https://itnext.io/solve-aws-lambda-timeout-limitations-751bf368538f?source=collection_archive---------1-----------------------#2018-10-26">https://itnext.io/solve-aws-lambda-timeout-limitations-751bf368538f?source=collection_archive---------1-----------------------#2018-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c23ed6b8fa58bdae1630cf701c81821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6N1eITXy6-GrR_WtR1WLA.png"/></div></div></figure><p id="265f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我一直在起草一个解决AWS Lambda超时限制的策略时，我觉得我离解决一个有时让我睡不好觉的问题越来越近了。诚然，有一些已知的模式可以让<a class="ae kw" href="https://www.jeremydaly.com/serverless-microservice-patterns-for-aws/" rel="noopener ugc nofollow" target="_blank">使用SQS </a>达到更高的可扩展性，尽管当AWS Lambda被用作核心计算服务时，手头的问题不容易用其中任何一种来解决。</p><p id="92fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我关注超时限制问题的同一时期，<a class="ae kw" href="https://aws.amazon.com/about-aws/whats-new/2018/10/aws-lambda-supports-functions-that-can-run-up-to-15-minutes/" rel="noopener ugc nofollow" target="_blank"> AWS将限制提高到15分钟</a>。尽管这肯定是一个有用改变，但我仍然倾向于使用一个没有任何限制的非lambda计算来完善我的策略草案。当安全网计算也基于按需求定价模型时，这形成了问题的真正解决方案。实际上，有时不可能预先预测负载，最大限度地提高负载并不是最终的解决方案。</p><h1 id="d2cb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">显著的改进</h1><p id="a7ce" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">以下是我在草案实现和当前实现之间所做的最重要改进的简要概述:</p><ul class=""><li id="b857" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae kw" href="https://www.npmjs.com/package/unzip" rel="noopener ugc nofollow" target="_blank"> unzip </a>已经被交换到<a class="ae kw" href="https://www.npmjs.com/package/unzipper" rel="noopener ugc nofollow" target="_blank"> unzipper </a>中，理由<a class="ae kw" href="https://github.com/EvanOxfeld/node-unzip/issues/120" rel="noopener ugc nofollow" target="_blank">充分</a>。API是一样的。</li><li id="bc8c" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">粘合主要和次要lambda处理程序的逻辑已更改。我没有使用容易出错的命名约定，而是放置了一个映射“备忘单”。</li><li id="f810" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/gmetzker/serverless-plugin-lambda-dead-letter" rel="noopener ugc nofollow" target="_blank">server less-plugin-lambda-dead-letter</a>依赖性看起来很有前途，但为了支持CloudFormation的原生功能，它被移除了。主要原因:<a class="ae kw" href="https://github.com/gmetzker/serverless-plugin-lambda-dead-letter/issues/37" rel="noopener ugc nofollow" target="_blank">固有函数的问题</a>。</li><li id="1529" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">主处理程序中的<code class="fe mo mp mq mr b">event</code>和<code class="fe mo mp mq mr b">context</code>已经通过<a class="ae kw" href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ContainerOverride.html" rel="noopener ugc nofollow" target="_blank"> ContainerOverride </a> API移动到环境变量中，因为在执行<a class="ae kw" href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html" rel="noopener ugc nofollow" target="_blank"> runTask </a>的过程中，来自原始JSON对象的信息被丢弃。就管理环境变量的一致性而言，这也是一种改进。</li><li id="d2b7" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">通过相同的<a class="ae kw" href="https://docs.aws.amazon.com/lambda/latest/dg/API_GetFunction.html" rel="noopener ugc nofollow" target="_blank"> GetFunction </a>使用来自主处理程序的原始环境变量，该GetFunction 产生这个<a class="ae kw" href="https://docs.aws.amazon.com/lambda/latest/dg/API_EnvironmentResponse.html?shortFooter=true" rel="noopener ugc nofollow" target="_blank">配置</a>以及已经获取的主处理程序的源的位置。</li><li id="f959" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">增加了一个助手来处理不同的<code class="fe mo mp mq mr b">event</code>结构。看起来SNS事件会根据存储桶中管理文件的方式而有所不同。</li></ul><p id="813a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终实现的框架可以在这个<a class="ae kw" href="https://github.com/kalinchernev/immortal-aws-lambda" rel="noopener ugc nofollow" target="_blank">库</a>中看到。</p><h1 id="b944" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">履行</h1><p id="f3fd" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">那么，经过前面提到的改进后，当前的实现看起来如何呢？</p><p id="20b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从鸟瞰图来看，结构和主要思想是相同的:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="479c" class="na ky iq mr b gy nb nc l nd ne"><strong class="mr ir">immortal-aws-lambda</strong> <br/>├── <strong class="mr ir">container</strong> <br/>│   ├── Dockerfile <br/>│   ├── package.json <br/>│   ├── README.md <br/>│   └── <strong class="mr ir">runner.js</strong> <br/>└── <strong class="mr ir">serverless</strong> <br/>    ├── package.json <br/>    ├── README.md <br/>    ├── serverless.yml <br/>    ├── <strong class="mr ir">src</strong> <br/>    │   ├── <strong class="mr ir">events</strong> <br/>    │   │   └── onFailure.js <br/>    │   └── <strong class="mr ir">lib</strong> <br/>    │       ├── extractors.js <br/>    │       ├── getHandlerData.js <br/>    │       └── snsTopicToHandlerMap.js <br/>    └── webpack.config.js <br/> <br/>5 directories, 12 files</span></pre><h1 id="1bcf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><a class="ae kw" href="https://github.com/kalinchernev/immortal-aws-lambda/tree/master/container" rel="noopener ugc nofollow" target="_blank">不朽的AWS Lambda:容器服务</a></h1><p id="8f68" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">您可能希望首先在AWS控制台中创建ECS任务，并对无服务器服务进行一些设置。</p><p id="3771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该服务的唯一目标是将一个<code class="fe mo mp mq mr b">runner.js</code>脚本放入一个容器中，并从死信队列服务远程运行它。</p><p id="00b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该脚本的内容实际上非常简单，由3个主要步骤组成:</p><ol class=""><li id="8000" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv nf mg mh mi bi translated">获取lambda处理程序的初始源代码</li><li id="6a3b" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nf mg mh mi bi translated">采用同一个处理程序的环境变量</li><li id="286f" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv nf mg mh mi bi translated">运行处理程序</li></ol><p id="f342" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有设置都是动态变量。</p><p id="2931" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来源非常简单:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="fa38" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><a class="ae kw" href="https://github.com/kalinchernev/immortal-aws-lambda/tree/master/serverless" rel="noopener ugc nofollow" target="_blank">不朽的AWS Lambda:无服务器服务</a></h1><p id="70e2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是要部署的无服务器服务。它尽可能简单和独立:</p><ul class=""><li id="a79f" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">提供一个死信队列<code class="fe mo mp mq mr b">LambdaFailureQueue</code>，当失败时其他人可以将消息推送到这个队列。</li><li id="2e1e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">导出队列的ARN，以便其他服务能够导入ARN的值。(<a class="ae kw" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/outputs-section-structure.html" rel="noopener ugc nofollow" target="_blank">文档</a>)</li><li id="c602" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">关于<code class="fe mo mp mq mr b">iamRoleStatements</code>、<code class="fe mo mp mq mr b">events</code>订阅和设置的所有其他细节与之前相同。</li></ul><p id="5c47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mo mp mq mr b">lib</code>的助手是你的责任，因为<code class="fe mo mp mq mr b">event</code>结构在你的案例中会有所不同。(最有可能)</p><p id="2ccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，拥有此服务的主要目的仍然是运行ECS任务来启动容器:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记从AWS控制台获取这些设置，并将它们设置在您的<code class="fe mo mp mq mr b">serverless.yaml</code>配置文件中。</p><h1 id="7173" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在工作流中集成服务</h1><p id="59ea" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">将其他无服务器服务和处理程序“附加”到此工作流可归结为以下几点:</p><ol class=""><li id="23f0" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv nf mg mh mi bi translated">允许服务将消息推送到SQS死信队列:</li></ol><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="5671" class="na ky iq mr b gy nb nc l nd ne">iamRoleStatements:<br/>  # Allow queueing messages to the DLQ https://docs.aws.amazon.com/lambda/latest/dg/dlq.html<br/>  - Effect: 'Allow'<br/>    Action:<br/>      - sqs:SendMessage<br/>    Resource: '*'</span></pre><p id="a4a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.从<code class="fe mo mp mq mr b">Resources</code>部分添加关于SQS队列的ARN信息</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="6fde" class="na ky iq mr b gy nb nc l nd ne">resources:<br/>  Resources:<br/>    fooFunction:<br/>      Type: "AWS::Lambda::Function"<br/>      Properties:<br/>        DeadLetterConfig:<br/>          TargetArn:<br/>            Fn::ImportValue: immortal-aws-lambda:LambdaFailureQueue</span></pre><p id="6f52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为无服务器框架还不能正确支持<code class="fe mo mp mq mr b"><a class="ae kw" href="https://www.trek10.com/blog/dead-letter-config/" rel="noopener ugc nofollow" target="_blank">onError</a></code>。感谢<a class="ae kw" href="https://github.com/neowulf" rel="noopener ugc nofollow" target="_blank"> Siva Kommuri </a>为<a class="ae kw" href="https://github.com/neowulf" rel="noopener ugc nofollow" target="_blank">建议了这个变通办法</a>。</p><p id="8108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当您的服务失败时，错误将被排队到由不朽的aws lambda服务提供的死信队列中，不朽的服务将接收此消息，找到正确的处理程序并通过容器服务调用它。</p><h1 id="e4f4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后的想法</h1><p id="e1d8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我找到这个解决方案的道路并不容易。</p><p id="a522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所用的工具边缘粗糙。</p><p id="dd89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，由于超时、重建容器等原因触发和再现故障的过程。每次迭代都是一个漫长的过程。例如，每次由于缺少字符或拼写错误而失败时，我需要将lambda函数的非捆绑包和非优化代码重新部署到云中，以便在ECS的日志中获得足够的错误消息用于调试。(疯了！)</p><p id="c9be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一下，在Node中处理流和承诺仍然非常痛苦，很难调试…</p><p id="4596" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我希望拥有这些相互通信的非常薄的变量层将是解决AWS Lambda未来几个月超时限制的可行解决方案。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="bf69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="np">最初发布于</em><a class="ae kw" href="https://kalinchernev.github.io/solve-aws-lambda-timeout-limitations" rel="noopener ugc nofollow" target="_blank"><em class="np">kalinchernev . github . io</em></a><em class="np">。</em></p></div></div>    
</body>
</html>