<html>
<head>
<title>Using Protocol Buffers with Node.js applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js应用程序中使用协议缓冲区</h1>
<blockquote>原文：<a href="https://itnext.io/using-protocol-buffers-with-node-js-applications-b45c1d03c6d?source=collection_archive---------3-----------------------#2022-08-23">https://itnext.io/using-protocol-buffers-with-node-js-applications-b45c1d03c6d?source=collection_archive---------3-----------------------#2022-08-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7351" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">跨平台-跨语言二进制数据编码，解释</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/9b1b19cc96d65a7ee006a54498d497bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uoTs147HMik51DP8.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</figcaption></figure><p id="3998" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> Protocol Buffers是Google开发的工具链，用于编程语言之间的数据和对象的二进制编码。它是跨语言远程过程调用系统gRPC的基础，但可以单独使用。</strong></p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><p id="562b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">软件工程的历史总是面临着在应用程序之间共享数据的挑战。存在许多技术，例如，通常使用基于文本的数据格式，如JSON、TOML、XML或YAML。由于有合适的库，这些格式可以被任何编程语言的程序读写。但是，以这些格式存储数据需要更多的磁盘空间、通过互联网传输时的网络带宽以及编码和解码的CPU时间。</p><p id="563c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一种选择是使用二进制数据格式。例如，在互联网流行之前，基于ISO的网络平台将用于大范围的联网。ISO协议基于二进制格式ASN.1，它被严格指定到无数的程度，可以支持任何类型的二进制数据编码需求。ASN.1在很大程度上是一个被遗忘的东西，除了像我这样三十年前致力于将ISO协议栈实现到Unix系统中的人。今天，它是保证用不同编程语言编写的应用程序之间可移植性的二进制数据格式的历史范例。</p><p id="60f7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Google对协议缓冲区有这样的说法:</p><blockquote class="mc md me"><p id="ea51" class="kz la mf lb b lc ld jv le lf lg jy lh mg lj lk ll mh ln lo lp mi lr ls lt lu in bi translated"><em class="iu">协议缓冲区提供了一种语言中立、平台中立、可扩展的机制，用于以向前兼容和向后兼容的方式序列化结构化数据。它很像JSON，只不过它更小更快，并且生成本机语言绑定。</em></p></blockquote><p id="299f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">短语<em class="mf">语言中立</em>意味着协议缓冲绑定可用于大多数流行的编程语言，而<em class="mf">平台中立</em>意味着绑定可用于多芯片架构。短语<em class="mf">结构化数据</em>意味着协议缓冲区支持按照模式声明编码的数据，并且该模式支持在其他定义中嵌套定义。</p><p id="704b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">使用协议缓冲区从使用<code class="fe mj mk ml mm b">.proto</code>文件描述模式开始。这些文件允许您描述二进制数据块的格式，该数据块将被编码到二进制消息缓冲区中。<code class="fe mj mk ml mm b">.proto</code>文件可以被编译成十几种编程语言中的任何一种。编译后的模块为您提供了将数据编码为二进制格式以及从二进制格式解码的代码。您的应用程序如何处理编码数据取决于您自己。</p><p id="0a4c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">它旨在将编码为协议缓冲区的数据用于网络协议中，以通过互联网传输数据，因此得名该项目的名称。例如，Google在内部应用程序中广泛使用协议缓冲区。但是，不要让这种预期的用法限制了你的想象力。</p><p id="b931" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">官方文档位于:<a class="ae mn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/protocol-buffers</a></p><p id="9bf8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">本文中显示的代码可以在:<a class="ae mn" href="https://github.com/robogeek/nodejs-protocol-buffers" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/nodejs-protocol-buffers</a>获得</p><h1 id="7021" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">Node.js上的协议缓冲区入门</h1><p id="4be7" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">我们将从使用Google开发的协议缓冲工具开始。</p><p id="acd2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第一个需求是获得用于将协议缓冲区定义转换成代码的<code class="fe mj mk ml mm b">protoc</code>编译器。您可能很幸运，您计算机的软件包管理器有一个包含协议缓冲工具的软件包。</p><p id="6565" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，在我的macOS笔记本电脑上，我使用MacPorts来提供开源工具。<code class="fe mj mk ml mm b">protobuf3-cpp</code>包是相对最新的，并声称包括编译器。</p><p id="49b8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在Ubuntu上，我发现<code class="fe mj mk ml mm b">protobuf-compiler</code>包含了正确的工具。因此，在Ubuntu上安装非常简单:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="2986" class="np mp iu mm b gz nq nr l ns nt">$ sudo apt-get install protobuf-compiler</span></pre><p id="38b1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果失败，您可以前往<code class="fe mj mk ml mm b">https://github.com/protocolbuffers/protobuf/releases</code>获取协议缓冲团队提供的预构建包。或者，你也可以下载源代码，自己编译。</p><p id="f95b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个练习的目标是一个名为<code class="fe mj mk ml mm b">protoc</code>的命令行工具，它是协议缓冲编译器。</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="e6ec" class="np mp iu mm b gz nq nr l ns nt">$ protoc<br/>Usage: protoc [OPTION] PROTO_FILES <br/>Parse PROTO_FILES and generate output based on the options given:</span><span id="c73d" class="np mp iu mm b gz nu nr l ns nt">...</span></pre><p id="53c1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">当命令不带参数运行时，将打印用法消息。</p><p id="2d8d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">协议缓冲区规范语言有两个版本。在本教程中，我们将使用这种语言的第3版，在线文档位于:<a class="ae mn" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/protocol-buffers/docs/proto3</a></p><p id="dfdb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">遗憾的是，该网站没有Node.js的使用教程。你可以阅读其他语言的官方教程。</p><p id="a819" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">谷歌在https://www.npmjs.com/package/google-protobuf<a class="ae mn" href="https://www.npmjs.com/package/google-protobuf" rel="noopener ugc nofollow" target="_blank">提供了一个Node.js包</a></p><p id="2aed" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该包的源存储库包含类似教程的文档:<a class="ae mn" href="https://github.com/protocolbuffers/protobuf-javascript/blob/main/docs/index.md" rel="noopener ugc nofollow" target="_blank">https://github . com/protocol buffers/proto buf-JavaScript/blob/main/docs/index . MD</a></p><h1 id="26d6" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用协议缓冲区定义简单的数据格式</h1><p id="47f0" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">在本教程的剩余部分，我们将介绍一个简单的数据格式，它由协议缓冲区和一对Node.js脚本指定，使用该数据格式对数据进行编码和解码。这将是一个简单的Todo对象，类似于我在一个示例应用程序中实现的对象，该应用程序是为了探索当时新发布的Bootstrap v5而编写的。</p><p id="3551" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">参见:<a class="ae mn" href="https://techsparx.com/nodejs/examples/todo-bootstrap/" rel="noopener ugc nofollow" target="_blank">https://techsparx.com/nodejs/examples/todo-bootstrap/</a></p><p id="4a3b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">创建项目目录:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="521c" class="np mp iu mm b gz nq nr l ns nt">$ mkdir protobuf<br/>$ cd protobuf<br/>$ npm init -y<br/>$ npm install google-protobuf --save</span></pre><p id="125b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这需要安装一个外部依赖项，即上一节描述的<code class="fe mj mk ml mm b">protoc</code>编译器。</p><p id="2b5a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在目录中创建一个名为<code class="fe mj mk ml mm b">todo.proto</code>的文件，并将它放在文件的顶部:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="5221" class="np mp iu mm b gz nq nr l ns nt">syntax = "proto3";</span></pre><p id="69c8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这告诉<code class="fe mj mk ml mm b">protoc</code>使用版本3。如果您不这样做，编译器将打印一个警告，其中包含文本<em class="mf">没有为原型文件</em>指定语法，并告诉您将上述文本添加到您的文件中。</p><p id="0a26" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我的示例应用程序中的TODO对象包含四个字段:</p><ol class=""><li id="f48f" class="nv nw iu lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">作为识别对象的编号的<em class="mf"> id </em></li><li id="86ea" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">待办事项列表中显示的一个<em class="mf">标题</em>字符串</li><li id="6ad8" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">一个<em class="mf"> body </em>字符串，当用户查看一个TODO项目时显示</li><li id="a22b" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">给出高/中/低优先级的<em class="mf">优先级</em>枚举</li></ol><p id="e0a2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在协议缓冲区中，定义如下:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="6dc9" class="np mp iu mm b gz nq nr l ns nt">message Todo {<br/>    int64 id = 1;<br/>    string title = 2;<br/>    string body = 3;<br/>    Precedence precedence = 4;<br/>}</span></pre><p id="c36c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">单词<code class="fe mj mk ml mm b">message</code>开始定义一个对象。<code class="fe mj mk ml mm b">message</code>块有一个名字，在本例中是<code class="fe mj mk ml mm b">Todo</code>，给出了类名。主体内部是一个或多个字段定义。每个字段都有一个数据类型和一个名称。数字赋值是字段编号，而不是类似默认值的任何东西。字段编号决定了数据在记录中的编码位置。</p><p id="20b6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后一个字段由类型<em class="mf">优先级</em>定义。这不是内置于协议缓冲区语言中的，而是由以下应用程序定义的:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="71dd" class="np mp iu mm b gz nq nr l ns nt">enum Precedence {<br/>     PRECEDENCE_NONE = 0;<br/>     PRECEDENCE_LOW = 1;<br/>     PRECEDENCE_MEDIUM = 2;<br/>     PRECEDENCE_HIGH = 3; <br/>}</span></pre><p id="22e6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们选择使用一个<code class="fe mj mk ml mm b">enum</code>对象类型来描述<code class="fe mj mk ml mm b">precedence</code>字段的允许值。在我的示例应用程序中，LOW、MEDIUM和HIGH的值如下所示。这意味着最初这个<code class="fe mj mk ml mm b">enum</code>只被指定了这三个值，而<code class="fe mj mk ml mm b">PRECEDENCE_NONE</code>并不存在。但是，编译器给出了这个错误:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="8119" class="np mp iu mm b gz nq nr l ns nt">The first enum value must be zero in proto3.</span></pre><p id="867d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mj mk ml mm b">enum</code>中的第一个字段必须具有值<code class="fe mj mk ml mm b">0</code>。为了保持与先前Todo应用程序中使用的值(1，2，3)的兼容性，我希望保持相同的值。这意味着引入值为<code class="fe mj mk ml mm b">0</code>的<code class="fe mj mk ml mm b">PRECEDENCE_NONE</code>。</p><p id="1e54" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">从protocol buffers文档中可以看出，enum声明可以放在<code class="fe mj mk ml mm b">message Todo {...}</code>的主体中，但是在示例实现中，它是独立的。</p><p id="2451" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这定义了一个单一对象，或者称为<em class="mf">标量值类型</em>。有十几种数据类型可以归结为整数、浮点、布尔和字符串。每一个都被精确地定义为取N个字节，这样它们就可以被正确地编码为二进制。</p><p id="9245" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个要考虑的问题是字段编号。随着应用程序的发展，您可能需要更改对象定义。您可以重用现有字段来存储不同类型的值。但是这会破坏您已经在现场部署的应用程序。相反，最佳实践是保留旧的字段定义，或者使用<code class="fe mj mk ml mm b">reserved</code>关键字来屏蔽那些旧的字段。目的是保持与应用程序旧版本的向后兼容性。</p><p id="aeec" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">例如，我们可能希望在<code class="fe mj mk ml mm b">body</code>字段中使用Markdown。现有的<code class="fe mj mk ml mm b">body</code>字段用于简单文本，而不是降价。我们可以将消息定义改为:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="b4f6" class="np mp iu mm b gz nq nr l ns nt">message Todo {<br/>    int64 id = 1;<br/>    string title = 2;<br/>    string bodyMD = 5;<br/>    Precedence precedence = 4;<br/>    reserved 3;<br/>}</span></pre><p id="76fa" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这一更改将<code class="fe mj mk ml mm b">body</code>字段重命名为<code class="fe mj mk ml mm b">bodyMD</code>，以明确该字段存储降价。这个新字段被标记为字段号<code class="fe mj mk ml mm b">5</code>，字段号<code class="fe mj mk ml mm b">3</code>被标记为<code class="fe mj mk ml mm b">reserved</code>。另一种方法是保留旧的<code class="fe mj mk ml mm b">body</code>字段定义，但是让您的应用程序忽略该字段。</p><p id="df50" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">像<code class="fe mj mk ml mm b">Todo</code>这样的标量值类型只对一个对象有用。您可能想要发送一个Todo项列表，因此需要一种方法来指定一个对象数组。</p><p id="2127" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在协议缓冲区中，您这样描述:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="2b8e" class="np mp iu mm b gz nq nr l ns nt">message Todos {<br/>   repeated Todo todos = 1 <br/>}</span></pre><p id="e07f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们定义了一个新的对象类型，<code class="fe mj mk ml mm b">Todos</code>。现在我们定义了什么是数组。这意味着该消息包含零个或多个<code class="fe mj mk ml mm b">Todo</code>对象的实例，它位于字段编号1。粗略地说，这使它成为一个数组。如果您的应用程序需要，这个对象可以很容易地包含其他项目。</p><h1 id="a60e" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">为TODO protobuf架构生成Node.js源</h1><p id="6edb" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">我们已经创建了一个完整的模式。下一步是将它转换成我们可以在应用程序中使用的源代码。这也是我们之前安装<code class="fe mj mk ml mm b">protoc</code>的原因。</p><p id="4585" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这个编译器可以为多种语言生成源代码。顺便说一句，如果你还记得你的计算机科学课，一个<em class="mf">编译器</em>将源代码从一种编程语言翻译成一种完全不同的语言。因此<code class="fe mj mk ml mm b">protoc</code>正在将协议缓冲源代码翻译成其他几种编程语言中的任何一种。</p><p id="18d5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">阅读Protocol Buffers文档网站可能会让你摸不着头脑——我们的目标是将其用于Node.js，但没有Node.js用法的文档。这是Protocol Buffers团队要回答的问题，他们为什么不在自己的网站上发布Node.js文档。</p><p id="0f4f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">转到:<a class="ae mn" href="https://www.npmjs.com/package/google-protobuf" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/google-protobuf</a></p><p id="361d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后跟随几个链接结束:<a class="ae mn" href="https://github.com/protocolbuffers/protobuf-javascript/blob/main/docs/index.md" rel="noopener ugc nofollow" target="_blank">https://github . com/protocol buffers/proto buf-JavaScript/blob/main/docs/index . MD</a></p><p id="eb56" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这两个页面包含Google编写的关于使用Google协议缓冲区实现的文档，包括使用<code class="fe mj mk ml mm b">protoc</code>生成Node.js (JavaScript)代码。令人费解的是，谷歌为什么不在主网站上扩展文档。这可能是因为软件包文档中的警告，因为2022年7月的项目状态是项目有些中断，他们正在试图纠正。</p><p id="a591" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<code class="fe mj mk ml mm b">package.json</code>中添加此<code class="fe mj mk ml mm b">script</code>条目:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="f18d" class="np mp iu mm b gz nq nr l ns nt">"scripts": {<br/>    "protoc": "protoc --js_out=import_style=commonjs,binary:. todo.proto"<br/>},</span></pre><p id="7552" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在这个文件中包含像这样的命令是一个最佳实践，这样你就不必花费宝贵的脑细胞去记忆琐事。</p><p id="aee5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于JavaScript输出，有两种风格。一个是支持使用带有<code class="fe mj mk ml mm b">require</code>函数的CommonJS进行导入，这是Node.js中的传统用法，另一个是Google Closure风格的导入。因为我们的目标是Node.js，所以我们指定了<code class="fe mj mk ml mm b">commonjs</code>。<code class="fe mj mk ml mm b">binary</code>选项使函数的生成序列化为二进制，并从二进制反序列化。选项的<code class="fe mj mk ml mm b">:.</code>部分指定了输出目录，在本例中是当前目录。使用<code class="fe mj mk ml mm b">:build/gen</code>表示输出目录是<code class="fe mj mk ml mm b">./build/gen</code>。该命令的最后一部分指定了输入文件，在本例中为<code class="fe mj mk ml mm b">todo.proto</code>。</p><p id="2af4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">编译器在处理错误信息方面做得很好。前面已经展示了其中的几个，很容易确定要做什么。</p><p id="a18c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">该命令在当前目录下创建一个文件<code class="fe mj mk ml mm b">todo_pb.js</code>。阅读这个文件是有益的。您将看到为<code class="fe mj mk ml mm b">Todo</code>、<code class="fe mj mk ml mm b">Todos</code>和<code class="fe mj mk ml mm b">Precedence</code>创建了JavaScript对象定义。</p><p id="093e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最上面是这个:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="9ecd" class="np mp iu mm b gz nq nr l ns nt">var jspb = require('google-protobuf');</span></pre><p id="c702" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们的代码没有使用<code class="fe mj mk ml mm b">google-protobuf</code>，是生成的代码使用了它。在生成的代码中，您将看到该包中函数的自由使用。为了确保这个包是可用的，我们之前安装了它。</p><h1 id="0956" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">为协议缓冲区编码数据</h1><p id="7967" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">在真实的应用程序中，我们可能有一个请求处理器函数收集一些数据，并需要使用协议缓冲区对其进行格式化以发送回复。在我们的例子中，我们希望演示生成协议缓冲区对象，然后将其序列化为二进制文件的核心步骤。在下面的脚本中，我们将演示如何反序列化二进制文件来读取数据。</p><p id="3170" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">创建一个名为<code class="fe mj mk ml mm b">encode.mjs</code>的文件(因为ES6模块是JavaScript的未来，所以我们尽可能地使用它们)。从这个开始:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="45ca" class="np mp iu mm b gz nq nr l ns nt">import { default as Schema } from './todo_pb.js';<br/>import { promises as fsp } from 'fs';<br/><br/>// console.log(Schema);<br/><br/>const todos = new Schema.Todos();<br/><br/>let todo = new Schema.Todo();<br/>todo.setId(1);<br/>todo.setTitle("Buy cheese");<br/>todo.setBody("PIZZA NIGHT");<br/>todo.setPrecedence(Schema.Precedence.PRECEDENCE_HIGH);<br/>todos.addTodos(todo);</span></pre><p id="5bb5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">生成的代码是CommonJS格式的，似乎没有生成ES6模块的选项。这种导入模式被认为是最有用的。我们还将<code class="fe mj mk ml mm b">fs/promises</code>作为<code class="fe mj mk ml mm b">fsp</code>导入，这样我们就有了异步文件系统功能。</p><p id="663d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">生成的代码让我们使用<code class="fe mj mk ml mm b">new Schema.Todos()</code>和<code class="fe mj mk ml mm b">new Schema.Todo()</code>来生成相应的对象。</p><p id="942f" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于<code class="fe mj mk ml mm b">Todo</code>对象，我找不到设置字段值的好方法。相反，我们必须明确地调用<code class="fe mj mk ml mm b">set</code>方法，如下所示。创建Todo对象后，使用<code class="fe mj mk ml mm b">todos.addTodos</code>将其添加到<code class="fe mj mk ml mm b">Todos</code>对象。</p><p id="e0ee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">尽可能多次重复最后一位代码，根据需要调整值。以此结束脚本:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="1cea" class="np mp iu mm b gz nq nr l ns nt">console.log(todos.toObject());<br/><br/>await fsp.writeFile('todos.bin', todos.serializeBinary());</span></pre><p id="2320" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第一个为您提供已创建对象的视觉反馈。<code class="fe mj mk ml mm b">toObject</code>方法将协议缓冲区对象转换成普通的JavaScript对象。</p><p id="d5c6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后一行将数据写入文件<code class="fe mj mk ml mm b">todos.bin</code>。<code class="fe mj mk ml mm b">serializeBinary</code>方法将对象转换成二进制blob，然后写入文件。</p><p id="ee83" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">输出将如下所示:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="3eba" class="np mp iu mm b gz nq nr l ns nt">{<br/>  todosList: [<br/>    { id: 1, title: 'Buy cheese', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 2, title: 'Buy sauce', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 3, title: 'Buy Spinach', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 4, title: 'Buy ham', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 5, title: 'Buy olives', body: 'PIZZA NIGHT', precedence: 3 }<br/>  ]<br/>}</span></pre><p id="5a43" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在我们家，每周六晚上我们从头开始做比萨饼。</p><p id="9c81" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们还可以检查二进制文件:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="95cf" class="np mp iu mm b gz nq nr l ns nt">$ od -c todos.bin <br/>0000000  \n 035  \b 001 022  \n   B   u   y       c   h   e   e   s   e<br/>0000020 032  \v   P   I   Z   Z   A       N   I   G   H   T     003  \n<br/>0000040 034  \b 002 022  \t   B   u   y       s   a   u   c   e 032  \v<br/>0000060   P   I   Z   Z   A       N   I   G   H   T     003  \n 036  \b<br/>0000100 003 022  \v   B   u   y       S   p   i   n   a   c   h 032  \v<br/>0000120   P   I   Z   Z   A       N   I   G   H   T     003  \n 032  \b<br/>0000140 004 022  \a   B   u   y       h   a   m 032  \v   P   I   Z   Z<br/>0000160   A       N   I   G   H   T     003  \n 035  \b 005 022  \n   B<br/>0000200   u   y       o   l   i   v   e   s 032  \v   P   I   Z   Z   A<br/>0000220       N   I   G   H   T     003<br/>0000230</span></pre><p id="d3e1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">仔细看字节。就在每个标题的文本前面有字段编号，每个字符串有长度，等等。如果您愿意，文档中包含了这种格式的详细描述。注意到我们的数据在这个文件中是很重要的。</p><p id="c103" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个需要注意的是相对大小的差异。文本形式比二进制形式占用更多的字节。</p><h1 id="0c8f" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用Node.js反序列化协议缓冲区消息</h1><p id="5422" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">因为协议缓冲区是语言中立的，所以我们可以使用用不同语言编写的代码来反序列化数据。但这是关于在Node.js中这样做的，所以让我们把重点放在那上面。</p><p id="5fc8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">创建一个名为<code class="fe mj mk ml mm b">decode.mjs</code>的文件，其中包含:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="a17a" class="np mp iu mm b gz nq nr l ns nt">import { default as Schema } from './todo_pb.js';<br/>import { promises as fsp } from 'fs';<br/><br/>const todosBin = await fsp.readFile('todos.bin');<br/>const todos = Schema.Todos.deserializeBinary(todosBin);<br/><br/>console.log(todos);<br/>console.log(todos.toObject());</span></pre><p id="1563" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这只是读取<code class="fe mj mk ml mm b">todos.bin</code>并将数据反序列化为一个对象。然后我们打印对象本身，以及<code class="fe mj mk ml mm b">toObject</code>表单。</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="73ba" class="np mp iu mm b gz nq nr l ns nt">{<br/>  wrappers_: { '1': [ [Object], [Object], [Object], [Object], [Object] ] },<br/>  messageId_: undefined,<br/>  arrayIndexOffset_: -1,<br/>  array: [ [ [Array], [Array], [Array], [Array], [Array] ] ],<br/>  pivot_: 1.7976931348623157e+308,<br/>  convertedPrimitiveFields_: {}<br/>}<br/>{<br/>  todosList: [<br/>    { id: 1, title: 'Buy cheese', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 2, title: 'Buy sauce', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 3, title: 'Buy Spinach', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 4, title: 'Buy ham', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 5, title: 'Buy olives', body: 'PIZZA NIGHT', precedence: 3 }<br/>  ]<br/>}</span></pre><p id="5196" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">第一个让您对协议缓冲区对象有所了解。我们不需要深究细节，但是看到这个还是挺有意思的。第二个是我们上面看到的相同数据，表明我们成功地将数据从一个应用程序传输到另一个应用程序。</p><h1 id="9ef7" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用协议缓冲区在应用程序之间传输数据</h1><p id="2e6f" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">从高层次来看，我们看到的流程是:</p><ol class=""><li id="0165" class="nv nw iu lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">在<code class="fe mj mk ml mm b">.proto</code>文件中定义模式，然后为所有感兴趣的语言生成代码</li><li id="a49c" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">传输数据从生成一个协议缓冲消息对象开始，然后调用<code class="fe mj mk ml mm b">serializeBinary</code>方法</li><li id="79bc" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">通过调用<code class="fe mj mk ml mm b">deserializeBinary</code>方法接收数据，将消息缓冲区转换成协议缓冲区对象，然后在应用程序中使用这些数据</li></ol><h1 id="a104" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">为Node.js/JavaScript使用备用协议缓冲区实现</h1><p id="fa97" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">当与Node.js一起使用时，官方的Google protocol buffers实现还有一些需要改进的地方。一个是<em class="mf"> protocolbuf.js </em>，它自称是一个纯JavaScript实现，支持TypeScript，可以在Node.js和浏览器上运行。</p><p id="8de4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有两个包:</p><ol class=""><li id="955f" class="nv nw iu lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">is包含对使用协议缓冲区对象、解析和使用模式等的运行时支持</li><li id="66f7" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe mj mk ml mm b">protobufjs-cli</code>是一个命令行工具，可以被视为大致相当于<code class="fe mj mk ml mm b">protoc</code></li></ol><p id="c755" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">文档(<a class="ae mn" href="https://www.npmjs.com/package/protobufjs" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/protobufjs</a>)讲述了两种使用模式:</p><ol class=""><li id="ff17" class="nv nw iu lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">不编译直接加载<code class="fe mj mk ml mm b">.proto</code>文件，并立即开始调用对象上的方法</li><li id="f75e" class="nv nw iu lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">将<code class="fe mj mk ml mm b">.proto</code>文件编译成静态类，类似于上面所示</li></ol><p id="5a24" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对于本教程，我们将使用第二种模式，以便更容易与我们刚刚走过的代码形成对比。</p><p id="c2f1" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">以这种方式安装软件包:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="b7c8" class="np mp iu mm b gz nq nr l ns nt">$ npm install protobufjs protobufjs-cli --save</span></pre><p id="05bd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">后者安装两个命令，<code class="fe mj mk ml mm b">pbjs</code>和<code class="fe mj mk ml mm b">pbts</code>，分别支持JavaScript和TypeScript用法。</p><p id="356c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要将<code class="fe mj mk ml mm b">.proto</code>文件编译成可用的代码，运行以下命令:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="f6f5" class="np mp iu mm b gz nq nr l ns nt">$ npx pbjs -t static-module -w commonjs -o dist-pbjs/todo.js todo.proto </span><span id="e6a0" class="np mp iu mm b gz nu nr l ns nt">#### OR, for ES6 code generation </span><span id="da56" class="np mp iu mm b gz nu nr l ns nt">$ npx pbjs -t static-module -w es6 -o dist-pbjs/todo-es6.mjs todo.proto</span></pre><p id="2a51" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这将旨在生成一个“静态模块”，这意味着创建源代码。模块格式将是CommonJS或ES6格式，这取决于您的偏好。注意，对于ES6模块，为了与Node.js兼容，我们用<code class="fe mj mk ml mm b">.mjs</code>扩展名来命名它。</p><p id="dede" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">检查生成的代码很有用，因为这是学习生成的API最实用的方法。我发现缺少项目文档，生成的代码足够清晰，可以直接理解如何使用这个包。</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="3348" class="np mp iu mm b gz nq nr l ns nt">import { default as Schema } from './dist-pbjs/todo.js';<br/>import { promises as fsp } from 'fs';<br/><br/>const todos = new Schema.Todos();<br/><br/>todos.todos.push(new Schema.Todo({<br/>    id: 1,<br/>    title: "Buy Cheese",<br/>    body: "PIZZA NIGHT",<br/>    precedence: Schema.Precedence.PRECEDENCE_HIGH<br/>}));<br/><br/>// ...<br/><br/>console.log(Schema.Todos.toObject(todos));<br/><br/>await fsp.writeFile('todos-protobufjs.bin', Schema.Todos.encode(todos).finish());</span></pre><p id="e2a4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">此包的用法略有不同。例如，我们可以使用属性对象实例化一个对象实例。研究源代码，我们看到属性是在我们可以直接赋值的地方生成的。</p><p id="038d" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><code class="fe mj mk ml mm b">toObject</code>和<code class="fe mj mk ml mm b">encode</code>方法不附属于对象实例，而是类的静态方法。因此，我们称之为<code class="fe mj mk ml mm b">Schema.Todos.toObject</code>而不是<code class="fe mj mk ml mm b">todos.toObject</code>。</p><p id="4832" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">运行应用程序，我们会看到<code class="fe mj mk ml mm b">toObject</code>表示的输出:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="ec46" class="np mp iu mm b gz nq nr l ns nt">{<br/>  todos: [<br/>    { id: 1, title: 'Buy Cheese', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 2, title: 'Buy sauce', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 3, title: 'Buy Spinach', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 4, title: 'Buy ham', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 5, title: 'Buy olives', body: 'PIZZA NIGHT', precedence: 3 }<br/>  ]<br/>}</span></pre><p id="cb31" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">和之前大致相同。输出文件的大小与上一个示例完全相同:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="1892" class="np mp iu mm b gz nq nr l ns nt">$ ls -l todos* <br/>-rw-rw-r-- 1 david david 152 Aug 22 11:38 todos.bin <br/>-rw-rw-r-- 1 david david 152 Aug 22 11:37 todos-protobufjs.bin</span></pre><p id="9942" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这验证了协议缓冲区是语言中立的观点，因为我们使用了两个不同的协议缓冲区实现来生成同一个文件。</p><p id="7759" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">对<code class="fe mj mk ml mm b">decode.mjs</code>做一点小小的改变，我们可以在命令行上命名文件，然后以这种方式解码数据文件:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="21dd" class="np mp iu mm b gz nq nr l ns nt">$ node decode.mjs todos-protobufjs.bin <br/>{<br/>  wrappers_: { '1': [ [Object], [Object], [Object], [Object], [Object] ] },<br/>  messageId_: undefined,<br/>  arrayIndexOffset_: -1,<br/>  array: [ [ [Array], [Array], [Array], [Array], [Array] ] ],<br/>  pivot_: 1.7976931348623157e+308,<br/>  convertedPrimitiveFields_: {}<br/>}<br/>{<br/>  todosList: [<br/>    { id: 1, title: 'Buy Cheese', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 2, title: 'Buy sauce', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 3, title: 'Buy Spinach', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 4, title: 'Buy ham', body: 'PIZZA NIGHT', precedence: 3 },<br/>    { id: 5, title: 'Buy olives', body: 'PIZZA NIGHT', precedence: 3 }<br/>  ]<br/>}</span></pre><p id="4edf" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这演示了用一种实现生成协议缓冲区文件，用另一种实现对其进行解码。</p><p id="1581" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">用protobufjs编写的解码器如下所示:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="f2b4" class="np mp iu mm b gz nq nr l ns nt">import { default as Schema } from './dist-pbjs/todo.js';<br/>import { promises as fsp } from 'fs';<br/><br/>const todosBin = await fsp.readFile(process.argv[2]);<br/><br/>const todos = Schema.Todos.decode(todosBin);<br/><br/>console.log(Schema.Todos.toObject(todos).todos);</span></pre><p id="a10c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">执行(<code class="fe mj mk ml mm b">node decode-protobufjs.mjs todos-protobufjs.bin</code>)如下所示:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="a447" class="np mp iu mm b gz nq nr l ns nt">[<br/>  {<br/>    id: Long { low: 1, high: 0, unsigned: false },<br/>    title: 'Buy Cheese',<br/>    body: 'PIZZA NIGHT',<br/>    precedence: 3<br/>  },<br/>  {<br/>    id: Long { low: 2, high: 0, unsigned: false },<br/>    title: 'Buy sauce',<br/>    body: 'PIZZA NIGHT',<br/>    precedence: 3<br/>  },<br/>  {<br/>    id: Long { low: 3, high: 0, unsigned: false },<br/>    title: 'Buy Spinach',<br/>    body: 'PIZZA NIGHT',<br/>    precedence: 3<br/>  },<br/>  {<br/>    id: Long { low: 4, high: 0, unsigned: false },<br/>    title: 'Buy ham',<br/>    body: 'PIZZA NIGHT',<br/>    precedence: 3<br/>  },<br/>  {<br/>    id: Long { low: 5, high: 0, unsigned: false },<br/>    title: 'Buy olives',<br/>    body: 'PIZZA NIGHT',<br/>    precedence: 3<br/>  }<br/>]</span></pre><p id="7c35" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">奇怪的是,<code class="fe mj mk ml mm b">id</code>字段以不同的方式表示。相反，它是一个似乎适合于表示数值范围的对象。否则，输出与前面的实现相同。</p><h1 id="9370" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用JSON、协议缓冲区和Protobuf对编码和解码进行基准测试。射流研究…</h1><p id="64b0" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">我创建了三对基准函数，它们只对预先创建的对象调用编码或解码函数。对于JSON，它用的是<code class="fe mj mk ml mm b">JSON.stringify</code>和<code class="fe mj mk ml mm b">JSON.parse</code>，其他用的是上面显示的函数。本例中的对象数组有1000个元素。</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="097c" class="np mp iu mm b gz nq nr l ns nt">$ node bench.mjs <br/>cpu: Intel(R) Core(TM) i7-5600U CPU @ 2.60GHz<br/>runtime: node v18.6.0 (x64-linux)<br/><br/>benchmark        time (avg)             (min … max)<br/>---------------------------------------------------<br/>encode-JSON  342.37 µs/iter   (311.93 µs … 1.19 ms)<br/>decode-JSON   435.9 µs/iter   (384.44 µs … 1.41 ms)<br/>encode-PB    946.43 µs/iter   (777.38 µs … 3.13 ms)<br/>decode-PB    770.79 µs/iter   (688.99 µs … 1.78 ms)<br/>encode-PBJS  696.75 µs/iter   (618.43 µs … 2.43 ms)<br/>decode-PBJS  455.36 µs/iter   (413.66 µs … 1.09 ms)</span></pre><p id="b88a" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有趣的是，JSON编码和解码明显快于同等的协议缓冲区。</p><p id="fb72" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">另一个衡量标准是每个表示的大小:</p><pre class="kk kl km kn gu nl mm nm nn aw no bi"><span id="d81b" class="np mp iu mm b gz nq nr l ns nt">-rw-rw-r-- 1 david david 328 Aug 22 16:46 todos.json <br/>-rw-rw-r-- 1 david david 152 Aug 22 11:38 todos.bin <br/>-rw-rw-r-- 1 david david 152 Aug 22 12:18 todos-protobufjs.bin</span></pre><p id="b1c8" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">等效的JSON是两倍多。显然，基于文本的数据格式将比二进制数据格式更大。</p><h1 id="f0df" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">摘要</h1><p id="d3b7" class="pw-post-body-paragraph kz la iu lb b lc ng jv le lf nh jy lh li ni lk ll lm nj lo lp lq nk ls lt lu in bi translated">Google的协议缓冲区是应用程序之间交换数据或应用程序存储数据的强大方式。它将数据结构编码为紧凑的二进制数据块。</p><p id="0865" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">协议缓冲区的主要优势是编码数据的大小。因为它被很好地指定，并且可以在多种编程语言中使用，所以它非常适合许多应用程序。</p><p id="7614" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">基于文本的数据格式也在多种编程语言中被很好地指定和使用。显然，大量应用程序使用JSON、YAML、XML等进行数据传输，证明了它们的有用性。但是，在保留网络带宽很重要的情况下，该怎么办呢？无论是容纳几十万台繁忙服务器的服务器场，还是连接5G蜂窝数据的远程安装的物联网设备，还是智能手机应用程序，在许多场景下，紧凑的二进制数据将提高性能或降低网络数据成本。</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><h1 id="ca92" class="mo mp iu bd mq mr oj mt mu mv ok mx my ka ol kb na kd om ke nc kg on kh ne nf bi translated">关于作者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/782322c10f70aa6b27c3f2810e042706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*kRbxL5h0ZzIl8hJ7.jpg"/></div></figure><p id="529e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><a class="ae mn" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iv">大卫·赫伦</strong> </a> <strong class="lb iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><p id="9303" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="mf">最初发表于</em><a class="ae mn" href="https://techsparx.com/nodejs/datastore/protocol-buffers.html" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://techsparx.com</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>