<html>
<head>
<title>Testing GraphQL Mutations In Ruby On Rails With RSpec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RSpec测试Ruby On Rails中的GraphQL突变</h1>
<blockquote>原文：<a href="https://itnext.io/testing-graphql-mutations-in-ruby-on-rails-with-rspec-219fbb1e71ab?source=collection_archive---------5-----------------------#2019-03-21">https://itnext.io/testing-graphql-mutations-in-ruby-on-rails-with-rspec-219fbb1e71ab?source=collection_archive---------5-----------------------#2019-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a0570cd3bfb1a654d9e92c47ac7c0432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5NETmR5VutRkK6a7-HumBg.jpeg"/></div></div></figure><div class=""/><p id="5ca0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上一篇<a class="ae kw" href="https://medium.com/@IreneuszSkrobis/graphql-mutations-in-ruby-on-rails-4f93f91b1f2d" rel="noopener">文章</a>中，我们在测试应用程序中添加了一些GraphQL变体。是时候为它们中的每一个创建自动化测试了。但是首先，我们需要建立RSpec来编写更好的规范。</p><h1 id="e4c3" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">RSpec和FactoryBot</h1><p id="29fa" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">安装Rspec和Factory Bot是微不足道的。首先，你必须将这些宝石添加到你的<code class="fe ma mb mc md b">Gemfile</code>:</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="595a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe ma mb mc md b">bundle install</code></p><p id="9348" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后跑<code class="fe ma mb mc md b">rails generate rspec:install</code></p><p id="132c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我建议做的最后一件事是将这一行添加到<code class="fe ma mb mc md b">spec/rails_helper.rb</code></p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0a6b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多亏了这一行，我们将能够使用简化的语法通过工厂来构建和创建对象。这意味着我们将能够简单地编写<code class="fe ma mb mc md b">create(:book)</code>，而不是<code class="fe ma mb mc md b">FactoryBot.create(:book)</code>。</p><h1 id="6133" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">工厂</h1><p id="2331" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我提到过，由于FactoryBot，我们将能够轻松地创建对象。但是为了有这种可能性，我们必须先定义那些工厂。我们需要创建其中的两个:</p><p id="9913" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">specs/factories/author_factory.rb</code></p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a1b8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">specs/factories/book_factory.rb</code></p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="fdcd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经万事俱备，可以开始写规格了。但请注意，现在，我们将只涵盖幸福的道路。</p><h1 id="935a" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建图书规格</h1><p id="72df" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在创建对象的过程中，我们可以编写的最重要的断言是检查对象是否被创建以及它在数据库中的字段是否正确。但是当我们测试GraphQL端点时，我们也希望确保它返回正确的对象。了解了所有这些之后，让我们来看看测试的最终版本。按照RSpec约定，我们将把我们的文件保存在<code class="fe ma mb mc md b">specs</code>文件夹中，与原始文件在同一个树目录中。简而言之，我们将我们的规范保存在<code class="fe ma mb mc md b">specs/graphql/mutations/books/create_book_spec.rb</code>中</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0524" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们测试了<code class="fe ma mb mc md b">.resolve</code>方法，我们检查了我之前提到的东西，因此编写并返回了对象。有两个独立的规范，我们希望对它们使用相同的查询。因此，当我们传递对我们重要的参数时，我们定义了<code class="fe ma mb mc md b">query</code>函数。在这种情况下，我们只需要通过<code class="fe ma mb mc md b">author_id</code>。</p><h1 id="079e" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更新手册规格</h1><p id="5883" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在<code class="fe ma mb mc md b">updateBook</code>规范中，我们将测试一个对象在操作后是否改变，以及是否返回正确的对象。代码将与前一个非常相似，我们将它放在<code class="fe ma mb mc md b">specs/graphql/mutations/books/update_book_spec.rb</code></p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="7274" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">销毁书规格</h1><p id="07d0" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">最后一个规格将为<code class="fe ma mb mc md b">destroyBook</code>突变而写。我们将重点检查对象是否被移除，以及在操作完成后是否返回移除的对象。正如您可能猜到的，我们将代码保存在<code class="fe ma mb mc md b">specs/graphql/mutations/books/destroy_book_spec.rb</code>中</p><figure class="me mf mg mh gt is"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="2a9a" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="3645" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为GraphQL变体编写规格说明与为控制器的动作编写规格说明没有什么不同。唯一的区别可能是定义了<code class="fe ma mb mc md b">query</code>方法。我强烈建议您使用<code class="fe ma mb mc md b">&lt;&lt;~</code>来编写多行查询并增加可读性。除此之外，你只需要专注于你想要在你的规范中涵盖的事情和边缘情况。仅此而已。编码快乐！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="38eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【selleo.com】最初发表于<a class="ae kw" href="https://selleo.com/blog/testing-graphql-mutations-in-ruby-on-rails-with-rspec" rel="noopener ugc nofollow" target="_blank"><em class="mr"/></a><em class="mr">。</em></p></div></div>    
</body>
</html>