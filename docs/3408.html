<html>
<head>
<title>Fail a test in Jest if an unexpected network request happens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果意外的网络请求发生，测试失败</h1>
<blockquote>原文：<a href="https://itnext.io/fail-a-test-in-jest-if-an-unexpected-network-request-happens-210ca4c159fa?source=collection_archive---------2-----------------------#2019-12-08">https://itnext.io/fail-a-test-in-jest-if-an-unexpected-network-request-happens-210ca4c159fa?source=collection_archive---------2-----------------------#2019-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="60e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<a class="ae kl" href="https://martinfowler.com/bliki/UnitTest.html" rel="noopener ugc nofollow" target="_blank">单元测试</a>不应该触发网络请求，比如对REST API的调用。它打破了隔离，会使测试变得不可靠。</p><p id="ef54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们应该嘲笑这些要求。<a class="ae kl" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae kl" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>提供了一种方便的方法。但是，如果你忘记嘲笑一些请求，该怎么办呢？我们将设置<em class="km"> Jest </em>的方式，如果尝试网络请求，测试将自动失败。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/263264889f213ae8ad67fff40294c531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*_HfTynfQ8LOCx3x2.png"/></div></figure><p id="2d4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近一直在使用<a class="ae kl" href="https://testing-library.com/" rel="noopener ugc nofollow" target="_blank"> react-testing-library </a>来测试<em class="km"> React </em>应用程序。它的核心设计原理是这样描述的:</p><blockquote class="kv kw kx"><p id="0729" class="jn jo km jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">你的测试越像你的软件被使用的方式，它们就越能给你信心。</p></blockquote><p id="46a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是好事！根据我的经验，一旦你习惯了，你会写更强的测试。但是，如果您使用此库，您可能会多次看到此错误消息:</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="8055" class="lg lh iq lc b gy li lj l lk ll">1: "Warning: An update to %s inside a test was not wrapped in act(...).· <br/>When testing, code that causes React state updates should be wrapped into act(...):·<br/> act(() =&gt; {<br/>   /* fire events that update state */ <br/>});</span></pre><p id="7170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这通常意味着当测试完成时，有挂起的异步请求。</p><h1 id="5faa" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们捕捉错误的第一次尝试</h1><p id="6f5c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">如果您使用<a class="ae kl" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App </a>，我们会在<code class="fe mo mp mq lc b">setupTests.js</code>中自动加载这个初始配置。这是相当标准的。</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="1da9" class="lg lh iq lc b gy li lj l lk ll">import '@testing-library/jest-dom/extend-expect'<br/>import { cleanup } from '@testing-library/react'  </span><span id="4060" class="lg lh iq lc b gy mr lj l lk ll">console.error = jest.fn()  </span><span id="1552" class="lg lh iq lc b gy mr lj l lk ll">afterEach(() =&gt; {<br/>   expect(console.error).not.toHaveBeenCalled() <br/>}) <br/>afterEach(cleanup)</span></pre><p id="5cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mo mp mq lc b">console.error</code>上失败是非常有用的，因为这将显示有挂起的请求。然而，输出可能会相当混乱。我的项目中有一个测试失败了，因为我们向一个组件添加了一个新的部分。新部分从一个端点获取数据并不明显，所以我们实际上通过到处添加<code class="fe mo mp mq lc b">await wait()</code>语句来“修复”它。</p><p id="4b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这并没有解决根本问题。我不得不花相当多的时间去挖掘它，然后才弄明白发生了什么。我们想要更清晰的反馈。</p><h1 id="5a26" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">更有针对性的方法</h1><p id="90b0" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们使用<a class="ae kl" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>来构建我们的API请求。任何没有被嘲笑的请求的测试都应该失败。为服务测试之类的事情添加显式模拟仍然是可能的。我们还使用<a class="ae kl" href="https://pact.io/" rel="noopener ugc nofollow" target="_blank">契约</a>进行<em class="km">契约测试</em>。这些测试是针对本地服务器的，运行时不应该激活任何模拟。我扩展了<code class="fe mo mp mq lc b">setupTests.js</code>文件来模仿<code class="fe mo mp mq lc b">axios</code>。</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="37b6" class="lg lh iq lc b gy li lj l lk ll">import axios from 'axios'</span><span id="4628" class="lg lh iq lc b gy mr lj l lk ll">const spies = {<br/>  get: jest.spyOn(axios, 'get'),<br/>  patch: jest.spyOn(axios, 'patch'),<br/>  post: jest.spyOn(axios, 'post')<br/>}</span><span id="a101" class="lg lh iq lc b gy mr lj l lk ll">beforeEach(() =&gt; {<br/>  jest.resetAllMocks()<br/>})</span><span id="671c" class="lg lh iq lc b gy mr lj l lk ll">afterEach(() =&gt; {<br/>  expect(spies.get).not.toHaveBeenCalled()<br/>  expect(spies.patch).not.toHaveBeenCalled()<br/>  expect(spies.post).not.toHaveBeenCalled()<br/>})</span></pre><p id="36eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。这样，任何试图执行意外请求的行为都会触发一个明确的失败断言。我们仍然需要处理<em class="km">预期的</em>请求。</p><h1 id="250b" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">嘲弄服务</h1><p id="ebae" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">此设置没有为请求定义任何退货。如果您正在为您的组件构建集成测试，您需要注意这一点。</p><p id="1b7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我倾向于在服务级别处理这个问题。我的请求通常封装在一个文件中，由需要它们的组件导入。我用Jest的<a class="ae kl" href="https://jestjs.io/docs/en/manual-mocks" rel="noopener ugc nofollow" target="_blank">手动模拟</a>，它比<code class="fe mo mp mq lc b">axios</code>高一级。一项服务可以像这样简单:</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="2edf" class="lg lh iq lc b gy li lj l lk ll">// src/recipe-list/recipeList.service.ts<br/>import axios, { AxiosResponse } from 'axios'<br/>import { Recipe } from 'components/recipe/types'</span><span id="8803" class="lg lh iq lc b gy mr lj l lk ll">export const recipeList = async (): Promise&lt;AxiosResponse&lt;Recipe[]&gt;&gt; =&gt; {<br/>  return axios('/rest/recipes')<br/>}</span></pre><p id="6e67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以用这样的手动模拟来代替:</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="c327" class="lg lh iq lc b gy li lj l lk ll">// src/recipe-list/__mocks__/recipeList.service.ts<br/>import { AxiosResponse } from 'axios'<br/>import { recipes } from '<a class="ae kl" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>/__fixtures__'<br/>import { Recipe } from 'components/recipe/types'</span><span id="3a18" class="lg lh iq lc b gy mr lj l lk ll">export const recipeList = async (): Promise&lt;AxiosResponse&lt;Recipe[]&gt;&gt; =&gt; {<br/>  return Promise.resolve({<br/>    status: 200,<br/>    statusText: 'OK',<br/>    data: recipes(),<br/>    headers: [],<br/>    config: {}<br/>  })<br/>}</span></pre><h1 id="2e56" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">直接嘲讽axios</h1><p id="a7f2" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">另一种选择是直接模仿<em class="km"> axios </em>并添加您的行为，这将取代我们最初定义的模仿。</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="3f84" class="lg lh iq lc b gy li lj l lk ll">jest.mock('axios')</span><span id="f5a0" class="lg lh iq lc b gy mr lj l lk ll">describe('service, () =&gt; {<br/>  beforeEach(() =&gt; {<br/>    ;(axios.get as jest.Mock).mockResolvedValue(response)<br/>  })<br/>})</span></pre><h1 id="4d45" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">重置模拟</h1><p id="bdd2" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">如果您需要<code class="fe mo mp mq lc b">axios</code>正常工作，就像在契约测试的情况下，您可以恢复原来的行为。</p><pre class="ko kp kq kr gt lb lc ld le aw lf bi"><span id="e0b2" class="lg lh iq lc b gy li lj l lk ll">beforeAll(() =&gt; {<br/>  jest.restoreAllMocks()<br/>})</span></pre><h1 id="93b5" class="lm lh iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">总结:明确你的错误</h1><p id="090c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">这就是事情的全部。一个简单的、虽然有点粗糙的解决方案，确保错误尽可能快地暴露出来，而不会被隐藏起来。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="667e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2019年12月8日https://hceris.com</em><em class="km">T21</em><a class="ae kl" href="https://hceris.com/jest-fail-test-if-unexpected-network-request-happens/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>