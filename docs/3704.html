<html>
<head>
<title>C# IEnumerator is hiding things</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# IEnumerator隐藏了一些东西</h1>
<blockquote>原文：<a href="https://itnext.io/c-ienumerator-is-hiding-things-d367dc31ebe5?source=collection_archive---------6-----------------------#2020-02-06">https://itnext.io/c-ienumerator-is-hiding-things-d367dc31ebe5?source=collection_archive---------6-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/630897243c0deeae4998eba4f0d9c847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9zS5BJKHtOdC8pfwzNiPA.jpeg"/></div></div></figure><p id="a6c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，一个同事在序列化我们的遗留应用程序的一个相当复杂的部分，做得有点过火，让序列化程序进入了未知的领域。这个应用程序在一个老式的<em class="kw"> IEnumerator </em>实现上出现了一个不错的<em class="kw"> StackOverflowException </em>崩溃。</p><p id="5b27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">崩溃发生在当前<em class="kw">的</em>实现上，看起来像这样:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生了什么是非常明显的，最初的开发者认为它会调用当前属性的另一个实现，但是它实际上递归地调用了自己，直到栈满并且应用崩溃。通过将显式实现转移到返回<em class="kw">对象</em>的<em class="kw"> Current </em>并保持代码的其余部分不变，这很容易纠正。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a08d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码现在没有bug了(至少是那部分)，一切都很好……除了……所有这些让我思考。我们到底是怎么陷入这种境地的，这个<em class="kw">枚举器</em>在代码的某个部分经常被使用，这个应用程序又是如何不崩溃的。更重要的是，<em class="kw">当前</em>属性的每个版本何时被调用，为什么。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="7ab4" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">非泛型IEnumerator和泛型IEnumerator</h1><p id="abdf" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">IEnumerator 和它的通用对应物<em class="kw"> IEnumerator &lt; T &gt; </em>是相当老的接口，一个从那时就存在了。Net 1，其他自。Net 2(随着泛型的到来)。泛型继承了非泛型，<em class="kw"> IEnumerator </em>仍然在这里可能主要是因为兼容性的原因。这是他们的定义。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="0625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们非常简单，不言自明。唯一有趣的是，它们都有一个名为<em class="kw"> Current </em>的只读属性，但返回类型不同。C#不允许你通过改变返回类型来覆盖一个方法，所以…这怎么可能呢？</p><p id="c9d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有可能是因为在那种情况下，不是覆盖，是<em class="kw">隐藏</em>。如果你查看类属<em class="kw"> IEnumerator </em>中定义的<em class="kw">当前</em>，你会看到<em class="kw">新</em>关键字。以下是<a class="ae mn" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-modifier" rel="noopener ugc nofollow" target="_blank"> C#参考</a>对<em class="kw">新</em>修改器的看法。</p><blockquote class="mo mp mq"><p id="4d1a" class="jy jz kw ka b kb kc kd ke kf kg kh ki mr kk kl km ms ko kp kq mt ks kt ku kv ij bi translated">当用作声明修饰符时，<code class="fe mu mv mw mx b">new</code>关键字显式隐藏从基类继承的成员。隐藏继承的成员时，该成员的派生版本将替换基类版本。尽管不使用<code class="fe mu mv mw mx b">new</code>修饰符也可以隐藏成员，但是会得到一个编译器警告。如果您使用<code class="fe mu mv mw mx b">new</code>来显式隐藏一个成员，它会取消这个警告。</p></blockquote><p id="b191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它实际上意味着什么？隐藏和覆盖有什么不同？我们来试一个小例子。</p><h2 id="27d1" class="my ll iq bd lm mz na dn lq nb nc dp lu kj nd ne ly kn nf ng mc kr nh ni mg nj bi translated">遗产</h2><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="efd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行这个示例，您显然会得到一个“汪汪”的输出。它是面向对象编程的基础。不管你的<em class="kw">狗</em>藏在<em class="kw">动物</em>变量里面，它还是一只狗，它会叫。</p><h2 id="0c21" class="my ll iq bd lm mz na dn lq nb nc dp lu kj nd ne ly kn nf ng mc kr nh ni mg nj bi translated">隐藏</h2><p id="bf36" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在，更令人困惑的是隐藏在<em class="kw">中的新</em>关键词。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="48b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，基于<strong class="ka ir">变量类型</strong>，输出是不同的。即使我们的对象仍然是一只狗，如果它所在的变量是一只<em class="kw">动物</em>，那么调用<em class="kw">动物</em>实现的<em class="kw">呼</em>方法。当它在<em class="kw"> Dog </em>变量中时，使用的是<em class="kw"> Dog </em>实现，因为它隐藏了<em class="kw">动物</em>one……哎哟。需要把握的一点是，我们使用<strong class="ka ir">隐藏</strong>是有原因的，在一个<em class="kw">狗</em>的对象中，<strong class="ka ir">既有</strong> <em class="kw">喊</em>的方法存在！你实际上可以通过在前面加上动物类名来访问它。</p><p id="3314" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不言而喻，这是令人难以置信的混乱，应该非常谨慎地使用，你应该有一个非常好的理由这样做，比如对于<em class="kw"> IEnumerator &lt; T &gt; </em>接口。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="203e" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">实现通用IEnumerator <t/></h1><p id="b254" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">回到我们的<em class="kw"> IEnumerator… </em>当我们实际实现<em class="kw"> IEnumerator &lt; T &gt; </em>接口时会发生什么？</p><p id="0108" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<em class="kw"> IEnumerator开始。当前</em>属性仅<strong class="ka ir"> <em class="kw">隐藏</em></strong><em class="kw">IEnumerator&lt;T&gt;。当前</em>属性，两者都存在。这意味着要实现这两个接口(因为泛型继承自非泛型，所以是强制性的)，我们需要实现<em class="kw">当前</em>属性的<strong class="ka ir">两个版本</strong>，一个具有返回类型<em class="kw">对象</em>，一个具有<em class="kw"> T </em>。</p><p id="15d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要使用<a class="ae mn" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation" rel="noopener ugc nofollow" target="_blank">显式接口实现</a>。通过在属性名之前添加接口名，我们可以定义一个实现<em class="kw"> IEnumerator </em>接口的属性和另一个实现<em class="kw"> IEnumerator &lt; T &gt; </em>接口的属性。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="7385" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，你可以看到我已经实现了三个版本的<em class="kw">当前</em>属性。第一个没有实现接口，它只属于<em class="kw"> ConfusingEnumerator </em>类，如果你有一个<em class="kw"> ConfusingEnumerator </em>类型的变量，它是唯一可用的。</p><p id="e411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个显式实现了<em class="kw">IEnumerator&lt;string&gt;</em>接口，第三个显式实现了<em class="kw"> IEnumerator </em>接口。显式实现不能是公共的。它们仅通过接口可见。</p><p id="8e7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在执行结果中看到的，根据对象所在的变量类型，调用不同的实现。这使我们能够回答两个接口。</p><p id="f6f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管您可以看到“same”<em class="kw">Current</em>属性可能有三种不同的实现，但这可能不是该接口的预期用途，泛型版本中的new关键字是为了避免无法用不同的返回类型覆盖。</p><p id="9e48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“标准”实现是隐式实现泛型<em class="kw"> Current </em>属性，显式实现非泛型，简单地调用隐式属性，就像这样。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="ca2c" class="lk ll iq bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">结论</h1><p id="7486" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我希望我能使接口的隐藏和显式实现的概念不那么混乱，并能解释泛型<em class="kw"> IEnumerator的奇怪情况。</em></p><p id="6e61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，这不是唯一一个继承了。Net框架，并且很容易错误地实现它们。</p><p id="b251" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随意添加备注或提问。</p></div></div>    
</body>
</html>