<html>
<head>
<title>Generating Kubernetes Network Policies Automatically By Sniffing Network Traffic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过嗅探网络流量自动生成Kubernetes网络策略</h1>
<blockquote>原文：<a href="https://itnext.io/generating-kubernetes-network-policies-by-sniffing-network-traffic-6d5135fe77db?source=collection_archive---------2-----------------------#2021-04-04">https://itnext.io/generating-kubernetes-network-policies-by-sniffing-network-traffic-6d5135fe77db?source=collection_archive---------2-----------------------#2021-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0a69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博文是关于一个实验，该实验基于从Kubernetes集群上运行的应用程序捕获的实际网络流量，自动创建<a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank"> Kubernetes网络策略</a>。</p><p id="d0e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这篇博文中提到的所有代码都可以在这里</strong><a class="ae kl" href="https://github.com/mcelep/blog/tree/master/automated-networkpolicy-generation" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a><strong class="jp ir">找到。</strong></p><p id="639f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">我们与一位VMware同事合作撰写了这篇博文:</em><a class="ae kl" href="https://ch.linkedin.com/in/assaf-sauer-b6261b23" rel="noopener ugc nofollow" target="_blank"><em class="km">Assaf Sauer</em></a><em class="km">。</em></p><h2 id="0047" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">但是为什么呢？</h2><p id="0693" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated"><a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="noopener ugc nofollow" target="_blank">网络策略</a>用于允许/阻止在Kubernetes集群上运行的应用程序的网络流量。处理关键客户数据的企业，如金融机构(银行、保险等。)有非常严格的安全要求，那些在Kubernetes集群上运行应用程序的人很可能使用<em class="km">网络策略</em>(或者根据他们使用的CNI插件，类似于它的东西，如<a class="ae kl" href="https://github.com/vmware-tanzu/antrea/blob/a9adf5a58acee9bfb06fbe75b0f2d097ec362c99/docs/antrea-network-policy.md" rel="noopener ugc nofollow" target="_blank"> Antrea的ClusterNetworkPolicy </a>或<a class="ae kl" href="https://docs.cilium.io/en/v1.8/concepts/kubernetes/policy/#ciliumnetworkpolicy" rel="noopener ugc nofollow" target="_blank"> CiliumNetworkPolicy </a>)来控制应用程序允许的入口/出口网络流量。</p><p id="f5f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于简单的应用程序，例如由前端和连接到数据库的后端组成的传统三层架构应用程序，创建<em class="km">网络策略</em>是非常简单的。然而，由许多组件组成的更复杂的应用程序(想想具有许多组件的基于微服务架构的应用程序)提出精确的正确网络策略(这里我们所说的精确是指，只有在明确需要时才允许两个组件之间的通信，并且只允许在已知的端口上通信)可能非常耗时。这就是为什么我们想出了几个脚本，使创建标准的(非CNI特定的)Kubernetes网络策略变得更容易。</p><h2 id="0ae4" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">怎么会？</h2><p id="42c6" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">网络策略生成自动化背后的想法很简单。下图对此进行了总结:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/a437cdb26337126b9e0d6a1bfd962acf.png" data-original-src="https://miro.medium.com/v2/0*eJf3zW3oAoUsIAaB"/></div></figure><p id="60e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它由下述步骤组成:</p><h2 id="a718" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">1)捕获网络流量</h2><p id="a96c" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">首先，我们需要一种方法来捕获每个pod运行的网络流量。我们使用传统的<a class="ae kl" href="https://en.wikipedia.org/wiki/Tcpdump" rel="noopener ugc nofollow" target="_blank"> tcpdump </a>来捕捉流量，使用<a class="ae kl" href="https://www.google.com/search?q=kubernetes+sidecar+pattern" rel="noopener ugc nofollow" target="_blank"> kubernetes sidecar模式</a>。为此，我们需要运行<a class="ae kl" href="https://hub.docker.com/r/dockersec/tcpdump" rel="noopener ugc nofollow" target="_blank"> tcpdump映像</a>的pod/容器的正确权限，即tcpdump容器需要以root用户身份运行。我们意识到这在高度安全的企业kubernetes安装中可能是不可行的。也就是说，此回购中脚本的预期用途是在集群中运行应用程序，该集群:</p><ul class=""><li id="8b16" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">根本不实施网络策略(或者通过使用诸如<a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic" rel="noopener ugc nofollow" target="_blank"> this </a>和<a class="ae kl" href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-egress-traffic" rel="noopener ugc nofollow" target="_blank"> this </a>之类的网络策略来允许所有入/出流量)</li><li id="4c84" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">允许pod以root用户身份运行</li></ul><p id="b82c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在一个群集上生成策略，而应用程序在另一个群集上运行，您需要确保为网络策略指定的IPs、FQDNs针对目标环境进行了相应的调整。例如，如果有一个用于连接到在IP 10.2.3.4上运行的Oracle数据库的出口网络策略，并且如果该IP在应用程序将部署到的实际目标环境上不同，则您将需要调整该IP。</p><h2 id="a527" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">2)生成网络流量</h2><p id="003a" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">为了创建正确的网络策略，我们需要捕获代表所有用例的网络流量，从而捕获与应用程序相关的所有潜在网络通信。由您来确保在捕获网络流量期间，您在应用程序上生成有意义的负载。例如，如果您的应用程序是一个基于REST的web应用程序，您应该确保访问所有相关的REST端点。如果应用程序基于从MessageQueue接收的消息进行一些处理，那么就由您将这些消息发送到队列，以便应用程序执行它在生产中通常执行的操作。</p><h2 id="c5a8" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">3)收集捕获文件和Kubernetes数据</h2><p id="16f1" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">Tcpdump sidecar容器使用以下命令运行tcpdump:<code class="fe mh mi mj mk b">tcpdump -w /tmp/tcpdump.pcap</code>。因此，在我们分析流量之前，我们需要从pod收集所有pcap文件。此外，我们还需要一些来自Kubernetes的元数据。我们将获取有关Kubernetes资源的信息，如服务、部署、副本集等，以便稍后我们可以使用这些信息来分析哪个应用程序拥有哪个IP。</p><h2 id="6d40" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">4)分析数据并生成网络策略</h2><p id="ec27" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">收集了所有关于IP、端口和标签的数据包捕获和kubernetes数据后，现在我们可以构建一个图表。在该图中，节点/顶点将代表pod，而边将是这些pod之间的网络通信。在生成网络策略的python脚本中，首先构建一个图，然后遍历边，并为每条边生成一个网络策略。</p><h2 id="fdf9" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">让我们看看它的实际效果吧！</h2><p id="319b" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">让我们看一下下面的步骤，看看我们能否为测试应用程序生成网络策略。测试应用程序是一个来自谷歌的微服务演示应用程序，可以在<a class="ae kl" href="https://github.com/GoogleCloudPlatform/microservices-demo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="00f4" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">环境准备</h2><p id="adf2" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">您需要访问Kubernetes集群，并且需要安装以下工具:</p><ul class=""><li id="c0ed" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">Kubernetes CLI</li><li id="f042" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">Python (v3)</li><li id="2c6e" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">Pip(管理python依赖关系)(v3)</li><li id="4988" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">Tshark是一个基于终端的<a class="ae kl" href="https://www.wireshark.org/" rel="noopener ugc nofollow" target="_blank"> Wireshark </a>(见<a class="ae kl" href="https://www.wireshark.org/docs/man-pages/tshark.html" rel="noopener ugc nofollow" target="_blank">此处</a>)</li><li id="d12c" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kl" href="https://man7.org/linux/man-pages/man1/cut.1.html" rel="noopener ugc nofollow" target="_blank">切</a></li><li id="9d5c" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated"><a class="ae kl" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> Jq </a></li></ul><p id="8e08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安装python依赖项，从顶层项目文件夹运行以下命令:<code class="fe mh mi mj mk b">pip install -r requirements.txt</code></p><p id="98a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经在Mac OS和Linux上测试了这个报告中的脚本。</p><h2 id="b3b6" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">部署测试应用程序</h2><p id="1102" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated"><code class="fe mh mi mj mk b">env.sh</code>顶层项目文件夹中的文件包含一些在多个脚本中使用的变量。请用您的首选值覆盖这些变量，例如<strong class="jp ir"> TARGET_NS </strong>是将用于所有脚本的Kubernetes名称空间。默认情况下<em class="km"> TARGET_NS </em>设置为<em class="km"> netpol-demo </em>，如果您愿意，您可以对其进行编辑。</p><p id="d8c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的摘录用于创建Kubernetes名称空间，然后部署一个测试应用程序。这种情况下的测试应用程序是一个微服务演示应用程序，可以在本<a class="ae kl" href="https://github.com/GoogleCloudPlatform/microservices-demo" rel="noopener ugc nofollow" target="_blank">报告</a>中找到。然而，你可以使用任何你喜欢的应用程序。</p><pre class="ll lm ln lo gt ml mk mm mn aw mo bi"><span id="1ace" class="kn ko iq mk b gy mp mq l mr ms">source env.sh<br/># create a namespace if it does not already exist<br/>kubectl create ns $TARGET_NS --dry-run -o yaml  | kubectl apply -f -<br/># deploy application<br/>kubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/microservices-demo/cbd3c9643400de7471807821e212a6f3db38ed14/release/kubernetes-manifests.yaml -n ${TARGET_NS}</span></pre><h2 id="836c" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">$TARGET_NS中的修补程序部署</h2><p id="a788" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">运行以下命令:<code class="fe mh mi mj mk b">./1-inject-sidecar.sh</code>修补所有部署，并注入一个sidecar容器，该容器使用以下命令运行tcpdump:<code class="fe mh mi mj mk b">tcpdump -w /tmp/tcpdump.pcap</code>。在我们的测试应用程序中，我们只有由部署控制的pod。如果您要使用一个不同的应用程序，演示谷歌应用程序在这里使用，您将需要采用sidecar注入机制。</p><h2 id="76bb" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">准备复制捕获和元数据</h2><p id="6491" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">注意，下面的脚本(<em class="km">2-copy-capture-and-metadata . sh</em>)将捕获pod名称，然后打印出它将等待<em class="km"> TEST_DURATION_IN_SECONDS </em>。在此期间，您应该“加载”应用程序，以便生成涵盖真实用例中所有潜在通信模式的网络流量。</p><p id="afb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行下面的命令:</p><p id="87e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">./2-copy-capture-and-metadata.sh</code></p><p id="4055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在运行该脚本时遇到问题，可以重新运行它。请记住，虽然你将需要确保在重新运行的应用程序流量也产生。</p><h2 id="7e39" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">产生流量</h2><p id="5743" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">在我们的演示应用程序中，有一个名为<em class="km">负载生成器</em>的pod，它将与其他应用程序组件一起部署。这个pod不断调用ui来生成应用程序流。您可以通过运行<code class="fe mh mi mj mk b">kubectl -n $TARGET_NS logs $(kubectl get pods -l app=loadgenerator -o jsonpath='{.items[0].metadata.name}' -n $TARGET_NS) -c main</code>来查看<em class="km">负载生成器</em> pod的日志。</p><p id="59bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果使用相同的谷歌微服务演示应用程序来产生网络流量，则不需要做任何额外的工作。然而，如果您使用另一个应用程序，您将需要运行您自己的负载生成工具，而脚本<em class="km">。/2-copy-capture-and-metadata . sh</em>继续输出该消息:“将等待X秒，以便生成应用程序流量……”</p><h2 id="850b" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">分析数据并构建网络策略</h2><p id="fe9c" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">运行以下命令来分析数据并生成网络策略。脚本的输入是一个以<em class="km"> capture- </em>为前缀的捕获json文件。您可以通过运行<code class="fe mh mi mj mk b">ls .tmp/capture-*.json</code>找到候选捕获文件。</p><pre class="ll lm ln lo gt ml mk mm mn aw mo bi"><span id="e93c" class="kn ko iq mk b gy mp mq l mr ms">./3-analyse.py .tmp/capture-XXX.json</span></pre><p id="347a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成的网络策略应该在<em class="km">中。tmp/网络策略</em>文件夹。对于我们的演示应用程序，我们为每个应用程序生成了一个网络策略文件，包括入口和出口规则。此外，默认情况下会创建一个允许在端口53上进行出站通信的DNS策略。</p><p id="9357" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为运行<em class="km"> 3-analyse.py </em>脚本的结果，还有一个图形(以<a class="ae kl" href="https://graphviz.org/doc/info/lang.html" rel="noopener ugc nofollow" target="_blank">点</a>格式)生成。您可以使用在线工具，如<a class="ae kl" href="https://dreampuf.github.io/GraphvizOnline" rel="noopener ugc nofollow" target="_blank"> this </a>或<a class="ae kl" href="https://edotor.net/" rel="noopener ugc nofollow" target="_blank"> this </a>来创建图表的可视化表示。以下是一些通过点表示创建的图像示例。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/bd45b45c7018deff92623bc898dbbad2.png" data-original-src="https://miro.medium.com/v2/0*CyvkG8BJy4hcoUej"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><a class="ae kl" href="https://github.com/mcelep/blog/blob/master/automated-networkpolicy-generation/graph_ms_demo.png?raw=true" rel="noopener ugc nofollow" target="_blank">https://github . com/MC elep/blog/blob/master/automated-network policy-generation/graph _ ms _ demo . png？raw=true </a></figcaption></figure><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/acc434ec5851d8dd54c2a1afaacef8c8.png" data-original-src="https://miro.medium.com/v2/0*-A3UCrtT33L_73xP"/></div></figure><h2 id="e42c" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">清理</h2><p id="221c" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">只要tcpdump sidecar在运行，它就会持续捕获网络流量。所以，不要忘记在你完成后把那些边车容器拿走。运行<code class="fe mh mi mj mk b">./4-delete-sidecar.sh</code>清除tcpdump边车容器。</p><h2 id="9d31" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">逮到你了</h2><p id="0a35" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">此报告中的脚本是在概念验证设置中创建的，代码质量有改进的空间。有一些限制:</p><ul class=""><li id="5d8d" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">开发脚本是为了为在单个命名空间中运行pod的应用程序生成网络策略。因此，如果有调用发生在应用程序运行的地方之外的其他名称空间，网络策略将不会被正确处理。</li><li id="034d" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">进出群集外部的流量的网络策略规则是基于IP的。如果应用程序与受我的多个IP支持的域通信，则只有在脚本运行期间解析的IP才有网络策略规则。所以，你可能会错过一些规则。</li><li id="f563" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">仅分析TCP流量。有一个为DNS生成的网络策略，但不会创建其他基于UDP的网络策略。</li><li id="c7a8" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">运行tcpdump需要一些提升的权限。在实施网络策略的环境/集群中，您可能无法获得这些提升的权限。然而，我们认为，这篇博文中提供的概念/脚本在一些用例中可能是有益的，比如用于Kubernetes的COTS(商业现货)软件。在Kubernetes上的COTS软件场景中，供应商可以从在集群中生成网络策略中获益，从安全角度来看，这种策略不是非常严格。然后，生成的网络策略可以作为模板提供给软件供应商的客户。</li></ul><p id="68d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意扩展这些脚本以涵盖更多的用例:)</p></div></div>    
</body>
</html>