<html>
<head>
<title>Test-Driven Development In Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振的试验驱动发展</h1>
<blockquote>原文：<a href="https://itnext.io/test-driven-development-in-flutter-e7fe7921ea92?source=collection_archive---------2-----------------------#2020-02-25">https://itnext.io/test-driven-development-in-flutter-e7fe7921ea92?source=collection_archive---------2-----------------------#2020-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d3d6716746051a75e0adfcdd1c1b3955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N2BXwOQSUtG8FegnyudvuA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">试验驱动的发展颤振</figcaption></figure><p id="1445" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">测试驱动开发(TDD)是软件开发中的一个原则，它禁止我们在编写测试之前编写代码/实现。</p><p id="f548" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据Bob叔叔的说法，TDD有3条规则:</p><blockquote class="la lb lc"><p id="4dd3" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq"> 1。除非是为了通过失败的单元测试，否则不允许编写任何产品代码。</em></p><p id="1a28" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq"> 2。不允许编写任何超过足以导致失败的单元测试；编译失败就是失败。</em></p><p id="98e8" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq"> 3。除了足以通过一个失败的单元测试之外，您不允许编写更多的产品代码。<br/>——鲍勃大叔(</em><a class="ae lh" href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd" rel="noopener ugc nofollow" target="_blank"><em class="iq">http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd</em></a><em class="iq">)</em></p></blockquote><p id="36c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个我们必须重复的循环。我们对我们想要实现的东西写一个测试，这样当测试运行时，结果将是“失败”,然后我们写一个<strong class="ke ir">足够</strong>的实现，这样测试就通过了。然后，我们修正我们的代码质量，这可能是我们忽略的，因为我们关注于使测试通过而不使测试失败。</p><p id="e143" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有些人试图先写实现，再写测试，然后只提交测试。这就是现在人们应该如何对待TDD。你应该注意到，你只能实现足够通过测试的代码(Bob叔叔的规则3)。</p><h1 id="bfb9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">颤振中的TDD</h1><p id="dce8" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">为了理解Flutter中的这个概念，让我们跳到一个实际的例子中。出于本教程的目的，我将使用PiggyX应用程序。这些代码可以在Github上找到。点击<a class="ae lh" href="https://github.com/Mastersam07/PiggyX" rel="noopener ugc nofollow" target="_blank">这里的</a>进入代码。</p><p id="718b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将创建并测试几个简单的功能:<code class="fe ml mm mn mo b">EmailFieldValidator</code>、<code class="fe ml mm mn mo b">PasswordFieldValidator</code>。让我们通过创建一个名为<code class="fe ml mm mn mo b">loginpage.dart</code>的新文件来分离登录逻辑，并实现如下:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="b028" class="mx lj iq mo b gy my mz l na nb">class EmailFieldValidator {<br/>  static String <em class="ld">validate</em>(String value) {<br/>    return false;<br/>  }<br/>}<br/><br/>class PasswordFieldValidator {<br/>  static String <em class="ld">validate</em>(String value) {<br/>    return false;<br/>  }<br/>}</span></pre><p id="eee5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们为上面的验证器编写测试。我们转到测试文件夹，删除默认的<code class="fe ml mm mn mo b">widget_tests.dart</code>，并添加一个名为<code class="fe ml mm mn mo b">fieldvalidators_tests.dart</code>的新文件。我们实现如下所示的测试:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="cfc5" class="mx lj iq mo b gy my mz l na nb">import 'package:PiggyX/ui/loginpage.dart';<br/>import 'package:flutter_test/flutter_test.dart';<br/><br/>void main() {<br/><br/>  test('empty email returns error string', () {<br/><br/>    final result = EmailFieldValidator.<em class="ld">validate</em>('');<br/>    expect(result, 'Email can\'t be empty');<br/>  });<br/><br/>  test('non-empty email returns null', () {<br/><br/>    final result = EmailFieldValidator.<em class="ld">validate</em>('email');<br/>    expect(result, null);<br/>  });<br/><br/>  test('empty password returns error string', () {<br/><br/>    final result = PasswordFieldValidator.<em class="ld">validate</em>('');<br/>    expect(result, 'Password can\'t be empty');<br/>  });<br/><br/>  test('non-empty password returns null', () {<br/><br/>    final result = PasswordFieldValidator.<em class="ld">validate</em>('password');<br/>    expect(result, null);<br/>  });<br/>}</span></pre><p id="9e61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的内容中，我们预计会出现以下情况:<br/> i)电子邮件字段不得为空<br/> ii)密码字段不得为空<br/>如果我们想要，我们可以扩展测试用例，但出于本教程和本<a class="ae lh" href="https://github.com/Mastersam07/PiggyX" rel="noopener ugc nofollow" target="_blank">应用程序</a>的目的，我们将坚持使用这两个。</p><p id="03d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们尝试在实现之前运行<code class="fe ml mm mn mo b">flutter test</code>时，您可能会看到<code class="fe ml mm mn mo b">+0 -4: Some tests failed</code>。这告诉我们，0个测试通过(+)，4个测试失败(-)😪 😪 😪。</p><p id="0ac6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们现在在TDD模式下修复它们吧！</p><p id="2528" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前往<code class="fe ml mm mn mo b">loginpage.dart</code>并修理<code class="fe ml mm mn mo b">EmailFieldValidator</code>:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="3b82" class="mx lj iq mo b gy my mz l na nb">static String <em class="ld">validate</em>(String value) {<br/>  return value.isEmpty ? 'Email can\'t be empty' : null;<br/>}</span></pre><p id="1835" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">再次运行测试，您应该会看到<code class="fe ml mm mn mo b">+2 -2</code>。</p><p id="b572" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们前往<code class="fe ml mm mn mo b">loginpage.dart</code>并用以下代码修复<code class="fe ml mm mn mo b">PasswordFieldValidator</code>:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="8d3e" class="mx lj iq mo b gy my mz l na nb">static String <em class="ld">validate</em>(String value) {<br/>  return value.isEmpty ? 'Password can\'t be empty' : null;<br/>}</span></pre><p id="5c2e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">再次运行测试，您应该<code class="fe ml mm mn mo b">+4: All Tests Passed!</code>💃 💃 💃</p><p id="2806" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您已经使用Flutter以TDD方式成功测试了您的应用程序！你应该得到一些荣誉。现在，可以安全地完成我们的循环了，因为我们特性的目标现在已经完成了(只制作UI)！</p><p id="cb58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些代码可以在GitHub repo <a class="ae lh" href="https://github.com/Mastersam07/PiggyX" rel="noopener ugc nofollow" target="_blank"> PiggyX </a>中找到。</p><p id="4c72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">加分<br/> </strong>对于嘲讽依赖，可以利用<a class="ae lh" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> mockito包</a>。例如，我们需要能够模拟来自应用程序需求的数据，以便根据API进行身份验证，而不是依赖于实时API，模拟实时web服务或数据库以根据情况返回特定结果，使用firebase.e.t.c进行操作。我们需要做的就是通过手动编码或使用<a class="ae lh" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> mockito包</a>创建一个类的替代实现。你可以遵循这个关于<a class="ae lh" href="https://flutter.dev/docs/cookbook/testing/unit/mocking" rel="noopener ugc nofollow" target="_blank">嘲讽</a>的指南。</p><p id="7d12" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您有任何问题，请随时发表评论🙂。</p><h1 id="2d7d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">参考资料:</h1><p id="5f73" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated"><a class="ae lh" href="https://flutter.dev/docs/cookbook/testing" rel="noopener ugc nofollow" target="_blank">颤振测试</a> <br/> <a class="ae lh" href="https://flutter.dev/docs/testing" rel="noopener ugc nofollow" target="_blank">测试颤振app</a><br/><a class="ae lh" href="https://flutter.dev/docs/cookbook/testing/unit/mocking" rel="noopener ugc nofollow" target="_blank">嘲讽依赖使用Mockito </a> <br/> <a class="ae lh" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank"> Mockito包</a></p></div></div>    
</body>
</html>