<html>
<head>
<title>Running and Writing Gatekeeper Policies in Kubernetes — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中运行和编写网守策略—第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/running-and-writing-gatekeeper-policies-in-kubernetes-part-2-1c49c1c683b2?source=collection_archive---------3-----------------------#2021-09-07">https://itnext.io/running-and-writing-gatekeeper-policies-in-kubernetes-part-2-1c49c1c683b2?source=collection_archive---------3-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="013c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">系列概述</h1><p id="a4e2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本系列文章考察了一个自以为是的Kubernetes网关守护设备策略生态系统，包括什么是网关守护设备，为什么使用网关守护设备，编写和测试策略，将策略部署到本地Kubernetes集群，以及如何使它们对用户可见。本系列的所有代码都位于这个GitHub存储库中:</p><div class="lj lk gp gr ll lm"><a href="https://github.com/sebradloff/k8s-gatekeeper-policies-example" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">GitHub-sebradloff/k8s-网关守护设备-策略-示例</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">在GitHub上创建一个帐户，为sebradloff/k8s-gate keeper-policies-example开发做出贡献。</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">github.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma mb lm"/></div></div></a></div><p id="d709" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><a class="ae mh" href="https://medium.com/@sebradloff/running-gatekeeper-in-kubernetes-and-writing-policies-part-1-fcc83eba93e3" rel="noopener"> <strong class="kn ir">第1部分:网守组件和架构概述</strong> </a></p><h1 id="8116" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">第2部分概述</h1><p id="92bb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我们将回顾最初的项目设置，利用<a class="ae mh" href="https://github.com/plexsystems/konstraint" rel="noopener ugc nofollow" target="_blank"> konstraint </a> cli编写策略，创建一个本地<a class="ae mh" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">种类的Kubernetes集群</a>和<a class="ae mh" href="https://github.com/sighupio/gatekeeper-policy-manager" rel="noopener ugc nofollow" target="_blank">网关守护设备策略管理器</a>(查看策略和违规的UI)，并将这些策略应用到集群。</p><h1 id="f221" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">初始项目设置和概述</h1><p id="69aa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们回顾一下高级存储库结构，让我们的本地集群启动并运行起来。</p><p id="0404" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我假设您在Mac上运行这个程序，但是它应该也可以在Linux上运行。将项目依赖项<a class="ae mh" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> docker </a>、<a class="ae mh" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>和<a class="ae mh" href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation" rel="noopener ugc nofollow" target="_blank"> kind </a>作为二进制文件安装在您的路径中。安装完依赖项后，克隆GitHub存储库:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b808" class="mr jo iq mn b gy ms mt l mu mv">git clone <a class="ae mh" href="https://github.com/sebradloff/k8s-gatekeeper-policies-example.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sebradloff/k8s-gatekeeper-policies-example.git</a></span></pre><h2 id="5777" class="mr jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">知识库结构</h2><p id="10a1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">目录是我们写政策的地方。<code class="fe nh ni nj mn b">policies/</code>目录中的每个新子目录都代表一个新策略的名称，我们将在其中创建定义策略的<code class="fe nh ni nj mn b">src.rego</code>和测试策略的<code class="fe nh ni nj mn b">src_test.rego</code>。</p><p id="cd5c" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">每个策略子目录都有一个代表约束和约束模板的<code class="fe nh ni nj mn b">constraint.yaml</code>和<code class="fe nh ni nj mn b">template.yaml</code>，由<a class="ae mh" href="https://github.com/plexsystems/konstraint" rel="noopener ugc nofollow" target="_blank"> konstraint </a> cli通过rego上的注释生成。<code class="fe nh ni nj mn b">policies/lib/</code>目录包含一个konstraint <a class="ae mh" href="https://github.com/plexsystems/konstraint/tree/main/examples/lib" rel="noopener ugc nofollow" target="_blank">标准Kubernetes库</a>的副本，我们在我们的策略中使用它。为什么要重新发明轮子？</p><p id="eeb7" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">manifests/</code>目录是通过脚本放置所有约束和约束模板的地方。在某些情况下，我们希望手动生成约束，这就是为什么在konstraint cli策略创建命令期间，所有的CRD都没有放入<code class="fe nh ni nj mn b">manifests/</code>目录。</p><p id="51ec" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">scripts/</code>目录包含一组初始设置或持续集成过程所需的脚本和配置。</p><p id="c570" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">gatekeeper-infra-manifests/</code>目录包含最初用网关守护设备和网关守护设备策略管理器配置我们的集群所必需的Kubernetes清单。</p><p id="596d" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">Makefile</code>保存了我们需要运行的所有命令，以建立我们的集群并快速迭代我们的策略。</p><h2 id="0c7d" class="mr jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">集群设置</h2><p id="4dde" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将使用我们的网关守护设备和网关守护设备策略管理器Kubernetes manifests建立一个友好的Kubernetes集群。运行以下两个make目标来创建集群并应用Kubernetes清单。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8fbf" class="mr jo iq mn b gy ms mt l mu mv">make kind_cluster_setup<br/>make kubectl_apply_gatekeeper_infra</span></pre><p id="b48f" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">运行这些命令可能需要几分钟时间来设置群集，并提取运行Gatekeeper pods所需的docker映像。</p><p id="7652" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">如果您想使用kubectl查看集群，请确保使用Makefile中定义的kubeconfig。</p><p id="4e45" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">您可以通过运行<code class="fe nh ni nj mn b">make port_forward_gatekeeper_policy_manger_ui</code>并在浏览器的<code class="fe nh ni nj mn b">localhost:8080</code>访问网关守护设备策略管理器UI，确保一切正常运行。</p><figure class="mi mj mk ml gt nl gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nk"><img src="../Images/1173441613a1eca3d3a0d168ed9d76b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6GGrta6sYONiaM1RgR0dw.png"/></div></div></figure><h1 id="3c9b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">迭代网关守护设备策略</h1><p id="b5c9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本节中，我们将重点关注网关守护设备策略的迭代过程。我们将首先编写一个策略，测试它，生成Kubernetes资源，将它们应用到集群，并证明违反策略的对象拒绝。我们将要开始的策略是确保所有名称空间都有一个“团队”标签。</p><h2 id="5705" class="mr jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">撰写政策</h2><p id="394d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先创建目录<code class="fe nh ni nj mn b">policies/namespace-team-label-01/</code>，我们将在其中存储该策略所需的所有文件。我们将在<code class="fe nh ni nj mn b">policies/namespace-team-label-01/src.rego</code>文件中定义策略本身。</p><figure class="mi mj mk ml gt nl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f173" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">从文件的顶部开始，我们有konstraint cli使用的注释和注释。<code class="fe nh ni nj mn b">@title</code>注释表示策略的标题以及策略的描述，在生成的策略文档中使用。</p><p id="cbf3" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">@enforcement</code>标签用于告诉konstraint哪个<a class="ae mh" href="https://open-policy-agent.github.io/gatekeeper/website/docs/violations/#dry-run-enforcement-action" rel="noopener ugc nofollow" target="_blank">执行动作</a>用于生成的约束。现在，我们将坚持“拒绝”，但我们将讨论如何在未来利用“干运行”。</p><p id="bfa0" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">@kinds</code>是我们指定我们希望将这个策略应用到哪些Kubernetes资源类型的地方，这些资源类型被添加到约束匹配器中。在我们的例子中，我们只关注名称空间。</p><p id="9fba" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">package</code>定义了rego模块的名称，如果需要，可以将它导入到其他策略中。</p><p id="92ad" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">现在说正题，遵循<a class="ae mh" href="https://github.com/open-policy-agent/frameworks/blob/4f80ac172ddffad377f88986a162242dcf772eb6/constraint/README.md#rule-schema" rel="noopener ugc nofollow" target="_blank">规则模式</a>的看门人需要<code class="fe nh ni nj mn b">violation</code>规则。括号<code class="fe nh ni nj mn b">[{"msg": msg, “details": {}}]</code>定义了违例函数的预期返回参数。这就是我们如何向集群用户反馈为什么网关守护设备拒绝了对其资源的更改。值得注意的是“细节”键是可选的。</p><p id="b579" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated"><code class="fe nh ni nj mn b">violation</code>的主体是我们定义政策的地方。<strong class="kn ir">我建议将您的策略视为一组真或假的陈述，需要评估为真才会发生违规</strong>。首先，我们将输入对象定义为一个名为<code class="fe nh ni nj mn b">resource</code>的变量。如果team标签不存在，或者其中任何一个键的值为null，那么该语句的值应该为true。因为它评估为真，所以它继续遍历违例块并创建<code class="fe nh ni nj mn b">msg</code>变量。<code class="fe nh ni nj mn b">msg</code>变量被定义为名称空间名称的插值字符串，它解释了名称空间被拒绝的原因。</p><h2 id="8896" class="mr jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">为策略编写测试</h2><p id="e0eb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae mh" href="https://www.openpolicyagent.org/docs/latest/policy-testing/" rel="noopener ugc nofollow" target="_blank"> OPA为我们提供了在类似style的单元测试中直接测试策略</a>的能力。我们创建一个名为<code class="fe nh ni nj mn b">src_test.rego</code>的文件，因为konstraint库在生成CRDs时会忽略所有带有<code class="fe nh ni nj mn b">_test.rego</code>的文件。测试被表示为减压阀规则，规则名称的必要约定是以<code class="fe nh ni nj mn b">test_</code>为前缀。在文件的顶部，我们声明了与策略相同的包名来调用策略中声明的函数。</p><figure class="mi mj mk ml gt nl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e3ed" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">以上是最简单的测试例子。一个<code class="fe nh ni nj mn b">input</code>变量定义了传入违规规则的审查对象。在这里，它是一个名称空间Kubernetes资源。然后用输入变量调用<code class="fe nh ni nj mn b">violation</code>规则，返回值存储在<code class="fe nh ni nj mn b">results</code>变量中。然后，根据测试的情况，如果我们预期会有一个违例，我们期望结果包含一组对象，如果没有违例，则包含一个空集。</p><p id="54e8" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">在这个项目中，我们使用<code class="fe nh ni nj mn b">make opa_test</code>运行测试，它在我们的policies目录下的OPA docker容器中运行OPA test命令。如果你想在一个正在运行的测试中理解一个变量在策略或者测试中的值，你需要使用<code class="fe nh ni nj mn b"><a class="ae mh" href="https://www.openpolicyagent.org/docs/latest/policy-reference/#debugging" rel="noopener ugc nofollow" target="_blank">trace</a></code> <a class="ae mh" href="https://www.openpolicyagent.org/docs/latest/policy-reference/#debugging" rel="noopener ugc nofollow" target="_blank">内置函数</a>，并且测试需要失败。</p><div class="lj lk gp gr ll lm"><a href="https://asciinema.org/a/QVgjReiQFtFEdxb652tNZrVCj" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">调试测试</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">由sebradloff录制</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">asciinema.org</p></div></div><div class="lv l"><div class="nt l lx ly lz lv ma mb lm"/></div></div></a></div><p id="cf4d" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">在上面的记录中，我使用trace函数打印出results变量的值，并使用语句<code class="fe nh ni nj mn b">true == false</code>故意使测试失败。当测试运行时，失败测试的输出显示我的打印语句，前缀为<code class="fe nh ni nj mn b">Note</code>。</p><h2 id="9a63" class="mr jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">生成Kubernetes策略清单</h2><p id="d089" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们已经编写了策略并对其进行了有效的测试，我们希望创建Kubernetes资源来将策略应用到我们的集群。在这个项目中，我们可以运行<code class="fe nh ni nj mn b">make generate_all</code>目标来运行测试并生成所有的Kubernetes策略清单，并将它们放在<code class="fe nh ni nj mn b">manifests/</code>目录中。底层make目标<code class="fe nh ni nj mn b">constraints</code>使用konstraint cli创建策略，而<code class="fe nh ni nj mn b">migrate_manifests</code>目标运行脚本<code class="fe nh ni nj mn b">scripts/migrate_manifests.sh</code>。</p><p id="ad1c" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我使用<code class="fe nh ni nj mn b">migrate_manifests.sh</code>脚本将所有与策略相关的Kubernetes资源移动到<code class="fe nh ni nj mn b">manifests/</code>目录，因为<a class="ae mh" href="https://github.com/plexsystems/konstraint/issues/106" rel="noopener ugc nofollow" target="_blank">有些情况下</a>我需要手动生成约束。</p><p id="cfc0" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">生成的ConstraintTemplate输出到名为<code class="fe nh ni nj mn b">template.yaml</code>的文件中，相应的约束输出到名为<code class="fe nh ni nj mn b">constraint.yaml</code>的文件中。生成的资源如下所示:</p><figure class="mi mj mk ml gt nl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="mi mj mk ml gt nl"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2ecc" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">要将策略应用到集群，运行<code class="fe nh ni nj mn b">make kubectl_apply_policies</code>。这可确保ConstraintTemplates在相应的约束之前应用于聚类。为了查看策略，我们在浏览器中检查网关守护设备UI。</p><figure class="mi mj mk ml gt nl gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nu"><img src="../Images/51e8bc7acbb51fbbbe9346d6933f3070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UkrgkTAABLjr2o4scZA4rg.png"/></div></div></figure><p id="44cb" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">我们看到所有现有的名称空间目前都是违规的。这是把关者审计功能的一部分，对于迁移到新策略特别有用。</p><p id="cdf0" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">既然策略已经激活，如果我尝试使用kubectl创建一个没有团队标签的名称空间，我会得到如下体验:</p><div class="lj lk gp gr ll lm"><a href="https://asciinema.org/a/UEiaUC1stIlotcx16PTtcFX9A" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd ir gy z fp lr fr fs ls fu fw ip bi translated">kubectl创建名称空间策略失败</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">由sebradloff录制</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">asciinema.org</p></div></div><div class="lv l"><div class="nv l lx ly lz lv ma mb lm"/></div></div></a></div><h2 id="69cb" class="mr jo iq bd jp mw mx dn jt my mz dp jx kw na nb kb la nc nd kf le ne nf kj ng bi translated">生成策略文档</h2><p id="5620" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以使用konstraint cli为我们的策略生成文档。当集群用户遇到违反策略的错误时，我发现这很有用；他们可以很容易地更好地理解违反的政策。文档是通过make目标<code class="fe nh ni nj mn b">docs</code>生成的，它是<code class="fe nh ni nj mn b">generate_all</code>目标的一部分。</p><p id="6bcc" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">您可以在<code class="fe nh ni nj mn b">policies.md</code>文件中查看该存储库的策略文档:<a class="ae mh" href="https://github.com/sebradloff/k8s-gatekeeper-policies-example/blob/main/policies.md" rel="noopener ugc nofollow" target="_blank">https://github . com/sebradloff/k8s-gate keeper-policies-example/blob/main/policies . MD</a></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="2597" class="pw-post-body-paragraph kl km iq kn b ko mc kq kr ks md ku kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">在下一篇文章中，我们将深入探讨编写策略及其相应测试的有趣想法。</p></div></div>    
</body>
</html>