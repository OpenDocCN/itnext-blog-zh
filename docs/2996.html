<html>
<head>
<title>Global Error Handling for REST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST的全局错误处理</h1>
<blockquote>原文：<a href="https://itnext.io/global-error-handling-for-rest-ba708f790679?source=collection_archive---------1-----------------------#2019-09-13">https://itnext.io/global-error-handling-for-rest-ba708f790679?source=collection_archive---------1-----------------------#2019-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5333" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Spring处理REST异常的集中式系统</h2></div><blockquote class="kf kg kh"><p id="0447" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kl ir">场景</strong>。前端正在向后端服务执行REST，但出现了错误。我们如何通知最终用户是什么导致了服务器端的特定错误？</p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/ca9327f8e0dc35d1b41d1ca4f49fc19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W5-Int2XYlOLWBlO"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae lv" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7569" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">当我们开发后端服务，为REST请求服务时，总是建议考虑一个正确的，或者至少是集中式的异常处理系统，能够处理在业务逻辑执行期间出现的异常。</p><p id="968a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">在大多数情况下，不仅要告知最终用户由于执行请求而导致的一般性错误，更具体地说，还要告知最终用户在执行过程中到底出了什么问题。</p><p id="600f" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">例如，我们可以考虑一个注册流程，通过该流程，用户可以通过提供他们的<em class="kk">名</em>、<em class="kk">姓</em>和<em class="kk">电子邮件地址</em>进行注册。<br/>在此阶段，如果没有提供强制数据，或者如果两个不同的用户试图用相同的电子邮件地址注册，服务器端业务逻辑可能会引发特定的异常。</p><p id="c601" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">显然，我们需要向前端发送一个自定义消息和内部错误代码以及通常的<em class="kk"> 400错误请求</em> <a class="ae lv" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank"> HTTP状态代码</a>或其他。(对于每个缺失的强制信息或执行的禁止操作，都会发送一个特定的内部错误代码)</p><p id="6bed" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">在这个故事中，定制代码和消息通过响应头流动。</p><p id="2279" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">因此，我们如何聪明地捕捉异常，保持系统的集中化，并提供内部代码来定制针对用户的错误消息呢？<br/>答案是<strong class="kl ir">异常处理程序</strong>！</p><p id="7153" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">通过异常处理程序，可以处理和集中后端服务在执行期间引发的每个自定义异常。</p><p id="aae8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">让我们看看它是如何工作的。</p><p id="de58" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">首先，有必要创建我们要处理的异常。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="844b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">之后，让我们创建异常处理程序组件。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><ol class=""><li id="1522" class="mb mc iq kl b km kn kp kq lw md lx me ly mf le mg mh mi mj bi translated">@ <em class="kk"> ControllerAdvice </em>注释允许将多个<em class="kk"> @ExceptionHandler </em>合并到一个单一的全局错误处理组件中</li><li id="0b2b" class="mb mc iq kl b km mk kp ml lw mm lx mn ly mo le mg mh mi mj bi translated">@ <em class="kk"> ExceptionHandler </em>注释，由于有了<em class="kk"> value </em>属性，允许定义对于一个特定的引发异常必须调用哪个方法</li><li id="94af" class="mb mc iq kl b km mk kp ml lw mm lx mn ly mo le mg mh mi mj bi translated">总是需要定义一个特定的HTTP响应状态代码；<br/>我们用<em class="kk">不好请求</em>和<em class="kk">禁止</em></li><li id="5ffe" class="mb mc iq kl b km mk kp ml lw mm lx mn ly mo le mg mh mi mj bi translated">使用自定义内部错误代码和消息定义自定义响应标头</li></ol><p id="15e8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">现在，让我们创建一个模拟用户的POJO</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="767d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">…包含内部错误代码的枚举…</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6429" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">…和一个处理注册请求的REST控制器。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4958" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">如果成功，控制器与注册用户进行应答。</p><h2 id="bc86" class="mp mq iq bd mr ms mt dn mu mv mw dp mx lw my mz na lx nb nc nd ly ne nf ng nh bi translated">测试和结论</h2><p id="0e54" class="pw-post-body-paragraph ki kj iq kl b km ni jr ko kp nj ju kr lw nk ku kv lx nl ky kz ly nm lc ld le ij bi translated">现在，我们可以用<a class="ae lv" href="https://www.getpostman.com/downloads/" rel="noopener ugc nofollow" target="_blank">邮递员</a>来测试REST控制器。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/a67e753d94c7588f13048b0a28b42f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FCYdXGl8OjuzcpZ8L25zA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">成功案例—响应正文中没有自定义标头和200个HTTP响应代码，并且保存了用户</figcaption></figure><p id="716a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">在下面的快照中，我们可以注意到响应正文是空的，而标题中则填充了内部错误代码和消息。</p><p id="5dae" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">通过这种方式，前端知道服务器端具体出了什么问题，并可以用明确的响应消息通知最终用户。</p><div class="lg lh li lj gt ab cb"><figure class="no lk np nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/84c6692c1845cb412a2ec03ea87eb5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*hq76Ouio7q93jg_qO7518Q.png"/></div></figure><figure class="no lk nu nq nr ns nt paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/b4ba6c9cf74997412a901f3861adc0cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*WRY8oY7sNrafZcJ5bKKJjA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk nv di nw nx translated">1.缺少电子邮件地址2。缺少姓氏400 HTTP错误请求状态代码</figcaption></figure></div><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ny"><img src="../Images/b27a1061f291b33adb1cdc22daca2bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZ4z11m5Mv_k6lVB5RrXAA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">我们正在尝试保存两个具有相同电子邮件的用户— 403 HTTP禁止状态代码</figcaption></figure><p id="a22d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">最后，在这个故事中，我们学习了如何创建一个能够处理自定义异常的集中式系统。此外，我们还学习了如何通过响应头传输定制的内部服务器错误代码和消息。</p><p id="de36" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lw kt ku kv lx kx ky kz ly lb lc ld le ij bi translated">你可以在这里从GitHub资源库下载项目<a class="ae lv" href="https://github.com/maunat/exceptions-handler" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>