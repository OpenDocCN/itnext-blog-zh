<html>
<head>
<title>Gatsby.js saved 400$/month on our React SSR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gatsby.js在我们的React SSR上每月节省400美元</h1>
<blockquote>原文：<a href="https://itnext.io/gatsby-saved-400-month-react-server-side-rendering-5456f036ab6a?source=collection_archive---------0-----------------------#2019-09-22">https://itnext.io/gatsby-saved-400-month-react-server-side-rendering-5456f036ab6a?source=collection_archive---------0-----------------------#2019-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6197b2b90b5032919e99f882b2ce31c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7XDY9O9FdGaesHhW.png"/></div></div></figure><p id="e35a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每一个关心SEO的React.js网站所有者都应该有一个服务器端渲染设置，这需要大量的资源，即使有一些缓存层，有时它也会阻塞整个基础设施，特别是如果它是像我们(<a class="ae kz" href="https://hexometer.com" rel="noopener ugc nofollow" target="_blank">hexometer.com</a>)这样的网站，在一天的特定时间内流量会动态增加。</p><p id="f39c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SSR的主要问题是它是一个阻塞操作，当它执行时，整个Node.js进程不会获得任何新的请求，这就是为什么我们必须有许多Node.js SSR进程来处理传入的请求。CDN缓存当然有助于减少SSR过载，但有时当有新的更新或我们必须为认证用户提供内容时，SSR会破坏我们的基础设施，因为它还需要来自我们API的一些数据。</p><p id="c3a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上每次当用户导航到我们的网站时，它发送1个SSR请求，然后SSR发送1个API请求，然后在浏览器中，我们的react应用程序发送第二个API请求来比较缓存的数据。很明显，React SSR只是为了让SEO页面可用而浪费大量资源:/</p><p id="8c6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们开始研究其他解决方案，这将只需要静态内容，没有SSR可用。你可以猜到我们找到了Gatsby.js！</p><h1 id="5a53" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么Gatsby.js与众不同</h1><p id="fcfc" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Gatsby.js背后的主要思想是构建静态编译的React + GraphQL应用程序，您可以编译一次并通过CDN缓存提供它，而无需任何SSR后端。我们已经有了GraphQL后端，所以这对我们的用例来说是完美的。</p><p id="9f98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不能把Gatsby.js插到现有的React + Apollo应用中。它需要自己的设置，并且因为它正在编译为静态呈现的HTML + JS，所以您必须定制Gatsby GraphQL端点，以便在Gatsby.js构建过程中交付您的API数据。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f360" class="mm lb it mi b gy mn mo l mp mq">// gatsby-node.js<br/>const query = `<br/>  query {<br/>    .... your custom query here from your API endpoint<br/>  }<br/>`;<br/><br/>exports.sourceNodes = ({ actions, createNodeId, createContentDigest }, configOptions) =&gt; {<br/>  return fetch(getQueryURL(query))<br/>    .then(response =&gt; response.json())<br/>    .then(res =&gt; {<br/>      createNode({<br/>        ... node data from response JSON<br/>      })<br/>    });<br/>}</span></pre><p id="3aef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意</strong> Gatsby.js有两个阶段</p><ol class=""><li id="7d3d" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">构建静态内容，包括外部数据，下载并呈现为html内容</li><li id="c935" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">作为一个常规的React应用程序在浏览器中运行，您可以使用React Apollo发出一个动态GraphQL请求，包括身份验证！</li></ol><h1 id="e31e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们如何将UI应用程序迁移到Gatsby</h1><p id="c342" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">老实说，这不是一个快速的迁移过程，它需要大量的代码迁移和需要考虑的事情，特别是我们学到了很多关于如何设计React组件以要求静态构建的知识。</p><p id="2171" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"/>首先，我们制作了一个基本的Gatsby.js应用程序，其中包含了我们应用程序迁移的所有构建模块，然后我们开始复制/粘贴我们的React组件，包括我们应用程序所需的特定NPM包。在这一阶段没有比赛可担心，感谢上帝我们有一个非常原子的组件基础，我们真的有一个巨大的优势！</p><p id="54ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">其次，</strong>我们不得不移动一些静态查询，这是我们React应用程序渲染的一部分，具体来说，我们有一些动态内容，如<a class="ae kz" href="https://hexometer.com/most-popular-tech-stacks" rel="noopener ugc nofollow" target="_blank">顶级技术堆栈应用程序列表</a>，这些内容必须可供搜索引擎机器人使用。因此，我们只是添加了静态查询，并对页面查询做了一点调整，以满足Gatsby.js页面静态查询的概念。</p><p id="6ae7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">应用程序的其余部分是相同的，我们有React Apollo，它仍然是React Apollo，用于网站分析请求或用户验证等动态内容，令人惊讶的是，我们甚至不需要在那里做任何更改。</p><p id="c007" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">最大的问题</strong>是动态导航，因为我们有基于API内容和结构的页面导航，而且因为Gatsby.js本身是静态导航的，所以很难理解你实际上必须在other中创建一个基于API内容的页面才能使用那个URL。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5812" class="mm lb it mi b gy mn mo l mp mq">const pageResult = await fetchQuery(TechStackCategoryQuery(category));<br/>await createPage({<br/>    path: `most-popular-tech-stacks/${cleanURLSpace(category)}`,<br/>    component: path.resolve(`./src/components/tech-stack/stackByCategory.tsx`),<br/>    context: {<br/>      ...pageResult.data.TechStack,<br/>      name: category,<br/>      isDetails: false,<br/>    }<br/>});</span></pre><p id="4a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除此之外，应用内迁移没有任何问题。如果你想到，如果你只是让你的组件原子化，你实际上可以节省多少匹配时间，那就太棒了！</p><h1 id="1283" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实际节省</h1><p id="ccd1" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">目前我们没有服务器端渲染，所以我们实际上没有任何服务器或服务来处理初始UI内容请求，它完全通过Cloudflare CDN提供服务！它只是一个静态文件，包含预先呈现的完整HTML内容。</p><p id="bf9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅迁移到Gatsby.js并从我们的基础架构中移除服务器端渲染流程这一项，我们平均每月就节省了400美元。你可以想象，我们的网站开始从许多不同的地区更快地加载比赛。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="4dd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这个故事，请分享你的掌声和推文链接！👏👏👏👏</p></div></div>    
</body>
</html>