<html>
<head>
<title>Assembling your own Tasks with TaskCompletionSource</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TaskCompletionSource组装您自己的任务</h1>
<blockquote>原文：<a href="https://itnext.io/assembling-your-own-tasks-with-taskcompletionsource-82bfdab5b995?source=collection_archive---------3-----------------------#2021-08-22">https://itnext.io/assembling-your-own-tasks-with-taskcompletionsource-82bfdab5b995?source=collection_archive---------3-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/e986eaa71a3c6d9e67f74cb0b961990e.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*Sb76eYuWQFborGkeO7CLzA.jpeg"/></div></figure><div class=""/><p id="fffa" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们的日常工作中，我们几乎只处理具有预定义和可预测集合的任务。例如，您的代码中可能有一个如下所示的方法:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="b30c" class="le lf ja la b gy lg lh l li lj">private async Task&lt;string&gt; GetInfo()<br/>{<br/>    var response = await _httpClient.GetAsync("<a class="ae lk" href="https://medium.com" rel="noopener">https://medium.com</a>");<br/>    return await response.Content.ReadAsStringAsync();<br/>}</span></pre><p id="6dc1" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，这种方法可能仍然需要很长的时间来完成，因为许多变量会影响连接等。—然而，方法本身仍然是非常可预测的。我们有一组必须完成的指令，然后任务就完成了。</p><p id="c377" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，如果我们想让一个任务代表一个预先不可预测的操作，我们该怎么做呢？基于事件的API就是一个例子。在某些情况下，您可能不得不放弃对任务的控制，并在特定情况发生时做出反应:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4200" class="le lf ja la b gy lg lh l li lj">public class EventTracker<br/>{<br/>    private void OnEvent(EventData eventData)<br/>    {<br/>        // Raised when event is received<br/>    }</span><span id="0d5d" class="le lf ja la b gy ll lh l li lj">    public async Task WaitForNextEvent()<br/>    {<br/>        await ...?<br/>    }<br/>}</span></pre><p id="c0f4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们该怎么做？</p><h1 id="12dd" class="lm lf ja bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">任务完成资源拯救世界</h1><p id="c42e" class="pw-post-body-paragraph jx jy ja jz b ka mj kc kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku im bi translated">对于这种情况。Net提供了<em class="mo">TaskCompletionSource&lt;T&gt;</em>类。这个类提供了一个底层任务来分发给消费者，它可以像任何其他任务一样使用。然而，另一方面，生产者可以明确地控制这个任务的生命周期。</p><p id="10aa" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了做到这一点，<em class="mo">TaskCompletionSource&lt;T&gt;T3】公开了一组方法:</em></p><ul class=""><li id="7215" class="mp mq ja jz b ka kb ke kf ki mr km ms kq mt ku mu mv mw mx bi translated"><em class="mo"> SetResult(T result) </em> —设置底层任务的特定结果，并将其移入<em class="mo"> RanToCompletion </em>状态。</li><li id="f3f5" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku mu mv mw mx bi translated"><em class="mo"> SetCanceled() </em> —将任务移动到<em class="mo">已取消</em>状态。</li><li id="e21c" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku mu mv mw mx bi translated"><em class="mo">set Exception(Exception exc)/set Exception(IEnumerable&lt;Exception&gt;exceptions)—</em>将任务移入<em class="mo"> Faulted </em>状态，并向其添加相应的异常。</li></ul><p id="e19d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，所有这些方法都有一个<em class="mo"> Try… </em>版本来防止已经发生的任务消耗。</p><p id="e9ca" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">听起来不错，所以让我们看看如何在前面的例子中使用它。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="dbc6" class="le lf ja la b gy lg lh l li lj">public record EventData();</span><span id="9196" class="le lf ja la b gy ll lh l li lj">public class EventTracker<br/>{<br/>    private TaskCompletionSource&lt;object&gt; _tcs;</span><span id="1134" class="le lf ja la b gy ll lh l li lj">    public void OnEvent(EventData eventData)<br/>    {<br/>        _tcs.SetResult(null);<br/>    }</span><span id="b025" class="le lf ja la b gy ll lh l li lj">    public async Task WaitForNextEvent()<br/>    {<br/>        _tcs = new TaskCompletionSource&lt;object&gt;();<br/>        await _tcs.Task;<br/>    }<br/>}</span><span id="aa51" class="le lf ja la b gy ll lh l li lj">public static async void Main(string[] args) <br/>{<br/>    var eventTracker = new EventTracker();<br/>    _ = Task.Run(async () =&gt; {<br/>        await Task.Delay(2000);<br/>        Console.WriteLine("Triggering event");<br/>        eventTracker.OnEvent(new EventData());<br/>    });<br/> <br/>    Console.WriteLine("Awaiting event...");<br/>    await eventTracker.WaitForNextEvent();<br/>    Console.WriteLine("Event awaited!");<br/>}</span><span id="21d0" class="le lf ja la b gy ll lh l li lj">// Output:<br/>Awaiting event...<br/>Triggering event<br/>Event awaited!</span></pre><p id="230d" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">完美！那么，到底发生了什么？</p><ol class=""><li id="dc59" class="mp mq ja jz b ka kb ke kf ki mr km ms kq mt ku nd mv mw mx bi translated">我们创建一个新的EventTracker实例。</li><li id="6e49" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku nd mv mw mx bi translated">出于嘲弄的目的，我们在这里开始一个小任务，它将在2秒钟后“引发”一个事件。</li><li id="1961" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku nd mv mw mx bi translated">现在，我们进入EventTracker实例的<em class="mo"> WaitForNextEvent() </em>方法。在这里，我们创建了我们的<em class="mo"> TaskCompletionSource &lt;对象&gt; </em>的一个新实例，并获取底层任务，我们将立即等待它。注意，不幸的是没有非通用版本的<em class="mo"> TaskCompletionSource </em>，所以对于一个“中性”版本，我们需要使用<em class="mo"> TaskCompletionSource &lt;对象&gt;。</em></li><li id="c0b9" class="mp mq ja jz b ka my ke mz ki na km nb kq nc ku nd mv mw mx bi translated">2秒钟后，我们的后台任务触发<em class="mo">OnEvent(event data event data)</em>方法，并在<em class="mo"> TaskCompletionSource </em>上设置结果。此时，任务被标记为已完成，我们的等待方法可以返回。</li></ol><h1 id="6532" class="lm lf ja bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">逮到你了</h1><p id="8b84" class="pw-post-body-paragraph jx jy ja jz b ka mj kc kd ke mk kg kh ki ml kk kl km mm ko kp kq mn ks kt ku im bi translated">我想提两个问题。</p><p id="a8f8" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">第一个是指默认情况下，<em class="mo"> TaskCompletionSource </em>同步运行所有延续的特殊行为。为了安全起见，您应该始终像这样构造TaskCompletionSource:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8593" class="le lf ja la b gy lg lh l li lj">new TaskCompletionSource&lt;object&gt;(TaskCreationOptions.RunContinuationsAsynchronously);</span></pre><p id="9b49" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你想了解更多这方面的内容，我绝对可以推荐<a class="ae lk" href="https://devblogs.microsoft.com/premier-developer/the-danger-of-taskcompletionsourcet-class/" rel="noopener ugc nofollow" target="_blank">这篇</a>文章——在这里谈论可能会有点太长。</p><p id="9781" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">除了这个具体的技术问题之外，我还想指出这样一个事实，即虽然使用<em class="mo"> TaskCompletionSource </em>作为一种基于事件的API创建任务的方法很有吸引力，但是您也应该记住，很多事情都可能出错，特别是当事件通过网络传入时，这可能会导致任务被无限期地等待。</p><p id="e13f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个可能减轻这种情况的例子是创建一个定制的<em class="mo"> TaskCompletionSource </em>，或者创建一个提供CancellationToken的工厂，这可以确保任务不会永远挂起:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9a7e" class="le lf ja la b gy lg lh l li lj">public class TimeoutTaskCompletionSource&lt;T&gt; : TaskCompletionSource&lt;T&gt;<br/>{<br/>    public TimeoutTaskCompletionSource(TaskCreationOptions        creationOptions)<br/>         :base(creationOptions)<br/>        {<br/>            var cts = new CancellationTokenSource(1000);<br/>            cts.Token.Register(SetCanceled);<br/>        }<br/>}</span></pre><p id="1385" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，这个实现将在一秒钟后自动取消任务。不过，我想你明白我要去哪里。当你控制了任务的生命周期，你也控制了悲观的路径，而不仅仅是乐观的路径。</p><p id="0f00" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，总结一下:如果您需要对任务对象进行显式控制，例如在基于事件的架构中，那么<em class="mo"> TaskCompletionSource </em>就是您的完美API！</p></div></div>    
</body>
</html>