<html>
<head>
<title>How to Upload a File with Reactjs and Nodejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Reactjs和Nodejs上传文件</h1>
<blockquote>原文：<a href="https://itnext.io/connecting-a-node-js-and-reactjs-example-17dd2673979e?source=collection_archive---------6-----------------------#2018-06-23">https://itnext.io/connecting-a-node-js-and-reactjs-example-17dd2673979e?source=collection_archive---------6-----------------------#2018-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/879acb0d09c571cbb349879fc3cbcf79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDFqFIcXFinfWdDUFUECbw.jpeg"/></div></figure><p id="9cb7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上传文件似乎是一项需要被征服的任务，尤其是如果你正在从事web开发的话。在本教程中，使用Reactjs在前端和Node.js后端上传简单的基于AJAX的文件。这很容易用下面的技术来实现，因为整个源代码将使用一种语言，JavaScript。在本例中，为了演示Reactjs应用程序与Node.js后端的连接，我们将使用一个简单的文件上传示例。我们将讨论的主题包括:</p><ul class=""><li id="0f9f" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">使用<code class="fe lb lc ld le b">express-generator</code>设置我们应用程序的后端</li><li id="a773" class="ks kt iq jw b jx lf kb lg kf lh kj li kn lj kr kx ky kz la bi translated">使用<code class="fe lb lc ld le b">create-react-app</code>搭建前端反应堆应用程序</li><li id="823d" class="ks kt iq jw b jx lf kb lg kf lh kj li kn lj kr kx ky kz la bi translated">使用<code class="fe lb lc ld le b">axios</code>进行跨来源API调用</li><li id="ec55" class="ks kt iq jw b jx lf kb lg kf lh kj li kn lj kr kx ky kz la bi translated">在我们的服务器上处理POST请求</li><li id="b756" class="ks kt iq jw b jx lf kb lg kf lh kj li kn lj kr kx ky kz la bi translated">使用<code class="fe lb lc ld le b">express-fileupload</code>，一个基于承诺的库</li><li id="ef3f" class="ks kt iq jw b jx lf kb lg kf lh kj li kn lj kr kx ky kz la bi translated">最后，在Reactjs和Node.js之间建立一个连接</li></ul><h1 id="ad39" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">入门指南</h1><p id="998d" class="pw-post-body-paragraph ju jv iq jw b jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">我们将首先开始没有后端。我们将编写一个具有必要配置的服务器应用程序，以接受跨源请求和上传文件。首先，我们需要安装<code class="fe lb lc ld le b">express-generator</code>,这是开始快速后端应用程序的官方和最快捷的方式。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1f80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将从我们的终端在全球范围内安装这个模块。安装这个全局<code class="fe lb lc ld le b">npm</code>模块后，我们有一个名为<code class="fe lb lc ld le b">express</code>的实例来生成我们的项目结构。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c5ae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当将当前目录更改为刚刚搭好的项目<code class="fe lb lc ld le b">express</code>命令时，我们可以观察到以下结构和文件:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/58d84425026b0b13a6145a310c386b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/0*x6livl3bk3Wc8OX6.png"/></div></figure><p id="ef3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要在默认配置下运行这个后端服务器，我们必须首先安装<code class="fe lb lc ld le b">package.json</code>中提到的依赖项。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4392" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Express-generator具有以下依赖性。其中一些是必不可少的，比如<code class="fe lb lc ld le b">morgan</code>和<code class="fe lb lc ld le b">body-parser</code>，有些我们可以在这个项目中省去。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1174" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将为我们的可配置后端应用程序添加两个以上的包，以按照我们想要的方式运行。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6c81" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lb lc ld le b">cors</code>为Express应用程序提供中间件功能，以支持各种跨来源的资源共享选项。CORS是一种允许来自另一个域的web页面上的受限资源(在我们的例子中，是API或AJAX请求)的机制。它帮助浏览器和服务器进行通信，并且可以被托管在不同的域中。当你看到它发挥作用时，你会更理解它。</p><p id="40d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">另一个模块<code class="fe lb lc ld le b">express-fileupload</code>是一个用于上传文件的简单的express中间件功能。它的优点是支持承诺，并且可以处理多个文件上传。</p><p id="59a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将这两个重要的包作为依赖项添加到我们的项目中后，我们现在可以从修改<code class="fe lb lc ld le b">app.js</code>文件中的默认Express后端开始。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4759" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的代码中，你会注意到我们做了一些添加。我们做的第一件事是在加载完其他依赖项后，在<code class="fe lb lc ld le b">app.js</code>中导入包<code class="fe lb lc ld le b">cors</code>和<code class="fe lb lc ld le b">express-fileupload</code>。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5a14" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后就在其他中间件功能之后，我们将实例化这两个新导入的包。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b987" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，我们需要允许数据来自一个表单。为此，我们必须启用<code class="fe lb lc ld le b">body-parser</code>模块的<code class="fe lb lc ld le b">urlencoded</code>选项，并指定一个路径来存储来自客户端的图像文件。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d8d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样，我们可以通过运行以下命令来查看我们的服务器是否正常工作:</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2cf9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你在端口<code class="fe lb lc ld le b">http://localhost:3000</code>上导航得到下面的屏幕，说明我们的服务器正在运行。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/50dcdf734bcec7ebd74f2766b0b1ebe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tgeuf8qKcqzzwfSZ.png"/></div></div></figure><p id="e3d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们开始生成前端应用程序之前，我们需要为我们的后端更改端口，因为使用<code class="fe lb lc ld le b">create-react-app</code>生成的前端应用程序也将在端口<code class="fe lb lc ld le b">3000</code>上运行。打开<code class="fe lb lc ld le b">bin/www</code>文件并编辑:</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="e7b5" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">设置前端</h1><p id="8e26" class="pw-post-body-paragraph ju jv iq jw b jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated"><code class="fe lb lc ld le b">create-react-app</code>是另一个命令行实用程序，用于生成默认的Reactjs前端应用程序。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="07e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还将安装所需的库，我们将使用它对我们的后端服务器进行API调用。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0395" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lb lc ld le b">index.js</code>是我们的应用程序在<code class="fe lb lc ld le b">src/</code>目录中的起点。它通过安装<code class="fe lb lc ld le b">App</code>组件使用<code class="fe lb lc ld le b">ReactDOM.render()</code>注册渲染功能。组件是任何Reactjs应用程序的构造块。这个<code class="fe lb lc ld le b">App</code>组件来自<code class="fe lb lc ld le b">src/App.js</code>。我们将在我们的前端源代码中编辑这个文件。</p><h1 id="c46f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">文件上传表单</h1><p id="8ba6" class="pw-post-body-paragraph ju jv iq jw b jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">我们将使用HTML <code class="fe lb lc ld le b">form</code>元素，它的输入提供了对值的访问，也就是使用<code class="fe lb lc ld le b">refs</code>的文件。<code class="fe lb lc ld le b">Ref</code>是React中可以附加到任何组件的特殊属性。它采用一个回调函数，这个回调函数将在组件挂载后立即执行。它也可以用在HTML元素上，相关的回调函数将接收DOM元素作为参数。这样，<code class="fe lb lc ld le b">ref</code>可以用来存储DOM元素的引用。这正是我们要做的。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="de19" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lb lc ld le b">input</code>元素必须有<code class="fe lb lc ld le b">type="file"</code>,否则它将无法识别我们使用它的类型。类似于<code class="fe lb lc ld le b">email</code>、<code class="fe lb lc ld le b">password</code>等数值。</p><p id="7862" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lb lc ld le b">handleUploadImage</code>方法将负责我们需要向服务器请求的API调用。如果调用成功，我们React应用程序的本地状态将被设置为让用户知道上传成功。在这个函数中，为了进行API调用，我们将使用在设置前端应用程序时安装的<code class="fe lb lc ld le b">axios</code>库。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5f9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">FormData对象允许您编译一组键/值对，以便使用XMLHttpRequest发送。它主要用于发送表单数据，但也可以独立于表单使用，以传输键控数据。构建一个FormData对象，实例化它，然后通过调用它的<code class="fe lb lc ld le b">append()</code>方法向它追加字段，就像我们上面做的那样。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/34cee4ae7d63a61bb9d764246d3d7f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*Xa5qBk-hqFkJsTIW.png"/></div></figure><p id="5282" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因为我们没有使用任何样式，所以我们的表单看起来非常丑陋。但是你可以让它看起来更专业。为了简洁，我将保持事情简单。我建议你总是输入一个uname文件，否则它会以<code class="fe lb lc ld le b">undefined.jpg</code>名存储文件。</p><h1 id="a217" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">更新服务器以处理AJAX请求</h1><p id="ae97" class="pw-post-body-paragraph ju jv iq jw b jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr ij bi translated">现在，我们的服务器代码中没有处理React应用程序请求的<code class="fe lb lc ld le b">POST</code>请求。我们将在定义默认路线的Express应用程序中的<code class="fe lb lc ld le b">app.js</code>中添加路线。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0cfb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当向<code class="fe lb lc ld le b">/upload/</code>发出请求时，该路由被触发。使用路由关联的回调包含<code class="fe lb lc ld le b">req</code>、<code class="fe lb lc ld le b">res</code>对象和对<code class="fe lb lc ld le b">next</code>的访问，这是在Express应用程序中定义中间件功能的标准方式。<code class="fe lb lc ld le b">req</code>对象包含在表单提交过程中从客户端应用程序上传的文件和文件名。如果出现任何错误，我们将返回500服务器错误代码。否则，我们返回实际文件的路径，并控制<code class="fe lb lc ld le b">response</code>对象来检查是否一切都如我们预期的那样工作。</p><p id="9022" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe lb lc ld le b">.mv</code>文件是基于承诺的，由我们之前安装的<code class="fe lb lc ld le b">express-fileupload</code>包提供给我们。现在尝试从客户端上传图像文件。此时，确保客户端和服务器都从不同的终端选项卡运行。如果您在终端中收到这样的成功消息:</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fbea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与此同时，客户端正在使用<code class="fe lb lc ld le b">GET</code> HTTP方法请求在前端查看文件。这意味着来自浏览器的路由<code class="fe lb lc ld le b">/upload</code>被成功调用，一切正常。一旦文件上传到服务器上，它将被发送回客户端，以反映用户已经成功上传了文件。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi na"><img src="../Images/42b15e1de2d2924901cbba89e2c00707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cWOzuejEhEOtSQV8.png"/></div></div></figure><p id="f414" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在<a class="ae nb" href="https://github.com/amandeepmittal/fileupload-example" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">file upload-Example</strong></a>Github库找到这个例子的完整代码。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nc ms l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="62a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="nk">本文原载于2018年6月20日</em><a class="ae nb" href="https://www.zeolearn.com/magazine/connecting-reactjs-frontend-with-nodejs-backend" rel="noopener ugc nofollow" target="_blank"><em class="nk">Zeolearn.com</em></a></p></div></div>    
</body>
</html>