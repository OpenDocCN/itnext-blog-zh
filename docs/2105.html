<html>
<head>
<title>React Hooks — designing a simple forms API — part 3 — validation and a running example!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Hooks——设计简单的表单API——第3部分——验证和运行示例！</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-designing-a-simple-forms-api-part-3-validation-and-a-running-example-18b835a3b817?source=collection_archive---------4-----------------------#2019-04-01">https://itnext.io/react-hooks-designing-a-simple-forms-api-part-3-validation-and-a-running-example-18b835a3b817?source=collection_archive---------4-----------------------#2019-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cc89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的第1部分中，我们研究了如何使用React钩子来设计一个React表单库。第1部分介绍了这个库的动机和一些总体设计目标。</p><p id="b83f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本系列的第2部分<a class="ae ko" href="https://medium.com/@shanplourde/react-hooks-designing-a-simple-forms-api-part-2-1fe5d12f23d9" rel="noopener">中，我们创建了一个<code class="fe kp kq kr ks b">useInput</code>钩子，回顾了我们的解决方案的状态管理，合并了一些额外的测试，并且更详细地回顾了测试策略。</a></p><p id="f5a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第3部分中，我们将讨论验证、异步验证和异步表单提交。我们还将确保涵盖异步单元测试，并更新我们的样本表单。一旦我们有了这些部分，我们就基本上构建了基于React hooks的表单API的所有关键元素。</p><p id="0e64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对了，<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-4-scaling-to-other-input-types-e738db0a3fc3">第四部</a>上线了💪。</p><p id="29b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始吧！</p><h1 id="46c2" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">工作示例</h1><p id="6098" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">到目前为止，我还没有发布我们API的运行示例，因为它缺少一些关键特性。在本文中，我们将完成表单API的所有关键元素。因此，让我们来看看到目前为止我们所建立的一切的演示。</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">示例表单展示了我们将在第3部分中开发的所有表单特性</figcaption></figure><p id="ad03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面展示了我们的标准HTML表单解决方案。如果你检查一下HTML，你会看到我们只是使用常规的旧的<code class="fe kp kq kr ks b">&lt;form /&gt;</code>、<code class="fe kp kq kr ks b">&lt;label /&gt;</code>和<code class="fe kp kq kr ks b">&lt;input /&gt;</code>标签。<code class="fe kp kq kr ks b">useForm</code>提供表单的功能需求。UI由最终表单创建者来实现。</p><p id="7345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/shanplourde/react-hooks-form-util" rel="noopener ugc nofollow" target="_blank">完整的解决方案可以在我的github </a>中找到。演示中有很多样板文件，但我希望在这一点上有非常明确的例子。请注意，由于CodeSandbox设计决定不支持从<code class="fe kp kq kr ks b">package.json</code>加载<code class="fe kp kq kr ks b">devDependencies</code>，测试此时不会通过CodeSandbox。</p><h1 id="70fd" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设计公共API以支持<code class="fe kp kq kr ks b">validation</code></h1><p id="9537" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">我发现在设计React hooks API时，最好的起点是首先理解你希望它做什么，然后你将如何使用它。尽早编写单元测试有助于改进API。</p><h2 id="b899" class="mh ku it bd kv mi mj dn kz mk ml dp ld kb mm mn lh kf mo mp ll kj mq mr lp ms bi translated">我们希望验证做什么？</h2><ul class=""><li id="6f1c" class="mt mu it js b jt lr jx ls kb mv kf mw kj mx kn my mz na nb bi translated">支持多种开箱即用的验证，如required、email等。</li><li id="e6d7" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">支持自定义验证</li><li id="0749" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">使新的验证易于添加</li><li id="2151" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">支持异步验证</li><li id="c012" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">支持可选的输入模糊验证</li><li id="415d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">表单提交时应支持验证</li></ul><h2 id="77f6" class="mh ku it bd kv mi mj dn kz mk ml dp ld kb mm mn lh kf mo mp ll kj mq mr lp ms bi translated">验证未来美好生活</h2><ul class=""><li id="a187" class="mt mu it js b jt lr jx ls kb mv kf mw kj mx kn my mz na nb bi translated">onBlur异步验证可能需要支持取消</li><li id="df12" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">onBlur异步验证可能希望在运行异步操作之前支持延迟——比如一个<a class="ae ko" href="https://levelup.gitconnected.com/debounce-in-javascript-improve-your-applications-performance-5b01855e086" rel="noopener ugc nofollow" target="_blank">去抖算法</a></li><li id="a17d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">可以增强API以减少样板文件</li><li id="e0a3" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">API可以通过JSON模式库支持模式验证</li><li id="d55c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">更大的测试覆盖范围</li></ul><h2 id="8043" class="mh ku it bd kv mi mj dn kz mk ml dp ld kb mm mn lh kf mo mp ll kj mq mr lp ms bi translated">我们希望消费者如何使用验证？</h2><p id="f241" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">遵循第2部分中描述的相同的<code class="fe kp kq kr ks b">useInput</code>哲学，其中<code class="fe kp kq kr ks b">useInput</code>从表单创建者中抽象出来，验证也将被抽象出来。<code class="fe kp kq kr ks b">useForm</code>的最终用户将通过<code class="fe kp kq kr ks b">useForm</code> API配置他们的输入验证。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/0c5fe7eb55c12454e86560cb1793eca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8n9PLzfKTsY3xlQE2-D-w.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">图1-使用表单和验证状态管理以及API使用</figcaption></figure><p id="2e85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如图1所示，我希望表单消费者直接使用<code class="fe kp kq kr ks b">useForm</code>钩子进行验证，并让<code class="fe kp kq kr ks b">useForm</code>直接处理管理整体表单验证和单个表单字段验证。<code class="fe kp kq kr ks b">useForm</code>将配置需要在输入模糊和表单提交时触发的验证。<code class="fe kp kq kr ks b">useForm</code>将向表单创建者提供此验证状态。这将允许表单创建者:</p><ul class=""><li id="9a96" class="mt mu it js b jt ju jx jy kb no kf np kj nq kn my mz na nb bi translated">基于单个输入查询验证错误</li><li id="bf0c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">查询整体表单有效性</li><li id="71c4" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">在表单创建者的<code class="fe kp kq kr ks b">onSubmit</code>回调期间，表单创建者可以检查整体有效性，并决定是否要提交表单数据</li><li id="25fd" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">查询异步验证当前是否正在运行(例如，表单创建者可以阻止额外的表单提交)</li></ul><p id="30ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，表单创建者应该能够:</p><ul class=""><li id="baf7" class="mt mu it js b jt ju jx jy kb no kf np kj nq kn my mz na nb bi translated">异步验证或提交运行时阻止表单提交</li><li id="e818" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">可以选择允许输入存储无效数据，也可以选择阻止输入存储无效数据，这取决于输入如何作用于验证状态</li><li id="bdf5" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">根据表单的设计，提交或阻止提交无效表单</li></ul><h2 id="ee61" class="mh ku it bd kv mi mj dn kz mk ml dp ld kb mm mn lh kf mo mp ll kj mq mr lp ms bi translated">状态管理设计</h2><p id="8916" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">如图1所示，<code class="fe kp kq kr ks b">useInput</code>不会管理任何类型的验证状态。我更喜欢用<code class="fe kp kq kr ks b">useInput</code>钩子来管理输入状态和输入UI状态(原始的，已访问的)。</p><p id="4476" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我更喜欢用<code class="fe kp kq kr ks b">useForm</code>来管理验证状态。我的直觉告诉我，可以创建一个验证挂钩<em class="nr"/><strong class="js iu"><em class="nr"/></strong>，但是我现在看不到这个需要。</p><p id="4ad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">整体UI验证状态</strong></p><p id="eaee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>通过<code class="fe kp kq kr ks b">uiState</code>属性跟踪整个表单的有效性状态。一个例子:<code class="fe kp kq kr ks b">{“isValidating”:false,”isValid”:true,”isSubmitting”:false}</code>。一旦评估了所有验证，将在提交表单时重新评估整个表单的有效性。<code class="fe kp kq kr ks b">isValidating</code>跟踪异步验证是否正在运行。<code class="fe kp kq kr ks b">isValid</code>跟踪所有输入是否有效。</p><p id="17b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">个人输入验证状态</strong></p><p id="7684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">useForm</code>通过<code class="fe kp kq kr ks b">formValidity</code>属性跟踪单个验证器的验证状态。在下面的示例值中，<code class="fe kp kq kr ks b">formValidity</code>有3个字段，<code class="fe kp kq kr ks b">firstName</code>、<code class="fe kp kq kr ks b">lastName</code>和<code class="fe kp kq kr ks b">email</code>，它们都被标记为有效:</p><pre class="lw lx ly lz gt ns ks nt nu aw nv bi"><span id="32d3" class="mh ku it ks b gy nw nx l ny nz">{"firstName":{"field":"firstName","valid":true},"lastName":{"field":"lastName","valid":true},"email":{"field":"email","valid":true}}</span></pre><p id="092c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中,<code class="fe kp kq kr ks b">lastName</code>字段被标记为无效，而<code class="fe kp kq kr ks b">errors</code>属性是一个失败的验证集合——在本例中是必需的。<code class="fe kp kq kr ks b">email</code>字段被标记为无效，验证失败的是INVALID_EMAIL:</p><pre class="lw lx ly lz gt ns ks nt nu aw nv bi"><span id="7878" class="mh ku it ks b gy nw nx l ny nz">{"firstName":{"field":"firstName","valid":true},"lastName":{"field":"lastName","valid":false,"errors":["REQUIRED"]},"email":{"field":"email","valid":false,"errors":["INVALID_EMAIL"]}}</span></pre><p id="b8f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe kp kq kr ks b">formValidity</code>属性，错误被设计为支持多个验证。然而，我对验证的偏好是一旦一个失败就停止评估它们。我相信这提高了UI性能，减少了不必要的网络往返，等等。所以这在未来可能会改变，但我喜欢它提供的可伸缩性。</p><p id="1fa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">表单创建者可以决定在发生验证错误时向最终用户显示哪些错误内容。</p><p id="3d95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">跟踪异步输入验证的状态</strong></p><p id="9fb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">formValidity</code>属性也跟踪异步验证状态。以下示例显示名为<code class="fe kp kq kr ks b">custom</code>的字段当前无效。除了无效之外，该字段还被再次异步验证，如<code class="fe kp kq kr ks b">isValidating: true</code>属性所示。当<code class="fe kp kq kr ks b">isValidating</code>为真时，添加<code class="fe kp kq kr ks b">value</code>属性，如果输入值仍然相同，则允许忽略重叠的异步onBlur验证。</p><pre class="lw lx ly lz gt ns ks nt nu aw nv bi"><span id="be2c" class="mh ku it ks b gy nw nx l ny nz">{"field":"custom","valid":false,"errors":["CUSTOM_ASYNC_ERROR"],"isValidating":true,"value":"custom"}</span></pre><p id="4edd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">未来重构的考虑事项</strong></p><p id="526c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在模糊时触发的异步验证的理想长期设计还应该包括去抖动和承诺取消，因为这些将有助于防止过多的异步验证在输入模糊时触发。</p><p id="6f47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在以后的某个时刻，很明显需要进一步的抽象，那么验证可以从<code class="fe kp kq kr ks b">useForm</code>中抽象出来。我通常更喜欢持续重构，而不是在愿景不完全清晰的情况下从一开始就过度工程化。</p><p id="ea7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输入表单将通过<code class="fe kp kq kr ks b">useForm</code>钩子接收所有的验证状态。</p><h2 id="4d64" class="mh ku it bd kv mi mj dn kz mk ml dp ld kb mm mn lh kf mo mp ll kj mq mr lp ms bi translated">源代码和说明</h2><p id="37f7" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">为了获得基本的验证支持，需要对源代码进行大量的修改。本节将回顾一部分代码变更，但是整个解决方案可以在github 中回顾。</p><p id="8927" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> validators.js </strong></p><p id="fc99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">validators.js</code>是一个新文件，它提供了一个API来创建新的验证器，并提供了一些现成的股票验证器。关于设计和实现的一些设计:</p><ul class=""><li id="d688" class="mt mu it js b jt ju jx jy kb no kf np kj nq kn my mz na nb bi translated">表单库的最终用户将使用导出的<code class="fe kp kq kr ks b">createValidator</code>，以及库存的<code class="fe kp kq kr ks b">email</code>和<code class="fe kp kq kr ks b">required</code>验证器</li><li id="a518" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe kp kq kr ks b">createValidator</code>函数返回一个带有<code class="fe kp kq kr ks b">validate</code>函数的对象，这个函数将被<code class="fe kp kq kr ks b">useForm</code>钩子使用</li><li id="eb4b" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">在表单提交之前，<code class="fe kp kq kr ks b">useForm</code>钩子将使用<code class="fe kp kq kr ks b">runValidators</code>函数来运行表单上的所有验证器</li><li id="12ab" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe kp kq kr ks b">useForm</code>钩子将保存所有验证器的集合</li><li id="0848" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">虽然<code class="fe kp kq kr ks b">useForm</code>钩子将是<code class="fe kp kq kr ks b">validate</code>函数的消费者，但是最终用户也可以使用<code class="fe kp kq kr ks b">validate</code>库</li><li id="ee06" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">还需要一些与验证相关的东西，比如“验证器应该在什么时候触发”。为了限制该文件的责任，这些将是<code class="fe kp kq kr ks b">useForm</code>钩子的责任。</li><li id="89b2" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe kp kq kr ks b">validate</code>将阻塞异步验证函数，直到它们返回</li><li id="1498" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">如果validate函数出错，<code class="fe kp kq kr ks b">validate</code>将返回<code class="fe kp kq kr ks b">undeterminedValidations</code>，这是一个未能完成的验证器的集合。<code class="fe kp kq kr ks b">useForm</code>钩子的最终用户可以检查这个集合并决定是否提交一个表单</li><li id="bbb8" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">我们使用<code class="fe kp kq kr ks b"><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank">async</a></code> <a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank"> / </a> <code class="fe kp kq kr ks b"><a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank">await</a></code>使我们的异步代码更具可读性</li></ul><pre class="lw lx ly lz gt ns ks nt nu aw nv bi"><span id="0b5d" class="mh ku it ks b gy nw nx l ny nz">export const constants = {<br/>  undetermined: "undetermined"<br/>};</span><span id="5868" class="mh ku it ks b gy oa nx l ny nz">export const runValidators = async ({<br/>  field,<br/>  validators,<br/>  eventType,<br/>  value<br/>}) =&gt; {<br/>  const valPromises = [];<br/>  validators<br/>    .filter(validator =&gt; {<br/>      return validator.when.some(whenItem =&gt; whenItem === eventType);<br/>    })<br/>    .forEach(async validator =&gt; {<br/>      valPromises.push(validator.validate(value));<br/>    });<br/>  const validationResults = await Promise.all(valPromises);<br/>  const validationErrors = validationResults.filter(<br/>    result =&gt; !result.valid &amp;&amp; !result.undeterminedValidation<br/>  );<br/>  const undeterminedValidations = validationResults<br/>    .filter(<br/>      result =&gt;<br/>        result.undeterminedValidation &amp;&amp;<br/>        result.undeterminedValidation.length &gt; 0<br/>    )<br/>    .map(validation =&gt; validation.undeterminedValidation);<br/>  const undetermined =<br/>    undeterminedValidations.length === 0<br/>      ? null<br/>      : {<br/>          undeterminedValidations<br/>        };</span><span id="a968" class="mh ku it ks b gy oa nx l ny nz">if (validationErrors.length === 0)<br/>    return { field, valid: true, ...undetermined };<br/>  return {<br/>    field,<br/>    valid: false,<br/>    errors: validationErrors.map(error =&gt; error.error),<br/>    ...undetermined<br/>  };<br/>};</span><span id="afdd" class="mh ku it ks b gy oa nx l ny nz">/**<br/> * Returns a new validator definition<br/> * <a class="ae ko" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} validateFn - validation function. Receives<br/> *        value<br/> * <a class="ae ko" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {*} error - Error constant if validation fails<br/> *            Readable copy would be provided by application<br/> */<br/>export const createValidator = ({ validateFn, error = "ERROR_KEY" }) =&gt; {<br/>  return {<br/>    validate: async text =&gt; {<br/>      try {<br/>        const isValid = await validateFn(text);<br/>        if (typeof isValid === "boolean" &amp;&amp; isValid) {<br/>          return { valid: true };<br/>        }<br/>        return { valid: false, error };<br/>      } catch {<br/>        return { undeterminedValidation: error };<br/>      }<br/>    }<br/>  };<br/>};</span><span id="66ad" class="mh ku it ks b gy oa nx l ny nz">/**<br/> * A required field validator that fires on blur and submit<br/> */<br/>export const required = createValidator({<br/>  validateFn: text =&gt; (text || "").length &gt; 0,<br/>  error: "REQUIRED"<br/>});</span><span id="6bf5" class="mh ku it ks b gy oa nx l ny nz">/**<br/> * An email validator that fires on blur and submit<br/> */<br/>export const email = createValidator({<br/>  validateFn: text =&gt; {<br/>    const re = /^(([^&lt;&gt;()[\]\\.,;:\s@"]+(\.[^&lt;&gt;()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;<br/>    return !text || re.test(String(text).toLowerCase());<br/>  },<br/>  error: "INVALID_EMAIL"<br/>});</span></pre><p id="4ab4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> validators.test.js </strong></p><p id="e95b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe kp kq kr ks b">validators.test.js</code>包括覆盖<code class="fe kp kq kr ks b">validations.js</code>文件的单元测试。完整的测试文件可以在github repo中找到。</p><ul class=""><li id="7549" class="mt mu it js b jt ju jx jy kb no kf np kj nq kn my mz na nb bi translated">我们正在测试同步和异步验证逻辑</li><li id="cd55" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">我们正在测试validations.js文件的所有路径和状态</li></ul><p id="1457" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用形式. js </strong></p><p id="f030" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与验证相关的更新在下面的<code class="fe kp kq kr ks b">useForm</code>中以粗体显示。</p><ul class=""><li id="444d" class="mt mu it js b jt ju jx jy kb no kf np kj nq kn my mz na nb bi translated"><code class="fe kp kq kr ks b">useForm</code>用<code class="fe kp kq kr ks b">formValidity</code>状态对象跟踪有效状态。在<code class="fe kp kq kr ks b">formValidity</code>中，每个输入字段都有一个单独的键</li><li id="7417" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">表单的整体UI状态跟踪<code class="fe kp kq kr ks b">isValidating</code>和<code class="fe kp kq kr ks b">isValid</code>。这些允许表单创建者跟踪验证是否正在运行，以及表单整体是否有效</li><li id="e808" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe kp kq kr ks b">onSubmit</code>永不屏蔽。阻止提交由表单作者决定。表单作者接收验证状态</li><li id="fe67" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe kp kq kr ks b">onInputBlur</code>执行一个简单的测试，如果异步验证当前正在使用相同的测试值进行，该测试可防止异步验证再次运行</li></ul><pre class="lw lx ly lz gt ns ks nt nu aw nv bi"><span id="9ca1" class="mh ku it ks b gy nw nx l ny nz">import { useState } from "react";<br/>import { useInput } from "./use-input";<br/><strong class="ks iu">import { runValidators } from "./validators";</strong></span><span id="9e38" class="mh ku it ks b gy oa nx l ny nz">export const defaultFormProps = {<br/>  autoComplete: "on"<br/>};</span><span id="8458" class="mh ku it ks b gy oa nx l ny nz">export const useForm = (name, initialState = {}) =&gt; {<br/>  const [formValues] = useState({<br/>    ...initialState<br/>  });<br/><strong class="ks iu">  const [formValidity, setFormValidity] = useState({});<br/>  const [validators] = useState({});<br/></strong>  const [uiState, setUiState] = useState({<br/><strong class="ks iu">    isValidating: false,<br/>    isValid: true,<br/></strong>    isSubmitting: false<br/>  });<br/>  const [inputs] = useState({});</span><span id="daa9" class="mh ku it ks b gy oa nx l ny nz"><strong class="ks iu">const validateAll = async () =&gt; {<br/>    const promises = [];<br/>    let newUiState = { ...uiState };</strong></span><span id="3d73" class="mh ku it ks b gy oa nx l ny nz"><strong class="ks iu">Object.keys(validators).forEach(async field =&gt; {<br/>      promises.push(<br/>        runValidators({<br/>          field,<br/>          validators: validators[field],<br/>          eventType: "onBlur",<br/>          value: inputs[field].value<br/>        })<br/>      );<br/>    });</strong></span><span id="c25f" class="mh ku it ks b gy oa nx l ny nz"><strong class="ks iu">newUiState = {<br/>      ...newUiState,<br/>      isValidating: true<br/>    };<br/>    setUiState(newUiState);</strong></span><span id="ba01" class="mh ku it ks b gy oa nx l ny nz"><strong class="ks iu">const results = await Promise.all(promises);<br/>    results.forEach(result =&gt; {<br/>      formValidity[result.field] = result;<br/>    });</strong></span><span id="92be" class="mh ku it ks b gy oa nx l ny nz"><strong class="ks iu">setUiState({ ...newUiState, isValidating: false });<br/>  };</strong></span><span id="5562" class="mh ku it ks b gy oa nx l ny nz">const onSubmit = async (evt, props) =&gt; {<br/>    evt.preventDefault();<br/>    let newUiState = { ...uiState };<br/>    try {<br/><strong class="ks iu">      await validateAll();<br/>      const isFormValid = !Object.keys(formValidity).some(<br/>        field =&gt; !formValidity[field].valid<br/>      );</strong></span><span id="905c" class="mh ku it ks b gy oa nx l ny nz">newUiState = {<br/>        ...newUiState,<br/>        isSubmitting: true,<br/><strong class="ks iu">        isValid: isFormValid<br/></strong>      };<br/>      setUiState(newUiState);<br/>      if (props.onSubmit) {<br/>        await props.onSubmit({ evt, formValues });<br/>      }<br/>      setUiState({ ...newUiState, isSubmitting: false });<br/>    } catch {<br/>      setUiState({ ...newUiState, isSubmitting: false });<br/>    }<br/>  };</span><span id="4c0f" class="mh ku it ks b gy oa nx l ny nz">const getFormProps = (props = {}) =&gt; ({<br/>    ...defaultFormProps,<br/>    ...props,<br/>    onSubmit: evt =&gt; onSubmit(evt, props)<br/>  });</span><span id="ed92" class="mh ku it ks b gy oa nx l ny nz">const onInputChange = (name, value) =&gt; {<br/>    formValues[name] = value;<br/>  };</span><span id="6d34" class="mh ku it ks b gy oa nx l ny nz"><strong class="ks iu">const onInputBlur = async (name, value) =&gt; {<br/>    if (validators[name]) {<br/>      if (<br/>        formValidity[name] &amp;&amp;<br/>        formValidity[name].isValidating &amp;&amp;<br/>        formValidity[name].value === value<br/>      ) {<br/>        // No need to do anything at this point since validator is already running<br/>        return;<br/>      }<br/>      setFormValidity({<br/>        ...formValidity,<br/>        [name]: { ...formValidity[name], isValidating: true, value }<br/>      });<br/>      const validationResults = await runValidators({<br/>        field: name,<br/>        validators: validators[name],<br/>        eventType: "onBlur",<br/>        value<br/>      });<br/>      setFormValidity({ ...formValidity, [name]: validationResults });<br/>    }<br/>  };</strong></span><span id="2c1d" class="mh ku it ks b gy oa nx l ny nz">const addInput = ({ name, value<strong class="ks iu">, validators: inputValidators = []</strong> }) =&gt; {<br/>    const input = useInput({<br/>      name,<br/>      value,<br/>      props: { onChange: onInputChange, onBlur: onInputBlur }<br/>    });<br/>    inputs[name] = input;<br/>    formValues[name] = value;<br/><strong class="ks iu">    validators[name] = inputValidators;</strong><br/>    return input;<br/>  };</span><span id="0445" class="mh ku it ks b gy oa nx l ny nz">return {<br/>    getFormProps,<br/>    formValues,<br/><strong class="ks iu">    formValidity,</strong><br/>    uiState,<br/>    inputs,<br/>    api: {<br/>      addInput<br/>    }<br/>  };<br/>};</span></pre><p id="27b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> use-form.test.js </strong></p><p id="4906" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加了与验证相关的use-form.test.js更新，可以在github资源库中找到。下面显示了use-form.test.js中的一个测试。它展示了我们如何在触发模糊的异步验证过程中测试状态变化。</p><pre class="lw lx ly lz gt ns ks nt nu aw nv bi"><span id="63fc" class="mh ku it ks b gy nw nx l ny nz">it("should be able to add an input with valid asynchronous validation and get correct formValidity input state", async () =&gt; {<br/>    const customValidator = createValidator({<br/>      validateFn: async text =&gt;<br/>        await new Promise(resolve =&gt; {<br/>          setTimeout(() =&gt; resolve(true), 1);<br/>        }),<br/>      error: "CUSTOM_ASYNC_ERROR"<br/>    });</span><span id="0363" class="mh ku it ks b gy oa nx l ny nz">const { result, waitForNextUpdate } = renderHook(() =&gt; useForm());</span><span id="2622" class="mh ku it ks b gy oa nx l ny nz">renderHook(() =&gt;<br/>      result.current.api.addInput({<br/>        name: "test",<br/>        value: "",<br/>        validators: [{ ...customValidator, when: ["onBlur"] }]<br/>      })<br/>    );<br/>    await result.current.inputs.test.getInputProps().onBlur({<br/>      preventDefault: noop,<br/>      target: {<br/>        value: ""<br/>      }<br/>    });<br/>    expect(result.current.formValidity).toEqual({<br/>      test: { isValidating: true, value: "" }<br/>    });</span><span id="8c7d" class="mh ku it ks b gy oa nx l ny nz">jest.runAllTimers();<br/>    await waitForNextUpdate();</span><span id="1996" class="mh ku it ks b gy oa nx l ny nz">expect(result.current.formValidity).toEqual({<br/>      test: { field: "test", valid: true }<br/>    });<br/>  });</span></pre><h1 id="6b14" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="f5bb" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">在这篇文章中，我们设计了基本的输入验证支持，修改了<code class="fe kp kq kr ks b">useForm</code>钩子来支持它，决定了验证状态解决方案，添加了适当的测试覆盖，并扩展了我们的表单示例。</p><p id="0a2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后面的部分中，我们将讨论其他主题，比如减少样板文件、从JSON模式添加验证、承诺取消、去抖动、钩子性能考虑和其他设计优化。</p><p id="a8b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何问题、反馈或建议，或者您希望我介绍本系列中的其他内容，请告诉我。</p></div></div>    
</body>
</html>