<html>
<head>
<title>Scrolling through large datasets in Spring Data JPA with Streams and Specification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流和规范在Spring Data JPA中滚动大型数据集</h1>
<blockquote>原文：<a href="https://itnext.io/scrolling-through-large-datasets-in-spring-data-jpa-with-streams-and-specification-2fd975129758?source=collection_archive---------0-----------------------#2020-03-03">https://itnext.io/scrolling-through-large-datasets-in-spring-data-jpa-with-streams-and-specification-2fd975129758?source=collection_archive---------0-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e57f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">如何高效地构建CSV文件——以Spring Data JPA的流功能和JPA规范(或任何其他相关的东西)为特色。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4f370d2b0a9da7b2a9fc665b47f8cb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H_pjfNXzIDI7-qPb"/></div></div></figure><p id="124a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例GitHub(如果你更愿意浏览代码本身而不是阅读本文):<a class="ae ky" href="https://github.com/verzac/demo-spring-data-jpa-stream-and-spec" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/verzac/demo-spring-data-JPA-stream-and-spec</a></p><h1 id="b4c1" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们为什么需要这个？</h1><p id="9cd2" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><em class="kl">如果你是专门找这篇文章的，不需要解释为什么这很重要，请随意跳过。</em></p><p id="e165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象以下场景:您的用户希望根据动态标准(例如，他们的年龄超过30岁)从您的数据库下载一个填充了客户数据的CSV文件。简单吧？任何系统都应该具有这种导出功能！</p><p id="a767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是等等，没那么简单。首先，您不能总是在内存中加载数据集和构造CSV，以免您的应用程序以最怪异的方式崩溃:耗尽内存。</p><h1 id="f825" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们要用什么？</h1><p id="67bb" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">创建CSV是比较容易的部分:您所要做的就是返回一个包含所有数据的文本。CSV文本中的每一行都代表一行(和/或本例中的一个实体),每一行都包含一组用逗号分隔的数据。</p><p id="b243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是困难的部分:因为您的用户希望按照某个标准动态过滤，所以我们必须使用一种允许您动态构建WHERE子句的机制。如果你以前使用过Spring，你可能会注意到这不是很容易/优雅地做到，因为Spring为你设置的许多功能都是在系统启动时设置的。</p><p id="ba7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么我们需要JPA规范。</p><p id="9b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JPA规范允许您在Spring数据中动态地创建WHERE子句，而无需实际实现自己的存储库类(即，您自己处理EntityManager并手动创建查询，这对于许多样板代码来说是一个滑坡)。</p><p id="12a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JPA规范有几个优点:</p><ul class=""><li id="fada" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">默认情况下，它与Spring数据一起提供。存在JPA规范的第三方替代方案，如QueryDSL。这些第三方替代品<em class="kl">可能</em>为一些开发者提供更好的API。然而，JPA规范位于Spring现有的Criteria API(自己编写SQL字符串的替代方案)之上，这意味着您编写的逻辑可以在JPA规范和Criteria API之间互换(某种程度上)。</li><li id="439b" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">您可以使用简单但可行的布尔逻辑来混合和匹配规范。因为这是基于代码的，而不是Spring自动为你生成的，所以你可以根据需要动态地混合和匹配。例如，您可以使用AND操作符组合以下两个规范:<code class="fe mq mr ms mt b">CustomerSpecification.hasName(“Ben”).and(CustomerSpecification.hasJob(“Software Developer”))</code>，它相当于<code class="fe mq mr ms mt b">SELECT … WHERE name = ‘Ben’ AND job = ‘Software Developer’</code>。</li></ul><p id="af29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这篇博文不会深入讨论如何创建自己的规范；已经有大量的资源可以帮助你做到这一点:</p><ul class=""><li id="bb78" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">上面的GitHub repo是一个示例项目，它实现了我们将要在这里讨论的所有内容。</li><li id="40a6" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated"><a class="ae ky" href="https://spring.io/blog/2011/04/26/advanced-spring-data-jpa-specifications-and-querydsl/" rel="noopener ugc nofollow" target="_blank">https://spring . io/blog/2011/04/26/advanced-spring-data-JPA-specifications-and-query DSL/</a></li></ul><h1 id="5a0e" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">将一切联系在一起</h1><p id="2f34" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">那么，我们如何实现它来构造我们可爱的CSV文件呢？</p><h2 id="0e4e" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated">将所有内容加载到内存中，然后将它们全部整理到一个CSV中。</h2><p id="1244" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">坦白地说，对于某些系统来说，这已经足够了。例如，如果您知道您的数据永远不会超过100行，那么您可能不希望过度设计您的解决方案，而只是快速运行一行程序来实现这一点。类似于…</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2377" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，问题是这种解决方案不太具有可伸缩性，而且坦率地说，很危险，因为将所有内容都加载到内存中意味着您可以加载太多的数据，以至于应用服务器的内存无法容纳。例如，如果您的数据每天都在增长，有一天，您不得不将1亿条记录加载到应用程序的内存中，该怎么办？我告诉你:你的应用要崩溃了。</p><p id="0697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使我们……</p><h2 id="4b3e" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated">逐页加载所有内容，然后将每一页作为CSV文件顺序写入输出</h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e77e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是第二种选择，也是最常见的一种，真的。这种技术背后的基本概念是，您将数据分割成多个一口大小的“页面”，然后逐页处理它们。这可以防止应用服务器崩溃，因为您试图将整个数据库加载到应用程序中。</p><p id="0eb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，我们使用<code class="fe mq mr ms mt b">PrintWrite</code>来发送数据，而不是在内存中整理完整的列表然后返回。这允许您在处理下一个页面之前将页面内容刷新到您的响应中，有效地防止您的应用程序耗尽内存。</p><p id="e3d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法没有什么大的错误。这是广泛应用中使用的标准方法。如果这种方法对你有效，请继续使用它。</p><p id="b7a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这种方法有一些奇怪的地方。</p><p id="1e37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您必须编写自己的逻辑来“迭代”页面，这意味着需要测试和维护更多的代码。现在，这还不是世界末日，但这样做确实很烦人。记住，你写的代码越少，你需要维护的就越少。</p><p id="c7ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个更重要的原因是，据报道，这种分页方法不如下一种方法有效，后者是…</p><h1 id="6197" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用Spring Data JPA的流功能</h1><p id="775c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这就是我们今天要讲的内容。</p><p id="af28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，调用您的存储库方法将产生一个<code class="fe mq mr ms mt b">Stream&lt;YourObject&gt;</code>。您的持久性提供者(例如，通过ScrollableResultSet的Hibernate，通过ScrollableCursor的EclipseLink)将决定如何有效地将您想要的数据传输到您的应用程序中，尽管可以放心的是，他们可以<em class="kl">通常</em>比您自己实现它们更好地处理分页逻辑。</p><p id="c1fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法有几个优点:</p><ul class=""><li id="c4ac" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">更好的代码组织，因为你不必处理数据集的迭代逻辑。</li><li id="1744" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">性能，因为您不必向数据库发出多个庞大的页面请求。</li><li id="2e47" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">记忆友好！[至少对于PostgreSQL和MySQL您可以将加载到内存中的条目数量限制为一次只能加载一个条目，其余的都可以进行GC处理！</li></ul><p id="c9b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[1]<a class="ae ky" href="https://www.baeldung.com/spring-data-java-8" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/spring-data-java-8</a></p><p id="30ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Spring数据已经支持流。有关实现这一点的各种方法，请参见以下代码片段:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="05f9" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated"><strong class="ak">但是等等，这两个特性还不一定兼容呢！</strong></h2><p id="f884" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">有人谈到在JpaSpecificationExecutor中引入一个基于流的结果(如果你想使用JPA规范，这是你通常会扩展的)，但我不认为它背后有任何真正的驱动(我丢失了票号；埋在Spring Data的JIRA里，见<a class="ae ky" href="https://jira.spring.io" rel="noopener ugc nofollow" target="_blank"> https://jira.spring.io </a>。</p><p id="4635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，实现它(为你自己)是相当容易的；你所需要做的就是使用EntityManager的<code class="fe mq mr ms mt b">getResultStream </code>而不是通常的<code class="fe mq mr ms mt b">getResultList </code>返回一个列表(<code class="fe mq mr ms mt b">CustomerRepository.findAll</code>在幕后使用它)。</p><p id="d43b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，当Spring数据中存在功能缺口时，你会怎么做呢(除了自己实现整个存储库类，只是为了使用一个新的、时髦的功能)？</p><h1 id="944c" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">仓库碎片来拯救！</h1><div class="ni nj gp gr nk nl"><a href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.single-repository-behavior" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">Spring数据共享——参考文档</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">由于各个Spring数据模块的开始日期不同，大多数都有不同的主要和次要版本…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">docs.spring.io</p></div></div></div></a></div><p id="fe37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“片段”是某种程度上可重用的、定制的拼图，您的存储库类可以对其进行扩展，以在任何现有的通用查询方法(例如findAll、findById)之上添加定制的方法/功能。以下是Spring Data的文档对碎片的描述:</p><blockquote class="nu nv nw"><p id="a848" class="jn jo kl jp b jq jr js jt ju jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj kk ij bi translated">当查询方法需要不同的行为或者无法通过查询派生来实现时，就有必要提供自定义实现。Spring数据存储库允许您提供定制的存储库代码，并将其与通用的CRUD抽象和查询方法功能集成在一起。</p></blockquote><p id="8a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你觉得这听起来可怕吗？最初对我来说是这样，但实际上这是我发现的最好的东西，可以用来“聚合填充”Spring数据中缺失的功能。</p><p id="9d40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以这样使用它:</p><p id="527f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您必须定义一个片段接口:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="031f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后是片段接口的实现(注意，您可以<code class="fe mq mr ms mt b">@Autowire</code>任何您想要的东西，因为Spring在运行时将它实例化为bean，即使您没有将它作为Spring组件):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="64e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了在您的存储库中使用定制方法，您需要做的就是扩展我们制作的片段接口:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9c63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧啊。现在CustomerRepository将有一个接受您的规范的stream()方法！你可以这样使用它:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="de64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，这不仅限于JPA规范；使用存储库片段，您实际上可以让您的存储库按照您想要的方式运行，因为您可以完全控制方法是如何执行的。</p><h1 id="eda6" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">重要花絮</h1><h2 id="a74e" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated">流只能在事务中打开</h2><p id="2ea1" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这是因为当我们在流中返回数据时，我们必须保持数据库状态足够稳定，这样我们才能安全地滚动它的数据。除此之外，默认情况下，当您在Spring数据中做了一些事情之后，您的DB会话是“关闭”的，但是流不一定以这种方式工作。当流仍然打开且尚未关闭时，需要保证连接/会话是打开的，因为客户端仍可能检索数据。</p><h2 id="a47d" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated">EntityManager::分离</h2><p id="8c7c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">现在，取决于你问谁，这可能是可选的。我还没有仔细研究过流式对象是如何被处理的，但是我想这样做不会有什么坏处(而且我看过的所有资料都推荐这样做)。</p><p id="ec7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">据我所知，如果对象没有被首先分离(我认为这是有意义的)，它不会被自动GC'd并从内存中删除。请记住，所有这些都发生在一个事务中，因此返回的“对象”与持久性上下文相关联，这意味着对对象的任何更改都会同步到您的数据库中。</p><h2 id="58e4" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated">获取大小？那是什么？</h2><p id="8186" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这设置了JDBC驱动程序(即从系统中实际连接到数据库的设备)在给定时间应该获取的行数。不同的DB驱动程序需要不同的值来执行逐行提取(这就是我们在这里要做的)。我记得MySQL要求HINT_FETCH_SIZE为<code class="fe mq mr ms mt b">"" + Integer.MIN_VALUE</code>，PostgreSQL要求值设置为1。</p><p id="5896" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">差不多就是这样了！现在，您可以在任何需要这个规范+流能力的存储库中扩展<code class="fe mq mr ms mt b">StreamableJpaSpecificationRepository</code>。</p><h2 id="cb88" class="mu la iq bd lb mv mw dn lf mx my dp lj jy mz na ln kc nb nc lr kg nd ne lv nf bi translated">我必须使用JPA规范吗？</h2><p id="0e4c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">不可以。存储库允许您使用任何东西来定义您的“标准”。只要它与Criteria API(或EntityManager)兼容，就可以使用这个方法来插入任何缺失的功能。</p><p id="cb64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，如果您想玩我设置的示例应用程序，请查看我的GitHub repo，它附带了一个SQL脚本，可以用500，000条虚拟数据记录播种您的数据库:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/verzac/demo-spring-data-jpa-stream-and-spec" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">verzac/demo-spring-data-JPA-stream-and-spec</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">或者，您可以自己设置Postgres实例并编辑src/main/resources/application-local . yml docker run…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kw nl"/></div></div></a></div><h1 id="991d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">后续步骤</h1><p id="d9e1" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">您可以采取各种后续步骤来优化这一功能:</p><ul class=""><li id="50f5" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">您可以将您的CSV流功能分离到一个单独的服务中，该服务处理所有这些逻辑，这样您就可以让其他组件重用它。我为以前的项目这样做，它允许任何控制器利用这一功能；控制器所要做的就是将响应的PrintWriter传递给服务。</li><li id="4d47" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">将它与StreamingResponseBody结合起来，以便将繁重的工作卸载到另一个线程，这样就可以释放HTTP servlet线程，从而防止阻塞应用程序。这对于大型数据集非常有用。我在这篇中型文章中发现了这个绝妙的技巧:</li></ul><div class="ni nj gp gr nk nl"><a href="https://medium.com/swlh/streaming-data-with-spring-boot-restful-web-service-87522511c071" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">使用Spring Boot RESTful Web服务流式传输数据</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">流式数据是一种全新的向网络浏览器发送数据的方式，它提供了显著更快的页面速度…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of kw nl"/></div></div></a></div><ul class=""><li id="5533" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">告诉你的用户不要再要求这个功能了，这样你就不用构建了；)</li></ul></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="334e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！希望你喜欢这篇文章，并随时向我提供任何反馈意见:)</p></div></div>    
</body>
</html>