<html>
<head>
<title>Kafka Consumer Autoscaling with KEDA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡消费与KEDA的自动缩放</h1>
<blockquote>原文：<a href="https://itnext.io/kafka-consumer-autoscaling-with-keda-41310f80a62a?source=collection_archive---------2-----------------------#2022-03-13">https://itnext.io/kafka-consumer-autoscaling-with-keda-41310f80a62a?source=collection_archive---------2-----------------------#2022-03-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/81bb4aea8caa3345fdef598bef9dddca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIXOHTrWiUPpngWdhv16vA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自<a class="ae kf" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2397805" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="0803" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在Kubernetes中探索卡夫卡式的消费者自动缩放。</p><p id="a4ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果消费者的当前读取偏移落后于分区中的实际偏移(Log End Offset)太多，超过某个阈值，那么将创建额外的消费者副本来加速Kafka主题的处理。如果滞后下降到阈值以下，那么消费者的数量也应该下降。</p><p id="e0cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个典型的水平Pod自动扩展用例，可以通过自定义指标来实现。我们没有这样做，而是使用KEDA，它有一个现成的Kafka缩放器来实现Kafka消费者的自动缩放。让我们来测试一下。</p><p id="5ad3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于测试环境，Kubernetes引擎是OpenShift容器平台(OCP)。我正在为Kafka使用IBM事件流(基于Strimizi操作符)。</p><h2 id="587b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">安装KEDA</h2><p id="e922" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们让KEDA在OCP当接线员。</p><p id="8751" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先创建一个名为<code class="fe mc md me mf b">keda</code>的名称空间。创建以下OperatorGroup和订阅，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="21cd" class="le lf it mf b gy mo mp l mq mr">apiVersion: operators.coreos.com/v1<br/>kind: OperatorGroup<br/>metadata:<br/>  name: keda-og<br/>  namespace: keda<br/>spec:<br/>  targetNamespaces:<br/>---<br/>apiVersion: operators.coreos.com/v1alpha1<br/>kind: Subscription<br/>metadata:<br/>  name: keda-operator<br/>  namespace: keda<br/>spec:<br/>  name: keda<br/>  source: community-operators<br/>  sourceNamespace: openshift-marketplace</span></pre><p id="229c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作符将被安装在keda名称空间上，并将管理所有的名称空间(<em class="ms"> targetNamespaces被设置为空</em>)。</p><p id="d3f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦安装了操作符，创建下面的Keda控制器CRD，跳过所有带有默认值的字段。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="b527" class="le lf it mf b gy mo mp l mq mr">apiVersion: keda.sh/v1alpha1<br/>kind: KedaController<br/>metadata:<br/>  name: keda<br/>  namespace: keda<br/>spec:<br/>  watchNamespace: ""<br/>  logEncoder: console<br/>  logLevel: info<br/>  logLevelMetrics: '0'</span></pre><p id="318f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">KEDA控制器现在正在监视KEDA CRDs的任何名称空间。KEDA部署已完成。</p><h2 id="448b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">卡夫卡生产者和消费者</h2><p id="e801" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">使用Kafka库<code class="fe mc md me mf b">github.com/segmentio/kafka-go</code>在Golang中创建了Kafka生产者和消费者。</p><p id="d850" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成器作为HTTP处理程序运行。一旦收到请求，处理程序就会触发一个goroutine向一个Kafka主题写入一些伪造的JSON数据。goroutine的生命周期是不受管理的，因为我们是在一个长期运行的web处理程序中。下面显示了一些代码摘录，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2d8d" class="le lf it mf b gy mo mp l mq mr">func write_messages(writer *kafka.Writer, count int) {<br/> for i := 0; i &lt; count; i++ {<br/>  payload, err := dataset.NewDataAsBytes()<br/>  if err != nil {<br/>   log.Printf("Failed to create payload:%v", err)<br/>   continue<br/>  }<br/>  err = writer.WriteMessages(context.Background(), kafka.Message{<br/>   // Key:   []byte("key"),<br/>   Value: payload,<br/>  })</span><span id="a9f1" class="le lf it mf b gy mt mp l mq mr">  if err != nil {<br/>   log.Printf("Failed to write message:%v", err)<br/>   continue<br/>  }<br/> }<br/>}</span><span id="f685" class="le lf it mf b gy mt mp l mq mr">func handle_producer(writer *kafka.Writer) http.HandlerFunc {<br/> return func(w http.ResponseWriter, r *http.Request) {<br/>  count := r.FormValue("count")<br/>  n, err := strconv.Atoi(count)<br/>  if err != nil {<br/>   log.Printf("Failed to convert count:%v", err)<br/>   http.Error(w, "count value is not a valid number", http.StatusBadRequest)<br/>   return<br/>  }</span><span id="efc8" class="le lf it mf b gy mt mp l mq mr">  go write_messages(writer, n) //fire and forget<br/>  fmt.Fprintf(w, "request submitted: count=%d\n", n)<br/> }<br/>}</span></pre><p id="7e0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在消费者程序中，<code class="fe mc md me mf b">ibmes.RunCGReadLoop</code>是一个等待卡夫卡消息的循环。当消息可用时，它将调用一个函数来处理它。该函数将消息发送到go通道进行进一步处理。该函数应该是一个goroutine，但是在我们的测试场景中，我们同步运行它来模拟延迟，以便消息可以堆积在分区中。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="dbeb" class="le lf it mf b gy mo mp l mq mr">func main() {<br/> ...</span><span id="b64f" class="le lf it mf b gy mt mp l mq mr"> msgCh := make(chan []byte)<br/> go ibmes.RunCGReadLoop(strings.Split(brokers, ","), scramUser, scramPass, pemFile, topic, group, func(m kafka.Message) {<br/>  // go func() {<br/>  log.Printf("Sleep 10 seconds to simulate delay...")<br/>  time.Sleep(10 * time.Second)<br/>  msgCh &lt;- m.Value<br/>  log.Printf("Wake up...")<br/>  // }()<br/> })</span><span id="9b0e" class="le lf it mf b gy mt mp l mq mr"> for {<br/>  select {<br/>  case msg := &lt;-msgCh:<br/>   fmt.Printf("msg: %s\n", string(msg))<br/>  }<br/> }<br/>}</span></pre><p id="a2a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生产者和消费者作为K8s部署在名称空间<code class="fe mc md me mf b">keda-kafka</code>中运行</p><h2 id="edd0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用KEDA自动缩放</h2><p id="9b12" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">一旦创建了KEDA控制器，我们就可以创建一个ScaledObject来监视和缩放。</p><p id="4e81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ScaledObject将需要一些目标的身份验证信息，我们可以将它们存储在一个秘密中。如下所示，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="96c5" class="le lf it mf b gy mo mp l mq mr">apiVersion: keda.sh/v1alpha1<br/>kind: TriggerAuthentication<br/>metadata:<br/>  name: keda-trigger-auth-kafka-credential<br/>  namespace: keda-kafka<br/>spec:<br/>  secretTargetRef:<br/>  - parameter: sasl<br/>    name: keda-kafka-secrets<br/>    key: sasl<br/>  - parameter: username<br/>    name: keda-kafka-secrets<br/>    key: username<br/>  - parameter: password<br/>    name: keda-kafka-secrets<br/>    key: password<br/>  - parameter: tls<br/>    name: keda-kafka-secrets<br/>    key: tls<br/>  - parameter: ca<br/>    name: keda-kafka-secrets<br/>    key: ca</span></pre><p id="c86d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个TriggerAuthentication CR。例如，参数值username将引用名为<code class="fe mc md me mf b">keda-kafka-secrets</code>的秘密中的密钥字段username。</p><p id="8541" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相应的秘密如下所列，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="bf97" class="le lf it mf b gy mo mp l mq mr">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: keda-kafka-secrets<br/>  namespace: keda-kafka<br/>stringData:<br/>  sasl: scram_sha512<br/>  username: ...redacted...<br/>  password: ...redacted...<br/>  tls: enable<br/>  ca: |-<br/>    -----BEGIN CERTIFICATE-----<br/>    ...redacted...<br/>    -----END CERTIFICATE-----</span></pre><p id="96a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ScaledObject的列表</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="deb7" class="le lf it mf b gy mo mp l mq mr">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: kafka-scaledobject<br/>  namespace: keda-kafka<br/>spec:<br/>  scaleTargetRef:<br/>    name: consumer<br/>  pollingInterval: 30</span><span id="e5b8" class="le lf it mf b gy mt mp l mq mr">  minReplicaCount: 1<br/>  triggers:<br/>  - type: kafka<br/>    metadata:<br/>      bootstrapServers: es-kafka-bootstrap-es.apps.dev-ocp49.ibmcloud.io.cpak:443<br/>      consumerGroup: test-consumer-group<br/>      topic: test-topic<br/>      lagThreshold: "5" #must be a string<br/>      offsetResetPolicy: latest<br/>    authenticationRef:<br/>      name: keda-trigger-auth-kafka-credential</span></pre><p id="5033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">扩展目标是名为“消费者”的K8s部署。扩展的触发器是用设置为Kafka的类型定义的，后面是引导服务器、主题、要监控的消费者组、滞后阈值和认证参考。</p><p id="c9d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用YAML文件，我们现在可以看到创建了一个HPA资源，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3c7e" class="le lf it mf b gy mo mp l mq mr">$ kubectl -n keda-kafka get hpa<br/>NAME                          REFERENCE             TARGETS     MINPODS   MAXPODS   REPLICAS   AGE<br/>keda-hpa-kafka-scaledobject   Deployment/consumer   0/5 (avg)   1         100       1          25h</span></pre><h2 id="e8a5" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">测试</h2><p id="72a2" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">检查吊舱的初始数量。我们只有生产者和消费者的豆荚，每一个都有。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="0b00" class="le lf it mf b gy mo mp l mq mr">$ oc get pods<br/>NAME                        READY   STATUS    RESTARTS   AGE<br/>consumer-59fc86f698-tz45s   1/1     Running   0          24h<br/>producer-7bc59d8bc7-6zcht   1/1     Running   0          24h</span></pre><p id="0d73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用生产者泵入100条信息，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="dfa9" class="le lf it mf b gy mo mp l mq mr">curl "http://producer-service-keda-kafka.apps.dev-ocp49.ibmcloud.io.cpak/pump?count=100"</span></pre><p id="eb31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于延迟，你会很快看到缩放，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="f107" class="le lf it mf b gy mo mp l mq mr">$ oc get pods<br/>NAME                        READY   STATUS    RESTARTS   AGE<br/>consumer-59fc86f698-2xcvs   1/1     Running   0          2m23s<br/>consumer-59fc86f698-gsf7c   1/1     Running   0          2m8s<br/>consumer-59fc86f698-gv7cx   1/1     Running   0          2m23s<br/>consumer-59fc86f698-mft5w   1/1     Running   0          2m23s<br/>consumer-59fc86f698-tz45s   1/1     Running   0          24h<br/>consumer-59fc86f698-vkcwh   1/1     Running   0          2m8s<br/>producer-7bc59d8bc7-6zcht   1/1     Running   0          24h</span></pre><p id="e8bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HPA资源显示，</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2d4f" class="le lf it mf b gy mo mp l mq mr">$ oc get hpa<br/>NAME                          REFERENCE             TARGETS         MINPODS   MAXPODS   REPLICAS   AGE<br/>keda-hpa-kafka-scaledobject   Deployment/consumer   4167m/5 (avg)   1         100       6          25h</span></pre><p id="e628" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同时，我们可以从事件流控制台检查滞后，</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/5e25cbc79c52893babc31dfccd6d58bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AhO56ASaRX0cgdD4x_-KA.png"/></div></div></figure><p id="75d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦波通过，在默认的5分钟冷却时间后，豆荚的数量将下降到1。</p><p id="8fb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用下面的PromSQL创建一个Grafana仪表板</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="b630" class="le lf it mf b gy mo mp l mq mr">count(kube_pod_info{namespace="keda-kafka", pod=~"consumer.*"})</span></pre><p id="8ded" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以清楚地看到豆荚的自动伸缩。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/e5ce7de72e2e1b1cf14fa6b436f64af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8h0VvimsEUIZprIbfUoICg.png"/></div></div></figure><p id="cee5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ms">讨论:题目有5个分区。KEDA正在将副本扩展到分区数量。然而，似乎KEDA没有计算初始吊舱。在卡夫卡的例子中，在6个复制品中，有一个复制品在空转。</em></p><p id="667e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ms">参考</em> <a class="ae kf" href="https://zhimin-wen.medium.com/running-kafka-exporter-in-openshift-81c62d45bd8d" rel="noopener"> <em class="ms">我后来的故事</em> </a> <em class="ms">关于如何在Grafana仪表盘中查看和观察消费群体滞后。</em></p><h2 id="fb90" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="7794" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">KEDA带来了大量的定标器，使HPA更容易。</p></div></div>    
</body>
</html>