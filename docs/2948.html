<html>
<head>
<title>Building a Skinnable, Multi-Tenant Angular Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建可换肤的多租户Angular应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/building-a-skinnable-multi-tenant-angular-application-7bc6f558fc0c?source=collection_archive---------0-----------------------#2019-09-05">https://itnext.io/building-a-skinnable-multi-tenant-angular-application-7bc6f558fc0c?source=collection_archive---------0-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="08a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">这是一个常见的故事:你开始一个构建应用程序的项目，比方说，一个为客户售票的应用程序。事情进展顺利。你的客户喜欢这个应用程序。一切都很好，直到你的客户问你是否有可能为他们的另一个资产部署应用程序——问题是外观和感觉必须不同于你一直在开发的那个。哦，也许，只是为了好玩，让我们说它与不同的认证提供者对话。</p><p id="87b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝贺您:您刚刚进入了多租户区域。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/b9f45edbdebf369616c83f32487ea0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*_IHDTTv-8szUfWhAJ5cC1A.png"/></div></figure><p id="5385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是应用程序开发中的一个常见问题，根据语言/工具包/框架的不同，有许多既定的解决方案。大体上，我们可以认为解决方案有两种不同的风格:</p><ol class=""><li id="c5fb" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">静</strong>。在静态解决方案中，人们会产生不同的代码，这些代码将被单独编译和部署。</li><li id="a222" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">动态</strong>。在动态解决方案中，人们会生成一个单一的代码库，在运行时确定正确的租户。</li></ol><p id="c197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为很容易想到静态解决方案是如何工作的。动态的那个？不太明显。</p><p id="5e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将分享一个基于Angular框架的动态方法来解决这个问题。本文中的示例是在Angular 8的上下文中开发的，但是很可能与Angular 7以及更早版本的Angular兼容。因此，让我们开始吧…</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="ab33" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">多租户角度应用程序的核心</h1><p id="e9c6" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi kl translated">要建立多租户，我们需要做的第一件事是创建一组负责管理应用程序中当前租户的组件。它将负责以下任务:</p><ol class=""><li id="7ce7" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">基于URL确定当前租户是谁。</li><li id="4034" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">用一个特殊的头装饰我们发送回应用程序服务器部分的头，让后端知道我们代表哪个租户。</li></ol><p id="f7d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据这两个简单的功能，我们将启用以下多租户功能:</p><ol class=""><li id="3917" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">基于租户的可换肤组件。</li><li id="2ad9" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">基于租户的服务变体的自动注入。</li><li id="f707" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">基于租户的自动模块级路由重新配置。</li></ol><p id="782c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，在概念上更多的特性是可能的，但是本文只考虑这两个。</p><p id="deb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们启动一个新的角度应用程序:</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="47ad" class="ng lz iq nc b gy nh ni l nj nk"># ng new multi-tenant-angular</span></pre><p id="4633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创造一个新鲜的，但空白的新的角度应用，这将作为我们将要建立的基础。</p><h1 id="cc65" class="ly lz iq bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">构建租户服务</h1><p id="d3a4" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">我们需要做的第一件事是构建一个服务，它可以确定给定URL的正确租户。以这种方式建立租赁是一种非常常见的模式，下面是它的工作方式。</p><p id="e955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，考虑一个如下所示的URL:</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="bf9b" class="ng lz iq nc b gy nh ni l nj nk">http://<strong class="nc ir">tenant-name</strong>.applicationdomain.dom</span></pre><p id="9c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的URL中，域的第一部分(租户名称)是租户的来源。这允许我们构建一个URL结构，例如:</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="3ee7" class="ng lz iq nc b gy nh ni l nj nk"><a class="ae nq" href="http://client1.applicationdomain.dom" rel="noopener ugc nofollow" target="_blank">http://client1.applicationdomain.dom</a><br/>http://client2.applicationdomain.dom<br/>http://client3.applicationdomain.dom</span></pre><p id="dcbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中客户机1、客户机2和客户机3都是我们应用程序的租户。为了实现这个功能，让我们在应用程序中的一个模块中创建一个TenantService，我们用它来保存所有的租户功能。我们可以用下面两个命令完成所有这些。</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="5934" class="ng lz iq nc b gy nh ni l nj nk"># ng generate module tenant<br/># ng generate service tenant/tenant</span></pre><p id="a1f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个命令将在文件<code class="fe nr ns nt nc b">src/app/tenant/tenant.module.ts</code>中创建模块<code class="fe nr ns nt nc b">TenantModule</code>，第二个命令将在文件<code class="fe nr ns nt nc b">src/app/tenant/tenant.service.ts</code>中创建服务<code class="fe nr ns nt nc b">TenantService</code>。</p><p id="4a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们不需要做任何事情来实现租户模块，下面我们提供服务的最小可行实现。</p><p id="e5d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文件<code class="fe nr ns nt nc b">src/app/tenant/tenant.service.ts</code></p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">TenantService的基本实现。</figcaption></figure><p id="5192" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的定义中，我们为三件事提供了方法:</p><ol class=""><li id="3bf0" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">根据主机名获取当前租户。</li><li id="e8b2" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">向一组HttpHeaders添加特殊的租户头。</li><li id="a4c4" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">为不同的租户定义一组枚举。</li></ol><p id="2407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类现在可以被注入到任何你需要的地方。在下一节中，我们将这样做来注入我们的自定义头。</p><h1 id="9b34" class="ly lz iq bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">用租户信息装饰标题</h1><p id="3690" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">既然我们已经勾勒出了多租户应用程序的基础，现在您可以在任何需要的地方注入您的租户服务。TenantService的目标不是基于租户执行不同的操作，而是注入不同的功能。我们将在下一节介绍如何在我们的应用程序中做到这一点，但在此之前，让我们先介绍另一个小细节:在后端处理多租户。</p><p id="15ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在后端处理多租户，我们将用一个特殊的头来修饰我们发送到后端的任何HTTP请求，该头指示请求的当前租户。为此，我们将使用HTTP拦截器。</p><p id="a243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在您的项目中做到这一点，您将首先创建拦截器，然后将它连接到您的模块中。</p><p id="d6bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，在src/app/tenant目录下创建文件<code class="fe nr ns nt nc b">tenant.interceptor.ts</code>。您的文件应该如下所示:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">我们的房客拦截者。</figcaption></figure><p id="ff55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的文件中，我们简单地截取了HTTP请求，并在其中添加了一个头，表明当前租户是谁。取决于租户，后端会做一些不同的事情。</p><p id="8d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在您的租户中连接拦截器。</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">我们更新的租户模块。</figcaption></figure><p id="334c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成这两项更改后，对后端的任何请求都会自动添加正确的租用标题。</p><h1 id="0a69" class="ly lz iq bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">基于租户动态注入服务</h1><p id="3257" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">好了，现在来点更有趣的。假设在我们的应用程序中，我们有一个负责实现登录的服务。对于客户端1，服务应该以一种方式工作，但是对于客户端2，行为与客户端1不同但相似。</p><p id="4d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从面向对象的角度来看，我们将使用的设计是简单地创建一个基类，比如说，<code class="fe nr ns nt nc b">LoginService</code>，并从中派生两个类，比如说，<code class="fe nr ns nt nc b">Client1LoginService</code>和<code class="fe nr ns nt nc b">Client2LoginService</code>。如何才能实现这一点？</p><p id="f837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在本节中详细介绍的模式可以重复用于任何需要像这样注入服务的情况。基本成分是:</p><ol class=""><li id="9da5" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">它需要在一个模块里</strong>。为了实现这一点，我们将挂钩Angular的提供者特性。我们可以很容易地在模块级做到这一点。</li><li id="9223" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">需要定义一个工厂</strong>。在该模块中，当您配置提供者时，您将配置一个获取服务的正确实例的工厂。</li></ol><p id="f39e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们开始吧。</p><p id="5c9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，创建一个名为LoginModule的新模块，并创建三个服务:</p><ol class=""><li id="a4a5" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">LoginService:基类</li><li id="ccb6" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">Client1LoginService:专门用于client1的服务。</li><li id="6010" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">Client2LoginService:专门为client2提供的服务。</li></ol><p id="0556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过下面的命令序列来实现:</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="6aec" class="ng lz iq nc b gy nh ni l nj nk"># ng generate module login<br/># ng generate service login/login<br/># ng generate service login/client1login<br/># ng generate service login/client2login</span></pre><p id="7420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，让我们假设这两种实现的区别在于，client1需要一个localStorage键集，而as client2不需要。</p><p id="685f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要定义基本的LoginService，它需要包含用于访问登录服务的正确实例的工厂。</p><p id="9721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的清单在login.service.ts中实现了该功能:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">LoginService的实现。</figcaption></figure><p id="74d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于上述实现，有几点需要注意:</p><ol class=""><li id="c54e" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">与大多数服务不同，我们已经移除了<code class="fe nr ns nt nc b">Injectable</code>注释。那是因为你不能直接注入这个服务。</li><li id="dec3" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">在文件的顶部，我们定义了一个工厂，稍后我们将使用它来注入服务的正确版本。请注意，我们将句柄注入到我们将动态返回的服务中。</li><li id="c502" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">在我们抽象的LoginService中，我们定义了一个方法<code class="fe nr ns nt nc b">login</code>，它将返回一个布尔值，表明登录是否成功。</li></ol><p id="48ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们以常规方式实现两个子类，从LoginService扩展:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">Client1登录服务的实现。</figcaption></figure><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">Client2登录服务的实现。</figcaption></figure><p id="abee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在，为了把它绑起来，我们需要更新登录模块的模块定义。我们在下面的login.module.ts清单中这样做:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">登录模块的定义，包括提供者定义。</figcaption></figure><p id="f101" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在登录模块的清单中值得注意的是，我们已经为LoginService显式定义了一个提供者。要使用它，您只需在任何您想要为客户机引用登录服务的地方注入LoginService。例如:</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="c5dd" class="ng lz iq nc b gy nh ni l nj nk">constructor(private loginService: LoginService) {}</span></pre><p id="3b66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保将登录模块添加到您的模块的导入列表中！</p><p id="fc7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意:永远不要试图显式地注入派生的登录类:让工厂来处理！</strong></p><h1 id="b666" class="ly lz iq bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">基于租户动态更改路由</h1><p id="92a3" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">除了动态注入服务之外，有时您可能希望动态更改模块提供的路由。基于上一节中的LoginModule，在这一节中，我们将演示如何基于租户动态切换应用程序中可用的路由。</p><p id="6898" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的技巧是在LoginModule的构造函数中实现这个切换逻辑。在下面的列表中，我们演示了如何实现这一点:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">我们更新的登录模块。</figcaption></figure><h1 id="9db5" class="ly lz iq bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">基于租户动态设计组件样式</h1><p id="f244" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">到目前为止，在本文中，我们已经看到了一些非常简单的概念如何允许我们基于多租户的实现注入一些相当复杂的动态行为。在这一节中，我们将把注意力转向基于租户的组件样式。</p><p id="a896" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在我们开始编写代码之前，让我们先来讨论一下让它工作的想法。</p><p id="710e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们方法背后的技巧是在根应用程序组件上使用CSS选择器<code class="fe nr ns nt nc b">host-context</code>。加载到应用程序根组件中的任何组件都可以访问这个选择器。实际情况是这样的:</p><p id="47de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe nr ns nt nc b">app.component.ts</code></p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">在应用程序中使用主题。</figcaption></figure><p id="35ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的清单中，有几点需要注意:</p><ol class=""><li id="8d71" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">该组件实现了<code class="fe nr ns nt nc b">OnInit</code>。这很重要，因为我们希望在加载组件时建立租户(以及样式)。</li><li id="6a7c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">我们使用<code class="fe nr ns nt nc b">HostBinding </code>注释来有选择地启用<code class="fe nr ns nt nc b">theme-client1</code>或<code class="fe nr ns nt nc b">theme-client2</code>类。</li><li id="9128" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">在ngOnInit函数中，我们基于租户启用主题。</li></ol><p id="feda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要为这个配置编写主题，只需提供一个如下所示的样式表:</p><figure class="kv kw kx ky gt kz"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">我们的应用程序的简单样式表由两个皮肤组成。</figcaption></figure><p id="937f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种配置的好处在于，我们在应用程序组件中展示的代码是初始化代码需要存在的唯一地方。模块中的任何组件只需要为各种主题提供css选择器。也就是说，在您创建的每个组件中，您只需为您的组件提供<code class="fe nr ns nt nc b">host-context</code>样式。</p><h1 id="7858" class="ly lz iq bd ma mb nl md me mf nm mh mi mj nn ml mm mn no mp mq mr np mt mu mv bi translated">结论</h1><p id="d226" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在本文中，我们介绍了构建多租户角度应用程序的基础。具体来说，我们涵盖了:</p><ol class=""><li id="4e53" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">如何创建基本的租户服务？</li><li id="df6c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如何用当前租户装饰传出标头？</li><li id="a057" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如何基于租户动态注入正确的类实例。</li><li id="ccf6" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如何基于租户动态调整应用程序的路由。</li><li id="893a" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如何根据租户设计应用程序的样式。</li></ol><p id="c1b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这篇文章对你有用。如果你有任何建议、问题或意见，请在下面的评论中提出来！</p><p id="1ace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想试试本文开发的应用程序，你可以在GitHub上找到源代码，这里:【https://github.com/jsinglet/multi-tenant-angular<a class="ae nq" href="https://github.com/jsinglet/multi-tenant-angular" rel="noopener ugc nofollow" target="_blank"/></p><p id="78b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要进行本地测试，请确保为client1和client2创建<code class="fe nr ns nt nc b">hosts</code>文件条目，如下所示:</p><p id="d609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe nr ns nt nc b">hosts</code>中:</p><pre class="kv kw kx ky gt nb nc nd ne aw nf bi"><span id="631b" class="ng lz iq nc b gy nh ni l nj nk">127.0.0.1 client1.localhost<br/>127.0.0.1 client2.localhost</span></pre><p id="6ab9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您在本地访问应用程序时，请确保通过这些主机名之一进行访问，以便租赁能够正常工作。</p></div></div>    
</body>
</html>