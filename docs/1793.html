<html>
<head>
<title>Getting Started with Red Hat Ansible for Google Cloud Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Red Hat ansi ble for Google Cloud Platform入门</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-red-hat-ansible-for-google-cloud-platform-fa666c42a00c?source=collection_archive---------2-----------------------#2019-01-30">https://itnext.io/getting-started-with-red-hat-ansible-for-google-cloud-platform-fa666c42a00c?source=collection_archive---------2-----------------------#2019-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7805" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本帖中，我们将探索由Red Hat赞助的开源社区项目<a class="ae ko" href="https://www.ansible.com/#" rel="noopener ugc nofollow" target="_blank"> Ansible </a>的使用，以自动化<a class="ae ko" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a> (GCP)上的资源供应、配置、部署和测试。我们将从使用Ansible配置应用程序并将其部署到现有的GCP计算资源开始。然后，我们将扩展Ansible的用途，使用Ansible/GCP <a class="ae ko" href="https://www.ansible.com/integrations/cloud/google-cloud-platform" rel="noopener ugc nofollow" target="_blank">与<a class="ae ko" href="https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google" rel="noopener ugc nofollow" target="_blank"> GCP模块</a>的本地集成</a>来供应和配置GCP计算资源。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/3063df36710b04c91c7744045eaa20cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZJWHfxItItQElwMsB_ZDg.png"/></div></div></figure><h2 id="e456" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">红帽Ansible</h2><p id="f191" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Ansible，<a class="ae ko" href="https://www.redhat.com/en/about/press-releases/red-hat-acquire-it-automation-and-devops-leader-ansible" rel="noopener ugc nofollow" target="_blank">于2015年10月被Red Hat收购</a>，它在单个平台中无缝地提供了配置管理、供应和应用部署的工作流编排。与类似工具不同，Ansible的工作流自动化是无代理的，依赖于<a class="ae ko" href="https://en.wikipedia.org/wiki/Secure_Shell" rel="noopener ugc nofollow" target="_blank">安全外壳</a> (SSH)和<a class="ae ko" href="https://docs.microsoft.com/en-us/windows/desktop/winrm/about-windows-remote-management" rel="noopener ugc nofollow" target="_blank"> Windows远程管理</a> (WinRM)。Ansible发布了一份关于<a class="ae ko" href="https://www.ansible.com/hubfs/pdfs/Benefits-of-Agentless-WhitePaper.pdf" rel="noopener ugc nofollow" target="_blank">无代理架构的优势</a>的白皮书。</p><p id="c12f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据<a class="ae ko" href="https://www.g2crowd.com/products/ansible/reviews" rel="noopener ugc nofollow" target="_blank"> G2人群</a>，Ansible在<a class="ae ko" href="https://www.g2crowd.com/categories/configuration-management?segment=all" rel="noopener ugc nofollow" target="_blank">配置管理软件</a>类别中是一个明显的领导者，排在<a class="ae ko" href="https://about.gitlab.com/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>之后。Ansible在该类别中的一些主要竞争对手包括GitLab、AWS Config、Puppet、Chef、Codenvy、HashiCorp Terraform、Octopus Deploy和TeamCity。有几十篇发表的文章，将Ansible比作<a class="ae ko" href="https://puppet.com/" rel="noopener ugc nofollow" target="_blank">木偶</a>、<a class="ae ko" href="https://www.chef.io/chef/" rel="noopener ugc nofollow" target="_blank">厨师</a>、<a class="ae ko" href="https://www.saltstack.com/" rel="noopener ugc nofollow" target="_blank">盐堆</a>，以及最近的<a class="ae ko" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>。</p><h2 id="6a82" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">谷歌计算引擎</h2><p id="8921" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">据谷歌称，谷歌计算引擎(GCE)提供在谷歌数据中心和全球光纤网络上运行的虚拟机。Compute Engine的工具和工作流支持支持从单个实例扩展到负载平衡的全局云计算。</p><p id="f2f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://www.g2crowd.com/categories/infrastructure-as-a-service-iaas" rel="noopener ugc nofollow" target="_blank"> IaaS类别</a>中与GCE相当的产品包括<a class="ae ko" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank">亚马逊弹性计算云</a>(EC2)<a class="ae ko" href="https://azure.microsoft.com/en-us/services/virtual-machines/" rel="noopener ugc nofollow" target="_blank">Azure虚拟机</a>、<a class="ae ko" href="https://www.ibm.com/cloud/virtual-servers" rel="noopener ugc nofollow" target="_blank"> IBM云虚拟服务器</a>和<a class="ae ko" href="https://cloud.oracle.com/en_US/compute" rel="noopener ugc nofollow" target="_blank"> Oracle计算云服务</a>。</p><h2 id="ec6f" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">Apache HTTP服务器</h2><p id="fd9e" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">据<a class="ae ko" href="http://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache </a>介绍，Apache HTTP Server(“httpd”)是一款开源的HTTP服务器，适用于包括Linux和Windows在内的现代操作系统。Apache HTTP Server提供了一个安全、高效、可扩展的服务器，它提供与当前HTTP标准同步的HTTP服务。Apache HTTP服务器于1995年推出，自1996年以来，它一直是互联网上最受欢迎的web服务器。我们将使用Ansible将Apache HTTP Server部署到GCE虚拟机。</p><h1 id="f71b" class="lz lc it bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">示范</h1><p id="32e4" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在本帖中，我们将展示Ansible在GCP上的两个不同的工作流程。首先，我们将使用Ansible将Apache HTTP服务器配置和部署到一个现有的GCE实例。</p><ol class=""><li id="bb5b" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">使用Google Cloud ( <code class="fe mz na nb nc b">gcloud</code> ) CLI工具供应和配置GCE <a class="ae ko" href="https://cloud.google.com/compute/docs/instances/" rel="noopener ugc nofollow" target="_blank"> VM实例</a>、磁盘、防火墙规则和外部IP；</li><li id="8816" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn mv mw mx my bi translated">使用包含<code class="fe mz na nb nc b">httpd</code> <a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" rel="noopener ugc nofollow" target="_blank">可承担角色</a>的<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" rel="noopener ugc nofollow" target="_blank">可承担剧本</a>部署和配置<a class="ae ko" href="https://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache HTTP服务器</a>和相关的包；</li><li id="8e14" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn mv mw mx my bi translated">手动测试GCP资源和Apache HTTP服务器；</li><li id="57ed" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn mv mw mx my bi translated">使用<code class="fe mz na nb nc b">gcloud</code> CLI工具清理GCP资源；</li></ol><p id="6665" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二个工作流中，我们将使用Ansible来供应和配置GCP资源，以及将Apache HTTP服务器部署到新的GCE VM。</p><ol class=""><li id="7896" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">使用包含<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" rel="noopener ugc nofollow" target="_blank">责任角色</a>的<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" rel="noopener ugc nofollow" target="_blank">责任剧本</a>，而不是<code class="fe mz na nb nc b">gcloud</code> CLI工具，供应和配置虚拟机实例、磁盘、VPC全球网络、子网、防火墙规则和外部IP地址；</li><li id="c6eb" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn mv mw mx my bi translated">使用包含<code class="fe mz na nb nc b">httpd</code>和<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" rel="noopener ugc nofollow" target="_blank">角色</a>的<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" rel="noopener ugc nofollow" target="_blank">可行剧本</a>部署和配置<a class="ae ko" href="https://httpd.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache HTTP服务器</a>和相关包；</li><li id="555f" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn mv mw mx my bi translated">使用基于角色的测试任务测试GCP资源和Apache HTTP服务器；</li><li id="6920" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn mv mw mx my bi translated">使用一个包含<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" rel="noopener ugc nofollow" target="_blank">角色</a>的<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" rel="noopener ugc nofollow" target="_blank">角色剧本</a>清理所有GCP资源；</li></ol><h2 id="ed66" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">源代码</h2><p id="2f26" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">这篇文章的源代码可以在<a class="ae ko" href="https://github.com/garystafford/ansible-gcp-demo" rel="noopener ugc nofollow" target="_blank"> ansible-gcp-demo </a> GitHub库的<code class="fe mz na nb nc b">master</code>分支中找到。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="6c65" class="lb lc it nc b gy nm nn l no np">git clone --branch master --single-branch --depth 1 --no-tags \<br/>  <a class="ae ko" href="https://github.com/garystafford/ansible-gcp-demo.git" rel="noopener ugc nofollow" target="_blank">https://github.com/garystafford/ansible-gcp-demo.git</a></span></pre><p id="fff1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该项目具有以下文件结构。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="f989" class="lb lc it nc b gy nm nn l no np">.<br/>├── LICENSE<br/>├── README.md<br/>├── _unused<br/>│   ├── httpd_playbook.yml<br/>├── ansible<br/>│   ├── ansible.cfg<br/>│   ├── group_vars<br/>│   │   └── webservers.yml<br/>│   ├── inventories<br/>│   │   ├── hosts<br/>│   │   └── webservers_gcp.yml<br/>│   ├── playbooks<br/>│   │   ├── 10_webserver_infra.yml<br/>│   │   └── 20_webserver_config.yml<br/>│   ├── roles<br/>│   │   ├── gcpweb<br/>│   │   └── httpd<br/>│   └── site.yml<br/>├── part0_source_creds.sh<br/>├── part1_create_vm.sh<br/>└── part2_clean_up.sh</span></pre><p id="2a48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文中的源代码示例显示为GitHub <a class="ae ko" href="https://help.github.com/articles/about-gists/" rel="noopener ugc nofollow" target="_blank"> Gists </a>，可能无法在所有移动和社交媒体浏览器上正确显示，如LinkedIn。</p><h1 id="dcda" class="lz lc it bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">设置新的GCP项目</h1><p id="d706" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">对于这个演示，我已经创建了一个新的<a class="ae ko" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank"> GCP项目</a>，其中包含一个新的服务帐户和公共SSH密钥。项目的服务帐户将用于<code class="fe mz na nb nc b">gcloud</code> CLI工具，并可用于访问和配置项目内的计算资源。这两个工具都将使用SSH密钥通过SSH进入项目中的GCE VM。首先创建一个新的GCP项目。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/26c28fb80b12574d076f29dd40cbff9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*8nzQunTioQKHxQ_u"/></div></figure><p id="3ed4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在IAM &amp; admin服务帐户选项卡上向项目添加新的服务帐户。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2b1d165bc863508dca5adb391f8c018a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*bpxN7GynPjiDTGRD"/></div></figure><p id="1d3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用“角色”下拉菜单向项目中的“计算管理员”角色授予新服务帐户权限。<a class="ae ko" href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" rel="noopener ugc nofollow" target="_blank">最小特权原则</a> (PoLP)建议我们应该将服务帐户的权限仅限于调配所需计算资源所必需的角色。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6c281884ece5ed2500dfb044b0a6ec51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*N3QDQR75D-9C7VGB"/></div></figure><p id="c8b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在IAM &amp; admin服务帐户选项卡上，为服务帐户创建私钥。这个私有密钥不同于SSH密钥，SSH密钥将添加到项目中。此私钥包含服务帐户的凭据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fcef974163753ea1ab53d4159524fff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*0QeR_yUlOwn0R7b3"/></div></figure><p id="71eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选择JSON密钥类型。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a6e8dbcb8d7efee80c7548f9154d485a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*QchICzrZAxWo4p8D"/></div></figure><p id="fd5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下载私钥JSON文件，并将其放在Ansible可以访问的安全位置。注意不要将该文件签入源代码管理。同样，该文件包含用于以编程方式访问GCP和管理计算资源的服务帐户凭据。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/96ec257f2deb577f69445e3579f80cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*6lVPZPHDav7Zo8UE"/></div></figure><p id="0fa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在应该有一个服务帐户，与新的GCP项目相关联，具有“计算管理”角色的权限，以及一个已经下载并可供Ansible访问的私钥。注意服务帐户的电子邮件地址，在我的例子中是<code class="fe mz na nb nc b">ansible@ansible-gce-demo.iam.gserviceaccount.com</code>；您将需要在稍后的配置中引用它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a4c813be2ab49c075d87bb02aa13cfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*MZ6j2jm8Z1WS51dj"/></div></figure><p id="f803" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，创建一个SSH公共/私有密钥对。SSH密钥将用于以编程方式访问GCE虚拟机。创建一个单独的密钥对允许您将它的使用仅限于新的GCP项目。如果泄露，密钥对很容易在GCP项目和Ansible配置中被删除和替换。在Mac上，您可以使用以下命令创建新的密钥对，并将公钥复制到剪贴板。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="3ea3" class="lb lc it nc b gy nm nn l no np">ssh-keygen -t rsa -b 4096 -C "ansible"<br/>cat ~/.ssh/ansible.pub | pbcopy</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ba3ad19cfbc47dfe2652db2253da8e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*io7HvVRYtnRNL8am"/></div></figure><p id="5c6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在计算引擎元数据SSH Keys选项卡上，将新的公钥剪贴板内容添加到项目中。在此处添加密钥意味着它可由项目中的任何虚拟机使用，除非您在调配新虚拟机并专门为该虚拟机配置密钥时显式阻止此选项。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2e68989c7a53c552374cf2ada733a574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*3o83pENE1Rl4gBhg"/></div></figure><p id="b944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意与密钥相关联的名称<code class="fe mz na nb nc b">ansible</code>，您将需要在稍后的配置中引用它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/879a98560ba74d1b683e8065f55d1c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*O_mRZuzZoUvhh81E"/></div></figure><h1 id="3559" class="lz lc it bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">设置可行</h1><p id="babd" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">虽然这篇文章不是Ansible的入门，但我将介绍一些我为准备这个演示而做的设置步骤。在我的Mac上，我运行的是Python 3.7、pip 18.1和Ansible 2.7.6。安装了Python和pip之后，在Mac或Linux上<a class="ae ko" href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html" rel="noopener ugc nofollow" target="_blank">安装Ansible </a>最简单的方法就是使用pip。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="4597" class="lb lc it nc b gy nm nn l no np">pip install ansible</span></pre><p id="668c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要安装两个额外的包，以便使用<a class="ae ko" href="https://docs.ansible.com/ansible/latest/scenario_guides/guide_gce.html#gce-dynamic-inventory" rel="noopener ugc nofollow" target="_blank"> GCE动态库存</a>收集关于基于GCP的主机的信息，稍后会在帖子中解释。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="9ed1" class="lb lc it nc b gy nm nn l no np">pip install requests google-auth</span></pre><h2 id="3fcb" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">可变配置</h2><p id="3580" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">我为这个项目创建了一个简单的Ansible <code class="fe mz na nb nc b">ansible.cfg</code>文件，位于<code class="fe mz na nb nc b">/ansible/inventories/</code>子目录中。Ansible配置文件包含项目角色和清单的位置，这将在后面解释。该文件还包含两个与我们刚刚创建的SSH密钥对相关联的配置项。如果您的密钥命名不同或位于不同的位置，请更新文件(<a class="ae ko" href="https://gist.github.com/garystafford/98a1f59efa208b324c0848980a81e283" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> gist </em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cf62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ansible在<a class="ae ko" href="https://github.com/ansible/ansible/blob/devel/examples/ansible.cfg" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有一个配置文件参数的完整例子。</p><h2 id="9559" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">可变环境变量</h2><p id="ba26" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为了将我们特定的GCP项目证书与Ansible行动手册和角色分离，<a class="ae ko" href="https://medium.com/@odedia/listen-to-yourself-design-pattern-for-event-driven-microservices-16f97e3ed066?source=userActivityShare-1c57fc47fc23-1527520403" rel="noopener"> Ansible建议</a>将那些必需的模块参数设置为环境变量，而不是将它们包含在行动手册中。此外，我将GCP项目名称设置为一个环境变量，以便将它从剧本中分离出来。要设置这些环境变量，使用<code class="fe mz na nb nc b">source</code>命令(<a class="ae ko" href="https://gist.github.com/garystafford/8ec01497c324aa7871241bb954cff3ca" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> gist </em> </a>)在项目的根目录中找到<code class="fe mz na nb nc b">part0_source_creds.sh</code>脚本。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="a24a" class="lb lc it nc b gy nm nn l no np">source ./part0_source_creds.sh</span></pre><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="a71c" class="lz lc it bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">GCP CLI/Ansible混合工作流</h1><p id="5292" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">企业经常混合使用DevOps工具来调配、配置和部署计算资源。在第一个工作流中，我们将使用Ansible配置一个web服务器，并将其部署到一个现有的GCE VM上，这个VM是用<code class="fe mz na nb nc b">gcloud</code> CLI工具预先创建的。</p><h2 id="e558" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">创建GCP资源</h2><p id="709f" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">首先，使用<code class="fe mz na nb nc b">gcloud</code> CLI工具创建一个GCE VM和相关资源，包括一个外部IP地址和端口80 (HTTP)的防火墙规则。为简单起见，我们将使用现有的GCP <code class="fe mz na nb nc b">default</code> <a class="ae ko" href="https://cloud.google.com/vpc/" rel="noopener ugc nofollow" target="_blank">虚拟私有云</a> (VPC)网络和<code class="fe mz na nb nc b">default</code> us-east1子网。执行项目根目录下的<code class="fe mz na nb nc b">part1_create_vm.sh</code>脚本。网络应该已经在防火墙上打开了端口22 (SSH)。请注意，脚本中的<code class="fe mz na nb nc b">SERVICE_ACCOUNT</code>变量是在IAM &amp; admin服务帐户选项卡上找到的服务帐户电子邮件，如前一节所示(<a class="ae ko" href="https://gist.github.com/garystafford/7bed6bc1a0d41fa31f02553f7faaad35" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a97a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脚本的输出应该如下所示。请注意与虚拟机相关联的外部IP地址，您将需要在稍后的帖子中引用该地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/fdb1323ed8566b1d50e37aa93e7e2204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*--zEaewv4j4akw87"/></div></figure><p id="3e7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe mz na nb nc b">gcloud</code> CLI工具或谷歌云控制台，我们应该能够在GCP上查看我们新提供的资源。首先，我们的新GCE虚拟机，使用计算引擎虚拟机实例详细信息选项卡。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/59ac4e865442d05568d78ffd1e654b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*9dluCMEPJmzO0NQX"/></div></figure><p id="5cd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，检查网络接口详细信息选项卡。在这里，我们可以看到运行虚拟机的网络和子网的详细信息。我们可以看到虚拟机的内部和外部IP地址。我们还看到了防火墙规则，包括我们的新规则，允许TCP在端口80上进入流量。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9ca6a6731d068af3e740fdc85066cae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*-mPFUsc2KCtp8Wmo"/></div></figure><p id="ff82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，检查新的防火墙规则，它将允许TCP流量在端口80上从任何IP地址到达我们位于<code class="fe mz na nb nc b">default</code>网络中的虚拟机。注意另一个预先存在的控制访问<code class="fe mz na nb nc b">default</code>网络的规则。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f2666832984a1a754c279fc34b998800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*tpe2j0zbpwYzgxzb"/></div></figure><p id="4903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终的GCP建筑看起来如下。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c6af1d2b4c9140b28ca409e0464adead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*09OnmkxZFEVR4Cu-"/></div></figure><h2 id="deab" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">GCE动态库存</h2><p id="c744" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Ansible中的两个核心概念是<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html" rel="noopener ugc nofollow" target="_blank">主机和库存</a>。我们需要一份主机清单来运行我们的Ansible行动手册。如果我们有长期存在的主机，通常称为“pet”，它们有长期存在的静态IP地址或DNS条目，那么我们可以手动将主机添加到静态hosts文件中，类似于下面的示例。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="0a7c" class="lb lc it nc b gy nm nn l no np">[webservers]<br/>34.73.171.5<br/>34.73.170.97<br/>34.73.172.153<br/> <br/>[dbservers]<br/>db1.example.com<br/>db2.example.com</span></pre><p id="268e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，考虑到云的短暂性，主机(通常被称为“牛”)、IP地址甚至DNS条目通常都是短暂的，我们将使用动态清单的概念。</p><p id="0cd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你记得我们<code class="fe mz na nb nc b">pip</code>在我们的Ansible设置中安装了两个包<code class="fe mz na nb nc b">requests</code>和<code class="fe mz na nb nc b">google-auth</code>，用于<a class="ae ko" href="https://docs.ansible.com/ansible/latest/scenario_guides/guide_gce.html#gce-dynamic-inventory" rel="noopener ugc nofollow" target="_blank"> GCE动态库存</a>。根据Ansible的说法，与GCE VM主机交互的最佳方式是使用<code class="fe mz na nb nc b">gcp_compute</code>清单插件。该插件允许Ansible动态查询GCE中可以管理的节点。使用<code class="fe mz na nb nc b">gcp_compute</code>清单插件，我们还可以有选择地将找到的主机分类到<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#hosts-and-groups" rel="noopener ugc nofollow" target="_blank">组</a>中。然后，我们将在一组或多组主机上运行包含角色的行动手册。</p><p id="1441" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要演示如何动态查找新的GCE主机，并将其添加到组中，请使用<a class="ae ko" href="https://docs.ansible.com/ansible/latest/cli/ansible-inventory.html" rel="noopener ugc nofollow" target="_blank"> Ansible Inventory </a> CLI执行以下命令。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="d6a6" class="lb lc it nc b gy nm nn l no np">ansible-inventory --graph -i inventories/webservers_gcp.yml</span></pre><p id="518e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令调用<code class="fe mz na nb nc b">webservers_gcp.yml</code>文件，该文件包含将GCE主机与<code class="fe mz na nb nc b">webservers</code>主机组相关联所需的逻辑。Ansible目前关于这个主题的文档非常少。感谢Matthieu Remy的伟大帖子，<a class="ae ko" href="http://matthieure.me/2018/12/31/ansible_inventory_plugin.html" rel="noopener ugc nofollow" target="_blank">如何使用Ansible GCP计算库存插件</a>。在本演示中，我们仅在us-east1-b中寻找名称中包含“web-”的主机。(<a class="ae ko" href="https://gist.github.com/garystafford/1e6f12af18a5cd3180fe9c8da2cd6613" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要诀</em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ff7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。我们应该观察到我们的新虚拟机，正如其外部IP地址所示，被分配给了<code class="fe mz na nb nc b">webservers</code>组的一部分。我们将使用动态清单的功能将播放列表应用到<code class="fe mz na nb nc b">webservers</code>组中的所有主机。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/79342d98642a9e40d925464bf7fe5ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*DvoIyOYVoJjJeIGN"/></div></figure><p id="df64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以通过修改inventory命令来查看有关主机的详细信息。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="210d" class="lb lc it nc b gy nm nn l no np">ansible-inventory --list -i inventories/webservers_gcp.yml --yaml</span></pre><p id="3e8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。这个特殊的例子是在一个早期的主机上运行的，使用了不同的外部IP地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/60ad70d66c556f62c7a28ae60e43defd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*CCSMvyK5l_Rt7NM9"/></div></figure><h2 id="e787" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">Apache HTTP服务器行动手册</h2><p id="bc14" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为了在GCP上第一次体验Ansible，我们将运行一个<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html" rel="noopener ugc nofollow" target="_blank"> Ansible剧本</a>来在新的基于CentOS的虚拟机上安装和配置Apache HTTP服务器。根据Ansible的说法，总部位于YAML的剧本可以声明配置，它们还可以编排任何手动订购流程的步骤，即使不同的步骤必须以特定的顺序在不同的机器之间来回跳动。他们可以同步或异步启动任务。行动手册用于编排任务，而不是使用Ansible的临时任务执行模式。</p><p id="2c7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">剧本在本质上可以是“单一的”，包含所有必需的<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html" rel="noopener ugc nofollow" target="_blank">变量</a>、<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#tasks-list" rel="noopener ugc nofollow" target="_blank">任务</a>和<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html#handlers-running-operations-on-change" rel="noopener ugc nofollow" target="_blank">处理程序</a>，以实现期望的结果。如果我们编写一个剧本来部署和配置我们的Apache HTTP服务器，它可能看起来像下面的<code class="fe mz na nb nc b">httpd_playbook.yml</code>，剧本(<a class="ae ko" href="https://gist.github.com/garystafford/ebccb1250c9e22edfb30157a4180f47e" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c0d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用下面的命令运行这个剧本来部署Apache HTTP服务器，但是我们不会这样做。相反，接下来，我们将运行一个应用<code class="fe mz na nb nc b">httpd</code>角色的剧本。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="3f9d" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  playbooks/<!-- -->httpd_playbook.yml</span></pre><h2 id="253b" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">可变角色</h2><p id="7c8d" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">根据Ansible 的说法，角色是基于已知的文件结构自动加载某些变量_文件、任务和处理程序的方式。按角色对内容进行分组还允许与其他用户轻松共享角色。角色的使用是首选的，因为它提供了一个很好的组织系统。</p><p id="83b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">httpd</code>角色在功能上与第一个工作流中使用的<code class="fe mz na nb nc b">httpd_playbook.yml</code>相同。然而，剧本的主要部分已经被分解成单独的资源文件，正如Ansible所描述的。这个结构是使用Ansible Galaxy CLI创建的。Ansible Galaxy是Ansible分享Ansible内容的官方中心。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="12d4" class="lb lc it nc b gy nm nn l no np">ansible-galaxy init httpd</span></pre><p id="cda5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe mz na nb nc b">ansible-galaxy</code>命令创建了下面的结构。之后，我添加了文件和Jinja2模板。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="f701" class="lb lc it nc b gy nm nn l no np">.<br/>├── README.md<br/>├── defaults<br/>│   └── main.yml<br/>├── files<br/>│   ├── info.php<br/>│   └── server-status.conf<br/>├── handlers<br/>│   └── main.yml<br/>├── meta<br/>│   └── main.yml<br/>├── tasks<br/>│   └── main.yml<br/>├── templates<br/>│   └── index.html.j2<br/>├── tests<br/>│   ├── inventory<br/>│   └── test.yml<br/>└── vars<br/>    └── main.yml</span></pre><p id="1ad4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe mz na nb nc b">httpd</code>角色内:</p><ul class=""><li id="4cf5" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn nu mw mx my bi translated">变量存储在<code class="fe mz na nb nc b">defaults/main.yml</code>文件中；</li><li id="366d" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn nu mw mx my bi translated">任务存储在<code class="fe mz na nb nc b">tasks/main.yml</code>文件中；</li><li id="4e9b" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn nu mw mx my bi translated">句柄存储在<code class="fe mz na nb nc b">handlers/main.yml</code>文件中；</li><li id="e2b5" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn nu mw mx my bi translated">文件存储在<code class="fe mz na nb nc b">files/</code>子目录中；</li><li id="15c3" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn nu mw mx my bi translated">Jinja2模板存储在<code class="fe mz na nb nc b">templates/</code>子目录中；</li><li id="ce60" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn nu mw mx my bi translated">测试存储在<code class="fe mz na nb nc b">tests/</code>子目录中；</li><li id="159b" class="mq mr it js b jt nd jx ne kb nf kf ng kj nh kn nu mw mx my bi translated">其他子目录和文件包含有关角色的元数据；</li></ul><p id="8d48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了应用<code class="fe mz na nb nc b">httpd</code>角色，我们将运行<code class="fe mz na nb nc b">20_webserver_config.yml</code>剧本。将下面这份剧本与之前那份完整的<code class="fe mz na nb nc b">httpd_playbook.yml</code>剧本进行比较。所有的逻辑现在已经被分解到<code class="fe mz na nb nc b">httpd</code>角色的独立支持文件中(<a class="ae ko" href="https://gist.github.com/garystafford/a19d94416c94a0da9be084f9dc5c6187" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ddea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以从使用Ansible的<a class="ae ko" href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html" rel="noopener ugc nofollow" target="_blank">检查模式</a>(“预演”)运行我们的剧本开始。当<code class="fe mz na nb nc b">ansible-playbook</code>与<code class="fe mz na nb nc b">--check</code>一起运行时，Ansible不会对远程系统进行任何实际的更改。根据Ansible 的说法，检查模式只是一种模拟，如果您的步骤使用了依赖于先前命令结果的条件，它可能对您没什么用处。然而，它非常适合一次一个节点的基本配置管理用例。使用检查模式执行以下命令。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="2d20" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  playbooks/20_webserver_config.yml --check</span></pre><p id="5620" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。它表明，如果我们执行实际的命令，我们应该预期会发生七个变化。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/07df789905e1e1eb26b9d9256a1058fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*DxiHvR1jmBcADMfK"/></div></figure><p id="3625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切正常，那么不使用检查模式运行相同的命令。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="895b" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  playbooks/20_webserver_config.yml</span></pre><p id="1bc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。请注意，更改的项目数(七个)与上面使用检查模式的结果相同。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/666b7bcc95b2555d8a590fdfd7eeff89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*3bBxDwrrkDvCdwJW"/></div></figure><p id="db27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们第二次使用Check模式执行命令，我们应该观察到零更改项。这意味着最后一个命令成功应用了所有更改，剧本中没有新的更改。</p><h2 id="2997" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">测试结果</h2><p id="54bb" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">我们可以使用许多方法和工具来测试Apache HTTP服务器和服务器工具的部署。首先，我们可以使用一个专门的<code class="fe mz na nb nc b">ansible</code> CLI命令，通过调用<code class="fe mz na nb nc b">systemctl</code>来确认<code class="fe mz na nb nc b">httpd</code>进程正在VM上运行。<code class="fe mz na nb nc b">systemctl</code>应用程序用于检查和控制运行在基于CentOS的虚拟机上的<code class="fe mz na nb nc b">systemd</code>系统和服务管理器的状态。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="cfed" class="lb lc it nc b gy nm nn l no np">ansible webservers \<br/>  -i inventories/webservers_gcp.yml \<br/>  -a "systemctl status httpd"</span></pre><p id="a278" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。我们看到了Apache HTTP服务器服务的详细信息。我们还看到它根据角色中的任务和处理程序的要求被停止和启动。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/858fe10eff22c3a88263d21c8a3488dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*BC9HDvimlhRwXC6t"/></div></figure><p id="2e7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以检查我们作为剧本的一部分部署的主页和PHP信息文档是否在虚拟机上的正确位置。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="47a9" class="lb lc it nc b gy nm nn l no np">ansible webservers \<br/>  -i inventories/webservers_gcp.yml \<br/>  -a "ls -al /var/www/html"</span></pre><p id="70ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。我们看到我们部署的两个文档位于网站目录的根目录下。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9dbb2a664c307e1280110cf18d932d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*yEP_nK8BZPkRIvGR"/></div></figure><p id="dff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，通过将您的web浏览器指向我们之前创建的外部IP地址，并在端口80 (HTTP)上与虚拟机关联，来查看我们网站的主页。我们应该观察剧本中的变量值，“你好，GCP的Ansible！”，被注入到<a class="ae ko" href="http://jinja.pocoo.org/docs/2.10/" rel="noopener ugc nofollow" target="_blank"> Jinja2 </a>模板文件<code class="fe mz na nb nc b">index.html.j2</code>，页面被正确部署到VM。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/44c309929bf8993171ef72d8bdb74e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*yIq6CxukhHv_mm0b"/></div></figure><p id="2dd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还记得<code class="fe mz na nb nc b">httpd</code>角色，我们的任务是部署服务器状态配置文件。这个配置文件公开了<code class="fe mz na nb nc b">/server-status</code>端点，如下所示。状态页面显示分配给虚拟机的内部和外部IP地址。它还显示了Apache HTTP Server和PHP的当前版本、服务器正常运行时间、流量、负载、CPU使用率、请求数量、正在运行的进程数量等等。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/887f8f5bd7b03b4aa7349e82ad7db130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Ay2HVkS52XNDIIeX"/></div></figure><h2 id="571e" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">使用Apache Bench进行测试</h2><p id="9a12" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated"><a class="ae ko" href="https://httpd.apache.org/docs/2.4/programs/ab.html" rel="noopener ugc nofollow" target="_blank"> Apache Bench </a> ( <code class="fe mz na nb nc b">ab</code>)是Apache HTTP server基准测试工具。我们可以在本地使用Apache Bench，在虚拟机上生成CPU、内存、文件和网络I/O负载。例如，使用下面的命令，我们可以向服务器状态页面生成100K个请求，模拟100个并发用户。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="b6a4" class="lb lc it nc b gy nm nn l no np">ab -kc 100 -n 100000 http://your_vms_external_ip/server-status</span></pre><p id="85f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。观察这个命令成功地在web服务器上产生了大约17.5分钟的持续负载。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d3d97621bd512b46f10c19d78a68c06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*ndy1310bFr5Jc5mA"/></div></figure><p id="a0f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用计算引擎虚拟机实例监控选项卡，我们看到虚拟机上相应的Apache Bench CPU、内存、文件和网络负载，大约从上午10:03开始，在运行剧本安装Apache HTTP Server后不久。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c2cb387c8e12610e11059acafa9c811d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*JP-badPPUeqMlRbT"/></div></figure><h2 id="b1cb" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">破坏GCP资源</h2><p id="843a" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在探索了我们工作流的结果之后，在我们继续下一个工作流之前，拆除现有的GCE资源。要删除资源，执行项目根目录下的<code class="fe mz na nb nc b">part2_clean_up.sh</code>脚本(<a class="ae ko" href="https://gist.github.com/garystafford/23b81d5d9c8c945ea43b04ecaf7eb3e2" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> gist </em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0ed3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脚本的输出应该如下所示。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/39c1b96427842cfec8afbdcf27cf8321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*okBqNCboAJT-q8wI"/></div></figure><h1 id="ac96" class="lz lc it bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">可行工作流</h1><p id="089a" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在第二个工作流中，我们将提供和配置GCP资源，并使用Ansible将Apache HTTP Server部署到新的GCE VM。我们将使用与上一个示例相同的项目、区域和分区。然而，这一次，我们将创建一个新的全球VPC网络，而不是像以前一样使用<code class="fe mz na nb nc b">default</code>网络；创建一个新的子网，而不是像以前一样使用<code class="fe mz na nb nc b">default</code>子网；创建一个新的防火墙，并使用入口规则来打开端口22和80。最后，将创建一个外部IP地址，并将其分配给虚拟机。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b7b54d1cdb1ba9a732093b2d0b600ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*vC_nqY5KF1Jk93Em"/></div></figure><h2 id="29c8" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">提供GCP资源</h2><p id="af75" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">我们将使用Ansible来供应GCP资源，而不是使用<code class="fe mz na nb nc b">gcloud</code> CLI工具。为此，我创建了一个剧本<code class="fe mz na nb nc b">10_webserver_infra.yml</code>，其中有一个角色<code class="fe mz na nb nc b">gcpweb</code>，但是有两组任务，一组创建GCE资源<code class="fe mz na nb nc b">create.yml</code>，另一组删除GCP资源<code class="fe mz na nb nc b">delete.yml</code>。这是一个典型的可行的剧本模式。角色的标准文件目录结构如下所示，类似于<code class="fe mz na nb nc b">httpd</code>角色。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="7bed" class="lb lc it nc b gy nm nn l no np">.<br/>├── README.md<br/>├── defaults<br/>│   └── main.yml<br/>├── files<br/>├── handlers<br/>│   └── main.yml<br/>├── meta<br/>│   └── main.yml<br/>├── tasks<br/>│   ├── create.yml<br/>│   ├── delete.yml<br/>│   └── main.yml<br/>├── templates<br/>├── tests<br/>│   ├── inventory<br/>│   └── test.yml<br/>└── vars<br/>    └── main.yml</span></pre><p id="4aed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了提供GCE资源，我们运行<code class="fe mz na nb nc b">10_webserver_infra.yml</code>行动手册(<a class="ae ko" href="https://gist.github.com/garystafford/c7e7f6635ddcc616884c80fa805c1cae" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="f887" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本行动手册运行<code class="fe mz na nb nc b">gcpweb</code>角色。角色的默认<code class="fe mz na nb nc b">main.yml</code>任务文件导入另外两组任务，一组用于创建，一组用于删除。每组任务都有一个相应的标签与之相关联(<a class="ae ko" href="https://gist.github.com/garystafford/98d146203029d6d6065fae71683362b4" rel="noopener ugc nofollow" target="_blank"><em class="nr"/></a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2c4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过调用剧本并传递“创建”标记，角色将运行并应用相关的创建任务集。标签是Ansible中一个强大的构造。执行下面的命令，传递<code class="fe mz na nb nc b">create</code>标签。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="6232" class="lb lc it nc b gy nm nn l no np">ansible-playbook -t create playbooks/10_webserver_infra.yml</span></pre><p id="a5c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本行动手册中，前面使用的检查模式在这里会失败。如果您还记得的话，这个特性并不是为那些步骤使用依赖于先前命令结果的条件的行动手册而设计的，例如本行动手册。</p><p id="537d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">create.yml</code>文件包含六个任务，它们利用了Ansible <a class="ae ko" href="https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google" rel="noopener ugc nofollow" target="_blank"> GCP模块</a>。这些任务创建全球VPC网络、美国东部地区的子网、防火墙和规则、外部IP地址、磁盘和虚拟机实例(<a class="ae ko" href="https://gist.github.com/garystafford/53036067e92eba52273d8f004350dfca" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e947" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对剧本执行过程中实际发生的事情感兴趣，可以在上面的命令中添加详细选项(<code class="fe mz na nb nc b">-v</code>或<code class="fe mz na nb nc b">-vv</code>)。这对学习Ansible很有帮助。</p><p id="6e3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。请注意应用于localhost的更改。由于在提供资源之前，GCP上不存在GCE VM主机，因此我们引用localhost。整个过程不到两分钟就创建了一个全球VPC网络、子网、防火墙规则、虚拟机、连接的磁盘，并分配了一个公共IP地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a814854ca5980fa1cad963da706232af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*1cjRjIfRwvb8F83Q"/></div></figure><p id="51a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，所有GCP资源都已调配和配置完毕。下面，我们看到Ansible创建的新GCE VM。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/25d345b0348786a5d5fc5ce71a79c8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*_pFB7tpOH1vBaOPU"/></div></figure><p id="4e44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到了新GCE虚拟机的网络接口详细信息控制台页面，显示了有关虚拟机、NIC、内部和外部IP地址、网络、子网和入口防火墙规则的详细信息。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c3633857bf800366c7c1a7138bc6a6bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*igGd68M-c6xCv-NZ"/></div></figure><p id="095b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们看到了VPC的详细信息，显示了每个自动创建的区域子网，以及我们在us-east1区域的新“ansible-subnet”，跨越了172.16.0.0/28 <a class="ae ko" href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" rel="noopener ugc nofollow" target="_blank"> CIDR </a>(无类域间路由)块中的14个IP地址。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a55638f8ad30975ba18c794ca6cb530c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*6LR1uRbKr2T8axAM"/></div></figure><p id="71d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了部署和配置Apache HTTP Server，以与我们在第一个工作流中完全相同的方式运行<code class="fe mz na nb nc b">httpd</code>角色。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="60d1" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  playbooks/20_webserver_config.yml</span></pre><h2 id="223f" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">基于角色的测试</h2><p id="7a28" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在第一个工作流中，我们使用一些特别的命令并通过在浏览器中查看网页来手动测试我们的结果。这些测试方法不适合DevOps自动化。更有效的策略是编写测试，这是角色的一部分，并且可能在每次应用角色时运行，作为CI/CD管道的一部分。这个项目中的每个角色都包含一些简单的测试来确认角色中任务的成功。首先，用下面的命令运行<code class="fe mz na nb nc b">gcpweb</code>角色的测试。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="dae3" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  roles/gcpweb/tests/test.yml</span></pre><p id="bfc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">行动手册收集了主机组中GCE主机的信息，并针对这些主机运行了总共五个测试任务。这些任务使用收集的事实(<a class="ae ko" href="https://gist.github.com/garystafford/75d79de362f523016885e6a10b7f9c06" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)来确认主机的时区、vCPU计数、操作系统类型、操作系统主要版本和主机名。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。观察到所有五个任务都成功运行。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/2bc723223ea2e009870ed5c743d9627f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*QYOllrmpcf-u8SUt"/></div></figure><p id="858f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，运行<code class="fe mz na nb nc b">httpd</code>角色的测试。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="91ad" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  roles/httpd/tests/test.yml</span></pre><p id="4af8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，该命令的输出应该类似于以下内容。剧本这次运行四个测试任务。这些任务确认两个文件都存在，主页可访问，并且服务器状态页面显示正确。下面，我们四个都跑成功了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/98f2da06c16085f62388815247da7eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*aEiuCU38q7xrbY8r"/></div></figure><h2 id="5f0e" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">改变剧本</h2><p id="602d" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为了观察如果我们对剧本进行更改会发生什么，让我们在<code class="fe mz na nb nc b">httpd</code>角色的<code class="fe mz na nb nc b">/roles/httpd/defaults/main.yml</code>文件中更改<code class="fe mz na nb nc b">greeting</code>变量值。回想一下，原来的主页是这样的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b6a98c07eea446b336bde2968c0483df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*-4M_bv1nTpWbKIh-"/></div></figure><p id="85a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用相同的命令，更改<code class="fe mz na nb nc b">greeting</code>变量值并重新运行剧本。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="2992" class="lb lc it nc b gy nm nn l no np">ansible-playbook \<br/>  -i inventories/webservers_gcp.yml \<br/>  playbooks/20_webserver_config.yml</span></pre><p id="bba8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。正如所料，我们应该观察到只有一个任务，即部署主页，发生了变化。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c92f637891151d99b181fa1e16b9cbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*kvC5-DNdZ3C7blAl"/></div></figure><p id="16e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次查看主页，或者通过修改相关的测试任务，我们应该观察到新的值被注入到Jinja2模板文件中，<code class="fe mz na nb nc b">index.html.j2</code>，并且新的页面被正确部署。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f841a9323342e6ab7d4236c7b5d1cd29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Z14-45jR7TuNpU5C"/></div></figure><h2 id="c660" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">用Ansible摧毁GCP资源</h2><p id="757f" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">完成后，您可以通过调用<code class="fe mz na nb nc b">10_webserver_infra.yml</code>剧本并传递<code class="fe mz na nb nc b">delete</code>标签来销毁所有GCP资源，角色将运行并应用相关的删除任务集。</p><pre class="kq kr ks kt gt ni nc nj nk aw nl bi"><span id="6b4c" class="lb lc it nc b gy nm nn l no np">ansible-playbook -t delete playbooks/10_webserver_infra.yml</span></pre><p id="22d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Ansible，我们通过将<code class="fe mz na nb nc b">state</code>从<code class="fe mz na nb nc b">present</code>更改为<code class="fe mz na nb nc b">absent</code>来删除GCP资源。行动手册将以特定的顺序删除资源，以避免依赖性冲突，例如尝试在虚拟机之前删除网络。请注意，我们不必显式删除磁盘，因为，如果您还记得，我们用<code class="fe mz na nb nc b">disks.auto_delete=true</code>选项(<a class="ae ko" href="https://gist.github.com/garystafford/bb000453def0b4b80d72394516e650d4" rel="noopener ugc nofollow" target="_blank"> <em class="nr">要点</em> </a>)调配了VM实例。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="169a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该命令的输出应该如下所示。我们看到虚拟机实例、连接的磁盘、防火墙、规则、外部IP地址、子网，最后是网络，它们都被删除了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/373c73632aa9bf89daeb794fef3a9bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*Nd6art9O43N9ngxM"/></div></figure><h1 id="3cf2" class="lz lc it bd ld ma mb mc lg md me mf lj mg mh mi lm mj mk ml lp mm mn mo ls mp bi translated">结论</h1><p id="7100" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在这篇文章中，我们看到了在Google云平台上使用Ansible是多么容易。使用Ansible的300+ <a class="ae ko" href="https://www.ansible.com/integrations/cloud" rel="noopener ugc nofollow" target="_blank">云模块</a>，供应、配置、部署和测试广泛的GCP、Azure和AWS资源是容易的、可重复的和完全自动化的。</p><p id="241f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文表达的所有观点都是我个人的，不一定代表我现在或过去的雇主或他们的客户的观点。</p><p id="48e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nr">原载于2019年1月30日</em><a class="ae ko" href="https://wp.me/p1RD28-6bj" rel="noopener ugc nofollow" target="_blank"><em class="nr">【programmaticponderings.com</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>