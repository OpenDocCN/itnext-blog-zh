<html>
<head>
<title>Event Driven Microservices: Achieving evolutionary development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动的微服务:实现进化发展</h1>
<blockquote>原文：<a href="https://itnext.io/event-driven-microservices-achieving-evolutionary-development-278c18caf6a3?source=collection_archive---------4-----------------------#2021-08-03">https://itnext.io/event-driven-microservices-achieving-evolutionary-development-278c18caf6a3?source=collection_archive---------4-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/941d57d7e1b4248939edd5e68cceebc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ne3DHCWLQjboU1YJqxjbyQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">雨果·赫塞尔拍摄的图片</figcaption></figure><h1 id="3c95" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">应用增长的解决方案</h1><p id="472b" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">所有的软件都是从一个单一的想法开始的，并且在这个想法的基础上，软件需要扩展。这篇文章将描述如何使用事件驱动的微服务来最好地发展您的应用，并解释每个决策的优势。</p><h1 id="7bb1" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">硬件扩展</h1><p id="83a3" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">随着应用程序中软件的增长，它最终会达到服务器所能提供的极限。需要决定硬件如何随应用程序扩展。有两种解决方案:</p><ul class=""><li id="3f44" class="lv lw iq kz b la lx le ly li lz lm ma lq mb lu mc md me mf bi translated">垂直扩展—一台更大、功能更强的服务器。</li><li id="548d" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">水平扩展—多个较小的服务器，应用程序分布在这些服务器上。</li></ul><h2 id="0d44" class="ml ka iq bd kb mm mn dn kf mo mp dp kj li mq mr kn lm ms mt kr lq mu mv kv mw bi translated">水平缩放的优势</h2><ul class=""><li id="88b0" class="lv lw iq kz b la lb le lf li mx lm my lq mz lu mc md me mf bi translated">成本更低—许多小型服务器比1台大型服务器更便宜。</li><li id="3eca" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">可靠性—其他地方的峰值不会影响本地服务器。</li><li id="3316" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">无限扩展—垂直扩展的上限是您能找到的最大服务器，水平扩展的上限是您能添加越来越多的服务器。</li></ul><p id="1331" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">水平缩放通常是首选方法。</p><h1 id="fee6" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">如何拆分应用程序</h1><p id="812d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">决定使用多台服务器后，您需要考虑将应用程序分散到这些服务器上。那么我们该怎么做呢？</p><h2 id="1a98" class="ml ka iq bd kb mm mn dn kf mo mp dp kj li mq mr kn lm ms mt kr lq mu mv kv mw bi translated">选项1:微型服务，也称为模块化整体:</h2><p id="6758" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这被定义为一套<strong class="kz ir">依赖的模块化服务</strong>，意味着这些服务相互依赖。如果一个服务有问题，那么整个系统都有问题。</p><p id="67a0" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">该选项具有整个企业的范围，使得难以扩展软件，更新影响系统的多个部分，并且使得开发者难以理解和测试。该选项通常使用同步通信，这意味着一个函数在执行前必须等待第一个函数完成。然而，该选项也更容易运行，并且具有较低的复杂性。这是一个分布式架构。</p><h2 id="ac92" class="ml ka iq bd kb mm mn dn kf mo mp dp kj li mq mr kn lm ms mt kr lq mu mv kv mw bi translated"><strong class="ak">选项2:微服务:</strong></h2><p id="1c75" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><a class="ae jy" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank"> Martin Fowler </a>将微服务定义为<strong class="kz ir">“可独立部署的服务套件”</strong>。这意味着它还可以独立扩展，节省资金和资源，将故障隔离限制在一项服务中，并且不受技术限制，可以防止供应商锁定。</p><p id="6368" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">该选项具有单个业务域的范围，提供松散耦合，并且每个服务都有一个固定的模块边界。由于这些界限，每个服务由一个特定的团队拥有和管理变得非常容易。该选项通常使用异步通信，这意味着功能可以同时执行。该选项采用了一种渐进的设计，使得添加更多服务变得容易，并允许更大的灵活性。这是一个集成架构。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nd"><img src="../Images/7070120dad527081b2aa5b0fdfb5fbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbxjPGKwEGaY4J_oVpz8fw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片由Gartner提供</figcaption></figure><h1 id="a4fa" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">微服务应该有多大？</h1><p id="809e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在决定微服务后，我们需要考虑规模，微服务的规模应该根据认知负载来考虑。</p><blockquote class="nm nn no"><p id="9fae" class="kx ky np kz b la lx lc ld le ly lg lh nq na lk ll nr nb lo lp ns nc ls lt lu ij bi translated">“认知负荷:用于工作记忆的脑力劳动总量”。约翰·斯威勒</p></blockquote><p id="5de0" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated"><a class="ae jy" href="https://twitter.com/tastapod" rel="noopener ugc nofollow" target="_blank"> Daniel Terhorst-North </a>说微服务应该是“适合你头脑的软件”的大小，根据<a class="ae jy" href="https://teamtopologies.com/" rel="noopener ugc nofollow" target="_blank">团队拓扑</a>的教导，你应该“将软件服务的大小限制在团队可以处理的认知负荷之内”。这意味着更少的错误、所有权和更易理解的代码。</p><h1 id="2e79" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">分什么</h1><p id="d202" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们需要找到产品的接缝。从商业角度来看，它们自然属于哪一类？使用领域驱动设计——软件代码的结构和语言应该与业务领域相匹配的概念。</p><p id="50c2" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">需要有一个团队优先的软件边界方法，其中服务必须由一个团队拥有，考虑到康威定律:</p><blockquote class="nm nn no"><p id="4b88" class="kx ky np kz b la lx lc ld le ly lg lh nq na lk ll nr nb lo lp ns nc ls lt lu ij bi translated">“组织被迫生产应用程序设计，这是他们的通信结构的副本”——康威定律</p></blockquote><p id="032a" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">相反，使用“逆康威定律”——进化你的团队和组织结构，以促进你想要的架构。理想情况下，您的技术架构将显示出与您的业务架构的同构。</p><h1 id="969d" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">如何集成服务</h1><p id="33b0" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">既然我们已经将应用程序拆分为服务，那么我们需要将这些服务集成在一起，以便它们能够通信。有4种集成服务的常见方法。</p><ul class=""><li id="90a4" class="lv lw iq kz b la lx le ly li lz lm ma lq mb lu mc md me mf bi translated">文件传输—将数据写入文件，然后将其发送给另一个服务进行读取。</li><li id="87ec" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">共享数据库—所有服务存储和访问数据的一个数据库。</li><li id="e966" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">远程过程调用(RMI) /远程过程调用(RPC)——向另一个服务上的函数发送数据并接收输出。</li><li id="694d" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">消息传递——将数据发送到消息总线，然后消息总线负责将数据异步转发到其他服务。</li></ul><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4a5cf7539300fceef7bbee5ea804bc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*H_0TpDn0loh-rW9Yodbuwg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片由enterpriseintegrationpatterns.com拍摄</figcaption></figure><h2 id="7e0f" class="ml ka iq bd kb mm mn dn kf mo mp dp kj li mq mr kn lm ms mt kr lq mu mv kv mw bi translated">使用消息传递的优势</h2><ul class=""><li id="1b68" class="lv lw iq kz b la lb le lf li mx lm my lq mz lu mc md me mf bi translated">异步可靠交付——我们可以信任消息总线发出消息，并同时将它们发送给不同的服务。</li><li id="ebda" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">发送并忽略——源服务只负责将消息发送到消息总线，然后就可以忽略它了。</li><li id="40bc" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">通用连接性——消息总线具有与许多不同服务的内置连接性，应该易于集成。</li><li id="ab7b" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">无过载—接收方控制其消耗请求的速率，因此服务不会过载。</li><li id="5181" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">断开连接的操作——不依赖任何其他东西，客户端仍然可以访问消息总线。</li><li id="75ce" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">支持使用事件源—对应用程序状态的所有更改都存储为一系列事件。</li></ul><h1 id="9da9" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">整合问题</h1><p id="7d24" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">集成服务有3个主要问题:</p><ol class=""><li id="f056" class="lv lw iq kz b la lx le ly li lz lm ma lq mb lu nu md me mf bi translated">网络不可靠且速度慢。</li><li id="a4ae" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu nu md me mf bi translated">任何两个应用程序都是不同的。</li><li id="7163" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu nu md me mf bi translated">变化是不可避免的——应用程序确实会随着时间而变化。</li></ol><h2 id="4df8" class="ml ka iq bd kb mm mn dn kf mo mp dp kj li mq mr kn lm ms mt kr lq mu mv kv mw bi translated"><strong class="ak">我们选择消息传递是因为:</strong></h2><p id="baad" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">它比文件传输更直接，比共享数据库封装得更好，比远程过程调用更可靠。</p><h1 id="a29a" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是事件驱动架构？</h1><p id="1740" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">AWS将事件驱动架构定义为“使用事件在解耦的服务之间触发和通信”。我们通过微服务创建一个事件，将其发送到我们的消息总线，然后将其发送到其他解耦的微服务，触发一些操作来实现这一点。</p><p id="2d97" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">事件驱动架构和其他架构的明显区别在于事件是可观察的，而不是可控制的。这使我们能够拥有清晰的边界，并且可以在不知道其他服务的情况下同时执行多个功能。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/303c9e38ec8bad599d9445e87c45b0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*NpNcnsbcjaLxRn9HB6qVgw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片由AWS提供——詹姆斯·贝斯维克</figcaption></figure><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/81de56910f7e864e48b7dd50e5ba745a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*bKUngP4Kq-C_cIsp70uFSg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">图片由AWS提供——詹姆斯·贝斯维克</figcaption></figure><h2 id="adf6" class="ml ka iq bd kb mm mn dn kf mo mp dp kj li mq mr kn lm ms mt kr lq mu mv kv mw bi translated">事件驱动架构有4个组件:</h2><ul class=""><li id="54a0" class="lv lw iq kz b la lb le lf li mx lm my lq mz lu mc md me mf bi translated">事件制作者</li><li id="6cfe" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">事件总线</li><li id="359f" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">事件路由器</li><li id="579f" class="lv lw iq kz b la mg le mh li mi lm mj lq mk lu mc md me mf bi translated">事件消费者</li></ul><p id="5a52" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">事件生成器创建发送到事件总线的事件。然后，事件路由器将事件定向到适当的事件消费者。</p><p id="226c" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">在AWS中，您可以通过使用Amazons EventBridge服务来重新创建它。事件生产者被称为事件源，事件消费者被称为目标，事件路由器被称为规则，您配置一个规则来触发来自事件源的事件模式，然后路由到目标。</p><h1 id="709e" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">进化发展</h1><blockquote class="nx"><p id="60ad" class="ny nz iq bd oa ob oc od oe of og lu dk translated">最终，我们今天写的是明天的遗留代码，所以让它进化吧！</p></blockquote><p id="9f7c" class="pw-post-body-paragraph kx ky iq kz b la oh lc ld le oi lg lh li oj lk ll lm ok lo lp lq ol ls lt lu ij bi translated">上面的步骤已经为我们实现进化开发做好了准备，通过利用<strong class="kz ir">扼杀者模式</strong>，使用事件路由器向新服务和旧服务发送数据，我们可以在不威胁遗产的情况下进化我们的软件。</p><blockquote class="nm nn no"><p id="638f" class="kx ky np kz b la lx lc ld le ly lg lh nq na lk ll nr nb lo lp ns nc ls lt lu ij bi translated"><strong class="kz ir">扼杀者模式</strong>是一种渐进地迁移遗留系统的方法，通过分阶段地用新的应用程序和服务替换现有的功能</p></blockquote><p id="c845" class="pw-post-body-paragraph kx ky iq kz b la lx lc ld le ly lg lh li na lk ll lm nb lo lp lq nc ls lt lu ij bi translated">我曾与许多在高压下设计和建造的系统一起工作过，尽管它们符合所有的验收标准，但很少有人考虑接下来会发生什么。人们更容易接受这样的想法，即项目完成了，需求列表结束了，就好像业务处于需要恢复正常的不稳定状态。为了开发成功的软件，我们需要更加适应变化的标准状态，始终关注不断变化的环境带来的好处。通过这种方式，可以用更少的努力从技术中获得更多的价值，这就是为什么你需要一个进化的架构。它使您能够快速、独立地构建想法，而不会威胁到遗产，因此您可以在客户面前获得最佳想法，并更快地开始实现收益。</p></div></div>    
</body>
</html>