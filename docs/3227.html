<html>
<head>
<title>4 golang code snippets that will deceive C# developers!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个会欺骗C#开发者的golang代码片段！</h1>
<blockquote>原文：<a href="https://itnext.io/4-golang-code-snippets-that-will-deceive-c-developers-6f50a31f0548?source=collection_archive---------0-----------------------#2019-10-30">https://itnext.io/4-golang-code-snippets-that-will-deceive-c-developers-6f50a31f0548?source=collection_archive---------0-----------------------#2019-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/87b3599052352b28210a303724535c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwwWvc-9rT0OAFbcULwSIA.png"/></div></div></figure><div class=""/><div class=""><h2 id="9baf" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">学习新的编程语言就像学习一门新的口语。当事情听起来相同，意思相同时，它们之间的相似性就变得非常方便。但是，如果情况不是这样，这一切就会土崩瓦解。</h2></div><p id="5e94" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在口语中，这被称为<em class="lm">假同源词，</em>看起来或听起来一样，但意思完全不同的词。比如英语中的动词<em class="lm">到</em> <strong class="ks jc"> <em class="lm">假装</em> </strong>和葡萄牙语中的<strong class="ks jc"> <em class="lm">假装</em> </strong> <em class="lm">呃</em>。他们看起来很相似，但后者在英语中翻译成<em class="lm">意为</em>。当你真的认为你在说你打算做某事，而你实际上说的是你在假装时，这会导致各种尴尬的局面。去过那里，做过那个！:)</p><p id="3784" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">编程语言也有同样的问题。例如，C#和golang有许多相似之处，这使得c#开发人员学习golang并不困难。然而，当用C#思维思考时，有一些细微之处会导致意想不到的行为。</p><p id="d314" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是4个可能会欺骗经验丰富的c#开发人员的差异:</p><h1 id="fa06" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">1.带有可重复使用外壳的开关</h1><p id="a2d9" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">在golang中，<code class="fe mk ml mm mn b">switch</code>语句不需要在每个<code class="fe mk ml mm mn b">case</code>后加上<code class="fe mk ml mm mn b">break</code>或<code class="fe mk ml mm mn b">return</code>。像在C#中一样，按顺序处理几个案例将导致只处理最后一个案例:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="eb17" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了在C#中获得与您期望的相同的结果，每个<code class="fe mk ml mm mn b">case</code>处理的不同选项需要用逗号分隔:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d802" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这看起来真的很棒！</p><h1 id="9324" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">2.int！= int32</h1><p id="babe" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">在C#中<code class="fe mk ml mm mn b">int</code>是<code class="fe mk ml mm mn b">System.Int32</code>的别名。这些术语经常被互换使用。在Golang中，它们是完全不同的类型，这意味着下面的代码无法编译:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d224" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在Golang中，<code class="fe mk ml mm mn b">int</code>类型<em class="lm">可能</em>会根据其运行的CPU而变化:</p><blockquote class="mu mv mw"><p id="29b3" class="kq kr lm ks b kt ku kc kv kw kx kf ky mx la lb lc my le lf lg mz li lj lk ll ij bi translated">在32位系统上，<code class="fe mk ml mm mn b">int</code>、<code class="fe mk ml mm mn b">uint</code>和<code class="fe mk ml mm mn b">uintptr</code>类型通常是32位宽，在64位系统上是64位宽。当你需要一个整数值时，你应该使用<code class="fe mk ml mm mn b">int</code>,除非你有特殊的理由使用一个有大小的或者无符号的整数类型。</p></blockquote><h1 id="1e92" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">3.ifs可以重新定义变量的含义</h1><p id="8aa6" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">在if语句中使用操作符<code class="fe mk ml mm mn b">:=</code>将创建新的临时变量，忽略相同上下文中可能存在的同名变量。在下面的例子中，<code class="fe mk ml mm mn b">exists</code>不会是第三个<code class="fe mk ml mm mn b">if</code>语句中的<code class="fe mk ml mm mn b">true</code>。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9097" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了避免这种情况，应该使用操作符<code class="fe mk ml mm mn b">=</code>，这意味着<code class="fe mk ml mm mn b">exists</code>和<code class="fe mk ml mm mn b">err</code>都需要提前声明。相反，您可以通过将整个<code class="fe mk ml mm mn b">fileExists</code>调用放在<code class="fe mk ml mm mn b">if</code>语句之前来保留<code class="fe mk ml mm mn b">:=</code>操作符:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2900" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">官方文档清楚地表明这是预期的行为:</p><blockquote class="mu mv mw"><p id="9f05" class="kq kr lm ks b kt ku kc kv kw kx kf ky mx la lb lc my le lf lg mz li lj lk ll ij bi translated">与常规变量声明不同，短变量声明可以<em class="jb">重新声明</em>变量，前提是它们最初是在同一个块中声明的…</p><p id="e8d3" class="kq kr lm ks b kt ku kc kv kw kx kf ky mx la lb lc my le lf lg mz li lj lk ll ij bi translated">在某些上下文中，如用于<a class="ae na" href="https://golang.org/ref/spec#If_statements" rel="noopener ugc nofollow" target="_blank"> "if" </a>、<a class="ae na" href="https://golang.org/ref/spec#For_statements" rel="noopener ugc nofollow" target="_blank"> "for" </a>或<a class="ae na" href="https://golang.org/ref/spec#Switch_statements" rel="noopener ugc nofollow" target="_blank"> "switch" </a>语句的初始值设定项，它们可用于声明局部临时变量。</p></blockquote><p id="482d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">还要注意，正如上面的引用所阐明的那样，这并不特定于if语句。</p><h1 id="f564" class="ln lo jb bd lp lq lr ls lt lu lv lw lx kh ly ki lz kk ma kl mb kn mc ko md me bi translated">4.不完全是C#枚举</h1><p id="0079" class="pw-post-body-paragraph kq kr jb ks b kt mf kc kv kw mg kf ky kz mh lb lc ld mi lf lg lh mj lj lk ll ij bi translated">这是最不相似的片段。但是在Golang中，类似enum的东西的实现将基于一个新的<code class="fe mk ml mm mn b">type</code>和新创建的<code class="fe mk ml mm mn b">type</code>的几个常量。然而，当用C#思维思考时，编译器不会像您所期望的那样强制这样做:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c09c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的<code class="fe mk ml mm mn b">type</code>语句根据表示的<em class="lm">定义了Weekday，同时将其关联到一个实际类型，在本例中是<code class="fe mk ml mm mn b">string</code>。在一个没有枚举的世界里，阅读那些特定的字符串<em class="lm">表示</em>工作日确实会更清楚。然而，编译器不会强制要求<code class="fe mk ml mm mn b">print</code>只接收<code class="fe mk ml mm mn b">Weekday</code>对象，而是关注底层类型。</em></p><p id="bfa5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">来自社区的请求(<a class="ae na" href="https://github.com/golang/go/issues/19412" rel="noopener ugc nofollow" target="_blank">添加sum类型</a>，<a class="ae na" href="https://github.com/golang/go/issues/19814" rel="noopener ugc nofollow" target="_blank">添加类型化的enum支持</a>)将enum特性引入golang，但这些讨论仍在进行中。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="b30f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一般来说，有相当多的东西可以用两种语言以相同的方式编码。但是对于任何一个从Go开始的人来说，底线是不要假设一个有效的c#语法在golang中会有相同的行为。</p><p id="6928" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从基础做起，从头开始培养你的技能，你一定会一路走好。:)</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8483ccbd137aebc80186584a561dc874.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/0*EL7XpxsKl2q01CAu.gif"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">图片来源:<a class="ae na" href="https://github.com/egonelbre/gophers" rel="noopener ugc nofollow" target="_blank">雷内·弗伦奇</a></figcaption></figure></div></div>    
</body>
</html>