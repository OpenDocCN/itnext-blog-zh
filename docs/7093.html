<html>
<head>
<title>Flutter: BLOCs at Scale | 1— The State Machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter: BLOCs at Scale | 1—状态机</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9?source=collection_archive---------0-----------------------#2022-06-10">https://itnext.io/flutter-blocs-at-scale-1-the-state-machine-fce5f086d7b9?source=collection_archive---------0-----------------------#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/054d8dd373af4dfe1b3da98bb15f9ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aytkguzncNYPN5B3AQPs-Q.png"/></div></div></figure><h2 id="cf27" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">介绍</h2><p id="31c3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">欢迎来到<strong class="kw ir">集团</strong>系列<strong class="kw ir">第一部分</strong>。</p><blockquote class="lp"><p id="d758" class="lq lr iq bd ls lt lu lv lw lx ly lo dk translated">如果你准备用新的概念提升你的BLOCs，这将使你的代码更健壮，更结构化，更不容易出错——你在正确的地方！</p></blockquote><p id="b5c8" class="pw-post-body-paragraph ku kv iq kw b kx lz kz la lb ma ld le kh mb lg lh kl mc lj lk kp md lm ln lo ij bi translated">由于良好的基础总是至关重要的，我们将从谈论可扩展的BLOC <strong class="kw ir">设计</strong> <strong class="kw ir">原则</strong>开始。这些原则中的一些开始是作为实验，后来帮助设计简单、精简和可读的模块。</p><p id="5d36" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">这个系列使用的是下面的<a class="ae mj" href="https://pub.dev/packages/bloc" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir"> <em class="mk"> BLOC包</em></strong><em class="mk">(pub . dev)</em></a>。</p><p id="840c" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">让我们开始吧！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="c98b" class="ms jz iq bd ka mt mu mv kd mw mx my kg mz na nb kk nc nd ne ko nf ng nh ks ni bi translated">1.<strong class="ak">开始把你的BLOCs当成有限状态机</strong></h1><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/01380e395172a10a2a62b32bde170cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDjlN6ajwEM58rZBKTkdbQ.png"/></div></div></figure><p id="e17d" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">关于如何设计<strong class="kw ir">区块以适应</strong>的一个改变游戏规则的方法是<em class="mk"> (re) </em>引入<strong class="kw ir">有限状态机(FSM) </strong>。</p><p id="539b" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">如果你已经熟悉了BLOC，你可能会说:但是BLOC基本上是状态机？你说得对——但是要利用<strong class="kw ir"> FSM </strong>的力量，你需要<strong class="kw ir">把它们设计好</strong>！</p><p id="c1ff" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">如果你在设计阶段没有意识到这一点，你将会错过很多东西。我们来探索一下。</p><h2 id="5614" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">状态机简介</h2><ul class=""><li id="6b10" class="no np iq kw b kx ky lb lc kh nq kl nr kp ns lo nt nu nv nw bi translated">固定的状态集。机器一次只能处于一种状态</li><li id="746d" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">每台机器都有一个初始状态</li><li id="ba57" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">每个状态都有一组转换</li><li id="dc1b" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">转换是指从输入状态到输出状态</li></ul><p id="d843" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">一个简单的例子是具有<strong class="kw ir"> 2个状态</strong> <strong class="kw ir"> <em class="mk">(关/开)</em> </strong>和<strong class="kw ir">一个转换<em class="mk">(按压)</em> </strong>的灯开关。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/843ce90fa283bc9d73f574ffb05c8584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oYnrxHx7eEDOKpH3_tuHw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">简单状态机的示例状态图。</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/5128c2910061fe8ecb66fef36201c3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tPRwLxFstnfoMOYgjjaFA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">LightSwitch状态机示例的基本实现。</figcaption></figure><blockquote class="oi oj ok"><p id="5947" class="ku kv mk kw b kx me kz la lb mf ld le ol mg lg lh om mh lj lk on mi lm ln lo ij bi translated"><strong class="kw ir"><em class="iq">*提示1:使用状态图表</em> </strong></p></blockquote><p id="e458" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">挑战:</strong></p><ul class=""><li id="e66c" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated">过了一段时间，当你回到一个集团时，你会挠头<strong class="kw ir">试图弄清楚它是如何工作的</strong>和<strong class="kw ir">所有的部分是如何组合在一起的</strong>？</li><li id="2ed3" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">每次有新的开发人员加入你的团队时，你必须解释特定的团队是如何工作的吗<strong class="kw ir">？</strong></li></ul><p id="efba" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">解决方案:<br/> </strong>理想情况下，你应该<strong class="kw ir">设计</strong>和<strong class="kw ir">绘制状态图</strong>，甚至在开始你的第一行与BLOC相关的代码之前。<br/>不喜欢视觉设计工具？使用像<a class="ae mj" href="https://github.com/sverweij/state-machine-cat" rel="noopener ugc nofollow" target="_blank"> <strong class="kw ir">状态机猫</strong> </a>这样的基于代码的工具来创建它们。<br/>确保<strong class="kw ir">将它们检查到源代码控制</strong>和<strong class="kw ir">中，使它们与修改后的块</strong>保持同步。</p><p id="710a" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">结果:<br/> </strong>在我们的团队将这种简单的方法付诸实践后，由于一种<strong class="kw ir">更周到的设计方法</strong>而不是边走边编码和设计，模块的质量和可维护性得到了极大的提高。关于某个集团如何运作的会议几乎再也没有出现过，因为每个人都可以随时查看状态图。作为开发人员，我们永远不应该低估文档的力量——尤其是对于应用程序中最关键的部分！</p><blockquote class="lp"><p id="21b6" class="lq lr iq bd ls lt lu lv lw lx ly lo dk translated">从长远来看，拥有BLOCs的可视化蓝图可以加快团队的速度，减少新开发人员的入职时间。</p></blockquote></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="2902" class="ms jz iq bd ka mt mu mv kd mw mx my kg mz na nb kk nc nd ne ko nf ng nh ks ni bi translated">2.设计清晰的状态</h1><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/2970524966810a6d9ddcbf5bf5e358bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bHB91IvTxQNCFVWMCqyuaw.png"/></div></div></figure><p id="89cc" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">应该以最好地支持<strong class="kw ir">状态消费者</strong>的需求<em class="mk">(例如UI) </em>的方式来定义块的状态。他们应该能够轻松地利用像条件渲染这样的概念，了解潜在的错误和加载状态，并显示它们。</p><p id="7b98" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">挑战:</strong></p><ul class=""><li id="212d" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated">你的集团<strong class="kw ir">没有</strong>很好地代表国家之间的关系吗？</li><li id="fb99" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">你的<code class="fe or os ot ou b"><strong class="kw ir">BlocBuilders</strong></code> / <code class="fe or os ot ou b"><strong class="kw ir">BlocListeners</strong></code>是逻辑混乱吗？</li></ul><p id="9621" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">解决方案:<br/> </strong>在设计阶段，你要尽量弄清楚所有状态之间的关系。尝试看看是否有可能<strong class="kw ir">将状态分成多个逻辑组</strong>并使用<strong class="kw ir"> OOP </strong>概念(如抽象类)将它们分组。这将给你的状态一个逻辑结构，使它们更容易与BlocBuilder  s一起工作。</p><p id="3e30" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">例子:<br/> </strong>为了详细说明所描述的解决方案，我们来做一个例子！</p><p id="7ff9" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">通常，您从一些空状态开始，需要从API获取数据来填充状态。您可能已经多次遇到过这个用例。这实际上是练习设计和状态逻辑分离的一个非常好的方法。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="ov ow l"/></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">以下示例的最终功能展示。</figcaption></figure><p id="f928" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">为了这个例子，让我们定义一个<code class="fe or os ot ou b"><strong class="kw ir">UserBloc</strong></code>的状态，它以一个<code class="fe or os ot ou b"><strong class="kw ir">User</strong></code>属性的形式保存一些与用户相关的信息<em class="mk">(例如电子邮件、用户名)</em>。这个阻塞唯一事件是一个试图获取数据的<code class="fe or os ot ou b"><strong class="kw ir">FetchUser</strong></code>事件。</p><p id="222c" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">通常对于这种类型的BLOCs，您可以从将状态分成两个逻辑部分开始:</p><ol class=""><li id="8c95" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo ox nu nv nw bi translated"><strong class="kw ir">未初始化</strong> →数据<strong class="kw ir">不存在</strong>的状态</li><li id="e473" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo ox nu nv nw bi translated"><strong class="kw ir">初始化</strong> →数据<strong class="kw ir">已经存在</strong>的状态</li></ol><p id="c157" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">现在我们的状态已经大致逻辑分离，让我们开始定义分离的状态。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="e976" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">状态设计步骤:</strong></h2><p id="dd61" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><strong class="kw ir"> 1。</strong>先来定义<strong class="kw ir">初始状态</strong>叫做<code class="fe or os ot ou b"><strong class="kw ir">UserUninitialized</strong></code>。这表示尚未提取远程数据的空状态。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/2ca747ed13fa392b23736f0b04e4c7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBZ7pvEI2DijpsjQPae5Dw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">初始状态。</figcaption></figure><p id="ed67" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir"> 2。让我们想象在这种状态下调用<code class="fe or os ot ou b"><strong class="kw ir">FetchUser</strong></code>事件。下一步可以是加载状态，其代表数据获取</strong>期间的<strong class="kw ir">状态。姑且称之为<code class="fe or os ot ou b"><strong class="kw ir">UserInitialFetching</strong></code>。</strong></p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/261d8b75b83e7dcf2f1c524341a1bc89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxm9Mzt_iMNbjroIR2mXrg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd ka">用户初始提取</strong>表示初始提取正在进行时的状态。</figcaption></figure><p id="5456" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir"> 3。</strong>如果提取失败，让我们定义一个类似<code class="fe or os ot ou b"><strong class="kw ir">UserInitialFetchingError</strong></code>的<strong class="kw ir">临时状态</strong>，它将<strong class="kw ir">立即</strong>转换回<code class="fe or os ot ou b"><strong class="kw ir">UserUninitialized</strong></code>状态。</p><p id="1f59" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">在代码中，这可以写成:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/81a7d598df1d5ccdf0a2310bc1b4eb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bTzxo8dy-6mkAqi6yJw2g.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">临时<strong class="bd ka">useinitialfetchingerror</strong>状态的示例。</figcaption></figure><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/bb01bb15882bc93e77b91fc1fd2c1519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md1xz9XaLIYFOMaISjjhyQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd ka">UserInitialFetchingError</strong>作为临时错误状态。虚线箭头线表示几乎立即的转变。</figcaption></figure><blockquote class="oi oj ok"><p id="2e71" class="ku kv mk kw b kx me kz la lb mf ld le ol mg lg lh om mh lj lk on mi lm ln lo ij bi translated"><strong class="kw ir">问:</strong>为什么以及什么时候应该使用<strong class="kw ir">临时</strong>状态<strong class="kw ir">状态</strong>？</p><p id="8553" class="ku kv mk kw b kx me kz la lb mf ld le ol mg lg lh om mh lj lk on mi lm ln lo ij bi translated"><strong class="kw ir">答:</strong> <em class="iq">当</em> <strong class="kw ir"> <em class="iq">状态消费者从中受益</em> </strong> <em class="iq">。假设UI需要显示一个错误</em> <code class="fe or os ot ou b"><strong class="kw ir"><em class="iq">SnackBar</em></strong></code> <em class="iq">以防请求失败。在这种情况下，拥有细粒度的临时状态是有益的，这些状态是唯一的，并且易于从UI和其他状态使用者那里听到。</em></p></blockquote><p id="4096" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir"> 4。</strong>如果获取成功，BLOC也可以发出一个临时的<code class="fe or os ot ou b"><strong class="kw ir">UserInitialFetchingSuccess</strong></code>状态，但是让我们假设还没有消费者依赖它，所以让我们转换到状态的<strong class="kw ir">初始化</strong>部分。</p><blockquote class="lp"><p id="7d37" class="lq lr iq bd ls lt lu lv lw lx ly lo dk translated"><strong class="ak"> <em class="pa">注意:</em> </strong> <em class="pa">因为</em>从现在起<em class="pa">所有的状态都有数据可用，创建一个</em> <strong class="ak"> <em class="pa">抽象</em></strong><em class="pa"/><code class="fe or os ot ou b"><em class="pa">UserInitialized</em></code><em class="pa"/><strong class="ak"><em class="pa">类</em> </strong> <em class="pa">，所有其他非空状态都将从该类扩展而来，完全有意义。</em></p></blockquote><p id="5445" class="pw-post-body-paragraph ku kv iq kw b kx lz kz la lb ma ld le kh mb lg lh kl mc lj lk kp md lm ln lo ij bi translated">这种抽象可能是这样的:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/3a37c5aa68fb30a23eb88a737775f64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dD46xygcQu3A4IEnVxv1qw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">与<strong class="bd ka"> UserInitialized </strong>抽象类逻辑相关的状态可以从它扩展。</figcaption></figure><p id="7faf" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">最后，让我们发射并过渡到这个阶段的<code class="fe or os ot ou b"><strong class="kw ir">UserLoaded</strong></code>状态。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/da92167208ec51ee01b0efa2e3adc6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQ6iNiE11chdsP_x_rByPw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">一旦获取的数据可用，状态就转换到抽象<strong class="bd ka">用户初始化</strong>状态。从现在开始，所有扩展<strong class="bd ka"> UserInitialized </strong>抽象类<strong class="bd ka">的状态都有数据可用</strong>。</figcaption></figure><p id="1f1c" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir"> 5。</strong>当当前状态为<code class="fe or os ot ou b"><strong class="kw ir">UserLoaded</strong></code>时，<code class="fe or os ot ou b"><strong class="kw ir">FetchUser</strong></code>事件会触发数据<strong class="kw ir">重取</strong>。让我们添加一个额外的状态来表示它— <code class="fe or os ot ou b"><strong class="kw ir">UserRefetching</strong></code>。该状态对于例如在UI层上呈现加载指示符也是有用的。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/c77074b46553e65f57fedf1e2a4f9f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5CVJ2Uj9zumUKJLMN2REA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd ka"> FetchUser </strong>事件在<strong class="bd ka">用户加载</strong>状态下被调用时触发<strong class="bd ka">重取</strong>。</figcaption></figure><p id="d0c1" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir"> 6。</strong>类似于步骤3，在状态返回到<code class="fe or os ot ou b"><strong class="kw ir">UserLoaded</strong></code> <em class="mk">(在获取失败的情况下，使用其旧数据作为备用数据)</em>之前，让我们定义一个临时错误状态— <code class="fe or os ot ou b"><strong class="kw ir">UserRefetchingError</strong></code>，它很容易从UI中听到。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/7e81a0884cccb5a8f7fc0c10ec203d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oe5jDIVmsGkpQHzh5T8Kng.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">当refetch失败时，发出临时<strong class="bd ka"> UserRefetchingError </strong>状态。</figcaption></figure><p id="a223" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">7.这一次，让我们添加一个临时的成功状态<code class="fe or os ot ou b"><strong class="kw ir">UserRefetchingSuccess</strong></code>，因为UI需要显示一个成功消息。状态切换回带有新获取数据的<code class="fe or os ot ou b"><strong class="kw ir">UserLoaded</strong></code>状态。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/d9ba9b17124287fc4ccbb06b0d9de3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7yr5ipSvmZQcacgEr2TYg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd ka">用户块</strong>状态图的最终结果。</figcaption></figure><p id="4371" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">就是这样！我们设法以清晰简洁的方式定义了状态机。这种设计BLOCs的结构化方法将帮助您轻松使用代码库的其余部分。</p><blockquote class="oi oj ok"><p id="ad5f" class="ku kv mk kw b kx me kz la lb mf ld le ol mg lg lh om mh lj lk on mi lm ln lo ij bi translated"><strong class="kw ir"><em class="iq">*提示2</em></strong><em class="iq">:</em><strong class="kw ir"><em class="iq">试着将你的状态分离并抽象成两个或更多的逻辑组</em>(例如未初始化/已初始化)<em class="iq">并使用临时发出的状态，这样状态消费者就能从中受益。</em> </strong></p></blockquote></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="09a8" class="ms jz iq bd ka mt mu mv kd mw mx my kg mz na nb kk nc nd ne ko nf ng nh ks ni bi translated">3.*奖励:处理NoOps和意外状态+事件组合</h1><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/77203e008e00a80125ddbc59fea3b146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9HJnGacMNhDd_34iPJ0xg.png"/></div></div></figure><p id="2870" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">挑战:</strong></p><ul class=""><li id="3b52" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated">当你的一些事件发生时，很难跟踪你的博客处于什么状态？</li><li id="ac57" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">没有捕捉到<strong class="kw ir">意外状态+事件</strong>的组合，导致随机错误？</li></ul><p id="1a07" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">解决方案:<br/> </strong>如果你想进一步强化你的BLOCs的稳定性和可预测性，它有助于捕捉所有<strong class="kw ir">意外状态+事件组合</strong>。这有助于你在早期发现缺失的处理程序实现<em class="mk">，并在以后避免与BLOC相关的错误。</em></p><p id="ff75" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">让我们在<code class="fe or os ot ou b"><strong class="kw ir">UserBloc</strong></code>和<code class="fe or os ot ou b"><strong class="kw ir">FetchUser</strong></code>事件<em class="mk">的实现上演示一下。本文观点)。</em></p><p id="9b5a" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">为了捕捉意外的组合，您可以从向我们的状态处理程序添加一个<code class="fe or os ot ou b"><strong class="kw ir">else</strong></code>语句开始，如下所示:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/7c782397b071fc3b66a3735ae48f5b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWQLErS9BC-58gc50-fmDA.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">预期状态+事件组合，并添加了一个常规意外事件处理程序。</figcaption></figure><p id="b1f3" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">简单！如果<code class="fe or os ot ou b"><strong class="kw ir">UnimplementedError</strong></code>像这样传播到您的主应用程序错误处理程序，您可以很容易地在您的错误报告仪表板<em class="mk">(例如Crashlytics) </em>中看到这些错误。</p><p id="e4a2" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！<br/>注意:等等！这个实现有一个问题。<br/>！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></p><p id="bb0d" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">如果当前状态既不是<code class="fe or os ot ou b"><strong class="kw ir">UserUninitialized</strong></code> <strong class="kw ir">也不是</strong> <code class="fe or os ot ou b"><strong class="kw ir">UserLoaded</strong></code>，上面的例子会发生什么？</p><blockquote class="oi oj ok"><p id="c729" class="ku kv mk kw b kx me kz la lb mf ld le ol mg lg lh om mh lj lk on mi lm ln lo ij bi translated">如果你不想总是抛出一个错误怎么办？</p><p id="919d" class="ku kv mk kw b kx me kz la lb mf ld le ol mg lg lh om mh lj lk on mi lm ln lo ij bi translated"><strong class="kw ir">预计某些状态不会对某些事件做出反应。</strong></p></blockquote><p id="634c" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">现在，您可以看到实际上有3种类型的案例<strong class="kw ir">需要处理:</strong></p><ul class=""><li id="e35d" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated"><strong class="kw ir">预期</strong>状态+事件组合✅</li><li id="3fab" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated"><strong class="kw ir">意外的</strong>状态+事件组合<em class="mk">(错误，缺少处理程序实现)</em> ✅</li><li id="a9be" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated"><strong class="kw ir"> *NEW: NoOps </strong> —预期<strong class="kw ir"> </strong>状态+事件组合与<strong class="kw ir">空处理程序</strong> <em class="mk">(又名无动作应发生)</em> ❓❓❓</li></ul><p id="708c" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">现在的目标是在事件处理程序中显式地处理这些，以摆脱抛出不需要的<strong class="kw ir"/><code class="fe or os ot ou b"><strong class="kw ir">UnimplementedErrors</strong></code><strong class="kw ir">。</strong></p><blockquote class="lp"><p id="bf65" class="lq lr iq bd ls lt lu lv lw lx ly lo dk translated">由于可能有许多状态需要被忽略，让我们通过在逻辑上将一些<strong class="ak">混合</strong>附加到我们的状态来获得一些帮助，以便于选择。</p></blockquote><p id="2396" class="pw-post-body-paragraph ku kv iq kw b kx lz kz la lb ma ld le kh mb lg lh kl mc lj lk kp md lm ln lo ij bi translated">让我们试着看看哪种状态最需要<strong class="kw ir">忽略</strong>:</p><ul class=""><li id="7fe8" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated"><strong class="kw ir">加载/获取</strong> →加载状态期间无需处理新事件</li><li id="1982" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated"><strong class="kw ir">暂时错误</strong></li><li id="381d" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated"><strong class="kw ir">暂时的成功</strong></li></ul><p id="de11" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">让我们将这些<strong class="kw ir">3</strong>4<strong class="kw ir">状态类别</strong>定义为<strong class="kw ir">混合</strong>如下:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pe"><img src="../Images/bbae5ff4a1427ec3a38cf54bcfe4bef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWLuoEk9mlR9-bYu0QYUSQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd ka">可以附加到逻辑对应状态的混合</strong>。</figcaption></figure><p id="1636" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">现在让我们将它们与相应的状态联系起来:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/4edae5c58f5585cee2fe639f3fa4c120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COTXb8vI636x5C4aRjVb0w.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">示例:通过使用`<strong class="bd ka"> with` </strong>关键字，在逻辑对应的状态类上使用上述<strong class="bd ka">混合</strong>。</figcaption></figure><p id="29e8" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">这现在使我们能够简化NoOps定义，并在我们的事件处理程序中轻松地选择它们:</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/4d7977572f33fc32962fbd80e4a2cf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6znMopjMd--dnTHyi0927g.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated">借助<strong class="bd ka"> mixins </strong>在处理程序的开头明确定义<strong class="bd ka"> NoOps </strong>。</figcaption></figure><p id="9837" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">结果:<br/> </strong>使用这种方法，您应该能够:</p><ul class=""><li id="cc37" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated">增加你的块的稳定性，因为所有的状态+事件组合都是显式处理的<em class="mk">(生产中不再有被遗忘的情况)</em></li><li id="f235" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">使代码尽可能接近设计的状态图</li><li id="4e67" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">通过对NoOps、预期和意外状态+事件组合的清晰定义，加快对集团运作方式的理解</li><li id="3b53" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">早点抓虫子</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="cb39" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h2><p id="8543" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">感谢您在大规模BLOCs的<strong class="kw ir">第1部分</strong>中走到这一步！这些设计方法被认为是真正的改变游戏规则的方法。它有助于代码更加稳定、可预测，同时在处理复杂的业务逻辑时使编码更加高效。</p><p id="d93f" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated">如果你的博客缺少本文所描述的一些东西，请随意尝试这些方法，并在评论中告诉我进展如何:)</p><p id="cf60" class="pw-post-body-paragraph ku kv iq kw b kx me kz la lb mf ld le kh mg lg lh kl mh lj lk kp mi lm ln lo ij bi translated"><strong class="kw ir">如果你想用一些新的概念装备自己并提升你的团体游戏，请继续关注这个系列的剩余部分</strong>。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="ef6d" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">本系列文章</h2><p id="9148" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">1 —状态机<br/> 2 — <a class="ae mj" href="https://medium.com/@nickjokic/flutter-blocs-at-scale-2-keeping-blocs-lean-1b659536e3ec" rel="noopener">保持区块精简</a> <br/> 3 —(即将推出)<br/> 4 —(即将推出)</p><h2 id="8920" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">*谢谢你</h2><p id="b6ff" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">给每一个读到这篇文章的人。<br/>如果你想要<strong class="kw ir">更多像这样的文章</strong>，请随意:</p><ul class=""><li id="0d74" class="no np iq kw b kx me lb mf kh oo kl op kp oq lo nt nu nv nw bi translated">💬<strong class="kw ir">评论</strong>您自己使用颤振、阻塞和状态管理解决方案的一般经验。</li><li id="fc71" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">👏<strong class="kw ir">发几个拍手</strong>。这将激励我继续分享关于颤振开发的生产准备技巧。</li><li id="79e7" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">➕ <strong class="kw ir">在我的媒介上按下跟随</strong>。</li><li id="a609" class="no np iq kw b kx nx lb ny kh nz kl oa kp ob lo nt nu nv nw bi translated">🔗<strong class="kw ir">在你的社区内分享</strong>该系列。</li></ul></div></div>    
</body>
</html>