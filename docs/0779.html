<html>
<head>
<title>Securing Kubernetes cluster access.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护Kubernetes集群访问。</h1>
<blockquote>原文：<a href="https://itnext.io/securing-kubernetes-cluster-access-3f0ea15428fa?source=collection_archive---------1-----------------------#2018-05-28">https://itnext.io/securing-kubernetes-cluster-access-3f0ea15428fa?source=collection_archive---------1-----------------------#2018-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8a4e69a368dc4a41db1acff880971619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxMyEjOrV0oluaGjF6y9ng.png"/></div></div></figure><p id="0c80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个不断发展的世界中，团队能够完全拥有自己的服务已经成为一种规范。从最初的规划到开发和最终的部署。将代码扔向你从未见过面或只与之发生过争执的运营团队的日子已经一去不复返了，欢迎来到未来。</p><p id="af91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="http://www.turnitin.com" rel="noopener ugc nofollow" target="_blank"> Turnitin </a>我们开始在部署中充分利用Kubernetes的力量。我们有大量的团队致力于与LMSs (Moodle、Blackboard、Canvas等)的集成。)，到我们用于原创匹配的强大服务，所有这些都必须放在某个地方，并以这样的方式放置，以便负责服务的团队能够管理他们的部署。</p><h1 id="6c40" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">输入名称空间</strong></h1><p id="8444" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将使用<a class="ae kw" href="https://kubernetes.io/docs/getting-started-guides/minikube/" rel="noopener ugc nofollow" target="_blank"> minikube </a>来利用名称空间的力量，让我们来看看默认情况下提供了什么。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4a72" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl get namespaces<br/>NAME STATUS AGE<br/>default Active 69d<br/>kube-public Active 69d<br/>kube-system Active 69d</span></pre><p id="ad80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但是我们的团队需要他们自己的名称空间，我们可以使用<code class="fe mo mp mq mf b">kubectl</code>创建名称空间！查看这个<a class="ae kw" href="https://gist.github.com/DominicGunn/6af344f949333cbb90b32b3701833c87" rel="noopener ugc nofollow" target="_blank">要点</a>以获得对<strong class="ka ir"> team-a </strong>的名称空间的描述。让我们利用这一点为团队建立一个区域。</p><p id="57e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它包含了一些关于我们将要创建的名称空间的信息，最重要的是名称！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3bb2" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl create -f team-a-namespace.json<br/>namespace “team-a” created</span><span id="fe2f" class="mj ky iq mf b gy mr ml l mm mn">➜ ~ kubectl get namespaces<br/>NAME STATUS AGE<br/>default Active 69d<br/>kube-public Active 69d<br/>kube-system Active 69d<br/>team-a Active 9s</span></pre><p id="fb30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在创建名称空间时，可以定义各种超级棒的策略，您可能有兴趣看一下涉及<a class="ae kw" href="https://kubernetes.io/docs/concepts/policy/resource-quotas/" rel="noopener ugc nofollow" target="_blank">资源配额</a>的策略。</p><h1 id="fbb1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">处理部署</strong></h1><p id="da08" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果团队不能在名称空间中放置任何东西，那么这个名称空间就没有用。我们不想让每个团队都超级访问集群，所以我们应该创建一个服务帐户，该帐户有权为他们管理名称空间。</p><p id="3ba4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes有各种各样的授权机制，但我们将要关注的是<a class="ae kw" href="https://kubernetes.io/docs/admin/authorization/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>，具体来说就是<a class="ae kw" href="https://kubernetes.io/docs/admin/authorization/rbac/#role-examples" rel="noopener ugc nofollow" target="_blank">角色</a>T6和<a class="ae kw" href="https://kubernetes.io/docs/admin/authorization/rbac/#rolebinding-and-clusterrolebinding" rel="noopener ugc nofollow" target="_blank">角色绑定</a> ' <a class="ae kw" href="https://kubernetes.io/docs/admin/authorization/rbac/#rolebinding-and-clusterrolebinding)'s" rel="noopener ugc nofollow" target="_blank"> s </a>。</p><p id="cc2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建服务账户</strong></p><p id="4ffb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建服务帐户是一个简单的过程，为了做到这一点，我们需要定义帐户的名称，并定义它将存在的名称空间，要点是这里的<a class="ae kw" href="https://gist.github.com/DominicGunn/ca57b205930039224d05bb227d5ef3fc" rel="noopener ugc nofollow" target="_blank"/>，但它足够小，我们可以看一看。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1dd2" class="mj ky iq mf b gy mk ml l mm mn">apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/> name: team-a-service-account<br/> namespace: team-a</span></pre><p id="bf48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">超级简单，让<code class="fe mo mp mq mf b">kubectl</code>为我们创建它。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="03f1" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl create -f team-a-service-account.yaml<br/>serviceaccount “team-a-service-account” created</span></pre><p id="3c61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建角色</strong></p><p id="c2d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个服务帐户，但它还不能做任何事情，我们需要给它一个角色。<a class="ae kw" href="https://kubernetes.io/docs/admin/authorization/rbac/#role-examples" rel="noopener ugc nofollow" target="_blank">文档</a>非常棒，所以我建议你阅读一下，为了这个团队，一个服务帐户，创建和更新部署和服务的权限将满足团队的需求。</p><p id="3b92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个角色的定义可以在这里的要点<a class="ae kw" href="https://gist.github.com/DominicGunn/ca57b205930039224d05bb227d5ef3fc" rel="noopener ugc nofollow" target="_blank">中找到，看起来是这样的</a></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8d9e" class="mj ky iq mf b gy mk ml l mm mn">kind: Role<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/> namespace: team-a<br/> name: team-a-deploy-role<br/>rules:<br/>- apiGroups: [“extensions”, “apps”]<br/> resources: [“deployments”]<br/> verbs: [“get”, “create”, “update”, “patch”]<br/>- apiGroups: [“”]<br/> resources: [“services”]<br/> verbs: [“get”, “create”, “update”, “patch”]</span></pre><p id="b5c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样没什么大不了的，我们已经为这个角色定义了几个明确的规则，完全符合我们团队的需要。我们可以根据需要添加更多，但这符合我们当前团队的需求，重要的是，我们还调用了该角色适用的名称空间。用<code class="fe mo mp mq mf b">kubectl</code>来套用一下吧</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="042e" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl create -f team-a-deploy-role.yaml<br/>role “team-a-deploy-role” created</span></pre><p id="fa50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建角色角色绑定</strong></p><p id="2a17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们就快完成了，现在我们只需要将角色绑定到我们创建的服务帐户，同样，如果您正在努力理解任何概念，那么<a class="ae kw" href="https://kubernetes.io/docs/admin/authorization/rbac/#default-roles-and-role-bindings" rel="noopener ugc nofollow" target="_blank">文档</a>是一个很好的资源。让我们来看看<a class="ae kw" href="https://gist.github.com/DominicGunn/21fdc919b2fd55ef8acf0f2cc0ad86bf" rel="noopener ugc nofollow" target="_blank">和</a>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5b65" class="mj ky iq mf b gy mk ml l mm mn">kind: RoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/> name: team-a-binding<br/> namespace: team-a<br/>subjects:<br/>- kind: ServiceAccount<br/> name: team-a-service-account<br/> namespace: team-a<br/>roleRef:<br/> kind: Role<br/> name: team-a-deploy-role<br/> apiGroup: rbac.authorization.k8s.io</span></pre><p id="448a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了什么？正在创建一个名为<strong class="ka ir"> team-a-binding </strong>的新角色绑定，我们将它绑定到subject<strong class="ka ir">team-a-service-account</strong>并引用我们创建的角色<strong class="ka ir"> team-a-deploy-role </strong>，所有这些都发生在<strong class="ka ir"> team-a </strong>名称空间内。让<code class="fe mo mp mq mf b">kubectl</code>为我们运行这个。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6445" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl create -f team-a-role-binding.yaml<br/>rolebinding “team-a-binding” created</span></pre><h1 id="83fc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">共享凭证</strong></h1><p id="bd36" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">太好了，我们有了一个服务帐户，它能够执行团队请求的部署，但现在我们实际上需要与<strong class="ka ir"> team-a </strong>共享凭据，我们该如何做呢？</p><p id="0ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们创建服务帐户之后，Kubernetes为我们创建了一堆东西，包括一个包含帐户CA和token的秘密。让我们看一下资源。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a108" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl get sa team-a-service-account — namespace team-a -o json<br/>{<br/> “apiVersion”: “v1”,<br/> “kind”: “ServiceAccount”,<br/> “metadata”: {<br/> “creationTimestamp”: “2018–05–20T15:59:38Z”,<br/> “name”: “team-a-service-account”,<br/> “namespace”: “team-a”,<br/> “resourceVersion”: “18409”,<br/> “selfLink”: “/api/v1/namespaces/team-a/serviceaccounts/team-a-service-account”,<br/> “uid”: “cc52ba75–5c46–11e8–9562–080027247075”<br/> },<br/> “secrets”: [<br/> {<br/> “name”: “team-a-service-account-token-lf4k7”<br/> }<br/> ]<br/>}</span></pre><p id="ce63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到已经为我们创建了一个名为<strong class="ka ir">team-a-service-account-token-lf4k 7</strong>的秘密资源，我们将使用它来获取一些信息，并与团队分享。</p><p id="1cc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来的一些步骤将包括一个名为<code class="fe mo mp mq mf b">jq</code>的伟大工具，如果你以前没有用过它，我建议你安装它并看看<a class="ae kw" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank">文档</a>，它是一个使用JSON的伟大工具！</p><p id="7957" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">抓取证书权限</strong></p><p id="df01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建服务帐户的方式意味着我们使用CA和令牌对群集进行身份验证，我们可以使用<code class="fe mo mp mq mf b">kubectl</code>获取CA并将其放入证书文件中！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="558b" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl get secret team-a-service-account-token-lf4k7 — namespace team-a -o json | jq -r ‘.data[“ca.crt”]’ &gt; team-a.crt</span><span id="9d65" class="mj ky iq mf b gy mr ml l mm mn">➜ ~ cat team-a.crt<br/>ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJ….</span></pre><p id="c3b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">抓取用户令牌</strong></p><p id="da68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了CA之外，我们还需要用于针对Kubernetes API进行身份验证的无记名令牌，我们可以以非常相似的方式获取它。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5222" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl get secret team-a-service-account-token-lf4k7 — namespace team-a -o json | jq -r ‘.data[“token”]’ &gt; team-a.token</span><span id="b757" class="mj ky iq mf b gy mr ml l mm mn">➜ ~ cat team-a.token<br/>ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJ….</span></pre><h1 id="8d45" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">与库伯内特交谈</strong></h1><p id="a757" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">作为Kubernetes管理员，我们的工作现在已经完成，我们可以将证书和令牌传递给需要它们的团队，并用它们来擦手，但是作为团队，我们现在如何与集群对话呢？</p><p id="6141" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们使用<code class="fe mo mp mq mf b">kubectl</code>获得的证书是base64编码的，在我们继续之前，我们需要确定这一点。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cea5" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ base64 — decode -i team-a.crt &gt; team-a-decoded.crt</span></pre><p id="8d9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，现在让我们使用<code class="fe mo mp mq mf b">kubectl</code>来设置我们的本地配置，以便我们可以与集群对话。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="59be" class="mj ky iq mf b gy mk ml l mm mn">➜ ~ kubectl config set-cluster minikube — embed-certs=true — server=<a class="ae kw" href="https://192.168.99.100:8443" rel="noopener ugc nofollow" target="_blank">https://192.168.99.100:8443</a> — certificate-authority=team-a-decoded.crt<br/>Cluster “minikube” set.</span><span id="c6d8" class="mj ky iq mf b gy mr ml l mm mn">➜ ~ kubectl config set-credentials team-a-service-account — token=ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJ….<br/>User “team-a-service-account” set.</span><span id="b497" class="mj ky iq mf b gy mr ml l mm mn">➜ ~ kubectl config set-context team-a-context — cluster=minikube — user=team-a-service-account — namespace=team-a<br/>Context “team-a-context” created.</span><span id="85ec" class="mj ky iq mf b gy mr ml l mm mn">➜ ~ kubectl config use-context team-a-context<br/>Switched to context “team-a-context”.</span></pre><p id="b6ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几个细节，服务器<code class="fe mo mp mq mf b"><a class="ae kw" href="https://192.168.99.100:8443`" rel="noopener ugc nofollow" target="_blank">https://192.168.99.100:8443</a></code>是我们的Minikube集群的地址，这可能对你来说是不同的，在现实生活中肯定是不同的，你的Kubernetes管理员应该能够提供给你。</p><p id="4921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您是集群管理员，并且不确定主服务器在哪里运行，您可以使用<code class="fe mo mp mq mf b">cluster-info</code>轻松找到它</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="55a2" class="mj ky iq mf b gy mk ml l mm mn">➜ kubectl cluster-info<br/>Kubernetes master is running at <a class="ae kw" href="https://192.168.99.100:8443" rel="noopener ugc nofollow" target="_blank">https://192.168.99.100:8443</a></span></pre><h1 id="94bf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">乡亲们都到了</strong></h1><p id="f170" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">没有太多太多了。在真实的场景中，您可能有几个脚本来自动完成一些设置，并且您授予您的角色的规则可能在这里或那里有点严格，但是这应该有助于您立即投入使用！</p><p id="a21e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的博客上阅读这篇文章和更多内容，<a class="ae kw" href="https://fable.sh" rel="noopener ugc nofollow" target="_blank">https://寓言. sh </a>！</p></div></div>    
</body>
</html>