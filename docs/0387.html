<html>
<head>
<title>Handling large lists and tables in react</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在react中处理大型列表和表格</h1>
<blockquote>原文：<a href="https://itnext.io/handling-large-lists-and-tables-in-react-238397854625?source=collection_archive---------0-----------------------#2018-03-03">https://itnext.io/handling-large-lists-and-tables-in-react-238397854625?source=collection_archive---------0-----------------------#2018-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/69f99d6c9836318987827f4776feee04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-ERgvkOJIwHCTFSa9CXNw.jpeg"/></div></div></figure><p id="6afd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想象一种常见的情况:您有一个包含大量数据的表，或者一个包含许多项的列表。如果您在react中已经遇到过这种情况，您应该知道组件在屏幕上实际呈现之前会有一段等待时间，然后它会立即呈现。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="590f" class="lf lg iq lb b gy lh li l lj lk">class ParentComponent extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;<br/>      ...<br/>      {this.props.items.map( item =&gt;<br/>        &lt;ChildComponent {...item}/&gt;<br/>      )}<br/>    &lt;/div&gt;<br/>  }<br/>} </span></pre><p id="80ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦ParentComponent接收到props.items，它首先将其全部添加到虚拟DOM，然后检查真实DOM的哪一部分需要协调，然后一次性更新它。您看到的延迟是react在进行协调之前处理大量项目所需的时间。</p><p id="48da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想要的是能够显示已经加载到虚拟DOM中的项目，同时等待其他项目加载。要做到这一点，我们需要尽快呈现我们的ParentComponent(让它在屏幕上可见)，然后逐步添加项目。让我们扩展我们的ParentComponent:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0df8" class="lf lg iq lb b gy lh li l lj lk">constructor(props) {<br/>  super(props);</span><span id="2db2" class="lf lg iq lb b gy ll li l lj lk">  this.state = {<br/>    items: this.props.items.slice(0, 1)<br/>  }<br/>}<br/>...<br/>render() {<br/>  return &lt;div&gt;<br/>    ...<br/>    {this.state.items.map( item =&gt;<br/>      &lt;ChildComponent {...item}/&gt;<br/>    )}<br/>  &lt;/div&gt;<br/>}</span></pre><p id="e8af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们添加了一个构造函数，并在其中定义了state.items，这是我们刚刚更新的render()方法中实际映射的内容。我们确保state.items是一个只有一个元素的数组。现在我们需要一种方法来逐个更新state.items和添加其他项。通过使用这种方法，render方法将更频繁地触发(props.items.length times ),但它将立即显示所有加载的项目，这正是我们想要的。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ef63" class="lf lg iq lb b gy lh li l lj lk">recursive = () =&gt; {<br/>  setTimeout(() =&gt; {<br/>    let hasMore = this.state.items.length + 1 &lt; this.props.items.length;<br/>    this.setState( (prev, props) =&gt; ({<br/>      items: props.items.slice(0, prev.items.length + 1)<br/>    }));<br/>    if (hasMore) this.recursive();<br/>  }, 0);<br/>}</span></pre><p id="3fd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编辑:如果您担心在递归函数中调用setState，即调用太多次，请注意:</p><ol class=""><li id="fc99" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">调用setState是更新视图的正确方法</li><li id="91d8" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">根据您的需要，您可以一次加载多个项目。因此，如果您有一个包含4个项目的网格，您可以一次加载4个项目。</li><li id="a883" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">setState可以将几个调用批处理在一起，从而提高效率。</li><li id="b105" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">setTimeout将执行放在堆栈的末尾，因此如果用户与已经呈现的组件交互，他的交互将优先于呈现其余的项目。这提高了UX，因为用户可以开始工作，而不必等待一切都出现。</li><li id="73ae" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">做性能测试，看看它是否减慢或加快你的应用程序</li><li id="5262" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">这是有用的，如果你已经有所有的项目在前面。如果你正在抓取，你需要使用不同的策略</li><li id="8a8e" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">提取成分就不会有副作用。做这件事的组件在它的状态下不应该做任何事情。我把它做成一个临时的。</li></ol><p id="c492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个递归函数，它会一直调用自己，直到长度相同。每次迭代将向state.items数组添加一个元素。我们添加了setTimeout将其放在堆栈的末尾，这样我们只在渲染完成后更新状态，从而提供更好的用户体验。我们只需要调用这个函数:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="45c7" class="lf lg iq lb b gy lh li l lj lk">componentDidMount() {<br/>   this.recursive();<br/>}</span></pre><p id="9b12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧啊。</p><p id="8aef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编辑:也有可能在render方法中分割props，在递归中只更新一个state.counter，但是我没有得到性能上的差别。</p><p id="d4be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编辑2:这段代码已经过测试，证明对于包含10到1500个react元素的列表和集合非常有用，挂载时间很长(2到3毫秒)。您也可以将react-virtualized作为一种外部解决方案</p></div></div>    
</body>
</html>