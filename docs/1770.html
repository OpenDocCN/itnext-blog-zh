<html>
<head>
<title>JavaScript Wizard: Tips &amp; Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript向导:提示和技巧</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-wizard-tips-and-tricks-1b91025a0d62?source=collection_archive---------2-----------------------#2019-01-23">https://itnext.io/javascript-wizard-tips-and-tricks-1b91025a0d62?source=collection_archive---------2-----------------------#2019-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/09f9cb0f37cbbefa06aadd6a4059f63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bo3_iJbnmZ3OWGCmA_VudA.jpeg"/></div></div></figure><div class=""/><p id="4a4f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2017年，职位空缺中需求第二大的语言是JavaScript，仅次于Java。</p><p id="a5a0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，如果你想获得一个理想的软件工程师的安全职位，知道如何使用这种流行语言是非常有益的。<br/>如果你已经在那里了，学习一些JavaScript的隐藏角落可以帮助你避免不时的头痛😉</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/fd632d5245e878b912e44434d4b9c29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vr3vTUISRDwovjBnKR2K6A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">2017年末，<a class="ae lf" href="https://www.indeed.com/" rel="noopener ugc nofollow" target="_blank">Indeed.com</a>发布的职位空缺中最受欢迎的语言列表。[ <a class="ae lf" href="https://stackify.com/popular-programming-languages-2018/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="e601" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将介绍8个您可能没有听说过的简洁的JavaScript技巧和窍门。<br/>本文既适合JavaScript新手，也适合有中级经验的人。</p><h1 id="fdd9" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">1.数字</h1><p id="d30a" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在JavaScript中解析数字时，您可能已经见过并使用过全局函数<code class="fe mj mk ml mm b">parseInt()</code>和<code class="fe mj mk ml mm b">parseFloat().</code></p><p id="65fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript正慢慢远离上述的全局函数，转而支持使用模块。<br/><code class="fe mj mk ml mm b">parseInt()</code>和<code class="fe mj mk ml mm b">parseFloat()</code>都属于<code class="fe mj mk ml mm b">Number</code>对象，可以像<code class="fe mj mk ml mm b">Number.parseInt()</code>一样调用</p><p id="7b1b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中，所有的数字都是相同的数据类型“number ”,都是浮点型的。更具体地说，JavaScript使用了<a class="ae lf" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank">双精度浮点格式</a>。<br/><code class="fe mj mk ml mm b">Number</code>对象是用<code class="fe mj mk ml mm b">Number()</code>构造函数创建的，从字符串中解析数字的最简单方法(如果不需要使用基数)是将字符串作为参数传递给构造函数。</p><p id="93c2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">const num = Number('42.5')</code></p><p id="e5bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，<code class="fe mj mk ml mm b">Number</code>对象有一组方便的函数，用于处理数字和数学运算。</p><p id="8917" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一些正在使用的函数的例子</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="a0ea" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">2.求幂运算<code class="fe mj mk ml mm b"> infix operator</code></h1><p id="5d8b" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">当您需要对某个数字进行其他数字的幂次运算时，您可能已经习惯于使用<code class="fe mj mk ml mm b">Math.pow(a, b)</code> <br/>从ECMAScript 2016 (ES7)开始，您现在可以使用取幂中缀运算符<code class="fe mj mk ml mm b">**</code>来代替。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="7df0" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">3.真/假布尔转换</h1><p id="7774" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在JavaScript中，任何值都可以在布尔上下文中计算。<br/>如果一个值被评估为<em class="mp">真</em>，则称其为<em class="mp">真</em>否则称其为<em class="mp">假</em>。</p><p id="b14c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在布尔上下文中，以下值将始终被评估为<strong class="ka jc">假</strong>。</p><ul class=""><li id="606c" class="mq mr jb ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><code class="fe mj mk ml mm b">false</code></li><li id="09c0" class="mq mr jb ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><code class="fe mj mk ml mm b">null</code></li><li id="5c16" class="mq mr jb ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><code class="fe mj mk ml mm b">undefined</code></li><li id="175d" class="mq mr jb ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><code class="fe mj mk ml mm b">0</code></li><li id="63ff" class="mq mr jb ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><code class="fe mj mk ml mm b">''</code>或<code class="fe mj mk ml mm b">""</code>(空弦)</li><li id="5aed" class="mq mr jb ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><code class="fe mj mk ml mm b">NaN</code></li></ul><p id="10e7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在布尔上下文中，其他任何内容都将被评估为<strong class="ka jc">真</strong>。</p><p id="ad7c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时我们想把一个非布尔值转换成布尔值。<br/>我们可以使用<code class="fe mj mk ml mm b">!!</code>操作符来完成，也称为<em class="mp"> not-not操作符。</em></p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4734" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe mj mk ml mm b">!!</code>本身不是逻辑运算符，而是两个<code class="fe mj mk ml mm b">!</code>运算符顺序使用的组合。<br/>第一个<code class="fe mj mk ml mm b">!</code>将在一个布尔上下文中计算它后面的值，将它强制转换成一个布尔值并取反它。第二个<code class="fe mj mk ml mm b">!</code>将否定这个布尔值，产生将真值/假值转换成其布尔值表示的预期效果。</p><p id="af6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种方法是使用<code class="fe mj mk ml mm b">Boolean</code>对象。</p><p id="6b0f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mp">注意:对于非布尔值，使用</em> <code class="fe mj mk ml mm b">Boolean</code> <em class="mp">作为函数，而不是创建</em> <code class="fe mj mk ml mm b">Boolean</code> <em class="mp">对象的新实例。</em></p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="f665" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">4.对象.条目</h1><p id="9c1b" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">也许你已经知道可以使用<code class="fe mj mk ml mm b">Object.keys()</code>返回一个包含对象键名的列表。当你想要像这样迭代一个对象时，这很方便</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6c49" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是您可能没有意识到，您可以使用<code class="fe mj mk ml mm b">Object.entries()</code>来返回一个包含键值名和对象值的<em class="mp">条目列表</em>。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4aa0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您自己还没有弄明白，您当然也可以像这样使用<code class="fe mj mk ml mm b">Object.values()</code>返回一个只包含值的列表</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="931a" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">5.对象上的Rest运算符</h1><p id="ccc3" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在ES6中，引入了rest和spread运算符。<br/>它们有非常不同的效果，但都是通过设置三个点来使用<code class="fe mj mk ml mm b">...</code></p><ul class=""><li id="7bfb" class="mq mr jb ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated"><strong class="ka jc">扩展操作符</strong>允许将iterables扩展为单个参数/元素。</li><li id="e06d" class="mq mr jb ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><strong class="ka jc"> Rest操作符</strong>将所有剩余的元素收集到一个iterable中。</li></ul><p id="84d9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">rest操作符可以应用于数组和对象，如果使用正确，这将是一个强大的工具。</p><p id="1604" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在对象上结合析构和rest操作符，我们可以很容易地从对象中提取出想要的属性，将对象中剩余的属性留给自己。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a06e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们想清除一个对象的某些属性时，这也是非常方便的。<br/>无需遍历整个对象并创建一个新的干净对象。</p><p id="d1f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想阅读更多关于spread和rest操作符的内容，我建议你阅读Hugo Di Francesco的文章:<a class="ae lf" href="https://hackernoon.com/recursion-in-javascript-with-es6-destructuring-and-rest-spread-4b22ae5998fa" rel="noopener ugc nofollow" target="_blank">用ES6在JavaScript中递归，析构和rest/spread </a>。</p><h1 id="6fb0" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak"> 6。最后</strong></h1><p id="3134" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在JavaScript中，承诺已经成为一件大事。<br/>由于这个主题的整体性超出了本文的范围，我想把重点放在一个新的函数上；已经被添加到JavaScript Promises中作为一个实例方法，可以用在扩展中</p><p id="452c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">finally()</code>被调用时没有任何价值，无论一个承诺被解决或拒绝都被调用。即无论如何都要执行。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="42d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它也可以与ES7 <em class="mp">异步/等待</em>一起使用。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6625" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想更全面地了解JavaScript的承诺，我建议你阅读Gokul N K的文章:<a class="ae lf" href="https://hackernoon.com/understanding-promises-in-javascript-13d99df067c1" rel="noopener ugc nofollow" target="_blank">理解JavaScript中的承诺</a>。</p><h1 id="ceb0" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">7.等待…的</h1><p id="2bcb" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">当我们谈到承诺这个话题时，我想提一下另一个非常有用的特性。<br/>全新的<em class="mp">等待...来自ES8的</em>特性让我们异步迭代承诺列表。<br/>循环的<em class="mp">for await…将有效地等待承诺解决，然后继续下一次迭代。</em></p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="03d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意迭代中的每个<em class="mp">消息</em>是承诺的解析值，而不是承诺本身。在这种情况下，我们也可以确定我们会以正确的顺序记录承诺。</p><p id="14e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mp"> NB。这是一个实验性的功能，预计将来会有所改变。<br/>而且这在IE和Edge中还不支持，Node.js中的支持未知。</em></p><h1 id="9c95" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">8.平面地图</h1><p id="8e91" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><code class="fe mj mk ml mm b">flatMap()</code>是另一个用于执行一级阵列扁平化的ES8提案。使用<code class="fe mj mk ml mm b">map()</code>和<code class="fe mj mk ml mm b">reduce()</code>可以实现相同的行为，但是使用<code class="fe mj mk ml mm b">flatMap()</code>更简单，可读性更好。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="01a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个例子中，使用<code class="fe mj mk ml mm b">flatMap()</code>会更加方便。在这里，我们从句子列表中生成一个单词列表。</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8206" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">就是这样！<br/>我希望您喜欢阅读，如果您有任何问题或反馈，请随时在下面发表评论。<br/>如果你喜欢这篇文章，请鼓掌👏扣几下吧！</strong></p></div></div>    
</body>
</html>