<html>
<head>
<title>The 114 standard C++ algorithms. Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">114种标准C++算法。介绍</h1>
<blockquote>原文：<a href="https://itnext.io/the-114-standard-c-algorithms-introduction-2a75a2df4300?source=collection_archive---------0-----------------------#2022-02-14">https://itnext.io/the-114-standard-c-algorithms-introduction-2a75a2df4300?source=collection_archive---------0-----------------------#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="85e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到关于C++标准算法的新系列。标准算法提供了安全和优化的构建模块，可以取代数量惊人的用户代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/84e066f69498e694b67fab9e4a59c89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dpfp7Rxu-s5DK_3jwKGZcw.png"/></div></div></figure><p id="774a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们将看一下算法的基础，解释迭代器的概念，谈一谈C++23的历史和未来，最后看一下<code class="fe kx ky kz la b">for_each</code>和<code class="fe kx ky kz la b">swap</code>算法。</p><h2 id="3bcb" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">该系列:</h2><ul class=""><li id="fe08" class="lu lv iq jp b jq lw ju lx jy ly kc lz kg ma kk mb mc md me bi translated">介绍</li><li id="4b30" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">排序和划分算法</a></li><li id="8f1e" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e">对排序或分区范围进行操作的算法</a></li><li id="f7c1" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/transformations-the-114-c-algorithms-series-deacdbd4c373">转换算法</a></li><li id="5f59" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324">左折叠和其他缩小</a></li><li id="dddd" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、副本和移动</a></li><li id="6c9c" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d">堆和堆</a></li><li id="a7f8" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><a class="ae mk" href="https://medium.com/@simontoth/8a6ed951ad40" rel="noopener">搜索和最小值-最大值</a></li><li id="e5ab" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">结论(即将发布)</li></ul><h1 id="deeb" class="ml lc iq bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">标准算法</h1><p id="b99a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">你可以批评C++标准库缺乏功能。然而，当涉及到数据和数字处理时，C++标准库提供了一个通用的算法工具包。因此，如果你是一名C++开发人员，你应该知道有哪些可用的工具。</p><h2 id="2851" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">迭代器:互操作层</h2><p id="ee8e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">位于C++数据结构和算法之间的核心是迭代器。迭代器抽象出特定数据结构如何被遍历的细节，同时捕捉数据结构强加的行为限制。</p><p id="6bda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，一个数组(如<code class="fe kx ky kz la b">std::vector</code>)允许随机访问，这意味着我们可以在恒定的时间内从一个元素移动到另一个元素。另一方面，链表(如<code class="fe kx ky kz la b">std::list</code>)只允许我们在常数时间内移动到下一个和上一个元素，移动n的距离需要n次运算(线性复杂度)。</p><p id="7bf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C++识别以下迭代器类别:</p><ul class=""><li id="fa68" class="lu lv iq jp b jq jr ju jv jy nf kc ng kg nh kk mb mc md me bi translated"><strong class="jp ir">输入迭代器:</strong>前进，读取，一次通过</li><li id="b66b" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">向前迭代器:</strong>前进，读取</li><li id="90c9" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">双向迭代器:</strong>向前迭代器+向后移动</li><li id="9e23" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">随机访问迭代器:</strong>双向迭代器+前进&amp;后退任意整数，计算两个迭代器之间的距离</li><li id="d3b1" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">连续迭代器:</strong>随机访问+元素的存储是连续的</li><li id="89d4" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated"><strong class="jp ir">输出迭代器:</strong>前进，写入，一次通过</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种分类允许算法指定它们需要的迭代器的类型，要么显式地(使用C++20概念)，要么隐式地使用特定类型迭代器支持的操作。</p><p id="0b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如<code class="fe kx ky kz la b">std::sort</code>需要随机访问迭代器，因为它需要高效地计算两个迭代器的距离。因此下面的代码不会被编译(std::list提供了双向迭代器):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="77d3" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">范围</h2><p id="007e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">虽然C++20形式化了范围的概念，但范围的概念从一开始就存在于C++中。每个容器都应该提供对两个迭代器的访问，<code class="fe kx ky kz la b">begin</code>和<code class="fe kx ky kz la b">end</code>。这里的语义是<code class="fe kx ky kz la b">[begin,end)</code>，即<code class="fe kx ky kz la b">begin</code>是第一个元素的迭代器，<code class="fe kx ky kz la b">end</code>是最后一个元素之后的迭代器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="95ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用相同类别的迭代器对范围进行分类。在本系列中，我们将在迭代器上使用范围命名法(例如，输入范围、前向范围、双向范围等。).</p><h2 id="29e3" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">一点历史</h2><p id="1d71" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">从前面的章节中，您可能已经怀疑C++20代表了算法历史上的一个重要里程碑。随着范围和惰性视图的引入，情况确实如此。然而，除此之外，一些C++标准引入了影响标准算法的重大变化。</p><ul class=""><li id="568d" class="lu lv iq jp b jq jr ju jv jy nf kc ng kg nh kk mb mc md me bi translated">C++11引入了lambdas</li><li id="67d9" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">C++17引入了并行算法</li><li id="f35c" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">C++20引入了范围和惰性视图</li><li id="a98c" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">C++23有望引入对用户实现的视图和潜在的图形算法的支持</li></ul><h1 id="9f3b" class="ml lc iq bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">for_each，for_each_n</h1><p id="d709" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">理论到此为止。先说具体算法，先从最简单的<code class="fe kx ky kz la b">for_each</code>和<code class="fe kx ky kz la b">for_each_n</code>说起。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/d5585194f74769c92c3a882b32c7cf35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHl63Zd6POvHDnr8cE8Xuw.png"/></div></div></figure><p id="5aa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于C++11引入了范围循环，for_each变成了一个不太相关的算法。然而，仍然有一些情况下for_each提供了很多功能。</p><p id="04f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并行版本可能是C++中最简单的并行工具。如果您只需要对每个元素单独运行一个开销很大的操作，那么并行for_each是一个完美的解决方案:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e36d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，如果操作不是完全隔离的，您将需要lambda内部的额外同步。</p><p id="81b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您只需要投影一个元素，然后将结果分派给另一个函数，那么range版本可以提供更简洁的代码。这里，我们使用for_each和一个范围循环来表示相同的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在range版本中(第10行)，第一个参数是范围，第二个参数是我们要为每个元素调用的函数，第三个是投影。在这种情况下，我们使用一个成员指针。如果你想深入了解细节，我有一篇关于<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/c-20-ranges-complete-guide-4d26e3511db0"> C++20范围</a>的独立文章。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/9eeaa1d0b8a247a4a49b027a610340fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkddqHgacDZjvG2wqrXHRA.png"/></div></div></figure><p id="5ec8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而for_each作用于整个范围，interval [begin，end，for_each_n作用于范围[first，first+n]。重要的是，因为算法甚至不能访问源范围的结束迭代器，所以它不进行越界检查，确保[first，first+n)范围有效是调用者的责任。</p><p id="7312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示，让我们看一段评估锦标赛资格赛的代码。我们希望邀请顶级玩家参加主锦标赛，然后在线发布最终得分，并按100个条目进行分页:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8d31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发送邀请可以并行进行(第18行)，但是一定要避免越界(第19行std::min)。对于分页，我们进入PAGE_SCORE_SIZE的块，并且对于每个块，调用for_each_n(第26行)。</p><h1 id="7384" class="ml lc iq bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">交换，交换范围，迭代交换</h1><p id="a4cb" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">我们今天要讨论的第二组算法是交换组。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/e95cee0beac43558e58b5475fe812cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsUuL-CHmhSxpRJH7UjS0w.png"/></div></div></figure><p id="1cbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们首先需要讨论由参数相关查找引起的一点复杂性。当数据结构交换起来很便宜时，这并不罕见，所以我们希望为它们定制交换。</p><p id="fbab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在std名称空间中专门化std::swap，但这意味着这种专门化将不会与依赖于参数的查找相匹配(它将位于与其参数不同的名称空间中)。这意味着对swap的非限定调用不会找到正确的实现。</p><p id="3a99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">专门化swap的正确方法是在与数据结构相同的名称空间中提供一个(friend)函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而调用swap的正确方法是在非限定调用之前拉入std::swap:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ac6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，c++ 20 rangized版本的swap消除了这种复杂性。这是一个终极解决方案，它将:</p><ul class=""><li id="5fd3" class="lu lv iq jp b jq jr ju jv jy nf kc ng kg nh kk mb mc md me bi translated">将调用匹配类型的用户提供的或标准的交换</li><li id="0a03" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">如果不存在并且参数是范围，将执行swap_range</li><li id="c4ad" class="lu lv iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">如果参数不是范围，则默认为移动交换<br/> <code class="fe kx ky kz la b">V v(std::move(t)); t = std::move(u); u = std::move(v);</code></li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6adf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后说说另外两个变种，iter_swap和swap_ranges。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/3f7e2c61bea2cd9e25408654bd5ef147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E5bZg8lr-xydQMlrU-FfQ.png"/></div></div></figure><p id="c17d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Iter交换也可以称为间接交换，交换迭代器或其他间接类型背后的底层值。它主要有助于实现自定义算法，因为这些算法是在迭代器上操作的。</p><p id="e723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个使用iter_swap实现分区算法的示例(第12行):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/73b19979c2e028f067d81c9f482b5904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Zgix33tPtUlPpN4GJQxgQ.png"/></div></div></figure><p id="42b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交换范围是两个非重叠范围的分段交换(可能来自同一个容器)。begin迭代器指定第二个范围，调用者负责确保目标范围有足够的容量。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0c86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们用数组的最后三个元素交换数组的前三个元素。元素的顺序是颠倒的，因为我们使用rbegin(反向迭代的begin iterator)。</p><h1 id="356a" class="ml lc iq bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">感谢您的阅读</h1><p id="3156" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">不要忘记关注，这样你就不会错过本系列的其他文章。下一个将是关于排序和划分算法。</p><p id="5552" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在<a class="ae mk" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">推特</a>或<a class="ae mk" href="https://www.linkedin.com/in/simontoth" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>