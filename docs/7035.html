<html>
<head>
<title>Let's implement basic service discovery using Go 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们使用Go实现基本的服务发现🚀</h1>
<blockquote>原文：<a href="https://itnext.io/lets-implement-basic-service-discovery-using-go-d91c513883f6?source=collection_archive---------0-----------------------#2022-05-22">https://itnext.io/lets-implement-basic-service-discovery-using-go-d91c513883f6?source=collection_archive---------0-----------------------#2022-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们已经知道的，要请求一个服务实例(服务器)，我们必须知道它的网络位置(IP地址和端口)。</p><p id="3dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着当今世界微服务的突破，越来越多的用户、请求、需求使得这项工作变得非常困难。此外，在基于云的微服务时代，由于各种情况，如<a class="ae kl" href="https://en.wikipedia.org/wiki/Autoscaling" rel="noopener ugc nofollow" target="_blank">自动伸缩</a>，故障和升级，我们的服务也在不断变化。由于这些变化，他们不断获得新的知识产权。</p><p id="f258" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<a class="ae kl" href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/" rel="noopener ugc nofollow" target="_blank">服务发现进入微服务场景</a>的地方。我们需要一个系统来监视所有服务，并跟踪在任何给定时间哪个服务部署在哪个IP/端口组合上，以便微服务的客户端可以相应地无缝路由。<a class="ae kl" href="https://www.amazon.com/Microservice-Architecture-Aligning-Principles-Practices/dp/1491956259" rel="noopener ugc nofollow" target="_blank">【1】</a></p><p id="15d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务发现在概念上非常简单:它的重要组件是服务注册中心，它是应用程序服务实例的网络位置的数据库。<a class="ae kl" href="https://www.amazon.com/Microservices-Patterns-examples-Chris-Richardson/dp/1617294543" rel="noopener ugc nofollow" target="_blank">【2】</a>该机制在服务实例启动和停止时更新服务注册表。</p><p id="3897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现服务发现有两种主要方式:</p><ul class=""><li id="d1e7" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">首先，服务及其客户端直接与服务注册中心交互。</li><li id="2e05" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">部署基础设施<a class="ae kl" href="https://iximiuz.com/en/posts/service-discovery-in-kubernetes/" rel="noopener ugc nofollow" target="_blank"> (k8s等。)处理服务发现</a>。</li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="8d65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用第三方注册模式来实现我们的服务发现。由于这种模式，不是服务向服务注册中心注册，而是第三方注册(在我们的例子中，非常基本的go函数以特定的时间间隔运行<code class="fe lh li lj lk b">docker ps -a</code>)。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/eb2dde755154caf3d0e78827118cf7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gm4glVVGH7LrryIioXTKwQ.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">图:项目架构概述</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="f45c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更详细地回顾一下我们的应用程序。</p><h1 id="b900" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">反向代理</h1><p id="7f89" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">为了实现<a class="ae kl" href="https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/#:~:text=A%20reverse%20proxy%20is%20a,security%2C%20performance%2C%20and%20reliability." rel="noopener ugc nofollow" target="_blank">反向代理</a>，我使用了<a class="ae kl" href="https://pkg.go.dev/net/http/httputil#ReverseProxy" rel="noopener ugc nofollow" target="_blank"> httputil包</a>——我实现它的主要目的是提供<a class="ae kl" href="https://www.nginx.com/resources/glossary/load-balancing/" rel="noopener ugc nofollow" target="_blank">负载平衡</a>。</p><p id="7421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了以<a class="ae kl" href="https://en.wikipedia.org/wiki/Round-robin_tournament" rel="noopener ugc nofollow" target="_blank">循环方式</a>实现客户端请求路由，我做了基本的数学计算，计算获取请求的数量，并对服务注册列表的长度做了一个模块化操作，这样我就可以轻松地找到后端并代理请求。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="ea99" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">登记员</h1><p id="41b4" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我用了<a class="ae kl" href="https://www.geeksforgeeks.org/time-tick-function-in-golang-with-examples/" rel="noopener ugc nofollow" target="_blank">时间。勾选</a>表示在特定时间间隔(默认为3秒)之间执行轮询。在每一个节拍，代码使用官方docker go SDK<a class="ae kl" href="https://pkg.go.dev/github.com/docker/docker/client" rel="noopener ugc nofollow" target="_blank">运行<code class="fe lh li lj lk b">docker ps -a</code>。<em class="ng">(我使用了-a，因为我需要知道哪些容器是downstate如果是这样，我从我们的服务注册列表中删除不健康的容器IP和端口)。</em>如果一个新的容器被添加并处于运行状态，检查它是否已经存在于服务注册表中；否则，将其地址添加到服务注册表中。</a></p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="b2f3" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">服务注册中心</h1><p id="7665" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">这是一个非常基本的结构片，由于有了<code class="fe lh li lj lk b"><a class="ae kl" href="https://pkg.go.dev/sync#RWMutex" rel="noopener ugc nofollow" target="_blank">sync.RWMutex</a></code>，它具有并发访问的安全性，如上所述，它保存了所有健康的后端地址列表。该列表由注册商每3秒更新一次。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="2cb5" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">反馈:</h1><h2 id="01cc" class="nh mc iq bd md ni nj dn mh nk nl dp ml jy nm nn mp kc no np mt kg nq nr mx ns bi translated">1-使用Docker事件API代替时间池来观察容器:</h2><p id="7342" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我使用基本的时间池(每3秒一次)来跟踪新启动的或死亡的容器。通过这样做，我可以保持我的服务注册是最新的。</p><p id="d10c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据收到的反馈，最好使用<code class="fe lh li lj lk b">docker events api</code>来达到这个目的。多亏了这个API，我可以从docker服务器获得实时更新。</p><p id="5953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是这样实现的。(<a class="ae kl" href="https://github.com/Abdulsametileri/simple-service-discovery/commit/5556fce20c9b9206848a65a421bda13fdcf2089d" rel="noopener ugc nofollow" target="_blank">提交</a>)</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c19f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lh li lj lk b">Init() error</code>一次性获得初始运行容器的方法。</p><p id="02e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lh li lj lk b">Observe()</code>方法中，我使用特殊的过滤器来观察事件，比如图像名称等。</p><p id="8605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用docker API客户端返回的通道监听事件；当一个新事件到来时，我可以根据它的有效负载更新服务注册中心。</p><h2 id="c2fe" class="nh mc iq bd md ni nj dn mh nk nl dp ml jy nm nn mp kc no np mt kg nq nr mx ns bi translated">2-使用原子。值而不是同步。互斥（体）…</h2><p id="84eb" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我使用<code class="fe lh li lj lk b">sync.Mutex</code>来控制服务注册中心的读写。但是当然，使用它也有不好的一面。它在服务注册中心变化期间阻止新的代理连接。</p><p id="a51f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据另一个反馈，<em class="ng">“一个高级的技巧是使用</em> <code class="fe lh li lj lk b"><a class="ae kl" href="https://pkg.go.dev/sync/atomic#Value" rel="noopener ugc nofollow" target="_blank">sync/atomic.Value</a></code> <em class="ng">，构造一个新的查找表(写时复制是可以的)，然后消费者可以在任何时候加载那个值，作为一个不可变的查找快照，就像他们加载的那一刻一样。”</em></p><p id="7659" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我如下重构了我的服务注册中心。(<a class="ae kl" href="https://github.com/Abdulsametileri/simple-service-discovery/commit/6bccef2bd0156f123af907aecb8923e349f0d710" rel="noopener ugc nofollow" target="_blank">提交</a>)</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="a3da" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">源代码</h1><p id="9000" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/Abdulsametileri/simple-service-discovery" rel="noopener ugc nofollow" target="_blank">https://github.com/Abdulsametileri/simple-service-discovery</a></p><h1 id="a566" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">参考</h1><p id="5126" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">[1]微服务架构符合原则、实践和文化</p><p id="d4bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]Java中的微服务模式示例</p></div></div>    
</body>
</html>