<html>
<head>
<title>Concurrent Processing in .NET 6 with System.Threading.Channels (Bonus: Interval Trees)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的并发处理。NET 6带系统。线程通道(奖励:间隔树)</h1>
<blockquote>原文：<a href="https://itnext.io/concurrent-processing-in-net-6-with-system-threading-channels-bonus-interval-trees-441b7539b5d1?source=collection_archive---------0-----------------------#2022-11-06">https://itnext.io/concurrent-processing-in-net-6-with-system-threading-channels-bonus-interval-trees-441b7539b5d1?source=collection_archive---------0-----------------------#2022-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通道是一种简化并发执行和数据管道化的构造，通常被吹捧为Go的主要吸引力之一。但是你知道吗？NET也内置了对通道的支持？</p><p id="70f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在构建处理大量数据的应用程序，或者需要在聚合结果的同时与多个API进行交互，那么使用通道可以提高应用程序的整体吞吐量和响应能力，因为它允许您在合并结果和/或以流的形式执行后处理的同时并发执行这些API调用。</p><p id="cdce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何在C# 10中使用通道。NET 6以及使用内置的<code class="fe kl km kn ko b"><strong class="jp ir">System.Threading.Channels</strong></code>实现并发处理是多么容易。</p><p id="7a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想跟进回购，请点击此处查看:</p><div class="kp kq gp gr kr ks"><a href="https://github.com/CharlieDigital/dn6-channels" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab fo"><div class="ku ab kv cl cj kw"><h2 class="bd ir gy z fp kx fr fs ky fu fw ip bi translated">GitHub-Charlie digital/dn6-channels:演示dotnet 6通道用于…</h2><div class="kz l"><h3 class="bd b gy z fp kx fr fs ky fu fw dk translated">通道是一种结构，它简化了数据的并发执行和流水线操作，而不使用基于锁的…</h3></div><div class="la l"><p class="bd b dl z fp kx fr fs ky fu fw dk translated">github.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg lh ks"/></div></div></a></div></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="5ab3" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用案例</h1><p id="4924" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">首先，假设我们正在构建一个日历协调应用程序。一个用户有两个或多个日历(如Google、Outlook和iCloud Calendar ),我们希望从中读取并在该用户的所有日历中找到冲突事件。</p><p id="6f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一种方法是简单地循环每个日历并收集所有事件:</p><pre class="ms mt mu mv gt mw ko mx my aw mz bi"><span id="615f" class="na lq iq ko b gy nb nc l nd ne"># Pseudo code:<br/><br/># Use an interval tree to hold our events and detect conflicts<br/>var <strong class="ko ir">interval_tree</strong> = new IntervalTree()<br/><br/>do {<br/>  # API calls to get the google events; 3s<br/>} while (<strong class="ko ir">has_more_google_events</strong>)<br/><br/>do {<br/>  # API calls to get the outlook events; 4s<br/>} while (<strong class="ko ir">has_more_outlook_events</strong>)<br/><br/>do {<br/>  # API calls to get the iCloud events; 3s<br/>} while (<strong class="ko ir">has_more_icloud_events</strong>)</span><span id="14e4" class="na lq iq ko b gy nf nc l nd ne"># Requires 10s if executed sequentially!</span></pre><p id="bbaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用一个<code class="fe kl km kn ko b"><a class="ae ng" href="https://github.com/mbuchetics/RangeTree" rel="noopener ugc nofollow" target="_blank">IntervalTree</a></code>数据结构作为一种机制，将事件表示为时间间隔，这样我们就可以很容易地查询哪里有冲突。根据文件:</p><blockquote class="nh ni nj"><p id="ae09" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">查询需要<code class="fe kl km kn ko b">O(log n + m)</code>时间，<code class="fe kl km kn ko b">n</code>为间隔总数，<code class="fe kl km kn ko b">m</code>为报告结果数。建造需要<code class="fe kl km kn ko b">O(n log n)</code>时间，存储需要<code class="fe kl km kn ko b">O(n)</code>空间。</p></blockquote><p id="8dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们从不同的日历中检索到所有的事件，这给了我们一个非常有效的检查重叠的方法。</p><p id="1b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种串行检索方法的问题在于<em class="nk">从提供者处检索事件的每个API调用都是I/O绑定的</em>；换句话说，大部分时间将会花在网络上进行API调用，而这样做意味着我们的程序必须花费大量时间在网络上等待。</p><p id="0c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果调用平均花费<code class="fe kl km kn ko b">[3s, 4s, 3s]</code>，那么顺序处理这个操作的总时间是10秒。但是，如果我们可以同时执行<em class="nk">和</em>，我们的总操作时间将更接近4s。</p><p id="02a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么这很重要？在无服务器的环境中，计费通常是通过vCPU/秒等计算/时间指标产生的。因此，如果能够在更短的时间内执行相同的任务，尤其是不会给CPU带来压力的I/O受限任务，如HTTP API调用，那么通过实现更高的吞吐量(更不用说对最终用户交互的更快响应)，就可以节省运营成本。</p><p id="a9f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">。NET提供了许多不同的选项来同步这种并发执行，例如<code class="fe kl km kn ko b"><a class="ae ng" href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1?view=net-7.0" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">ConcurrentQueue</strong></a></code>或直接使用锁原语(如互斥体或信号量)来控制对共享资源(间隔树)的访问，但是今天让我们来看看一个使用<code class="fe kl km kn ko b"><a class="ae ng" href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels?view=net-6.0" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">System.Threading.Channels</strong></a></code> <strong class="jp ir"> </strong>的<em class="nk">高级生产者/消费者抽象</em>，它提供了一个易于使用的范例来管理并发执行流的同步。</p><h1 id="5acb" class="lp lq iq bd lr ls no lu lv lw np ly lz ma nq mc md me nr mg mh mi ns mk ml mm bi translated">模仿日历API</h1><p id="dfdb" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了模拟这一点，我们将创建一组简单的模拟提供程序来代替从Google Calendar、Outlook和Apple iCloud Calendar返回事件页面的实际API调用(在这种情况下没有实际的API调用，因为这需要设置OAuth令牌！).</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nt"><img src="../Images/6c702d0446709a87d4344c849c104f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdGbPr3oDfk6psmce0IzbQ.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">模拟一个延迟，然后将我们为提供者提供的事件集作为一组页面进行循环，就好像我们是从API中提取的一样。</figcaption></figure><p id="8995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉C#，<code class="fe kl km kn ko b"><strong class="jp ir">Task&lt;&gt;</strong></code>相当于TypeScript中的<code class="fe kl km kn ko b"><strong class="jp ir">Promise&lt;&gt;</strong></code>(或者只是JavaScript中的<code class="fe kl km kn ko b"><strong class="jp ir">Promise</strong></code>)；如果你想了解JavaScript、TypeScript和C#有多相似，请查看以下报告:</p><div class="kp kq gp gr kr ks"><a href="https://github.com/CharlieDigital/js-ts-csharp" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab fo"><div class="ku ab kv cl cj kw"><h2 class="bd ir gy z fp kx fr fs ky fu fw ip bi translated">GitHub-Charlie digital/js-ts-cs harp:一个展示C# 10函数技术的资源库…</h2><div class="kz l"><h3 class="bd b gy z fp kx fr fs ky fu fw dk translated">这个库旨在突出C#中可用的各种功能技术。点击此处阅读更多内容…</h3></div><div class="la l"><p class="bd b dl z fp kx fr fs ky fu fw dk translated">github.com</p></div></div><div class="lb l"><div class="oe l ld le lf lb lg lh ks"/></div></div></a></div><p id="e7a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于模拟目的，我们的每个提供者都创建了一个事件列表，我们将对其进行分页:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi of"><img src="../Images/ed1ed4bda107aa33fc13724ef4ef6719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDVlXUPvoeqh7faE6Pb_xg.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">模拟在3个独立的API调用中返回3页事件。为了概念上的清晰，我将任务分成了“早上”、“中午”和“晚上”几组。</figcaption></figure><p id="205b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将导致在对<code class="fe kl km kn ko b"><strong class="jp ir">GetCalendarEventsAsync</strong></code>的调用中返回3“页”的数据。</p><p id="80f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(您可以轻松地派生出代码并对其进行试验，看看不同的时间表会如何产生冲突。)</p><h1 id="a7ad" class="lp lq iq bd lr ls no lu lv lw np ly lz ma nq mc md me nr mg mh mi ns mk ml mm bi translated">并发执行</h1><p id="d778" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">该应用程序的核心是一组并发调用的简单设置，这些调用将使用一个<code class="fe kl km kn ko b"><strong class="jp ir">System.Threading.Channel</strong></code>在并发执行和我们调度器中冲突检查器的聚合之间进行通信。</p><p id="be1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从创建渠道开始:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi og"><img src="../Images/d17d9494bcfd6a8d79ef93e414a42a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvA0Ganh14u2Ig1G8WEo5g.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">注意，我们的通道是强类型的——它接受<strong class="bd lr"> CalendarEvent </strong>实例</figcaption></figure><p id="08bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们立即开始我们的<code class="fe kl km kn ko b">Scheduler</code>:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oh"><img src="../Images/6a5fa9ccd3cca1b989e45aba33147fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO63ZACh1nY9sz6cooOFWA.png"/></div></div></figure><p id="e96b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并为三个日历中的每一个设置我们的并发任务，这三个日历在通道的生产者端传递—<code class="fe kl km kn ko b">writer</code>:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oi"><img src="../Images/eae9a8df1ddd9b33a1b243e163057820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KTvQxEC_2U9q5Yin6AvDbA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">在第3、7和11行，我们将编写器传递给提供者，这样当我们同时检索事件时，它们可以写入通道。</figcaption></figure><p id="af96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码设置了我们的并发调用；每个日历提供者都获得一个对我们的<code class="fe kl km kn ko b"><strong class="jp ir">writer</strong></code>的引用。</p><p id="a319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们等待所有提供程序完成，然后向我们的通道发出信号，表示写入已完成(我们已经从日历中获取了所有事件):</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oj"><img src="../Images/592548c1847c7f1ecfa9de5236325416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9eunbF28lSxhV57g9zR7A.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">该通道包括一个内置的从编写器到读取器的信号机制。</figcaption></figure><p id="629e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们等待调度程序完成:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8286aba91b3d2a6433cbd13defec897d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*w5bI8YoTq7oe219LqN9sXA.png"/></div></figure><h1 id="7741" class="lp lq iq bd lr ls no lu lv lw np ly lz ma nq mc md me nr mg mh mi ns mk ml mm bi translated">输出</h1><p id="ea4c" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在我们的示例中，我们将获得以下输出:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/b7363ebe3ffc11300a235c1a951dee97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*KHDQJFTU7QUvutrTLDKIxA.png"/></div></figure><p id="d1fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，尽管我们总共运行了12次调用(最后一组调用返回0个结果，表示数据集结束),并且随机休眠了1秒，但我们的执行仅用了2.566秒就完成了(在这种情况下)！非常酷，几乎没有任何工作，使它并发！</p><p id="c33c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看我们实际上是如何使用通道的。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="9566" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">制作方</h1><p id="e125" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这是<em class="nk">将</em>写入通道的一面。换句话说，当我们进行API调用和检索事件页面时，我们希望通过通道将这些事件推送到调度程序。</p><p id="d304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出乎意料的简单:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi om"><img src="../Images/385967796c78f7385f1d7452ef998b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yimsBwCfpWS0VTz5vcArRA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">第14行是我们编写日历事件并将其推送到频道的地方。</figcaption></figure><p id="69f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们获取事件时，我们只需使用writer end将它们写入通道。我们的通道甚至是<em class="nk">强类型的:</em></p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi on"><img src="../Images/8bde14548b92b16626cfcd9953898858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iJ40XHg4lj3S_22JSKirdA.gif"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">请注意，我们的通道期望编写一个CalendarEvent实例。</figcaption></figure><h1 id="49ac" class="lp lq iq bd lr ls no lu lv lw np ly lz ma nq mc md me nr mg mh mi ns mk ml mm bi translated">消费者方面</h1><p id="e061" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这是<em class="nk">从通道读取</em>的一面。在这种情况下，当我们的日历事件提供者进行API调用并返回结果并将它们写入通道时，我们将使用<code class="fe kl km kn ko b"><strong class="jp ir">Scheduler</strong></code>从通道中读取并检查冲突。</p><p id="d67e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它也出奇的简单:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oo"><img src="../Images/05f19ab84c0d95c409733185ef49907c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRT6pE4rTM5AX4w86AxmUA.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">第3-4行是我们与渠道互动的地方。在第10行，我们将事件添加到间隔树中，然后在第13行和第15行进行测试，看看在间隔中是否有不止一个事件。</figcaption></figure><p id="d92c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！</p><p id="5d04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对<code class="fe kl km kn ko b">writer.Complete()</code>的调用向读取端发出信号，表明所有消息都已写入通道，我们可以退出循环。</p><p id="3913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像写端一样，读端也是<em class="nk">强类型</em>，所以我们确切地知道我们从通道中得到什么。</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi on"><img src="../Images/549734ad061774cfbda28af2fa89e2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dlkXOIa0d_FbCRRjGe_fZQ.gif"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">强类型，在读取端也有完整的智能感知。</figcaption></figure><p id="9bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ng" href="https://en.wikipedia.org/wiki/Interval_tree" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">间隔树</strong> </a>是一个很好的奖励，通过简单地将事件添加到树中，然后查询树以查看给定间隔内是否有不止一个事件，可以非常容易地检测重叠。</p><p id="885a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几乎没有任何额外的努力或复杂性，我们已经编写了一个日历调度冲突检测引擎，它可以并发执行，并从多个端点检索事件以检测冲突！</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h1 id="cca9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">包裹</h1><p id="ea2d" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们只是触及了渠道的表面。创建复杂的、多生产者和多消费者的场景是可能的；多级数据处理流水线；并使用通道而不是基于锁的同步技术实现其他高吞吐量场景。</p><p id="be08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ng" href="https://michaelscodingspot.com/performance-of-producer-consumer/" rel="noopener ugc nofollow" target="_blank"> Michael Shpilt撰写了一篇精彩的文章，介绍了中不同同步技术的性能。NET </a>:</p><figure class="ms mt mu mv gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi op"><img src="../Images/9714a88db12496bb3c6d111a4211c68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPV9gbPFYXTEHA8YXNJ7-Q.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">处理10万个作业；查看迈克尔的文章了解更多细节。</figcaption></figure><p id="954b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(需要注意的是，<a class="ae ng" href="https://github.com/dotnet/corefx/blob/master/src/System.Threading.Channels/src/System/Threading/Channels/UnboundedChannel.cs#L21" rel="noopener ugc nofollow" target="_blank">内部实现的</a> <code class="fe kl km kn ko b"><a class="ae ng" href="https://github.com/dotnet/corefx/blob/master/src/System.Threading.Channels/src/System/Threading/Channels/UnboundedChannel.cs#L21" rel="noopener ugc nofollow" target="_blank">Channel</a></code> <a class="ae ng" href="https://github.com/dotnet/corefx/blob/master/src/System.Threading.Channels/src/System/Threading/Channels/UnboundedChannel.cs#L21" rel="noopener ugc nofollow" target="_blank">实际上是一个</a> <code class="fe kl km kn ko b"><a class="ae ng" href="https://github.com/dotnet/corefx/blob/master/src/System.Threading.Channels/src/System/Threading/Channels/UnboundedChannel.cs#L21" rel="noopener ugc nofollow" target="_blank">ConcurrentQueue</a></code>)</p><p id="a862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b"><strong class="jp ir">System.Threading.Channels</strong></code>是考虑使用的众多理由之一。NET和C#来完成后端或计算密集型任务。对于可以并发运行的I/O密集型任务，使用通道可以显著提高性能和吞吐量。</p><p id="08c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你感兴趣，看看这些过去的文章:</p><ul class=""><li id="251b" class="oq or iq jp b jq jr ju jv jy os kc ot kg ou kk ov ow ox oy bi translated"><a class="ae ng" rel="noopener ugc nofollow" target="_blank" href="/the-case-for-c-and-net-72ee933da304"><strong class="jp ir">c#与。NET </strong> </a></li><li id="0c9c" class="oq or iq jp b jq oz ju pa jy pb kc pc kg pd kk ov ow ox oy bi translated"><a class="ae ng" href="https://blog.devgenius.io/6-net-myths-dispelled-celebrating-21-years-of-net-652795c2ea27" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> 6。净神话被驱散</strong> </a></li><li id="ae5c" class="oq or iq jp b jq oz ju pa jy pb kc pc kg pd kk ov ow ox oy bi translated"><a class="ae ng" rel="noopener ugc nofollow" target="_blank" href="/getting-functional-with-c-6c74bf279616"> <strong class="jp ir">用C#实现功能</strong> </a></li></ul><p id="068d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您喜欢这篇文章，请关注并订阅电子邮件更新。在Twitter<a class="ae ng" href="https://twitter.com/chrlschn" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="nk">@ chrlschn</em></strong></a><strong class="jp ir"><em class="nk"/></strong>或<a class="ae ng" href="https://www.linkedin.com/in/charlescchen/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>；我很想收到你的来信！</p></div></div>    
</body>
</html>