<html>
<head>
<title>Map and Reduce — A Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地图和缩小-初级读本</h1>
<blockquote>原文：<a href="https://itnext.io/map-and-reduce-a-primer-9e18a6b7e587?source=collection_archive---------7-----------------------#2020-05-26">https://itnext.io/map-and-reduce-a-primer-9e18a6b7e587?source=collection_archive---------7-----------------------#2020-05-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/b860724d1dd5efa73e5f1118ac97c8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcNhQl7W-6MieDoNWFqzCQ.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">拉斯伯里还原法。作者照片。</figcaption></figure><div class=""/><div class=""><h2 id="b2f9" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">明智地使用map和reduce函数是一项核心技能，但很少有效地使用。</h2></div><p id="5044" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated"><code class="fe lu lv lw lx b">map</code>函数是由所有<code class="fe lu lv lw lx b">Iterable</code>对象(<code class="fe lu lv lw lx b">Arrays</code>、<code class="fe lu lv lw lx b">Sets</code>、<code class="fe lu lv lw lx b">Lists</code>等)提供的，它允许你遍历条目，对条目进行转换，并返回相应的转换后的条目集合。</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="106a" class="mg mh jj lx b gz mi mj l mk ml">export const VERBS = ['start', 'stop']<br/>export const ACTIONS = VERBS.<strong class="lx jk">map</strong>(verb =&gt; import(`acts/${verb}`))</span></pre><p id="0099" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">这对于很多事情来说都很方便，但是上面所说的并不是非常有用。要得到一个函数，你必须做这样的事情:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="f509" class="mg mh jj lx b gz mi mj l mk ml">import { VERBS, ACTIONS } from 'acts'</span><span id="6288" class="mg mh jj lx b gz mm mj l mk ml">export default function action(verb) {<br/>  const i = VERBS.indexOf(verb)<br/>  return ACTIONS[I]<br/>}</span></pre><p id="bafb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">更有用的是，如果你把<code class="fe lu lv lw lx b">VERBS</code>转换成一个对象，你可以用它来通过名字查找正确的<code class="fe lu lv lw lx b">action</code>。</p><p id="7832" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">一个<strong class="la jk">缩减器</strong>是一个函数，它接受一个累积值和下一个数组项，对它们做一些事情，然后返回新的累积值。</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="d28e" class="mg mh jj lx b gz mi mj l mk ml">array.reduce(reducer, init) // =&gt; some new array or object</span></pre><p id="7596" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">示例:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="724e" class="mg mh jj lx b gz mi mj l mk ml">export const VERBS = ['start', 'stop']<br/>export const ACTIONS = VERBS.reduce((acc, verb) =&gt; {<br/>  acc[verb] = import(`acts/${verb}`)<br/>  return acc<br/>}, {})</span></pre><p id="e77e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">因此，对于每一个<code class="fe lu lv lw lx b">verb</code>，你都要在提供的<code class="fe lu lv lw lx b">{}</code>中添加一个<code class="fe lu lv lw lx b">key:value</code>对，产生:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="b460" class="mg mh jj lx b gz mi mj l mk ml">{<br/>  start: import('acts/start'),<br/>  stop: import('acts/stop')<br/>}</span></pre><p id="58ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">将上面的<code class="fe lu lv lw lx b">action</code>功能变为:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="0bb5" class="mg mh jj lx b gz mi mj l mk ml">import { ACTIONS } from 'acts'</span><span id="3802" class="mg mh jj lx b gz mm mj l mk ml">export default function action(verb) {<br/>  return ACTIONS[verb]<br/>}</span></pre><h2 id="9dc4" class="mg mh jj bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">一个六个，另一个半打</h2><p id="e81f" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt in bi translated">有一种观点认为，如果将'<em class="nj">数组查找</em>'策略与'<em class="nj">使其成为对象</em>'策略进行比较，两者的代码行数大致相同。两者的意图都很清楚。</p><p id="58e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">为什么将<code class="fe lu lv lw lx b">VERBS</code>数组<code class="fe lu lv lw lx b">reduce</code>到一个对象比将其<code class="fe lu lv lw lx b">map</code>到另一个数组更好？</p><p id="caf5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">这个问题的答案在于优化那些消费数据的人。</p><p id="1c2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">在对象中查找<code class="fe lu lv lw lx b">key</code>是一种语言特性，因此你可以依赖它进行高度优化。通过<code class="fe lu lv lw lx b">import</code>对<code class="fe lu lv lw lx b">actions</code>的实际设置通常是每个应用一次<em class="nj">，或者至少每个异常状态变化</em>一次<em class="nj">。这是一个常识性概念的直接应用，即你<em class="nj">索引你的文章</em>，而不是把工作推给你的读者。</em></p><figure class="ly lz ma mb gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nk"><img src="../Images/076e312b11b380ba2b96f1623898de4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxPJ84yqz2DeyvBIrYJDlA.jpeg"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">索引你的写作。收拾餐具时要分类。</figcaption></figure><p id="ed1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">这也是为什么在打开洗碗机时，我会确保汤勺先放在顶端，甜点勺最后放在顶端。我可以在黑暗中瞬间找回正确的勺子。</p><p id="8ea2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">我用大大小小的叉子也是这样，但奇怪的是，我从来没有觉得有必要用刀子这样做。</p><h2 id="3752" class="mg mh jj bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">承诺呢？</h2><p id="ca80" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt in bi translated">你可以使用<code class="fe lu lv lw lx b">map</code>和<code class="fe lu lv lw lx b">reduce</code>来创建<code class="fe lu lv lw lx b">Promises</code>的集合。让我们假设我们有一个带有异步<code class="fe lu lv lw lx b">findByName</code>函数的<code class="fe lu lv lw lx b">Person</code>数据库模型，并且我们想要编写一个异步函数<code class="fe lu lv lw lx b">people</code>，它接受一个<code class="fe lu lv lw lx b">names</code>数组并进行查找，然后返回相关的<code class="fe lu lv lw lx b">Person</code>记录。</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="c2c5" class="mg mh jj lx b gz mi mj l mk ml">import { Person } from 'models'</span><span id="e51f" class="mg mh jj lx b gz mm mj l mk ml">export default async function people(names) {<br/>  return names.map(Person.findByName)<br/>}</span></pre><p id="8292" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">因为是一个<code class="fe lu lv lw lx b">async</code>函数，<code class="fe lu lv lw lx b">people</code>返回的不是一个<code class="fe lu lv lw lx b">Person</code>记录的数组，而是一个<em class="nj">将</em>解析为一个未解析<code class="fe lu lv lw lx b">Promises</code>的数组的<code class="fe lu lv lw lx b">Promise</code>，每个数组最终<em class="nj">将</em>解析为一个<code class="fe lu lv lw lx b">Person</code>。这是一个很常见的bug。</p><p id="17f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">下面就不行了，虽然看起来没错。</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="aadb" class="mg mh jj lx b gz mi mj l mk ml">import people from './people'</span><span id="8fdf" class="mg mh jj lx b gz mm mj l mk ml">const summarise = ({ id, name, email }) =&gt; ({ id, name, email })</span><span id="bc6f" class="mg mh jj lx b gz mm mj l mk ml">async function meAndMyFriends(me, names) {<br/>  const friends = (await people(names)).map(summarise)<br/>  return { ...me, friends }<br/>}</span></pre><p id="727b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">这里的<code class="fe lu lv lw lx b">friends</code>数组将是一个:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="216c" class="mg mh jj lx b gz mi mj l mk ml">{<br/>  id: undefined,<br/>  name: undefined,<br/>  email: undefined<br/>}</span></pre><figure class="ly lz ma mb gu iw"><div class="bz fq l di"><div class="nl nm l"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">朱利叶斯·萨姆纳·米勒在20世纪80年代游历了澳大利亚，在他去世前的一段时间里，作为一种特殊的客串明星，在我的学校教了几堂物理课。他的电视节目“为什么会这样？”在我这个年龄的孩子中很受欢迎。就个人而言，他是一个表演大师，一个神话般的科学传播者，也可能是我见过的最了不起的教育家。我从来不会问自己“为什么”，而不加上“是这样吗？”</figcaption></figure><h2 id="1ab8" class="mg mh jj bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">为什么会这样呢？</h2><p id="3479" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt in bi translated">因为一个<code class="fe lu lv lw lx b">Promise</code>的实例没有<code class="fe lu lv lw lx b">id</code>、<code class="fe lu lv lw lx b">name</code>或<code class="fe lu lv lw lx b">email</code>。</p><p id="e232" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">为了解决这个问题，<code class="fe lu lv lw lx b">people</code>函数需要首先将<code class="fe lu lv lw lx b">names.map</code>包装在<code class="fe lu lv lw lx b">Promise.all</code>中，其中<em class="nj">将<code class="fe lu lv lw lx b">Promises</code>的数组</em>解析为保存结果数组的单个<code class="fe lu lv lw lx b">Promise</code>:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="53e0" class="mg mh jj lx b gz mi mj l mk ml">import { Person } from 'models'</span><span id="b152" class="mg mh jj lx b gz mm mj l mk ml">export default async function people(names) {<br/>  return Promise.all(names.map(Person.findByName))<br/>}</span></pre><p id="6442" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">现在<code class="fe lu lv lw lx b">meAndMyFriends</code>函数将返回预期值。</p><h2 id="a20b" class="mg mh jj bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">用<code class="fe lu lv lw lx b">reduce</code>连载承诺。</h2><p id="aa42" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt in bi translated">当您有一个<code class="fe lu lv lw lx b">Promises</code>数组，并且您需要确保一次只调用一个时，该怎么办？例如，您可能正在调用一个远程API，它需要一个‘nonce’(不仅仅是恋童癖者的俚语，也是计算机科学术语，表示一个在API调用之间必须递增的数字。去想想。)</p><p id="5ed9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">您可以使用<code class="fe lu lv lw lx b">reduce</code>来序列化<code class="fe lu lv lw lx b">Promises</code>的数组，迫使它们一个接一个地运行。</p><p id="6836" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">从一个已经<em class="nj">解析的</em> <code class="fe lu lv lw lx b">Promise</code>开始，您需要确保下一个<code class="fe lu lv lw lx b">Promise</code>(第一个将是您的数组中的第一个)不会运行，直到前一个运行:</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="0142" class="mg mh jj lx b gz mi mj l mk ml">const inSequence = (previous, next) =&gt; previous.then(() =&gt; next);</span><span id="e525" class="mg mh jj lx b gz mm mj l mk ml">export default async function serialise(promises) {<br/>  return promises.reduce(inSequence, Promise.resolve())<br/>}</span></pre><p id="fe1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">如果你有一个<code class="fe lu lv lw lx b">boolean</code>值的数组，你想累加它们<code class="fe lu lv lw lx b">and</code>呢？《T4》在这方面也很棒。</p><pre class="ly lz ma mb gu mc lx md me aw mf bi"><span id="ff36" class="mg mh jj lx b gz mi mj l mk ml">function absoluteTruth(truths) {<br/>  return truths.reduce((acc, truth) =&gt; acc &amp;&amp; truth, true)<br/>}</span></pre><h2 id="2187" class="mg mh jj bd mn mo mp dn mq mr ms dp mt lh mu mv mw ll mx my mz lp na nb nc nd bi translated">链接</h2><ul class=""><li id="c7c7" class="nn no jj la b lb ne le nf lh np ll nq lp nr lt ns nt nu nv bi translated"><code class="fe lu lv lw lx b">Array.map</code>—<a class="ae nw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array/map</a></li><li id="b5cc" class="nn no jj la b lb nx le ny lh nz ll oa lp ob lt ns nt nu nv bi translated"><code class="fe lu lv lw lx b">Array.reduce</code>—<a class="ae nw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Array/Reduce</a></li><li id="ab2d" class="nn no jj la b lb nx le ny lh nz ll oa lp ob lt ns nt nu nv bi translated">朱利叶斯·萨姆纳·米勒—<a class="ae nw" href="https://en.wikipedia.org/wiki/Julius_Sumner_Miller" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Julius_Sumner_Miller</a></li><li id="d322" class="nn no jj la b lb nx le ny lh nz ll oa lp ob lt ns nt nu nv bi translated">拉斯伯里酱—<a class="ae nw" href="https://www.allrecipes.com/recipe/241308/fresh-raspberry-sauce/" rel="noopener ugc nofollow" target="_blank">https://www . all recipes . com/recipe/241308/fresh-raspberry-Sauce/</a></li></ul><p id="2c3e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi">—</p><p id="f5f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt in bi translated">像这样但不是订户？你可以通过<a class="ae nw" href="https://davesag.medium.com/membership" rel="noopener">davesag.medium.com</a>加入来支持作者。</p></div></div>    
</body>
</html>