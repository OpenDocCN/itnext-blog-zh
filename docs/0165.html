<html>
<head>
<title>Redux Saga — How to make real good things with generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">redux Saga——如何用发电机做出真正的好东西</h1>
<blockquote>原文：<a href="https://itnext.io/redux-saga-how-to-make-real-good-things-with-generators-7d91a8916f0e?source=collection_archive---------0-----------------------#2017-09-25">https://itnext.io/redux-saga-how-to-make-real-good-things-with-generators-7d91a8916f0e?source=collection_archive---------0-----------------------#2017-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b9b0d916c8c9f648caee228a8dc599b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3a_mDHOtFm_PvgyUBdiHjw.png"/></div></div></figure><h1 id="65bf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">请系好安全带……CQRS</h1><p id="5a4f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">术语saga通常用于CQRS(命令查询责任分离)模式。更多信息你可以在这里找到<a class="ae lu" href="https://martinfowler.com/bliki/CQRS.html" rel="noopener ugc nofollow" target="_blank"/>。一般来说，术语<em class="lv"> saga </em>指的是在有界上下文和集合之间协调和路由消息的代码。但是就Redux Saga而言，我们可以简单地将其命名为<em class="lv">进程管理器</em>。它完全涵盖了我们需要知道的关于传说的所有内容。关于术语定义的更多信息可以从原始论文“<a class="ae lu" href="http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noopener ugc nofollow" target="_blank"> Sagas </a>”中找到。</p><p id="1097" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">当您实现CQRS模式时，您通常会想到在系统内交换信息的两种类型的消息:<em class="lv">命令</em>和<em class="lv">事件</em>。<em class="lv">命令</em>是请求系统执行一些任务或动作。命令通常由一个接收者执行并且只执行一次。<em class="lv">事件</em>是通知。他们通知相关方发生了一些事情。他们可以有多个订户。</p><p id="3f38" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们描述一下在网上商店订购一些产品。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/646e535e213dd7234701ab72f07050fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*kx4-b3yWZjZbSXogAMZQWg.png"/></div></figure><p id="6725" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在一个复杂的系统中，可能有一些涉及多个集合的业务流程。在这样的系统中，不同类型的多个消息由参与的集合交换。例如，在商店订购一些商品，你可以按照图(1-8)中的步骤进行，以获得成功的结果。他们必须通力合作，才能让顾客完成购买。您可以考虑使用如此复杂的解决方案的开销。对于一些小的业务流程来说确实如此。但是，当您拥有数十个聚合和大量消息时，好处就变得更加明显了。</p><p id="e931" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir">何时使用流程管理器？</strong>当您有大量事件和命令，很难作为聚合之间点对点交互的集合进行管理时。当您希望更容易地修改系统中的消息路由时。Process manager提供了定义所有路由规则的单一事实来源。</p><p id="30ac" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir">什么时候不用流程经理？</strong>当你拥有数量有限的少量聚合消息时。</p><p id="6097" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">不应该将业务逻辑放在流程管理器中。所有的业务逻辑都属于具体的聚合类型。</p><h1 id="c590" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> Thunk和Saga </strong></h1><p id="e22f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在Redux应用程序中有两种常见的处理副作用的方法。Thunk 是一个函数，它已经拥有了执行所需的一切。在Redux中，动作是用简单的对象定义的。而<em class="lv"> thunk </em>的主要好处是它允许发送一个函数来代替。因此，您已经能够编写一些逻辑来立即执行并分派其他操作。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1408" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这只是导出一个返回商店的函数，我们将把它添加到Provider中。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9bda" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在这个动作创建器文件中，我们有三个简单的动作和一个将通过<em class="lv"> thunk </em>中间件管理的动作。根据获取结果<code class="fe mi mj mk ml b">fetchOrganization</code>动作函数将自己分派<code class="fe mi mj mk ml b">FAIL</code>或<code class="fe mi mj mk ml b">SUCCESS</code>动作。</p><p id="87f6" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这个解决方案对于一些小逻辑来说非常棒。但是对于更大的解决方案，你已经需要使用一些更强大的中间件。</p><h1 id="4cfa" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是佐贺</h1><p id="8049" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir">简短说几句关于佐贺的方法</strong>。佐贺只是一系列相连的故事。Saga是长期存在事务，可以写成一系列可以交错的事务。序列中的所有事务都成功完成，或者运行补偿事务来修改部分执行。补偿交易能够撤销或添加一些关于交易或其失败的信息。</p><p id="2a42" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Sagas使用yield关键字及其在函数中暂停执行的能力。因此，通过编写生成器，您只需编写完成操作所需的步骤。</p><p id="9cb8" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们从初始步骤开始，用<code class="fe mi mj mk ml b">npm install redux-saga</code>将其添加到项目中。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3b3c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">让我们用一些评论和解释来定义我们的<code class="fe mi mj mk ml b">fetchDataSaga</code>:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c519" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">因此，我们在中间件的系统中注册了我们的saga。这个传奇听着<code class="fe mi mj mk ml b">REQUEST_FETCH</code>的动作，并准备好按照自己的流程制造我们需要的一切，然后将数据取出并放入存储。在任何情况下，所有saga都被实现为生成器函数，生成redux-saga中间件的对象。产生的对象是一种指令，将由中间件以适当的方式解释。在第一个<code class="fe mi mj mk ml b">yield</code>之后，发生器暂停并等待来自环境的数据解析和命令，以继续saga，直到下一个<code class="fe mi mj mk ml b">yield</code>。</p><p id="280d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">Redux Saga内部的流程编排通过使用所谓的<em class="lv">效果</em>实现。每次我们在调用<code class="fe mi mj mk ml b">put</code>、<code class="fe mi mj mk ml b">take</code>、<code class="fe mi mj mk ml b">delay</code>等命令时，都会让出一些对象给外部环境，Saga知道如何处理这些指令。例如，<code class="fe mi mj mk ml b">put({ type: 'FETCH_DATA' })</code>的结果指示中间件分派<code class="fe mi mj mk ml b">FETCH_DATA</code>动作。</p><p id="3b47" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们之后有什么？通过只调度一个动作，我们执行复杂的异步流，并把有效负载发送到存储。是不是很神奇？这个流程也可以用测试来覆盖，以确保我们执行的一切都是正确的。</p><h1 id="d7eb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用测试覆盖流程</h1><p id="0dc8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如我们从生成器中已经知道的，每次我们用yield表达式调用对象时，我们都会得到格式为<code class="fe mi mj mk ml b">{value: ..., done: [true|false]}</code>的对象。最后一次调用将为我们返回<code class="fe mi mj mk ml b">{value: undefined, done: true}</code>。因此，记住这一点，我们将简单地迭代返回的生成器并检查生成的值。</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="c522" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">助手</h1><p id="576e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">redux-saga的所有通信都是通过helper effects实现的，它包装了内部函数，以便在调度一些特定动作时产生任务。</p><p id="23b9" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><code class="fe mi mj mk ml b">put</code>返回指示redux-saga调度put参数中提到的类型为的操作的普通对象</p><p id="8dfe" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><code class="fe mi mj mk ml b">call</code>调用函数并返回结果，结果将由redux-saga传回。</p><p id="ac23" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><code class="fe mi mj mk ml b">take</code>、<code class="fe mi mj mk ml b">takeEvery</code>、<code class="fe mi mj mk ml b">takeLatest</code>返回指示redux-saga开始监听系统中某个特定动作的普通对象。<code class="fe mi mj mk ml b">take</code>将只听一次，<code class="fe mi mj mk ml b">takeEvery</code>将听每一个动作，<code class="fe mi mj mk ml b">takeLatest</code>将只听最后一个并取消之前的指令。</p><p id="7951" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><code class="fe mi mj mk ml b">fork</code>用于产生多个内置助手的观察者，在后台观察多个英雄的动作。</p><p id="c4ba" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">要创建效果，可以使用<code class="fe mi mj mk ml b">redux-saga/effects</code>包中库提供的函数。</p><h1 id="8df4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">错误处理</h1><p id="8838" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以使用熟悉的<code class="fe mi mj mk ml b">try/catch</code>语法很容易地捕捉到saga中的错误。</p><p id="972d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">如果我们需要在我们的传奇中抛出错误，您可以使用<code class="fe mi mj mk ml b">.throw</code>方法来伪造错误。这将导致生成器中断当前流并执行catch块。</p><h1 id="ee40" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这个介绍的最终世界</h1><p id="5854" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">任何来自传奇的副作用总是由一些声明性的效果来完成。这给我们带来了一些很好的优势，比如容易测试。Saga将所有效果组合在一起，以实现自我描述和易于阅读的控制流。本文中只描述了最简单的一种流程。您还可以使用<code class="fe mi mj mk ml b">if</code>、<code class="fe mi mj mk ml b">while</code>和<code class="fe mi mj mk ml b">for</code>操作符来实现更复杂的流程。</p><p id="c672" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">通过这个简单的使用示例，我们获得了与<code class="fe mi mj mk ml b">redux-thunk</code>软件包相同的结果。但是已经大大提高了它的可测试性。</p></div></div>    
</body>
</html>