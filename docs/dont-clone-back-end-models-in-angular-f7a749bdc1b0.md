# 不要克隆有角度的后端模型

> 原文：<https://itnext.io/dont-clone-back-end-models-in-angular-f7a749bdc1b0?source=collection_archive---------0----------------------->

在前端，模型-视图-控制器范式已经被明确抛弃，取而代之的是模型-组件:这在所有现代框架中都是如此，但如果你看看从 AngularJS 到 Angular2+的演变，这在 Angular world 中尤其明显。

*MVC 在前端的不足的主要原因通常被认为是控制器的角色不明确，但是在这篇文章中我想关注这种不足的另一个方面:* ***模型在后端和前端的不同角色。***

![](img/6db2b53e2b87a189112fb4bb1d0d920b.png)

# **文章路线图**

本文的目标是展示如何将后端模型复制到 Angular 应用程序中会导致架构问题(通常，这样的问题是如何由前端的后端方法引起的)；我会强调弱点，展示模式，提出解决方案。

*因为这篇文章是关于 Angular 和 AngularJS 的，为了避免混淆，我总是把 Angular 称为“Angular 2+”；我将使用通用术语“Angular ”,不指定任何版本，仅当我打算讨论两个框架共有的通用概念时。*

下面是这篇文章的大致路线图:

1.  我将介绍后端和前端之间的**总体架构差异**
2.  在 Angular 的具体例子中，我将展示**不同抽象层次**之间的区别，从我们绑定到 DOM 的属性开始，直到后端模型:我将展示避免错误的最佳方式是如何**将这些抽象清晰地分开**
3.  我将展示几个简单的例子，说明将不必要的后端变量引入前端如何导致**冗余**并使角度应用程序容易出错
4.  我将展示后端返回的嵌套 JSON 的典型例子，我将展示这种 JSON 的 **naif AngularJS 实现**如何隐藏**意外的结构问题**
5.  我将在 Angular2+ 中提出基于**组件模式的嵌套 JSON 的不同实现，并展示其优势**
6.  我将重点介绍将数据从 API 传递到组件的最佳方式，并展示不管我们从后端接收的数据结构如何，决定前端的架构是多么重要
7.  我将提出一种不同的方法来用来自后端 API 的数据填充 Angular2+组件，通过使用在组件级实例化的**服务**
8.  我将简要地讨论向 API 发送“ */post* ”调用的最佳方式，同时仍然保持前端与后端的分离
9.  我将简要地展示前端模型的用例，它们具有在后端没有任何对应关系的属性

# **后端和前端之间固有的架构差异**

现在每个人都知道 MVC 不适合前端。许多人将此归咎于控制器(在关于控制器的好文章中，我可以推荐[这一篇](https://medium.freecodecamp.org/is-mvc-dead-for-the-frontend-35b4d1fe39ec)):但是 MVC 失败的更深层次的原因可能是因为 ***我们试图将后端架构应用于前端*** 。

但是后端和前端真的如此不同吗？

在我看来是的，它们是: ***在后端解决问题的方法与在前端解决问题的方法有着本质的不同。***

*   后端开发必须实现所涉及的 ***实体*** 的逻辑抽象表示，以便对于外部用户和应用，*能够在这些实体上执行操作，而不管上下文如何*
*   前端开发必须实现所涉及的 ***视图*** 的逻辑抽象表示，以便不仅*与用户*顺利交互，而且确保实现是**优化的**(因为它必须在浏览器上运行)和**可伸缩的** (因为客户端的需求在前端比在后端变化得更快)。

直到大约 2010 年，当单页面应用程序开始普及时，这种差异才变得重要起来:在单页面应用程序出现之前，前端只是由 CSS、HTML 和一些零星的 JavaScript 组成，前端开发被认为是一项不需要特定模式或指南的任务。

如果有人试图用前端的方法开发后端，会发生什么？他会试着推断实体的逻辑结构，只看它们在他必须开发的特定视图中是如何使用的；他将只为他需要做的事情创建一组功能，而不考虑这些功能是否会在实体的抽象逻辑中产生更深层次的后果:产生的后端将是 **naif** 和**不稳定**，每个人都同意这一点。

***现在，完全一样，如果我们把问题反过来，尝试用后端的方法开发前端，结果会是* naif *和*不稳定*。***

这个问题的一个方面当然是控制器在 MVC 中的角色不明确，正如已经提到的；但是*在我看来，一个更深层次和更隐蔽的架构缺失是当一个具有后端思维的开发者试图定义一个 JavaScript* ***模型*** *的结构，这些模型是他们的后端副本的精确克隆。*

# **后端和前端模型如何在角度上产生分歧**

后端和前端模型都是一个*抽象*，但这并不意味着它们必须相同: ***原因是它们是不同事物的抽象。***

这种差异的第一个明显的例子是，当后端模型包含前端中没有使用的内部属性时(反之亦然，前端模型可能包含与后端不相关的属性)。

但是在 Angular world 中，DOM 会随着应用程序状态的改变而自动更新，事情变得不那么简单了:我们所说的“*应用程序状态*”是什么意思？这种状态存储在哪里，它与模型有什么关系？

在 Angular2+中，应用状态存储在**组件**中；但是什么是真正的组件，它们如何与 DOM 交互？来自[angular 2+](https://angular.io/guide/template-syntax#html-attribute-vs-dom-property)中数据绑定技术的官方文档:

> 当您编写数据绑定时，您专门处理目标对象的属性和事件。[…]数据绑定的目标是 DOM 中的某个东西。根据绑定类型，目标可以是(element | component | directive)属性、(element | component | directive)事件或(很少)属性名。

所以， ***Angular2+的组件只不过是 DOM*** 的(自然)扩展:DOM 可以被视为由嵌套的原生元素和组件组成的分层树。让我们看一个例子:

当我们想要使用上面代码片段中定义的组件时，我们只需使用标识它的标签，传递输入变量“ *text* ”，就像它是一个普通的 HTML 属性一样:

当我们使用标记“ *text-in-paragraph* ”时，它看起来就像是一个常规的 DOM 元素:它确实可以被认为是一个 DOM 元素，因为它的行为方式完全相同(有一些扩展)。

例如，定制组件除了 DOM 之外还有一个特性就是*数据绑定*:

当我们将属性“ *text* ”括在括号内时，意味着里面传递的表达式对应父组件中的一个变量:当该变量的值发生变化时，Angular2+更新子组件并重新加载其模板。

实际 DOM 和组件之间的相似之处超出了这个简单的例子(例如，在 DOM 中，组件可以使用别名属性，这些属性绑定到具有不同名称的属性)，但是核心概念是组件可以被安全地视为 DOM 的扩展。

***更一般的，由嵌套的原生 DOM 元素、组件、指令及其所有公共属性组成的树，是 Angular2+提供的 DOM 的抽象。***

所以，回到后端和前端模型之间的区别:*DOM 在 Angular 中的扩展可以被认为是第三种抽象 *，一种* **DOM 模型** *，这又必须与两者不同。**

在 AngularJS 中，概念是相同的，但实现是不同的:负责保存绑定到 DOM 的变量的实体被称为**控制器**。尽管 AngularJS 控制器并不完全是 DOM 的扩展，但最佳实践仍然是将它们与模型(前端和后端)分开。

# **保持清晰分离的后端、前端和 DOM 模型**

我们只是区分了三个不同的抽象层:

1.  **后端模型**，保存实体的逻辑和一般抽象
2.  **前端模型**，它代表前端的一个实体(Angular2+中的*对应于 TypeScript 模型类*):这些模型中有许多与后端模型相似，但它们很少完全相同，另外在前端我们可能需要额外的实体来与用户交互
3.  **DOM 模型**，它抽象并扩展了 DOM(angular 2 中的*+它对应于组件类*)

***为了实现一个健康的、可伸缩的架构，这三个抽象必须保持清晰的分离。***

当粗心地用后端方法开发 Angular 应用程序时，您可能会在不同程度上混合这三种抽象，并带来各种副作用:

*   如果您*创建的前端模型是后端模型*的精确克隆，您很可能会遇到**冗余**和**难以维护的胖组件/控制器**的问题
*   如果你*将 DOM 直接绑定到一个前端模型*，你最终会产生一个**复杂的 HTML** ，你会冒**失去组件隔离**的风险，并且你会经历**不可预知的副作用**
*   如果您将 DOM 直接绑定到一个前端模型，这个前端模型是后端模型的精确克隆，那么您将会得到以上两点

本文的目的是强调混淆后端、前端和 DOM 模型所带来的风险，并提出通过保持清晰的分离来避免这些风险的模式。让我们从一些实际例子开始。

# **例子:后端模型带来了不必要的变量**

我们有一个用户模型，在后端用两个布尔属性表示，称为“*订阅*和“*确认*”。这些表示后端的两个内部状态，因此当且仅当两个布尔值都为真时，用户才被视为“ *pro* ”用户。

在前端，"*订阅*"和"*确认*"是不相关的，我们唯一需要知道的是用户是否是" *pro* "

然而，后端 API 返回一个用户 JSON，其中包括"*订阅的*"和"*确认的*"，因此，如果我们运行一个 AngularJS 应用程序，我们会尝试这样做:

这个实现很简单，但是它包含了潜在问题的种子，随着应用程序变大，这些问题会影响应用程序。

DOM 被绑定到表达式“ *isPro* ”，这不是 DOM 模型的属性，而是一个基于相应前端模型的两个变量动态计算其值的函数:这是一个潜在的性能风险，因为这样的函数必须在每个“ *$digest* ”循环中调用。

反过来，前端模型是后端模型的副本，因为变量" *subscribed* "和" *confirmed* "没有直接暴露在前端:每次我们想要处理" *user* "模型时，我们都必须处理这种冗余，这给应用程序增加了不必要的复杂性。

特别是，如果 API 希望我们在创建或修改用户时发送整个对象，那么前端不应该负责记住将“ *subscribed* ”和“ *confirmed* ”都附加到有效负载上:这应该由后端来完成。

从这个例子中得到的教训是: **w *当你设计一个前端模型时，你应该在包含来自后端的任何数据之前仔细考虑。***

我见过后端开发人员，他们只有在前端完全复制了后端模型的完整结构，有时甚至包括一组用 JavaScript 编写的单元测试时，才会感到舒服。这种复杂性是不合适的，因为它已经存在于它应该存在的后端。

# 关于表格的简要说明

表单是一个特别容易混合前端模型和 DOM 模型的例子，因为它们自动做很多事情，开发人员倾向于认为它们是“神奇的”(Angular 中的表单将输入绑定到您的数据，并随着框架的发展以更复杂的方式保持更新)。

让我们听听文件本身，其中有一个关于模型之间的区别的明确警告:

> 该组件必须将*数据模型*中的英雄值复制到*表单模型*中。
> 
> 有两个重要的含义:开发人员必须理解*数据模型*的属性如何映射到*表单模型的属性；并且*用户将流程从 DOM 元素更改为*表单模型*，而不是*数据模型*。
> 
> 表单控件从不更新*数据模型*。

在上面的引用中，“*数据模型*对应于我在本文中称之为前端模型的东西，而“*表单模型*对应于我称之为 DOM 模型的东西。

在这篇文章中，我有太多的事情要说，以至于没有足够的空间在 Angular 中给出绑定到表单的详细例子，你会在[文档](https://angular.io/guide/user-input)中找到很多。出于本文的目的，我只想说明 Angular 的表单是 DOM 的另一种扩展。

# **一个有意义的例子:具有嵌套子模型的后端模型**

这是我会一直坚持到文章结尾的例子，因为它是有争议的，有很多含义。我说“有争议”是因为，乍一看，将嵌套模型直接绑定到 DOM 似乎是一个自然的选择:但由此产生的体系结构在可伸缩性(以及性能，特别是在糟糕的情况下)方面可能会有不可预知的问题。

我想用的例子是一个有评论和回复的帖子；这是我们的 API 返回的 JSON 结构:

# 第一个 naif 实现(以 AngularJS 表示)

从这个 JSON 构造前端的最直接的方法是简单地将它绑定到 DOM，使用两个对应于注释和回复的嵌套循环。

我将使用 AngularJS 来展示这个实现，因为它不强制组件模式，并且更容易显示这个错误的方法看起来有多简单。我在这个例子中选择 AngularJS 的事实并不意味着在 AngularJS 中你必须使用非执行模式。

我们希望显示与帖子相关的评论和回复，并提供添加和删除评论和回复的可能性。这是控制器:

这是相应的模板，包含两个嵌套的“ *ng-repeat* ”指令循环。

这个实现没有什么特别的，如果你对 AngularJS 有点熟悉的话，你会毫无问题地理解它。我使用控制器作为名称空间，所以很明显这个例子与臭名昭著的[作用域汤](https://toddmotto.com/no-scope-soup-bind-to-controller-angularjs/)(这不是本文的主题)没有任何关系。

# **naif 实现分析:将嵌套 JSON 直接绑定到 DOM 隐藏的架构缺陷**

正如在我们分析的第一个例子中，我试图尽我最大的努力将后端、前端和 DOM 模型混合在一起。

让我们开门见山，看看出问题的最明显症状:

这一行的目的是删除回复。但是它看起来有点太长了，不是吗？首先，您必须返回到“ *post* 对象，提取评论，然后获取对应于当前“ *commentId* ”的评论，提取回复，获取正确的评论并将其从数组中删除。

但是我们需要做的只是从 DOM 中移除一个简单的节点。那么为什么一直到我们模型的父模型的父模型？

您可能会反对点击回复上的“delete”按钮是一个有意义的事件，它超出了删除 DOM 中的一个节点的行为:因为用户不只是想从 DOM 中获得乐趣，他的目标实际上是从数据库中删除回复。

你错了，用户的动作背后没有隐藏的意义，至少在 DOM 模型的抽象层面上没有。***DOM 模型唯一的责任就是删除那个节点:通知 API 用户想要删除回复是别人的任务。***

这正是我在谈论保持抽象分离时的意思:*三个模型中最前面的只是 DOM 的扩展，它应该只关注于此。我们稍后会考虑如何通知 API。*

双重嵌套调用会给我们带来什么意想不到的后果？**答案是，缺乏可伸缩性**:我们正在分析的例子非常简单，*但是在前端世界中，事情变化很快，那行看似无害的代码很容易变成一场噩梦。*例如，如果我们想要异步删除评论和回复，将它们保存在 DOM 中直到 API 做出响应，该怎么办？或者，如果我们需要添加几个嵌套回复，直到某个最大深度，该怎么办？这条线会变得多长多复杂？

现在让我们从 DOM 后退一步，关注这个实现的另一方面:告诉后端更新帖子的 API 调用。

乍一看，这可能是与 API 通信的最简单的选择:我们有这个大对象，当用户与应用程序交互时，我们会不断更新它，让我们将它全部发布到 API。

但事情并不像看起来那么简单: ***发布整个 JSON 的策略之所以有效，只是因为我们的实现假设这样完整的对象总是可用的。***

我不得不重复自己的话，**前端客户的需求变化很快**:一个简单的静态帖子和嵌套的评论和回复可以很快变成高度动态的东西，你需要单独保存单个评论，或者只修改帖子的文本而不触及评论和回复。或者谁知道还有什么？

这已经是事情不对劲的早期征兆了:

当我们想要创建一个新的注释时，DOM 需要将一个" *input* " HTML 标签绑定到控制器中的一个变量:理想情况下，将这样一个变量集成到我们现有的体系结构中的自然选择是在我们的 JSON 中的注释列表后面添加一个新的空" *comment* "。

*但是这意味着，如果用户留下一个不完整的评论，然后执行一些其他的动作，将整篇文章提交给 API，他的评论草稿将会和其他的一起被发送，并被保存。*

因此，为了使它工作，我们已经开始将事情复杂化，并且创建了一个单独的" *newComment* "对象，我们只在提交评论时将它附加到" *post* "上:同样，这不是一个可靠的架构，随着应用程序的增长，它很容易变得过于复杂。

顺便说一下，如果我们看看空注释生成器的实现，我们会发现另一个潜在的问题:

“ *userId* ”属性在用户创建的每个新评论或回复中重复出现。这是多余的，因为评论用户的 ID 总是相同的，我们不需要随身携带并到处复制它:它应该只存储在一个地方，以备我们需要向 API 发布内容时使用。

关于 API 的简单说明:我知道有时候它们不是为前端优化而设计的，我也知道它们经常不能按照你的意愿进行修改。 ***所以你有可能被迫向 API 提交一个完整的嵌套对象，但这并不意味着你必须将这样的对象直接绑定到 DOM。***

最好的解决方案是将您的 API 封装在一个适配器中，该适配器负责保持对象的更新，我将在文章的最后详细介绍。

# “哥白尼革命”:组件模式方法

如果我必须用几句话来总结为什么之前的实现不正确，我会说:**我们围绕一个不代表它的对象开发了前端。**

一个"*帖子* " JSON with nested " *评论*"和"*回复*"是一个非常好的逻辑抽象，描述了帖子、评论和回复在我们头脑中的实际表现方式:这就是为什么选择这样一个数据结构在后端表现它们。

但是在前端，我们需要关注一些不同的东西，我们需要让用户编写内部输入，添加文本，并做任何种类的交互事情:因此，我们在前端使用的模型必须是这些 ***交互*** 的良好抽象。在 Angular 中更是如此，在 Angular 中，DOM 被绑定到自己的模型并自动更新。

**事实上，在 Angular 中，DOM 不能被手动修改，这并不意味着您应该将它绑定到后端模型并期望它神奇地更新:通过将它绑定到 JavaScript 对象来扩展 DOM 的想法，旨在提供一种更强大和可靠的方法来操作它，而不是将某种自动 HTML 附加到后端模型上并绕过前端。**

因此，让我们尝试用一种完全不同的方式来解决我们的问题:*我们不会从后端的模型开始，围绕它们来构建前端，而是分析视图，研究它需要以何种方式与用户交互，并对其进行抽象*(这就是为什么我称之为“哥白尼革命”，因为我们从相反的角度来看待同一问题)。

1.  首先，我们将视图分解成与用户交互的**组件**:我们将它们绑定到 DOM，它们将形成我们的 **DOM 模型**。
2.  然后我们将决定我们需要哪个进一步的抽象来协调我们应用程序的不同部分:这将是前端模型。请注意，我们正在构建前端模型，但还不知道后端是否有相同的模型，也不知道它们是如何实现的。
3.  最后，一旦设计好整个前端架构，**我们将查看 API** 并决定如何向后端发送数据，以及如何使来自后端的数据适应我们的架构。

第一步叫做 ***组件模式*** ，这是[angular 2+](https://angular.io/guide/architecture#components)架构背后的基本概念。

所以，让我们看看需求，决定我们需要哪些组件。让我们从最简单的事情开始，相对于评论的回复数组:这可以是一个组件，它需要做的就是让用户**添加**和**删除**一个回复。

看看前面的实现产生的 HTML，这样一个组件将对应于这个位:

这个组件本身非常简单，不需要知道它上面是什么，但是我们仍然需要在用户添加或删除回复时向 API 发送调用:**所以我们将让我们的组件向它的父组件**发送一个事件。该事件将要么说“添加了一个带有此文本的回复”，要么说“删除了此索引处的回复”。

第二个组件可以是注释列表，对应于这个 HTML:

该组件看起来与第一个组件相同，只是它还侦听子组件“replies ”,并使用子组件所附加的注释索引来确定原始消息的范围。

最后，最后一个组件应该是代表“*职位*的组件:

# **组件模式方法的实现(使用 Angular2+)**

对于这个实现，我将使用 Angular2+，因为这个框架更容易展示组件模式的好处；这并不意味着 AngularJS 不适合实现组件模式，如果你感兴趣，我建议你阅读[这篇非常有趣和详细的文章](https://teropa.info/blog/2015/10/18/refactoring-angular-apps-to-components.html)。

在接下来的实现中，我将只限于 DOM 模型(TypeScript 中的组件和相应的 HTML 模板)；所以，我将暂时省略:

*   当用户与 DOM 交互(与后端模型的交互)时，从 API 检索数据并将其推回的机制；
*   DOM 模型后面的前端模型的定义(省略它们意味着我将把相应的类型设置为“ *any* ”)。

在这之后的段落中，我将扩展这个例子，依次解释(1)如何使组件与 API 通信，以及(2)如何创建表示我们需要的前端模型的类型。

那么，让我们开始吧，让我们从" *post* "组件的实现开始。这是打字稿部分:

这是(非常简单的)HTML 模板:

这部分实现没有什么特别之处:模板将一篇文章的三个主要属性绑定到 dom，并调用组件“ *comments* ”。

这个组件的简单性也是它的优点。*TypeScript 类中唯一存在的变量是我们绑定到 DOM 的变量:一般来说应该遵守这个准则，因为* ***我们正在创建一个 DOM 模型，它的主要目的是扩展 DOM。***

您会注意到，我们没有向" *comments* "组件传递任何东西:现在不要担心这个问题，稍后当我描述与 API 的交互时，我会回到这个问题。目前，我唯一的目标是关注用户交互和 DOM 模型。

让我们前进到第二个组件，它代表注释:

模板:

这是实现中的关键组件，因为它是主动向 API 发送数据的组件。

我们可以通过读取绑定到组件的每个函数，简单地列出组件做的所有事情。让我们首先用对应于 DOM 交互的两个函数来做这件事(另外两个函数用于对发生在子组件“*回复*”层的事件做出反应):

*   当用户点击评论上的“ *delete* ”时，组件从评论数组中删除相应的索引，并向 API 发送一个通知(这里没有实现)
*   当用户在新的评论输入上点击“*保存*时，组件将新的评论添加到评论数组中，**在运行中添加用户的名字**；它清空输入以便用户可以再次评论；另外，它将新的注释和用户 ID(这里没有实现)一起发布到 API

这两个动作的关键点是**关注点分离**:

*   有一个对象表示 DOM(注释数组)，这个对象 ***包含了我们渲染这些注释所需要的内容，没有其他内容。***
*   另外，我们有一个外部 API(这里没有实现，我们将在后面实现) ***您只需将 API 需要知道的基本数据传递给它。***

让我们详细分析每个抽象层所需的最少数据:

1.  DOM 模型是一个注释数组，每个注释由一个文本和一个用户名组成
2.  通知 API 删除注释的调用只包含要删除的注释的**索引**
3.  通知 API 创建注释的调用只包含**文本**和**用户 ID**

现在让我们看看另外两个函数，处理回复的函数。我们正在使用 Angular2+的一个非常好的特性，它允许我们将子组件发送的输出事件视为清晰的输出事件:

这一行的意思是，子组件“*回复*”预计会发送两个可能的事件:

*   名为“ *deleteEvent* ”的事件，该参数是要删除的**回复**的**索引**
*   一个名为“ *submitEvent* 的事件，其参数是已经创建的**回复的**文本****

构建在这些事件**之上的[模板表达式](https://angular.io/guide/template-syntax#template-expressions)将注释的索引添加到从子组件发送的原始参数**中，并将所有内容传递给“ *comments* ”组件的相应方法**，该组件唯一的职责是通知 API 关于变化的信息**。

为什么我们从“*回复*到“*评论*”发送事件，而不是在“*回复*”中直接触发事件？ ***因为子组件没有足够的信息来通知 API:它是扁平的，它不知道它被附加到了哪个注释上。我们这样做是为了简化与 DOM 的交互。***

是时候最后看看最后一个组件了，它代表回复:

和(简单的)模板:

这个组件是**父母不可知的**:它简单地实现了与用户的两个交互，当用户删除或添加回复时发送一个信号；与信号一起发送的唯一参数是相对于回复的具体列表， ***它不包括任何关于这些回复附加到*** 的信息。

因此，DOM 模型的实现是**扁平的**并且容易:我们只存储我们需要来呈现 DOM 的**精确变量，并且当用户想要改变 DOM 时，我们能够直接修改它们。**

我想强调 Angular2+的两个技术细节:首先是**输出声明**，它是我们在" *comments* "模板中绑定的事件的组件副本:

被迫为每个组件声明一个输入和输出列表是如此美好和清晰:它让你保持架构的整洁，尤其是当与[依赖注入](https://angular.io/guide/dependency-injection)一起使用时。

二、看[模板变量](https://angular.io/guide/template-syntax#template-reference-variables--var-)“*# new reply*”的用法:

我决定在这个例子中避免双向绑定:[双向绑定](https://angular.io/guide/template-syntax#two-way-binding---)是我一直试图避免的事情，因为数据必须流动，在每一次击键时，从用户到 DOM 模型，然后返回到 DOM，这是对能量的极大浪费。有时双向绑定是必要的，*但是* *在这个特定的例子中，我只需要读取输入的值，并在用户提交时清空它，一个模板变量让我安全地完成这个任务*。

**这是我们新的 DOM 模型**；总而言之，与第一个 naif 实现相比，我们获得了以下好处:

*   在每个组件中，我们的模型只包含**渲染**DOM 部分所需的数据
*   这样的**数据是立即可用的**，我们不需要进入嵌套 JSONS 的列表:这是因为**我们将 DOM 模型与我们需要向 API 发送数据的任何结构分开**
*   我们没有被迫保留人工对象来存储空的评论或回复，每一个信息都被 DOM 自然地获取并发送给 API
*   DOM 中不需要的用户数据没有冗余；实际上，我们提取用户 ID 的唯一地方是组件“ *comments* ”，因为它是唯一向 API 发送数据的组件
*   这三个组件都受益于**隔离**和**封装**，这使得**更有可能成为可重用的**，尤其是“*回复*”:这是一个很好的成就，因为可重用性在前端更加困难。

# 从 API 到 DOM 的数据流:一般思想

为了完成我们的例子的实现，我们需要关心 API(与后端模型的交互)，它将把我们的小实现变成完整的、自给自足的；之后，我们将讨论前端模型的设计，这对于一个独立的工作示例来说并不是绝对必要的，但是对于使组件与前端的其余部分进行交互来说却是必需的。

关于与 API 的交互，这本身就是一个我们应该分解成两个子任务的任务:

1.  如何让数据从 API 流向 DOM
2.  作为 DOM 与用户交互的结果，如何向 API 发送信息

**从 API 到 DOM 的数据流**是本节及以下几段的主题；我想详细谈谈这个问题，因为我发现这是一个有争议的话题，会引起很多误解**:*在我看来，这样的数据流通常是人们错误地围绕后端模型开发 Angular 应用程序的原因。***

**我们已经看到了如何在第一个 naif AngularJS 实现中处理这样的数据流:API 返回给我们一个嵌套的 JSON，我们简单地用它来构造 DOM。如果我们忘记了实现的所有其他缺陷，而只关注我们绑定到来自 API 的 DOM 数据的方式，我们可以概括出它背后的两个概念如下:**

> **我们将 DOM 直接绑定到“post”对象的属性上，只是因为 API 返回给我们一个“post”对象，并且很容易直接使用它**

**然后，关于嵌套结构:**

> **我们决定将回复绑定到父评论，将评论绑定到父帖子，只是因为 API 以嵌套 JSON 的形式返回数据**

****换句话说，我们根据从后端接收到的任意数据结构来决定前端的架构。****

**不管我们设计的 DOM 模型有多好，我们使用的特定框架有多复杂和设计得多好，这样的架构决策仍然会严重影响我们的应用程序的质量，所以总是知道我们在做什么很重要。**

# **从 API 到 DOM 的数据流:Angular2+中的 naif 实现**

**我现在将描述一个“混合”实现:我将在我们两段前开发的良好的 Angular2+ DOM 模型之上添加一种从 API 接收数据的方法，这是我们在 AngularJS 中实现的第一个 naif 实现的 Angular2+模拟。**

*****我的目标是表明，一个好的 DOM 模型不足以保证我们的应用程序设计良好且容易出错:不管 DOM 模型如何，如果我们没有正确使用从 API 接收的数据，我们的应用程序将会很脆弱，并容易出现不可预测的错误。*****

**为了不使我的代码片段变得太大，在下面的实现中，我将只关注如何使用我们从 API 获取的数据:我将在组件的装饰器中内嵌 HTML，在某些情况下，我不会重复我们在两段之前已经描述过的一些函数和节点。**

**这是*岗位*的实现:**

**这是对*注释*的实现**

**最后“*回复*”:**

**该实现引入的两个关键特性是:**

1.  **我们没有将 DOM 绑定到组件“ *PostComponent* ”的属性，而是将它们绑定到对象“ *post* ”的属性；(我们会发现这本身并不是一个问题，*问题在于我们使用了从 API* 接收到的同一个对象。)**
2.  **数据不再传递给“*注释*”和“*回复*”，而是直接从 API、*获取，而是从父组件传递给子组件，遵循 API 返回的 JSON 的嵌套结构*(在实现中，“ *post* ”是唯一负责从 API 获取数据的组件，也是唯一实现“ *ngOnInit* ”的组件)**

**这两个决定的结果是，出于我们示例的特定目的，**尽管有 Angular2+的语法和我们设计的 DOM 模型，最终的架构不是封装的，也不是稳固的**。**

# **从 API 到 DOM 的数据流:naif 实现的意外、不可预测的错误**

**为了了解我们在做什么并分析新的实现，*我们需要至少对变更检测算法如何工作有一个大致的了解*。**

**我不打算详细说明:如果你想更深入地阅读，我建议你阅读这篇关于变化检测的伟大文章，还有这篇关于 DOM 插值的文章。**

**变化检测使用一个**递归算法**:**

*   **该算法从**根组件**开始:它做的第一件事是重新计算和更新组件上的“ *@Input()* ”绑定**
*   **然后，它提取子组件列表，并更新每个子组件上的“ *@Input()* ”绑定**
*   **该算法继续递归地做同样的事情，**直到它找到一个叶组件**(一个没有子组件的组件):在叶组件上，它传递到下一步，即**更新对应于它们的模板的 DOM****
*   **然后，它返回到父组件，并更新与其模板对应的 DOM**
*   **它递归地重复相同的操作，直到它回到一切开始的根组件:**现在整个 DOM 被更新****

**即使这是一个非常简单的变化检测算法的描述，它也比你在网上找到的大多数描述更多，因为它关注的是算法的递归性质，而这一点经常被忽略。**

**事实上，**递归性是变更检测过程**的核心**，**特别是决定**如何更新一个组件**的能力，仅仅基于它的状态和父组件的状态。**

**当算法从父组件中寻找子组件时，它通常面临三种可能的情况:**

1.  **子组件**只依赖于声明的输入**，那些输入在它们的引用没有改变的情况下是不会改变的: ***这是最有利的情况，在这种情况下，你可以使用***[***【on push】策略***](https://angular-2-training-book.rangle.io/handout/change-detection/change_detection_strategy_onpush.html) ***并从变更检测中分离出整个子组件的子树*****
2.  **子组件只依赖于声明的输入，但是那些输入是属性可以改变的**对象，同时仍然保持相同的对象引用: ***在这种情况下，不可能跳过对子树的更改检测，因为 Angular2+可能没有意识到子树中的某些内容已经改变*** (出于性能原因，Angular2+只在引用改变时更新绑定)****
3.  **子组件**不仅仅依赖于它的输入**，因为它还从 API 或其他外部服务获取数据: ***在这种情况下，优化也是不可能的，并且必须对整个子树*** 运行变更检测**

**现在我们准备看看我们最新实现的具体情况；这是*后件*的模板:**

**当变更检测发现这个模板时，你能说出我们处于三个描述场景中的哪一个吗？**

**它不能是前两者中的任何一个，因为组件显然不依赖于它声明的输入:事实上，组件没有任何输入，因为它的全部内容是由对 API 的调用决定的。**

**但问题是，令人惊讶的是，我们也不在第三种场景中，**，因为模板的状态不仅仅取决于 API** 。**

**我们实际上是在第四个场景中，当我们开始查看变化检测算法时，这似乎是不可能的: ***用于填充模板的对象“post”不仅可由 API 修改，而且它可能被从 API 服务获取相同 JSON 的任何其他服务或组件修改。*****

**在上面的代码片段中，“ *ApiService* ”将返回的 JSON 缓存在一个实例属性中，这是避免不必要的外部调用的好方法。 ***但是，由于我们直接将从 API 服务接收到的对象绑定到 DOM，我们的组件现在暴露于微不足道的错误*** ，就像“*AddMisterToUserNameService*中的错误。**

**直接绑定到从 API 接收的 DOM 对象的组件并不是孤立的，不管你的 DOM 模型设计得有多好。**

**我们如何防止这个问题，并使我们的组件隔离？让我们退后一步，问自己另一个问题:我们真的希望我们的组件被隔离吗？**

**实际上，在某些情况下，最好在 DOM 中的任何地方自动传播模型中发生的变化；*但是，如果我们处于这种情况，我们应该有意识地决定传播这些变化:我们不应该把它作为将 API 适配器返回的对象绑定到 DOM 的副作用，仅仅因为它很容易。***

**在我们的具体例子中，特别是因为我们正在查看一个独立的例子，而不知道应用程序其余部分的上下文，我们肯定不希望能够全局更新对象“ *post* :所以让我们来看看实现封装的可能解决方案。**

**如果我们希望我们的组件被隔离，我们应该**在 DOM 模型中复制我们需要的每个属性**，或者**让 API 适配器在检索之前复制整个对象**；如果我们选择第二个选项，实现它的最佳方式是将 API 数据包装到一个前端模型中。**

***如果我还没有谈到前端模型，那只是因为* ***我真的想把重点放在正确的架构设计流程上*** *，那应该总是从 DOM 模型开始，然后，抽象前端模型；事实上，只有当您连接应用程序的不同部分时，您才开始需要前端模型，并且像我们正在研究的这样的独立示例可以在没有任何抽象模型的情况下完美地存在。无论如何，在这篇文章结束之前，我将把一些话献给前端模型。***

**再看前端模型类的构造函数" *Post* ":**

*   **它**将 JSON 的每个相关属性**复制到一个本地属性中，所以每次我们实例化一个新的" *Post* "对象时，我们都会得到这些属性的不同副本**
*   **它过滤掉所有可能来自 API 的不必要的属性(我们忽略了冗余数据)**
*   **我将 JSON 类型保留为“ *any* ”，因为 JSON 来自 API，不受我们的控制**

**现在让我们看看 API 数据流的 naif 实现的另一个潜在风险:*回复数组被绑定到父“CommentsComponent”，注释数组被绑定到父“PostComponent”。***

**很明显，我们有同样的非隔离问题，正如我们对“ *Post* 对象所评论的，因为那些数组都直接来自 API 适配器服务；但是在这种情况下，还存在额外的风险，因为阵列可能会被父组件本身意外修改:**

**在上面的代码片段中，我们忘记了“ *post* 对象已经有了一个名为“ *comments* 的属性”(因为这样的组件没有在任何地方显式声明，因为我们是直接从 API 中注入的)，我们不小心用它存储了其他东西。这个错误的副作用是，我们会不小心抹掉所有与评论和回复相关的 HTML(甚至可能破坏应用程序)。**

**可能这个特定的错误在真实的应用程序中不太现实，但它为我的目的服务:*我想强调我们漂亮的 DOM 模型是如何被我们从 API 导入数据的方式意外削弱的。***

**使用我们设计的架构，我们让“*后置组件*”负责所有评论、回复和任何其他子组件的 DOM 呈现: ***和前面的例子一样，我们必须问自己是否真的想要实现它，或者我们是否因为来自 API*** 的数据结构而意外地做到了。**

**虽然在很多情况下，我们希望组件的子树可以从根组件完全修改(例如，在管理界面中，我们希望用户能够在任何嵌套级别对项目进行排序)，但是**我们绝对不希望它出现在这里**:用户不应该能够通过在" *post* 组件上执行操作来修改评论和回复。我们设计的所有子组件都应该被隔离。**

**我认为在这样的架构错误背后有一个更深层次的问题:**

> **人们经常混淆首次呈现和更新 DOM 的过程。**

****事实上，为了第一次呈现 DOM，我们需要将评论连接到帖子和对评论的回复，这并不意味着这些连接实际上是使 DOM 与用户交互所必需的。****

**我想为这个问题提出的解决方案应该有一个单独的段落，所以我在这里总结一下。**

**为了结束这一段，我想用几句话再次总结以下重要概念:我们从一开始就说过，当设计 DOM 模型时，我们不应该受后端模型结构的影响； ***同样，当我们设计从后端到 DOM 的数据流时，我们不应该受到来自 API*** 的数据结构的影响。**

# **从 API 到 DOM 的数据流:一种强制隔离的模式**

**为了保持隔离，我们看到我们需要做以下事情:**

1.  **不要在 DOM 模型(Angular2+ components)中使用 API 返回的相同 JSON**
2.  **削减来自 API 的内容，使其只包含我们需要的数据**
3.  **以某种方式使用 API **只是为了第一次** **渲染 DOM**，并且在第一次渲染之后保持组件相互隔离**

**到目前为止，我们在作为 API 适配器的同一个服务中实现了(1)和(2 );但是，最好不要去管 API 适配器，而是将这个逻辑放在一个单独的服务中，这样还可以处理第(3)点。**

**该服务充当 API 适配器和我们的 DOM 模型之间的**中介**:当您调用方法“ *storePost* 时，该服务:**

*   ****调用一次 API 适配器****
*   **使用对类型为" *post* "、" *comments* "和" *replies* "的**初始化前端模型对象**(我们将删除不必要数据的责任委托给这些对象的类，并确保没有对原始 JSON 的引用)**
*   ****在**内部存储这些对象 **，并提供获取它们的方法****

**注意，API 适配器不再负责缓存响应，因为缓存是在" *PostApiService* "中完成的:最好让 API 适配器只负责一件事，即与后端通信。**

**如何在我们的组件中使用这个服务？**

**我想到的想法是，根“*后置组件*”应该以某种方式初始化这个服务，然后**使它只对它的子树**中的所有组件可用:这样，如果其他的“*后置组件*”出现在同一个页面中，就不会有混淆的风险。**

**Angular2+的依赖注入的一个很酷的特性就在这里出现了: ***通过在组件*** 的级别注入来创建一个提供者的单独实例。**

**瞧啊。这是“*后组件*”的最终优化版本。**

*   **提供者" *PostApiService* "是在组件级别注入的，因此该组件及其所有子组件将获得其单独的副本，不存在与" *PostComponent* "的其他实例冲突的风险**
*   **帖子的 ID 作为输入传递给组件，然后组件使用它来初始化"*PostApiService*"；这发生在“ *ngOnInit* ”生命周期挂钩期间，因此“ *PostApiService* ”的实例将在子组件的所有“ *ngOnInit* ”挂钩中可用(因为它们都是在父组件的“ *ngOnInit* ”之后调用的)**
*   **我们安全地将" *Post* "的实例绑定到 DOM，因为我们知道模型的接口包含了我们需要在 DOM 中公开的变量；此外，因为我们确信这个实例只属于我们，它不会在应用程序中传播，也不会有被意外修改的风险**
*   **我们不传递任何" *@Input()* "绑定到组件"*注释*"，因为该组件已经知道如何通过我们提供的本地服务实例获取其数据**

***顺便记住，当一个组件依赖于一个 API 调用时，你应该* [*在路由器*](https://blog.thoughtram.io/angular/2016/10/10/resolving-route-data-in-angular-2.html) *中解析它，否则当 API 收到响应时 DOM 会闪烁。***

**我将用剩余两个组件的实现来结束这一段:**

**请注意"*comments component*" delegates "*PostApiService*"如何将数据发送到 API:"*comments components*"不知道评论附加到的帖子的 ID，但是因为它使用了" *PostApiService* 的特定实例，所以我们可以确保每个调用都在根帖子下面。**

**还要注意，这一次我们使用了类型:将来自 API 的数据包装在前端模型中是一种安全的方式，可以防止应用程序其他部分的意外修改。**

**最后，请注意我们是如何将父注释的索引传递给“ *RepliesComponent* ”的，以及子组件是如何使用它从“ *PostApiService* ”获取适当的回复数组的。**

# **这种模式的概括:模型和责任的分离**

**以上实现背后的关键词是**分离**:**

*   **将 DOM 模型从后端模型的逻辑中分离出来，这有助于我们平稳、无干扰地设计 DOM 功能**
*   ****第一次渲染**与随后与用户的交互分离，因为我们不绑定对评论的回复和对帖子的评论:在第一次渲染期间，我们更愿意使用外部服务作为将数据传递给子组件的替代方式**
*   ****职责分离**，因为并非所有组件都负责与 API 交互**

**我们选择**从 API** 获取数据的组件是根组件*后置组件*，因为这是唯一知道文章 ID 的组件。该组件不直接获取数据，但它通过初始化“ *PostApiService* ”来获取数据，PostApiService 反过来调用 API 并安全地存储该组件及其子组件需要的所有对象。**

**我们选择**向 API** 发送数据的组件是“ *CommentsComponent* ”，因为这是保存用户正在做什么的所有知识的组件(记住子组件“ *RepliesComponent* ”是父组件不可知的)。**

**这两个选择都是有意的，因为以不同的方式做事会给架构增加不必要的复杂性:**

**如果“ *CommentsComponents* ”负责初始化“ *PostApiComponent* ”，那么我们必须向其传递帖子的 ID(冗余信息)；此外，如果将来我们必须向"*后置组件*"(即" *CommentsComponent* ")添加更多子组件，我们将如何获取数据来填充它们？**

**然后，如果"*后置组件*"负责向 API 发送数据，我们将不得不从" *CommentComponents* "转发四个不同的事件:**

**这会给系统增加不必要的复杂性。**

**关于" *PostApiService* "的作用，最后说一下:*这个服务可能是前端开发人员和不必要的 API 调用之间永恒斗争的解决方案。***

**从前端架构的角度来看，用数据填充独立组件的理想方式是让每个组件直接从 API 获取自己的数据；但是，如果我们这样做，我们会用太多的外部呼叫来填充用户的连接，在低网络条件下，应用程序会变得太慢。**

**但是有了像我们设计的这样的作用域 API 适配器，我们就能够**

*   **查看 API 并确定单次调用可以提供的 DOM 的最大区域**
*   **将该区域包装在一个空组件中，该组件唯一职责是初始化作用域 API 适配器**
*   **API 适配器调用 API 一次，并存储所有必需的对象**
*   **最后，子树中的每个组件都可以调用 API 适配器，就像它是真正的 API 一样，而不需要对后端进行不必要的调用**

# **如何向“不友好”的 API 发送数据**

**我们谈了很多关于从 API 到 DOM 模型的数据流，让我们花点时间谈谈另一个方向的数据流。**

**当向后端提交数据时，主要问题在于**API 没有针对前端进行优化**。例如，我们希望实现 post 加评论加回复的最佳 API 应该是这样的:**

**不幸的是，有时 API 并没有像上面那样设计得很好；而且通常 API 不在我们的控制之下，不容易修改(因为，例如，后端可能外包给外部公司)。下面是一个糟糕的 API:**

**这个 API 真的很难交互，因为它只接受帖子、评论、回复的完整 JSON。前端开发人员可能会尝试让组件自己构建大型 JSON，并在用户交互时保持更新:但我们已经看到这不是一个好的选择，并且 ***我们不想仅仅因为 API 没有被正确设计而修改我们的前端架构*** 。**

**正确的解决方案是使用“ *PostApiAdaptor* ”:在从 API 获取数据的时候，服务确实收到了表示帖子的 JSON，所以存储它并在每次组件发送动作时保持它的更新就足够了。**

**这样，组件使用最适合它们的 **API 与服务进行交互** (" *deleteComment* "，" *postComment* "等等。):我们现在可以说我们的组件已经变成了 **API 不可知的**，因为我们可以用任何其他 API 适配器替换“ *PostApiService* ”来提供这些方法。**

# **前端模型保存的数据与后端模型中的任何数据都不对应**

**前端模型是前端实体的抽象:我们通常需要它们来保持这些实体在整个应用程序中的一致性。**

**您可能已经注意到，在本文大部分时间里我们所遵循的 post + comments + replies 的例子中，我们几乎从来没有提到过前端模型:只有当我们必须找到一种解决方案来应对将 DOM 绑定到整个应用程序共享的对象的风险时，我们才引入前端模型。**

**原因是，在我看来，在设计架构的时候，我们应该首先关注 DOM 模型: ***前端模型只有在 DOM 模型已经设计好之后才出现*** ，因为这些模型是进一步的抽象，其目的是使单独的组件相互交互并保持系统的一致性。因此，在一个单独的例子中，前端模型并不重要。**

**正如我从本文开始就一直重复的，前端模型通常与后端模型相似，但它们不可能完全相同。我已经说过，后端模型包含前端不需要的数据是多么常见， ***现在我想展示一个相反的例子:一个前端模型包含后端中没有对应关系的数据*** 。**

**让我们想象一下，在我们应用程序的其他地方，有一个状态栏显示当前用户的统计数据，包括一个根据用户在过去 24 小时内发布的评论/回复数量而改变颜色的徽章。**

**为了保持状态栏的一致性，我们需要某种共享服务来保存用户数据:**

**这个前端模型“*用户*”包含了一个不能保存在后端的属性， ***，因为它抽象了一个只存在于前端*** 的纯视觉属性。**

# ****结论****

**DOM 模型应该只包含直接在 DOM 中使用的属性，以及直接从 DOM 中调用的函数；任何更长或更复杂的功能都应该被重构并提取到服务中。**

> **首先，设计用户交互，并将它们抽象在一个可靠的、良好的 DOM 模型中(甚至在查看后端的数据结构之前)**

**前端模型应该是在前端看到的实体的抽象:除了后端的常规属性之外，它们还应该包含需要在前端的不同组件上共享的其他属性。**

> **第二，决定你必须在前端模型中抽象出哪些实体，以及如何抽象:在这个阶段，你已经可以有一个完全工作的应用程序，你只需要创建模拟与 API 交互的服务**

**在设计前端架构时，后端模型和相关的 API 结构不应该影响您的选择。**

> **最后，连接你的前端和后端:理想情况下，尝试简化和优化你的前端的 API，如果不可能，使用你创建的 API 适配器来解决这个问题**