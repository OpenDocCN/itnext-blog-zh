<html>
<head>
<title>Analyzing value of Operator Framework for Kubernetes community</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes社区运营商框架的价值分析</h1>
<blockquote>原文：<a href="https://itnext.io/analyzing-value-of-operator-framework-for-kubernetes-community-5a65abc259ec?source=collection_archive---------3-----------------------#2018-05-08">https://itnext.io/analyzing-value-of-operator-framework-for-kubernetes-community-5a65abc259ec?source=collection_archive---------3-----------------------#2018-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章分析了运营商框架对Kubernetes社区的潜在价值。Operator Framework是一个开源项目<a class="ae kl" href="https://coreos.com/blog/introducing-operator-framework" rel="noopener ugc nofollow" target="_blank">，上周在KubeCon </a>发布。</p><p id="dcc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CoreOS在2016年11月引入了术语<a class="ae kl" href="https://coreos.com/blog/introducing-operators.html" rel="noopener ugc nofollow" target="_blank"> Kubernetes运营商</a>。操作者是特定于应用程序的控制器，它扩展Kubernetes来创建、配置和管理复杂应用程序的实例。“Kubernetes操作员”不是Kubernetes本地术语；它主要代表两个本地Kubernetes术语的组合:1) Kubernetes CRD(自定义资源定义)和2)管理CRD/s的Kubernetes控制器。Operator术语已被社区广泛接受，在“Kubernetes Operator”上进行简单的Github搜索会得到186个存储库结果。针对etcd、Prometheus、Postgres、Elasticsearch、Kafka、Redis、Spark等各种平台元素编写了运算符。</p><p id="96b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://github.com/operator-framework" rel="noopener ugc nofollow" target="_blank">运营商框架</a>旨在简化运营商的建设和管理。它目前包括两个组件:</p><ul class=""><li id="3768" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir"> Operator SDK </strong>:允许开发者构建操作符</li><li id="a420" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">操作员生命周期管理</strong>:监督操作员的生命周期，例如安装、更新等。</li></ul><p id="06be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公告提到，很快将添加一个用于运营商计量的附加组件，以支持使用情况报告。</p><h1 id="ac67" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运营商SDK分析</h1><p id="4a2a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们看到运营商SDK的以下两个好处。</p><p id="49da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1)在开发操作符时，需要较少的代码来开始。我们对使用<a class="ae kl" href="https://github.com/cloud-ark/kubeplus/issues/14" rel="noopener ugc nofollow" target="_blank">手动方法创建code操作符代码</a>和使用操作符SDK 时所需的步骤数进行了快速比较。这两种方法的共同步骤是创建CRD类型定义和编写操作符的协调逻辑(控制循环)。然而，手动方法的其他步骤，例如创建所需的目录结构、定义注册和doc文件，都是由SDK自动完成的。</p><p id="6f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2)抽象client-go库的细节——您的操作员代码、操作员SDK和client-go库之间的关系如下图所示。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/5e95e25ab563f29c366d4c397ce8b92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0fp4e7RhoKSzC5N7UTxSw.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Operator SDK和您的操作员交互</figcaption></figure><p id="75c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Operator SDK及其抽象接口(一个回调函数，以上下文和事件作为提供的参数)隐藏了您必须知道的细节，例如<a class="ae kl" href="https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf" rel="noopener">工作队列、索引器、通知器、对象键</a>。</p><p id="26d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们认为SDK主要关心的是运营商开发人员只使用抽象接口是否足够；或者在开发和调试他们的操作符代码时，对client-go库及其语义有一个基本的了解将是有益的。</p><h1 id="98f1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运营商生命周期管理器(OLM)分析</h1><p id="3c7c" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如今，运营商的生命周期管理可以使用kubectl或Helm来完成。应用本身的生命周期管理是运营商控制器逻辑的一部分。</p><p id="85dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作符框架引入了两个元操作符(OLM操作符和目录操作符)和一个定制资源(ClusterServiceVersion ),用于定制操作符的生命周期管理。ClusterServiceVersion本质上是一个清单定义，Kubernetes管理员应该使用它来定义操作符的组成。它包括诸如操作者应该如何部署、操作者正在管理什么定制资源类型、操作者将使用什么本地Kubernetes资源等等。对于给定的操作员，OLM要求该操作员管理的自定义资源类型已经在集群中注册。可以使用Catalog操作符或由Kubernetes管理员手动注册这些类型。只有在满足此要求后，OLM才会实例化您的操作员。这些步骤如下图所示。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/4601441baf91900f71fd599da93335ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYLAUB7KGCysjPgwek-pPA.jpeg"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">运营商生命周期经理</figcaption></figure><p id="b37d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎使用操作符框架的主要优点是OLM可以将您的操作符无缝升级到新版本。运营商升级面临的挑战之一是，如何处理由以前版本的运营商管理的定制资源实例。有可能，您可以编写新的操作符，使它知道以前的版本并获得那些实例的所有权。但是这不是一个可扩展的方法，因为每次升级都需要编写定制的逻辑(v→v+1)。<a class="ae kl" href="https://github.com/operator-framework/operator-lifecycle-manager/blob/master/Documentation/design/philosopy.md" rel="noopener ugc nofollow" target="_blank">根据文档</a>，OLM解决了这个问题。它知道这两个版本，并且可以更新每个定制资源实例的所有权信息，以指向操作符的新版本。</p><p id="779b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，Operator框架是一个受欢迎的贡献，因为它似乎解决了Operator开发者和Kubernetes集群管理员的紧迫问题。</p><h1 id="9487" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运营商的终端用户呢？</h1><p id="9cd4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">操作员框架似乎针对两种类型的角色。SDK面向运营商开发人员，OLM面向Kubernetes集群管理员。但是最终用户呢？</p><p id="e433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们认为，这一领域真正缺少的是如何提高运营商对最终用户的可消费性。他们是应用程序开发人员，使用Operators/CRD作为平台元素，在Kubernetes上构建他们的应用程序平台。如今，一个典型的应用平台可以由多个运营商组成，如Prometheus、Postgres、Nginx、Fluentd等。在这种情况下，确实需要通过回答以下问题来提高运营商最终用户体验的一致性:最终用户如何了解新CRD提供的功能，为他们提供了哪些旋钮来定制运营商管理的应用，他们如何诊断运营商管理的应用中的任何问题。</p><p id="2b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://cloudark.io/" rel="noopener ugc nofollow" target="_blank"> www.cloudark.io </a></p></div></div>    
</body>
</html>