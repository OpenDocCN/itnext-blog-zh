<html>
<head>
<title>On cosmetics vs. intrinsics in programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于程序设计中的化妆品与内在特性</h1>
<blockquote>原文：<a href="https://itnext.io/on-cosmetics-vs-intrinsics-programming-c9d7f47e9fd6?source=collection_archive---------3-----------------------#2022-08-01">https://itnext.io/on-cosmetics-vs-intrinsics-programming-c9d7f47e9fd6?source=collection_archive---------3-----------------------#2022-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/172b017b72e746bd797541502ac3208f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okLTvMpXc7qBmoayosqNZA.jpeg"/></div></div></figure><p id="05c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">万维网上每天都在发生一场无情的战斗。它的目标是决定哪种编程风格是最好的:OOP还是FP？我假设命令式和过程式编程不是竞争者的一部分。</p><p id="c21c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">争论的范围从事实到无关紧要到完全愚蠢。几年前，我想听马丁·奥德斯基(Scala fame)的视频。我记不得确切的谈话内容和主题。不过，我记得的是引言:他解释说FP比OOP更受欢迎……因为致力于前者的会议比后者多得多。</p><p id="e6dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当时，我不认为知名度是帮助我交付项目的相关因素。在写这篇文章的时候，我仍然不知道。此外，这相当于说电力不流行，因为没有专门讨论它的会议。恐怕M. Odersky把学术研究中的受欢迎程度错当成了相关性。我在他的“争论”后停止了，直到今天，我再也没有看过他的演讲。</p><p id="6286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">话虽如此，我的观点并不是要抨击m .奥德斯基，而是要强调一些论点的空洞性。例如，对于FP爱好者来说，它的不变性不是一，因为OOP也可以很好地利用它。唯一的区别是不变性是FP中的一个要求。另一方面，过度使用OOP会导致像Java这样的语言，其中每个方法都必须属于一个类，即使是静态方法。在这种情况下，类只是方法的一个额外的名称空间——它们没有带来OOP“价值”。</p><p id="e230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其范围远远超出了面向对象编程和功能编程。考虑以下片段:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cf80" class="lf lg iq lb b gy lh li l lj lk">// Snippet 1</span><span id="0789" class="lf lg iq lb b gy ll li l lj lk">fun router(repo: PersonRepository) = router {<br/>    val handler = Handler(repo)<br/>    GET("/person", handler::getAll)<br/>}<br/>    <br/>class Handler(private val repo: PersonRepository) {<br/>    fun getAll(r: ServerRequest) =<br/>            ok().body(repo.findAll())<br/>}</span><span id="c18d" class="lf lg iq lb b gy ll li l lj lk">// Snippet 2</span><span id="451d" class="lf lg iq lb b gy ll li l lj lk">fun router(repo: PersonRepository) = router {<br/>    val handler = Handler(repo)<br/>    GET("/person/{id}", handler::getOne)<br/>}<br/>    <br/>class  Handler(private val repo: PersonRepository) {<br/>    fun getAll(r: ServerRequest) =<br/>            ok().bodyValue(repo.findAll())<br/>}</span></pre><p id="88d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，区别在于<code class="fe lm ln lo lb b">ok().body()</code> vs. <code class="fe lm ln lo lb b">ok().bodyValue()</code>。如果你不熟悉Spring框架，你不太可能正确地将左边的代码片段识别为WebMVC.fn，将右边的代码片段识别为Web Flux。如果<code class="fe lm ln lo lb b">repo.findAll()</code>从阻塞更新为非阻塞，情况会更加混乱，因为你不会发现任何区别。您只能通过查看包导入来区分它们:</p><ul class=""><li id="e41c" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">封锁:<code class="fe lm ln lo lb b">org.springframework.web.servlet.function.*</code></li><li id="17a6" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">非屏蔽:<code class="fe lm ln lo lb b">org.springframework.web.reactive.function.server.*</code></li></ul><p id="9fce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用注释而不是处理程序来重写以上两个代码片段。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="10db" class="lf lg iq lb b gy lh li l lj lk">// Snippet 1</span><span id="0a9a" class="lf lg iq lb b gy ll li l lj lk">@RestController<br/>class PersonController(private val repo: PersonRepository) {</span><span id="322f" class="lf lg iq lb b gy ll li l lj lk">  @GetMapping<br/>  fun getAll() = repo.findAll()<br/>}</span><span id="abc6" class="lf lg iq lb b gy ll li l lj lk">// Snippet 2</span><span id="4cbe" class="lf lg iq lb b gy ll li l lj lk">@RestController<br/>class PersonController(private val repo: PersonRepository) {</span><span id="7094" class="lf lg iq lb b gy ll li l lj lk">  @GetMapping<br/>  fun getAll() = repo.findAll()<br/>}</span></pre><p id="28d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个片段表面上看起来很相似，但是对于导入来说。化妆品是相同的，而内在特性——阻塞与非阻塞——是根本不同的。</p><p id="4558" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看Kotlin <a class="ae md" href="https://kotlinlang.org/docs/coroutines-basics.html" rel="noopener ugc nofollow" target="_blank">协程</a>。下面是摘自科特林<a class="ae md" href="https://kotlinlang.org/docs/composing-suspending-functions.html#async-style-functions" rel="noopener ugc nofollow" target="_blank">文档</a>的一个片段:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5741" class="lf lg iq lb b gy lh li l lj lk">measureTimeMillis {<br/>    val one = somethingUsefulOne()                             // 1<br/>    val two = somethingUsefulTwo()                             // 1<br/>    runBlocking {<br/>        println("The answer is ${one.await() + two.await()}")<br/>    }<br/>}</span></pre><ol class=""><li id="7875" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv me lv lw lx bi translated">函数指向挂起的计算</li></ol><p id="26c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">协同程序代码在异步时表面上看起来是必要的。<br/>这是<em class="mf">协程的</em>优势:</p><ul class=""><li id="b517" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">表面上看起来势在必行；因此很容易理解</li><li id="9f11" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">在后台，库异步运行代码</li></ul><p id="e614" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码具有表面的和内在的特征。我希望上面的几个例子能让你相信它们是完全正交的。你可以用不同的化妆品达到同样的效果，反之亦然。</p><p id="daea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不断地争论<em class="mf">化妆品</em>、<em class="mf">例如</em>、注释与“功能性”，但这本质上是个人品味的问题。为了解决问题，我们需要在<strong class="ka ir">内部函数</strong>上花更多的时间:参与者、异步等等。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="546a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mf">原载于</em> <a class="ae md" href="https://blog.frankel.ch/on-cosmetics-vs-intrinsics-programming/" rel="noopener ugc nofollow" target="_blank"> <em class="mf">一个Java极客</em></a><em class="mf">2022年7月31日</em></p></div></div>    
</body>
</html>