# 编写可测试的 Swift —第 2 部分:接口

> 原文：<https://itnext.io/writing-testable-swift-part-2-interfaces-e4897c426028?source=collection_archive---------4----------------------->

*你可以在 Github* [*这里*](https://github.com/tnev/writing-testable-swift) *关注这个系列的发展。*

![](img/51c994405f6efbcde9e3a9c257df1bfd.png)

欢迎回到编写可测试的 Swift！在本系列的第一部分[中，我们介绍了依赖注入，这是可测试代码的关键部分，也是任何代码库的重要原则——即使您没有编写测试。今天，让我们来谈谈如何继续自信地用接口编码。](/writing-testable-swift-part-1-dependency-injection-f7a9e3955369)

# 接口

如果你像我一样，当你听到“接口”时，你首先想到的是 objective-c 和头文件。放心吧！我们今天不会创建任何头文件。让我们继续上次的例子，制造更多的机器人！

今天，我们的老板大摇大摆地走进办公室，径直走向我们的办公桌，“我们有些客户需要一个有胳膊有腿的机器人。”

简单，让我们用上一课学到的知识，注入这个机器人需要的零件。

在我们结束之前，我们的老板回来说，“哦，是的，我们的客户有一些不同种类的手臂和腿，他们想测试，所以确保这个机器人可以使用任何可以抓取的手臂或可以行走的腿。”

当然，我们是面向对象的程序员，我们以前做过这种事情。没什么一点遗产解决不了的。我们编写了抽象基类，客户应该为他们自己的胳膊和腿创建子类:

我们把这个交给老板，然后靠在椅子上，对我们的机器人制造能力感到满意。大约 10 分钟后，我们的电子邮件开始被我们的客户发来的愤怒的信息打爆:

> “我们用结构来代表机器人的手臂，我们不能用继承！”

另一个…

> **“我们机器人的腿已经有超类了！”**

另一个…

> **“我们正在使用私有的第三方机器人手臂和腿！我们不能改变他们的实现"**

另一个…

> **“为什么我们的机器人一边尖叫一边崩溃”必须覆盖这个方法！”**

哦，孩子，我们做了什么？嗯，我们很清楚我们做了什么，我们试图通过继承来加强多态性。

但是等等，这怎么会错呢？这就是面向对象编程的工作方式！为什么这是一个这样的问题？

就在这时，我们回到了 Swift 历史上的一个重要时刻,就在 3 年前的 2015 年 WWDC。[Swift 标准库团队的技术负责人 David Abrahams](https://daveabrahams.com/) 登上旧金山莫斯康中心的舞台，说道:

> *“当我们制作 Swift 时，我们制作了第一种面向协议的编程语言。”*

围绕面向协议的含义有很多讨论，但我发现它最好由 David 在同一演讲中说的另一件事来描述，

> *“我们在 Swift 有句谚语。不要从一门课开始。从一个协议开始"*

因此，让我们按照大卫的建议，再次解决这个问题:

当我们以这种方式使用协议时，我们正在创建一个**接口**。我们的接口告诉程序的其余部分，“这就是我们如何交流。”

现在，当我们给机器人注射手臂时，机器人只知道手臂可以抓取。**这就是机器人为了发挥作用而需要知道的所有关于它的手臂的信息。**它不知道 Arms 的什么具体实现实际上符合这个接口并被传递到机器人中。所以现在我们可以这样做:

只要我们的具体实现符合我们的接口协议，我们就可以将它们注入到我们的机器人中。同样，我们的机器人所知道的是，它有能够抓住的手臂和能够行走的腿。

这能解决我们客户的问题吗？让我们看看:

“我们用结构来代表机器人的手臂，我们不能用继承！”太好了，结构和枚举都符合 Swift 中的协议。

**“我们机器人的腿已经有超类了！”**所有好的方面是，类可以遵循任意多的协议，即使它们是从另一个类继承的。

“我们正在使用私有的第三方机器人手臂和腿！我们不能改变它们的实现"在 Swift 中，我们可以扩展我们无法访问的类，并添加协议一致性。

**“为什么我们的机器人一边尖叫一边崩溃”必须覆盖这个方法！这可能看起来很傻，我们甚至会说，“这是客户没有覆盖基类的方法的错！".你觉得我们老板会在乎是不是客户的错吗？让我们通过使用一个在编译时强制一致性的协议来消除出错的可能性。**

这个面向协议的接口非常强大，原因如下:

# 多重一致性

与继承不同，单个类型可以符合多个协议。这允许在一个类型中有单独的接口，给了我们[组合胜过继承](https://en.wikipedia.org/wiki/Composition_over_inheritance)的能力。协议甚至可以从其他协议继承，这是我们将在本系列的下一部分开始使用的技术。

# 多态性

在 Swift 中，任何类、结构或 enum 都可以符合协议。这增加了可以为某个接口提供实现的实体的类型。

# 减少耦合

通过使用协议，我们的代码现在依赖于接口，而不是具体的实现。这意味着我们的接口可以调解实现之间的耦合，这比两个实现之间的紧密耦合更容易修改。

*如果你还记得这个系列的第一部分，* ***依赖注入*** *也有助于减少耦合。减少耦合对于我们软件的可重用性和可维护性是极其重要的。*

# 易测性

考虑这种情况:

如果我们只想测试控制器的 userName()方法呢？看看 userName()方法在做什么:

它天真地要求我们的具体网络类为一个用户发出网络请求…

*   …它反过来要求我们的服务器获取该用户
*   …现在，我们的服务器必须做大量工作来检索该用户
*   …我们的服务器将会(希望)返回一个用户
*   …该用户需要被解码成用户对象
*   …最后，我们的网络类将为我们的控制器提供一个用户

此外，我们如何知道服务器上的用户名，从而确保它与 userName()方法返回的名称相同？

真正的问题是**为什么**我们必须做*所有这些*当我只是试图确保我们的控制器可以返回一些任意的用户名时？**我们不是在测试我们的网络！**

通过依赖注入和协议接口，这可以很容易地完成:

现在，当我们去测试我们的控制器时，我们只需注入我们的 TestNetwork，我们知道我们的 userName()方法应该返回“John”。没有网络呼叫或解码。我们在*完全控制*。

Swift 协议是一个令人惊叹的强大工具，我们可以用它来实现出色的结果。使用它们来创建接口有助于我们避免继承的一些陷阱。当我们将依赖注入与接口相结合时，我们可以开始看到我们的组件变得耦合性更低，可重用性更高。这将导致我们能够自信地更快地修改代码。

我鼓励你在适当的时候使用接口，并继续朝着可测试的代码努力。下次见。