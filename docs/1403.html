<html>
<head>
<title>.NET Parameterized Queries Issues with SQL Server Temp Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。SQL Server临时表的. NET参数化查询问题</h1>
<blockquote>原文：<a href="https://itnext.io/net-parameterized-queries-issues-with-sql-server-temp-tables-f5ee4f304523?source=collection_archive---------3-----------------------#2018-10-07">https://itnext.io/net-parameterized-queries-issues-with-sql-server-temp-tables-f5ee4f304523?source=collection_archive---------3-----------------------#2018-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去几周的工作中，我遇到了许多人在。NET中包含一个临时表。经过一番挖掘，我们终于找到了问题所在。这篇文章将会讨论这个问题的原因以及解决的方法。本文中使用的数据库是微软的全球进口商样本数据库。关于设置它的说明，请查看我的<a class="ae kl" href="https://elanderson.net/2018/09/getting-a-sample-sql-server-database/" rel="noopener ugc nofollow" target="_blank">从上周开始获取一个SQL Server数据库示例</a>的帖子。</p><h2 id="2895" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">示例项目创建</h2><p id="e514" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">为了使事情尽可能简单，我使用了一个控制台应用程序。NET CLI命令。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="6d59" class="km kn iq lp b gy lt lu l lv lw">dotnet new console</span></pre><p id="2e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后面跟着这个命令从Nuget添加到SQL客户端中。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="70cf" class="km kn iq lp b gy lt lu l lv lw">dotnet add package System.Data.SqlClient</span></pre><p id="c780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是完整的<code class="fe lx ly lz lp b">Program</code>类和样本代码，它将导致本文所处理的异常。是的，我知道这不是构建这种类型代码的最好方式，所以请不要从这个角度来判断。这意味着演示问题很简单。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="74d7" class="km kn iq lp b gy lt lu l lv lw">class Program<br/>{<br/>    static void Main(string[] args)<br/>    {<br/>        Console.WriteLine("Running sample");<br/><br/>        using (var connection = <br/>                  new SqlConnection(@"Data Source=YourServer;<br/>                                      Initial Catalog=YourDatabase;<br/>                                      Integrated Security=SSPI;"))<br/>        {<br/>            connection.Open();<br/><br/>            using (var command = connection.CreateCommand())<br/>            {<br/>                SqlTest(command);<br/>            }<br/>        }<br/><br/>        Console.ReadLine();<br/>    }<br/><br/>    private static void SqlTest(SqlCommand command)<br/>    {<br/>        command.CommandText = @"SELECT OrderId<br/>                                      ,CustomerId<br/>                                      ,SalespersonPersonID<br/>                                      ,BackorderOrderId<br/>                                      ,OrderDate<br/>                                INTO #backorders<br/>                                FROM Sales.Orders<br/>                                WHERE BackorderOrderID IS NOT NULL<br/>                                  AND OrderDate &gt; @OrderDateFilter";<br/><br/>        command.Parameters.Add("@OrderDateFilter", <br/>                                SqlDbType.DateTime)<br/>                          .Value = DateTime.Now.AddYears(-1);<br/>        command.ExecuteNonQuery();<br/><br/>        command.CommandText = "SELECT OrderId FROM #backorders";<br/><br/>        using (var reader = command.ExecuteReader())<br/>        {<br/>            while (reader.Read())<br/>            {<br/>                Console.WriteLine(reader["OrderId"]);<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h2 id="0735" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">错误</h2><p id="877c" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">运行上面存在的应用程序将导致以下错误。</p><blockquote class="ma mb mc"><p id="5b91" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">无效的对象名' #backorders '。</p></blockquote><p id="1721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">奇怪的错误，因为我们刚刚创建了<strong class="jp ir">#缺货订单</strong>临时表。让我们试一试没有过滤器。查询现在看起来如下所示。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c625" class="km kn iq lp b gy lt lu l lv lw">command.CommandText = @"SELECT OrderId<br/>                              ,CustomerId<br/>                              ,SalespersonPersonID<br/>                              ,BackorderOrderId<br/>                              ,OrderDate<br/>                        INTO #backorders<br/>                        FROM Sales.Orders<br/>                        WHERE BackorderOrderID IS NOT NULL";<br/><br/>command.ExecuteNonQuery();</span></pre><p id="d85d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在应用程序运行没有任何问题。如果我们尝试添加回过滤器，但不使用命令参数会怎么样？</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="e880" class="km kn iq lp b gy lt lu l lv lw">command.CommandText = @"SELECT OrderId<br/>                              ,CustomerId<br/>                              ,SalespersonPersonID<br/>                              ,BackorderOrderId<br/>                              ,OrderDate<br/>                        INTO #backorders<br/>                        FROM Sales.Orders<br/>                        WHERE BackorderOrderID IS NOT NULL<br/>                          AND OrderDate &gt; '2018-01-01'";<br/><br/>command.ExecuteNonQuery();</span></pre><p id="d780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，应用程序运行没有任何问题。</p><h2 id="a6c0" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">原因</h2><p id="a8a4" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">为什么添加命令参数会导致我们的临时表消失？我通过使用SQL Server Profiler发现了这个问题(在SQL Server Management Studio中，可以在工具&gt; SQL Server Profiler中找到它)。代码返回到原始版本，命令参数和探查器连接到运行示例应用程序的同一服务器，示例应用程序显示了SQL Server收到的以下命令。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c7e3" class="km kn iq lp b gy lt lu l lv lw">exec sp_executesql N'SELECT OrderId <br/>                     FROM #backorders',<br/>                   N'@OrderDateFilter datetime',<br/>                   @OrderDateFilter='2017-08-28 06:41:37.457'</span></pre><p id="ca4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实证明，当您在。NET中，它在SQL Server上使用<a class="ae kl" href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql" rel="noopener ugc nofollow" target="_blank"> sp_executesql </a>存储过程来执行。这是我之前遗漏的关键信息。现在我知道参数化查询是在存储过程的范围内执行的，这也意味着我们第一个查询中使用的临时表仅限于在创建它的存储过程中使用。</p><figure class="lk ll lm ln gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/b778a82554aa39768cb827f193bee5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N8PB2eLOQCpyCNvr"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@casparrubin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕·鲁宾</a>上<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="16be" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">要修复的选项</h2><p id="bb88" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">第一个选项是在初始数据拉取时不使用参数。我不推荐这个选项。参数提供了我们不想失去的保护级别。</p><p id="91a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个选项和我们解决这个问题的方法是首先创建临时表。现在，临时表已经在存储过程之外创建了，它的作用域是连接，然后允许我们使用参数插入数据。下面的代码是我们使用这种策略的示例。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="1ee0" class="km kn iq lp b gy lt lu l lv lw">command.CommandText = @"CREATE TABLE #backorders<br/>                        (<br/>                           OrderId int<br/>                          ,CustomerId int<br/>                          ,SalespersonPersonID int<br/>                          ,BackorderOrderID int<br/>                          ,OrderDate date<br/>                        )";<br/><br/>command.ExecuteNonQuery();<br/><br/>command.CommandText = @"INSERT INTO #backorders<br/>                        SELECT OrderId<br/>                              ,CustomerId<br/>                              ,SalespersonPersonID<br/>                              ,BackorderOrderId<br/>                              ,OrderDate<br/>                        FROM Sales.Orders<br/>                        WHERE BackorderOrderID IS NOT NULL<br/>                          AND OrderDate &gt; @OrderDateFilter";<br/><br/>command.Parameters.Add("@OrderDateFilter", <br/>                       SqlDbType.DateTime)<br/>                  .Value = DateTime.Now.AddYears(-1);<br/>command.ExecuteNonQuery();</span></pre><h2 id="76e5" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">包扎</h2><p id="a40d" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我希望这能节省一些时间。一旦我明白了这个问题的意义所在。怎么会。NET处理带参数的SQL命令是一直有效的事情之一，直到现在我才需要深入研究。总是有新的东西要学，这也是我热爱我的工作的原因之一。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="1210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="md">原载于</em><a class="ae kl" href="https://elanderson.net/2018/10/net-parameterized-queries-issues-with-sql-server-temp-tables/" rel="noopener ugc nofollow" target="_blank"><em class="md"/></a><em class="md">。</em></p></div></div>    
</body>
</html>