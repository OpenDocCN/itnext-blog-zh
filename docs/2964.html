<html>
<head>
<title>Let’s Migrate Symfony Project to Kubernetes! Part 4: Building a Continuous Delivery Pipeline.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们将Symfony项目迁移到Kubernetes！第4部分:构建连续的交付管道。</h1>
<blockquote>原文：<a href="https://itnext.io/building-continuous-delivery-pipeline-2cc05e213935?source=collection_archive---------2-----------------------#2019-09-08">https://itnext.io/building-continuous-delivery-pipeline-2cc05e213935?source=collection_archive---------2-----------------------#2019-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e90b514b767f2b55941e4cbde1253756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCVG0l8-yDMZOYGLyjCoig.jpeg"/></div></div></figure><h1 id="254c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于这个系列</h1><p id="1756" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个系列中，我们将讨论现有Symfony项目到Kubernetes (K8s)的迁移。无论您当前在何处以及如何发布您的应用程序:裸机、VM或容器编排平台，通过遵循本指南，您将能够将其部署到K8s集群。<br/>这些*how to*文章的目标读者是那些已经了解Kubernetes、Docker和持续集成(CI)的一些基础知识、想要学习新技巧或只想完成工作的人。<br/>本系列的每一部分都致力于一个特定的主题:<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">构建Docker环境</a>，<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/testing-symfony-application-d02317d4018a">在不同级别上测试应用</a>，<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/publishing-symfony-application-with-helm-ecb525b34289">用Helm </a>将应用部署到Kubernetes，构建CI管道。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="1a37" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">关于第4部分</h1><p id="cf8b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这一部分，我们将讨论自动化。我们将利用在前面部分中获得的所有知识，创建一个可持续和可靠的持续交付(CD)渠道。</p><p id="76fa" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">有大量的工具可以帮助你进行持续开发:Jenkins、Travis CI、GitLab CI等。在本教程中，我选择了GitLab CI，因为它是市场上最先进、文档完善且易于使用的解决方案之一。</p><p id="392b" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">在本系列的最后一篇文章中，我将指导您完成将虚拟项目交付到生产环境的所有阶段。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="1496" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">关于虚拟项目</h1><p id="a2c3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我为这个系列准备了一个简单的Symfony 4应用程序。它需要PHP-FPM，Nginx和MySQL来运行。更多详情，请参考<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">第1部分</a>。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="f072" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">码头工人执行人</h1><p id="41e3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">GitLab使用Runner执行管道作业并收集结果。您可以从多个执行器中选择:SSH、Shell、Docker等。我们将坚持使用Docker executor，因为它最适合我们的用例。</p><p id="e341" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">使用Docker executor，您可以配置默认图像和服务，这些将用于运行您的作业。因为我们要操作管道中的图像和容器，所以将docker 中的<strong class="ky ir"> docker设置为默认配置是个好主意。</strong></p><p id="ef85" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">让我们创建<strong class="ky ir">。gitlab-ci.yml </strong>文件，并声明管道的基础:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="54da" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">阶段</h1><p id="519f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">流水线阶段对作业进行分组，并定义执行顺序。此外，如果在GitLab Runner中配置了并发性，同一阶段中的所有作业将并行运行。</p><p id="b549" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">我们的管道中需要哪些阶段？首先，我们需要构建Docker映像，因为我们使用容器来测试项目并在Kubernetes中运行它。下一步是执行单元和集成测试。如果测试通过，我们将图像推送到Docker Hub。然后，我们将项目部署到试运行阶段，并运行端到端测试。最后，如果没有发现问题，我们将应用程序部署到生产环境中。</p><p id="96c4" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">让我们宣布<strong class="ky ir">中讨论的阶段。gitlab-ci.yml </strong>文件:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="f9a5" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">构建阶段</h1><p id="a7ff" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了运行虚拟应用程序，我们需要PHP-FPM、Nginx和MySQL容器。要启动容器，我们需要首先构建图像。幸运的是，我们已经准备好使用Dockerfiles，它是在<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">第1部分</a>中创建的。</p><h2 id="b98d" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">模板</h2><p id="1992" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">构建Docker映像的过程可能是并行和统一的。要并行运行作业，我们可以简单地将它们放在同一个阶段。为了统一流程，我们可以利用<a class="ae lu" href="https://docs.gitlab.com/ee/ci/yaml/#special-yaml-features" rel="noopener ugc nofollow" target="_blank">特殊YAML功能</a>的力量，构建一个模板:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c912" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">以<strong class="ky ir">开头的所有作业。</strong>被GitLab CI忽略。一个隐藏的作业和一个锚(<strong class="ky ir"> &amp; buildTemplate </strong>)一起定义了一个模板。我们将在接下来的部分中看到如何使用模板，但是现在我只想鼓励您在任何有意义的时候使用模板，因为它增加了可读性，降低了管道的复杂性。</p><p id="eb74" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">我们上面定义的作业非常简单:我们构建一个图像并将结果保存在一个文件中，该文件可以通过工件特性与其他作业共享。</p><h2 id="6c1d" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">PHP-FPM图片</h2><p id="cd71" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要构建两个PHP-FPM映像:一个用于测试，另一个用于试运行/生产环境:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7261" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">我们使用<strong class="ky ir"> &lt; &lt; </strong>来合并一个模板，我们在上面声明了这个模板，并标记为<strong class="ky ir"> *buildTemplate </strong>。除此之外，我们定义了一组在模板中使用的变量。</p><blockquote class="ne nf ng"><p id="826c" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">因为所需的PHP版本已经在<strong class="ky ir">中配置好了。env </strong>文件，我们可以重用该值以避免重复。要设置<strong class="ky ir"> BUILD_VERSION </strong>参数，我们只需要在作业开始前读取文件并导出值。</p></blockquote><h2 id="3f50" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">Nginx图像</h2><p id="0964" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">构建Nginx映像非常相似:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="34d0" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">MySQL图像</h2><p id="2b8b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我想提醒你，我们在K8s集群中使用MySQL只是为了演示的目的。对于测试来说，数据库容器是一个很好的选择，但是对于生产和登台环境，可以考虑使用外部数据库:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="41e7" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">测试阶段</h1><p id="cbe8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当映像被构建时，我们可以运行单元和集成测试，这是我们在本系列的前一部分中创建的。我们在这个阶段不执行端到端测试，因为我们将在试运行环境中运行它们，为此，我们显然需要首先在试运行环境中部署我们的项目。</p><h2 id="29e4" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">单元测试</h2><p id="ef9b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在PHP-FPM容器中运行单元测试，该容器基于我们在<strong class="ky ir"> build-php-fpm-test </strong>任务中创建的图像。为了访问<strong class="ky ir"> build-php-fpm-test </strong>工件，以及php-fpm图像文件，我们可以将其定义为当前作业的一个依赖项:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><blockquote class="ne nf ng"><p id="f296" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">注意，我们需要在脚本之前加载图像，以使它对Docker可见。</p></blockquote><h2 id="a225" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">集成测试</h2><p id="d10f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">集成测试工作遵循与单元测试相同的逻辑，但是稍微复杂一点。它不仅需要PHP-FPM，还需要MySQL容器。两个容器必须在同一个网络中，并且根据我们的配置，数据库必须可以被<strong class="ky ir"> mysql </strong>别名访问:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><blockquote class="ne nf ng"><p id="5db2" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">我们不能在后台启动MySQL容器后立即运行测试，因为初始化数据库和设备需要一些时间。</p></blockquote><p id="c348" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">为了避免在没有准备好的环境中启动测试，我们使用了<strong class="ky ir"> ci/check-connection </strong>脚本，它基本上只是等待3306端口打开，因为这是一个信号，表明容器已经成功启动:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="ba82" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">注册表更新阶段</h1><p id="ff7b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果所有测试都通过了，我们可以将生产就绪映像从<strong class="ky ir">构建</strong>阶段推送到容器注册中心。我使用Docker Hub作为例子，但是可以随意选择任何满足您需求的注册表。</p><h2 id="9cc9" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">模板</h2><p id="49f4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于所有注册表更新作业看起来都很相似，因此创建一个模板很方便:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="547d" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">在上面的说明中，我们加载一个图像，重新标记它，并将其推送到注册表中。为什么我们要重新标记图像？为什么我们没有到处使用最后的标签？出于可读性的考虑，存储库标签相当长，我们不想在使用图像的每个作业中都键入它。</p><blockquote class="ne nf ng"><p id="63a7" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">从这个阶段开始，我们将在管道中添加的所有作业都将被标记为仅主作业。我们不想继续部署，除非代码被合并到主分支。</p></blockquote><h2 id="fb10" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">FPM图片</h2><p id="0b00" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在PHP-FPM的情况下，我们只推送<strong class="ky ir">symfony-dummy-project-PHP-fpm:prod</strong>image:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="24cc" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">Nginx图像</h2><p id="096a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">同时，我们将<strong class="ky ir">symfony-dummy-project-nginx:prod</strong>发送到注册表:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="7c52" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">MySQL图像</h2><p id="ebb4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我们推送<strong class="ky ir">symfony-dummy-project-MySQL:prod</strong>:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3234" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">阶段部署阶段</h1><p id="0742" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">既然所有的图像现在都在注册表中，我们就可以在登台和生产环境中发布我们的应用程序了。我们已经在<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/publishing-symfony-application-with-helm-ecb525b34289">系列的第二部分</a>中准备了一个掌舵图，现在我们只需要将它安装在一个选定的Kubernetes集群上。我选择Google Kubernetes Engine (GKE)作为本文演示集群的宿主平台。</p><h2 id="f47e" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">部署模板</h2><p id="7039" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">试运行和生产的部署流程是相同的。因此，我们可以创建一个模板:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5447" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">在之前的工作中，我们使用了默认映像— <strong class="ky ir"> docker:latest </strong>，因为我们只需要docker和Shell实用程序。在部署阶段我们与GKE进行交互，这需要安装更具体的工具:<strong class="ky ir"> gcloud </strong>、<strong class="ky ir"> helm </strong>、<strong class="ky ir"> kubectl </strong>等。为了方便集群通信，我创建了一个新的<strong class="ky ir"> helm-gke </strong>图像:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b327" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">在启动了一个<strong class="ky ir"> helm-gke </strong>容器之后，我们需要为<strong class="ky ir"> kubectl </strong>配置集群凭证。我已经在<strong class="ky ir">ci/fetch-cluster-credentials</strong>脚本中提取了必要的命令:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a8ec" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">当获取凭证时，没有什么可以阻止我们安装图表:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="d8cb" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">部署作业</h2><p id="a96a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">部署工作非常简单:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">UPD:除了使用带有环境后缀的变量(例如_STAGE)之外，你可以考虑在GitLab UI中为STAGE和production范围创建变量，然后<a class="ae lu" href="https://docs.gitlab.com/ee/ci/yaml/README.html#environment" rel="noopener ugc nofollow" target="_blank">用特定的环境</a>标记作业。</figcaption></figure><p id="75a8" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">这里唯一需要解释的是<strong class="ky ir">ci/等待推出</strong>脚本:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4a19" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">这个脚本一直等到所有的窗格都准备好了，以避免在以前的图表版本上启动端到端测试。</p><h2 id="7d18" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">回滚模板</h2><p id="c03f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当出现问题并且我们想要恢复最后的更改时，回滚工作非常方便:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d95b" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">这是一个手动操作，它使先前的图表修订生效(在<strong class="ky ir">回滚</strong>命令中的零指的是先前的修订)。</p><h2 id="813b" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">回滚作业</h2><p id="daaa" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">作业定义很简单，我们只需要提供集群凭据:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="3a35" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">端到端测试阶段</h1><p id="8bea" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个应用程序现在已经准备就绪，这意味着我们最终可以运行端到端的测试，并检查整个系统是否如预期的那样工作。</p><p id="fdcd" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">在这个系列的第三部分中，我们创建了一个Postman集合，它描述了虚拟项目的功能。我们还讨论了一个名为Newman的工具，如果您需要从命令行运行收集，它会非常方便。</p><p id="5274" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">Docker executor的便利之处在于能够使用任何图像来运行您的作业。在端到端测试的情况下，最合适的是官方的<strong class="ky ir">邮递员/纽曼:阿尔卑斯</strong>图像:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><blockquote class="ne nf ng"><p id="9d62" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">注意，<strong class="ky ir">邮递员/纽曼:阿尔卑斯</strong>有<strong class="ky ir">运行</strong>命令作为入口点。为了使它与Docker执行器一起工作，我们需要重置图像入口点。</p></blockquote></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="f9cb" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">生产部署阶段</h1><p id="af48" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们已经在<strong class="ky ir">阶段-部署</strong>阶段创建了必要的模板，所以让我们直接进入工作列表。</p><h2 id="2451" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">部署作业</h2><p id="6647" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们不会在生产中自动部署项目。相反，当我们准备好发布代码时，我们在GitLab UI中按下按钮:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><blockquote class="ne nf ng"><p id="7016" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">请注意，我们对生产群集有不同的凭据。</p></blockquote><h2 id="0534" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">回滚作业</h2><p id="3d41" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如所料，生产回滚作业类似于<strong class="ky ir">回滚-暂存</strong>:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="c7cd" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">配置</h1><p id="61f2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">管道已经准备好了，但是在触发它之前，我们需要设置CI变量，调整项目以与GKE兼容，并配置集群。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e1fbb35e1844efa4efe4ee3058535292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*FpKa2x4aB9heisd1TXh9lQ.jpeg"/></div></figure><h2 id="ca8f" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">GitLab CI变量</h2><p id="b232" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您再看一下管道代码，您会发现这里和那里有许多变量。其中一些直接在<strong class="ky ir">中定义。gitlab-ci.yml </strong>文件:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="81b3" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">其他是外部的:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f372" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">所有以CI为前缀的变量都是由GitLab CI提供的(例如<strong class="ky ir"> $CI_COMMIT_SHA </strong>)。其余在<strong class="ky ir">设置⇢ CI/CD </strong>页面配置:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/6ec33fea17b0b6603068121c882fca1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xx79opUogSeR1AOhUGqkkg.jpeg"/></div></div></figure><h2 id="0ee6" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">项目</h2><p id="36e0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了让我们的项目在GKE运行，我们需要对代码做一些修改:</p><ol class=""><li id="2219" class="nr ns iq ky b kz mh ld mi lh nt ll nu lp nv lt nw nx ny nz bi translated">由于我们将创建两个集群(暂存和生产)，并配备两个专用入口控制器，因此在入口对象定义中不需要路由规则。所有请求将由默认后端处理:</li></ol><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="813c" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">2.GKE不支持<strong class="ky ir"> ClusterIP </strong>，所以让我们将我们的服务类型改为<strong class="ky ir"> NodePort </strong>:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="692f" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">3.Google云平台可以通过HTTP端点监控我们的应用程序的健康状况。为了给GCloud提供应用程序状态信息，我创建了一个简单的<strong class="ky ir">健康控制器</strong>:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cd8d" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">默认情况下，Google负载平衡器向<strong class="ky ir"> / </strong>和<strong class="ky ir"> /healthz </strong>端点发出请求，以发现应用程序的状态。要在Nginx pod上启用GKE健康检查，我们可以配置活动和就绪探测器。作为第一步，我们必须调整图表部署模板以接受探测器设置:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="bd94" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">然后，我们需要在<strong class="ky ir"> values.yaml </strong>文件中配置<strong class="ky ir"> nginx </strong>服务:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="d1ae" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">簇</h2><p id="8683" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您决定像我们在本教程中所做的那样在GKE上发布您的项目，您将需要在第一次部署之前准备集群。如果您还没有创建集群，您可以在Google云控制台(<strong class="ky ir"> Kubernetes引擎⇢集群</strong>)中创建集群:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/719a5ac9944a226c328230519f1cb028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxibOJZTDcb6IcAtl1iaYA.jpeg"/></div></div></figure><p id="0dc5" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">当两个集群都启动并运行时，我们可以在<strong class="ky ir"> IAM &amp; admin ⇢服务帐户</strong>页面上使用<strong class="ky ir"> Kubernetes引擎管理</strong>角色创建<strong class="ky ir"> symfony-dummy-project </strong>服务帐户。然后生成一个JSON密钥，将其重命名为<strong class="ky ir"> sa.json </strong>，并遵循以下说明:</p><ol class=""><li id="5a09" class="nr ns iq ky b kz mh ld mi lh nt ll nu lp nv lt nw nx ny nz bi translated">从服务帐户密钥(<strong class="ky ir"> sa.json </strong>)所在的目录启动<strong class="ky ir"> helm-gke </strong>容器:</li></ol><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b16e" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">2.在Google云平台中进行身份验证:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cf21" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">3.获取集群凭据(不要忘记用集群参数替换占位符):</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2434" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">4.在K8s集群中创建项目名称空间:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="62cb" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">5.添加数据库机密:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c182" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">6.配置Tiller服务帐户:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e057" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">7.初始舵:</p><figure class="mm mn mo mp gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><blockquote class="ne nf ng"><p id="88c7" class="kw kx nh ky b kz mh lb lc ld mi lf lg ni mj lj lk nj mk ln lo nk ml lr ls lt ij bi translated">请注意，这种配置对于两个集群都是必需的:转移和生产。</p></blockquote><h2 id="7b5e" class="ms jz iq bd ka mt mu dn ke mv mw dp ki lh mx my km ll mz na kq lp nb nc ku nd bi translated">域名服务器(Domain Name Server)</h2><p id="a556" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一次部署后，GKE将创建两个负载平衡器，并为每个平衡器创建两个临时IP地址:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/754edc6755aa58cec589aaf4e4a1e40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gm5_oPG98IFr-cze9NmJ4Q.jpeg"/></div></div></figure><p id="617f" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">您可以将您的域名指向这些IP地址，使您的应用程序可以通过HTTP访问，但是推荐的方法是保留<a class="ae lu" href="https://cloud.google.com/compute/docs/ip-addresses/#reservedaddress" rel="noopener ugc nofollow" target="_blank">静态IP地址</a>。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="fd9f" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">运行管道</h1><p id="448c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所有准备工作都已完成，我们准备运行管道。要启动这些作业，您只需要将代码放入Git存储库中。虽然对功能分支的提交仅触发<strong class="ky ir">构建</strong>和<strong class="ky ir">测试</strong>阶段，但是对<strong class="ky ir">主</strong>的提交也调度<strong class="ky ir">注册表更新</strong>、<strong class="ky ir">阶段部署</strong>和<strong class="ky ir">端到端测试</strong>作业。</p><p id="53f9" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">您总是可以在UI中看到管道是否通过(或失败):</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/eff63ea2feb6ecfae73752f4ede1cebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mh3-SKBUTDlboUVWIvsYJQ.jpeg"/></div></div></figure><p id="c7d1" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">此外，只需点击一下，就可以查看任何感兴趣的作业的输出。如果你想自己尝试，只需访问其中一个管道页面。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/de2ac5d9022c596225a857a1169454be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQJDV-Aa517w6NPpwQ-oEw.jpeg"/></div></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="fb29" class="jy jz iq bd ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv bi translated">结束语</h1><p id="1295" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们终于将虚拟项目迁移到了Kubernetes！当然，我们简单地触及了大部分主题，有些问题根本没有讨论(自动伸缩、数据库迁移等)。)，但如果您决定在K8s上发布您的Symfony项目，这是一个很好的起点。</p><p id="340f" class="pw-post-body-paragraph kw kx iq ky b kz mh lb lc ld mi lf lg lh mj lj lk ll mk ln lo lp ml lr ls lt ij bi translated">我要感谢所有关注这个系列的人！我希望我的指南是有用的，并帮助您了解Kubernetes。下次见！</p></div></div>    
</body>
</html>