<html>
<head>
<title>Container Runtime in Rust — Part 0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的容器运行时—第0部分</h1>
<blockquote>原文：<a href="https://itnext.io/container-runtime-in-rust-part-0-7af709415cda?source=collection_archive---------1-----------------------#2021-09-09">https://itnext.io/container-runtime-in-rust-part-0-7af709415cda?source=collection_archive---------1-----------------------#2021-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="543a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker、Podman、Kubernetes和其他容器工具家族的成员:谢谢你们！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/48f7861a0303530f6e36be4217b6aa20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BBIGBAXpQbNznxlNkkxEg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:https://twitter.com/laurelcomics</figcaption></figure><p id="b0e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从DevOps的角度来看，我只能说活着是多么美好的时光！随着容器的兴起，我们在设置虚拟机、备份/恢复程序、动态资源调配方面遇到的所有困难都迎刃而解，因为使用量增加而扩展，因为未优化的架构设置而扩展，等等。通过一个<em class="lc"> docker-compose </em>文件或一个像<em class="lc"> helm install my-app </em>这样方便的一行程序，一切都烟消云散了(嗯，几乎是以上列表中的一切)。</p><p id="6b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，容器本质上是什么，Docker是如何工作的呢？</p><p id="4403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是一个系列，描述我用除了Rust之外的其他语言编写一个小的、实验性的容器运行时的旅程。第0部分描述了Linux操作系统的系统特性，Docker和其他工具利用这些特性来启动一个被隔离和保护的进程，换句话说，就是一个<strong class="jp ir">容器。</strong>整个系列都基于Linux容器，所以任何出现的<strong class="jp ir">容器</strong>都可以与“<strong class="jp ir"> Linux容器</strong>”互换。</p><p id="4830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的完整源代码可以在<a class="ae lb" href="https://github.com/penumbra23/pura" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ld"><img src="../Images/cdca9adbb917650f2cfcf2754bf6a7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rye3eqP0k0kSX_jSxURcmg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Rust中的容器运行时</figcaption></figure></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="2d93" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">容器</h1><p id="4858" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">当被要求用尽可能少的词描述容器是什么时，大多数开发人员感到失望。用一个技术词汇来描述，这是一个分叉或克隆的过程。它有一个专用的PID，由一个用户和一个组拥有，你可以用<em class="lc"> ps </em>命令列出它并向它发送信号(是的，信号#9也是)。仅此而已，周围没有什么超级花哨的出血边缘，只是一个老式的工艺。</p><p id="570d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是它是如何与系统的其他部分隔离开来的呢？</p><p id="60f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是<a class="ae lb" href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">名称空间</strong> </a>。</p><p id="6d7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命名空间为在不同命名空间集中运行的进程提供了资源的逻辑隔离。有不同类型的名称空间，例如，当前进程可以看到的所有装载点的装载名称空间，网络接口和流量规则的网络名称空间，进程树的PID，等等。在不同PID名称空间中运行的两个进程看不到相同的进程树。一个独立的网络命名空间拥有自己的网络堆栈、路由表、防火墙和环回接口。具有不同网络名称空间的两个进程绑定到各自的环回设备，它们被绑定到一个单独的逻辑接口，这样流量就不会在它们之间产生干扰。</p><p id="2522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">挂载名称空间包含一个进程可以看到的挂载点列表。当第一次从装载命名空间(CLONE_NEWNS标志)克隆时，所有装载点都从父命名空间复制到子命名空间。在子挂载点中创建的任何附加挂载点都不会传播到父挂载名称空间。此外，当子进程卸载任何挂载点时，它只在其挂载名称空间内受到影响。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/35813929448a051cb032edfa95be5a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*QtGiLnwuw13GR1igTcQYoQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">三个独立的MNT、网络和PID命名空间的示例</figcaption></figure><p id="4719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">root(“/”)也不例外。对于不同的挂载名称空间，根挂载点不必是(大部分不是)同一个目录。当运行一个容器时，Docker(特别是<a class="ae lb" href="https://containerd.io/" rel="noopener ugc nofollow" target="_blank"> containerd </a>)为每个容器的根挂载点创建一个目录。在实际的容器运行用户定义的进程之前，容器运行时负责将该目录挂载为容器的根目录。这样，每个容器都有自己的根挂载点，它独立于文件系统的其余部分和主机上运行的所有其他容器。</p><p id="3ebc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个进程在主机上都有一个<em class="lc"> /proc/PID/ns </em>子目录，包含它们所属的每个名称空间(PID、net、user、cgroup、…)的符号链接。如果两个进程属于同一个名称空间，它们的符号链接将是相同的。</p><p id="025f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看一个简单的<em class="lc"> sleep </em>命令有哪些名称空间(当然是在我的机器上):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/e035d2fa38bb38948de9ad3c50d6b7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlbWysxycogPICjkZ3Hu8Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">PID为694的睡眠进程的名称空间</figcaption></figure><p id="3d37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在同一个shell中运行另一个进程并检查其名称空间，会得到与上面相同的符号链接:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/b9aa1ab42c62174f2c9f12c00e83e5a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7Su_VtlAZtKdmHwfyu4yg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">PID为697的睡眠进程的名称空间</figcaption></figure><p id="1bfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个进程无需任何额外的命令或设置即可运行，它们具有相同的名称空间符号链接，因此属于相同的名称空间。</p><p id="ebcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Linux从<em class="lc"> sched.h </em>库中提供了<a class="ae lb" href="https://man7.org/linux/man-pages/man2/unshare.2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> UNSHARE </strong> </a> syscall来改变进程的执行上下文，并允许它创建和输入新的名称空间。在用特定的位掩码(结合哪些名称空间要从执行上下文中“取消共享”的标志)调用了<strong class="jp ir">取消共享</strong>之后，正在运行的进程从根名称空间分离到它自己的名称空间集中。不幸的是，仅仅调用<strong class="jp ir"> UNSHARE </strong>并期望拥有一个隔离的容器是不够的(例如，一个“取消共享”PID名称空间的父进程，仍然在根PID名称空间中运行，但是任何后来创建的子进程都将进入新创建的PID名称空间)。通常在容器运行时调用<strong class="jp ir"> UNSHARE </strong>之后，它会跟随一个<strong class="jp ir"> fork/vfork </strong>调用来创建实际的容器进程。</p><p id="be83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://man7.org/linux/man-pages/man2/clone.2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">克隆</strong> </a> syscall是一个好得多的选择，在<a class="ae lb" href="https://docs.rs/nix/0.22.1/nix/sched/fn.clone.html" rel="noopener ugc nofollow" target="_blank"> Rust的nix包</a>中的实现感觉更加健壮和细粒度。它提供了指定名称空间标志的能力，如<strong class="jp ir"> UNSHARE，</strong>fork一个子进程并为该子进程创建堆栈。</p><p id="b802" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">SETNS</strong>syscall(<strong class="jp ir">NSENTER</strong>command)提供了通过文件描述符将给定名称空间更改为现有名称空间的选项。例如，要派生进入PID为15的进程的mount命名空间的shell进程，请输入一个新的shell(具有root权限):</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="0f76" class="mw lm iq ms b gy mx my l mz na">nsenter --mount=/proc/15/ns/mnt /bin/sh</span></pre><p id="0fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">够理论</strong>！为了证实上面所说的一切，让我们跳到一个基于Docker的例子。我们将运行一个alpine容器，列出主机系统上的进程，检查其名称空间，并使用<strong class="jp ir"> SETNS </strong>将<em class="lc"> docker exec </em>插入其中。</p><p id="0fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们运行一个长期运行的睡眠容器:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/c4f2c58bf87da8c3541f033ee0979044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHs9xBKhc8-n-C6kwY0RRQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">运行“sleep 1000”(唯一运行相同命令的进程)的alpine容器的PID</figcaption></figure><p id="5fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查完容器的PID之后，让我们看看<em class="lc"> /proc/PID/ns </em>下的名称空间符号链接:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/1daba02901498d2087d29ba7c86b2c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXkjR5jN4yLuEj23FHcxhg.png"/></div></div></figure><p id="0836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有意思！一些名称空间与我们在终端中运行的上述sleep命令相同(具体来说是<strong class="jp ir">用户</strong>和<strong class="jp ir">c组</strong>名称空间)，但大多数名称空间是不同的，这证明Docker将容器分隔在不同的名称空间中。</p><p id="7126" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们尝试在容器内部执行一个shell来检查文件系统:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/81ac32955b49c3e098e90da60fccee47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7C2L6sWbRKy8doK6QHkeQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">NSENTER命令打开alpine容器的MOUNT名称空间内的shell</figcaption></figure><p id="1243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始有意义了吗？嗯，差不多…</p><p id="cbfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里发生的事情是，我们已经运行了<strong class="jp ir"> NSENTER </strong>来启动容器进程的mount名称空间内的<em class="lc"> shell </em>进程。容器的挂载名称空间不同于根目录，因为根目录列出的树结构与我的WSL实例上的略有不同。此外，在我的Debian实例上，打印容器内的Linux发行版信息(<em class="lc"> /etc/os-release </em>)显示了一个Alpine Linux发行版。所以我们得出结论:</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="bd80" class="mw lm iq ms b gy mx my l mz na">docker exec -it &lt;CONTAINER_ID&gt; &lt;CMD&gt;</span></pre><p id="b1ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等于:</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="3f8e" class="mw lm iq ms b gy mx my l mz na">nsenter -a -t &lt;CONTAINER_PID&gt; &lt;CMD&gt;</span></pre><p id="1cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">* n输入-a </strong>进入具有<strong class="jp ir"> -t </strong> arg中指定的PID的进程的所有名称空间</p><h1 id="59a8" class="ll lm iq bd ln lo ne lq lr ls nf lu lv lw ng ly lz ma nh mc md me ni mg mh mi bi translated">码头工人</h1><p id="2674" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">大多数读者已经熟悉了Docker客户机-服务器模型，因此没有必要解释CLI如何调用后台运行的<strong class="jp ir">Docker</strong>服务上的命令。让我们打开前盖，看看下面是什么。</p><p id="0222" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后一个例子中，我们看到了<em class="lc"> docker run </em>命令在一个单独的名称空间集中派生出一个进程。实际发生的情况是，Docker(同样，更具体地说是containerd，但现在让它保持简单)调用底层容器运行时来创建指定的名称空间，准备容器环境，并在实际的用户定义命令开始之前执行一些需要的特殊命令。</p><p id="d0dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果这是运行时的责任，我们用Docker做什么呢？</p><p id="30e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Docker在创建容器之前做好了一切准备，包括两个最重要的部分:</p><ol class=""><li id="c204" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated"><strong class="jp ir"> config.json </strong></li><li id="f4e1" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><strong class="jp ir">容器根目录</strong></li></ol><p id="dc29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个部分(以及我们将在本系列中发现的其他内容)被称为<strong class="jp ir">容器包</strong>。</p><p id="a502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> config.json </strong>文件具有整个容器生命周期的完整布局，从容器开始到容器删除。它包含容器根目录的路径、需要取消共享的名称空间列表、容器进程的资源限制、需要在特定时间点执行的挂钩以及许多其他设置。</p><p id="5f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">容器根目录</strong>是挂载名称空间部分提到的目录。这是主机系统上某处的子目录，将成为容器的根目录。用户定义的进程一定不知道在容器根目录之外有一个完全不同的世界，它基本上将用户进程“关”在容器根目录内(大多数文献称之为“监狱”)。</p><p id="0959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了这两件最重要的事情之外，Docker还做了其他准备工作(例如，从远程存储库中提取图像层，如果容器启用了网络，则设置网络接口，等等)。</p><h1 id="a11c" class="ll lm iq bd ln lo ne lq lr ls nf lu lv lw ng ly lz ma nh mc md me ni mg mh mi bi translated">OCI规格</h1><p id="3582" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">标准化是任何软件集成的关键部分。从编写REST APIs或gRPC服务到设计底层网络协议，一切都从一个定义良好的文档开始，该文档描述了什么是(不)预期的行为以及实现需要履行的最小契约。</p><p id="5839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放容器倡议(OCI) </a>创建并仍然维护着OCI运行时规范，可以在<a class="ae lb" href="https://github.com/opencontainers/runtime-spec/blob/master/spec.md" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这是一个仍在发展和添加新特性的规范，容器运行时可以或可能在启动容器进程时执行这些新特性。</p><p id="7b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会深入到规范的细节，因为它在文档中描述得很好，但至少这里是它的概括。</p><p id="7f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">符合OCI标准的<strong class="jp ir">容器运行时</strong>是实现以下命令的CLI二进制文件:</p><ul class=""><li id="9865" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk nx np nq nr bi translated"><strong class="jp ir">创建</strong><em class="lc">&lt;id&gt;&lt;bundle _ path&gt;</em></li><li id="58ed" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk nx np nq nr bi translated"><strong class="jp ir">开始</strong> <em class="lc"> &lt; id &gt; </em></li><li id="5279" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk nx np nq nr bi translated"><strong class="jp ir">状态</strong> <em class="lc"> &lt; id &gt; </em></li><li id="3282" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk nx np nq nr bi translated"><strong class="jp ir">杀死</strong> <em class="lc"> &lt; id &gt; &lt;信号&gt; </em></li><li id="4194" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk nx np nq nr bi translated"><strong class="jp ir">删除</strong> <em class="lc"> &lt; id &gt; </em></li></ul><p id="2a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和其他新兴规范一样，OCI运行时规范描述了创建容器的最基本特性。流行的容器运行时实现，如<a class="ae lb" href="https://github.com/opencontainers/runc" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">runc</strong></a><strong class="jp ir"/>或<a class="ae lb" href="https://github.com/containers/crun" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">crun</strong></a><strong class="jp ir"/>有额外的参数帮助设置进程的PID文件、容器状态的根文件夹或容器终端的套接字文件。</p><p id="79cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是不用担心这些部分。在本系列接下来的文章中，我们将用一些Rust代码更深入地研究它。</p><p id="376c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来:<a class="ae lb" href="https://penumbra23.medium.com/container-runtime-in-rust-part-i-7bd9a434c50a" rel="noopener"> <strong class="jp ir">第一部分</strong> </a></p><h1 id="0514" class="ll lm iq bd ln lo ne lq lr ls nf lu lv lw ng ly lz ma nh mc md me ni mg mh mi bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="3e19" class="nj nk iq jp b jq mj ju mk jy ny kc nz kg oa kk no np nq nr bi translated"><a class="ae lb" href="https://man7.org/linux/man-pages/man7/namespaces.7.html" rel="noopener ugc nofollow" target="_blank"> Linux名称空间手册页</a></li><li id="6a69" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><a class="ae lb" href="https://github.com/opencontainers/runtime-spec" rel="noopener ugc nofollow" target="_blank"> OCI运行时规范库</a></li><li id="d7b8" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated"><a class="ae lb" href="https://github.com/opencontainers/runc/blob/master/man/runc.8.md" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> runc </strong>储存库</a></li></ol></div></div>    
</body>
</html>