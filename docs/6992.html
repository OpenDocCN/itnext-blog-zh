<html>
<head>
<title>Flutter: Data Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振:数据测试</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-data-testing-362957f561c1?source=collection_archive---------5-----------------------#2022-05-09">https://itnext.io/flutter-data-testing-362957f561c1?source=collection_archive---------5-----------------------#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1a6a991ad2b79d05209431da3cd9002e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zhmquYiPRzdy2LwD.png"/></div></div></figure><p id="23e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在之前的一篇文章中，我们讨论了使用<code class="fe kw kx ky kz b">find.byPredicate</code>进行更加精确和可靠的小部件测试。</p><p id="2d0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae la" href="https://remelehane.dev/posts/up-your-testing-game/" rel="noopener ugc nofollow" target="_blank">颤振:升级您的测试游戏</a></p><p id="da18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将快速浏览同样的逻辑，但是是针对数据相关的单元测试。</p><p id="0c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我的95%的数据模型，我会使用冻结的<a class="ae la" href="https://pub.dev/packages/freezed" rel="noopener ugc nofollow" target="_blank">和</a>，这是一个奇妙的包，当涉及到数据类时，它使我们的生活变得更加简单，包括添加一些实用方法以及通过处理等式来简化单元测试，这是我以前手动实现的，并得到了<a class="ae la" href="https://pub.dev/packages/equatable" rel="noopener ugc nofollow" target="_blank"> equatable </a>的一些帮助。</p><p id="7240" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，当使用<code class="fe kw kx ky kz b">freezed</code>时有一点样板文件，因为它与代码生成一起工作。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="c94d" class="lj lk iq kz b gy ll lm l ln lo">enum MenuItemKey {logout, dashboard}<br/><br/>class MenuItem {<br/>  final MenuItemKey key;<br/>  final String localeKey;<br/>  final PageRouteInfo route;<br/><br/>  MenuItem({<br/>    required this.key,<br/>    required this.localeKey,<br/>    required this.route,<br/>  });<br/>  <br/>  static List&lt;MenuItem&gt; menuItems = [...]<br/>    <br/>  static List&lt;MenuItem&gt; itemsToDisplay(List&lt;MenuItemKey&gt; excludedKeys) {<br/>    return menuItems<br/>        .where((element) =&gt; !excludedKeys.contains(element.key))<br/>        .toList();<br/>  }<br/>}</span></pre><p id="9e3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以这个类为例，添加<code class="fe kw kx ky kz b">freezed</code>会很简单，增加2或3行代码和一个额外生成的文件，然而对我来说这是不必要的，因为这是我创建的一个简单管理导航列表的模型，没有数据要测试，与API无关，不需要等式或实用方法，等等。</p><p id="fd3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的应用程序中有一个菜单，它提供了<code class="fe kw kx ky kz b">menuItems</code>列表，我用它生成导航项目。</p><p id="0c8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我仍然希望能够准确地测试<code class="fe kw kx ky kz b">itemsToDisplay</code>，这个类的1位逻辑，默认情况下，所有项目都基于生成函数，然而不是所有的屏幕都有所有的导航项目。例如，登录屏幕不需要注销按钮。</p><h1 id="9983" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试…</h1><p id="5e77" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">与小部件一样，我们可以使用<code class="fe kw kx ky kz b">predicate</code>作为expect函数的一部分，深入数据模型，并将结果与定义的值进行比较。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="1221" class="lj lk iq kz b gy ll lm l ln lo">test('should return only logout menu item', () async {<br/>    //act<br/>    final result = MenuItem.itemsToDisplay([<br/>      MenuItemKey.dashboard,<br/>      MenuItemKey.support,<br/>      MenuItemKey.profile,<br/>    ]);<br/>    //assert<br/>    expect(<br/>      result,<br/>      predicate(<br/>        (List&lt;MenuItem&gt; items) =&gt;<br/>            items.length == 1 &amp;&amp; items.first.key == MenuItemKey.logout,<br/>      ),<br/>    );<br/>  });</span></pre><p id="4d04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们在<code class="fe kw kx ky kz b">menuItems</code>列表中有4个条目，并决定过滤掉除<code class="fe kw kx ky kz b">logout</code>之外的所有条目。</p><p id="bc6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了验证我们的函数正在工作，我们使用了<code class="fe kw kx ky kz b">predicate</code>,它将一个函数作为一个期望，我们将我们期望的数据类型传递给它，然后返回一个产生布尔结果的检查。</p><p id="781b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们有一个包含4个菜单项的列表，我们排除了其中的3个，所以我们验证我们的列表中只有1个项目，为了确保正确的项目仍然存在，我们验证列表中的第一个(唯一的)项目具有键<code class="fe kw kx ky kz b">MenuItemKey.logout</code>，这是分配给导航项目的枚举值。</p><h1 id="fd4f" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论…</h1><p id="348d" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">正如你现在所看到的，<code class="fe kw kx ky kz b">find.byPredicate</code>和<code class="fe kw kx ky kz b">predicate</code>是两个非常有用的方法，我们作为测试人员在编写测试时应该牢记在心。它们可以帮助不太标准的用例，并允许我们编写更高质量的测试。</p><p id="3133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望您对此感兴趣，如果您有任何问题、评论或改进，请随时发表评论。享受你的颤振发展之旅:D</p><p id="96d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢，一个赞就太棒了。</p><p id="6552" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。</p><p id="d33e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望继续单元测试的话题，请看:</p><div class="mr ms gp gr mt mu"><a rel="noopener  ugc nofollow" target="_blank" href="/widget-testing-dealing-with-renderflex-overflow-errors-9488f9cf9a29"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">小部件测试:处理Renderflex溢出错误</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">在单元测试中处理“一个RenderFlex被…溢出”的简单方法…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">itnext.io</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni jw mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a rel="noopener  ugc nofollow" target="_blank" href="/up-your-testing-game-ae40cb5d4449"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd ir gy z fp mz fr fs na fu fw ip bi translated">升级您的测试游戏</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">今天我们来看看Flutter测试提供的一个很棒的工具。</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">itnext.io</p></div></div><div class="nd l"><div class="nj l nf ng nh nd ni jw mu"/></div></div></a></div></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="5b21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nr">原载于2022年5月9日</em><a class="ae la" href="https://remelehane.dev/posts/flutter-data-testing/" rel="noopener ugc nofollow" target="_blank"><em class="nr">https://remelehane . dev</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>