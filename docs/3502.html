<html>
<head>
<title>How to use JavaScript Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JavaScript生成器</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-javascript-generators-e0381c9ac897?source=collection_archive---------4-----------------------#2019-12-28">https://itnext.io/how-to-use-javascript-generators-e0381c9ac897?source=collection_archive---------4-----------------------#2019-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c84cd26ce22353821d8756d4b1aaaa85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y3hjSGNQFoXzerUx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">科林·阿姆斯壮在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="15a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成器函数生成值序列。他们是基于每个请求来这样做的。这意味着每次消费者请求一个值时，生成器都会返回一个值。这种情况会持续下去，直到没有其他值可以返回为止。</p><p id="35b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成器使用<em class="le"> yield </em>关键字返回值。当这种情况发生时，生成器<em class="le">会无阻塞地挂起</em>的执行，返回值并耐心等待，直到收到另一个请求。</p><p id="bf2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有一个需要某种全局计数器变量的应用程序，查看生成器函数可能是一个不错的选择。</p><p id="b8f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于本文的目的，让我们假设我们有一个需要某种id的应用程序。我们的生成器会产生一个自动递增的数字。业务规则规定用户能够指定起始值。让我们深入一点代码，看看如何使用生成器创建一个简单的解决方案。</p><p id="53db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们简单的用户界面。我已经使用<a class="ae kf" href="http://www.getbootstrap.com" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>让它看起来像样。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/3245515b55368493e32198085a1bff4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*VAHPHiE-zw_7njln2R3OQA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">提供起始值的简单用户界面</figcaption></figure><p id="5fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HTML。</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="4fb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及让它运行的代码。</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="d8a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个代码示例使用显示模块模式，并利用闭包来模拟私有变量。<a class="ae kf" href="https://levelup.gitconnected.com/using-closures-in-javascript-to-create-private-variables-c0b358757fe0" rel="noopener ugc nofollow" target="_blank">我已经在这篇文章中讨论过这些话题。</a></p><p id="f7b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先要注意的是，我们使用了一个IIFE(立即调用的函数表达式),这样当页面加载时，我们就可以自动获得挂在窗口对象上的testGen变量。我们可以通过Chrome dev工具打开控制台选项卡并输入window.testGen来确认这一点。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lm"><img src="../Images/a40b236f735912a98b21d97a3d8a9025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGQ5x26pdAvcAdXWiejIkg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">开发工具中window.testGen的输出</figcaption></figure><p id="7a54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Dev tools确认window.testGen是一个对象，并且它公开了nextVal()函数。还要注意，通过使用IIFE，我们已经创建了一个闭包，它列在开发工具的Scopes部分下面。</p><p id="05cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为testGen在window对象上是可用的，所以我们用它来设置简单表单上按钮的onclick动作。</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">按钮HTML</figcaption></figure><p id="0406" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当按钮被点击时，nextVal()被执行。</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">nextVal()</figcaption></figure><p id="12ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们检查私有变量_myIterator是否为真。如果不是，我们调用两个函数来设置我们的执行环境:getStartingValue()和createIterator()。</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="82bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第8行，调用myGen()函数，并将返回值保存到_myIterator变量中。到底什么是_myIterator，我们为什么需要它？我以为这个帖子是关于发电机的？</p><p id="7437" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们暂停一下，更详细地讨论一下生成器。</p><h2 id="ae36" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">生成器和迭代器</h2><p id="e721" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">生成器是一种全新的函数。如上所述，发生器函数是产生一系列值的函数，但它不像常规函数那样一次产生所有的值。我们必须显式地请求一个值，如果生成器有值，它将返回一个值。返回的每个值都是一个<em class="le">新对象</em>,它包含一个用于检索序列中下一个值的next()方法和一个done属性，该属性告诉消费者是否有任何其他值。如果生成器没有任何额外的值，它会通过返回undefined for a value和将it done属性设置为true来告诉我们这一点。</p><p id="d1aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次我们请求一个值时，生成器“<em class="le">会记住</em>”上次请求时我们在哪里，并从上次我们请求值时停止的地方继续。</p><p id="7fea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们调用生成器时，并不意味着生成器函数的主体将要执行。相反，创建并返回一个迭代器对象。作为消费者，我们使用这个新创建的迭代器作为我们和生成器之间的“中间人”。这就是代码示例的第8行发生的情况。对myGen()的调用返回一个迭代器，我们用它与生成器进行通信。</p><p id="722c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">眼尖的读者可能已经注意到myGen()函数定义在function关键字旁边包含一个星号(*)。这是向运行时指定这是一个生成器函数。</p><h2 id="dc39" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">回到代码</h2><p id="96a2" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">有了这些新知识，让我们完成对代码的审查。</p><p id="946b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在getStartingValue()中，我们简单地使用document.getElementById()来获取用户在表单的文本框中输入的值。如果没有传递值，则_counter变量被初始化为0。</p><p id="3178" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">createIterator()然后做它的名字所暗示的事情。它检查迭代器是否已经定义，如果没有，调用myGen()返回一个新的迭代器。</p><p id="f8d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在myGen()的主体中，我们设置了一个无限循环，只要页面存在，它就会继续返回值。如果需要，我们可以在这里设置某种上限，但是对于这个例子，我们使用无限婴儿！</p><blockquote class="ml mm mn"><p id="2f4f" class="kg kh le ki b kj kk kl km kn ko kp kq mo ks kt ku mp kw kx ky mq la lb lc ld im bi translated">顺便提一下，通常在编程时，我们喜欢避免无限循环，但是当使用生成器时，它们就很好了。</p></blockquote><p id="a0ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在nextVal()中，我们调用迭代器上的next()方法，并将值写入控制台。</p><p id="aabf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在文本框中输入值20，单击几次按钮后，我们会在控制台中得到以下输出。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0fde00623a4551ffa73f5fe717081ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*aefA641TR8TfIuihPft79A.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们的发电机工作得非常好！</figcaption></figure><p id="c757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，每当按钮上发生click事件时，生成器都会被要求输入一个新值。很容易想象这样一种情况，我们将循环使用来自生成器的值。在这种情况下，JavaScript现在提供了专门用于生成器的<em class="le"> for-in </em>语法。让我们快速看一下这种方法。</p><p id="7fb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经更新了UI，允许用户输入开始和结束值。下面是UI和更新后的HTML。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6212fe2712f6eed019bb1a7bb780480b.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*vjF_5Wiwa50Y_ZbI2HnCaQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">更新的用户界面</figcaption></figure><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="4ba0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是更新后的代码:</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="c4fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大部分代码是相同的，但有一些变化。首先，我们从UI中获得开始和结束值。这些值在getStartingValue()函数中捕获，并分别保存到_start和_end变量中。</p><p id="eccb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们在myGen()函数中创建迭代器时，我们使用这些_start和_end变量。</p><p id="7800" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们在第38行使用新的<strong class="ki iu"> <em class="le"> for-of </em> </strong>循环语法来循环这些值并将它们写入控制台。</p><p id="89da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能会想:为什么我不能用while循环来做这件事呢？嗯，答案是可以。使用while循环的缺点是，在每次循环中，您都要负责调用迭代器上的next()方法。<strong class="ki iu"> <em class="le"> for-of </em> </strong>语言特性为您做到了这一点。这是我们免费得到的一点语法魔法。</p><h2 id="54f5" class="ln lo it bd lp lq lr dn ls lt lu dp lv kr lw lx ly kv lz ma mb kz mc md me mf bi translated">包裹</h2><p id="78d4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在这篇文章中，我们讨论了ES6中新的生成器功能。生成器与迭代器一起工作，为调用代码提供一系列值。生成器的独特之处在于，它们在返回值时暂停执行，并在再次被调用时从停止的地方继续执行。与新的for-of语法结合使用，可以轻而易举地生成数据序列，我们可以一次从一个项目中提取数据。</p><p id="17ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尝试一下，并在代码中利用这一新功能。</p><p id="ebd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看MDN中关于发电机的文件。</p><p id="b972" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读！</p></div></div>    
</body>
</html>