<html>
<head>
<title>Monitoring on Kubernetes: Custom Metrics and Autoscaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上的监控:自定义指标和自动缩放</h1>
<blockquote>原文：<a href="https://itnext.io/monitoring-on-kubernetes-custom-metrics-c068165f82d3?source=collection_archive---------1-----------------------#2018-02-05">https://itnext.io/monitoring-on-kubernetes-custom-metrics-c068165f82d3?source=collection_archive---------1-----------------------#2018-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3041f3b05848fabe282c869b3f1ab2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zob18MWLPnwVd2wacaOvQ.png"/></div></div></figure><p id="d315" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fmonitoring-on-kubernetes-custom-metrics-c068165f82d3" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="9af5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在之前的关于指标收集代理的文章之后，下一个合乎逻辑的步骤是写可以收集什么数据以及如何收集。一般来说，遥测有两类:度量快照和事件。度量快照会定期抓取，而事件可能随时发生。</p><p id="69fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着Prometheus在Kubernetes上采用监控，度量收集和可靠性工程正获得更多关注。请记住，Prometheus是基于拉的系统，非常适合集群监控和Kubernetes。它支持联合，可用于复杂的多集群拓扑。pull(或scrape)的替代方法是push model，其中数据被发送到时序数据库。如产品文档<a class="ae kw" href="https://prometheus.io/docs/practices/pushing/" rel="noopener ugc nofollow" target="_blank">此处</a>所述，在Prometheus中使用推送模式存在缺点并会增加复杂性。</p><p id="d4e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推和拉模式之间的竞争没有赢家，它们各有利弊。然而，重要的是要考虑更广泛的指标收集场景，而不仅仅是在Kubernetes上。此外，监视可能没有Kubernetes的混合环境需要在DMZ内部部署Prometheus来访问scrape目标。虽然一些企业可能愿意这样做，但其他企业更喜欢将指标推到安全边界之外，而不是时间序列数据库。</p><p id="f610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于任何类型的度量，遥测数据收集的一个关键方面是时间分辨率。虽然使用Prometheus每隔5-10秒从目标收集指标对于某些类型的指标来说可能足够了，但对于其他类型的指标来说可能是不可接受的。给定指标的变化频率是抽样的重要因素。有些人可能对这个<a class="ae kw" href="https://en.m.wikipedia.org/wiki/Nyquist–Shannon_sampling_theorem" rel="noopener ugc nofollow" target="_blank">定理</a>很熟悉。虽然使用抓取来观察变化对于集群监控来说很好，但是对于描述应用程序性能的所有指标的深入分析来说，这可能还不够。因此，收集具有所需时间分辨率的不同类型指标的能力需要使用混合方法:推和拉。</p><p id="67dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一挑战并不新鲜。2015年，网飞推出了<a class="ae kw" href="https://medium.com/netflix-techblog/introducing-vector-netflixs-on-host-performance-monitoring-tool-c0d3058c3f6f" rel="noopener">矢量</a>。Vector的目的是让可靠性工程师能够分析在主机级别收集的一组指标。</p><p id="cd6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当构建Sonar monitoring agent来统一指标收集(主要关注Windows容器)时，它支持将收集的指标暴露给Prometheus scraping(pull)并将它们写入Akumuli时序数据库(push)。</p><p id="8e89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在世界语中以“accumulate”命名的Akumuli是时间序列数据库，具有最低的资源消耗和摄取大量事件的能力。这使得它成为集群范围的应用程序或主机级指标的良好选择，这些指标需要实现时间解析，而使用定期擦除是不可能的。此外，Akumuli很简单:它预先分配卷，只保留最新的可用指标，因此永远不会耗尽空间。Akumuli中的度量结构与普罗米修斯相同:数值、时间戳和标签。</p><p id="411d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">时间序列数据库应该简单快速。因此，实时分析(连续查询等。)是由声纳执行的。Sonar定期执行的每个查询的结果都可以写入Akumuli，暴露给Prometheus或发送到其他目的地。声纳连续查询的配置可以在运行时改变，而不会影响时间序列数据库。</p><p id="2a7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在时间序列数据库、指标收集代理和用于收集和分析所收集数据的实时处理作业之间提供了良好的分离。因此，声纳可以作为监测代理和分析引擎与阿库木里时间序列数据库。</p><p id="64be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将Akumuli和Sonar结合使用可提供以下功能:</p><ul class=""><li id="aeea" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">收集需要高时间分辨率的指标，包括信号(IoT)、事件甚至不同级别的快照:应用程序、主机。</li><li id="1f5c" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">使用推或拉的资源消耗更低。Sonar支持通过TCP或UDP向Akumuli发送度量。</li><li id="957b" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">在应用程序或主机级别以高时间分辨率分析指标，以实现早期异常检测和警报。</li><li id="7ca7" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">通过缩减采样和将结果暴露到集群级别来减少指标数量:需要时使用Prometheus。</li><li id="882d" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">在收集和分析期间灵活配置标签和重新标签指标(缩减采样等。).</li></ul><p id="1be0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，使用Akumuli作为时间序列数据库，同时使用Sonar作为监控代理和处理引擎，可以简化指标收集、采样、重新标记以及将收集的时间序列暴露给其他目的地，包括Prometheus。这开启了许多新的场景，包括Kubernetes的场景:</p><ul class=""><li id="aafe" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">在需要低延迟来接收大量高频率事件的环境中，可以收集、合并和缩减采样物联网类型指标。制造业和机器人只是其中的一些例子。</li><li id="2790" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">在Kubernetes上扩展现代化的Windows应用程序。现在就可以做到这一点，通过在Windows容器上部署Sonar代理来公开带有或不带有下采样的自定义指标。因此，可以从性能计数器、WMI、SQL Server、MySQL收集指标，并扩展到其他来源。</li><li id="a120" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">支持联合:使用处理引擎允许缩减采样度量，并将它们发送到时序数据库的另一个实例，或者暴露给Prometheus。这是由您可以随时更改的配置决定的。因此，从一个阿库穆利实例到另一个实例的联盟现在是可能的。</li><li id="cbfa" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">易于备份和恢复时间序列数据。与普罗米修斯相比，阿库穆利使用很少的文件作为卷。</li><li id="4abf" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">运行时更改成本低，可灵活选择公制标签，保留系列原始时间戳。与Prometheus类似，Sonar支持为连续查询重新标记原始时间序列数据。</li><li id="fb3c" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">在应用程序/主机级别对原始时间序列使用异常检测来预测或确定问题的根本原因。并非所有这些指标都适合暴露给普罗米修斯。</li></ul><p id="dafa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑一个简单的例子:订单处理。每个授权付款的订单都需要创建运费。用于运输的后端服务必须按需扩展，以避免在没有大量订单的情况下消耗资源。关于待发货订单的信息存储在数据库中，可用于缩放此pod。因此，目标是找到根据数据库中的订单数据来扩展pod的方法。以下是实现这一点的步骤:</p><h1 id="36d9" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">先决条件</h1><p id="e1c8" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">要在Kubernetes上从Prometheus向HPA公开定制指标，请遵循GitHub上的这个<a class="ae kw" href="https://github.com/stefanprodan/k8s-prom-hpa" rel="noopener ugc nofollow" target="_blank">存储库</a>中描述的说明。在部署metrics server、自定义指标API、Prometheus并运行示例以进行扩展后，以下步骤显示了如何通过缩减采样向HPA公开订单处理自定义指标。</p><h2 id="b402" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">步骤1:创建MySQL数据库和订单表</h2><p id="3029" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">使用Helm在Kubernetes上提供MySQL可以使用以下命令完成:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4dc4" class="mp ln iq ng b gy nk nl l nm nn">helm install stable/mysql --name mysql01  --set mysqlRootPassword=Pass@word1</span></pre><p id="ed15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，创建运输数据库和订单表:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1046" class="mp ln iq ng b gy nk nl l nm nn">mysql -u root -p<br/>mysql&gt; source create-tables.mysql </span></pre><p id="b0cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">脚本非常简单:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5b79" class="mp ln iq ng b gy nk nl l nm nn">CREATE DATABASE IF NOT EXISTS `orders_shipping`;<br/>USE `orders_shipping`;<br/>DROP TABLE IF EXISTS `orders`;<br/>CREATE TABLE orders (<br/> `id` MEDIUMINT NOT NULL AUTO_INCREMENT,<br/>        `tid` VARCHAR(32) NOT NULL,<br/>  `state` VARCHAR(32) NOT NULL,<br/> `createdAt` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,<br/> PRIMARY KEY(`id`),<br/> UNIQUE KEY(`tid`)<br/>) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><span id="2dbc" class="mp ln iq ng b gy no nl l nm nn">USE `orders_shipping`;<br/>INSERT INTO orders(tid,state) VALUES('12345','Pending');</span></pre><p id="8b55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，可以通过简单的insert SQL语句模拟新订单，其中的数据稍后将用于HPA:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5d97" class="mp ln iq ng b gy nk nl l nm nn">INSERT INTO orders(tid,state) VALUES('12345','Pending');<br/>Query OK, 1 row affected (0.05 sec)</span></pre><h2 id="28e0" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">步骤2:将Akumuli时间序列数据库部署到k8s</h2><p id="5605" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">除了Prometheus之外，本例还将使用Akumuli时间序列数据库(参见先决条件)。克隆GitHub上的<a class="ae kw" href="http://github.com/infragravity/charts" rel="noopener ugc nofollow" target="_blank">图表</a>库。假设您创建了本地路径为<em class="kx">~/github . com/infra gravity/charts</em>的目录，可以使用以下命令部署Akumuli:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="0c96" class="mp ln iq ng b gy nk nl l nm nn">helm install ~/github.com/infragravity/charts/stable/akumuli --name=aku --set image.repository=akumuli/akumuli,image.tag=skylake</span></pre><p id="aa9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Akumuli存储卷的卷数及其大小可以在命令行或values.yml中设置，包括在此图表中。</p><h2 id="ee46" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">步骤3:为k8s配置和部署Sonar监控代理</h2><p id="9100" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">首先，让我们选择查询以轮询特定时间间隔内处于待定状态的订单:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="275b" class="mp ln iq ng b gy nk nl l nm nn">select count(*) as pending_orders_total from orders_shipping.orders where state='Pending' and timestampdiff(MINUTE,createdAt,NOW())&gt;1;</span></pre><p id="17c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用该查询，Sonar代理可以配置为使用MySQL输入适配器，如<strong class="ka ir"> orders.config </strong>文件所示，该文件包含在此Helm图表中:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="dcf5" class="mp ln iq ng b gy nk nl l nm nn">&lt;?xml version="1.0"?&gt;<br/>&lt;configuration&gt;<br/>  &lt;configSections&gt;<br/>    &lt;section name="Sonar" type="Infragravity.Sonar.SonarConfigurationSection, Sonar"/&gt;<br/>  &lt;/configSections&gt;<br/>  &lt;connectionStrings&gt;<br/>    &lt;add name="akumulidb" providerName="akumuli" connectionString="Data Source = tcp://aku-akumuli:8282;Initial Catalog=main;User Id =; Password =; Application Name = default;Max Pool Size=200;Packet Size=2048;Connection Timeout=100"/&gt;<br/>    &lt;add name="mysqldb" providerName="mysql" connectionString="Server=mysql01-mysql;Database=orders_shipping; User Id=root; Password={$mysql_password};Encrypt=false;" /&gt;<br/>  &lt;/connectionStrings&gt;<br/>  &lt;Sonar&gt;<br/>    &lt;Runtime scrapeIntervalSeconds="5" skipSSLCheck="true" threads="1"/&gt;<br/>    &lt;InputAdapters&gt;<br/>        &lt;add provider="mysql" type="Samples.Sonar.Adapters.MySql.MySqlAdapterFactory" path="Samples.Sonar.Adapters.MySql.dll" /&gt;<br/>    &lt;/InputAdapters&gt;<br/>    &lt;Schedules&gt; <br/>        &lt;add name="m01" query="orders_pending" input="mysqldb" intervalSeconds="10" output="akumulidb" /&gt;<br/>    &lt;/Schedules&gt;<br/>    &lt;Servers&gt;<br/>    &lt;/Servers&gt;   <br/>    &lt;Queries&gt;<br/>        &lt;add name="orders_pending" type="sql"<br/>        filter="SELECT count(*) as total from orders_shipping.orders where state='Pending' and timestampdiff(MINUTE,createdAt,NOW())&gt;1;"&gt;<br/>                &lt;Tags&gt;                   <br/>                    &lt;add name="type" value="orders" readonly="true" /&gt;<br/>                &lt;/Tags&gt;<br/>                &lt;Instances&gt;              <br/>                &lt;/Instances&gt;<br/>                &lt;Values&gt;<br/>                &lt;/Values&gt;<br/>        &lt;/add&gt;                <br/>    &lt;/Queries&gt;<br/>  &lt;/Sonar&gt;<br/> &lt;/configuration&gt;</span></pre><p id="2e64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，使用Helm chart部署Sonar代理和定制的MySQL数据库适配器:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7f7e" class="mp ln iq ng b gy nk nl l nm nn">helm install ~/github.com/infragravity/charts/stable/sonar --name orders-agent --set image.repo=infragravity/sample-mysql,image.tag=latest,config.name=samples/custom-metrics/orders.config,config.log_level=Debug</span></pre><p id="fc14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，检查pod日志，验证它能够从数据库中查询数据，并将结果发送到Akumuli时间序列数据库。</p><h2 id="f892" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">步骤4:为k8s配置和部署Sonar运行时</h2><p id="4ca0" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">现在我们已经在Akumuli中收集了数据，下一步是部署连续查询，用于缩减采样并将数据公开给Prometheus。之后，自定义指标API服务将能够访问自动缩放所需的订单指标。为此，使用连续查询配置文件<em class="kx"> orders-cq.config </em>:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4f77" class="mp ln iq ng b gy nk nl l nm nn">&lt;?xml version="1.0"?&gt;<br/>&lt;configuration&gt;<br/>  &lt;configSections&gt;<br/>    &lt;section name="Sonar" type="Infragravity.Sonar.SonarConfigurationSection, Sonar"/&gt;<br/>  &lt;/configSections&gt;<br/>  &lt;connectionStrings&gt;<br/>    &lt;add name="input-akumuli-http" providerName="akumuli-http-receive" connectionString="Server=<a class="ae kw" href="http://aku-akumuli/api/query" rel="noopener ugc nofollow" target="_blank">http://aku-akumuli/api/query</a>; Connect Timeout=5;" /&gt;<br/>  &lt;/connectionStrings&gt;<br/>  &lt;Sonar&gt;<br/>    &lt;Runtime scrapeIntervalSeconds="5" skipSSLCheck="true" threads="1"/&gt;<br/>    &lt;InputAdapters&gt;<br/>        &lt;add provider="akumuli-http-receive" type="Infragravity.Sonar.Adapters.Akumuli.Http.InputAdapterFactory,Infragravity.Sonar.Adapters.Akumuli.Http" /&gt;<br/>    &lt;/InputAdapters&gt;<br/>    &lt;Schedules&gt; <br/>        &lt;add name="a01" query="aku-test" input="input-akumuli-http" intervalSeconds="20" /&gt;<br/>    &lt;/Schedules&gt;<br/>    &lt;Servers&gt;<br/>    &lt;/Servers&gt;   <br/>    &lt;Queries&gt;<br/>        &lt;add name="aku-test" type="raw" timestamp="ts"<br/>        filter="{ 'group-aggregate':<br/>                    {<br/>                    'metric': 'orders-pending-total',<br/>                    'step': '20s',<br/>                    'func': ['mean','min','max']<br/>                    },<br/>                    'range': { 'from': 'timeshift(20s)','to': 'timeshift(0s)'},<br/>                    'output': { 'format': 'csv','timestamp': 'raw'  },<br/>                    'limit' : '100',<br/>                    'order-by':'series',<br/>                    'apply':[] }"&gt;<br/>            &lt;Tags&gt;                   <br/>               &lt;add name="namespace" value="default" readonly="true" /&gt;<br/>               &lt;add name="deployment" value="podinfo" readonly="true" /&gt;<br/>            &lt;/Tags&gt;<br/>            &lt;Values&gt;<br/>            &lt;/Values&gt;<br/>            &lt;Labels&gt;<br/>                &lt;add name="source" regex="type=(.+)" targetLabel="metric" replacement="$2"/&gt;<br/>            &lt;/Labels&gt;<br/>        &lt;/add&gt;<br/>    &lt;/Queries&gt;<br/>  &lt;/Sonar&gt;<br/> &lt;/configuration&gt;</span></pre><p id="3cc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，查询使用Sonar中的<em class="kx"> timeshift() </em>函数从Akumuli获取缩减采样的度量值。为连续查询配置的值“ts”允许保存来自Akumuli时间序列数据库的时间戳。接下来，它将标签应用到结果时间序列，以便使用部署和名称空间标签将它们与Kubernetes中的工件关联起来。在本例中，收集的指标将与默认名称空间中名为“podinfo”的部署相关。在结果被标记后，度量被暴露给Prometheus，它使用注释发现声纳目标端点。</p><p id="e103" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，部署Sonar来运行连续查询:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b9d7" class="mp ln iq ng b gy nk nl l nm nn">helm install ~/github.com/infragravity/charts/stable/sonar \<br/> --name orders-cq \<br/> --set image.repo=infragravity/sonar,image.tag=edge,config.name=samples/custom-metrics/orders-cq.config,config.log_level=Debug</span></pre><p id="d616" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">部署后，验证自定义指标API可以在一分钟或更短时间内从Prometheus查询此指标:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f789" class="mp ln iq ng b gy nk nl l nm nn">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/deployments.extensions/podinfo/akutest_orders_pending_total_mean" | jq .</span></pre><p id="70e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果应该与下面类似，只显示一个处于待定状态的订单:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e047" class="mp ln iq ng b gy nk nl l nm nn">{<br/>  "kind": "MetricValueList",<br/>  "apiVersion": "custom.metrics.k8s.io/v1beta1",<br/>  "metadata": {<br/>    "selfLink": "/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/deployments.extensions/podinfo/akutest_orders_pending_total_mean"<br/>  },<br/>  "items": [<br/>    {<br/>      "describedObject": {<br/>        "kind": "Deployment",<br/>        "name": "podinfo",<br/>        "apiVersion": "extensions/__internal"<br/>      },<br/>      "metricName": "akutest_orders_pending_total_mean",<br/>      "timestamp": "2018-02-05T18:53:45Z",<br/>      "value": "1"<br/>    }<br/>  ]<br/>}</span></pre><h2 id="1cd5" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">步骤5:为k8s上的HPA创建自动扩展策略</h2><p id="f9c7" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">到目前为止，指标已经公开，我们需要为autoscaler创建策略，部署名称为:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="9bec" class="mp ln iq ng b gy nk nl l nm nn">apiVersion: autoscaling/v2beta1<br/>kind: HorizontalPodAutoscaler<br/>metadata:<br/>  name: orders-shipping<br/>spec:<br/>  scaleTargetRef:<br/>    apiVersion: extensions/v1beta1<br/>    kind: Deployment<br/>    name: podinfo<br/>  minReplicas: 1<br/>  maxReplicas: 4<br/>  metrics:<br/>  - type: Object<br/>    object:<br/>      target:<br/>        kind: Deployment<br/>        name: podinfo<br/>      metricName: akutest_orders_pending_total_mean<br/>      targetValue: 4</span></pre><p id="4876" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，自定义指标可以在Sonar连续查询中使用元数据触发扩展部署。接下来，部署策略</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4d18" class="mp ln iq ng b gy nk nl l nm nn">kubectl create -f ./custom-metrics-hpa.yml</span></pre><p id="b8ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大约一分钟后，您将看到HPA识别指标:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="8dba" class="mp ln iq ng b gy nk nl l nm nn">&gt;kubectl get hpa     <br/>NAME              REFERENCE            TARGETS     MINPODS   MAXPODS   REPLICAS   AGE<br/>orders-shipping   Deployment/podinfo   1 / 4       1         2         2          1m</span></pre><h2 id="3894" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">步骤5:模拟未决订单和规模</h2><p id="2b44" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在这一点上，所有需要的是模拟订单，可以通过修改MySQL数据库中的订单表来完成。通过再添加5个订单，观察在之前步骤中创建的扩展策略的HPA状态:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="8762" class="mp ln iq ng b gy nk nl l nm nn">kubectl describe hpa<br/>Name:                                                         orders-shipping<br/>Namespace:                                                    default<br/>Labels:                                                       &lt;none&gt;<br/>Annotations:                                                  &lt;none&gt;<br/>CreationTimestamp:                                            Mon, 05 Feb 2018 11:47:27 -0800<br/>Reference:                                                    Deployment/podinfo<br/>Metrics:                                                      ( current / target )<br/>  "akutest_orders_pending_total_mean" on Deployment/podinfo:  6 / 4<br/>Min replicas:                                                 1<br/>Max replicas:                                                 4<br/>Conditions:<br/>  Type            Status  Reason              Message<br/>  ----            ------  ------              -------<br/>  AbleToScale     True    SucceededRescale    the HPA controller was able to update the target scale to 3<br/>  ScalingActive   True    ValidMetricFound    the HPA was able to succesfully calculate a replica count from Deployment metric akutest_orders_pending_total_mean<br/>  ScalingLimited  False   DesiredWithinRange  the desired count is within the acceptable range<br/>Events:<br/>  Type    Reason             Age   From                       Message<br/>  ----    ------             ----  ----                       -------<br/>  Normal  SuccessfulRescale  23s   horizontal-pod-autoscaler  New size: 3; reason: Deployment metric akutest_orders_pending_total_mean above target</span></pre><p id="2a3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成了。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b715" class="mp ln iq ng b gy nk nl l nm nn">kubectl describe hpa<br/>Name:                                                         orders-shipping<br/>Namespace:                                                    default<br/>Labels:                                                       &lt;none&gt;<br/>Annotations:                                                  &lt;none&gt;<br/>CreationTimestamp:                                            Mon, 05 Feb 2018 11:47:27 -0800<br/>Reference:                                                    Deployment/podinfo<br/>Metrics:                                                      ( current / target )<br/>  "akutest_orders_pending_total_mean" on Deployment/podinfo:  6 / 4<br/>Min replicas:                                                 1<br/>Max replicas:                                                 4<br/>Conditions:<br/>  Type            Status  Reason            Message<br/>  ----            ------  ------            -------<br/>  AbleToScale     True    ReadyForNewScale  the last scale time was sufficiently old as to warrant a new scale<br/>  ScalingActive   True    ValidMetricFound  the HPA was able to succesfully calculate a replica count from Deployment metric akutest_orders_pending_total_mean<br/>  ScalingLimited  True    TooManyReplicas   the desired replica count is more than the maximum replica count<br/>Events:<br/>  Type     Reason                        Age                 From                       Message<br/>  ----     ------                        ----                ----                       -------<br/>  Normal   SuccessfulRescale             11m                 horizontal-pod-autoscaler  New size: 3; reason: Deployment metric akutest_orders_pending_total_mean above target<br/>  Normal   SuccessfulRescale             7m                  horizontal-pod-autoscaler  New size: 4; reason: Deployment metric akutest_orders_pending_total_mean above target</span></pre><p id="1a9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，可以减少订单记录的数量，以便缩小部署规模。</p><h1 id="3ec8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="10c1" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">首先，这要归功于Prometheus为启用定制指标所做的出色工作，如先决条件中所述)。</p><p id="e7a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用一个Sonar部署从MySQL数据库收集数据，连续查询下采样并将数据暴露给Prometheus，上面的示例甚至可以更加简洁。此外，不经常变化的指标不需要下采样，可以由声纳收集并暴露给Prometheus。</p><p id="9946" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然上面的示例使用了拉方法，但是当需要基于订单处理中的事件进行缩放时，您也可以使用推方法。这允许为需要事件和高时间分辨率的许多类型的应用级度量实现对称。我们将在以后的文章中讨论一个使用相同拓扑来演示推送的例子。</p></div></div>    
</body>
</html>