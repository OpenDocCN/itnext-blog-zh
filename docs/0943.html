<html>
<head>
<title>How I structure production grade REST API’s in Golang.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在Golang中构建生产级REST API？</h1>
<blockquote>原文：<a href="https://itnext.io/structuring-a-production-grade-rest-api-in-golang-c0229b3feedc?source=collection_archive---------0-----------------------#2018-06-23">https://itnext.io/structuring-a-production-grade-rest-api-in-golang-c0229b3feedc?source=collection_archive---------0-----------------------#2018-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/673bcea2da76e8310483ff596de85cc2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3UaLDKs6bJRMtYoPDCIWBw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">人们不会简单地在golang中创建一个api或者他们会吗？</figcaption></figure><p id="6695" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一种误解认为用golang编写的API不能像其他语言一样简单和地道。实际上，我遇到过许多REST API代码库，它们被如此多的抽象弄得一团糟，最终损害了可读性和可维护性。</p><p id="19d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个系列中，我们将介绍如何构建一个生产级的todo list rest api，它将有机地增长，从代码结构和路由等必需品开始，然后继续添加一个mongo db和一个badger数据存储层，然后是一个身份验证层。</p><p id="8fac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个系列中，我们将使用chi路由器。</p><figure class="kx ky kz la gt jq gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/cbfdec901c790847dc63c99fec71a8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*X58wCXhjTjXW5F7FP5mWnQ.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">chi路由器</figcaption></figure><h1 id="92cd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么是池？为什么不是标准库，或者Gin，或者router-x？</h1><p id="48f2" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">嗯，没那么重要。无论您使用哪种路由器，本系列中将要讨论的概念都适用。但是有一个清单让我认为Chi-router是比大多数替代品更好的选择:</p><ul class=""><li id="b8b8" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">100%兼容net/http——在生态系统中使用与<code class="fe mn mo mp mq b">net/http</code>兼容的任何http或中间件pkg</li><li id="8feb" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv mj mk ml mm bi translated">专为模块化/可组合API设计——中间件、内嵌中间件、路由组和子路由安装</li><li id="ee11" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv mj mk ml mm bi translated">无外部依赖性—普通ol' Go 1.7+ stdlib + net/http</li><li id="8ffb" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv mj mk ml mm bi translated">稳健——在Pressly、CloudFlare、Heroku、99Designs和许多其他公司投入生产</li><li id="92d6" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv mj mk ml mm bi translated">轻量级—为chi路由器提供约1000 LOC的时钟</li><li id="f445" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv mj mk ml mm bi translated">是的，真的很快。</li></ul><p id="1edb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最喜欢的是，您为其他net/http兼容路由器编写的相同的旧http处理程序和中间件在这里也可以工作。</p><h1 id="81f5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们开始吧</h1><p id="6d68" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">首先，我们创建我们的主。去。角石(或中心部分🙂)我们节目的。</p><figure class="kx ky kz la gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/d9701a6bba2c647aedd62e852349a7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEItdQCk8Z2V3TgNqyuNXg.png"/></div></div></figure><h1 id="3b48" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">上面代码中一些最佳实践的亮点</h1><ol class=""><li id="5ccc" class="me mf iq ka b kb lz kf ma kj nb kn nc kr nd kv ne mk ml mm bi translated">将路由分组到各个程序包中的逻辑组中，然后装载这些路由:</li></ol><pre class="kx ky kz la gt nf mq ng nh aw ni bi"><span id="48f1" class="nj lc iq mq b gy nk nl l nm nn">r.Mount("/api/todo", todo.Routes())</span></pre><p id="7d7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.版本api，因此您可以在不破坏旧客户端的情况下进行API更新:</p><pre class="kx ky kz la gt nf mq ng nh aw ni bi"><span id="5e7a" class="nj lc iq mq b gy nk nl l nm nn">router.Route("/v1", ....)</span></pre><p id="3b4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.广泛使用中间件。大多数被多个路由大量使用的代码可以被转化成可链接的中间件。例如认证、设置响应头、压缩、请求记录、速率限制等。</p><p id="46f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">编辑(我将根据评论中</strong> <a class="no np ep" href="https://medium.com/u/4b8f17fbf02f?source=post_page-----c0229b3feedc--------------------------------" rel="noopener" target="_blank"> <strong class="ka ir">阿金克亚</strong> </a> <strong class="ka ir">的一个问题，进一步说明步行功能。):</strong></p><p id="d4c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">chi路由器有一个叫walk的方法。该方法接收:</p><ul class=""><li id="ed02" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">路由器</li><li id="53a8" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv mj mk ml mm bi translated">回调。</li></ul><p id="06a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为路由器上定义的每个路由调用回调，并接收4个参数:</p><ol class=""><li id="c971" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv ne mk ml mm bi translated">为路线定义的方法</li><li id="e17a" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv ne mk ml mm bi translated">实际路线字符串</li><li id="f0e4" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv ne mk ml mm bi translated">处理给定路由请求的处理器(函数)</li><li id="7fdb" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv ne mk ml mm bi translated">为给定路由定义的中间件列表(中间件只是在调用处理程序之前被调用的函数，因此它们用于预处理请求、验证等)</li></ol><p id="3e9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，我简单地遍历路由器并打印所有定义的路由。这有助于我一目了然地看到所有可用的路线。</p><h1 id="c959" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">接下来我们构建todo包，它实际上保存了我们的todo逻辑。</h1><figure class="kx ky kz la gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nq"><img src="../Images/0d1095edd8f7003defebf13b6af40a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bH-03IB5wAjFQjB1hmAU1w.png"/></div></div></figure><h1 id="dfa8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">注意事项</h1><ol class=""><li id="bc64" class="me mf iq ka b kb lz kf ma kj nb kn nc kr nd kv ne mk ml mm bi translated">todo包有一个函数返回它的所有路线。的路由安装在main.go中。实际上，我通常会将这些路由添加到名为<em class="nr"> routes.go、</em>的文件中，这样很容易在包<em class="nr">中找到。</em></li><li id="9631" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv ne mk ml mm bi translated">处理程序有函数签名<code class="fe mn mo mp mq b">func (w http.ResponseWriter,r *http.Request) </code>,这意味着如果您在标准库中使用net/http，您将编写的处理程序没有什么不同。</li><li id="13a0" class="me mf iq ka b kb mr kf ms kj mt kn mu kr mv kv ne mk ml mm bi translated">渲染的使用。json只是编码/json的包装器，它自动转义JSON响应中的所有html，并将内容类型设置为application/json</li></ol><p id="4503" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你对它的简单程度感到震惊吗？在github上的<a class="ae ns" href="https://github.com/tonyalaribe/todoapi/tree/master/basestructure" rel="noopener ugc nofollow" target="_blank">https://github . com/tonyalaribe/todo API/tree/master/base structure</a>查看这个项目。</p><p id="fbb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的下一篇文章中，我们将继续添加对配置和共享状态的支持。大多数项目通常需要外部配置，如数据库连接细节等。我们将在下一篇文章中讨论这个问题。</p><h1 id="c02d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">别忘了打个招呼，甚至让我知道你想学什么。我可能会有灵感去写它🙂。</h1><h1 id="81c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要忘记鼓掌，如果这对你有用的话。</h1></div></div>    
</body>
</html>