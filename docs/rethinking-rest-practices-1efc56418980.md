# 反思休息实践

> 原文：<https://itnext.io/rethinking-rest-practices-1efc56418980?source=collection_archive---------1----------------------->

## 使用 AWS AppSync 的 GraphQL 简介

![](img/45f29145fcee99ac9c98d42cf1bd983b.png)

这是 API 开发…

> 最终，您会意识到 API 开发只不过是列表操作。

# 思考数据的更好方式

## 结局是尽人皆知的

数据传输的基本前提，包括请求和接收列表。这很简单，但它触及到了我们开发使用 web 服务传递数据的技术和最佳实践的根本原因。RESTful APIs 已经发展到可以满足全球众多个人、创业公司和企业的需求。它们有用、高效，围绕它们的概念也相对标准化。如果您不知道如何创建一个 API，您可以很快找到构建一个可以满足您需求的优秀 API 的信息。这时候事情就复杂了…

如果你开始钻研 REST，你会意识到抛出列表有更多的意义。许多人在开发 API 时都会遇到一些常见的问题，您也会遇到许多其他人曾经遇到过的问题，例如:

*   你应该多严格地遵守休息原则？你如何决定哪些算？
*   你应该如何处理版本控制？你应该烦恼吗？
*   你想如何组织你的对象？什么样的数据形式最适合您的 API 的客户端？
*   您是否向用户发送了适当的数据？你在给他们发送他们不需要的信息吗？
*   关于相关或层次数据，他们是否能够从嵌套结构中高效地查询他们需要的内容？
*   用户是否能够很容易地找出哪些 API 端点是可用的，以及应该如何使用它们？

有许多方法可以实现这些，归结起来就是传达给定端点将返回或接受的结构。这里所做的选择产生的一连串问题将从后端波及到客户端。第二个问题是，这些问题和选择并不罕见。这些问题的答案都遵循最佳实践。但是，当试图构建一个灵活的、工作良好的 API 时，仍然存在许多模糊之处。这些是通常被容忍的情况。

如果你还没有猜到，有一个解决方案可以将我们从休息的教条中解放出来，并允许我们以一种声明性的、强大的、有趣的 T2 方式来解决所有这些问题。这个解决方案就是 **GraphQL** 。

## 规格和结构

GraphQL 首先是一个规范。它使您的数据交互成为声明性的。该规范的实现需要创建一个描述数据类型(更具体地说，是形状)的模式，该模式向 API 的客户端公开。它不是数据库的替代品，也不是一个对象关系映射系统——它是一套工具，用来替代(我们将在后面看到，增强)传统的 REST API。这可以与您可能已经用来与数据交互的所有业务层和软件层结合使用。

交互采取的形式是发送到传统上单个 GraphQL 端点的查询。您可能经常看到这个端点类似于 www.mysite.com/graphql.的一个**客户端**(您的应用程序)可以向**服务器**发送包含**查询**(获取数据)和**突变**(操作数据)的请求。GraphQL 服务器接收到一个**查询**或**变异**并将其分解成组成部分，数据**被解析**并发回。它可以被分解，因为 GraphQL 服务器使用一个**模式**来了解它可以解析的不同**类型的数据**以及哪些**解析器**用于那些**类型**。

哇哦。那里有很多。让我们把它分解开来，从最基本的开始。

# 从类型生成

使用 GraphQL 时释放的所有强大功能的基础都归结于类型。这使得您的 API 调用具有结构化的性质。这允许服务器智能地返回符合该结构的数据。这允许客户端自省该数据，以发现允许它使用的结构。这种自省提供的开发体验和工具远远超出了传统 REST API 所允许的生成文档。

> 默认情况下，内省、工具化和缺乏仪式意味着更少的愚蠢。

REST API 中存在的许多问题要么是不可能的，要么至少不容易重现。许多通常被容忍的情况消失了。让我们通过查看一些基本的类型示例来更深入地了解这些思想。

下面是一个包含标题、描述和评级的`Game`基本类型的例子。

```
type Game {
  title: String!
  description: String
  rating: Int!
}
```

该类型声明声明了在查询或变异中引用游戏时可以返回的对象类型。`title`被声明为`String!`——这意味着该值应该是一个字符串，感叹号意味着该值不可为空(也就是必需的)。这表示当游戏类型被检索或创建时，该契约将被强制执行，并生成一个错误，表示该值不存在。

默认情况下，GraphQL 中有五种标量类型。这些包括`String`、`Int`、`Float`、`Boolean`和`ID`。模式中声明的所有类型都归结于这些(在自定义服务器实现中，您可以实现自己的类型)。这意味着所有用户定义的类型，比如上面的`Game`类型，必须提供**解析器**，以便可以从服务、数据库或其他数据源收集数据。

# 下决心者

解析器用于检索或操作由类型定义的数据。例如，我们上面列出的`Game`类型可能有一个解析器，它从一个表中查询所有游戏的数据库。它可能调用一个服务，该服务又调用一个查询该表的 DAO 层。它甚至可能有一个解析器，调用 REST API 返回游戏列表。解析器应该做的就是关心它被定义要解析的数据类型。这样，他们可以将任何数据源或服务整合到一个统一的 API 中。

> 解析器通过解析来自服务、DAO 甚至其他 REST API 的类型来提供适应性强的 API 表面。

这是关键。这种基于类型的方法让您可以将数据更多地看作是桶或列表，而不是结构之间的关系。类型之间的关系可以建立在松散耦合的可能性中，而不是强耦合的结果中。我们稍后将回到这个区别。

# 查询和突变

查询和突变是 GraphQL 实现中两种可能的交互类型。查询从服务器请求数据。突变通过引起副作用和返回结果来与数据交互。它们依赖解析器对数据进行操作。它们提供了客户端用来与数据交互的 API 接口。让我们来看一些基础知识。

## 问题

让我们看一个使用我们之前定义的游戏类型来获取游戏列表的查询的基本示例。

```
allGames {
  title
  description
  rating
}
```

这是 GraphQL 服务器可以解析的基本请求的结构。这告诉服务器运行模式中定义的`allGames`查询，并返回每个游戏的`title`、`description`和`rating`属性。这使用由模式为`allGames`查询定义的解析器从数据源实际获取数据。

## 突变

这是一个创造游戏的基本突变的例子。

```
createGame (
  title: String!, 
  description: String, 
  rating: Int! ) 
{
  title
  description
  rating
}
```

这个例子展示了如何定义一个接受`title`、`description`和`rating`作为变量的突变。这个`createGame`变异的解析器将负责获取变量并将它们插入到一个表中，调用服务，或者处理变异所需要的操作。该操作将完成并返回插入的数据。

我们将稍微深入了解一下查询和突变。接下来，让我们讨论一下所有这些概念是如何在客户机和服务器上结合在一起的。

# 客户端和服务器

## 客户

客户端有点超出了本文的范围。简单地说，它可以从简单的 HTML 页面发送 POST 或 GET 请求到使用 GraphQL 客户端库，比如 [Apollo](https://www.apollographql.com/client/) 。我们将在以后的帖子中讨论这个问题…

## 计算机网络服务器

GraphQL 服务器是 API 的主干。这就是接收请求并处理它们以返回数据或执行变异的部分。这可以是自定义实现([节点](https://github.com/graphql/graphql-js)，[)。Net](https://github.com/graphql-dotnet/graphql-dotnet) 、 [Java](http://graphql-java.readthedocs.io/en/latest/) 等……)或者托管服务实例(比如 [AppSync](https://aws.amazon.com/appsync/) 或者 [Graphcool](https://www.graph.cool/) )。

对于传统的 REST API，您可能有一系列端点来定义客户端可以请求的数据。当您向特定端点发送请求时，作为响应接收的数据或执行的操作由服务器提前定义。这与 GraphQL 端点形成鲜明对比，因为您发送的任何特定请求都是基于该请求中包含的内容进行处理的。服务器通过描述响应的*可能性*而不是响应本身来处理这个问题。客户端负责根据允许的查询和变化请求它需要的内容或它想要执行的操作。

> 查询不描述返回的内容。相反，它描述了什么*可以被*返回。合同不是一组数据，合同是数据的一种形式。

您选择的实现将负责解析这些操作并对它们做出反应。让我们通过用 AWS AppSync 启动我们自己的实例来看看这在实践中意味着什么。

更多将在[的下一部](https://medium.com/@mwarger/go-forth-and-appsync-34450c277075)中出现。看看吧！

# 最后

我认为在大多数情况下，GraphQL 客观上是 RESTful APIs 的更好替代方案。它的灵活性在其类型系统和支持的技术中表现得最为突出。这带来了优秀的工具、美妙的开发体验和传统 API 开发无法比拟的快速迭代周期。我们将很快检查 AWS AppSync，看看它与传统的 REST API 相比如何— [如果您想知道下一篇文章何时发布，请在 Twitter @ m larger](https://twitter.com/mwarger)上关注我。有关使用 GraphQL 开发 API 的更多信息，请查看 [HowToGraphQL](https://www.howtographql.com/) 。如果您有任何问题或意见，请在下面留下。

> 我叫 Mat Warger，是 [Keyhole 软件](http://www.keyholesoftware.com)的开发人员。这里的想法是我自己的。
> 
> 如果你喜欢这篇文章，请为它鼓掌并分享给你的朋友。我喜欢写令人兴奋的新技术，所以如果你愿意，也可以关注这里或 twitter！

## 感谢您的阅读！