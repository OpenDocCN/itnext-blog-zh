<html>
<head>
<title>Kubernetes-based Microservice Observability with Istio Service Mesh: Part 2 of 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Kubernetes的Istio服务网格的微服务可观测性:第2部分，共2部分</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-based-microservice-observability-with-istio-service-mesh-part-2-of-2-ceec27575040?source=collection_archive---------2-----------------------#2021-06-11">https://itnext.io/kubernetes-based-microservice-observability-with-istio-service-mesh-part-2-of-2-ceec27575040?source=collection_archive---------2-----------------------#2021-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb66" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Istio服务网格在亚马逊EKS上使用Jaeger、Prometheus、Grafana、Kiali和Fluent Bit观察分布式系统</h2></div><p id="a9a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇由两部分组成的文章的第二部分中，我们将继续探索与Istio服务网格轻松集成的一组流行的开源可观察性工具。虽然这些工具不是Istio的一部分，但它们对于充分利用Istio的可观察性特性是必不可少的。这些工具包括用于分布式事务监控的<strong class="kk iu"> Jaeger </strong>和<strong class="kk iu"> Zipkin </strong>，用于指标收集和警报的<strong class="kk iu"> Prometheus </strong>，用于指标查询、可视化和警报的<strong class="kk iu"> Grafana </strong>，以及用于Istio整体可观察性和管理的<strong class="kk iu"> Kiali </strong>。我们将通过添加用于日志处理和聚合的<strong class="kk iu"> Fluent Bit </strong>来完善工具集。我们将使用这些工具来观察部署到<strong class="kk iu">亚马逊弹性Kubernetes服务(亚马逊EKS) </strong>集群的分布式、基于微服务的参考应用平台。该平台运行在EKS上，将使用亚马逊文档数据库作为持久数据存储，并使用亚马逊MQ来交换信息。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/37c8eeadc51933d4f622774230efb9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJGRL8oxig119UfbkSMcig.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">显示参考应用平台的Kiali管理控制台</figcaption></figure><h1 id="5810" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可观察性</h1><p id="62bf" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">辛迪·斯里德哈兰所著的《分布式系统可观测性》一书在第四章中描述了可观测性的三大支柱。虽然简单地访问日志、度量和跟踪并不一定使系统更容易被观察到，但是这些是强大的工具，如果理解得好，可以释放构建更好的系统的能力。”</p><h1 id="64b5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考应用平台</h1><p id="df42" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">为了展示Istio的可观察性工具，我们在AWS上为EKS部署了一个参考应用平台。我开发了应用程序平台来演示不同的Kubernetes平台，如EKS、GKE、AKS，以及服务网格、API管理、可观察性、DevOps和混沌工程等概念。该平台包括一个后端，包含八个基于Go的微服务，一般标记为服务A-服务H，一个基于Angular 12 TypeScript的前端UI，四个MongoDB数据库和一个RabbitMQ消息队列。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mt"><img src="../Images/4b55840eff21834568e18353928f0c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXNzBd8uZxcsu7Mz67IioQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">参考应用平台的基于角度的用户界面</figcaption></figure><p id="db3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该平台及其所有源代码都在GitHub上开源。</p><div class="mu mv gp gr mw mx"><a href="https://github.com/garystafford/k8s-istio-observe-backend" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">garystafter/k8s-istio-observe-back end</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">两篇博文的源代码，基于Kubernetes的带有Istio服务网格的微服务可观察性。请参见…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl lp mx"/></div></div></a></div><p id="9345" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考应用程序平台旨在生成基于HTTP的服务到服务、基于TCP的服务到数据库和基于TCP的服务到队列到服务IPC(进程间通信)。比如服务A调用服务B和服务C；服务B调用服务D和服务E；服务D向RabbitMQ队列发送消息，服务F在RabbitMQ队列上使用消息，并写入MongoDB，依此类推。当系统部署到运行Istio服务网格的Kubernetes集群时，可以使用Istio的可观察性工具观察平台的分布式服务通信。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nm"><img src="../Images/6b369b886cfab64fbc689dafbad69a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TCC5Ol6HydyMvrD-.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">参考应用平台的高层架构</figcaption></figure><h1 id="dc3f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第二部分</h1><p id="bb0b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在文章的第一部分，我们在AWS上的亚马逊EKS开发级集群上配置和部署了参考应用平台。运行在EKS上的参考应用程序与两个外部系统通信，<a class="ae le" href="https://aws.amazon.com/documentdb/" rel="noopener ugc nofollow" target="_blank"> Amazon DocumentDB </a> ( <em class="ms">兼容MongoDB】)和<a class="ae le" href="https://aws.amazon.com/amazon-mq/" rel="noopener ugc nofollow" target="_blank"> Amazon MQ </a>。</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/116afe8991db0059cb8e30708e2a5026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FHsldTu9KzfPNwuTa6JEg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">从<a class="ae le" href="https://argoproj.github.io/argo-cd/" rel="noopener ugc nofollow" target="_blank"> Argo CD </a>中可以看到部署的参考应用平台</figcaption></figure><p id="268a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章的第二部分，我们将更详细地探讨我们安装的每个可观察性工具。我们将理解每个工具如何对可观察性的三个支柱做出贡献:日志、度量和跟踪。</p><blockquote class="no np nq"><p id="60dd" class="ki kj ms kk b kl km ju kn ko kp jx kq nr ks kt ku ns kw kx ky nt la lb lc ld im bi translated">日志、度量和跟踪通常被称为可观察性的三大支柱。<br/> —辛迪·斯里达哈兰</p></blockquote><h1 id="e6b6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">支柱一:原木</h1><p id="68ef" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">借用Jay Kreps在LinkedIn工程博客<a class="ae le" href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" rel="noopener ugc nofollow" target="_blank">上的话来说，日志是一个按时间排序的只追加的、完全有序的记录序列。记录的排序定义了“时间”的概念，因为左边的条目被定义为比右边的条目更老。日志是过去发生的事件的历史记录。日志几乎和计算机一样历史悠久，是许多分布式数据系统和实时应用程序架构的核心。</a></p><h2 id="0064" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">基于Go的微服务日志记录</h2><p id="9158" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">有效的日志记录策略始于您记录什么、何时记录以及如何记录。作为平台日志策略的一部分，八个基于Go的微服务使用了<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logrus </a>，这是一个流行的Go结构化日志程序，于2014年首次发布。该平台的服务还实现了万岁云的<a class="ae le" href="https://github.com/banzaicloud/logrus-runtime-formatter" rel="noopener ugc nofollow" target="_blank">日志运行时格式器</a>。这两个日志包让我们能够更好地控制您记录的内容、记录的时间以及记录服务信息的方式。封装的<a class="ae le" href="https://github.com/banzaicloud/logrus-runtime-formatter#usage" rel="noopener ugc nofollow" target="_blank">推荐配置</a>最小。我选择了Logrus' <code class="fe og oh oi oj b">JSONFormatter</code>,以便于第三方系统进行解析，并将额外的上下文数据字段注入到日志条目中。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="c3fc" class="nu lw it oj b gy oo op l oq or">func init() {<br/> formatter := runtime.Formatter{ChildFormatter: &amp;log.JSONFormatter{}}<br/> formatter.Line = true<br/> log.SetFormatter(&amp;formatter)<br/> log.SetOutput(os.Stdout)<br/> level, err := log.ParseLevel(logLevel)<br/> if err != nil {<br/>  log.Error(err)<br/> }<br/> log.SetLevel(level)<br/>}</span></pre><p id="d218" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与Go的简单日志包<a class="ae le" href="https://golang.org/pkg/log/" rel="noopener ugc nofollow" target="_blank"> log </a>相比，Logrus提供了几个优势。例如，日志条目不仅用于致命错误，也不应该在生产环境中输出所有详细日志条目。Logrus能够记录七个级别的日志:跟踪、调试、信息、警告、错误、致命和紧急。平台微服务的日志级别可以在运行时使用环境变量进行更改。</p><p id="8a91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Banzai Cloud的<a class="ae le" href="https://github.com/banzaicloud/logrus-runtime-formatter" rel="noopener ugc nofollow" target="_blank">logrus-runtime-formatter</a>自动用运行时和堆栈信息标记日志消息，包括函数名和行号——在故障排除时非常有用。在Banzai Cloud(现在是Cisco的一部分)格式化程序上有一个很好的帖子，<a class="ae le" href="https://banzaicloud.com/blog/runtime-logging/" rel="noopener ugc nofollow" target="_blank">Golang runtime Logrus Formatter</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a5456f9f956ad806b04263501c681bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sllqkuVdsiiaCE9yLMhjw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">CloudWatch Insights中的服务A日志条目</figcaption></figure><p id="1941" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2020年，<a class="ae le" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logus </a>进入维护模式。作者Simon Eskildsen(Shopify的首席工程师)表示，他们不会推出新功能。这并不意味着Logrus已经死了。Logrus拥有超过18，000颗GitHub星，将继续维护其安全性、错误修复和性能。作者表示，现在存在许多替代Logus的奇妙选择，如<a class="ae le" href="https://github.com/rs/zerolog" rel="noopener ugc nofollow" target="_blank"> Zerolog </a>、<a class="ae le" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank"> Zap </a>和<a class="ae le" href="https://github.com/apex/log" rel="noopener ugc nofollow" target="_blank"> Apex </a>。</p><h2 id="c15e" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">客户端角度UI日志记录</h2><p id="614f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">同样，我使用<a class="ae le" href="https://www.npmjs.com/package/ngx-logger" rel="noopener ugc nofollow" target="_blank"> NGX记录器</a>增强了Angular UI的日志记录。NGX Logger是angular的一个简单的日志模块(<em class="ms">目前支持Angular 6+ </em>)。它允许“漂亮地打印”到控制台，并允许将日志消息发布到服务器端日志记录的URL。对于本演示，UI将只记录到web浏览器的控制台。与Logrus类似，NGX Logger支持多个日志级别:跟踪、调试、信息、警告、错误、致命和关闭。然而，NGX Logger不仅仅输出消息，还允许我们将格式正确的日志条目输出到浏览器的控制台。</p><p id="caa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日志输出的级别配置为取决于环境、生产或非生产。下面是Chrome中Angular UI的日志输出示例。因为UI的Docker映像是用生产配置构建的，所以日志级别被设置为<code class="fe og oh oi oj b">INFO</code>。您不希望将详细日志输出中的潜在敏感信息暴露给生产中的最终用户。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/5796a5e93296d8ad562e3f9e46f90bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2zATN76NoyFpd4I7n0Js0g.png"/></div></div></figure><p id="baf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过向<code class="fe og oh oi oj b">app.module.ts</code>文件添加以下三元运算符来控制日志记录级别。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="bfa4" class="nu lw it oj b gy oo op l oq or">imports: [<br/>    BrowserModule,<br/>    HttpClientModule,<br/>    FormsModule,<br/><strong class="oj iu">    LoggerModule.forRoot({<br/>      level: !environment.production ?<br/>        NgxLoggerLevel.DEBUG : NgxLoggerLevel.INFO,<br/>      serverLogLevel: NgxLoggerLevel.INFO<br/>    })<br/></strong>  ],</span></pre><h2 id="6503" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">平台日志</h2><p id="0f48" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">基于在<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">第一部分</a>中构建、配置和部署的平台，您现在可以从多个来源访问日志。</p><ol class=""><li id="82c3" class="os ot it kk b kl km ko kp kr ou kv ov kz ow ld ox oy oz pa bi translated">Amazon document db:Amazon cloud watch审计和Profiler日志；</li><li id="2349" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld ox oy oz pa bi translated">亚马逊MQ:亚马逊CloudWatch日志；</li><li id="f831" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld ox oy oz pa bi translated">亚马逊EKS: API服务器、审计、认证器、控制器管理器、调度器CloudWatch日志；</li><li id="03a7" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld ox oy oz pa bi translated">Kubernetes仪表板:个人EKS Pod和副本集日志；</li><li id="0c93" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld ox oy oz pa bi translated">Kiali:单个EKS豆荚和集装箱原木；</li><li id="baaa" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld ox oy oz pa bi translated">流畅位:EKS性能、主机、数据面板、应用CloudWatch日志；</li></ol><h2 id="91a6" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">流畅位</h2><p id="97d1" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">根据AWS最近的一篇博客文章，<a class="ae le" href="https://aws.amazon.com/blogs/containers/fluent-bit-integration-in-cloudwatch-container-insights-for-eks/" rel="noopener ugc nofollow" target="_blank">Fluent Bit Integration in CloudWatch Container Insights for EKS</a>，<a class="ae le" href="https://fluentbit.io/" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>是一个开源的多平台日志处理器和转发器，允许您从不同的来源收集数据和日志，并将其统一发送到不同的目的地，包括cloud watch日志。Fluent Bit还完全兼容Docker和Kubernetes环境。使用新推出的Fluent Bit <code class="fe og oh oi oj b">DaemonSet</code>，您可以将容器日志从您的EKS集群发送到CloudWatch logs进行日志存储和分析。</p><p id="9fe8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">借助部署在<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">第一部分</a>中的Fluent Bit，EKS集群的性能、主机、数据面板和应用程序日志也将在Amazon CloudWatch中提供。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5b549e547dffcd24b5434858d310aed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFrecWAN86ImRyJVt6k42w.png"/></div></div></figure><p id="daa1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在应用程序日志组中，您可以访问每个参考应用程序组件的单独日志流。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/bf5d5ecc576a42d8e2f55250e8c4578d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zjNx2n2r5ElW-a3DLXNSw.png"/></div></div></figure><p id="4b4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个CloudWatch日志流中，您可以查看单个日志条目。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/04695e226f03f14d66e4314555fa7075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9a7N4Ek93aP977VWZ59GA.png"/></div></div></figure><p id="6ba8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Logs Insights </a>让你能够在亚马逊CloudWatch Logs中交互式搜索和分析你的日志数据。您可以执行查询来帮助您更高效地响应操作问题。如果出现问题，您可以使用CloudWatch Logs Insights来确定潜在的原因并验证部署的修复。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pg"><img src="../Images/f97cf7dde81a67140d0f81930c04423d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgDUvv0TQBumG0J4hMwBRg.png"/></div></div></figure><p id="ed20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CloudWatch Logs Insights支持<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Logs Insights查询语法</a>，这是一种可以用来对日志组执行查询的查询语言。每个查询可以包含一个或多个查询命令，用Unix样式的管道字符(|)分隔。例如:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="896c" class="nu lw it oj b gy oo op l oq or">fields <a class="ae le" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>, <a class="ae le" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a><br/>| filter kubernetes.container_name = "service-f" <br/>  and <a class="ae le" href="http://twitter.com/message" rel="noopener ugc nofollow" target="_blank">@message</a> like "error"<br/>| sort <a class="ae le" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a> desc<br/>| limit 20</span></pre><h1 id="bc72" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">支柱二:衡量标准</h1><p id="77ef" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">对于指标，我们将检查<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch容器洞察</a>、<a class="ae le" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>和<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>。Prometheus和Grafana是您作为Istio部署的一部分安装的业界领先的工具。</p><h1 id="7fcb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">普罗米修斯</h1><p id="a509" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><a class="ae le" href="https://github.com/prometheus" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>是一个开源系统监控和警报工具包，最初是在大约2012年<a class="ae le" href="https://soundcloud.com/" rel="noopener ugc nofollow" target="_blank"> SoundCloud </a>开发的。普罗米修斯于2016年加入<a class="ae le" href="https://cncf.io/" rel="noopener ugc nofollow" target="_blank">云原生计算基金会</a> (CNCF)，作为继<a class="ae le" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>之后主持的第二个项目。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/013e8318615c1facf28b47ab51cc3f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rpsf9-KTIcrAT8FDK94UIQ.png"/></div></div></figure><p id="30ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/prometheus/" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，Prometheus插件是一个Prometheus服务器，预配置为收集Istio端点来收集指标。您可以将Prometheus与Istio一起使用，来记录跟踪Istio和服务网格中的应用程序的健康状况的指标。您可以使用像<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/grafana/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>和<a class="ae le" href="https://istio.io/latest/docs/tasks/observability/kiali/" rel="noopener ugc nofollow" target="_blank"> Kiali </a>这样的工具来可视化指标。Istio Prometheus插件仅用于演示，并未针对性能或安全性进行调整。</p><p id="c7df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi oj b"><a class="ae le" href="https://istio.io/latest/docs/reference/commands/istioctl/#istioctl-dashboard" rel="noopener ugc nofollow" target="_blank">istioctl dashboard</a></code>命令提供了对所有Istio web用户界面的访问。运行EKS集群，安装Istio，部署参考应用平台，从终端使用<code class="fe og oh oi oj b"><a class="ae le" href="https://istio.io/latest/docs/reference/commands/istioctl/#istioctl-dashboard-prometheus" rel="noopener ugc nofollow" target="_blank">istioctl dashboard prometheus</a></code>命令访问Prometheus。您必须从终端登录AWS才能成功连接到Prometheus。如果你没有登录AWS，你会经常看到以下错误:<code class="fe og oh oi oj b">Error: not able to locate &lt;tool_name&gt; pod: Unauthorized</code>。由于我们使用的是Istio插件的非生产演示版本，因此访问Prometheus不需要认证和授权。</p><p id="bf64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>的说法，用户使用名为<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/basics/" rel="noopener ugc nofollow" target="_blank"> PromQL </a> (Prometheus查询语言)的函数式查询语言实时选择和汇总时间序列数据。表达式的结果既可以显示为图形，在Prometheus的表达式浏览器中以表格数据的形式查看，也可以由外部系统通过Prometheus的<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/api/" rel="noopener ugc nofollow" target="_blank"> HTTP API </a>使用。表达式浏览器包括一个下拉菜单，其中包含所有可用的指标作为构建查询的起点。下面是一些PromQL的例子，它们是在撰写本文时开发的。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="53fa" class="nu lw it oj b gy oo op l oq or">istio_agent_go_info{kubernetes_namespace="dev"}</span><span id="2ecf" class="nu lw it oj b gy ph op l oq or">istio_build{kubernetes_namespace="dev"}</span><span id="63e5" class="nu lw it oj b gy ph op l oq or">up{alpha_eksctl_io_cluster_name="istio-observe-demo", job="kubernetes-nodes"}</span><span id="5001" class="nu lw it oj b gy ph op l oq or">sum by (pod) (rate(container_network_transmit_packets_total{stack="reference-app",namespace="dev",pod=~"service-.*"}[5m]))</span><span id="ceb5" class="nu lw it oj b gy ph op l oq or">sum by (instance) (istio_requests_total{source_app="istio-ingressgateway",connection_security_policy="mutual_tls",response_code="200"})</span><span id="1ddd" class="nu lw it oj b gy ph op l oq or">sum by (response_code) (istio_requests_total{source_app="istio-ingressgateway",connection_security_policy="mutual_tls",response_code!~"200|0"})</span></pre><h2 id="e6f3" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">普罗米修斯蜜蜂</h2><p id="3ab3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Prometheus既有一个<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/api/#http-api" rel="noopener ugc nofollow" target="_blank"> HTTP API </a>又有一个<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/management_api/" rel="noopener ugc nofollow" target="_blank">管理API </a>。除了Prometheus UI之外，还有许多有用的端点，可在<code class="fe og oh oi oj b"><a class="ae le" href="http://localhost:9090/graph" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/graph</a></code>获得。例如，列出所有命令行配置标志的Prometheus HTTP API端点在<code class="fe og oh oi oj b"><a class="ae le" href="http://localhost:9090/api/v1/status/flags" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/api/v1/status/flags</a></code>可用。列出所有可用普罗米修斯指标的端点可在<code class="fe og oh oi oj b"><a class="ae le" href="http://localhost:9090/api/v1/label/__name__/values" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/api/v1/label/__name__/values</a></code>获得；本演示中共有951项指标！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/08bbf34e5c4f59294cb6fbd92fae767f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0b1bt95jm7eWYpFxuE3xhg.png"/></div></div></figure><p id="e6c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe og oh oi oj b"><a class="ae le" href="http://localhost:9090/metrics" rel="noopener ugc nofollow" target="_blank">http://localhost:9090/metrics</a></code>可以找到Prometheus端点，它列出了许多可用的指标，用<code class="fe og oh oi oj b">HELP</code>和<code class="fe og oh oi oj b">TYPE</code>来解释它们的功能。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/b8618b31248f8d4361bec9e873e2c5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wMqJxWHVKIbCK0eBPNvqw.png"/></div></div></figure><h2 id="202e" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">了解指标</h2><p id="e448" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">除了这些端点，Istio导出并通过Prometheus提供的标准服务水平指标可在<a class="ae le" href="https://istio.io/latest/docs/reference/config/metrics/#metrics" rel="noopener ugc nofollow" target="_blank"> Istio标准指标</a>文档中找到。在他们的GitHub网站上的cAdvisor <a class="ae le" href="https://github.com/google/cadvisor/blob/master/docs/storage/prometheus.md#prometheus-container-metrics" rel="noopener ugc nofollow" target="_blank"> README </a>中也可以找到Prometheus中许多可用指标的解释。正如在这篇<a class="ae le" href="https://aws.amazon.com/blogs/containers/monitoring-amazon-eks-on-aws-fargate-using-prometheus-and-grafana/" rel="noopener ugc nofollow" target="_blank"> AWS博客文章</a>中提到的，cAdvisor指标也可以通过命令行使用以下命令获得:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="dd3d" class="nu lw it oj b gy oo op l oq or">export NODE=$(kubectl get nodes | sed -n '2 p' | awk {'print $1'})</span><span id="ec1c" class="nu lw it oj b gy ph op l oq or">kubectl get --raw "/api/v1/nodes/${NODE}/proxy/metrics/cadvisor"</span></pre><h2 id="8d7c" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">观察指标</h2><p id="b8ed" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">下面是部署到EKS的后端微服务容器的示例图。graph PromQL表达式返回工作集内存量，包括最近访问的内存、脏内存和内核内存(<code class="fe og oh oi oj b">container_memory_working_set_bytes</code>)，按pod求和，以兆字节(MB)为单位。在显示的时间段内，服务上没有负载。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="47ef" class="nu lw it oj b gy oo op l oq or">sum by (pod) (container_memory_working_set_bytes{image=~"registry.hub.docker.com/garystafford/.*"}) / (1024^2)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4d4c7f309a7a24b3bbc36516053100fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATEfQFlYTN2UOe2-b_de4w.png"/></div></div></figure><p id="8e58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi oj b">container_memory_working_set_bytes</code>度量与<code class="fe og oh oi oj b">kubectl top</code>命令使用的度量相同(不是<code class="fe og oh oi oj b">container_memory_usage_bytes</code>)。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="e312" class="nu lw it oj b gy oo op l oq or">&gt; kubectl top pod -n dev --containers=true --use-protocol-buffer</span><span id="125d" class="nu lw it oj b gy ph op l oq or">POD                          NAME          CPU(cores)   MEMORY(bytes)<br/>service-a-546fbd558d-28jlm   service-a     1m           6Mi<br/>service-a-546fbd558d-2lcsg   service-a     1m           6Mi<br/>service-b-545c85df9-dl9h8    service-b     1m           6Mi<br/>service-b-545c85df9-q99xm    service-b     1m           5Mi<br/>service-c-58996574-58wd8     service-c     1m           7Mi<br/>service-c-58996574-6q7n4     service-c     1m           7Mi<br/>service-d-867796bb47-87ps5   service-d     1m           6Mi<br/>service-d-867796bb47-fh6wl   service-d     1m           6Mi<br/>...</span></pre><p id="2663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在另一个Prometheus示例中，PromQL查询表达式返回以<a class="ae le" href="https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/#cpu-units" rel="noopener ugc nofollow" target="_blank"> CPU单位</a> (1个CPU = 1个AWS vCPU)度量的CPU资源的每秒<a class="ae le" href="https://prometheus.io/docs/prometheus/latest/querying/functions/#rate" rel="noopener ugc nofollow" target="_blank">速率，该速率是在过去5分钟内根据范围向量中的时间序列由pod求和得到的。在此期间，后端服务处于使用<code class="fe og oh oi oj b">hey</code>的25个并发用户的一致模拟负载下。在此期间，四个服务D单元消耗了最多的CPU单元。</a></p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="a559" class="nu lw it oj b gy oo op l oq or">sum by (pod) (rate(container_cpu_usage_seconds_total{image=~"registry.hub.docker.com/garystafford/.*"}[5m])) * 1000</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a7aff19a970b2dcda1e9b8b9f5f2ad49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IACITXnmwLTyLJ3fDsyGRQ.png"/></div></div></figure><p id="dbfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi oj b">container_cpu_usage_seconds_total</code>度量与<code class="fe og oh oi oj b">kubectl top</code>命令使用的度量相同。上面的PromQL表达式将查询结果乘以1000，以匹配来自<code class="fe og oh oi oj b">kubectl top</code>的结果，如下所示。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="4bfd" class="nu lw it oj b gy oo op l oq or">&gt; kubectl top pod -n dev --containers=true --use-protocol-buffer</span><span id="468c" class="nu lw it oj b gy ph op l oq or">POD                          NAME          CPU(cores)   MEMORY(bytes)<br/>service-a-546fbd558d-28jlm   service-a     25m          9Mi<br/>service-a-546fbd558d-2lcsg   service-a     27m          8Mi<br/>service-b-545c85df9-dl9h8    service-b     29m          11Mi<br/>service-b-545c85df9-q99xm    service-b     23m          8Mi<br/>service-c-58996574-c8hkn     service-c     62m          9Mi<br/>service-c-58996574-kx895     service-c     55m          8Mi<br/>service-d-867796bb47-87ps5   service-d     285m         12Mi<br/>service-d-867796bb47-9ln7p   service-d     226m         11Mi<br/>...</span></pre><h2 id="7c02" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">限制</h2><p id="40db" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">普罗米修斯也暴露了容器资源的限制。例如，在参考平台的后端服务上设置的内存限制，使用<code class="fe og oh oi oj b">container_spec_memory_limit_bytes</code>指标以兆字节(MB)为单位显示。当与服务消耗的实时资源一起查看时，这些指标有助于正确配置和监控Kubernetes管理功能，如<a class="ae le" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a>。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="2e01" class="nu lw it oj b gy oo op l oq or">sum by (container) (container_spec_memory_limit_bytes{image=~"registry.hub.docker.com/garystafford/.*"}) / (1024^2) / count by (container) (container_spec_memory_limit_bytes{image=~"registry.hub.docker.com/garystafford/.*"})</span></pre><p id="1848" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，Pod的内存限制:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="9695" class="nu lw it oj b gy oo op l oq or">sum by (pod) (container_spec_memory_limit_bytes{image=~"registry.hub.docker.com/garystafford/.*"}) / (1024^2)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/1ade3c0785e8f588f7c99619af1b7818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6GgAMa5oVdfzuduDwwTfg.png"/></div></div></figure><h2 id="e840" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">聚类指标</h2><p id="c50d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Prometheus还包含关于Istio组件、Kubernetes组件和EKS集群的指标。例如，<code class="fe og oh oi oj b">istio-observe-demo</code> EKS集群的<code class="fe og oh oi oj b">managed-ng-1</code>受管节点组中每个<code class="fe og oh oi oj b">m5.large</code> EC2工作节点的总内存(GB)。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="e8c1" class="nu lw it oj b gy oo op l oq or">machine_memory_bytes{alpha_eksctl_io_cluster_name="istio-observe-demo", alpha_eksctl_io_nodegroup_name="managed-ng-1"} / (1024^3)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/458dcbfe5b344fd61832ac7052801853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4JrGKNrz8aqSNuknzKSUA.png"/></div></div></figure><p id="5755" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于物理核心总数，使用<code class="fe og oh oi oj b">machine_cpu_physical_core</code>指标，对于vCPU核心，使用<code class="fe og oh oi oj b">machine_cpu_cores</code>指标。</p><h1 id="42ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">格拉夫纳</h1><p id="c270" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Grafana称自己是领先的时间序列分析开源软件。根据<a class="ae le" href="https://grafana.com/grafana" rel="noopener ugc nofollow" target="_blank"> Grafana Labs的说法，</a> Grafana允许您查询、可视化、提醒和了解您的指标，无论它们存储在哪里。您可以轻松创建、浏览和共享视觉效果丰富的数据驱动仪表板。Grafana还允许用户可视化地为他们最重要的指标定义警报规则。Grafana将不断评估规则，并可以发送通知。</p><p id="3bf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你使用帖子的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-based-microservice-observability-with-istio-service-mesh-part-1-of-2-19084d13a866">第一部分</a>中演示的Istio addons过程部署Grafana，访问Grafana类似于其他工具:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="dcd3" class="nu lw it oj b gy oo op l oq or">istioctl dashboard grafana</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/46208772cad94f28ef84455063e70fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0w-V5GJSqCKQuq7M8ktRA.png"/></div></div></figure><p id="fe63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/using-istio-dashboard/#about-the-grafana-add-on" rel="noopener ugc nofollow" target="_blank">消息，Istio </a>，<a class="ae le" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>是一款开源监控解决方案，用于为Istio配置仪表盘。您可以使用Grafana来监控服务网格中Istio和应用程序的健康状况。虽然您可以构建自己的仪表板，但Istio为网格和控制平面的所有最重要指标提供了一组预配置的仪表板。预配置的仪表板使用Prometheus作为数据源。</p><ul class=""><li id="0e16" class="os ot it kk b kl km ko kp kr ou kv ov kz ow ld pi oy oz pa bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7639" rel="noopener ugc nofollow" target="_blank"> Mesh Dashboard </a>提供了Mesh中所有服务的概述。</li><li id="8982" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7636" rel="noopener ugc nofollow" target="_blank"> Service Dashboard </a>提供了服务指标的详细分解。</li><li id="2972" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7630" rel="noopener ugc nofollow" target="_blank">工作负载仪表板</a>提供工作负载指标的详细细分。</li><li id="642a" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/11829" rel="noopener ugc nofollow" target="_blank">性能仪表板</a>监控网格的资源使用情况。</li><li id="cd4c" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><a class="ae le" href="https://grafana.com/grafana/dashboards/7645" rel="noopener ugc nofollow" target="_blank">控制面板仪表板</a>监控控制面板的健康和性能。</li></ul><p id="2fdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个Istio <a class="ae le" href="https://grafana.com/grafana/dashboards/7639" rel="noopener ugc nofollow" target="_blank">网格仪表板</a>的例子，过滤后显示了在<code class="fe og oh oi oj b">dev</code>名称空间中运行的八个后端服务工作负载。在此期间，后端服务处于使用<code class="fe og oh oi oj b">hey</code>的大约20个并发用户的一致模拟负载下。您可以观察这些工作负载的请求的p50、p90和p99延迟。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/76373f5795a5f54d70feae9f008b24f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6-DM_X6iQcp8Z5fnH-3hw.png"/></div></div></figure><p id="f144" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仪表板由Grafana中的基本可视化构建模块<a class="ae le" href="https://grafana.com/docs/grafana/latest/panels/" rel="noopener ugc nofollow" target="_blank">面板</a>构建而成。每个面板都有一个特定于所选数据源(在本例中为Prometheus)的查询编辑器。查询编辑器允许您编写(PromQL)查询。下面是负责Istio Mesh仪表板中显示的p50延迟面板的PromQL表达式查询。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="a5bf" class="nu lw it oj b gy oo op l oq or"> label_join((histogram_quantile(0.50, sum(rate(istio_request_duration_milliseconds_bucket{reporter="source"}[1m])) by (le, destination_workload, destination_workload_namespace)) / 1000) or histogram_quantile(0.50, sum(rate(istio_request_duration_seconds_bucket{reporter="source"}[1m])) by (le, destination_workload, destination_workload_namespace)), "destination_workload_var", ".", "destination_workload", "destination_workload_namespace")</span></pre><p id="ad08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Istio <a class="ae le" href="https://grafana.com/grafana/dashboards/7630" rel="noopener ugc nofollow" target="_blank">工作负载仪表板</a>的出站工作负载部分的示例。完整的控制面板包含三个部分:常规、入站工作负载和出站工作负载。在这里，我们已经在<code class="fe og oh oi oj b">dev</code>名称空间中过滤了on reference平台的后端服务。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi pj"><img src="../Images/0abbcf59df4aeb7110cef972a00647a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cM4jg2uEysvf2VVrX54_jQ.png"/></div></div></figure><p id="6c81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是Istio <a class="ae le" href="https://grafana.com/grafana/dashboards/7630" rel="noopener ugc nofollow" target="_blank">工作负载仪表板</a>的不同视图，仪表板的入站工作负载部分过滤为单个工作负载，服务A，后端的边缘服务。服务A接受来自Istio入口网关的传入流量，如仪表板面板所示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/2687e94cc01fb044d02131e643a033e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oizbhct0aZpPLSWHEyY6jQ.png"/></div></div></figure><p id="2fb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Grafana提供了浏览面板的能力。<a class="ae le" href="https://grafana.com/docs/grafana/latest/explore/" rel="noopener ugc nofollow" target="_blank">浏览</a>去掉仪表板和面板选项，以便您可以专注于查询。它帮助您迭代，直到您有一个工作查询，然后考虑建立一个仪表板。下面是一个面板示例，显示了基于<code class="fe og oh oi oj b">istio_tcp_sent_bytes_total</code>指标的服务F的出口TCP流量。服务F消耗RabbitMQ队列(Amazon MQ)上的消息，并将消息写入MongoDB (DocumentDB)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/01a58a028460f33a9ed419ad3580d71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YM4Xuee3OVWh_WxvHy5yXg.png"/></div></div></figure><p id="8613" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<a class="ae le" href="https://grafana.com/grafana/dashboards/11829" rel="noopener ugc nofollow" target="_blank">性能仪表板</a>监控Istio的资源使用情况。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/8c7b763bee4540032da0786cd07d01e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TF_HJIvDCS1YA8TOgp53jQ.png"/></div></div></figure><h2 id="0832" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">附加仪表板</h2><p id="d1d3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Grafana提供了一个包含官方和社区构建的仪表板的网站，其中包括上述Istio仪表板。将仪表板导入Grafana实例非常简单，只需复制仪表板URL或Grafana仪表板站点提供的ID，并将其粘贴到Grafana实例的仪表板导入选项中。请注意，并不是Grafan网站上的每个Kubernetes仪表板都与您的特定版本的Kubernetes、Istio或EKS兼容，也不依赖Prometheus作为数据源。因此，您可能必须测试和调整导入的仪表板，以使它们工作。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/09b08cac3a043412fc368dcab3a9de51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xeb-zcV19vE1b1dY6GKj8g.png"/></div></div></figure><p id="e8ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个由的<a class="ae le" href="https://grafana.com/orgs/instrumentisto" rel="noopener ugc nofollow" target="_blank">instruments团队开发的</a><a class="ae le" href="https://grafana.com/grafana/dashboards/315" rel="noopener ugc nofollow" target="_blank">Kubernetes cluster monitoring(via Prometheus)</a>(仪表板ID 315)的导入社区仪表板示例。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/433d0deabd224ca294cfd57a30583564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLmxg0wH_IF2SMGDohxRog.png"/></div></div></figure><h2 id="5834" class="nu lw it bd lx nv nw dn mb nx ny dp mf kr nz oa mh kv ob oc mj kz od oe ml of bi translated">发信号</h2><p id="7e3f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">有效的可观察性策略必须不仅仅包括可视化结果的能力。有效的策略还必须检测异常情况，并通知(提醒)适当的资源或直接解决事故。格拉夫纳和普罗米修斯一样，能够发出警报和通知。您可以直观地定义关键指标的警报规则。Grafana将根据规则持续评估指标，并在违反预定义阈值时发送通知。</p><p id="84bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Prometheus支持多个流行的<a class="ae le" href="http://docs.grafana.org/alerting/notifications/#all-supported-notifier" rel="noopener ugc nofollow" target="_blank">通知渠道</a>，包括PagerDuty、HipChat、Email、Kafka、Slack。下面是一个Prometheus通知通道的示例，它向Slack支持通道发送预警通知。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/86f417dbbea362806ed37a3f7c71f56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTcSrXWSqDJMzKgv0v5TpA.png"/></div></div></figure><p id="d243" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个基于300毫CPU)的任意高CPU使用率的警报示例。当单个pod的CPU使用率超过该值超过3分钟时，将会发送警报。高CPU使用率可能是由于水平机架自动缩放器不起作用，或者HPA已达到其<code class="fe og oh oi oj b">maxReplicas</code>限制，或者群集中没有足够的可用资源来调度额外的机架。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/2d5c6307a34d34e877983103c832a50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLIjmsottTscfuYk5_ehfA.png"/></div></div></figure><p id="a0cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由警报触发，Prometheus向指定的Slack信道发送详细的通知。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/717820e4512997d5d574ed232f5e15cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYlHgew5hvrSzDL2HxO9NQ.png"/></div></div></figure><h1 id="8936" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">亚马逊云观察容器洞察</h1><p id="0401" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">最后，在指标类别中，<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/ContainerInsights.html" rel="noopener ugc nofollow" target="_blank">Amazon cloud watch Container Insights</a>从您的容器化应用和微服务中收集、汇总和总结指标和日志。可以根据Container Insights收集的指标设置CloudWatch警报。Container Insights可用于亚马逊弹性容器服务(Amazon ECS)，包括亚马逊EC2上的Fargate、亚马逊EKS和Kubernetes平台。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/46de90f21ddb28ae83ac9a16e9b9d326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMCZB-7lbfz13ezCRq2MEg.png"/></div></div></figure><p id="d754" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在亚马逊EKS，Container Insights使用CloudWatch代理的容器化版本来发现集群中所有正在运行的容器。然后，它在性能堆栈的每一层收集性能数据。Container Insights使用<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format.html" rel="noopener ugc nofollow" target="_blank">嵌入式指标格式</a>收集性能日志事件数据。这些性能日志事件是使用结构化JSON模式的条目，该模式支持大规模接收和存储高基数数据。</p><p id="60c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在文章的第一部分中，我们还为Prometheus安装了cloud watch Container Insights monitoring，它可以自动从容器化的系统和工作负载中发现Prometheus指标。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/7a53ed115200bad779bf26d807386415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeDjVtbijcFISb0tJZuXzA.png"/></div></div></figure><p id="613d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个基本性能监控CloudWatch Container Insights仪表板的示例。仪表板被过滤到EKS集群的<code class="fe og oh oi oj b">dev</code>名称空间，参考应用程序平台在此运行。在此期间，使用<code class="fe og oh oi oj b">hey</code>将后端服务置于模拟负载下。随着应用程序负载的增加，根据部署资源和HPA配置，观察到单元的数量从19个增加到34个。还有一个警告，显示在屏幕的右侧。任意高水平的网络传输活动触发了警报。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5652ce9a31109d02375571c64769496c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbgLzrELKn7fA1G8rcvJOw.png"/></div></div></figure><p id="4943" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来是Container Insights在内存模式下的容器图视图示例。您可以看到<code class="fe og oh oi oj b">dev</code>名称空间的可视化表示，其中显示了每个后端服务的<code class="fe og oh oi oj b">Service</code>和<code class="fe og oh oi oj b">Deployment</code>资源。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/385c49c1aba0229915ab349922a3c4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBhYNjqCEKkY4HPKcZ2_Gw.png"/></div></div></figure><p id="e9d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个警告图标，指示集群上的警报被触发。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/f2d0e8cece78582cda6629dad6ad64b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wmt7G7AMcnpi_ZH1rrkTg.png"/></div></div></figure><p id="86f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，CloudWatch Insights允许您从CloudWatch Insights跳转到CloudWatch Log Insights控制台。CloudWatch Insights还将为您编写CloudWatch Insights查询。下面，我们从CloudWatch Insights性能监控控制台中的Service D container metrics视图直接转到CloudWatch Log Insights控制台，带有一个查询，准备运行。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/e6e05e473f03f2cb60942f145d4b012b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yliA_wVawxxQgk0twP-1A.png"/></div></div></figure><h1 id="8812" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">支柱3:痕迹</h1><p id="8173" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">根据<a class="ae le" href="https://opentracing.io/docs/overview/what-is-tracing/" rel="noopener ugc nofollow" target="_blank">开放跟踪网站</a>的说法，分布式跟踪，也称为分布式请求跟踪，用于分析和监控应用程序，尤其是那些使用微服务架构构建的应用程序。分布式跟踪有助于查明故障发生的位置以及导致低性能的原因。</p><p id="8262" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae le" href="https://istio.io/docs/tasks/telemetry/distributed-tracing/#understanding-what-happened" rel="noopener ugc nofollow" target="_blank"> Istio </a>的说法，头传播可以通过客户端库来完成，比如<a class="ae le" href="https://zipkin.io/pages/tracers_instrumentation.html" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>或者<a class="ae le" href="https://github.com/jaegertracing/jaeger-client-java/tree/master/jaeger-core#b3-propagation" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>。也可以手动完成，称为跟踪上下文传播，记录在<a class="ae le" href="https://istio.io/latest/docs/tasks/observability/distributed-tracing/overview/#trace-context-propagation" rel="noopener ugc nofollow" target="_blank">分布式跟踪任务</a>中。Istio代理可以自动发送跨度。应用程序需要传播适当的HTTP头，以便当代理发送跨度信息时，跨度可以正确地关联到单个跟踪中。为了实现这一点，应用程序需要从传入请求到任何传出请求收集并传播以下标头。</p><ul class=""><li id="3b0a" class="os ot it kk b kl km ko kp kr ou kv ov kz ow ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-request-id</code></li><li id="9670" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-b3-traceid</code></li><li id="ca14" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-b3-spanid</code></li><li id="ef0c" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-b3-parentspanid</code></li><li id="3fed" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-b3-sampled</code></li><li id="109f" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-b3-flags</code></li><li id="5379" class="os ot it kk b kl pb ko pc kr pd kv pe kz pf ld pi oy oz pa bi translated"><code class="fe og oh oi oj b">x-ot-span-context</code></li></ul><p id="f9bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标题起源于Zipkin项目的一部分。报头的B3部分以Zipkin的原名命名，<strong class="kk iu">B</strong>ig<strong class="kk iu">B</strong>rother<strong class="kk iu">B</strong>ird。跨服务调用传递这些头被称为<a class="ae le" href="https://github.com/openzipkin/b3-propagation" rel="noopener ugc nofollow" target="_blank"> B3传播</a>。根据<a class="ae le" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing#arch-overview-tracing" rel="noopener ugc nofollow" target="_blank"> Zipkin </a>的说法，这些属性会在进程内传播，并最终传播到下游(通常通过HTTP头),以确保源自同一个根的所有活动都被收集在一起。</p><p id="18e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示Jaeger和Zipkin的分布式跟踪，服务A、服务B和服务E被修改为传递b3头。这是向其他上游服务发出HTTP请求的三个服务。添加了以下代码来将标头从一个服务传播到下一个服务。Istio sidecar代理(<a class="ae le" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>)生成第一个<a class="ae le" href="https://istio.io/latest/about/faq/#distributed-tracing" rel="noopener ugc nofollow" target="_blank">报头</a>。关键是只传播下游请求中出现的头并有一个值，如下面的代码所示。传播空标头会破坏分布式跟踪。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="db6c" class="nu lw it oj b gy oo op l oq or">incomingHeaders := []string{<br/>  "x-b3-flags",<br/>  "x-b3-parentspanid",<br/>  "x-b3-sampled",<br/>  "x-b3-spanid",<br/>  "x-b3-traceid",<br/>  "x-ot-span-context",<br/>  "x-request-id",<br/> }</span><span id="e332" class="nu lw it oj b gy ph op l oq or">for _, header := range incomingHeaders {<br/>  if r.Header.Get(header) != "" {<br/>   req.Header.Add(header, r.Header.Get(header))<br/>  }<br/> }</span></pre><p id="ff71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，来自对服务A的<code class="fe og oh oi oj b">/api/request-echo</code>端点的调用的响应有效负载的突出显示部分揭示了源自Istio代理并传递给服务A的b3头。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/feb9fa186d8905add13f3904b90cf56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4d2RMppafAzwyxhwXmR4Q.png"/></div></div></figure><h1 id="9fc1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">贼鸥</h1><p id="29dd" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">根据他们的网站介绍，<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/" rel="noopener ugc nofollow" target="_blank"> Jaeger </a>受<a class="ae le" href="https://research.google.com/pubs/pub36356.html" rel="noopener ugc nofollow" target="_blank"> Dapper </a>和<a class="ae le" href="http://zipkin.io/" rel="noopener ugc nofollow" target="_blank"> OpenZipkin </a>的启发，是由<a class="ae le" href="http://uber.github.io/" rel="noopener ugc nofollow" target="_blank">优步科技</a>开源发布的分布式追踪系统。Jaeger用于对基于微服务的分布式系统进行监控和故障排除，包括分布式上下文传播、分布式事务监控、根本原因分析、服务依赖性分析以及性能和延迟优化。Jaeger网站包含Jaeger架构和一般追踪相关术语的有用概述。</p><p id="3844" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用本文第一部分中演示的Istio插件过程部署了Jaeger，请使用类似于其他工具的方式访问Jaeger:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="9d99" class="nu lw it oj b gy oo op l oq or">istioctl dashboard j<!-- -->aeger</span></pre><p id="5917" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是Jaeger UI的搜索视图示例，显示了一段时间内对Istio入口网关服务的搜索结果。我们在顶部看到跟踪时间线，下面是跟踪结果列表。正如Jaeger <a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture/" rel="noopener ugc nofollow" target="_blank">网站</a>上所讨论的，一条轨迹由跨度组成。span表示Jaeger中具有操作名称的逻辑工作单元。踪迹是通过系统的执行路径，可以被认为是<a class="ae le" href="https://www.jaegertracing.io/docs/1.10/architecture#span" rel="noopener ugc nofollow" target="_blank">跨度</a>的<a class="ae le" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图</a> (DAG)。如果您使用过像Apache Spark这样的系统，您可能已经熟悉Dag的概念。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/929cac270479c4502b517280b034f852.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wiI8BVgG35iUcleHB58ZAA.png"/></div></div></figure><p id="49b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Jaeger的轨迹时间线模式中单个轨迹的详细视图。14个跨度包含参考平台的八个组件:八个后端服务中的七个和Istio入口网关。每个跨度都有单独的计时，总跟踪时间为160 ms。跟踪中的根跨度是Istio入口网关。加载在最终用户的web浏览器中的Angular UI通过Istio入口网关调用服务A。从那里，我们看到了我们的服务到服务IPC的预期流程。服务A调用服务B和服务c，服务B调用服务E，服务E调用服务G和服务h。</p><p id="642b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个演示中，跟踪既没有跨越RabbitMQ消息队列，也没有跨越MongoDB。这意味着您不会看到包含通过RabbitMQ从服务D到服务F的调用的跟踪。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/85b251c41b471f5e4037ea2cb405757b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcoFU8evkd-pZ0RRux3zOg.png"/></div></div></figure><p id="34e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跟踪时间线的可视化展示了参考平台的服务到服务IPC的同步性质，而不是使用RabbitMQ消息队列的解耦通信的异步性质。服务A等待其调用链中的每个服务做出响应，然后将其响应返回给请求者。</p><p id="9029" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Jaeger的跟踪时间线视图中，您可以钻取包含附加元数据的单个跨度。span的元数据包括被调用的API端点URL、HTTP方法、响应状态和其他几个头。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/efaddaf5cc76948dfce2e8faa389eebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIVsczRFQVDHKu4dLUTL-A.png"/></div></div></figure><p id="fc25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jaeger还有一个实验性的Trace Graph模式，可以显示相同轨迹的图形视图。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5ddba11019896b770a7b3edb43c56526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FY95UBcb1jHhv98lqHaIIg.png"/></div></div></figure><p id="f46c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Jaeger还包括一个比较跟踪功能和两个依赖关系视图:力定向图和DAG。我发现这两种观点与基亚利相比都相当原始。缺少对Kiali的访问，这些视图作为依赖图没有多大用处。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/367b9c13a99b852279f65636e499ca83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6x2dSkBPmvCFPlVJYMPgjQ.png"/></div></div></figure><h1 id="19d3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">齐普金</h1><p id="0c68" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Zipkin 是一个分布式跟踪系统，它帮助收集解决服务架构中的延迟问题所需的时间数据。根据2012年在<a class="ae le" href="https://blog.twitter.com/engineering/en_us/a/2012/distributed-systems-tracing-with-zipkin" rel="noopener ugc nofollow" target="_blank"> Twitter的工程博客</a>上的一篇帖子，Zipkin是在Twitter的第一个黑客周期间作为一个项目开始的。在那一周，他们实施了一个基本版本的<a class="ae le" href="http://research.google.com/pubs/pub36356.html" rel="noopener ugc nofollow" target="_blank">谷歌衣冠楚楚</a>节俭纸。</p><p id="8cb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Zipkin和Jaeger在能力上非常相似。我选择在这篇文章中关注耶格，因为比起齐普金，我更喜欢它。如果你想尝试Zipkin而不是Jaeger，你可以使用以下命令从Istio addons extras目录中移除Jaeger并<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/zipkin/" rel="noopener ugc nofollow" target="_blank">安装Zipkin </a>。在帖子的第一部分，我们在部署Istio插件时没有默认安装Zipkin。请注意，在同一个Kubernetes集群中同时运行这两个工具会导致不可预测的跟踪结果。</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="3737" class="nu lw it oj b gy oo op l oq or">kubectl delete -f <a class="ae le" href="https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/jaeger.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/jaeger.yaml</a></span><span id="3d91" class="nu lw it oj b gy ph op l oq or">kubectl apply -f <a class="ae le" href="https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/extras/zipkin.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/istio/istio/release-1.10/samples/addons/extras/zipkin.yaml</a></span></pre><p id="0a13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">访问Zipkin类似于其他观察工具:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="7b22" class="nu lw it oj b gy oo op l oq or">istioctl dashboard zipkin</span></pre><p id="c640" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个在Zipkin的UI中可视化的分布式轨迹的例子，包含14个跨度。这与Jaeger中显示的轨迹非常相似，如上所示。该跨度包含参考平台的八个组件:八个后端服务中的七个和Istio入口网关。每个跨度都有单独的计时，总跟踪时间为154 ms。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4075d12ba930663c06e1c9e701fb8da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vO75dFxKpOdN1HJteShRXw.png"/></div></div></figure><p id="61c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Zipkin还可以基于分布式跟踪可视化一个依赖图。下面是一个两分钟内的流量模拟示例，显示了参考平台组件之间的网络流量，以依赖关系图的形式显示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/befc3d063638a7124021b99e98ff6747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PtkYkBI0GQmgcRD0XkMXA.png"/></div></div></figure><h1 id="a471" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Kiali:微服务可观察性</h1><p id="3047" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">根据他们的<a class="ae le" href="https://kiali.io/" rel="noopener ugc nofollow" target="_blank">网站</a>，Kiali是一个基于Istio的服务网格的管理控制台。它提供了仪表板、可观察性，并允许您使用健壮的配置和验证功能来操作网格。它通过推断流量拓扑和显示网格的健康状况来显示服务网格的结构。Kiali提供了详细的指标、强大的验证、Grafana访问以及与Jaeger的分布式跟踪的强大集成。</p><p id="8ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你使用本文第一部分中展示的Istio addons过程部署了Kaili，访问Kiali的方式与其他工具类似:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="5a6b" class="nu lw it oj b gy oo op l oq or">istioctl dashboard kaili</span></pre><p id="1210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提高安全性，我选择使用Istio文档中提到的<a class="ae le" href="https://istio.io/latest/docs/ops/integrations/kiali/#option-2-customizable-install" rel="noopener ugc nofollow" target="_blank">可定制安装</a>来安装最新版本的Kaili。使用Kiali的<a class="ae le" href="https://kiali.io/documentation/latest/quick-start/#_install_via_kiali_server_helm_chart" rel="noopener ugc nofollow" target="_blank">Install via Kiali Server Helm Chart</a>选项添加了基于令牌的身份验证，类似于Kubernetes仪表板。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/b2e9f128e89c9108b9370b99be1b0689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NESyTnJCMrPTsx-hGAKM7g.png"/></div></div></figure><p id="ca0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">登录Kiali，我们会看到Overview选项卡，它提供了Istio服务网格中所有名称空间的全局视图，以及每个名称空间中的应用程序数量。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/7386892b2e10245841e1e11beb882d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xd8LEnQ9hMoJ6YkR9ddRcA.png"/></div></div></figure><p id="625a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali UI中的Graph选项卡表示在Istio服务网格中运行的组件。下面，过滤集群的<code class="fe og oh oi oj b">dev</code>名称空间，我们可以观察到Kiali映射了8个应用程序(工作负载)、10个服务和22个边缘(一个图形术语)。具体来说，我们看到位于服务网格边缘的Istio Ingres代理、Angular UI和八个后端服务，所有这些服务都有各自的Envoy代理侧柜，这些侧柜接收流量(在本例中，服务F没有从另一个服务接收任何直接流量)、外部DocumentDB出口点和外部Amazon MQ出口点。最后，注意使用Istio，服务到服务的流量是如何从服务到其sidecar代理，再到另一个服务的sidecar代理，最后到服务的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/8bdef48b2c71b752dd60879dadde9a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9TndLfs4SW_XoJLYThnJQ.png"/></div></div></figure><p id="16f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是服务网格的类似视图，但这一次，Istio入口网关和服务A之间存在故障，以红色显示。我们还可以观察HTTP流量的总体指标，例如每秒入站和出站请求数、总请求数、成功率和出错率，以及HTTP状态代码。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/ad8f2cbfd9b5b7b6d4b1d75cf9fec3cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_GqpqZyF_8oBiQvm4bydg.png"/></div></div></figure><p id="3dc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali允许您放大并关注图表中的单个组件及其各个指标。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/c1a660b8fe409774d9034e3c5f97d0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LhcQFg78JntO9j3qOaPxg.png"/></div></div></figure><p id="bdb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还可以显示图中每条边的平均请求时间和其他指标(两个组件之间的通信)。Kaili甚至可以使用Kiali的重放功能显示给定时间段内的这些指标，如下所示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/855e5c64544387c70ebeb64ce35c0527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_GuQXVBsK24kLSOZ-dKTw.png"/></div></div></figure><p id="3fc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关注外部DocumentDB集群，Kiali还允许我们查看连接到外部集群的服务网格中的四个服务之间的TCP流量。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/f40f64c13cf9ea8b32a34290cd9f0d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7Vb3XTlrtHEK-CzLgENsA.png"/></div></div></figure><p id="9cb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“应用程序”选项卡列出了所有应用程序、它们的名称空间和标签。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/77a97982406f5dc98d08f37a4386528f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZuOlGZGChXqtGVCQlxSPQ.png"/></div></div></figure><p id="aea8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在“应用程序”和“工作负载”选项卡上深入查看单个组件，并查看更多详细信息。详细信息包括总体运行状况、pod和Istio配置状态。下面是对<code class="fe og oh oi oj b">dev</code>名称空间中服务A工作负载的概述。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/d83aa14978aca76f1a10ddb9c3e60eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*py63IKLkvLnAeQrfcYxy5g.png"/></div></div></figure><p id="7184" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工作负载详细视图还包括入站和出站指标。下面是在<code class="fe og oh oi oj b">dev</code>名称空间中服务A的出站请求量、持续时间、吞吐量和大小度量的示例。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/497c49e318c125d3ae693bf6078ec4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K17s_7uJKJM3bgxMxQ4d_A.png"/></div></div></figure><p id="93af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还可以让您访问单个pod的集装箱日志。虽然日志访问不像前面讨论的其他日志源那样用户友好，但是在Kiali中提供日志以及度量(与Grafana集成)、跟踪(与Jaeger集成)和网格可视化，作为可观察性的单一源是非常有效的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/b57ca99968d8ee559a767c0f72d8f127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vExVP1cWqFoyrNjXuAvwQ.png"/></div></div></figure><p id="148f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kiali还有一个Istio配置选项卡。Istio配置选项卡显示用户环境中存在的所有可用Istio配置对象的列表。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/4626423d785e379e3dacd8410d5432ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0ftf7bDMTq-_19HTYQ4iQ.png"/></div></div></figure><p id="003d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用Kiali来配置和管理Istio服务网格及其安装的资源。使用Kiali，您实际上可以修改已部署的资源，类似于使用<code class="fe og oh oi oj b">kubectl edit</code>命令。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/ce5105f1b73c4e04bad8e587b1867cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wADSHPjnn7TbhMttuse5Mg.png"/></div></div></figure><p id="2f58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我经常发现Kiali是我解决平台问题的第一站。一旦我确定了有问题的特定组件或通信路径，我就可以通过Grafana仪表板查询CloudWatch日志和Prometheus指标。</p><h1 id="cfde" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">拆毁</h1><p id="d989" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要拆除EKS集群、DocumentDB集群和Amazon MQ broker，请使用以下命令:</p><pre class="lg lh li lj gt ok oj ol om aw on bi"><span id="eeeb" class="nu lw it oj b gy oo op l oq or"># EKS cluster<br/>eksctl delete cluster --name $CLUSTER_NAME</span><span id="2b77" class="nu lw it oj b gy ph op l oq or"># Amazon MQ<br/>aws mq list-brokers | jq -r '.BrokerSummaries[] | .BrokerId'aws mq delete-broker --broker-id <strong class="oj iu">{{ your_broker_id }}</strong></span><span id="cac5" class="nu lw it oj b gy ph op l oq or"># DocumentDB<br/>aws docdb describe-db-clusters \<br/>    | jq -r '.DBClusters[] | .DbClusterResourceId'aws docdb delete-</span><span id="326f" class="nu lw it oj b gy ph op l oq or">db-cluster \<br/>    --db-cluster-identifier <strong class="oj iu">{{ your_cluster_id }}</strong></span></pre><h1 id="9249" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="21d5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在这篇由两部分组成的文章中，我们探索了一组流行的开源可观察性工具，它们很容易与Istio服务网格集成。这些工具包括用于分布式事务监控的Jaeger和Zipkin，用于指标收集和警报的Prometheus，用于指标查询、可视化和警报的Grafana，以及用于Istio整体可观察性和管理的Kiali。我们完善了工具集，增加了用于日志处理和转发到Amazon cloud watch Container Insights的Fluent Bit。使用这些工具，我们成功观察了部署到亚马逊EKS的基于微服务的分布式参考应用平台。</p><h1 id="f47b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于gRPC的可观测性</h1><p id="a280" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">有兴趣探索这些相同的可观察性工具来监视另一组基于Go的微服务，这些服务使用<a class="ae le" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>(又名<em class="ms">proto buf</em>)over<a class="ae le" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank">gRPC</a>(gRPC远程过程调用)和<a class="ae le" href="https://en.wikipedia.org/wiki/HTTP/2" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>进行客户端-服务器通信，而不是更常见的RESTful JSON over HTTP？</p><div class="mu mv gp gr mw mx"><a href="https://garystafford.medium.com/observing-grpc-based-microservices-on-amazon-eks-running-istio-77ba90dd8cc0" rel="noopener follow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">观察亚马逊EKS上运行Istio的基于gRPC的微服务</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">在亚马逊EKS上使用Jaeger、Zipkin、Prometheus、Grafana和Kiali观察一个基于Kubernetes的分布式应用程序…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">garystafford.medium.com</p></div></div><div class="ng l"><div class="pk l ni nj nk ng nl lp mx"/></div></div></a></div></div><div class="ab cl pl pm hx pn" role="separator"><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq pr"/><span class="po bw bk pp pq"/></div><div class="im in io ip iq"><p id="ec01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇博客代表我自己的观点，而不是我的雇主亚马逊网络服务公司(AWS)的观点。所有产品名称、徽标和品牌都是其各自所有者的财产。</p></div></div>    
</body>
</html>