<html>
<head>
<title>Automatically handling runtime data validation in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中自动处理运行时数据验证</h1>
<blockquote>原文：<a href="https://itnext.io/automatically-handling-runtime-data-validation-in-typescript-b6dad067bdef?source=collection_archive---------6-----------------------#2022-05-27">https://itnext.io/automatically-handling-runtime-data-validation-in-typescript-b6dad067bdef?source=collection_archive---------6-----------------------#2022-05-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b320" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">JavaScript本身不能进行运行时数据验证，因此类型安全需要数据验证工具</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/8e875f5a1c60d6c7e1b40c93aafa15e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zjqFjv_kAyOElV-Q.jpg"/></div></div></figure><p id="f575" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">TypeScript做了出色的编译时类型检查。但这并不意味着TypeScript代码确保运行时类型或数据验证或检查。TypeScript在没有运行时检查的情况下将代码编译成JavaScript，这为运行时数据问题敞开了大门。</p><p id="92af" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用在编写时自动显示类型错误的IDE编写TypeScript代码，可以确保您的代码正确地处理它接收到的数据。理论上，这使得我们的应用程序更加安全。但是，这可能会让你自满。最终，TypeScript代码变成了JavaScript，在执行时没有检查，因为它是JavaScript。</p><p id="70ef" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这意味着您的生产代码容易受到坏数据导致的各种故障的影响。除非你了解防御性编程并正确检查你的数据。我们当中有多少人记得在每一个需要的地方都这样做？我们可能有最好的意图每次都在每一步检查数据的有效性，但是让我们诚实地承认我们有时会忘记这样做。</p><p id="e522" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最好实现自动运行时数据检查。数据检查可以内置于TypeScript类的定义中，这样每当您将数据分配给类中的字段时，或者每当您调用类方法时，都会进行数据检查。</p><p id="87bb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">要发现问题，请考虑以下情况:</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="5f27" class="lw lx iu ls b gz ly lz l ma mb">import { promises as fs } from 'fs';  </span><span id="ef1a" class="lw lx iu ls b gz mc lz l ma mb">class jsdata {<br/>     title: string;<br/>     range: number; <br/>}  </span><span id="3875" class="lw lx iu ls b gz mc lz l ma mb">async function readData(fn: string): Promise&lt;jsdata&gt; {<br/>     const txt = await fs.readFile(fn, 'utf-8');<br/>     const d = JSON.parse(txt);<br/>     const ret = new jsdata();<br/>     ret.title = d.title;<br/>     ret.range = d.range;<br/>     return ret; <br/>}  </span><span id="979a" class="lw lx iu ls b gz mc lz l ma mb">readData(process.argv[2]) .then(data =&gt; {<br/>     console.log(data); <br/>}) .catch(err =&gt; {<br/>     console.error(err); <br/>});</span></pre><p id="a8ef" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于一个应用程序来说，获得JSON数据，解析它，将数据存储在一个对象中，然后将该对象发送到其他地方是很常见的。这就是这个例子所展示的。</p><p id="c51b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们用一些好的数据来运行它:</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="2b8e" class="lw lx iu ls b gz ly lz l ma mb">{<br/>     "title": "Fantastic book title",<br/>     "range": 42 <br/>}</span></pre><p id="2f7e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">像这样运行它:</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="bb97" class="lw lx iu ls b gz ly lz l ma mb">$ npx ts-node ./json1.ts ./data1.json jsdata <br/>{ title: 'Fantastic book title', range: 42 }</span></pre><p id="8a59" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">它按预期工作，给出正确的值，并且这些值符合声明的数据类型。</p><p id="456a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是，如果我们给我们神奇的算法一些坏数据会发生什么？</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="13dc" class="lw lx iu ls b gz ly lz l ma mb">{<br/>     "range": "Fantastic book title",<br/>     "title": 42 <br/>}</span></pre><p id="4c20" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是相同的数据，但不知何故，一个错误弄乱了标签。这是可能发生的，对吗？</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="086c" class="lw lx iu ls b gz ly lz l ma mb">$ npx ts-node ./json1.ts ./data2.json jsdata <br/>{ title: 42, range: 'Fantastic book title' }</span></pre><p id="d917" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">哎呀，没有错误，现在我们的数据对象有了错误的数据类型。字段<code class="fe md me mf ls b">title</code>被声明为<code class="fe md me mf ls b">string</code>，但它却有<code class="fe md me mf ls b">number</code>，这与<code class="fe md me mf ls b">range</code>有着同样的问题。在实际的生产应用程序中，这种错误可能会产生严重的后果。</p><p id="52b0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们可能会挠头，想知道这是怎么发生的，因为TypeScript类清楚地声明了数据类型。但是，看看实际编译的JavaScript:</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="dfa1" class="lw lx iu ls b gz ly lz l ma mb">"use strict"; <br/>Object.defineProperty(exports, "__esModule", { value: true }); </span><span id="e7d0" class="lw lx iu ls b gz mc lz l ma mb">const fs_1 = require("fs"); </span><span id="b1eb" class="lw lx iu ls b gz mc lz l ma mb">class jsdata { } async function readData(fn) {<br/>     const txt = await fs_1.promises.readFile(fn, 'utf-8');<br/>     const d = JSON.parse(txt);<br/>     const ret = new jsdata();<br/>     ret.title = d.title;<br/>     ret.range = d.range;<br/>     return ret; <br/>} </span><span id="441d" class="lw lx iu ls b gz mc lz l ma mb">readData(process.argv[2])<br/>.then(data =&gt; {<br/>     console.log(data); <br/>})<br/>.catch(err =&gt; {<br/>     console.error(err); <br/>});</span></pre><p id="ec2f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">您在这里看到任何数据类型或类型检查了吗？事实上，<code class="fe md me mf ls b">jsdata</code>类在这里有一个空的声明。这段代码没有包含任何运行时数据验证的内容。这是运行时执行的代码，而不是上面显示的TypeScript代码。</p><p id="9da3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">换句话说——如果你写了上面的代码，并且相信自己是安全的，那么你已经被忽悠到啦啦地了。</p><p id="23c0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">需要的是运行时数据验证。TypeScript团队建议使用类型保护，这是确保数据类型正确的小函数。例如，在<code class="fe md me mf ls b">JSON.parse</code>行之后，将会有一行读数<code class="fe md me mf ls b">isJSData(d)</code>，它将检查所需的字段是否存在。</p><p id="fa39" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">另一种方法是<a class="ae mg" href="https://www.npmjs.com/package/runtime-data-validation" rel="noopener ugc nofollow" target="_blank">运行时数据验证</a>包中的运行时数据验证装饰器。它们允许在每次为字段赋值或者每次调用方法时进行自动类型检查。</p><p id="c300" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用这些装饰器重写上面的示例，如下所示:</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="4627" class="lw lx iu ls b gz ly lz l ma mb">import { promises as fs } from 'fs'; <br/>import {<br/>     IsInt, IsAscii,<br/>     ValidateParams, ValidateAccessor <br/>} from 'runtime-data-validation'; </span><span id="52c2" class="lw lx iu ls b gz mc lz l ma mb">class jsdata {<br/>     #title: string;</span><span id="54f0" class="lw lx iu ls b gz mc lz l ma mb">     @ValidateAccessor&lt;string&gt;()<br/>     @IsAscii()<br/>     set title(nt: string) { this.#title = nt; }<br/>     get title(): string { return this.#title; }</span><span id="54ec" class="lw lx iu ls b gz mc lz l ma mb">      #range: number;</span><span id="7ae9" class="lw lx iu ls b gz mc lz l ma mb">     @ValidateAccessor&lt;number&gt;()<br/>     @IsInt()<br/>     set range(nr: number) { this.#range = nr; }<br/>     get range(): number { return this.#range; }  <br/>}  </span><span id="5e8e" class="lw lx iu ls b gz mc lz l ma mb">async function readData(fn: string): Promise&lt;jsdata&gt; {<br/>     const txt = await fs.readFile(fn, 'utf-8');<br/>     const d = JSON.parse(txt);<br/>     const ret = new jsdata();<br/>     ret.title = d.title;<br/>     ret.range = d.range;<br/>     return ret; <br/>}  </span><span id="4934" class="lw lx iu ls b gz mc lz l ma mb">readData(process.argv[2]) .then(data =&gt; {<br/>     console.log({ title: data.title, range: data.range }); <br/>})<br/>.catch(err =&gt; {<br/>     console.error(err); <br/>});</span></pre><p id="4650" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这和上面大体相同。装饰者通过在代码中明确指出什么是预期的数据，为代码增加了一些价值。</p><p id="8502" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在设计<code class="fe md me mf ls b">runtime-data-validators</code>包时，我们发现不能使用附加到类属性的装饰器来实现运行时数据验证。只可能在访问器函数上实现这一点。因此，这个实现依赖于使字段<code class="fe md me mf ls b">title</code>和<code class="fe md me mf ls b">range</code>成为私有字段，并使用访问器函数来代替。</p><p id="ab52" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于成功案例，没有变化:</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="05b2" class="lw lx iu ls b gz ly lz l ma mb">$ npx ts-node ./lib/json/json2.ts ./lib/json/data1.json <br/>{ title: 'Fantastic book title', range: 42 }</span></pre><p id="ee08" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">代码仍然按预期执行，并产生正确的结果。</p><pre class="kk kl km kn gu lr ls lt lu aw lv bi"><span id="1f3a" class="lw lx iu ls b gz ly lz l ma mb">$ npx ts-node ./lib/json/json2.ts ./lib/json/data2.json <br/>TypeError: Expected a string but received a number<br/>     at assertString (/home/david/Projects/nodejs/runtime-data-validation-typescript/node_modules/validator/lib/util/assertString.js:17:11)<br/>     at Object.isAscii (/home/david/Projects/nodejs/runtime-data-validation-typescript/node_modules/validator/lib/isAscii.js:17:29)<br/>     at /home/david/Projects/nodejs/runtime-data-validation-typescript/lib/decorators/strings.ts:65:31<br/>     at vfunc (/home/david/Projects/nodejs/runtime-data-validation-typescript/lib/index.ts:87:14)<br/>     at jsdata.descriptor.set (/home/david/Projects/nodejs/runtime-data-validation-typescript/lib/index.ts:247:21)<br/>     at readData (/home/david/Projects/nodejs/typescript-decorators-examples/simple/lib/json/json2.ts:29:14)</span></pre><p id="01f1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">失败案例现在是真正的失败。在运行时，数据类型被正确实施。此外，堆栈跟踪不仅清楚地描述了问题，还指出了导致问题的正确代码行。</p><h2 id="162a" class="lw lx iu bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">摘要</h2><p id="ed60" class="pw-post-body-paragraph kv kw iu kx b ky my jv la lb mz jy ld le na lg lh li nb lk ll lm nc lo lp lq in bi translated"><code class="fe md me mf ls b">runtime-data-validation</code>包包含了一个很长的数据验证装饰者列表。有了它，您的应用程序应该运行得更安全，因为在将数据存储在类字段中或在类方法中使用之前，会自动检查数据。</p><p id="1fcc" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个包并不是JavaScript中运行时数据验证问题的唯一解决方案。有像AJV或JOI这样的软件包来帮助数据验证。并且，可以使用JSON模式和<code class="fe md me mf ls b">@hyperjump/json-schema</code>包来验证JSON。</p><p id="3d5e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这些方法的问题在于，在对象被验证之后，它们不能防止无效数据被分配给对象。假设您像上面一样读取JSON，然后验证它，并将JSON数据分配给<code class="fe md me mf ls b">jsdata</code>实例。怎样才能阻止代码将不正确的数据分配给实例呢？</p><p id="5a26" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用<code class="fe md me mf ls b">runtime-data-validation</code>，使用验证装饰器的保护存在于对受保护字段的每一次赋值和对受保护方法的每一次使用中。</p><p id="c562" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">要了解这些验证装饰器是如何实现的，请参见:<a class="ae mg" href="https://techsparx.com/nodejs/typescript/decorators/runtime-validation.html" rel="noopener ugc nofollow" target="_blank">使用装饰器和反射元数据在TypeScript中进行运行时数据验证</a></p><h1 id="4f2e" class="nd lx iu bd mh ne nf ng mk nh ni nj mn ka nk kb mq kd nl ke mt kg nm kh mw nn bi translated">关于作者</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj no"><img src="../Images/cd3e7a8d86d6e50583c4059045c1859f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*I4yAk25UAnZvtLye.jpg"/></div></figure><p id="a2b0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><a class="ae mg" href="https://davidherron.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iv">大卫·赫伦</strong> </a> <strong class="kx iv"> </strong>:大卫·赫伦是一名作家和软件工程师，专注于技术的明智使用。他对太阳能、风能和电动汽车等清洁能源技术特别感兴趣。David在硅谷从事了近30年的软件工作，从电子邮件系统到视频流，再到Java编程语言，他已经出版了几本关于Node.js编程和电动汽车的书籍。</p></div><div class="ab cl np nq hy nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="in io ip iq ir"><p id="aba4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><em class="nw">最初发表于</em><a class="ae mg" href="https://techsparx.com/nodejs/typescript/runtime-validation.html" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://techsparx.com</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>