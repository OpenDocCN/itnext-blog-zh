<html>
<head>
<title>Default Function Parameter Values: JavaScript ES6 Feature Series (Pt 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">默认函数参数值:JavaScript ES6特性系列(Pt 3)</h1>
<blockquote>原文：<a href="https://itnext.io/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12?source=collection_archive---------5-----------------------#2019-08-23">https://itnext.io/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12?source=collection_archive---------5-----------------------#2019-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7f17" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">更少的参数未定义检查使开发人员的工作更容易</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e16303c03ae70c3eb0a75a2ead60a55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4KYEDykRaoB9iQ24pBPlw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@thepootphotographer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">🇸🇮·扬科·菲利— @specialdaddy </a>在<a class="ae lb" href="https://unsplash.com/search/photos/learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="7a24" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="a05a" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi ma translated">这些帖子背后的灵感很简单:对于很多开发人员来说，JavaScript毫无意义——或者至少有时令人困惑。</p><p id="2adb" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">由于JS为web提供了如此多的功能，我想提供一些关于我经常使用的JavaScript ES6特性的文章，供其他开发人员参考。</p><p id="20ed" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我们的目标是让这些文章简短、深入地解释该语言的各种改进，我希望这些文章能启发您使用JS编写一些真正酷的东西。谁知道呢，在这个过程中你可能会学到一些新东西。😄</p><blockquote class="mo"><p id="7cfe" class="mp mq iq bd mr ms mt mu mv mw mx lz dk translated">在我的第三篇文章中，我想谈谈默认的函数参数值:这些东西将会把我们从代码中大量未定义的检查中拯救出来。</p></blockquote><h1 id="5055" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy my ka kb kc mz ke kf kg na ki kj kk bi translated">传统函数参数</h1><p id="0933" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">正如我之前的一篇文章所详述的，函数是JavaScript的基本构件之一。函数允许我们做的事情之一是定义一组语句，每次都以相同的方式执行任务或计算值，并提供一个可以传入进行操作的参数列表。</p><p id="ceb0" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">不管什么值作为参数传入，该函数将在每次调用时尝试运行相同的任务<em class="nb">。</em></p><h2 id="062a" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">剖析带参数的函数声明</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="ec45" class="nc jo iq np b gy nt nu l nv nw">function simpleAdd(a, b){<br/>  return a + b;<br/>}</span><span id="adaa" class="nc jo iq np b gy nx nu l nv nw">simpleAdd(2, 3); // prints: 5</span></pre><p id="c2a0" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">如果你在看上面的函数声明，下面是它的组成。<code class="fe ny nz oa np b">simpleAdd</code>是函数名，<code class="fe ny nz oa np b">a</code>和<code class="fe ny nz oa np b">b</code>是函数接受的两个参数，函数体<code class="fe ny nz oa np b">return a + b;</code>是语句。</p><p id="83ed" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">好的，这很简单，直截了当，非常有意义，对吗？没错。但是，如果传统的函数声明没有传递正确数量的参数，会发生什么呢？</p><p id="8a4d" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">参数过多是可以的，JavaScript引擎只知道忽略函数中不使用的额外参数，但是没有提供足够的参数是完全不同的问题……看看会发生什么。</p><h2 id="5825" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">函数声明的参数太多&amp;太少</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="fc56" class="nc jo iq np b gy nt nu l nv nw">function add(a, b){<br/>  return a + b;<br/>}</span><span id="fd17" class="nc jo iq np b gy nx nu l nv nw">console.log(add(1, 2, 3, 4)); // prints: 3</span><span id="d93e" class="nc jo iq np b gy nx nu l nv nw">console.log(add(1)); // prints: NaN</span></pre><p id="37d9" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">啊哈，缺少一个<code class="fe ny nz oa np b">b</code>参数对于<code class="fe ny nz oa np b">add(1)</code>函数来说不是很好。<code class="fe ny nz oa np b">NaN</code>(“不是一个数字”)是开发人员在试图用JavaScript做数学运算时永远不想看到的。</p><p id="630f" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">为什么会这样？因为传统上，函数参数在声明函数时默认为<code class="fe ny nz oa np b">undefined</code>，在代码中调用函数时等待<code class="fe ny nz oa np b">arguments</code>传入。那么，我们如何避免类似<code class="fe ny nz oa np b">NaN</code>的可怕事情呢？在ES6之前，我们不得不在函数中到处做类似于<code class="fe ny nz oa np b">undefined</code>检查的事情。</p><h2 id="d7c3" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">检查函数的“未定义”参数</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="bb5b" class="nc jo iq np b gy nt nu l nv nw">function addImproved(a, b) {<br/>if(a === undefined){<br/>  a = 3;<br/>}<br/>if(b === undefined){<br/>  b = 7;<br/>}<br/>  return a + b;<br/>}</span><span id="c845" class="nc jo iq np b gy nx nu l nv nw">console.log(addImproved(6,9)); // prints: 15 </span><span id="4136" class="nc jo iq np b gy nx nu l nv nw">console.log(addImproved()); // prints: 10</span></pre><p id="655d" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">在上面的例子<code class="fe ny nz oa np b">addImproved()</code>中，为了避免<code class="fe ny nz oa np b">undefined</code>参数错误，我们必须在每个参数传入时进行物理检查，并确保在最终让函数达到它的主要目标:将两个数相加之前，它不是未定义的。</p><p id="8b61" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">多么痛苦——想象一下，在一个庞大的代码库中，不得不为数百个函数一遍又一遍地编写相同类型的逻辑。😩不，谢谢，应该有更好的方法…</p><h1 id="6708" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">默认函数参数</h1><p id="de8b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">进入<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="noopener ugc nofollow" target="_blank">默认功能参数</a>；如果没有传入值或<code class="fe ny nz oa np b">undefined</code>，它们允许函数中的命名参数用默认值初始化。</p><p id="70f2" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">上面我简单解释过，到目前为止，在JavaScript中，函数参数自动默认为<code class="fe ny nz oa np b">undefined</code>；这意味着我们必须测试函数体中的参数值，检查潜在的未定义参数，如果它们未定义，就赋值。</p><p id="6877" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">如果没有赋值，这里有两种设置值的方法。第一个是简单的<code class="fe ny nz oa np b">if / else</code>语句，第二个是三元语句，检查参数的<code class="fe ny nz oa np b">type</code>是否未定义，并在需要时设置值。</p><h2 id="016c" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">防止未定义参数的两种老方法</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="5c00" class="nc jo iq np b gy nt nu l nv nw">function oldSum (x, y, z) {<br/>  if (y === undefined) {<br/>    y = 7;<br/>  }<br/>  z = (typeof z !== 'undefined') ? z : 42;<br/>  return `oldSum(${x}) === ${x + y + z}`;<br/>};</span><span id="b0a6" class="nc jo iq np b gy nx nu l nv nw">console.log(oldSum(1));  // prints: oldSum(1) === 50<br/>console.log(oldSum(2, 5, 8)); // prints: oldSum(2) === 15<br/>console.log(oldSum()); // prints: oldSum(undefined) === NaN</span></pre><p id="5b02" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">似乎有很多额外的代码只是为了在函数运行之前防止错误。使用ES2015中的默认参数，不再需要检查函数体。</p><h2 id="be42" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">使用默认参数防止未定义错误的ES6方法</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="fca8" class="nc jo iq np b gy nt nu l nv nw">function newSum (x, y = 7, z = 42) {<br/>  return `newSum(${x}) === ${x + y + z}`;<br/>};</span><span id="5b66" class="nc jo iq np b gy nx nu l nv nw">console.log(newSum(1)); // prints: newSum(1) === 50<br/>console.log(newSum(3, 6, 9)); // prints: newSum(3) === 18<br/>console.log(newSum(16, undefined)); // prints: newSum(16) === 65</span></pre><p id="7cd9" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">好多了！在命名参数的地方，如果没有提供足够的参数，它们也会被赋予默认值。这样读起来更干净、更容易，并且去掉了未定义检查的样板文件。</p><p id="b571" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我还应该提到，适用于函数声明中默认参数的规则也适用于箭头函数。看看这个。</p><h2 id="4774" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">箭头函数中的ES6默认参数</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="e7c9" class="nc jo iq np b gy nt nu l nv nw">const thisWayWorksToo = (x = 7, y = 8) =&gt; {<br/>  return x + y;<br/>}</span><span id="f8dd" class="nc jo iq np b gy nx nu l nv nw">console.log(thisWayWorksToo(3, 4)); // prints: 7</span><span id="eb29" class="nc jo iq np b gy nx nu l nv nw">console.log(thisWayWorksToo()); // prints: 15</span></pre><p id="d9eb" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">这些类型的例子是默认参数最常见的用例，但是，如果您有兴趣的话，还有更多的东西需要了解。🤔</p><h1 id="3eba" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">默认参数的陷阱和其他用例</h1><p id="6faa" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">默认参数还有一些其他有趣的功能，了解这些功能会很有帮助——它们还有一些非常方便的用例。让我们仔细检查一下，这样您就不会出错，或者当您出错时，您可以更快地调试问题的根源。</p><h2 id="a0c2" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">传递未定义的vs其他假值</h2><p id="25c1" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有一件事可能会让你犯错误:将其他错误值如<code class="fe ny nz oa np b">null</code>或<code class="fe ny nz oa np b">'’</code>传递给带有默认参数的函数将会导致默认值被替换。</p><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="1a8e" class="nc jo iq np b gy nt nu l nv nw">function luckyNumber(num = 11) { <br/>  console.log(typeof num);<br/>};</span><span id="1627" class="nc jo iq np b gy nx nu l nv nw">luckyNumber(); // prints: 'number' (num is set to 11)<br/>luckyNumber(undefined); // prints: 'number' (num is set to 11 too)</span><span id="3142" class="nc jo iq np b gy nx nu l nv nw">// test with other falsy values:</span><span id="c3b1" class="nc jo iq np b gy nx nu l nv nw">luckyNumber(''); // prints: 'string' (num is set to '')<br/>luckyNumber(null); // prints: 'object' (num is set to null)</span></pre><p id="0289" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">正如你在上面看到的，当调用<code class="fe ny nz oa np b">luckyNumber()</code>而没有值或者值为<code class="fe ny nz oa np b">undefined</code>时，它回到默认参数11。然而，当用空字符串或<code class="fe ny nz oa np b">null</code>值调用它时，它会取那个值。</p><h2 id="76c4" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">呼叫时的评估</h2><p id="afd8" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">第二件要知道的事情是:默认值是在调用时计算的，所以每次调用函数时都会创建一个新的对象<em class="nb">而不是像你想的那样，添加到一个已经存在的对象或数组中。</em></p><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="5f77" class="nc jo iq np b gy nt nu l nv nw">function append(value, array = []) {<br/>  array.push(value);<br/>  return array;<br/>}</span><span id="691a" class="nc jo iq np b gy nx nu l nv nw">console.log(append(1)); // prints: [1]<br/>console.log(append(2)); // prints: [2], not [1, 2]</span></pre><p id="b1ab" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">每次<code class="fe ny nz oa np b">append()</code>函数运行时，它都会创建一个全新的数组，数组中的内容是所提供的值。第一次调用和执行函数时，它会运行，生成一个数组，然后结束，一旦结束运行，它的执行上下文就会被销毁。</p><p id="67fa" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">这意味着该函数现在已经完全使用了(并且不知道)它创建的原始数组。这就是为什么当第二次使用第二个值调用<code class="fe ny nz oa np b">append()</code>时，它会创建第二个全新的数组，而不是添加到它创建的第一个数组中。</p><h2 id="4577" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">较早的参数可用于较新的默认参数</h2><p id="e647" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好了，这里有一个很酷的技巧:参数字符串中前面(左边)声明的参数可以被后面的默认参数使用。</p><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="8676" class="nc jo iq np b gy nt nu l nv nw">function welcome(name, greeting, message = greeting + ' ' + name) {<br/>  return [name, greeting, message];<br/>}</span><span id="cea9" class="nc jo iq np b gy nx nu l nv nw">console.log(welcome('Sean', 'Hi'));  // ["Sean", "Hi", "Hi Sean"]<br/>console.log(welcome('Sean', 'Hi', 'Happy Birthday!'));  // ["Sean", "Hi", "Happy Birthday!"]</span></pre><p id="eb27" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">通过传入参数<code class="fe ny nz oa np b">name</code>和<code class="fe ny nz oa np b">greeting</code>的值，<code class="fe ny nz oa np b">message</code>的第三个参数能够将这两个值作为另一个字符串值。很可爱。</p><p id="cd67" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">想象一下，你可以更干净地处理有很多潜在变量的函数。这个例子是我从<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters#Default_parameters_are_available_to_later_default_parameters" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>中借用的，关于默认参数，它真正说明了这一点。</p><h2 id="73bb" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">使用和不使用默认参数的更清晰的边缘案例处理</h2><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="dd58" class="nc jo iq np b gy nt nu l nv nw">function go() {<br/>  return ':P';<br/>}<br/><br/>function withDefaults(a, b = 5, c = b, d = go(), e = this, <br/>                      f = arguments, g = this.value) {<br/>  return [a, b, c, d, e, f, g];<br/>}<br/><br/>function withoutDefaults(a, b, c, d, e, f, g) {<br/>  switch (arguments.length) {<br/>    case 0:<br/>      a;<br/>    case 1:<br/>      b = 5;<br/>    case 2:<br/>      c = b;<br/>    case 3:<br/>      d = go();<br/>    case 4:<br/>      e = this;<br/>    case 5:<br/>      f = arguments;<br/>    case 6:<br/>      g = this.value;<br/>    default:<br/>  }<br/>  return [a, b, c, d, e, f, g];<br/>}<br/><br/>withDefaults.call({value: '=^_^='});<br/>// [undefined, 5, 5, ":P", {value:"=^_^="}, arguments, "=^_^="]<br/><br/>withoutDefaults.call({value: '=^_^='});<br/>// [undefined, 5, 5, ":P", {value:"=^_^="}, arguments, "=^_^="]</span></pre><p id="7d5a" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">是啊，有人会选择写出<code class="fe ny nz oa np b">withoutDefaults()</code>函数而不是<code class="fe ny nz oa np b">withDefaults()</code>函数吗？我认为不是。</p><h2 id="e62c" class="nc jo iq bd jp nd ne dn jt nf ng dp jx ln nh ni kb lr nj nk kf lv nl nm kj nn bi translated">默认参数后没有默认值的参数</h2><p id="7f8b" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然早期的参数可用于后来的默认参数，但您不能传入已定义的参数来填充函数中后来未定义的参数。很有道理，对吧？😉换句话说:参数总是从左到右设置的，即使后面有没有默认值的参数，它们也会覆盖默认参数。下面的例子可能更好地说明了这一点。</p><pre class="km kn ko kp gt no np nq nr aw ns bi"><span id="eab9" class="nc jo iq np b gy nt nu l nv nw">function f(x = 1, y) {<br/>  return [x, y];<br/>}</span><span id="fae2" class="nc jo iq np b gy nx nu l nv nw">console.log(f()); // prints: [1, undefined]</span><span id="66e3" class="nc jo iq np b gy nx nu l nv nw">console.log(f(4)); // prints: [4, undefined]</span></pre><p id="0da7" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">当涉及到函数中的默认参数时，这些是需要知道的一些主要事情。</p><h1 id="f64d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="ad2f" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">尽管JS已经存在了20多年，ES6也已经在2015年问世，但围绕它仍然存在大量错误信息和知识差距。</p><p id="d613" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">我试图揭开它的神秘面纱，让你更好地理解JavaScript和ES6——这些东西你可能每天都在使用，但并没有完全掌握它们的细微差别。</p><p id="344c" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">函数是JavaScript的关键构建块之一，在此之前，检查未定义的参数只是生活的一部分。不过，随着缺省参数的引入，至少可以去掉一些样板文件，使函数更容易编写、阅读和维护，我个人非常感激，并对未来的改进感到兴奋。</p><p id="d152" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">过几周再来看看，我会写更多关于JavaScript和ES6或其他与web开发相关的东西，所以请关注我，这样你就不会错过了。</p><p id="6f97" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated">感谢您的阅读，我希望您有机会在以后编写的函数中利用默认参数，无论是声明、表达式还是箭头函数。如果你觉得有帮助，请与你的朋友分享！</p><p id="7e69" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客:</strong></p><ul class=""><li id="5ae9" class="ob oc iq le b lf mj lj mk ln od lr oe lv of lz og oh oi oj bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392">箭头功能:JavaScript ES6特性系列(Pt 2) </a></li><li id="1508" class="ob oc iq le b lf ok lj ol ln om lr on lv oo lz og oh oi oj bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e"> Var，Let &amp; Const: JavaScript ES6特性系列(Pt 1) </a></li><li id="32bb" class="ob oc iq le b lf ok lj ol ln om lr on lv oo lz og oh oi oj bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/4-solutions-to-run-multiple-node-js-or-npm-commands-simultaneously-9edaa6215a93">同时运行多个Node.js或NPM命令的4种解决方案</a></li></ul></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="1a82" class="pw-post-body-paragraph lc ld iq le b lf mj lh li lj mk ll lm ln ml lp lq lr mm lt lu lv mn lx ly lz ij bi translated"><strong class="le ir">参考资料和更多资源:</strong></p><ul class=""><li id="4c82" class="ob oc iq le b lf mj lj mk ln od lr oe lv of lz og oh oi oj bi translated">函数，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Guide/Functions</a></li><li id="be21" class="ob oc iq le b lf ok lj ol ln om lr on lv oo lz og oh oi oj bi translated">默认函数参数，MDN Docs:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Functions/Default _ Parameters</a></li></ul></div></div>    
</body>
</html>