<html>
<head>
<title>Build fault tolerant applications with Cassandra API for Azure Cosmos DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Cassandra API为Azure Cosmos DB构建容错应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/build-fault-tolerant-applications-with-cassandra-api-for-azure-cosmos-db-d83f5f1fffb7?source=collection_archive---------2-----------------------#2020-09-10">https://itnext.io/build-fault-tolerant-applications-with-cassandra-api-for-azure-cosmos-db-d83f5f1fffb7?source=collection_archive---------2-----------------------#2020-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0bb0dd84ae9dac79e435e1d5af29dffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jI1uaqPLGjnrEnf407PYPA.png"/></div></div></figure><p id="163c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Azure Cosmos DB 是一个资源管理系统，它允许你根据你配置的<a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/set-throughput" rel="noopener ugc nofollow" target="_blank">提供的吞吐量</a>每秒执行一定数量的操作。如果客户端超过了这个限制，消耗的<a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/request-units" rel="noopener ugc nofollow" target="_blank">请求单元</a>比供应的多，就会导致后续请求的速率限制和抛出异常——它们也被称为<a class="ae kw" href="https://docs.microsoft.com/rest/api/cosmos-db/http-status-codes-for-cosmosdb?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank"> 429错误</a>。</p><p id="66d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">借助一个实际的例子，我将演示如何通过处理和重试受这些速率限制错误影响的操作，在您的<a class="ae kw" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>应用程序中引入容错。为了帮助你理解，这个博客的示例应用程序代码可以在GitHub 上找到<a class="ae kw" href="https://github.com/abhirockzz/cosmos-go-rate-limiting" rel="noopener ugc nofollow" target="_blank">——它使用了Apache Cassandra </a>的<a class="ae kw" href="https://github.com/gocql/gocql" rel="noopener ugc nofollow" target="_blank"> gocql驱动程序。</a></p><p id="8d97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将介绍:</p><ul class=""><li id="1ee5" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">运行示例应用程序之前的初始设置和配置</li><li id="234c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">执行各种负载测试场景并分析结果</li><li id="7975" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">重试策略实施的快速概述。</li></ul><p id="f4ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决速率限制的一种方法是调整供应的吞吐量，以满足您的应用需求。有多种方法可以做到这一点，包括使用Azure portal、Azure CLI和CQL (Cassandra Query Language)命令。</p><h2 id="983a" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">但是，如果您想在应用程序本身中处理这些错误呢？</h2><p id="8453" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">好在Azure Cosmos DB的Cassandra API将速率限制异常转化为Cassandra本地协议上的过载错误。由于<code class="fe mj mk ml mm b">gocql</code>驱动程序允许你插入自己的<a class="ae kw" href="https://pkg.go.dev/github.com/gocql/gocql?tab=doc#RetryPolicy" rel="noopener ugc nofollow" target="_blank"> RetryPolicy </a>，你可以编写一个定制的实现来拦截这些错误，并在某个(冷却)时间段后重试它们。然后这个策略可以<a class="ae kw" href="https://pkg.go.dev/github.com/gocql/gocql?tab=doc#Query.RetryPolicy" rel="noopener ugc nofollow" target="_blank">应用于每个查询</a>或者使用<a class="ae kw" href="https://pkg.go.dev/github.com/gocql/gocql?tab=doc#ClusterConfig" rel="noopener ugc nofollow" target="_blank"> ClusterConfig </a>在全局级别应用。</p><p id="19b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Azure Cosmos DB扩展库使得在Java应用程序中使用重试策略变得非常容易。GitHub 上有一个等价的Go版本<a class="ae kw" href="https://github.com/abhirockzz/cosmos-cassandra-go-extension" rel="noopener ugc nofollow" target="_blank">,并且已经在这篇博文的示例应用程序中使用。</a></p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="5e5c" class="mu lm iq bd ln mv mw mx lq my mz na lt nb nc nd lw ne nf ng lz nh ni nj mc nk bi translated">重试策略在起作用</h1><p id="1a1a" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">正如所承诺的，您将使用一个简单而实用的示例来完成整个过程。用于演示概念的示例应用程序是一个服务，它将REST端点暴露给保存在Azure Cosmos DB的Cassandra表中的<code class="fe mj mk ml mm b">POST</code>订单数据。</p><p id="1e77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在这个API服务上运行一些负载测试，以查看速率限制是如何表现的以及如何处理的。</p><h2 id="5f39" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">先决条件</h2><p id="8a6e" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">首先安装<a class="ae kw" href="https://github.com/rakyll/hey" rel="noopener ugc nofollow" target="_blank">嘿</a>，一个负载测试程序。您可以为<a class="ae kw" href="https://storage.googleapis.com/hey-release/hey_linux_amd64" rel="noopener ugc nofollow" target="_blank"> Linux </a>、<a class="ae kw" href="https://storage.googleapis.com/hey-release/hey_darwin_amd64" rel="noopener ugc nofollow" target="_blank"> Mac </a>和<a class="ae kw" href="https://storage.googleapis.com/hey-release/hey_windows_amd64" rel="noopener ugc nofollow" target="_blank"> Windows </a>下载特定于操作系统的二进制文件(64位)(如果您在下载实用程序时遇到问题，请参考<a class="ae kw" href="https://github.com/rakyll/hey#installation" rel="noopener ugc nofollow" target="_blank">GitHub repo</a>获取最新信息)</p><blockquote class="nl nm nn"><p id="7ce6" class="jy jz no ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq">您可以使用任何其他允许您在HTTP端点上生成负载的工具</em></p></blockquote><p id="d014" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">克隆这个GitHub repo并切换到正确的目录:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="ef81" class="ll lm iq mm b gy oa ob l oc od">git clone github.com/abhirockzz/cosmos-go-rate-limiting <br/>cd cosmos-go-rate-limiting</span></pre><h2 id="2161" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">设置Azure Cosmos DB</h2><p id="bdf4" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">选择Cassandra API选项，创建一个Azure <a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/create-cassandra-api-account-java?WT.mc_id=medium-blog-abhishgu#create-a-database-account" rel="noopener ugc nofollow" target="_blank"> Cosmos DB帐户</a></p><p id="1844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建一个键空间和表，使用下面的<code class="fe mj mk ml mm b">CQL</code>:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="84c6" class="ll lm iq mm b gy oa ob l oc od">CREATE KEYSPACE ordersapp WITH REPLICATION = {'class' : 'SimpleStrategy'};<br/>    <br/>    CREATE TABLE ordersapp.orders (<br/>        id uuid PRIMARY KEY,<br/>        amount int,<br/>        state text,<br/>        time timestamp<br/>    );</span></pre><h2 id="c21c" class="ll lm iq bd ln lo lp dn lq lr ls dp lt kj lu lv lw kn lx ly lz kr ma mb mc md bi translated">启动应用程序</h2><p id="ac91" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">打开终端并为应用程序设置环境变量:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="4654" class="ll lm iq mm b gy oa ob l oc od">export COSMOSDB_CASSANDRA_CONTACT_POINT=.cassandra.cosmos.azure.com <br/>export COSMOSDB_CASSANDRA_PORT=10350 <br/>export COSMOSDB_CASSANDRA_USER= <br/>export COSMOSDB_CASSANDRA_PASSWORD= <br/>#optional (default: 5) <br/>#export MAX_RETRIES=</span></pre><p id="7d64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要启动应用程序:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="5b99" class="ll lm iq mm b gy oa ob l oc od">go run main.go <br/>    <br/>//wait for this output <br/>Connected to Azure Cosmos DB</span></pre><p id="86a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试应用程序是否按预期工作，通过从不同的终端调用REST端点(每个订单一次)插入几个订单:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="96b9" class="ll lm iq mm b gy oa ob l oc od">curl <a class="ae kw" href="http://localhost:8080/orders" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/orders</a></span></pre><p id="717c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序会生成随机数据，因此您不必在调用端点时输入数据</p><p id="b4ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确认订单已成功存储。你可以在Azure门户中使用<a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/cassandra-support?WT.mc_id=medium-blog-abhishgu#hosted-cql-shell-preview" rel="noopener ugc nofollow" target="_blank">托管的CQL外壳，并执行下面的查询:</a></p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="6853" class="ll lm iq mm b gy oa ob l oc od">select count(*) from ordersapp.orders;<br/>    <br/>    // you should see this output<br/>    system.count(*) <br/>    ----------------- <br/>        1 <br/>    (1 rows)</span></pre><p id="80c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你都准备好了。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="6752" class="mu lm iq bd ln mv mw mx lq my mz na lt nb nc nd lw ne nf ng lz nh ni nj mc nk bi translated">让负载测试开始吧！</h1><p id="4ff2" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">用300个请求调用REST端点。这足以使系统过载，因为默认情况下只分配了400 RU/s。</p><p id="548d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">若要启动负载测试:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="0cd9" class="ll lm iq mm b gy oa ob l oc od">hey -t 0 -n 300 <a class="ae kw" href="http://localhost:8080/orders" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/orders</a></span></pre><p id="f3a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意应用程序终端中的日志。开始时，您将看到订单被成功创建。例如:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="5aa4" class="ll lm iq mm b gy oa ob l oc od">Added order ID 25a8cec1-e67a-11ea-9c17-7f242c2eeac0<br/>Added order ID 25a8f5ef-e67a-11ea-9c17-7f242c2eeac0<br/>Added order ID 25a8f5ea-e67a-11ea-9c17-7f242c2eeac0<br/>...</span></pre><p id="9644" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一段时间后，随着吞吐量下降并最终超过供应的限制，Azure Cosmos DB将对应用程序请求进行速率限制。这将以如下所示的错误形式出现:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="45da" class="ll lm iq mm b gy oa ob l oc od">Request rate is large: ActivityID=ac78fac3-5c36-4a20-8ad7-4b2d0768ffe4, <strong class="mm ir">RetryAfterMs=112</strong>, Additional details='Response status code does not indicate success: <strong class="mm ir">TooManyRequests (429)</strong>; Substatus: 3200; ActivityId: ac78fac3-5c36-4a20-8ad7-4b2d0768ffe4; Reason: ({<br/>      "Errors": [<br/>        "Request rate is large. More Request Units may be needed, so no changes were made. Please retry this request later. Learn more: http://aka.ms/cosmosdb-error-429"<br/>      ]<br/>    });</span></pre><blockquote class="nl nm nn"><p id="4e1e" class="jy jz no ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq">在上面的错误消息中，请注意以下内容:TooManyRequests (429)和RetryAfterMs=112 </em></p></blockquote><p id="7660" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">观察查询错误</strong></p><p id="9e34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们将使用日志输出进行测试/诊断。在查询执行过程中遇到的任何错误(在这种情况下与速率限制相关)都会被一个<a class="ae kw" href="https://pkg.go.dev/github.com/gocql/gocql?tab=doc#QueryObserver" rel="noopener ugc nofollow" target="_blank"> gocql截获。QueryObserver </a>。随机生成的订单ID也会记录在每个错误消息中，这样您就可以检查日志以确认失败的订单是否已经重试并(最终)存储在Azure Cosmos DB中。</p><p id="375f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是代码片段:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="946f" class="ll lm iq mm b gy oa ob l oc od">....<br/>    type OrderInsertErrorLogger struct {<br/>       orderID string<br/>    }<br/>    <br/>    // implements gocql.QueryObserver<br/>    func (l OrderInsertErrorLogger) ObserveQuery(ctx context.Context, oq gocql.ObservedQuery) {<br/>      err := oq.Err<br/>      if err != nil {<br/>         log.Printf("Query error for order ID %sn%v", l.orderID, err)<br/>      }<br/>    }<br/>    <br/>    ....<br/>    <br/>    // the Observer is associated with each query<br/>    rid, _ := uuid.GenerateUUID()<br/>    err := cs.Query(insertQuery).Bind(rid, rand.Intn(200)+50, fixedLocation, time.Now()).Observer(OrderInsertErrorLogger{orderID: rid}).Exec()<br/>    ....</span></pre><p id="21b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">完成了多少订单？</strong></p><p id="28ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">切换回负载测试终端，检查一些统计数据(为了简洁起见，输出已经被编辑)</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="b560" class="ll lm iq mm b gy oa ob l oc od">Summary: <br/>    <br/>      Total:        2.8507 secs <br/>      Slowest:      1.3437 secs <br/>      Fastest:      0.2428 secs <br/>      Average:      0.5389 secs <br/>      Requests/sec: 70.1592 <br/>    .... <br/>    <br/>    Status code distribution: <br/>      [200] 300 responses</span></pre><blockquote class="nl nm nn"><p id="68ac" class="jy jz no ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq">根据多种因素，具体情况下的数字会有所不同。</em></p></blockquote><p id="0838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是一个原始的基准测试，我们也没有生产级应用，所以你可以忽略<code class="fe mj mk ml mm b">Requests/sec</code>等。但是请注意<code class="fe mj mk ml mm b">Status code distribution</code>属性，它表明我们的应用程序对所有请求都用<code class="fe mj mk ml mm b">HTTP</code> <code class="fe mj mk ml mm b">200</code>来响应。</p><p id="c4c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们确认一下最终的数字。在Azure Cosmos DB门户中打开<strong class="ka ir"> Cassandra Shell </strong>并执行相同的查询:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="db46" class="ll lm iq mm b gy oa ob l oc od">select count(*) from ordersapp.orders;<br/>    <br/>    //output<br/>    <br/>    system.count(*)<br/>    -----------------<br/>        301</span></pre><p id="3c9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该看到已经插入了300个额外的<em class="no">行(订单)。关键的一点是，所有的订单都成功地存储在Azure Cosmos DB中——尽管存在速率限制错误，因为我们的应用程序代码基于我们配置的重试策略透明地重试了它们(只用一行代码！)</em></p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="393c" class="ll lm iq mm b gy oa ob l oc od">clusterConfig.RetryPolicy = retry.NewCosmosRetryPolicy(numRetries)</span></pre><h1 id="77fd" class="mu lm iq bd ln mv oe mx lq my of na lt nb og nd lw ne oh ng lz nh oi nj mc nk bi translated">关于动态吞吐量管理的一点注记</h1><p id="b784" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">如果您的应用大部分时间都以大约60–70%的吞吐量运行，那么使用<a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/provision-throughput-autoscale?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">自动扩展配置的吞吐量</a>可以通过在不使用时按比例缩减来帮助优化您的RU/s和成本使用，您只需按小时支付工作负载所需的资源。</p><p id="b628" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果没有重试策略，会发生什么呢？</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="dbcd" class="mu lm iq bd ln mv mw mx lq my mz na lt nb nc nd lw ne nf ng lz nh ni nj mc nk bi translated">停用策略以查看差异</h1><p id="1b09" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">停止应用程序(在终端中按<code class="fe mj mk ml mm b">control+c</code>，设置一个环境变量并重新启动应用程序:</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="f8b2" class="ll lm iq mm b gy oa ob l oc od">export USE_RETRY_POLICY=false <br/>go run main.go</span></pre><p id="658d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在再次运行负载测试之前，使用<code class="fe mj mk ml mm b">select count(*) from ordersapp.orders;</code>记下订单表中的行数</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="2c1c" class="ll lm iq mm b gy oa ob l oc od">hey -t 0 -n 300 <a class="ae kw" href="http://localhost:8080/orders" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/orders</a></span></pre><p id="fd09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在应用程序日志中，您会注意到相同的速率限制错误。在运行负载测试的终端中，在输出摘要的末尾，您将看到一些请求未能成功完成，即它们返回了除<code class="fe mj mk ml mm b">HTTP 200</code>之外的响应</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="6635" class="ll lm iq mm b gy oa ob l oc od">...<br/>Status code distribution: <br/>  [200] 240 responses <br/>  [429] 60 responses</span></pre><p id="96b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于没有强制实施重试策略，应用程序不再重试由于速率限制而失败的请求。</p><h1 id="6694" class="mu lm iq bd ln mv oe mx lq my of na lt nb og nd lw ne oh ng lz nh oi nj mc nk bi translated">增加调配的吞吐量</h1><p id="4444" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">您可以使用Azure门户增加请求单元(例如，加倍到<code class="fe mj mk ml mm b">800 RU/s</code>)并运行相同的负载测试</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="d984" class="ll lm iq mm b gy oa ob l oc od">hey -t 0 -n 300 <a class="ae kw" href="http://localhost:8080/orders" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/orders</a></span></pre><p id="641b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将<strong class="ka ir">而不是</strong>看到速率限制(<code class="fe mj mk ml mm b">HTTP 429</code>)错误，以及相对较低的延迟、每秒请求数等。</p><p id="21b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试增加请求的数量(使用<code class="fe mj mk ml mm b">-n</code>标志),看看应用程序何时突破了吞吐量阈值，从而达到速率限制。正如预期的那样，所有订单都将成功持久化(没有任何错误或重试)</p><p id="878b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一节简要介绍了<a class="ae kw" href="https://github.com/abhirockzz/cosmos-cassandra-go-extension" rel="noopener ugc nofollow" target="_blank">定制重试策略</a>的工作原理。</p><blockquote class="nl nm nn"><p id="ab41" class="jy jz no ka b kb kc kd ke kf kg kh ki np kk kl km nq ko kp kq nr ks kt ku kv ij bi translated"><em class="iq">这是一个实验性的实现，您应该编写自定义策略来满足应用程序的容错和性能要求。</em></p></blockquote></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="b8aa" class="mu lm iq bd ln mv mw mx lq my mz na lt nb nc nd lw ne nf ng lz nh ni nj mc nk bi translated">在幕后</h1><p id="aa46" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><code class="fe mj mk ml mm b">CosmosRetryPolicy</code>遵守<a class="ae kw" href="https://pkg.go.dev/github.com/gocql/gocql?tab=doc#RetryPolicy" rel="noopener ugc nofollow" target="_blank"> gocql。通过实现<code class="fe mj mk ml mm b">Attempt</code>和<code class="fe mj mk ml mm b">GetRetry</code>函数来返回策略</a>接口。</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="6542" class="ll lm iq mm b gy oa ob l oc od">type CosmosRetryPolicy struct {<br/>        MaxRetryCount         int<br/>        FixedBackOffTimeMs    int<br/>        GrowingBackOffTimeMs  int<br/>        numAttempts           int<br/>}</span></pre><p id="8e8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅当该查询的重试尝试次数小于或等于最大重试配置或将最大重试配置设置为-1(无限次重试)时，才会启动重试</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="acaa" class="ll lm iq mm b gy oa ob l oc od">func (crp *CosmosRetryPolicy) Attempt(rq gocql.RetryableQuery) bool { <br/>    crp.numAttempts = rq.Attempts() <br/>    return rq.Attempts() &lt;= crp.MaxRetryCount || crp.MaxRetryCount == -1<br/>}</span></pre><p id="c130" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">GetRetryType</code>函数检测错误类型，如果是速率受限错误(<code class="fe mj mk ml mm b">HTTP 429</code>)，它会尝试提取<code class="fe mj mk ml mm b">RetryAfterMs</code>字段的值(从错误消息中)，并在重试查询前使用该值休眠。</p><pre class="ns nt nu nv gt nw mm nx ny aw nz bi"><span id="ee55" class="ll lm iq mm b gy oa ob l oc od">func (crp *CosmosRetryPolicy) GetRetryType(err error) gocql.RetryType {<br/>    <br/>       switch err.(type) {<br/>       default:<br/>             retryAfterMs := crp.getRetryAfterMs(err.Error())<br/>             if retryAfterMs == -1 {<br/>                 return gocql.Rethrow<br/>             }<br/>            time.Sleep(retryAfterMs)<br/>            return gocql.Retry<br/>    <br/>    //other case statements have been omitted for brevity<br/>}</span></pre><p id="140d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Azure Cosmos DB不仅为您提供了使用各种方式配置和调整吞吐量需求的灵活性，还提供了允许应用程序处理速率限制错误的基本原语，从而使它们变得健壮和容错。这篇博客文章演示了如何为Go应用程序实现这一点，但是这些概念适用于任何语言及其各自的<a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/cassandra-support?WT.mc_id=medium-blog-abhishgu#cassandra-protocol" rel="noopener ugc nofollow" target="_blank"> CQL兼容</a>驱动程序，您可以选择这些驱动程序来使用Cassandra API for Azure Cosmos DB。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="6dcd" class="mu lm iq bd ln mv mw mx lq my mz na lt nb nc nd lw ne nf ng lz nh ni nj mc nk bi translated">要了解更多信息:</h1><p id="dc90" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">请查阅官方文档中的一些资源:</p><ul class=""><li id="ba25" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/provision-throughput-autoscale?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">自动扩展调配吞吐量的使用案例和优势</a></li><li id="31ff" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/cassandra-support?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">Azure Cosmos DB中Cassandra API支持的详细信息</a></li><li id="8b80" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/create-cassandra-go?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">使用Go应用程序和Cassandra API for Azure Cosmos DB开始运行</a></li><li id="b102" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/create-cassandra-go?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">关于Azure Cosmos DB中Cassandra API的常见问题</a></li><li id="f949" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.microsoft.com/azure/cosmos-db/request-units?WT.mc_id=medium-blog-abhishgu" rel="noopener ugc nofollow" target="_blank">请求单位概念</a></li></ul></div></div>    
</body>
</html>