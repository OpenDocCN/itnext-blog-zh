<html>
<head>
<title>Deploying Across Heterogeneous Edge Gateways in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中跨异构边缘网关部署</h1>
<blockquote>原文：<a href="https://itnext.io/deploying-across-heterogeneous-edge-gateways-in-kubernetes-b23571641061?source=collection_archive---------6-----------------------#2020-05-05">https://itnext.io/deploying-across-heterogeneous-edge-gateways-in-kubernetes-b23571641061?source=collection_archive---------6-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="668d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://www.sodalite.eu/" rel="noopener ugc nofollow" target="_blank">方钠石H2020项目</a>中，我们关注的一个领域是部署优化的集装箱，采用加速器专用ML模型，在互联车队中的异构边缘网关之间进行基于边缘的推理。这样做的主要动机有三点:</p><ul class=""><li id="6ced" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">虽然我们可以从用于基础模型训练的云和HPC资源(例如TensorFlow)中受益，但仍然需要针对特定加速器进行调整(例如，准备在GPU或EdgeTPU上执行的衍生TFLite模型)。</li><li id="6328" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">车辆的生命周期远远超过特定云服务的生命周期，这意味着我们无法对随着时间的推移我们正在部署的环境做出假设。</li><li id="5504" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">不同的服务可能更需要特定类型的加速器(例如GPU、FPGA)，这意味着现有服务可能需要重新调度，并在最佳基础上重新部署到另一个可用资源上。</li></ul><h1 id="c04c" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">Kubernetes中的节点标记</h1><p id="59a6" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">虽然已经有研究异构Kubernetes集群中的节点功能标记的现有工作，其中最突出的是官方的<a class="ae ko" href="https://github.com/kubernetes-sigs/node-feature-discovery" rel="noopener ugc nofollow" target="_blank">节点功能发现</a>项目，但是已经发现对边缘网关的支持有些缺乏，边缘网关通常是嵌入式SBC(通常作为独立的黑盒，或者作为预先存在的车载信息娱乐(IVI)系统的一部分)。例如，在官方<a class="ae ko" href="https://github.com/NVIDIA/k8s-device-plugin" rel="noopener ugc nofollow" target="_blank"> NVIDIA GPU设备插件</a>的情况下，GPU的检测需要使用NVIDIA管理库(NVML)，而NVIDIA管理库又假设了一个可枚举的PCI总线。因此，拥有集成GPU的Jetson Nano用户目前只是运气不佳。其他的，比如Coral Dev板，通过PCI总线提供EdgeTPU的枚举，但是还没有提供特定的设备插件来管理和展示EdgeTPU设备。<em class="mg">在这两种情况下，我们可以通过使用特定于平台的属性/设备功能来标记节点，并使用特定于加速器的目标运行时环境来部署容器，从而解决这些限制。</em></p><h2 id="59b8" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">输入设备树</h2><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mt"><img src="../Images/b5a16a4d314381907cd4e5029d8ee5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LoVIirfw6Wh-jdA8qrX5A.png"/></div></div></figure><p id="e8ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数这些边缘网关的一个共同特征是存在一个半标准的<em class="mg">设备树blob (DTB) </em>，它通过一个特殊的树结构公开了硬件及其相应拓扑的静态描述。虽然对devicetree的全面解释超出了这篇文章的范围，但是有兴趣的人可以在这里通读规范<a class="ae ko" href="https://www.devicetree.org/" rel="noopener ugc nofollow" target="_blank"/>。设备树及其<em class="mg">节点</em>结构概述如下:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nf"><img src="../Images/0102e129708bba0ac967db19a376f092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idfhcwRdsDUMEEbsqGcbtw.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">设备树节点概述。来源:自由电子，ELC 2014。</figcaption></figure><p id="2f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Jetson Nano的情况下，如下所示，其中<code class="fe nk nl nm nn b">/</code>表示树的顶部，或<em class="mg">根节点</em>:</p><pre class="mu mv mw mx gt no nn np nq aw nr bi"><span id="1cab" class="mh le it nn b gy ns nt l nu nv">/dts-v1/;</span><span id="c584" class="mh le it nn b gy nw nt l nu nv">/ {<br/>        nvidia,fastboot-usb-pid = &lt;0xb442&gt;;<br/>        compatible = "nvidia,jetson-nano", "nvidia,tegra210";<br/>        nvidia,proc-boardid = "3448";<br/>        nvidia,pmu-boardid = "3448";<br/>        serial-number = "xxxxxxxxxxxxxxxxx";<br/>        nvidia,dtbbuildtime = "Jul 16 2019", "17:09:35";<br/>        model = "NVIDIA Jetson Nano Developer Kit";<br/>        ...</span><span id="9e19" class="mh le it nn b gy nw nt l nu nv">        gpu {<br/>                compatible = "nvidia,tegra210-gm20b", "nvidia,gm20b";<br/>                access-vpr-phys;<br/>                resets = &lt;0x21 0xb8&gt;;<br/>                status = "okay";<br/>                interrupts = &lt;0x0 0x9d 0x4 0x0 0x9e 0x4&gt;;<br/>                reg = &lt;0x0 0x57000000 0x0 0x1000000 0x0 0x58000000 0x0 0x1000000 0x0 0x538f0000 0x0 0x1000&gt;;<br/>                iommus = &lt;0x2b 0x1f&gt;;<br/>                reset-names = "gpu";<br/>                nvidia,host1x = &lt;0x78&gt;;<br/>                interrupt-names = "stall", "nonstall";<br/>        };<br/>        ...</span></pre><p id="57c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然一般来说，根节点的<code class="fe nk nl nm nn b">model</code>属性应该以标准<code class="fe nk nl nm nn b">manufacturer,model</code>格式为我们提供特定型号系统板的唯一标识符，但不幸的是，规范选择了简单的方式，只有<em class="mg">推荐了标准格式</em>。规范的这种淡化意味着，不幸的是，我们不能使用<code class="fe nk nl nm nn b">model</code>属性作为节点标记的一致来源，而必须依赖于<code class="fe nk nl nm nn b">compatible</code>属性——虽然规范在这里也没有提供明确的要求，但这些至少被迫隐式地采用标准约定，以便与Linux内核命名约定相匹配。</p><h2 id="3781" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">从设备树属性生成节点标签</h2><p id="3533" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">为了从DeviceTree属性生成节点标签，我们专门为此开发了一个定制的Kubernetes控制器:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/adaptant-labs/k8s-dt-node-labeller" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">adaptent-labs/k8s-dt-node-label er</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">该工具提供了一个定制的Kubernetes控制器，用于自动标记带有devicetree属性的节点。这是…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo nd oa"/></div></div></a></div><p id="a7e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">鉴于<code class="fe nk nl nm nn b">model </code>编码缺乏一致性，如上所述，我们的DeviceTree节点标注器采用的方法是迭代根节点中的<code class="fe nk nl nm nn b">compatible</code>属性，以及我们希望显示标签的任何指定的子节点——例如，在Jetson Nano的情况下，<code class="fe nk nl nm nn b">gpu</code>节点。在定义了感兴趣的子节点的节点上进行的简单模拟演示了将要生成的标记:</p><pre class="mu mv mw mx gt no nn np nq aw nr bi"><span id="aede" class="mh le it nn b gy ns nt l nu nv">$ k8s-dt-node-labeller -d -n gpu<br/>Discovered the following devicetree properties:</span><span id="8f97" class="mh le it nn b gy nw nt l nu nv">beta.devicetree.org/nvidia-jetson-nano: 1<br/>beta.devicetree.org/nvidia-tegra210: 1<br/>beta.devicetree.org/nvidia-tegra210-gm20b: 1<br/>beta.devicetree.org/nvidia-gm20b: 1</span></pre><h2 id="91df" class="mh le it bd lf mi mj dn lj mk ml dp ln kb mm mn lr kf mo mp lv kj mq mr lz ms bi translated">将节点标记器部署到异构集群中</h2><p id="8d4f" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">节点标签本身旨在作为DaemonSet部署到异构集群中。下面显示了贴标机的运行概况:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi op"><img src="../Images/8bb6bf823cc7a21b03c85afa9070f371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8bahOg_Ml90vK8PunZ7hA.png"/></div></div></figure><p id="4bf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它设计为使用树内示例DaemonSet规范直接部署到集群中:</p><p id="51fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nk nl nm nn b">$ kubectl apply -f k8s-dt-labeller-ds.yaml</code></p><h1 id="be40" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">目标Pod放置</h1><p id="a31d" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">一旦贴标机启动并运行，现在就可以瞄准特定的网关或网关+加速器对。例如，为了以Jetson Nano为目标，特定于型号的<code class="fe nk nl nm nn b">beta.devicetree.org/nvidia-jetson-nano</code>标签可用作节点选择的基础。要针对特定的GPU，可以使用<code class="fe nk nl nm nn b">beta.devicetree.org/nvidia-gm20b</code>。为了进一步约束选择，可以一起使用多个标签来定义选择基础。</p><p id="f51b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用HTTP echo服务器作为简单的部署示例，带有GM20B GPU的Jetson Nano的目标Pod描述可以编写如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="oq or l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">针对Jetson Nano的Pod规格示例</figcaption></figure><p id="b995" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后可以通过一个简单的服务定义公开它，如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="oq or l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">HTTP echo服务规范示例</figcaption></figure><p id="304e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们进一步向外公开端口，以便在群集外进行测试:</p><pre class="mu mv mw mx gt no nn np nq aw nr bi"><span id="2110" class="mh le it nn b gy ns nt l nu nv">$ kubectl port-forward service/http-echo-service 5678:5678</span></pre><p id="aa83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并演示与相应节点的连接:</p><pre class="mu mv mw mx gt no nn np nq aw nr bi"><span id="2069" class="mh le it nn b gy ns nt l nu nv">$ curl -X GET localhost:5678<br/>hello from a Jetson Nano with an NVIDIA GM20B GPU</span></pre><h1 id="2881" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">后续步骤</h1><p id="0477" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">针对不同加速器类型的特定基本容器运行时环境正在单独准备，并将在方钠石项目的后期阶段提供。</p><p id="8a4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于针对Jetson Nano的NVIDIA GPU容器运行时入门示例，请参考NVIDIA官方指南<a class="ae ko" href="https://github.com/NVIDIA/nvidia-docker/wiki/NVIDIA-Container-Runtime-on-Jetson" rel="noopener ugc nofollow" target="_blank">此处</a>。可以使用前述的节点选择标准和Pod模板来执行集群内的Pod的调度。</p><h1 id="c692" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">限制</h1><ul class=""><li id="a6a7" class="kp kq it js b jt mb jx mc kb os kf ot kj ou kn ku kv kw kx bi translated">为了遍历设备树，需要访问节点的<code class="fe nk nl nm nn b">/sys/firmware</code>目录——这目前通过在<code class="fe nk nl nm nn b">privileged</code>模式下运行Pod来实现。或许可以利用<code class="fe nk nl nm nn b">allowedProcMountTypes</code>来禁用Pod内的路径屏蔽，并在无特权模式下运行，但这尚未得到验证。</li><li id="1755" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">目前，由于在DaemonSet Pod规范中Pod <a class="ae ko" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy" rel="noopener ugc nofollow" target="_blank"> RestartPolicy </a>被强制为<code class="fe nk nl nm nn b">Always</code>，因此不存在DaemonSet可以在不触发重启的情况下正常终止的机制。这意味着，此时，DaemonSet的初始节点选择器必须将其自身约束到已知支持DeviceTree的节点，以避免虚假的重新启动。这对于主要瞄准<code class="fe nk nl nm nn b">arm64</code>和<code class="fe nk nl nm nn b">armhf</code>目标来说还不是问题，但是对于其他架构来说可能是问题。</li><li id="d621" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">虽然标签器可以证明devicetree中节点的存在，但它不提供详细的特定于设备的信息或控制——所有这些都需要通过合适的设备插件来实现(或嵌入到容器运行时中——就像GPU的情况一样)。然而，标记器可以用作在具有匹配能力的节点上调度设备插件的基础。</li></ul></div></div>    
</body>
</html>