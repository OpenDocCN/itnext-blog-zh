<html>
<head>
<title>Understanding Angular Reactive Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解角反应形式</h1>
<blockquote>原文：<a href="https://itnext.io/understanding-angular-reactive-forms-241f9ed42c56?source=collection_archive---------4-----------------------#2019-05-07">https://itnext.io/understanding-angular-reactive-forms-241f9ed42c56?source=collection_archive---------4-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e9fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一篇有实际例子的深度文章！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df7d6039950d1fc476d9a7e734a8e658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h116XJOV-zU8MsMmNmY-NA.png"/></div></div></figure><blockquote class="ku kv kw"><p id="571a" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="it"> " </em>反应式表单提供了一种模型驱动的方法来处理值随时间变化的表单输入</p></blockquote><p id="3080" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">尽管第一次接触时，角反应形式看起来很复杂，但当你真正理解它时，它们会非常棒。它们非常强大，我在这里的目的是展示一些与它们相关的最重要的东西，这些东西在现实应用中非常有用。</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="6945" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">首先，为了使用它们，您需要将ReactiveFormsModule导入到所需的模块中。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="84cb" class="mj mk it mf b gy ml mm l mn mo">import { ReactiveFormsModule } from ‘@angular/forms’;</span></pre><h2 id="8ff8" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">表单控件</h2><p id="028c" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">一个<strong class="la iu">表单控件</strong>是一个保存表单每个属性的值和验证状态的类。大致来说，表单中的每个“输入”都将关联到一个<strong class="la iu">表单控件</strong>。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="fb4a" class="mj mk it mf b gy ml mm l mn mo">const myFormControl = new FormControl();</span></pre><p id="205c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">当创建一个<strong class="la iu">表单控件</strong>时，你可以将参数传递给构造函数。<br/>下面，我来介绍一下<strong class="la iu">表单控件</strong>初始化用的一些最有用的。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="c05f" class="mj mk it mf b gy ml mm l mn mo">const myFormControl = new FormControl(<br/>    { value: 'My String Value', disabled: true },<br/>    [ Validators.required, Validators.maxLength(30)]<br/>);</span></pre><p id="8122" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">第一个参数是<em class="kz">表单状态</em>，在其中我们可以设置<strong class="la iu">表单控件</strong> <strong class="la iu">的初始值</strong>以及是否应该初始禁用<strong class="la iu"/>。</p><p id="9da2" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">第二个参数是一个<strong class="la iu">验证器</strong>的数组，当<strong class="la iu">表单控件</strong>验证不通过时，将其设置为<strong class="la iu">无效</strong>。例如，在上面的例子中，<strong class="la iu">表单控件</strong>是<strong class="la iu">必填</strong>字段，其<strong class="la iu">最大长度为30 </strong>。如果输入值不符合这些要求，<strong class="la iu">表单控制</strong>状态将被设置为<strong class="la iu">无效</strong>。当它出现时，它将被设置为<strong class="la iu">有效</strong>。</p><p id="4624" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">Angular附带了一些适合大多数需求的预建验证器，可以在这里找到:<a class="ae nl" href="https://angular.io/api/forms/Validators" rel="noopener ugc nofollow" target="_blank">https://angular.io/api/forms/Validators</a>。</p><p id="0ce3" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">然而，有时你需要一些特定的验证，而那些验证器就是不行。对于这些情况，您可以创建自己的<strong class="la iu">定制验证器</strong>。我将在文章中进一步讨论这个问题。</p><h2 id="f54c" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">形式组合</h2><p id="5dbf" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">一个<strong class="la iu">表单组</strong>包含一组<strong class="la iu">表单控件</strong>。它也可能有<strong class="la iu">嵌套的表单组</strong>。它们还包含关于整个组的验证状态的信息。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="c486" class="mj mk it mf b gy ml mm l mn mo">const formGroup = new FormGroup({<br/>    'name': new FormControl('', [ Validators.required ]),<br/>    'email': new FormControl('', [ Validators.required ]),<br/>    'address': new FormGroup({<br/>        'zipCode': new FormControl(''),<br/>        'street': new FormControl(''),<br/>        'number': new FormControl('')<br/>    )<br/>});</span></pre><p id="3685" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">例如，在上面的例子中，<strong class="la iu">表单组</strong>的状态只有在<em class="kz">名称</em>和<em class="kz">电子邮件</em>属性被填充时才有效。</p><p id="498b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">在我们的组件中创建了一个<strong class="la iu">表单组</strong>，现在我们可以将它绑定到HTML中的一个表单。以下示例显示了如何实现这一点:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="a910" class="mj mk it mf b gy ml mm l mn mo">&lt;form [formGroup]="formGroup" &gt;<br/>  &lt;h1&gt;User Profile Form&lt;/h1&gt;</span><span id="c6ee" class="mj mk it mf b gy nm mm l mn mo">  &lt;input required<br/>    type="text"<br/>    placeholder="Full Name"<br/>    formControlName="name"<br/>  /&gt;</span><span id="1691" class="mj mk it mf b gy nm mm l mn mo">  &lt;input required<br/>    type="text"<br/>    placeholder="E-mail"<br/>    formControlName="email"<br/>  /&gt;</span><span id="b39d" class="mj mk it mf b gy nm mm l mn mo">  &lt;div formGroupName="address" &gt;<br/>    &lt;input required<br/>      type="text"<br/>      placeholder="Zipcode"<br/>      formControlName="zipcode"<br/>    /&gt;</span><span id="6805" class="mj mk it mf b gy nm mm l mn mo">    &lt;input required<br/>      type="text"<br/>      placeholder="Street"<br/>      formControlName="street"<br/>    /&gt;</span><span id="344c" class="mj mk it mf b gy nm mm l mn mo">    &lt;input required<br/>      type="number"<br/>      placeholder="Number"<br/>      formControlName="number"<br/>    /&gt;<br/>  &lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="45f4" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">如图所示，我们首先将表单绑定到创建的<strong class="la iu">表单组</strong>。然后，对于每个输入，我们绑定一个<strong class="la iu">表单控件</strong>。由于我们有一个<strong class="la iu">嵌套的表单组</strong>，我们必须为它设置一个区域<em class="kz"> formGroupName】，</em>让Angular知道那个区域中的<strong class="la iu">表单控件</strong>在那个嵌套的表单组中<strong class="la iu">。</strong></p><h2 id="4f81" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">读取表单控件值</h2><p id="261d" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">使用<strong class="la iu">表单组的</strong>方法<em class="kz"> get </em>您可以选择一个特定的<strong class="la iu">表单控件</strong>以读取其值或调用其一些方法。下面是您如何读取它的值，并且我们将进一步深入到您可以使用的一些方法中。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="37b6" class="mj mk it mf b gy ml mm l mn mo">const inputtedName = formGroup.get('name').value;</span><span id="944e" class="mj mk it mf b gy nm mm l mn mo">const inputtedZipCode = formGroup.get('address.zipCode').value;</span></pre><p id="35da" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">另外，在您的HTML中:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="43ec" class="mj mk it mf b gy ml mm l mn mo">&lt;p&gt;Inputted Name: {{ formGroup.get('name').value }}&lt;/p&gt;</span><span id="f2de" class="mj mk it mf b gy nm mm l mn mo">&lt;p&gt;Inputted ZIP: {{ formGroup.get('address.zipCode').value }}&lt;/p&gt;</span></pre><h2 id="d639" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">形成数组</h2><p id="46ec" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">一个<strong class="la iu">表单数组</strong>包含一个 <strong class="la iu">表单控件</strong>、<strong class="la iu">表单组</strong>甚至<strong class="la iu">表单数组</strong>的<strong class="la iu">数组。这是一个基本但必要的结构，用于处理具有角形的数组。假设你想收集一个用户的电话号码，允许他输入一个主要号码和一个次要号码。这就是你如何在你的<strong class="la iu">窗体组</strong>中声明一个<em class="kz">手机</em> <strong class="la iu"> <em class="kz"> </em>窗体数组</strong>:</strong></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="e7eb" class="mj mk it mf b gy ml mm l mn mo">const formGroup = new FormGroup({<br/>    'phones': new FormArray([<br/>        new FormGroup({<br/>            'number': new FormControl('', [ Validators.required ]),<br/>            'type': new FormControl('Primary')<br/>        }),<br/>        new FormGroup({<br/>            'number': new FormControl(''),<br/>            'type': new FormControl('Secondary')<br/>        })<br/>    ])<br/>});</span></pre><p id="db9f" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">然后，这就是如何设置您的标记，提供一个将为表单数组中的每个元素呈现的循环:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="f64d" class="mj mk it mf b gy ml mm l mn mo">&lt;form [formGroup]="formGroup" &gt;<br/>  &lt;h1&gt;User Phones&lt;/h1&gt;</span><span id="5aae" class="mj mk it mf b gy nm mm l mn mo">  &lt;div class="phones"<br/>    *ngFor="let phoneGroup of formGroup.get('phones')['controls'];<br/>            let i = index"<br/>    formArrayName="phones"<br/>  &gt;<br/>    &lt;ng-container [formGroupName]="i" &gt;</span><span id="9d72" class="mj mk it mf b gy nm mm l mn mo">      &lt;p&gt;Phone Type: {{ phoneGroup.get('type').value }}&lt;/p&gt;</span><span id="a840" class="mj mk it mf b gy nm mm l mn mo">      &lt;input<br/>        type="tel"<br/>        placeholder="Phone number"<br/>        formControlName="number"<br/>      /&gt;</span><span id="b777" class="mj mk it mf b gy nm mm l mn mo">    &lt;/ng-container&gt;<br/>  &lt;/div&gt;<br/>&lt;/form&gt;</span></pre><h2 id="cfc8" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">更新表单值</h2><p id="8506" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated"><strong class="la iu"> <em class="kz">设定值</em> </strong>和<strong class="la iu"> <em class="kz">补丁值</em> </strong>是来自角度反应表单的方法，允许您设置<strong class="la iu">表单组</strong> <strong class="la iu">控件</strong>的值。</p><p id="66c5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">使用<strong class="la iu"> <em class="kz"> setValue </em> </strong>您必须提供完整的对象，该对象将查找所有<strong class="la iu">表单组的</strong>属性并覆盖<strong class="la iu">表单控件的</strong>值。如果没有提供一个包含所有<strong class="la iu">表单组</strong>属性的对象，它将无法工作。下面是一个使用示例。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="fcee" class="mj mk it mf b gy ml mm l mn mo">const formGroup = new FormGroup({<br/>    'name': new FormControl('', [ Validators.required ]),<br/>    'email': new FormControl('', [ Validators.required ]),<br/>    'address': new FormGroup({<br/>        'zipCode': new FormControl(''),<br/>        'street': new FormControl(''),<br/>        'number': new FormControl('')<br/>    )<br/>});</span><span id="c22a" class="mj mk it mf b gy nm mm l mn mo">const updatedUserInfo = <em class="kz">{<br/>  </em>'name': 'Leonardo Giroto',<br/>  'email': 'leonardo@email.com',<br/>  'address': {<br/>    'zipCode': '22630-010',<br/>    'street': 'Avenida Lucio Costa',<br/>    'number': 9999<br/>  }<em class="kz"><br/>};</em></span><span id="fe73" class="mj mk it mf b gy nm mm l mn mo"><em class="kz">formGroup.setValue( </em>updatedUserInfo <em class="kz">);</em></span></pre><p id="7c0c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">另一方面，<strong class="la iu"> <em class="kz"> patchValue </em> </strong>方法可用于覆盖<strong class="la iu">表单组</strong>上已更改的任何一组属性。因此，当更新<strong class="la iu">表单控件的</strong>值时，您可以只传递一些字段。</p><p id="63ae" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">下面是一个使用示例，当我们使用它只更新我们的<strong class="la iu">表单组</strong>的地址部分时。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="6869" class="mj mk it mf b gy ml mm l mn mo">const formGroup = new FormGroup({<br/>    'name': new FormControl('', [ Validators.required ]),<br/>    'email': new FormControl('', [ Validators.required ]),<br/>    'address': new FormGroup({<br/>        'zipCode': new FormControl(''),<br/>        'street': new FormControl(''),<br/>        'number': new FormControl('')<br/>    )<br/>});</span><span id="2ecf" class="mj mk it mf b gy nm mm l mn mo">const newUserAddress = {<br/>  'zipCode': '01306-001',<br/>  'street': 'Rua Avanhandava',<br/>  'number': 999<br/>};</span><span id="a7e9" class="mj mk it mf b gy nm mm l mn mo"><em class="kz">formGroup.patchValue({</em><br/>  'address': newUserAddress<em class="kz"><br/>});</em></span></pre><p id="90f7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">注意到<strong class="la iu"> <em class="kz"> setValue </em> </strong>方法不仅可以在整个<strong class="la iu">表单组</strong>中使用，而且<strong class="la iu">也可以在表单控件</strong>中使用。因此，您可以通过在<strong class="la iu">表单控件</strong>上直接调用它来使用它更新单个控件值，如下所示。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="e160" class="mj mk it mf b gy ml mm l mn mo">formGroup.get('email').setValue('new_email@email.com');</span></pre><h2 id="dc25" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">表单验证状态</h2><p id="619b" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">当创建一个带有验证器的<strong class="la iu">表单组</strong>时，如前所示，根据其<strong class="la iu">表单控件</strong>保存的值，它将包含关于当前<strong class="la iu">表单验证状态</strong>的信息。例如，如果我们在<strong class="la iu">表单控件</strong>上有<em class="kz">必需的</em>验证器，并且所有值都为空，那么表单将被设置为<em class="kz">无效</em>。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="1be4" class="mj mk it mf b gy ml mm l mn mo">const isFormValid = formGroup.valid;</span><span id="faf6" class="mj mk it mf b gy nm mm l mn mo">const isEmailValid = formGroup.get('email').valid;</span></pre><p id="4910" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">以上是如何检查一个<strong class="la iu">表单组</strong>是否有效。需要注意的是，每个<strong class="la iu">表单控件</strong>都有一个验证状态。因此，如果任何一个表单控件验证状态为<em class="kz">无效</em>无效，则<strong class="la iu">表单组验证状态为<em class="kz">无效</em>。</strong></p><p id="7e34" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">另一个有趣的功能是选择<strong class="la iu">手动设置误差</strong>。如果您碰巧需要在您的流程中手动设置一个<strong class="la iu">表单控件</strong>为<em class="kz">无效</em>而不考虑验证器，那么您应该这样做:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="f89d" class="mj mk it mf b gy ml mm l mn mo">formGroup.get('email').setErrors({ 'incorrect': true });</span></pre><p id="64e5" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">该变更将更新<strong class="la iu">表单控件验证状态</strong>，并因此更新其<strong class="la iu">表单组</strong>。同样，您也可以通过将<strong class="la iu">表单控件的</strong>错误设置为<em class="kz"> null </em>来清除它们，如下所示:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="3ebe" class="mj mk it mf b gy ml mm l mn mo">formGroup.get('email').setErrors(null);</span></pre><h2 id="0e5f" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">感动&amp;肮脏</h2><blockquote class="ku kv kw"><p id="e5d4" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能不希望应用程序在用户有机会编辑表单之前显示错误。对<strong class="la iu">变脏</strong>和<strong class="la iu">被触摸</strong>的检查防止错误显示，直到用户做以下两件事之一:改变值，将控件变脏；或者模糊表单控件元素，将控件设置为touched。</p></blockquote><p id="3cd8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">检查<strong class="la iu">表单控件的“已触摸</strong>和<strong class="la iu">脏</strong>状态非常简单，如下例所示:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="7481" class="mj mk it mf b gy ml mm l mn mo">const isDirty = formGroup.get('email').dirty;</span><span id="9bba" class="mj mk it mf b gy nm mm l mn mo">const isTouched = formGroup.get('email').touched;</span></pre><h2 id="ba79" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">观察变化</h2><p id="f07d" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">一个非常有趣的特性是能够让<em class="kz">订阅</em>对<strong class="la iu">表单组</strong>或<strong class="la iu">表单控件</strong>的更改。这个想法非常简单:你设置一个订阅，每次窗体(或控件)上的值改变时，回调函数被触发，你可以在那里设置逻辑。这是您设置这些订阅的方式:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="319f" class="mj mk it mf b gy ml mm l mn mo">formGroup.valueChanges.subscribe((val) =&gt; {<br/>   // The form has changed. Insert here your logic!<br/>});</span></pre><p id="ef8b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">我发现它非常有用的一个实例是地址搜索API集成。假设您有一个供用户提供邮政编码的输入。您可以将一个<em class="kz">订阅</em>添加到它的控件中，一旦您收到一个有效的邮政编码，您就可以调用地址搜索API，并用它的响应填充其他地址字段；地址、城市、社区等。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="c534" class="mj mk it mf b gy ml mm l mn mo">formGroup.get(<br/>  'address.zipCode'<br/>).valueChanges.subscribe(async (val) =&gt; {<br/>  const fullAddress = await _service.getFullAddress(val);<br/>  formGroup.get('address.street').setValue(fullAddress.street);<br/>});</span></pre><h2 id="3468" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">自定义验证程序</h2><p id="396b" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated">正如我之前说过的，创建你自己的<strong class="la iu">自定义验证器</strong>来服务于特定的目的是可能的。大致来说，<em class="kz">验证器</em>是一个函数，它接收<strong class="la iu">表单控件</strong>作为参数，如果有效则返回<em class="kz"> null </em>，如果无效则返回<em class="kz">错误对象</em>。</p><p id="82cf" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">下面是一个<strong class="la iu">自定义验证器</strong>的例子。创建该文件是为了验证所提供的<em class="kz"> CPF </em>编号<em class="kz"> </em>(巴西文件)是否有效。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="02bd" class="mj mk it mf b gy ml mm l mn mo">public static CPFValidator(control) {<br/>  if (!control || !control.value) return null;</span><span id="d8dc" class="mj mk it mf b gy nm mm l mn mo">  return isCPFValid(control.value) ?<br/>    null : { 'invalidCnpj': 'invalid cpf' };<br/>}</span><span id="8cab" class="mj mk it mf b gy nm mm l mn mo">function isCPFValid(cpf) {<br/>  const regex = /[.-\s]/g;<br/>  let strCPF = cpf.replace(regex, '');<br/>  let Soma = 0;<br/>  let Resto;</span><span id="80d0" class="mj mk it mf b gy nm mm l mn mo">  for (let i = 1; i &lt;= 9; i++) {<br/>    Soma = Soma + parseInt(strCPF.substring(i - 1, i)) * (11 - i);<br/>    Resto = (Soma * 10) % 11;<br/>  }</span><span id="3d6f" class="mj mk it mf b gy nm mm l mn mo">  if ((Resto === 10) || (Resto === 11))<br/>    Resto = 0;</span><span id="8b78" class="mj mk it mf b gy nm mm l mn mo">  if (Resto !== parseInt(strCPF.substring(9, 10)))<br/>    return false;</span><span id="c02e" class="mj mk it mf b gy nm mm l mn mo">  Soma = 0;</span><span id="0bad" class="mj mk it mf b gy nm mm l mn mo">  for (let i = 1; i &lt;= 10; i++) {<br/>    Soma = Soma + parseInt(strCPF.substring(i - 1, i)) * (12 - i);<br/>    Resto = (Soma * 10) % 11;<br/>  }</span><span id="e3b4" class="mj mk it mf b gy nm mm l mn mo">  if ((Resto === 10) || (Resto === 11))<br/>    Resto = 0;</span><span id="0f43" class="mj mk it mf b gy nm mm l mn mo">  if (Resto !== parseInt(strCPF.substring(10, 11)))<br/>    return false;<br/>  return true;<br/>}</span></pre><p id="d345" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">这就是你如何在<strong class="la iu">表单控件的</strong>声明中使用它:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="ddeb" class="mj mk it mf b gy ml mm l mn mo">const formGroup = new FormGroup({<br/>    'name': new FormControl('', [ Validators.required ]),<br/>    'cpf': new FormControl('',<br/>        [ Validators.required, CPFValidator ]<br/>    )<br/>})</span></pre></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="ae77" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">角反应形式是非常强大的，其文件是非常完整的。即使有时候你不得不深入挖掘才能找到你想要的东西，你也可以通过一些例子找到它。</p><p id="01bb" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lu li lj lk lv lm ln lo lw lq lr ls lt im bi translated">希望有帮助😉</p><h2 id="f712" class="mj mk it bd mp mq mr dn ms mt mu dp mv lu mw mx my lv mz na nb lw nc nd ne nf bi translated">参考资料:</h2><p id="9492" class="pw-post-body-paragraph kx ky it la b lb ng ju ld le nh jx lg lu ni lj lk lv nj ln lo lw nk lr ls lt im bi translated"><a class="ae nl" href="https://angular.io/guide/reactive-forms" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/reactive-forms</a></p></div></div>    
</body>
</html>