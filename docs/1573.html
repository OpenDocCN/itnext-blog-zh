<html>
<head>
<title>Yet another tool to mock interfaces in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">又一个模仿Go接口的工具</h1>
<blockquote>原文：<a href="https://itnext.io/yet-another-tool-to-mock-interfaces-in-go-73de1b02c041?source=collection_archive---------0-----------------------#2018-11-27">https://itnext.io/yet-another-tool-to-mock-interfaces-in-go-73de1b02c041?source=collection_archive---------0-----------------------#2018-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/eed7f0d5315820857979ee54b0fa6333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OC_uFaDoGfZ7s1Pkg8YbGg.png"/></div></figure><p id="c3b0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一个强大的工具，单元测试能够检查代码行为的每个方面。如果你记住了代码测试的需求，你将会写出可持续和可维护的代码。依赖于抽象的设计良好的代码易于测试，因此代码的可测试性也可以作为其质量的指标。</p><p id="4d82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你已经尝试过在Go中测试代码，你可能知道接口有多有用。Go标准库为你提供了一系列接口，你可以在你的代码中使用这些接口，其中大多数只包含一个方法。</p><p id="7036" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Go还有一个补充的<a class="ae ks" href="https://github.com/golang/mock" rel="noopener ugc nofollow" target="_blank">框架</a>，用来帮助模仿界面和一堆共享类似功能的其他社区驱动的包。它们中的大多数提供了生成实现给定接口的结构的能力；如果一个接口很大或者它嵌入了其他接口，这是非常有用的。但是一个接口只有一个方法是不是太多了？</p><p id="828e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于Go中的接口，最令人惊奇的部分是它们被隐含地满足了。任何类型只要提供签名与接口声明匹配的方法，就能满足接口的要求。这种类型甚至可以是一个函数，如果你熟悉包<code class="fe kt ku kv kw b">net/http</code>，你可能已经见过其中一个类型，也叫做<code class="fe kt ku kv kw b">adapters</code>。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="3985" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您所看到的，<code class="fe kt ku kv kw b">adapter</code>本身是一个函数类型，具有与接口方法声明相同的签名，它通过在相应的方法中调用自己来实现一个接口。这个<code class="fe kt ku kv kw b">adapter</code>允许通过具有适当签名的任何函数来实现<code class="fe kt ku kv kw b">Handler</code>。它是模拟接口的通用工具，在表驱动测试中看起来非常方便。例如，下面是应该测试的代码:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="55d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着<code class="fe kt ku kv kw b">adapter</code>的使用，单元测试可能看起来像这样:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a8d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">编写这样的<code class="fe kt ku kv kw b">adapters</code>真的很烦人，所以我决定为它们的自动生成编写一个工具，并将其命名为<a class="ae ks" href="https://github.com/romanyx/adapt" rel="noopener ugc nofollow" target="_blank"> adapt </a>，这个工具为指定的接口生成一个<code class="fe kt ku kv kw b">adapter</code>并将其打印在输出中。您只需要传递一个包名和一个接口名来生成它。</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="ca91" class="lh li iq kw b gy lj lk l ll lm">$ adapt io Reader<br/>type readerFunc func([]byte) (int, error)<br/><br/>func (f readerFunc) Read(p []byte) (int, error) {<br/>	return f(p)<br/>}</span></pre><p id="80ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您还可以在包文件夹中调用<code class="fe kt ku kv kw b">adapt</code>来为一些包接口生成适配器。</p><pre class="kx ky kz la gt ld kw le lf aw lg bi"><span id="2952" class="lh li iq kw b gy lj lk l ll lm">$ cd $GOPATH/src/github.com/x/execute Doer<br/>$ adapt Doer<br/>type doerFunc func() (int, error)<br/><br/>func (f doerFunc) Do() (int, error) {<br/>	return f()<br/>}</span></pre><p id="9d34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它附带了一个方便的<a class="ae ks" href="https://github.com/romanyx/vim-go-adapt" rel="noopener ugc nofollow" target="_blank"> vim插件</a>，可以在vim中生成一个<code class="fe kt ku kv kw b">adapter</code>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/46a70a4100abc7b50e7310d4e2671a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PCMcTGnUNvjP0hooLXYBOw.gif"/></div></div></figure><p id="5955" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望你会发现它很有用。</p></div></div>    
</body>
</html>