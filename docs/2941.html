<html>
<head>
<title>Learn and Build Web Authentication System (Universal Principles)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习和建立网络认证系统(通用原则)</h1>
<blockquote>原文：<a href="https://itnext.io/learn-and-build-web-authentication-system-universal-principles-f23438cd44d2?source=collection_archive---------5-----------------------#2019-09-03">https://itnext.io/learn-and-build-web-authentication-system-universal-principles-f23438cd44d2?source=collection_archive---------5-----------------------#2019-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b88aa5c30ba34a9c8d208aacd7b298d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gN4Tf4rHQOKDdKAsynnGg.jpeg"/></div></div></figure><h1 id="a5e0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是认证？</h1><p id="0591" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">服务器基本上是愚蠢的计算机程序，它们在服务一次后就不记得是谁和什么发出了请求。客户机和服务器之间通过HTTP模型的通信是<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless" rel="noopener ugc nofollow" target="_blank">无状态的</a>，因为如果没有某种认证，服务器无法为每个请求确认客户机(用户代理)的身份。此外，他们还背负着过多的责任，比如不向其他人展示你的个人Twitter DM，记住你在亚马逊上添加到购物车的东西，保护你在DEV文章上的草稿不被其他人复制，防止你黑掉前任的脸书。所有这些都需要一种方式来告诉服务器你是谁，应该为你提供什么。</p><p id="715a" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">身份验证不仅仅是存储“用户电子邮件”。电子邮件和用户名是你在网上为自己创建的面向公众的数字身份。其他人也可以看到并使用它。因此，我们还使用密码和令牌来保护您的非公共资源。</p><h1 id="c0fa" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">密码</h1><p id="d074" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">存储密码的最基本也是最不安全的方法就是按原样保存。保存后，您可以查询并匹配用户提供的密码。这种方法非常糟糕，因为密码可以通过网络窃取，也可以在数据库遭到黑客攻击时窃取。大多数人在多个服务上使用同一个密码，你可能会把所有的密码都暴露给在你的网站上注册的所有用户。</p><blockquote class="mb mc md"><p id="9539" class="kw kx lu ky b kz lw lb lc ld lx lf lg me ly lj lk mf lz ln lo mg ma lr ls lt ij bi translated"><em class="iq"/>用明文存储密码是一种罪过。<em class="iq">”—j✝️</em></p></blockquote><p id="12be" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">一种方法是<strong class="ky ir">加密</strong>密码，然后存储起来。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/c04e24388e8743f443c7a9f7001c65e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXUvxp0st9_OlxckCfC9Bw.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><em class="mq">加密和解密</em></figcaption></figure><ol class=""><li id="d9e7" class="mr ms iq ky b kz lw ld lx lh mt ll mu lp mv lt mw mx my mz bi translated">您选择了一个密钥，您将使用该密钥混合密码来生成一个使用算法的随机字符串。</li><li id="2ee8" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">这个密码(乱码文本)将被存储在数据库中。</li><li id="ac87" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">认证时:</li></ol><ul class=""><li id="7bbe" class="mr ms iq ky b kz lw ld lx lh mt ll mu lp mv lt nf mx my mz bi translated">您可以使用相同的密钥解密数据库中的密码，以生成一个值，并将其与用户提供的密码相匹配。</li><li id="010c" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt nf mx my mz bi translated">或者，您可以在输入时使用相同的密钥加密密码，并将其与数据库中存储的值进行匹配。</li></ul><p id="3d56" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">有许多加密算法可以作为<a class="ae lv" href="https://golang.org/pkg/crypto/" rel="noopener ugc nofollow" target="_blank"> go </a>库使用。你可以在你选择的其他语言中找到相同的内容。这种方法的缺点是，如果你能解密出密码的原文，黑客也能。如果他们能够猜出一个密钥，那么您数据库中的每个其他用户也会受到威胁。</p><h1 id="9348" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">散列法</h1><p id="0f15" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用散列函数可以在不解密口令的情况下比较用于认证的口令。哈希函数使用一些预定义的算法将随机长度的字符串转换为固定长度的字符串。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/162006604e5d7a103a031ae0087ef5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RjWycLnGR_WxzMTXRSLSCA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">散列法</figcaption></figure><ol class=""><li id="37f5" class="mr ms iq ky b kz lw ld lx lh mt ll mu lp mv lt mw mx my mz bi translated">与加密不同，哈希函数生成的文本是不可逆的。</li><li id="992a" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">对于可变长度的输入，输出将是固定长度的。</li><li id="766f" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">即使输入文本的微小变化也会产生完全不同的<em class="lu">散列</em>。</li><li id="8b9d" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">对于相同的输入，生成相同的散列。我们可以用盐和胡椒来防止这种情况。</li></ol><h1 id="cbf2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">盐和胡椒</h1><p id="6d0e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在传递给哈希函数之前，我们需要在密码中添加一些字节。因为散列不能被解密，但是一个人仍然可以生成一个<a class="ae lv" href="https://en.wikipedia.org/wiki/Rainbow_table" rel="noopener ugc nofollow" target="_blank">彩虹表</a>，这是一个预先计算的常用密码及其散列函数的表。黑客可以将哈希值与数据库哈希值进行匹配，并能够说出密码。如果在保存哈希之前将唯一的随机字符串添加到密码中，这将被阻止。<br/> <code class="fe nh ni nj nk b">saltedhash(password) = hash(password || salt)</code></p><ol class=""><li id="16af" class="mr ms iq ky b kz lw ld lx lh mt ll mu lp mv lt mw mx my mz bi translated">每个密码的salt都是唯一的。因此，所有的散列都是唯一的。</li><li id="0d50" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">salt不是私有实体，它可以作为hash的一部分与hash一起保存，或者保存在不同的字段中。</li><li id="204a" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">如果两个用户使用相同的密码，当添加salts时，他们生成的哈希将会不同。</li></ol><p id="2a7c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><strong class="ky ir"> <em class="lu"> Pepper </em> </strong>也是添加到密码中的随机字符串，它们与salt的不同之处在于，它们对每个用户都不是唯一的，它们在所有应用程序中都是相同的。它们不一定存储在数据库中。我们将在应用程序演示中使用它们作为环境变量。</p><h1 id="b678" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">把手放在某物或者某人身上</h1><ol class=""><li id="ca7d" class="mr ms iq ky b kz la ld le lh nl ll nm lp nn lt mw mx my mz bi translated">注册一个在线免费的<a class="ae lv" href="https://www.elephantsql.com/" rel="noopener ugc nofollow" target="_blank"> postgres数据库</a>服务并获得<code class="fe nh ni nj nk b">host, port, username, dbname and password</code>。</li><li id="865f" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">在这里从github <a class="ae lv" href="https://github.com/erdahuja/blog-auth-system" rel="noopener ugc nofollow" target="_blank">派生并克隆项目。</a></li><li id="af63" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">编辑数据库凭据(或使用提供的凭据)。</li><li id="9098" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">运行在项目的根<code class="fe nh ni nj nk b">go run main.go</code>。</li><li id="5350" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">该项目包括主页，登录，注册，个人资料和帐户页面。要导航到个人资料和帐户页面，您需要一个令牌(稍后解释)。</li><li id="12ce" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">每次重启服务器时，数据库都会重置。你可以在根的<code class="fe nh ni nj nk b">main.go</code>中注释掉so的代码<code class="fe nh ni nj nk b">setUpDB</code>。</li></ol><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/cbd1d2b0d9dacff960ac7137378de39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*nNmfAhwKqq0_LBSkR98lcg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">项目结构</figcaption></figure><p id="5127" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">为了理解散列的应用，我们首先需要像密码和密码散列这样的字段。</p><h1 id="ba85" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用户模型</h1><blockquote class="mb mc md"><p id="6585" class="kw kx lu ky b kz lw lb lc ld lx lf lg me ly lj lk mf lz ln lo mg ma lr ls lt ij bi translated"><em class="iq">gorm标签(</em> <code class="fe nh ni nj nk b"><em class="iq">gorm:"-"</em></code> <em class="iq">)忽略密码字段，因为我们从不在数据库中存储密码。我们将存储明确定义的密码散列。</em></p></blockquote><h1 id="f69c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">注册流程</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c558a9232e635d008f90a712857d3b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*gLjubK5-PlcykkgNK9q_tA.png"/></div></figure><p id="9f0f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">使用<code class="fe nh ni nj nk b"><a class="ae lv" href="https://godoc.org/golang.org/x/crypto/bcrypt#GenerateFromPassword" rel="noopener ugc nofollow" target="_blank">bcrypt.GenerateFromPassword(password, cost)</a></code>获得密码的散列值。第二个参数是成本，即散列密码所需的工作量。将来当计算机变得更强大时，这种情况就会改变。现在默认成本是10。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">登录服务</figcaption></figure><p id="7a29" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">上面的代码片段使用了注册步骤。您可以在路径<code class="fe nh ni nj nk b">/dev-blog/services/signup.go</code>的项目资源库中找到完整的工作。</p><h1 id="720e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">登录过程</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b01493d31db6aec113998dbc73dc2e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*TxWzPPKhIxLORux_57pHQQ.png"/></div></figure><p id="0446" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">使用<code class="fe nh ni nj nk b"><a class="ae lv" href="https://godoc.org/golang.org/x/crypto/bcrypt#CompareHashAndPassword" rel="noopener ugc nofollow" target="_blank">bcrypt.CompareHashAndPassword(password, cost)</a></code>将散列密码与其纯文本密码进行比较。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fa34" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">上面的代码片段使用了注册步骤。您可以在路径<code class="fe nh ni nj nk b">/dev-blog/services/login.go</code>的项目库中找到完整的工作。</p><h1 id="73d0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Web服务器是无状态</h1><p id="3944" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">服务器独立处理每个请求。它不保存来自客户端请求的任何数据。每个请求都从服务器获得它所需要的一切，并得到响应。<br/>如何让服务器记住你前段时间在网站上做了什么？坦率地说，我们没有。我们让客户在每个请求中告知他们是谁以及他们需要什么资源。浏览时每次登录都是一项繁琐的任务，因此在登录一次后，我们会登录一个<a class="ae lv" href="https://dev.to/dpkahuja/!%5BCookie%5D(https://thepracticaldev.s3.amazonaws.com/i/p4rl31fjyk2yegfb536g.png)" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> cookie </strong> </a>(存储在计算机中的数据)，因此每次浏览一个网站时，浏览器都会将cookie和每个请求一起发送到链接的网站。我们将使用此cookie数据来验证用户。这个存储在cookie中的认证数据被称为一个<code class="fe nh ni nj nk b">Remember Token</code>。我们之前已经在用户模式中添加了这一点。</p><p id="a8e5" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">记住令牌是一系列特定长度的随机字节。<br/>我们使用以下代码片段创建它:</p><pre class="mi mj mk ml gt nt nk nu nv aw nw bi"><span id="3f29" class="nx jz iq nk b gy ny nz l oa ob">// GenerateRememberToken returns a 32 bytes random token string using<br/>// crypto/rand packages<br/>func GenerateRememberToken() string {<br/>    // create a placeholder of 32 bytes (big enough)    <br/>    b := make([]byte, 32) <br/>    _, err := rand.Read(b) // Fill it with random bytes<br/>    Must(err)<br/>    return base64.URLEncoding.EncodeToString(b) // encoded string<br/>}</span></pre><p id="f842" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">将该令牌添加到用户对象(RememberToken)的字段中，并保存到数据库。</p><p id="9985" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">以下代码片段有助于为网站设置cookie。</p><pre class="mi mj mk ml gt nt nk nu nv aw nw bi"><span id="2f6a" class="nx jz iq nk b gy ny nz l oa ob">cookie := http.Cookie{<br/>        Name:     "remember_token",<br/>        Value:    user.RememberToken,<br/>        HttpOnly: true,<br/>                Expires: time.Now().Add(24 * time.Hour),<br/>    }<br/>    http.SetCookie(w, &amp;cookie)</span></pre><p id="3715" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">在浏览器中看到cookie并修改它是非常容易的。为了保护我们的cookie不被临时修改，我们可以使用一些选项，比如HttpOnly(不允许javascript修改cookie)或者<strong class="ky ir">而不是</strong>以纯文本的形式存储记住的令牌。这是您的可编辑cookie:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/c081bc2a63e3473ea29010df3a38e124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfXEsjoqFdj5mmidyGJ4ug.png"/></div></div></figure><p id="962d" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我们宁愿保存相同令牌的散列，并在每次请求时将它与cookie提供的令牌进行比较。<br/>如果我们使用bcrypt散列，我们将:</p><ol class=""><li id="ec9d" class="mr ms iq ky b kz lw ld lx lh mt ll mu lp mv lt mw mx my mz bi translated">使用电子邮件从数据库中查找用户</li><li id="87ca" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">使用salt散列用户的密码，salt是PasswordHash字段的一部分</li><li id="6f75" class="mr ms iq ky b kz na ld nb lh nc ll nd lp ne lt mw mx my mz bi translated">比较，但在记住令牌的情况下，我们无法从数据库中查找用户，因为我们没有在数据库中存储remember token(只有它的散列)，我们需要一种方法来首先从cookie中散列值，然后找到用户。像<a class="ae lv" href="https://golang.org/pkg/crypto/hmac/#New" rel="noopener ugc nofollow" target="_blank"> crypto/hmac </a>这样简单的散列函数就可以了。</li></ol><pre class="mi mj mk ml gt nt nk nu nv aw nw bi"><span id="ff81" class="nx jz iq nk b gy ny nz l oa ob">// Hash generates hash for given input with secret key of hmac object<br/>func Hash(token string) string {<br/>       // sha256 is hashing algorithm<br/>       // key can be taken from env variable too<br/>    h := hmac.New(sha256.New, []byte("somekey"))<br/>    h.Reset() // Clear previous leftover bytes<br/>    h.Write([]byte(token))<br/>    b := h.Sum(nil)<br/>    return base64.URLEncoding.EncodeToString(b)<br/>}</span></pre><p id="a897" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated"><em class="lu"> utils/utils.go </em></p><p id="a09c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">下面是我们将如何使用所有这些:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1efc" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这些登录方法将在<em class="lu">登录</em>或<em class="lu">注册</em>后调用一次，一个记住令牌将作为cookie存储在浏览器中，其哈希版本将保存到数据库中。</p><p id="93bf" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">现在，当用户访问个人资料或帐户等认证页面。我们可以使用令牌进入请求，并将其与存储在数据库中的散列版本进行比较。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9080" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">因为我们知道在<em class="lu">中，散列</em>对于相同的输入字符串产生相同的输出。我们可以散列cookie中的记忆令牌并进行比较。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7317" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">这些是构建认证系统的几个部分。完整的工作项目可在<a class="ae lv" href="https://github.com/erdahuja/blog-auth-system" rel="noopener ugc nofollow" target="_blank">这里</a>获得。这也有go中的html模板解析，我写了一个深入的指南<a class="ae lv" href="https://levelup.gitconnected.com/learn-and-use-templates-in-go-aa6146b01a38" rel="noopener ugc nofollow" target="_blank">释放SSR的超能力</a>(学习和使用Go中的模板)。</p><p id="3cab" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">通过错误处理、每条路线的单独处理程序文件等，简化了项目结构以便于理解。谢谢你坚持到最后。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/247741b59b2daf9d27f96f8368966be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*-9aEy8A4el3qzJ_BP8tJyQ.gif"/></div></figure><p id="0601" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">有不清楚的地方请随意评论或者在<a class="ae lv" href="https://twitter.com/dpkahuja" rel="noopener ugc nofollow" target="_blank"> twitter </a>打个招呼。</p><p id="030f" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh ly lj lk ll lz ln lo lp ma lr ls lt ij bi translated">我的另一项工作是<a class="ae lv" href="https://levelup.gitconnected.com/get-a-taste-of-concurrency-in-go-625e4301810f" rel="noopener ugc nofollow" target="_blank">体验Go中的并发性</a></p></div></div>    
</body>
</html>