<html>
<head>
<title>Connecting Competing Microservices using RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RabbitMQ连接竞争的微服务</h1>
<blockquote>原文：<a href="https://itnext.io/connecting-competing-microservices-using-rabbitmq-28e5269861b6?source=collection_archive---------3-----------------------#2018-06-05">https://itnext.io/connecting-competing-microservices-using-rabbitmq-28e5269861b6?source=collection_archive---------3-----------------------#2018-06-05</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><figure class="iq ir gq gs is it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj ip"><img src="../Images/24d967f8e1c21a5caeee73214e2fb4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zu67flWwrp8MrDTSo98p2w.jpeg"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">一起在电梦兔女郎里。(改编自rente42 的公共域<a class="ae je" href="https://www.flickr.com/photos/129713999@N05/21164282874" rel="noopener ugc nofollow" target="_blank">照片)</a></figcaption></figure><div class=""/><p id="3627" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">将现有的整体应用程序分解为微服务的一个常见原因是“可扩展性”。通过StackOverflow 的快速<a class="ae je" href="https://stackoverflow.com/search?q=rabbitMQ+competing+consumers" rel="noopener ugc nofollow" target="_blank">搜索显示，很少有人真正了解如何做到这一点，对于如何协调竞争的微服务这个问题，实际上没有真正好的答案。</a></p><p id="c4f5" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">许多人的核心问题是，如果多个相同的服务竞争使用一个事件，一旦该事件被一个服务使用，如何确保其他不竞争的服务也被调用。</p><p id="0c43" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">在本文中，我用一个简单的假设的例子来解释如何做到这一点，这个例子用<a class="ae je" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>编写，使用<a class="ae je" href="https://www.rabbitmq.com" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>作为消息总线。</p><h1 id="3de1" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">方案</h1><p id="f7a3" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">假设您正在构建一个系统，该系统从网络上检索图像，对它们进行ocr以提取任何文本内容，并记录与该图像相关的任何元数据。OCR过程很慢，所以您希望通过运行许多相互竞争的OCR服务来并行处理系统的这一方面。</p><p id="a110" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">只是为了更好地衡量，您还希望运行多个元数据分析服务。</p><p id="5200" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以你编写三个微服务，它们将通过<code class="fe mf mg mh mi b"><a class="ae je" href="https://www.amqp.org" rel="noopener ugc nofollow" target="_blank">AMQP</a></code>消息总线发送的消息链接在一起。</p><ol class=""><li id="a391" class="mj mk jh kg b kh ki kl km kp ml kt mm kx mn lb mo mp mq mr bi translated"><strong class="kg ji">图像检测器</strong>:获取一幅图像，完成后通过<code class="fe mf mg mh mi b">AMQP</code>发出一个<code class="fe mf mg mh mi b">'image.detected'</code>事件。</li><li id="5821" class="mj mk jh kg b kh ms kl mt kp mu kt mv kx mw lb mo mp mq mr bi translated"><strong class="kg ji">图像OCR服务</strong>:它监听<code class="fe mf mg mh mi b">'image.detected'</code>事件，当它听到该事件时，它对图像进行OCR。您将运行该服务的两个竞争实例。</li><li id="b5b4" class="mj mk jh kg b kh ms kl mt kp mu kt mv kx mw lb mo mp mq mr bi translated">图像元数据服务:它也监听<code class="fe mf mg mh mi b">'image.detected'</code>事件，当它听到时，提取图像的元数据。您还将运行两个相互竞争的实例。</li></ol><p id="cca0" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe mf mg mh mi b">ImageOCR</code>和<code class="fe mf mg mh mi b">ImageMetaData</code>服务都需要监听<code class="fe mf mg mh mi b">'image.detected'</code>事件，但是<strong class="kg ji">每个服务</strong>中只有一个应该实际处理消息。</p><p id="ae5a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">整个系统将如下所示:</p><figure class="my mz na nb gu it gi gj paragraph-image"><div role="button" tabindex="0" class="iu iv di iw bf ix"><div class="gi gj mx"><img src="../Images/b990a8fad3d5b7f5840eca5e3fedc4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ns8GHalm9m_ixvQW4AaFQ.png"/></div></div><figcaption class="ja jb gk gi gj jc jd bd b be z dk translated">使用RabbitMQ的图像分析微服务架构</figcaption></figure><p id="e81d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">当然，在现实世界中，这些服务也需要一种方式将图像发送到其他服务，并存储或传输它们提取的数据。但是这里的重点是消息交换，所以我忽略了这些方面。</p><h1 id="fe9d" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">密码</h1><p id="4716" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">github.com/davesag/competing-services-example的全部来源。</p><h2 id="2723" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">该图像检测器</h2><p id="7ee5" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">撇开它从哪里获得图像，以及如何存储或传输图像不谈，让我们只关注这项服务的<em class="no">事件发布</em>方面。</p><p id="005d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">首先定义一些所有服务可以共享的常量:</p><h2 id="884d" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">src/constants.js</h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="a51f" class="nc ld jh mi b gz nt nu l nv nw">const exchange = 'IMAGE-ANALYSIS'<br/>const routingKey = 'image.detected'</span><span id="a4b6" class="nc ld jh mi b gz nx nu l nv nw">const OCR_QUEUE = 'OCR'<br/>const META_DATA_QUEUE = 'META-DATA'</span><span id="a134" class="nc ld jh mi b gz nx nu l nv nw">module.exports = {<br/>  exchange,<br/>  routingKey,<br/>  OCR_QUEUE,<br/>  META_DATA_QUEUE<br/>}</span></pre><p id="1401" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后是<code class="fe mf mg mh mi b">ImageDetector</code> ( <em class="no">只是它的发布者部分</em>):</p><p id="e11e" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="kg ji">注</strong> : <em class="no">我用</em> <code class="fe mf mg mh mi b"><a class="ae je" href="https://github.com/davesag/amqp-simple-pub-sub" rel="noopener ugc nofollow" target="_blank"><em class="no">amqp-simple-pub-sub</em></a></code> <em class="no">来说明这一点，因为1)这是我写的，2)这使得构建AMQP发布/订阅系统非常简单。</em></p><h2 id="1f48" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">src/ImageDetector/index.js</h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="5f09" class="nc ld jh mi b gz nt nu l nv nw">const { makePublisher } = require('amqp-simple-pub-sub')<br/>const { exchange } = require('../constants')</span><span id="87d0" class="nc ld jh mi b gz nx nu l nv nw">const makeService = () =&gt; makePublisher({ exchange })</span><span id="afe4" class="nc ld jh mi b gz nx nu l nv nw">const start = async () =&gt; {<br/>  const service = makeService()<br/>  await service.start()<br/>  return service<br/>}</span><span id="d3c9" class="nc ld jh mi b gz nx nu l nv nw">module.exports = { start }</span></pre><p id="acf2" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">对于<code class="fe mf mg mh mi b">OCR</code>和<code class="fe mf mg mh mi b">MetaData</code>服务，定义一个<code class="fe mf mg mh mi b">genericSubscriber</code>外壳:</p><h2 id="7553" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">src/genericSubscriber.js</h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="eed1" class="nc ld jh mi b gz nt nu l nv nw">const { makeSubscriber } = require('amqp-simple-pub-sub')</span><span id="8bc5" class="nc ld jh mi b gz nx nu l nv nw">const { exchange, routingKey } = require('./constants')</span><span id="28fd" class="nc ld jh mi b gz nx nu l nv nw">const genericSubscriber = (queueName, makeHandler) =&gt; {<br/>  const routingKeys = [routingKey]</span><span id="8d77" class="nc ld jh mi b gz nx nu l nv nw">  const makeService = () =&gt;<br/>    makeSubscriber({ exchange, queueName, routingKeys })</span><span id="32be" class="nc ld jh mi b gz nx nu l nv nw">  const start = async name =&gt; {<br/>    const service = makeService()<br/>    const handler = makeHandler(service, name)<br/>    await service.start(handler)<br/>    return service<br/>  }</span><span id="bec2" class="nc ld jh mi b gz nx nu l nv nw">  return { start }<br/>}</span><span id="3ded" class="nc ld jh mi b gz nx nu l nv nw">module.exports = genericSubscriber</span></pre><p id="9aa9" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后按如下方式声明每个服务:</p><h2 id="bbe0" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated"><code class="fe mf mg mh mi b">src/ImageMetaData/index.js</code></h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="9463" class="nc ld jh mi b gz nt nu l nv nw">const genericSubscriber = require('../genericSubscriber')<br/>const makeHandler = require('./makeHandler')<br/>const { META_DATA_QUEUE: queueName } = require('../constants')</span><span id="dc2e" class="nc ld jh mi b gz nx nu l nv nw">module.exports = genericSubscriber(queueName, makeHandler)</span></pre><p id="4007" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">并且:</p><h2 id="4784" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated"><code class="fe mf mg mh mi b">src/ImageOCR/index.js</code></h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="4846" class="nc ld jh mi b gz nt nu l nv nw">const genericSubscriber = require('../genericSubscriber')<br/>const makeHandler = require('./makeHandler')<br/>const { OCR_QUEUE: queueName } = require('../constants')</span><span id="9dee" class="nc ld jh mi b gz nx nu l nv nw">module.exports = genericSubscriber(queueName, makeHandler)</span></pre><p id="50a6" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">真正的服务实现所在的<code class="fe mf mg mh mi b">handlers</code>很简单:</p><h2 id="5b23" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated"><code class="fe mf mg mh mi b">src/ImageMetaData/makeHandler.js</code></h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="f84d" class="nc ld jh mi b gz nt nu l nv nw">const makeHandler = (subscriber, name) =&gt; async message =&gt; {<br/>  const data = JSON.parse(message.content.toString())<br/>  console.log('Meta Data', name, data.meta)<br/>  // do service implementation.<br/>  subscriber.ack(message)<br/>}</span><span id="732c" class="nc ld jh mi b gz nx nu l nv nw">module.exports = makeHandler</span></pre><p id="1858" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">并且:</p><h2 id="59b9" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated"><code class="fe mf mg mh mi b">src/ImageOCR/makeHandler.js</code></h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="d59f" class="nc ld jh mi b gz nt nu l nv nw">const makeHandler = (subscriber, name) =&gt; async message =&gt; {<br/>  const data = JSON.parse(message.content.toString())<br/>  console.log('OCR', name, data.text)<br/>  // do service implementation.<br/>  subscriber.ack(message)<br/>}</span><span id="b2d8" class="nc ld jh mi b gz nx nu l nv nw">module.exports = makeHandler</span></pre><h1 id="82fe" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">将它连接在一起</h1><p id="c514" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">下面是一个简单的<code class="fe mf mg mh mi b">index.js</code>文件，它实例化了各种服务并运行事件发布器:</p><h2 id="64b1" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">src/index.js</h2><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="1e64" class="nc ld jh mi b gz nt nu l nv nw">const ImageDetector = require('./ImageDetector')<br/>const ImageMetaData = require('./ImageMetaData')<br/>const ImageOCR = require('./ImageOCR')</span><span id="7a0c" class="nc ld jh mi b gz nx nu l nv nw">const { routingKey } = require('./constants')<br/>const FIVE_SECONDS = 5000</span><span id="4e8c" class="nc ld jh mi b gz nx nu l nv nw">const start = async () =&gt; {<br/>  const imageDetector = await ImageDetector.start()<br/>  const listeners = await Promise.all([<br/>    ImageMetaData.start('MetaData A'),<br/>    ImageMetaData.start('MetaData B'),<br/>    ImageOCR.start('OCR A'),<br/>    ImageOCR.start('OCR B')<br/>  ])<br/>}</span><span id="9407" class="nc ld jh mi b gz nx nu l nv nw">// Go and get some image and generate a message.<br/>// Obviously I'm just faking it here for brevity.<br/>const run = async () =&gt; {<br/>  await start()<br/>  let count = 0</span><span id="201e" class="nc ld jh mi b gz nx nu l nv nw">  setInterval(async () =&gt; {<br/>    const message = JSON.stringify({<br/>      text: `This is message ${count}`,<br/>      meta: `This is meta-data for ${count}`<br/>    })<br/>    await imageDetector.publish(routingKey, message)<br/>    count += 1<br/>  }, FIVE_SECONDS)<br/>}</span><span id="0ce6" class="nc ld jh mi b gz nx nu l nv nw">run()<br/>  .then(() =&gt; {<br/>    console.log('Services running.')<br/>  })<br/>  .catch(err =&gt; {<br/>    console.error(err)<br/>  })</span></pre><p id="3a1e" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><strong class="kg ji"> <em class="no">注意</em> </strong> <em class="no">我已经省略了处理</em> <code class="fe mf mg mh mi b"><em class="no">ctrl-c</em></code> <em class="no">关闭服务这样的细节。查看完整的源代码。</em></p><h2 id="6966" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">设置RabbitMQ</h2><p id="e5c3" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">你需要运行<code class="fe mf mg mh mi b">RabbitMQ</code>。为了不污染基础现实，我喜欢在<code class="fe mf mg mh mi b">Docker</code>容器中运行消息队列、数据库等服务。</p><p id="c725" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这个<code class="fe mf mg mh mi b">docker-compose.yml</code>文件将完成这项工作:</p><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="9e8c" class="nc ld jh mi b gz nt nu l nv nw">version: "3"<br/>volumes:<br/>  rabbit-data:<br/>    driver: local</span><span id="27ac" class="nc ld jh mi b gz nx nu l nv nw">services:<br/>  amqp:<br/>    image: rabbitmq<br/>    ports:<br/>      - 15672:15672<br/>      - 5672:5672<br/>    volumes:<br/>      - rabbit-data:/var/lib/rabbitmq<br/>    healthcheck:<br/>      test: "exit 0"</span></pre><p id="d50d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">现在，在您的终端中，运行:</p><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="afdc" class="nc ld jh mi b gz nt nu l nv nw">docker-compose up -d<br/>npm start</span></pre><p id="72df" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">瞧:</p><pre class="my mz na nb gu np mi nq nr aw ns bi"><span id="2870" class="nc ld jh mi b gz nt nu l nv nw">&gt; Services running. <br/>&gt; OCR OCR B This is message 0<br/>&gt; Meta Data MetaData A This is meta-data for 0<br/>&gt; Meta Data MetaData B This is meta-data for 1<br/>&gt; OCR OCR A This is message 1<br/>&gt; OCR OCR B This is message 2<br/>&gt; Meta Data MetaData A This is meta-data for 2<br/>&gt; Meta Data MetaData B This is meta-data for 3<br/>&gt; OCR OCR A This is message 3<br/>... etc</span></pre><p id="e03a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated"><code class="fe mf mg mh mi b">ImageDetector</code>每5秒发出一条新消息，每个<code class="fe mf mg mh mi b">OCR</code>和<code class="fe mf mg mh mi b">MetaData</code>服务竞相完成各自的工作。</p><h1 id="660f" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="4d69" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ik bi translated">把微服务连在一起很琐碎。您需要做出的真正的设计决策不是<a class="ae je" href="https://www.rabbitmq.com/tutorials/tutorial-four-javascript.html" rel="noopener ugc nofollow" target="_blank">如何使用</a> <code class="fe mf mg mh mi b"><a class="ae je" href="https://www.rabbitmq.com/tutorials/tutorial-four-javascript.html" rel="noopener ugc nofollow" target="_blank">topic</a></code> <a class="ae je" href="https://www.rabbitmq.com/tutorials/tutorial-four-javascript.html" rel="noopener ugc nofollow" target="_blank">交换</a>等等，而是简单地应该如何构造您的路由键。</p><p id="1002" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">路由键是微服务网络的<em class="no">语法</em>，将是另一篇文章的主题。</p><h2 id="1863" class="nc ld jh bd le nd ne dn li nf ng dp lm kp nh ni lq kt nj nk lu kx nl nm ly nn bi translated">链接</h2><ul class=""><li id="d260" class="mj mk jh kg b kh ma kl mb kp ny kt nz kx oa lb ob mp mq mr bi translated"><a class="ae je" href="https://github.com/davesag/amqp-simple-pub-sub" rel="noopener ugc nofollow" target="_blank"> AQMP简单发布/订阅</a> : <em class="no">我写这篇文章是为了简化AMQP微服务网络的制作。</em></li><li id="725d" class="mj mk jh kg b kh ms kl mt kp mu kt mv kx mw lb ob mp mq mr bi translated"><a class="ae je" href="https://github.com/davesag/competing-services-example" rel="noopener ugc nofollow" target="_blank">竞争服务示例</a> : <em class="no">它有效，并且具有100%的测试覆盖率。耶。</em></li><li id="cece" class="mj mk jh kg b kh ms kl mt kp mu kt mv kx mw lb ob mp mq mr bi translated"><a class="ae je" href="https://www.rabbitmq.com" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a> : <em class="no">太牛了。</em></li></ul><p id="b382" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi">—</p><p id="af35" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">你也可以使用Kafka，这也是StackOverflow中的许多答案所推荐的，但是Kafka实际上是为了解决一个不同的问题，即构建分布式流媒体系统。如果您正在构建下一个网飞，这没问题，但是如果您正在构建一个相当简单的微服务网络，这就有点过了。</p><p id="7114" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi">—</p><p id="f5f2" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">像这样但不是订户？你可以通过davesag.medium.com加入<a class="ae je" href="https://davesag.medium.com/membership" rel="noopener">来支持作者。</a></p></div></div>    
</body>
</html>