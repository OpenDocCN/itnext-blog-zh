<html>
<head>
<title>In-Depth Look at TypeScript Generics: Part 2 — Advanced Inference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解TypeScript泛型:第2部分—高级推理</h1>
<blockquote>原文：<a href="https://itnext.io/in-depth-look-at-typescript-generics-part-2-advanced-inference-5c75638ee6bf?source=collection_archive---------4-----------------------#2022-02-21">https://itnext.io/in-depth-look-at-typescript-generics-part-2-advanced-inference-5c75638ee6bf?source=collection_archive---------4-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2520635ca31855a8b6058e5cc4480737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgXKXcWt9rMDhsSA8kO9iw.png"/></div></div></figure><p id="6e4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欢迎来到我们关于类型脚本泛型系列的第二篇文章！在这篇文章中，我们将仔细看看TypeScript推理。我们将讨论高级推理、映射和条件类型等主题。</p><p id="49fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你还没有，你应该阅读关于<a class="ae kz" href="https://isamatov.com/typescript-generics-in-depth-basics/" rel="noopener ugc nofollow" target="_blank">泛型基础</a>的系列文章的第一部分，以便更好地理解。</p><h1 id="ea11" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">打字稿中的高级推理</h1><p id="4016" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">通过结合泛型和类型推断，我们可以创建基于彼此之上的高级类型。通过以这种方式创建新类型，您可以为您的项目创建一个易于维护的健壮的类型系统，因为所有子类型都将自动采用其父类型中的更改。</p><p id="be86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开始时，您可能会发现高级类型推理的语法有点棘手，但是稍加练习，您应该能够掌握它。</p><p id="cacb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从映射类型开始。</p><h1 id="ca07" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">映射类型</h1><p id="f758" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">映射类型派生自其他类型。当我们将映射类型与泛型相结合时，我们可以形成强大而灵活的类型定义。</p><p id="0ba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe md me mf mg b">keyof</code>创建新类型就是一个例子。在第一篇的<a class="ae kz" href="https://isamatov.com/typescript-generics-in-depth-basics/" rel="noopener ugc nofollow" target="_blank">中，我们简单的提到了<code class="fe md me mf mg b">keyof</code>。现在让我们更深入地探讨一下。</a></p><p id="d605" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">keyof</code>是一个TypeScript操作符，它允许你根据他人的属性派生出新的类型。它接受一个输入类型，并返回一个新类型，该类型具有原始类型的所有属性。</p><p id="ef50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个例子:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="931b" class="mp lb it mg b gy mq mr l ms mt">type KeysOfObject&lt;T&gt; = keyof T;</span><span id="9fe8" class="mp lb it mg b gy mu mr l ms mt">type User = {<br/>  id: number;<br/>  name: string;<br/>  address: string;<br/>}</span><span id="710d" class="mp lb it mg b gy mu mr l ms mt">type UserKeys = KeysOfObject&lt;User&gt;</span><span id="cbe6" class="mp lb it mg b gy mu mr l ms mt">const accessUser = (user: User, key:UserKeys) =&gt; {<br/>  return user[key]<br/>}</span><span id="38ac" class="mp lb it mg b gy mu mr l ms mt">const user = {<br/>  id: 1,<br/>  name: "John Doe",<br/>  address: "private"<br/>}</span><span id="e4c2" class="mp lb it mg b gy mu mr l ms mt">accessUser(user, "address");<br/>accessUser(user, "SSN") // ERROR: Argument of type '"SSN"' is not assignable to parameter of type 'keyof User'.</span></pre><p id="5bde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在通用类型<code class="fe md me mf mg b">KeysOfObject</code>中使用<code class="fe md me mf mg b">keyof</code>，我们可以用它来创建其他映射类型。我们使用<code class="fe md me mf mg b">KeysOfObject</code>来基于<code class="fe md me mf mg b">User</code>的属性创建一个新的<code class="fe md me mf mg b">UserKeys</code>类型。</p><p id="5c85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在第<code class="fe md me mf mg b">accessUser(user, "SSN")</code>行得到一个错误。原因是我们使用了类型<code class="fe md me mf mg b">UserKeys</code>来确保我们的函数只接受现有的用户字段。</p><p id="116b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建映射类型是这样一个基本特性，TypeScript在语言中添加了实用工具类型。这些实用程序类型，如Partial、Readonly、Pick等，使得创建自定义映射类型变得更加容易。</p><p id="4699" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些实用程序类型使用泛型来处理它们作为输入接收的类型。让我们更详细地介绍这三种实用程序类型。</p><h2 id="8e36" class="mp lb it bd lc mv mw dn lg mx my dp lk km mz na lo kq nb nc ls ku nd ne lw nf bi translated">部分的</h2><p id="cb02" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Partial用于创建所有字段都设置为可选的新类型。这对于处理不完整的对象实例非常有用，因为您事先不知道哪些字段可能会丢失:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b976" class="mp lb it mg b gy mq mr l ms mt">type User = {<br/>  id: number;<br/>  name: string;<br/>  address: string;<br/>}</span><span id="2dc8" class="mp lb it mg b gy mu mr l ms mt">function updateUserObj(id: number, body: Partial&lt;User&gt;) {<br/>  return makeUpdateAPIRequest(); // Updates the user using partial user object as a body;<br/>}</span></pre><p id="de30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们将我们的<code class="fe md me mf mg b">body</code>参数设置为类型<code class="fe md me mf mg b">Partial&lt;User&gt;</code>，我们不需要向这个函数提供整个用户对象，只需要提供我们试图更新的字段。</p><h2 id="dfc8" class="mp lb it bd lc mv mw dn lg mx my dp lk km mz na lo kq nb nc ls ku nd ne lw nf bi translated">只读</h2><p id="164c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><code class="fe md me mf mg b">Readonly</code>实用程序类型用于创建一个新类型，所有字段都设置为只读。TypeScript不允许您在初始化后更改此类对象的任何字段值:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="fc10" class="mp lb it mg b gy mq mr l ms mt">type User = {<br/>  id: number;<br/>  name: string;<br/>  address: string;<br/>}</span><span id="74c2" class="mp lb it mg b gy mu mr l ms mt">const readonlyUser: Readonly&lt;User&gt; = { id: 0, name:"John Doe", address: "private" };<br/>readonlyUser.address = "public"; //ERROR: Cannot assign to 'address' because it is a read-only property.</span></pre><p id="cba9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们创建了一个新的类型<code class="fe md me mf mg b">Readonly&lt;User&gt;</code>，除了只读权限之外，它的字段与用户类型相同。当我们创建一个<code class="fe md me mf mg b">readonlyUser</code>的新实例并试图修改它时，TypeScript抛出一个错误。</p><h2 id="1926" class="mp lb it bd lc mv mw dn lg mx my dp lk km mz na lo kq nb nc ls ku nd ne lw nf bi translated">挑选</h2><p id="ada3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><code class="fe md me mf mg b">Pick</code>实用程序用于通过指示您想要复制的字段来创建新类型。要选择字段，需要将它们作为联合类型传递:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="9020" class="mp lb it mg b gy mq mr l ms mt">type PickedUser = Pick&lt;User, "id" | "name"&gt;</span><span id="e088" class="mp lb it mg b gy mu mr l ms mt">const pickedUser: PickedUser = {<br/>  id: 1,<br/>  name: "John Doe"<br/>}</span></pre><p id="cd23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参见我在<a class="ae kz" href="https://isamatov.com/typescript-utility-types-for-react/" rel="noopener ugc nofollow" target="_blank">上发表的另一篇关于React最有用的实用工具类型的文章</a>，了解更多关于实用工具类型以及它们如何帮助你。</p><h1 id="1457" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">条件类型</h1><p id="8c18" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在让我们来看看条件类型。我们知道JavaScript中的条件表达式:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="897f" class="mp lb it mg b gy mq mr l ms mt">const myLabel = isEven ? "even" : "odd";</span></pre><p id="75bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实证明，我们可以使用相同的语法来定义类型。TypeScript的条件类型允许我们根据收到的输入类型的值返回不同的类型:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="dc23" class="mp lb it mg b gy mq mr l ms mt">type Cat = { catName: string }<br/>type Dog = { dogName: string }</span><span id="d6fc" class="mp lb it mg b gy mu mr l ms mt">type BarkOrMeow&lt;T&gt; = T extends Dog ? { barkSound: "Bark!" } : { meowSound: "Meow!" };</span><span id="b833" class="mp lb it mg b gy mu mr l ms mt">type CatSound = BarkOrMeow&lt;Cat&gt;;</span></pre><p id="230a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码定义了一个条件类型<code class="fe md me mf mg b">BarkOrMeow&lt;T&gt;</code>，它根据输入<code class="fe md me mf mg b">T</code>返回一个带有<code class="fe md me mf mg b">barkSound</code>或<code class="fe md me mf mg b">meowSound</code>的类型。然后我们通过将<code class="fe md me mf mg b">Cat</code>类型传递给<code class="fe md me mf mg b">BarkOrMeow</code>来创建一个<code class="fe md me mf mg b">CatSound</code>类型。</p><p id="7e58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使通过这个简单的例子，您也可以看到TypeScript条件类型是多么有用。</p><h1 id="224e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">分布式条件类型</h1><p id="ef29" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在定义条件类型时，我们可以返回几个分布式类型，而不是返回一个类型作为条件语句的一部分。</p><p id="101f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">分布式类型允许您为代码增加另一个级别的灵活性，并处理更复杂的边缘情况:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="a023" class="mp lb it mg b gy mq mr l ms mt">type dateOrNumberOrString&lt;T&gt; = T extends Date ? Date : T extends number ? Date | number : never</span><span id="cf21" class="mp lb it mg b gy mu mr l ms mt">function compareValues&lt;T extends Date | number&gt; (value1: T, value2: dateOrNumberOrString&lt;T&gt;) {<br/>  // do the comparison<br/>}</span></pre><p id="4e05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们使用分布式条件类型<code class="fe md me mf mg b">dateOrNumberOrString</code>来强制我们的<code class="fe md me mf mg b">compareValues</code>函数的第二个参数的类型。如果<code class="fe md me mf mg b">value1</code>是一个<code class="fe md me mf mg b">Date</code>，我们希望<code class="fe md me mf mg b">value2</code>也是一个<code class="fe md me mf mg b">Date</code>。如果<code class="fe md me mf mg b">value1</code>是一个数字，我们希望<code class="fe md me mf mg b">value2</code>要么是日期，要么是数字。</p><h1 id="0a05" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">条件类型推理</h1><p id="8185" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">条件类型的一个更复杂的情况是推断新类型作为条件语句的一部分。我们可以使用<code class="fe md me mf mg b">infer</code>关键字根据接收到的输入的某种属性或签名来推断新的类型。</p><p id="d082" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果没有具体的例子，这听起来可能有点太抽象了，所以让我们来看一个例子:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="c689" class="mp lb it mg b gy mq mr l ms mt">type inferFromFieldType&lt;T&gt; = T extends { id: infer U } ? U : never;</span></pre><p id="d72a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们从类型<code class="fe md me mf mg b">T</code>的<code class="fe md me mf mg b">id</code>字段中推断出类型<code class="fe md me mf mg b">U</code>。如果<code class="fe md me mf mg b">T</code>有<code class="fe md me mf mg b">id</code>属性，那么TypeScript推断该属性的类型为<code class="fe md me mf mg b">U</code>。然后，您可以在同一个条件类型语句中使用<code class="fe md me mf mg b">U</code>。</p><p id="8b6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">条件类型推理允许创建健壮的类型检查逻辑，可以处理深度嵌套的对象。</p><h1 id="c3bb" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">从函数签名进行类型推断</h1><p id="07aa" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">与我们从对象字段推断类型的方式相同，我们也可以从函数签名推断类型。</p><p id="e72f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以从函数参数以及函数返回类型中推断类型:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="eb49" class="mp lb it mg b gy mq mr l ms mt">type inferFromFunctionParam&lt;T&gt; = T extends (a: infer F) =&gt; void ? F : never;<br/>type inferFromFunctionReturnType&lt;T&gt; = T extends () =&gt; infer F ? F : never;</span></pre><p id="9c6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有两个泛型类型，它们从输入函数类型推断类型。第一个使用函数参数，另一个使用函数的返回类型。</p><p id="db43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看如何使用其中一种类型:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="2ce0" class="mp lb it mg b gy mq mr l ms mt">function executeFunction&lt;T extends (param: any) =&gt; void&gt; (fn: T, arg: inferFromFunctionParam&lt;T&gt;) {<br/>  fn(arg);<br/>}</span><span id="f42f" class="mp lb it mg b gy mu mr l ms mt">function sampleFunction(param: string) {<br/>  // Do something here!<br/>}<br/>executeFunction(sampleFunction, "Hello world");</span></pre><p id="0005" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有<code class="fe md me mf mg b">executeFunction</code>函数，它使用了我们之前在第二个参数<code class="fe md me mf mg b">arg</code>上创建的<code class="fe md me mf mg b">inferFromFunctionParam</code>泛型类型。</p><p id="de52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe md me mf mg b">executeFunction</code>的第一个参数是一个带一个参数的函数，<code class="fe md me mf mg b">param</code>。TypeScript将从<code class="fe md me mf mg b">param</code>的类型中推断第二个参数<code class="fe md me mf mg b">arg</code>的类型。</p><p id="6b83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，如果<code class="fe md me mf mg b">fn</code>应该接收一个字符串，TypeScript确保我们只能传递一个字符串作为<code class="fe md me mf mg b">executefunction</code>的第二个<code class="fe md me mf mg b">arg</code>参数的值。</p><p id="dff6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们试图用一个数字调用<code class="fe md me mf mg b">executeFunction</code>，TypeScript会抛出一个错误:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="9c8a" class="mp lb it mg b gy mq mr l ms mt">executeFunction(sampleFunction, 1); //ERROR: Argument of type 'number' is not assignable to parameter of type 'string'</span></pre><p id="30dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于您收到的函数参数的函数签名来强制类型的能力允许一个完全不同级别的类型安全。</p><h1 id="5ea7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="35ff" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这篇文章中，我们介绍了高级类型推理，并将其与泛型相结合，在其他类型的基础上构建灵活的类型。凭借对泛型和类型推断的深刻理解，我们可以确保流经我们应用程序的所有数据都具有很强的类型安全性。</p><p id="86c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就结束了我们对TypeScript泛型的深入研究。同样，如果你还没有阅读第一部分，我鼓励你这样做，因为它为理解TypeScript泛型奠定了<a class="ae kz" href="https://isamatov.com/typescript-generics-in-depth-basics/" rel="noopener ugc nofollow" target="_blank">基础。</a></p><p id="f2c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想获得更多的网络开发、反馈和打字技巧，可以考虑<a class="ae kz" href="https://twitter.com/IskanderSamatov" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我，</a>在那里我分享我学到的东西。<br/>打字快乐！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="2af5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nn">原载于2022年2月21日</em><a class="ae kz" href="https://isamatov.com/typescript-generics-in-depth-advanced-type-inference/" rel="noopener ugc nofollow" target="_blank"><em class="nn"/></a><em class="nn">。</em></p></div></div>    
</body>
</html>