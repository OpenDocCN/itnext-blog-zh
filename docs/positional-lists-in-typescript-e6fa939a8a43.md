# TypeScript 中的位置列表

> 原文：<https://itnext.io/positional-lists-in-typescript-e6fa939a8a43?source=collection_archive---------3----------------------->

## 处理列表而不处理索引

![](img/dd3e4958f59e4f4a97003a72997041cc.png)

布兰登·莫温克尔在 Unsplash 上的照片

列表是按顺序保存一系列项目的数据结构。因此，我们可以使用索引并修改它们，以获得相对于某个索引有偏移量的项目。这很好，但是它会导致代码修改大量的整数来获取和设置列表中某个位置的项目。在本文中，我们着眼于位置列表，这种列表抽象了索引的概念，并允许我们仅用前面的和后面的*项的概念进行推理。*

位置列表是在`Position`容器中存储项目的列表。基于这个容器，您可以从列表中检索上一个和下一个项目，而无需处理索引(但是索引仍然是获取位置的一个选项)。这有助于创建更优雅的代码，因为我们将“*下一项位于索引+ 1* ”的概念抽象到数据结构中。所以不再有像`currentIndex`和`indexLastProcessedItem`这样的变量。它还允许我们更容易地使用循环数据结构，因为外部世界不再对索引进行假设。

`Position`集装箱

一个`PositionalList`的部分界面

# 位置列表

位置列表很像普通列表，但是有一些事情需要考虑:

*   列表中的每个值都返回到一个`Position`容器中
*   列表具有基于另一个`Position`返回一个`Position`的`before`和`after`方法
*   移除通过`Position`进行，而不是通过步进
*   支持数据结构可以是任何东西，每种类型的列表都是可能的，但是数组、循环缓冲区和索引树也是可能的

基于这些信息，我们可以为位置列表必须实现的方法定义一个接口，以便实际上作为位置列表工作。当然，添加更多的方法使位置列表更加强大和灵活是可能的(并且非常常见)。

位置列表的轮廓

注意，在`elementAt`、`first`和`last`方法的帮助下，我们仍然可以将我们的位置列表用作常规列表，通过索引获得一个`Position`，并与其他方法一起使用。

# 用双向链表实现

实现位置链表最简单也是最常见的方法是使用双向链表。这是因为在双向链表中，很容易得到一个节点的前一个和下一个节点。它也已经实现了我们上面列出的每一个特性，所以它只需要很小的改变就可以适应`PositionalList`接口。下面是一个可能的实现:

基于双向链表的位置表实现

这里的主要“技巧”是让`Node`接口扩展`Position`接口，并在将节点传入和传出列表时进行向上和向下转换。外面的世界只知道位置，我们在列表里面知道有上一个和下一个项目的节点。

看到这个实现，人们可能想知道为什么`before`和`after`方法在列表中而不在位置上。如果我们能做`myPosition.before().before()`而不是每次都要参考列表，肯定会更方便吧？答案有两部分:

首先是抽象和责任。上一个和下一个节点是位置的一部分，这是我们知道的，但是外部系统不应该知道。他们唯一知道的是，在收藏中有类似上一件和下一件的东西，这些东西存放在哪里以及如何存放与他们无关。集合管理项，而项只是项。

答案的一半是你不必使用一个双向链表作为你的位置链表的支持数据结构。对于我们的实现来说，单个链表也是一个有效的选择，这样你的节点上就没有以前的属性了。然后我们还在考虑一个安全的选择关闭双向链表。让我们看看另一个使用数组存储实际项目的实现:

# 其他实现

位置列表也可以用数组实现。为此，我们将数组保存在我们的`PostionalList`中，所有的方法都修改并查询这个数组。这里我们看到了为什么最好将`before`和`after`保留在列表中，因为它们可以很容易地访问`data`变量。在这个实现中，我们仍然有一个`Node`接口，但是现在它将索引存储为附加的隐藏数据，而不是存储上一个和下一个节点。完整的实现可以在[这里](https://gist.github.com/WimJongeneel/42386fc8e2544a79c4fc3adf6a7fc1e5)找到。

基于数组的位置列表实现的一部分

这里我们看到，在动态调整数组大小的语言中(如 JavaScript ),位置链表实际上用数组实现比用更传统的双向链表实现更短。例如，在 Java 或 C#中，你必须使用自动调整大小的`ArrayList`来获得相同的结果。

# 函数式编程和位置列表

到目前为止，我向您展示的定义和实现都是非常基本和传统的 OOP，以尽可能保持简单。但是在现实世界中，几乎每个人都在他们的代码库中加入了一些函数式编程，尤其是在修改集合的时候。对于位置列表来说，实现函数`filter`和`map`是完全可能的，但是有一些问题。让我们从扩展我们的`PositionalList`接口开始，为一些功能性的好东西添加定义:

用于函数式编程的位置列表的接口

如你所见，我们没有为`map`、`filter`和`bind`函数中的项目使用位置。这是因为我们不应该关心这些函数中的位置。我们传递给`map`的函数应该只是将一个`T`转换成一个`U`，除了那个`T`的值之外，不考虑任何其他东西。

`map`对于位置列表，`filter`和`bind`将遵循类似的模式

现在我们开始引入创建新位置列表的方法，我们应该真正开始考虑一个问题:如果我们将一个位置传递给不属于那个列表的`before`或`after`会怎么样？在我们之前的实现中，它要么工作，要么产生无意义，要么返回 null。在我们认为一个位置有效之前，我们可以通过在位置上放置一个对列表的引用并检查该引用是否等于`this`来添加一个检查。

位置列表中`isValid`检查的部分实现

# 结论

在本文中，我们深入探讨了一种很少使用的列表变体，位置列表。这感觉有点遗憾，因为位置列表实际上非常酷和强大。让我知道你对他们的看法！

想阅读更多关于使用 TypeScript 进行函数式编程的内容吗？我正在用 TypeScript 写一个关于扩展函子家族的系列，你可以在这里阅读前两部分:

[](https://medium.com/hoppinger/contravariant-functors-in-typescript-ff8b8c4c4bf4) [## TypeScript 中的逆变函子

### 探索扩展函子族第一部分

medium.com](https://medium.com/hoppinger/contravariant-functors-in-typescript-ff8b8c4c4bf4) [](https://medium.com/hoppinger/bifunctors-in-typescript-e063fe880520) [## 打字稿中的双功能符号

### 探索扩展函子族第二部分

medium.com](https://medium.com/hoppinger/bifunctors-in-typescript-e063fe880520)