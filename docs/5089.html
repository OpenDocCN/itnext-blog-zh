<html>
<head>
<title>Testing Asynchronicity in Swift &amp; Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift &amp; Kotlin中测试异步性</h1>
<blockquote>原文：<a href="https://itnext.io/testing-asynchronicity-in-swift-kotlin-4926936eae28?source=collection_archive---------6-----------------------#2020-12-07">https://itnext.io/testing-asynchronicity-in-swift-kotlin-4926936eae28?source=collection_archive---------6-----------------------#2020-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9cdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比较Combine、ReactiveSwift和RxJava进行测试</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/806a1c1fe0a46717a734bab640f0170a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-njVHHewsxhgq54sdDHjA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">多线程很美但是很棘手！</figcaption></figure><p id="7ba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个系列中，我们介绍了一个<a class="ae lb" href="https://medium.com/perry-street-software-engineering/kotlin-in-xcode-swift-in-android-studio-26a4ace6fc72" rel="noopener">干净的MVVM架构</a>，用于在Swift和Kotlin中编写一致的代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lc"><img src="../Images/3b2212386ee21964b4266e6027e5c41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHJTRaLd_hqJO-KA2NMTSQ.png"/></div></div></figure><p id="9a39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们干净的MVVM架构的核心是<a class="ae lb" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">反应流</a>，它隐含地将异步引入到我们的应用中。测试反应式流并不简单——当编写使用反应式流的测试时，我们必须找到一种等待或阻塞的方法，直到我们的流完成或数据发出。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/70e98f685c4fbcea1e8351bbf53ec855.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/1*8ToDvAFngUnTXZgklksGqA.gif"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">反应式编程</figcaption></figure><h1 id="2faa" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将执行转移到主线程</h1><p id="c442" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">在Android上，我们可以覆盖调用反应流的线程，这样通常异步调用就变成了同步调用。我们用一个<code class="fe mh mi mj mk b">ExtendWith</code>块中的两个<code class="fe mh mi mj mk b">beforeEach</code>方法来实现这一点。</p><pre class="km kn ko kp gt ml mk mm mn aw mo bi"><span id="cf66" class="mp lf iq mk b gy mq mr l ms mt">@ExtendWith(InstantExecutorExtension::class,         <br/>            RxTestSchedulersExtension::class</span></pre><p id="9936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">InstantExecutorExtension</code>适用于<a class="ae lb" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>，改编自<a class="ae lb" href="https://perrystreet.atlassian.net/wiki/spaces/SWPRJ/pages/33604" rel="noopener ugc nofollow" target="_blank">这篇博客</a>的帖子。<code class="fe mh mi mj mk b">RxTestSchedulersExtension</code>适用于<a class="ae lb" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>中的线程执行。这两种实现都可以在下面找到:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="4f7a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用TestObserver评估流</h1><p id="9f73" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">反应流需要测试，为此，<a class="ae lb" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>、<a class="ae lb" href="https://github.com/ReactiveCocoa/ReactiveSwift" rel="noopener ugc nofollow" target="_blank"> ReactiveSwift </a>和<a class="ae lb" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>有一个TestObserver的概念。TestObserver是一个给定了流的类，比如一个<a class="ae lb" href="https://developer.apple.com/documentation/combine/publisher" rel="noopener ugc nofollow" target="_blank"> Publisher </a> (Combine)、<a class="ae lb" href="https://reactivecocoa.io/reactiveswift/docs/latest/SignalProducer.html#/s:13ReactiveSwift14SignalProducerV" rel="noopener ugc nofollow" target="_blank">signal producer</a>(ReactiveSwift)或<a class="ae lb" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html" rel="noopener ugc nofollow" target="_blank"> Observable </a> (RxJava)，它为这些流保存了发出值的历史记录。您也可以使用TestObserver来等待一个给定的事件被发出，然后测试才能继续。</p><p id="f9c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们通常将TestObserver对象声明为每个内部类/上下文中的共享对象，我们在<code class="fe mh mi mj mk b">beforeEach</code>块中分配它们，然后在每个then测试中询问它们。</p><h2 id="0580" class="mp lf iq bd lg mw mx dn lk my mz dp lo jy na nb ls kc nc nd lw kg ne nf ma ng bi translated">结合</h2><p id="72f4" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">要在Combine中评估流，请使用<a class="ae lb" href="https://github.com/groue/CombineExpectations" rel="noopener ugc nofollow" target="_blank"> CombineExpectations </a>包。这个包定义了一个<code class="fe mh mi mj mk b">Recorder</code>对象，在功能上相当于Android上的一个TestObserver。</p><pre class="km kn ko kp gt ml mk mm mn aw mo bi"><span id="d6f9" class="mp lf iq mk b gy mq mr l ms mt">let eventsRecorder = context.viewModel.events.record()<br/>context.viewModel.onEditProfileClick()<br/>let event = try eventsRecorder.next().get()<br/>XCTAssertEqual(event, PSSAccountViewModel.Event.triggerProfileOfflineAlert)</span></pre><h2 id="4c5e" class="mp lf iq bd lg mw mx dn lk my mz dp lo jy na nb ls kc nc nd lw kg ne nf ma ng bi translated">反应Swift</h2><p id="1bab" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">ReactiveSwift本身没有TestObserver，但是Kickstarter已经在他们的知识库中定义了这样一个类。下面是一个观察到发出<code class="fe mh mi mj mk b">.flagProfile</code>事件的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="ca0d" class="mp lf iq bd lg mw mx dn lk my mz dp lo jy na nb ls kc nc nd lw kg ne nf ma ng bi translated">RxJava</h2><p id="869e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">为了评估RxJava中的流，我们使用了被定义为<code class="fe mh mi mj mk b">io.reactivex.observers</code> <strong class="jp ir"> </strong>包的一部分的<code class="fe mh mi mj mk b">TestObserver</code>类。这是一个观察到发出了一个<code class="fe mh mi mj mk b">FlagProfile</code>事件的例子。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="6bb8" class="mp lf iq bd lg mw mx dn lk my mz dp lo jy na nb ls kc nc nd lw kg ne nf ma ng bi translated">LiveData</h2><p id="1f43" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们对LiveData的使用通常是作为视图层的<a class="ae lb" href="http://reactivex.io/RxJava/javadoc/io/reactivex/subjects/BehaviorSubject.html" rel="noopener ugc nofollow" target="_blank">行为主体</a>的替代。因此，如果我们已经应用了上述的InstantExecutor扩展，我们通常可以在测试中直接从主线程中访问<code class="fe mh mi mj mk b">.value</code>属性，而不需要任何特殊的处理或观察者。</p><h1 id="1e64" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">本系列的更多内容</h1><ul class=""><li id="b41e" class="nh ni iq jp b jq mc ju md jy nj kc nk kg nl kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/p/26a4ace6fc72" rel="noopener">在斯威夫特清洗MVVM&amp;科特林</a></li><li id="2991" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/p/721bbc6f8c07" rel="noopener">Swift中的视图模型&amp; Kotlin </a></li><li id="08d8" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/logic-classes-in-swift-kotlin-f7ac1f295839#4bdb-3e583789601">Swift中的逻辑类&amp; Kotlin </a></li><li id="b847" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/perry-street-software-engineering/repositories-and-models-in-swift-kotlin-df9ae2c84cb7" rel="noopener">Swift中的存储库和域模型&amp; Kotlin </a></li><li id="0040" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/perry-street-software-engineering/api-classes-in-swift-kotlin-a2cb90d3906d" rel="noopener">Swift中的API类&amp; Kotlin </a></li><li id="ba65" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/p/f5416dec42ea" rel="noopener">Swift中的视图&amp; Kotlin </a></li><li id="df54" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/better-programming/testing-mvvm-in-swift-and-kotlin-ccb55e462760" rel="noopener">在Swift中测试MVVM&amp;科特林</a></li><li id="e8aa" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated">在Swift &amp; Kotlin中测试异步性← <em class="nv">你在这里</em></li><li id="84d2" class="nh ni iq jp b jq nq ju nr jy ns kc nt kg nu kk nm nn no np bi translated"><a class="ae lb" href="https://medium.com/perry-street-software-engineering/summary-clean-mvvm-in-swift-kotlin-7057230600aa" rel="noopener">清洁MVVM总结</a></li></ul><h1 id="f6e9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">你可能喜欢的其他系列</h1><p id="ed5f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/a-visual-history-of-web-api-architecture-c36044df2ac7"> <strong class="jp ir">清理API架构(2021) </strong> </a> <strong class="jp ir"> <br/> </strong>构建现代API端点时的类、执行模式、抽象。</p><p id="dbfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://proandroiddev.com/android-activity-lifecycle-considered-harmful-98a5b00d287" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Android活动生命周期被认为有害</strong></a><strong class="jp ir">【2021】<br/></strong>Android进程死亡，不可解释的NullPointerExceptions，以及你现在需要的MVVM生命周期</p><h1 id="0280" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">关于作者</h1><p id="58a4" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><em class="nv">埃里克·西尔弗伯格(Eric Silverberg)是</em> <a class="ae lb" href="https://www.perrystreet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nv">佩里街软件</em> </a> <em class="nv">的CEO和创始人，是iOS和Android上两个全球最大的LGBTQ+交友应用的发行商。</em></p></div></div>    
</body>
</html>