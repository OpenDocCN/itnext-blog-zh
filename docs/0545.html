<html>
<head>
<title>Ajax fetch simplified with React &amp; RxJS &amp; reenhance-components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React &amp; RxJS &amp; re enhance-components简化了Ajax获取</h1>
<blockquote>原文：<a href="https://itnext.io/simple-ajax-fetch-with-react-rxjs-hocs-bb174bc45d9e?source=collection_archive---------0-----------------------#2018-03-29">https://itnext.io/simple-ajax-fetch-with-react-rxjs-hocs-bb174bc45d9e?source=collection_archive---------0-----------------------#2018-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2fc9d8614fa8134310ff4e76a9ff186b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lcLBVxdSwS6OXFpHg6r5TQ.png"/></div></div></figure><blockquote class="jy jz ka"><p id="5de4" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fsimple-ajax-fetch-with-react-rxjs-hocs-bb174bc45d9e%3Futm_source%3Dmedium_sharelink%26utm_medium%3Dsocial%26utm_campaign%3Dbuffer" rel="noopener ugc nofollow" target="_blank"> <em class="iq">点击这里在LinkedIn上分享这篇文章</em> </a></p></blockquote><p id="1483" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">TL；RxJS博士用中间件处理Ajax比Redux容易多了。通过使用<code class="fe le lf lg lh b"><a class="ae la" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>中的<code class="fe le lf lg lh b">AsyncResolver</code>，你可以很容易地在普通JSX中采用它。在附加的CodePen示例中，您可以看到通过API获取的iTunes专辑。</p><p id="9a5b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">*更新* 2018/7/19切换到ES6。介绍<code class="fe le lf lg lh b">reenhance-components</code></p><h1 id="e411" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">关于Ajax和React的简短介绍</h1><p id="89dc" class="pw-post-body-paragraph kb kc iq ke b kf mg kh ki kj mh kl km lb mi kp kq lc mj kt ku ld mk kx ky kz ij bi translated">React项目中试过Ajax吗？你可能已经尝试过在官方常见问题解答中使用<code class="fe le lf lg lh b">then/catch</code>子句中的<code class="fe le lf lg lh b">setState</code>或Redux中间件<a class="ae la" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>和<a class="ae la" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>中的<a class="ae la" href="https://reactjs.org/docs/faq-ajax.html" rel="noopener ugc nofollow" target="_blank">示例。无论哪种方式，国家管理都需要大量的工作。但是等等。原始问题有一个替代解决方案。是RxJS。</a></p><h1 id="7293" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">RxJS是什么？</strong></h1><p id="33d0" class="pw-post-body-paragraph kb kc iq ke b kf mg kh ki kj mh kl km lb mi kp kq lc mj kt ku ld mk kx ky kz ij bi translated">从<a class="ae la" href="http://reactivex.io/rxjs/" rel="noopener ugc nofollow" target="_blank">正式文件</a>，</p><blockquote class="jy jz ka"><p id="515b" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RxJS是一个使用Observables进行反应式编程的库，使得编写异步或基于回调的代码更加容易。</p></blockquote><p id="4571" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">实际上，像定时器、事件和承诺这样的异步流可以更容易地处理。</p><p id="3d16" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是一个用RxJS获取API的小例子。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8608" class="mt lj iq lh b gy mu mv l mw mx">const fetch$ = Observable<br/>  .from(fetch(url))<br/>  .flatMap(response =&gt; response.json());</span></pre><p id="83dc" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">和常规的<code class="fe le lf lg lh b">Promise</code>的<code class="fe le lf lg lh b">resolve/reject/then/catch</code>差不了那么远，但是我承认还是和常规的Javascript编程有区别。</p><h1 id="107b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">通过重新增强组件获得RxJS的好处</strong></h1><p id="ede1" class="pw-post-body-paragraph kb kc iq ke b kf mg kh ki kj mh kl km lb mi kp kq lc mj kt ku ld mk kx ky kz ij bi translated">虽然我最初的帖子使用了<code class="fe le lf lg lh b"><a class="ae la" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank">recompose</a></code>，但是现在我创建了<code class="fe le lf lg lh b"><a class="ae la" href="https://www.npmjs.com/package/reenhance-components" rel="noopener ugc nofollow" target="_blank">reenhance-components</a></code>，它是一组具有各种功能的组件。在本文中，我将展示一个使用基于RxJS和<code class="fe le lf lg lh b">recompose</code>的<code class="fe le lf lg lh b">AsyncResolve</code>的例子。</p><p id="8179" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">它像这样解析基于承诺的常规异步函数。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f860" class="mt lj iq lh b gy mu mv l mw mx">const asyncFetch =<br/>  ({ query }) =&gt;<br/>    fetch(queryToUrl(query))<br/>      .then(res =&gt; res.json())<br/>      .catch(err =&gt; ({ error: err.toString() }));</span></pre><p id="5be1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">必须首先实例化该组件。你可以为孩子传递一个参数名和初始道具。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9eb6" class="mt lj iq lh b gy mu mv l mw mx">const AlbumsAsyncResolver =<br/>  AsyncResolver('query', { resultCount: 0, results: [] });</span></pre><p id="9c30" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后，用它制作一个简单的功能组件<em class="kd">。</em></p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8fb7" class="mt lj iq lh b gy mu mv l mw mx">const Albums = ({ query }) =&gt; (<br/>  &lt;AlbumsAsyncResolver query={query} subject={asyncFetch}&gt;<br/>    {props =&gt; props.results &amp;&amp; (<br/>      &lt;ul&gt;<br/>        {props.results.map(itemRenderer)}<br/>      &lt;/ul&gt;<br/>    )}<br/>  &lt;/AlbumsAsyncResolver&gt;<br/>);</span></pre><p id="c97d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">仅此而已。<code class="fe le lf lg lh b">AsyncResolver</code>调用主题，解析<code class="fe le lf lg lh b">Promise</code>，并将结果作为其<code class="fe le lf lg lh b">children</code>的<code class="fe le lf lg lh b">props</code>传递。它是声明性的，不需要类或其他任何东西。</p><p id="63c6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">惊讶吗？你可以在下面的代码栏中看到它的工作。每个组件向iTunes发送一个API请求，并显示响应中的专辑信息。</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="bf84" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="f94b" class="pw-post-body-paragraph kb kc iq ke b kf mg kh ki kj mh kl km lb mi kp kq lc mj kt ku ld mk kx ky kz ij bi translated">要在React中执行异步操作，<code class="fe le lf lg lh b">setState</code>或Redux中间件不是唯一的解决方案。RxJS提供了很棒的编程模型，您可以使用<code class="fe le lf lg lh b">reenhance-components</code>中的<code class="fe le lf lg lh b">AsyncResolver</code>轻松采用它！</p></div></div>    
</body>
</html>