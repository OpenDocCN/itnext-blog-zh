<html>
<head>
<title>Kubernetes Ingress on Azure using the Application Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用应用程序网关在Azure上导入Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-ingress-on-azure-using-the-application-gateway-2779b647deb5?source=collection_archive---------0-----------------------#2021-03-17">https://itnext.io/kubernetes-ingress-on-azure-using-the-application-gateway-2779b647deb5?source=collection_archive---------0-----------------------#2021-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5aac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在单个主机上公开多个服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9db4833d6ca2d4f4529b16c4be9caf81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TtU_d-PNzjQ6lO1i"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">拉斯·金勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将一个应用程序部署在由多个微服务组成的Kubernetes集群上，您可能希望公开其中的一些微服务，以便可以通过互联网进行访问。虽然这显然是为了您的web应用程序服务，但是您可能还想公开一些额外的API。</p><p id="1189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes的世界里，任何与你的微服务的连接都是通过使用<em class="lv">服务</em>资源来完成的。使用Kubernetes <em class="lv">服务</em>资源的类型<em class="lv">负载平衡器</em>利用底层云提供商创建特定于云提供商的负载平衡器，用于通过外部IP公开微服务。这种方法的问题是，每个微服务将暴露在一个单独的IP地址下。</p><p id="bd6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让它们暴露在同一个主机下会方便得多，同时有不同的路径到达专用微服务，对吗？</p><p id="3ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文展示了如何使用Azure上的Kubernetes集群和Azure应用程序网关来实现这一点。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3bb4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">介绍</h1><p id="c1d7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">微服务可以使用Kubernetes <em class="lv">服务</em>资源在Kubernetes内部和外部公开。到目前为止，一切顺利。但是如前所述，如果我们想在集群之外公开它们，使用类型为<em class="lv"> LoadBalancer </em>的服务资源，我们最终会为每个微服务提供不同的IP。这不是我们想要的，相反，我们想让它们暴露在一个和主机使用不同的路径。</p><p id="6bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Kubernetes <em class="lv"> Ingress </em>资源派上用场的地方。把入口想象成Kubernetes服务之上的一层。它是访问我们微服务的流量的单一入口，微服务根据指定的规则将流量路由到不同的Kubernetes <em class="lv">服务</em>。</p><p id="9853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes<em class="lv">Ingress</em>resource的概念就像一个抽象概念。为了使用Kubernetes <em class="lv">入口</em>，你必须安装一个特殊的<em class="lv">入口控制器</em>。Kubernetes <em class="lv"> Ingress </em>抽象有很多不同的实现。Nginx和Traefik Ingress是其中两个在Kubernetes和开源社区中非常受欢迎的工具。</p><p id="db76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们还有云提供商，你可以使用负载平衡器和网关等资源作为Kubernetes <em class="lv">入口</em>。在这篇文章中，我们关注的是<em class="lv"> Azure应用网关入口</em> (AGIC)。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b932" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">先决条件</h1><p id="b5be" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">以下是完成整个过程所需的一些先决条件:</p><ul class=""><li id="fddb" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">Azure CLI已安装</li><li id="cc4a" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">获取您拥有全局管理员角色的Azure订阅</li><li id="96cf" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">kubectl已安装</li><li id="0827" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">jq已安装</li></ul><h1 id="61ae" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">准备Azure环境</h1><p id="eca4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在创建应用程序网关和AKS集群之前，我们从准备Azure环境开始。</p><h2 id="e2ec" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">创建新的资源组</h2><p id="c531" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们要做的第一件事是在<strong class="lb iu"> eastus </strong>区域创建一个名为<strong class="lb iu"> k8srg </strong>的新资源组。因此，您首先必须登录您的Azure帐户。以下命令将打开一个带有单点登录站点的浏览器，您可以在其中输入凭据。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="58b3" class="nt me it og b gy ok ol l om on">az login</span></pre><p id="db2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功登录后，CLI将列出您帐户的所有可用订阅。选择您的订阅。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8e73" class="nt me it og b gy ok ol l om on">az account set --subscription &lt;subscription id&gt;</span></pre><p id="5505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以实际上我们的新资源组。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="494d" class="nt me it og b gy ok ol l om on">az group create —-name k8srg --location eastus</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="8a14" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">添加AKS预览扩展</h2><p id="f11a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当我使用Azure应用网关测试Kubernetes <em class="lv"> Ingress </em>时，这个功能还在预览版。为了在Azure CLI中使用AKS的预览功能，我们必须添加相应的扩展。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="bde2" class="nt me it og b gy ok ol l om on">az extension add --name aks-preview</span></pre><p id="02e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过调用以下命令来检查是否成功添加了扩展。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="25a1" class="nt me it og b gy ok ol l om on">az extension list</span></pre><p id="2d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个命令还显示了扩展的版本。如果有新版本的扩展，您可以使用以下命令更新扩展:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="8db0" class="nt me it og b gy ok ol l om on">az extension update --name aks-preview</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="ce2f" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">注册提供商</h2><p id="0ce3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">接下来，我们必须注册允许Kubernetes <em class="lv">入口</em>连接到应用程序网关的提供者。对于Azure订阅，该提供商只需注册一次。但是首先，我们需要扩展<em class="lv">微软。ContainerService </em>提供者具有将入口连接到应用程序网关的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="86af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供商扩展过程可能需要一些时间。对我来说，大约需要15分钟。无论如何，您可以使用下面的命令检查提供者扩展的状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个命令将显示当前状态，它首先应该等于<em class="lv">注册</em>，如果提供者扩展成功，则等于<em class="lv">注册</em>。</p><p id="96e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要注册<em class="lv">微软。ContainerService </em>提供者(如果它已经注册到您的订阅，它将被刷新)。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="7c1b" class="nt me it og b gy ok ol l om on">az provider register --namespace Microsoft.ContainerService</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="51f1" class="nt me it bd mf nu nv dn mj nw nx dp mn li ny nz mp lm oa ob mr lq oc od mt oe bi translated">创建新的虚拟网络</h2><p id="3bbc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当使用<em class="lv">应用网关Kubernetes Ingress </em>时，每当您想要公开一个微服务时，在应用网关内部会创建一个指向特定微服务的新路由。为了使连接工作，应用程序网关和Kubernetes必须在同一个Azure Vnet中。否则，连接将无法建立，您最终会在应用程序网关端得到不健康的后端探测。</p><p id="34e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，首先我们创建一个新的Vnet，并在该Vnet内创建两个子网，分别用于应用程序网关和Kubernetes。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="28c3" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">创建Azure应用网关</h1><p id="efa4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如我们将在本文后面看到的，根据URL路径将流量路由到不同的微服务可以通过Kubernetes清单进行配置。然而，Azure应用程序网关的创建必须提前完成。以下命令创建一个强制公共IP，并将其分配给一个新创建的应用程序网关。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3b21" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建AKS实例</h1><p id="b1f5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们可以开始创建一个简单配置的Kubernetes集群了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="de9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列出的命令将在<strong class="lb iu"> eastus </strong>地区创建一个名为<strong class="lb iu"> k8srg </strong>的资源组，并在其中创建一个Kubernetes集群。Kubernetes集群被命名为<strong class="lb iu"> myk8s </strong>，包含1个worker节点。最后一个命令将使您的<code class="fe oq or os og b">kubectl</code>连接到新创建的<strong class="lb iu"> myk8s </strong> Kubernetes集群。</p><p id="c987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的步骤中，我们为Azure订阅注册了提供者，这支持将应用程序网关用作Kubernetes <em class="lv">入口</em>的特性。现在我们需要为我们的Kubernetes集群启用该特性，并指定应该使用的应用程序网关。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="096e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，最后一个命令会将应用程序网关入口控制器所需的所有组件安装到Kubernetes集群中。在我撰写本文时，这种安装AGIC的方法还处于预览阶段，不推荐用于生产用例。或者，您可以“手动”安装组件，这稍微复杂一点。</p><h1 id="407e" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">测试AppGw入口</h1><p id="ab24" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果在此之前一切顺利，我们就可以开始测试我们的安装了。因此，我们可以利用ASP。Net应用程序，它通过我们的应用程序网关暴露自己。继续运行下面的命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="2b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该能够通过应用程序网关访问应用程序。打开浏览器，导航到应用网关的公共IP。您应该会看到一个. NET核心应用程序的基本欢迎页面。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e6c0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">公开多个服务</h1><p id="565b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在终于到了使用不同的路由在同一台主机上公开多个服务的时候了。因此，我们利用了我在Dockerhub 上发布的一个小小的Node.js应用程序。这个应用程序是一个非常简单的服务器，它返回一个由环境变量指定的消息。</p><p id="8f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看部署清单是什么样子的，它公开了主机上某个路由下的服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e53e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件的前两部分相对来说并不引人注意。请注意最后一节，它配置了如何公开服务。在第53行中，我们定义了应该使用哪个入口实现，第59行定义了应该公开服务的路由。一个有趣的方面是第54行，我们说后端的前缀是“/”。这是必需的，因为示例应用程序只有一个端点“/”。如果没有第54行，对<em class="lv">主机名/服务1 </em>的请求将被路由到不存在的<em class="lv">示例应用程序/服务1 </em>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您可以复制文件内容，创建您的文件并应用它。我为您简化了这一过程，并创建了一个GitHub repo，其中包含两个部署清单，每个清单公开了不同路径上的测试应用程序，而每个应用程序返回不同的响应。所以你只需要运行以下要点的命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，我们的Azure应用程序网关上应该有两条路由指向每个服务。我们将首先通过Azure门户或使用以下命令获取应用程序网关的IP来测试它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以简单地使用curl来检查主机上的两条服务路由。</p><p id="486a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oq or os og b">curl $pubIP/service1</code>应返回“来自服务1的问候”,相应地<code class="fe oq or os og b">curl $pubIP/service2</code>应返回“来自服务2的问候”。</p><h1 id="4fc0" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">解决纷争</h1><p id="d173" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于在公开我们的微服务的过程中包含多个组件，如果某些东西不能按预期工作，您将不得不查看不同的地方。</p><ul class=""><li id="9a53" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">首先，您应该检查所有pod是否都在运行。最重要的是名称空间kube-system中的<em class="lv">ingress-app GW-deployment-*</em>，而*等于随机字符串。该pod负责触发应用程序网关上的相应更新。</li><li id="3672" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">检查之后，如果代表您的微服务的pod运行正常。此外，检查指向您的微服务的服务是否已创建并正在运行。不要忘记仔细检查它们是否指向正确的端口。</li><li id="0b15" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果pod和<em class="lv">服务</em>运行正常，检查<em class="lv">入口</em>是否也已创建，并且它们分别指向正确的<em class="lv">服务</em>。另外，检查入口定义中的<em class="lv">后端路径前缀</em>是否设置正确。</li><li id="c4f8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">最后但同样重要的是，如果它仍然不能正常工作，您可以检查kube-system名称空间中的<em class="lv">ingress-app GW-deployment-*</em>的日志，这可能会给你一些提示，如果有什么问题的话。如果所涉及的组件有一些瑕疵，删除该pod也会有所帮助。</li></ul><h1 id="2d90" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">结论</h1><p id="92e0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">关于所示的在一个主机下公开多个服务的解决方案，最重要的结论是，您不应该盲目地遵循所提供的解决方案。而是想想自己真正的需求是什么。虽然应用程序网关是公开服务的一种方式，但也有其他技术可以用作Kubernetes <em class="lv">入口</em>，从而实现在一台主机下公开多个服务的目标。不要忘记仪表定律:“如果你有一把锤子，所有东西看起来都像钉子”。如果您确实需要应用程序网关的高级特性，或者如果您已经有了一个应用程序网关，那么就去使用它吧。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="9354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我鼓励你在这里务实一点。我在一个客户项目中的个人经历表明，我并不真的需要一个全功能的应用程序网关。此外，在重新部署微服务时，我在应用网关方面遇到了几个关于证书处理和零停机部署的问题，但这是另一回事了。也许我会写另一篇关于它的文章。作为一个试探，我选择Traefik作为那个客户项目的Kubernetes <em class="lv">入口</em>。一定会有另一篇文章展示我是如何做到的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="5800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读我的文章，并且你已经成功地公开了你的服务。我很想听听你在AGIC的经历。</p><h1 id="6b77" class="md me it bd mf mg no mi mj mk np mm mn jz nq ka mp kc nr kd mr kf ns kg mt mu bi translated">进一步阅读</h1><ul class=""><li id="5684" class="na nb it lb b lc mv lf mw li ot lm ou lq ov lu nf ng nh ni bi translated"><a class="ae ky" href="https://github.com/Azure/application-gateway-kubernetes-ingress" rel="noopener ugc nofollow" target="_blank">https://github . com/Azure/application-gateway-kubernetes-ingress</a></li><li id="b651" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://docs.microsoft.com/de-de/azure/aks/load-balancer-standard" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/de-de/azure/aks/load-balancer-standard</a></li><li id="5a4f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://docs.microsoft.com/de-de/azure/application-gateway/tutorial-ingress-controller-add-on-new" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/de-de/azure/application-gateway/tutorial-ingress-controller-add-on-new</a></li></ul></div></div>    
</body>
</html>