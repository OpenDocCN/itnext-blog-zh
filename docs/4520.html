<html>
<head>
<title>How To Capture Emails For Free With FaunaDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用FaunaDB免费捕捉电子邮件</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-capture-emails-for-free-with-faunadb-954ee10efce5?source=collection_archive---------6-----------------------#2020-07-17">https://itnext.io/how-to-capture-emails-for-free-with-faunadb-954ee10efce5?source=collection_archive---------6-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e74" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用无服务器数据库，零运营成本启动您的应用</h2></div><p id="8ba1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">作为</span>一家新成立的公司，你可能会考虑在早期用电子邮件捕获表单来捕获人们对你产品的兴趣。你的选择可能包括MailChimp、HubSpot、OptinMonster、SumoMe、Sleeknote等等。然而，不变的是，它们都是要花钱的，而且所有这些服务都有附加功能，比如电子邮件活动和跟踪，你对此还不感兴趣。</p><p id="b46b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要一个表格，捕捉一个电子邮件地址，并将其存储在某个地方。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/e837d49da89f3ddbc8923afaf02fb8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vv73-9UTS4DPHoPqTysZdw.png"/></div></div></figure><p id="4660" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将向您展示如何用FaunaDB非常简单地构建它。它应该可以帮助您开始无服务器数据库之旅。最后，你应该对GraphQL、自定义函数、自定义角色和Fauna中的特权有所了解。</p><p id="2cbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们将要构建的……</p><p id="ab1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lw" href="https://eknowles.github.io/fauna-email-capture/" rel="noopener ugc nofollow" target="_blank">https://eknowles.github.io/fauna-email-capture/</a></p><h1 id="dc00" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">GraphQL模式</h1><p id="423a" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">你可以通过描述一个GraphQL模式来创建一个API。在我们的例子中，我们只需要捕获一个电子邮件地址，并且它必须是唯一的。</p><pre class="ll lm ln lo gt mu mv mw mx aw my bi"><span id="a6b8" class="mz ly iq mv b gy na nb l nc nd"><strong class="mv ir">type </strong>Subscriptions {<br/>  email: String! <strong class="mv ir">@</strong>unique<br/>}</span></pre><p id="1aa5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们目前所需要的！将此保存为一个<code class="fe ne nf ng mv b">schema.gql</code>文件，然后<a class="ae lw" href="https://docs.fauna.com/fauna/current/start/graphql#import" rel="noopener ugc nofollow" target="_blank">将其上传到FaunaDB仪表板</a>。Fauna将在我们的数据库中创建一个<code class="fe ne nf ng mv b">Subscriptions</code>集合，并创建CRUD GraphQL查询和变异。魔法。</p><p id="9706" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望用户订阅两次，所以我添加了一个<code class="fe ne nf ng mv b">@unique</code>指令。这将在创建或更新时强制唯一性。如果您愿意，您可以<a class="ae lw" href="https://docs.fauna.com/fauna/current/api/graphql/directives/d_unique" rel="noopener ugc nofollow" target="_blank">自定义索引的名称</a>。</p><p id="f9df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这个怎么样。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nh"><img src="../Images/c0c6d2e515cbb9265e0bd83d8dd6970e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwZC-rGs2qvBmr33ttHEoA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">生成的GraphQL CRUD</figcaption></figure><p id="e0bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的截图显示了你如何创建一个新的订阅，在右边你可以看到所有由动物创造的突变。</p><ul class=""><li id="43c9" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la nr ns nt nu bi translated">findSubscriptionByID</li><li id="9448" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">创建订阅</li><li id="bb37" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">更新订阅</li><li id="ad5a" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">删除订阅</li></ul><p id="dc9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大多数用例来说，这是一个很好的kickstarter，但是我们不想考虑生成的ID，我们只关心电子邮件地址。此外，在安全方面，我们需要确保用户无法访问每个人的电子邮件，这些默认的变化并不理想，以抵御这一点。</p><p id="9982" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以做一些很酷的事情。</p><h2 id="6eac" class="mz ly iq bd lz oa ob dn md oc od dp mh ko oe of mj ks og oh ml kw oi oj mn ok bi translated">用户定义的函数(UDF)</h2><p id="9753" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">让我们在模式上定义我们自己的变化。我们可以使用在数据库内部创建和执行的用户定义函数(UDF)来处理GraphQL解析器。我们只需要描述突变的输入和输出。如果您将它添加到模式中并上传，FaunaDB将创建占位符函数供您编辑。</p><pre class="ll lm ln lo gt mu mv mw mx aw my bi"><span id="f5b3" class="mz ly iq mv b gy na nb l nc nd"><strong class="mv ir">type </strong>Mutation {<br/>  unsubscribe(email: String!): Boolean! <strong class="mv ir">@</strong>resolver(name: <strong class="mv ir">"unsub"</strong>)<br/>  subscribe(email: String!): Boolean! <strong class="mv ir">@</strong>resolver(name: <strong class="mv ir">"sub"</strong>)<br/>}</span></pre><blockquote class="ol"><p id="9d3c" class="om on iq bd oo op oq or os ot ou la dk translated">我们可以使用在数据库内部创建和执行的用户定义函数(UDF)来处理GraphQL解析器。</p></blockquote><h1 id="8822" class="lx ly iq bd lz ma mb mc md me mf mg mh jw ov jx mj jz ow ka ml kc ox kd mn mo bi translated">订阅</h1><p id="fc96" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">为了订阅用户，我们在<code class="fe ne nf ng mv b">Subscriptions</code>集合中创建新文档。在我们的模式中，我们说过这个函数将返回一个<code class="fe ne nf ng mv b">Boolean</code>，因此我用一个<code class="fe ne nf ng mv b">IsDoc</code>包装了<code class="fe ne nf ng mv b">Create</code>方法，所以它总是返回true。</p><pre class="ll lm ln lo gt mu mv mw mx aw my bi"><span id="7e61" class="mz ly iq mv b gy na nb l nc nd">Query(<br/>  Lambda(<br/>    ['<strong class="mv ir">email</strong>'],<br/>    IsDoc(<br/>      Create(<br/>        Collection(<strong class="mv ir">'Subscriptions'</strong>), <br/>        { data: { email: Var(<strong class="mv ir">'email'</strong>) } }<br/>      )<br/>    )<br/>  )<br/>)</span></pre><p id="555d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果电子邮件已经存在，那么它将返回一个错误。</p><h1 id="17ea" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">取消订阅</h1><p id="8ff2" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我们的退订功能也很类似。我们使用了<code class="fe ne nf ng mv b">Delete</code>函数，该函数期望引用集合中的一个文档。还记得我们模式中的独特装饰吗？这将为我们创建一个默认如下的索引:<code class="fe ne nf ng mv b">unique_Subscriptions_email</code>。</p><p id="ca7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解释FQL是如何工作的，我发现最好通过“从里到外”来讲述。</p><p id="20df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了搜索索引，我们需要使用<code class="fe ne nf ng mv b"><a class="ae lw" href="https://docs.fauna.com/fauna/current/API/FQL/functions/Match.html" rel="noopener ugc nofollow" target="_blank">Match</a></code>，这给了我们一个<a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/sets" rel="noopener ugc nofollow" target="_blank">集合</a>。然后，我们可以通过使用<code class="fe ne nf ng mv b"><a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/functions/get" rel="noopener ugc nofollow" target="_blank">Get</a></code>从数据库中检索匹配的文档(这将导致一个读取操作，该操作将计入您的配额，因此请注意这一点)。现在我们有一个文档，我们可以删除它。然而<code class="fe ne nf ng mv b"><a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/functions/delete" rel="noopener ugc nofollow" target="_blank">Delete</a></code>函数需要一个<a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/functions/ref" rel="noopener ugc nofollow" target="_blank"> Ref </a>，所以我们使用<code class="fe ne nf ng mv b"><a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/functions/select" rel="noopener ugc nofollow" target="_blank">Select</a></code>函数从返回的文档中挑选出Ref值。</p><p id="1bf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这令人困惑，想象一下在JavaScript中你通常如何使用点来访问嵌套属性(例如data.document.thing.ref)。我们需要使用<code class="fe ne nf ng mv b"><a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/functions/select" rel="noopener ugc nofollow" target="_blank">Select</a></code>来获得一个属性。一旦你理解了FQL只是一堆组合函数的概念，就很容易理解了。</p><pre class="ll lm ln lo gt mu mv mw mx aw my bi"><span id="06e1" class="mz ly iq mv b gy na nb l nc nd">Query(<br/>  Lambda(<br/>    ['<strong class="mv ir">email</strong>'],<br/>    IsDoc(<br/>      Delete(<br/>        Select(<br/>          [<strong class="mv ir">'ref'</strong>],<br/>          Get(<br/>            Match(Index(<strong class="mv ir">'unique_Subscriptions_email'</strong>), Var(<strong class="mv ir">'email'</strong>))<br/>          )<br/>        )<br/>      )<br/>    )<br/>  )<br/>)</span></pre><p id="372f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唷！如果你明白这一切，那么你现在是动物群查询语言(FQL)的一个向导！去拍拍自己的背吧。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/e9e33d2d7579b4cdf8288c864beb4f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*rVEaBgvpjiTmSRDJzYVnWw.gif"/></div></figure><h1 id="f73e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">安全性</h1><p id="e187" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">要进入动物群，你需要一把<a class="ae lw" href="https://docs.fauna.com/fauna/current/security/keys.html" rel="noopener ugc nofollow" target="_blank">钥匙</a>。密钥由<a class="ae lw" href="https://docs.fauna.com/fauna/current/security/roles" rel="noopener ugc nofollow" target="_blank">角色</a>生成，角色拥有<a class="ae lw" href="https://docs.fauna.com/fauna/current/security/roles#pco" rel="noopener ugc nofollow" target="_blank">权限</a>。</p><p id="5a6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了保护我们的邮件列表，我们需要创建一个自定义角色。这些自定义角色是动物群中的特殊文档，描述了角色所拥有的访问权限。然后，我们可以为这个角色创建一个键，并将其用作GraphQL API的<code class="fe ne nf ng mv b">Authorisation</code>头。想不到！</p><blockquote class="oz pa pb"><p id="6e01" class="kf kg pc kh b ki kj jr kk kl km ju kn pd kp kq kr pe kt ku kv pf kx ky kz la ij bi translated">邮件列表应该是最高机密，我们给我们的前端令牌应该不能查询其他电子邮件地址。</p></blockquote><p id="c19b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，所有角色都没有访问权限。我们可以通过在角色上使用<a class="ae lw" href="https://docs.fauna.com/fauna/current/security/roles#pco" rel="noopener ugc nofollow" target="_blank">特权</a>来授予集合和索引等权限。</p><p id="a3a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望从前端调用GraphQL端点，从而消除对后端的需求。通过使用“最小特权原则”,前端用户只能调用<code class="fe ne nf ng mv b">subscribe</code>和<code class="fe ne nf ng mv b">unsubscribe</code>函数。</p><p id="0439" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跳进仪表盘，进入<code class="fe ne nf ng mv b">Security &gt; Manage Roles &gt; New Role</code>。滚动到功能，选择两者，并给它打电话访问。如果您手动执行此操作，代码将如下所示:</p><pre class="ll lm ln lo gt mu mv mw mx aw my bi"><span id="bbb9" class="mz ly iq mv b gy na nb l nc nd">{<br/>  name: <strong class="mv ir">'frontend'</strong>,<br/>  membership: [],<br/>  privileges: [<br/>    {<br/>      resource: Function(<strong class="mv ir">'subscribe'</strong>),<br/>      actions: {<br/>        call: <strong class="mv ir">true<br/>      </strong>}<br/>    },<br/>    {<br/>      resource: Function(<strong class="mv ir">'unsubscribe'</strong>),<br/>      actions: {<br/>        call: <strong class="mv ir">true<br/>      </strong>}<br/>    }<br/>  ],<br/>}</span></pre><p id="59c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">角色描述了它可以做的许多事情。对于一个函数，它只能被<em class="pc">调用</em>，但是对于集合和索引，你可以读、写、创建、更新、删除等等。</p><p id="d80c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为这个角色生成一个密钥非常简单，在仪表板上只需点击<code class="fe ne nf ng mv b">Security &gt; New Key</code>。</p><p id="0c55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们的函数本身需要对订阅集合进行“创建和读取”访问。因为这些功能不会泄露任何电子邮件地址或其他数据，所以给它们管理员角色是完全没问题的。</p><p id="4cb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们已经讨论了动物安全的基本原则。使用基于属性的访问控制(ABAC)可以做更多的事情，它包括像谓词函数而不是布尔函数这样的东西，允许您根据用户正在做的事情和用户是谁来授予权限。</p></div><div class="ab cl pg ph hu pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ij ik il im in"><p id="c057" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来如此！现在，您在一个全球多云复制数据库上有了一个安全的API，专门用于您的邮件列表。</p><p id="6a5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GitHub上有一个工作示例库，您可以在那里下载源代码，并在2分钟内建立和运行您自己的数据库和API。</p><div class="pn po gp gr pp pq"><a href="https://github.com/eknowles/fauna-email-capture" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd ir gy z fp pv fr fs pw fu fw ip bi translated">eknowles/动物群-电子邮件-捕获</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">对于新的创业公司，你可能会考虑用电子邮件捕获表单来捕获早期的兴趣。您对…的选择</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">github.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe lu pq"/></div></div></a></div><p id="8dbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你甚至可以在此基础上添加<a class="ae lw" href="https://docs.fauna.com/fauna/current/api/fql/collections" rel="noopener ugc nofollow" target="_blank"> TTL </a>，这样电子邮件地址就会在6个月后被清除。</p><p id="6b00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很期待看到<em class="pc">你</em>能对此做出什么贡献，请在评论中告诉我你的想法！</p><p id="f2df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请继续关注本系列的下一篇文章，在那里，我将使用<a class="ae lw" href="https://docs.fauna.com/fauna/current/integrations/fdm/" rel="noopener ugc nofollow" target="_blank"> FaunaDB数据管理器(FDM) </a>，向您展示如何提取您准备处理的电子邮件。</p></div></div>    
</body>
</html>