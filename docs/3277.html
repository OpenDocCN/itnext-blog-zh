<html>
<head>
<title>Breaking Down Containers | Part 0 — System Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解容器|第0部分—系统架构</h1>
<blockquote>原文：<a href="https://itnext.io/breaking-down-containers-part-0-system-architecture-37afe0e51770?source=collection_archive---------0-----------------------#2019-11-12">https://itnext.io/breaking-down-containers-part-0-system-architecture-37afe0e51770?source=collection_archive---------0-----------------------#2019-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1b9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文中需要注意的事项</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="e5bf" class="ku kv iq kq b gy kw kx l ky kz">1. This is not an absolute beginner article on Containers, you've read too many of them. This is more of a past beginner intro.<br/>2. You're not learning about Docker and what it does in its simplest form here, you're learning about containers and container runtimes.<br/>3. Pre-requisite knowledge of Linux is important but not necessary.<br/>4. Are you using Windows as a developer in 2019??????<br/>5. I cover a lot more about linux system architecture here, do take a moment or two to read on something new!<br/>6. There will be code demos in C following other tutorials, nothing complex but just a heads up!</span></pre></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="91d3" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是容器？</h1><p id="39ec" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">随着Kubernetes、Docker Compose、Mesos OS、Consul等的出现，容器成了这些云计算时代的头条新闻。</p><p id="e427" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要真正理解容器的骨架组合，首先需要知道几件事:</p><ol class=""><li id="f818" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">Linux内核用户和系统空间</li><li id="5865" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">系统调用和功能</li><li id="5be2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">Cgroups</li><li id="48ef" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">名称空间</li><li id="1565" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">EIAF(一切都是文件)，对基于Unix的文件系统的描述</li></ol><p id="9e9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这5件事对于真正理解容器如何工作以及为什么我们需要一个Linux VM在Windows和Mac上运行容器很重要，尽管<a class="ae mx" href="https://en.wikipedia.org/wiki/MacOS#Architecture" rel="noopener ugc nofollow" target="_blank"> Mac内核</a>是POSIX兼容的并且基于OpenBSD。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="ef3e" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">为什么我会这样开始？</h1><p id="f77b" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我打算深入研究，因为关于容器的文章关注的是Docker、Dockerfiles和臭名昭著的命令<code class="fe my mz na kq b">docker build -t .</code>之类的东西，这些都很琐碎。基本部分仍然会在后面的部分中出现，但它们如何工作背后的底层是我将在接下来的系列中讨论的内容。</p><p id="7195" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我采用了一种不同的方法，直奔容器的工作原理以及它们的结构和功能。</p><p id="b98e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从理解Linux内核系统和用户空间开始，以便更好地做出决策，并深入了解容器真正做了什么。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="7db3" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Linux内核空间</h1><p id="8900" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在Linux中，我们有两个应用程序通常运行的空间，内核系统空间和用户空间。通常，在默认内核配置下，用户空间占用0–3GB空间，而内核空间占用3–4GB空间，更多详细信息<a class="ae mx" href="http://linux.it/~rubini/docs/ksys/" rel="noopener ugc nofollow" target="_blank">在此</a>。</p><p id="290e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内核空间是我们为内核上运行的低级应用程序提供系统内存的地方。用户空间是用户处理功能和执行的环境。</p><figure class="kl km kn ko gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nb"><img src="../Images/a6f3291bf23beda556a3eb95d85d1d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JXy_NGicgg0SEqMr"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">用户空间如何通过系统调用与内核空间交互</figcaption></figure><blockquote class="nn no np"><p id="c175" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="https://redhat.com/en/blog/architecting-containers-part-1-why-understanding-user-space-vs-kernel-space-matters" rel="noopener ugc nofollow" target="_blank">https://red hat . com/en/blog/architecting-containers-part-1-why-understanding-user-space-vs-kernel-space-matters</a></p></blockquote><p id="d057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个内存空间由一个被称为<a class="ae mx" href="https://en.wikipedia.org/wiki/Protection_ring" rel="noopener ugc nofollow" target="_blank">环</a>的微调权限层分隔开。这些环定义了在某个操作被授权之前，一个应用程序的需求需要有多高的特权或无特权。</p><figure class="kl km kn ko gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nu"><img src="../Images/b51b786e85e21c3e9366b81bdd1831c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UpqIFrVXClmdqAaA.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">X86系统的环形层</figcaption></figure><blockquote class="nn no np"><p id="0b51" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="https://en.wikipedia.org/wiki/Protection_ring" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Protection_ring</a></p></blockquote><p id="5b39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些环并不是Linux所特有的，而是操作系统中定义良好的布局，尽管每一级的功能区域都是根据操作系统在上运行的<a class="ae mx" href="https://unix.stackexchange.com/a/368313" rel="noopener ugc nofollow" target="_blank"> CPU架构来分配的。为了在用户空间和内核空间之间切换，我们通过一个系统调用来应用一个操作，简称为syscall。</a></p><p id="7e7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使用可从用户空间应用程序访问的定义的内核函数来请求对内核级功能的访问。下图很好地解释了这个订单是如何定义的。</p><figure class="kl km kn ko gt nc gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/15a46e0dfcd997e1f213df4d64cfe686.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*7EqrMllyQfu4ujDl"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">操作系统层的分层概述</figcaption></figure><p id="107a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当应用程序向内核级函数发出请求时，就会发送一个中断，告诉处理器停止正在做的任何事情，去处理那个特定的请求，如果这样更容易理解的话，你可以把它想象成上下文切换。假设用户空间应用程序具有相关的许可，则存在到内核空间的上下文切换，在上下文切换已经开始并且内核空间中所需的程序/功能通过适当的中断处理程序的帮助被执行之后，用户空间应用程序等待返回的响应。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="c04c" class="ku kv iq kq b gy kw kx l ky kz">tmp_buf = mmap(file, len); # mmap here is from a C library</span><span id="5500" class="ku kv iq kq b gy nw kx l ky kz"># This is called a memory map and it's a C function<br/># It allocates a certain amount of memory for a task, file etc.<br/># Since memory is a kernel space resource, a syscall is made to the mmap syscall in the linux kernel to make this request possible</span></pre><figure class="kl km kn ko gt nc gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/16ec591cb8e876c96a837997b05b93a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*Ps0wfy3namvezbg_.jpg"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">mmap零拷贝的内核到用户空间操作的例子</figcaption></figure><blockquote class="nn no np"><p id="c207" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="https://web.archive.org/web/20190808074654/https://www.linuxjournal.com/article/6345" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20190808074654/https://www . linuxjournal . com/article/6345</a></p></blockquote></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="4e50" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">接下来是系统调用和功能</h1><p id="5b06" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">系统调用(又名syscall)是一个API，它允许内核功能的一小部分<strong class="jp ir">暴露给用户级应用程序。一小部分是为了告诉读者，系统调用是有限的，并且是通用的。它们在不同的操作系统中并不相同，在定义和访问模式上都有所不同。</strong></p><div class="kl km kn ko gt ab cb"><figure class="ny nc nz oa ob oc od paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/c7f8ec34f71532706e3266b2fcad4b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*nkxfSMNFuVpRNGJhlSNzvw.png"/></div></figure><figure class="ny nc oe oa ob oc od paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><img src="../Images/c3e8d8d30e93c526d061a2b809a0ae99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*6JMSXXphZbAU5fK5ixG4cg.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk of di og oh translated">分别针对Unix和Windows的系统调用</figcaption></figure></div><blockquote class="nn no np"><p id="5b88" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="https://www.tutorialspoint.com/system-calls-in-unix-and-windows" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/system-calls-in-UNIX-and-windows</a></p></blockquote><p id="c7a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">追溯到前面的mmap示例，它没有在映像中列出，因为这只是一个小列表，linux中系统调用的完整列表可以在这里<a class="ae mx" href="http://man7.org/linux/man-pages/man2/syscalls.2.html" rel="noopener ugc nofollow" target="_blank">获得</a>。</p><p id="3287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，我们想要将一组系统调用组合在一起，我们使用一个叫做Capabilities的linux内核特性来实现。这些是预定义的特权集，一个正在运行的程序可以访问这些特权，或者受到这些特权的限制。</p><p id="6b91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">功能进一步增强了系统调用，方法是将相关的系统调用分组到可以立即授予或拒绝的已定义的特权中。这甚至可以防止根级别的应用程序利用带有保留权限的受限内核空间。</p><p id="6aca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几个linux功能，大部分将在后面的文章中介绍，它们如何使用SecComp之类的配置文件和更具体的LSM(Linux安全模块)如AppArmor、SELinux等与容器集成。但是您可以在这里参考手册页<a class="ae mx" href="http://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener ugc nofollow" target="_blank">中的列表。</a></p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="8b07" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Cgroups</h1><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="eb8b" class="ku kv iq kq b gy kw kx l ky kz">Control groups, usually referred to as cgroups, are a Linux kernel<br/>feature which allow processes to be organized into hierarchical<br/>groups whose usage of various types of resources can then be limited<br/>and monitored.  The kernel's cgroup interface is provided through a<br/>pseudo-filesystem called cgroupfs.  Grouping is implemented in the<br/>core cgroup kernel code, while resource tracking and limits are<br/>implemented in a set of per-resource-type subsystems (memory, CPU,<br/>and so on).</span></pre><blockquote class="nn no np"><p id="50ff" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="http://man7.org/linux/man-pages/man7/cgroups.7.html" rel="noopener ugc nofollow" target="_blank">http://man7.org/linux/man-pages/man7/cgroups.7.html</a></p></blockquote><p id="4907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单来说，cgroups控制我们可以使用什么。它们的功能列表如下所示:</p><ul class=""><li id="eccb" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk oi mp mq mr bi translated"><strong class="jp ir">资源限制:</strong>可以对组进行配置，使其不超过指定的内存限制，或使用超过所需数量的处理器，或仅限于特定的外围设备。</li><li id="715e" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><strong class="jp ir">优先级:</strong>可以配置一个或多个组来利用更少或更多的CPU或磁盘I/O吞吐量。</li><li id="0483" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><strong class="jp ir">会计:</strong>监控和测量集团的资源使用情况。</li><li id="4ec6" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><strong class="jp ir">控制:</strong>可以冻结或停止多组流程，并重新启动。</li></ul><blockquote class="nn no np"><p id="7506" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="https://web.archive.org/web/20190808230154/https://www.linuxjournal.com/content/everything-you-need-know-about-linux-containers-part-i-linux-control-groups-and-process" rel="noopener ugc nofollow" target="_blank">https://web . archive . org/web/20190808230154/https://www . Linux journal . com/content/everything-you-need-know-about-Linux-containers-part-I-Linux-control-groups-and-process</a></p></blockquote><p id="b3ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Cgroups通过使用修改进程运行时环境的子系统/控制器来发挥作用。v1和v2两个版本中有多种控制器可用。</p><p id="0148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在v1控制器领域，我们有以下内容:</p><ul class=""><li id="032d" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk oi mp mq mr bi translated"><code class="fe my mz na kq b">blkio</code> —该子系统设置物理驱动器(磁盘、固态硬盘或USB)等块设备的输入/输出访问限制。</li><li id="78c2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">cpu</code> —该子系统使用调度程序向CPU提供cgroup任务访问。</li><li id="a7a7" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">cpuacct</code> —该子系统自动生成关于cgroup中任务使用的CPU资源的报告。</li><li id="575a" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">cpuset</code> —该子系统将单个CPU(在多核系统上)和内存节点分配给cgroup中的任务。</li><li id="eb1d" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">devices</code> —该子系统允许或拒绝cgroup中的任务访问设备。</li><li id="d218" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">freezer</code> —该子系统暂停或恢复cgroup中的任务。</li><li id="18ac" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">memory</code> —该子系统为cgroup中的任务设置内存使用限制，并自动报告这些任务使用的内存资源。</li><li id="1e1e" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">net_cls</code> —该子系统使用类别标识符(classid)标记网络数据包，该标识符允许Linux流量控制器(<code class="fe my mz na kq b">tc</code>)识别源自特定cgroup任务的数据包。</li><li id="ef25" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">net_prio</code> —该子系统提供了一种为每个网络接口动态设置网络流量优先级的方法。</li><li id="3077" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">ns</code>—<em class="nq">命名空间</em>子系统。</li><li id="7fbc" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">perf_event</code> —该子系统识别任务的cgroup成员，并可用于性能分析。</li><li id="d8d4" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b"><em class="nq">hugetlb</em></code> —支持限制cgroups使用大页面。</li><li id="2e46" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b"><em class="nq">pids</em></code> —该控制器允许限制在cgroup(及其后代)中创建的<br/>进程的数量。</li><li id="37c6" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b"><em class="nq">rdma</em></code>—RDMA(远程DMA)控制器允许限制每个cgroup使用RDMA / IB专用资源。</li></ul><p id="bbc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于v2控制器空间，我们有v1的一些功能，因为一些控制组没有实现，linux系统可以使用这两者，但是v2系统更精简，cgroups更少。</p><ul class=""><li id="5bb8" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk oi mp mq mr bi translated"><code class="fe my mz na kq b">io</code> —这是版本1 blkio控制器的后继产品。</li><li id="78fd" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">memory</code> —这是第1版内存控制器的继任者。</li><li id="54e2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">pids</code> —这与版本1的pids控制器相同。</li><li id="a0eb" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">perf_event</code> —与版本1的perf_event控制器相同。</li><li id="9663" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">rdma</code> —与版本1 rdma控制器相同。</li><li id="1a97" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk oi mp mq mr bi translated"><code class="fe my mz na kq b">cpu</code> —这是第1版cpu和cpuacct控制器的后继产品。</li></ul><p id="6950" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所注意到的，就功能而言，它与版本1的控制器相同。每个cgroup都提供限制一个或多个资源的功能。围绕这一点的库和工具将在接下来的部分中重新讨论。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="8b60" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">现在名称空间</h1><p id="d5c7" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">@jpetazzo是我在这个主题上最喜欢的开发者，这篇tweets总结了cgroups、namespaces和基于文件的进程文件系统之间的关系，我将在下一节中介绍。</p><figure class="kl km kn ko gt nc"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0c6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要深入了解名称空间和cgroups在容器中的作用，请观看此视频:</p><figure class="kl km kn ko gt nc"><div class="bz fp l di"><div class="ol ok l"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">cgroups、名称空间和容器的完整分类</figcaption></figure><p id="b963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在回到名称空间，名称空间使容器认为它们存在于一个完全隔离的环境中，而不是在主主机系统中。更具体地说，容器中的进程认为自己是系统中唯一的进程。</p><p id="f342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以认为它是在一个盒子里，当你在一个盒子里的时候，你认为你拥有这个盒子，但你只是在另一个人的盒子里玩梦境游戏，那个人实际上拥有这两个盒子。由于这个特性，在容器中运行容器是可能的，尽管还有一些问题，我将在后面讨论。</p><p id="3dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于名称空间特性，它嵌入在linux的构成中。</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="3959" class="ku kv iq kq b gy kw kx l ky kz"><strong class="kq ir"><em class="nq"><br/>Name .    CLONE FLAG .   MAN DOC .             FUNCTION .  </em></strong></span><span id="3879" class="ku kv iq kq b gy nw kx l ky kz">IPC       <strong class="kq ir">CLONE_NEWIPC    ipc_namespaces</strong>(7)     System V IPC,<br/>                                               POSIX message  queues</span><span id="9626" class="ku kv iq kq b gy nw kx l ky kz">Network   <strong class="kq ir">CLONE_NEWNET    network_namespaces</strong>(7) Network devices,<br/>                                                stacks, ports, etc.</span><span id="9ccb" class="ku kv iq kq b gy nw kx l ky kz">Mount     <strong class="kq ir">CLONE_NEWNS     mount_namespaces</strong>(7)   Mount points</span><span id="7843" class="ku kv iq kq b gy nw kx l ky kz">PID       <strong class="kq ir">CLONE_NEWPID    pid_namespaces</strong>(7)     Process IDs</span><span id="9110" class="ku kv iq kq b gy nw kx l ky kz">User      <strong class="kq ir">CLONE_NEWUSER   user_namespaces</strong>(7)    User and group IDs</span><span id="d7f8" class="ku kv iq kq b gy nw kx l ky kz">UTS       <strong class="kq ir">CLONE_NEWUTS    uts_namespaces</strong>(7)     Hostname and NIS<br/>                                                  domain name</span></pre><blockquote class="nn no np"><p id="65f9" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="http://man7.org/linux/man-pages/man7/namespaces.7.html" rel="noopener ugc nofollow" target="_blank">http://man7.org/linux/man-pages/man7/namespaces.7.html</a></p></blockquote><p id="c062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些名称空间提供不同的功能。</p><p id="703e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">IPC</code> —隔离进程间通信，这是一个很大的词，意味着进程可以沿着通道或管道在彼此内部共享消息，就像水通过管道流动一样。如果没有名称空间，就像我们的主要管道，一个容器(进程)可以使用同一管道向其他进程提供数据。对于名称空间，管道是独特的，并且仅限于名称空间内的某些进程。在linux中，这是使用<code class="fe my mz na kq b">/dev/shm(shared memory)</code>或<code class="fe my mz na kq b">/dev/mqueue(message queue)</code>块文件从主机共享的。</p><blockquote class="nn no np"><p id="236e" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">注意:<code class="fe my mz na kq b">/dev/mqueue</code>块文件在基于队列的应用程序中被大量使用，你可以创建自己的队列，这非常简单！。详情<a class="ae mx" href="https://www.youtube.com/watch?v=JbmOegG9-J0" rel="noopener ugc nofollow" target="_blank">此处</a>，手册页<a class="ae mx" href="http://man7.org/linux/man-pages/man7/mq_overview.7.html" rel="noopener ugc nofollow" target="_blank">此处</a>，使用本<a class="ae mx" href="https://forums.cranksoftware.com/viewtopic.php?f=5&amp;t=39" rel="noopener ugc nofollow" target="_blank">指南</a>验证您是否拥有mqueue支持</p></blockquote><p id="b4d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">Network</code> —负责隔离ip地址、接口、网络请求、端口等。</p><p id="aa69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">Mount</code> —限制主机上的卷和外部数据装载的使用。命名空间中的进程在其自己的本机文件系统中运行。</p><p id="8b66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">PID</code> —隔离进程运行时，在主机上的进程和命名空间中的进程之间给出纯粹的限制。因此，主机上的bash实例不同于容器中的实例。这是允许我们在不在主机上的容器中运行应用程序的一个奇特的例子。</p><p id="3e8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">User</code> —限制容器用户的UID(用户标识)和GID(组标识)分配。这有效地允许主机是安全的，因为容器不能从主机读取。</p><p id="8ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">UTS</code> —用于设置或获取主机名，非常简单。</p><p id="8f34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些名称空间都使用<a class="ae mx" href="http://man7.org/linux/man-pages/man2/unshare.2.html" rel="noopener ugc nofollow" target="_blank"> unshare </a>系统调用来隔离资源。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="b93d" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">最后是Linux文件系统</h1><p id="6c91" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">在linux中首先要注意的是，所有东西都是一个文件。我不骗你，从存储、串行设备等等都是<code class="fe my mz na kq b">/dev/*</code>到<code class="fe my mz na kq b">/proc/fileystems</code>中的文件系统列表，甚至一直到运行在主机上的组。不同文件系统之间的大部分交互是由虚拟文件系统驱动程序(VFS)处理的，但是这是另外一个话题。</p><figure class="kl km kn ko gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi om"><img src="../Images/ec5bf2b65f9069ce92372af037287c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8n1LCYRso1Uxw0OdSYf_g.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">我的流浪箱中所有支持的文件系统列表</figcaption></figure><p id="df94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为所有的东西都是一个文件，所以我可以通过<code class="fe my mz na kq b">cat</code>(这是一个将所有文本放到一个文件中的命令)来查看所支持的配置。</p><blockquote class="nn no np"><p id="55ec" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">那么这是从哪里装入容器的呢？</p></blockquote><p id="09ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前面提到的容器是流程。我们都知道容器和虚拟机之间的区别，容器共享主机的内核和一些资源。这里的主要提示是<strong class="jp ir">资源</strong>，容器使用不同的根文件系统来启动它们自己的操作，容器(提示:它们是进程)用来启动的实际文件系统是映像。</p><p id="d02a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">映像是一个linux文件系统，在需要运行之前大部分都被压缩了，从这里它使用一些<a class="ae mx" href="https://stackoverflow.com/questions/628938/what-is-copy-on-write" rel="noopener ugc nofollow" target="_blank"> COW </a>(写时复制)文件系统来执行，比如AUFS、设备映射器、Btrfs、XFS等等……有几个。</p><p id="66d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些安装了docker的用户，你可以运行下面的命令来查看docker镜像的内部结构(不是容器，容器是<strong class="jp ir">进程，运行镜像等等。)</strong></p><blockquote class="nn no np"><p id="9526" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">mkdir rootfs &amp;&amp; \</p><p id="dd94" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">docker export $(docker create Ubuntu:18.04)| tar-C rootfs-xvf-</p></blockquote><figure class="kl km kn ko gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi on"><img src="../Images/f2cba79d241a4e86ccc22ae443fbb528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xC-8I0ylpsekIwqdv03k7A.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">Ubuntu上的Linux虚拟机:18.04</figcaption></figure><p id="c0e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要的linux文件系统很特别，你会注意到<strong class="jp ir"> vmlinuz </strong>和<strong class="jp ir"> initrd.img </strong>，稍后我会回头再讨论它们。</p><figure class="kl km kn ko gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oo"><img src="../Images/fe1b389aa5fdc0555ce496da4a7352e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bsDFrD6aullFObNTlzhfw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">Ubuntu 18.04实例映像的文件系统映像，与主机相同</figcaption></figure><p id="89fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们注意到我们没有主文件系统上看到的<strong class="jp ir"> initrd </strong>和<strong class="jp ir"> vmlinuz </strong>文件，这是因为这两个文件是内核文件。</p><p id="e59f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe my mz na kq b">InitRD</code> —初始化Ram磁盘</p><blockquote class="nn no np"><p id="9f4d" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated"><em class="iq">初始RAM磁盘(initrd) </em>是一个初始根文件系统，在真正的根文件系统可用之前安装。initrd绑定到内核，并作为内核引导过程的一部分加载。然后，内核挂载这个initrd，作为两阶段引导过程的一部分，以加载模块，使真正的文件系统可用，并获得真正的根文件系统。</p><p id="4540" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:https://developer.ibm.com/articles/l-initrd/<a class="ae mx" href="https://developer.ibm.com/articles/l-initrd/" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="3983" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">VMLinuz—<strong class="jp ir">V</strong>I virtual<strong class="jp ir">M</strong>emory<strong class="jp ir">LINU</strong>x g<strong class="jp ir">Z</strong>IP</p><blockquote class="nn no np"><p id="a174" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">vmlinuz是Linux内核可执行文件的名称。vmlinuz是一个压缩的Linux内核，它能够将操作系统加载到内存中，以便计算机变得可用，应用程序可以运行。</p></blockquote><p id="506c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在linux上，您可能会遇到vmlinux或vmlinuz。它们是一样的，但是其中一个被压缩了。</p><p id="a47f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">vmlinuz =<strong class="jp ir">V</strong>I virtual<strong class="jp ir">M</strong>emory<strong class="jp ir">LINU</strong>x g<strong class="jp ir">Z</strong>IP =压缩的Linux内核可执行文件</p><p id="0247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">VM linux =<strong class="jp ir">V</strong>I virtual<strong class="jp ir">M</strong>emory<strong class="jp ir">LINU</strong>X =非压缩的Linux内核可执行文件</p><p id="4d0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">vmlinuz和initrd文件都在引导时使用。</p><blockquote class="nn no np"><p id="fb5f" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">在这个内核映像(vmlinuz)的头部是一个例程，它进行一些最少量的硬件设置，然后解压缩内核映像中包含的内核，并将其放入高内存中。如果存在一个初始RAM磁盘映像(initrd ),这个例程将它移动到内存中(或者我们可以说将压缩的RAM磁盘映像提取到实际内存中),并记录下来供以后使用。然后例程调用内核，内核启动开始。</p><p id="b7b7" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">来源:<a class="ae mx" href="https://developer.ibm.com/articles/l-initrd/" rel="noopener ugc nofollow" target="_blank">https://developer.ibm.com/articles/l-initrd/</a></p></blockquote><p id="26f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果“容器文件系统”的音节太多，这就是我们在容器文件系统或映像中没有这两个文件的主要原因。</p><blockquote class="nn no np"><p id="0e0d" class="jn jo nq jp b jq jr js jt ju jv jw jx nr jz ka kb ns kd ke kf nt kh ki kj kk ij bi translated">容器使用主机内核！ </p></blockquote><p id="d311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它不需要引导序列来获得内核，来自容器内的应用程序的所有可能的请求都是通过主机内核经由通过rings、capabilities、seccomp、LSMs等强制执行的系统调用来进行的，就像任何普通的linux程序一样。</p><p id="6a8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的主要思想是容器只是使用完全不同的文件系统，但是它们共享相同的linux内核。对于我们这些稍微了解linux的人来说，我们知道我们可以<strong class="jp ir"> chroot </strong>到一个外来的linux文件系统中，并在其中操作，就像文件系统已经启动一样，只要主机上所有必需的文件都通过bind安装在那个文件夹中。</p><figure class="kl km kn ko gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi op"><img src="../Images/f4dd4c1e3f4b2eb8b0cdc6f425ddcaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGzu9vkrAjO9K4WSpg2D5Q.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">chroot与实际容器不同的一个清晰的例子</figcaption></figure><p id="d6c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经完成了其中的某些部分，你会发现容器只是用名称空间、cgroups和许多其他很酷的特性打包的类固醇，以使应用程序沙箱在同一主机上尽可能安全。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="270a" class="lh kv iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">总而言之，什么是容器？</h1><p id="8632" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">容器是在名称空间内执行的运行时进程，该名称空间由cgroups和各种其他LSM和安全功能进行资源管理，以确保运行时完全的进程隔离。容器中的这些过程是自动化的，其中包括Docker之类的容器运行时，它简化了许多讨论的内容，但是我已经解释过的主要底层仍然是相同的。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="eb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi oq translated"><span class="l or os ot bm ou ov ow ox oy di">那么</span>接下来呢？</p><p id="b12d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一部分(第1部分)中，我将更深入地讨论名称空间和cgroup，什么是unshare，以及各种cgroup如何组合在一起帮助进程隔离，这样我们就不会在下一个pseudo chroot kinda exec中看到tail。</p><div class="oz pa gp gr pb pc"><a rel="noopener  ugc nofollow" target="_blank" href="/breaking-down-containers-part-1-namespaces-9668b86d003d"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">分解容器|第1部分—名称空间</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">在继续之前，有一些事情需要注意</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">itnext.io</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq nh pc"/></div></div></a></div><h1 id="a647" class="lh kv iq bd li lj pr ll lm ln ps lp lq lr pt lt lu lv pu lx ly lz pv mb mc md bi translated">资源</h1><p id="c06f" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated"><a class="ae mx" href="https://www.kernel.org/doc/Documentation/filesystems/proc.txt" rel="noopener ugc nofollow" target="_blank">https://www . kernel . org/doc/Documentation/file systems/proc . txt</a></p><p id="31b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mx" href="https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt" rel="noopener ugc nofollow" target="_blank">https://www . kernel . org/doc/Documentation/file systems/sys fs . txt</a></p><div class="oz pa gp gr pb pc"><a href="https://users.pja.edu.pl/~jms/qnx/help/watcom/clibref/mq_overview.html" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">POSIX.4消息队列</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">本章讨论:POSIX消息队列允许一个有效的、优先级驱动的IPC机制，它具有多个…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">users.pja.edu.pl</p></div></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://developer.ibm.com/articles/l-initrd/" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">Linux初始RAM磁盘(initrd)概述</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">Linux初始RAM磁盘(initrd)是一个临时的根文件系统，它在系统引导期间被挂载以支持…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">developer.ibm.com</p></div></div><div class="pl l"><div class="pw l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://superuser.com/questions/165116/mount-dev-proc-sys-in-a-chroot-environment" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">在chroot环境中挂载dev、proc、sys？</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">我正在尝试创建一个带有自定义精选包的Linux映像。我想做的是手工制作包装，我…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">superuser.com</p></div></div><div class="pl l"><div class="px l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/container_security_guide/linux_capabilities_and_seccomp" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">第八章。Linux功能和sec comp Red Hat Enterprise Linux Atomic Host 7 | Red Hat客户…</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">名称空间是docker格式的容器所使用的隔离的构建块之一。他们提供了这样一个…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">access.redhat.com</p></div></div><div class="pl l"><div class="py l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="http://www.linux.it/~rubini/docs/ksys/" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">内核系统调用</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">本文是理解kHTTPd如何扮演网络角色的第一步…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">www.linux.it</p></div></div><div class="pl l"><div class="pz l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="http://man7.org/linux/man-pages/man2/unshare.2.html" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">unshare(2) - Linux手册页</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">UNSHARE(2) Linux程序员手册UNSHARE(2)UNSHARE——解除流程执行上下文部分的关联unshare()…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">man7.org</p></div></div><div class="pl l"><div class="qa l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">功能(7) - Linux手册页</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">功能(7) Linux程序员手册功能(7)功能-概述Linux的功能…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">man7.org</p></div></div><div class="pl l"><div class="qb l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://www.redhat.com/en/blog/architecting-containers-part-1-why-understanding-user-space-vs-kernel-space-matters" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">架构容器第1部分:为什么理解用户空间和内核空间很重要</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">也许您负责开发基于容器的应用程序基础设施？如果是这样，你很可能…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">www.redhat.com</p></div></div><div class="pl l"><div class="qc l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/lec/11/lec.html" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">Lec 11:用户空间、内核空间和系统调用API</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">到目前为止，在这个类中，我们还没有直接使用系统调用接口，而是使用了C标准…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">www.usna.edu</p></div></div><div class="pl l"><div class="qd l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://stackoverflow.com/questions/5957570/what-is-the-difference-between-the-kernel-space-and-the-user-space" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">内核空间和用户空间有什么区别？</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">问内核空间和用户空间有什么区别？内核空间、内核线程、内核…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">stackoverflow.com</p></div></div><div class="pl l"><div class="qe l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://stackoverflow.com/questions/6710040/cpu-privilege-rings-why-rings-1-and-2-arent-used" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">CPU特权环:为什么不使用环1和环2？</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">作为一个业余操作系统作家，我发现因为分页(现代保护模型的主要部分)只…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">stackoverflow.com</p></div></div><div class="pl l"><div class="qf l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://en.wikipedia.org/wiki/Protection_ring" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">保护环</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">在计算机科学中，分级保护域，通常称为保护环，是保护数据和数据的机制</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">en.wikipedia.org</p></div></div><div class="pl l"><div class="qg l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch01" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">第一章。控制组(Cgroups)介绍Red Hat Enterprise Linux 6 | Red Hat客户…</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">Red Hat Enterprise Linux 6提供了一个新的内核特性:控制组，用它们的简称来称呼…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">access.redhat.com</p></div></div><div class="pl l"><div class="qh l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="http://man7.org/linux/man-pages/man7/cgroups.7.html" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">cgroups(7) - Linux手册页</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">在cgroups v1下，每个控制器可以安装在一个单独的cgroup文件系统上，该文件系统提供自己的…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">man7.org</p></div></div><div class="pl l"><div class="qi l pn po pp pl pq nh pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/ch12s01.html" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">了解Linux内核，第3版</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">虚拟文件系统(VFS)的作用虚拟文件系统(也称为虚拟文件系统交换机或VFS)是一个…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">www.oreilly.com</p></div></div><div class="pl l"><div class="qj l pn po pp pl pq nh pc"/></div></div></a></div></div></div>    
</body>
</html>