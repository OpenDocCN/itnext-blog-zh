<html>
<head>
<title>It’s Time To Replace ahmetb/go-linq With samber/lo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是时候用samber/lo代替ahmetb/go-linq了</h1>
<blockquote>原文：<a href="https://itnext.io/its-time-to-replace-ahmetb-go-linq-with-samber-lo-e77b3c86ff1?source=collection_archive---------0-----------------------#2022-06-29">https://itnext.io/its-time-to-replace-ahmetb-go-linq-with-samber-lo-e77b3c86ff1?source=collection_archive---------0-----------------------#2022-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0b107420d2c746b27896ba9b1d42973b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlGely8443fKL2vNu4gBIQ.png"/></div></div></figure><p id="3f5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">与Golang一起工作时，我们经常需要操作一组数据。例如过滤、映射、求和等。</p><p id="d3b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管这些操作中的大部分可以用一个简单的“for循环”来完成，但这是相当繁琐的，我们宁愿避免它。</p><p id="36f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Golang1.18之前，我们用<a class="ae li" href="https://github.com/ahmetb/go-linq" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> ahmetb/go-linq </strong> </a>完成工作。</p><p id="573f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Golang1.18发布后，语言中加入了内置的泛型支持，<a class="ae li" href="https://github.com/samber/lo" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> samber/lo </strong> </a>成为了更好的选择。</p><h1 id="ac03" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">关于ahmetb/go-linq</h1><p id="32a4" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">LINQ(language integrated query)是C#中的一个概念，<strong class="kd iu"> ahmetb/go-linq </strong>借用这个思想，用golang重新实现。作为一个库，linq帮助我们提高开发性能。</p><p id="01eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:是“开发性能”，不是“运行时性能”。</p><p id="431c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于缺乏对golang的泛型支持，linq选择反射来支持所有类型的切片。这注定linq不是很有效率。</p><p id="6aaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据作者(ahmetb)的<a class="ae li" href="https://github.com/ahmetb/go-linq/issues/96#issuecomment-997313301" rel="noopener ugc nofollow" target="_blank">反馈</a>，linq不会升级利用golang的内置泛型。</p><p id="42d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Linq </strong>为每个方法提供了两个版本。</p><p id="c1dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个版本使用<code class="fe mm mn mo mp b">interface{}</code>作为参数，用户必须在使用时将其转换为实际类型。</p><p id="99a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个版本是type safer，由<strong class="kd iu"> linq </strong>的作者推荐。但是这是有代价的——类型安全版本要慢得多。</p><p id="e720" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Linq </strong>有一个可链接的API，这使得使用它成为一种乐趣。</p><p id="d26f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在golang1.18之前，<strong class="kd iu"> linq </strong>是最好的选择。</p><h1 id="9cbf" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">关于samber/lo</h1><p id="d0ee" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">引自其主页:</p><blockquote class="mq mr ms"><p id="68c5" class="kb kc mt kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated"><strong class="kd iu"> samber/lo </strong>是基于Go 1.18+泛型的Lodash风格的Go库。</p></blockquote><p id="a3f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">lo的想法来源于著名的JavaScript库<a class="ae li" href="https://github.com/lodash/lodash" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> lodash </strong> </a>。它是100%类型安全的，并且具有更好的性能。编译时检查将有助于我们避免大多数打字错误。所有这些好处从根本上来说都是来自golang仿制药。</p><p id="980f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你检查一下<strong class="kd iu"> lo </strong>和<strong class="kd iu"> linq </strong>的源代码，你会发现<strong class="kd iu"> lo </strong>的源代码比<strong class="kd iu"> linq </strong>要简单得多。这意味着维护和改进<strong class="kd iu"> lo </strong>将比<strong class="kd iu"> linq </strong>容易得多。</p><p id="9f90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">唯一的遗憾是<strong class="kd iu"> lo </strong>没有提供可链接的API，因为它没有引入额外的抽象层。</p><h1 id="3cbe" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">并排比较</h1><p id="fd0c" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">接下来，我会选择几个常见的场景，用<strong class="kd iu">lo</strong>/<strong class="kd iu">linq</strong>/实现函数三次，进行相应的循环。通过这些例子，你会明白如何用不同的方法达到相同的目标。</p><p id="6593" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是一些场景:</p><ul class=""><li id="506a" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">Uniq，从int切片返回唯一元素</li><li id="18c3" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">仅当元素的模数为13时，才从int slice返回元素</li><li id="fd8a" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">映射，将所有元素从int切片转移到string切片</li></ul><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="77f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如上面的源代码所示，<strong class="kd iu"> lo </strong>可以提供最清晰、最简单的解决方案。</p><h1 id="8093" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">基准</h1><p id="d0f4" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">让我们对所有功能进行基准测试。下面是对包含10000个元素的int切片进行基准测试的结果。</p><p id="faf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，<strong class="kd iu"> lo </strong>和“for-loop”函数的性能差不多，而且远远优于<strong class="kd iu"> linq </strong>。</p><ul class=""><li id="fcb2" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">就速度而言，<strong class="kd iu"> lo </strong>比<strong class="kd iu"> linq </strong>快4-80倍</li><li id="66c9" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">至于内存分配，在某些场景下<strong class="kd iu"> lo </strong>比<strong class="kd iu"> linq </strong>好10000倍。</li></ul><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">基准结果</figcaption></figure><h1 id="c7bf" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="0173" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">尽管我们上面举例的情景是不完整的，但不难得出结论:</p><ul class=""><li id="6846" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">lo 可以提供一个更简单的解决方案来实现业务逻辑</li><li id="faa1" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">lo可以提供更好的编译时检查</li><li id="1780" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">lo的性能要好得多</li><li id="92c9" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">在golang1.18发布后用<strong class="kd iu"> lo </strong>替换<strong class="kd iu"> linq </strong>可能是一个明智的决定。</li></ul></div></div>    
</body>
</html>