<html>
<head>
<title>Part 1: A Complete Guide For Building RESTful Applications Using Aqueduct</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分:使用Aqueduct构建RESTful应用程序的完整指南</h1>
<blockquote>原文：<a href="https://itnext.io/part-1-a-complete-guide-for-building-restful-applications-using-aqueduct-668b07f62ad5?source=collection_archive---------2-----------------------#2019-09-05">https://itnext.io/part-1-a-complete-guide-for-building-restful-applications-using-aqueduct-668b07f62ad5?source=collection_archive---------2-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e722d85aee68be0c3908c69b8fc1cf03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCyGl9yS90RTxvALoL3usQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae kc" href="https://stablekernel.com/wp-content/uploads/2017/07/aqueduct-1500x660.png" rel="noopener ugc nofollow" target="_blank">https://stable kernel . com/WP-content/uploads/2017/07/aqueduct-1500 x660 . png</a></figcaption></figure><p id="6408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文是关于使用Aqueduct在Dart中构建RESTful应用程序的系列文章的第一篇。</p><p id="92ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对渡槽及其核心概念不熟悉，下面给出对这些概念的简要介绍。如果你已经熟悉它们，请随意跳到下一部分<a class="ae kc" href="https://medium.com/@zubairehman.work/part-2-a-complete-guide-for-building-restful-applications-using-aqueduct-c58688ab8b8e" rel="noopener"/>(尽管快速刷新一下不会有什么坏处)。</p><h1 id="9f52" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是渡槽？</h1><p id="d346" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Aqueduct是一个HTTP web服务器框架，用于构建用Dart编写的REST应用程序。REST是表述性状态转移的缩写，允许使用HTTP协议进行客户端-服务器交互。每个url被称为<strong class="kf ir"> <em class="me">请求</em> </strong>，而发回的数据被称为<strong class="kf ir"> <em class="me">响应</em> </strong>。</p><p id="0711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RESTful API是一个应用程序编程接口(API)，它使用HTTP请求来获取、上传、发布和删除数据。</p><h1 id="25d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">核心概念</h1><p id="3467" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们继续实现之前，让我们快速浏览一下我们将用来构建RESTful应用程序的核心概念。</p><h2 id="bc14" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated"><strong class="ak">资源</strong></h2><p id="2d31" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">资源是应用程序通过其HTTP API公开的东西。例如，GitHub API公开了组织、存储库、问题和拉请求资源；社交网络API有个人资料、帖子和用户关系。资源被组织成集合(例如，所有帖子)，该集合中的各个资源可以被唯一地标识(例如，单个帖子)。</p><h2 id="fa92" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated"><strong class="ak">路由</strong></h2><p id="faa5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个应用程序为它管理的每个资源公开<strong class="kf ir">和<em class="me">路由</em>和</strong>。路由是匹配请求路径的字符串。资源由HTTP请求的路径来标识。例如，URL <code class="fe mr ms mt mu b">http://example.com/organizations</code>标识服务器<code class="fe mr ms mt mu b">http://example.com</code>上的组织资源集合。路由<code class="fe mr ms mt mu b">/organizations/:id</code>标识单个组织，并且将匹配路径<code class="fe mr ms mt mu b">/organizations/1</code>、<code class="fe mr ms mt mu b">/organizations/2</code>等等。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="1066" class="mf lc iq mu b gy nd ne l nf ng">// Matches /organizations and /organizations/:id<br/>route("/organizations/[:id]")...;<br/><br/>// Matches /organizations/:organizationId/posts <br/>// and /organizations/:organizationsId/posts/:postId<br/>route("/organizations/:organizationsId/posts/[:postId]")...;<br/><br/>// Matches /organizations/:organizationsId/posts <br/>// and /organizations/:organizationsId/notes/:noteId<br/>route("/organizations/:organizationsId/notes/[:noteId]")...;</span></pre><h2 id="e6fa" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated"><strong class="ak">控制器</strong></h2><p id="6e3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">控制器是处理请求的对象。例如，控制器可能从数据库中获取行，并在响应正文中将它们发送给客户端。另一个控制器可能会验证请求的用户名和密码。<em class="me">例如</em>，控制器可以返回一个带有JSON编码的组织列表的200 OK响应。控制器还可以检查请求，以确保其授权头中有正确的凭证。</p><p id="fce5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种风格的控制器。一个<em class="me">e</em><strong class="kf ir">T5】ndpoint控制器 </strong>和一个<strong class="kf ir"> <em class="me">中间件控制器</em> </strong>。</p><ul class=""><li id="39a6" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><strong class="kf ir">端点控制器</strong></li></ul><p id="6246" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="me">端点控制器</em> </strong>对资源或资源集合执行操作，并且总是发送响应。端点控制器<em class="me">通过返回资源状态或改变资源状态来满足</em>请求。您使用端点控制器编写大多数特定于应用程序的逻辑。</p><ul class=""><li id="8636" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><strong class="kf ir">中间件控制器</strong></li></ul><p id="e21e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kf ir"> <em class="me">中间件控制器</em> </strong>对一个请求采取行动，但不负责完成该请求。中间件控制器可以做许多不同的事情，并且通常可以在许多渠道中重用。最常见的情况是，中间件控制器在请求到达端点控制器或发送请求响应之前验证请求，以防止该通道中的任何其他控制器处理请求。</p><blockquote class="nq nr ns"><p id="e7dc" class="kd ke me kf b kg kh ki kj kk kl km kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">一个通道必须正好有一个端点控制器。它前面可以有零个或多个中间件控制器。有关使用的详细信息，请参见<a class="ae kc" href="http://aqueduct.io/docs/http/controller/" rel="noopener ugc nofollow" target="_blank">控制器</a>和<a class="ae kc" href="http://aqueduct.io/docs/http/resource_controller/" rel="noopener ugc nofollow" target="_blank">资源控制器</a>上的指南。</p></blockquote><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="3d7d" class="mf lc iq mu b gy nd ne l nf ng">class Authorizer extends Controller {<br/>  @override<br/>  Future&lt;RequestOrResponse&gt; handle(Request request) async {<br/>    if (isValid(request)) {<br/>      return request;<br/>    }<br/><br/>    return Response.unauthorized();<br/>  }<br/>}</span></pre><h2 id="ecd8" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">频道</h2><p id="49f9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">控制器被链接在一起，形成一系列对请求采取的动作。这些链接在一起的控制器被称为一个<strong class="kf ir"> <em class="me">通道</em> </strong>。例如，通道可以验证请求的凭证，然后通过组合两个控制器来返回组织列表，这两个控制器执行这些操作。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/24ae570abeafc019156eb6435a660268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yv2cRhLMBUdg3RPXrzbg0A.png"/></div></div></figure><h2 id="8c45" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">申请渠道</h2><p id="22b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir"> <em class="me">应用程序通道</em> </strong>是包含应用程序中所有控制器的对象。它指定一个控制器作为接收每个请求的第一控制器，该请求被称为其<strong class="kf ir"> <em class="me">入口点</em> </strong>。控制器被链接到入口点(直接地或过渡地)以形成整个应用程序通道。几乎在每个应用中，入口点都是路由器；该控制器将信道分成给定路由的子信道。</p><p id="f406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序通道还负责初始化应用程序的服务、读取配置文件和其他与启动相关的任务。</p><blockquote class="nq nr ns"><p id="8652" class="kd ke me kf b kg kh ki kj kk kl km kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">详见<a class="ae kc" href="http://aqueduct.io/docs/application/channel/" rel="noopener ugc nofollow" target="_blank">申请通道</a>上的指南。</p></blockquote><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="a54e" class="mf lc iq mu b gy nd ne l nf ng">class AppChannel extends ApplicationChannel {<br/>  @override<br/>  Controller get entryPoint {<br/>    final router = new Router();<br/><br/>    router<br/>      .route("/users")<br/>      .link(() =&gt; Authorizer())<br/>      .link(() =&gt; UserController());<br/><br/>    return router;<br/>  }<br/>}</span></pre><h2 id="12e3" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">服务</h2><p id="46be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个<strong class="kf ir"> <em class="me">服务</em> </strong>是一个对象，它封装了复杂的任务或算法、外部通信或跨应用程序重用的任务。服务对象的主要用户是控制器。控制器通常需要从应用程序外部获取(或创建)信息。最常见的例子是数据库访问、另一个REST API、连接的设备等。</p><p id="11f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kf ir"> <em class="me">服务对象</em> </strong>封装了与外部系统协同工作所需的信息和行为，并通过将它们作为参数传递给控制器的构造函数来注入控制器。控制器保存对服务的引用，以便在处理请求时可以使用它。</p><blockquote class="nq nr ns"><p id="daa3" class="kd ke me kf b kg kh ki kj kk kl km kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">有关注入服务的更多详细信息，请参见<a class="ae kc" href="http://aqueduct.io/docs/application/channel/" rel="noopener ugc nofollow" target="_blank">应用程序通道</a>上的指南。</p></blockquote><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="d341" class="mf lc iq mu b gy nd ne l nf ng">class AppChannel extends ApplicationChannel {<br/>  PostgreSQLConnection database;<br/><br/>  @override<br/>  Future prepare() async {<br/>    database = PostgreSQLConnection();<br/>  }<br/><br/>  @override<br/>  Controller get entryPoint {<br/>    final router = new Router();<br/><br/>    router<br/>      .route("/users")<br/>      .link(() =&gt; new Authorizer())<br/>      .link(() =&gt; new UserController(database));<br/><br/>    return router;<br/>  }<br/>}</span></pre><h2 id="4134" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">孤立者</h2><p id="48a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir"> <em class="me">隔离</em> </strong>是内存隔离的线程；在一个隔离上创建的对象不能被另一个隔离引用。当应用程序启动时，会产生一个或多个包含应用程序代码副本的隔离区。这种行为有效地在多个线程之间“负载平衡”了您的应用程序。</p><p id="7ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种结构的一个好处是每个隔离都有自己的一组服务，比如数据库连接。这消除了对“数据库连接池”等技术的需要，因为整个应用程序被有效地“池化”。</p><h2 id="fa7a" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">粘合剂</h2><p id="735f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">请求可能包含需要在控制器代码中解析、验证和使用的头部、查询参数、主体和路径参数。<strong class="kf ir"> <em class="me">绑定</em> </strong>是添加到变量中的注释，自动执行这种解析和验证。当绑定值无法解析为预期类型或验证失败时，会发送适当的错误响应。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="830d" class="mf lc iq mu b gy nd ne l nf ng">// Path Variable<br/>@Bind.path(pathVariableName)</span><span id="127e" class="mf lc iq mu b gy nx ne l nf ng">// URL Query Parameter <!-- -->@Bind.query(queryParameterName)<!-- -->Header<!-- -->@Bind.header(headerName)</span><span id="c5e2" class="mf lc iq mu b gy nx ne l nf ng">// Request Body<br/>@Bind.body()</span></pre><h2 id="0b07" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">查询和数据模型</h2><p id="c2ca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">手工编写数据库<strong class="kf ir"> <em class="me">查询</em> </strong>容易出错，并且没有利用静态分析工具。Aqueduct的ORM(对象关系映射)提供了易于编写和测试的静态类型查询。</p><p id="9798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序的数据模型是通过创建Dart类来定义的。每个类都映射到一个数据库表，该类的每个属性都映射到该表中的一列。Aqueduct的命令行工具可以生成数据库迁移文件，这些文件可以检测数据模型中的变化，这些变化可以应用于实时的版本化数据库。数据模型也可以表示为JSON对象，以便在应用程序之上构建工具。</p><blockquote class="nq nr ns"><p id="f435" class="kd ke me kf b kg kh ki kj kk kl km kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">有关更多详细信息，请参见关于<a class="ae kc" href="http://aqueduct.io/docs/db/" rel="noopener ugc nofollow" target="_blank">数据库</a>的指南。</p></blockquote><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="7df8" class="mf lc iq mu b gy nd ne l nf ng">// This is a table definition of an 'article'<br/>class _Article {<br/>  @Column(primaryKey: true)<br/>  int id;<br/><br/>  String contents;<br/><br/>  @Column(indexed: true)<br/>  DateTime publishedDate;<br/>}</span></pre><h2 id="1d81" class="mf lc iq bd ld mg mh dn lh mi mj dp ll ko mk ml lp ks mm mn lt kw mo mp lx mq bi translated">批准</h2><p id="21b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">OAuth 2.0是一个标准化的授权框架。Aqueduct包含一个OAuth 2.0服务器的符合规范的实现，可以直接集成到您的应用程序中。这种实现很容易定制——它可以在不同类型的数据库中存储授权工件，如令牌和客户端标识符，或者使用无状态授权机制，如JWT。默认实现利用Aqueduct ORM在PostgreSQL中存储工件。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/a2de2899eb6b4d6e70c3ea60dc0cb1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-fWaL42hLKZXR5prlNx5g.png"/></div></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="d466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！欢迎在LinkedIn <a class="ae kc" href="https://www.linkedin.com/in/zubairehman/" rel="noopener ugc nofollow" target="_blank"> @zubairehman </a>或在下面的回复中打招呼或分享你的想法！</p><h1 id="4da4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">下一篇文章</h1><p id="75f9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">故事还没有结束，在下一篇文章中，我们将学习如何使用aqueduct配置和构建我们的第一个API，敬请关注:)</p><p id="022f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的其他部分:</p><ul class=""><li id="5b8d" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">第1部分:使用Aqueduct构建RESTful应用程序的完整指南(核心概念)</li><li id="4885" class="nh ni iq kf b kg og kk oh ko oi ks oj kw ok la nm nn no np bi translated"><a class="ae kc" href="https://medium.com/@zubairehman.work/part-2-a-complete-guide-for-building-restful-applications-using-aqueduct-c58688ab8b8e" rel="noopener">第2部分:使用Aqueduct构建RESTful应用程序的完整指南(应用程序开发)</a></li><li id="c702" class="nh ni iq kf b kg og kk oh ko oi ks oj kw ok la nm nn no np bi translated">第3部分:使用Aqueduct构建RESTful应用程序的完整指南(DB配置，即将推出)</li></ul><h1 id="4179" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">有用的资源</h1><p id="c179" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae kc" href="http://aqueduct.io/docs/" rel="noopener ugc nofollow" target="_blank">http://aqueduct.io/docs/</a></p><p id="d3ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="me">这篇文章到此为止，如果你喜欢这篇文章，别忘了拍手👏尽可能多的表达你的支持，留下你的评论并与你的朋友分享。</em>T11】</strong></p></div></div>    
</body>
</html>