<html>
<head>
<title>Health checks for Kafka Streams application on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes上Kafka Streams应用程序的运行状况检查</h1>
<blockquote>原文：<a href="https://itnext.io/health-checks-for-kafka-streams-application-on-kubernetes-e9c5e8c21b0d?source=collection_archive---------0-----------------------#2019-10-24">https://itnext.io/health-checks-for-kafka-streams-application-on-kubernetes-e9c5e8c21b0d?source=collection_archive---------0-----------------------#2019-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f045" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个由三部分组成的博客系列，涵盖了Kafka Streams在Kubernetes上的应用</p><ul class=""><li id="3a0a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">第1部分— <a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/learn-how-to-develop-a-kafka-streams-application-for-data-processing-and-deploy-it-to-kubernetes-231d4cbb0688">如何在Kubernetes上运行Kafka Streams应用程序</a></li><li id="e200" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">第2部分— <a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kubernetes-to-deploy-stateful-kafka-streams-applications-872c77f03c3a">如何在Kubernetes上运行有状态的Kafka Streams应用程序</a></li><li id="4255" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">第3部分—这篇博文</li></ul></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="6181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的博客中，我们探索了如何使用Kubernetes原语运行由Kafka Streams支持的有状态流处理应用。权力越大，责任越大！如果你使用<a class="ae ku" href="https://kafka.apache.org/23/documentation/streams/developer-guide/interactive-queries#interactive-queries" rel="noopener ugc nofollow" target="_blank">交互式查询</a>和一个有状态的Kafka Streams应用程序，你需要注意这样一个事实:如果你的实例正在从changelog主题中重新平衡/恢复/调整它的本地状态，那么本地状态存储并不处于可查询状态。</p><p id="8a74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用Kubernetes <a class="ae ku" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#probe-v1-core" rel="noopener ugc nofollow" target="_blank">探测器</a>来配置您的应用程序并妥善处理这个问题。</p><h1 id="5aa1" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">就绪探测</h1><p id="fcf8" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">Kubernetes使用就绪探测器来检测容器何时准备好开始接受流量。将此应用到Kafka Streams应用程序将确保只有在满足某些(用户定义的)标准后，应用程序实例才会注册到Kubernetes <code class="fe mk ml mm mn b">Service</code>。如果一个实例由于重新平衡而不可用，它的REST端点将不会暴露给客户端(通过<code class="fe mk ml mm mn b">Service</code>)进行交互查询。</p><blockquote class="mo mp mq"><p id="4e98" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><em class="iq">此时，只有您的应用程序的部分状态可以通过通过准备就绪探测的实例进行查询</em></p></blockquote><p id="294e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">容器启动后，Kubernetes将在触发准备就绪探测前等待<code class="fe mk ml mm mn b">initialDelaySeconds</code>中指定的持续时间，并在每隔<code class="fe mk ml mm mn b">periodSeconds</code>后重复一次，直到成功或超时(<code class="fe mk ml mm mn b">timeoutSeconds</code>)。</p><h1 id="22b8" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">活性探针</h1><p id="a76b" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">即使在你的Kafka Streams应用程序(及其所有实例)启动并运行后，由于多种原因——成员加入、离开等，可能会有重新平衡。在这种情况下，您可能希望从交互式查询的角度检查实例是否处于就绪状态。您可以配置一个活跃度探测器，就像它的准备就绪对应物一样(甚至为它们使用相同的机制，例如<code class="fe mk ml mm mn b">/health</code>端点),并且它的工作方式也是相同的(除了当探测器失败时会发生什么)</p><blockquote class="mo mp mq"><p id="d395" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><em class="iq"> Kubernetes v1.16增加了一个</em> <code class="fe mk ml mm mn b"><a class="ae ku" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe" rel="noopener ugc nofollow" target="_blank"><em class="iq">Startup Probe</em></a></code> <em class="iq">，可以用来检查容器进程是否已经启动。它可以与活跃度和就绪性探测器一起使用，但值得一提的是，如果进行了配置，它会禁用活跃度和就绪性检查，直到成功，确保这些探测器不会干扰应用程序的启动</em></p></blockquote><h1 id="794b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">探针配置</h1><p id="135f" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">要使这些探测器工作，您需要:</p><ul class=""><li id="d11f" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">实施检查机制，以及</li><li id="6155" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">在Kubernetes ( <code class="fe mk ml mm mn b">StatefulSet</code>)清单中配置探测器</li></ul><blockquote class="mo mp mq"><p id="ea30" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><em class="iq">为了进行测试，您可以按照下面提到的步骤</em>更新 <a class="ae ku" href="https://dev.to/azure/learn-about-the-kubernetes-components-required-to-run-stateful-kafka-streams-applications-44jl" rel="noopener ugc nofollow" target="_blank"> <em class="iq">有状态Kafka流</em> </a> <em class="iq">中的应用程序</em></p></blockquote><h1 id="d728" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">探测器的运行状况检查端点</h1><p id="f814" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">Kubernetes支持HTTP端点、TCP套接字和任意命令执行作为健康检查探针。对于我们的Kafka Streams应用程序，就健康检查而言，通过REST端点公开状态存储状态信息非常有意义</p><pre class="mv mw mx my gt mz mn na nb aw nc bi"><span id="772f" class="nd li iq mn b gy ne nf l ng nh">@GET("health")<br/>public Response health() {<br/>    Response healthCheck = null;<br/>    KafkaStreams.State streamsAppState = KafkaStreamsBootstrap.getKafkaStreamsState();<br/>    if (streamsAppState.name().equals(RUNNING_STATE)) {<br/>        healthCheck = Response.ok().build();<br/>    } else {<br/>        healthCheck = Response.status(Response.Status.SERVICE_UNAVAILABLE)<br/>                .entity(streamsAppState.name())<br/>                .build();<br/>    }<br/>    return healthCheck;<br/>}</span></pre><h1 id="3631" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">探测器配置清单</h1><p id="22dc" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">下面是就绪探测器的样子(同样适用于活动探测器)</p><pre class="mv mw mx my gt mz mn na nb aw nc bi"><span id="b65c" class="nd li iq mn b gy ne nf l ng nh">readinessProbe:<br/>      httpGet:<br/>        path: /health<br/>        port: 8080<br/>      initialDelaySeconds: 15<br/>      periodSeconds: 5<br/>      timeoutSeconds: 2<br/>      failureThreshold: 5</span></pre><p id="ea74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这些调查将缓解问题，但在处理Kafka Streams应用程序(尤其是)时，您应该注意一些极端情况。涉及大量有状态计算的。</p><h1 id="ae03" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">警告</h1><p id="431f" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">您的Kafka Streams状态可能非常大，以至于它的重新平衡可能会超出就绪性和/或活性探测器指定的阈值/约束。以下是在这些情况下可能发生的情况:</p><ul class=""><li id="f991" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">就绪探测被破坏:在Kubernetes停止执行之前，该探测将考虑<code class="fe mk ml mm mn b">failureThreshold</code>计数，并将Pod标记为<code class="fe mk ml mm mn b">Unready</code>，从而使其不可用。</li><li id="6c38" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">活性探测器被破坏:在这种情况下，Kubernetes在<code class="fe mk ml mm mn b">failureThreshold</code>后重启Pod。因此，您的应用程序可能会陷入一个试图恢复状态的循环中，但是由于Kubernetes重新启动(由于探测)Pod，它会被中断(并且它必须重新开始！)</li></ul><h1 id="026c" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">可能的解决方案</h1><p id="01fa" class="pw-post-body-paragraph jn jo iq jp b jq mf js jt ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk ij bi translated">如果与Kafka Streams应用程序相关的状态存储在外部(例如，<code class="fe mk ml mm mn b">PersistentVolume</code>由持久的云存储支持)，则可以在很大程度上避免冗长的重新平衡</p><blockquote class="mo mp mq"><p id="f6d5" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kubernetes-to-deploy-stateful-kafka-streams-applications-872c77f03c3a"> <em class="iq">本博客</em> </a> <em class="iq">详细介绍了</em></p></blockquote><p id="0f27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个关键点是测试您的应用程序，注意它的状态以及恢复/重新平衡/调整状态可能需要的时间。然后，您可以做出明智的决定并调整探头配置参数(<code class="fe mk ml mm mn b">failureThreshold</code>、<code class="fe mk ml mm mn b">initialDelaySeconds</code>等)。)相应地，这样您的应用程序就有足够的时间在您使用探针之前实际执行恢复过程！</p><p id="6464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以配置您的Kafka Streams应用程序，使其拥有本地状态的备用副本(使用<code class="fe mk ml mm mn b">num.standby.replicas</code>配置)，这些副本是状态的完全复制副本。当重新平衡被触发时，Kafka Streams将尝试将任务分配给已经存在这种备用副本的实例，以最小化任务(重新)初始化成本。</p><p id="88a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该考虑在Kubernetes的未来版本中使用Startup probe(一旦稳定下来)</p><p id="7ed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">暂时就这样了。我真的希望你喜欢这篇文章，并从中学到了一些东西。如果你做了，请喜欢并跟随。很高兴通过<a class="ae ku" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> Twitter </a>获得反馈或发表评论！</p></div></div>    
</body>
</html>