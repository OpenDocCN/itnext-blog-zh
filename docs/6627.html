<html>
<head>
<title>A tentative comparison of fault tolerance libraries on the JVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JVM上容错库的初步比较</h1>
<blockquote>原文：<a href="https://itnext.io/comparison-of-fault-tolerance-libraries-f9f58b45fe2f?source=collection_archive---------3-----------------------#2022-01-09">https://itnext.io/comparison-of-fault-tolerance-libraries-f9f58b45fe2f?source=collection_archive---------3-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/44586817d6d88f0a8d9dd32405f2c4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyDjG9oC2DPKRKGEVd2sJw.jpeg"/></div></div></figure><p id="7178" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您是否正在实现微服务，都有可能调用HTTP端点。使用HTTP调用，很多事情都会出错。有经验的开发人员会为此进行规划，并设计出超越快乐路径的东西。一般来说，容错包括以下功能:</p><ul class=""><li id="1014" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">重试</li><li id="b965" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">超时</li><li id="61dd" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">断路器</li><li id="fbd5" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">撤退</li><li id="bdd1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">避免服务器端429响应的速率限制器</li><li id="0198" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">隔板:速率限制器限制在一个确定的时间范围内调用的数量，而隔板限制并发调用的数量</li></ul><p id="eb05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几个库在JVM上实现了这些特性。在本帖中，我们将关注微文件容错、<a class="ae lk" href="https://failsafe.dev/" rel="noopener ugc nofollow" target="_blank">故障安全</a>和Resilience4J。</p><h1 id="b259" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">微文件容错</h1><p id="c83d" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><a class="ae lk" href="https://download.eclipse.org/microprofile/microprofile-fault-tolerance-1.1.2/microprofile-fault-tolerance-spec.html" rel="noopener ugc nofollow" target="_blank">微文件容错</a>来自微文件保护伞项目。它与其他两个不同，因为它是一个<em class="mo">规范</em>，依赖运行时来提供它的功能。例如，Open Liberty就是这样一个运行时。<a class="ae lk" href="https://smallrye.io/docs/smallrye-fault-tolerance/5.2.1/index.html" rel="noopener ugc nofollow" target="_blank"> SmallRye容错</a>又是一个。反过来，其他组件如Quarkus和WildFly嵌入了SmallRye。</p><p id="9fb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微文件为每个特征定义了<em class="mo">注释</em>:<code class="fe mp mq mr ms b">@Timeout</code>、<code class="fe mp mq mr ms b">@Retry Policy</code>、<code class="fe mp mq mr ms b">@Fallback</code>、<code class="fe mp mq mr ms b">@Circuit Breaker</code>和<code class="fe mp mq mr ms b">@Bulkhead</code>。它还定义了<code class="fe mp mq mr ms b">@Asynchronous</code>。</p><p id="4317" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为运行时读取批注，所以应该仔细阅读文档，以了解如果设置了多个批注，它们是如何交互的。</p><blockquote class="mt mu mv"><p id="0cfb" class="jy jz mo ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><em class="iq">可以指定一个</em> <code class="fe mp mq mr ms b"><em class="iq">@Fallback</em></code> <em class="iq">，如果抛出</em> <code class="fe mp mq mr ms b"><em class="iq">TimeoutException</em></code> <em class="iq">就会被调用。如果</em> <code class="fe mp mq mr ms b"><em class="iq">@Timeout</em></code> <em class="iq">与</em> <code class="fe mp mq mr ms b"><em class="iq">@Retry</em></code> <em class="iq">一起使用，则</em> <code class="fe mp mq mr ms b"><em class="iq">TimoutException</em></code> <em class="iq">会触发重试。当</em> <code class="fe mp mq mr ms b"><em class="iq">@Timeout</em></code> <em class="iq">与</em> <code class="fe mp mq mr ms b"><em class="iq">@CircuitBreaker</em></code> <em class="iq">一起使用时，如果出现</em> <code class="fe mp mq mr ms b"><em class="iq">TimeoutException</em></code> <em class="iq">，故障将导致电路开路。</em></p><p id="fd56" class="jy jz mo ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae lk" href="https://download.eclipse.org/microprofile/microprofile-fault-tolerance-1.1.2/microprofile-fault-tolerance-spec.html#_timeout_usage" rel="noopener ugc nofollow" target="_blank"> <em class="iq">超时用法</em> </a></p></blockquote><h1 id="5752" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">弹性4J</h1><p id="b78d" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">当我在谈论断路器模式时，我偶然发现了Resilience4J。这个演讲包括一个演示，它依赖于<a class="ae lk" href="https://github.com/Netflix/Hystrix" rel="noopener ugc nofollow" target="_blank"> Hystrix </a>。有一天，我想将演示更新到最新的Hystrix版本，并注意到维护人员已经弃用它而支持Resilience4J。</p><p id="4a98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Resilience4J基于几个核心概念:</p><ul class=""><li id="becb" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">每个容错特性一个JAR，附加JAR用于特定集成，<em class="mo">，例如</em>，Kotlin</li><li id="4ff4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">静态工厂</li><li id="5266" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">通过<em class="mo">装饰模式</em>应用于函数的函数组合</li><li id="adf1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">与Java的功能接口<em class="mo">集成，如</em>、<code class="fe mp mq mr ms b">Runnable</code>、<code class="fe mp mq mr ms b">Callable</code>、<code class="fe mp mq mr ms b">Function</code>等。</li><li id="a682" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">异常传播:可以使用抛出异常的函数接口，库将在调用管道中传播异常</li></ul><p id="20e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个<code class="fe mp mq mr ms b">Retry</code>的简化类图。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/44ddab811d38a040c2055a72c32a2f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FjQorWz3V0mlkEUEYNrvvA.png"/></div></div></figure><p id="ac63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个容错特性都是围绕上面看到的相同模板构建的。通过利用函数组合，可以创建几个特性的管道，每个特性调用另一个特性。</p><p id="8f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们分析一个样本:</p><pre class="na nb nc nd gt ne ms nf ng aw nh bi"><span id="982c" class="ni lm iq ms b gy nj nk l nl nm">var retrySupplier = Retry.decorateSupplier(                     // 1<br/>    Retry.ofDefaults("retry"),                                  // 2<br/>    () -&gt; server.call()                                         // 1<br/>);<br/>var config = new CircuitBreakerConfig.Builder()                   // 3<br/>        .slowCallDurationThreshold(Duration.ofMillis(200))      // 4<br/>        .slidingWindowSize(2)                                   // 5<br/>        .minimumNumberOfCalls(2)                                // 6<br/>        .build();<br/>var breakerSupplier = CircuitBreaker<br/>.of("circuit-breaker", config)                                   // 7                                    .decorateSupplier(retrySupplier);                               // 7<br/>supplier = SupplierUtils.recover(                               // 8<br/>    breakerSupplier,<br/>    List.of(<br/>        IllegalStateException.class,<br/>        CallNotPermittedException.class),                       // 9<br/>    e -&gt; "fallback"                                            // 10<br/>);</span></pre><ol class=""><li id="967a" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated">用<code class="fe mp mq mr ms b">Retry</code>修饰基本<code class="fe mp mq mr ms b">server.call()</code>功能:该功能是需要保护的功能</li><li id="eeb4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">使用默认配置</li><li id="4c80" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">创建一个新的<em class="mo">断路器</em>配置</li><li id="ef84" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">设置阈值，高于该阈值的呼叫将被视为慢速呼叫</li><li id="1173" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">在2个呼叫的滑动窗口内计数</li><li id="71b8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">决定是否打开<em class="mo">断路器</em>的最小呼叫次数</li><li id="1375" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">用具有上述配置的<em class="mo">断路器</em>装饰重试功能</li><li id="4149" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">创建一个当<em class="mo">断路器</em>打开时返回的回退值</li><li id="03b4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">要处理的异常列表:它们不会被传播。当电路断开时，Resilience4J抛出一个<code class="fe mp mq mr ms b">CallNotPermittedException</code>。</li><li id="273d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">如果抛出任何已配置的异常，请调用此函数</li></ol><p id="6416" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数的组合顺序可能很难理解。因此，该项目提供了<code class="fe mp mq mr ms b">Decorators</code>类来使用fluent API组合函数。你可以在<code class="fe mp mq mr ms b">resilience4j-all</code>模块中找到它。人们可以将上面的代码重写为:</p><pre class="na nb nc nd gt ne ms nf ng aw nh bi"><span id="3285" class="ni lm iq ms b gy nj nk l nl nm">var pipeline = Decorators.ofSupplier(() -&gt; server.call())<br/>    .withRetry(Retry.ofDefaults("retry"))<br/>    .withCircuitBreaker(CircuitBreaker.of("circuit-breaker", config))<br/>    .withFallback(<br/>        List.of(<br/>            IllegalStateException.class,<br/>            CallNotPermittedException.class),<br/>        e -&gt; "fallback"<br/>    );</span></pre><p id="76d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得意图更加清晰。</p><h1 id="443c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">破损安全</h1><p id="d800" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">不久前我偶然发现了故障保护。它的原则类似于Resilience4J:静态工厂、函数组合和异常传播。</p><p id="aefd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然Resilience4J容错特性不共享类层次结构，但Failsafe提供了<code class="fe mp mq mr ms b">Policy</code>的概念:</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/25e5a397d8e35eb2236f74befbad5832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qa7z0NNoYfgbkj-3o45Jg.png"/></div></div></figure><p id="f544" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为Resilience4J的主要区别在于它的流水线方法。Resilience4J的API要求您首先提供“基本”函数，然后将它嵌入到任何包装器函数中。您不能在不同的基础函数上重用管道。故障安全通过<code class="fe mp mq mr ms b">FailsafeExecutor</code>类允许它。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/481d6aa2d08d5884b2db33f106f8a9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAJsVhdo-RDpycvizlbKxQ.png"/></div></div></figure><p id="a000" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是如何创建一个管道，<em class="mo">即</em>，一个<code class="fe mp mq mr ms b">FailsafeExecutor</code>的实例。<br/>注意这里没有对基本调用的引用:</p><pre class="na nb nc nd gt ne ms nf ng aw nh bi"><span id="7434" class="ni lm iq ms b gy nj nk l nl nm">var pipeline = Failsafe.with(                            // 1<br/>    Fallback.of("fallback"),                             // 2<br/>    Timeout.ofDuration(Duration.of(2000, MILLIS)),       // 3<br/>    RetryPolicy.ofDefault()                              // 4<br/>);</span></pre><ol class=""><li id="d498" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated">按顺序定义从最后到第一个应用的策略列表</li><li id="c4f9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">后备值</li><li id="4fd8" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">如果调用超过2000毫秒，抛出<code class="fe mp mq mr ms b">TimeoutExceededException</code></li><li id="79be" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">默认重试策略</li></ol><p id="b1b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，可以结束通话了:</p><pre class="na nb nc nd gt ne ms nf ng aw nh bi"><span id="da49" class="ni lm iq ms b gy nj nk l nl nm">pipeline.get(() -&gt; server.call());</span></pre><p id="9484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Failsafe还提供了流畅的API。人们可以将上面的代码重写为:</p><pre class="na nb nc nd gt ne ms nf ng aw nh bi"><span id="aaec" class="ni lm iq ms b gy nj nk l nl nm">var pipeline = Failsafe.with(Fallback.of("fallback"))<br/>    .compose(RetryPolicy.ofDefault())<br/>    .compose(Timeout.ofDuration(Duration.of(2000, MILLIS)));</span></pre><h1 id="bf9a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="ec5b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这三个库提供了或多或少相同的特性。如果您不使用CDI兼容的运行时，比如常规的应用服务器或Quarkus，请忘记微概要文件容错。</p><p id="2997" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Failsafe和Resilience4J都基于函数组合，非常相似。如果您需要独立于基调用来定义函数管道，请选择Failsafe。否则，随便挑一个。</p><p id="0d2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我更熟悉Resilience4J，我可能会在我的下一个项目中使用Failsafe来获得更多的经验。</p><p id="d33b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="ba68" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae lk" href="https://download.eclipse.org/microprofile/microprofile-fault-tolerance-1.1.2/microprofile-fault-tolerance-spec.html" rel="noopener ugc nofollow" target="_blank">微文件容错规范</a></li><li id="ba9e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://smallrye.io/docs/smallrye-fault-tolerance/5.0.0/index.html" rel="noopener ugc nofollow" target="_blank"> SmallRye容错文档</a></li><li id="773a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://resilience4j.readme.io/docs" rel="noopener ugc nofollow" target="_blank">resilience 4j简介</a></li><li id="7a5d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae lk" href="https://failsafe.dev/" rel="noopener ugc nofollow" target="_blank">故障保护概述</a></li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="6288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">原载于</em> <a class="ae lk" href="https://blog.frankel.ch/comparison-fault-tolerance-libraries/" rel="noopener ugc nofollow" target="_blank"> <em class="mo">一个Java怪胎</em></a><em class="mo">2022年1月7日</em></p></div></div>    
</body>
</html>