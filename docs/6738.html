<html>
<head>
<title>How ranges work in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中范围的工作方式</h1>
<blockquote>原文：<a href="https://itnext.io/how-ranges-work-in-swift-572cdec620e9?source=collection_archive---------5-----------------------#2022-02-14">https://itnext.io/how-ranges-work-in-swift-572cdec620e9?source=collection_archive---------5-----------------------#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8c295a9344eaf043f378d8b09b0ae26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvyYNEhgadhAGwDvk8tGrw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sidseverin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西德尼·塞弗林</a>在<a class="ae kc" href="https://unsplash.com/s/photos/range?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f59a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Ranges家族的类型似乎不会给我们带来惊喜，但是它们隐藏了实现中令人兴奋的地方。</p><p id="b831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Swift标准库有一系列我们习惯使用的范围类型，例如:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6e2b" class="lk ll iq lg b gy lm ln l lo lp">let array: Array&lt;Int&gt; = [0, 1, 2, 3, 4, 5]<br/>array[...3]<br/>array[...]<br/>for i in 1..&lt;4 {<br/>  print(i)<br/>}</span></pre><p id="503d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们习惯于操作像<code class="fe lq lr ls lg b">[1, 2, 3]</code>或<code class="fe lq lr ls lg b">[1:2, 3:4]</code>或<code class="fe lq lr ls lg b">"some string"</code>这样的文字。我们可以声明我们的范围为let<code class="fe lq lr ls lg b">r = 2..&lt;4</code>。它看起来像一个文字，但它是一个二元运算符<code class="fe lq lr ls lg b">..&lt;</code>，有两个参数作为输入，一个范围作为输出(范围的具体类型取决于运算符——二元运算符<code class="fe lq lr ls lg b">1...10</code>和<code class="fe lq lr ls lg b">1..&lt;10</code>，一元运算符<code class="fe lq lr ls lg b">...10</code>、<code class="fe lq lr ls lg b">..&lt;10</code>和<code class="fe lq lr ls lg b">1...</code>)</p><p id="af6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管系列产品的类型有相似之处，但所有产品在实施方面都有显著差异。然而，乍一看，似乎唯一的区别是如何指定范围的边界。</p><p id="783e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们了解一下Range是如何工作的。</p><h1 id="4c1d" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak"> RangeExpression协议</strong></h1><p id="1386" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">Swift中几乎所有的Range类型都有一个共同点:都符合<em class="mv"> RangeExpression </em>协议(除了<em class="mv">unboutedrange</em>)。该协议有两种能力:</p><ul class=""><li id="9719" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">首先，它可以检查一个元素是否包含在一个范围内(<em class="mv">包含</em>函数)</li><li id="5b55" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">第二个功能可以将任意量程类型(<em class="mv">partial Range up到</em>、<em class="mv"> PartialRangeThrough </em>、<em class="mv"> PartialRangeFrom </em>、<em class="mv"> ClosedRange </em>)转换为通用<em class="mv">量程</em>类型(<em class="mv">相对于</em>功能)</li></ul><p id="2fe0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为什么需要它？如你所知，我们可以通过下标来引用集合。例如:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ce91" class="lk ll iq lg b gy lm ln l lo lp">let array = [0, 1, 2, 3, 4, 5, 6, 7, 8]<br/>array[1..&lt;3] <em class="mv">// operator 1..&lt;3 returns Range&lt;Int&gt;(lowerBound: 1, upperBound: 3), which we pass as input to the subscript</em><br/>array[..&lt;3] // PartialRangeUpTo&lt;Int&gt;<br/>array[...3] // PartialRangeThrough&lt;Int&gt;<br/>array[1...3] // ClosedRange&lt;Int&gt;<br/>array[1...] // PartialRangeFrom&lt;Int&gt;</span></pre><p id="50b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在所有这些例子中，不同的范围类型被传递给下标，所以在每个集合中为每种范围族实现一个下标是不好的。</p><p id="6f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入下标接受<em class="mv"> RangeExpression </em>协议。在执行下标之前，集合调用协议上的<em class="mv">相对</em>函数，将结果范围(<em class="mv"> PartialRangeUpTo </em>，<em class="mv"> PartialRangeThrough </em>，<em class="mv"> PartialRangeFrom </em>，<em class="mv"> ClosedRange </em>)转换为通用<em class="mv">范围</em>类型。</p><p id="36d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有一个特性，我们不能绝对地将任何类型的范围系列转换为<em class="mv">范围</em>类型。例如，在输出端，我们无法提交<code class="fe lq lr ls lg b">obj1...obj2</code>并获得通用的<em class="mv">范围</em> <code class="fe lq lr ls lg b">obj1..&lt;obj3</code>(其中<em class="mv"> obj3 </em>是跟随<em class="mv"> obj2 </em>的对象)，因为我们不知道哪个对象在<em class="mv"> obj2 </em>之后。但是，如果<em class="mv">绑定的</em>是<em class="mv">集合</em>协议中的一个索引，我们仍然可以识别以下元素</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="60a9" class="lk ll iq lg b gy lm ln l lo lp">func relative&lt;C: Collection&gt;(    to collection: C  ) -&gt; Range&lt;Bound&gt; where C.Index == Bound</span></pre><p id="4460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们可以调用<em class="mv">collection . index(after:)</em>，找出下一个元素返回标准<em class="mv">范围</em>。</p><h1 id="6b79" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">范围</h1><p id="ed8c" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">主范围结构非常简单:两个字段存储在下限和上限结构中。</p><p id="941e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的最低要求是这些字段必须是可比较的类型。<code class="fe lq lr ls lg b">public struct Range&lt;Bound: Comparable&gt;</code>。让我提醒你<em class="mv">可比</em>反过来符合<em class="mv">公平</em>协议。假设您想要实现符合<em class="mv">可比</em>的结构。在这种情况下，你必须至少实现<code class="fe lq lr ls lg b">&lt;</code>操作符(如果你的结构不满足自动合成<em class="mv">等价</em>的要求，那么你也必须实现<code class="fe lq lr ls lg b">==</code>操作符)。其余运算符<code class="fe lq lr ls lg b">&gt;</code>、<code class="fe lq lr ls lg b">&lt;=</code>、<code class="fe lq lr ls lg b">&gt;=</code>默认基于<code class="fe lq lr ls lg b">&lt;</code>运算符实现。因此，您可以创建自己的结构:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d789" class="lk ll iq lg b gy lm ln l lo lp">+---------+---------------+<br/>|  Body   | Diameter (km) |<br/>+---------+---------------+<br/>| Sun     |     1,391,000 |<br/>| Mercury |         4,880 |<br/>| Venus   |        12,104 |<br/>| Earth   |        12,756 |<br/>| Mars    |         6,794 |<br/>| Jupiter |       142,984 |<br/>| Saturn  |       120,536 |<br/>| Uranus  |        51,118 |<br/>| Neptune |        49,532 |<br/>+---------+---------------+</span><span id="f45e" class="lk ll iq lg b gy nk ln l lo lp"><strong class="lg ir">struct</strong> Planet: Comparable {<br/>  <strong class="lg ir">static</strong> <strong class="lg ir">func</strong> &lt; (lhs: Planet, rhs: Planet) -&gt; Bool {<br/>    <strong class="lg ir">return</strong> lhs.diameterKm &lt; rhs.diameterKm<br/>  }<br/>  <strong class="lg ir">let</strong> name: String<br/>  <strong class="lg ir">let</strong> diameterKm: Double<br/>}</span><span id="a093" class="lk ll iq lg b gy nk ln l lo lp"><strong class="lg ir">let</strong> mercury = Planet(name: "Mercury", diameterKm: 4880)<br/><strong class="lg ir">let</strong> earth = Planet(name: "Earth", diameterKm: 12756)<br/><strong class="lg ir">let</strong> neptune = Planet(name: "Neptune", diameterKm: 49532)<br/><strong class="lg ir">let</strong> jupiter = Planet(name: "Jupiter", diameterKm: 142984)</span><span id="6660" class="lk ll iq lg b gy nk ln l lo lp">mercury == neptune // false</span><span id="ef2b" class="lk ll iq lg b gy nk ln l lo lp"><strong class="lg ir">let</strong> planets = mercury..&lt;neptune</span></pre><p id="a767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创造了一个从水星到海王星的范围。地球在这些行星之间，但这个范围不包括海王星和木星。我们只有两颗行星在<em class="mv">范围</em>内，基于一个简单的比较算子，我们可以找出被检查的对象是否包含在<em class="mv">范围</em>内:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a5bd" class="lk ll iq lg b gy lm ln l lo lp">planets.contains(earth) // true<br/>planets.contains(neptune) // false<br/>planets.contains(jupiter) // false</span></pre><p id="769c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以返回两个范围的交集或检查交叉点。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a445" class="lk ll iq lg b gy lm ln l lo lp">(mercury..&lt;neptune).clamped(to: earth..&lt;jupiter) // earth..&lt;neptune</span></pre><p id="e21e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是<em class="mv">系列</em>结构的骨架。我们的自定义绑定类型的简单范围仅限于这些函数；没有额外的努力，我们无法迭代或做任何其他事情。Range的其他特性的实现取决于哪些类型符合Range的下限和上限。</p><h1 id="9561" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">范围可以是集合</h1><p id="c01a" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated"><em class="mv"> Range </em>可以是一个集合，但前提是Range中指定的界限符合<em class="mv"> Strideable </em>协议，其中stride是一个<em class="mv"> SignedInteger </em>(下文只提到<em class="mv"> Strideable </em>，也暗示了对<em class="mv"> SignedInteger </em>的限制)。</p><p id="fb9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<em class="mv">系列</em>的边界符合<em class="mv">可划分的</em>，那么<em class="mv">系列</em>具有我们已经熟悉的系列所固有的新特征。例如，可以循环迭代:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="143c" class="lk ll iq lg b gy lm ln l lo lp">for i in -1..&lt;8 {<br/>  print(i)<br/>}</span></pre><p id="2312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们定义了一个<em class="mv">范围</em>，但是我们的<em class="mv">范围</em>也将是一个<em class="mv">序列</em>，因为它的边界符合<em class="mv">可跨越的</em>协议。</p><p id="25f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能为我们的行星写出<code class="fe lq lr ls lg b">for p in mercury…jupiter</code>,因为在这种情况下，许多函数没有被定义。我们不知道哪个星球跟着哪个星球(我们的星球是不可跨越的)。</p><p id="e620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">符合<em class="mv"> Strideable </em>的<em class="mv">范围</em>有一个类型别名叫做<em class="mv"> CountableRange </em>。这样的<em class="mv">范围</em>可以通过下标进行迭代和访问。常规<em class="mv">范围</em> ( <em class="mv">绑定</em>不符合<em class="mv">可绑定</em>)不具备此功能；它只有两个界限，并且只受<em class="mv"> RangeExpression </em>协议能力的限制。</p><p id="4391" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以像使用常规集合一样使用<em class="mv"> CountableRange </em>，例如<code class="fe lq lr ls lg b">(3..&lt;5)[4]</code>，在这种情况下，下标必须接收一个值作为参数，该值本身在指定的边界内。因此，表达式<code class="fe lq lr ls lg b">(3..&lt;5)[0]</code>将不起作用，我们将有一个错误。</p><h1 id="58a4" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">部分范围到</strong> <strong class="ak">和</strong> <strong class="ak">部分范围到</strong></h1><p id="f525" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">这些结构非常相似，都包含一个<em class="mv"> upperBound </em>字段。关于<em class="mv">partialrangeupt到</em>，该字段不在范围内，而在<em class="mv">partialrangeup到</em>的情况下，该字段在范围内。这两个实体都没有下限。因此，它们遵循与这些结构在任何情况下都不能符合<em class="mv">序列</em>或<em class="mv">集合</em>协议的事实相关的特征。因此，您不能迭代它们或通过下标引用它们:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="64ec" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">// </strong>this code will not compile<strong class="lg ir"><br/>for</strong> n <strong class="lg ir">in</strong> ...10 {<br/>  print(n)<br/>}<br/><strong class="lg ir">for</strong> n <strong class="lg ir">in</strong> ..&lt;10 {<br/>  print(n)<br/>}<br/>(...10)[9]<br/>(..&lt;10)[9]</span></pre><p id="2c5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连这个代码都不行:<code class="fe lq lr ls lg b">(..&lt;4).reversed()</code>。我们知道我们可以定义反向序列的开始元素，并迭代剩余的元素。尽管如此，由于<em class="mv"> PartialRangeUpTo </em>不符合<em class="mv">序列</em>，该表达式将不被编译。</p><h1 id="1d6d" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">部分距离</h1><p id="83b4" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">这是一个只有下限的系列结构。我们已经有了一个开始元素，但是在这个例子中没有结束元素。因此，如果我们的下限是<em class="mv"> Strideable </em>，我们可以实现<em class="mv">序列</em>协议的功能，但是由于缺少上限，我们将无法在我们的结构上实现<em class="mv">集合</em>。</p><p id="e6a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我提醒你，<em class="mv">序列</em>对元素的数量没有限制，而<em class="mv">集合</em>中的元素数量必须是有限的。对于来自的<em class="mv">partial range，其中<em class="mv"> Strideable </em>的下界是来自</em>的type alias<em class="mv">countable partial range，我们可以迭代。</em></p><h1 id="3367" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">封闭区域</h1><p id="6ffb" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">就实现而言，这是系列产品中最不寻常的结构。与常规的<em class="mv">范围</em>一样，如果边界参数符合<em class="mv">可跨越的</em>，该结构可以实现<em class="mv">序列</em>和<em class="mv">集合</em>协议。似乎与<em class="mv">范围</em>相比，在<em class="mv">集合</em>协议的实现上应该有最小的差异。然而，使用索引有很大的不同，只是差别很小。<em class="mv"> ClosedRange </em>中集合的索引定义为enum:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2443" class="lk ll iq lg b gy lm ln l lo lp">public enum Index {<br/>    case pastEnd<br/>    case inRange(Bound)<br/>}</span></pre><p id="3ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该索引是一个枚举！</p><p id="93a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种认知差异的原因是什么？<em class="mv">集合</em>协议有一个<em class="mv"> endIndex </em>属性。我强调一下，这是集合的上限，不包含在集合里。对于一个<em class="mv">范围</em>结构，<em class="mv"> endIndex </em>很容易被定义为上界(<em class="mv"> upperBound </em>属性)。在<em class="mv"> ClosedRange </em>的权利要求中，<em class="mv"> endIndex </em>可以定义为跟随上限的索引。</p><p id="8023" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于上界必须符合<em class="mv">可刻划的</em>，我们可以称之为<code class="fe lq lr ls lg b">upperBound.advanced(by: 1)</code>。一切看起来都很好，但是有一个小问题:<em class="mv"> Int </em>值(符合<em class="mv"> Strideable </em>)有一个最大值<code class="fe lq lr ls lg b">Int.max</code>。对于一个定义为<code class="fe lq lr ls lg b">1...Int.max</code>的<em class="mv"> ClosedRage </em>，其<em class="mv"> endIndex </em>属性的值应该是<code class="fe lq lr ls lg b">Int.max+1</code>，但是<code class="fe lq lr ls lg b">Int.max</code>已经是最大值了。我们可以通过使用enum作为索引来解决这个问题，其中<em class="mv"> endIndex </em>只是enum中的一种情况。处理集合中索引的逻辑是围绕这个枚举实现的。</p><p id="77f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能像对待常规的<em class="mv">范围</em>那样对待<code class="fe lq lr ls lg b">(4...10)[5]</code>。但是我们可以这样做<code class="fe lq lr ls lg b">(4...10)[.inRange(5)]</code>，此外，在当前的实现中，对于这样的调用，没有包含在<em class="mv"> ClosedRange </em>中的检查。<code class="fe lq lr ls lg b">(4...11)[.inRange(3)]</code>将返回3(即使范围不包含3)，而<code class="fe lq lr ls lg b">(4...11)[3]</code>将不起作用(因为在closed range index-enum中)。</p><p id="6bcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来<em class="mv"> ClosedRange </em>是标准库中最奇怪的集合，因为它通过一个下标来引用它的集合；enum需要使用一个不寻常的结构。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fde9" class="lk ll iq lg b gy lm ln l lo lp">// ClosedRange<strong class="lg ir"><br/>let</strong> collection1 = 4...100<br/>collection1[.inRange(-100)] // ok: -100<br/>collection1[.inRange(5)] // ok: 5<br/>// collection1[5] // compile error</span><span id="8742" class="lk ll iq lg b gy nk ln l lo lp">// Range<strong class="lg ir"><br/>let</strong> collection2 = 4..&lt;100 <br/>// collection2[.inRange(-100)] // compile error<br/>// collection2[-100] // runtime error<br/>collection2[5] // ok: 5</span></pre><p id="c77c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是您还应该注意，建议使用<em class="mv"> startIndex </em>、<em class="mv"> endIndex </em>属性和用于计算索引的函数<em class="mv"> index(after:) </em>、<em class="mv"> distance(from:to:) </em>等来处理集合索引。，在<em class="mv">系列</em>的协议中定义。它将使您的应用程序在运行时安全，并允许您从所有集合类型的特定索引实现中抽象出来。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="27fa" class="lk ll iq lg b gy lm ln l lo lp">// a safe way to work with ranges<br/><strong class="lg ir">let</strong> closedRange = 4...100<br/>closedRange[closedRange.index(after: closedRange.startIndex)]//ok: 5</span></pre><h1 id="45b0" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">UnboundedRange</h1><p id="8c57" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">这里有一个更不寻常的系列类型。这是一个定义为<code class="fe lq lr ls lg b">public typealias UnboundedRange = (UnboundedRange_)-&gt;()</code>的typealias。Enum <em class="mv"> UnboundedRange_ </em>被用作<code class="fe lq lr ls lg b">...</code>操作符的名称空间，它什么也不做。它允许我们使用这样的<code class="fe lq lr ls lg b">collection[...]</code>结构。我们可以在解决递归问题的文档中看到这样的例子。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ec3f" class="lk ll iq lg b gy lm ln l lo lp">func countLetterChanges(_ s1: Substring, _ s2: Substring) -&gt; Int {<br/>  if s1.isEmpty { return s2.count }    <br/>  if s2.isEmpty { return s1.count }     </span><span id="9800" class="lk ll iq lg b gy nk ln l lo lp">  let cost = s1.first == s2.first ? 0 : 1     <br/>  return min(<br/>        countLetterChanges(s1.dropFirst(), s2) + 1,<br/>        countLetterChanges(s1, s2.dropFirst()) + 1,<br/>        countLetterChanges(s1.dropFirst(), s2.dropFirst()) + cost)<br/>}</span><span id="5f3f" class="lk ll iq lg b gy nk ln l lo lp">let word1 = "grizzly"<br/>let word2 = "grisly"<br/>let changes = countLetterChanges(word1[...], word2[...])<br/>// changes == 2</span></pre><p id="f152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该类型不符合<em class="mv">range expression</em>(Ranges家族类的唯一例外)，因此<em class="mv">集合</em>和<em class="mv"> MutableCollection </em>对于<em class="mv"> UnboundedRange </em>有单独的下标实现。</p><p id="91d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它本质上是一个很小的改动，只需要在集合的下标中指定集合本身的大小范围。</p><h1 id="65ca" class="lt ll iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="7ef5" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们探索了所有类型的产品系列。这些类别表示定义范围边界的不同组合。</p><ul class=""><li id="427f" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><strong class="kf ir">范围<em class="mv">类型</em>和<em class="mv">关闭范围</em>和</strong>类型如果边界工作到<em class="mv">可Strideable </em>就可以符合<em class="mv">集合</em>(为这种情况定义的类型别名<em class="mv">可计数范围</em>和<em class="mv">可计数关闭范围</em>)。但是对于<em class="mv"> CountableClosedRange </em>来说，索引通常是通过enum实现的，因为否则的话，在实现某些函数时，可能会出现处理类型最大值的问题。</li><li id="e927" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir">一个来自 </strong>类型的<em class="mv">partial range如果边界符合<em class="mv"> Strideable </em>就可以符合<em class="mv">序列</em>(这种情况下定义了type alias<em class="mv">countablepartial range from</em>)。但是由于缺少上限，我们无法符合这种类型的<em class="mv">集合</em>。</em></li><li id="c709" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir"><em class="mv">PartialRangeUpTo</em>和<em class="mv">PartialRangeThrough</em></strong>类型不能有<em class="mv"> Sequence </em>或<em class="mv">集合</em>实现，因为它们没有定义开始索引。</li><li id="1bf9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir"><em class="mv">UnboundedRange</em></strong>是一个hack类型，由操作符<code class="fe lq lr ls lg b">...</code>专门用来定义<em class="mv">集合</em>和<em class="mv">可变集合</em>上的下标。</li></ul><p id="4a7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这里看到范围<a class="ae kc" href="https://github.com/apple/swift/tree/main/stdlib/public/core" rel="noopener ugc nofollow" target="_blank">的实现。</a></p></div></div>    
</body>
</html>