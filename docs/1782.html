<html>
<head>
<title>Node Health Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点健康检查</h1>
<blockquote>原文：<a href="https://itnext.io/node-health-checks-b25a6c62d990?source=collection_archive---------2-----------------------#2019-01-28">https://itnext.io/node-health-checks-b25a6c62d990?source=collection_archive---------2-----------------------#2019-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ebf7561e1c12c8c53aa9af6d0af17155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6R977vhoSYfudlTLRnWtg.jpeg"/></div></div></figure><div class=""/><p id="8fcc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Cloud Foundry (CF)有一个<em class="kz">健康检查</em>的概念。这些检查有几种形式，但首选的方法是HTTP(而不是基于端口或基于进程的检查)。应用程序可以公开一个<code class="fe la lb lc ld b">/healthcheck</code>端点，由<a class="ae le" href="https://docs.cloudfoundry.org/concepts/architecture/cloud-controller.html" rel="noopener ugc nofollow" target="_blank">云控制器</a>进行轮询。如果应用程序变得不健康(由非200 HTTP状态代码指示)，则会尝试重新启动。</p><p id="7f2e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一个<em class="kz">健康检查超时</em>，我喜欢把它称为<em class="kz">启动超时</em>。在应用程序的初始启动期间，运行状况检查过程将等待这么长时间(每隔几秒钟轮询一次)以使应用程序变得运行状况良好。该值是可配置的(在<a class="ae le" href="https://pivotal.io/platform" rel="noopener ugc nofollow" target="_blank"> Pivotal Cloud Foundry </a>中为60-600秒)，支持具有更密集设置任务的应用。</p><figure class="lg lh li lj gt iv gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/0cbeb4239a7bfb154092b8c30ca59a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*zzV8KR_iikBm7cJCS3dpMA.png"/></div></figure><p id="338e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有一个<em class="kz">调用超时</em>，它控制运行状况检查器等待正在运行的应用程序响应的时间(在初始启动完成后，应用程序已经提供了第一个运行状况良好的响应)。历史上，这被硬编码为一秒。</p><p id="a32f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使健康检查不会使系统陷入困境，但也意味着需要对许多依赖项进行密集健康检查的应用程序经常会超时，并被判断为不健康(重启风暴！).</p><p id="7908" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae le" href="https://github.com/cloudfoundry/cloud_controller_ng/issues/1055" rel="noopener ugc nofollow" target="_blank">提供了一个补丁，使这成为可配置的</a>，但当我第一次听说它时，我回想起以前的生活…一般的问题并不具体。我记得当Nagios和Cacti处于领先地位时，我曾解决过类似的问题(轮询超时)。</p><p id="b8e2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这不是我发明的模式，比我聪明得多的同事指出，解决方案是<em class="kz">从测试执行中分离响应</em>，而不是更少(减少覆盖率)或更不准确的测试(端口或过程)。</p><h1 id="6d88" class="lk ll je bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">代码时间！</h1><p id="4cdb" class="pw-post-body-paragraph kb kc je kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated"><a class="ae le" href="https://github.com/deadlysyn/node-healthcheck" rel="noopener ugc nofollow" target="_blank">克隆存储库以遵循</a> …</p><p id="6fd1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">即使有可配置的超时，解耦也是好的…所以我想创建一个简单的<a class="ae le" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>应用，利用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>和<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步/等待</a>来模拟一个<em class="kz">健康检查模式</em>，该模式被设计为与<a class="ae le" href="https://www.cloudfoundry.org/" rel="noopener ugc nofollow" target="_blank">云铸造</a>一起工作。想法是<em class="kz">使用async/await来正确地运行和收集任意数量的长期测试的结果</em>，同时尽可能地保持您的端点的响应性和准确性。</p><p id="0ccb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您没有完整地看过示例应用程序，那么这些示例会更有意义，我创建了一个全局对象，我们可以用它来存储测试结果。我们还设置了一个默认的状态代码，稍后您会看到更多。</p><figure class="lg lh li lj gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5953" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了模拟潜在的缓慢的应用程序依赖测试，我使用了<code class="fe la lb lc ld b">setTimeout</code>来引入延迟。想象一下，一个过载的数据库或您最喜欢的上游API在高峰时段受到冲击。</p><figure class="lg lh li lj gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="d326" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在示例应用程序中，我有几个这样的函数，而一个真正的应用程序可能有很多……所以下一步是将测试套件包装在一个<code class="fe la lb lc ld b">async</code>函数中，该函数调用每个测试并<code class="fe la lb lc ld b">await</code>响应。在简单的情况下，它检查我们的模拟结果是否失败，并相应地更新状态代码。</p><figure class="lg lh li lj gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="73ad" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一部分是正确构建健康检查端点本身…我们希望启动<code class="fe la lb lc ld b">testRunner</code>，但不是作为中间件，这会导致响应阻塞。</p><figure class="lg lh li lj gt iv"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0084" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当健康检查请求进来时，异步函数将运行并做所有需要的检查，随着进程更新<code class="fe la lb lc ld b">testResults</code>。如果出现问题，后续请求将收到一个非200的状态代码。此外，每次测试都会返回一条潜在有用的消息和时间戳…可能还集成了第三方监控。</p><p id="a778" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你的机器上运行着<a class="ae le" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，你可以简单的<a class="ae le" href="https://github.com/deadlysyn/node-healthcheck" rel="noopener ugc nofollow" target="_blank">克隆这个项目</a>，然后运行<code class="fe la lb lc ld b">make build; make run</code>在<code class="fe la lb lc ld b"><a class="ae le" href="http://localhost:3000/healthcheck." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/healthcheck</a></code> <a class="ae le" href="http://localhost:3000/healthcheck." rel="noopener ugc nofollow" target="_blank">上获得快速监听。</a></p><p id="abc4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">端点将立即使用默认响应代码(200)进行响应。这保持了健康检查过程的愉快。如果您观察stdout，您会看到几秒钟后<em class="kz"> db测试运行</em>，几秒钟后<em class="kz">网络测试运行</em>。刷新端点将显示测试结果。您可以将<code class="fe la lb lc ld b">message</code>设置为<code class="fe la lb lc ld b">OK</code>以外的其他值来模拟故障。任何测试失败都会导致500状态代码。</p><pre class="lg lh li lj gt mp ld mq mr aw ms bi"><span id="0b9f" class="mt ll je ld b gy mu mv l mw mx">❯ http localhost:3000/healthcheck<br/>HTTP/1.1 200 OK<br/>Connection: keep-alive<br/>Content-Length: 14<br/>Content-Type: application/json; charset=utf-8<br/>Date: Sun, 20 Jan 2019 18:09:30 GMT<br/>ETag: W/"e-QlsUp1vTYvBgYHrHCBYe2n/q268"<br/>X-Powered-By: Express</span><span id="daea" class="mt ll je ld b gy my mv l mw mx">{<br/>    "status": 200<br/>}</span><span id="e022" class="mt ll je ld b gy my mv l mw mx">❯ http localhost:3000/healthcheck<br/>HTTP/1.1 200 OK<br/>Connection: keep-alive<br/>Content-Length: 121<br/>Content-Type: application/json; charset=utf-8<br/>Date: Sun, 20 Jan 2019 18:06:56 GMT<br/>ETag: W/"79-topudR8vULOkkpcpIVCdvk+S1nQ"<br/>X-Powered-By: Express</span><span id="2471" class="mt ll je ld b gy my mv l mw mx">{<br/>    "database": {<br/>        "message": "OK",<br/>        "timestamp": 1548007610802<br/>    },<br/>    "network": {<br/>        "message": "OK",<br/>        "timestamp": 1548007612803<br/>    },<br/>    "status": 200<br/>}</span><span id="3eee" class="mt ll je ld b gy my mv l mw mx">❯ http localhost:3000/healthcheck<br/>HTTP/1.1 500 Internal Server Error<br/>Connection: keep-alive<br/>Content-Length: 125<br/>Content-Type: application/json; charset=utf-8<br/>Date: Sun, 20 Jan 2019 18:09:43 GMT<br/>ETag: W/"7d-NbOObgl/2uT9jLi9gSpqy8qDyWE"<br/>X-Powered-By: Express</span><span id="5f43" class="mt ll je ld b gy my mv l mw mx">{<br/>    "database": {<br/>        "message": "OK",<br/>        "timestamp": "1548007773994"<br/>    },<br/>    "network": {<br/>        "message": "FAIL",<br/>        "timestamp": 1548007775999<br/>    },<br/>    "status": 500<br/>}</span></pre><p id="c251" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望这能给你一些方法来为你的节点应用程序创建更好的健康检查！</p><figure class="lg lh li lj gt iv gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9f8b767a65d5ec095ac35f235e597ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*EXDcBRbF-eV8evhq0qSQ-g.jpeg"/></div></figure></div></div>    
</body>
</html>