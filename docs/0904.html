<html>
<head>
<title>Dynamic Programming vs Divide-and-Conquer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程与分治</h1>
<blockquote>原文：<a href="https://itnext.io/dynamic-programming-vs-divide-and-conquer-2fea680becbe?source=collection_archive---------1-----------------------#2018-06-15">https://itnext.io/dynamic-programming-vs-divide-and-conquer-2fea680becbe?source=collection_archive---------1-----------------------#2018-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="55b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者在类固醇上各个击破</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/058c36ac88ea3a2b21839f80e84ca022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRgXjJ6gv8sR59cu3sM64A.png"/></div></div></figure><h2 id="313a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="22d3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在这篇文章中，我试图通过两个例子来解释动态编程和分治法之间的区别/相似之处:<a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">【二分搜索法】</strong> </a>和<a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">最小编辑距离</strong> </a> (Levenshtein距离)。</p><h2 id="59a6" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">问题是</h2><p id="c002" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">当我<a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">开始学习算法</strong> </a>时，我很难理解动态编程(<strong class="lp ir"> DP </strong>)的主要思想，以及它与分治(<strong class="lp ir"> DC </strong>)方法有什么不同。当要比较这两种范式时，通常斐波那契函数可以作为很好的例子<a class="ae mg" href="https://stackoverflow.com/questions/13538459/difference-between-divide-and-conquer-algo-and-dynamic-programming" rel="noopener ugc nofollow" target="_blank"/>。但是当我们试图使用DP和DC方法来解释它们中的每一个来解决相同的问题时，我感觉我们可能会失去有价值的细节，而这些细节可能有助于更快地发现差异。这些细节告诉我们，每种技术最适合不同类型的问题。</p><p id="e627" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我仍然在理解DP和DC差异的过程中，我不能说我已经完全掌握了这些概念。但是我希望这篇文章能够提供一些额外的启示，帮助您更进一步地学习像动态编程和分治这样有价值的算法范例。</p><h2 id="7912" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">动态编程和分治的相似之处</h2><p id="9e7b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在我看来，现在我可以说动态编程是分而治之范式的延伸。</p><p id="0fb5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我不会把它们当作完全不同的东西。因为<strong class="lp ir">和</strong> <strong class="lp ir">都是通过递归地将一个问题分解成两个或更多相同或相关类型的子问题</strong>来工作的，直到这些子问题变得足够简单，可以直接解决。然后将子问题的解决方案组合起来，给出原问题的解决方案。</p><p id="e1db" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">那么为什么我们仍然有不同的范式名称，为什么我称动态编程为扩展。这是因为只有当问题具有某些 <strong class="lp ir">限制或先决条件</strong>时，动态规划方法才可以应用于问题<strong class="lp ir">。然后动态编程<strong class="lp ir">用<strong class="lp ir">记忆</strong>或<strong class="lp ir">列表</strong>技术扩展</strong>分治法。</strong></p><p id="af59" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">让我们一步一步来…</p><h2 id="95e2" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">动态编程先决条件/限制</h2><p id="8f45" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">正如我们刚刚发现的，为了使动态编程适用，分治问题必须具有两个关键属性:</p><ol class=""><li id="d419" class="mm mn iq lp b lq mh lt mi la mo le mp li mq mf mr ms mt mu bi translated"><a class="ae mg" href="https://en.wikipedia.org/wiki/Optimal_substructure" rel="noopener ugc nofollow" target="_blank">最优子结构</a>——最优解可以由其子问题的最优解构成</li><li id="c852" class="mm mn iq lp b lq mv lt mw la mx le my li mz mf mr ms mt mu bi translated"><a class="ae mg" href="https://en.wikipedia.org/wiki/Overlapping_subproblems" rel="noopener ugc nofollow" target="_blank">重叠子问题</a>——问题可以被分解成子问题，这些子问题可以重复使用几次，或者问题的递归算法反复解决同一个子问题，而不是总是产生新的子问题</li></ol><p id="c60e" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">一旦这两个条件得到满足，我们就可以说这个分而治之的问题可以用动态规划方法来解决。</p><h2 id="4b02" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">分而治之的动态编程扩展</strong></h2><p id="ac08" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">动态编程方法使用两种技术(<strong class="lp ir">记忆</strong>和<strong class="lp ir">制表</strong>)扩展了分治方法，这两种技术都具有存储和重用子问题解决方案的目的，可以显著提高性能。例如，斐波纳契函数的朴素递归实现具有时间复杂度<code class="fe na nb nc nd b">O(2^n)</code>，而DP解决方案仅用<code class="fe na nb nc nd b">O(n)</code>时间做同样的事情。</p><p id="4b0c" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">内存化(自顶向下缓存填充)</strong>指的是缓存和重用先前计算结果的技术。记忆的<code class="fe na nb nc nd b">fib</code>函数看起来会是这样的:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="296c" class="kr ks iq nd b gy ni nj l nk nl">memFib(n) {<br/>    if (mem[n] is undefined)<br/>        if (n &lt; 2) result = n<br/>        else result = memFib(n-2) + memFib(n-1)<br/>        mem[n] = result<br/>    return mem[n]<br/>}</span></pre><p id="f578" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">制表(自底向上的高速缓存填充)</strong>类似，但侧重于填充高速缓存的条目。迭代计算缓存中的值是最简单的。<code class="fe na nb nc nd b">fib</code>的列表版本如下所示:</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="f1f1" class="kr ks iq nd b gy ni nj l nk nl">tabFib(n) {<br/>    mem[0] = 0<br/>    mem[1] = 1<br/>    for i = 2...n<br/>        mem[i] = mem[i-2] + mem[i-1]<br/>    return mem[n]<br/>}</span></pre><p id="8de5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">你可以在这里阅读更多关于记忆和列表比较的内容。</p><p id="f0e8" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这里你应该掌握的主要思想是，因为我们的分治问题有重叠的子问题，子问题解决方案的缓存成为可能，因此记忆/列表逐步出现。</p><h2 id="d057" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">那么迪拜和DC到底有什么区别呢</h2><p id="bb91" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">既然我们现在已经熟悉了DP的先决条件及其方法，我们就准备将上面提到的所有内容放入一张图片中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/7c80845700ce2e275442fff035161cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXpfyivX8XmtULGNiXXmEw.png"/></div></div></figure><p id="c20e" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">让我们试着用DP和DC方法来解决一些问题，让这个例子更清楚。</p><h2 id="6cdd" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">分而治之的例子:二分搜索法</h2><p id="3756" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><a class="ae mg" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>算法，也称为半区间搜索，是一种查找目标值在排序数组内的位置的搜索算法。二分搜索法将目标值与数组的中间元素进行比较；如果它们不相等，则目标不能位于其中的那一半被消除，并且在剩余的一半上继续搜索，直到找到目标值。如果搜索结束时剩下的一半为空，则目标不在数组中。</p><p id="0ff0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">例子</strong></p><p id="2ac1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这里是二分搜索法算法的可视化，其中<code class="fe na nb nc nd b">4</code>是目标值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/77d6582f588f669307b5b7545c18f9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j85cBAsBYpglrWGbZCUqXQ.png"/></div></div></figure><p id="a8cf" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">让我们画出同样的逻辑，但以决策树的形式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/9a28767ef90274f3dfedae7b40b01f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umSvrSPEhaHeMAXpPrf1SA.png"/></div></div></figure><p id="d17f" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">在这里你可以清楚地看到解决问题的分而治之的原则。我们迭代地将原始数组分解成子数组，并试图在其中找到所需的元素。</p><p id="6c75" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我们能把动态编程应用到它上面吗？<strong class="lp ir">否</strong>是因为<strong class="lp ir">没有重叠的子问题</strong>。每次我们把数组分割成完全独立的部分。并且根据分治先决条件/限制，子问题<strong class="lp ir">必须以某种方式与</strong>重叠。</p><p id="9269" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">通常每次你画一个决策树，它实际上是一个<strong class="lp ir">树</strong>(而<strong class="lp ir">不是</strong>一个决策<strong class="lp ir">图</strong>)这意味着你没有重叠的子问题，这不是动态规划问题。</p><p id="f55c" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">代码</strong></p><p id="6c7a" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到二分搜索法函数的完整源代码，以及测试案例和解释。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="537a" class="kr ks iq nd b gy ni nj l nk nl">function binarySearch(sortedArray, seekElement) {<br/>  let startIndex = 0;<br/>  let endIndex = sortedArray.length - 1;</span><span id="5f7c" class="kr ks iq nd b gy np nj l nk nl">  while (startIndex &lt;= endIndex) {<br/>    const middleIndex = startIndex + Math.floor((endIndex - startIndex) / 2);</span><span id="e6fc" class="kr ks iq nd b gy np nj l nk nl">    // If we've found the element just return its position.<br/>    if (sortedArray[middleIndex] === seekElement)) {<br/>      return middleIndex;<br/>    }</span><span id="f375" class="kr ks iq nd b gy np nj l nk nl">    // Decide which half to choose: left or right one.<br/>    if (sortedArray[middleIndex] &lt; seekElement)) {<br/>      // Go to the right half of the array.<br/>      startIndex = middleIndex + 1;<br/>    } else {<br/>      // Go to the left half of the array.<br/>      endIndex = middleIndex - 1;<br/>    }<br/>  }</span><span id="343e" class="kr ks iq nd b gy np nj l nk nl">  return -1;<br/>}</span></pre><h2 id="46b7" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">动态编程示例:最小编辑距离</h2><p id="af46" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">通常当涉及到动态编程的例子时，默认情况下会采用<a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/fibonacci" rel="noopener ugc nofollow" target="_blank">斐波那契</a>数字算法。但是让我们用一个稍微复杂一点的算法，来做一些变化，这应该有助于我们理解这个概念。</p><p id="3def" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><a class="ae mg" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank">最小编辑距离</a>(或Levenshtein距离)是一个字符串度量，用于测量两个序列之间的差异。非正式地，两个单词之间的Levenshtein距离是将一个单词变成另一个单词所需的单个字符编辑(<em class="nq">插入、删除或替换</em>)的最小数量。</p><p id="4ff9" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">示例</strong></p><p id="5f20" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">对于<strong class="lp ir"> </strong>示例,“小猫”和“坐着”之间的Levenshtein距离是3，因为以下三个编辑将一个改变为另一个，并且少于三个编辑是无法实现的:</p><ol class=""><li id="e2ec" class="mm mn iq lp b lq mh lt mi la mo le mp li mq mf mr ms mt mu bi translated"><strong class="lp ir">k</strong>itten→<strong class="lp ir">s</strong>itten(用“s”代替“k”)</li><li id="c416" class="mm mn iq lp b lq mv lt mw la mx le my li mz mf mr ms mt mu bi translated">sitt<strong class="lp ir">e</strong>n→sitt<strong class="lp ir">I</strong>n(用“I”代替“e”)</li><li id="daff" class="mm mn iq lp b lq mv lt mw la mx le my li mz mf mr ms mt mu bi translated">sittin → sittin <strong class="lp ir"> g </strong>(在末尾插入“g”)。</li></ol><p id="1825" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">应用</strong></p><p id="5c71" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">这具有广泛的应用，例如，拼写检查器、用于光学字符识别的校正系统、模糊字符串搜索以及基于翻译记忆的辅助自然语言翻译的软件。</p><p id="deb2" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">数学定义</strong></p><p id="009c" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">数学上，两个弦<code class="fe na nb nc nd b">a</code>、<code class="fe na nb nc nd b">b</code>(长度分别为<code class="fe na nb nc nd b">|a|</code>和<code class="fe na nb nc nd b">|b|</code>)之间的Levenshtein距离由函数<code class="fe na nb nc nd b">lev(|a|, |b|)</code>给出，其中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4bdc529506abe73bd87aa9b9dc2007b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njxdMX6ChqZIAnaqd6NZlQ.png"/></div></div></figure><p id="5ba5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">注意，最小值中的第一个元素对应于<strong class="lp ir">删除</strong>(从<code class="fe na nb nc nd b">a</code>到<code class="fe na nb nc nd b">b</code>)，第二个对应于<strong class="lp ir">插入</strong>，第三个对应于<strong class="lp ir">匹配</strong> <strong class="lp ir">或不匹配</strong>，这取决于各自的符号是否相同。</p><p id="dc7b" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">解释</strong></p><p id="6fb5" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">好，让我们试着弄清楚这个公式在说什么。让我们举一个简单的例子，找出字符串<strong class="lp ir"> ME </strong>和<strong class="lp ir"> MY </strong>之间的最小编辑距离。直觉上你已经知道这里的最小编辑距离是<strong class="lp ir"> 1 </strong>操作，这个操作是“<em class="nq">用</em> <strong class="lp ir"> <em class="nq"> Y </em> </strong>替换 <strong class="lp ir"> <em class="nq"> E </em> </strong> <em class="nq">”。但是，让我们试着用算法的形式来形式化它，以便能够做更复杂的例子，比如将<strong class="lp ir">星期六</strong>转换成<strong class="lp ir">星期天</strong>。</em></p><p id="2d55" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">要将该公式应用于<em class="nq">M</em><strong class="lp ir"><em class="nq">E</em></strong><em class="nq">→M</em><strong class="lp ir">→Y</strong>变换，我们需要知道之前的<em class="nq"> ME→M </em>、<em class="nq"> M→MY </em>和<em class="nq"> M→M </em>变换的最小编辑距离。然后，我们将需要挑选最小的一个，并添加+1操作来转换最后一个字母<em class="nq"> E→Y </em>。</p><p id="396a" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">因此，我们已经可以在这里看到解决方案的递归性质:最小编辑距离的<em class="nq"> ME→MY </em>转换是基于三个先前可能的转换计算的。因此我们可以说这是<strong class="lp ir">分治算法</strong>。</p><p id="cf63" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">为了进一步解释这一点，让我们画出下面的矩阵。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/9958570c3d1e48f1a09a4ae38f3008ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTunSUoy0BJyYBVn4tWGrA.png"/></div></div></figure><p id="daa1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">单元格(0，1) </strong>包含红色数字1。意味着我们需要1次操作将<strong class="lp ir"> M </strong>转换为<strong class="lp ir">空串</strong>:删除<strong class="lp ir"> M </strong>。这就是为什么这个数字是红色的。</p><p id="9bfd" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">单元格(0，2) </strong>包含红色数字2。这意味着我们需要2个操作来将<strong class="lp ir"> ME </strong>转换为<strong class="lp ir">空串</strong>:删除<strong class="lp ir"> E </strong>，删除<strong class="lp ir"> M </strong>。</p><p id="3c17" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">单元格(1，0) </strong>包含绿色数字1。这意味着我们需要1次操作将空字符串转换为<strong class="lp ir"> M </strong>:插入<strong class="lp ir"> M </strong>。这就是为什么这个数字是绿色的。</p><p id="bf0b" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">单元格(2，0) </strong>包含绿色数字2。这意味着我们需要2个操作来将空字符串转换为<strong class="lp ir"> MY </strong>:插入<strong class="lp ir"> Y </strong>，插入<strong class="lp ir"> M </strong>。</p><p id="5b84" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">单元格(1，1) </strong>包含数字0。意思是把<strong class="lp ir"> M </strong>改造成<strong class="lp ir"> M </strong>不需要任何成本。</p><p id="a115" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">单元格(1，2) </strong>包含红色数字1。意味着我们需要1次操作将<strong class="lp ir"> ME </strong>转换为<strong class="lp ir"> M </strong>:删除<strong class="lp ir"> E </strong>。</p><p id="5b45" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">诸如此类…</p><p id="f747" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">对于我们这样的小矩阵来说，这看起来很容易(它只有3x3)。但是对于更大的矩阵，我们如何计算所有这些数字呢(比如说9x7的一个，周六<em class="nq"> → </em>周日变换)？</p><p id="178d" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">好消息是，根据公式，你只需要三个相邻的单元格<code class="fe na nb nc nd b">(i-1,j)</code>、<code class="fe na nb nc nd b">(i-1,j-1)</code>和<code class="fe na nb nc nd b">(i,j-1)</code>来计算当前单元格<code class="fe na nb nc nd b">(i,j)</code>的数量。我们需要做的就是找到这三个单元格中的最小值，然后加上+1，以防我们在<code class="fe na nb nc nd b">i</code>的行和<code class="fe na nb nc nd b">j</code>的列中有不同的字母</p><p id="f354" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">所以你可以再次清楚地看到这个问题的递归性质。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/c4e7ba85931645abfd90ceadcc11a7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8UB4DSvBnAK6mBXRGQDjw.png"/></div></div></figure><p id="f7d1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">好了，我们刚刚发现，我们正在处理分而治之的问题。但是我们能应用动态规划方法吗？这个问题满足我们的<strong class="lp ir">重叠子问题</strong>和<strong class="lp ir">最优子结构</strong>限制吗？<strong class="lp ir">是的</strong>。从决策图来看。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/89ef5dc9fd1d4c733e02acaa26dab667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jD0qvr5B9PwRFM_9z7q9A.png"/></div></div></figure><p id="5ce1" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">首先这是<strong class="lp ir">而不是</strong>一个决定<strong class="lp ir">的树</strong>。这是一个决定<strong class="lp ir">图</strong>。您可能会在图片上看到许多用红色标记的<strong class="lp ir">重叠子问题</strong>。也没有办法减少运算的次数，使其小于公式中三个相邻单元格的最小值。</p><p id="49dd" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">您可能还会注意到，矩阵中的每个单元号都是基于以前的单元号计算的。因此，这里应用了<strong class="lp ir">制表</strong>技术(自底向上填充缓存)。您将在下面的代码示例中看到它。</p><p id="f96f" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">进一步应用这个原则，我们可以解决更复杂的情况，比如周六<em class="nq"> → </em>周日转换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b864c6b5bbf76db8e13f93de227ad8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*497gMaFErzJpCXG7kS_7dw.png"/></div></div></figure><p id="af4d" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><strong class="lp ir">代码</strong></p><p id="0c94" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated"><a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到完整的最小编辑距离函数的源代码，以及测试案例和解释。</p><pre class="kg kh ki kj gt ne nd nf ng aw nh bi"><span id="e275" class="kr ks iq nd b gy ni nj l nk nl">function levenshteinDistance(a, b) {<br/>  const distanceMatrix = Array(b.length + 1)<br/>    .fill(null)<br/>    .map(<br/>      () =&gt; Array(a.length + 1).fill(null)<br/>    );</span><span id="5e6b" class="kr ks iq nd b gy np nj l nk nl">  for (let i = 0; i &lt;= a.length; i += 1) {<br/>    distanceMatrix[0][i] = i;<br/>  }</span><span id="facf" class="kr ks iq nd b gy np nj l nk nl">  for (let j = 0; j &lt;= b.length; j += 1) {<br/>    distanceMatrix[j][0] = j;<br/>  }</span><span id="8785" class="kr ks iq nd b gy np nj l nk nl">  for (let j = 1; j &lt;= b.length; j += 1) {<br/>    for (let i = 1; i &lt;= a.length; i += 1) {<br/>      const indicator = a[i - 1] === b[j - 1] ? 0 : 1;<br/>      <br/>      distanceMatrix[j][i] = Math.min(<br/>        distanceMatrix[j][i - 1] + 1, // deletion<br/>        distanceMatrix[j - 1][i] + 1, // insertion<br/>        distanceMatrix[j - 1][i - 1] + indicator, // substitution<br/>      );<br/>    }<br/>  }</span><span id="0337" class="kr ks iq nd b gy np nj l nk nl">  return distanceMatrix[b.length][a.length];<br/>}</span></pre><h2 id="589a" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h2><p id="9fd4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">在本文中，我们比较了两种算法方法，如动态编程和分治法。我们已经发现，动态规划是基于分治原则的，只有当问题有重叠的子问题和最优子结构时(如在Levenshtein距离的情况下)，才可以应用动态规划。然后，动态规划使用记忆或列表技术来存储重叠子问题的解，以备后用。</p><p id="7cd0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">我希望这篇文章没有给你带来更多的困惑，而是让你对这两个重要的算法概念有所了解！:)</p><p id="5b52" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">您可能会在<a class="ae mg" href="https://github.com/trekhleb/javascript-algorithms" rel="noopener ugc nofollow" target="_blank"> JavaScript算法和数据结构</a>资源库中找到更多分而治之和动态编程问题的示例以及解释、注释和测试案例。</p><p id="0dc0" class="pw-post-body-paragraph ln lo iq lp b lq mh jr ls lt mi ju lv la mj lx ly le mk ma mb li ml md me mf ij bi translated">编码快乐！</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt oc"><a href="https://twitter.com/Trekhleb" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">Oleksii Trekhleb (@Trekhleb) |推特</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Oleksii Trekhleb的最新推文(@Trekhleb)。@EPAMSYSTEMS的首席软件工程师。正在创建全堆栈…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">twitter.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kp oc"/></div></div></a></div></div></div>    
</body>
</html>