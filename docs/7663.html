<html>
<head>
<title>Downloading files using Golang/gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang/gRPC下载文件</h1>
<blockquote>原文：<a href="https://itnext.io/downloading-files-using-golang-grpc-f07e4a16a536?source=collection_archive---------1-----------------------#2022-12-12">https://itnext.io/downloading-files-using-golang-grpc-f07e4a16a536?source=collection_archive---------1-----------------------#2022-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ff5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时我们需要从一些存储器下载文件。文件有一些元数据，如名称、大小和扩展名(可能我们需要更多的元数据，但让我们保持简单)，文件也应该实现<strong class="jp ir"> <em class="kl"> io。阅读器</em>的</strong>接口用于获取该内容的字节数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4dbff62020aa0c6aeb71332f788e7e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_wrjuJynuqvC50x22Htvg.png"/></div></div></figure><p id="97aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，文件结构可能如下所示:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="1c17" class="ld le iq kz b gy lf lg l lh li">package file<br/><br/>import (<br/>   "io"<br/>)<br/><br/>func NewFile(name string, extension string, size int, r io.Reader) *File {<br/>   return &amp;File{Name: name, Extension: extension, Size: size, r: r}<br/>}<br/><br/>type File struct {<br/>   r         io.Reader<br/>   Name      string<br/>   Extension string<br/>   Size      int<br/>}<br/><br/>func (f *File) Read(p []byte) (n int, err error) {<br/>   return f.r.Read(p)<br/>}</span></pre><p id="8ebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想使用Golang/gRPC实现将这个结构从服务器发送到客户端。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="8530" class="lq le iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">gRPC API</h1><p id="3bab" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在开始实现服务器和客户端之前，我们需要有API。我们的API非常简单:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="7a5d" class="ld le iq kz b gy lf lg l lh li">syntax = 'proto3';<br/><br/>package api.v1;<br/><br/>option go_package = "github.com/andrey-berenda/go-filestorage/generated/v1;api";<br/><br/>service FileService {<br/>  rpc Download(DownloadRequest) returns(stream DownloadResponse);<br/>}<br/><br/>message DownloadRequest{<br/>  string id = 1;<br/>}<br/><br/>message DownloadResponse{<br/>  bytes chunk = 1;<br/>}</span></pre><p id="bf88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在API中看到的，没有文件元数据:元数据将在头中，因为我们只需要发送一次，头是实现这个目标的最佳候选。</p><p id="5fa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们需要在我们的结构中有来自元数据的<strong class="jp ir"> <em class="kl"> Metadata() </em> </strong>方法和构造函数:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="58db" class="ld le iq kz b gy lf lg l lh li">package file<br/><br/>import (<br/>   "io"<br/>   "strconv"<br/><br/>   "google.golang.org/grpc/metadata"<br/>)<br/><br/>var fileNameHeader = "file-name"<br/>var fileTypeHeader = "file-type"<br/>var fileSizeHeader = "file-size"<br/><br/>func (f *File) Metadata() metadata.MD {<br/>   return metadata.New(map[string]string{<br/>      fileNameHeader: f.Name,<br/>      fileTypeHeader: f.Extension,<br/>      fileSizeHeader: strconv.Itoa(f.Size),<br/>   })<br/>}<br/><br/>func NewFromMetadata(md metadata.MD, r io.Reader) *File {<br/>   var name, fileType string<br/>   var size int<br/><br/>   if names := md.Get(fileNameHeader); len(names) &gt; 0 {<br/>      name = names[0]<br/>   }<br/>   if types := md.Get(fileTypeHeader); len(types) &gt; 0 {<br/>      fileType = types[0]<br/>   }<br/>   if sizes := md.Get(fileSizeHeader); len(sizes) &gt; 0 {<br/>      size, _ = strconv.Atoi(sizes[0])<br/>   }<br/><br/>   return &amp;File{Name: name, Extension: fileType, Size: size, r: r}<br/>}</span></pre><h1 id="fb92" class="lq le iq bd lr ls ms lu lv lw mt ly lz ma mu mc md me mv mg mh mi mw mk ml mm bi translated">服务器实现</h1><p id="edc4" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">服务器的界面如下所示:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="e8b5" class="ld le iq kz b gy lf lg l lh li">type FileServiceServer interface {<br/>   Download(req *pb.DownloadRequest, server pb.FileService_DownloadServer) error<br/>}</span></pre><p id="2b18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要检查客户端是否发送了文件id:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="77f9" class="ld le iq kz b gy lf lg l lh li">if req.GetId() == "" {<br/>   return status.Error(codes.<em class="kl">InvalidArgument</em>, "id is required")<br/>}</span></pre><p id="fd50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们从一些存储器中获取文件:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="d95b" class="ld le iq kz b gy lf lg l lh li">f, ok := getFile(req.Id)<br/>if !ok {<br/>   return status.Error(codes.<em class="kl">NotFound</em>, "file is not found")<br/>}</span></pre><p id="c6de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，存储非常简单，所有内容都保存在内存中(只有一个名为“gopher”的文件):</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="736a" class="ld le iq kz b gy lf lg l lh li">//<strong class="kz ir"><em class="kl">go:embed </em></strong>static/gopher.png<br/>var gopher []byte<br/><br/>func getFile(fileID string) (*file.File, bool) {<br/>   if fileID != "gopher" {<br/>      return nil, false<br/>   }<br/>   return file.NewFile("gopher", "png", len(gopher), bytes.NewReader(gopher)), true<br/>}</span></pre><p id="f403" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">得到文件后，我们发送文件头:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="0dd6" class="ld le iq kz b gy lf lg l lh li">err := server.SendHeader(f.Metadata())<br/>if err != nil {<br/>   return status.Error(codes.<em class="kl">Internal</em>, "error during sending header")<br/>}</span></pre><p id="5294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并发送内容:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="fb42" class="ld le iq kz b gy lf lg l lh li">   const <em class="kl">chunkSize </em>= 1024 * 3<br/>   chunk := &amp;pb.DownloadResponse{Chunk: make([]byte, chunkSize)}<br/>   var n int</span><span id="279a" class="ld le iq kz b gy mx lg l lh li">Loop:<br/>   for {<br/>      n, err = f.Read(chunk.Chunk)<br/>      switch err {<br/>      case nil:<br/>      case io.EOF:<br/>         break Loop<br/>      default:<br/>         return status.Errorf(codes.<em class="kl">Internal</em>, "io.ReadAll: %v", err)<br/>      }<br/>      chunk.Chunk = chunk.Chunk[:n]<br/>      serverErr := server.Send(chunk)<br/>      if serverErr != nil {<br/>         return status.Errorf(codes.<em class="kl">Internal</em>, "server.Send: %v", serverErr)<br/>      }<br/>   }<br/>   return nil</span></pre><p id="76ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器已实现。块大小不是很大，我认为我们可以将其增加到1MB或类似的大小，但保持块大小是3的倍数(我将在后面解释为什么这很重要)。</p><p id="9000" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器的所有代码是</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="1bcd" class="lq le iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">客户端实现</h1><p id="85e3" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我想实现客户端的方法:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="b269" class="ld le iq kz b gy lf lg l lh li">type Client struct {<br/>   client pb.FileServiceClient<br/>}</span><span id="e74b" class="ld le iq kz b gy mx lg l lh li"><br/>func (c Client) GetFile(ctx context.Context, fileID string)(*file.File, error)</span></pre><p id="5c70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要向服务器发出gRPC请求:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="7bdb" class="ld le iq kz b gy lf lg l lh li">response, err := c.client.Download(<br/>   ctx,<br/>   &amp;pb.DownloadRequest{Id: fileID},<br/>)<br/>if err != nil {<br/>   return nil, fmt.Errorf("client.LoadFile: %w", err)<br/>}</span></pre><p id="3d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们需要从上下文中获取标题:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="c678" class="ld le iq kz b gy lf lg l lh li">md, err := response.Header()<br/>if err != nil {<br/>   return nil, fmt.Errorf("response.Header: %w", err)<br/>}</span></pre><p id="3d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并最终创建<strong class="jp ir"> <em class="kl"> io。管道</em> </strong>并将所有内容从响应复制到<strong class="jp ir"> <em class="kl"> *io。管道工</em> : </strong></p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="be65" class="ld le iq kz b gy lf lg l lh li">r, w := io.Pipe()<br/>f := file.NewFromMetadata(md, r)<br/>go copyFromResponse(w, response)<br/>return f, nil</span></pre><p id="b7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制的实现在这里:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="a4a4" class="ld le iq kz b gy lf lg l lh li">func copyFromResponse(w *io.PipeWriter, res pb.FileService_DownloadClient) {<br/>   message := new(pb.DownloadResponse)<br/>   var err error<br/>   for {<br/>      err = res.RecvMsg(message)<br/>      if err == io.EOF {<br/>         _ = w.Close()<br/>         break<br/>      }<br/>      if err != nil {<br/>         _ = w.CloseWithError(err)<br/>         break<br/>      }<br/>      if len(message.GetChunk()) &gt; 0 {<br/>         _, err = w.Write(message.Chunk)<br/>         if err != nil {<br/>            _ = res.CloseSend()<br/>            break<br/>         }<br/>      }<br/>      message.Chunk = message.Chunk[:0]<br/>   }<br/>}</span></pre><p id="5729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端已实现。这是客户端的所有代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="8337" class="lq le iq bd lr ls ms lu lv lw mt ly lz ma mu mc md me mv mg mh mi mw mk ml mm bi translated">奖金</h1><p id="e757" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">当您使用简单的HTTP发送文件时，有一个优点:您可以只使用bash通过id获取文件，而不用用Golang编写任何代码。当我们将gRPC与streams一起使用时，有什么方法可以做到吗？</p><p id="de6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是肯定的。要做到这一点，我们需要有<a class="ae na" href="https://github.com/fullstorydev/grpcurl" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">grpcurl</em></strong></a>，<a class="ae na" href="https://stedolan.github.io/jq/download/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl"> jq </em> </strong> </a>，<a class="ae na" href="https://linuxhint.com/bash_tr_command/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kl"> tr </em> </strong> </a>，<a class="ae na" href="https://linuxhint.com/bash_base64_encode_decode/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kl">base64</em></strong></a>。如果服务器是在<strong class="jp ir"><em class="kl">localhost:8000</em></strong>上服务的，你可以使用这个命令获得你的“gopher ”:</p><pre class="kn ko kp kq gt ky kz la lb aw lc bi"><span id="9ff2" class="ld le iq kz b gy lf lg l lh li">grpcurl -plaintext -d '{"id":"gopher"}' localhost:8000 api.v1.FileService.Download  | jq .chunk | tr -d '"\n' | base64 -d &gt; gopher.png</span></pre><p id="ca64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当每个块字节数是3的倍数时，该命令才能正确工作。如果块大小不是3的倍数，我们将在使用<strong class="jp ir"> <em class="kl"> base64 </em> </strong>从字符串解码为字节的过程中出错。</p><h1 id="2630" class="lq le iq bd lr ls ms lu lv lw mt ly lz ma mu mc md me mv mg mh mi mw mk ml mm bi translated">最后的想法</h1><p id="8163" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">在本文中，我介绍了如何使用Golang/gRPC将“文件”(参见本文开头的结构)从服务器发送到客户机。你可以在我的<a class="ae na" href="https://github.com/andrey-berenda/go-filestorage" rel="noopener ugc nofollow" target="_blank"> github库</a>找到所有代码。</p></div></div>    
</body>
</html>