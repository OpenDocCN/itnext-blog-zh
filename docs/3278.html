<html>
<head>
<title>Server Side Rendering the right way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端以正确的方式呈现</h1>
<blockquote>原文：<a href="https://itnext.io/server-side-rendering-the-right-way-6c6ab5995be3?source=collection_archive---------0-----------------------#2019-11-13">https://itnext.io/server-side-rendering-the-right-way-6c6ab5995be3?source=collection_archive---------0-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="786c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">原则、战略和客户方</h2></div><p id="0c87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你是一名web开发人员，你迟早需要去“服务器端”，了解那里正在发生什么，以及如何与客户端(浏览器)完美结合。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/bdceb8534c72823c5fbc6e916581a998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3bAsNiDs8chOuyPYKSBcw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">一个简单的HTML文件，也就是任何SSR进程的输出</figcaption></figure><h2 id="5e69" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">SSR和CSR的定义</h2><p id="3086" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">因此，我们将从定义什么是SSR(服务器端渲染)和CSR(客户端渲染)开始</p><ul class=""><li id="0663" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu"> SSR </strong>:用户向服务器请求某个url的过程，例如:【https://www.mywebsite.com/how-to-ssr】T2，服务器用一个html文件响应，如上图所示。就这么简单，所以请记住，每当您的一些同事或一些文章谈论SSR时，不要害怕:它基本上是在谈论一个服务器发送给您的文件，其中包含html文本(可能还附有一些标题)。因此，浏览器有一个可以处理的html文件。</li><li id="bfbb" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated"><strong class="kk iu"> CSR </strong>:解析客户端(浏览器)上已经下载的html文件的过程(执行css文件、javascript、图像请求、字体等)，结果浏览器可以修改DOM(最初加载html内容)。这一次，结果是用户实际上可以在浏览器中看到一个页面。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/5be042865c0422de0c43eba906025a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*UeK_WLTzmYUHol0egzlmMg.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">SSR / CSR的简单比较</figcaption></figure><h2 id="f883" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">主要使用案例</h2><p id="6152" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">因此，在只做SSR或只做CSR之间没有选择，你将总是两者都按顺序做。</p><p id="76b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的页面在服务器端可以是轻量级的(只是一个基本的html结构)，在客户端可以是重量级的(执行了大量的javascript)，在服务器端可以是重量级的(当服务器生成html文件时，html文件中已经包含了大量的内容)，在客户端可以是轻量级的(只是一些基本的行为)，或者可能两边都是重量级的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/44370106d73f3b2d4e60817c21b149a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*3rZq2_hqfyK6Q8qZO-TlfA.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">SSR / CSR的典型使用案例</figcaption></figure><p id="bad7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把上面的图片作为一个心理参考。“轻”和“重”之间没有明确的界限，并且总是有新的用例出现。</p><p id="df60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事情是，由于javascript作为一种语言的发展所带来的浏览器引擎的演变，“瘦客户端”的旧web范式正在被“胖客户端”所取代。</p><p id="bfc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于创业公司来说，今天的用户手边有“一台完整的电脑”(手机)是件好事，这样他们就可以建立更丰富的交互，避免服务器端的资源消耗。</p><h2 id="34e7" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">静态SSR与动态SSR</h2><p id="34fc" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">另一个重要的考虑是决定你是想要已经生成的html文件(静态呈现)还是需要先处理请求，然后(相应地)动态生成html。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nj"><img src="../Images/8bff6a998b442787a849b62baa575d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtPYyA2F6jqcHQdhHMuiQA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">静态SSR与动态SSR</figcaption></figure><p id="f510" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道这可能看起来很奇怪，但实际上对于大多数用例，您可以使用静态SSR或动态SSR，让我用一个例子来解释。</p><p id="8063" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">策略一。静态SSR脸书配置文件页面:</strong></p><ul class=""><li id="3834" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">很明显，用户A和用户B会看到完全不同的个人资料页面，那么静态SSR怎么可能呢？</li><li id="0d14" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">答案是轻量级SSR。因此，HTML中不包含太多数据，只包含一些基本的结构、样式，javascript将完成所有“繁重的工作”:连接到服务器，为用户请求数据，然后将轻量级DOM转换为完全呈现的个人资料页面。</li><li id="ca59" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">但是，服务器如何知道登录的用户是谁呢？为此，在客户机中需要一个cookie(未过期的、安全的和HttpOnly ),它将与请求一起发送到服务器。</li><li id="c30c" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">然后，服务器可以读取cookie并发送所需的数据，或者将用户重定向到登录页面。</li><li id="f0b8" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">注意:前一个服务器可能不是你请求html文件的同一台服务器，我们称它为“ApiServer”(稍后会详细介绍)</li></ul><p id="706a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">策略二。动态SSR脸书个人资料页面:</strong></p><ul class=""><li id="70ce" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">在这种情况下，我们可以生成一个html文件，其中包含特定于请求页面的用户的所有内容。</li><li id="7d30" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">首先，我们需要知道用户是谁，以及它是否经过身份验证(策略1中的相同cookie很好)，然后向数据库发出请求以检索该用户的数据，最后生成自定义html以发送给客户端。</li><li id="6db9" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">注意:这个服务器就像一个ApiServer。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/77e31493d1c8e8526ecc4dac53314676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*FKK7emjeHVHjt8La909NGQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">ApiServer用于返回关于用户的数据(给定一个令牌cookie)</figcaption></figure><p id="db6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，如何决定呢？以下是每种策略的权衡</p><p id="dada" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">静态SSR </strong></p><ul class=""><li id="1169" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">最佳性能:服务器不需要生成文件(他们已经准备好了)</li><li id="296d" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">CDN / Caching / Gzip:因此，您可以在用户附近压缩和缓存文件，以降低网络调用的延迟。</li><li id="0cb7" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">需要“重量级”CSR:因为html文件非常简单，所以客户端将负责数据获取和呈现</li><li id="7110" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">需要管理html文件生成过程:您可以只手动编写一个html文件，但您很可能会使用一些进程管理器(如gulp)来调用一些进程来生成html。这是一个仅限于开发人员的过程，您可以在部署之前在您的机器上完成。</li><li id="f8d9" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">您仍然需要实现ApiServer，因为您确实可以将html、css和js文件作为静态文件提供，但是json数据很可能总是动态的并且依赖于用户。</li></ul><p id="b003" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">动态SSR </strong></p><ul class=""><li id="cfef" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">不是最佳性能:服务器需要为每个请求生成响应，所以性能仍然可以很好，但不是最佳的。</li><li id="cacc" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">缓存是可以做到的，但是比较棘手。</li><li id="0ac7" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">您不需要hmtl文件的构建过程(您正在动态创建html响应)。</li><li id="f91a" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">您不需要实现单独的服务器来处理数据需求(“ApiServer”)。</li><li id="b87a" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">你的客户端可以是轻量级的(但也可能因为其他原因而变得很重)。</li></ul><p id="fdf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们来谈谈客户端的渲染。</p><h2 id="69e8" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">客户端渲染</h2><p id="faae" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">如果我们希望定义非常“规范”，客户端渲染实际上是唯一“在用户眼前”发生的渲染。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nl"><img src="../Images/7ebc18dcb478957407b72139470f4c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pld1rm2Qa7iDZQ4EhDb7Dg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">好的(网页)，坏的(DOM)和丑的(SSR)😜</figcaption></figure><p id="a27c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图像中:</p><ul class=""><li id="ea05" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">SSR</strong>(HTML)是浏览器的“指令”。所以它不适合人类，除非你是开发者😎</li><li id="5c9d" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated"><strong class="kk iu">DOM</strong>(文档对象模型)它是浏览器执行html时的幕后工作。但是，同样的，它不适合人类。它代表了浏览器中正在发生的事情，以及一些有用的API来为页面添加行为、提供存储等等。</li><li id="c39b" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated"><strong class="kk iu">网页</strong>(实际渲染)，就是用户看到的和交互的。在图片中，谷歌主页。</li></ul><p id="79d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，所有的渲染都可以看作是一个包含4个步骤的过程:</p><ol class=""><li id="e919" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld nm my mz na bi translated">你点击了一个链接，浏览器要求提供互联网的网址。</li><li id="5365" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld nm my mz na bi translated">服务器用一个hmtl文件作出响应(由于DNS可以找到它)</li><li id="42d8" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld nm my mz na bi translated">bowser执行html文件，并启动页面在不久的将来可能需要的DOM apis。因此，用户现在可以在页面上看到“一些东西”。Javascript还没有工作，但它即将到来…</li><li id="c100" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld nm my mz na bi translated">javascript文件被执行，现在完全控制了页面中的内容。因此:</li></ol><ul class=""><li id="7b95" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated">SSR页面可以完全改变(更可能是“扩展”)</li><li id="0d1a" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">JS可以与DOM apis进行交互，从而平滑地、渐进地修改页面。</li><li id="7584" class="ms mt it kk b kl nc ko nd kr ne kv nf kz ng ld mx my mz na bi translated">用户看到并感受到一个响应页面，在他点击和手势之后事件发生。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/bcdeed8ab99d8ade48e1445c99f5a893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*9s2dL1wFjOZ8OTN_hHuGTQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">整个渲染过程循序渐进</figcaption></figure><h2 id="b1d8" class="lu lv it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">NAQ:非常见问题</h2><p id="1d64" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> 1。CSR流程何时停止？</strong></p><p id="fcaf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">= &gt;当用户单击页面上的链接时= &gt;这会告诉浏览器需要一个新的url = &gt;这会启动一个新的SSR-CSR循环。</p><p id="3350" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 2。浏览器位置的每次改变都会触发整个渲染周期？</strong></p><p id="65e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸好没有。</p><p id="7d72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你知道新页面不需要加载额外的javascript或者启动一个全新的循环，不要这样做(使用<strong class="kk iu"><em class="nb">window . history . replace state</em></strong>API)。否则使用<strong class="kk iu"><em class="nb">window . location . replace</em>T17】。</strong></p><p id="9c5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 3。用户是否注意到SSR和CSR之间的转换？</strong></p><p id="b336" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，也许。</p><p id="bced" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从服务器向用户呈现一些东西，然后有一个3秒钟的白色页面，最后在他的眼前有一个令人惊叹的页面，这确实是一个糟糕的做法。</p><p id="63d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免这种情况，您的客户端javascript必须知道页面何时准备好完全呈现，并同时显示一些加载器、闪屏或漂亮的消息。</p><p id="be73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> 4。做SSR需要框架吗？</strong></p><p id="2f49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸好没有。</p><p id="afcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我使用React(实际上是Preact)是因为它非常符合我的思维模式。此外，使用React，我可以在服务器(SSR)中将javascript代码转换为html字符串，并将页面从状态1转换为状态2(在客户端)，而不用担心协调或一些涉及DOM的命令性代码。</p><p id="79dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是！我目前的策略是不在服务器上进行大量渲染，而给客户端更多的能力。所以，我的html文件内容是轻量级的，不需要使用任何框架就可以生成。</p><p id="323a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，这取决于你…</p><p id="79e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这有所帮助。它不是框架驱动或代码驱动的，因为我认为这是理解原则和策略的方法，而不会迷失在实现细节中。</p><p id="2a3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自智利的欢呼！！🇨🇱</p></div></div>    
</body>
</html>