<html>
<head>
<title>Optimizing data access in JavaScript arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化JavaScript数组中的数据访问</h1>
<blockquote>原文：<a href="https://itnext.io/optimizing-data-access-in-javascript-arrays-dfd4894a4fc0?source=collection_archive---------3-----------------------#2018-11-18">https://itnext.io/optimizing-data-access-in-javascript-arrays-dfd4894a4fc0?source=collection_archive---------3-----------------------#2018-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bfc125475b8b0f74533eb07f7ebfbe85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dil-rSyT8dRrjhku2OoNqg.jpeg"/></div></div></figure><div class=""/><p id="2268" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我花了一些时间研究数组，我发现了一些有趣的地方，更具体地说是关于通过唯一键获取项目的最佳方式<strong class="ka jc">。</strong></p><h1 id="e75b" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">伪造一些数据</h1><p id="bda1" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，我写了一些实用函数。第一个用于生成一个由只有两个属性<strong class="ka jc"> id </strong>和<strong class="ka jc">内容</strong>的<em class="lz"> N </em>对象组成的数组。我想要这样的东西:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2789" class="mj kx jb mf b gy mk ml l mm mn">[<br/>  {<br/>    id: "key0",<br/>    content: "I ate pizza 0 times"<br/>  },<br/>  {<br/>    id: "key1",<br/>    content: "I ate pizza 1 times"<br/>  },<br/>  {<br/>    id: "key2",<br/>    content: "I ate pizza 2 times"<br/>  },<br/>  ...<br/>]</span></pre><p id="aeac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我需要另一个数组，这次包含要查找的对象的随机id，作为测试用例。因此，第二个效用函数用于返回类似于以下内容的结果:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b70f" class="mj kx jb mf b gy mk ml l mm mn">["key284", "key958", "key23", "key625", "key83", "key9", ... ]</span></pre><p id="1597" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦得到了源数组和要得到的物品的随机键，让我们看看谁参与了这个游戏，分析不同的方法。</p><h1 id="a45b" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">做同一件事的许多方法</h1><p id="7ac1" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将看到的每个函数都运行了<strong class="ka jc"> 10，000次迭代</strong>(在10，000个对象的数组中找到10，000个随机键)。<br/>为了简化，我没有执行任何空检查来查看具有特定id的对象是否不存在。在这种情况下，由于我们使用了实用函数来构建模型数据，随机键列表中的每个id将总是与源数组中的一个对象相匹配。</p><p id="f3d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在node环境中运行了这些函数(我也在Chrome中运行了这些函数，得到了或多或少相同的结果)。为了测量每个块所用的时间，我使用了<a class="ae mo" href="https://nodejs.org/api/perf_hooks.html" rel="noopener ugc nofollow" target="_blank"> performance.now() </a>并注册了<strong class="ka jc"> t1 </strong>和<strong class="ka jc"> t2 </strong>，分别在<strong class="ka jc"> </strong>运行函数之前和之后<strong class="ka jc"> </strong>。总时间<strong class="ka jc">毫秒</strong>将由<code class="fe mp mq mr mf b">t2 — t1</code>给出。</p><h2 id="4a28" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">本机for循环</h2><p id="6ec0" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">旧但很金。这种方法包括循环我们的数组，并检查每个元素的id是否与我们正在寻找的一致。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/81b02a357ea2cfef248b5e3d2aa71f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcajVsUsaAE7vtBChrHCOg.png"/></div></div></figure><h2 id="3f2f" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">本机while循环</h2><p id="ae2f" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">与之前使用的逻辑相同，但这次是在while循环中。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/73b27517efe29bf18ebe3f76befa3eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZix4kEO3zWbOhPZkK4vvA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">将链接到代码片段</figcaption></figure><h2 id="0e61" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">为了…在</h2><p id="4a1e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">尽管使用这种语法来迭代数组被认为是不好的，但我还是想涉及到它，我认为它有值得讨论的地方。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/71d58b1d19c1759c9c44a8a8390b2b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32v1oXpiVXAblwmtWaE2EA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520for%2520(let%2520i%2520in%2520list)%2520%257B%250A%2520%2520%2520%2520if%2520(list%255Bi%255D.id%2520%253D%253D%253D%2520id)%2520%257B%250A%2520%2520%2520%2520%2520%2520return%2520list%255Bi%255D%253B%250A%2520%2520%2520%2520%257D%250A%2520%2520%257D%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">链接</a>到片段</figcaption></figure><h2 id="60da" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">为了…的</h2><p id="0669" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这只是迭代数组元素。此外，它的语法简洁明了。我个人真的很喜欢。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/6cb4a6cef5094c340c9c3095a3eb020e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dllT7YCw09fIhhGaYclhzA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520for%2520(let%2520item%2520of%2520list)%2520%257B%250A%2520%2520%2520%2520if%2520(item.id%2520%253D%253D%253D%2520id)%2520%257B%250A%2520%2520%2520%2520%2520%2520return%2520item%253B%250A%2520%2520%2520%2520%257D%250A%2520%2520%257D%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">链接</a>到片段</figcaption></figure><h2 id="4d0b" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">。forEach()</h2><p id="1557" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">同样在这里，我们检查每个元素的<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">，看它是否有我们要找的id。当它出现时，我们把它赋给一个变量，最后我们返回这个变量。<br/> <em class="lz">注:</em> </a><a class="ae mo" href="https://stackoverflow.com/questions/2641347/short-circuit-array-foreach-like-calling-break" rel="noopener ugc nofollow" target="_blank"> <em class="lz">看为什么</em> </a> <em class="lz">我们不像在for循环中那样，提前返回一次找到的项。</em></p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/505a635d636c9a3cd0b71706a58aa45c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqn1akICid4bsNdqE850Jg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520let%2520result%253B%2520%250A%2520%2520%250A%2520%2520list.forEach(item%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520if%2520(item.id%2520%253D%253D%253D%2520id)%2520%257B%250A%2520%2520%2520%2520%2520%2520result%2520%253D%2520item%253B%250A%2520%2520%2520%2520%257D%250A%2520%2520%257D)%253B%250A%2520%2520%250A%2520%2520return%2520result%253B%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">将</a>链接到片段</figcaption></figure><h2 id="41e3" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">。map()和。索引Of()</h2><p id="1af2" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">用<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">。map() </a>我们首先将源数组转换成字符串id数组，然后使用<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener ugc nofollow" target="_blank">。indexOf() </a>来查找我们正在寻找的id的索引。因为源数组中的项和转换后的数组中的id具有相同的顺序，所以我们可以使用那个索引来访问我们的项。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/7ae1c914b984216b73ab4982ba52b6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15Aqq0mcmzgUt0vbirH2EA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520const%2520index%2520%253D%2520list.map(item%2520%253D%253E%2520item.id).indexOf(id)%253B%250A%2520%2520return%2520list%255Bindex%255D%253B%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">将</a>链接到片段</figcaption></figure><h2 id="0d24" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">。filter()和get first</h2><p id="a2fa" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这里我们用<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">。filter() </a>使数组只包含与条件<code class="fe mp mq mr mf b">item.id === id</code>匹配的项目。然后，我们只返回第一个匹配的元素，使用0作为索引来访问它。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/da460e0fa40d9090005e4133067d5550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZKsUCT_rgq03DljfbUpTQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520return%2520list.filter(item%2520%253D%253E%2520item.id%2520%253D%253D%253D%2520id)%255B0%255D%253B%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">将</a>链接到片段</figcaption></figure><h2 id="f0b8" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">。查找()</h2><p id="2258" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noopener ugc nofollow" target="_blank">这个方法</a>将一个函数作为输入，我们可以在这里设置一个条件，就像我们对。filter()，它返回与之匹配的第一个元素。这是我们可以用来达到目的的最短的语法。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/bb9dde29653601804f8896f496aead25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zOrrY5VwYL83NAGozL26w.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520return%2520list.find(item%2520%253D%253E%2520item.id%2520%253D%253D%253D%2520id)%253B%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">链接</a>到片段</figcaption></figure><h2 id="c12b" class="mj kx jb bd ky ms mt dn lc mu mv dp lg kj mw mx lk kn my mz lo kr na nb ls nc bi translated">。findIndex()</h2><p id="1105" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">与上面的非常相似，但是<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener ugc nofollow" target="_blank">它</a>返回匹配元素的索引。然后，我们可以使用该索引来访问我们的项目。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/3daf4177bff95119908798801fad8419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdTNBhcLc8K0r1T2VVPYqw.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520getItemById%2520%253D%2520(list%252C%2520id)%2520%253D%253E%2520%257B%250A%2520%2520const%2520index%2520%253D%2520list.findIndex(item%2520%253D%253E%2520item.id%2520%253D%253D%253D%2520id)%253B%250A%2520%2520return%2520list%255Bindex%255D%253B%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">将</a>链接到片段</figcaption></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="4421" class="kw kx jb bd ky kz np lb lc ld nq lf lg lh nr lj lk ll ns ln lo lp nt lr ls lt bi translated">谁花的时间少？</h1><p id="fd04" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">该图显示了我在测试用例中运行的每个函数所用的时间，单位为毫秒。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/75e00f803ff7db4e66a171b89b7e4689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6dbCNpLxVqqAPuc4j6koQ.png"/></div></div></figure><p id="d559" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我增加了两个选项，负for和while循环。基本上，我们不是递增循环控制变量，而是从数组的长度开始递减，直到它达到零。<a class="ae mo" href="https://stackoverflow.com/questions/3520688/javascript-loop-performance-why-is-to-decrement-the-iterator-toward-0-faster-t" rel="noopener ugc nofollow" target="_blank">这似乎<em class="lz">略微</em>加快了迭代</a>的速度。</p><p id="9a23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一件让我们眼前一亮的事情是for…in语法慢得令人难以置信。在我的测试中，对于循环，它几乎比普通的<em class="lz">慢9倍。为什么？嗯，语法中的<strong class="ka jc">for…是第一个能够迭代对象键的JavaScript语句。在对象键(<code class="fe mp mq mr mf b">{}</code>)上循环不同于在数组(<code class="fe mp mq mr mf b">[]</code>)上循环，因为<a class="ae mo" href="https://stackoverflow.com/questions/13488751/why-is-for-in-slow-in-javascript" rel="noopener ugc nofollow" target="_blank">引擎做了一些额外的工作来跟踪已经被迭代的属性</a>。当我们在数组上使用这种语法时，左边表达式中的变量被赋予数组索引。</strong></em></p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/b89e5f963c1b667f2a9355979add28b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fE38_OT5n6i2XivujQjsfA.png"/></div></div></figure><p id="b52d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，for…in在这两种情况下使用相同的算法。希望有人在读完这篇文章后会运行来删除他们代码中的那些语句。这是个不错的主意。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="496f" class="kw kx jb bd ky kz np lb lc ld nq lf lg lh nr lj lk ll ns ln lo lp nt lr ls lt bi translated">改变游戏规则的人</h1><p id="14e2" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">尽管我们有很多方法可以通过惟一键从数组中获取条目，但我推荐另一种方法，如果我们在应用程序中不止一次地访问同一个数组，这种方法会非常有用。</p><p id="35a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑下面的对象数组:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c66b" class="mj kx jb mf b gy mk ml l mm mn">[<br/>  {<br/>    "key": "4PXEVKq__II",<br/>    "name": "Undertow"<br/>  },<br/>  {<br/>    "key": "yCXrgASzf50",<br/>    "name": "Aenima"<br/>  },<br/>  {<br/>    "key": "6-uNyUmP9TA",<br/>    "name": "Lateralus"<br/>  },<br/>  {<br/>    "key": "wzmgWtl53Vs",<br/>    "name": "10,000 days"<br/>  }<br/>]</span></pre><p id="b6dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常情况下，如果我们需要快速获得这些对象中的一个，我们会使用<code class="fe mp mq mr mf b">array.find(o =&gt; o.key === myKey)</code>。</p><p id="6946" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而如果我们发现。find()ing几次，我们宁愿<strong class="ka jc">在一个键值对象</strong>中转换数组，其中<em class="lz">键</em>实际上是唯一键，值是对象本身。<br/>然后，我们将不再使用<code class="fe mp mq mr mf b">.find()</code>来获取一个条目，而只使用<code class="fe mp mq mr mf b">arrayObj[key]</code>，其中<code class="fe mp mq mr mf b">arrayObj</code>的结构如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5c81" class="mj kx jb mf b gy mk ml l mm mn">{<br/>  "4PXEVKq__II": {<br/>    "key": "4PXEVKq__II",<br/>    "name": "Undertow"<br/>  },<br/>  "yCXrgASzf50": {<br/>    "key": "yCXrgASzf50",<br/>    "name": "Aenima"<br/>  },<br/>  "6-uNyUmP9TA": {<br/>    "key": "6-uNyUmP9TA",<br/>    "name": "Lateralus"<br/>  },<br/>  "wzmgWtl53Vs": {<br/>    "key": "wzmgWtl53Vs",<br/>    "name": "10,000 days"<br/>  }<br/>}</span></pre><p id="5df8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自然，这个想法是<strong class="ka jc">不要在每次</strong>我们需要得到一个物品的时候执行转换，而是在使用它很多次之前执行转换。一个好的做法是总是在某个地方保存一个键值对象，以及我们的源数组。下面的例子展示了如何在Redux场景中做到这一点。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/8e5003e06c7fbd1e83766cc5385f316a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zRzLM_ktjfX_MJd9qunZQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=const%2520initialState%2520%253D%2520%257B%250A%2520%2520results%253A%2520%255B%255D%252C%250A%2520%2520resultsObj%253A%2520%257B%257D%250A%257D%253B%250A%250Aconst%2520reducer%2520%253D%2520(state%2520%253D%2520initialState%252C%2520action)%2520%253D%253E%2520%257B%250A%2520%2520switch%2520(action.type)%2520%257B%250A%250A%2520%2520%2520%2520case%2520%27LOAD_RESULTS%27%253A%250A%250A%2520%2520%2520%2520%2520%2520return%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520...state%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520results%253A%2520action.payload%252C%250A%2520%2520%2520%2520%2520%2520%2520%2520resultsObj%253A%2520transform(action.payload)%250A%2520%2520%2520%2520%2520%2520%257D%253B%250A%250A%2520%2520%2520%2520default%253A%250A%2520%2520%2520%2520%2520%2520return%2520state%253B%250A%250A%2520%2520%257D%250A%257D%253B&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">链接</a>到片段</figcaption></figure><p id="a16f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面代码片段中的函数<code class="fe mp mq mr mf b">transform()</code>的实现如下:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/022a47a4a608e2a093999285fa27c1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fV99GHjqlWkO5uM5hFOu1A.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><a class="ae mo" href="https://carbon.now.sh/?bg=rgba(171%2C184%2C195%2C0)&amp;t=material&amp;wt=none&amp;l=javascript&amp;ds=false&amp;dsyoff=20px&amp;dsblur=68px&amp;wc=false&amp;wa=false&amp;pv=48px&amp;ph=32px&amp;ln=false&amp;fm=Hack&amp;fs=14px&amp;lh=133%25&amp;si=false&amp;code=function%2520transform(arr)%2520%257B%250A%2520%2520return%2520arr.reduce((a%252C%2520b)%2520%253D%253E%2520%257B%250A%2520%2520%2520%2520return%2520%257B...a%252C%2520%255Bb.key%255D%253A%2520b%257D%253B%250A%2520%2520%257D%252C%2520%257B%257D)%253B%250A%257D&amp;es=2x&amp;wm=false&amp;ts=false" rel="noopener ugc nofollow" target="_blank">链接</a>到片段</figcaption></figure><p id="c54e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">准备好转换后的数据后，在我的测试案例中，使用<code class="fe mp mq mr mf b">object[key]</code>获得一个随机项目10，000次只需要<strong class="ka jc"> 2毫秒</strong>。</p></div></div>    
</body>
</html>