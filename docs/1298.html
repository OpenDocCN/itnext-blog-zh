<html>
<head>
<title>Dependency injection in React using InversifyJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用InversifyJS在React中进行依赖注入</h1>
<blockquote>原文：<a href="https://itnext.io/dependency-injection-in-react-using-inversifyjs-a38ff0c6601?source=collection_archive---------1-----------------------#2018-09-03">https://itnext.io/dependency-injection-in-react-using-inversifyjs-a38ff0c6601?source=collection_archive---------1-----------------------#2018-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/29cc4470f50e8f0663aba031c2b4f769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITU04s0BnNmGtAsbX9iCtQ.jpeg"/></div></div></figure><p id="5658" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">InversifyJS是一个强大的、轻量级的、易于使用的JavaScript依赖注入库。不幸的是，由于React的性质，将它用作组件特性并不简单。这是因为InversifyJS中的依赖注入依赖于构造函数注入，而React不希望用户扩展其组件的构造函数。</p><p id="01b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，有一些方法允许我们在React代码中使用控制反转。通过创建一个示例项目，我将向您展示在处理项目时如何绕过这个问题。</p><h1 id="1851" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">示例项目</h1><p id="8f40" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我已经为本文创建了一个简单的React项目。这里有趣的地方是:</p><ul class=""><li id="94e9" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">IoC初始化</li><li id="08bb" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><em class="mn"> NameProvider </em>类(它将提供一个由React组件显示的名称)</li></ul><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><em class="my">清单1 IoC初始化和域名提供商</em></figcaption></figure><p id="7f61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是InversifyJS的典型用法，创建一个新的IoC容器，我们将一个类绑定到该容器的给定标识符下(在本例中是一个<em class="mn">字符串</em>，但它也可以是一个<em class="mn">符号</em>或一个类型)。这是一个瞬态范围声明，这意味着对于每一次注入，它都将创建该类的一个新实例。还有单例作用域(每次注入总是相同的实例)和请求作用域(对<em class="mn"> container.get </em>的一次调用相同的实例)。</p><p id="0bda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个可以通过Inversify注入的类都必须用<em class="mn">可注入的</em>来修饰，通常是通过在构造函数内部或在属性上使用注入修饰器。然而，这在React中是不可能的，所以我们必须用不同的方法来做。</p><p id="12cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">项目的其余部分是一个简单的React应用程序。<em class="mn"> Hello </em>是一个使用provider在header中显示名称的组件。在<em class="mn">索引</em>中，我们将其呈现在DOM中。在我们注入我们的<em class="mn"> NameProvider </em>实例之前，代码不会工作。</p><h1 id="d229" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用inversify-inject-decorator</h1><div class="mz na gp gr nb nc"><a href="https://www.npmjs.com/package/inversify-inject-decorators" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">投资注入装饰者</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">用于InversifyJS的惰性求值属性注入装饰器</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.npmjs.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq jw nc"/></div></div></a></div><p id="85a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们不能进行构造函数注入时，这是使用Inversify的推荐方法。这个库提供了四个额外的装饰器在项目中使用:<em class="mn"> lazyInject </em>，<em class="mn"> lazyInjectNamed </em>，<em class="mn"> lazyInjectTagged </em>，<em class="mn"> lazyMultiInject </em>。顾名思义，它们提供了一个延迟求值的注入，这意味着在初始化对象时，不像通常那样提供依赖关系。相反，它是在第一次使用时提供的，然后缓存起来供以后使用。可以通过在初始化期间提供一个适当的布尔值来关闭缓存。</p><p id="138a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们首先执行<em class="mn"> getDecorators </em>函数，该函数将返回上面提到的Decorators。在这种情况下，我们将只使用<em class="mn"> lazyInject </em>，因为我们不使用名称或标签，也不在一个标识符下绑定多个类来使用多重注入。然后我们用<em class="mn"> lazyInject </em>来装饰我们的<em class="mn"> nameProvider </em>属性。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><em class="my">清单2 lazyInject导出和带有注入提供者的组件</em></figcaption></figure><p id="63db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在大多数React和InversifyJS项目中使用它相当简单。不幸的是，使用这种方法获得循环依赖是很常见的，尤其是在将容器模块放在单独的文件中，然后将它们合并到一个容器中，类似于ioc.ts文件。这可以通过将模块加载和导出<em class="mn"> lazyInject </em>分成单独的文件来避免。你可以在这里看到整个例子:</p><div class="mz na gp gr nb nc"><a href="https://github.com/tswistak/react-inversify-inject-decorators-example" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">tswistak/react-inversify-inject-decorators-示例</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">react+InversifyJS+inversify-inject-decorators。贡献给tswistak/react-inversify-inject-decorators-example…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nr l nn no np nl nq jw nc"/></div></div></a></div><h1 id="9cb2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用inversify-react</h1><div class="mz na gp gr nb nc"><a href="https://www.npmjs.com/package/inversify-react" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">反作用</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">要连接的组件和装饰器使用inversify进行反应。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.npmjs.com</p></div></div><div class="nl l"><div class="ns l nn no np nl nq jw nc"/></div></div></a></div><p id="d57d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">inversify-react是一个以稍微不同的方式执行依赖注入的库。在我们的使用中，我们得到一个React组件提供者，它保存IoC容器并向下传递给React树。我们还得到四个装饰器——<em class="mn">提供</em>、<em class="mn">提供. singleton </em>、<em class="mn">提供. transient </em>和<em class="mn">解决</em>。在我们的例子中，我们只需要解析获得依赖关系和<em class="mn">提供者</em>来将它传递给容器。<em class="mn"> resolve </em>的工作方式与前面方法中的<em class="mn"> lazyInject </em>类似，但它不需要任何初始化。</p><p id="3fe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用它，我们只需将我们的应用程序放在我们要向其传递IoC容器的<em class="mn"> Provider </em>组件中。在<em class="mn"> Hello </em>中，我们用<em class="mn"> resolve </em>来修饰<em class="mn"> nameProvider </em>，并为其提供一个合适的标识符。ioc.ts应保持不变(与之前的方法相反)。您可以在此处检查所有更改:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><em class="my">清单3提供者的用法和解析</em></figcaption></figure><p id="4b22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种简单的方法意味着我们不需要在IoC中做任何改变，我们只是沿着React树向下传递一个容器，并使用适当的装饰器获得依赖关系。然而，该库目前处于开发的早期阶段，API甚至可能在没有警告的情况下随时更改。另一个缺点是我们只能得到最简单的依赖注入。它将涵盖大多数情况，但我在一些项目中需要多次注入，这是我无法用这个库完成的。你可以在这里看到整个例子:</p><div class="mz na gp gr nb nc"><a href="https://github.com/tswistak/inversify-react-example" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">tswistak/inversify-react-example</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">reaction+InversifyJS+inversify-reaction。通过创建一个……为tsw stak/inversify-reaction-example开发做出贡献</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nt l nn no np nl nq jw nc"/></div></div></a></div><h1 id="8435" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用反应反转</h1><div class="mz na gp gr nb nc"><a href="https://www.npmjs.com/package/react-inversify" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">反应-反转</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">反应的依赖注射</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.npmjs.com</p></div></div><div class="nl l"><div class="nu l nn no np nl nq jw nc"/></div></div></a></div><p id="6992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个名字类似于以前的库，但是这个有一个完全不同的方法。我们有一个<em class="mn">提供者</em>组件，类似于逆向反应中的组件，还有一个更高阶的<em class="mn">连接</em>组件，它将依赖注入道具。</p><p id="a34c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它比以前的方法更难使用，因为我们没有在组件中使用装饰器。我们需要创建一个类，在那里我们以一种典型的方式注入依赖项，使用<em class="mn">注入</em>。然后，我们使用<em class="mn"> connect </em> HOC将这个类的一个实例提供给我们的组件的属性，如下所示:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><em class="my">列表4提供者和连接的用法</em></figcaption></figure><p id="9532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用法有点复杂，因为我们需要创建一个额外的类并用HOC包装我们的组件。在这个例子中，我把它作为一个装饰器，但是你也可以用传统的方式来使用它。一般来说，这个方法最符合React，因为对象是作为属性传递的，而不是在组件中实例化的。另一个优点是充分利用了InversifyJS，这意味着我们不需要依赖于库提供的东西——但是它确实比其他解决方案需要编写更多的代码。您可以在这里看到整个示例:</p><div class="mz na gp gr nb nc"><a href="https://github.com/tswistak/react-inversify-example" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">t wistak/reactor-inversify-示例</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">reactor+InversifyJS+reactor-inversify。通过创建一个……为tsw stak/react-inversify-示例开发做出贡献</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nv l nn no np nl nq jw nc"/></div></div></a></div><h1 id="c3dc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="c8cc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">因此，我们有三种方法在React项目中使用InversifyJS。每一种都有优点和缺点，也就是说没有完美的解决方案，但是我希望这能让您更容易地选择最适合您的项目的库。</p><p id="0cb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">帖子也发表在</em> <a class="ae nw" href="https://www.synergycodes.com/blog/dependency-injection-in-react-using-inversifyjs" rel="noopener ugc nofollow" target="_blank"> <em class="mn">协同代码博客</em> </a> <em class="mn">上。</em></p><p id="87de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您对创建数据可视化应用程序感兴趣吗？<a class="ae nw" href="https://synergycodes.com/gojs-ebook/" rel="noopener ugc nofollow" target="_blank">点击此处了解GoJS库</a>！</p></div></div>    
</body>
</html>