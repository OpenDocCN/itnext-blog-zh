<html>
<head>
<title>Minimize GO Resource Size With Docker Multi-Stage Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Docker多阶段构建最小化GO资源大小</h1>
<blockquote>原文：<a href="https://itnext.io/minimize-go-resource-size-with-docker-multi-stage-build-3b03cb9787e1?source=collection_archive---------4-----------------------#2019-11-05">https://itnext.io/minimize-go-resource-size-with-docker-multi-stage-build-3b03cb9787e1?source=collection_archive---------4-----------------------#2019-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/eef484b3e37fac0322b8154dba8e3088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*idyjx1em90uyvXGQHqstvw.png"/></div></figure><p id="dc44" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最近，我一直在探索<a class="ae kv" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>。鉴于我的后端经验主要是在NodeJS中，我预计会有一个急剧的学习曲线。但是到目前为止，并没有我预期的那么多拉头发。GO在强制执行严格的模式、规则和类型的同时保持语法的简洁性和代码的效率之间取得了良好的平衡。</p><p id="80c1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于GO是一种编译语言，并作为可执行文件运行，我们可以利用Docker 17的一个特性，<a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>。这个特性允许开发人员使用一个基本映像作为构建器，使用一个更有效或更小的映像作为最终资源的映像。本质上，多阶段允许您在另一个阶段使用一个阶段中的工件。</p><p id="17f2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这样做的主要好处是可以部署更小的映像。它还可以缩短开发生命周期中的构建时间，因为您可以选择所需的最少资源。</p><p id="bf38" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看如何:</p><p id="ce21" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我的例子中，我将创建一个包含大部分配置的<code class="fe kx ky kz la b">Dockefile</code>和两个<code class="fe kx ky kz la b">docker-compose</code>文件来说明如何支持多种构建环境，这是任何真实服务都应该具备的。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="11f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> Docker撰写</strong></p><p id="7a3f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">支持多种部署环境是一个非常典型的现实需求。当然，你不会看到docker-compose这样做。但是我一直更喜欢docker-compose，因为它的设置更简单，而且不需要在docker构建命令中加入变量。</p><p id="1c27" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于我的例子，我创建了两个docker-compose文件，主要区别是环境变量<em class="kw">、ENV。这个变量可以用来定义GO程序将使用哪个环境文件。</em></p><p id="324a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了发展:</p><p id="bfdd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> docker-compose-dev.yml </strong></p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="dd0d" class="lq lr it la b gy ls lt l lu lv">version: '3.5'<br/>services:<br/>  go-server:<br/>    build:<br/>      args:<br/>     <strong class="la iu">   - ENV=dev</strong><br/>      context: .<br/>    image: go-server-dev<br/>    container_name: go-server-box-dev<br/>    ports:<br/>      - "9000:9000"</span></pre><p id="732b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于生产:</p><p id="f34e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> docker-compose.yml </strong></p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="26d1" class="lq lr it la b gy ls lt l lu lv">version: '3.5'<br/>services:<br/>  go-server:<br/>    build:<br/>      args:<br/>    <strong class="la iu">    - ENV=prod</strong><br/>      context: .<br/>    image: go-server<br/>    container_name: go-server-box<br/>    ports:<br/>      - "4445:9000"</span></pre><p id="0767" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是我们需要的docker-compose文件。这两个文件将构建在同一个Dockerfile文件上。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="a61b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> Dockerfile ( </strong> <a class="ae kv" href="https://gist.github.com/cherihung/08dd99f520865a10e11fc19ab65af06e" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">要诀</strong> </a> <strong class="jz iu"> ) </strong></p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="6fe6" class="ly lr it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">构建阶段</h1><p id="e371" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated"><strong class="jz iu">选择操作系统映像并定义阶段(#1) </strong></p><p id="88dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一个独立的围棋程序执行起来并不需要太多。对于最小的资源，我想使用<code class="fe kx ky kz la b">alpine</code>作为<code class="fe kx ky kz la b">final</code> <em class="kw">阶段</em>操作系统，它只有大约5mb。因此，反过来，为了减少不同平台的复杂性，我将使用<code class="fe kx ky kz la b">golang:alpine</code>作为<code class="fe kx ky kz la b">builder</code> <em class="kw">阶段</em>操作系统。</p><p id="18ea" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要定义一个阶段，只需将名称放在<code class="fe kx ky kz la b">AS</code>之后，与您定义将图像放在哪里在同一行。正如您将看到的，我不会引用docker-compose文件中的每个<code class="fe kx ky kz la b">stage</code>。但是使用 <code class="fe kx ky kz la b"><a class="ae kv" href="https://docs.docker.com/compose/compose-file/#target" rel="noopener ugc nofollow" target="_blank">target</a></code> <a class="ae kv" href="https://docs.docker.com/compose/compose-file/#target" rel="noopener ugc nofollow" target="_blank">从3.4版</a><a class="ae kv" href="https://docs.docker.com/compose/compose-file/#target" rel="noopener ugc nofollow" target="_blank">开始docker-compose肯定支持。</a></p><p id="436c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">添加标签(#2) </strong></p><p id="a252" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我发现给我的<code class="fe kx ky kz la b">builder</code>形象贴上标签是个好习惯。这样，我可以通过标签轻松地过滤它，并在成功构建后删除它:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="c703" class="lq lr it la b gy ls lt l lu lv">docker image prune --filter label=stage=builder -f</span></pre><p id="73b3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">安装编译器依赖项(#3) </strong></p><p id="937e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在步骤#3中，它展示了一个安装只编译依赖项的例子— <code class="fe kx ky kz la b">gcc</code>和<code class="fe kx ky kz la b">libc-dev</code>。要进一步优化流程，您可以创建一个已经包含其他依赖项的基础映像。</p><p id="0725" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我还可以选择定义一个工作目录。减少阶段间混淆的良好实践。</p><p id="00d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">将所有源文件复制到构建(#4) </strong></p><p id="be08" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了准备构建，复制所有的GO源文件。</p><p id="d196" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">构建GO程序(#5) </strong></p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="8b3d" class="lq lr it la b gy ls lt l lu lv">CGO_ENABLED=0 GOOS=linux go build -a</span></pre><p id="c157" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个命令相当标准，因为我在很多例子中都遇到过。</p><p id="febd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，<code class="fe kx ky kz la b">CGO_ENABLED=0</code>禁用CGO，因为我是在alpine上构建的，要在alpine上运行，目标是使用<code class="fe kx ky kz la b">GOOS=linux</code>的Linux。禁用它可以消除编译跨平台依赖项的需要。<code class="fe kx ky kz la b">-a</code>标志执行强制重建。</p><p id="c90a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> <em class="kw">至此，围棋程序编译完毕！</em> </strong>👍</p><h1 id="ead5" class="ly lr it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">末级</h1><p id="b438" class="pw-post-body-paragraph jx jy it jz b ka mv kc kd ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku im bi translated"><strong class="jz iu">开始最终构建并读入环境变量(#6、#7) </strong></p><p id="7ebd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦第一个<code class="fe kx ky kz la b">build</code>阶段完成，我们继续下一个阶段，命名为<code class="fe kx ky kz la b">final</code>，在这里它使用<code class="fe kx ky kz la b">golang:alpine</code>图像作为基础。我们还读入docker-compose文件中定义的任何构建参数。在示例中，它只是一个<code class="fe kx ky kz la b">ENV</code>变量。</p><p id="171a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">复制编译好的GO可执行文件和环境文件(#8) </strong></p><p id="5ef2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">设置了<code class="fe kx ky kz la b">ENV</code>之后，下面的<code class="fe kx ky kz la b">COPY</code>命令从<code class="fe kx ky kz la b">build</code>阶段构建的工件中复制可执行文件和相应的env文件:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="856b" class="lq lr it la b gy ls lt l lu lv">COPY --from=builder /workspace/mygoexecutable .<br/>COPY --from=builder /workspace/_envs/env_$ENV.yaml ./_envs/</span></pre><p id="eab7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">定义状态命令</strong></p><p id="4009" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">与任何Docker流程一样，最后一步是定义在容器启动时做什么(<strong class="jz iu"> #9 </strong>)。对于一个GO程序，最简单的命令就是执行可执行文件:<code class="fe kx ky kz la b">CMD [ “./mygoexecutable” ]</code></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="2ccc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> Docker构建命令</strong></p><p id="afbe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">把它们绑在一起。现在我们可以运行docker构建命令:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="90b0" class="lq lr it la b gy ls lt l lu lv">docker-compose up --build -d</span></pre><p id="924c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">看看图像大小的差异:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/ca683b1a61b3df6e093d437431d2a3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7ec9-Uh5NIMzh5ZdHbKLg.png"/></div></div></figure><p id="6879" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于上下文——我在这里构建的示例GO服务是一个带有健康检查的非常简单的HTTP服务器，它使用了<a class="ae kv" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin-Tonic framework </a>。</p><p id="ad09" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们从列表中看到，用于建筑的基础<code class="fe kx ky kz la b">golang:alpine</code>图像是<strong class="jz iu"> 359MB </strong>。<code class="fe kx ky kz la b">build</code>包含所有依赖项和编译程序的stage镜像增加到<strong class="jz iu"> 602MB </strong>。</p><p id="60f2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，由于只能部署GO可执行文件，我们最终只能得到一个微小的<strong class="jz iu"> 24.2MB </strong>映像<code class="fe kx ky kz la b">go-server-dev:0.0.2</code>！💪</p></div></div>    
</body>
</html>