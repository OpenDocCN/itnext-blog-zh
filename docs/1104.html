<html>
<head>
<title>GraphQL using .NET Boxed: Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL。NET Boxed:查询</h1>
<blockquote>原文：<a href="https://itnext.io/graphql-using-net-boxed-queries-e4dff929bb35?source=collection_archive---------6-----------------------#2018-07-22">https://itnext.io/graphql-using-net-boxed-queries-e4dff929bb35?source=collection_archive---------6-----------------------#2018-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="81a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将继续我使用<a class="ae kl" href="https://github.com/Dotnet-Boxed/Templates" rel="noopener ugc nofollow" target="_blank">对<a class="ae kl" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的探索。NET Boxed </a>模板作为跳开点。我开始写的代码可以在<a class="ae kl" href="https://github.com/elanderson/ASP.NET-Core-GraphQl/tree/f8a353800ab5006c78b5445cc0204cb66f367147" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果您想从获取。NET盒装模板安装，检查出我的<a class="ae kl" href="https://elanderson.net/2018/07/asp-net-core-with-graphql-using-net-boxed/" rel="noopener ugc nofollow" target="_blank">ASP.NET核心与GraphQL使用。网框</a>帖。</p><h2 id="03e0" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">寻找线索</h2><p id="40d6" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">如上一篇文章所述，该项目的支持数据位于<strong class="jp ir"> Repositories/Database.cs </strong>文件中的一个静态类中。这些数据以星球大战为主题，由两个角色列表组成，一个是机器人的，另一个是人类的，这两个列表合并成一个角色列表。</p><p id="d2d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将从应用程序处理请求的角度来处理这个问题，而不是从数据开始并找出它在哪里被使用。对于ASP.NET核心应用程序，这意味着查看启动类的Configure函数，这是配置HTTP管道的地方。</p><p id="473d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Configure函数中，我们发现以下两个调用与GraphQL相关。我在两次调用中都删除了选项的实际设置。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="38d9" class="km kn iq lp b gy lt lu l lv lw">.UseGraphQLWebSocket&lt;MainSchema&gt;(new GraphQLWebSocketsOptions())<br/>.UseGraphQLHttp&lt;MainSchema&gt;(new GraphQLHttpOptions())</span></pre><p id="346e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看来MainSchema是我们需要跟进的线索。</p><h2 id="620a" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">主模式</h2><p id="c6d6" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">MainSchema类中没有很多代码。下面是模板生成的完整类。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="5c92" class="km kn iq lp b gy lt lu l lv lw">public class MainSchema : Schema<br/>{<br/>    public MainSchema(<br/>        QueryObject query,<br/>        MutationObject mutation,<br/>        SubscriptionObject subscription,<br/>        IDependencyResolver resolver)<br/>        : base(resolver)<br/>    {<br/>        this.Query = resolver.Resolve&lt;QueryObject&gt;();<br/>        this.Mutation = mutation;<br/>        this.Subscription = subscription;<br/>    }<br/>}</span></pre><p id="5d08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为基类的模式类是由。NET 库。就像GraphQL中的任何其他模式一样，它用于定义客户端可用的数据以及可以使用的查询类型。现在，我们将继续遵循查询类型，将变异和订阅留给以后的帖子。</p><h2 id="1728" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">查询对象</h2><p id="3116" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">对于模板，我们使用位于QueryObject类中的查询模式。下面是这个类，但是被简化为只包含一个实体的设置。对于我们的星球大战样本数据，我使用了人类的比特并丢弃了机器人。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="ab9b" class="km kn iq lp b gy lt lu l lv lw">public class QueryObject : ObjectGraphType&lt;object&gt;<br/>{<br/>    public QueryObject(IHumanRepository humanRepository)<br/>    {<br/>        this.Name = "Query";<br/>        this.Description = "The query type, represents all of the entry points into our object graph.";<br/><br/>        this.FieldAsync&lt;HumanObject, Human&gt;(<br/>            "human",<br/>            "Get a human by it's unique identifier.",<br/>            arguments: new QueryArguments(<br/>                new QueryArgument&lt;IdGraphType&gt;()<br/>                {<br/>                    Name = "id",<br/>                    Description = "The unique identifier of the human.",<br/>                }),<br/>            resolve: context =&gt; humanRepository.GetHuman(<br/>                context.GetArgument("id", <br/>                                    defaultValue: new Guid("94fbd693-2027-4804-bf40-ed427fe76fda")),<br/>                context.CancellationToken));<br/>    }<br/>}</span></pre><p id="90e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类构造函数需要一个类的实例，该实例用于访问为其定义查询的实体的数据，在本例中为IHumanRepository。</p><p id="4555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个类的关键是FieldAsync <humanobject human="">调用。这是允许获取单个人的查询的定义。第一个参数是查询的名称，第二个是查询的描述。</humanobject></p><p id="368e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，是查询需要执行的参数。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="eb33" class="km kn iq lp b gy lt lu l lv lw">arguments: new QueryArguments(<br/>                new QueryArgument&lt;IdGraphType&gt;()<br/>                {<br/>                    Name = "id",<br/>                    Description = "The unique identifier of the human.",<br/>                })</span></pre><p id="f454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，查询可以接受一个参数作为要返回的人的ID。最后一点是如何将这个查询解析为实际的后台数据。</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="b405" class="km kn iq lp b gy lt lu l lv lw">resolve: context =&gt; humanRepository.GetHuman(<br/>            context.GetArgument("id", <br/>                                defaultValue: new Guid("94fbd693-2027-4804-bf40-ed427fe76fda")),<br/>            context.CancellationToken))</span></pre><p id="a27b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，上下文允许我们使用上下文提取客户端传递的参数。获取名为的参数函数调用，如参数部分中所定义，并在对humanRepository的调用中使用它们。</p><h2 id="eaf1" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">对象图形类型</h2><p id="2996" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我想谈的最后一点是FieldAsync <humanobject human="">调用中两种类型的区别。Human是数据访问所使用的实体类型。HumanObject是包装在ObjectGraphType中的人。下面是完整的HumanObject类。</humanobject></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="fb20" class="km kn iq lp b gy lt lu l lv lw">public HumanObject(IHumanRepository humanRepository)<br/>{<br/>    this.Name = "Human";<br/>    this.Description = "A humanoid creature from the Star Wars universe.";<br/>    this.Field(x =&gt; x.Id, <br/>                    type: typeof(IdGraphType))<br/>              .Description("The unique identifier of the human.");<br/>    this.Field(x =&gt; x.Name)<br/>              .Description("The name of the human.");<br/>    this.Field(x =&gt; x.HomePlanet, nullable: true)<br/>              .Description("The home planet of the human.");<br/>    this.Field&lt;ListGraphType&lt;EpisodeEnumeration&gt;&gt;<br/>              (nameof(Character.AppearsIn), <br/>               "Which movie they appear in.");<br/>    <br/>    this.FieldAsync&lt;ListGraphType&lt;CharacterInterface&gt;, <br/>                    List&lt;Character&gt;&gt;(<br/>        nameof(Human.Friends),<br/>        "The friends of the character, or an empty list if they have none.",<br/>        resolve: context =&gt; <br/>                 humanRepository.GetFriends(context.Source,<br/>                                            context.CancellationToken));<br/>    this.Interface&lt;CharacterInterface&gt;();<br/>}</span></pre><p id="e03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式允许将额外的元数据添加到被包装的类型中。您可以在示例应用程序在开发模式下启动的模式区域playground中看到这项工作。</p><figure class="lk ll lm ln gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lx"><img src="../Images/b79849d1d66e0a7368eab4bab025ddbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N41Yl9XyKHxtj3uj.png"/></div></div></figure><h2 id="96c0" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">包扎</h2><p id="323d" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">我在GraphQL上的上一篇文章让我觉得它非常神奇。从客户端的角度来看确实如此。从服务器端来看，这种魔力伴随着一些复杂性。不要认为这是对GraphQL的判断，这只是在选择技术之前必须考虑的一个方面。随着我对GraphQL的服务器端越来越熟悉，我确信我刚刚学习时看到的一些复杂性将变得清晰。</p><p id="733c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相关的示例代码可以在这里找到<a class="ae kl" href="https://github.com/elanderson/ASP.NET-Core-GraphQl/tree/59792e870382dba7c6c40d444cfe573577b2569b" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="ac56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mm">原载于</em> <a class="ae kl" href="https://elanderson.net/2018/07/graphql-using-net-boxed-queries/" rel="noopener ugc nofollow" target="_blank"> <em class="mm">安德森</em> </a> <em class="mm">。</em></p></div></div>    
</body>
</html>