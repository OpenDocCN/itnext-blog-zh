<html>
<head>
<title>Kubernetes in a box</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">盒子里的Kubernetes</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-in-a-box-7a146ba9f681?source=collection_archive---------1-----------------------#2022-10-16">https://itnext.io/kubernetes-in-a-box-7a146ba9f681?source=collection_archive---------1-----------------------#2022-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/fd893b1552398f2092758fc2cb85803a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hApo9XGWpo-opvBr"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@miagolic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米娅·戈利奇</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="83c4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将对任何有兴趣以一种可重复且简单的方式建立本地Kubernetes开发/测试环境的人有所帮助。这个博客的源代码可以在这个<a class="ae jd" href="https://github.com/Piotr1215/kubernetes-box" rel="noopener ugc nofollow" target="_blank">配套资源库</a>中找到。</p><p id="b809" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相同的内容发布到我的网页上，在那里你可以找到博客、文档和云原生相关的练习:cloudrumble.net</p><p id="9421" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本地Kubernetes环境有用的原因有几个:</p><ul class=""><li id="c122" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">云原生应用开发，包括共享</li><li id="6ce1" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在部署到产品之前检查新的舵图</li><li id="34b8" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">测试基础设施变更和配置</li><li id="75bf" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">测试新的Kubernetes版本</li></ul><p id="9d00" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这个清单还不止这些。</p><p id="8352" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于本地或测试Kubernetes环境非常有用，它的创建应该完全自动化。让我们学习如何做它。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lp"><img src="../Images/dfface51d7addfe7a3f38bcf29cadf9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*345knGhLO5dxsZn6"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">莱尼·屈尼在Unsplash的照片</figcaption></figure><h1 id="4663" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">选择什么设置</h1><p id="2c33" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">运行本地Kubernetes实例有很多选择，但我们将重点关注KIND。KIND非常容易维护，设置起来也很快。第二好的IMO是<code class="fe mx my mz na b">k3s</code>。</p><ul class=""><li id="594a" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae jd" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> Minikube </a></li><li id="b8eb" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae jd" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> MicroK8s </a></li><li id="a751" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf jh"> → </strong> <a class="ae jd" href="https://kind.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank">种类</a>在Docker中Kubernetes</li><li id="0d90" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae jd" href="https://www.vagrantup.com/" rel="noopener ugc nofollow" target="_blank">流浪汉</a>和<a class="ae jd" href="https://www.virtualbox.org/" rel="noopener ugc nofollow" target="_blank"> VirtualBox </a></li><li id="4624" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae jd" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker桌面</a></li><li id="5dc2" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae jd" href="https://rancherdesktop.io/" rel="noopener ugc nofollow" target="_blank">牧场主桌面</a></li><li id="c7f3" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae jd" href="https://github.com/k3s-io/k3s" rel="noopener ugc nofollow" target="_blank"> k3s </a>也带有<a class="ae jd" href="https://k3d.io/v5.4.6/" rel="noopener ugc nofollow" target="_blank"> k3d </a>包装</li></ul><h1 id="1e7f" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">命令式vs陈述式</h1><p id="6388" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">在我们开始设置之前，让我们先讨论一下<em class="nb">声明式</em> vs <em class="nb">命令式</em>方法。在devo PS/云原生世界中，任何<em class="nb">命令</em>通常都是不被认可的。我认为这两种方法都有道理，取决于具体情况。</p><blockquote class="nc nd ne"><p id="7075" class="kd ke nb kf b kg kh ki kj kk kl km kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated"><em class="jg">每当谈到</em> <strong class="kf jh"> <em class="jg">某物vs别的什么</em> </strong> <em class="jg">的时候，确实是在讲什么时候用</em> <strong class="kf jh"> <em class="jg">某物</em> </strong> <em class="jg">和什么时候用</em> <strong class="kf jh"> <em class="jg">别的什么</em> </strong> <em class="jg">。</em></p></blockquote><p id="67ed" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个启发，我们将根据需求和我们想要达到的目标使用这两种方法。</p><h1 id="d7fa" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">这就像一个Makefile，只是更好</h1><p id="4ba0" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">建立一个本地或测试Kubernetes环境意味着编排一堆命令，包括脚本、YAML文件、舵图等。在<em class="nb">命令式</em>范例中，这通常通过<code class="fe mx my mz na b">Makefile</code>或<code class="fe mx my mz na b">bash scripts</code>来完成。</p><p id="0ee5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">make</code>的问题在于，它被设计成<em class="nb">构建C源代码的工具，它可以</em>运行命令，但这不是它的目的。这意味着当使用<code class="fe mx my mz na b">Makefile</code>时，我们承担了构建部分所有不必要的负担。</p><p id="c2c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mx my mz na b">Bash scripts</code>稍微好一点，但是过了一会儿它们就变得过于啰嗦和沉重了。当使用<code class="fe mx my mz na b">defensive coding</code>实践创建设置时尤其如此。</p><p id="59c4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一种工具结合了两者的优点；<a class="ae jd" href="https://github.com/casey/just" rel="noopener ugc nofollow" target="_blank">只是</a>与<code class="fe mx my mz na b">make</code>类似，但侧重于命令编排。</p><blockquote class="nc nd ne"><p id="1296" class="kd ke nb kf b kg kh ki kj kk kl km kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated"><em class="jg">你会在后面的动作示例部分看到一个</em> <code class="fe mx my mz na b"><em class="jg">justfile</em></code> <em class="jg">。</em></p></blockquote><h1 id="1f5a" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">声明式方法仍然是我们的朋友</h1><p id="a4e0" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated"><code class="fe mx my mz na b">Justfile</code>包含快速创建和销毁本地集群所需的所有命令性逻辑。它暴露了各种旋钮和按钮，供我们与之交互或更改设置。</p><p id="90d5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在来看集群应用。安装舵图、操作符或简单的YAML文件可以使用GitOps进程声明性地完成。这可以通过<code class="fe mx my mz na b">Flux</code>或<code class="fe mx my mz na b">ArgoCD</code>完成。对于快速的本地设置，<a class="ae jd" href="https://argo-cd.readthedocs.io/en/stable/getting_started/" rel="noopener ugc nofollow" target="_blank"> ArgoCD </a>由于其强大的网络客户端而更加用户友好。在这里，我们利用<code class="fe mx my mz na b">app of apps</code>模式引导来自单一来源的额外应用。<a class="ae jd" href="https://kubito.dev/posts/automated-argocd-app-of-apps-installation/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>很好地描述了这个模式。</p><blockquote class="nc nd ne"><p id="e046" class="kd ke nb kf b kg kh ki kj kk kl km kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated">我们只是触及了ArgoCD或GitOps的皮毛。你可以在 <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/gitops-with-kubernetes-740f37ea015b"> <em class="jg">这里</em> </a> <em class="jg">和</em> <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/gitopsify-cloud-infrastructure-with-crossplane-and-flux-d605d3043452"> <em class="jg">这里</em> </a> <em class="jg">阅读更多关于GitOps的内容。</em></p></blockquote><h1 id="5bb7" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">合作</h1><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/ab761d6c217c0d5ec4d924ac787a6feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ppIDYsDYNzUGo0hv"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@krakenimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> krakenimages </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1fa2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本地设置不排除协作。我们可以通过两种主要方式按需协作。</p><ul class=""><li id="54d4" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">使用<strong class="kf jh"> ngrok </strong>在互联网上显示本地端口并共享我们的Kubernetes应用程序</li><li id="8040" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">接受PRs到我们的ArgoCD库，让其他人在我们的集群上安装基础设施/应用程序</li></ul><blockquote class="nc nd ne"><p id="654b" class="kd ke nb kf b kg kh ki kj kk kl km kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/expose-local-kubernetes-service-on-internet-using-ngrok-2888a1118b5b"> <em class="jg">点击此处了解更多关于使用ngrok在互联网上共享本地Kubernetes服务的信息。</em></a></p></blockquote><h1 id="c85c" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">示例设置</h1><p id="0bed" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我使用类似的设置来测试<a class="ae jd" href="https://github.com/upbound/universal-crossplane" rel="noopener ugc nofollow" target="_blank">通用交叉平面</a> (uxp)，它是<a class="ae jd" href="https://crossplane.io/" rel="noopener ugc nofollow" target="_blank">交叉平面</a>的上游分支。</p><p id="14db" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入<code class="fe mx my mz na b">just&lt;TAB&gt;</code>将显示所有可用的公正目标。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/6933d84d8b376def77fa63791099c9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tb_vQ7Vj8DHZO1MzNctNA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">只有参数</figcaption></figure><pre class="lq lr ls lt gt nk na nl nm aw nn bi"><span id="735e" class="no lv jg na b gy np nq l nr ns">set export<br/>set shell := ["bash", "-uc"]</span><span id="4233" class="no lv jg na b gy nt nq l nr ns">yaml    := justfile_directory() + "/yaml"<br/>scripts := justfile_directory() + "/scripts"</span><span id="a220" class="no lv jg na b gy nt nq l nr ns">browse      := if os() == "linux" { "xdg-open "} else { "open" }<br/>copy        := if os() == "linux" { "xsel -ib"} else { "pbcopy" }</span><span id="4a9d" class="no lv jg na b gy nt nq l nr ns">argocd_port  := "30950"<br/>cluster_name := "control-plane"</span><span id="2399" class="no lv jg na b gy nt nq l nr ns">export gcp_provider_version     := "v0.15.0"</span><span id="0276" class="no lv jg na b gy nt nq l nr ns"># this list of available targets<br/># targets marked with * are main targets<br/>default:<br/>  @just --list --unsorted</span><span id="e4c2" class="no lv jg na b gy nt nq l nr ns"># * setup kind cluster with GCP official provider and ArgoCD<br/>setup_infra: setup_kind setup_uxp setup_gcp setup_argo</span><span id="437c" class="no lv jg na b gy nt nq l nr ns"># setup kind cluster<br/>setup_kind:<br/>  #!/usr/bin/env bash<br/>  set -euo pipefail</span><span id="b8a3" class="no lv jg na b gy nt nq l nr ns">  echo "Creating kind cluster - {{cluster_name}}"<br/>  envsubst &lt; kind-config.yaml | kind create cluster --config - --wait 3m<br/>  kind get kubeconfig --name {{cluster_name}}<br/>  kubectl config use-context kind-{{cluster_name}}</span><span id="de57" class="no lv jg na b gy nt nq l nr ns"># setup Universal Crossplane<br/>setup_uxp:<br/>  echo "Installing UXP"<br/>  kubectl create namespace upbound-system<br/>  helm repo add upbound-stable https://charts.upbound.io/stable &amp;&amp; helm repo update<br/>  helm install uxp --namespace upbound-system upbound-stable/universal-crossplane --devel<br/>  kubectl wait --for condition=Available=True --timeout=300s deployment/xgql --namespace upbound-system</span><span id="e9c5" class="no lv jg na b gy nt nq l nr ns"># setup GCP Crossplane provider<br/>setup_gcp:<br/>  @echo "Setting up GCP Crossplane provider"<br/>  @kubectl config use-context kind-control-plane<br/>  @envsubst &lt; {{yaml}}/gcp-provider.yaml | kubectl apply -f -<br/>  @kubectl wait --for condition=healthy --timeout=300s provider/provider-gcp</span><span id="05c7" class="no lv jg na b gy nt nq l nr ns"># setup ArgoCD and patch server service to nodePort 30950<br/>setup_argo:<br/>  @echo "Installing ArgoCD"<br/>  @kubectl create namespace argocd<br/>  @kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml<br/>  @kubectl wait --for condition=Available=True --timeout=300s deployment/argocd-server --namespace argocd<br/>  @kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "NodePort"}}'<br/>  @kubectl patch svc argocd-server -n argocd --type merge --type='json' -p='[{"op": "replace", "path": "/spec/ports/0/nodePort", "value": {{argocd_port}}}]'</span><span id="43c7" class="no lv jg na b gy nt nq l nr ns"># copy ArgoCD server secret to clipboard and launch browser without port forwarding<br/>launch_argo:<br/>  @kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d | {{copy}}<br/>  @nohup {{browse}} http://localhost:{{argocd_port}} &gt;/dev/null 2&gt;&amp;1 &amp;</span><span id="a668" class="no lv jg na b gy nt nq l nr ns"># bootstrap ArgoCD apps<br/>bootstrap_apps:<br/>  @kubectl apply -f bootstrap.yaml</span><span id="0660" class="no lv jg na b gy nt nq l nr ns"># * delete KIND cluster<br/>teardown:<br/>  @echo "Delete KIND cluster"<br/>  @kind delete clusters control-plane</span></pre><h1 id="31ad" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">YAML文件中的替代变量</h1><p id="b8b5" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">有时我们需要用自定义值来修补YAML文件。</p><p id="8269" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以模仿YAML。我们可以用<a class="ae jd" href="https://helm.sh/docs/topics/charts/" rel="noopener ugc nofollow" target="_blank">头盔图</a>包装，用<a class="ae jd" href="https://carvel.dev/ytt/" rel="noopener ugc nofollow" target="_blank"> ytt </a>，<a class="ae jd" href="http://localhost:8098/page/jsonnet" rel="noopener ugc nofollow" target="_blank"> jsonnet </a>，<a class="ae jd" href="https://mikefarah.gitbook.io/yq/" rel="noopener ugc nofollow" target="_blank"> yq </a>，<a class="ae jd" href="https://github.com/kubernetes-sigs/kustomize" rel="noopener ugc nofollow" target="_blank"> kustomize </a>或者其他很多。这些都是有效的方法，但是对于本地环境，有一个更简单的方法。</p><p id="ebb3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<code class="fe mx my mz na b">envsubst</code>来代替。它是<a class="ae jd" href="https://www.gnu.org/software/gettext/manual/gettext.html" rel="noopener ugc nofollow" target="_blank"> GNU gettext实用程序</a>的一部分，应该已经安装在您的系统上了。这个工具使我们能够动态地修补环境变量。</p><h1 id="d795" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">创建集群</h1><p id="e84d" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">这将创建一个安装了ArgoCD和UXP的本地类集群。</p><blockquote class="nc nd ne"><p id="8102" class="kd ke nb kf b kg kh ki kj kk kl km kn nf kp kq kr ng kt ku kv nh kx ky kz la ij bi translated">这个设置应该可以在Linux和Mac上运行，但是我只在Linux上测试过</p></blockquote><p id="71ae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe mx my mz na b">root</code>文件夹运行</p><pre class="lq lr ls lt gt nk na nl nm aw nn bi"><span id="8259" class="no lv jg na b gy np nq l nr ns">just setup_infra</span></pre><p id="f97c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦一切都设置好了，启动ArgoCD并登录</p><pre class="lq lr ls lt gt nk na nl nm aw nn bi"><span id="099e" class="no lv jg na b gy np nq l nr ns">just launch_argo</span></pre><ul class=""><li id="45c7" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">用户名:<strong class="kf jh">管理员</strong></li><li id="7474" class="lb lc jg kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">密码:<strong class="kf jh">应该在你的剪贴板</strong>里，所以把它粘贴到<code class="fe mx my mz na b">password</code>文本框里就行了。如果这不起作用，您可以运行<code class="fe mx my mz na b">@kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d</code>来获取密码。</li></ul><h2 id="eeb3" class="no lv jg bd lw nu nv dn ma nw nx dp me ko ny nz mi ks oa ob mm kw oc od mq oe bi translated">安装更多内容</h2><p id="942a" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">ArgoCD的引导应用程序一旦部署，就会观察<code class="fe mx my mz na b">apps</code>目录的任何变化。</p><pre class="lq lr ls lt gt nk na nl nm aw nn bi"><span id="a122" class="no lv jg na b gy np nq l nr ns">just bootstrap_apps</span></pre><p id="f024" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目录中已经有2个示例应用程序。</p><pre class="lq lr ls lt gt nk na nl nm aw nn bi"><span id="27f6" class="no lv jg na b gy np nq l nr ns">apiVersion: argoproj.io/v1alpha1<br/>kind: Application<br/>metadata:<br/>  name: bootstrap<br/>  namespace: argocd<br/>spec:<br/>  destination:<br/>    namespace: argocd<br/>    server: https://kubernetes.default.svc<br/>  project: default<br/>  source:<br/>    path: apps<br/>    repoURL: https://github.com/Piotr1215/kubernetes-box<br/>    targetRevision: HEAD<br/>  syncPolicy:<br/>    automated:<br/>      selfHeal: true<br/>    syncOptions:<br/>    - CreateNamespace=true</span></pre><p id="35b0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将通过ArgoCD将所有应用程序从<code class="fe mx my mz na b">apps</code>文件夹部署到集群中。</p><h1 id="1395" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">摧毁集群</h1><pre class="lq lr ls lt gt nk na nl nm aw nn bi"><span id="762f" class="no lv jg na b gy np nq l nr ns">just teardown</span></pre><h1 id="57e5" class="lu lv jg bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">摘要</h1><p id="ba4d" class="pw-post-body-paragraph kd ke jg kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">部署本地/测试Kubernetes实例可以而且应该完全自动化。我们已经看到了如何使用<em class="nb">声明性</em>和<em class="nb">命令性</em>技术帮助我们创建一个功能齐全的集群，能够公开Kubernetes服务并与任何愿意贡献内容的人协作。</p><p id="5daf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种设置可以很容易地过渡到生产集群。然而，在这种情况下，安装的<em class="nb">命令性</em>组件应该转换为<em class="nb">声明性</em>方法，以帮助长期维护。</p><p id="c0d2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用这个设置来测试<a class="ae jd" href="https://docs.upbound.io/uxp/" rel="noopener ugc nofollow" target="_blank">通用交叉平面</a>及其提供者。你会用它做什么？你认为你会改进，改变部分设置吗？请在评论中告诉我。</p></div></div>    
</body>
</html>