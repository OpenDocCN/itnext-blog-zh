<html>
<head>
<title>Azure DevOps Pipelines: Manual Tagging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure DevOps管道:手动标记</h1>
<blockquote>原文：<a href="https://itnext.io/azure-devops-pipelines-manual-tagging-244721c16c38?source=collection_archive---------3-----------------------#2020-04-27">https://itnext.io/azure-devops-pipelines-manual-tagging-244721c16c38?source=collection_archive---------3-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3d36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本周的帖子中，我们将讨论手动标记，而不是使用Azure DevOps内置的标记功能。这篇文章将使用一个在过去几周的文章中构建的示例Azure DevOps项目。如果你想知道这个项目是如何进行到这一步的，请看下面的帖子。</p><p id="badb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://elanderson.net/2020/02/getting-started-with-azure-devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS入门</a><br/><a class="ae kl" href="https://elanderson.net/2020/03/pipeline-creation-in-azure-devops/" rel="noopener ugc nofollow" target="_blank">Azure devo PS中的管道创建</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-publish-asp-net-core/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps为ASP.NET核心发布工件</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-pipelines-multiple-jobs-in-yaml/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:YAML的多个作业</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/03/azure-devops-pipelines-reuseable-yaml/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:可重用的YAML </a> <br/> <a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-use-yaml-across-repos/" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道:跨Repos使用YAML</a><br/><a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-conditionals-in-yaml/" rel="noopener ugc nofollow" target="_blank">Azure devo PS管道:YAML的条件</a> <br/> <a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-naming-and-tagging/" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/d8d0db25133044aa48b7d931bbd010ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*0oQPcylaECH5-6_y.png"/></div></figure><h2 id="8ce5" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">为什么？</h2><p id="0d9b" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">当事件发生时，标签为您提供关于您的回购状态的信息，这是我们案例的一个构建。这非常有用，特别是当你需要一个地方来安装补丁的时候。我的<a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-naming-and-tagging/" rel="noopener ugc nofollow" target="_blank">Azure devo PS Pipelines:Naming and Tagging</a>帖子中提到的自动标记是一种可行的方法，它已经在我95%的项目中使用。我有几个项目，自动标记由于某种原因无法工作。因为我不知道为什么Azure DevOps不标记，所以我不得不在管道中添加一个作业来执行标记。</p><h2 id="4bae" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">许可</h2><p id="4528" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">要执行此手动标记，我们管道中使用的帐户将需要为我们的回购提供contribute权限，以便它能够推送标记。使用左下方的齿轮打开项目设置页面。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/1e0de7041c6d5f0c2d553a6981205378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-GfS8QmMFu6DTlXh.png"/></div></div></figure><p id="f3b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择<strong class="jp ir">存储库</strong>选项，然后单击您想要更改其设置的特定回购协议，<strong class="jp ir">游乐场</strong>是我们在示例中使用的回购协议。请注意，如果您想要更改所有回购的权限，也可以使用顶级的<strong class="jp ir"> Git repositories </strong>选项来更改该设置。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lx"><img src="../Images/80fef8e5ba2df6097ece16cf062b15fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NTuE8UbD41btIHmO.png"/></div></div></figure><p id="461d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir"> Users </strong>下的<strong class="jp ir"> Security </strong>选项卡上，查找名称中包含<strong class="jp ir"> Build Service </strong>的用户并选择它。当用户被选中时，它会在用户的右边显示他们的权限。找到<strong class="jp ir">贡献</strong>选项，将其值改为<strong class="jp ir">允许</strong>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/0d6783a887e41489f5e6ace3ed2f596c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PExdy-BZfk-OOQN_.png"/></div></div></figure><h2 id="9285" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">YAML的变化</h2><p id="809a" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">快速提醒一下，这个项目的YAML目前有3个职位。两个web应用程序构建(WebApp1、WebApp2)，第三个作业展示了如何使用作业依赖关系(DependentJob)。我将跳过显示这些现有工作的YAML，但如果你需要完整的现有YAML，可以在顶部链接的帖子中找到。</p><p id="82a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们已经有多个作业在我们的管道中，我们将添加标记代码作为一个新的作业。这将很容易让我们只在所有其他作业成功运行时进行标记。以下是这份新工作的完整YAML。</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="2a22" class="ku kv iq lz b gy md me l mf mg">- job: TagSources<br/>  displayName: 'Tag Sources'<br/>  pool:<br/>    vmImage: 'ubuntu-latest'<br/><br/>  dependsOn:<br/>  - WebApp1<br/>  - WebApp2<br/>  - DependentJob<br/> <br/>  steps:<br/>  - checkout: self<br/>    persistCredentials: true<br/>    clean: true<br/>    fetchDepth: 1<br/><br/>  - task: PowerShell@2<br/>    inputs:<br/>      targetType: 'inline'<br/>      script: |<br/>        $env:GIT_REDIRECT_STDERR` = '2&gt;&amp;1'<br/>        $tag = "manual_$(Build.BuildNumber)".replace(' ', '_')<br/>        git tag $tag<br/>        Write-Host "Successfully created tag $tag" <br/><br/>        git push --tags<br/>         Write-Host "Successfully pushed tag $tag"     <br/><br/>      failOnStderr: false</span></pre><p id="3043" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，您会看到，在这个新作业运行之前，这个作业依赖于我们现有的三个作业来成功完成。</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="6695" class="ku kv iq lz b gy md me l mf mg">dependsOn: <br/>- WebApp1 <br/>- WebApp2 <br/>- DependentJob</span></pre><p id="1f7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从<strong class="jp ir">步骤</strong>部分开始，您会看到一个<strong class="jp ir">检查</strong>步骤，通常由作业自动处理，但在这种情况下，我们需要使用<strong class="jp ir"> persistCredential </strong>选项，这样作业仍将被授权，并允许我们推送到git repo。<strong class="jp ir">自身</strong>选项用于表示当前回购/分支。更多信息见官方<a class="ae kl" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema%2Cparameter-schema#checkout" rel="noopener ugc nofollow" target="_blank">结账文件</a>。</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="d829" class="ku kv iq lz b gy md me l mf mg">- checkout: self<br/>  persistCredentials: true<br/>  clean: true<br/>  fetchDepth: 1</span></pre><p id="3c56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这项工作的最后一部分是执行实际标记和推送的PowerShell任务。我在stackoverflow和/或GitHub上找到了大部分内容，但是已经有一段时间了，所以我手头没有相关链接。StdErr的内容是解决一些git输出，这些输出不会影响标记，但会导致作业被标记为失败。除此之外，它使用标准的git命令来标记和推送。</p><pre class="kn ko kp kq gt ly lz ma mb aw mc bi"><span id="ea03" class="ku kv iq lz b gy md me l mf mg">- task: PowerShell@2<br/>  inputs:<br/>    targetType: 'inline'<br/>    script: |<br/>      $env:GIT_REDIRECT_STDERR` = '2&gt;&amp;1'<br/>      $tag = "manual_$(Build.BuildNumber)".replace(' ', '_')<br/>      git tag $tag<br/>      Write-Host "Successfully created tag $tag" <br/><br/>      git push --tags<br/>       Write-Host "Successfully pushed tag $tag"     <br/><br/>    failOnStderr: false</span></pre><h2 id="25eb" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">包扎</h2><p id="7f18" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">我真心希望你们都不用这个。锻炼是一件非常痛苦的事情。这也是为了解决Azure DevOps内置标签支持的一些问题。公平地说，我可以看到在更复杂的管道中，您可能需要某种程度的灵活性，而内置标记无法提供这种灵活性，这将是您唯一的选择。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="b02f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mo">原载于</em><a class="ae kl" href="https://elanderson.net/2020/04/azure-devops-pipelines-manual-tagging/" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a><em class="mo">。</em></p></div></div>    
</body>
</html>