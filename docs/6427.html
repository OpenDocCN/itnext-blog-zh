<html>
<head>
<title>Native-image with Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot本土形象</h1>
<blockquote>原文：<a href="https://itnext.io/native-image-spring-boot-2862371d3149?source=collection_archive---------4-----------------------#2021-11-14">https://itnext.io/native-image-spring-boot-2862371d3149?source=collection_archive---------4-----------------------#2021-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/91a669d8ce23aba0af06b173f9ad8062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Mx3i3W4ECNNSl0sF9N1lw.png"/></div></div></figure><p id="ffa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">云实现了许多以前不可能实现的新用途。其中包括无服务器:</p><blockquote class="kw kx ky"><p id="fb61" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq">无服务器计算是一种云计算执行模式，其中云提供商按需分配机器资源，代表客户管理服务器。无服务器计算不在易失性存储器中保存资源；计算是在短时间内完成的，结果保存在存储器中。当应用程序不在使用中时，没有计算资源分配给该应用程序。</em></p><p id="1e9a" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq">——</em><a class="ae ld" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank"><em class="iq">维基</em> </a></p></blockquote><p id="b502" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，为了管理锁定单个云供应商的风险，人们可以避开他们的特定服务，选择Kubernetes。</p><p id="ce27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这两种情况下，尤其是在前一种情况下，运输舱/容器的寿命很短。因此，启动时间对整个系统的性能有很大的影响。很明显，这是一个JVM没有表现出来的领域。</p><p id="6a86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，Oracle提供了GraalVM，它包含一个字节码到二进制的AOT编译器。我一直在关注GraalVM在几个版本上的改进，独立的和与Spring Boot集成的。</p><p id="2b17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring框架是在十多年前设计的，当时还没有这个问题。另一方面，几年前出现了拥抱云和AOT的Spring竞争者:<br/> Micronaut和Quarkus。</p><p id="bf9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个由三部分组成的系列中，我想依次看看它们，剖析几个主题:</p><ul class=""><li id="ba2e" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">创建新项目</li><li id="5cca" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Bean配置</li><li id="4ab9" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">控制器配置</li><li id="52f9" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">非阻塞HTTP客户端</li><li id="b4fd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">参数化</li><li id="a9d5" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">测试</li><li id="8eb4" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Docker集成</li><li id="1d67" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">生成GraalVM映像</li><li id="0732" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">等等。</li></ul><p id="cfb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我将创建一个基于Kotlin的应用程序，它可以使用非阻塞代码查询漫威API。</p><p id="2c4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章致力于解释应用程序和Spring Boot。</p><h1 id="f8ba" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">漫威空气污染指数</h1><p id="591b" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">漫威提供了一个REST API来查询他们的数据。它需要生成一个API密钥<strong class="ka ir">和一个私有密钥</strong>。</p><p id="86cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要进行身份验证，需要传递以下内容作为查询参数:</p><ol class=""><li id="9b47" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">现有的API密钥</li><li id="5832" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">时间戳</li><li id="0ef0" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">时间戳、私钥和API密钥串联的MD5哈希</li></ol><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="adbc" class="nf lt iq nb b gy ng nh l ni nj">curl http://gateway.marvel.com/v1/public/comics?ts=1&amp;apikey=1234&amp;hash=ffd275c5130566a2916217b101f26150</span></pre><p id="f653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更多详细信息，请参考<a class="ae ld" href="https://developer.marvel.com/documentation/authorization" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="4e4b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">创建新项目</h1><p id="dd96" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Spring团队是第一个提供Web UI来配置项目的团队，Spring Initializr 。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/da9134778b98b85e454571986a327174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cm9o-HXoLpJllWT1.jpg"/></div></figure><p id="4f43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用它，您可以配置以下参数:</p><ul class=""><li id="dcbc" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">构建工具，Maven或Gradle</li><li id="294c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">语言，Java、Kotlin或Groovy</li><li id="4e25" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Spring Boot的版本</li><li id="ea64" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">一些元数据</li><li id="645b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">属国</li></ul><p id="c2e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，该应用程序还提供了一个REST API来使用CLI和自动化重复性任务。IntelliJ IDEA集成了REST API，因此您可以在不离开IDE的情况下创建一个新项目。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/955bb776429c98a3ae7703d17107beeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*q-UqGZAbMeFuvw_q.jpg"/></div></figure><p id="557f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，当它被托管时，底层代码是在Apache v2许可下在GitHub 上可用的<a class="ae ld" href="https://github.com/spring-io/initializr" rel="noopener ugc nofollow" target="_blank">，因此您可以克隆和配置它。它的设计考虑到了可扩展性，允许升级。</a></p><h1 id="e2f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Bean配置</h1><p id="4e26" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我已经写了一篇关于在Spring中创建beans的不同方法的文章。</p><p id="68ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管Spring为beans提供了专用的DSL，但我们将使用“传统的”方式——注释。</p><p id="28df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一个MD5消息摘要来认证。使用Bean DSL，我们可以这样配置:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="fb91" class="nf lt iq nb b gy ng nh l ni nj">@Configuration<br/>class MarvelConfig {<br/><br/>    @Bean<br/>    fun md5(): MessageDigest = MessageDigest.getInstance("MD5")<br/>}</span></pre><p id="5217" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于有了<code class="fe nm nn no nb b">@SpringBootApplication</code>注释，Spring将在启动时自动发现这个类，并实例化beans:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="979b" class="nf lt iq nb b gy ng nh l ni nj">@SpringBootApplication<br/>class BootNativeApplication</span></pre><h1 id="5195" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">控制器配置</h1><p id="0110" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Spring率先在Servlet API之上引入了基于注释的控制器配置。从那以后，有一些反对注释的声音。出于这个原因，Spring引入了声明性路由。Kotlin让DSL路由变得更加令人愉快:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="dd5f" class="nf lt iq nb b gy ng nh l ni nj">fun routes() = router {<br/>    GET("/") { request -&gt;<br/>        ServerResponse.ok().build()<br/>    }<br/>}</span></pre><p id="f7ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要将路由器注册为bean:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="cb04" class="nf lt iq nb b gy ng nh l ni nj">@Configuration<br/>class MarvelConfig {<br/><br/>    @Bean<br/>    fun routes() = router {<br/>    GET("/") { request -&gt;<br/>        ServerResponse.ok().build()<br/>    }<br/><br/>    // Other beans<br/>}</span></pre><h1 id="95c7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">非阻塞HTTP客户端</h1><p id="550c" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">很久以来，Spring已经以作为Web MVC一部分的<code class="fe nm nn no nb b">RestTemplate</code>的形式提供了一个<em class="kz">阻塞</em> HTTP客户端。在第5版中，Spring引入了WebFlux，它是Web MVC的反应式对应物。WebFlux建立在Project Reactor之上，而Project Reactor本身建立在反应流之上。您可能熟悉Project Reactor的基础原语:</p><ul class=""><li id="6a31" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><code class="fe nm nn no nb b">Mono</code>:最多发射一个项目</li><li id="ce6c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><code class="fe nm nn no nb b">Flux</code>:发射0..n个项目</li></ul><p id="d2b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了WebFlux，Spring弃用了<code class="fe nm nn no nb b">RestTemplate</code>，取而代之的是提供的无功<code class="fe nm nn no nb b">WebClient</code>。以下是如何在现有路线内拨打电话:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="6a97" class="nf lt iq nb b gy ng nh l ni nj">fun routes() = router {<br/>    GET("/") { _ -&gt;<br/>        val client = WebClient.create();<br/>        val mono = client<br/>            .get()<br/>            .uri("https://gateway.marvel.com:443/v1/public/characters")<br/>            .retrieve()<br/>            .bodyToMono&lt;String&gt;()<br/>        ServerResponse.ok().body(mono)<br/>    }<br/>}</span></pre><p id="4381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还想获得一些参数，并进一步传播它们。在漫威API提供的所有工具中，我选择暴露三个:<code class="fe nm nn no nb b">limit</code>、<code class="fe nm nn no nb b">offset</code>和<code class="fe nm nn no nb b">orderBy</code>。</p><p id="6c30" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nm nn no nb b">GET</code>函数接受一个<code class="fe nm nn no nb b">(ServerRequest) -&gt; ServerResponse</code>作为其第二个参数。<code class="fe nm nn no nb b">ServerRequest</code>提供了<code class="fe nm nn no nb b">queryParam(String)</code>来检查查询参数的存在。它返回一个Java <code class="fe nm nn no nb b">Optional</code>。另一方面，<code class="fe nm nn no nb b">UriBuilder</code>允许通过<code class="fe nm nn no nb b">queryParam(String, String)</code>功能设置查询参数。</p><p id="cb99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在两者之间创建一个扩展桥:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3312" class="nf lt iq nb b gy ng nh l ni nj">fun UriBuilder.queryParamsWith(request: ServerRequest) = apply {<br/>    arrayOf("limit", "offset", "orderBy").forEach { param -&gt;     &lt;1&gt;<br/>        request.queryParam(param).ifPresent {                    &lt;2&gt;<br/>            queryParam(param, it)                                &lt;3&gt;<br/>        }<br/>    }<br/>}</span></pre><ol class=""><li id="7509" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">对于每个参数</li><li id="b845" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">如果请求中有</li><li id="eb19" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">在URI构建器上设置其名称和值</li></ol><p id="faeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以相应地称之为:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a28f" class="nf lt iq nb b gy ng nh l ni nj">fun routes(client: WebClient, props: MarvelProperties, digest: MessageDigest) = router {<br/>    GET("/") { request -&gt;<br/>        val mono = client<br/>            .get()<br/>            .uri {<br/>                it.path("/characters")<br/>                  .queryParamsWith(request)<br/>                  .build()<br/>            }.retrieve()<br/>            .bodyToMono&lt;String&gt;()<br/>        ServerResponse.ok().body(mono)<br/>    }<br/>}</span></pre><h1 id="9660" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">参数化</h1><p id="6d7f" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">下一步是参数化应用程序:漫威API要求我们进行身份验证，我们不想硬编码我们的凭证。此外，出于测试目的，我们希望快速更改我们发送请求的服务器的URL。</p><p id="56c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参数化包括两个部分:如何将参数传递给应用程序，以及如何在应用程序中使用这些参数。</p><p id="4737" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于传递参数，Spring Boot提供了许多不同的方法。参数可以在配置文件中分组，并作为一个整体激活。在本例中，我选择在应用程序内部的YAML文件中设置服务器URL，因为这是默认设置，并通过命令行传递秘密。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d401" class="nf lt iq nb b gy ng nh l ni nj">app:<br/>  marvel:<br/>    server-url: https://gateway.marvel.com:443</span></pre><p id="81a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在应用程序中使用参数，我们还有几种选择。一种是用<code class="fe nm nn no nb b">@Value</code>注释字段，让Spring在运行时注入值。或者，我们可以将它们分组到一个专用的类(或几个类)中，让Spring再次进行绑定。我相信，除非你只有一个单一的价值，财产类是一个很好的选择。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0f4c" class="nf lt iq nb b gy ng nh l ni nj">@ConfigurationProperties("app.marvel")      &lt;1&gt;<br/>@ConstructorBinding                        &lt;2&gt;<br/>data class MarvelProperties(<br/>    val serverUrl: String,                 &lt;3&gt;<br/>    val apiKey: String,<br/>    val privateKey: String<br/>)</span></pre><ol class=""><li id="cf5d" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">管理要读取的前缀</li><li id="8698" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">与Kotlin数据类集成</li><li id="c951" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">Spring比较宽容，允许几种情况:烤肉串、蛇或者骆驼</li></ol><h1 id="c402" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试</h1><p id="2ac4" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">代码库的大小不适合大量的测试，尤其是单元测试。但是，我们可以添加一个集成测试，确保来自API的响应被解组到一个类中，并再次从应用程序中封送回来。在测试中，我们希望避免依赖第三方基础设施:测试不应该因为我们无法控制的依赖而失败。</p><p id="cb7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于集成测试，我们可以在类上使用<code class="fe nm nn no nb b">@SpringBootTest</code>注释:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3ec3" class="nf lt iq nb b gy ng nh l ni nj">@SpringBootTest(<br/>    webEnvironment = WebEnvironment.RANDOM_PORT,      &lt;1&gt;<br/>    properties = [<br/>        "app.marvel.api-key=dummy",                   &lt;2&gt;<br/>        "app.marvel.private-key=dummy"                &lt;3&gt;<br/>    ]<br/>)<br/>class BootNativeApplicationTests</span></pre><ol class=""><li id="b0e0" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">在随机端口上启动应用程序，以避免由于端口冲突而导致失败</li><li id="c195" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated"><code class="fe nm nn no nb b">MarvelProperties</code>需要该参数，但未用于测试。只要参数存在，我们就传递任何东西。</li></ol><p id="c6d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TestContainer 是一个Java库，允许启动/停止Docker容器。要使用它，我们只需要用相关的注释对类进行注释。我们还需要配置我们想要使用的容器:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="cc6a" class="nf lt iq nb b gy ng nh l ni nj">@Testcontainers                                             &lt;1&gt;<br/>class BootNativeApplicationTests {<br/><br/>    companion object {                                      &lt;2&gt;<br/><br/>        @Container                                          &lt;3&gt;<br/>        val mockServer = MockServerContainer(<br/>            DockerImageName.parse("mockserver/mockserver")  &lt;4&gt;<br/>        )<br/>}</span></pre><ol class=""><li id="2031" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">与测试容器集成</li><li id="be60" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">在Java中，我们需要有一个<code class="fe nm nn no nb b">static</code>成员。<br/>在Kotlin中，它被翻译成伴随对象的属性</li><li id="e437" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">配置测试容器</li><li id="23e3" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">使用引用的容器图像</li></ol><p id="9c32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="https://www.testcontainers.org/modules/mockserver" rel="noopener ugc nofollow" target="_blank"> MockServer </a>是一个容器，可以被存根化以返回依赖于输入的有效载荷。</p><p id="cb9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在真正有趣的部分来了:</p><ul class=""><li id="b229" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">为了开始测试，我们需要IP和port作为参数来初始化<code class="fe nm nn no nb b">MavelProperties</code></li><li id="7fd6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">要获得IP和端口，我们需要启动容器，容器的生命周期与测试绑定在一起，<em class="kz">即</em>，我们需要首先启动测试</li></ul><p id="2d28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在<a class="ae ld" href="https://www.baeldung.com/spring-dynamicpropertysource" rel="noopener ugc nofollow" target="_blank">动态属性源</a>的帮助下解决这个鸡和蛋的问题。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0c0d" class="nf lt iq nb b gy ng nh l ni nj">companion object {<br/><br/>    @JvmStatic                                                   &lt;1&gt;<br/>    @DynamicPropertySource                                       &lt;2&gt;<br/>    fun registerServerUrl(registry: DynamicPropertyRegistry) {   &lt;3&gt;<br/>        registry.add("app.marvel.server-url") {                  &lt;4&gt;<br/>            "http://${mockServer.containerIpAddress}:${mockServer.serverPort}"    &lt;5&gt;<br/>        }<br/>    }<br/>}</span></pre><ol class=""><li id="052e" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">Java兼容性所必需的</li><li id="9883" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">神奇！</li><li id="85f7" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">Spring Test在运行时注入它</li><li id="fb55" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">添加此属性…</li><li id="f30f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">…这个值取自<code class="fe nm nn no nb b">mockServer</code>财产</li></ol><p id="0341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来看看测试方法:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="a2b2" class="nf lt iq nb b gy ng nh l ni nj">@Test<br/>fun `should deserialize JSON payload from server and serialize it back again`() {                                                  &lt;1&gt;<br/>    val mockServerClient = MockServerClient(<br/>        mockServer.containerIpAddress,<br/>        mockServer.serverPort<br/>    )                                                            &lt;2&gt;<br/>    val sample = ClassPathResource("/sample.json").file.readText()&lt;3&gt;<br/>    mockServerClient.`when`(                                     &lt;4&gt;<br/>        HttpRequest.request()<br/>            .withMethod("GET")<br/>            .withPath("/v1/public/characters")<br/>    ).respond(                                                   &lt;5&gt;<br/>        HttpResponse()<br/>            .withStatusCode(200)<br/>            .withHeader("Content-Type", "application/json")<br/>            .withBody(sample)<br/>    )<br/>    // Test code<br/>}</span></pre><ol class=""><li id="c965" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">Kotlin允许测试方法名称有描述性文本</li><li id="9c00" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">创建存根</li><li id="e0d2" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">引用类路径资源的Spring抽象。<code class="fe nm nn no nb b">sample.json</code>是测试样本。</li><li id="b00e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated"><em class="kz">当</em>部分存根</li><li id="3ede" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated"><em class="kz">然后是</em>部分</li></ol><p id="cc1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续测试本身。Spring Test提供了<code class="fe nm nn no nb b">WebTestClient</code>，一个非阻塞的测试客户端。它允许参数化HTTP请求，发送它们并在响应上执行几个流畅的断言。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="afb1" class="nf lt iq nb b gy ng nh l ni nj">class BootNativeApplicationTests {<br/><br/>    @Autowired<br/>    private lateinit var webTestClient: WebTestClient            &lt;1&gt;<br/><br/>    @Test<br/>    fun `should deserialize JSON payload from server and serialize it back again`() {<br/>        // Stubbing code<br/>        webTestClient.get()<br/>            .uri("/")<br/>            .exchange()<br/>            .expectStatus().isOk<br/>            .expectBody()<br/>            .jsonPath("\$.data.count").isEqualTo(1)              &lt;2&gt;<br/>            .jsonPath("\$.data.results").isArray                 &lt;2&gt;<br/>            .jsonPath("\$.data.results[0].name")<br/>                .isEqualTo("Anita Blake")                        &lt;2&gt;<br/>    }<br/>}</span></pre><ol class=""><li id="1e31" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">春试为你注入<code class="fe nm nn no nb b">WebTestClient</code></li><li id="bdb2" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">响应上的断言</li></ol><p id="43b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，此时测试无法执行。我们使用Beans DSL配置了应用程序；我们必须在应用程序启动时显式调用<code class="fe nm nn no nb b">beans</code>。我们还需要明确地配置测试。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ea01" class="nf lt iq nb b gy ng nh l ni nj">class TestConfigInitializer : ApplicationContextInitializer&lt;GenericApplicationContext&gt; {<br/>    override fun initialize(context: GenericApplicationContext) {<br/>        beans.initialize(context)<br/>    }<br/>}<br/><br/>@SpringBootTest(<br/>    properties = [<br/>        "context.initializer.classes=ch.frankel.blog.TestConfigInitializer" &lt;1&gt;<br/>    ]<br/>)<br/>class BootNativeApplicationTests</span></pre><ol class=""><li id="5d95" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">引用初始化类</li></ol><h1 id="034b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Docker和GraalVM集成</h1><p id="7613" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">注意:本节假设您已经熟悉GraalVM native。</p><p id="7465" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring Boot提供了两种创建本地二进制文件的方法:</p><ol class=""><li id="679c" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">依赖于系统的二进制文件:这种方法需要安装带有<code class="fe nm nn no nb b">native-image</code>扩展名的本地GraalVM。它将创建一个非跨平台的系统相关的二进制文件。<br/>对此，Spring Boot有专门的简介:<br/> <code class="fe nm nn no nb b">./mvnw -Pnative package</code></li><li id="f709" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">Docker映像:这种方法构建了应用程序的容器化版本。它需要一个本地映像构建，<em class="kz">，例如</em>，Docker。在内部，它利用了<a class="ae ld" href="https://buildpacks.io/" rel="noopener ugc nofollow" target="_blank"> CNCF构建包</a>(但不需要<code class="fe nm nn no nb b">pack</code>)。<br/> Spring Boot为此提供了一个专家目标:</li></ol><ul class=""><li id="9356" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><code class="fe nm nn no nb b">./mvnw spring-boot:native-image</code></li></ul><p id="5da0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring Boot负责GraalVM代码的本地配置和大多数依赖关系。如果需要进一步配置，可以使用标准配置文件<em class="kz">，如</em>、<code class="fe nm nn no nb b">/META-INF/native-image///reflect-config.json</code>。</p><p id="036c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为替代，Spring提供了基于注释的配置。让我们开始吧:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c074" class="nf lt iq nb b gy ng nh l ni nj">@SpringBootApplication<br/>@NativeHint(options = ["--enable-https"])                        &lt;1&gt;<br/>@TypeHint(<br/>    types = [<br/>        Model::class, Data::class, Result::class, Thumbnail::class,<br/>        Collection::class, Resource::class, Url::class, URI::class<br/>    ],<br/>    access = AccessBits.FULL_REFLECTION                          &lt;2&gt;<br/>)<br/>class BootNativeApplication</span></pre><ol class=""><li id="e5a6" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">保留TLS相关代码</li><li id="1cd8" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">保持分类并允许在运行时反射</li></ol><p id="1532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用第二种方法，结果如下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="cdf1" class="nf lt iq nb b gy ng nh l ni nj">REPOSITORY      TAG       IMAGE ID         CREATED         SIZE<br/>native-boot     1.0       c9284b7f99a6     41 years ago    104MB</span></pre><p id="ef9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们深入到图像中，我们可以看到以下图层:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="7d48" class="nf lt iq nb b gy ng nh l ni nj">┃ ● Layers ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━<br/>Cmp   Size  Command<br/>     17 MB  FROM c09932ee5c22aa1                &lt;1&gt;<br/>     268 B                                      &lt;2&gt;<br/>    3.4 MB                                      &lt;3&gt;<br/>     81 MB                                      &lt;4&gt;<br/>    2.5 MB                                      &lt;5&gt;<br/>     12 kB<br/>       0 B                                      &lt;6&gt;</span></pre><ol class=""><li id="5f23" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv mv lk ll lm bi translated">父图像</li><li id="b360" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">系统权限</li><li id="dcfd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">Paketo buildpacks CA证书</li><li id="2eb6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">我们的本地二进制</li><li id="3174" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">云原生启动器可执行文件</li><li id="7d38" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv mv lk ll lm bi translated">启动器别名</li></ol><p id="4f8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成的图像接受参数，就像您在命令行上运行Java应用程序一样。</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ffba" class="nf lt iq nb b gy ng nh l ni nj">docker run -it -p8080:8080 native-boot:1.0 --app.marvel.apiKey=xyz --app.marvel.privateKey=abc --logging.level.root=DEBUG</span></pre><p id="5e12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以发送请求来使用该应用程序:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e0c0" class="nf lt iq nb b gy ng nh l ni nj">curl localhost:8080<br/>curl 'localhost:8080?limit=1'<br/>curl 'localhost:8080?limit=1&amp;offset=50'</span></pre><h1 id="a30a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="b52f" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Spring在处理样板代码和让开发人员专注于业务代码方面有着悠久的历史。在后来的几年里，它成功地集成了Kotlin语言，提供了一种奇妙的开发体验。</p><p id="14ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，随着云变得更加广泛，Spring生态系统被迫应对GraalVM原生。虽然它仍有改进的空间，但它完成了任务。</p><p id="b0c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在接下来的文章中，我将使用所谓的云原生框架Quarkus和Micronaut来描述同一个应用程序。</p><p id="f7e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢<a class="ae ld" href="https://twitter.com/sdeleuze" rel="noopener ugc nofollow" target="_blank"> Sébastien Deleuze </a>对这篇文章的帮助。</p><p id="03d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的完整源代码可以在<a class="ae ld" href="https://github.com/ajavageek/springboot-native" rel="noopener ugc nofollow" target="_blank"> Github </a>上以Maven格式找到。</p><p id="9dfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="1089" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae ld" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">弹簧初始化</a></li><li id="0861" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="https://www.baeldung.com/spring-dynamicpropertysource" rel="noopener ugc nofollow" target="_blank">动态房产来源</a></li><li id="403f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/" rel="noopener ugc nofollow" target="_blank">春天原生文档</a></li><li id="1469" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#native-hints" rel="noopener ugc nofollow" target="_blank">原生提示</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="139a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kz">原载于</em> <a class="ae ld" href="https://blog.frankel.ch/native/spring-boot/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">一个Java怪胎</em></a><em class="kz">2021年11月14日</em></p></div></div>    
</body>
</html>