<html>
<head>
<title>Introduction to Kubernetes extensibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes扩展性介绍</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-extensibility-c5fed27f0952?source=collection_archive---------3-----------------------#2022-09-21">https://itnext.io/kubernetes-extensibility-c5fed27f0952?source=collection_archive---------3-----------------------#2022-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/72796057e8bf49ff58c51790d75ff558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3u8s_imGuoYAFaeij1rq_Q.jpeg"/></div></div></figure><p id="eb2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes提供了很多好处:一个拥有大量参与者的巨大生态系统，自我修复能力等。然而，没有免费的午餐。它也有缺点，主要是复杂性和运营成本。</p><p id="1ce1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我和Kubernetes合作得越多，我就越觉得它最重要的资产是<strong class="ka ir">可扩展性</strong>。如果您需要平台默认不提供的东西，可以选择自己开发并集成它。在这篇文章中，我想列出这样的扩展点。</p><h1 id="15f9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">库伯内特101</h1><p id="baa7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">很多关于Kubernetes的解释都集中在架构上。我相信他们考虑太多细节而忽略了大局。在这里，我只想强调一下基本概念。</p><p id="51da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最基本的层面上，Kubernetes只是一个能够运行容器映像的平台。它将其配置存储在分布式存储引擎中。该配置的最重要部分专用于对象的<em class="md">期望状态</em>。例如，只有当您使用<code class="fe lz ma mb mc b">kubectl</code>命令行安排一个pod时，您才可以更新这个状态。</p><p id="84ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">称为控制器的其他组件观察配置变化并读取<em class="md">期望状态</em>。然后，他们试图使<em class="md">期望状态</em>与<em class="md">实际状态</em>相一致。这不是什么革命性的东西:Puppet基于同样的控制回路方法，而AFAIK，Chef。通常，控制器管理单一类型的对象，<em class="md">例如，</em>，<code class="fe lz ma mb mc b">DeploymentController</code>管理部署。</p><p id="906b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">制作通用工具背后的想法是遵循帕累托定律:用20%的努力解决80%的问题。不幸的是，工具越通用，用户基础越广泛，就越需要定制剩下的20%。</p><p id="24eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes的设计师认为这个问题是广泛采用的最关键的障碍。因此，Kubernetes提供了许多扩展点。</p><h1 id="0843" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可扩展模型</h1><p id="9ebf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在上一节中，我提到了调度pod。pod是Kubernetes开箱即用的众多对象之一。其他对象包括:部署、作业、服务等。</p><p id="e765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些解决方案很容易符合这种模式。例如，可以很容易地创建三个Hazelcast吊舱的部署。它开箱即用:豆荚将通过网络多播，找到彼此，并形成一个集群。</p><p id="001f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他解决方案并不如此同质。在<a class="ae me" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-500%3A+Replace+ZooKeeper+with+a+Self-Managed+Metadata+Quorum" rel="noopener ugc nofollow" target="_blank"> KIP-500 </a>之前，卡夫卡会依赖动物园管理员。At集群由至少三个Zookeeper节点和任意数量的Kafka节点组成。Kubernetes使得在同一个pod上部署多个映像成为可能。然而，如果所有需要的组件都在同一个pod上，而pod出现故障，那就什么都不是了。我们应该将一个常规组件映射到一个pod。</p><p id="1756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们需要一个功能齐全的Kubernetes清单来描述架构。由于不同的需求，我们需要使它可配置。Kubernetes的生态系统提供了几个解决这个问题的替代方案:Kustomize和Helm是最流行的解决方案。但是两者都不能在理想的抽象层次上工作，即Kafka集群。</p><p id="2ddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，Kubernetes允许设计一个新的<code class="fe lz ma mb mc b">Kafka</code>对象。这种自定义对象被称为CRD。下面是一个简单的任意<code class="fe lz ma mb mc b">Foo</code>对象的例子:</p><pre class="mf mg mh mi gt mj mc mk ml aw mm bi"><span id="d191" class="mn kx iq mc b gy mo mp l mq mr">apiVersion: apiextensions.k8s.io/v1       #1<br/>kind: CustomResourceDefinition<br/>metadata:<br/> name: foos.frankel.ch                    #2<br/>spec:<br/> group: frankel.ch                        #3<br/> names:<br/>   plural: foos                           #4<br/>   singular: foo                          #5<br/>   kind: Foo                              #6<br/> scope: Namespaced                        #7<br/> versions:<br/>   - name: v1alpha1<br/>     served: true                         #8<br/>     storage: true                        #9<br/>     schema:<br/>       openAPIV3Schema:<br/>         type: object<br/>         properties:<br/>           spec:<br/>             type: object<br/>             properties:<br/>               bar:<br/>                 type: string<br/>             required: ["bar"]<br/>         required: ["spec"]</span></pre><ol class=""><li id="6ff8" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">必需的标题</li><li id="6b65" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">匹配以下<code class="fe lz ma mb mc b">&lt;plural&gt;.&lt;group&gt;</code></li><li id="57b3" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">REST API的组名— <code class="fe lz ma mb mc b">/apis/&lt;group&gt;/&lt;version&gt;</code></li><li id="2757" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">REST API的复数名称— <code class="fe lz ma mb mc b">/apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;</code></li><li id="48c7" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">用于CLI和显示的单数名称</li><li id="5801" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">在清单中使用</li><li id="a586" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">可以是<code class="fe lz ma mb mc b">Cluster</code>也可以是<code class="fe lz ma mb mc b">Namespaced</code>。一个<code class="fe lz ma mb mc b">Cluster</code>资源被声明为集群范围的，每个集群可以有一个单独的资源；<code class="fe lz ma mb mc b">Namespaced</code>资源可以是多个，需要在一个命名空间下；默认情况下，<code class="fe lz ma mb mc b">default</code></li><li id="bfb0" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">可以启用/禁用某个版本</li><li id="192a" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">最新版本必须标记为存储版本</li></ol><p id="1a1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦应用了这个清单，您就可以管理您的<code class="fe lz ma mb mc b">Foo</code>。让我们创建一个清单来创建一个新的<code class="fe lz ma mb mc b">Foo</code>对象。</p><pre class="mf mg mh mi gt mj mc mk ml aw mm bi"><span id="57d6" class="mn kx iq mc b gy mo mp l mq mr">apiVersion: foos.frankel.ch/v1alpha1<br/>kind: Foo<br/>metadata:<br/>  name: myfoo<br/>spec:<br/>  bar: "whatever"</span><span id="aa96" class="mn kx iq mc b gy ng mp l mq mr">kubectl apply -f foo.yml<br/>kubectl get foo</span></pre><p id="a7d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上命令用新的<code class="fe lz ma mb mc b">Foo</code>类型更新了数据模型，并创建了一个<code class="fe lz ma mb mc b">Foo</code>对象。但是实际上，我们只是通过Kubernetes API将数据存储在<code class="fe lz ma mb mc b">etcd</code>中。除非我们启动一个控制器来观察新的对象并对它们进行操作，否则什么都不会发生。请注意，管理CRDs的控制器的名称是<em class="md">操作员</em>。</p><h1 id="a754" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可扩展验证</h1><p id="ad9c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">对于可以运行第三方工作负载的平台，一个常见的问题是只允许经过审查的工作负载。有些工作负载可能会消耗太多资源；其他人可能是恶意的。</p><p id="6fb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有两个具体的场景:</p><ul class=""><li id="0359" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv nh my mz na bi translated">作为集群操作员，您希望管理集群有限的物理资源(CPU/内存)并在所有pod之间共享它们。为此，您需要强制每个pod描述其<a class="ae me" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" rel="noopener ugc nofollow" target="_blank">资源需求</a>。开发人员通过设置<code class="fe lz ma mb mc b">request</code>和<code class="fe lz ma mb mc b">limits</code>属性来实现这一点。您想要禁止没有它们的pod。</li><li id="91de" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated">作为一名注重安全的操作员，您希望防止<a class="ae me" href="https://docs.bridgecrew.io/docs/bc_k8s_19" rel="noopener ugc nofollow" target="_blank">权限升级</a>。它不应该改变豆荚的最终行为。你想把<code class="fe lz ma mb mc b">allowPrivilegeEscalation=false</code>加到每一个豆荚里。</li></ul><p id="8a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然可以通过“构建”管道来管理这两种情况，但Kubernetes提供了开箱即用的解决方案。</p><p id="313a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我上面解释的，Kubernetes存储配置是<code class="fe lz ma mb mc b">etcd</code>，而控制器观察变化并对其采取行动。为了防止不必要的行为，最安全的方法是验证改变配置的有效负载；这是<em class="md">准入控制器</em>的作用。</p><blockquote class="ni nj nk"><p id="e6ab" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq">准入控制器是一段代码，它在对象持久化之前，但是在请求被认证和授权之后，拦截对Kubernetes API服务器的请求。控制器由下面的列表组成，被编译成kube-apiserver二进制文件，并且只能由集群管理员进行配置。在那个列表中，有两个特殊的控制器:</em> <code class="fe lz ma mb mc b"><em class="iq">MutatingAdmissionWebhook</em></code> <em class="iq">和</em> <code class="fe lz ma mb mc b"><em class="iq">ValidatingAdmissionWebhook</em></code> <em class="iq">。它们分别执行在API中配置的变异和验证准入控制网络挂钩。</em></p><p id="4fb4" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae me" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">使用录取控制器</em> </a></p></blockquote><p id="8e55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，有两种准入控制器可用:</p><ol class=""><li id="a48a" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">验证准入webhook允许/阻止请求改变状态</li><li id="3ca0" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">变异准入网页挂钩改变请求</li></ol><p id="47b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们按照下图依次运行:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/0ca59d36214896570d8337170bc84a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rnU6hKjXSYpK-nO6.png"/></div></div></figure><p id="6664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">从</em> <a class="ae me" href="https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers" rel="noopener ugc nofollow" target="_blank"> <em class="md">到</em> </a>的一个引导</p><p id="83a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个都可以解决上面强调的场景。</p><h1 id="730b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">可扩展的客户端功能</h1><p id="d267" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在最基本的层面上，<code class="fe lz ma mb mc b">kubectl</code>命令行是对REST客户端的高级抽象。您可以通过设置详细选项来验证它:</p><pre class="mf mg mh mi gt mj mc mk ml aw mm bi"><span id="d3c8" class="mn kx iq mc b gy mo mp l mq mr">kubectl get pods --v=8</span><span id="fad7" class="mn kx iq mc b gy ng mp l mq mr">loader.go:372] Config loaded from file:  /Users/nico/.kube/config<br/>round_trippers.go:463] GET https://127.0.0.1:61378/api/v1/namespaces/default/pods?limit=500<br/>round_trippers.go:469] Request Headers:<br/>round_trippers.go:473]     Accept: application/json;as=Table;v=v1;g=meta.k8s.io,application/json;as=Table;v=v1beta1;g=meta.k8s.io,application/json<br/>round_trippers.go:473]     User-Agent: kubectl/v1.24.2 (darwin/arm64) kubernetes/f66044f<br/>round_trippers.go:574] Response Status: 200 OK in 8 milliseconds<br/>round_trippers.go:577] Response Headers:<br/>round_trippers.go:580]     Cache-Control: no-cache, private<br/>round_trippers.go:580]     Content-Type: application/json<br/>round_trippers.go:580]     X-Kubernetes-Pf-Flowschema-Uid: 479e2d49-7b9f-4e4c-8fca-63c273cfb525<br/>round_trippers.go:580]     X-Kubernetes-Pf-Prioritylevel-Uid: 4787583d-e7d4-4679-a474-ebb66919a43c<br/>round_trippers.go:580]     Date: Sun, 04 Sep 2022 09:32:39 GMT<br/>round_trippers.go:580]     Audit-Id: 2f2f163d-fb6d-4149-ba44-ecf4395028aa<br/>request.go:1073] Response Body: {"kind":"Table","apiVersion":"meta.k8s.io/v1","metadata":{"resourceVersion":"263411"},"columnDefinitions":[{"name":"Name","type":"string","format":"name","description":"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names","priority":0},{"name":"Ready","type":"string","format":"","description":"The aggregate readiness state of this pod for accepting traffic.","priority":0},{"name":"Status","type":"string","format":"","description":"The aggregate status of the containers in this pod.","priority":0},{"name":"Restarts","type":"string","format":"","description":"The number of times the containers in this pod have been restarted and when the last container in this pod has restarted.","priority":0},{"name":"Age","type":"st [truncated 6465 chars]</span></pre><p id="fe57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes的REST API是(大部分？)基于CRUD操作。有时，您需要运行几个命令来获得想要的结果。例如，我们希望查询哪些主体可以执行某个操作。</p><p id="da40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">kubectl</code>包括一个机制，让<a class="ae me" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" rel="noopener ugc nofollow" target="_blank">编写代码</a>来编排这些调用。该机制与Git非常相似:</p><ol class=""><li id="3159" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">你根据特定的格式编写代码——一个<em class="md">插件</em></li><li id="af5f" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">你在你的<code class="fe lz ma mb mc b">PATH</code>变量中设置它</li></ol><p id="2b29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从这一点上，<code class="fe lz ma mb mc b">kubectl</code>可以发现它。</p><p id="92ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在您的机器上管理您的插件，但是这种方法不能扩展到整个组织。解决方案是插件管理器。认识克鲁:</p><blockquote class="ni nj nk"><p id="7402" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> Krew是</em> <code class="fe lz ma mb mc b"><em class="iq">kubectl</em></code> <em class="iq">命令行工具的插件管理器。</em></p><p id="bb81" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> Krew帮你:</em></p><p id="99ba" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> *发现</em> <code class="fe lz ma mb mc b"><em class="iq">kubectl</em></code> <em class="iq">插件，</em></p><p id="d00f" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> *将它们安装到您的机器上，</em></p><p id="eb46" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> *并保持已安装的插件最新。</em></p><p id="4d35" class="jy jz md ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae me" href="https://krew.sigs.k8s.io/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">什么是Krew？</em> </a></p></blockquote><p id="67b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于哪些主体可以执行操作，以下是操作方法:</p><pre class="mf mg mh mi gt mj mc mk ml aw mm bi"><span id="2732" class="mn kx iq mc b gy mo mp l mq mr">brew install krew                              #1 <br/>kubectl krew completion                        #2<br/># follow instructions to update your shell<br/>kubectl krew update                            #3<br/>kubectl krew install who-can                   #4<br/>k who-can watch pod                            #5</span></pre><ol class=""><li id="f8c7" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">在Mac上安装<code class="fe lz ma mb mc b">brew</code></li><li id="78b7" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">显示自动完成指令</li><li id="6636" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">更新缓存的插件列表</li><li id="8d8d" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">安装<code class="fe lz ma mb mc b">who-can</code> Krew插件</li><li id="e0db" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">尽情享受吧！</li></ol><pre class="mf mg mh mi gt mj mc mk ml aw mm bi"><span id="cde3" class="mn kx iq mc b gy mo mp l mq mr">No subjects found with permissions to watch pod assigned through RoleBindings</span><span id="6583" class="mn kx iq mc b gy ng mp l mq mr">CLUSTERROLEBINDING                             SUBJECT                                 TYPE            SA-NAMESPACE<br/>apisix-clusterrolebinding                      apisix-ingress-controller               ServiceAccount  ingress-apisix<br/>cluster-admin                                  system:masters                          Group<br/>local-path-provisioner-bind                    local-path-provisioner-service-account  ServiceAccount  local-path-storage<br/>system:controller:attachdetach-controller      attachdetach-controller                 ServiceAccount  kube-system<br/>system:controller:daemon-set-controller        daemon-set-controller                   ServiceAccount  kube-system<br/>system:controller:deployment-controller        deployment-controller                   ServiceAccount  kube-system<br/>system:controller:endpoint-controller          endpoint-controller                     ServiceAccount  kube-system<br/>system:controller:endpointslice-controller     endpointslice-controller                ServiceAccount  kube-system<br/>system:controller:ephemeral-volume-controller  ephemeral-volume-controller             ServiceAccount  kube-system<br/>system:controller:generic-garbage-collector    generic-garbage-collector               ServiceAccount  kube-system<br/>system:controller:job-controller               job-controller                          ServiceAccount  kube-system<br/>system:controller:persistent-volume-binder     persistent-volume-binder                ServiceAccount  kube-system<br/>system:controller:pod-garbage-collector        pod-garbage-collector                   ServiceAccount  kube-system<br/>system:controller:pvc-protection-controller    pvc-protection-controller               ServiceAccount  kube-system<br/>system:controller:replicaset-controller        replicaset-controller                   ServiceAccount  kube-system<br/>system:controller:replication-controller       replication-controller                  ServiceAccount  kube-system<br/>system:controller:resourcequota-controller     resourcequota-controller                ServiceAccount  kube-system<br/>system:controller:statefulset-controller       statefulset-controller                  ServiceAccount  kube-system<br/>system:coredns                                 coredns                                 ServiceAccount  kube-system<br/>system:kube-controller-manager                 system:kube-controller-manager          User<br/>system:kube-scheduler                          system:kube-scheduler                   User</span></pre><h1 id="e580" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="0919" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在本文中，我们浏览了Kubernetes中的几个扩展点:数据模型、准入控制器和客户端。这是一个非常简短的介绍，在广度和深度上都是如此。然而，我希望它能为进一步的研究提供一个很好的切入点。</p><ul class=""><li id="878d" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv nh my mz na bi translated"><a class="ae me" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/" rel="noopener ugc nofollow" target="_blank">用CustomResourceDefinitions扩展Kubernetes API</a></li><li id="f807" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated"><a class="ae me" href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/" rel="noopener ugc nofollow" target="_blank">自定义资源定义中的版本</a></li><li id="4a75" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated"><a class="ae me" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/" rel="noopener ugc nofollow" target="_blank">使用许可控制器</a></li><li id="5af1" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated"><a class="ae me" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" rel="noopener ugc nofollow" target="_blank">用插件扩展ku bectl</a></li><li id="d581" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv nh my mz na bi translated"><a class="ae me" href="https://krew.sigs.k8s.io/plugins/" rel="noopener ugc nofollow" target="_blank"> Krew插件</a></li></ul></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="39bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="md">原载于</em> <a class="ae me" href="https://blog.frankel.ch/kubernetes-extensibility/" rel="noopener ugc nofollow" target="_blank"> <em class="md">一个Java怪胎</em></a><em class="md">2022年9月18日</em></p></div></div>    
</body>
</html>