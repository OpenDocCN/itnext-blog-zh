<html>
<head>
<title>React performance tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应性能技巧</h1>
<blockquote>原文：<a href="https://itnext.io/react-performance-tricks-why-is-it-so-fast-6ece8ade9762?source=collection_archive---------3-----------------------#2019-08-10">https://itnext.io/react-performance-tricks-why-is-it-so-fast-6ece8ade9762?source=collection_archive---------3-----------------------#2019-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8def7047931a8bf6affe1dda10079a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DdB7fsMTCxDuUXcAANgfOw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="e7d2" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">React如何能够如此快速地执行，并且对开发人员来说仍然保持灵活性？</h2></div><blockquote class="kq kr ks"><p id="547e" class="kt ku kv kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="jb">这篇文章需要关于形状和内联缓存的基本知识。如果你没有看过</em> <a class="ae lq" href="https://medium.com/@kemalpiro/v8-function-optimization-2a9c0ececf5e" rel="noopener"> <em class="jb"> V8函数优化</em> </a> <em class="jb">，可能很难跟上这一条。</em></p></blockquote><p id="2306" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">每当有人谈论React中的“性能”时，通常都是关于虚拟DOM的。这是React的重要部分，但我们今天将关注其他内容(仍然相关)。</p><h1 id="cb58" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">纤维</h1><p id="b472" class="pw-post-body-paragraph kt ku jb kw b kx mm kc kz la mn kf lc lr mo lf lg ls mp lj lk lt mq ln lo lp ij bi translated">在2017年F8会议上，React宣布对其核心算法进行重大重写。这就是<code class="fe mr ms mt mu b">Fiber</code>的由来。但是纤维到底是什么？</p><p id="ed92" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">一个<code class="fe mr ms mt mu b">Fiber</code>是一个组件上需要完成或者已经完成的工作。(另一个词“用于处理的包装”)。创建纤程有不同的方法，但它们都有相同的数据结构(这对我们很重要)。这些只是其中的一部分:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="ed87" class="nd lv jb mu b gy ne nf l ng nh">createWorkInProgress<br/>createHostRootFiber<br/>createFiberFromTypeAndProps<br/>createFiberFromElement<br/>createFiberFromFragment<br/>...</span></pre><blockquote class="kq kr ks"><p id="e1d9" class="kt ku kv kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="jb">你可以在这里</em> 查看纤维的外观 <a class="ae lq" href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.js#L118" rel="noopener ugc nofollow" target="_blank"> <em class="jb"/></a></p></blockquote><p id="461e" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">我们不打算深入讨论光纤内部结构(下次吧)。重要的是，React使用这些容器，而不是直接操作组件。</p><p id="1822" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">现在让我们看看当我们返回JSX时react会做什么:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="0f68" class="nd lv jb mu b gy ne nf l ng nh">return &lt;Layout&gt;{children}&lt;/Layout&gt;;</span></pre><p id="6e0a" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">这就转化成了:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="5430" class="nd lv jb mu b gy ne nf l ng nh">React.createElement(Layout, props, children);</span></pre><p id="92b9" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">创建了ReactElement，这是另一种容器。</p><h1 id="b866" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">简化React内部</h1><p id="d7e3" class="pw-post-body-paragraph kt ku jb kw b kx mm kc kz la mn kf lc lr mo lf lg ls mp lj lk lt mq ln lo lp ij bi translated">我将稍微简化一下React的内部结构，以便更容易理解它的功能。除此之外，我将为<code class="fe mr ms mt mu b">FiberNode</code>使用一个类而不是函数:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="f6fc" class="nd lv jb mu b gy ne nf l ng nh">class Component {<br/>  constructor() {<br/>    this.name = 'Component';<br/>  }<br/><br/>  render() {}<br/>}<br/><br/>class MyComponent1 extends Component {<br/>  render() {<br/>    return '&lt;span&gt;Test 1&lt;/span&gt;';<br/>  }<br/>}<br/><br/>class MyComponent2 extends Component {<br/>  render() {<br/>    return '&lt;span&gt;Test 2&lt;/span&gt;';<br/>  }<br/>}<br/><br/>class MyComponent3 extends Component {<br/>  render() {<br/>    return '&lt;span&gt;Test 3&lt;/span&gt;';<br/>  }<br/>}<br/><br/>function createElement(element, ...rest) {<br/>  return {<br/>    type: element,<br/>  };<br/>}</span></pre><p id="f58c" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">这是我们的组件类，看起来应该很熟悉，而<code class="fe mr ms mt mu b">createElement</code>返回类似结构的元素(过于简化)。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="4ab9" class="nd lv jb mu b gy ne nf l ng nh">const ReactWorkTags = {<br/>  ClassComponent: 1,<br/>  HostComponent: 5,<br/>};<br/><br/>class FiberNode {<br/>  constructor(tag, ...rest) {<br/>    this.tag = tag;<br/>    // Other important staff...<br/>  }<br/>}<br/><br/>const createFiberFromElement = function(element, ...rest) {<br/>  // another simplification, there are different WorkTags<br/>  const fiberTag =<br/>    typeof element.type === 'string'<br/>      ? ReactWorkTags.HostComponent<br/>      : ReactWorkTags.ClassComponent;<br/>  const fiber = new FiberNode(fiberTag, ...rest);<br/>  fiber.type = element.type;<br/><br/>  return fiber;<br/>};</span></pre><p id="c629" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">这里我们有一个<code class="fe mr ms mt mu b">FiberNode</code>的定义和一种创建它的方法。重要的是要知道，当传递我们的元素时，从该元素创建的FiberNode与任何其他FiberNode具有相同的形状(即使我们使用不同的组件类型)。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="948f" class="nd lv jb mu b gy ne nf l ng nh">const comp1 = createElement(MyComponent1);<br/>const comp2 = createElement(MyComponent2);<br/>const comp3 = createElement(MyComponent3);<br/>const comp4 = createElement('div');<br/><br/>const fiber1 = createFiberFromElement(comp1);<br/>const fiber2 = createFiberFromElement(comp2);<br/>const fiber3 = createFiberFromElement(comp3);<br/>const fiber4 = createFiberFromElement(comp4);<br/><br/>console.log(%HaveSameMap(fiber1, fiber2)); // true<br/>console.log(%HaveSameMap(fiber1, fiber3)); // true<br/>console.log(%HaveSameMap(fiber1, fiber4)); // true<br/>console.log(%HaveSameMap(fiber2, fiber3)); // true<br/>console.log(%HaveSameMap(fiber2, fiber4)); // true<br/>console.log(%HaveSameMap(fiber3, fiber4)); // true</span></pre><p id="c962" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">如果您只是手动生成这些组件并为其分配附加属性，会发生什么情况？</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="1e9a" class="nd lv jb mu b gy ne nf l ng nh">const comp1 = new MyComponent1();<br/>const comp2 = new MyComponent2();<br/><br/>console.log(%HaveSameMap(comp1, comp2)); // false</span></pre><h1 id="aa20" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">这如何帮助我们更快地运行代码</h1><p id="04d3" class="pw-post-body-paragraph kt ku jb kw b kx mm kc kz la mn kf lc lr mo lf lg ls mp lj lk lt mq ln lo lp ij bi translated">正如您可能知道的那样，每次React发生变化时，它都必须经过协调过程。调和就是用纤程算出下一棵树。它是如何工作的？</p><p id="8810" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">在<code class="fe mr ms mt mu b">ReactFiberWorkLoop</code>内部，一切都进入<code class="fe mr ms mt mu b">workLoopSync</code>(或<code class="fe mr ms mt mu b">workLoop</code>)。之后的<code class="fe mr ms mt mu b">performUnitOfWork</code>被称为带“顶”的光纤。<code class="fe mr ms mt mu b">performUnitOfWork</code>正在做三件事之一:</p><ul class=""><li id="901a" class="ni nj jb kw b kx ky la lb lr nk ls nl lt nm lp nn no np nq bi translated">没有任何东西</li><li id="5d69" class="ni nj jb kw b kx nr la ns lr nt ls nu lt nv lp nn no np nq bi translated">用电流<code class="fe mr ms mt mu b">unitOfWork</code>呼叫<code class="fe mr ms mt mu b">beginWork</code>(光纤)</li><li id="ff1a" class="ni nj jb kw b kx nr la ns lr nt ls nu lt nv lp nn no np nq bi translated">用电流<code class="fe mr ms mt mu b">unitOfWork</code>调用<code class="fe mr ms mt mu b">completeUnitOfWork</code>(也是光纤)</li></ul><p id="d79b" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">最后，它返回null或这两个函数之一的结果(令人惊讶的是…它是纤程)。</p><p id="adc5" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">从这一点来看，协调器只是使用<code class="fe mr ms mt mu b">performUnitOfWork</code>在所有纤维上循环，并等待直到<code class="fe mr ms mt mu b">workInProgress</code>为空。</p><p id="0eff" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">重要的是，React不使用递归来遍历树。他们使用简单的while循环来避免大的堆栈(也许如果我们能把PTC放到JS中，那就不一样了)。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="3375" class="nd lv jb mu b gy ne nf l ng nh">while(sthToDo !== null) {<br/>    sthToDo = doSomeWork(sthToDo)<br/>}</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/587f58df5eaabeac9a28c6bac3011049.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*3GHHXtsjQ82jIw30.png"/></div></figure><blockquote class="kq kr ks"><p id="a6f0" class="kt ku kv kw b kx ky kc kz la lb kf lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="jb"> React对简单的“文本”节点进行了额外的优化，以避免创建额外的元素</em></p></blockquote><p id="d579" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">这就是我们可以在React结构中找到优化的地方。</p><p id="c4fb" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">因为所有这些都足够复杂，所以让我们用简化的结构来检查函数被调用数千次时的行为:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="f37a" class="nd lv jb mu b gy ne nf l ng nh">function doSomeWork(unitOfWork) {<br/>	let result = '';<br/>    // I realize that is stupid but just to make a point of doing sth<br/>	for(let i=0; i&lt;1000; i += 1) {<br/>		result += unitOfWork.name;<br/>	}<br/>	return unitOfWork.nextFiber;<br/>}</span></pre><p id="eec6" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">我知道我们不是指返回的<code class="fe mr ms mt mu b">unitOfWork</code>，但这只是运行<code class="fe mr ms mt mu b">doSomeWork</code>多次。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="cdec" class="nd lv jb mu b gy ne nf l ng nh">// testComp.js<br/>const N = 100000;<br/><br/>const startComp = Date.now();<br/>for(let i=0; i&lt;N; i += 1) {<br/>	doSomeWork(comp1);<br/>	doSomeWork(comp2);<br/>	doSomeWork(comp3);<br/>	doSomeWork(comp4);<br/>	doSomeWork(comp5);<br/>}<br/>console.log("test with components:", Date.now() - startComp, "ms.");</span><span id="66bd" class="nd lv jb mu b gy nx nf l ng nh">// testFiber.js<br/>const N = 100000;<br/><br/>const startFiber = Date.now();<br/>for(let i=0; i&lt;N; i += 1) {<br/>	doSomeWork(fiber1);<br/>	doSomeWork(fiber2);<br/>	doSomeWork(fiber3);<br/>	doSomeWork(fiber4);<br/>	doSomeWork(fiber5);<br/>}<br/>console.log("test with fibers:", Date.now() - startFiber, "ms.");</span></pre><p id="e9b7" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">结果:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="f726" class="nd lv jb mu b gy ne nf l ng nh">test with components: 4186 ms. <br/>test with fibers: 2431 ms.</span></pre><p id="6e25" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">为什么结果不一样？主要是因为<code class="fe mr ms mt mu b">FiberNode</code> wrapper。每次调用函数V8都会创建一个名为<code class="fe mr ms mt mu b">Inline Cache</code> (IC)的东西。当具有相同<code class="fe mr ms mt mu b">Shape</code>的对象被传递给IC时，IC用于优化函数执行。你可能还记得我们的纤维有相同的图谱:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="cef5" class="nd lv jb mu b gy ne nf l ng nh">console.log(%HaveSameMap(fiber1, fiber2)); // true</span></pre><p id="1d27" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">而我们的组件却没有</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="a7ae" class="nd lv jb mu b gy ne nf l ng nh">console.log(%HaveSameMap(comp1, comp2)); // false</span></pre><p id="6eb8" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">因为这个简单的事情，V8不能为组件优化<code class="fe mr ms mt mu b">doSomeWork</code></p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8e74d101d748175f817fb8e27de6b62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*1g2FTc0pIhb_iYZC.png"/></div></figure><p id="269d" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">但对纤维来说可以</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9da6bc2c6aa9d9aab20298d692c89ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/0*GQcx5arbQg4dAO0N.png"/></div></figure><p id="91f0" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">如果你看上面的截图，你会注意到第一次V8经历了<code class="fe mr ms mt mu b">premonomorphic (.) -&gt; monomorphic (1) -&gt; polymorphic (P)-&gt; megamorphic (N)</code>状态，但第二次停留在<code class="fe mr ms mt mu b">premonomorphic (.) -&gt; monomorphic (1)</code>状态。在我的<a class="ae lq" href="https://erdem.pl/2019/08/v-8-function-optimization#back-to-our-function" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我描述了优化在V8中是如何工作的。这里我们必须处理<strong class="kw jc">巨形</strong>函数，这意味着它不会被引擎优化，另一方面，我们有<strong class="kw jc">单形</strong>函数，它针对给定的形状(纤维的形状)进行优化。因此，即使有一个额外的层(更复杂的对象)，一个函数可能会执行得更快。</p><h1 id="dcfb" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">结论</h1><p id="8662" class="pw-post-body-paragraph kt ku jb kw b kx mm kc kz la mn kf lc lr mo lf lg ls mp lj lk lt mq ln lo lp ij bi translated">这只是React codebase内部进行的众多优化之一。描述这个的原因是因为它在React之外很有用。Angular对一个叫做<code class="fe mr ms mt mu b">View Nodes</code>的东西使用了同样的方法。您甚至可能希望在我们自己的应用程序中实现这种结构。</p><p id="a8f6" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">我必须为过分简化反应结构道歉。我真的鼓励你去看看，看看<code class="fe mr ms mt mu b">workLoop</code>到底是如何工作的。我的观点是，即使您必须处理许多不同的组件，也有一种方法可以通过创建“特殊”容器而不是直接传递组件来加速函数的执行。</p><p id="fea7" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">如果你想在你的机器上运行那个代码<a class="ae lq" href="https://gist.github.com/burnpiro/fec834b8473ffecd439ae5c98855bc61" rel="noopener ugc nofollow" target="_blank">看看这个要点</a>。随意修改组件或<code class="fe mr ms mt mu b">FiberNode</code>实现，看看会发生什么。</p><p id="6eb0" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated">ofc，祝你今天过得愉快:)</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="8b71" class="pw-post-body-paragraph kt ku jb kw b kx ky kc kz la lb kf lc lr le lf lg ls li lj lk lt lm ln lo lp ij bi translated"><em class="kv">最初发布于</em><a class="ae lq" href="https://erdem.pl/2019/08/react-performance-tricks" rel="noopener ugc nofollow" target="_blank"><em class="kv">https://erdem . pl</em></a><em class="kv">。</em></p></div></div>    
</body>
</html>