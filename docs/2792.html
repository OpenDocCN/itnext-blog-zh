<html>
<head>
<title>How we manage live 1M GraphQL Websocket Subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何管理实时1M GraphQL Websocket订阅</h1>
<blockquote>原文：<a href="https://itnext.io/how-we-manage-live-1m-graphql-websocket-subscriptions-11e1880758b0?source=collection_archive---------0-----------------------#2019-08-04">https://itnext.io/how-we-manage-live-1m-graphql-websocket-subscriptions-11e1880758b0?source=collection_archive---------0-----------------------#2019-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bc9486ef28607665bd20fd13d9caf10a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FVZW923o5NHHkuewirhuw.jpeg"/></div></div></figure><p id="21d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL订阅是我们环境的关键部分，因为它允许使用相同的基于模式/查询的概念，但通过多个UI组件进行实时WebSocket更新。特别是考虑到我们在<a class="ae kz" href="https://hexometer.com" rel="noopener ugc nofollow" target="_blank">Hexometer.com</a>进行UI &lt;&gt; API通信的用例，我们的一些网站分析工具可能会给出部分数据的响应，或者可能会花费大量时间。使用WebSockets允许我们在工具准备好响应时向UI发送数据。</p><p id="a9f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了UI便利性之外，使用基于Queue + PubSub的系统来处理用户请求实际上还有很多好处，因为一切都以异步方式运行，不需要增加新服务或分配更多资源来处理每个请求。然而，当然也有一些缺点，特别是管理WebSocket连接可能需要比标准的请求-响应周期更多的资源。</p><h1 id="ac1e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的基地设置</h1><p id="c14c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">对我们基础设施的所有请求都通过我们的Nginx实例传递，然后该实例根据请求代理特定的服务。我们的Node.js API实例也是如此，它通过我们的Apollo服务器处理GraphQL Websocket订阅。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/75aaa14776945bd9110a3a4db82a3df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wBWqrqHATwj-JhDb"/></div></div></figure><p id="6625" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于这种结构和我们的基准，每个WebSocket连接平均需要大约4Kb的内存，这不是一个大问题，但如果你计算一下我们正在进行的活动连接和活动网站分析的数量，保持活动WebSockets连接会变得越来越昂贵。</p><p id="61d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WebSockets的主要问题是资源使用呈指数级增长，很难预测如何与之匹配。有时，当连接关闭时，Node.js不会释放内存，因为默认情况下有一个特定的超时选项。</p><h1 id="e4b5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Apollo服务器设置</h1><p id="a9db" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">一般来说，我们这里没有任何定制的东西，它是一个基本的Apollo服务器，带有一些中间件来处理连接、验证或通过认证过程。我们使用<code class="fe mi mj mk ml b">cors</code>模块来保持我们的API端点作为子域，并从多个UI项目中访问它。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="a88b" class="mq lb it ml b gy mr ms l mt mu">const server = new ApolloServer({<br/>  resolvers: Resolvers,<br/>  typeDefs,<br/>  context: async ({ req }) =&gt; {<br/>    // Authentication and Connection validation goes here<br/>  },<br/>  subscriptions: {<br/>    keepAlive: 1000,<br/>    onConnect: async (<br/>      connectionParams: ConnectionParamsObject,<br/>      websocket,<br/>      context<br/>    ) =&gt; {<br/>      // Handling connection context here<br/>    },<br/>    onDisconnect: (websocket, context) =&gt; {<br/>      // console.log("WS Disconnected! -&gt; ", JSON.stringify(context));<br/>    },<br/>    path: '/api/ws'<br/>  }<br/>});</span><span id="e820" class="mq lb it ml b gy mv ms l mt mu">const app = express();<br/>app.use(cors());<br/>server.applyMiddleware({ app, path: '/api/ql', cors: false });</span><span id="a03e" class="mq lb it ml b gy mv ms l mt mu">const httpServer = http.createServer(app);<br/>server.installSubscriptionHandlers(httpServer);</span><span id="1242" class="mq lb it ml b gy mv ms l mt mu">const port = process.env.HEXOMETER_PORT || 4000;</span><span id="bead" class="mq lb it ml b gy mv ms l mt mu">httpServer.listen({ port }, () =&gt; {<br/>  console.log(<br/>    `🚀 Server ready at <a class="ae kz" href="http://localhost:${port}${server.graphqlPath}`" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}${server.graphqlPath}`</a><br/>  );<br/>  console.log(<br/>    `🚀 Subscriptions ready at ws://localhost:${port}${<br/>      server.subscriptionsPath<br/>    }`<br/>  );<br/>});</span></pre><p id="2879" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您可能注意到的，我们使用一个<code class="fe mi mj mk ml b">express</code>来进行一个基本的路由，并通过Apollo服务器进行连接，但是，如果我们需要一个外部REST端点(以防万一)，这只是为了进行一些路由。否则，我们在所有应用中只使用基于GraphQL的查询、变异和订阅。即使我们需要从其他服务向我们的主API发出请求，我们也是用GraphQL查询体发出基本的HTTP请求，遵循规则就是这么简单:)</p><h1 id="f94a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">GraphQL订阅</h1><p id="9ff2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">GraphQL订阅背后的主要概念是发送基于特定类型的订阅请求，并保持无限异步迭代器活动，这允许在我们需要时从API端点发送回UI消息。为了实现所有这些过程，我们使用了定制的PubSub库，与Apollo Server默认提供的非常相似。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="a7f3" class="mq lb it ml b gy mr ms l mt mu">import { PubSub } from 'apollo-server-express';<br/>....<br/>export const pubsub = new PubSub();<br/>....</span><span id="067c" class="mq lb it ml b gy mv ms l mt mu">async subscribeResolver(parent: Object, args: Object, context: GrqphqlContext) {<br/>  return pubsub.asyncIterator(topic);<br/>}</span><span id="e2dd" class="mq lb it ml b gy mv ms l mt mu">....</span><span id="5597" class="mq lb it ml b gy mv ms l mt mu">// After some specific events, we can publish to that asyncIterator<br/>// Which will send Websocket message to UI and will try to get another async iterator message<br/>pubsub.publish(topic, data);</span></pre><p id="ed81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个过程很酷的一点是，对于GraphQL订阅，您必须拥有一个异步迭代器来获取UI上发布的消息，否则这与拥有一个基本查询类型是一样的。</p><p id="c8f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以将每个PubSub主题想象成一个队列，它以“先进先出”的概念运行，并且实际上是由所有客户共享的。起初，我们为每个订阅创建了新的PubSub对象，但它最终占用了大量资源，因为每个主题都分配了特定的内存大小，只有当您手动处理连接关闭和清理特定主题队列时，它才会释放内存。</p><p id="7d04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们基本上包装了默认的PubSub类，现在，只要Websocket连接关闭，异步迭代器停止迭代，它就会自动销毁自己。最酷的部分是，我们现在在整个服务中制作单个PubSub对象，但对于每个客户，我们都制作一个单独的主题，这允许我们跨多个模块传递全局<code class="fe mi mj mk ml b">pubsub</code>对象并将对象发送到UI，甚至不需要特定模块的功能。</p><h1 id="c5e0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1M WebSocket问题</h1><p id="687b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果你能想象一下拥有100万个实时WebSocket连接意味着什么，你会发现这需要大量资源，这很难自动扩展，尽管我们所有的基础设施都在Google Cloud Kubernetes上。</p><p id="aa70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实时TCP连接的核心概念是它需要</p><ul class=""><li id="398c" class="mw mx it kd b ke kf ki kj km my kq mz ku na ky nb nc nd ne bi translated">打开文件/套接字</li><li id="f9af" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">为IO缓冲区分配的内存</li><li id="fea6" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">管理数据流事件的CPU周期</li></ul><p id="6795" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有这些都受到操作系统本身的极大限制。当然，这也取决于您的应用程序性能，但是如果您拥有我们所拥有的一切(基本的、默认的方式)，那么您的主要限制或性能问题实际上来自这3个限制。</p><p id="270b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果您将Apache Server作为主要的Websocket处理程序，而不是Nginx，您可能会非常头疼，因为Apache不是异步的，并且会占用大量资源来保持单个连接的活动。因此，选择负载平衡软件至关重要，实际上没有负载平衡器是不行的，因为在任何情况下，您都希望将API实例从一个扩展到多个，这就是微服务的本质。</p><p id="0bf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与其他软件负载平衡器相比，Nginx实际上在资源使用方面要便宜得多，但是，我们必须对其他软件进行一些特定的调整，以使它在WebSocket连接方面更加可靠。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="f49d" class="mq lb it ml b gy mr ms l mt mu">worker_processes auto;<br/>events {<br/>    use epoll;  # Using OS's base Event Loop for IO operations<br/>    worker_connections 1024;<br/>    multi_accept on;<br/>}</span><span id="4341" class="mq lb it ml b gy mv ms l mt mu">....<br/>	location '/ws' {<br/>     ......<br/>     proxy_http_version 1.1;<br/>     proxy_set_header Connection $connection_upgrade;<br/>     proxy_set_header Upgrade $http_upgrade;<br/>     proxy_read_timeout 999950s;  # Just a large number to wait for data<br/>  }<br/>....</span></pre><p id="2494" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里最重要的部分是添加<code class="fe mi mj mk ml b">use epoll</code>配置，这意味着Nginx将维护基本Linux Epoll事件循环系统上的所有连接，为所有硬件驱动程序管理整个IO。这两个字实际上使我们的CPU和内存使用率下降了4-5倍，因为此后Nginx不再为特定套接字维护数据缓冲，而是由OS Epoll自己完成，然后它使用基本的事件原理将缓冲区和套接字状态转移到Nginx。</p><h1 id="c3b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么WebSockets没有那么流行？</h1><p id="c6dd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我认为大多数公司仍然使用基本HTTP请求的原因是他们认为很难维护。但是使用GraphQL订阅，就完全抽象掉了，开发者其实感觉不到任何区别，因为是同样的GraphQL类型，同样的解析器。唯一的区别是，开发人员应该理解拥有PubSub系统的基本概念，以及所有消息/数据流通过队列原则(先进先出)。将GraphQL订阅PubSub连接到Redis或任何其他队列(DB)系统实际上是可能的，但这取决于特定的用例。</p><p id="4128" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们继续将越来越多的内容从基本的查询转移到订阅，为我们的用户提供更多的交互式UI，但我同意它不会完全取代标准的请求响应。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="0d69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过分享和鼓掌来帮助制作更多这种类型的内容👏👏</p></div></div>    
</body>
</html>