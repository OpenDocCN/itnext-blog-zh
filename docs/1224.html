<html>
<head>
<title>Simple internationalization of React apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序的简单国际化</h1>
<blockquote>原文：<a href="https://itnext.io/simple-internationalization-of-react-apps-34b3bda95725?source=collection_archive---------0-----------------------#2018-08-15">https://itnext.io/simple-internationalization-of-react-apps-34b3bda95725?source=collection_archive---------0-----------------------#2018-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8587496e2f5ce6c2103093ba35435382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-PigmqwooA-D4Y64ILK8A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/photos/ywqa9IZB-dU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗曼·维涅斯</a>在<a class="ae kc" href="https://unsplash.com/search/photos/dictionary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><blockquote class="kd ke kf"><p id="8b6c" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kj ir">注:</strong>有没有单语的app？继续读！像复数、数字和日期格式这样的东西即使对于单语项目也仍然有用。</p></blockquote><p id="d9fb" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">国际化是一种完美的方式，可以让你的项目为更多的观众所接受。</p><p id="3c47" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><code class="fe li lj lk ll b">react-intl</code>说到React apps的i18n还是标配。尽管它已经有一年没有维护了，但是这个社区是如此的强大，以至于它越来越受欢迎，新的独立工具也在不断地被发布。</p><p id="7f64" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我想向您介绍我在过去一年半时间里一直在研究的另一种i18n解决方案— <a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>。底层API与<code class="fe li lj lk ll b">react-intl</code>非常相似，使我的项目迁移更容易，但除此之外，还有完全不同的开发人员体验。</p><h2 id="71bc" class="lm ln iq bd lo lp lq dn lr ls lt dp lu lf lv lw lx lg ly lz ma lh mb mc md me bi translated">语言简介</h2><p id="1c69" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">我开始使用LinguiJS作为一个实验，如何使用Babel简化i18n。我花了几个小时调试消息语法中的语法错误，还花了大量时间构建缺失的工具。经过几次迭代，我得到了一个非常类似于<code class="fe li lj lk ll b">react-intl</code>的库，但是在引擎盖下优化了几个<code class="fe li lj lk ll b">react-intl</code>缺少的特性。</p><p id="9bd0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">公开宣布他们正在使用<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>的项目并不多，但是这个库已经有了很多兴奋的用户。加入<a class="ae kc" href="https://lingui.js.org/misc/showroom.html" rel="noopener ugc nofollow" target="_blank"> LinguiJS showroom </a>的最新项目是<a class="ae kc" href="https://www.mymusictaste.com/" rel="noopener ugc nofollow" target="_blank"> MyMusicTaste </a>，一款翻译成13种语言的打字稿app。</p><p id="d041" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">让我们继续学习教程。我假设对i18n一无所知，从头开始:</p><h1 id="03e1" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">什么是国际化</h1><p id="8f98" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">W3C有一个我一直使用的美丽定义:</p><blockquote class="nb"><p id="98e9" class="nc nd iq bd ne nf ng nh ni nj nk le dk translated">国际化是指产品、应用程序或文档内容的设计和开发，能够为不同文化、地区或语言的目标受众轻松实现本地化。— <a class="ae kc" href="https://www.w3.org/International/questions/qa-i18n" rel="noopener ugc nofollow" target="_blank"> W3C Web国际化常见问题解答</a></p></blockquote><p id="c626" class="pw-post-body-paragraph kg kh iq kj b kk nl km kn ko nm kq kr lf nn ku kv lg no ky kz lh np lc ld le ij bi translated">这是什么意思？当你开发一个应用程序，你想让它支持多种语言，你需要找到一种方法来轻松地交换文本的翻译。您应该能够在不修改代码的情况下做到这一点，只需为所有消息提供不同的字典。翻译人员只需很少或根本不需要编程技能就能翻译词典。</p><p id="67a7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">换句话说:<strong class="kj ir">国际化</strong>就是你作为一个开发者所做的事情，允许翻译人员<strong class="kj ir">将你的应用程序本地化</strong>成多种语言。</p><h1 id="5491" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">步骤1 —安装</h1><p id="9364" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">让我们从安装所需的工具开始。<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>附带有用的<a class="ae kc" href="https://lingui.js.org/tutorials/cli.html" rel="noopener ugc nofollow" target="_blank"> CLI </a>我们可以用它来安装所有需要的包:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="932b" class="lm ln iq ll b gy ny nz l oa ob">npm install -g @lingui/cli<br/>lingui init</span></pre><p id="5783" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果你不信任它，只需运行<code class="fe li lj lk ll b">lingui init --dry-run</code>来检查它将安装什么。</p><p id="5c22" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">命令安装<code class="fe li lj lk ll b">@lingui/core</code>和<code class="fe li lj lk ll b">@lingui/react</code>。第一个包包含所有i18n功能，可以用于任何项目。第二个包提供了建立在核心功能之上的React组件，主要是为了利用React生命周期方法和优化重新呈现。</p><p id="8c9d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">它还安装了我们需要添加到我们的<code class="fe li lj lk ll b">.babelrc</code>配置中的<code class="fe li lj lk ll b">@lingui/babel-preset-react</code>:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="556c" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  <strong class="ll ir">"presets"</strong>: [<br/>    "env",<br/>    "react",<br/>    "@lingui/babel-preset-react"<br/>  ]<br/>}</span></pre><p id="07f5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><strong class="kj ir">注:</strong>这个巴别预设完全可选，但推荐。XXX</p><h1 id="e4cd" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">步骤2 —准备应用程序</h1><p id="7ff7" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">首先，我们需要能够从外部字典加载消息，并设置我们将在应用程序中使用的语言。这是<code class="fe li lj lk ll b">I18nProvider</code>的工作。你只需要一次，它应该是你应用程序中最顶层的组件(类似于<a class="ae kc" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank">的<code class="fe li lj lk ll b">Provider</code>react-redux</a>或者<a class="ae kc" href="https://github.com/apollographql/react-apollo" rel="noopener ugc nofollow" target="_blank"> react-apollo </a>的ApolloProvider)。</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="d3d8" class="lm ln iq ll b gy ny nz l oa ob"><em class="ki">// index.js</em><br/><strong class="ll ir">import</strong> React from 'react'<br/><strong class="ll ir">import</strong> { render } from 'react-dom'<br/><strong class="ll ir">import</strong> Inbox from './Inbox.js'<br/><br/><strong class="ll ir">import</strong> { I18nProvider } from '@lingui/react'</span><span id="ed29" class="lm ln iq ll b gy oc nz l oa ob">const catalogs = {}  // don't worry about it now</span><span id="3de6" class="lm ln iq ll b gy oc nz l oa ob"><strong class="ll ir">const</strong> App = () =&gt; (<br/>  &lt;<strong class="ll ir">I18nProvider</strong> language="en" catalogs={catalogs}&gt;<br/>    &lt;<strong class="ll ir">Inbox</strong> /&gt;<br/>  &lt;/<strong class="ll ir">I18nProvider</strong>&gt;<br/>)<br/><br/>render(&lt;<strong class="ll ir">App</strong> /&gt;, document.getElementById('app'))</span></pre><p id="6ceb" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">因为我们没有任何字典(也称为消息目录)，所以现在让<code class="fe li lj lk ll b">catalogs</code> prop为空。我们晚点回来。<code class="fe li lj lk ll b">I18nProvider</code>设置我们接下来要使用的i18n上下文。</p><h1 id="a802" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">步骤3——国际化</h1><p id="49e8" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">有趣的部分来了。我们将把我们的简单应用程序变成一个可以翻译的应用程序。这是我们的应用程序:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="0ea7" class="lm ln iq ll b gy ny nz l oa ob"><strong class="ll ir">const</strong> Inbox = ({ messages, markAsRead, user }) =&gt; {<br/>   <strong class="ll ir">const</strong> messagesCount = messages.length<br/>   <strong class="ll ir">const</strong> { name, lastLogin } = user<br/><br/>   <strong class="ll ir">return</strong> (<br/>      &lt;<strong class="ll ir">div</strong>&gt;<br/>        &lt;<strong class="ll ir">h1</strong>&gt;Message Inbox&lt;/<strong class="ll ir">h1</strong>&gt;<br/><br/>        &lt;<strong class="ll ir">p</strong>&gt;<br/>          See all &lt;<strong class="ll ir">Link</strong> to="/unread"&gt;unread messages&lt;/<strong class="ll ir">Link</strong>&gt;{" or "}<br/>          &lt;<strong class="ll ir">a</strong> onClick={markAsRead}&gt;mark them&lt;/<strong class="ll ir">a</strong>&gt; as read.<br/>        &lt;/<strong class="ll ir">p</strong>&gt;<br/><br/>        &lt;<strong class="ll ir">p</strong>&gt;<br/>          {<br/>            messagesCount === 1<br/>              ? "There's {messagesCount} message in your inbox."<br/>              : "There're {messagesCount} messages in your inbox."<br/>          }<br/>        &lt;/<strong class="ll ir">p</strong>&gt;<br/><br/>        &lt;<strong class="ll ir">footer</strong>&gt;<br/>          Last login on {lastLogin}.<br/>        &lt;/<strong class="ll ir">footer</strong>&gt;<br/>      &lt;/<strong class="ll ir">div</strong>&gt;<br/>   )<br/>}</span></pre><p id="0b45" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">假设我们想翻译标题<strong class="kj ir">消息收件箱</strong>。我们需要将它包装成组件，组件从字典中加载翻译。</p><p id="8859" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>对简单消息使用<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/react.html#trans" rel="noopener ugc nofollow" target="_blank">&lt;Trans&gt;</a></code>组件。我们需要做的就是将我们的消息包装在这个组件中:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="2e91" class="lm ln iq ll b gy ny nz l oa ob">&lt;h1&gt;&lt;Trans&gt;Message Inbox&lt;/Trans&gt;&lt;/h1&gt;</span></pre><p id="d073" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">它是如何工作的？<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/react.html#trans" rel="noopener ugc nofollow" target="_blank">&lt;Trans&gt;</a></code>组件将在字典中查找<strong class="kj ir">消息收件箱</strong>或将其替换为翻译。这是默认的方法，当<em class="ki">我们使用消息作为消息id</em>时。邮件ID是在字典中标识邮件的信息。例如，捷克语词典会是这样的:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="6383" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  "Message Inbox": "Příchozí pošta"<br/>}</span></pre><blockquote class="nb"><p id="5144" class="nc nd iq bd ne nf od oe of og oh le dk translated">消息ID由开发人员定义(在源代码中)，翻译由翻译人员定义(在字典中)。</p></blockquote><h2 id="52e9" class="lm ln iq bd lo lp oi dn lr ls oj dp lu lf ok lw lx lg ol lz ma lh om mc md me bi translated">消息或密钥作为消息id？</h2><p id="1f02" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">您可能听说过使用消息作为id是一种反模式，最好使用自定义键，如下所示:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="89a9" class="lm ln iq ll b gy ny nz l oa ob">&lt;h1&gt;&lt;Trans id="Inbox.message"&gt;Message Inbox&lt;/Trans&gt;&lt;/h1&gt;</span></pre><p id="8858" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">然后，字典会是这样的:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="819d" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  "Inbox.message": "Příchozí pošta"<br/>}</span></pre><p id="d1bd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我就不争论哪个更好了。我一直在从事两种方法都使用的大型项目，但没有一个是完美的。它们各有利弊，最终问题不是你用什么作为消息id，而是你如何在你的开发人员和翻译人员之间建立翻译工作流程。</p><p id="538c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">重要的一点是:<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>支持这两者，并让您，作为一名开发人员，选择最适合您和您的团队的方式。</p><h2 id="d266" class="lm ln iq bd lo lp lq dn lr ls lt dp lu lf lv lw lx lg ly lz ma lh mb mc md me bi translated">带富文本格式的翻译</h2><p id="5790" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">让我们通过下一条消息继续我们的旅程:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="de3e" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>  See all &lt;<strong class="ll ir">Link</strong> to="/unread"&gt;unread messages&lt;/<strong class="ll ir">Link</strong>&gt;{" or "}<br/>  &lt;<strong class="ll ir">a</strong> onClick={markAsRead}&gt;mark them&lt;/<strong class="ll ir">a</strong>&gt; as read.<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="327b" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这一个有点棘手，因为消息包含React组件。理想情况下，我们希望在没有任何标记干扰的情况下翻译“查看所有未读邮件或将它们标记为已读”。不幸的是，我们不能轻易预测翻译后的消息看起来会是什么样子，所以我们需要包含最少的标记。幸运的是，<trans>组件自动为我们做了这件事:</trans></p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="7d5f" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>   &lt;<strong class="ll ir">Trans</strong>&gt;<br/>      See all &lt;<strong class="ll ir">Link</strong> to="/unread"&gt;unread messages&lt;/<strong class="ll ir">Link</strong>&gt;{" or "}<br/>      &lt;<strong class="ll ir">a</strong> onClick={markAsRead}&gt;mark them&lt;/<strong class="ll ir">a</strong>&gt; as read.<br/>   &lt;/<strong class="ll ir">Trans</strong>&gt;<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="20ae" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">没错。我们需要做的就是将消息包装在<trans>中。消息看起来会是什么样子？包括属性在内的React组件被删除，翻译器只获得相关信息。邮件ID将如下所示:</trans></p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="3c84" class="lm ln iq ll b gy ny nz l oa ob">See all &lt;0&gt;unread messages&lt;/0&gt; or &lt;1&gt;mark them&lt;/1&gt; as read.</span></pre><p id="080f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我曾经做过在消息中包含html属性的项目，当我们在改变类或href后必须更新翻译时，这总是困扰着我。在这种情况下，translator得到了他们需要的一切，我可以使用内置元素和反应组件，而没有任何限制。</p><p id="d705" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">和前面的例子一样，如果您喜欢用键作为消息id，也可以这样做:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="3665" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>   &lt;<strong class="ll ir">Trans id</strong>="Inbox.actionsDescription"&gt;<br/>      See all &lt;<strong class="ll ir">Link</strong> to="/unread"&gt;unread messages&lt;/<strong class="ll ir">Link</strong>&gt;{" or "}<br/>      &lt;<strong class="ll ir">a</strong> onClick={markAsRead}&gt;mark them&lt;/<strong class="ll ir">a</strong>&gt; as read.<br/>   &lt;/<strong class="ll ir">Trans</strong>&gt;<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="a7cf" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在翻译者将得到:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="c446" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  "Inbox.actionsDescription": <br/>    "See all &lt;0&gt;unread messages&lt;/0&gt; or &lt;1&gt;mark them&lt;/1&gt; as read."<br/>}</span></pre><h2 id="f8ba" class="lm ln iq bd lo lp lq dn lr ls lt dp lu lf lv lw lx lg ly lz ma lh mb mc md me bi translated">复数</h2><p id="5465" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">下一条信息也很棘手，但方式不同。</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="79c1" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>  {<br/>    messagesCount === 1<br/>      ? "There's {messagesCount} message in your inbox."<br/>      : "There're {messagesCount} messages in your inbox."<br/>  }<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="83dd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">看到了吗？有时信息依赖于一个变量。不仅仅是在消息内部包含一个变量，而是使用完全不同的形式。这是一种常见的语言特征，称为复数，通常我们在收件箱中使用简化的消息来避免这个问题。不幸的是，这只适用于有两种复数形式(单数、复数)的语言。在捷克语中，我们有3种复数形式，有些语言甚至更多。</p><p id="ae28" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在怎么办？我们不能对每种语言都有不同的<code class="fe li lj lk ll b">if</code>条件。这需要针对每种语言重构我们的应用程序。相反，我们将使用国际化消息格式来处理所有需要的语言特性。</p><p id="c16f" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我给你介绍一下<a class="ae kc" href="https://lingui.js.org/ref/message-format.html" rel="noopener ugc nofollow" target="_blank"> ICU消息格式</a>。这种格式足够简单，即使没有编程知识的翻译人员也可以使用，但功能足够强大，可以支持不同语言的所有语法差异。</p><p id="0c69" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们的消息以ICU消息格式表示，如下所示:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="bd30" class="lm ln iq ll b gy ny nz l oa ob">{messagesCount, plural,<br/>   one {There's # message in your inbox}<br/>   other {There're # messages in your inbox}<br/>}</span></pre><p id="9865" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们看到有一个变量<code class="fe li lj lk ll b">messageCount</code>，接着是格式化程序<code class="fe li lj lk ll b">plural</code>，最后是这个格式化程序的参数。<code class="fe li lj lk ll b">one</code>用于单数，<code class="fe li lj lk ll b">other</code>用于复数。在捷克语中，这将是:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="a78f" class="lm ln iq ll b gy ny nz l oa ob">{messagesCount, plural,<br/>   one {Máte # zprávu v příchozí poště}<br/>   few {Máte # zprávy v příchozí poště}<br/>   other {Máte # zpráv v příchozí poště}<br/>}</span></pre><p id="f99c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">看出区别了吗？除了一个词之外，这些信息几乎完全相同！</p><p id="5dc4" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我猜你现在感到很困惑，因为这一切看起来很复杂。但是再一次，<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>将事情简化了很多。</p><p id="eeab" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">这次我们要用<a class="ae kc" href="https://lingui.js.org/ref/react.html#plural" rel="noopener ugc nofollow" target="_blank">&lt;&gt;</a>的复数代替<a class="ae kc" href="https://lingui.js.org/ref/react.html#trans" rel="noopener ugc nofollow" target="_blank">&lt;&gt;</a>的反式成分:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="d81f" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>   &lt;<strong class="ll ir">Plural</strong><br/>      value={messagesCount}<br/>      one="There's # message in your inbox"<br/>      other="There're # messages in your inbox"<br/>   /&gt;<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="b35d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们用复数&gt; 组件替换了conditional，并在<code class="fe li lj lk ll b">one</code>和<code class="fe li lj lk ll b">other</code>道具中添加了消息。这就是我们需要做的。LinguiJS自动生成ICU MessageFormat格式的语法有效的消息。</p><p id="037e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们也不关心其他语言的复数。作为开发人员，我们只需要提供源代码中使用的语言的复数形式(本例中为英语)。其他一切都由翻译和图书馆处理。</p><h2 id="9560" class="lm ln iq bd lo lp lq dn lr ls lt dp lu lf lv lw lx lg ly lz ma lh mb mc md me bi translated">引擎盖下的复数</h2><p id="70bc" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated"><a class="ae kc" href="https://lingui.js.org/ref/react.html#plural" rel="noopener ugc nofollow" target="_blank"> &lt;复数&gt; </a>组件对于不同复数形式的翻译(例如捷克语中的一个、几个、其他)是如何工作的并不明显，所以让我们看看它是如何工作的。</p><p id="2d62" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated"><a class="ae kc" href="https://lingui.js.org/ref/react.html#plural" rel="noopener ugc nofollow" target="_blank"> &lt;复数&gt; </a>组件在Babel插件中解析，替换为<a class="ae kc" href="https://lingui.js.org/ref/react.html#trans" rel="noopener ugc nofollow" target="_blank"> &lt; Trans &gt; </a>组件:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="6e23" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>   &lt;<strong class="ll ir">Trans</strong><br/>      id="{messagesCount, plural, one {There's # message in your inbox} other {There're # messages in your inbox}}"<br/>      values={{ messagesCount }}<br/>   /&gt;<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="900a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">复数的格式化由核心库使用语言特定的复数规则来处理。当我们从翻译器获得翻译后的消息时，我们不必改变我们的<a class="ae kc" href="https://lingui.js.org/ref/react.html#plural" rel="noopener ugc nofollow" target="_blank"> &lt;复数&gt; </a>组件。它只是作为ICU MessageFormat的一种更简单的语法。</p><p id="97a8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">值得一提的是，自定义键也支持复数:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="28d4" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">p</strong>&gt;<br/>   &lt;<strong class="ll ir">Plural<br/>      </strong>id="Inbox.messageCount"<br/>      value={messagesCount}<br/>      one="There's # message in your inbox"<br/>      other="There're # messages in your inbox"<br/>   /&gt;<br/>&lt;/<strong class="ll ir">p</strong>&gt;</span></pre><p id="2a26" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">翻译者会得到:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="0b48" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  "Inbox.messageCount": <br/>    "{messagesCount, plural, one {There's # message in your inbox} other {There're # messages in your inbox}}"<br/>}</span></pre><p id="b9c6" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">复数有点难以理解，但是非常容易使用。我试图深入解释它们是如何工作的，但大多数信息只与翻译人员相关。作为开发人员，我们关心的只是默认语言使用的复数形式。</p><h2 id="8efa" class="lm ln iq bd lo lp lq dn lr ls lt dp lu lf lv lw lx lg ly lz ma lh mb mc md me bi translated">日期和数字格式</h2><p id="2df7" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">最后，我们将看到应用程序中的最后一条消息。在上一节中，我谈到了复数，这是一种语言的特征。这次我们将关注日期和数字格式，这取决于国家和文化。</p><p id="853d" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在美国，通常用格式<code class="fe li lj lk ll b">MM/DD/YYYY</code>写日期，而在捷克语中，我们通常写<code class="fe li lj lk ll b">YYYY/MM/DD</code>。同样，作为开发人员，我们不应该被要求知道我们需要使用什么样的日期格式。那是翻译的工作。我们只需将消息包装在我们习惯的<a class="ae kc" href="https://lingui.js.org/ref/react.html#trans" rel="noopener ugc nofollow" target="_blank"> &lt; Trans &gt; </a>组件中，并使用<a class="ae kc" href="https://lingui.js.org/ref/react.html#dateformat" rel="noopener ugc nofollow" target="_blank"> &lt; DateFormat &gt; </a>组件进行日期格式化。</p><p id="aa61" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">原始邮件:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="f903" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">footer</strong>&gt;<br/>  Last login on {lastLogin}.<br/>&lt;/<strong class="ll ir">footer</strong>&gt;</span></pre><p id="f36a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">…看起来会像这样:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="ef6f" class="lm ln iq ll b gy ny nz l oa ob">&lt;<strong class="ll ir">footer</strong>&gt;<br/>   &lt;<strong class="ll ir">Trans</strong>&gt;<br/>      Last login on &lt;<strong class="ll ir">DateTimeFormat</strong> value={lastLogin} /&gt;.<br/>   &lt;/<strong class="ll ir">Trans</strong>&gt;<br/>&lt;/<strong class="ll ir">footer</strong>&gt;</span></pre><p id="40b5" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">翻译器将处理消息<code class="fe li lj lk ll b">Last login on {lastLogin, date}.</code><code class="fe li lj lk ll b">lastLogin</code>变量使用<code class="fe li lj lk ll b">date</code>格式化器格式化，该格式化器使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat" rel="noopener ugc nofollow" target="_blank"> Intl。DateTimeFormat </a>隐藏起来(因此允许相同的格式选项)。</p><p id="09f7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">数字格式非常相似，我们只是用<a class="ae kc" href="https://lingui.js.org/ref/react.html#numberformat" rel="noopener ugc nofollow" target="_blank"> &lt;数字格式&gt; </a>代替。</p><h1 id="b160" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">步骤4-创建消息目录</h1><p id="2aa1" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">我们的工作大部分已经完成。一旦我们的应用程序国际化了，我们需要创建一个<strong class="kj ir">消息目录</strong>(我称之为<strong class="kj ir">字典</strong>)并发送给翻译人员。</p><p id="a30e" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">CLI又来了。命令解析源代码，找到所有需要翻译的消息，并将其提取到外部文件中。</p><p id="f389" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">首先，我们需要定义我们将在<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/cli.html#add-locale" rel="noopener ugc nofollow" target="_blank">lingui add-locale</a></code>命令中使用的语言。先说英语和捷克语:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="c127" class="lm ln iq ll b gy ny nz l oa ob">lingui add-locale en cs</span></pre><p id="8f4a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们会得到一个确认和一个类似git的帮助，告诉我们下一步该怎么做:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="05bd" class="lm ln iq ll b gy ny nz l oa ob">Added locale en.<br/>Added locale cs.<br/><br/>(use "lingui extract" to extract messages)</span></pre><p id="9139" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">运行<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/cli.html#extract" rel="noopener ugc nofollow" target="_blank">lingui extract</a></code>在<code class="fe li lj lk ll b">locale</code>目录下创建一个消息目录；</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="f205" class="lm ln iq ll b gy ny nz l oa ob">lingui extract</span></pre><p id="48a8" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">该命令输出关于总翻译和缺失翻译的统计信息:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="280e" class="lm ln iq ll b gy ny nz l oa ob">Extracting messages from source files…<br/>Collecting all messages…<br/>Writing message catalogs…<br/>Messages extracted!<br/><br/>Catalog statistics:<br/>┌──────────┬─────────────┬─────────┐<br/>│ Language │ Total count │ Missing │<br/>├──────────┼─────────────┼─────────┤<br/>│ cs       │     4       │   4     │<br/>│ en       │     4       │   4     │<br/>└──────────┴─────────────┴─────────┘<br/><br/>(use "lingui add-locale &lt;locale&gt;" to add more locales)<br/>(use "lingui extract" to update catalogs with new messages)<br/>(use "lingui compile" to compile catalogs for production)</span></pre><p id="5864" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">默认情况下，提取的空目录看起来像这样，但是<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a> CLI也支持一个<a class="ae kc" href="https://lingui.js.org/ref/conf.html#po" rel="noopener ugc nofollow" target="_blank"> po文件</a>:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="3507" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  <strong class="ll ir">"Message Inbox"</strong>: "",<br/>  <strong class="ll ir">"See all &lt;0&gt;unread messages&lt;/0&gt; or &lt;1&gt;mark them&lt;/1&gt; as read."</strong>: "",<br/>  <strong class="ll ir">"{messagesCount, plural, one {There's {messagesCount} message in your inbox.} other {There're {messagesCount} messages in your inbox.}}"</strong>: "",<br/>  <strong class="ll ir">"Last login on {lastLogin,date}."</strong>: "",<br/>}</span></pre><p id="9236" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们在源代码中使用英语，因为我们不使用关键字作为消息id，所以我们不需要翻译英语消息目录！让我们通过将<code class="fe li lj lk ll b">lingui</code> <a class="ae kc" href="https://lingui.js.org/ref/conf.html" rel="noopener ugc nofollow" target="_blank">配置</a>添加到我们的<code class="fe li lj lk ll b">package.json</code>来修复它(如果您使用密钥作为消息id，请跳过这一步):</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="f6c4" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  "lingui": {<br/>    "sourceLocale": "en",<br/>  }<br/>}</span></pre><p id="3531" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">另外，让我做你的捷克语翻译。这是捷克语的目录:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="68de" class="lm ln iq ll b gy ny nz l oa ob">{<br/>  <strong class="ll ir">"Message Inbox"</strong>: <br/>    "Přijaté zprávy",</span><span id="6267" class="lm ln iq ll b gy oc nz l oa ob">  <strong class="ll ir">"See all &lt;0&gt;unread messages&lt;/0&gt; or &lt;1&gt;mark them&lt;/1&gt; as read."</strong>:<br/>    "Zobrazit všechny &lt;0&gt;nepřečtené zprávy&lt;/0&gt; nebo je &lt;1&gt;označit&lt;/1&gt; jako přečtené.",</span><span id="0440" class="lm ln iq ll b gy oc nz l oa ob">  <strong class="ll ir">"{messagesCount, plural, one {There's {messagesCount} message in your inbox.} other {There're {messagesCount} messages in your inbox.}}"</strong>:<br/>    "{messagesCount, plural, one {V příchozí poště je {messagesCount} zpráva.} few {V příchozí poště jsou {messagesCount} zprávy. } other {V příchozí poště je {messagesCount} zpráv.}}",</span><span id="a4fb" class="lm ln iq ll b gy oc nz l oa ob">  <strong class="ll ir">"Last login on {lastLogin,date}."</strong>:<br/>    "Poslední přihlášení {lastLogin,date}",<br/>}</span></pre><p id="084c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">让我们再次运行<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/cli.html#extract" rel="noopener ugc nofollow" target="_blank">lingui extract</a></code>:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="ad2e" class="lm ln iq ll b gy ny nz l oa ob">Extracting messages from source files…<br/>Collecting all messages…<br/>Writing message catalogs…<br/>Messages extracted!<br/><br/>Catalog statistics:<br/>┌────────────┬─────────────┬─────────┐<br/>│ Language   │ Total count │ Missing │<br/>├────────────┼─────────────┼─────────┤<br/>│ cs         │     4       │   0     │<br/>│ en (source)│     4       │   -     │<br/>└────────────┴─────────────┴─────────┘<br/><br/>(use "lingui add-locale &lt;locale&gt;" to add more locales)<br/>(use "lingui extract" to update catalogs with new messages)<br/>(use "lingui compile" to compile catalogs for production)</span></pre><p id="934a" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">就是这样！我们现在有了所有需要的翻译，我们可以进入最后一步。如你所见，我们可以随时运行<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/cli.html#extract" rel="noopener ugc nofollow" target="_blank">lingui extract</a></code>，它会将现有的翻译与任何新消息合并。当我们从源代码中删除消息时，它还会标记过时的消息。</p><h1 id="0bd4" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">步骤5—加载翻译</h1><p id="21f7" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">下面是与其他i18n库有点不同的部分。在加载翻译后的消息目录之前，我们需要编译它们。编译将ICU MessageFormat中的消息转换成简单的JavaScript函数，该函数接受插值的值。</p><p id="bb32" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">编译使库变得很小很快，因为我们不需要在产品包中包含消息解析器。</p><p id="8d55" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我们可以使用<code class="fe li lj lk ll b"><a class="ae kc" href="http://lingui compile" rel="noopener ugc nofollow" target="_blank">lingui compile</a></code>手动编译消息目录:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="22ad" class="lm ln iq ll b gy ny nz l oa ob">Compiling message catalogs…<br/>Done!</span></pre><p id="5ba1" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">该命令在原<code class="fe li lj lk ll b">messages.json</code>旁边创建<code class="fe li lj lk ll b">messages.js</code>。值得一提的是，<code class="fe li lj lk ll b">messages.json</code>是为翻译人员准备的文件，而<code class="fe li lj lk ll b">messages.js</code>是加载到我们的应用程序中的。</p><p id="80d0" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果你使用的是webpack，你可以使用<code class="fe li lj lk ll b"><a class="ae kc" href="https://lingui.js.org/ref/loader.html" rel="noopener ugc nofollow" target="_blank">@lingui/loader</a></code>来动态编译信息。</p><p id="c957" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">现在我们需要将目录加载到我们的应用程序中。让我们回到教程的开头:</p><pre class="nq nr ns nt gt nu ll nv nw aw nx bi"><span id="7b79" class="lm ln iq ll b gy ny nz l oa ob"><em class="ki">// index.js</em><br/><strong class="ll ir">import</strong> React from 'react'<br/><strong class="ll ir">import</strong> { render } from 'react-dom'<br/><strong class="ll ir">import</strong> Inbox from './Inbox.js'<br/><strong class="ll ir">import</strong> catalogEn from './locale/en/messages.js'<br/><strong class="ll ir">import</strong> catalogCs from './locale/cs/messages.js'<br/><br/><strong class="ll ir">import</strong> { I18nProvider } from '@lingui/react'</span><span id="3ba8" class="lm ln iq ll b gy oc nz l oa ob"><strong class="ll ir">const</strong> catalogs = { en: catalogEn, cs: catalogCs }</span><span id="9da8" class="lm ln iq ll b gy oc nz l oa ob"><strong class="ll ir">const</strong> App = () =&gt; (<br/>  &lt;<strong class="ll ir">I18nProvider</strong> language="en" catalogs={catalogs}&gt;<br/>    &lt;<strong class="ll ir">Inbox</strong> /&gt;<br/>  &lt;/<strong class="ll ir">I18nProvider</strong>&gt;<br/>)<br/><br/>render(&lt;<strong class="ll ir">App</strong> /&gt;, document.getElementById('app'))</span></pre><p id="fc51" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">为了简化这个冗长的教程，我们一次加载所有消息。prop接受一个字典，其中键是可用的语言，值是编译的目录。</p><p id="ca34" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果你对更复杂的用例感兴趣，看看这篇关于使用webpack动态加载消息目录的指南。</p><h1 id="1bb5" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">第六步——下一步是什么</h1><p id="ffe7" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">还有一些工作要做，比如切换语言(取决于React使用的数据层)，但i18n的基础知识已经涵盖。</p><p id="5d89" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">在<a class="ae kc" href="https://lingui.js.org/tutorials/react-patterns.html" rel="noopener ugc nofollow" target="_blank"> React中描述了许多常见的i18n模式——常见模式</a>教程，如文本属性的翻译或在React上下文之外使用<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>(例如在redux-saga中)。</p><p id="a9fc" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">查看全面的<a class="ae kc" href="https://lingui.js.org/" rel="noopener ugc nofollow" target="_blank">文档</a>以获取其他教程、指南和参考资料。</p><h1 id="2534" class="mk ln iq bd lo ml mm mn lr mo mp mq lu mr ms mt lx mu mv mw ma mx my mz md na bi translated">今后</h1><p id="1e5a" class="pw-post-body-paragraph kg kh iq kj b kk mf km kn ko mg kq kr lf mh ku kv lg mi ky kz lh mj lc ld le ij bi translated">下一个版本的LinguiJS 将在不久的将来推出。巴别塔插件将被许多框架支持的巴别塔宏所取代。例如，我已经用即将发布的create-react-app 2.0测试了开发版本，效果非常好。</p><p id="cb1c" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">不要误会我的意思，你现在可以在CRA上使用<a class="ae kc" href="https://github.com/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> LinguiJS </a>，但是没有插件和无缝语法，它只是另一个i18n lib(虽然占用空间更小)。</p><p id="2ec7" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">即将推出的版本也会小一点。现在核心库是2kb gzipped，React组件增加了3kb gzipped。总的来说，这比全功能的i18n lib的<a class="ae kc" href="https://github.com/emotion-js/emotion" rel="noopener ugc nofollow" target="_blank">情感</a>少两倍。</p><figure class="nq nr ns nt gt jr"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="56bd" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">我也在研究开箱即用的代码分割，但这需要更多的研究。</p><p id="2678" class="pw-post-body-paragraph kg kh iq kj b kk kl km kn ko kp kq kr lf kt ku kv lg kx ky kz lh lb lc ld le ij bi translated">如果你有兴趣，试试看。加入我们的<a class="ae kc" href="https://gitter.im/lingui/js-lingui" rel="noopener ugc nofollow" target="_blank"> gitter </a>或者在twitter上分享你的经历。我很好奇你的意见或建议。</p></div></div>    
</body>
</html>