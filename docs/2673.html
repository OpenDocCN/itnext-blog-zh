<html>
<head>
<title>ReactJS Interview Questions for Senior Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJS针对高级开发人员的面试问题</h1>
<blockquote>原文：<a href="https://itnext.io/reactjs-interview-questions-for-senior-developers-64618f6a0aca?source=collection_archive---------0-----------------------#2019-07-09">https://itnext.io/reactjs-interview-questions-for-senior-developers-64618f6a0aca?source=collection_archive---------0-----------------------#2019-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f02eb73425c22d3519e00a4c4f0503aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zs5s6VrCvohpkVXu-Z09Qw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">https://unsplash.com/photos/wawEfYdpkag<a class="ae kc" href="https://unsplash.com/photos/wawEfYdpkag" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="3ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个房间里有几个已经使用React年以上的开发人员，他们很可能会问你类似“道具和状态的区别”这样的问题。</p><p id="9bbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，人们希望看到你对常见的ReactJS模式、众所周知的陷阱、如何重构和测试你的组件等等的了解。</p><p id="abc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以和React一起工作多年，实际上对一些不太实际的问题没有意见，这很好。然而，如果你有一个面试，那么有一个观点是非常重要的。为什么？嗯，首先，能够回答面试官的问题感觉很好，也表明了你对这个话题的兴趣。</p><h1 id="68ee" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q1。为什么我们既有受控输入又有不受控输入？</h1><h2 id="1190" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想要看到的:对基本反应概念的深刻理解。</h2><p id="cd2b" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">好吧，这更像是一个热身问题。更重要的是给出一个完整的答案。</p><p id="350c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">一个受控输入</strong>接受它的当前值作为一个属性，以及一个改变该值的回调。这是一种“反应方式”:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7c25" class="lz lc iq mv b gy mz na l nb nc">&lt;input type="text" value={value} onChange={this.handleChange} /&gt;</span></pre><p id="f6a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不受控制的输入使用DOM API在内部存储自己的状态。</p><p id="5853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里不提供<code class="fe nd ne nf mv b">value</code>和<code class="fe nd ne nf mv b">onChange</code>句柄，但是我们使用<a class="ae kc" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> ref </a>():</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3a45" class="lz lc iq mv b gy mz na l nb nc">&lt;input type="text" ref={this.textInput} /&gt;</span></pre><p id="8a96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以通过以下方式访问输入数据:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fc41" class="lz lc iq mv b gy mz na l nb nc">this.textInput.current.value</span></pre><p id="7334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你的面试官想听到更多细节:使用不受控制的组件有什么好处吗，有什么性能差异吗？</p><p id="f28e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就我个人而言，我从未使用过不受控制的输入，但是如果你正在学习React或者你必须集成React和non React代码，那么这可能是必要的。</p><p id="d141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得一提的是，您的数据(状态)和UI(输入)总是与受控输入方法同步，这意味着您必须更新组件的状态，这将触发<a class="ae kc" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"> React协调过程</a>。</p><p id="c2d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而对于不受控制的元素就不需要这样了——只需将值保存在输入DOM元素中。</p><h1 id="6f24" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q2。为什么我们需要一个密钥属性？给出一个坏键导致错误的例子。</h1><h2 id="80c6" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看的:关于React内部运作的一些见解。</h2><p id="6bc7" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">答案基于<a class="ae kc" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">官方React对账流程文件</a>。</p><p id="aff7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存在具有O(n)时间复杂度的经典差分算法，其可用于创建反应元素树。但这意味着显示1000个元素需要<strong class="kf ir">十亿次</strong>比较。</p><p id="0b78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，React实现了一个启发式的O(n)算法，并假设开发人员可以用一个<code class="fe nd ne nf mv b">key</code>道具提示哪些子元素在不同的渲染中可能是稳定的。</p><p id="fc1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">坏钥匙怎么办？嗯，如果你决定让你的孩子可移动，索引可能是一个非常糟糕的键。<a class="ae kc" href="https://codesandbox.io/s/react-example-qfp5s" rel="noopener ugc nofollow" target="_blank">看看这个演示</a>。尝试在第二个输入中键入一些内容，然后删除第一个。但是你仍然可以看到第二个的价值，为什么呢？</p><p id="a67d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为你的钥匙不稳定。删除后，您的第三个孩子的键等于3，现在的键等于2。这和现在反应不是同一个元素。它会将其与错误的DOM元素进行匹配，该元素之前有一个等于2的键(它保留了我们在第二个输入中键入的值)。</p><h1 id="5526" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q3。React事件系统与DOM事件有何不同。使用stopImmediatePropagation()。</h1><h2 id="f373" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看的:不同JavaScript事件模型的一般知识和日常实践经验。</h2><p id="0ebf" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">回答这个问题的最好方法是先简要解释一下像冒泡和捕获这样的DOM事件概念是如何工作的。</p><p id="d466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，使用冒泡，事件首先被最内部的元素捕获和处理，然后传播到外部元素。</p><p id="fd83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过捕获，事件首先被最外面的元素捕获，然后传播到内部元素。</p><p id="bae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看这篇文章，了解更多信息和演示。</p><p id="7caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那之后，最好提一下React使用了<strong class="kf ir">事件委托模式</strong>——而不是给它们每个都分配一个处理程序——我们在它们的共同祖先上放了一个处理程序，可以用<code class="fe nd ne nf mv b">event.target</code>访问那个元素。</p><p id="297c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后很明显地解释了<code class="fe nd ne nf mv b">stopImmediatePropagation</code>与传统<code class="fe nd ne nf mv b">stopPropagation</code>方法的不同之处:由于事件委托模式，它防止了同一个事件的其他侦听器被调用。</p><h1 id="2243" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q4。如何防止组件重渲染？</h1><h2 id="845d" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看到的:更多关于反应的知识，你关心表现。</h2><p id="953d" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">这是最常被问到的问题之一。值得一提的是:</p><ol class=""><li id="b906" class="ng nh iq kf b kg kh kk kl ko ni ks nj kw nk la nl nm nn no bi translated"><strong class="kf ir">shouldcomponentdupdate()</strong>—默认情况下返回“真”。如果您知道哪些属性必须触发更新，您可以覆盖。</li><li id="bfa9" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated"><strong class="kf ir"> PureComponents </strong> —它们之间的区别在于<code class="fe nd ne nf mv b"><a class="ae kc" href="https://reactjs.org/docs/react-api.html#reactcomponent" rel="noopener ugc nofollow" target="_blank">React.Component</a></code>没有实现<code class="fe nd ne nf mv b"><a class="ae kc" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdat</a>e</code>方法，而<code class="fe nd ne nf mv b">React.PureComponent</code>用一个浅属性和状态比较实现了它。</li><li id="ab45" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated"><strong class="kf ir"> React.memo </strong> —与前一个相同，但它与功能组件一起工作。</li></ol><p id="99b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为后续:什么时候使用Component而不是PureComponent？</p><p id="0e54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在modern React中，99%的情况下使用PureComponents。但是，如果使用Redux选择器，通常需要显式指定传入的属性更改，以取消即将发生的重新渲染，从而防止UI抖动。在这种情况下，使用组件是合适的。</p><p id="42c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对这篇<a class="ae kc" href="http://jamesknelson.com/should-i-use-shouldcomponentupdate/" rel="noopener ugc nofollow" target="_blank">深度阅读</a>有些模糊，那就来看看吧。</p><h1 id="d8b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q5。举一个HOC的例子。</h1><h2 id="17c9" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看到的:你熟悉一个众所周知的反应模式。</h2><p id="ff32" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><em class="nu"> HOC </em> —高阶分量是接受一个分量并返回一个新分量的函数。这是一种在React组件之间共享代码的技术。</p><p id="a1e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个简单的按钮组件:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9904" class="lz lc iq mv b gy mz na l nb nc">const Button = props =&gt; &lt;button {...props}&gt;Hello&lt;/button&gt;;</span></pre><p id="565e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想为按钮组件创建一个红色边框的特设。让我们使用我们的定义来创建它:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d4c5" class="lz lc iq mv b gy mz na l nb nc">const withRedBorder = Component =&gt;<br/>  (props) =&gt; (<br/>    &lt;Component {...props} style={{ border: "1px solid red" }} /&gt;<br/>  );</span></pre><p id="181e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以创建一个RedButton组件:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="189e" class="lz lc iq mv b gy mz na l nb nc">const RedButton = withRedBorder(Button);</span><span id="b620" class="lz lc iq mv b gy nv na l nb nc">// and use it as:<br/>&lt;RedButton /&gt;</span></pre><p id="a378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用特设模式的库:<a class="ae kc" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank"> Redux connect </a>，<a class="ae kc" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank">compose</a>。</p><h1 id="0228" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q6。什么是渲染道具？</h1><h2 id="3dfa" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看到的:你熟悉第二种众所周知的反应模式。</h2><p id="fae5" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated"><em class="nu">渲染道具</em> —当一个组件接受一个返回React元素的函数并调用它，而不是实现它自己的渲染逻辑。</p><p id="373c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是React组件之间共享代码的另一种技术。</p><p id="672f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个例子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="869b" class="lz lc iq mv b gy mz na l nb nc">&lt;DataProvider render={data =&gt; (<br/>  &lt;h1&gt;Hello {data.target}&lt;/h1&gt;<br/>)}/&gt;</span></pre><p id="5edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用渲染道具模式的库:<a class="ae kc" href="https://reacttraining.com/react-router/web/api/Route/render-func" rel="noopener ugc nofollow" target="_blank">反应路由器</a>，<a class="ae kc" href="https://github.com/paypal/downshift" rel="noopener ugc nofollow" target="_blank">降档</a>。</p><p id="6eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">一个后续</strong>:那HOC vs渲染道具呢。哪款比较好，什么时候用？这是一个颇有争议的话题，在这篇<a class="ae kc" href="https://www.richardkotze.com/coding/hoc-vs-render-props-react" rel="noopener ugc nofollow" target="_blank">文章</a>中你可以找到一些赞成和反对的意见。</p><h1 id="046b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> Q7。对组件的单元测试和集成测试进行反应。</strong></h1><h2 id="d084" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看什么:了解测试组件的不同方法。</h2><p id="ef4f" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">值得一提的是<a class="ae kc" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">酶</a>和<a class="ae kc" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank">反应测试库</a>。</p><p id="f72f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> React测试库</strong>提供了一个干净简单的API，专注于“像用户一样”测试应用程序。这意味着API返回HTML元素，而不是用Enzyme中的浅层渲染来反应组件。这是一个编写集成测试的好工具。</p><p id="9fff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Enzyme </strong>仍然是一个有效的工具，它提供了一个更复杂的API，可以让你访问组件的属性和内部状态。为组件创建<strong class="kf ir">单元测试</strong>是有意义的。</p><p id="7b29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看这个关于react-testing-library的简洁视频。</p><h1 id="3c47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> Q8。你最喜欢的钩子是什么，如何实现？</strong></h1><h2 id="95f2" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看的:钩子的实际用法和对其工作原理的理解。</h2><p id="e6b4" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">尽管钩子仍然是新的API，但是很多人已经在生产中使用它了，他们希望你了解它。</p><p id="b553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重新创建一个<code class="fe nd ne nf mv b">useWindowSize</code>——它是一个易读且非常简单的钩子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3ab4" class="lz lc iq mv b gy mz na l nb nc">import { useState, useEffect } from 'react';</span><span id="aaf4" class="lz lc iq mv b gy nv na l nb nc">const useWindowSize = () =&gt; {<br/>  const getSize = () =&gt; ({<br/>    width: window.innerWidth,<br/>    height: window.innerHeight<br/>  });</span><span id="9d07" class="lz lc iq mv b gy nv na l nb nc">  const [size, setSize] = useState(getSize);</span><span id="929b" class="lz lc iq mv b gy nv na l nb nc">  useEffect(() =&gt; {<br/>    const handleResize = () =&gt; setSize(getSize());<br/>    window.addEventListener('resize', handleResize);<br/>    return () =&gt; window.removeEventListener('resize', handleResize);<br/>  }, []);</span><span id="d37b" class="lz lc iq mv b gy nv na l nb nc">  return size;<br/>}</span></pre><p id="f07c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用法:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="156c" class="lz lc iq mv b gy mz na l nb nc">const App = () =&gt; {<br/>  const size = useWindowSize();</span><span id="6454" class="lz lc iq mv b gy nv na l nb nc">  return (<br/>    &lt;div&gt;<br/>      {size.width}px / {size.height}px<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="2aca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会想到一些问题，如:</p><p id="fedd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nu"> 1。有必要调用你的函数</em> <code class="fe nd ne nf mv b"><em class="nu">useWindowSize</em></code> <em class="nu">吗，直接调用getWindowSize怎么样？</em></p><p id="498b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，如果没有它，我们将无法自动检查钩子的<a class="ae kc" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则的违反情况，因为我们无法判断某个函数内部是否包含对钩子的调用。</a></p><p id="721f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nu"> 2。如果我们把</em> <code class="fe nd ne nf mv b"><em class="nu">useEffect</em></code> <em class="nu">中的</em> <code class="fe nd ne nf mv b"><em class="nu">[]</em></code> <em class="nu">论点去掉，会管用吗？</em></p><p id="313a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，但是我们会在每次渲染时调用<code class="fe nd ne nf mv b">useEffect</code>钩子，这可能会导致性能问题。</p><p id="2a9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nu"> 3。如果我们在</em> <code class="fe nd ne nf mv b"><em class="nu">useWindowSize</em></code> <em class="nu">中处理窗口大小调整，React如何知道何时重新渲染</em> <code class="fe nd ne nf mv b"><em class="nu">App</em></code> <em class="nu">组件？</em></p><p id="a732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你在自定义钩子内部调用<code class="fe nd ne nf mv b">setSize</code>时，React知道这个钩子用在了<code class="fe nd ne nf mv b">App</code>组件中，并将重新渲染它。</p><p id="5103" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些反作用钩子的魔法。看看<a class="ae kc" href="https://overreacted.io/why-do-hooks-rely-on-call-order/" rel="noopener ugc nofollow" target="_blank">为什么React挂钩依赖于调用顺序？</a>文章了解更多信息。</p><p id="f1b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nu"> 4。如何让这个钩子为服务器端渲染做好准备？</em></p><p id="829f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概是这样的:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="98d3" class="lz lc iq mv b gy mz na l nb nc">import { useState, useEffect } from 'react';</span><span id="ec5a" class="lz lc iq mv b gy nv na l nb nc">const useWindowSize = () =&gt; {<br/>  const isClient = typeof window === 'object';  <br/>  const getSize = () =&gt; ({<br/>    width: isClient ? window.innerWidth : undefined,<br/>    height: isClient ? window.innerHeight : undefined<br/>  });</span><span id="3996" class="lz lc iq mv b gy nv na l nb nc">  const [size, setSize] = useState(getSize);</span><span id="caa1" class="lz lc iq mv b gy nv na l nb nc">  useEffect(() =&gt; {<br/>    const handleResize = () =&gt; setSize(getSize());<br/>    window.addEventListener('resize', handleResize);<br/>    return () =&gt; window.removeEventListener('resize', handleResize);<br/>  }, []);</span><span id="0024" class="lz lc iq mv b gy nv na l nb nc">  return size;<br/>}</span></pre><h1 id="fcd3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q9。上下文API。重新渲染了多少？</h1><h2 id="bed9" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看的:可以说是React中最重要的东西——如何管理数据流。</h2><p id="f86f" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">首先，值得一提的是，与Redux不同，上下文<strong class="kf ir">没有自己的状态，</strong>相反，它只是一个管道，通常从另一个组件的状态读取数据。</p><p id="c5c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，有了上下文API，即使你使用PureComponent或React.memo ，也可以很容易地重新渲染比你需要的多得多的内容。</p><p id="f496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，我们每次点击按钮都会在控制台中看到一条新消息:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="24a7" class="lz lc iq mv b gy mz na l nb nc">import React, { useState, useContext } from "react";<br/>import ReactDOM from "react-dom";</span><span id="1475" class="lz lc iq mv b gy nv na l nb nc">const ProfileContext = React.createContext();</span><span id="bca4" class="lz lc iq mv b gy nv na l nb nc">const App = () =&gt; {<br/>  const [val, setIncrement] = useState(0);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Profile userInfo={val} /&gt;<br/>      &lt;button onClick={() =&gt; setIncrement(val + 1)}&gt;Click&lt;/button&gt;<br/>      &lt;p&gt;value: {val}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="1afd" class="lz lc iq mv b gy nv na l nb nc">class Profile extends React.PureComponent {<br/>  state = {<br/>    name: "Alex"<br/>  };</span><span id="670a" class="lz lc iq mv b gy nv na l nb nc">  setName(name) {<br/>    this.setState({ name });<br/>  }</span><span id="dd31" class="lz lc iq mv b gy nv na l nb nc">  render() {<br/>    const { name } = this.state;<br/>    const { setName } = this;</span><span id="53e8" class="lz lc iq mv b gy nv na l nb nc">    return (<br/>      &lt;ProfileContext.Provider<br/>        value={{<br/>          name,<br/>          setName<br/>        }}<br/>      &gt;<br/>        &lt;Logger /&gt;<br/>      &lt;/ProfileContext.Provider&gt;<br/>    );<br/>  }<br/>}</span><span id="6c21" class="lz lc iq mv b gy nv na l nb nc">const Logger = React.memo(() =&gt; {<br/>  const { name } = useContext(ProfileContext);<br/>  console.log("Logger rerendering");<br/>  return null;<br/>});</span><span id="233e" class="lz lc iq mv b gy nv na l nb nc">ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</span></pre><p id="0fa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们的<code class="fe nd ne nf mv b"><strong class="kf ir">Logger</strong></code> <strong class="kf ir">组件是一个纯组件，但是我们仍然每次都重新渲染</strong>。这是因为我们使用了上下文。尝试注释掉Logger组件中的第一行，现在它不会重新呈现。</p><p id="3cf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为上下文使用引用标识来确定何时重新呈现。让我们改变我们的<code class="fe nd ne nf mv b">Profile</code>组件来使它工作:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9854" class="lz lc iq mv b gy mz na l nb nc">class Profile extends React.PureComponent {<br/>  state = {<br/>    name: "Alex",<br/>    setName(name) {<br/>      this.setState({ name });<br/>    }<br/>  };</span><span id="2c1d" class="lz lc iq mv b gy nv na l nb nc">  render() {<br/>    return (<br/>      &lt;ProfileContext.Provider value={this.state}&gt;<br/>        &lt;Logger /&gt;<br/>      &lt;/ProfileContext.Provider&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="d48a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在它像预期的那样工作了。顺便说一句，如果你知道如何让它和钩子一起工作——把它贴在评论区吧！</p><h1 id="8c5c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Q10。从类到功能组件的迁移。</h1><h2 id="e52f" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">面试官想看到的:你知道如何使用钩子重构ReactJS，并且你可以展示出来。</h2><p id="8926" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">使用功能组件和挂钩，您可以覆盖所有类组件用例，例如:</p><ol class=""><li id="f381" class="ng nh iq kf b kg kh kk kl ko ni ks nj kw nk la nl nm nn no bi translated">带有useState挂钩的类组件状态</li><li id="aa24" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">带有useEffect挂钩的类组件生命周期方法</li><li id="3b75" class="ng nh iq kf b kg np kk nq ko nr ks ns kw nt la nl nm nn no bi translated">额外的好处:更好的抽象和定制挂钩</li></ol><p id="c647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下面的例子，并使用钩子重构它:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2b27" class="lz lc iq mv b gy mz na l nb nc">class App extends React.Component {<br/>  state = {<br/>    value: localStorage.getItem("info") || ""<br/>  };</span><span id="83f7" class="lz lc iq mv b gy nv na l nb nc">  componentDidUpdate() {<br/>    localStorage.setItem("info", this.state.value);<br/>  }</span><span id="472c" class="lz lc iq mv b gy nv na l nb nc">  onChange = event =&gt; {<br/>    this.setState({ value: event.target.value });<br/>  };</span><span id="3494" class="lz lc iq mv b gy nv na l nb nc">  render() {<br/>    const { value } = this.state;<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;input value={value} type="text" onChange={this.onChange} /&gt;<br/>        &lt;p&gt;{value}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="d431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<a class="ae kc" href="http://class fields" rel="noopener ugc nofollow" target="_blank">类字段声明</a>和<a class="ae kc" href="https://javascriptweblog.wordpress.com/2015/11/02/of-classes-and-arrow-functions-a-cautionary-tale/" rel="noopener ugc nofollow" target="_blank">类箭头函数</a>，这已经很紧凑了。</p><p id="a131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">替换<code class="fe nd ne nf mv b">setState</code>和<code class="fe nd ne nf mv b">componentDidUpdate</code>的第一次重构可能是这样的:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="dbdd" class="lz lc iq mv b gy mz na l nb nc">const App = () =&gt; {<br/>  const val = localStorage.getItem("info") || "";<br/>  const [value, setValue] = useState(val);<br/>  const onChange = event =&gt; setValue(event.target.value);</span><span id="e789" class="lz lc iq mv b gy nv na l nb nc">  useEffect(() =&gt; localStorage.setItem("info", value), [value]);</span><span id="4486" class="lz lc iq mv b gy nv na l nb nc">  return (<br/>    &lt;div&gt;<br/>      &lt;input value={value} type="text" onChange={onChange} /&gt;<br/>      &lt;p&gt;{value}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="ccb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有13行代码，而不是具有完全相同功能的19个类。但是我们可以更进一步:我们可以很容易地在这里提取和重用一个自定义钩子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1ee6" class="lz lc iq mv b gy mz na l nb nc">const usePersistentStorage = key =&gt; {<br/>  const val = localStorage.getItem(key) || "";<br/>  const [value, setValue] = useState(val);</span><span id="9ddb" class="lz lc iq mv b gy nv na l nb nc">  useEffect(() =&gt; localStorage.setItem(key, value), [key, value]);</span><span id="8bd6" class="lz lc iq mv b gy nv na l nb nc">  return [value, setValue];<br/>};</span></pre><p id="21fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在我们的<code class="fe nd ne nf mv b">App</code>中使用这个:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f575" class="lz lc iq mv b gy mz na l nb nc">const App = () =&gt; {<br/>  const [value, setValue] = usePersistentStorage("info");<br/>  const onChange = event =&gt; setValue(event.target.value);</span><span id="086f" class="lz lc iq mv b gy nv na l nb nc">  return (<br/>    &lt;div&gt;<br/>      &lt;input value={value} type="text" onChange={onChange} /&gt;<br/>      &lt;p&gt;{value}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="7003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有10行代码，比以前缩短了两倍。在真正的应用程序中，您可以提取更多信息。</p><h1 id="b02e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在你搞定它之前。</h1><p id="8c11" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">请记住，给出一个清晰而宽泛的答案是至关重要的。</p><p id="5a73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，人们不会要求你在白板上写下react组件的单元测试，但是缺乏对不同react组件测试方法的解释会导致更多的问题。</p><p id="61d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且，感觉越来越多的采访集中在钩子上。使用<a class="ae kc" href="https://usehooks.com" rel="noopener ugc nofollow" target="_blank">这个网站</a>来练习。</p><h1 id="bde7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">就是这样！</h1><p id="6618" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">如果你有任何问题或反馈，请在下面的评论中告诉我。</p><h2 id="c051" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">如果这有用，请点击拍手👏下面扣几下，以示支持！⬇⬇ 🙏🏼</h2></div></div>    
</body>
</html>