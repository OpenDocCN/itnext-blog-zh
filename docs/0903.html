<html>
<head>
<title>Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是为什么在JavaScript中映射一个构造好的数组不起作用的原因</h1>
<blockquote>原文：<a href="https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a?source=collection_archive---------0-----------------------#2018-06-15">https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a?source=collection_archive---------0-----------------------#2018-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6094" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何正确地去做</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/870b1b67d5cff4d6363056a0f3b97a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFIR37BFmQcxyPd7UPs6xg.png"/></div></div></figure><h1 id="e93f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">方案</h1><p id="e17b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了便于演示，假设您需要生成一个从0到99的数字数组。你会怎么做？这里有一个选择:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="2894" class="mn kv it mj b gy mo mp l mq mr">const arr = [];</span><span id="3db5" class="mn kv it mj b gy ms mp l mq mr">for (let i = 0; i &lt; 100; i++) {<br/>  arr[i] = i;<br/>}</span></pre><p id="e37f" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">如果你和我一样，在JavaScript中看到传统的for循环会让你有点不舒服。事实上，由于高阶函数如<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> forEach </a>、<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> map </a>、<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> filter </a>、<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> reduce </a>，我已经<em class="my">年</em>没有写过一个传统的for-loop <em class="my">、T1。面向胜利的声明式函数编程！</em></p><p id="14c6" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">也许你还没有喝过函数式编程的苦艾酒，你认为上面的解决方案看起来非常好。从技术上来说确实如此，但是在你领略了高阶函数的魔力之后，你可能会想，“<em class="my"> There </em> <strong class="lo iu"> <em class="my">一定是更好的方法。</em></strong></p><p id="3482" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">我对这个问题的第一反应是，“<em class="my">我知道！我将创建一个长度为100的空数组，并将索引映射到每个元素！</em> " JavaScript允许您使用数组构造函数创建一个长度为<em class="my"> n </em>的空数组，如下所示:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="d1d4" class="mn kv it mj b gy mo mp l mq mr">const arr = Array(100);</span></pre><p id="85ea" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">完美，对吧？我有一个长度为100的数组，所以现在我只需要将索引映射到每个元素。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="1880" class="mn kv it mj b gy mo mp l mq mr">const arr = Array(100).map((_, i) =&gt; i);</span><span id="7fce" class="mn kv it mj b gy ms mp l mq mr">console.log(arr[0] === undefined);  // true</span></pre><p id="2295" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">什么鬼东西！？数组的第一个元素应该是<em class="my"> 0 </em>，但实际上是<em class="my">未定义</em>！</p><h1 id="6cdf" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">说明</h1><p id="7001" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了解释为什么会发生这种情况，我需要在这里做一个重要的技术区分。在内部，JavaScript数组<strong class="lo iu">是</strong>对象，以数字作为键。例如:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="0113" class="mn kv it mj b gy mo mp l mq mr">['a', 'b', 'c']</span></pre><p id="1c4d" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">本质上等同于这个对象:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="a324" class="mn kv it mj b gy mo mp l mq mr">{<br/>  0: 'a',<br/>  1: 'b',<br/>  2: 'c',<br/>  length: 3<br/>}</span></pre><p id="4c91" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">当访问数组中索引为0的元素时，实际上只是访问一个键为0的对象属性。这一点很重要，因为当您将数组视为对象并结合这些高阶函数的实现方式时(别担心，我已经为您完成了这一部分)，我们问题的原因就很清楚了。</p><p id="4dee" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">当你用数组构造函数创建一个新的数组时，它会创建一个新的数组对象，它的<em class="my">长度</em>属性被设置为你传入的值，否则<em class="my">对象就是一个真空</em>。无论如何，在数组的对象表示中没有索引键。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="77aa" class="mn kv it mj b gy mo mp l mq mr">{<br/>  //no index keys!<br/>  length: 100<br/>}</span></pre><p id="5b93" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">当您试图访问索引0处的数组值时，您会得到<em class="my">未定义的</em>，但这并不是说值<em class="my">未定义的</em>存储在索引0处，而是说如果您试图访问一个不存在的键的对象的值，JavaScript中的默认行为是返回<em class="my">未定义的</em>。</p><p id="f0e0" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">恰好高阶函数<em class="my">映射</em>、<em class="my">归约</em>、<em class="my">过滤</em>、<em class="my"> forEach </em>从0到<em class="my">长度</em>迭代数组对象的索引键，但是只有在对象上存在的情况下才会执行<em class="my">回调。这解释了为什么我们的回调函数从来没有被调用，当我们在数组上调用map函数时什么也没有发生——因为没有索引键！</em></p><h1 id="6178" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">解决办法</h1><p id="ee08" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">正如你现在所知道的，我们需要的是一个数组，它的内部对象表示包含一个从0到<em class="my">长度</em>的每个数字的键。最好的方法是<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">将数组</a>展开成一个空数组。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="7392" class="mn kv it mj b gy mo mp l mq mr">const arr = [...Array(100)].map((_, i) =&gt; i);</span><span id="3433" class="mn kv it mj b gy ms mp l mq mr">console.log(arr[0]);<br/>// 0</span></pre><p id="9919" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">将数组展开为空数组会导致数组在每个索引处填充未定义的<em class="my"/>。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="ce2e" class="mn kv it mj b gy mo mp l mq mr">{<br/>  0: undefined,<br/>  1: undefined,<br/>  2: undefined,<br/>  ...<br/>  99: undefined,<br/>  length: 100<br/>}</span></pre><p id="7dbe" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">这是因为spread运算符比map函数简单。它简单地从0到<em class="my">长度</em>遍历数组(或任何可迭代的对象),并在封闭数组中创建一个新的索引键，该索引键的值来自当前索引处的扩展数组。由于JavaScript在其每个索引处从我们的扩展数组返回<em class="my"> undefined </em>(记住，它默认这样做，因为它没有该值的索引键)，我们最终得到一个实际上填充了索引键的新数组，因此<em class="my">映射</em> -able(以及<em class="my">减少</em> -able、<em class="my">过滤</em> -able和<em class="my"> forEach </em> -able)。</p><h1 id="89af" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="6fb1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们发现了数组在Javascript中被内部表示为对象的一些含义，并了解了创建任意长度的数组的最佳方式，其中填充了您需要的任何值。</p><p id="8bc7" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated"><em class="my">一如既往，请在下面留下您的评论、问题和反馈！</em></p><p id="eeb2" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated">编码快乐！👍</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="5cf8" class="ku kv it bd kw kx nh kz la lb ni ld le jz nj ka lg kc nk kd li kf nl kg lk ll bi translated">跟我来。</h1><p id="ccf1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你喜欢这篇文章，请关注我！或者至少给我一两下掌声。你能省下一点掌声，对吧？</p><p id="9efd" class="pw-post-body-paragraph lm ln it lo b lp mt ju lr ls mu jx lu lv mv lx ly lz mw mb mc md mx mf mg mh im bi translated"><strong class="lo iu">中</strong>:<a class="ae mz" href="https://medium.com/@shawn.webdev" rel="noopener">@ Shawn . web dev</a><br/><strong class="lo iu">推特</strong>:<a class="ae mz" href="https://twitter.com/ReisnerShawn" rel="noopener ugc nofollow" target="_blank">@ reisner Shawn</a><br/><strong class="lo iu">dev . to</strong>:<strong class="lo iu"/><a class="ae mz" href="https://dev.to/sreisner" rel="noopener ugc nofollow" target="_blank">@ sreisner</a><strong class="lo iu"><br/>insta gram</strong>:<a class="ae mz" href="https://www.instagram.com/shawn.webdev" rel="noopener ugc nofollow" target="_blank">@ Shawn . web dev</a></p><h1 id="d1e5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">查看我的更多作品</h1><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/a-quick-practical-use-case-for-es6-generators-building-an-infinitely-repeating-array-49d74f555666"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">ES6发电机的快速实用用例</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">构建无限重复的数组</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">itnext.io</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/understanding-the-react-context-api-through-building-a-shared-snackbar-for-in-app-notifications-6c199446b80c"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">学习React Context API，并将其应用到您的应用中</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">为应用内通知构建共享素材UI Snackbar</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">itnext.io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/building-a-toggled-mask-password-input-component-w-react-and-material-ui-f55e6bd73434"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">使用React和Material UI构建“Mask Toggle”密码输入组件</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">众所周知，允许用户切换密码输入可见性消除了摩擦并提高了用户…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">itnext.io</p></div></div><div class="ny l"><div class="of l oa ob oc ny od ks np"/></div></div></a></div></div></div>    
</body>
</html>