<html>
<head>
<title>Patch Kubernetes resources in Java using Fabric8 Kubernetes Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fabric8 Kubernetes客户端在Java中修补Kubernetes资源</h1>
<blockquote>原文：<a href="https://itnext.io/patch-kubernetes-resources-in-java-using-fabric8-kubernetes-client-25e0c68b9cb5?source=collection_archive---------0-----------------------#2021-05-22">https://itnext.io/patch-kubernetes-resources-in-java-using-fabric8-kubernetes-client-25e0c68b9cb5?source=collection_archive---------0-----------------------#2021-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/6f8fc6c970d4c4727c35fbb5b811bc63.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*-58gIpXpeckgKtH8jJPUfA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://github.com/fabric8io/kubernetes-client" rel="noopener ugc nofollow" target="_blank"> Fabric8 Kubernetes客户端</a></figcaption></figure><p id="0cc8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在今天的博客中，我们将探讨如何使用Fabric8 Kubernetes Client在java中以编程方式就地更新Kubernetes API对象。在我们的最新版本中，我们对这个补丁API做了很多改进，我认为写一篇关于它的博客是个不错的主意。为了使用Fabric8 Kubernetes客户端，您需要将Fabric8 Kubernetes客户端作为项目中的依赖项。如果这是一个maven项目，您需要添加以下内容:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="35b4" class="lg lh iq lc b gy li lj l lk ll"><strong class="lc ir">&lt;dependency&gt;<br/>  &lt;groupId&gt;</strong>io.fabric8<strong class="lc ir">&lt;/groupId&gt;<br/>  &lt;artifactId</strong>&gt;kubernetes-client<strong class="lc ir">&lt;/artifactId&gt;<br/>  &lt;version&gt;</strong>6.1.1<strong class="lc ir">&lt;/version&gt;<br/>&lt;/dependency&gt;</strong></span></pre><p id="cf55" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">一旦添加了依赖项，您就可以开始使用客户端了。为了使用补丁API。您需要在kubernetes集群中已经存在一些资源。我使用minikube作为本地kubernetes集群进行测试。让我们创建一个简单的部署，稍后我们将使用补丁API对其进行修改。以下是创建部署的代码:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">为我们的补丁测试创建示例部署</figcaption></figure><p id="9e0b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果您运行这个示例，您将能够看到正在创建的部署。查看与您的部署相关联的窗格:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="03f1" class="lg lh iq lc b gy li lj l lk ll">$ kubectl get pods</span></pre><p id="2fc4" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">输出显示该部署有两个pod。<code class="fe lo lp lq lc b">1/1</code>表示每个Pod有一个容器:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="e219" class="lg lh iq lc b gy li lj l lk ll">NAME                        READY     STATUS    RESTARTS   AGE<br/>patch-demo-28633765-670qr   1/1       Running   0          23s<br/>patch-demo-28633765-j5qs3   1/1       Running   0          23s</span></pre><p id="7a0b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">此时，每个Pod都有一个运行nginx映像的容器。现在假设您希望每个Pod有两个容器:一个运行nginx，一个运行redis。</p><p id="112c" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">按照我们旧的补丁API，您需要提供一个完整的对象，其中包含修改过的补丁对象，以便能够打补丁。下面是使用旧API添加另一个容器的示例:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Fabric8 Kubernetes客户端旧补丁API</figcaption></figure><p id="893b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行此代码并查看修补后的部署:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="bc79" class="lg lh iq lc b gy li lj l lk ll"><strong class="lc ir">$</strong> kubectl get deploy patch-demo  -ojsonpath='{.spec.template.spec.containers}' | jq . <br/><strong class="lc ir">[</strong> <br/><strong class="lc ir">  {</strong> <br/><strong class="lc ir">    "image": </strong>"nginx"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "imagePullPolicy": </strong>"Always"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "name": </strong>"patch-demo-ctr"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "resources": {},</strong> <br/><strong class="lc ir">    "terminationMessagePath": </strong>"/dev/termination-log"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "terminationMessagePolicy": </strong>"File" <br/><strong class="lc ir">  },</strong> <br/><strong class="lc ir">  {</strong> <br/><strong class="lc ir">    "image": </strong>"redis"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "imagePullPolicy": </strong>"Always"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "name": </strong>"patch-demo-ctr-2"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "resources": {},</strong> <br/><strong class="lc ir">    "terminationMessagePath": </strong>"/dev/termination-log"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "terminationMessagePolicy": </strong>"File" <br/><strong class="lc ir">  }</strong> <br/><strong class="lc ir">]</strong></span></pre><p id="5b2b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如你所见，我们的<code class="fe lo lp lq lc b">Deployment</code>现在有两个容器，而不是一个，这意味着我们的补丁工作了。Kubernetes支持三种补丁策略，早期的Fabric8 Kubernetes客户端没有为我们提供任何选项，只做了<a class="ae jy" href="https://datatracker.ietf.org/doc/html/rfc6902" rel="noopener ugc nofollow" target="_blank"> JSON补丁(RFC 6902) </a>。</p><p id="cc7b" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们来看一下最新版本中所有新的补丁选项。</p><h1 id="0463" class="lr lh iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用策略合并补丁进行补丁操作:</h1><p id="bfc7" class="pw-post-body-paragraph jz ka iq kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ij bi translated">Fabric8 Kuberenetes客户端还提供了一个<code class="fe lo lp lq lc b">patch(String patchAsStr)</code>方法，该方法接受原始JSON/YAML字符串，您可以提供该字符串进行修补。默认情况下，它使用战略合并补丁(这只是一个定制版本的<a class="ae jy" href="https://datatracker.ietf.org/doc/html/rfc7396" rel="noopener ugc nofollow" target="_blank"> JSON合并补丁(RFC 7396) </a>)。下面是如何用这个新方法完成上述操作:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">为战略合并补丁提供JSON字符串</figcaption></figure><p id="9a44" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">您可以通过在这个patch方法中提供一个额外的<code class="fe lo lp lq lc b">PatchContext</code>来覆盖它，它相当于<a class="ae jy" href="https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/types.go#L554" rel="noopener ugc nofollow" target="_blank"> client-go的PatchOptions </a>:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用PatchContext提供补丁类型</figcaption></figure><p id="865a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行上述代码后，您应该能够看到与之前全身补丁示例相同的结果。</p><h1 id="8559" class="lr lh iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用JSON补丁进行补丁操作:</h1><p id="de2d" class="pw-post-body-paragraph jz ka iq kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ij bi translated">假设我们想将这个<code class="fe lo lp lq lc b">Deployment</code>的第一个容器映像更新为<code class="fe lo lp lq lc b">nginx:mainline</code>，我们想使用JSON补丁来完成这个任务。我们可以简单地通过在<code class="fe lo lp lq lc b">PatchContext</code>中指定<code class="fe lo lp lq lc b">PatchType.JSON</code>作为补丁类型来实现，如下所示:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">在补丁操作中使用JSON补丁</figcaption></figure><p id="0fec" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当您运行这段代码时，您应该能够看到我们的<code class="fe lo lp lq lc b">Deployment</code>图像正在更新:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b0a9" class="lg lh iq lc b gy li lj l lk ll"><strong class="lc ir">$</strong> kubectl get deploy patch-demo  -ojsonpath='{.spec.template.spec.containers}' | jq . <br/><strong class="lc ir">[</strong> <br/><strong class="lc ir">  {</strong> <br/><strong class="lc ir">    "image": </strong>"nginx:mainline"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "imagePullPolicy": </strong>"Always"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "name": </strong>"patch-demo-ctr-2"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "resources": {},</strong> <br/><strong class="lc ir">    "terminationMessagePath": </strong>"/dev/termination-log"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "terminationMessagePolicy": </strong>"File" <br/><strong class="lc ir">  },</strong> <br/><strong class="lc ir">  {</strong> <br/><strong class="lc ir">    "image": </strong>"nginx"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "imagePullPolicy": </strong>"Always"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "name": </strong>"patch-demo-ctr"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "resources": {},</strong> <br/><strong class="lc ir">    "terminationMessagePath": </strong>"/dev/termination-log"<strong class="lc ir">,</strong> <br/><strong class="lc ir">    "terminationMessagePolicy": </strong>"File" <br/><strong class="lc ir">  }</strong> <br/><strong class="lc ir">]</strong></span></pre><h1 id="9590" class="lr lh iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用JSON合并补丁进行补丁操作:</h1><p id="2a52" class="pw-post-body-paragraph jz ka iq kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ij bi translated">使用Json合并补丁也非常类似于使用上述两种补丁技术。我们只需要在<code class="fe lo lp lq lc b">PatchContext</code>中指定<code class="fe lo lp lq lc b">PatchType.JSON_MERGE</code>为补丁类型。让我们尝试使用Json Merge patch删除一个注释。我们的部署现在有以下注释:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="cbb0" class="lg lh iq lc b gy li lj l lk ll"><strong class="lc ir">$</strong> kubectl get deploy patch-demo  -ojsonpath='{.metadata.annotations}' | jq . <br/><strong class="lc ir">{</strong> <br/><strong class="lc ir">  "app": </strong>"nginx"<strong class="lc ir">,</strong> <br/><strong class="lc ir">  "deployment.kubernetes.io/revision": </strong>"3"<strong class="lc ir">,</strong> <br/><strong class="lc ir">  "foo": </strong>"bar" <br/><strong class="lc ir">}</strong></span></pre><p id="7c04" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们试着用键<code class="fe lo lp lq lc b">foo</code>删除注释，下面是我们的做法:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lm ln l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用JSON合并补丁更新部署</figcaption></figure><p id="b812" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当您运行这段代码时，您应该能够看到正在更新的注释:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7308" class="lg lh iq lc b gy li lj l lk ll">$ kubectl get deploy patch-demo  -ojsonpath='{.metadata.annotations}' | jq . <br/><strong class="lc ir">{</strong> <br/><strong class="lc ir">  "app": </strong>"nginx"<strong class="lc ir">,</strong> <br/><strong class="lc ir">  "deployment.kubernetes.io/revision": </strong>"6" <br/><strong class="lc ir">}</strong></span></pre><h1 id="9200" class="lr lh iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论:</h1><p id="3ca0" class="pw-post-body-paragraph jz ka iq kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ij bi translated">在今天的博客中，您看到了如何利用Fabric8 Kubernetes客户端补丁API来更改任何Kubernetes对象的实时配置。您可以在这个资源库的<a class="ae jy" href="https://github.com/rohanKanojia/kubernetes-client-demo/blob/master/src/main/java/io/fabric8/PatchExamples.java" rel="noopener ugc nofollow" target="_blank">PatchExamples.java</a>中找到所有这些代码:</p><div class="mt mu gp gr mv mw"><a href="https://github.com/rohanKanojia/kubernetes-client-demo" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd ir gy z fp nb fr fs nc fu fw ip bi translated">rohanKanojia/kubernetes-客户端-演示</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">该项目包含Fabric8 Kubernetes客户端不同用法的各种示例。我通常在我的…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk js mw"/></div></div></a></div></div></div>    
</body>
</html>