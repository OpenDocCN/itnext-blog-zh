<html>
<head>
<title>Implementing JSON Web Tokens &amp; Passport.js in a JavaScript Application with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React在JavaScript应用程序中实现JSON Web令牌&amp; Passport.js</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436?source=collection_archive---------0-----------------------#2018-09-12">https://itnext.io/implementing-json-web-tokens-passport-js-in-a-javascript-application-with-react-b86b1f313436?source=collection_archive---------0-----------------------#2018-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/62c07f64b655a74e502b841d25d45de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V33pOI8o-eADn-GDjPfnOA.png"/></div></div></figure><p id="15f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">T2在你说之前，我知道，我知道。已经有大量的MERN教程展示了如何在Express中使用JWT (JSON Web Tokens)和Passport.js。</p><p id="37a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这里是每一个教程都没有提到的，而我的教程将会涉及的:</p><blockquote class="lf"><p id="1596" class="lg lh iq bd li lj lk ll lm ln lo kv dk translated">如何以及为什么使用Passport提供的各种身份验证方式(包括<code class="fe lp lq lr ls b">passport-jwt</code>)，以及让我犯错误的陷阱</p></blockquote><p id="53de" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku kv ij bi translated">一连几个小时，我都在整理用户注册申请。</p><p id="faec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不知道你有什么经验，但是我专业参与的大多数项目都已经得到了别人的授权。因此，除了提高我的MERN技能之外，我还将此视为一个学习更多关于安全性和身份验证以及不同实现方式的机会。</p><p id="00b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将主要讲述如何在服务器端实现护照和JWT，因为那里是大部分魔法发生的地方，但是如果你愿意，你可以在这里看到源文件并下载完整的MERN项目<a class="ae ly" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">。一旦它被正确地连接到后端，前端就是纯粹的反应。</a></p><p id="cb15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我开始之前，让我给你一个JWT和Passport.js认证的快速运行。</p><h2 id="e1de" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">什么是JSON Web令牌？</h2><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/47466920f940137c505f0df1b924bf9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkmnsJ6Joa6EDFVGUw0tfA.png"/></div></div></figure><p id="1162" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个JSON Web令牌，根据站点是:</p><blockquote class="mx my mz"><p id="3a4f" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">“…一种开放标准(<a class="ae ly" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，它定义了一种紧凑且独立的方式，以JSON对象的形式在各方之间安全地传输信息。”— JWT.io</p></blockquote><p id="0210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从本质上讲，jwt是可以验证和信任的数字签名令牌，它们越来越受各方(如服务器和客户端)的安全和授权以及交换敏感信息的欢迎，同时验证令牌没有被篡改或解码。</p><p id="1427" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会深入讨论令牌如何工作的细节，您可以从比我更有资格的来源阅读所有相关内容<a class="ae ly" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">这里是</a>，但可以说，我选择使用JWT作为我的用户验证策略的一部分，以及Passport.js来使我的简单用户注册应用程序安全(因为我很好奇我是否能做到这一点，因为我没有太多实现授权的实践经验)。</p><p id="c678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我的认证解决方案的下一部分是Passport.js。</p><h2 id="5b2c" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">什么是Passport.js &amp;我为什么要使用它？</h2><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b4848f08a21ca227045f673a8d6d1cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*YI1tt4kGzvea-v4dAhZ90w.png"/></div></figure><p id="3154" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">护照是:</p><blockquote class="mx my mz"><p id="3737" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">Node.js — Passport.js的简单、不引人注目的身份验证</p></blockquote><p id="a331" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它和Express配合得非常好。Passport是用于节点的身份验证中间件，它有一个目的，即以模块化的方式对请求进行身份验证，将所有其他功能留给应用程序本身，从而使代码更简洁、更易于维护，并提供清晰的关注点分离。</p><p id="7486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在谷歌搜索栏中输入“JavaScript认证中间件”或者仅仅是“JavaScript认证”，Passport.js会排在前五名。这就是这个解决方案在JavaScript生态系统中无处不在的原因。</p><p id="2cd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我提到过它拥有500多种身份认证策略吗？确实如此。您是否希望使用简单的用户名和密码、Github凭证、脸书、oAuth等登录。，可能有Passport.js策略。</p><p id="291c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以选择Passport作为我的授权策略的一部分是一个简单的决定。</p><p id="a67b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想在网站上添加文档是很好的，尽管有些东西如<a class="ae ly" href="http://www.passportjs.org/docs/authorize/" rel="noopener ugc nofollow" target="_blank">自定义回调</a>需要更仔细的阅读(对我来说，还有试错)才能正确设置。但是我超越了自己，我将讨论实现中的问题。</p><h2 id="dad0" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">我如何在Express.js中实现它们(以及一点反应)？</h2><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/7809fb83511e2857387755e605db6730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8DELPVuI_w8045sxmHQsA.png"/></div></div></figure><p id="e0a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在到了有趣的部分，如何在一个Express/Node应用程序中实现Passport.js和JWT？老实说，它难倒了我好一阵子。但是在无数的教程、重读文档和求助于Stack Overflow之后，我找到了理解和满足的地方。</p><p id="02fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我应该说，我的这个应用程序的目标之一是使它模块化，使它非常简单地添加或删除功能，所以当你看到我的文件结构时，你会注意到CRUD功能(创建、读取、更新、删除)的所有路径都构建在单独的文件中，并且所有的Passport身份验证都在一个集中的文件中处理。这里看一下我的应用程序的API部分的文件结构。</p><p id="b5e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">API文件树</strong></p><pre class="mt mu mv mw gt ng ls nh ni aw nj bi"><span id="10fb" class="lz ma iq ls b gy nk nl l nm nn">root/<br/>├── api/ <br/>| ├── config <br/>| | ├── passport.js <br/>| | ├── jwtConfig.js<br/>| ├── server.js <br/>| ├── sequelize.js <br/>| ├── package.json<br/>| ├── models/ <br/>| | ├── user.js<br/>| ├── routes/ <br/>| | ├── deleteUser.js <br/>| | ├── findUsers.js <br/>| | ├── loginUser.js <br/>| | ├── registerUser.js<br/>| | ├── updateUser.js<br/>| ├── node-modules/</span></pre><p id="e9a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"/><code class="fe lp lq lr ls b"><strong class="ka ir">package.json</strong></code><strong class="ka ir">文件</strong></p><p id="9310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是<code class="fe lp lq lr ls b">package.json</code>和它的依赖项，所以你可以看到我到底在用什么。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/ca4c283161a83b88bea59e99e5983fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYBYS2t3idM94iJdXipLnQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">这里没有什么特别的东西:只有jsonwebtoken、passport、passport-local和passport-jwt。</figcaption></figure><p id="31b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖项包括一些额外的东西，如<code class="fe lp lq lr ls b">babel</code>，这样我可以在我的Node.js应用程序中使用ES6语法，<code class="fe lp lq lr ls b">bcrypt</code>用于密码哈希，<code class="fe lp lq lr ls b">sequelize</code>作为我的MySQL ORM，但你需要关注的是<code class="fe lp lq lr ls b">jsonwebtoken</code>、<code class="fe lp lq lr ls b">passport</code>、<code class="fe lp lq lr ls b">passport-local</code>和<code class="fe lp lq lr ls b">passport-jwt</code>。这些是这个博客的必需品。</p><p id="599a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"/><code class="fe lp lq lr ls b"><strong class="ka ir">server.js</strong></code><strong class="ka ir">文件</strong></p><p id="fcc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将首先从<code class="fe lp lq lr ls b">server.js</code>文件开始，因为它需要的解释最少。这个文件纯粹是为了启动服务器，初始化Passport在应用程序中的使用，以及设置路由和解析来自客户端的请求。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/f3670ff1783a8526421a3a836551902a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7eM5lUDe_Kj_V9morUVeQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">imports和consts中有一点ES6，但是您应该关注的是passport.initialize()和routes。</figcaption></figure><p id="ba52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很简单，对吧？太好了。继续前进。</p><p id="b705" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能也注意到了<code class="fe lp lq lr ls b">require('./config/passport');</code>，这是我下一步要讲的。JWT和护照的配置，在名为<code class="fe lp lq lr ls b">config</code>的文件夹里面。</p><p id="b57b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"/><code class="fe lp lq lr ls b"><strong class="ka ir">jwtConfig.js</strong></code><strong class="ka ir">文件</strong></p><p id="3f72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JWT配置非常简单，它是JWT编码和解码令牌所需的秘密。通常，这将作为一个环境变量存储在一个没有签入Github的文件中，但是为了展示这是如何工作的，我将它设置在这里。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/b1c799773edd2ef3523f1706d4497a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OI4PyET0eLINN6Bkg0qy_w.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">这是Config文件夹中的jwtConfig.js文件。</figcaption></figure><p id="c300" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"/><code class="fe lp lq lr ls b"><strong class="ka ir">passport.js</strong></code><strong class="ka ir">文件</strong></p><p id="428c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有Passport身份验证的真正设置来自于<code class="fe lp lq lr ls b">passport.js</code>文件。在这里。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/c5354664197cf67940f71bff118d931c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3Q76dUmGqO2imEYEKqrnQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">是的，所有这些都是passport.js文件的一部分。</figcaption></figure><p id="139a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道这需要理解很多代码。如果你想看护照的代码和带护照认证的路线，我在这里用代码创建了几个gist<a class="ae ly" href="https://gist.github.com/paigen11/c72c8c20da9cd440f45025a1b05e5e58" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="12cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将介绍这里发生的两种类型的Passport实现:passport-local用于<code class="fe lp lq lr ls b">register</code>和<code class="fe lp lq lr ls b">login</code>方法，passport-jwt用于<code class="fe lp lq lr ls b">jwt</code>方法。</p><p id="0725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Passport-local使用用户名和密码，passport-jwt使用jwt有效载荷来验证用户是否合法。</p><p id="4826" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我前面说过的，只使用Express.js的文档是相当好的，但是技巧在于将它与MySQL数据库和从前端React客户端传递的信息结合起来。</p><p id="ef59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦passport-local策略被传递了用户名和密码(在回调服务器之前，我验证这两个输入至少都被填充了)，我做的第一个检查是使用Sequelize，我的SQL ORM(类似于Mongoose for MongoDB)，以确定该用户名是否存在于数据库中。如果它返回<code class="fe lp lq lr ls b">null</code>，认证失败(数据库中没有匹配的用户)，通常情况下，会从服务器向客户端返回一个<code class="fe lp lq lr ls b">401 Unauthorized</code>，没有进一步的信息。</p><h2 id="2a66" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">Passport陷阱#1:错误处理中的信息</h2><p id="b98a" class="pw-post-body-paragraph jy jz iq ka b kb nv kd ke kf nw kh ki kj nx kl km kn ny kp kq kr nz kt ku kv ij bi translated">对我来说，这种类型的错误处理是Passport最令人沮丧的地方。缺乏信息让用户(或我自己)知道什么是超出<code class="fe lp lq lr ls b">401 Unathorized</code>的实际错误。</p><p id="9fc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是有一个更好的解决方案，需要一点额外的工作，用<strong class="ka ir">自定义回调</strong>。我将很快更详细地介绍回调，但是现在，你可以看看是否有某种错误，而不是返回一个<code class="fe lp lq lr ls b">return done(null, user);</code>，passport可以传递回<code class="fe lp lq lr ls b">return done(null, false, { message: 'bad username or passwords don't match' });</code>。然后这个消息可以从服务器传回到客户端，实际上告诉用户问题是什么(这是我对这个应用程序的期望)。如果您更喜欢告诉用户他们的身份验证失败了，但不透露原因，这也很酷。您的选择，但是我想展示错误消息是如何实现的。</p><p id="6bcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">passport-local策略的其余部分是不言自明的，在<code class="fe lp lq lr ls b">register</code>上，用户的密码用加密包<code class="fe lp lq lr ls b">bcrypt</code>散列和加盐，然后当<code class="fe lp lq lr ls b">login</code>方法被调用时，它散列新输入的密码并用bcrypt的<code class="fe lp lq lr ls b">compare</code>函数检查密码，然后返回肯定或否定的验证结果。</p><p id="27fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这让我想到了passport-jwt策略，它被命名为<code class="fe lp lq lr ls b">jwt</code>。这是在应用程序中受保护的路由上调用的认证:<code class="fe lp lq lr ls b">findUsers</code>、<code class="fe lp lq lr ls b">updateUser</code>、<code class="fe lp lq lr ls b">deleteUser</code>。对于jwt策略，每次调用服务器时，JWT都从客户端传递回来(我在一个带有密钥:<code class="fe lp lq lr ls b">JWT</code>的授权头中传递了我的请求)，提取这个密钥，然后使用秘密(存储在另一个文件中，但实际上应该是只有系统知道的环境变量)进行解码。</p><p id="823b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦JWT有效载荷被解密，就可以像passport-local策略一样在数据库中搜索ID(对我来说是用户名)，如果找到用户，则返回<code class="fe lp lq lr ls b">done(null, user);</code>，如果没有找到用户，则返回<code class="fe lp lq lr ls b">done(null, false);</code>(这几乎不会发生，因为JWT以加密形式包含用户名，所以除非用户名被篡改或数据库被篡改，否则它应该能够找到用户)。</p><h2 id="4401" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">护照陷阱#2:护照-当地想要返回，护照-JWT不要</h2><p id="ee3b" class="pw-post-body-paragraph jy jz iq ka b kb nv kd ke kf nw kh ki kj nx kl km kn ny kp kq kr nz kt ku kv ij bi translated">这让我想到了我的第二个问题，这个问题困扰了我很长时间；并非所有的passport策略都需要相同的分辨率。如果你仔细观察，你会发现passport-local策略都有<code class="fe lp lq lr ls b">return done(null, user);</code>，但是passport-jwt策略有<code class="fe lp lq lr ls b">done(null, user);</code>。看出区别了吗？这很小，但是有(或者去掉那个<code class="fe lp lq lr ls b">return</code>)就是用户数据从中间件传回服务器与否的区别。</p><p id="4560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它使我的进度停止了好几个小时，直到Stack Overflow的好心帮助我解决了这个问题(这是我第一次不得不这样要求一个我已经找不到的答案，但这是非常值得的)。所以要注意什么时候去<code class="fe lp lq lr ls b">return</code>或者不去。</p><p id="b30c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我已经介绍了我的程序中用于中间件认证的两种Passport策略和三种方法，现在继续介绍服务器上的认证。</p><p id="cedd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"/><code class="fe lp lq lr ls b"><strong class="ka ir">registerUser.js</strong></code><strong class="ka ir">文件</strong></p><p id="b8b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是如何在各种路由中实现这些新创造的方法。这里是<code class="fe lp lq lr ls b">registerUser</code>路线。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/ba8d1b3d821a42771a13989a25230b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-wqLmoF6GCZyx5crZX5zQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">注意这个路由的闭包风格调用——这使得从身份验证层到服务器和客户端的消息成为可能。</figcaption></figure><p id="9536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，passport的这个实现看起来与大多数例子有些不同，这是因为我使用的是定制回调版本的Passport，它需要一个闭包调用。我使用它是为了当Passport的认证失败时返回的错误消息可以从服务器发送到客户端，而不是晦涩的<code class="fe lp lq lr ls b">401 Unauthorized</code>。</p><p id="98c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这是作为回调实现的(这就是为什么你在这些脚本中看到<code class="fe lp lq lr ls b">(req, res, next)</code>不是一次，而是两次；它允许我从Passport中间件访问<code class="fe lp lq lr ls b">(err, user, info)</code>。<code class="fe lp lq lr ls b">info</code>是我感兴趣的——那是被发回的消息，所以如果信息是除了null之外的任何东西，那就意味着认证失败了，然后我可以把消息发送给客户端，让他们知道原因。</p><h2 id="bf86" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">Passport陷阱#3:在您的自定义回调中不要忘记“req.logIn()”</h2><p id="366c" class="pw-post-body-paragraph jy jz iq ka b kb nv kd ke kf nw kh ki kj nx kl km kn ny kp kq kr nz kt ku kv ij bi translated">现在，我到了第三个Passport gotcha，为了使闭包和定制回调与passport-local一起工作，如果从中间件成功返回数据，那么在处理<code class="fe lp lq lr ls b">user</code>数据之前，必须调用小方法<code class="fe lp lq lr ls b">req.logIn()</code>。</p><p id="9018" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在Passport文档中有记录，但是它的重要性并没有像我希望的那样被强调(在最初几次试图让自定义回调工作时，我错过了它)，这就是我现在强调它的原因。</p><p id="3083" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这必须发生，一旦完成，我就能够从客户端获取注册用户的额外输入，在passport-local <code class="fe lp lq lr ls b">register</code>调用期间找到在数据库中创建的同一个用户，并用额外信息更新用户文件。我也可以将这些额外的数据传递给中间件，但是我希望Passport只处理认证，而不处理用户创建。模块化，记住。</p><p id="8fa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，如果将身份验证拆分到一个单独的服务中，该服务具有一个单独的数据库，其中仅包含加密的用户名和密码，这样会更容易做到这一点，然后使用用户名或ID在该注册服务中查找并更新相应的用户记录。</p><p id="af11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦所有这些都被成功处理，一个200 HTTP状态和成功消息被发送回客户端。</p><p id="86b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lp lq lr ls b">loginUser.js</code>文件</p><p id="4c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在看到<code class="fe lp lq lr ls b">loginUser</code>路线应该更有意义。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/43bb4ef60e21962a04170f7a7a6294f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7utL18UTRZaiGvarkduxHg.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">登录路径的关闭方式相同。</figcaption></figure><p id="1bfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用了相同风格的自定义回调和闭包，最大的不同在于，一旦用户被成功验证并定位到数据库中，就使用<code class="fe lp lq lr ls b">jwt.sign();</code>函数生成JWT令牌，该函数将用户名设置为在JWT中传递的ID，并使用我之前设置的秘密进行加密。</p><p id="69dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，如果所有这些工作都成功，那么将发送一个200 HTTP状态，并为客户端设置一个名为<code class="fe lp lq lr ls b">auth</code>的布尔值I、新生成的令牌和一条简短的登录成功消息。</p><p id="81a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"/><code class="fe lp lq lr ls b"><strong class="ka ir">findUsers.js</strong></code><strong class="ka ir">文件</strong></p><p id="55f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，这是<code class="fe lp lq lr ls b">findUsers</code>路线。对于<code class="fe lp lq lr ls b">updateUser</code>和<code class="fe lp lq lr ls b">deleteUser</code>路线，我使用了相同的passport-jwt身份验证，所以我只展示这个作为例子。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/6222dacbc9da8aac6cc42e6bd35874ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKk1wRN5jefrgl5xxcs2nQ.png"/></div></div></figure><p id="b458" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对所有通过Passport验证的路由都使用了自定义回调(我喜欢良好、清晰的错误处理)，所以这种代码风格现在应该看起来很常规了。</p><p id="0e84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次，当调用<code class="fe lp lq lr ls b">passport.authenticate()</code>时，我实现了在<code class="fe lp lq lr ls b">passport.js</code>文件中定义的JWT策略。同样的<code class="fe lp lq lr ls b">(err, user, info)</code>从中间件返回，但是这次没有来自<code class="fe lp lq lr ls b">req.logIn()</code>的调用。相反，我只是返回在身份验证过程中找到的<code class="fe lp lq lr ls b">user</code>对象，并将所有必需的字段以及<code class="fe lp lq lr ls b">auth</code>布尔值和成功消息传递给客户端。JWT令牌仍然存储在客户端的本地存储中，因此不需要重新生成或再次传递给客户端。这让我想到了我的最后一张护照。</p><h2 id="39ae" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">Passport陷阱#4:正确传递授权头</h2><p id="9204" class="pw-post-body-paragraph jy jz iq ka b kb nv kd ke kf nw kh ki kj nx kl km kn ny kp kq kr nz kt ku kv ij bi translated">这并不完全是护照特有的问题，但这是另一件让我犯错误的事情。</p><p id="f600" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我所说的，我从一堆其他教程和文档中拼凑了我对JWT和护照的理解(现在更完整了)，其中一个教程把我引入了歧途。除了真正的授权头之外，它还让我将jwt传递回客户端，这是我选择让passport-jwt策略从客户端请求中提取JWT有效载荷的方式。出于这个原因，我想简单介绍一下前端代码的一部分，在那里我以正确的格式传回令牌，这样您就不必像我一样浪费时间调试了。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/17b6d385b63b668a2f45c7112eab5642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tjg-XaIFVhZEZCxEixNPRQ.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">客户端调用，在传回存储在用户本地存储中的JWT后加载用户数据。</figcaption></figure><p id="aa37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用流行的基于promise的HTTP客户端<a class="ae ly" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>进行服务器调用，但是你真正需要注意的是<code class="fe lp lq lr ls b">headers</code>部分。在调用服务器之前，我使用<code class="fe lp lq lr ls b">localStorage.getItem('JWT')</code>(当我从服务器端的<code class="fe lp lq lr ls b">loginUser()</code>路由转发令牌时，我用JWT值设置的密钥)从本地存储中提取JWT，然后我使用<code class="fe lp lq lr ls b">headers: { Authorization: `JWT ${accessString}` }</code>和一点ES6字符串插值来设置它。这样，如果我的授权头有不止一个值需要解析，passport-jwt仍然可以很容易地通过找到与“jwt”相关的字符串来提取正确的JWT有效载荷信息。</p><p id="8f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样，我只是想覆盖它，因为它阻止了我一段时间，只有通过失眠的API测试，我才能确认我的JWT令牌实际上在工作，并发现我从客户端错误地传递了授权头。</p><h2 id="1d6a" class="lz ma iq bd mb mc md dn me mf mg dp mh kj mi mj mk kn ml mm mn kr mo mp mq mr bi translated">结论</h2><p id="2b06" class="pw-post-body-paragraph jy jz iq ka b kb nv kd ke kf nw kh ki kj nx kl km kn ny kp kq kr nz kt ku kv ij bi translated">我知道我写了很多(并且提供了一堆代码片段和gists)，但是认证不是一个简单的概念。也不可能让一个应用程序变得如此安全，没有人能够破解它。但是如果你像JWT和Passport.js认证中间件一样采取预防措施，你的Node.js应用应该有更好的机会抵御怀有恶意的人。</p><p id="e358" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请务必留意我在Passport中强调的陷阱，这样您就可以访问更安全的网站。</p><p id="44cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想确保你不会错过我写的一篇文章，在这里注册我的时事通讯:<a class="ae ly" href="https://www.paigeniedringhaus.substack.com/" rel="noopener ugc nofollow" target="_blank">https://www.paigeniedringhaus.substack.com</a></p><p id="09f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读，我希望这证明是有帮助的，并让您更好地理解实现Passport身份验证和使用JSON web令牌。非常感谢鼓掌和分享！</p><p id="043f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢读这篇文章，你可能也会喜欢我的其他一些博客</p><ul class=""><li id="d6b9" class="od oe iq ka b kb kc kf kg kj of kn og kr oh kv oi oj ok ol bi translated"><a class="ae ly" href="https://medium.com/@paigen11/postman-vs-insomnia-comparing-the-api-testing-tools-4f12099275c1" rel="noopener">邮递员vs .失眠:比较API测试工具</a></li><li id="0216" class="od oe iq ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated"><a class="ae ly" href="https://medium.com/@paigen11/using-docker-docker-compose-to-improve-your-full-stack-application-development-1e41280748f4" rel="noopener">使用Docker &amp; Docker Compose改进您的全栈应用开发</a></li><li id="1b5a" class="od oe iq ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated"><a class="ae ly" href="https://medium.com/@paigen11/sequelize-the-orm-for-sql-databases-with-nodejs-daa7c6d5aca3" rel="noopener"> Sequelize:带有NodeJS的SQL数据库的ORM</a></li></ul></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="8702" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考资料和更多资源:</strong></p><ul class=""><li id="ce08" class="od oe iq ka b kb kc kf kg kj of kn og kr oh kv oi oj ok ol bi translated">passport . js:<a class="ae ly" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">http://www.passportjs.org/</a></li><li id="ec32" class="od oe iq ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated">JSON网络令牌:【https://jwt.io/ T2】</li><li id="0336" class="od oe iq ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated">带护照和JWT回购的MERN App:【https://github.com/paigen11/mysql-registration-passport T4】</li><li id="1644" class="od oe iq ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated">带路线的护照实现要点:<a class="ae ly" href="https://gist.github.com/paigen11/c72c8c20da9cd440f45025a1b05e5e58" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/paigen 11/c 72 c8 c 20 da 9 CD 440 f 45025 a1 b 05 e 5 e 58</a></li><li id="9dd0" class="od oe iq ka b kb om kf on kj oo kn op kr oq kv oi oj ok ol bi translated">阿希奥斯:<a class="ae ly" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/axios</a></li></ul></div></div>    
</body>
</html>