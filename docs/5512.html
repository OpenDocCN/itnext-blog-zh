<html>
<head>
<title>How to work with intervals in React hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React挂钩中使用音程</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-work-with-intervals-in-react-hooks-f29892d650f2?source=collection_archive---------0-----------------------#2021-03-21">https://itnext.io/how-to-work-with-intervals-in-react-hooks-f29892d650f2?source=collection_archive---------0-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b2cb35e64033ab57736f2bedda3ff558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ge75MNcYNUSpegnZssTIeA.jpeg"/></div></div></figure><p id="6b0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然大多数范例并不要求React开发人员了解太多关于底层发生的事情，但是使用区间会变得有点棘手。本文的目标是向您介绍在react中使用区间和状态的所有方法。</p><h2 id="e35e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用音程有什么复杂的？</h2><p id="8579" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">React中让区间变得有点棘手的是，传递给区间的回调函数将不可避免地关闭(<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">还记得闭包吗？</a>)覆盖组件的当前状态。您的间隔将看到“旧”的状态，而不是你想要的方式工作。这经常让新的React开发人员感到困惑。</p><p id="b84f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看一个计数器的简单实现，它使用<code class="fe lv lw lx ly b">setInterval</code>每秒递增一个数字:</p><p id="bfa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">此代码不起作用。</strong></p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="ccb2" class="kw kx iq ly b gy mh mi l mj mk">export default function App() {</span><span id="cd8c" class="kw kx iq ly b gy ml mi l mj mk">    const [count, setCount] = useState(0);</span><span id="f4cc" class="kw kx iq ly b gy ml mi l mj mk">    useEffect(() =&gt; {</span><span id="9c8a" class="kw kx iq ly b gy ml mi l mj mk">        setInterval(() =&gt; {</span><span id="2081" class="kw kx iq ly b gy ml mi l mj mk">        setCount(count + 1);</span><span id="2b2d" class="kw kx iq ly b gy ml mi l mj mk">        }, 1000)<br/>    }, []);</span><span id="749e" class="kw kx iq ly b gy ml mi l mj mk">    return (</span><span id="fe90" class="kw kx iq ly b gy ml mi l mj mk">        &lt;div className="App"&gt;</span><span id="37fa" class="kw kx iq ly b gy ml mi l mj mk">            &lt;h1&gt;The current count is:&lt;/h1&gt;</span><span id="e62e" class="kw kx iq ly b gy ml mi l mj mk">            &lt;h2&gt;{count}&lt;/h2&gt;</span><span id="a01c" class="kw kx iq ly b gy ml mi l mj mk">        &lt;/div&gt;</span><span id="4572" class="kw kx iq ly b gy ml mi l mj mk">    );</span><span id="fa59" class="kw kx iq ly b gy ml mi l mj mk">}</span></pre><p id="60a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要理解为什么这段代码不起作用，您必须理解React如何处理状态。丹·阿布拉莫夫写了一篇很棒的(也很长的)指南来解释这一点。简而言之，每个渲染只访问自己的状态。让我们仔细看看在组件的前两次呈现期间发生了什么，以理解为什么这段代码不起作用:</p><p id="d1d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">组件第一次渲染:</strong></p><ol class=""><li id="2d4c" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">计数变量被设置为0(初始状态)</li><li id="e679" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">组件渲染绘制完成后，React会执行<code class="fe lv lw lx ly b">useEffect</code>钩子。<code class="fe lv lw lx ly b">useEffect</code>挂钩将记录音程。注册的时间间隔可以访问计数(计数为0)变量。</li><li id="417e" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">1秒钟后将调用回调。它会叫<code class="fe lv lw lx ly b">setCount(0 + 1)</code>。这不会改变计数常数。相反，它将触发一个新的组件呈现，状态为<code class="fe lv lw lx ly b">count=1</code>(这是一个全新的变量和组件实例)。</li></ol><p id="fe64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">组件第二次渲染:</strong></p><ol class=""><li id="a65a" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">计数变量设置为1(由间隔触发)</li><li id="e2e6" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">组件被渲染，浏览器为<code class="fe lv lw lx ly b">count=1</code>绘制UI</li><li id="171d" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">该效果不会运行，因为空的依赖数组定义了钩子应该只在第一次渲染时运行</li><li id="0727" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">1秒钟后，回调(这段代码仍然存在于第一次渲染中)被再次调用，但是回调并没有神奇地移动到新的状态为<code class="fe lv lw lx ly b">count=1</code>的渲染中。相反，回调只访问定义它的作用域的<code class="fe lv lw lx ly b">count</code>值(React只是JavaScript，必须遵守所有的作用域规则)。回调还是会看到<code class="fe lv lw lx ly b">count=0</code>，会再次调用<code class="fe lv lw lx ly b">setCount(0 + 1)</code>。一个新的渲染将被触发，值为<code class="fe lv lw lx ly b">count=1</code>。</li></ol><blockquote class="na nb nc"><p id="d41f" class="jy jz nd ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">使用React时，拥有正确的心理模型非常重要。你应该把每一个渲染看作一个有自己变量的盒子。如果你渲染一个组件两次，你会得到两个盒子。代码绝对有可能永远不会离开第一个盒子，一直运行到时间结束(这里的间隔就是这样)。</p></blockquote><p id="3f32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">计数器的值永远不会超过</strong> <code class="fe lv lw lx ly b"><strong class="ka ir">count=1</strong></code> <strong class="ka ir">。间隔回调将存在于第一次渲染中，并且只在增加到</strong> <code class="fe lv lw lx ly b"><strong class="ka ir">setCount(0 + 1)</strong></code> <strong class="ka ir">之前看到过</strong> <code class="fe lv lw lx ly b"><strong class="ka ir">count=0</strong></code> <strong class="ka ir">。</strong></p><h1 id="75fb" class="nh kx iq bd ky ni nj nk lb nl nm nn le no np nq lh nr ns nt lk nu nv nw ln nx bi translated">解决国家问题</h1><p id="732f" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">意识到这一点后，你可能会发现自己不知道该如何处理这类问题。通常，这个问题可以通过四种方式解决。所有四个解决方案都有有效的用例。一般来说，我觉得方案4最有用，其次是方案3。</p><h2 id="8f47" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">解决方案1:描述状态变化</h2><p id="460b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">直接访问状态可能没有您想象的那么重要。<code class="fe lv lw lx ly b">setCount()</code>接受一个回调函数，您可以在其中访问当前(未来)状态。你可以简单地描述你希望如何修改它。</p><p id="10c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点</strong></p><ul class=""><li id="9aad" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv ny ms mt mu bi translated">仅适用于非常简单的用例</li></ul><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="a72b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">解决方案2:携带ref</h2><p id="764b" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">引用是一种摆脱状态封装的方法。您可以使用引用来访问未来状态。通过改变<code class="fe lv lw lx ly b">.current</code>你可以访问更新后的状态。下面是一个工作示例:</p><p id="3b47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点:</strong></p><ul class=""><li id="34d2" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv ny ms mt mu bi translated">你必须记住在每次渲染时更新引用，这样才能工作</li><li id="95d1" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv ny ms mt mu bi translated">不遵循React设计模式</li></ul><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="7408" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">解决方案3:在每次渲染时重建效果</h2><p id="d120" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">通过从<code class="fe lv lw lx ly b">useEffect</code>返回一个函数，你注册了一个清理函数。清理功能在效果运行后运行。第二次渲染后，react会清除第一次渲染的效果(以此类推……)。</p><p id="3513" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在清理功能的帮助下，您可以在每次渲染时拆除并重建间隔。虽然这听起来很复杂，但实际上这是解决这个问题最常见的方法。使用清理功能意味着坚持React设计模式，通常被认为是良好的实践。</p><p id="4ede" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点:</strong></p><ul class=""><li id="f078" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv ny ms mt mu bi translated">遵循React设计模式</li></ul><p id="d1e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点:</strong></p><ul class=""><li id="c6a9" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv ny ms mt mu bi translated">如果您的应用程序的多个部分调用<code class="fe lv lw lx ly b">setCount</code>，它们将各自重新开始间隔。</li></ul><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="76d2" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">解决方案4:使用<code class="fe lv lw lx ly b">dispatch</code>功能</h2><p id="1e8a" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">另一种欺骗自己摆脱React处理状态的方法是使用<code class="fe lv lw lx ly b">useReducer</code>钩子。调度函数的默认行为是访问组件的最新状态。调度将让您访问“未来”状态。</p><p id="2584" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">优点:</strong></p><ul class=""><li id="d835" class="mm mn iq ka b kb kc kf kg kj mo kn mp kr mq kv ny ms mt mu bi translated">非常灵活的解决方案</li><li id="36e0" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv ny ms mt mu bi translated">遵循React设计模式</li></ul><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="5f2d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论🤙🏽</h2><p id="7556" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我希望这篇文章能帮助你在React中使用间隔和超时时获得信心。如果这篇文章对你有帮助，请留下评论或鼓掌，让我知道。</p><p id="3d04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nd">如果你有兴趣增加你在所有社交渠道的有机接触，请查看</em><a class="ae lu" href="https://gosquad.cc" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nd">https://gosquad . cc</em></strong></a></p></div></div>    
</body>
</html>