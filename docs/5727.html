<html>
<head>
<title>Why and How of Kubernetes Ingress (and Networking)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes Ingress(和联网)的原因和方式</h1>
<blockquote>原文：<a href="https://itnext.io/why-and-how-of-kubernetes-ingress-and-networking-6cb308ca03d2?source=collection_archive---------3-----------------------#2021-05-11">https://itnext.io/why-and-how-of-kubernetes-ingress-and-networking-6cb308ca03d2?source=collection_archive---------3-----------------------#2021-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ebfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes上运行的服务无法在公共云或私有云上访问。这就是Kubernetes在设计时考虑服务安全性的方式。</p><p id="cdc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要安全地允许访问集群外的服务，需要对网络的设置方式以及推动网络选择的不同需求有所了解。</p><p id="0c2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先简要探讨一下Kubernetes集群在服务隔离、服务扩展和服务交付方面的期望。一旦高层次的需求被列出，理解不同的构造和抽象的意义就变得容易了。</p><p id="7b49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过对比在Kubernetes内部运行的服务之前使用入口运行L7策略(或代理)层的优势得出结论。</p><h1 id="ed92" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">了解Kubernetes网络方案</h1><p id="b5e0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">了解Kubernetes Ingress是运行微服务和安全访问这些服务的关键。这篇文章试图揭开Kubernetes网络是如何设置的。</p><p id="f025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在创建服务、创建不同的Kubernetes工件、满足不同需求所需的网络机器时会考虑网络。</p><p id="e5c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还描述了不同类型IP的重要性，如外部IP、节点IP、集群IP和Pod IP，并描述了流量如何通过其中的每一个。</p><p id="3216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从群集网络要求开始，我们有机会了解为什么要以这种方式设置网络。</p><h2 id="192b" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">集群网络要求</h2><p id="c519" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><strong class="jp ir">Kubernetes中的集群联网</strong>有几个<strong class="jp ir">要求</strong></p><ul class=""><li id="a3a9" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir">服务的安全性和隔离</strong></li><li id="cb77" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">pod的连接、联网和IP分配</strong></li><li id="c086" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">设置网络，从多个物理节点构建集群抽象</strong></li><li id="346e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">跨多个服务实例的流量负载平衡</strong></li><li id="94b5" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">控制对服务的外部访问</strong></li><li id="ce15" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">在公共云和私有云环境中使用Kubernetes networking。</strong></li></ul><p id="1ee4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解Kubernetes网络的这些不同方面，我们首先描述当一个服务在一个pod中创建，一直到在公共和私有云中访问该服务时会发生什么。</p><p id="9715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们强调了对Ingress的需求，以及它如何适应整个Kubernetes网络模型。</p><h2 id="479e" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">Kubernetes Pods中运行的服务的网络隔离</h2><p id="4d76" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">让我们考虑一个具有两个节点的简单Kubernetes集群</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mo"><img src="../Images/32477ba9b9cf159608398044e29afb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q4XSHySusenBDAYH.png"/></div></div></figure><p id="bb77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes编排容器或豆荚(这是一组容器)。<strong class="jp ir">当Kubernetes创建一个pod时，它在自己的隔离网络中运行(使用网络名称空间)。</strong></p><p id="80ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了在每个节点上创建的两个窗格。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/78188d96ddd17d19770bb4315763563b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G3xJnBkzCKjeMM6u.png"/></div></div></figure><p id="cf18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对服务来说意味着什么？服务在pod网络中的pod内运行。<strong class="jp ir">在此pod网络上分配的IP地址(用于服务)在pod外部不可访问。</strong></p><p id="d919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么你如何获得这项服务呢？</p><h2 id="10fa" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">使主机网络堆栈可以访问Pod中的服务</h2><p id="1e37" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Kubernetes在多个物理节点或机器上构建了一个集群的抽象。物理节点有自己的网络堆栈。Kubernetes创建的pod为在pod内部运行的服务创建了一个隔离的网络堆栈。</p><p id="7815" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了到达该服务(或pod内的IP地址)，需要在pod网络和主机网络之间创建路径的路由/桥接。<strong class="jp ir">容器网络接口或CNI设置与在节点和pod之间创建流量路径相关联的网络。CNI流行的例子有印花布、纤毛、法兰绒等。</strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nb"><img src="../Images/fb76b953ac940e376b3b76351db30fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jFteB2r2VI44unnK.png"/></div></div></figure><p id="2255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当Kubernetes创建一个pod时，它调用CNI回调。这些回调导致调用CNI提供商服务来为pod设置IP地址，并将pod网络与主机网络连接起来。</p><h2 id="2c67" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">使服务可以跨节点边界访问</h2><p id="4d97" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一个服务驻留在一个或多个pod中。这些单元中的每一个都可以驻留在一个或多个物理节点上。例如，假设一个服务分布在驻留在两个物理节点上的两个pod上。</p><p id="96a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当流量的目的地是这个服务(分布在两个节点的两个pod上)时，Kubernetes如何在它们之间负载平衡流量？</p><p id="8be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kubernetes使用集群IP的抽象。<strong class="jp ir">任何发往集群IP的流量都会在pod(服务在其中运行)之间实现负载平衡</strong>。</p><p id="ed51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了对pod中的服务实例进行负载平衡，网络被设置为到达这些pod中的服务。这些pod可能运行在集群的不同物理节点上。为服务连接集群IP确保了发送到集群IP的流量可以发送到运行该服务的所有pods不管pods在哪个物理节点上运行。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/def2b6c665787c0f4856a575464d2a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0v89lOAJGCbiG9GG.png"/></div></div></figure><p id="c218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集群IP的实施和实现是通过kube-proxy组件和类似iptables、ipv或用户空间流量导向的机制来实现的。</p><h2 id="6ea5" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">从集群外部访问服务</h2><p id="993f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">发往ClusterIP的流量在可能跨越多个物理节点的pod之间实现负载平衡。但是只能从集群中的节点访问ClusterIP。或者，换句话说，<strong class="jp ir">Kubernetes中的联网确保了对ClusterIP的外部访问受到限制。</strong></p><p id="67e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在集群外部访问ClusterIP需要一个显式声明，以便在Kubernetes集群的节点外部访问它。这是<code class="fe nd ne nf ng b">NodePort</code></p><p id="dba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Kubernetes中的一个</strong> <code class="fe nd ne nf ng b"><strong class="jp ir">NodePort</strong></code> <strong class="jp ir">用ClusterIP连接一个节点IP(和端口)。</strong></p><p id="4293" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义一个<code class="fe nd ne nf ng b">NodePort</code>在本地网络上提供一个IP地址。<strong class="jp ir">发送到此节点端口IP(和端口)的流量随后被路由到ClusterIP，并最终负载平衡到pod(和服务)。</strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/23c673c3b2ac4690266cbb6217ae1749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dZvPFWVZbF7JvDhI.png"/></div></div></figure><h2 id="4179" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">在公共云上访问Kubernetes中的服务</h2><p id="4eea" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">一个<code class="fe nd ne nf ng b">NodePort</code>使得一个服务可以在集群外部访问，但是IP地址只能在本地使用。<code class="fe nd ne nf ng b">LoadBalancer</code>服务是一种将公共IP(或DNS)与<code class="fe nd ne nf ng b">NodePort</code>服务相关联的方式。</p><p id="f27c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在Kubernetes集群中创建一个<code class="fe nd ne nf ng b">LoadBalancer</code>类型的服务时，它会分配一个公共IP并在云提供商(如AWS、GCP、OCI、Azure等)上设置负载平衡器。).<strong class="jp ir">云负载均衡器被配置为将发送到外部IP的流量输送到</strong> <code class="fe nd ne nf ng b"><strong class="jp ir">NodePort</strong></code> <strong class="jp ir">服务。</strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/61bb39a31c43043b376c4bc4db381ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3qA_f9RsWPNRR62F.png"/></div></div></figure><h2 id="cb05" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">在私有云上访问Kubernetes中的服务</h2><p id="12b5" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当在私有云中运行时，创建一个<code class="fe nd ne nf ng b">LoadBalancer</code>类型的服务需要一个Kubernetes控制器，它可以提供一个负载平衡器。一个这样的实现是<a class="ae nj" href="https://metallb.universe.tf/" rel="noopener ugc nofollow" target="_blank"> MetalLB </a>，它分配一个IP来路由集群内部的外部流量。</p><h1 id="6a6e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">通过或不通过入口访问公共云上的服务</h1><p id="d88d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">有几种方法可以访问公共云上Kubernetes集群中运行的服务。在公共云上，当服务类型为<code class="fe nd ne nf ng b">LoadBalancer</code>时，会为外部访问分配一个外部IP。</p><ul class=""><li id="277e" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir">一个服务可以直接声明为</strong> <code class="fe nd ne nf ng b"><strong class="jp ir">LoadBalancer</strong></code> <strong class="jp ir">类型。</strong></li><li id="3d20" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">或者，控制和配置代理的入口服务可以声明为类型</strong> <code class="fe nd ne nf ng b"><strong class="jp ir">LoadBalancer</strong></code> <strong class="jp ir">。然后可以在这个入口服务上创建路由和策略，将外部流量路由到目标服务。</strong></li></ul><p id="4b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像Envoy/Nginx/HAProxy这样的代理可以接收所有进入集群的外部流量，方法是将集群作为服务运行，并定义类型为<code class="fe nd ne nf ng b">LoadBalancer</code>的服务。这些代理可以使用L7路由和安全规则进行配置。这些规则的集合形成了入口规则。</p><h2 id="2234" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">无入口—通过使服务成为类型<code class="fe nd ne nf ng b">LoadBalancer</code>的服务来直接访问服务</h2><p id="fa8c" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated"><strong class="jp ir">当服务被声明为类型</strong> <code class="fe nd ne nf ng b"><strong class="jp ir">LoadBalancer</strong></code> <strong class="jp ir">时，它直接从外部负载平衡器接收流量。</strong>在下图中，服务<code class="fe nd ne nf ng b">helloenroute</code>被声明为类型<code class="fe nd ne nf ng b">LoadBalancer</code>。它直接从外部负载平衡器接收流量。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nk"><img src="../Images/df263fe709c13acd0129e1317f58f5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*An_qflLJQAJ64nGO.png"/></div></div></figure><h2 id="5070" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">使用入口——将服务放在一个代理之后，该代理可通过<code class="fe nd ne nf ng b">LoadBalancer</code>从外部访问</h2><p id="130f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">可以在服务之前放置一层L7代理，以应用L7路由和策略。为此，需要一个入口控制器。</p><p id="deda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">入口控制器是Kubernetes集群内部的一项服务，配置为类型</strong> <code class="fe nd ne nf ng b"><strong class="jp ir">LoadBalancer</strong></code> <strong class="jp ir">接收外部流量。入口控制器使用定义的L7路由规则和L7策略将流量路由到服务。</strong></p><p id="896b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的示例中，<code class="fe nd ne nf ng b">helloenroute</code>服务从路由入口控制器接收流量，该控制器从外部负载平衡器接收流量。</p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/aa6b527a1acba5a713bbd7c311a00c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RQLUM-qqdeWPbw5o.png"/></div></div></figure><h1 id="6b0c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用途中入口控制器代理的优势</h1><p id="e4dd" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">运行入口控制器并在入口实施策略有几个明显的优势。</p><ul class=""><li id="e613" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">Ingress提供了一种可移植的机制来在Kubernetes集群内部实施策略。在集群内部实施的策略更容易跨云移植。</li><li id="2317" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">多个代理可以使用Kubernetes服务伸缩进行水平伸缩。L7面料的弹性使其更易于操作和缩放</li><li id="c088" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">L7策略可以与服务一起托管在具有群集本机状态存储的群集中</li><li id="f6f4" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">让L7策略更接近服务简化了策略实施以及服务和API的故障排除。</li></ul><h2 id="4234" class="lo km iq bd kn lp lq dn kr lr ls dp kv jy lt lu kz kc lv lw ld kg lx ly lh lz bi translated">用于细粒度流量控制的插件</h2><p id="7d43" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">EnRoute使用Envoy作为底层代理来提供L7入口功能。EnRoute有一个模块化的架构，很好地反映了Envoy的可扩展模型。</p><p id="0517" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nj" href="https://getenroute.io/features/" rel="noopener ugc nofollow" target="_blank">插件/过滤器</a>可在路由级别或服务级别定义，以在入口实施L7策略。EnRoute在社区版中提供了一个高级限速插件，完全免费，没有任何限制。<a class="ae nj" href="https://getenroute.io/blog/why-every-api-needs-a-clock/" rel="noopener ugc nofollow" target="_blank">为您的API和微服务提供时钟</a>使用深L7状态是一项关键需求，路由灵活的速率限制功能提供了巨大的灵活性，可匹配各种速率限制用例。</p><p id="9164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae nj" href="https://getenroute.io/features/" rel="noopener ugc nofollow" target="_blank"> EnRoute Enterprise </a>包括支持和企业插件，有助于确保Kubernetes入口的流量安全。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="d83f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ns">最初发布于</em><a class="ae nj" href="https://getenroute.io/blog/ingress-controller-kubernetes-api-gateway-secure-service-jwt-oauth-oidc-network-namespace/" rel="noopener ugc nofollow" target="_blank"><em class="ns">https://geten route . io</em></a><em class="ns">。</em></p></div></div>    
</body>
</html>