<html>
<head>
<title>Unix Command Line Crash Course</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unix命令行速成班</h1>
<blockquote>原文：<a href="https://itnext.io/unix-command-line-crash-course-453e409d62f5?source=collection_archive---------2-----------------------#2022-07-06">https://itnext.io/unix-command-line-crash-course-453e409d62f5?source=collection_archive---------2-----------------------#2022-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ed9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Unix shell、命令和环境变量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc18a704faca1c7b55f3e602d8a3daac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VhHixy2DGtjP_MQMwWmFdA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用于在macOS上编写shell命令的Unix终端窗口</figcaption></figure><p id="d3c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di"> H </span>幸运的是，你之前已经见过命令行界面CLI。你可以在几乎所有系统上找到它们:Windows、Linux、macOS，甚至我的老Amiga都有一个CLI。它们的工作方式略有不同，但是有一个标准已经占据了主导地位，它基于Unix操作系统。Linux和macOS都源自Unix操作系统。当在Linux或Mac上与CLI交互时，您将使用几乎相同的Unix命令。过去几年，通过【Linux的Windows子系统(WSL) ，Unix命令行界面在Windows上也变得流行起来。</p><p id="6f2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您通过一个程序与Unix命令行交互，该程序通常称为终端或控制台。下面是一个在我的Mac上使用<a class="ae md" href="https://iterm2.com" rel="noopener ugc nofollow" target="_blank"> iTerm2 </a>的例子。在这个特殊的例子中，我发出命令来查看<code class="fe me mf mg mh b">Godot</code>目录的内容，在那里我存储了一些我开发的游戏。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mi"><img src="../Images/682a086a2ad75c4bc03b47cf737d91b0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0Sb812VrI2968XMkX3R9YA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用终端应用程序列出Godot目录的内容</figcaption></figure><p id="b57b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用图形文件管理器，如Finder，这个<code class="fe me mf mg mh b">Godot</code>目录应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mi"><img src="../Images/76ec5bd36f501aa3b6912f1329207f2d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Tgcv4pa6MSWohVCnZqokGQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Finder文件管理器显示Godot目录</figcaption></figure><p id="da15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么您应该学习如何使用Unix命令行界面？在文件管理器中点击不是更容易吗？事实上，图形用户界面更容易探索和学习。但是基于文本的界面有许多在图形用户界面中难以复制的优势:</p><ol class=""><li id="6763" class="mj mk it la b lb lc le lf lh ml ll mm lp mn lt mo mp mq mr bi translated">他们通常证明了更多的权力和灵活性。</li><li id="4cf9" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">复杂的图形界面比复杂的基于文本的界面更难学。</li><li id="c035" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">基于文本的界面自然有助于自动化，这可以节省大量时间。</li></ol><p id="6483" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二点需要一些理由。的确，图形用户界面更容易理解，但只是在一定程度上。大型复杂的图形应用程序可能很难学习。做什么不明显。找到正确的按钮点击或对话框打开可能需要一个视频或一系列的图像，仔细一步一步的指示。</p><p id="9d36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相比之下，在本文这样的文章中，基于文本的界面很容易解释。复杂的操作，你很容易忘记如何做，所以你可以很容易地复制到一个笔记本上，并写下解释。以后可以使用搜索工具轻松检索这些笔记。搜索图形用户界面的图像要困难得多。</p><p id="61c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将教你如何做以下事情:</p><ul class=""><li id="266e" class="mj mk it la b lb lc le lf lh ml ll mm lp mn lt mx mp mq mr bi translated">像使用图形文件管理器一样在文件系统中导航。</li><li id="00b4" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated">看看一个目录里有什么文件，过滤掉你不感兴趣的文件或目录。</li><li id="56e5" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated">对文件进行操作。</li><li id="2a76" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated">解释二分搜索法路径。终端使用它来定位您编写的命令。</li><li id="fb2e" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated">什么是环境变量，你能用它们做什么？</li></ul><h2 id="e31d" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">使用文件和目录</h2><p id="4e5f" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">当您启动Unix命令行时，您会得到某种问候。这取决于您的系统和配置。我的看起来像这样:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="2aab" class="my mz it mh b gy oa ob l oc od">Last login: Thu Jun 23 22:10:30 on ttys001<br/>Welcome to fish, the friendly interactive shell<br/>Type help for instructions on how to use fish<br/><br/>~<br/>❯</span></pre><p id="b39b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提示符旁边会有一个光标，表示CLI正在等待您键入命令并按enter键。行首的提示通常是符号<code class="fe me mf mg mh b">$</code>、<code class="fe me mf mg mh b">#</code>或<code class="fe me mf mg mh b">❯</code>中的一个。我的是<code class="fe me mf mg mh b">❯</code>，因为我用的是<a class="ae md" href="https://starship.rs" rel="noopener ugc nofollow" target="_blank">星舰提示</a>。它增加了几个很酷的功能，但你不必使用它。</p><p id="5b07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看最基本的命令<code class="fe me mf mg mh b">ls</code>、<code class="fe me mf mg mh b">cd</code>、<code class="fe me mf mg mh b">pwd</code>、<code class="fe me mf mg mh b">man</code>、<code class="fe me mf mg mh b">cat</code>、<code class="fe me mf mg mh b">touch</code>和<code class="fe me mf mg mh b">file</code>。</p><h2 id="8a50" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">ls-列出目录内容</h2><p id="a4d5" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">使用<code class="fe me mf mg mh b">ls</code>命令，您可以看到目录中有哪些文件和目录，就像使用文件管理器一样。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="ed10" class="my mz it mh b gy oa ob l oc od">❯ ls /bin<br/>[		expr		pwd<br/>bash		hostname	rm<br/>cat		kill		rmdir<br/>chmod		ksh		sh<br/>cp		launchctl	sleep<br/>csh		link		stty<br/>dash		ln		sync<br/>date		ls		tcsh<br/>dd		mkdir		test<br/>df		mv		unlink<br/>echo		pax		wait4path<br/>ed		ps		zsh<br/><br/>❯</span></pre><p id="48c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这显示了Unix系统上的<code class="fe me mf mg mh b">bin</code>目录的内容。这是Unix保存最常用命令的二进制文件的地方。我们称包含程序的文件为二进制文件。</p><p id="0e0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">命令比你的文件管理器更聪明。你可以做许多巧妙的把戏。像<code class="fe me mf mg mh b">*</code>和<code class="fe me mf mg mh b">?</code>这样的字符以一种特殊的方式被解释。它们形成了我们所说的球状模式。您可以使用glob模式来过滤显示哪些文件。<code class="fe me mf mg mh b">*</code>匹配任意数量的字母，而<code class="fe me mf mg mh b">?</code>匹配单个字母。因此<code class="fe me mf mg mh b">a?</code>将匹配名为<code class="fe me mf mg mh b">ab</code>、<code class="fe me mf mg mh b">ab</code>、<code class="fe me mf mg mh b">ad</code>、<code class="fe me mf mg mh b">ae</code>等的文件，而<code class="fe me mf mg mh b">*.txt</code>将匹配名为<code class="fe me mf mg mh b">foo.txt</code>、<code class="fe me mf mg mh b">bar.txt</code>、<code class="fe me mf mg mh b">baz,txt</code>等的文件。<code class="fe me mf mg mh b">foo</code>和<code class="fe me mf mg mh b">bar</code>的名字是怎么回事？那些只是我们在编程和Unix圈子里倾向于使用的愚蠢的名字。当你看到<code class="fe me mf mg mh b">foo</code>、<code class="fe me mf mg mh b">bar</code>、<code class="fe me mf mg mh b">qux</code>或<code class="fe me mf mg mh b">baz</code>时，你应该知道它们是占位符。使用的具体单词并不重要。什么都有可能。</p><h2 id="f2a1" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">cd —更改工作目录</h2><p id="f9ff" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">为了测试<code class="fe me mf mg mh b">ls</code>命令，我们将使用<code class="fe me mf mg mh b">cd</code>和<code class="fe me mf mg mh b">pwd</code>命令。就像图形终端一样，有一个当前工作目录。这是您的命令将应用更改的目录。您可以使用<code class="fe me mf mg mh b">cd</code>命令切换到工作目录。如果你忘记了你在哪里，你可以使用<code class="fe me mf mg mh b">pwd</code>命令。<code class="fe me mf mg mh b">pwd</code>是对打印工作目录的排序。</p><p id="c148" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们跳过一点，看看macOS系统上的一些目录(在Linux上类似)。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="7422" class="my mz it mh b gy oa ob l oc od">❯ cd /bin<br/><br/>❯ ls<br/>[         df        ln        sh<br/>bash      echo      ls        sleep<br/>cat       ed        mkdir     stty<br/>chmod     expr      mv        sync<br/>cp        hostname  pax       tcsh<br/>csh       kill      ps        test<br/>dash      ksh       pwd       unlink<br/>date      launchctl rm        wait4path<br/>dd        link      rmdir     zsh<br/><br/>❯ pwd<br/>/bin<br/><br/>❯ cd /System<br/>❯ ls<br/>Applications DriverKit    Volumes<br/>Developer    Library      iOSSupport<br/><br/>❯ pwd<br/>/System</span></pre><h2 id="ebe4" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">触摸和mkdir —创建文件和目录</h2><p id="240c" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">为了能够用<code class="fe me mf mg mh b">ls</code>做更多的实验，我们将创建自己的目录，并用伪造的文件填充它。我们将转到我们的主目录。如果你只写<code class="fe me mf mg mh b">cd</code>，你将跳转到你的用户的主目录。这里我们将制作一个名为<code class="fe me mf mg mh b">animals</code>的目录来实验<code class="fe me mf mg mh b">ls</code>。</p><p id="39c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从现在开始，我将在提示符上方显示我的当前目录，文件将以<code class="fe me mf mg mh b">*</code>结尾，而目录以<code class="fe me mf mg mh b">/</code>结尾。你可以通过写<code class="fe me mf mg mh b">ls -p</code>而不是仅仅写<code class="fe me mf mg mh b">ls</code>在你的系统上得到尾随斜线。这个<code class="fe me mf mg mh b">-p</code>叫做开关。每个Unix命令都带有几个开关，影响它们的运行方式。</p><p id="0df2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，让我们用<code class="fe me mf mg mh b">touch</code>命令创建一些虚拟文件。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="a345" class="my mz it mh b gy oa ob l oc od">~<br/>❯ mkdir animals<br/><br/>~<br/>❯ cd animals <br/><br/>~/animals<br/>❯ touch bird.png dog.jpg cat.jpg monkey.gif<br/><br/>~/animals<br/>❯ ls<br/>bird.png    dog.jpg<br/>cat.jpg     monkey.gif<br/><br/>~/animals<br/>❯ touch horse.png whale.png fox.gif</span></pre><p id="b633" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe me mf mg mh b">mkdir</code>命令创建一个给定名称的目录，而<code class="fe me mf mg mh b">touch</code>可以用来创建一个或多个空文件。对于这些文件，我们将看看如何使用glob pattern和<code class="fe me mf mg mh b">ls</code>来只显示当前目录中文件的子集。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="bcc5" class="my mz it mh b gy oa ob l oc od">~/animals<br/>❯ ls<br/>bird.png    fox.gif     whale.png<br/>cat.jpg     horse.png<br/>dog.jpg     monkey.gif</span></pre><p id="6190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你只想看到<code class="fe me mf mg mh b">animals</code>目录中的<code class="fe me mf mg mh b">.png</code>文件，你可以使用<code class="fe me mf mg mh b">*.png</code> glob模式，这意味着我们不关心文件名是什么，只要它以<code class="fe me mf mg mh b">.png</code>结尾</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="f260" class="my mz it mh b gy oa ob l oc od">❯ ls *.png<br/>bird.png   horse.png  whale.png<br/><br/>~/animals<br/>❯ ls *.gif<br/>fox.gif     monkey.gif</span></pre><p id="dee6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用与单个字母匹配的问号<code class="fe me mf mg mh b">?</code>找到中间带有<code class="fe me mf mg mh b">o</code>的所有三个字母文件名。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="746f" class="my mz it mh b gy oa ob l oc od">~/animals<br/>❯ ls ?o?.*<br/>dog.jpg  fox.gif</span></pre><h2 id="1382" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">man-Manual-获取帮助</h2><p id="aef1" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">一旦你掌握了Unix命令的基础知识，你就会希望能够看到具体的详细信息，而这些信息在博客文章中是没有意义的。我们可以使用<code class="fe me mf mg mh b">man</code>命令查看每个命令的手册。<code class="fe me mf mg mh b">man ls</code>将为我们提供<code class="fe me mf mg mh b">ls</code>(列表)命令的手册页。它会让你进入一个传呼机程序。很多初学者马上会问:我如何退出这个程序？！无论您是在<code class="fe me mf mg mh b">vim</code>程序、<code class="fe me mf mg mh b">less</code>还是<code class="fe me mf mg mh b">man</code>程序中，您都可以按<code class="fe me mf mg mh b">q</code>退出。在<code class="fe me mf mg mh b">vim</code>编辑器中，您可能需要先按<code class="fe me mf mg mh b">ESC</code>键，然后按冒号<code class="fe me mf mg mh b">:</code>，然后才能按<code class="fe me mf mg mh b">q</code>退出。</p><p id="054b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是对在<code class="fe me mf mg mh b">man</code>文档页面中导航最有用的命令的概述:</p><ul class=""><li id="9935" class="mj mk it la b lb lc le lf lh ml ll mm lp mn lt mx mp mq mr bi translated"><code class="fe me mf mg mh b">↑</code>和<code class="fe me mf mg mh b">↓</code>上下一行箭头键。</li><li id="3ccf" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated"><code class="fe me mf mg mh b">Ctrl-U</code>和<code class="fe me mf mg mh b">Ctrl-D</code>用于一次上下移动一整页。</li><li id="a609" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated"><code class="fe me mf mg mh b">/foobar</code>在手册页中搜索文本<code class="fe me mf mg mh b">foobar</code>。你只需写一个斜线<code class="fe me mf mg mh b">/</code>，然后输入你感兴趣的文本。(<code class="fe me mf mg mh b">foobar</code>是个无厘头的词)。</li><li id="5ed1" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mx mp mq mr bi translated"><code class="fe me mf mg mh b">q</code>退出手动页面查看。</li></ul><p id="6444" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看你能否找到<code class="fe me mf mg mh b">-l</code>开关的手动入口。它在长表单上打印关于目录内容的信息。可以通过写<code class="fe me mf mg mh b">/-l</code>来搜索。该条目应该如下所示:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="c15b" class="my mz it mh b gy oa ob l oc od">-l   (The lowercase letter “ell”.) List files in the long<br/>      format, as described in the The Long Format<br/>      subsection below.</span></pre><p id="3637" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以试试<code class="fe me mf mg mh b">-l</code>开关，看看我们如何获得更多信息:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="89c6" class="my mz it mh b gy oa ob l oc od">~/animals<br/>❯ ls -l<br/>total 0<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:11 bird.png<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:11 cat.jpg<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:11 dog.jpg<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:16 fox.gif<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:16 horse.png<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:11 monkey.gif<br/>-rw-r--r--  1 erikengheim  staff  0 Jun 24 14:16 whale.png</span></pre><p id="e2e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这显示了关于每个文件的一大堆信息。每列用于以下内容:</p><ol class=""><li id="401e" class="mj mk it la b lb lc le lf lh ml ll mm lp mn lt mo mp mq mr bi translated">是否可以读取<code class="fe me mf mg mh b">r</code>，写入<code class="fe me mf mg mh b">w</code>或执行<code class="fe me mf mg mh b">x</code>文件。用户、文件所属的组和其他所有人有一个三元组。</li><li id="fa5a" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">文件链接的数量。硬盘上不同位置的不同文件可能都指向同一个文件。</li><li id="27a9" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">文件的所有者，本例中为<code class="fe me mf mg mh b">erikengheim</code>。</li><li id="e4c4" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">文件所属的组。<code class="fe me mf mg mh b">staff</code>在这个例子中。</li><li id="e02e" class="mj mk it la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated">文件中的字节数。它是零，因为我们创建了空文件。</li></ol><p id="80ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一列是最后一次修改文件的时间，最后是文件名。</p><h2 id="1e49" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">cat-Concatenate-连接文件并显示内容</h2><p id="7caa" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">我们的文件是空的，所以为了能够测试用于显示内容的<code class="fe me mf mg mh b">cat</code>命令，我们必须实际编辑文件并添加一些内容。您可以使用任何文本编辑器将文本存储为UTF-8编码，也可以使用<code class="fe me mf mg mh b">echo</code>命令将文本添加到文件中。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="c6c3" class="my mz it mh b gy oa ob l oc od">~/animals<br/>❯ echo blue bird &gt; bird.png<br/><br/>~/animals<br/>❯ echo black cat &gt; cat.jpg<br/><br/>~/animals<br/>❯ echo red fox &gt; fox.gif</span></pre><p id="0038" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用<code class="fe me mf mg mh b">cat</code>查看单个文件的内容或连接多个文件的内容并显示出来。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="55a7" class="my mz it mh b gy oa ob l oc od">~/animals<br/>❯ cat bird.png cat.jpg<br/>blue bird<br/>black cat<br/><br/>~/animals<br/>❯ cat bird.png cat.jpg fox.gif<br/>blue bird<br/>black cat<br/>red fox</span></pre><h2 id="4935" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">回显—显示文本</h2><p id="00ac" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">在许多情况下，我们需要向用户显示一些文本。为此，我们可以使用<code class="fe me mf mg mh b">echo</code>:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="1b30" class="my mz it mh b gy oa ob l oc od">❯ echo Hello world<br/>Hello world</span></pre><p id="bcba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子可能看起来有点无意义，但是当编写更长的脚本做多件事，你想给用户反馈的时候，它是有意义的。你也可以用它来显示<em class="oe">环境变量</em>的内容。我们可以使用命名变量来存储文本，这些文本可以在以后显示:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="2fef" class="my mz it mh b gy oa ob l oc od">❯ NAME=Joe<br/>❯ echo hello $NAME<br/>hello Joe</span></pre><p id="6307" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么我们需要美元符号？因为如果你只写了<code class="fe me mf mg mh b">NAME</code>，系统将无法意识到你想要一个名为<code class="fe me mf mg mh b">NAME</code>的变量的内容。它会认为你想写文本<code class="fe me mf mg mh b">NAME</code>:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="0b17" class="my mz it mh b gy oa ob l oc od">❯ echo hello NAME<br/>hello NAME</span></pre><p id="686f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，虽然在设置环境变量时不需要美元符号<code class="fe me mf mg mh b">$</code>,但在使用它时会用到它。</p><h2 id="bd59" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">命令在二分搜索法路径中的位置</h2><p id="d1a8" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">大多数命令如<code class="fe me mf mg mh b">ls</code>、<code class="fe me mf mg mh b">cat</code>、<code class="fe me mf mg mh b">cp</code>、<code class="fe me mf mg mh b">rm</code>都是由操作系统加载并执行的实际小程序。当您键入一个命令时，操作系统将在不同的位置查找该命令。您可以使用<code class="fe me mf mg mh b">which</code>命令找到操作系统找到该命令的位置:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="53e7" class="my mz it mh b gy oa ob l oc od">❯ which ls<br/>/bin/ls<br/><br/>❯ which cat<br/>/bin/cat<br/><br/>❯ which vim<br/>/usr/bin/vim</span></pre><p id="ba4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe me mf mg mh b">vim</code>编辑器在<code class="fe me mf mg mh b">/usr/bin</code>目录中时，操作系统如何知道在<code class="fe me mf mg mh b">/bin</code>目录中查找<code class="fe me mf mg mh b">ls</code>和<code class="fe me mf mg mh b">cat</code>？这是使用二分搜索法路径完成的。它存储在名为<code class="fe me mf mg mh b">PATH</code>的环境变量中。我们可以使用<code class="fe me mf mg mh b">echo</code>命令查看二分搜索法路径的内容。</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="9075" class="my mz it mh b gy oa ob l oc od">❯ echo $PATH<br/>/usr/local/bin /usr/bin /bin /usr/sbin /sbin</span></pre><p id="f569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但也许我们在其他地方也有项目。我们如何让操作系统找到它们？假设在<code class="fe me mf mg mh b">/opt/bin</code>目录中有我们想要使用的二进制文件。每个搜索路径用冒号<code class="fe me mf mg mh b">:</code>分隔，当重新定义<code class="fe me mf mg mh b">PATH</code>变量时，我们可以简单地插入现有路径:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="78ab" class="my mz it mh b gy oa ob l oc od">❯ PATH=/opt/bin:$PATH</span></pre><p id="4432" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我们刚刚写的有一个问题。一旦你关闭终端窗口，路径将被遗忘。这就是为什么您需要将这一行添加到主目录中的<code class="fe me mf mg mh b">.profile</code>或<code class="fe me mf mg mh b">.zshrc</code>文件中。添加到哪个文件取决于您使用的是<code class="fe me mf mg mh b">bash</code>还是<code class="fe me mf mg mh b">zsh</code> shell。您还必须添加<code class="fe me mf mg mh b">export</code>关键字，否则环境变量在shell配置文件<code class="fe me mf mg mh b">.profile</code>或<code class="fe me mf mg mh b">.zshrc</code>之外是未知的。所以你写道:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="7902" class="my mz it mh b gy oa ob l oc od">export PATH=/opt/bin:$PATH</span></pre><p id="ef85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为路径可能包含空格，我们倾向于在文本字符串周围使用引号<code class="fe me mf mg mh b">"</code>来表明它是一个连续的文本块。因此我们通常写:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="fa55" class="my mz it mh b gy oa ob l oc od">export PATH="/opt/bin:$PATH"</span></pre><p id="cc13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们把<code class="fe me mf mg mh b">/opt/bin</code>放在第一位，但是如果我们把它写成这样呢？</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="48b7" class="my mz it mh b gy oa ob l oc od">export PATH="$PATH:/opt/bin"</span></pre><p id="e321" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是完全有效的，这意味着当寻找一个Unix命令时，在查找<code class="fe me mf mg mh b">/opt/bin</code>之前，系统将首先查找已经在<code class="fe me mf mg mh b">PATH</code> <em class="oe">中定义的路径之一。如果在多个位置有同名的命令，这可能很重要。例如，你的操作系统可能安装了<code class="fe me mf mg mh b">python</code>语言，但是你安装了自己的更新版本到<code class="fe me mf mg mh b">/opt/bin</code>。因为你希望默认使用你的新版本，你把<code class="fe me mf mg mh b">/opt/bin</code>目录放在第一位，所以它有优先权。</em></p><h2 id="11fb" class="my mz it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">环境变量</h2><p id="3f00" class="pw-post-body-paragraph ky kz it la b lb nr ju ld le ns jx lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">环境变量有许多用途。我们刚刚看到了用于指定二分搜索法路径的<code class="fe me mf mg mh b">PATH</code>环境变量。各种Unix工具都需要文本编辑器。例如，Git版本控制系统有时会打开一个编辑器来编辑提交消息。你的操作系统怎么知道打开哪个编辑器？您可以使用<code class="fe me mf mg mh b">EDITOR</code>环境变量来指定。尽管有时你想为不同的程序使用不同的编辑器。例如，我不想像使用Julia编程语言那样使用Git编辑器。幸运的是，Julia允许我在<code class="fe me mf mg mh b">JULIA_EDITOR</code>环境变量中指定一个编辑器，这个编辑器优先于<code class="fe me mf mg mh b">EDITOR</code>环境变量。让我展示给你看:</p><pre class="kj kk kl km gt nw mh nx ny aw nz bi"><span id="81a1" class="my mz it mh b gy oa ob l oc od">export EDITOR="mate -w"<br/>export JULIA_EDITOR=mate</span></pre><p id="6a0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于Git，我使用了<code class="fe me mf mg mh b">-w</code>开关，因为它会导致调用程序(Git)暂停，直到我关闭编辑器。这不是我在使用Julia时想要的行为。</p><p id="bc46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用的文本编辑器TextMate允许您在首选项面板中设置环境变量。可以看到<code class="fe me mf mg mh b">BOARD</code>、<code class="fe me mf mg mh b">SERIALDEV</code>、<code class="fe me mf mg mh b">TM_JULIA</code>等变量。这很有用，因为任何由TextMate启动的程序都可以访问这些环境变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl mi"><img src="../Images/434304a76b96e46ffe6d084a679e5b14.png" data-original-src="https://miro.medium.com/v2/format:webp/1*a4TMeRZkcLEM_rnR54x1RA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在TextMate编辑器中配置可由自定义插件读取的环境变量</figcaption></figure><p id="59fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">导出的环境变量由子<em class="oe">进程</em>继承。你什么意思？一个正在运行的程序被称为<em class="oe">进程</em>。流程有父子关系。终端窗口是一个进程，当运行一个命令如<code class="fe me mf mg mh b">ls</code>、<code class="fe me mf mg mh b">man</code>或<code class="fe me mf mg mh b">touch</code>时，你正在创建该窗口的一个子进程，或者更具体地说，是在窗口内运行的外壳进程。</p><p id="ce84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何正在运行的程序都可以启动子进程，并定义应该由子进程继承的环境变量。TextMate允许你编写shell脚本、Python、Ruby或Julia脚本来读取这些环境变量。</p><p id="b678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，环境变量的使用不仅限于文本模式的应用程序。您可以使用环境变量在任何程序之间传递数据。</p></div></div>    
</body>
</html>