<html>
<head>
<title>Docker Compose update on GitHub webhook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitHub webhook上的Docker撰写更新</h1>
<blockquote>原文：<a href="https://itnext.io/docker-compose-update-on-github-webhook-b212c9433a9b?source=collection_archive---------6-----------------------#2019-09-03">https://itnext.io/docker-compose-update-on-github-webhook-b212c9433a9b?source=collection_archive---------6-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/66c0a84ddf57b0f6d51707e40fd9796a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lcahX8pRIT-D-BDC.png"/></div></div></figure><p id="f14b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">去年我写了一篇博文，内容是关于<a class="ae kz" href="https://webhookrelay.com/blog/2018/07/17/auto-deploy-on-git-push" rel="noopener ugc nofollow" target="_blank">结合几个工具</a>在git push上自动化简单的NodeJS应用更新。许多用户通过用Ruby、Python或PHP编写本地web服务器来接收webhooks，然后进行异步处理，从而解决了类似的问题。我很高兴地宣布，我们最终决定将这一功能添加到<a class="ae kz" href="https://webhookrelay.com/v1/installation/cli" rel="noopener ugc nofollow" target="_blank">中继CLI </a>中。现在，要在接收到的公共webhook上执行bash脚本，您可以:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5b78" class="lj lk it lf b gy ll lm l ln lo">relay forward --bucket my-bucket-name --relayer exec --command bash update.sh</span></pre><p id="d714" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要在webhook上启动Python应用程序:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="1db1" class="lj lk it lf b gy ll lm l ln lo">relay forward --bucket my-bucket-name --relayer exec --command python my-app.py</span></pre><p id="e97c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这开启了一些有趣的可能性，可以创建管道，可以对几乎所有发出webhooks的东西做出反应。在本文中，我将向您展示如何构建GitOps风格的管道，使Docker Compose部署与托管在git存储库上的docker-compose.yaml保持同步。</p><p id="2484" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">先决条件</strong></p><ul class=""><li id="ebcd" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated">Docker &amp; <a class="ae kz" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"> Docker撰写</a></li><li id="4bfd" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><a class="ae kz" href="https://my.webhookrelay.com/login" rel="noopener ugc nofollow" target="_blank">配置了<a class="ae kz" href="https://webhookrelay.com/v1/installation/cli" rel="noopener ugc nofollow" target="_blank">中继CLI </a>的Webhook中继帐户</a></li><li id="1aeb" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><a class="ae kz" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> Github账户</a></li></ul><p id="47a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">包含我在本文中使用的脚本的存储库可以在这里找到:<a class="ae kz" href="https://github.com/webhookrelay/docker-compose-update-on-git-push" rel="noopener ugc nofollow" target="_blank">https://github . com/webhook relay/docker-compose-update-on-git-push</a>。</p><h1 id="378c" class="md lk it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">步骤1:通过Docker Compose部署容器</h1><p id="65aa" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">第一步是进行初始部署。我们将创建一个简单的dockerized Python应用程序，您可以在这里找到<a class="ae kz" href="https://github.com/webhookrelay/docker-compose-update-on-git-push" rel="noopener ugc nofollow" target="_blank">连接到Redis并部署它:</a></p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/0b3bce7f45fa441ccea140da141250c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r39fy1_LAStIFEbNrrwlmg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">docker-compose.yml</figcaption></figure><p id="7f96" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们只想更新git标签，而不只是任何推送，所以让我们配置一个webhook并分析有效负载。</p><p id="3fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现这一点，让我们首先创建一个具有内部输出的bucket:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/5a47cf08791a4dacf6f7e34a32f10da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2KrUN9LjzteD1WNNU-t5Vg.png"/></div></div></figure><p id="b722" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，稍后将使用bucket来订阅github请求，而destination只是一个强制参数，在本例中我们不必使用。</p><p id="21d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">抓取那个<a class="ae kz" href="https://my.webhookrelay.com/v1/webhooks/***" rel="noopener ugc nofollow" target="_blank">https://my.webhookrelay.com/v1/webhooks/***</a>的URL，并转到你的库的settings - &gt; webhooks部分。到达后，设置:</p><ul class=""><li id="8c41" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated">您唯一的<a class="ae kz" href="https://my.webhookrelay.com/v1/webhooks/***" rel="noopener ugc nofollow" target="_blank">https://my.webhookrelay.com/v1/webhooks/***</a>网址的有效负载网址</li><li id="1d02" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><em class="nl">应用程序/json </em>的内容类型</li><li id="788e" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">一个随机的秘密名称，为了这个例子，我的秘密将是' webhooksecret '</li><li id="dae9" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">点击<code class="fe nm nn no lf b">Let me select individual events.</code>并选择<em class="nl">释放</em>。</li></ul><p id="7023" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，转到您的存储库的发布页面(例如<a class="ae kz" href="https://github.com/webhookrelay/docker-compose-update-on-git-push/releases" rel="noopener ugc nofollow" target="_blank">https://github . com/webhook relay/docker-compose-update-on-git-push/releases</a>)并创建一个新的发布<code class="fe nm nn no lf b">1.0.0</code>。然后，如果你访问bucket details页面或者<a class="ae kz" href="https://my.webhookrelay.com/logs" rel="noopener ugc nofollow" target="_blank"> logs页面</a>——你应该会看到来自Github的webhook。打开它，让我们检查有效载荷。虽然很长，但我们应该能看到</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="0c67" class="lj lk it lf b gy ll lm l ln lo">"action": "released",</span></pre><p id="faf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在顶部。为了确保我们只对这些事件做出反应，请创建一个规则:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/97e94095111466bd3f8af8ec7726be12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*si99HpWEDRb_qljK.png"/></div></div></figure><p id="b968" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您标记另一个版本，您现在应该看到只有一个webhook是forwarder:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/70849c251b253bd921150dfda562cce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V0U-5u1zZ9h7kd7R.png"/></div></div></figure><p id="9db2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的更新脚本是:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5fac" class="lj lk it lf b gy ll lm l ln lo">#!/bin/bash<br/>git pull<br/>docker-compose up -d</span></pre><p id="455f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将获取最新的合成文件并更新容器。现在，让我们更新<code class="fe nm nn no lf b">relay.yml</code>文件中的配置(<a class="ae kz" href="https://my.webhookrelay.com/tokens" rel="noopener ugc nofollow" target="_blank">访问密钥&amp;秘密可以在这里生成</a>):</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8d7b" class="lj lk it lf b gy ll lm l ln lo">version: v1<br/>key: xxx     # your access key<br/>secret: xxx  # your access secret<br/>buckets:<br/>- docker-compose-update-on-git-push<br/>relayer:<br/>  type: exec<br/>  command: bash<br/>  commandArgs:<br/>  - /full/path/to/docker-compose-update-on-git-push/update.sh<br/>  timeout: 300</span></pre><p id="ce66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要启动中继，请运行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="23e8" class="lj lk it lf b gy ll lm l ln lo">relay run -c relay.yml</span></pre><p id="ba04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将通过您的终端运行它。对于生产用例，请使用<a class="ae kz" href="https://webhookrelay.com/v1/installation/background-service" rel="noopener ugc nofollow" target="_blank">后台服务模式</a>。它将确保守护程序在操作系统启动时启动。</p><h1 id="dcf4" class="md lk it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">让我们试一试</h1><p id="2aac" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">启动docker-撰写:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="6c80" class="lj lk it lf b gy ll lm l ln lo">docker-compose up -d</span></pre><p id="8f66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">检查容器:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c754" class="lj lk it lf b gy ll lm l ln lo">$ docker ps<br/>CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES<br/>26cd2219e18b        redis:alpine                    "docker-entrypoint.s…"   20 seconds ago      Up 3 seconds        6379/tcp                 docker-compose-update-on-git-push_redis_1<br/>63c8cd1ae7bb        karolisr/python-counter:0.1.0   "flask run"              20 seconds ago      Up 18 seconds       0.0.0.0:5000-&gt;5000/tcp   docker-compose-update-on-git-push_web_1</span></pre><p id="6bf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Docker ps向我们展示了我们当前运行的映像，它是0 . 1 . 0——到目前为止没有什么意外。</p><p id="9bc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是构建一个新的映像<code class="fe nm nn no lf b">0.2.0</code>并将其推送到注册表中。一旦它可用，我们可以更新我们的GitHub库<code class="fe nm nn no lf b">docker-compose.yml</code>并发布新版本。为了这个例子，让我们通过GitHub UI来实现。</p><p id="d9d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">几秒钟后，您应该会看到一个新的容器正在运行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="16a2" class="lj lk it lf b gy ll lm l ln lo">$ docker ps<br/>CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES<br/>27b2542423ec        karolisr/python-counter:0.2.0   "flask run"              9 seconds ago       Up 7 seconds        0.0.0.0:5000-&gt;5000/tcp   docker-compose-update-on-git-push_web_1<br/>26cd2219e18b        redis:alpine                    "docker-entrypoint.s…"   10 minutes ago      Up 9 minutes        6379/tcp                 docker-compose-update-on-git-push_redis_1</span></pre><p id="2c06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们看到我们的容器现在运行的是0.2.0版本，更新成功！</p><h1 id="1031" class="md lk it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">可选项:验证GitHub机密</h1><p id="8764" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">Webhook中继输出规则也可以验证GitHub签名:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1fd27ff8b1e342391bbd472dadd346a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3TsAVbTP7yvmfMSZ.png"/></div></div></figure><p id="0dcc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将确保只处理GitHub签名的webhooks。</p><h1 id="74d6" class="md lk it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">替代解决方案</h1><p id="fe66" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">我已经成功地使用了这些工具来更新容器:</p><ul class=""><li id="c56c" class="lp lq it kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated"><a class="ae kz" href="https://github.com/pyouroboros/ouroboros" rel="noopener ugc nofollow" target="_blank">https://github.com/pyouroboros/ouroboros</a></li><li id="ab12" class="lp lq it kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated"><a class="ae kz" href="https://github.com/containrrr/watchtower" rel="noopener ugc nofollow" target="_blank">https://github.com/containrrr/watchtower</a></li></ul><p id="f72b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你有一个简单的设置，只需要跟踪<code class="fe nm nn no lf b">latest</code>标签，这两个工具都可以工作。然而，如果您有多个带有semver(或任何其他版本控制机制)的容器，这些解决方案就不起作用了。这就是为什么有一个要么是有用的。将带有图像标签的env或docker-compose.yml config提交到git并同步到运行服务的主机。</p><h1 id="69cf" class="md lk it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">结论</h1><p id="1c61" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">与在您的机器上执行的任何代码一样，您在自动化任务时必须小心。Webhook Relay将为您提供单向的Webhook流入机器。您的脚本/应用程序在您的机器上，不能通过Webhook中继远程修改。结合经过身份验证的webhook端点(您可以在存储桶级别上配置它)或webhook有效负载校验和验证，您可以构建一个安全的更新机制。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="bab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nl">最初发表于</em><a class="ae kz" href="https://webhookrelay.com/blog/2019/09/02/docker-compose-update-on-github-webhooks/" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl">。</em></p></div></div>    
</body>
</html>