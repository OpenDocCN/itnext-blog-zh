<html>
<head>
<title>React Server Side Code Splitting Made.. Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React服务器端代码拆分已完成..又</h1>
<blockquote>原文：<a href="https://itnext.io/react-server-side-code-splitting-made-again-a61f8cbbd64b?source=collection_archive---------2-----------------------#2018-08-01">https://itnext.io/react-server-side-code-splitting-made-again-a61f8cbbd64b?source=collection_archive---------2-----------------------#2018-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="797f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React代码拆分在一年前就成为了一件事。从那时起，我们正在寻找新的方法来代码分割和推迟组件渲染。让我们暂停一下，试着理解为什么代码拆分如此重要。为此，我们必须回到未来。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/40e6fccbfe98147043a8379b42148f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fl89R-emhz-OLH9OZIQKUg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">回到未来</figcaption></figure><h1 id="f76f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单页应用程序。</h1><p id="cc3a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">SPAs——当今的圣牛，也是主要的代码分解主题。</p><p id="7283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您必须“拆分”它，因为SPA由兆字节的Java脚本组成，加载、解析、检测和执行将花费很长时间。<strong class="jp ir">而且你不需要全部。同时。</strong></p><p id="bd03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SPA，一个“单页应用程序”，并不是一个“单页”——从技术上来说，它是一个“T4”的单页，只供浏览器使用，而不是供你使用。“单页应用程序”实际上是“多页应用程序”。、或多视图、或多组件应用。没关系。二级“页面”确实存在，但在使用之前你并不需要它们，因此你可以推迟那些额外的页面，以及渲染所有内容所需的代码，但不是当前页面。<strong class="jp ir">可以进行代码拆分。你必须进行代码拆分。</strong></p><blockquote class="mf"><p id="76dd" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">代码拆分的主要原因JavaScript的数量。</p><p id="065e" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">这么多JavaScript。哦哇🐶</p></blockquote><p id="3b9d" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">通过推迟一些代码块的执行，您可以更早地获得第一批代码块。通过不加载你不需要<strong class="jp ir">加载的代码——你正在修改你的应用程序。让它更好地做事情，它应该<strong class="jp ir">现在</strong>做，而不是在未来的某个地方。使其使用起来更加舒适。</strong></p><blockquote class="mu mv mw"><p id="16b5" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">这里的“愉快”几乎就像<code class="fe na nb nc nd b"> loading indicators</code>—“通过展示一些<strong class="jp ir">微调器</strong>，而不是一个<strong class="jp ir">空白页</strong>，你让用户认为你的页面很快，并且很快就准备好了，只要他们得到一些<em class="iq">感知</em>信号”。</p></blockquote><h2 id="d729" class="ne lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">所以SPA？</h2><blockquote class="mu mv mw"><p id="3dc4" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">从客户的角度来看，SPA和老派网站有什么区别？</p></blockquote><ul class=""><li id="91f7" class="nq nr iq jp b jq jr ju jv jy ns kc nt kg nu kk nv nw nx ny bi translated">点击老派网站的链接，你会打开一个新的页面。打开新页面后，您必须再次加载所有数据。执行几十个脚本，从头开始运行一些东西，显示新的广告、横幅和跟踪器。</li><li id="a320" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">点击SPA中的链接会做同样的事情…更快，并带有一个花哨的过渡动画。</li></ul><p id="c33f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，依我拙见——水疗馆生来就是为了让“下一页”更快。只是为了去掉“下一页”的意思。为了让一切更ajaxy化，更流畅，执行我们通常在第一个页面视图中加载和执行的所有垃圾，只执行一次。</p><blockquote class="mf"><p id="4ac6" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">SPA背后的理念——让下一个“第二个”页面浏览速度更快。</p></blockquote><p id="55eb" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">但是，你知道，代码分割背后的想法是让<strong class="jp ir">的第一个视图更快</strong>，让<strong class="jp ir">的第二个视图更慢</strong>。我不确定，但是看起来代码分裂正在试图解决这个问题<strong class="jp ir">与SPA生来要解决的问题</strong>相反。</p><blockquote class="mf"><p id="fae8" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">这里很不对劲！</p><p id="762f" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">我们要回到未来了！</p></blockquote><figure class="of og oh oi oj kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/ba673b100349ed800e4c5830fd7ca6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UEFtZQLySnb3yHSGgDimQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">轰鸣·轰鸣！</figcaption></figure><h1 id="1310" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">服务器端渲染？</h1><p id="5215" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">SPA之前是什么？老平原服务器端渲染。简单的HTML。简单的CSS。温暖的阳光。绿草如茵。还有就是几滴JS。</p><p id="c049" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能回答几个愚蠢的问题吗？我来指导你:</p><ul class=""><li id="8210" class="nq nr iq jp b jq jr ju jv jy ns kc nt kg nu kk nv nw nx ny bi translated">问:在第一页加载后，客户看到的SSR和SPA“图片”是否相同？在HTML层面是一样的吗？</li><li id="7237" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">答:是的。两种解决方案看起来完全一样！</li><li id="a062" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">问:在“第二次”页面加载后，客户看到的SSR和SPA“图片”是否相同？在HTML层面是一样的吗？</li><li id="c243" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">答:是的。然而，他们看起来完全一样！</li></ul><blockquote class="mu mv mw"><p id="1743" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">现在，准备好主要的魔术，主要的问题</p></blockquote><ul class=""><li id="a95a" class="nq nr iq jp b jq jr ju jv jy ns kc nt kg nu kk nv nw nx ny bi translated">问:你需要下载多少JavaScript来渲染SPA页面？</li><li id="2795" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">答:一兆字节。轻轻松松！如今——也许更多。</li><li id="3169" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">问:为了渲染页面，你需要下载多少HTML？</li><li id="0389" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">答:一千字节。或者是关于。</li></ul><p id="e106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SSR可以为客户提供相同的体验，相同的结果，成本是爱人的100倍，速度快100倍，能够在任何设备上运行。老派网站证明，我奶奶的电脑可以打开。</p><p id="554a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应该很清楚——最好的体验可以通过SSR渲染实现，并且只有“然后”——SPA和代码分割。这种差异，尤其是对于前沿设备(和网络)来说，可能是巨大的！</p><p id="bf8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更重要的是，没有任何JS发送到客户端的SSR是有史以来最好的代码分割，只要所有的东西都留在服务器上，并且没有任何不重要的东西(只有HTML、CSS和图像是重要的)被发送到客户端。</p><blockquote class="mu mv mw"><p id="abf2" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">你可以使用任何你想要的库，无论大小，例如moment.js，并且仍然适合1kb的网络流量限制。你自由了！</p></blockquote><h1 id="30f4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用SSR进行代码拆分</h1><p id="d925" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">所以。你已经为你的站点实现了SSR，但是仍然需要把静态的，我想说是死的，HTML转换成动态的React应用。静态站点是死站点。所以你还是要发兆的JS，还是要运行，还是要代码拆分。</p><blockquote class="mf"><p id="7a0f" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">突然间——不像以前那么容易了。为什么？</p></blockquote><h2 id="33d2" class="ne lc iq bd ld nf ok dn lh nh ol dp ll jy om nk lp kc on nm lt kg oo no lx np bi translated">SSR友好代码拆分的复杂性</h2><p id="b80a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">SSR现在是如何工作的？简而言之——你在服务器上渲染一个页面，把它发送到客户端，加载所需的js，然后<code class="fe na nb nc nd b">hydrate</code> HTML，它就活了。答对了。</p><p id="89bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你调用<code class="fe na nb nc nd b">hydrate</code>的时候，所有的脚本都必须被加载，所以你必须知道在某种状态下渲染某个页面所需的所有程序块。这就是为什么你必须使用“代码分割库”——它们将帮助你跟踪所使用的代码块。这并不像听起来那么简单。</p><p id="fb3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现代的React代码拆分库，像<a class="ae op" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank"> React-loadable </a>、<a class="ae op" href="https://github.com/smooth-code/loadable-components" rel="noopener ugc nofollow" target="_blank"> loadable-components </a>或<a class="ae op" href="https://github.com/theKashey/react-imported-component" rel="noopener ugc nofollow" target="_blank"> react-imported-component </a>能够做到这一点。他们将使用不同的方法来收集和报告当前渲染调用所需的<em class="me">块</em>。但是！，即使它们的工作方式不同——结局总是一样——给<strong class="jp ir">的单一命令等待所有使用的块</strong>。</p><p id="544a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要真正呈现页面，用户已经可以看到由于SSR，你必须加载所有脚本，才能重新呈现这个页面了。能够呈现出和你已经看到的一模一样的画面。</p><blockquote class="mu mv mw"><p id="4105" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">所以——页面已经准备好了，但是您还在等待加载脚本。<strong class="jp ir">这是互动时间</strong>。最糟糕的一秒钟，你可以看到任何东西，但什么也做不了…</p></blockquote><p id="3bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们大多数人来说，以我为例，这里的主要词汇——<strong class="jp ir">加载所有脚本</strong>。如果你想更深入地研究这个问题，我还有一篇关于它的文章。</p><div class="oq or gp gr os ot"><a href="https://hackernoon.com/react-and-code-splitting-made-easy-f118befb5168" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">反应和代码分割变得容易</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">代码分割一直是个问题。从你添加大量不同的脚本标签的时候起，直到需要…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">hackernoon.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kv ot"/></div></div></a></div><p id="ed18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别忘了从JavaScript的角度挖掘问题:</p><div class="oq or gp gr os ot"><a href="https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">2018年JavaScript的成本</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">构建交互式网站可能需要向用户发送JavaScript。通常，太多了。你一直在…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph kv ot"/></div></div></a></div><p id="c45a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，今天，让我们来关注另一句话，没有人(真的！看起来像没有人)给了狗屎之前— <strong class="jp ir">用户已经可以看到由于SSR </strong>的网站。</p><p id="9d25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有人真的认为——这很糟糕。只要您将在服务器上“花费”更多时间，即使页面生成也会增加首字节时间或交互时间。看看这根线。然后，我会解释什么是错的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="06c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里出了什么问题？</p><ul class=""><li id="495c" class="nq nr iq jp b jq jr ju jv jy ns kc nt kg nu kk nv nw nx ny bi translated">花费在<code class="fe na nb nc nd b">renderToString</code>的1.5s秒。老式的php制作的网站通常不超过300毫秒就可以完全渲染。</li><li id="74bc" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">可能那不是<code class="fe na nb nc nd b">renderToString</code>，而是全脂<code class="fe na nb nc nd b">render</code>？不要用。</li><li id="847b" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">组件方法—在这里是错误的。组件方法产生了一个问题，你必须首先渲染所有的东西，然后才能得到你提供给react-helmet的关于页面标题的信息。</li><li id="e1e0" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">代码中的一个简单错误。</li></ul><p id="abfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">错误很简单——你不需要在<code class="fe na nb nc nd b">renderToString</code>之前<code class="fe na nb nc nd b">render</code>,你不需要将呈现的字符串注入更大的模板。你可以，也必须是“线性”的。你可以尽可能快地发送你页面的“顶行”,然后再发送其他内容。让客户端开始下载软件包。让客户看到标题之前，你完成渲染的一切。就像sui-components的SSR包一样。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl pk l"/></div></figure><p id="1e16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之。假设我们有服务器呈现的页面。这里的要点非常简单明了。很难否认——</p><h1 id="1caa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">页面已经呈现。</h1><p id="727b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这才是重点！每个人都应该等待所有脚本被加载，以便能够呈现页面，但它已经呈现了。已经到了。如果你可以重复使用它呢？</p><p id="3643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“重用”不是再水化重用它，而是重用它进行代码拆分！</p><p id="921d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我所说的想法非常简单</p><ul class=""><li id="2bbc" class="nq nr iq jp b jq jr ju jv jy ns kc nt kg nu kk nv nw nx ny bi translated">每个<code class="fe na nb nc nd b">AsyncComponent</code>，基本上都是一个<code class="fe na nb nc nd b">div</code>。其中包含“异步结果”。</li><li id="f62d" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">对于客户端，AsyncComponent在开始时为空，填充后“async”操作解决。它被装载了。</li><li id="f612" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">对于服务器端，AsyncComponent不为空，这就是为什么我们必须等待客户端的异步操作竞争来匹配结果HTML。</li><li id="254c" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">只要AsyncComponent不为空，它在从服务器发送的HTML中就不会为空，我们是否可以只保留用于包装组件的<code class="fe na nb nc nd b">div</code>的<code class="fe na nb nc nd b">innerHTML</code>，并在JS被加载时显示这个“记忆化”的值。</li><li id="55e3" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">不要显示“spinner”或空格，而是呈现实际内容，<code class="fe na nb nc nd b">AsyncComponent</code>将不得不替换<strong class="jp ir">完全相同的HTML，</strong>但是在将来，当chink加载时。但是，虽然未来不在这里—显示我们从<code class="fe na nb nc nd b">innerHTML</code>获得的内容。</li><li id="9668" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">在任何时刻，我们都在显示相同的内容。没有视觉变化。它像普通的代码分割一样工作，但是你不必等待所有的块都被加载到前面。</li></ul><p id="cb4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从某些角度来看，SSR友好的代码分割总是一件困难而脆弱的事情。并且总是以“全有或全无”的形式工作。使用我所说的方法，您不必先等待所有的块都被加载——您可以在接收时开始执行传入的块。或者甚至不执行javascript，只要内容已经呈现，就能够呈现应用程序某些部分，即使它以静态的、死的、非反应性的HTML代码的形式存在，对客户也是有用的。没有规则。你自由了。</p><h1 id="4bf4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应预渲染组件</h1><div class="oq or gp gr os ot"><a href="https://github.com/theKashey/react-prerendered-component" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">kashey/react-预渲染组件</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">反应-预渲染-组件-🤔前suspence时代的部分水合作用</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pm l pe pf pg pc ph kv ot"/></div></div></a></div><p id="4cd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说的是图书馆。预渲染组件。当内容不“实时”时，保留其内部的渲染内容，只有当您准备好开始渲染时，才开始渲染。这里唯一棘手的时刻——你正在控制<code class="fe na nb nc nd b">live</code>道具。正如我所说的——只有当用户<code class="fe na nb nc nd b">clicks</code>或<code class="fe na nb nc nd b">points</code>使用内容时，你才可以“上线”。这由你决定。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl pk l"/></div></figure><p id="7b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这与随机代码分割库不太兼容，而且长期以来他们通常不公开加载<code class="fe na nb nc nd b">promises</code>，而得到它的唯一方法——调用静态<code class="fe na nb nc nd b">preload</code>，你可能不应该在一些组件“挂载”之前调用。但是10行长的小型有状态组件应该可以完成这项工作。</p><h2 id="63b2" class="ne lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">它实际上是如何变魔术的？</h2><p id="c745" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这种模式的主要障碍是模式本身。在React中，您不能访问DOM节点，也不能从中读取信息，除非您呈现它。如果你渲染它，你会删除之前存在于那个节点中的所有信息。</p><blockquote class="mu mv mw"><p id="aada" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">PS:在这种情况下,“那个”信息“只存在于”React 16 <code class="fe na nb nc nd b">hydrate</code>调用，且只在第一次呈现时存在。</p></blockquote><p id="0c7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使之成为可能，我使用了由<a class="ae op" href="https://github.com/thearnica/react-uid" rel="noopener ugc nofollow" target="_blank"> react-uid </a>库提供的“位置id ”,它帮助我用众所周知的id创建<code class="fe na nb nc nd b">divs</code>,我可以在<strong class="jp ir">组件构造器</strong>中使用<code class="fe na nb nc nd b">querySelector</code>,并且在react控制innerHTML之前预取它。并最终抹去它。</p><p id="8979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多细节，一如既往，在另一篇文章。这并不像听起来那么简单。</p><div class="oq or gp gr os ot"><a href="https://medium.com/@antonkorzunov/unique-ids-and-where-to-find-them-14020ddbc964" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">唯一id以及在哪里可以找到它们</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">第一件事，你将在HTML开发者课堂上听到——</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium . com SSR代码拆分的结论</p></div></div><div class="pc l"><div class="pn l pe pf pg pc ph kv ot"/></div></div></a></div><h1 id="01c1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">SSR代码分割结论</h1><p id="3a90" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">你仍然必须使用SSR友好的代码分割库，只要能够并行加载使用过的块就更好了。这变成了一件不重要的、绝对可选的事情，没有深度嵌套代码分割的大多数应用程序可以停止使用任何神奇的工具来跟踪使用过的js。</p><blockquote class="mu mv mw"><p id="c3f0" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">但不是CSS。不要忘记CSS。</p></blockquote><p id="e59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">预加载组件给你更多的时间来加载东西，包括脚本和数据，然后才真正切换视图。</p><blockquote class="mf"><p id="0f2c" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">但它实际上并不是它的全部功能。</p></blockquote><h1 id="7657" class="lb lc iq bd ld le lf lg lh li lj lk ll lm po lo lp lq pp ls lt lu pq lw lx ly bi translated">反应双重定义问题</h1><p id="b437" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们回忆一下最初的问题——你必须加载JS来重新绘制已经绘制的信息。我把它叫做——<strong class="jp ir">反应双定义问题</strong>。</p><blockquote class="mu mv mw"><p id="c2fb" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">你必须重新定义已经定义好的东西。渲染渲染。绘制绘制。</p></blockquote><p id="dfd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是反应双重定义问题是…两个问题。这是双重双重问题。</p><blockquote class="mu mv mw"><p id="cff1" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">您必须加载渲染已经渲染的信息所需的所有数据。</p></blockquote><p id="6a35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要重新呈现页面，您必须加载所有正在使用的js，并加载所有正在使用的数据。JS可能比HTML“多”1000倍。数据……也好不到哪里去。我看到过这样的例子，水合标准化redux store比“从它”呈现的信息大100倍。</p><p id="604b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会说——SSR太糟糕了，只要你不得不重做、重新加载、重新运行任何东西。我不确定SSR是一件好事。请用火杀死它。</p><blockquote class="mf"><p id="f870" class="mg mh iq bd mi mj mk ml mm mn mo kk dk translated">你在服务器上做的任何东西都是无用的！扔掉它。</p></blockquote><p id="e016" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">这在今天很常见，死于SPA获取和<em class="me">消费</em>信息的方式，但在jQuery时代是反模式的。</p><p id="b57f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">jQuery不调用REST或GraphQL端点。jQuery只是从你留在HTML 中的<strong class="jp ir">数据属性中读取所有的东西。jQuery只是遍历DOM并从HTML中恢复数据。jQuery就是这么jQuery。我不能说它做了所有正确的事情，但有些事情是…他们是有用的，我仍然很高兴使用它们。每次我不得不重构10年前的网站——由于我们今天“不得不”使用的所有“架构”,它变得更大(更胖)和更慢。</strong></p><p id="62c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">10年前这还不是一回事。你们的父亲比我们聪明。</p><blockquote class="mu mv mw"><p id="e856" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">可能—如果您使用一些数据(状态)来呈现一些数据(HTML) —您能够从派生视图(HTML)中恢复源数据(状态)。或者至少部分恢复它。</p></blockquote><p id="790d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用自己呈现的页面作为状态的来源。只是把一些看不见的，但是很重要的数据片存储在看不见的属性或者标签里。</p><p id="af39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这实际上是一个边缘案例，但是我感兴趣的不仅仅是HTML，还有状态。合成并从服务器发送到客户端Redux存储相对容易(这是内置特性)，但是发送“内部组件状态”几乎是不可能的，只要<strong class="jp ir">没有地方可以存储它。那里<strong class="jp ir">没有地方</strong>。</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl pk l"/></div></figure><ul class=""><li id="a5e1" class="nq nr iq jp b jq jr ju jv jy ns kc nt kg nu kk nv nw nx ny bi translated">在第一个例子中，我们使用类似jQuery的方式，只是将信息扫描回状态。</li><li id="239a" class="nq nr iq jp b jq nz ju oa jy ob kc oc kg od kk nv nw nx ny bi translated">第二个例子有点像jQuery，实际上是将JSON存储在element旁边。</li></ul><p id="a344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两者都能够在服务器端渲染存储“内部组件状态”,并在客户端恢复它。一些你以前做不到的事。一些你以前能做的事。回到未来。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pr"><img src="../Images/976f80d7a2ca71bada6ce3235ad51ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*377reefXFC55luc37YQPPg.png"/></div></div></figure><p id="2dde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要像“我必须在结果HTML中存储一些不太有用的信息”那样考虑这个问题。当一个开发人员喝着冰沙玩着React时，另一个开发人员向他们的页面添加越来越多的微数据，使他们的页面更容易被发现、访问和理解。对于人类和机器人来说。</p><blockquote class="mu mv mw"><p id="12b3" class="jn jo me jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">如果你能够从源html中<strong class="jp ir">再水合信息</strong>——那么，也许GoogleBot也将能够。</p></blockquote><h1 id="1bc1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">但是这个东西和代码拆分没有关系！</h1><p id="c621" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">确实如此。React-prerendered-component不是关于代码拆分，而是关于<strong class="jp ir">代码拆分</strong>加上<strong class="jp ir"> React16水合物</strong>。请随意使用React。您可以随意选择使用任何代码拆分库或组件。现在——绝对免费，绝对任意。</p><p id="56b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反应-预呈现-组分是异步组分和水合物之间的一个“<strong class="jp ir">加</strong>”。不多不少。</p><h2 id="ea8e" class="ne lc iq bd ld nf ng dn lh nh ni dp ll jy nj nk lp kc nl nm lt kg nn no lx np bi translated">结束了</h2><p id="dbdf" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这还不是结束。这只是一个实验，没有生产用途。一个提议。尝试把一些石器时代的好东西带到反应世界。重新思考我们代码分割的方式。我们为什么要代码分割，为什么。</p><p id="2770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来，这是唯一一种可以很好地处理即将到来的React悬念流渲染的方法，只要不必“等待”。让我们看看。在未来。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pj pk l"/></div></figure><h1 id="c414" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">附言:如果我没有说服你</h1><p id="0880" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">还有另一篇文章，几乎是绝对相同的问题，但没有解决方案。网飞只是在服务器端保持反应，然后就收工了。</p><div class="oq or gp gr os ot"><a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">网飞网络性能案例研究</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">改善桌面Netflix.com的交互时间</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="ps l pe pf pg pc ph kv ot"/></div></div></a></div><p id="eb81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们有我所说的“双重定义问题”。index.html JSON的270kb 。这怎么可能！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pt"><img src="../Images/256546229c07a42c5ffaa2ced2a653be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPpW56EKt9LN4gsO0Kj5Cw.png"/></div></div></figure><p id="ee2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看他们的文章。然后——重读这一篇。</p></div></div>    
</body>
</html>