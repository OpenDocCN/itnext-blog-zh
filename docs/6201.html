<html>
<head>
<title>Getting into source generators in .Net</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">进入源代码生成器。网</h1>
<blockquote>原文：<a href="https://itnext.io/getting-into-source-generators-in-net-6bf6d4e9e346?source=collection_archive---------1-----------------------#2021-09-18">https://itnext.io/getting-into-source-generators-in-net-6bf6d4e9e346?source=collection_archive---------1-----------------------#2021-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/32768e415cda8fbd30883aac3e82efee.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*pacaGW8KSyzJ1Ga3Szv4OA.png"/></div></figure><div class=""/><p id="3345" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你曾经尝试过自己自动生成C#代码，你可能使用过T4文本模板，或者你创建了一个小的应用程序，它在后/预构建事件设置中运行，你也知道这有时有多复杂。</p><p id="1016" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好了，现在有一个新的孩子来做这项工作:罗斯林的源发电机！或许你已经听说过它们，但从未真正尝试过。我想给你一个简短的介绍和一些实际操作的例子，告诉你如何在你的项目中使用它们！</p><h1 id="99ce" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">为什么&amp;什么</h1><p id="b62c" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">到目前为止，我之前提到的现有选项只作用于纯文本模型。然而，有一个主要的区别:现有的解决方案大多是在编译前生成代码，或者在编译后生成代码，所以它们只能依赖于可用的元数据，并通过反射来处理它。</p><p id="f39b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，源生成器在编译周期内工作<strong class="jz jb">。这里有一个简单的概述:</strong></p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ly"><img src="../Images/0012059e753cac3c97bdf04f95340a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Agwh2KTLleGHZtpL.png"/></div></div></figure><p id="f06b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">源生成器实质上接收到了现有程序迄今为止的一个完整的语法树，并且可以完整地分析它。这可以深入到分析变量赋值，并基于此生成代码。</p><p id="bdbe" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">简而言之，源代码生成器可以在运行时做很多以前通过反射完成的工作。例如Asp.Net模型&amp;控制器绑定，或者依赖注入。阿迪框架可以从技术上分析你的代码，找出哪些绑定被解析，并提前生成代码，而不是在运行时使用反射来影响性能。听起来是不是很棒？</p><h1 id="cec8" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如何使用它</h1><p id="2281" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">到目前为止(2021年9月)，仍然有一些严格的，有时是未记录的要求，以使源发生器工作。以下是我用来让一切正常工作的设置:</p><p id="3271" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在引用端(希望使用生成代码的项目)，我们的。csproj需要包含以下设置:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mh"><img src="../Images/abd4ea928ab9f3856f71d8ff116c134d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2mMjGEVNJht7QHSou8m5A.png"/></div></div></figure><p id="5e79" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我们在接收端需要做的所有事情。注意，接收端也可以是. Net 5.0项目，没有任何问题。</p><p id="414f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在发电机上。csproj方面，我们还有一些设置要做:</p><ul class=""><li id="0e2e" class="mi mj ja jz b ka kb ke kf ki mk km ml kq mm ku mn mo mp mq bi translated">源发生器需要驻留在<strong class="jz jb">中。网标2.0项目</strong>。这仍然是一个很难的要求，如果你的代码库的其余部分已经存在，这可能会有点尴尬。Net 5.0。</li><li id="fbbf" class="mi mj ja jz b ka mr ke ms ki mt km mu kq mv ku mn mo mp mq bi translated">您的souce generator项目需要导入以下两个包:</li></ul><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mw"><img src="../Images/3e69c05ecc9eda72b4149789df303c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PDzwvnphzmCs5ESZyeY_w.png"/></div></div></figure><p id="1782" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们准备实现一个源生成器！</p><h1 id="cd6e" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">实现生成器</h1><p id="f7b7" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">源生成器是一个实现了<em class="mx"> ISourceGenerator </em>接口的类，标记有<em class="mx"> GeneratorAttribute </em>:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="3e2f" class="nd kw ja mz b gy ne nf l ng nh">[Generator]<br/>public class MyGenerator : ISourceGenerator<br/>{<br/>    public void Initialize(GeneratorInitializationContext context)<br/>    {<br/>    }</span><span id="0ad6" class="nd kw ja mz b gy ni nf l ng nh">    public void Execute(GeneratorExecutionContext context)<br/>    {<br/>    }<br/>}</span></pre><p id="b3af" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">生成器实现了来自<em class="mx"> ISourceGenerator </em>接口的两个方法。总结一下:</p><ul class=""><li id="d634" class="mi mj ja jz b ka kb ke kf ki mk km ml kq mm ku mn mo mp mq bi translated"><em class="mx">初始化</em>方法，用于在编译时分析语法树。对于简单的生成器来说，它应该只发出基于非上下文的代码，这也可以完全跳过。</li><li id="7c09" class="mi mj ja jz b ka mr ke ms ki mt km mu kq mv ku mn mo mp mq bi translated"><em class="mx">执行</em>方法，负责实际发出源代码。如前所述，这种方法会将源代码添加到编译周期中，并且与其他技术相比，不需要重新开始编译。</li></ul><p id="39cf" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">源生成器和基于反射的生成之间有很大的概念上的区别。虽然基于反射的代码将继续前进并探索基于CLR <em class="mx">类型</em>的元数据，但源代码生成器将在编译周期中实际访问程序的<em class="mx">语法树</em>。此时不会发出任何已编译的类型，所以反射在这里不起作用。当我试图理解这个概念的时候，我马上得出的最接近的联系是一个<em class="mx">表达式&lt; Func &lt;..&gt; &gt;。</em>表达式也代表了代码可以分析的表达式树，在概念层面上，这与语法树非常相似。</p><p id="7766" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，让我们继续实现一个生成器，它发出以下接口的简单实现:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="6b46" class="nd kw ja mz b gy ne nf l ng nh">public interface IAnimal<br/>{<br/>    void MakeNoise();<br/>    void MakeNoise(string withNoise);<br/>}</span></pre><p id="b8f7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，为了使它更有趣，我们将在调用项目提供的相同名称空间中生成它。下面是这段代码的样子:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="ad55" class="nd kw ja mz b gy ne nf l ng nh">[Generator]<br/>public class PlainGenerator : ISourceGenerator<br/>{<br/>     public void Initialize(GeneratorInitializationContext context)<br/>     {<br/>     }</span><span id="731a" class="nd kw ja mz b gy ni nf l ng nh">     public void Execute(GeneratorExecutionContext context)<br/>     {<br/>         var callingEntrypoint = context.Compilation.GetEntryPoint(context.CancellationToken);</span><span id="06c6" class="nd kw ja mz b gy ni nf l ng nh">         var sb = new StringBuilder();</span><span id="04dc" class="nd kw ja mz b gy ni nf l ng nh">         sb.Append(@$"<br/>using SourceGenerator.Console.Interfaces;</span><span id="375c" class="nd kw ja mz b gy ni nf l ng nh">namespace {$"{callingEntrypoint!.ContainingNamespace.ContainingNamespace.Name}.{callingEntrypoint!.ContainingNamespace.Name}"}<br/>{{<br/>public class CustomDuck : IAnimal<br/>{{<br/> public void MakeNoise()<br/> {{<br/>  System.Console.WriteLine(""Hello from custom duck"");<br/> }}</span><span id="0ca5" class="nd kw ja mz b gy ni nf l ng nh">public void MakeNoise(string withNoise)<br/> {{<br/>  System.Console.WriteLine($""Hello from custom duck with noise: {{withNoise}}"");<br/> }}<br/>}}<br/>}}<br/>  ");</span><span id="1e6b" class="nd kw ja mz b gy ni nf l ng nh">         context.AddSource("CustomDuck", SourceText.From(sb.ToString(), Encoding.UTF8));<br/> }<br/>}</span></pre><p id="61df" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大部分代码应该与常规代码生成器非常相似。我们使用一个stringbuilder并追加一个表示我们想要发出的代码的逐字字符串。</p><p id="f941" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，在这种情况下，我们也从编译上下文中获取调用入口点。<em class="mx">上下文。Compilation </em>属性允许我们访问当前的编译信息，入口点代表实际的入口点，就像我们程序中的Main()方法一样。我使用这个生成器的控制台应用程序驻留在<em class="mx"> SourceGenerator中。控制台</em>名称空间。带有包含名称空间的<em class="mx">。名字</em>我们可以抢到这个名字。然而，每个包含的名称空间只代表一层名称空间，所以为了接收整个名称空间，我们需要在这里经历两层。</p><p id="5783" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了发出文件，我们调用了<em class="mx">。AddSource() </em>方法。这个方法需要两个参数，第一个参数是发出的源的惟一标识符，第二个参数是实际的sorce文本，它来自我们的stringbuilder，在上面指定各自的编码。</p><p id="70c7" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果一切都设置正确，我们现在可以在Program.cs中使用<em class="mx"> CustomDuck </em>类型，就像它是一个常规类一样:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="4d08" class="nd kw ja mz b gy ne nf l ng nh">namespace SourceGenerator.Console<br/>{<br/>    public class Program<br/>    {<br/>        public static void Main(string[] args)<br/>        {<br/>            var customDuck = new CustomDuck();<br/>            customDuck.MakeNoise();<br/>            customDuck.MakeNoise("Additional noise");<br/>        }<br/>    }<br/>}</span><span id="3836" class="nd kw ja mz b gy ni nf l ng nh">// Output:<br/>Hello from custom duck<br/>Hello from custom duck with noise: Additional noise</span></pre><p id="895e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太棒了，成功了！因为我们在名称空间<em class="mx"> SourceGenerator中。控制台</em>并且不需要为<em class="mx"> CustomDuck </em>指定任何其他东西，我们知道我们所做的命名空间工作也是可行的！</p><h1 id="fadd" class="kv kw ja bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">更复杂的发电机</h1><p id="3b15" class="pw-post-body-paragraph jx jy ja jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">既然我们现在已经用一个简单的发电机预热了，让我们来处理一些不同的东西。</p><p id="705b" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在想要实现一个生成器，它自动生成一个装饰器，当调用在接口上有一个特定的属性时，该装饰器测量并记录调用各个接口实现者所用的时间。</p><p id="4417" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是我们的设置:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="6314" class="nd kw ja mz b gy ne nf l ng nh">public class GenerateDecoratorAttribute : Attribute<br/>{<br/>}</span><span id="f228" class="nd kw ja mz b gy ni nf l ng nh">[GenerateDecorator]<br/>public interface IAnimal<br/>{<br/>    void MakeNoise();<br/>    void MakeNoise(string withNoise);<br/>}</span><span id="1259" class="nd kw ja mz b gy ni nf l ng nh">[GenerateDecorator]<br/>public interface ICar<br/>{<br/>    void Drive();<br/>}</span></pre><p id="d043" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们看看发电机:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="e7e2" class="nd kw ja mz b gy ne nf l ng nh">[Generator]<br/>public class DuckGenerator : ISourceGenerator<br/>{<br/>    internal class SyntaxReceiver : ISyntaxReceiver<br/>    {<br/>        public List&lt;InterfaceDeclarationSyntax&gt; DecoratorRequestingInterfaces { get; } =<br/>       new List&lt;InterfaceDeclarationSyntax&gt;();<br/>   <br/>        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)<br/>        {<br/>            // Get all interfaces with any attributes<br/>            if (!(syntaxNode is InterfaceDeclarationSyntax ids) || !ids.AttributeLists.Any())<br/>            {<br/>                return;<br/>            }</span><span id="c496" class="nd kw ja mz b gy ni nf l ng nh">            var requiresGeneration = ids.AttributeLists<br/>                .Select(x =&gt; x.Attributes)<br/>                .SelectMany(x =&gt; x)<br/>                .Select(x =&gt; x.Name)<br/>                .OfType&lt;IdentifierNameSyntax&gt;()<br/>                .Any(x =&gt; x.Identifier.ValueText ==           "GenerateDecorator");<br/>    <br/>           if (requiresGeneration)<br/>           {<br/>               DecoratorRequestingInterfaces.Add(ids);<br/>          }<br/>      }<br/>  }</span><span id="39e9" class="nd kw ja mz b gy ni nf l ng nh">    public void Initialize(GeneratorInitializationContext context)<br/>    {<br/>       context.RegisterForSyntaxNotifications(() =&gt; new SyntaxReceiver());<br/>    }<br/>    <br/>    ...<br/>}</span></pre><p id="438e" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">首先，我们将看到Initialize方法，这次我们使用它来分析现有的代码。标准的方法是注册一个<em class="mx">isyntaxereceiver</em>，它接收相应的<em class="mx"> SyntaxNode </em>进行分析。</p><p id="6b99" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们的实现中，我们希望找到作为接口的所有语法节点，并将我们需要的属性添加到它们的声明中。我们将保存在公共列表中找到的节点。作为Roslyn和Analyzers的新手，要弄清楚有哪些节点类型并不容易，也没有很好的文档记录。通常节点被类型化为一个接口，它可以有多个实现，并且整个分析过程可能需要大量的类型检查。类型列表可以在<a class="ae nj" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntax?view=roslyn-dotnet-3.11.0" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/API/Microsoft . code analysis . cs harp . syntax？view=roslyn-dotnet-3.11.0 </a>。我主要是通过阅读roslyn源代码、找出接口的具体实现以及调试生成器来找到自己的路。</p><p id="b8c0" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了调试生成器，我们可以添加一个<strong class="jz jb"> <em class="mx">调试器。Launch() </em> </strong>在<em class="mx">内任意位置初始化</em>或<em class="mx">执行</em>方法，编译时VS会提示我们在csc.exe进程上附加一个调试器。</p><p id="c8f3" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">转到执行方法:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="356d" class="nd kw ja mz b gy ne nf l ng nh">public void Execute(GeneratorExecutionContext context)<br/>{<br/>    // Get our SyntaxReceiver back<br/>    if (!(context.SyntaxReceiver is SyntaxReceiver receiver))<br/>    {<br/>        throw new ArgumentException("Received invalid receiver in Execute step");<br/>    }</span><span id="3fc5" class="nd kw ja mz b gy ni nf l ng nh">    foreach (var ids in receiver.DecoratorRequestingInterfaces)<br/>    {<br/>        var methods = ids.DescendantNodes().OfType&lt;MethodDeclarationSyntax&gt;();</span><span id="31d1" class="nd kw ja mz b gy ni nf l ng nh">        var sourceBuilder = new StringBuilder();</span><span id="11dd" class="nd kw ja mz b gy ni nf l ng nh">        var interfaceName = ids.Identifier.ValueText;<br/>        var className = $"Decorated{ids.Identifier.ValueText.Substring(1)}";<br/>    <br/>        sourceBuilder.Append("using System.Diagnostics;\n");<br/>        sourceBuilder.Append("using SourceGenerator.Console.Interfaces;\n");<br/>        sourceBuilder.Append("\n");<br/>        sourceBuilder.Append("namespace SourceGenerator.Console.Decorators\n");<br/>        sourceBuilder.Append("{\n");<br/>        sourceBuilder.Append($"\tpublic class {className} : {interfaceName}\n");<br/>        sourceBuilder.Append("\t{\n");<br/>        sourceBuilder.Append($"\t\tprivate {interfaceName} _decorated;\n");<br/>        sourceBuilder.Append("\n");<br/>        sourceBuilder.Append($"\t\tpublic {className}({interfaceName} decorated)\n");<br/>        sourceBuilder.Append("\t\t{\n");<br/>        sourceBuilder.Append("\t\t\t_decorated = decorated;\n");<br/>        sourceBuilder.Append("\t\t}\n");<br/>        sourceBuilder.Append("\n");</span><span id="96e8" class="nd kw ja mz b gy ni nf l ng nh">            foreach (var method in methods)<br/>            {<br/>                var methodName = method.Identifier.Text;</span><span id="a87a" class="nd kw ja mz b gy ni nf l ng nh">                sourceBuilder.Append($"\t\tpublic {((PredefinedTypeSyntax) method.ReturnType).Keyword.Text} {methodName}(");</span><span id="ba6e" class="nd kw ja mz b gy ni nf l ng nh">                var parameterIdentifiers = new List&lt;string&gt;();</span><span id="b723" class="nd kw ja mz b gy ni nf l ng nh">                for (var i = 0; i &lt; method.ParameterList.Parameters.Count; i++)<br/>                {<br/>                    var parameter = method.ParameterList.Parameters[i];<br/>                    if (!(parameter.Type is PredefinedTypeSyntax typeSyntax))<br/>                    {<br/>                        return;<br/>                    }</span><span id="1466" class="nd kw ja mz b gy ni nf l ng nh">                    var type = typeSyntax.Keyword.Text;<br/>                    var name = parameter.Identifier.ValueText;</span><span id="af0a" class="nd kw ja mz b gy ni nf l ng nh">                    sourceBuilder.Append($"{type} {name}");</span><span id="4983" class="nd kw ja mz b gy ni nf l ng nh">                    parameterIdentifiers.Add(name);</span><span id="9438" class="nd kw ja mz b gy ni nf l ng nh">                    if (i != method.ParameterList.Parameters.Count - 1)<br/>                    {<br/>                        sourceBuilder.Append(",");<br/>                    }<br/>               }<br/>              sourceBuilder.Append(")\n");<br/>              sourceBuilder.Append("\t\t{\n");</span><span id="e09e" class="nd kw ja mz b gy ni nf l ng nh">              sourceBuilder.Append("\t\t\tvar sw = Stopwatch.StartNew();\n");<br/>              sourceBuilder.Append($"\t\t\t_decorated.{methodName}({string.Join(",", parameterIdentifiers)});\n");<br/>              sourceBuilder.Append("\t\t\tsw.Stop();\n");<br/>                      sourceBuilder.Append("\t\t\tSystem.Console.WriteLine($\"Elapsed time: {sw.Elapsed}\");\n");<br/>              sourceBuilder.Append("\t\t}\n");<br/>              sourceBuilder.Append("\n");<br/>          }</span><span id="d161" class="nd kw ja mz b gy ni nf l ng nh">          sourceBuilder.Append("\t}\n");<br/>          sourceBuilder.Append("}");</span><span id="9604" class="nd kw ja mz b gy ni nf l ng nh">          context.AddSource(ids.Identifier.ValueText, SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));<br/>    }<br/>}</span></pre><p id="4c68" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在第一行中，我们可以获取我们在<em class="mx">初始化</em>步骤中构建的<em class="mx">isyntaxereceiver</em>，它是同一个实例，因此保存了我们之前编译的接口节点列表。现在我们可以采取行动了。代码应该是不言自明的。我们用来自接口的相应元数据构建常规类，然后添加我们需要实现的方法。</p><p id="a060" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为我们想要构建一个装饰器，所以我们实现了相应的接口，并接收了它的一个对象作为构造函数参数。</p><p id="3275" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的每个方法都添加了一个秒表，用方法的参数调用底层对象的方法，然后记录经过的时间。</p><p id="af9f" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于源代码，请在<a class="ae nj" href="https://github.com/Sossenbinder/SourceGeneratorDemo" rel="noopener ugc nofollow" target="_blank">https://github.com/Sossenbinder/SourceGeneratorDemo</a>按照您自己的速度随意探索。正如我已经提到的，进入找出正确节点类型的最佳状态确实需要一些时间。获取调试器，并探索编译上下文。</p><p id="e616" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">生成装饰器后，让我们测试一下代码。回到我们的Program.cs，我们现在可以使用装饰器:</p><pre class="lz ma mb mc gt my mz na nb aw nc bi"><span id="2ecc" class="nd kw ja mz b gy ne nf l ng nh">System.Console.WriteLine("Running application");<br/>System.Console.WriteLine("---");</span><span id="dc2d" class="nd kw ja mz b gy ni nf l ng nh">IAnimal duck = new Duck();</span><span id="44d9" class="nd kw ja mz b gy ni nf l ng nh">System.Console.WriteLine("Regular duck:");<br/>duck.MakeNoise();<br/>duck.MakeNoise("additional noise");</span><span id="e6ce" class="nd kw ja mz b gy ni nf l ng nh">System.Console.WriteLine("Decorated duck:");<br/>duck = new DecoratedAnimal(duck);<br/>duck.MakeNoise();<br/>duck.MakeNoise("additional noise");</span><span id="f5a8" class="nd kw ja mz b gy ni nf l ng nh">ICar car = new Toyota();<br/>System.Console.WriteLine("Regular car:");<br/>car.Drive();<br/>System.Console.WriteLine("Decorated car:");<br/>car = new DecoratedCar(car);<br/>car.Drive();</span><span id="a614" class="nd kw ja mz b gy ni nf l ng nh">// Output:<br/>Running application<br/>---<br/>Regular duck:<br/>Quack<br/>Quack with additional noise<br/>Decorated duck:<br/>Quack<br/>Elapsed time: 00:00:00.0295439<br/>Quack with additional noise<br/>Elapsed time: 00:00:00.0612864<br/>Regular car:<br/>Driving<br/>Decorated car:<br/>Driving<br/>Elapsed time: 00:00:00.1066615</span></pre><p id="b174" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">太好了！我们生成的装饰器正在工作。我们需要做的只是用自定义属性标记我们想要装饰的各个接口。</p><p id="52c4" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，底线是，源代码生成器是语言的一个很好的补充。很高兴看到对代码生成的一些一流支持，这些支持被允许与编译周期挂钩。然而，到目前为止，文档并不是很好。特别是我给出的更复杂的例子，为了理解整个流程以及如何使用语法树，需要花费相当多的时间来研究，这绝对是一个不同于我以前使用的基于反射的生成器的模型。</p><p id="5a40" class="pw-post-body-paragraph jx jy ja jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，随着更多工具、更好的调试和更多语言支持的到来，我很高兴能越来越多地使用这个特性！</p></div></div>    
</body>
</html>