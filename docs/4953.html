<html>
<head>
<title>How to deploy only changed packages in a Lerna Monorepo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Lerna Monorepo中仅部署已更改的包</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-deploy-only-changed-packages-in-a-lerna-monorepo-7e5fb234b32a?source=collection_archive---------2-----------------------#2020-11-02">https://itnext.io/how-to-deploy-only-changed-packages-in-a-lerna-monorepo-7e5fb234b32a?source=collection_archive---------2-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="945e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理包含多个包的monorepo的部署阶段的两种方法</h2></div><p id="91b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kh ir"> monorepo </strong>是一种软件开发策略，其中许多项目的<strong class="kh ir">代码存储在同一个存储库中</strong>，而<strong class="kh ir"> Lerna </strong>是一个库，它提供工具来管理monorepo中包含的包。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d496e06e50b3f596a00bb5a8e476be1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5Y6w3YXw_xJu3IhqimPkA.png"/></div></div></figure><p id="24d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多关于使用Monorepos的利与弊的讨论，在这篇文章中我不会讨论这些，但是我会解释<strong class="kh ir">我是如何和我的同事</strong>、<strong class="kh ir">一起解决关于部署monorepo </strong>中包含的包的问题的。</p><h1 id="50c1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">参考知识库</h1><p id="8599" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我将在本文中作为示例使用的lerna基础项目位于:<a class="ae mk" href="https://github.com/mzuccaroli/lerna-deploy-packages," rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">https://github.com/mzuccaroli/lerna-deploy-packages</strong>，</a>它是一个简单的Lerna存储库，由“lerna init”命令生成，包含三个由“lerna create”命令生成的包。有关创建Lerna回购的更多信息，请参见:<a class="ae mk" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank">https://github.com/lerna/lerna</a></p><h1 id="4706" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">问题是</h1><p id="9cdb" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">如果你正在处理一个复杂的项目，涉及<strong class="kh ir">微服务</strong>，我认为monorepos非常棒。有了monorepo，我解决了许多开发中的问题，但也出现了一些新问题:</p><ol class=""><li id="93a4" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">在开发了一个功能之后，这可能会涉及到对多个微服务的修改，我想轻松地<strong class="kh ir">只部署修改后的包。</strong></li><li id="0eb2" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">当我部署多个Lerna包时，很可能在同一个Monorepo中一些包依赖于其他包，所以我想<strong class="kh ir">控制包的构建和部署优先级</strong></li></ol><p id="6326" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与我的同事一起，我们为这些问题找出了两个可能的解决方案:第一个简单的方案完全基于Lerna特性，第二个相当“老派”,通过bash脚本解决问题。</p><h1 id="948f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">解决方案一:Lerna命令</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mz"><img src="../Images/09696b6cdf5853a570119e42b3d8ff0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LXB5aSNqZxr0Wve60jEjQ.png"/></div></div></figure><p id="25a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lerna本身提供了一个解决方案，它很容易应用，但不容易在文档中找到，也不容易在工作示例中看到。</p><p id="f123" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案的唯一问题是，您需要在您的构建/部署机器上安装lerna，对于大型项目，lerna bootstrap命令可能会非常慢。如果您的管道系统支持启动lerna和npm命令，这就是您的解决方案。</p><h1 id="4990" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">仅部署已更改的包</h1><p id="c984" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">你需要知道的唯一命令是“<a class="ae mk" href="https://github.com/lerna/lerna/tree/master/commands/run#readme" rel="noopener ugc nofollow" target="_blank"> lerna run </a>”，它只是<strong class="kh ir">在每个包含该脚本的包</strong>中运行一个npm脚本。</p><p id="cd13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果您在执行部署的包的package.json中放置一个“部署”脚本，您可以通过运行以下命令调用所有脚本:</p><pre class="lc ld le lf gt na nb nc nd aw ne bi"><span id="c7bb" class="nf lo iq nb b gy ng nh l ni nj">$ npx lerna run deploy</span></pre><p id="94dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于只为修改的包运行脚本，只需运行</p><pre class="lc ld le lf gt na nb nc nd aw ne bi"><span id="4e0a" class="nf lo iq nb b gy ng nh l ni nj">$ npx lerna run deploy — since HEAD~1</span></pre><p id="5570" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">这将“自动地”检测在最后的“~N”次提交中哪些包被改变了</strong>，如果你使用一个像git flow这样的好的分支系统，合并提交将准确地识别被改变的包。</p><p id="5451" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行此命令要求lerna可用，并且程序包已准备好部署，以便您可以创建一个安装lerna的迷你脚本，并为您的管道安装所有repo依赖项:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="3703" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">确定包装顺序</h1><p id="6a19" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">假设我们有一些<a class="ae mk" href="https://github.com/mzuccaroli/lerna-deploy-packages/tree/main/packages" rel="noopener ugc nofollow" target="_blank">示例包</a> : package_1是一个与package_2有一些耦合的微服务，微服务之间的这种“耦合”情况并不理想，但有时会发生，因此我们需要一个解决方案。</p><p id="4309" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果两个包都被修改，您必须在构建和部署package_1之前构建和部署package_2。</p><p id="909e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lerna提供了一个有点“黑”的解决方案:<strong class="kh ir">只需将package_2放入package_1的devDependencies中</strong> : Lerna会自动检测包的依赖关系，并按照正确的顺序构建。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a5ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以尝试使用示例repo:对包进行一些修改，然后运行。/build_lerna.sh:您可以注意到，package_2的部署脚本是在package_1之前调用的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nm"><img src="../Images/c899dcb4e13102bfbaf56cd3cfa52b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vsUFT2F9rXWsIHnj"/></div></div></figure><h1 id="f1ef" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">解决方案二:Bash脚本</h1><p id="4ca1" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">如果<strong class="kh ir">您的部署管道没有准备好启动Lerna和npm命令</strong>,您可以依赖传统的bash/git组合。这相当“老派”，需要创建和维护小bash脚本，但是非常<strong class="kh ir">可移植</strong>并且没有要求(除了git)。所以<strong class="kh ir">不需要在部署环境</strong>中安装lerna。</p><h1 id="f3ec" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">仅部署已更改的包</h1><p id="6fba" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">让我们创建一个bash脚本，它将检查修改的包并为每个包启动一个构建脚本，<a class="ae mk" href="https://github.com/mzuccaroli/lerna-deploy-packages/blob/main/build_general.sh" rel="noopener ugc nofollow" target="_blank">在示例repo </a>中提供了该脚本的一个现成版本。</p><p id="d38c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本的主要步骤是:</p><h2 id="47f7" class="nf lo iq bd lp nn no dn lt np nq dp lx ko nr ns lz ks nt nu mb kw nv nw md nx bi translated">获取已修改文件的列表</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="fb70" class="nf lo iq bd lp nn no dn lt np nq dp lx ko nr ns lz ks nt nu mb kw nv nw md nx bi translated">根据文件列表确定哪些包被更改</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="4edc" class="nf lo iq bd lp nn no dn lt np nq dp lx ko nr ns lz ks nt nu mb kw nv nw md nx bi translated">为每个包启动build.sh脚本</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="b9dc" class="nf lo iq bd lp nn no dn lt np nq dp lx ko nr ns lz ks nt nu mb kw nv nw md nx bi translated">软件包脚本</h2><p id="f187" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">记住，这个解决方案假设每个包都有一个<strong class="kh ir">。包/ <em class="ny">包名</em>文件夹中的/build.sh </strong>脚本。<a class="ae mk" href="https://github.com/mzuccaroli/lerna-deploy-packages/blob/main/packages/package_1/build.sh" rel="noopener ugc nofollow" target="_blank">根据作为参数传递给的分支来处理不同部署阶段的示例</a>可以是:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="cebc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">确定包装顺序</h1><p id="4b5b" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这是我为解决包优先级问题而应用的一个小技巧:只需在package.json文件中添加一个可选的"<strong class="kh ir">构建优先级</strong>"字段，所有没有指定优先级的包都将采用默认值(例如。50)然后在运行单个构建之前按优先级排序包:</p><p id="1544" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">包_ 2/包. json:</p><pre class="lc ld le lf gt na nb nc nd aw ne bi"><span id="d7af" class="nf lo iq nb b gy ng nh l ni nj">...<br/>“build_priority”: 10<br/>...</span></pre><p id="a0ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">build_general.sh</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ee1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是一个非常优雅的解决方案，但<strong class="kh ir">完成工作</strong>，如果你有任何更好的想法，请告诉我！</p><p id="dc40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您可以运行您的<em class="ny"> build_general.sh </em>脚本，输出应该是这样的:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nz"><img src="../Images/66ab8b6d979d3e761ed89b99ec900e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BVx04ypMisyno2DQ"/></div></div></figure><p id="d5bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，您可以在<a class="ae mk" href="https://github.com/mzuccaroli/lerna-deploy-packages" rel="noopener ugc nofollow" target="_blank">参考资源库</a>:<a class="ae mk" href="https://github.com/mzuccaroli/lerna-deploy-packages." rel="noopener ugc nofollow" target="_blank">https://github.com/mzuccaroli/lerna-deploy-packages.</a>中下载包含构建脚本和演示包的工作示例</p><h1 id="5bc4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">关于文章的注释</h1><p id="0c5d" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">本文和参考示例的灵感来自于<strong class="kh ir">生产中运行的真实项目</strong>。本文的代码不是“hello world”演示，而是支持大型项目的真实代码。它并不完美，但是这两个不同的解决方案在一年多的时间里为项目提供了一个健壮的部署系统。</p></div></div>    
</body>
</html>