<html>
<head>
<title>Deep Dive into Docker Internals — Union Filesystem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Docker内部——Union文件系统</h1>
<blockquote>原文：<a href="https://itnext.io/deep-dive-into-docker-internals-union-filesystem-5a1fbcd426b5?source=collection_archive---------0-----------------------#2021-03-01">https://itnext.io/deep-dive-into-docker-internals-union-filesystem-5a1fbcd426b5?source=collection_archive---------0-----------------------#2021-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索OverlayFS的内部工作方式，overlay fs是Docker映像和容器分层架构背后的文件系统</h2></div><p id="76aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Docker CLI非常简单——你只需要<code class="fe le lf lg lh b">build</code>、<code class="fe le lf lg lh b">run</code>、<code class="fe le lf lg lh b">inspect</code>、<code class="fe le lf lg lh b">pull</code>和<code class="fe le lf lg lh b">push</code>容器和图像，但是你有没有想过Docker接口背后的内部是如何工作的？在这个简单的接口背后隐藏着许多很酷的技术，在本文中我们将探索其中之一——联合文件系统——所有容器和图像层背后的底层文件系统...</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/7754e69100dc8bd5e010b78d5bf61531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMkgTa50HKbHU-jUnvb7cQ.jpeg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">肖恩·斯特拉顿在<a class="ae ly" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="18e4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是联合文件系统？</h1><p id="dd01" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">Union mount是一种文件系统，它可以创建一种假象，将几个目录的内容合并成一个目录，而不修改其原始(物理)源。这很有用，因为我们可能将相关的文件集存储在不同的位置或介质中，但我们希望在一个合并的视图中显示它们。例如，来自远程NFS服务器的一群用户的<code class="fe le lf lg lh b">/home</code>目录全部<em class="mw">联合</em>成一个目录，或者将分割的ISO映像合并成一个完整的目录。</p><p id="63e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">联合装载或联合文件系统为；然而，<em class="mw">不是</em>文件系统类型，而是一个有许多实现的概念。其中一些更快，一些更简单，具有不同的目标或不同的成熟度。因此，在我们开始深入研究细节之前，让我们快速浏览一下一些更流行的可用实现:</p><ul class=""><li id="2a00" class="mx my it kk b kl km ko kp kr mz kv na kz nb ld nc nd ne nf bi translated"><em class="mw"> UnionFS </em> —让我们从最初的union文件系统开始。UnionFS似乎不再被积极开发了，它的<a class="ae ly" href="http://git.fsl.cs.sunysb.edu/?p=unionfs-2.6.39.y.git;a=summary" rel="noopener ugc nofollow" target="_blank">最近一次提交</a>是在2014年8月。你可以在https://unionfs.filesystems.org/的网站上了解更多。</li><li id="7319" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><em class="mw">aufs</em>——原始UnionFS的重新实现，增加了许多新特性，但由于合并到主流Linux内核中而被拒绝。Aufs是Ubuntu/Debian上Docker的默认驱动程序，但被OverlayFS取代(用于Linux内核&gt; 4.0)。与Docker <a class="ae ly" href="https://docs.docker.com/storage/storagedriver/aufs-driver/#aufs-and-docker-performance" rel="noopener ugc nofollow" target="_blank">文档第</a>页描述的其他union文件系统相比，它有一些优势。</li><li id="7a98" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><em class="mw"> OverlayFS </em> —接下来，OverlayFS从3.18(2014年10月26日)开始包含在Linux内核中。这是默认使用的文件系统<code class="fe le lf lg lh b">overlay2</code> Docker驱动程序(你可以用<code class="fe le lf lg lh b">docker system info | grep Storage</code>来验证)。它通常比aufs有更好的性能，并且有一些很好的特性，比如<a class="ae ly" href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/#overlayfs-and-docker-performance" rel="noopener ugc nofollow" target="_blank"> <em class="mw">页面缓存共享</em> </a>。</li><li id="c663" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><em class="mw">ZFS</em>——ZFS是由<em class="mw">太阳微系统</em>(现在的<em class="mw">甲骨文</em>)创建的联合文件系统。它有一些有趣的功能，如分层校验和、快照和备份/复制的本机处理或本机数据压缩和重复数据删除。然而，由于由Oracle维护，它拥有非操作系统友好许可证(CDDL ),因此不能作为Linux内核的一部分提供。然而，你可以使用Linux上的<em class="mw">ZFS(ZoL)</em>项目，Docker文档中将其描述为<em class="mw">健康且成熟的…，但尚未准备好投入生产</em>。如果你想尝试一下，那么你可以在这里找到它<a class="ae ly" href="https://zfsonlinux.org/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="c9e1" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><em class="mw"> Btrfs </em> —另一个选项是Btrfs，它是<a class="ae ly" href="https://btrfs.wiki.kernel.org/index.php/Contributors" rel="noopener ugc nofollow" target="_blank">多家公司</a> —包括SUSE、WD或脸书——在GPL许可下发布的联合项目，是Linux内核的一部分。Btrfs是Fedora 33的默认文件系统。它还具有一些有用的功能，如块级操作、碎片整理、可写快照和许多其他功能。如果你真的想通过切换到Docker的非默认存储驱动程序的麻烦，那么Btrfs及其特性和性能可能是正确的选择。</li></ul><p id="1dcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想更详细地研究这些与Docker相关的驱动程序，你可以查看<a class="ae ly" href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" rel="noopener ugc nofollow" target="_blank"> Docker文档</a>中的驱动程序比较。也就是说，除非你<em class="mw">真的</em>知道你在做什么(在这一点上你不会读这篇文章)，那么你应该坚持使用默认的<code class="fe le lf lg lh b">overlay2</code>，它也将在本文的其余部分用于演示。</p><h1 id="2994" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">但是为什么呢？</h1><p id="bf2c" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">在上一节中，我们提到了为什么这种类型的文件系统可能是有用的，但是为什么它是Docker和容器的好选择呢？</p><p id="78c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用来旋转容器的许多图片都很大，不管是72MB的<code class="fe le lf lg lh b">ubuntu</code>还是133MB的<code class="fe le lf lg lh b">nginx</code>。每次我们想从这些图像中创建一个容器时，分配那么多空间是非常昂贵的。由于有了union文件系统，Docker只需要在映像上创建一个薄层，其余部分可以在所有容器之间共享。这还提供了减少启动时间的额外好处，因为不需要复制图像文件和数据。</p><p id="4711" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Union文件系统还提供了隔离，因为容器对共享图像层具有只读访问权限。如果他们需要修改任何只读共享文件，他们使用<em class="mw">写时复制</em>策略(稍后讨论)将内容复制到他们的顶部可写层，在那里可以安全地修改内容。</p><h1 id="e90d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">它是如何工作的？</h1><p id="665d" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">现在是时候问一个重要的问题了——它实际上是如何工作的？从上面描述的所有事情来看，整个union文件系统似乎是某种魔法，但事实并非如此。让我们首先解释一下它在一般(非容器)情况下是如何工作的——让我们想象一下，我们希望将两个目录(<code class="fe le lf lg lh b">upper</code>和<code class="fe le lf lg lh b">lower</code>)联合挂载到同一个挂载点，并拥有它们的联合视图:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d179" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在union mount术语中，这些目录被称为<em class="mw">分支</em>。这些分支中的每一个都被分配了优先级。如果在多个源分支中有相同名称的文件，这个优先级用于确定哪个文件将出现在合并视图中。看看上面的文件和目录——很明显，如果我们试图覆盖它们，我们就会产生这种冲突(<code class="fe le lf lg lh b">code.py</code>文件)。所以，让我们试着看看会出现什么:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8006" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们使用类型为<code class="fe le lf lg lh b">overlay</code>的<code class="fe le lf lg lh b">mount</code>命令来合并<code class="fe le lf lg lh b">lower</code>目录(只读；低优先级)和<code class="fe le lf lg lh b">upper</code>目录(读写；更高的优先级)到<code class="fe le lf lg lh b">/mnt/merged</code>中的合并视图中。我们还包括了<code class="fe le lf lg lh b">workdir=./workdir</code>选项，它是在将<code class="fe le lf lg lh b">lowerdir</code>和<code class="fe le lf lg lh b">upperdir</code>移动到原子操作中的<code class="fe le lf lg lh b">/mnt/merged</code>之前，准备合并视图的地方。</p><p id="2ab3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样查看上面的<code class="fe le lf lg lh b">cat</code>命令的输出，我们可以看到在合并视图中<code class="fe le lf lg lh b">upper</code>目录中的文件内容确实优先。</p><p id="9a9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，现在我们知道了如何合并两个目录，如果有冲突会发生什么，但是如果我们试图从合并视图中修改一些文件会发生什么呢？这就是<em class="mw">写时拷贝(CoW) </em>发挥作用的地方。那么，到底是什么呢？CoW是一种优化技术，如果两个调用者请求相同的资源，您可以给他们指向相同资源的指针，而不用复制它。只有当调用者之一试图写入他们的<em class="mw">“副本”</em>时，复制才变得必要——因此术语<em class="mw">在(第一次尝试)写入</em>时复制。</p><p id="9500" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在联合挂载的情况下，这意味着当我们试图修改共享文件(或只读文件)时，它首先被复制到顶部可写分支(<code class="fe le lf lg lh b">upperdir</code>)，该分支比只读的较低分支(<code class="fe le lf lg lh b">lowerdir</code>)具有更高的优先级。然后——当它在可写分支中时——可以安全地修改它，并且它的新内容将在合并视图中可见，因为顶层具有更高的优先级。</p><p id="747e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能要执行的最后一个操作是删除文件。为了执行<em class="mw">【删除】</em>，在可写分支中创建一个<em class="mw">空白</em>文件来清除我们想要删除的文件。这意味着文件实际上并没有被删除，而是隐藏在合并视图中。</p><p id="07b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们讨论了很多关于union mount的一般工作方式，但是它和Docker及其容器有什么关系呢？为了将它们连接起来，让我们看看Docker分层架构。一个容器的沙箱由一些图像分支组成——或者我们都知道它们——<em class="mw">层</em>。这些层是合并视图的只读(<code class="fe le lf lg lh b">lowerdir</code>)部分，容器层是瘦的可写顶部(<code class="fe le lf lg lh b">upperdir</code>)部分。</p><p id="80aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了这个架构术语之外，实际上是同样的事情——从注册表中提取的图像层是<code class="fe le lf lg lh b">lowerdir</code>,当您运行容器时，<code class="fe le lf lg lh b">upperdir</code>被附加到图像层的顶部，为您的容器提供可写的工作空间。听起来很简单，对吗？所以，我们来试试吧！</p><h1 id="cc42" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">尝试一下</h1><p id="170b" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">为了演示OverlayFS是如何被Docker使用的，我们将尝试模拟Docker是如何挂载容器和图像层的。在我们这样做之前，我们首先需要清理我们的工作区，并得到一个图像来玩:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4cde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个图像(<code class="fe le lf lg lh b">nginx</code>)来玩，所以接下来，让我们检查它的层。我们可以通过在图像上运行<code class="fe le lf lg lh b">docker inspect</code>并检查<code class="fe le lf lg lh b">GraphDriver</code>字段或者通过浏览存储所有图像层的<code class="fe le lf lg lh b">/var/lib/docker/overlay2</code>目录来检查图像层。所以，让我们两个都做，看看里面有什么:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4fbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看上面的输出，它看起来和我们用<code class="fe le lf lg lh b">mount</code>命令看到的非常相似，对吗？更具体地说:</p><ul class=""><li id="e3d4" class="mx my it kk b kl km ko kp kr mz kv na kz nb ld nc nd ne nf bi translated"><code class="fe le lf lg lh b">LowerDir</code>:只读图层目录，用冒号分隔</li><li id="d707" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><code class="fe le lf lg lh b">MergedDir</code>:来自图像和容器的所有层的合并视图</li><li id="d884" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><code class="fe le lf lg lh b">UpperDir</code>:写入变更的读写层</li><li id="9727" class="mx my it kk b kl ng ko nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><code class="fe le lf lg lh b">WorkDir</code>:Linux overlay fs用来准备合并视图的工作目录</li></ul><p id="0b78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们更进一步，运行一个容器并检查它的层:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="30ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的输出显示，之前在<code class="fe le lf lg lh b">docker inspect nginx</code>的输出中列出的与<code class="fe le lf lg lh b">MergedDir</code>、<code class="fe le lf lg lh b">UpperDir</code>和<code class="fe le lf lg lh b">WorkDir</code>(id为<code class="fe le lf lg lh b">3d963d191b2101b3406348217f4257d7374aa4b4a73b4a6dd4ab0f365d38dfbd</code>)相同的目录现在是容器的<code class="fe le lf lg lh b">LowerDir</code>的一部分。这里的<code class="fe le lf lg lh b">LowerDir</code>是由所有的<code class="fe le lf lg lh b">nginx</code>图像层叠加而成的。在它们上面是<code class="fe le lf lg lh b">UpperDir</code>中的可写层，包含<code class="fe le lf lg lh b">/etc</code>、<code class="fe le lf lg lh b">/run</code>和<code class="fe le lf lg lh b">/var</code>。同样，如果我们在上面列出了<code class="fe le lf lg lh b">MergedDir</code>，您将看到容器可以使用整个文件系统，包括来自<code class="fe le lf lg lh b">UpperDir</code>和<code class="fe le lf lg lh b">LowerDir</code>的所有内容。</p><p id="b833" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，为了模拟Docker的行为，我们可以使用这些相同的目录来手动创建我们自己的合并视图:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cb7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们只是从前面的代码片段中抓取值，并将它们传递给<code class="fe le lf lg lh b">mount</code>命令中的适当参数，唯一的不同是我们使用<code class="fe le lf lg lh b">/mnt/merged</code>来合并视图，而不是<code class="fe le lf lg lh b">/var/lib/docker/overlay2/.../merged</code>。</p><p id="25d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也是Docker中整个OverlayFS的本质——一个<code class="fe le lf lg lh b">mount</code>命令跨越多个堆叠层。下面是负责这个的Docker代码的一部分——替换<code class="fe le lf lg lh b">lowerdir=...,upperdir=...,workdir=...</code>值，然后是<code class="fe le lf lg lh b">unix.Mount</code></p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="6c03" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="0c33" class="pw-post-body-paragraph ki kj it kk b kl mr ju kn ko ms jx kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">当从外面看Docker接口时，它可能看起来像一个黑盒子，里面有许多模糊的技术。这些技术——虽然晦涩难懂——非常有趣和有用，虽然你不需要理解它们就能有效地使用Docker，但在我看来——学习和理解它们仍然是值得的。对该工具有了更深入的理解，就可以更容易地做出正确的决策——在这种情况下——关于性能优化或安全影响。另外，它还能帮助你发现一些很酷的技术，这些技术在未来会有更多的应用。</p><p id="2b06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们只探讨了Docker架构的一部分——文件系统——还有其他值得深入研究的部分，比如<code class="fe le lf lg lh b">cgroups</code>或Linux名称空间。因此，如果您喜欢这篇文章，请密切关注后续文章，我们也将深入研究这些技术。😉</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="3bcc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mw">本文最初发布于</em><a class="ae ly" href="https://martinheinz.dev/blog/44?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_44" rel="noopener ugc nofollow" target="_blank"><em class="mw">martinheinz . dev</em></a></p><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/hardening-docker-and-kubernetes-with-seccomp-a88b1b4e2111"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用seccomp强化Docker和Kubernetes</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">您的容器可能不像您想象的那样安全，但是seccomp配置文件可以帮助您解决这个问题…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">itnext.io</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ls nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/building-docker-images-the-proper-way-3c9807524582"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">以正确的方式构建Docker图像</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">让我们优化Docker构建，以创建更小、更安全的Docker映像，只需普通构建的一小部分…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">itnext.io</p></div></div><div class="og l"><div class="om l oi oj ok og ol ls nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a href="https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">你不用再用Docker了</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Docker不是唯一的集装箱工具，可能会有更好的替代工具…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ls nx"/></div></div></a></div></div></div>    
</body>
</html>