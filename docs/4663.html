<html>
<head>
<title>Serverless video upload and encoding with Firebase Storage, Cloud Functions and Publitio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Firebase存储、云功能和Publitio进行无服务器视频上传和编码</h1>
<blockquote>原文：<a href="https://itnext.io/serverless-video-upload-and-encoding-with-firebase-storage-cloud-functions-and-publitio-a4b2997b1508?source=collection_archive---------2-----------------------#2020-08-18">https://itnext.io/serverless-video-upload-and-encoding-with-firebase-storage-cloud-functions-and-publitio-a4b2997b1508?source=collection_archive---------2-----------------------#2020-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9be654767d571f4a72300aed0e1117fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_0IjV63E1U1fFUxUD2wCA.png"/></div></div></figure><figure class="kb kc kd ke gt ju"><div class="bz fp l di"><div class="kf kg l"/></div></figure><h1 id="fe86" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">我们正在建造的东西</strong></h1><p id="a855" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我的<a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-serverless-flutter-video-sharing-app-with-firebase-storage-including-hls-and-411e4fff68fa">上一篇文章</a>中，我展示了如何使用<em class="me">客户端编码</em>将视频上传到Firebase云存储。这种方法将编码负担放在客户端，但是可以节省服务器代码转换成本。</p><p id="b67c" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">这一次我将展示如何使用<em class="me">服务器端编码</em>，结合<a class="ae md" href="https://firebase.google.com/docs/storage" rel="noopener ugc nofollow" target="_blank"> Firebase云存储</a>、<a class="ae md" href="https://firebase.google.com/docs/functions" rel="noopener ugc nofollow" target="_blank"> Firebase云函数</a>和<a class="ae md" href="https://publit.io?fpr=jonathan43" rel="noopener ugc nofollow" target="_blank"> Publitio API </a>，我之前已经就<a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68">写过</a>。</p><blockquote class="mk ml mm"><p id="5da0" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated"><em class="it">注意:我们在这里看到的方法解决了我在</em> <a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68"> <em class="it">这篇文章</em> </a> <em class="it">中描述的安全问题，因为API密钥和秘密根本不在客户端使用。</em></p></blockquote><h1 id="0932" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">系统设计</strong></h1><p id="e9a1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每个视频文件的处理管道如下:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/22504476777f3f9b34650fbf806ecf8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JYpm9aa2CSzrwSxM8Zg7g.png"/></div></div></figure><ol class=""><li id="dd9c" class="mr ms it lh b li mf lm mg lq mt lu mu ly mv mc mw mx my mz bi translated">将文件从客户端上传到Firebase云存储。</li><li id="aef0" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">在Firestore中创建状态为“正在处理”的文档。</li><li id="3426" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">云功能由文档创建触发。</li><li id="2670" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">云函数生成一个临时签名的url，指向云存储中的文件。</li><li id="2e4a" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">Cloud函数调用Publitio远程文件上传端点，带有签名的url。(您可以将其切换到任何媒体编码API)</li><li id="b4b6" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">云功能将Publitio视频id、url、缩略图URL和其他元数据保存在Firestore中，并将文档“处理中”状态更改为已完成。</li><li id="a0a8" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">更新后的Firestore文档会在客户端上即时更新。</li></ol><p id="bbc8" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">为什么不直接从客户端上传到publitio？</p><p id="5822" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">Firebase云存储在无服务器架构中提供了一种更健壮的上传方式。我们可以使用firebase认证，只允许登录用户上传，防止用户删除其他人的视频等。如果我们直接从客户端上传到publitio，我们必须把API密匙和秘密放在客户端。这是一个安全问题，因为我们必须假设客户端上的任何东西都可能被恶意的参与者获取。</p><p id="02e6" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">为什么不在云函数中编码呢？</p><p id="9eba" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">造成这个问题的主要原因是Firebase对函数执行时间的硬性限制:9分钟(<a class="ae md" href="https://cloud.google.com/functions/docs/concepts/exec#timeout" rel="noopener ugc nofollow" target="_blank">来源</a>)。如果你想实现良好的压缩，你需要运行一个缓慢的编码过程，这可能需要9分钟以上。</p><p id="28f2" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">另一个原因是，您将重写专用API中已经可用的视频编码逻辑。</p><h1 id="d487" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">委托人</strong></h1><p id="c4c7" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">客户端是这里最简单的部分。为了简单起见，我基本上使用了与<a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-serverless-flutter-video-sharing-app-with-firebase-storage-including-hls-and-411e4fff68fa">上一篇文章</a>相同的Flutter客户端，没有客户端编码。</p><p id="2b08" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">我假设你已经有一个firebase项目设置。如果没有，可以看看<a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/how-to-make-a-serverless-flutter-video-sharing-app-with-firebase-storage-including-hls-and-411e4fff68fa">以前的帖子</a></p><p id="14e5" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">上传文件</strong></p><p id="acc6" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">上传过程需要两个部分:</p><p id="7dc5" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">1.保存到Firebase存储</p><p id="d402" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">我们将使用<a class="ae md" href="https://pub.dev/packages/image_picker" rel="noopener ugc nofollow" target="_blank"> <em class="me"> image_picker </em> </a>就像在之前的帖子中一样，但是现在文件上传是一个简单的存储<em class="me"> putFile </em>:</p><figure class="kb kc kd ke gt ju"><div class="bz fp l di"><div class="nf kg l"/></div></figure><p id="dfcf" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">2.在Firestore中保存初始条目</p><p id="d8da" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">然后，我们将创建一个只包含名称的新Firestore文档(我们将在云函数中使用该名称在云存储中查找文件)，并将<em class="me"> finishedProcessing </em>字段设置为false。</p><figure class="kb kc kd ke gt ju"><div class="bz fp l di"><div class="nf kg l"/></div></figure><p id="e8d5" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">要添加删除选项，我们只需从Firestore中删除文档，让云功能触发Publitio文件的删除。</p><p id="15b3" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">结合客户端和服务器端编码</strong></p><p id="5332" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">当然，您可以在这里混合搭配，在上传之前使用基本的客户端编码，让API来完成繁重的工作。为了简单起见，我在这里没有包括代码，但是如果你想看，请留下评论:)</p><blockquote class="mk ml mm"><p id="a6ec" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated">只要有云存储上传支持，您就可以将这种方法用于任何客户端框架，无论是移动的还是web的。</p></blockquote><h1 id="c453" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">云功能</strong></h1><p id="b675" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是大部分逻辑发生的地方。在部署之前，有几个设置步骤来配置云功能，但是首先，在firebase控制台中转到“功能”并启用云功能特性:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d4b72dd798f7f34c5ee438f653a03921.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*RrnCbqsFz58-sNTjfR-Gmw.png"/></div></figure><p id="162b" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">初始化云功能</strong></p><p id="fdb7" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">让我们首先在项目根目录下创建一个文件夹，其中包含所有与函数相关的内容，这样就不会与客户端代码混淆。我们将该文件夹命名为<code class="fe nh ni nj nk b">cloud-functions</code>。</p><p id="8a68" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">现在，在文件夹中，我们将初始化函数部署环境:</p><pre class="kb kc kd ke gt nl nk nm nn aw no bi"><span id="76d1" class="np ki it nk b gy nq nr l ns nt">cd cloud-functions<br/>firebase login<br/>firebase init functions</span></pre><p id="f399" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">这将在“cloud-functions”中创建一个新的文件夹“functions”，包含将要部署的实际代码。</p><blockquote class="mk ml mm"><p id="5a4f" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated"><em class="it">注意，因为我们想从云函数内部调用第三方API，所以您必须更改为“Blaze”计划并启用计费，因为Spark计划不支持出站网络请求(</em><a class="ae md" href="https://firebase.google.com/pricing" rel="noopener ugc nofollow" target="_blank"><em class="it">【https://firebase.google.com/pricing】</em></a><em class="it">)。这并不意味着你将被收费，你仍然每月获得相同的免费配额。</em></p></blockquote><p id="3a77" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">初始化代码</strong></p><p id="c1b7" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">现在来看实际的功能代码。打开<code class="fe nh ni nj nk b">/cloud-functions/functions/index.js</code>文件，添加以下代码(顺便说一下，这是node.js)</p><figure class="kb kc kd ke gt ju"><div class="bz fp l di"><div class="nf kg l"/></div></figure><p id="f37c" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">这将初始化我们函数中需要的模块:</p><ul class=""><li id="1aca" class="mr ms it lh b li mf lm mg lq mt lu mu ly mv mc nu mx my mz bi translated"><strong class="lh iu">功能</strong>:定义触发器</li><li id="09b1" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc nu mx my mz bi translated"><strong class="lh iu"> admin </strong>:用于访问Firestore和云存储。管理环境在云功能环境中预先配置了一个专用的服务帐户。</li><li id="f22e" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc nu mx my mz bi translated"><strong class="lh iu">publitio API</strong>—publitio node SDK。</li><li id="922f" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc nu mx my mz bi translated"><strong class="lh iu"> publitioCredentials </strong> —创建publitio凭证文件:<code class="fe nh ni nj nk b">/cloud-functions/functions/publitio_credentials.json</code>，以简单的json结构包含凭证:</li></ul><pre class="kb kc kd ke gt nl nk nm nn aw no bi"><span id="95e1" class="np ki it nk b gy nq nr l ns nt">{<br/>  "key": "&lt;your key&gt;",<br/>  "secret": "&lt;your secret&gt;"<br/>}</span></pre><blockquote class="mk ml mm"><p id="fee2" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated"><em class="it">如果您还没有Publitio凭据，您可以创建一个</em> <a class="ae md" href="https://publit.io?fpr=jonathan43" rel="noopener ugc nofollow" target="_blank"> <em class="it">自由帐户</em> </a> <em class="it">并从仪表板中复制它们。该文件将与我们的功能代码一起部署，在服务器上需要</em>和<em class="it">。</em></p></blockquote><p id="5a54" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">上传新视频云功能</strong></p><p id="1da4" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">我们有两个功能，一个用于上传新视频，一个用于删除视频。<code class="fe nh ni nj nk b">uploadNewVideo</code>功能由Firestore <code class="fe nh ni nj nk b">onCreate</code>事件触发。该函数的作用如下:</p><ol class=""><li id="e3a8" class="mr ms it lh b li mf lm mg lq mt lu mu ly mv mc mw mx my mz bi translated">使用Firestore文档的id获取对云存储文件的引用</li><li id="b38d" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">获取指向存储文件的具有“读取”权限的临时签名URL，该URL将在一小时后过期。</li><li id="d30b" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">用已签名的URL调用publitio的<code class="fe nh ni nj nk b">uploadRemoteFile</code>端点。</li><li id="4170" class="mr ms it lh b li na lm nb lq nc lu nd ly ne mc mw mx my mz bi translated">上传返回成功状态后，用视频URL和其他元数据更新Firestore文档。</li></ol><figure class="kb kc kd ke gt ju"><div class="bz fp l di"><div class="nf kg l"/></div></figure><blockquote class="mk ml mm"><p id="af32" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated"><em class="it">注:我们发送的是</em> <code class="fe nh ni nj nk b"><em class="it">option_hls: 1</em></code> <em class="it">。这启用了由Publitio生成的HLS(包括加密)。</em></p></blockquote><p id="40ad" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">删除视频云功能</strong></p><p id="b5a1" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">这个函数只是调用<code class="fe nh ni nj nk b">/files/delete/</code> publitio API，由Firestore <code class="fe nh ni nj nk b">onDelete</code>事件触发。根据您的使用情况，您可能希望保留文件进行备份，而只删除元数据。</p><figure class="kb kc kd ke gt ju"><div class="bz fp l di"><div class="nf kg l"/></div></figure><p id="cf63" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">部署</strong></p><p id="eb57" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">现在我们可以运行<code class="fe nh ni nj nk b">firebase deploy</code>命令了。成功部署后，您会看到控制台的“功能”部分出现了两个新功能:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/4bce7b2d0edcc5028540a8337f34c393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMx3Jxpl0SP5jDsBp0vPNQ.png"/></div></div></figure><p id="4cfb" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">增加功能超时</strong></p><p id="f451" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">现在我们已经部署了函数，我们可以配置超时了。云函数的默认超时时间为60秒。这对于我们的目的来说可能是不够的，所以让我们改变它。</p><p id="0fa4" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">点击<code class="fe nh ni nj nk b">uploadNewVideo</code>功能旁边的三个点，然后转到<code class="fe nh ni nj nk b">Detailed Usage Stats</code>:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/3ac48dada66ba5e2269e69bae529e228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NS1R1bnnRqfo9w9fVAnklQ.png"/></div></div></figure><p id="0e9e" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">这将打开GCP的功能设置。现在转到编辑-&gt;高级，并更改超时字段:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/cf29630fa61f24d1bf4fb81d0a17cbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6gmmgAdiXR6pJCtOZqtlA.png"/></div></div></figure><blockquote class="mk ml mm"><p id="482c" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated"><em class="it">注意:最大超时是540秒— 9分钟。</em></p></blockquote><p id="1b6b" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated"><strong class="lh iu">编辑IAM角色</strong></p><p id="4df5" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">我们还需要添加最后一项配置。为了使用<code class="fe nh ni nj nk b">getSignedUrl</code>，我们需要启用IAM(身份和访问管理)，它控制对云存储中的存储桶和对象的访问。在GCP控制台打开<a class="ae md" href="https://console.cloud.google.com/iam-admin/iam?pli=1" rel="noopener ugc nofollow" target="_blank"> IAM &amp;管理页面</a>:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/a1aab3098909b3b5c5c63d28bee2ca44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhHEKECyODr2Ata1VfpTgA.png"/></div></div></figure><p id="610d" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">现在向这个服务帐户添加两个角色:<code class="fe nh ni nj nk b">Service Account Token Creator</code>和<code class="fe nh ni nj nk b">Storage Object Creator</code>:</p><figure class="kb kc kd ke gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/f6672dbd61744700b3e0bd253e6e4d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK8h-FiYci8fcttqNJJEuw.png"/></div></div></figure><p id="3c8c" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">现在，该函数应该有权限获取已签名的url。</p><blockquote class="mk ml mm"><p id="bc8f" class="lf lg me lh b li mf lk ll lm mg lo lp mn mh ls lt mo mi lw lx mp mj ma mb mc im bi translated">信用:<a class="ae md" href="https://stackoverflow.com/questions/53305784/signingerror-with-firebase-getsignedurl" rel="noopener ugc nofollow" target="_blank">这个SO问题</a></p></blockquote><h1 id="8996" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">运行代码</strong></h1><p id="99a9" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，你可以在Android / iOS设备上运行代码，上传视频，并在上传后直接从Publitio播放编码/转码后的文件。</p><p id="62f1" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">感谢阅读！</p><p id="a6c3" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">完整的源代码可以在<a class="ae md" href="https://github.com/syonip/flutter_cloud_function_publitio" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="512c" class="pw-post-body-paragraph lf lg it lh b li mf lk ll lm mg lo lp lq mh ls lt lu mi lw lx ly mj ma mb mc im bi translated">如果您有任何问题，请留下您的评论！</p></div></div>    
</body>
</html>