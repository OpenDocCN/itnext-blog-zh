<html>
<head>
<title>Modern C++ in Advent of Code: Day16</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第16天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day16-6de15011455b?source=collection_archive---------2-----------------------#2021-12-16">https://itnext.io/modern-c-in-advent-of-code-day16-6de15011455b?source=collection_archive---------2-----------------------#2021-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天是<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">代码</a>问世的第十六天。今天，我们将分析和评估以压缩二进制格式编码的数据包，这种压缩二进制格式编码为文本。好玩。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/a822f64ce2b96874287a0aae48290950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKKH641Ig72ERiXl5d0ViQ.png"/></div></div></figure><p id="3727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于本系列中的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">请看这个列表</a>。</p><h1 id="9f1c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第16天</h1><p id="c060" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">今天的问题太难理解了。首先，我们的输入是编码为十六进制文本的数据，其中每个字符是一个数字0-F，代表4位数据。为了解析这个输入，我们需要遵循递归包格式。</p><p id="feb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于AoC的描述非常详细，但它可以归结为三种类型的数据包:</p><ul class=""><li id="5b1e" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">文字包:<code class="fe mk ml mm mn b">[version:3][type:3 == 4]([literal_chunk:5])+</code></li><li id="b876" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">大小运营商包:<code class="fe mk ml mm mn b">[version:3][type:3][type:1 == 0][bit_length:15]([sub_packet])+</code></li><li id="ccbb" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">清点运营商数据包:<code class="fe mk ml mm mn b">[version:3][type:3][type:1 == 1][count:11]([sub_packet])+</code></li></ul><p id="6b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，无论哪种情况，我们都从一个由版本和类型组成的六位(3+3)报头开始。如果类型的值为4，我们就有了一个文本。否则，我们有一个运营商包。文字的数据由重复的五位块组成，其中第一位用来表示最后一个块(如果为零)，其余4位是值的一部分。大小确定的操作符分组使用要读取的总比特数(15比特字段)来指定子分组的数量。计数的操作符包使用它们的计数(11位字段)指定子包的数量。</p><h2 id="4733" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">花式比特流</h2><p id="19dd" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">今天，我们将用不同于往常的方式来解决这个问题。首先，我们将在一个想法的基础上构建我们的实现，并在完成后实现支持代码。</p><p id="7bdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这个想法是什么呢？想象一下，我们可以编写以下代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样一个界面无疑会让编写今天问题的解决方案变得令人愉快。假设我们有了这个比特流，并开始实现一个解决方案。</p><h2 id="bdbb" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">代表数据包</h2><p id="2e76" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们需要从表示递归分组数据结构开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5a29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个包要么包含一个文字，要么包含子包(第19行)。子分组由大小字段(以比特为单位的长度或计数)和实际分组的向量组成。我们也有一些助手函数，因为使用<code class="fe mk ml mm mn b">std::variant</code>很麻烦。</p><h2 id="8d15" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">从语法上分析</h2><p id="59ee" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">假设我们已经有了神奇的比特流，让我们来实现解析:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5c5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于解析文本，我们一直循环，直到遇到一个带有前导零的块(第8行)，并且我们一直将四个值位添加到总值中(第7行)。</p><p id="5111" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解析包本身，我们首先读取头部，然后根据类型，要么将其视为文字，要么开始读取子包。注意，为了读取特定数量的位，我们创建了一个子位流，这就是为什么输入操作符需要接受BaseBitStream(这开始决定位流类需要如何工作)。</p><h2 id="e246" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">解决办法</h2><p id="08c4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">总结这些版本，我们可以跨子包递归:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第2部分，我们必须解释type字段的所有可能值，并将整个数据包视为具有以下语义的数字表达式:</p><ul class=""><li id="f69b" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">类型0:子包的总和</li><li id="6c41" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型1:子包产品</li><li id="3737" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型2:最少的子包</li><li id="f875" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型3:子包的最大数量</li><li id="8d24" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型4是文字</li><li id="387c" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型5:如果第一个子包大于第二个子包，则为1，否则为零</li><li id="bac5" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型6:如果第一个子包小于第二个子包，则为1，否则为零</li><li id="6af4" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">类型7:如果第一个子包等于第二个子包，则为1，否则为零</li></ul><p id="041c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过向<code class="fe mk ml mm mn b">uint64_t</code>引入一个转换操作符来非常直接地实现这一点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8f34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种转换将触发递归扩展，因为每个子表达式也需要相应的子包转换成<code class="fe mk ml mm mn b">uint64_t</code>。</p><p id="6c5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以在主函数中使用这两个解决方案:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="6264" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">比特流</h2><p id="5de9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">好了，现在我们有了一个完整但行不通的解决方案。是时候实现缺失的部分了，比特流。我们知道我们将需要三个类，一个用于输入流操作符的<code class="fe mk ml mm mn b">BaseBitStream</code>，<code class="fe mk ml mm mn b">BitStream</code>类用于表示流，另一个<code class="fe mk ml mm mn b">SubBitStream</code>类支持位读取限制。</p><p id="7702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从用<code class="fe mk ml mm mn b">field_width</code>修饰符实现基类开始。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将实际读数推迟到<code class="fe mk ml mm mn b">BitStream</code>类(第9行)。接下来，<code class="fe mk ml mm mn b">field_width_mod</code>的输入流操作符重载使我们能够设置下面字段的宽度(第12行)。最后，我们为任何整数类型重载输入流操作符(第16行)，然后根据请求读取有限数量的位(第19行)或该类型的整个宽度(第17行)。</p><p id="f0fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于主要的输入解析，我们通过使用一个生成器将四位块转换成一个比特流来帮助自己:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后<code class="fe mk ml mm mn b">read_bits</code>方法将它集合在一起，并读取所请求的位数(第25行)。</p><p id="8c30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于子位流，我们还跟踪要读取的总位数限制:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="9cb0" class="mt kz iq bd la mu mv dn le mw mx dp li jy my mz lm kc na nb lq kg nc nd lu ne bi translated">测试</h2><p id="7a36" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">最后，由于我们今天以相反的顺序做事情，是时候使用来自AoC的测试数据进行测试了:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="88e3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="0d49" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="4775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表，里面有关于《代码降临》其他日子的文章</a>。</p><p id="796b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且请不要忘记亲自尝试一下<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="5c29" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="d708" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="52ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在推特<a class="ae kl" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">或LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>