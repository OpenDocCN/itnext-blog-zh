<html>
<head>
<title>Renovate Your Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更新你的软件</h1>
<blockquote>原文：<a href="https://itnext.io/renovate-your-software-2d767a48b1f2?source=collection_archive---------6-----------------------#2021-04-06">https://itnext.io/renovate-your-software-2d767a48b1f2?source=collection_archive---------6-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0d06b172215dd3eaaa84963c913baffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4BIIomXvy6UghTendYZnA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@davidpisnoy" rel="noopener ugc nofollow" target="_blank"> David Pisnoy </a>在Unsplash上拍摄</figcaption></figure><div class=""/><p id="b334" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码腐烂。当你发布它的时候，你的软件就成为了遗产。有人称之为技术债务。你必须积极维护。本文将向您展示如何做到这一点。</p><h1 id="2986" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题陈述</h1><p id="7d05" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">今天的软件包含许多依赖项。通常，对于您选择的编程语言，您会使用大量的开源库。您的构建工具将引入额外的依赖项。此外，您可能会使用容器技术来发布您的程序，从而增加更多的依赖性。</p><p id="5254" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些依赖性带来了核心问题:新版本发布得很快。有不同的驱动因素:缺陷被修复，特性被添加——变化可能是向下兼容的或中断的。您通常不希望总是手动将所有依赖项更新到最新版本，因为这是一项繁琐的工作，会花费太多时间。</p><p id="cd31" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，严重的错误和安全漏洞需要快速修复。如果您不定期更新您的依赖项，您可能会面临大量的工作，因为差距越来越大，最终导致昂贵的迁移项目。</p><p id="0356" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我用几个流行的依赖项来说明这一点:</p><ul class=""><li id="ebb4" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">棱角分明的<strong class="kf jh"/>4年内有了<a class="ae jd" href="https://en.wikipedia.org/wiki/Angular_(web_framework)#History" rel="noopener ugc nofollow" target="_blank"> 9个主要版本</a>。</li><li id="ee7f" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">2017年Java切换到半年发布时间表，导致4年内<a class="ae jd" href="https://en.wikipedia.org/wiki/Java_version_history" rel="noopener ugc nofollow" target="_blank"> 9个主要发布</a>。</li><li id="b524" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Go在9年内有<a class="ae jd" href="https://golang.org/doc/devel/release.html" rel="noopener ugc nofollow" target="_blank"> 17个主要版本</a>。</li></ul><p id="7146" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看最近的严重漏洞:</p><ul class=""><li id="96de" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">Lodash 4有一个原型污染攻击<a class="ae jd" href="https://nvd.nist.gov/vuln/detail/CVE-2020-8203" rel="noopener ugc nofollow" target="_blank">漏洞</a>。</li><li id="09c6" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">HtmlUnit 2包含代码执行<a class="ae jd" href="https://nvd.nist.gov/vuln/detail/CVE-2020-5529" rel="noopener ugc nofollow" target="_blank">漏洞</a>。</li><li id="061c" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Spring Framework 5容易受到反射文件下载攻击。</li></ul><h1 id="88c1" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决方案策略</h1><p id="a8c9" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">那么，你有什么选择？</p><blockquote class="ms"><p id="1296" class="mt mu jg bd mv mw mx my mz na nb la dk translated">解决这个问题的最佳策略是自动化依赖性更新。</p></blockquote><p id="cca9" class="pw-post-body-paragraph kd ke jg kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">为什么？首先，您要保持依赖关系的最新状态。不再需要为重大更新做额外的计划—您可以持续地做。第二，如果由于依赖项更新而出现问题，您将立即得到反馈(前提是您有足够的自动化测试)。第三，因为你已经更新了，所以你面临的漏洞要少得多。没有任何应用程序安全测试工具会再困扰你了。</p><h1 id="44eb" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">革新</h1><p id="8d6d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有什么工具可以帮助你实现这个策略吗？是的，有。<a class="ae jd" href="https://github.com/renovatebot/renovate#readme" rel="noopener ugc nofollow" target="_blank">翻新</a>就是这样的工具。它帮助您自动化依赖项更新，并且做得非常好。</p><h2 id="777b" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated"><strong class="ak">第一步:入门</strong></h2><p id="15e3" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">基本上有两种方法可以使用翻新:</p><ul class=""><li id="0717" class="me mf jg kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated"><a class="ae jd" href="https://github.com/marketplace/renovate" rel="noopener ugc nofollow" target="_blank"> GitHub应用</a>:要在GitHub上激活你的库，使用这个方便的集成。(注意，对于GitLab.com，您必须使用下面的自托管变体。)</li><li id="cb85" class="me mf jg kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated"><a class="ae jd" href="https://docs.renovatebot.com/getting-started/running/#self-hosting-renovate" rel="noopener ugc nofollow" target="_blank">自托管</a>:对于所有其他变体(内部部署，包括GitLab.com和本地执行)，renew被打包为一个节点模块和Docker映像，具有针对不同<a class="ae jd" href="https://docs.renovatebot.com/modules/platform/" rel="noopener ugc nofollow" target="_blank">平台</a>的各种集成。</li></ul><h2 id="92e3" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated"><strong class="ak">第二步:入职</strong></h2><p id="9687" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当renew bot第一次运行时，它会在项目存储库的根目录中寻找一个<em class="nt">renew . JSON</em>配置文件。如果找不到这样的文件(或其他位置)，它将创建一个onboarding拉/合并请求，并建议使用以下默认配置添加这样的文件:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="57be" class="nh lc jg nz b gy od oe l of og">{<br/>    "extends": [<br/>        "config:base"<br/>    ]<br/>}</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oh"><img src="../Images/97f254035344191f4c0abed7597853d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TJXBpZJjbfTfxTbmuTc8w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">入职公关</figcaption></figure><p id="593c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您合并此PR，翻新将开始…翻新😃</p><h2 id="a0c6" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated"><strong class="ak">第三步:配置</strong></h2><p id="3ecb" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">翻新是高度可配置的。当你开始使用renewal时，这可能有点让人不知所措。你可以浏览所有的<a class="ae jd" href="https://docs.renovatebot.com/configuration-options/" rel="noopener ugc nofollow" target="_blank">配置选项</a>，甚至还有更多<a class="ae jd" href="https://docs.renovatebot.com/self-hosted-configuration/" rel="noopener ugc nofollow" target="_blank">自托管实例</a>的选项。</p><p id="893c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，可以给<em class="nt">renew . JSON添加配置选项；自托管选项——包括上面的配置选项——充当中央配置，属于自托管实例<em class="nt">中的<em class="nt">config.js/config.json</em>。</em></em></p><h2 id="6f83" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated"><strong class="ak">步骤4:重复使用配置</strong></h2><p id="82df" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您可以通过将通用配置添加到<em class="nt">renew . JSON</em>的“<em class="nt">extends”</em>数组中来重用它。以下是如何启用Docker主要更新的示例:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="3752" class="nh lc jg nz b gy od oe l of og">{<br/>    "extends": [<br/>        "config:base",<br/>        "docker:enableMajor"<br/>    ]<br/>}</span></pre><p id="7553" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">renew已经配备了丰富的<a class="ae jd" href="https://docs.renovatebot.com/presets-config/" rel="noopener ugc nofollow" target="_blank">配置预置</a>。此外，您可以定义<a class="ae jd" href="https://docs.renovatebot.com/config-presets/" rel="noopener ugc nofollow" target="_blank">您的预置</a>，并与您的软件项目共享它们。这里有一个自定义预置用法的例子，位于<a class="ae jd" href="https://github.com/johanngyger/blog/blob/main/renovate.json" rel="noopener ugc nofollow" target="_blank">github&gt;johanngyger/blog</a>(所有预置托管选项见<a class="ae jd" href="https://docs.renovatebot.com/config-presets/#preset-hosting" rel="noopener ugc nofollow" target="_blank">命名约定</a>):</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="d8a3" class="nh lc jg nz b gy od oe l of og">{<br/>    "extends": [<br/>        "config:base",<br/>        "github&gt;johanngyger/blog"<br/>    ]<br/>}</span></pre><p id="9c80" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于自托管实例，您还可以在<em class="nt"> config.js </em>中添加您的默认配置，这样您就不必将它添加到每个<em class="nt">renew . JSON</em>的“extends”数组中。</p><h2 id="1762" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated"><strong class="ak">更新观念</strong></h2><p id="d03d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们深入了解配置选项之前，您必须了解renew的一些核心概念:</p><p id="0278" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://docs.renovatebot.com/modules/manager/" rel="noopener ugc nofollow" target="_blank">管理器</a>作为语言相关包管理器的主要抽象，比如npm (JavaScript)、Maven (Java)、Bundler (Ruby)、Composer (PHP)等等。经理的目标是检测某种依赖类型，在革新术语中称为“包”。</p><p id="b810" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://docs.renovatebot.com/modules/datasource/" rel="noopener ugc nofollow" target="_blank">数据源</a>知道如何更新一个包。一旦管理者识别出一个包，它将被分配给一个相应的数据源，该数据源知道如何获得可用的版本。</p><p id="3df1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://docs.renovatebot.com/modules/versioning/" rel="noopener ugc nofollow" target="_blank">版本化</a>是对不同版本化方案的抽象，比如语义版本化。这是更新过程的最后一步。在识别出软件包并检测到可用版本后，版本化方案将确定新版本。</p><h2 id="ee7a" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated">包装规则</h2><p id="6165" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">range支持多种语言，并试图反映它们生态系统的特征。rules有合理的缺省值，但是有时你想覆盖这些缺省值，这就是软件包规则发挥作用的地方。您可以将自己的规则添加到“packageRules”数组中。</p><p id="62fa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一些我觉得有用的例子。第一个将启用默认禁用的主要版本的Docker更新:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="02ce" class="nh lc jg nz b gy od oe l of og">"packageRules": [<br/>    {<br/>        "matchDatasources": ["docker"],<br/>        "matchUpdateTypes": ["major"],<br/>        "enabled": true<br/>    }<br/>]</span></pre><p id="ceed" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个将自动合并所有Docker包。默认情况下，runs将分两次运行。第一次运行将创建PR，随后的运行将合并PR。(对于GitLab，有一个漂亮的<a class="ae jd" href="https://docs.renovatebot.com/configuration-options/#gitlabautomerge" rel="noopener ugc nofollow" target="_blank"> gitLabAutomerge </a>选项，这样当管道成功时，合并请求会自动合并。)</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="6431" class="nh lc jg nz b gy od oe l of og">"packageRules": [<br/>    {<br/>        "matchDatasources": ["docker"],<br/>        "automerge": true,<br/>        "gitLabAutomerge": true<br/>    }<br/>]</span></pre><p id="b7c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下规则将对Go模块更新进行分组，以便PRs不会淹没您:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="66c1" class="nh lc jg nz b gy od oe l of og">"packageRules": [<br/>    {<br/>        "matchDatasources": ["go"],<br/>        "groupName": "Go modules",<br/>        "groupSlug": "gomod",<br/>        "separateMajorMinor": false<br/>    }<br/>]</span></pre><h2 id="6778" class="nh lc jg bd ld ni nj dn lh nk nl dp ll ko nm nn lp ks no np lt kw nq nr lx ns bi translated">正则表达式管理器</h2><p id="848d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有时，默认经理不会发现一个包。您可以使用自定义正则表达式添加您的<a class="ae jd" href="https://docs.renovatebot.com/modules/manager/regex/" rel="noopener ugc nofollow" target="_blank">经理</a>。</p><p id="d838" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的例子改变了Docker储存库的组织方式，即它支持子储存库。此外，还使用了不同的版本控制方案:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="65ae" class="nh lc jg nz b gy od oe l of og">"regexManagers": [<br/>    {<br/>        "fileMatch": [<br/>            "(^|/|\\.)Dockerfile$",<br/>            "(^|/)Dockerfile\\.[^/]*$"<br/>        ],<br/>        "matchStrings": ['FROM (?&lt;depName&gt;\\S*):(?&lt;currentValue&gt;\\S*)'],<br/>        "datasourceTemplate": "docker",<br/>        "versioningTemplate": "loose"<br/>    }<br/>]</span></pre><h1 id="e6f6" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8656" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">管理代码中的依赖关系需要时间。renew可以通过自动更新依赖关系来自动化其中的一部分。翻新在基本配置中已经做得很好了，你应该马上激活它。但是，react会不断地创建PRs，所以你必须做出反应。</p><p id="1247" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从革新中获得最大收益，你必须学习T4文件。您还必须了解配置选项，并尝试使用它们。有时你甚至必须研究翻新源代码。但是，一旦renew按照你的需求运作，那就是一大乐事。</p></div></div>    
</body>
</html>