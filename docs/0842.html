<html>
<head>
<title>How To: Implement a Set of Stacks in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何:在Javascript中实现一组堆栈</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-implement-a-set-of-stacks-in-javascript-6fcfd19adda?source=collection_archive---------2-----------------------#2018-06-07">https://itnext.io/how-to-implement-a-set-of-stacks-in-javascript-6fcfd19adda?source=collection_archive---------2-----------------------#2018-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ed546fefeb33e0fdad4b22af8e83e822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eCM37-e60fCh5Yc2"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jd" href="https://unsplash.com/@baher366?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Baher Khairy </a>创作的“粉色、绿色、棕色和黄色杏仁饼”</figcaption></figure><div class=""/><p id="9058" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">问题:</em>创建一个堆栈数据结构，如果前一个堆栈超过了特定的大小，它将创建额外的堆栈。</p><p id="6c53" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这个堆栈中推入和弹出应该像在常规堆栈中那样正常工作。也就是说，push()应该将一个值放在最后一个堆栈的末尾，pop()应该返回最后一个堆栈中的最后一个值。</p><p id="50f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">奖励:</em>创建一个popAt()方法，该方法从一个特定的堆栈返回一个弹出的值，并移动其余的值，这样就没有间隙了。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="c268" class="lj lk jg bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">行动（或活动、袭击）计划</h1><p id="cdcc" class="pw-post-body-paragraph kd ke jg kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">所以我们知道，我们至少需要用一个空的主栈<strong class="kf jh">来开始，当我们积累输入的时候，我们最终会把更多的栈放进去。我们可能还需要一个<strong class="kf jh">变量来存储用户可以传入的最大堆栈大小</strong>。</strong></p><p id="2da4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的push()方法需要<strong class="kf jh">找到最后一个堆栈，并将一个值推入其中</strong>。它还需要<strong class="kf jh">检查该堆栈是否超过最大大小</strong>，因为如果超过，它将需要将另一个空堆栈推入我们的主堆栈。</p><p id="aa7c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的pop()方法<strong class="kf jh">同样需要找到最后一个堆栈，并从中弹出最后一个值</strong>。它还需要<strong class="kf jh">检查最后一个堆栈的长度</strong>，如果没有剩余，就从主堆栈中弹出它，这样我们就不会有空堆栈了。</p><p id="ff69" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的popAt()方法将是最复杂的。它将接受一个对应于我们要弹出一个值的堆栈的数字。首先，我们应该<strong class="kf jh">根据堆栈长度</strong>检查这个数字，因为我们知道如果这个数字等于堆栈的数量，我们可以运行常规的pop方法，因为它只是从最后一个堆栈中弹出最后一个值。</p><p id="aaa5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还应该<strong class="kf jh">检查数字是否超出界限</strong>，比如它是否为0或者它是否大于我们拥有的筹码数量。如果是这样，那将是一个错误。</p><p id="82a7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要找到有问题的堆栈，从该堆栈中弹出值，然后以不留下剩余空间的方式移动其余的堆栈。这个问题的解决方案可能不会马上显现出来，但是我们会看到它实际上比你想象的要简单。</p><h1 id="9365" class="lj lk jg bd ll lm mm lo lp lq mn ls lt lu mo lw lx ly mp ma mb mc mq me mf mg bi translated">步骤1:初始化我们的数据结构</h1><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9425" class="na lk jg mw b gy nb nc l nd ne">class StackSet {<br/>  constructor(maxSize) {<br/>   if (arguments.length &lt; 1) {<br/>    throw new Error (‘Woops, maxSize is required!’)<br/>   }<br/> <br/>   this.stacks = [[]]<br/>   this.maxSize = maxSize<br/>  }<br/>}</span></pre><p id="ef59" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们知道我们最终会有多个堆栈，所以我们可以从嵌套数组开始。这使得事情更容易开始。</p><p id="24fc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们需要存储最大大小，因为这将决定我们何时创建新的堆栈。</p><h1 id="1fc9" class="lj lk jg bd ll lm mm lo lp lq mn ls lt lu mo lw lx ly mp ma mb mc mq me mf mg bi translated">步骤2:我们的push()方法</h1><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="db69" class="na lk jg mw b gy nb nc l nd ne">push(value) {<br/>  if (this.stacks[this.stacks.length - 1].length === this.maxSize) {</span><span id="39b6" class="na lk jg mw b gy nf nc l nd ne">   this.stacks.push([])<br/>  }<br/>    <br/>  this.stacks[this.stacks.length - 1].push(value) <br/>}</span></pre><p id="4492" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们用一个<strong class="kf jh">值</strong>参数创建我们的push()方法，因为我们想要向堆栈中添加一个值。然后我们将做一个快速检查，看看主堆栈中的最后一个堆栈是否等于上面传递给我们的构造函数的最大大小。如果是这样，我们知道我们的主堆栈中需要另一个堆栈，因为我们无法在当前堆栈中容纳更多的堆栈，所以让我们推一个空堆栈。</p><p id="6cb3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将把我们的值放入最后一个堆栈。</p><p id="61a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:记住这一点。length返回数组的<em class="lb">实际</em>长度，而不是索引的数量。这就是为什么我们需要减去1。</p><p id="c46d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们的maxSize = 3。这是正在发生的事情的形象化描述:</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/3a3869ef47f26d72bd7a8939b64f5230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R2FbXd5SVUereUofEBvNsw.png"/></div></div></figure><h1 id="1335" class="lj lk jg bd ll lm mm lo lp lq mn ls lt lu mo lw lx ly mp ma mb mc mq me mf mg bi translated">步骤3:我们的pop()方法</h1><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6946" class="na lk jg mw b gy nb nc l nd ne">pop() {<br/>  const value = this.stacks[this.stacks.length - 1].pop()<br/>   <br/>  if (this.stacks.length &gt; 1 &amp;&amp;<br/>this.stacks[this.stacks.length - 1].length === 0) {    </span><span id="b122" class="na lk jg mw b gy nf nc l nd ne">  this.stacks.pop()<br/>  }<br/>    <br/>  return value<br/>}</span></pre><p id="8ab5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的pop()方法中，我们将找到最后一个堆栈，并简单地从中弹出()最后一个值。</p><p id="757c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将它存储在一个变量中，因为接下来我们必须检查刚刚弹出的堆栈的长度。如果里面什么都没有，我们需要从主栈中弹出空栈。我们还检查主堆栈中的堆栈数量是否大于1，因为如果我们从第一个(索引0)堆栈中弹出，然后它是空的，我们希望它保持我们在构造器中初始化它时的状态，作为嵌套数组。否则，我们会弹出嵌套的数组，它只是一个普通的空数组，这会把事情弄糟！</p><p id="d816" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将返回值，这样我们就可以看到弹出了什么。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/edf722c936d0901353708a93697dc122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7-2G1EUqfLVMrFxXhXkAQ.png"/></div></div></figure><h1 id="61c3" class="lj lk jg bd ll lm mm lo lp lq mn ls lt lu mo lw lx ly mp ma mb mc mq me mf mg bi translated">步骤4:我们的popAt()方法</h1><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="af90" class="na lk jg mw b gy nb nc l nd ne">popAt(number) {<br/>  // checks<br/>  if (number &lt; 1 || number &gt; this.stacks.length) {<br/>    throw new Error ('Whoa, that number is either too small or too  large for our stack.')<br/>  }<br/>    <br/>  if (number === this.stacks.length) {<br/>    return this.pop()<br/>  }<br/>    <br/>  let stack = this.stacks[number - 1]<br/>  let value = stack.pop()<br/>  let nextStack = []<br/>    <br/>  for (let i = number; i &lt; this.stacks.length; i++) {<br/>    nextStack = this.stacks[i]<br/>    nextStack.reverse()<br/>    stack.push(nextStack.pop())<br/>    nextStack.reverse()<br/>    stack = nextStack<br/>  }<br/>    <br/>  if (this.stacks.length &gt; 1 &amp;&amp; this.stacks[this.stacks.length - 1].length === 0) {<br/>    this.stacks.pop()<br/>  }<br/>   <br/>    return value;<br/>}</span></pre><p id="79af" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住这个方法只需要<strong class="kf jh">在传入的数字处从堆栈中取出一个值</strong>。<strong class="kf jh">我们需要移动堆栈，这样就没有任何空间了</strong>。</p><p id="249a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在顶部，我们可以从一些初步检查开始。如果这个数字是0或者大于栈的数量，那么它对我们来说是没有用的，所以我们应该让用户知道。</p><p id="19f8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，如果数字与最后一个堆栈相同，那么我们可以运行一个常规的pop()。没问题。</p><p id="4eeb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有通过任何一项初步检查，现在是时候开始工作了。</p><p id="bacc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们通过从number param中减去1来获得我们需要的堆栈索引。很好，现在让我们弹出我们最终想要从堆栈中返回的值。</p><p id="4e46" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们快到了，现在我们只需要清理我们的堆栈。</p><p id="c2c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了进行移位，我们将在栈上运行一个for循环，从对应于numbers参数的栈开始(我们不关心前面的栈，因为它们不受pop的影响)。</p><p id="ac5e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们要做的是1)在我们选择的堆栈之后获取堆栈<em class="lb">，2)弹出该堆栈的第一个值，3)将弹出的值添加到我们选择的堆栈中，因为我们之前弹出最终值的地方有一个空白点。我们可以用类似pop()的<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" rel="noopener ugc nofollow" target="_blank"> shift() </a>方法轻松地做到这一点，但是是在数组的<em class="lb">开头</em>而不是结尾。</em></p><blockquote class="ni"><p id="e78c" class="nj nk jg bd nl nm nn no np nq nr la dk translated">注意:记住Javascript中的数组和对象是由引用指定的，这意味着当你给一个数组或对象指定一个变量时，它指向实际的对象，而不是创建一个副本。这意味着当我们修改“stack”和“nextStack”时，我们也在修改主堆栈中的堆栈。</p></blockquote><p id="e4cb" class="pw-post-body-paragraph kd ke jg kf b kg nt ki kj kk nu km kn ko nv kq kr ks nw ku kv kw nx ky kz la ij bi translated">之后，我们将把Stack赋给nextStack中剩余的部分，这样，如果我们的循环还有迭代，它可以在下一个stack上运行相同的过程，直到一切都在正确的位置。</p><p id="9665" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将运行与在pop()中相同的检查，看看在我们完成所有工作后，最后一个堆栈是否为空。如果是，那就把它去掉吧。然后我们将最终返回弹出的值，这样用户就可以看到它是什么了。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/32e278b9e07551af12130a190be608f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oFlr2QdljppBWWeqoeBcQ.png"/></div></div></figure><h1 id="e470" class="lj lk jg bd ll lm mm lo lp lq mn ls lt lu mo lw lx ly mp ma mb mc mq me mf mg bi translated">最终代码</h1><p id="82d8" class="pw-post-body-paragraph kd ke jg kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">这是我们的数据结构的样子。我在最后添加了一些日志，向您展示每种方法的输出。如果你注意到任何错别字，让我知道！</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d610" class="na lk jg mw b gy nb nc l nd ne">class StackSet {<br/>  constructor(maxSize) {<br/>    if (arguments.length &lt; 1) {<br/>      throw new Error ('Woops, maxSize is required!')<br/>    }<br/>    <br/>    this.stacks = [[]]<br/>    this.maxSize = maxSize<br/>  }<br/>  <br/>  push(value) {<br/>    if (this.stacks[this.stacks.length - 1].length === this.maxSize) {<br/>      this.stacks.push([])<br/>    }<br/>    <br/>    this.stacks[this.stacks.length - 1].push(value) <br/>  }<br/>  <br/>  pop() {<br/>   const value = this.stacks[this.stacks.length - 1].pop()<br/>   <br/>   if (this.stacks.length &gt; 1 &amp;&amp; this.stacks[this.stacks.length - 1].length === 0) {<br/>    this.stacks.pop()<br/>   }<br/>    <br/>    return value<br/>  }<br/>  <br/>  popAt(number) {<br/>    if (number &lt; 1 || number &gt; this.stacks.length) {<br/>      throw new Error ('Whoa, that number is either too small or too large for our stack.')<br/>    }<br/>    <br/>    if (number === this.stacks.length) {<br/>      return this.pop()<br/>    }<br/>    <br/>    let stack = this.stacks[number - 1]<br/>    let value = stack.pop()<br/>    let nextStack = []<br/>    <br/>    for (let i = number; i &lt; this.stacks.length; i++) {<br/>      nextStack = this.stacks[i]<br/>      stack.push(nextStack.shift())<br/>      stack = nextStack<br/>    }<br/>    <br/>    if (this.stacks.length &gt; 1 &amp;&amp; this.stacks[this.stacks.length - 1].length === 0) {<br/>    this.stacks.pop()<br/>   }<br/>   <br/>    return value;<br/>  }<br/>}</span><span id="1370" class="na lk jg mw b gy nf nc l nd ne">// initialize new StackSet object<br/>const myStack = new StackSet(3)</span><span id="0145" class="na lk jg mw b gy nf nc l nd ne">// to test if it works<br/>myStack.push(1)<br/>myStack.push(2)<br/>myStack.push(3)<br/>myStack.push(4)<br/>myStack.push(5)<br/>myStack.push(6)<br/>console.log(myStack.stacks) // [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]</span><span id="9539" class="na lk jg mw b gy nf nc l nd ne">console.log(myStack.pop()) // 6<br/>console.log(myStack.stacks) // [ [ 1, 2, 3 ], [ 4, 5 ] ]</span><span id="1f99" class="na lk jg mw b gy nf nc l nd ne">console.log(myStack.popAt(1)) // 3<br/>console.log(myStack.stacks) // [ [ 1, 2, 4 ], [ 5 ] ]</span></pre></div></div>    
</body>
</html>