<html>
<head>
<title>From Redux to MobX: A Smooth Experiment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Redux到MobX:一次顺利的实验</h1>
<blockquote>原文：<a href="https://itnext.io/from-redux-to-mobx-a-smooth-experiment-9eeb6248f58e?source=collection_archive---------1-----------------------#2021-03-09">https://itnext.io/from-redux-to-mobx-a-smooth-experiment-9eeb6248f58e?source=collection_archive---------1-----------------------#2021-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="caf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是一名软件开发人员，知道<strong class="jp ir"> Javascript </strong>和<strong class="jp ir"> React </strong>，那么你很有可能也知道或者至少对另一个叫做<strong class="jp ir"> Redux </strong>的东西有所了解。我敢说，没有听说过它几乎是不可避免的，因为<em class="kl">“状态管理”</em>是React的一个巨大组成部分，而Redux是最著名的方法之一。著名并不意味着无与伦比，所以如果您曾经寻找过替代方案(尤其是如果您想使用observables)，我敢打赌您已经看到了另一种状态管理解决方案的一些东西:<strong class="jp ir"> MobX </strong>。</p><p id="7af2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我开始关注它，推迟任何使用它的尝试的主要原因是当时缺乏支持。并不是说没有——有很多——但与Redux <strong class="jp ir"> </strong>相比，它仍然落后。这完全取决于你能承受多大的风险，以及在你当前的项目中有多大的实验空间。</p><p id="5e05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这么多年后，所有涉及的技术都变得更加成熟——大量的库和框架，在帖子和论坛中共享的知识，以及在开发过程中可能让您陷入困境的较小的错误和死角都得到了修复。</p><p id="bc3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定尝试一下MobX，哇，这是一次多么美好而有趣的经历啊！</p><p id="13e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我分享一下我的旅程才公平。由于我个人的Redux背景，我将把我最初使用MobX的尝试与一些类似的Redux解决方案和概念进行比较。这是一个很好的方式来看到一些利弊，因为我是MobX的新人，这也将是一个分享一些挑战，挫折和克服它们的努力的方式。当然，这将是一个非常个人的观点，但希望它可以帮助读者有一些期望:)</p><h1 id="fbd3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.MobX原则:</h1><p id="9f3b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">像大多数开发人员一样，我的第一步是研究官方文档，了解一些基础知识:<a class="ae lp" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank">https://mobx.js.org/</a></p><p id="19e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文档相当不错——我将尝试解释MobX的核心思想，并与Redux进行一些比较:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/1230826211d67e0568f9e26a053616ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RH-Uyj_8mEsd-tCG"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">MobX数据流</figcaption></figure><ol class=""><li id="1625" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="kl">动作:</em> </strong>是所有改变<em class="kl">可观察</em>状态<em class="kl">状态</em>的事物。MobX将确保由您的操作引起的应用程序状态的所有更改都由所有派生和反应自动处理。同步且无故障。</li><li id="ce05" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="kl">可观测状态:</em> </strong>任何可以变异并可能作为计算值来源的值都是可观测状态。塑造应用程序模型的对象、数组、原语和引用的图形。</li><li id="2ffc" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="kl">导出值:</em> </strong>基本上就是可以从你的应用的<em class="kl">可观测状态</em>自动计算出来的任何值。这些派生(或计算值)可以是简单的值，如未完成的待办事项的数量，也可以是复杂的东西，如待办事项的可视化HTML表示。</li><li id="74bc" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> <em class="kl">反应:</em> </strong>它们非常类似于推导。主要区别是这些函数不产生值。相反，它们会自动运行来执行一些任务。通常这是与I/O相关的。他们确保DOM被更新或者网络请求在正确的时间被自动发出。</li></ol><h1 id="ffa5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.还记得Redux吗？</h1><p id="8a47" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们来看看Redux流:</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d79206a162828685faf67e3e4b84d82d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*1WC3IKM7KVSfD642"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">冗余数据流</figcaption></figure><p id="e35b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，它们在某些方面看起来有些相似:它们都有某种动作，并且都保持一种可以重新呈现react组件的状态。在MobX中，这将发生在流的反应部分，我们可以将其与Redux中的视图更新进行比较。</p><p id="156b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们仔细看看:</p><h2 id="34fe" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">MobX与Redux / Actions:</h2><p id="82b6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在Redux中，一个动作是一个要被<em class="kl">调度的对象，而</em>是与<em class="kl">缩减器交互的方式。</em>我们通常创建单独的函数来接收参数和组织有效载荷，这样我们就可以回收那个调用。这些功能我们通常归类为动作创造者。在分派之后，动作通过一个开关，其中一个字符串将用于识别动作类型并创建一个新的状态。<strong class="jp ir">没有发生任何变化</strong>——您总是在另一个状态之上获得一个新的状态，这允许存储有一个<em class="kl">历史</em>。</p><p id="af11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在MobX中，你不需要分派任何东西。你调用函数，就是这样，<strong class="jp ir">会发生突变</strong>。在这里保持一致的基础的解决方案在于你的方法(动作),从我的角度来看<em class="kl"> Typescript </em>可以在定义将要更新的参数和可观察对象的部分提供很大帮助，使函数最不容易出错。因为突变是意料之中的，所以您应该知道它们是负责触发MobX流中其他步骤的。</p><p id="4784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的很喜欢不用创建额外的文件。通常我们有动作文件，常量文件，缩减文件等等。此外，我不太喜欢reducer中的switch语句——它只是在合并reducer后对整个应用程序的一个重要说明。不可开箱即用。</p><p id="75b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在有Typescript的MobX中，你有类。当然，在某些时候你必须实例化它们，但仅此而已。</p><h2 id="2ba3" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">MobX与Redux / State:</h2><p id="33e6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在Redux中，一个对象包含了一切。更新它们的唯一方法是通过<em class="kl">动作</em>。</p><p id="b6bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在MobX中，它们被称为<em class="kl">可观察对象</em>，基本上是类中的属性。一旦你定义其中一个为可观察的，任何相同属性的突变将调用导数/反应流。请记住，如果您没有将该属性设置为private，则无需适当的操作就可以访问它——但是不要搞错，它可以开箱即用，因为MobX定义了<em class="kl"> get </em>和<em class="kl"> set </em>是默认操作。</p><h2 id="b4e1" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">MobX与Redux / React:</h2><p id="1907" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在React with Redux中，视图更新是通过Redux提供的connect函数进行的。它接收另外两个函数，其中一个负责读取状态和其他属性，然后返回应该在组件中使用的内容。另一个是相同的，但是使用dispatch返回函数。我不会太深入细节或架构(如选择器等。)，，只知道增加了复杂性。</p><p id="a4b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在MobX中，您使用一种叫做autorun的方法——当您在一个可观察对象中有任何更新时，它将触发一个函数。从这些原始函数中，你可以得到更多的库来支持与其他框架的集成，在我们的例子中，就是React。对于React，有一个名为observer的函数，它使React组件成为数据流上的反应的一部分。所以，如果有什么道具，钩子什么的。起源于一个可观察的，它会工作，它会重新呈现从一个更新。这真的很简单，而且很快！</p><p id="c61c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，你所需要的只是一个类或对象作为你的可观察对象，以及一个做出反应的观察者。如果你可以这样说javascript的话，那么它的架构感觉如此自由，更加“自然”。</p><h2 id="e94d" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">MobX与Redux / Derivates</h2><p id="4c3d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是一个强大的工具，Redux不是开箱即用的。在MobX中，您可以使用一个函数，该函数将基于可观察值生成一个返回值，并且该函数将生成一个输出，并在使用后缓存它。因此，如果您在React组件中使用相同的函数，它将触发重新渲染，并且所有后续的渲染或使用都将缓存结果，这是一个非常好的开箱即用优化。</p><p id="153d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将这些派生函数想象成Redux中的选择器，并且它们缓存结果以避免重复所有的计算工作。</p><h2 id="3356" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated"><strong class="ak">结论</strong>:</h2><p id="dcc8" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我可以说，我对MobX + React的初步体验相当积极，主要原因是:</p><ul class=""><li id="fdd6" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk nh mm mn mo bi translated">对Javascript / Typescript感觉更自然；</li><li id="55c7" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nh mm mn mo bi translated">从文件结构到编码都比Redux简单得多；</li><li id="3367" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nh mm mn mo bi translated">充满了“自动化”——但是如果你愿意，你仍然可以定义和控制一切；</li><li id="4580" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nh mm mn mo bi translated">快速而精确——即使您使用您创建的整个MobX商店作为道具，它也只会在必要的地方和必要的时候精确地重新呈现组件。</li></ul><p id="4704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有很多东西需要尝试，尤其是看看它在一个更大的项目中的可扩展性。直到现在看起来真的很有前途很有意思:)</p><h2 id="73eb" class="mv kn iq bd ko mw mx dn ks my mz dp kw jy na nb la kc nc nd le kg ne nf li ng bi translated">下一步:</h2><p id="0590" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">从现在开始，我的计划是启动一个小型的个人项目，并在这个过程中分享更多的发现和经验——但我真的希望得到您的反馈，这样我就可以让它对每个人更有价值:)当然，如果您还没有尝试过MobX，请不要害羞，也请分享您的经验！:)</p></div></div>    
</body>
</html>