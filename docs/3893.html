<html>
<head>
<title>Authorization for a Kotlin Spring backend, using JSON Web Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSON Web令牌对Kotlin Spring后端进行授权</h1>
<blockquote>原文：<a href="https://itnext.io/authorization-for-a-kotlin-spring-backend-using-json-web-tokens-9f3c7b0d1ee7?source=collection_archive---------5-----------------------#2020-03-19">https://itnext.io/authorization-for-a-kotlin-spring-backend-using-json-web-tokens-9f3c7b0d1ee7?source=collection_archive---------5-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7e1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的文章中，我写了关于使用Terraform 设置Auth0的<a class="ae kl" href="https://hceris.com/setting-up-auth0-with-terraform/" rel="noopener ugc nofollow" target="_blank">。在本文中，我想使用</a><a class="ae kl" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> SpringBoot </a>将该设置用于授权对用<em class="km"> Kotlin </em>编写的后端API的请求。</p><p id="5525" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个API用于上传食谱。它通过前端应用程序使用。可以选择登录来查看它们。但是，我想授权创建新的请求。这就是我们现在要做的，感谢<a class="ae kl" href="https://en.wikipedia.org/wiki/JSON_Web_Token" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a>。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/e04eb49558b348a94521658141a42704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lhg1cXQfRcD0FxjF.png"/></div></div></figure><h1 id="8a61" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">JSON Web令牌</h1><p id="6e32" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我将用户管理委托给<em class="km"> Auth0 </em>。我们的前端使用<a class="ae kl" href="https://auth0.com/docs/api-auth/which-oauth-flow-to-use" rel="noopener ugc nofollow" target="_blank"> OAuth </a>与其通信，以获得<a class="ae kl" href="https://tools.ietf.org/html/rfc6750" rel="noopener ugc nofollow" target="_blank">承载令牌</a>，但这超出了本文的目的。我们将假设这一步已经发生，并且对我们后端的请求带有一个<em class="km">授权</em>头。</p><p id="cdf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令牌以base64编码，可以使用<a class="ae kl" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>方便地解码。解码后，我们可以看看有效载荷，它只是一个JSON对象:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="aaa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们有一个发布者(<code class="fe me mf mg mh b">iss</code>)、一个受众(<code class="fe me mf mg mh b">aud</code>)、一个到期时间(<code class="fe me mf mg mh b">exp</code>)和被授予的范围(<code class="fe me mf mg mh b">scope</code>)。所有这些都是我们可以验证的领域。这将如何工作？这里有一个图表:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/10818e1589850871a4df14cf4cc5381b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9lipHrQAme9frQan.png"/></div></div></figure><p id="e6ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了授权请求，我们需要三个组件:</p><ul class=""><li id="c18d" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">一个<em class="km">验证器</em>，用于检查令牌是否有效，如果有效，则从中提取信息</li><li id="3777" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">一个<em class="km"> JwtAuthorizationFilter </em>，它在每个后端请求之前运行，并运行<em class="km">验证器</em></li><li id="f122" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">与<em class="km"> Spring Security </em>的连接，如果请求无效，则拒绝该请求</li></ul><p id="8a79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们分别来看一看。</p><h1 id="e431" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">验证令牌</h1><p id="192b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">因此，我们的后端已经收到了一个请求，其中包括一个<em class="km"> JWT </em>，我们现在做什么？我们可以把它想象成两个不同的步骤。检查签名并验证令牌本身。我们将这两个步骤合并到一个接口(<code class="fe me mf mg mh b">Verifier</code>)中，该接口定义了一个方法:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="88d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用一个<code class="fe me mf mg mh b">Either</code>类型作为返回类型。我最近写了关于他们的<a class="ae kl" href="https://hceris.com/kotlin-either-types-instead-of-exceptions/" rel="noopener ugc nofollow" target="_blank"/>。本质上，如果<code class="fe me mf mg mh b">verify</code>成功，我们将得到一个<code class="fe me mf mg mh b">TokenAuthentication</code>，如果不成功，我们将得到一个<code class="fe me mf mg mh b">JWTVerificationException</code>的实例。</p><h1 id="51ee" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">签名</h1><p id="0c6b" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">令牌由发行者签名(在我们的例子中是<em class="km"> Auth0 </em>)。签名确保令牌来自发行者，并且没有被篡改。</p><p id="feb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免共享密钥，我们更喜欢使用公钥/私钥组合。这就是<code class="fe me mf mg mh b">JWKS</code>的用武之地。<em class="km"> Auth0 </em>在<a class="ae kl" href="https://%7B%7Bauth0_tenant%7D%7D.eu.auth0.com/.well-known/jwks.json" rel="noopener ugc nofollow" target="_blank">https://{ { auth 0 _ tenant } } . eu . auth 0 . com/下为您的租户发布密钥。知名/jwks.json </a>。我将那个键注入到我们的<code class="fe me mf mg mh b">RemoteVerifier</code>中，它实现了我上面定义的接口。我们将其作为<code class="fe me mf mg mh b">Bean</code>提供:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="a56b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">Bean</code>是有条件的，这样我们可以为我们的测试提供一个替代实现，从而避免网络请求。</p><h1 id="f499" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">设置验证器</h1><p id="86b1" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">对于验证本身，我们将使用auth0的<a class="ae kl" href="https://github.com/auth0/java-jwt" rel="noopener ugc nofollow" target="_blank">自己的库</a>。首先，我们初始化一个<code class="fe me mf mg mh b">JWTVerifier</code>:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="7370" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，我们包括了之前获得的密钥，以及令牌到期时间的灵活限制。如果你想明确地测试发布者和受众，你可以在调用<code class="fe me mf mg mh b">build()</code>之前使用<code class="fe me mf mg mh b">withIssuer</code>和<code class="fe me mf mg mh b">withAudience</code>方法。在我的情况下，检查我的租户签署令牌感觉足够安全。</p><p id="61b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过调用刚刚创建的<code class="fe me mf mg mh b">JWTVerifier</code>的<code class="fe me mf mg mh b">verify</code>方法来触发实际的验证，包装它以便它不会抛出异常。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="096e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等，那个<code class="fe me mf mg mh b">asToken</code>方法在那里做什么？正如我提到的，我们希望从令牌中提取信息。我们稍后需要令牌中的作用域列表，我们获取并将其包含在我们的<code class="fe me mf mg mh b">TokenAuthentication</code>中</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="bcfa" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">授权过滤器</h1><p id="0e31" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">验证器在一个过滤器中运行，该过滤器继承自<code class="fe me mf mg mh b">OncePerRequestFilter</code>。正如您可能猜到的，它在每个请求之前运行，但只运行一次。姑且称之为<code class="fe me mf mg mh b">JwtAuthorizationFilter</code>。它执行以下步骤:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/69dd887321d24aff70c43469b456cc92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/0*XzmMPKlzRb76MLPt.png"/></div></figure><p id="d760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在上一节中介绍了<em class="km">验证令牌</em>的步骤。在此之前，我们必须从报头中提取令牌。如果验证成功，我们设置与<em class="km">弹簧安全</em>相关的<code class="fe me mf mg mh b">SecurityContext</code>。代码如下所示:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="b4cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这相当简单……等等，那个<code class="fe me mf mg mh b">Option.fx</code>是什么？括号呢？另外，根据图表，ever step可能有一个空答案，我们在哪里处理它呢？</p><p id="00d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">长篇大论，自成一篇。简而言之，由于有了<em class="km">箭头</em>，我们可以使用<a class="ae kl" href="https://arrow-kt.io/docs/patterns/monad_comprehensions/" rel="noopener ugc nofollow" target="_blank">单子理解</a>来简化我们的代码，并使<code class="fe me mf mg mh b">Option</code>上的操作集合看起来像一个常规的代码块。</p><h1 id="6be5" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">绑定弹簧安全性</h1><p id="8b74" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我正在使用<a class="ae kl" href="https://spring.io/projects/spring-security" rel="noopener ugc nofollow" target="_blank"> Spring Security </a>将我的过滤器集成到我的应用程序中。最简单的入门方法是使用这种依赖关系:</p><pre class="ko kp kq kr gt mx mh my mz aw na bi"><span id="0547" class="nb la iq mh b gy nc nd l ne nf">implementation 'org.springframework.boot:spring-boot-starter-security'</span></pre><p id="2bcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在配置中，我指定了以下内容:</p><ul class=""><li id="5c92" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">我的<code class="fe me mf mg mh b">JwtAuthorizationFilter</code>将在每个请求之前运行</li><li id="766c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe me mf mg mh b">GET</code>请求不需要授权</li><li id="11ad" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">对于变化的请求(比如一个<code class="fe me mf mg mh b">POST</code>)，我们期望那里有<code class="fe me mf mg mh b">create:recipes</code>范围。记住，作为验证的一部分，我们将它映射到我们的<code class="fe me mf mg mh b">TokenAuthentication</code>中。</li></ul><p id="df75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个流畅的界面可以在代码中进行配置，如下所示:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在这三个部分终于连在一起了。我们定义了想要授权的请求。过滤器解析并验证令牌。如果这个令牌满足了我们的所有要求，请求就会通过。否则，它会因未授权的响应而失败。</p><h1 id="9ac2" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="c176" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果你想确保你的后端正确地确保只有正确的一方被允许做某些事情，在你的API中建立授权是你需要做的事情。我为我参与的一个项目推出了一个定制的解决方案，但是如果你使用标准的工具和库，它会更方便，也更容易被其他人理解。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="9978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2020年3月19日https://hceris.com</em><em class="km">的</em> <a class="ae kl" href="https://hceris.com/authorize-spring-backend-with-jwt-in-kotlin/" rel="noopener ugc nofollow" target="_blank"> <em class="km">。</em></a></p></div></div>    
</body>
</html>