<html>
<head>
<title>Plain socket communication between two Go programs, the easy way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个围棋程序之间的简单套接字通信</h1>
<blockquote>原文：<a href="https://itnext.io/plain-socket-communication-between-two-go-programs-the-easy-way-bd5ac5819eb6?source=collection_archive---------1-----------------------#2021-08-29">https://itnext.io/plain-socket-communication-between-two-go-programs-the-easy-way-bd5ac5819eb6?source=collection_archive---------1-----------------------#2021-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c89c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个真实世界的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c30963f40c0603874853a911cc6a4120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_rVjkOLwHxtZMzHcEk3YQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由Renee French创建的原始地鼠图像，使用由Maria Letta创建的地鼠图像</figcaption></figure><p id="463c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章可以看作是上一篇关于web-socket通信的文章的第二部分，作者是<a class="lu lv ep" href="https://medium.com/u/6f72c855da06?source=post_page-----bd5ac5819eb6--------------------------------" rel="noopener" target="_blank"> Petr Jahoda </a>。</p><div class="lw lx gp gr ly lz"><a rel="noopener  ugc nofollow" target="_blank" href="/websocket-communication-between-two-go-programs-the-easy-way-d8c9cf40043f"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">两个Go程序之间的WebSocket通信，简单的方法</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">有一个提示，在Docker中运行围棋程序时</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">itnext.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><p id="e5c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为在<a class="ae mo" href="https://www.reddit.com/r/golang/comments/p825kd/websocket_go_tutorial_communication_between_two/" rel="noopener ugc nofollow" target="_blank"> reddit </a>上有一个有趣的讨论，建议使用SSE、GRPC、消息队列(还有很多其他的)，我想写一篇关于(比较)这些通信协议的文章。</p><p id="f947" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但最后，我决定不这样做。</p><p id="036d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为所有这些协议会给你的项目增加更多的代码。我的意思是，你必须进口一些东西。你必须使用一个额外的库。</p><p id="5821" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想要一些在T5以下有更少T4代码的东西。简单点。但我也想写一个例子，这将很容易遵循和理解。没有难读的，也没有难用的。没有低级别的。</p><p id="0995" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为最初的教程使用websockets，所以本教程只使用普通套接字。</p><p id="c893" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章的结构和上一篇一样:我们将构建一个服务器和一个客户端，但是我们会让它更有趣。</p><p id="84f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以将服务器部分想象成在硬件设备上运行(就像Arduino从按钮收集温度和信号)，在连接时发送数据。</p><p id="47c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以把客户端想象成一个服务，运行在物理服务器上，接收这些数据并保存到数据库中。</p><p id="681f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">真实代码的链接在文章的最后(数据库保存)。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="fe11" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">套接字服务器(运行在硬件设备上)</h1><p id="695e" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">这段代码主要做三件事。</p><ol class=""><li id="630e" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated">连接和断开</li><li id="b4d2" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">从客户端接收数据</li><li id="ae67" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">向客户端发送数据</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="cea1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你运行这个程序，你会看到服务器已经启动。仅此而已。原因:服务器正在等待来自客户端的连接。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="6a2e" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">套接字客户端(运行在服务器上)</h1><p id="231a" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">客户端代码同样只做三件事。</p><ol class=""><li id="74c1" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated">连接和断开</li><li id="f8e0" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">从服务器接收数据</li><li id="9d5c" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">向服务器发送数据</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="591b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以独立于服务器部分运行该程序(也可以独立于客户端运行服务器部分)。</p><p id="82a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">客户端程序在循环中检查连接。如果连接，客户端打印接收到的数据，并发送另一个数据到服务器。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="5d19" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">测试通信</h1><p id="8781" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">把它们都放到一边，你就会看到结果。</p><p id="2f85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面你可以看到服务器程序的输出在左边，客户端程序的输出在右边。</p><p id="0127" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在下面的动画中看到的，客户端和服务器是独立运行的。服务器代码对客户端的连接和断开做出反应，反之亦然。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8b354feb8b96f467dec917e7bb44487b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3qVXd6kjzkpo0BdQPt8AXg.gif"/></div></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="7cf2" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结果</h1><p id="78c1" class="pw-post-body-paragraph ky kz it la b lb no ju ld le np jx lg lh nq lj lk ll nr ln lo lp ns lr ls lt im bi translated">当处理从服务器到客户端的编程时，有很多选择可供选择。</p><p id="a87e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你做的每一个选择，都有优点和缺点。</p><p id="8c66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请像对待<em class="ok">在你的编程腰带</em>下添加另一个工具一样对待这篇文章。</p><p id="2efe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是真实世界代码的链接。一种服务(在服务器上运行的客户端代码)，它连接到许多设备(在一些硬件上运行的服务器代码)，从它们自己的Go例程中下载数据，并将它们保存到数据库。</p><div class="lw lx gp gr ly lz"><a href="https://github.com/petrjahoda/socket_service" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">GitHub-petrjahoda/socket _ service</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">Go服务使用套接字通信从设备下载数据。使用此docker文件在docker运行时下安装…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="ol l mk ml mm mi mn ks lz"/></div></div></a></div></div></div>    
</body>
</html>