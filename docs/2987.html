<html>
<head>
<title>How I debug Javascript code I didn’t write</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何调试不是我写的Javascript代码</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-debug-javascript-code-i-didnt-write-6c405a6a9103?source=collection_archive---------4-----------------------#2019-09-11">https://itnext.io/how-i-debug-javascript-code-i-didnt-write-6c405a6a9103?source=collection_archive---------4-----------------------#2019-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8a839bb728715946b77f19846a3c5c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WaJ9sVm3o3EGr2KktN1Ow.png"/></div></div></figure><div class=""/><p id="7045" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当调试您没有编写的代码时，尤其是JavaScript代码，事情会变得非常混乱和复杂。得益于Javascript的单线程方法和<a class="ae kz" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">事件循环</a>，代码通常不会沿着直线方向移动。可能有异步/同步回调、xhr、超时/间隔、事件监听器、承诺等等，这些<em class="la">“help”</em>使你的代码不能以一种直接的方式工作，并且很容易迷失代码前进的方向。</p><p id="0c11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，发现天知道代码的哪一部分将一些值改变成了它原本不期望的值，这变得非常令人沮丧。我开发了一个Angular.js应用程序，它相当复杂，有很多观察器、事件监听器和异步调用，很难理解。</p><p id="2d2d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比方说，我们有一个bug，其中<code class="fe lb lc ld le b">$scope.notifications.usage_exhausted</code>本应该是<code class="fe lb lc ld le b">true</code>，但是当你点击一个按钮时，不知何故变成了<code class="fe lb lc ld le b">false</code>，而你不知道是什么代码做的。一般来说，你会从一个方法开始，找出那个值做什么，那个按钮做什么，那个值设置在哪里，所有输入字段都设置了什么属性为<code class="fe lb lc ld le b">ng-model</code> (angular定义输入字段自动同步模型的方法)等等。这种方法是可行的，但是它会浪费大量的时间去查看那些不是罪魁祸首的代码，并且让你觉得<a class="ae kz" href="https://hackspirit.com/what-am-i-doing-with-my-life-5-steps-to-finally-work-it-out/" rel="noopener ugc nofollow" target="_blank"> <em class="la">我在生活中到底在做什么？如果当我点击那个该死的按钮时，我能以某种方式看到</em>变成<code class="fe lb lc ld le b">$scope.notifications.usage_exhausted</code>会怎么样？</a></p><p id="1d08" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯，你可以用下面的代码片段来实现:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3bb7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个代码片段所做的是，它用JavaScript的本机<a class="ae kz" href="http://javascript.info/property-accessors" rel="noopener ugc nofollow" target="_blank">getter/setter</a>替换object上的属性，这些属性的行为与普通属性完全一样，但是每当您希望观察的属性发生变化时，它都有一个<code class="fe lb lc ld le b">debugger</code>供您使用。你所需要做的就是，<code class="fe lb lc ld le b">watch</code>当属性正确或未定义时。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="0c8b" class="lp lq je le b gy lr ls l lt lu">// watch when it was correct or undefined<br/>watchProperty($scope.notifications, 'usage_exhausted');</span></pre><p id="c216" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，无论何时<code class="fe lb lc ld le b">$scope.notifications.usage_exhausted</code>由于应用程序中的任何代码而发生变化，您都会得到一个断点，现在您需要看到的只是堆栈跟踪。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lv"><img src="../Images/bfe75db63c23cce585a9ff8fc1fc2563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGwj2ACKiuAafwRoqB-dMg.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">值改变时的自动调试点</figcaption></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/37679e2d841447880f4dddaf5c8f4e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SKkAh57GOyKNSM-VR3l5Q.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">调用堆栈中的上一步</figcaption></figure><p id="a388" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你确切地知道值在哪里被改变了。如果您以正常的方式调试问题，那么到目前为止您已经有了几个断点，并且还在调试中。</p><p id="bbec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">我提到的场景(点击按钮)非常简单，但有时由于一些延迟的XHR调用、超时/间隔或任何异步原因，值会在没有任何用户操作的情况下发生变化，这种情况下使用传统的调试方法很难找出问题所在。</strong></p><h1 id="8100" class="mb lq je bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">监视数组</h1><p id="c30a" class="pw-post-body-paragraph kb kc je kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">同样，您也可以观察数组索引的变化，以发现在特定索引处设置了什么代码。</p><pre class="lf lg lh li gt ll le lm ln aw lo bi"><span id="86a4" class="lp lq je le b gy lr ls l lt lu">watchProperty($scope.projects, 3)</span></pre><p id="db1e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当<code class="fe lb lc ld le b">$scope.projects</code>上的第3个元素被设置时，这将触发一个调试点。尽管当第三个元素被<code class="fe lb lc ld le b">push</code>放入数组时这并没有帮助。为了缓解这一问题，我们可以创建一个新的函数来观察阵列上的任何变化，并且可以编码如下:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="60c0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们<em class="la">通过在数组本身上创建这些方法来隐藏<code class="fe lb lc ld le b"><a class="ae kz" href="https://medium.com/free-code-camp/prototype-in-js-busted-5547ec68872" rel="noopener">Array.prototype</a></code>的<code class="fe lb lc ld le b">push</code>、<code class="fe lb lc ld le b">pop</code>和<code class="fe lb lc ld le b">splice</code>方法。现在，无论何时，代码的任何部分调用特定数组<strong class="kd jf">的这些<em class="la">突变</em>方法中的任何一个，</strong>你都会有断点，然后你可以再次看到调用堆栈来跟踪问题。</em></p><p id="72fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以为任何类型的代码创建这样的调试器。假设您在您的应用程序中使用了<code class="fe lb lc ld le b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">Set</a></code> s，并且您想要调试<code class="fe lb lc ld le b">Set.</code>的一个特定的<a class="ae kz" href="https://medium.com/free-code-camp/prototype-in-js-busted-5547ec68872" rel="noopener">实例</a>，只需编写另一个类似<code class="fe lb lc ld le b">watchSet</code>的代码片段(就像我们在上面编写<code class="fe lb lc ld le b">watchArray</code>一样)，来查看您想要查看的任何函数。</p><p id="b85c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">您可以为感兴趣的属性在对象上添加多个监视或嵌套监视。如果新值本身是一个对象，你甚至可以在深入断点时添加观察器来观察新值的属性。T24】</strong></p><h1 id="dfe4" class="mb lq je bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">警告</h1><p id="4737" class="pw-post-body-paragraph kb kc je kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">这种调试方式并不是完美的，并且在这些技巧不起作用的地方有一些限制，这些限制是:</p><ul class=""><li id="cc29" class="nd ne je kd b ke kf ki kj km nf kq ng ku nh ky ni nj nk nl bi translated">如果使用<code class="fe lb lc ld le b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete" rel="noopener ugc nofollow" target="_blank">delete</a></code>操作符删除一个属性，该操作不会被检测到，因此不会被注意到。</li><li id="268b" class="nd ne je kd b ke nm ki nn km no kq np ku nq ky ni nj nk nl bi translated">如果你的代码中的一个属性是用<code class="fe lb lc ld le b">Object.defineProperty</code> / <code class="fe lb lc ld le b">Object.defineProperties</code>定义的，那会导致观察器被覆盖，你不得不再次观察它。</li><li id="2369" class="nd ne je kd b ke nm ki nn km no kq np ku nq ky ni nj nk nl bi translated">一些我现在想不起来的事情。</li></ul><p id="1d57" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像Vue.js这样的框架，它们本身使用getter和setter来进行变更检测和反应，在<code class="fe lb lc ld le b">watchProperty</code>片段中已经被处理了，方法是使用<code class="fe lb lc ld le b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" rel="noopener ugc nofollow" target="_blank">Object.getOwnPropertyDescriptor</a></code>获得原始的<code class="fe lb lc ld le b">getter/setter</code>，将它们保存在闭包中，并在调用getter/setter时使用正确的<code class="fe lb lc ld le b">this</code>调用它们。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="a78f" class="mb lq je bd mc md ny mf mg mh nz mj mk ml oa mn mo mp ob mr ms mt oc mv mw mx bi translated">助手Chrome扩展</h1><p id="da59" class="pw-post-body-paragraph kb kc je kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">现在，每次你想调试时创建这些方法都是一个问题，为此我使用了这个很棒的Chrome扩展<a class="ae kz" href="https://chrome.google.com/webstore/detail/user-javascript-and-css/nbhcbdghjpllgmfilhnhkllmkecfmpld?hl=en" rel="noopener ugc nofollow" target="_blank"><strong class="kd jf"/></a><strong class="kd jf"/>，它可以让你定义你想在任何网站加载时运行的javascript代码。只需将这些片段保存为<code class="fe lb lc ld le b">*.*</code>通配符，这样您就可以随时随地在控制台上使用它们。我将这个扩展用于更多的片段，比如在需要的时候按需加载任何javascript库。我是<em class="la"> lodash </em>  <em class="la"> </em>的<a class="ae kz" href="https://medium.com/@pranavjindal999/stop-using-loops-just-lodash-everything-c60417b43b6c" rel="noopener">超级粉丝，每当我不得不动态地大量修改数据时，我都会加载它。</a></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="68dc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这样的观察器确实加快了我的调试速度。我额外使用了框架特定的扩展(比如angular.js的<a class="ae kz" href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en" rel="noopener ugc nofollow" target="_blank"> this </a>和新的开发工具特性，比如<a class="ae kz" href="https://blittle.github.io/chrome-dev-tools/sources/conditional-breakpoints.html" rel="noopener ugc nofollow" target="_blank">条件断点</a>、<a class="ae kz" href="https://developers.google.com/web/updates/2019/01/devtools#logpoints" rel="noopener ugc nofollow" target="_blank">日志点</a>和<a class="ae kz" href="https://developers.google.com/web/updates/2018/08/devtools#watch" rel="noopener ugc nofollow" target="_blank">实时表达式</a>，让我的调试过程不那么令人沮丧。</p><p id="eff4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">调试愉快！！</p></div></div>    
</body>
</html>