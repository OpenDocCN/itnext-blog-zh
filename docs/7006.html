<html>
<head>
<title>Migrate Angular v13 to v14 RC utilizing Standalone Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用独立组件将Angular v13迁移到v14 RC</h1>
<blockquote>原文：<a href="https://itnext.io/migrate-angular-v13-to-v14-rc-utilizing-standalone-components-fba181ec9a16?source=collection_archive---------0-----------------------#2022-05-14">https://itnext.io/migrate-angular-v13-to-v14-rc-utilizing-standalone-components-fba181ec9a16?source=collection_archive---------0-----------------------#2022-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d5382466531db795f8cd97ad33925c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcykTtONUjJeVkZaHLsZMw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">角形独立组件</figcaption></figure><p id="e8e4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你最近在看<a class="ae ld" href="https://github.com/angular/angular/discussions/43784" rel="noopener ugc nofollow" target="_blank"> Angular社区</a>，你会知道独立组件正在流行。让我对RFC的独立组件感到兴奋的是:</p><ul class=""><li id="7058" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">使用起来更简单，</li><li id="3e94" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">更容易推理，</li><li id="db37" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">写起来不那么冗长，而且</li><li id="9589" class="le lf it kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">编译速度更快(更多详情请见<a class="ae ld" href="https://github.com/angular/angular/issues/43165" rel="noopener ugc nofollow" target="_blank"> #43165 </a>)。</li></ul><p id="64db" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天，在本文中，我将向您展示我利用新的独立组件迁移现有Angular v13应用程序的经验。我没有把它们全部迁移，但这足以理解这个过程。</p><p id="3cc4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">总的来说，这个过程非常简单，你不需要做太多的改变。</p><h2 id="1d37" class="ls lt it bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">迁移流程(Nx Workspace)</h2><p id="e830" class="pw-post-body-paragraph kf kg it kh b ki ml kk kl km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc im bi translated">如果您正在创建一个新项目——而不是Nx，只需运行这个命令</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="487e" class="ls lt it mv b gy mz na l nb nc">npx @angular/cli@next new standalone-app</span></pre><p id="1e5d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果要升级现有的app，需要更新package.json中的<code class="fe nd ne nf mv b">@angular/cli</code>，然后运行迁移脚本。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9a41" class="ls lt it mv b gy mz na l nb nc">// package.json</span><span id="c4a4" class="ls lt it mv b gy ng na l nb nc">"@angular/cli": "14.0.0-rc.0",</span></pre><p id="40ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">运行迁移脚本(Nx Workspace)</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e567" class="ls lt it mv b gy mz na l nb nc">dalenguyen$ npx nx migrate <a class="ae ld" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>@14.0.0-rc.0</span><span id="2037" class="ls lt it mv b gy ng na l nb nc">Fetching meta data about packages.<br/>It may take a few minutes.<br/>Fetching <a class="ae ld" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>@14.0.0-rc.0</span><span id="f559" class="ls lt it mv b gy ng na l nb nc">&gt;  NX  The migrate command has run successfully.</span><span id="36e1" class="ls lt it mv b gy ng na l nb nc">- package.json has been updated<br/>- migrations.json has been generated</span><span id="65c1" class="ls lt it mv b gy ng na l nb nc">&gt;  NX  Next steps:</span><span id="08d1" class="ls lt it mv b gy ng na l nb nc">- Make sure package.json changes make sense and then run 'yarn'<br/>- Run 'yarn nx migrate --run-migrations'<br/>- To learn more go to <a class="ae ld" href="https://nx.dev/using-nx/updating-nx" rel="noopener ugc nofollow" target="_blank">https://nx.dev/using-nx/updating-nx</a></span></pre><h2 id="c07c" class="ls lt it bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">拔靴带</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="96d5" class="ls lt it mv b gy mz na l nb nc">// main.ts - Angular v13</span><span id="0641" class="ls lt it mv b gy ng na l nb nc">platformBrowserDynamic().bootstrapModule(AppModule)<br/>  .catch(err =&gt; console.error(err));</span></pre><p id="2747" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用<code class="fe nd ne nf mv b">bootstrapApplication</code>引导一个新的应用程序，它可能需要一些将在所有组件&amp;路由中使用的提供者。如果您使用材料，在某些情况下将需要“BrowserAnimationsModule”。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0bee" class="ls lt it mv b gy mz na l nb nc">// main.ts - Angular v14</span><span id="a621" class="ls lt it mv b gy ng na l nb nc">bootstrapApplication(AppComponent, {<br/>  providers: [<br/>     importProvidersFrom(BrowserAnimationsModule),<br/>     importProvidersFrom(RouterModule.forRoot(APP_ROUTES))<br/>  ],<br/>}).catch((err) =&gt; console.error(err))</span></pre><h2 id="74bd" class="ls lt it bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">按指定路线发送</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5d3a" class="ls lt it mv b gy mz na l nb nc">// app-routing.module.ts - Angular v13</span><span id="5466" class="ls lt it mv b gy ng na l nb nc">const routes: Routes = [<br/>  { path: '', component: HomeComponent },<br/>  { path: 'resume', component: ResumeComponent },<br/>  ...<br/>  { path: '**', redirectTo: '' },<br/>]</span></pre><p id="bbbe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">差不多吧。使用<code class="fe nd ne nf mv b">loadComponent</code>，它将为每个路由路径生成lazyload chuck文件。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d6c7" class="ls lt it mv b gy mz na l nb nc">// app-routing.module.ts - Angular v14</span><span id="f7a7" class="ls lt it mv b gy ng na l nb nc">export const APP_ROUTES: Routes = [<br/>  { path: '', loadComponent: () =&gt; import('./home/home.component').then((m) =&gt; m.HomeComponent) },<br/>  { path: 'resume', component: ResumeComponent },<br/>  ...<br/>  { path: '**', redirectTo: '' },<br/>]</span><span id="ffd0" class="ls lt it mv b gy ng na l nb nc">// RouterModule is removed and moved to main.ts</span></pre><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/912980d69b21ee98fdd540d01e2cd387.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*Fdkm7JXzEwR8UAXcs_LaMw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">独立组件中的惰性卡盘文件</figcaption></figure><h2 id="9625" class="ls lt it bd lu lv lw dn lx ly lz dp ma kq mb mc md ku me mf mg ky mh mi mj mk bi translated">成分</h2><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ebec" class="ls lt it mv b gy mz na l nb nc">// Angular v13</span><span id="06e7" class="ls lt it mv b gy ng na l nb nc"><a class="ae ld" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: 'app-intro',<br/>  templateUrl: './intro.component.html',<br/>  styleUrls: ['./intro.component.scss'],<br/>})<br/>export class IntroComponent {}</span></pre><p id="e7c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于独立方法，所有的模块或服务都将在组件中提供。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="640c" class="ls lt it mv b gy mz na l nb nc">// Angular v14</span><span id="cf94" class="ls lt it mv b gy ng na l nb nc"><a class="ae ld" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/> <strong class="mv iu"> imports: [MatIconModule],</strong><br/> <strong class="mv iu"> providers: [NavService],</strong><br/>  selector: 'app-intro',<br/>  <strong class="mv iu">standalone: true,</strong><br/>  templateUrl: './intro.component.html',<br/>  styleUrls: ['./intro.component.scss'],<br/>})<br/>export class IntroComponent {}</span></pre><p id="aabe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此时，您可以删除所有未使用的NgModule，如AppModule或其他模块。更多例子可以查看我在Github上的<a class="ae ld" href="https://github.com/dalenguyen/dalenguyen.github.io/pull/55/files" rel="noopener ugc nofollow" target="_blank"> PR。</a></p><p id="9949" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">快乐重构(独自一人):D</p></div></div>    
</body>
</html>