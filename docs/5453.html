<html>
<head>
<title>C# GraphQL Hotchocolate + Specflow Acceptance tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C# GraphQL Hotchocolate + Specflow验收测试</h1>
<blockquote>原文：<a href="https://itnext.io/c-graphql-hotchocolate-specflow-acceptance-tests-b976af39ddf0?source=collection_archive---------1-----------------------#2021-03-10">https://itnext.io/c-graphql-hotchocolate-specflow-acceptance-tests-b976af39ddf0?source=collection_archive---------1-----------------------#2021-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd3d165f237402c8861267cea70d1184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYThqufqYr4MOu6jl9Oj4w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">小女孩与安全眼镜和发网做科学实验</figcaption></figure><p id="d372" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我之前的<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/no-more-rest-long-live-graphql-apis-with-c-55962ba8f942">帖子</a>中，我已经展示了GraphQL如何通过创建灵活/高效的API并适应微服务架构<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/graphql-schema-stitching-c-2ccfd209d3ce">来加速开发。但是到目前为止，我是在没有任何测试的情况下开发的，因为它们只是示例代码，但是如果我们想做生产质量的代码，我们必须能够测试API。</a></p><h2 id="9abb" class="le lf it bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">基本的内存测试</h2><p id="05de" class="pw-post-body-paragraph kf kg it kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">热巧克力。net core framework for GraphQL非常友好，为我们提供了一种简单的方法来执行GraphQL查询，因此我们可以运行查询，获得JSON响应，然后根据需要断言响应属性。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在管道中运行基本的HotChocolate测试，以JSON的形式获取响应，反序列化，然后断言响应属性。</figcaption></figure><p id="39c2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们完全可以只用上面的例子XUnit做测试覆盖。但是在我看来，测试范围将变得足够大和复杂，我们需要一种更好的方式来表达需求。</p><h1 id="784e" class="mi lf it bd lg mj mk ml lj mm mn mo lm mp mq mr lp ms mt mu ls mv mw mx lv my bi translated">一个稍微现实一点的场景:</h1><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c5ee66e3ec299ff86338af740ba828c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJYbCBTdlEy8cq-kUAfhUg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有配置文件、订单、订单项目和产品的图表模式。</figcaption></figure><p id="1aec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每种颜色代表数据来自哪个接口；这些可能是简单的SQL查询或NoSql实现。在合同方面，我们有:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7e84" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在ItemRepository和Product Repository中注意到；我们不会在单独的调用中为每个产品询问存储库，因为我们想要批量调用这些数据库。这就是使用GraphQL数据加载器的全部意义。</p><p id="1870" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的数据流读作:</p><ul class=""><li id="42fb" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">有一个获取当前登录用户的查询。</li><li id="d0b8" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">然后有一个查询来获取该用户的订单。</li><li id="92d5" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">然后有一个数据加载器把所有的订单id批量化，然后一气呵成的得到商品。</li><li id="cbd3" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">然后是同样的产品配料概念。</li></ul><p id="4f95" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们如何编写一个测试来覆盖这个图形查询的全部呢？</p><h1 id="507c" class="mi lf it bd lg mj mk ml lj mm mn mo lm mp mq mr lp ms mt mu ls mv mw mx lv my bi translated">验收测试驱动的测试— Specflow</h1><p id="9f6b" class="pw-post-body-paragraph kf kg it kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">我们将尝试实现一个验收测试，这种测试几乎是端到端的，也称为双环TDD。我们也将使用Specflow，所以如果你开始需要更多关于测试策略或者如何做的上下文，你可以参考我的<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/acceptance-test-driven-development-in-net-core-with-specflow-dcb17fb7a893"> Specflow。网芯帖</a>。</p><p id="cc5e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完整的代码可以在这里的<a class="ae ld" href="https://github.com/RaphaelYoshiga/HotChocolateDemo" rel="noopener ugc nofollow" target="_blank"> Github中找到。</a></p><p id="a723" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">查询的覆盖范围可以是这样的:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/6985441fe67c1afd503556b9ec76617d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ar7pSvusd6MhxBUo40f1vA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">涵盖整个订单查询的Specflow</figcaption></figure><p id="b1e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们定义我们的用户查询，以及我们的存储库将提供给我们的外部数据，然后相应地断言响应。</p><p id="126e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种类型的TDD上，您正在清除像数据库和外部API这样的外部依赖，这样做的好处是测试运行速度快，并且不会因为网络或数据变化而出现误报。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/572ce15afd62b78e878be5e6240688dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olSMIkZ8WaZn4Ctj4I8MKw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图中我们的4个适配器不在测试范围内。</figcaption></figure><h2 id="43fd" class="le lf it bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">热巧克力内存服务器。</h2><p id="8816" class="pw-post-body-paragraph kf kg it kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">记住，我们可以加速GraphQL执行管道来执行我们的查询。</p><p id="ca5e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后我们需要存根我们的<strong class="kh iu">外部依赖关系</strong>，所以我们将使用GraphQL服务器的服务集合来注入存根，而不是真正的实现。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="9eac" class="mi lf it bd lg mj mk ml lj mm mn mo lm mp mq mr lp ms mt mu ls mv mw mx lv my bi translated">存根还是不存根？</h1><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/771618f9d4266c36e99e418add9d0b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pF59cTl-EVefWbXVMOrqrQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">达芬奇的雕像在意大利米兰晴朗的蓝天上。</figcaption></figure><p id="8e43" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我已经和多个团队一起使用存根模型进行了有效的开发，效果很好，测试套件给了我们很多信心。然后，我们在隔离测试中测试外部依赖性，我们称之为适配器测试。stubbing的缺点是您只测试了应用程序的一部分。一旦注入真正的实现，什么能保证一切都很好地协作呢？</p><h2 id="7c1f" class="le lf it bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated"><strong class="ak">永不存根！(讥讽)</strong></h2><p id="f1a2" class="pw-post-body-paragraph kf kg it kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">有理由不清除外部依赖，因为这给了你更好的测试覆盖率，这对于更复杂和更慢的测试来说是有好处的。</p><p id="563a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你需要问的是:</p><ul class=""><li id="4019" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated">更好的覆盖率值得设置测试数据的额外工作和复杂性吗？</li><li id="32e1" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">测试会慢一点。是否慢到足以减缓发展？</li><li id="fd9c" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated">其他团队API呢？你应该存根吗？</li></ul><p id="9577" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我通常倾向于存根，但我会留给你这个:</p><blockquote class="nr"><p id="726e" class="ns nt it bd nu nv nw nx ny nz oa lc dk translated">答案没有对错，只有取舍。</p></blockquote><p id="a1a0" class="pw-post-body-paragraph kf kg it kh b ki ob kk kl km oc ko kp kq od ks kt ku oe kw kx ky of la lb lc im bi translated">如果您没有stubbing东西，您可以编写一个冒烟测试套件，直接测试部署的API，作为黑盒测试，而不是像我们以前那样在内存中运行查询。</p><h1 id="c687" class="mi lf it bd lg mj mk ml lj mm mn mo lm mp mq mr lp ms mt mu ls mv mw mx lv my bi translated">这对我们有什么好处？</h1><p id="6953" class="pw-post-body-paragraph kf kg it kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">这允许我们从测试优先的角度来思考如何编写GraphQL端点。根据经验，GraphQL端点会很快变得复杂，您可能希望有一种方法来描述从GraphQL到数据库调用的转换。此外，它还为您提供了一种快速检查一切是否如预期那样连接的方法。</p><p id="ecb0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">正如Kent Beck所说，“开发人员有权知道他们的代码是否有效”。</p><p id="bc8b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">祝你愉快。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="0199" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">资源:</p><ul class=""><li id="05e7" class="na nb it kh b ki kj km kn kq nc ku nd ky ne lc nf ng nh ni bi translated"><a class="ae ld" href="https://github.com/RaphaelYoshiga/HotChocolateDemo" rel="noopener ugc nofollow" target="_blank">完整代码示例</a></li><li id="8f5d" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/no-more-rest-long-live-graphql-apis-with-c-55962ba8f942">graph QL相对于Rest的优势</a></li><li id="76ae" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/graphql-schema-stitching-c-2ccfd209d3ce">如何用GraphQL和C#创建微服务架构？</a></li><li id="eeef" class="na nb it kh b ki nj km nk kq nl ku nm ky nn lc nf ng nh ni bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/acceptance-test-driven-development-in-net-core-with-specflow-dcb17fb7a893">使用Specflow和验收测试驱动开发。网芯。</a></li></ul></div></div>    
</body>
</html>