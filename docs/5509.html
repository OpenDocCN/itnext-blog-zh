<html>
<head>
<title>HTTP Compression - boost your server’s speed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP压缩-提高服务器的速度</h1>
<blockquote>原文：<a href="https://itnext.io/http-compression-boost-your-servers-speed-a5bad6403452?source=collection_archive---------1-----------------------#2021-03-20">https://itnext.io/http-compression-boost-your-servers-speed-a5bad6403452?source=collection_archive---------1-----------------------#2021-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/933269e81610b96a3eb78d9fddf0fcb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5tMiI1VYJVSGLu-T"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">马库斯·斯皮斯克在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="f12b" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">通过启用web服务器压缩来降低延迟和成本</h2></div><p id="c70e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们都在非常努力地工作以产生影响，偶尔也有机会通过非常小的努力产生巨大的影响。读完这篇文章后，你将能够对你的网络服务器产生快速的影响，并提高你的网站的性能！</p><p id="75df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">REST</a>API(HTTP的子集)是最流行的API之一。如果你在SaaS的一家公司工作，你可能会把它作为与客户交流的外部API，也可能在你的服务内部使用它。在<a class="ae jd" href="https://www.dynamicyield.com/" rel="noopener ugc nofollow" target="_blank"> Dynamic Yield </a>中，我们每秒处理数千个HTTP请求，我们努力争取轻松获胜，例如延迟改善和成本优化。压缩是通过简单地减少线路上的字节来帮助我们的方法之一。</p><p id="1b66" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天大多数现代网络浏览器都默认支持gzip和Brotli等压缩格式。</p><p id="8e09" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实证明，默认情况下，大多数web服务器框架不支持"<em class="lr"> Accept-Encoding: gzip" </em>头，我们需要主动启用这个压缩特性。我们将在下面介绍几个框架。</p><p id="e4dc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">启用压缩有助于降低延迟和成本，因为通过网络传输的字节更少。以下是我们得到的结果:</p><ul class=""><li id="e128" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">更低的内部延迟，通过目标响应时间指标在AWS负载平衡器中测量。</li><li id="0ba2" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">往返时间更短，因为需要通过互联网传输给最终用户的字节更少。</li><li id="bb5d" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">降低成本:云提供商对可用性区域内/外/跨可用性区域的<a class="ae jd" href="https://aws.amazon.com/ec2/pricing/on-demand/#Data_Transfer" rel="noopener ugc nofollow" target="_blank">数据传输</a>收费。更少的字节意味着你节省更多的钱。</li></ul><p id="b61b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你在谷歌上搜索每个程序员都应该知道的数字，你会发现压缩数据比通过网络发送数据包要快得多。这意味着压缩数据将节省延迟。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/d79b9cd538b2696afe9be2f85421cd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KMDpyXWOT_cdwYdGyMEtw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">应用压缩时处理的字节数改进(图片由作者提供)</figcaption></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/bb7c1c7ce116031fbbaa8a38bdb977c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRCGtjEp1OGKG383Q7ffKw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">应用压缩时的响应时间改进(图片由作者提供)</figcaption></figure><p id="8b02" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以在上面的图表中看到，启用压缩后，我们每分钟处理的字节数减少了<strong class="kx jh"> ~80% </strong>，我们的延迟提高了<strong class="kx jh"> ~15%！</strong></p><h1 id="4847" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">真实世界的服务器示例</h1><p id="5287" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">让我们看看不同框架/语言中的几个例子:</p><h2 id="8211" class="nj mn jg bd mo nk nl dn ms nm nn dp mw le no np my li nq nr na lm ns nt nc nu bi translated">龙卷风(蟒蛇)</h2><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="686c" class="nj mn jg nw b gy oa ob l oc od">import tornado.ioloop<br/>import tornado.web<br/><br/>class MainHandler(tornado.web.RequestHandler):<br/>    def get(self):<br/>        self.write("x" * 1024)<br/><br/>def make_app():<br/>    return tornado.web.Application([<br/>        (r"/", MainHandler),<br/>    ], compress_response=True)<br/><br/>if __name__ == "__main__":<br/>    app = make_app()<br/>    app.listen(8888)<br/>    tornado.ioloop.IOLoop.current().start()</span></pre><p id="d7b0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.tornadoweb.org/" rel="noopener ugc nofollow" target="_blank">Tornado</a>(6.1版本测试)是一个Python web框架和异步网络库。上面的片段是从他们的“Hello，world”<a class="ae jd" href="https://www.tornadoweb.org/en/stable/#hello-world" rel="noopener ugc nofollow" target="_blank">示例</a>中复制的，略有改动:</p><ol class=""><li id="1a01" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq oe ly lz ma bi translated">Tornado对长度为1024 及以上的内容<a class="ae jd" href="https://github.com/tornadoweb/tornado/blob/master/tornado/web.py#L3083" rel="noopener ugc nofollow" target="_blank">进行压缩。因此，在本演示中，<em class="lr"> "Hello，world" </em>字符串被替换为<em class="lr"> "x" * 1024 </em>。</a></li><li id="7cd5" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq oe ly lz ma bi translated"><em class="lr"> compress_response=True </em>被添加到应用程序的构造函数中。</li></ol><p id="e083" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们来测试一下！首先，让我们使用<em class="lr"> curl </em>发送一个没有压缩的请求:</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="001c" class="nj mn jg nw b gy oa ob l oc od">~ $ curl -vs <a class="ae jd" href="http://127.0.0.1:8888" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8888</a><br/>&gt; GET / HTTP/1.1<br/>&gt; Host: 127.0.0.1:8888<br/>&gt;<br/>&lt; HTTP/1.1 200 OK<br/>&lt; Content-Type: text/html; charset=UTF-8<br/>&lt; Content-Length: 1024<br/>&lt; Vary: Accept-Encoding<br/>&lt;<br/>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></pre><p id="7361" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们添加<em class="lr">压缩的</em>标志(以模拟网络浏览器):</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="95ed" class="nj mn jg nw b gy oa ob l oc od">~ $ curl -vs --compressed <a class="ae jd" href="http://127.0.0.1:8888" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8888</a><br/>&gt; GET / HTTP/1.1<br/>&gt; Host: 127.0.0.1:8888<br/>&gt; Accept-Encoding: deflate, gzip<br/>&gt;<br/>&lt; HTTP/1.1 200 OK<br/>&lt; Content-Type: text/html; charset=UTF-8<br/>&lt; Content-Length: 29<br/>&lt; Vary: Accept-Encoding<br/>&lt; Content-Encoding: gzip<br/>&lt;<br/>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></pre><p id="d328" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在上面看到的，请求中添加了"<em class="lr"> Accept-Encoding: deflate，gzip" </em>头，我们的服务器用"<em class="lr"> Content-Encoding: gzip" </em>头进行响应。结果，我们的内容被压缩为"<em class="lr">内容长度:29" </em>(相比之下，第一个请求中的"<em class="lr">内容长度:1024" </em>)。</p><h2 id="9e5e" class="nj mn jg bd mo nk nl dn ms nm nn dp mw le no np my li nq nr na lm ns nt nc nu bi translated">Aiohttp (Python)</h2><p id="d147" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><a class="ae jd" href="https://docs.aiohttp.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> AIOHTTP </a>(在3.7.4版本上测试)是用于<a class="ae jd" href="https://docs.aiohttp.org/en/stable/glossary.html#term-asyncio" rel="noopener ugc nofollow" target="_blank"> asyncio </a>的异步HTTP服务器。下面的代码片段是从他们的<a class="ae jd" href="https://docs.aiohttp.org/en/stable/#server-example" rel="noopener ugc nofollow" target="_blank">服务器示例</a>中复制的，稍有改动；我们添加了一个压缩中间件，在将响应发送回用户之前对其进行压缩:</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="c6e7" class="nj mn jg nw b gy oa ob l oc od">from aiohttp import web<br/><br/>@web.middleware<br/>async def compression_middleware(request, handler):<br/>    response = await handler(request)<br/>    response.enable_compression()<br/>    return response<br/><br/>async def handle(request):<br/>    return web.Response(text="x" * 128)<br/><br/>app = web.Application(middlewares=[compression_middleware])<br/>app.add_routes([web.get('/', handle)])<br/><br/>if __name__ == '__main__':<br/>    web.run_app(app)</span></pre><p id="c0bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，这里没有最小内容长度，每个请求都将被压缩(但是，您可以通过在上面的<em class="lr"> compression_middleware </em>函数中添加一个条件来应用最小长度规则)。</p><h2 id="7646" class="nj mn jg bd mo nk nl dn ms nm nn dp mw le no np my li nq nr na lm ns nt nc nu bi translated">Express (node.js)</h2><p id="ba27" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><a class="ae jd" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>(在4.17.1版本上测试)是一个快速的、非个性化的、极简的node . js web框架。下面的代码片段复制自<a class="ae jd" href="https://expressjs.com/en/starter/hello-world.html" rel="noopener ugc nofollow" target="_blank"> hello-world示例</a>，并调整为使用<a class="ae jd" href="http://expressjs.com/en/resources/middleware/compression.html" rel="noopener ugc nofollow" target="_blank">压缩中间件</a>。在express的<a class="ae jd" href="https://expressjs.com/en/advanced/best-practice-performance.html" rel="noopener ugc nofollow" target="_blank">生产最佳实践页面</a>上建议启用压缩。</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="a683" class="nj mn jg nw b gy oa ob l oc od">const compression = require('compression')<br/>const express = require('express')<br/>var app = express()<br/>app.use(compression())<br/>const port = 3000<br/><br/>app.get('/', (req, res) =&gt; {<br/>    res.send("x".repeat(1024))<br/>})<br/><br/>app.listen(port, () =&gt; {<br/>    <strong class="nw jh"><em class="lr">console</em></strong>.log(`Example app listening at http://localhost:${port}`)<br/>})</span></pre><p id="47aa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们在第一个示例(Tornado)中看到的，快速压缩也有一个最小的阈值1024 ，您可以在实例化中对其进行调整。与上面Tornado的curl示例相反，响应中缺少了<em class="lr"> Content-Length </em>头，但是我们确实看到了<em class="lr"> Content-Encoding: gzip </em>头:</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="214a" class="nj mn jg nw b gy oa ob l oc od">~ $ curl -vs --compressed <a class="ae jd" href="http://127.0.0.1:3000" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000</a><br/>&gt; Accept-Encoding: deflate, gzip<br/>&gt;<br/>&lt; HTTP/1.1 200 OK<br/>&lt; Content-Type: text/html; charset=utf-8<br/>&lt; Content-Encoding: gzip<br/>&lt;<br/>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span></pre><h2 id="9b10" class="nj mn jg bd mo nk nl dn ms nm nn dp mw le no np my li nq nr na lm ns nt nc nu bi translated">Ruby on Rails</h2><p id="b9c4" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">Ruby on Rails(在5.2.4.5版本上测试)是一个用Ruby编写的服务器端web应用程序框架。添加<em class="lr">紧缩器</em>中间件将在这里发挥神奇的作用:</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="4d10" class="nj mn jg nw b gy oa ob l oc od">require_relative 'boot'<br/>require 'rails/all'<br/><br/>Bundler.require(*Rails.groups)<br/><br/>module <em class="lr">Myapp<br/>  </em>class <em class="lr">Application </em>&lt; Rails::Application<br/>    config.load_defaults 5.2<br/>    config.middleware.insert_after ActionDispatch::Static, Rack::Deflater<br/>  end<br/>end</span></pre><div class="mh mi mj mk gt ab cb"><figure class="of is og oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/82e84ccc3d5cc4f730fa20b93efa460f.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*nzATaRcEkvqol3aer63dcw.png"/></div></figure><figure class="of is ol oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/533663c4e60f30f09c370834ad0574c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*vIqwQUNrCW33PhtFwA7uoA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk om di on oo translated">添加压缩中间件(图片由作者提供)</figcaption></figure></div><h1 id="ca0c" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">真实世界的客户示例</h1><p id="124d" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">如果您的客户端是web浏览器，启用服务器端压缩就足够了。如果您使用HTTP在其他内部组件之间进行通信，您需要通过添加“<em class="lr"> Accept-Encoding: deflate，gzip </em>”请求头来明确地请求来自服务器的压缩响应。</p><h2 id="525a" class="nj mn jg bd mo nk nl dn ms nm nn dp mw le no np my li nq nr na lm ns nt nc nu bi translated">弹性搜索客户端(Python)</h2><p id="8b89" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><a class="ae jd" href="https://www.elastic.co/elasticsearch/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>是一个分布式的、<strong class="kx jh"> RESTful </strong>搜索和分析引擎。如果您正在使用<a class="ae jd" href="https://elasticsearch-py.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Python Elasticsearch客户端</a>，您可以<a class="ae jd" href="https://elasticsearch-py.readthedocs.io/en/stable/#compression" rel="noopener ugc nofollow" target="_blank">在客户端实例化中启用</a>压缩:</p><pre class="mh mi mj mk gt nv nw nx ny aw nz bi"><span id="ccd2" class="nj mn jg nw b gy oa ob l oc od"><strong class="nw jh">from</strong> <strong class="nw jh">elasticsearch</strong> <strong class="nw jh">import</strong> Elasticsearch<br/>es = Elasticsearch(hosts, http_compress=<strong class="nw jh">True</strong>)</span></pre><h2 id="8951" class="nj mn jg bd mo nk nl dn ms nm nn dp mw le no np my li nq nr na lm ns nt nc nu bi translated">其他客户</h2><p id="e300" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">请求压缩响应的最简单方法是在请求中添加“<em class="lr"> Accept-Encoding: deflate，gzip </em>”头字段。一些客户端在默认情况下会这样做，大多数客户端也会自动为您解压缩响应。</p><h1 id="6e2d" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">一周后回到我们的服务</h1><p id="a68d" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">一张图胜过千言万语，所以这里有一些我们的负载平衡器的截图:</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/8d473be8f01fc4cf66c0d19d18011d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-bD6IGLJZfMVzt4-APvmw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">(图片由作者提供)</figcaption></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/879c13c257fa73e160f8f6b650ad4be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXOHHlYTPF-3jaozjk-IMA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">(图片由作者提供)</figcaption></figure><h1 id="f736" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">观察</h1><ol class=""><li id="458b" class="ls lt jg kx b ky ne lb nf le or li os lm ot lq oe ly lz ma bi translated">压缩级别— gzip支持从1(最小压缩)到9(最大压缩)的压缩级别。调整该级别是在压缩时间和结果大小之间的权衡。压缩是CPU密集型工作，因此请确保您也在监控CPU利用率。比如在Elasticsearch中，你可以通过<a class="ae jd" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-http.html#_http_settings" rel="noopener ugc nofollow" target="_blank"> HTTP设置</a>中的<em class="lr"> http.compression_level </em>进行配置。所有其他网络服务器也允许配置这个值。</li><li id="ff75" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq oe ly lz ma bi translated">Brotli是(相对)镇上的新人，最初的<a class="ae jd" href="https://en.wikipedia.org/wiki/Brotli" rel="noopener ugc nofollow" target="_blank">于2013年</a>上映。另一方面，gzip从90年代早期的<a class="ae jd" href="https://en.wikipedia.org/wiki/Gzip" rel="noopener ugc nofollow" target="_blank">到现在</a>。虽然很多基准测试表明Brotli甚至可以比gzip做得更好，但是在你的web服务器框架上配置Brotli可能更棘手，需要更多的工作。</li><li id="0646" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq oe ly lz ma bi translated">我们需要区分静态内容和动态内容，前者可以预先以更高的压缩级别进行压缩，后者就像我们的RESTful API一样，会为每个请求生成不同的响应，并且需要尽可能快地提供服务。</li><li id="cd98" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq oe ly lz ma bi translated">对于带宽有限或互联网连接速度较慢的区域，压缩最为有效。在这种情况下，最终用户体验将是最佳的！</li><li id="497d" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq oe ly lz ma bi translated">如果您使用CDN，请确保它配置正确，并且支持压缩算法。如果你正在使用一个反向代理(例如nginx ),你可能想把gzip编码委托给它。</li><li id="9b4e" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq oe ly lz ma bi translated">遵循REST原则和最佳实践，在需要获取数据时使用GET。在GET方法中，您将享受到HTTP <strong class="kx jh"> 304未修改的</strong>响应代码，它节省了数据传输，最终节省了时间&amp;金钱(更多细节<a class="ae jd" href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers#conditional-requests" rel="noopener ugc nofollow" target="_blank">在此</a>)。</li></ol><h1 id="5d2e" class="mm mn jg bd mo mp mq mr ms mt mu mv mw km mx kn my kp mz kq na ks nb kt nc nd bi translated">摘要</h1><p id="c40b" class="pw-post-body-paragraph kv kw jg kx b ky ne kh la lb nf kk ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在这篇文章中，我们看到了为HTTP web服务器和客户端启用压缩支持是多么容易。默认情况下，所有现代web浏览器都要求压缩响应，这是有原因的。虽然它带来了更高的CPU利用率，但在你的网站上没有什么比快速的用户体验更好的了。</p></div></div>    
</body>
</html>