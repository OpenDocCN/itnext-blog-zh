<html>
<head>
<title>Improving slow mounts in React apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改善React应用中的缓慢装载</h1>
<blockquote>原文：<a href="https://itnext.io/improving-slow-mounts-in-react-apps-cff5117696dc?source=collection_archive---------1-----------------------#2021-05-02">https://itnext.io/improving-slow-mounts-in-react-apps-cff5117696dc?source=collection_archive---------1-----------------------#2021-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d31ce7fefaede519cf14f76068c58741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pt6LscB7W0Jq-SqdSWjFtg.jpeg"/></div></div></figure><p id="e52e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/what-to-do-when-your-react-app-feels-slow-3744c966ddf">百万篇文章</a>关注如何通过移除不必要的重新渲染来提高应用速度&amp;防止不必要的组件更新，但是没有一篇文章谈到一个必要的渲染:初始挂载。</p><h2 id="2e82" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">介绍</h2><p id="e0ce" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">这是因为有一种理论认为在那里做不了多少事情。当你有一个空屏幕，你想渲染一个组件，你必须支付它的挂载价格。这包括React需要做的创建<a class="ae kw" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank">虚拟DOM </a>的工作，以及HTML 的实际<a class="ae kw" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">渲染。大多数时候，这个时间量是可以忽略的，甚至不会被人眼察觉。但是，有时您必须呈现由大量其他子组件组成的组件列表，这迫使React在您可以看到屏幕上的内容之前进行大量的工作&amp;计算。你知道我在说什么吗？当你导航到一个特定的页面或标签，你感觉你的导航没有100%的响应时，就是这组项目被渲染；就好像在你点击链接和显示你想要的东西之间有一个时间差。</a></p><p id="b44c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们开发人员将短语“组件列表”放在“性能问题”旁边时，我们的思维被训练成思考“窗口和虚拟化”。虽然虚拟列表<strong class="ka ir">在某些情况下可能是答案，但是在某些情况下，项目列表不够大，不足以保证使用这种技术。在这些情况下，虚拟化库的内部计算比我们一次渲染整个项目列表的成本要高得多。想象一个由20张脸书/推特卡片组成的列表，每张卡片由100个子组件组成，一个屏幕可以同时显示5-6张脸书/推特卡片。大多数情况下，一次渲染全部20张卡片比根据滚动位置进行必要的基于滚动的计算来渲染正确的<strong class="ka ir">卡片更容易。</strong></strong></p><p id="27ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个好的思路是让你确认你只渲染屏幕上可见的东西，而把任何不可见的东西(比如模态、弹出窗口、工具提示)留到以后，这样就限制了React必须在幕后维护的组件树的深度。这是一个很棒的技术，肯定会产生效果，但是如果在这个领域没有什么可做的了呢？如果实际的延迟来自于组件组成、React上下文读取、客户端缓存条目识别和反规范化、昂贵的计算等等，那该怎么办？？</p><h2 id="81d2" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">方法</h2><p id="89d5" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">如果你在屏幕后面点头表示同意，那么你需要的是推迟渲染。我听到你问这是什么？嗯，这是一种声明性地延迟某些组件的呈现的能力，以便将单个阻塞React工作负载分割成更小的块。就是说反应“几毫秒后渲染那个组件没问题，我不介意”的选项。这实际上是将React渲染20个昂贵组件所需的200毫秒分割成50毫秒的块，每次渲染5个组件。</p><p id="ff9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这并不意味着我们并行渲染，因为JS仍然是单线程的。我们所做的是将这些渲染块一个接一个地排队，同时在它们之间留出用户输入的空间。类似于Webpack思想，理想的块大小取决于组件的数量和复杂性。在上面的例子中，使用10个由2个组件组成的渲染块可能比使用2个由10个组件组成的渲染块更好。您需要自己测试它，为您的特定组件集找到块大小的最佳点。</p><p id="48e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们如何实现这一点呢？嗯，其实超级简单。我们取一个项目列表，把它分成块，呈现第一个块，让给用户，呈现第二个块，让给用户，等等。我们需要的是在渲染过程的暂停和恢复之间交替。在JS领域，这被翻译成<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">微任务</strong> </a>。我们渲染一些项目，将一个任务排队以渲染更多的项目，等待这些项目被渲染，将另一个任务排队以渲染更多的项目，等等。所有这些都可以作为React实用程序组件来实现，如下所示:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">推迟其子组件呈现的实用程序组件</figcaption></figure><p id="106b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它可以这样使用:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">使用“延迟”一次渲染5张卡片</figcaption></figure><p id="1be7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面这段代码所做的是从立即呈现第一个项目块(给定为<code class="fe mf mg mh mi b">children</code>)开始，然后让一个微任务排队来呈现另一个项目块。每当主线程上有<a class="ae kw" href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback" rel="noopener ugc nofollow" target="_blank">空闲时间或经过200毫秒后(以先发生者为准),该微任务将被执行。这将持续到所有项目都被渲染。有趣的是，<code class="fe mf mg mh mi b">requestIdleCallback</code>只有在<code class="fe mf mg mh mi b">renderedItemsCount</code>改变时才会被注册，以试图限制同时存在于单个进程节拍中的微任务的数量。请记住，这个微任务最多有16毫秒的执行时间，这意味着理想的块渲染时间应该不超过16毫秒。如果微任务占用的时间明显更多，Chrome会发出控制台警告，但如果微任务占用的时间多一点，也不是世界末日。这种方法的UX优势超过了稍长的微任务的成本。</a></p><p id="96a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的是，这整个想法并不新鲜。事实上，这正是<a class="ae kw" href="https://github.com/acdlite/react-fiber-architecture/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> React在v16.x.x .及以上版本的引擎盖下</a>所做的。它有效地开始在一个微任务中渲染一个组件，不断地检查是否已经过了16毫秒，如果已经过了16毫秒就暂停所有当前的工作，并在事件循环的下一个滴答中从它停止的地方继续。有趣的是，相同的逻辑可以应用于这两种情况，只是在不同的层上。</p><h2 id="7dbe" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">结束语</h2><p id="fd0e" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我在这里的总体目标是介绍一种技术，以帮助增加你的UX时，安装沉重的组件。事实上，这种方法并不局限于列表。通过指定<code class="fe mf mg mh mi b">chunkSize={1}</code>,您也可以将它用于单个组件，从而将某个“沉重”部分的渲染延迟得足够短，以至于用户不会察觉到它，但是延迟得足够长，以消除整个组件安装上的任何滞后。</p><p id="ba86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想看这个的演示，我已经链接了一个展示这个的代码沙箱。这个演示是故意滞后的，目的是清楚地展示这两种方法的区别。</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="mj ma l"/></div></figure><p id="cc85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保你和<code class="fe mf mg mh mi b">chunkSize</code>一起玩，看看什么对你来说感觉更好。</p><p id="8105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢你的阅读！</p><p id="8675" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="mk"/></strong>👋<strong class="ka ir"> <em class="mk">嗨，我是</em></strong><a class="ae kw" href="https://aggelosarvanitakis.me/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mk">Aggelos</em></strong></a><strong class="ka ir"><em class="mk">！如果你喜欢这个，可以考虑在推特上关注我或者</em> </strong> <a class="ae kw" href="https://medium.com/@aggelosarvanitakis" rel="noopener"> <strong class="ka ir"> <em class="mk">中</em> </strong> </a> <strong class="ka ir"> <em class="mk"> </em>😀</strong></p></div></div>    
</body>
</html>