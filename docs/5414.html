<html>
<head>
<title>Flutter: An Easy and Pragmatic Approach to Navigator 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振:导航器2.0的简单实用方法</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-an-easy-and-pragmatic-approach-to-navigator-2-0-44152e73112f?source=collection_archive---------0-----------------------#2021-02-28">https://itnext.io/flutter-an-easy-and-pragmatic-approach-to-navigator-2-0-44152e73112f?source=collection_archive---------0-----------------------#2021-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6c7dcf80fcfe859d3350527088753253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwSkBTxbi8F9tc41E98ung.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="9d71" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">尽管乍看起来令人生畏，但进化的颤振导航系统可以解决比它看起来更多的问题</h2></div><p id="0675" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在2020年下半年，颤振团队推出了一个改进的导航和路由系统，名为<a class="ae lm" href="https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit" rel="noopener ugc nofollow" target="_blank"> Navigator 2.0 </a>。到目前为止，开发人员社区的反应还不是很好:<a class="ae lm" href="https://github.com/flutter/flutter/issues/69315" rel="noopener ugc nofollow" target="_blank">主要的批评</a>是关于API的复杂性和缺少一个用于常见场景的额外抽象层。</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/e8dd1fc747c6944c983b20d52729e3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1FIYRq8EZrVOEWnpMNHDQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">约翰·瑞安写的<a class="ae lm" href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade" rel="noopener">伟大的文章</a>深入分析了Navigator 2.0的复杂性和完整性</figcaption></figure><p id="eeb8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">此外，命名一直很糟糕:<em class="lw"> Navigator 2.0 </em>听起来像是一项胜过其前身——<em class="lw">Navigator 1.0</em>的技术——但事实并非如此。只要你愿意，你仍然可以使用<code class="fe lx ly lz ma b">Navigator.push</code>。这并不意味着您不会失去新API带来的许多优势，例如:</p><ul class=""><li id="1d24" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated">一种更为多变的声明式风格；</li><li id="3ab0" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">更好地支持屏幕更换；</li><li id="045c" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">更好地支持多次推送和弹出；</li><li id="4a49" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">全面支持传入网址(如:Flutter Web和/或app深度链接)；</li><li id="c162" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">使用Flutter Web时完全支持浏览器历史。</li></ul><h2 id="94f8" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">务实的方法</h2><p id="6e69" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">我不想在技术细节上花太多时间，但是我想直接进入一个方便的解决方案。出于学习的目的，我想创建一个带有底部标签和潜在的无限系列页面的应用程序。</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4d506f039f7e81fd1bba3f00950d46bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/1*WFuxwNoC-2Wral4cEUuPBA.gif"/></div></figure><h2 id="31ad" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">页面建模</h2><p id="30b9" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">首先，让我们选择一个好的抽象来建模用户可以导航的页面。直接使用Flutter <code class="fe lx ly lz ma b">Page</code>会违背抽象过程，所以我将使用一个数据模型，该模型使用由<a class="ae lm" href="https://pub.dev/packages/freezed" rel="noopener ugc nofollow" target="_blank"> frezeed package </a>提供的极好的<a class="ae lm" href="https://pub.dev/packages/freezed#unionssealed-classes" rel="noopener ugc nofollow" target="_blank">联合类</a>:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">要进一步了解freezed，请阅读我的另一篇文章，<a class="ae lm" href="https://levelup.gitconnected.com/flutter-dart-immutable-objects-and-values-5e321c4c654e" rel="noopener ugc nofollow" target="_blank"> Flutter: Dart不可变对象和值</a></figcaption></figure><ul class=""><li id="6be0" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStackItem.notFound</code>代表<em class="lw"> 404 </em>页面；</li><li id="091c" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStackItem.appSection</code>代表一个选中的底栏标签；</li><li id="f038" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStackItem.ingredient</code>代表配料详情页；</li><li id="6400" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStackItem.recipe</code>代表菜谱详情页。</li></ul><h2 id="d0af" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">建模用户动作</h2><p id="95c4" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">反映用户在导航期间可能做出的动作的最佳数据结构是堆栈:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">请注意，我们总是希望保留条目列表的副本，因为Dart列表不是不可变的</figcaption></figure><ul class=""><li id="f31f" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">push</code>对应于推送到导航栈上的新屏幕；</li><li id="b7e6" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">pop</code>对应从导航栈弹出的一个屏幕；</li><li id="47d0" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">总是可以通过设置<code class="fe lx ly lz ma b">items</code>属性来替换整个导航栈。这可能有多种原因，如一次弹出或推送多个页面，从深层页面更改底部选项卡选择，甚至在当前屏幕前推送页面。</li></ul><h2 id="fb7f" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">使导航堆栈可访问</h2><p id="6b56" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">主导航堆栈将是顶部应用程序状态的一部分。我选择采用来自<a class="ae lm" href="https://pub.dev/packages/riverpod" rel="noopener ugc nofollow" target="_blank"> riverpod包</a>的<code class="fe lx ly lz ma b">ChangeNotifierProvider</code>,而不是使用单例变量——或者更糟糕的全局变量:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">第一个堆栈内容是第一个选定的底部选项卡</figcaption></figure><p id="cb16" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦正确配置了插件，访问导航栈就很简单了。要从一个小部件推送配料详情页面，很简单，如下所示:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="3c6b" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">将URL转换为项目堆栈</h2><p id="e50d" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">Flutter的<code class="fe lx ly lz ma b">RouteInformationParser</code>是用来来回转换输入URL的对象。</p><p id="bd3c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我想用一个格式是这样的URL:<code class="fe lx ly lz ma b">/section/ingredients/ingredient/1/recipe/2/ingredient/2</code>(以此类推)。解析它有点简单，因为这是一系列的键值对:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="db8c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">代码有点冗长，但也很简单:</p><ol class=""><li id="9125" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll nq mh mi mj bi translated">我首先将URL分解成它的组件。</li><li id="f28e" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll nq mh mi mj bi translated">我获取键-值对并验证接收到的标识符:如果值有效，我插入正确的<code class="fe lx ly lz ma b">NavigationStackItem</code>，否则我插入<code class="fe lx ly lz ma b">notFound</code>。</li><li id="0d38" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll nq mh mi mj bi translated">如果在循环结束时，我没有发现一个<code class="fe lx ly lz ma b">appSection</code>作为堆栈的第一项(例如:URL只有<code class="fe lx ly lz ma b">/</code>，我就把它放在前面。</li></ol><p id="f593" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从<code class="fe lx ly lz ma b">NavigationStack</code>到URL的转换非常简单，因为我们利用了<code class="fe lx ly lz ma b">when</code>结构，也是从冻结的包:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="f5e5" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">路由！</h2><p id="d76a" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">最后但同样重要的是，我们必须实际引导用户浏览页面。Flutter的<code class="fe lx ly lz ma b">RouterDelegate</code>是将<code class="fe lx ly lz ma b">NavigationStack</code>、<code class="fe lx ly lz ma b">RouterInformationParser</code>生成的数据和<code class="fe lx ly lz ma b">Navigator</code>小部件显示给用户的粘合剂。</p><p id="35a7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，我们需要能够接触到<code class="fe lx ly lz ma b">NavigationStack</code>。委托实例将观察它并对它的变化做出响应。</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="14e0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后，我们实际上通过实现<code class="fe lx ly lz ma b">build</code>方法将堆栈项目转换为Flutter的<code class="fe lx ly lz ma b">Page</code>实例:我们只需要返回一个<code class="fe lx ly lz ma b">Navigator</code>小部件，它具有一个固定的<code class="fe lx ly lz ma b">navigatorKey</code>和通过将堆栈项目映射到<code class="fe lx ly lz ma b">MaterialPage</code>对象而计算的<code class="fe lx ly lz ma b">pages</code>数组。<code class="fe lx ly lz ma b">onPopPage</code>实现——每当用户点击后退按钮时就会被调用——就像从观察堆栈中弹出一个项目一样简单。</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">如果您还没有识别出mapIndexed，不要担心:它只是Iterable的一个小型智能自定义扩展！</figcaption></figure><p id="1ad7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lx ly lz ma b">RouterDelegate</code>的最后一点告诉应用程序当新路线到来时该做什么，或者如何处理浏览器历史:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="67f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">传递给<code class="fe lx ly lz ma b">newRoutePath</code>方法的<code class="fe lx ly lz ma b">configuration</code>是在解析器中创建的实例:我们替换了托管堆栈中的<code class="fe lx ly lz ma b">items</code>,一切就绪。</p><h2 id="3202" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">最终应用程序</h2><p id="8b15" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">由于我们没有引入新概念，我们可以直接使用<code class="fe lx ly lz ma b">MaterialApp.router</code>便利法:</p><figure class="lo lp lq lr gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9a4d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">就是这样！如果您使用的是Flutter Web，它甚至可以处理浏览器历史记录:</p><figure class="lo lp lq lr gt is gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c1191eb8580bdc4e7971eb56e1aeb4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*rgN3ELbYEjNxvNY3nbFlQA.gif"/></div></figure><p id="4872" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可以通过访问GitHub repo 阅读并下载完整的例子。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h2 id="b71c" class="mp mq jb bd mr ms mt dn mu mv mw dp mx kz my mz na ld nb nc nd lh ne nf ng nh bi translated">还有一点</h2><p id="aa55" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">当我在写这个分析的时候，我注意到这些概念是非常通用和可重用的。那么，为什么不为我的(和你的)发布一个包呢？)下一个项目？<strong class="ks jc">我来介绍一下</strong> <a class="ae lm" href="https://pub.dev/packages/pragmatic_navigation" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> <em class="lw">务实_导航</em> </strong> </a> <strong class="ks jc">。它不是解决与导航2.0相关的所有问题的灵丹妙药，而是旨在成为更常见问题的轻量级解决方案的集合。</strong></p><p id="9a2e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个新包公开的第一组组件将包括本文中描述的概念:</p><ul class=""><li id="6964" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStack</code>是一个泛型类，用于保存您需要在应用程序状态时公开的堆栈项目；</li><li id="3ea5" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStackRouterInformationParser</code>是一个通用类，它实现了将URL组件解析为堆栈项的策略，反之亦然；</li><li id="f695" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated"><code class="fe lx ly lz ma b">NavigationStackRouterDelegate</code>是链接堆栈和解析器的通用类。</li></ul><p id="b195" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">更多细节请参考<a class="ae lm" href="https://github.com/muccy/flutter_pragmatic_navigation" rel="noopener ugc nofollow" target="_blank">包库主页</a>，但是如果你读到这里，你会有宾至如归的感觉。</p></div></div>    
</body>
</html>