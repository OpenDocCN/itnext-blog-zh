<html>
<head>
<title>Getting started with Kafka and Rust: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡夫卡与鲁斯特入门:第2部分</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-kafka-and-rust-part-2-129c372dc1ad?source=collection_archive---------2-----------------------#2021-04-14">https://itnext.io/getting-started-with-kafka-and-rust-part-2-129c372dc1ad?source=collection_archive---------2-----------------------#2021-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个实践指南，教你如何使用Rust编程语言与Kafka进行交互</h2></div><p id="8f4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个由两部分组成的系列，帮助您开始了解Rust和Kafka。我们将使用<a class="ae lb" href="https://github.com/fede1024/rust-rdkafka/" rel="noopener ugc nofollow" target="_blank"> rust-rdkafka </a>机箱，它本身基于<a class="ae lb" href="https://github.com/edenhill/librdkafka" rel="noopener ugc nofollow" target="_blank"> librdkafka </a> ( <code class="fe lc ld le lf b">C</code>库)。</p><p id="99f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将介绍Kafka消费者API。</p><p id="a70a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第一部分:</p><div class="lg lh gp gr li lj"><a href="https://abhishek1987.medium.com/getting-started-with-kafka-and-rust-part-1-e0074961ec6b" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd ir gy z fp lo fr fs lp fu fw ip bi translated">卡夫卡与鲁斯特入门:第1部分</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">一个实践指南，教你如何使用Rust编程语言与Kafka进行交互</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">abhishek1987.medium.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx ly lj"/></div></div></a></div><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/48489f4b9a64976b1c706f026cf268de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A1jGo1ilyW469KNG.png"/></div></div></figure><h1 id="dbc4" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">初始设置</h1><p id="a02a" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">确保你安装了一个Kafka代理——本地安装就足够了。当然，你也需要安装<a class="ae lb" href="https://www.rust-lang.org/tools/install" rel="noopener ugc nofollow" target="_blank">Rust</a>——你需要<a class="ae lb" href="https://github.com/fede1024/rust-rdkafka#minimum-supported-rust-version-msrv" rel="noopener ugc nofollow" target="_blank">1.45或更高版本</a></p><p id="212a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始之前，克隆GitHub repo:</p><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="60fb" class="nl ml iq lf b gy nm nn l no np">git clone https://github.com/abhirockzz/rust-kafka-101<br/>cd part2</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="060c" class="mk ml iq bd mm mn nx mp mq mr ny mt mu jw nz jx mw jz oa ka my kc ob kd na nb bi translated">简单消费者</h1><p id="81d1" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">创建一个低级消费者(<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/struct.BaseConsumer.html" rel="noopener ugc nofollow" target="_blank"> BaseConsumer </a>)与创建它的对应者——<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html" rel="noopener ugc nofollow" target="_blank">base producer</a>惊人地相似。唯一的区别是，您必须将输出转换为正确的类型(在本例中是<code class="fe lc ld le lf b">BaseConsumer</code>)</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi oc"><img src="../Images/2b8d380b84df13044b3bb7635c2aec0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJw5K0zHBigdIzbNI4t_2w.png"/></div></div></figure><blockquote class="od oe of"><p id="a871" class="kf kg og kh b ki kj jr kk kl km ju kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated"><em class="iq">注意，</em> <code class="fe lc ld le lf b"><em class="iq">group.id</em></code> <em class="iq"> config也被</em><code class="fe lc ld le lf b"><em class="iq">.set("group.id", "my_consumer_group")</em></code><em class="iq">——其强制。</em></p></blockquote><p id="732f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦创建了一个<code class="fe lc ld le lf b">BaseConsumer</code>，用户就可以订阅一个或多个主题(在本例中，只有一个名为<code class="fe lc ld le lf b">rust</code>的主题)。</p><p id="a4d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从主题中获取消息，我们启动(<a class="ae lb" href="https://doc.rust-lang.org/std/thread/fn.spawn.html" rel="noopener ugc nofollow" target="_blank"> spawn </a>)一个新的<code class="fe lc ld le lf b">thread</code>:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ok"><img src="../Images/85bea5f489f5e7aea07a81969c630622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqfSt3XdisSVNDIIN2eo1g.png"/></div></div></figure><p id="fc81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个<code class="fe lc ld le lf b">closure</code>，在这种情况下恰好是一个无限的<code class="fe lc ld le lf b">loop</code>:</p><ul class=""><li id="352a" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">接收消息，</li><li id="9073" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">打印出键、值以及偏移量和分区信息</li></ul><p id="7e4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在消费者上调用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/base_consumer/struct.BaseConsumer.html#method.iter" rel="noopener ugc nofollow" target="_blank"> iter </a>只是调用<code class="fe lc ld le lf b">poll</code>的一种捷径，没有任何超时。</p><p id="0eb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他变化也是可能的。可以直接用<code class="fe lc ld le lf b">poll</code>:</p><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="9605" class="nl ml iq lf b gy nm nn l no np">loop {<br/>  let message = consumer.poll(Duration::from_secs(2));<br/>    ...<br/>}</span></pre><p id="01e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，使用以下格式:</p><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="13e3" class="nl ml iq lf b gy nm nn l no np">for message in &amp;consumer {<br/>...<br/>}</span></pre><h2 id="3157" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">运行程序</h2><ul class=""><li id="9790" class="ol om iq kh b ki nc kl nd ko pk ks pl kw pm la oq or os ot bi translated">将文件<code class="fe lc ld le lf b">src/1_consumer_simple.rs</code>重命名为<code class="fe lc ld le lf b">main.rs</code>，并且</li><li id="5916" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">执行<code class="fe lc ld le lf b">cargo run</code></li></ul><p id="d23d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="cb65" class="nl ml iq lf b gy nm nn l no np">sending message<br/>sending message<br/>produced message with key user-1 in offset 25 of partition 2<br/>produced message with key user-2 in offset 12 of partition 4<br/>sending message<br/>produced message with key user-3 in offset 20 of partition 0<br/>received key user-3 with value User { id: 3, email: "user-3@foobar.com" } in offset 20 from partition 0<br/>sending message<br/>produced message with key user-4 in offset 24 of partition 3<br/>received key user-4 with value User { id: 4, email: "user-4@foobar.com" } in offset 24 from partition 3<br/>sending message<br/>produced message with key user-5 in offset 25 of partition 3<br/>received key user-5 with value User { id: 5, email: "user-5@foobar.com" } in offset 25 from partition 3<br/>sending message<br/>produced message with key user-6 in offset 26 of partition 3<br/>received key user-6 with value User { id: 6, email: "user-6@foobar.com" } in offset 26 from partition 3<br/>sending message<br/>produced message with key user-7 in offset 27 of partition 3<br/>received key user-7 with value User { id: 7, email: "user-7@foobar.com" } in offset 27 from partition 3</span></pre><p id="2e96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不出所料:</p><ul class=""><li id="7b3d" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">你会看到制作人的回电——确认信息被发送给了卡夫卡</li><li id="20a7" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">消费者也收到了该消息，日志对此进行了确认</li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="691d" class="mk ml iq bd mm mn nx mp mq mr ny mt mu jw nz jx mw jz oa ka my kc ob kd na nb bi translated">消费者回访怎么办？</h1><p id="9849" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">是的，就像生产者一样，消费者API也有回调函数:</p><ul class=""><li id="b53a" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">重新平衡</li><li id="9984" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">偏移提交</li></ul><p id="df29" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们需要实现<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/trait.ConsumerContext.html" rel="noopener ugc nofollow" target="_blank"> ConsumerContext </a>特征。我们将:</p><ul class=""><li id="4635" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">定义一个<code class="fe lc ld le lf b">struct</code></li><li id="b606" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">为<code class="fe lc ld le lf b">ClientContext</code>提供一个空的实现</li><li id="ed76" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">从<code class="fe lc ld le lf b">ConsumerContext</code>trait-<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/trait.ConsumerContext.html#method.pre_rebalance" rel="noopener ugc nofollow" target="_blank">pre _ rebalance</a>，<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/trait.ConsumerContext.html#method.post_rebalance" rel="noopener ugc nofollow" target="_blank"> post_rebalance </a>，<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/trait.ConsumerContext.html#method.commit_callback" rel="noopener ugc nofollow" target="_blank"> commit_callback </a>中覆盖以下方法</li></ul><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pn"><img src="../Images/46bba87431eb2d103544a13382805fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xVFYXRkyUuDzf5wHnETwg.png"/></div></div></figure><blockquote class="od oe of"><p id="997b" class="kf kg og kh b ki kj jr kk kl km ju kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated"><em class="iq">我们将跳过</em> <code class="fe lc ld le lf b"><em class="iq">pre_rebalance</em></code> <em class="iq">方法，重点关注本例中的</em><code class="fe lc ld le lf b"><em class="iq">post_rebalance</em></code><em class="iq">:</em></p></blockquote><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi po"><img src="../Images/728da195583d2d37c3151e3b6944cdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3s-Ey4RmIeCsGEoMwcxktg.png"/></div></div></figure><p id="4774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/enum.Rebalance.html" rel="noopener ugc nofollow" target="_blank">再平衡</a>是一个<code class="fe lc ld le lf b">enum</code>。作为实现的一部分，我们将它与所有可能的选项(分配的分区、撤销的分区、重新平衡错误)进行匹配，并简单地记录它。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pp"><img src="../Images/0df8559a38c60b2d8002325badd9e060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJLP_hDOK7xaWfppg0Z4Vw.png"/></div></div></figure><p id="b2ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于提交回调事件，我们在<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/error/type.KafkaResult.html" rel="noopener ugc nofollow" target="_blank"> KafkaResult </a>(在<code class="fe lc ld le lf b">commit_callback</code>参数中可用)上进行匹配，以检查提交是否成功。如果是，我们只需打印出分区中提交的偏移量，或者记录提交过程中发生的错误。</p><p id="763c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们只需插入新的实现:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pq"><img src="../Images/db288116b14146859bb86b363ae88f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ptO6fhaI1EM57GZRZmZvg.png"/></div></div></figure><p id="a4f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们做了一些改变:</p><ul class=""><li id="2390" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">使用<code class="fe lc ld le lf b">create_with_context</code>(而不是<code class="fe lc ld le lf b">create</code>)</li><li id="17bb" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">使用<code class="fe lc ld le lf b">BaseConsumer&lt;ConsumerCallbackLogger&gt;</code></li></ul><h2 id="d81e" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">运行程序</h2><ul class=""><li id="b4b3" class="ol om iq kh b ki nc kl nd ko pk ks pl kw pm la oq or os ot bi translated">将文件<code class="fe lc ld le lf b">src/2_consumer_callback.rs</code>重命名为<code class="fe lc ld le lf b">main.rs</code>，并且</li><li id="58ec" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">执行<code class="fe lc ld le lf b">cargo run</code></li></ul><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="5a82" class="nl ml iq lf b gy nm nn l no np">sending message<br/>sending message<br/>produced message with key user-1 in offset 0 of partition 2<br/>post_rebalance callback<br/>rebalanced partition 0<br/>rebalanced partition 1<br/>rebalanced partition 2<br/>rebalanced partition 3<br/>rebalanced partition 4<br/>rebalanced partition 5<br/>produced message with key user-2 in offset 0 of partition 4<br/>sending message<br/>produced message with key user-3 in offset 0 of partition 0<br/>received key user-3 with value User { id: 3, email: "user-3@foobar.com" } in offset 0 from partition 0<br/>sending message<br/>committed offset Offset(1) in partition 0<br/>committed offset Offset(1) in partition 4<br/>produced message with key user-4 in offset 0 of partition 3<br/>received key user-4 with value User { id: 4, email: "user-4@foobar.com" } in offset 0 from partition 3</span></pre><p id="175a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如所料，重新平衡事件与成功的提交一起被记录。</p><h2 id="7ffe" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">引发重新平衡</h2><p id="340f" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">由于我们的<code class="fe lc ld le lf b">ConsumerContext</code>实现，当您启动应用程序时，分区分配第一次发生，您能够见证这一点。您也可以通过启动应用程序的新实例来再次触发重新平衡。由于在同一个使用者组中有两个实例，主题分区将被重新平衡。例如，如果主题中有<code class="fe lc ld le lf b">6</code>分区，它们将在这两个实例中平均分配。</p><p id="22ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到类似以下内容的日志消息:</p><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="08ac" class="nl ml iq lf b gy nm nn l no np">....<br/># instance 1<br/>post_rebalance callback<br/>rebalanced partition 0<br/>rebalanced partition 1<br/>rebalanced partition 2<br/>...</span><span id="9553" class="nl ml iq lf b gy pr nn l no np"># instance 2<br/>post_rebalance callback<br/>rebalanced partition 3<br/>rebalanced partition 4<br/>rebalanced partition 5</span></pre></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="2322" class="mk ml iq bd mm mn nx mp mq mr ny mt mu jw nz jx mw jz oa ka my kc ob kd na nb bi translated">切换到手动提交</h1><p id="0a82" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">默认情况下，偏移量提交过程由库本身负责。但是我们可以通过切换到手动模式对它进行更多的控制。</p><p id="d1e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先要做的是将<code class="fe lc ld le lf b">enable.auto.commit</code>设置为<code class="fe lc ld le lf b">false</code> - <code class="fe lc ld le lf b">set("enable.auto.commit", "false");</code></p><h2 id="4bee" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">至少一次交货</h2><p id="a033" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">为了实现这一点，我们需要确保在提交偏移量之前<em class="og">我们确实成功地处理了消息。为了模拟这一点，让我们编写一个可以随机失败的函数(名为<code class="fe lc ld le lf b">process</code>)。然后，我们将在我们的消费者循环中使用这个函数，当这个函数成功返回时，只提交<em class="og"/>。</em></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ps"><img src="../Images/2b87da1e2876ff5d01765af5712c99ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHVxX2e3Rjt_xWg1j12AMw.png"/></div></div></figure><p id="97d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要改变我们的消费圈</p><ul class=""><li id="0d8c" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">基于来自<code class="fe lc ld le lf b">process</code>功能的响应添加手动偏移提交</li><li id="2b68" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">给我们的线程循环添加一个标签(<code class="fe lc ld le lf b">'consumer_thread</code>)</li></ul><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi pt"><img src="../Images/de45a44fa4261bbe0f7d58d01195bea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5X1b6FqPYKengtDrXKTxVg.png"/></div></div></figure><p id="6ef3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为<code class="fe lc ld le lf b">process</code>——这是为了模拟消费者收到的每个记录的处理。如果处理成功(返回<code class="fe lc ld le lf b">Ok</code>，我们使用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/struct.BaseConsumer.html#method.commit_message" rel="noopener ugc nofollow" target="_blank"> commit_message </a>提交记录。</p><blockquote class="od oe of"><p id="818f" class="kf kg og kh b ki kj jr kk kl km ju kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated">请注意，提交本身可能会失败。这最好在 <code class="fe lc ld le lf b"><em class="iq">ConsumerContext</em></code>的 <code class="fe lc ld le lf b"><em class="iq">commit_callback</em></code> <em class="iq">实现中处理</em></p></blockquote><h2 id="8d31" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">运行程序</h2><ul class=""><li id="58d6" class="ol om iq kh b ki nc kl nd ko pk ks pl kw pm la oq or os ot bi translated">将文件<code class="fe lc ld le lf b">src/3_manual_commit.rs</code>重命名为<code class="fe lc ld le lf b">main.rs</code>，并且</li><li id="1be1" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">执行<code class="fe lc ld le lf b">cargo run</code></li></ul><p id="f5e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序输出冗长，请多包涵。</p><p id="851f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出:</p><pre class="ma mb mc md gt nh lf ni nj aw nk bi"><span id="7c17" class="nl ml iq lf b gy nm nn l no np">produced message with key user-1 in offset 22 of partition 2<br/>produced message with key user-2 in offset 28 of partition 4<br/>post_rebalance callback<br/>rebalanced partition 0<br/>rebalanced partition 1<br/>rebalanced partition 2<br/>rebalanced partition 3<br/>rebalanced partition 4<br/>rebalanced partition 5<br/>received key user-5 with value User { id: 5, email: "user-5@foobar.com" } in offset 52 from partition 3<br/>SUCCESSFULLY processed User info User { id: 5, email: "user-5@foobar.com" }<br/>committed offset Offset(53) in partition 3<br/>received key user-2 with value User { id: 2, email: "user-2@foobar.com" } in offset 28 from partition 4<br/>SUCCESSFULLY processed User info User { id: 2, email: "user-2@foobar.com" }<br/>produced message with key user-3 in offset 35 of partition 0<br/>committed offset Offset(29) in partition 4<br/>received key user-1 with value User { id: 1, email: "user-1@foobar.com" } in offset 22 from partition 2<br/>FAILED to process User info User { id: 1, email: "user-1@foobar.com" }<br/>loop encountered processing error. closing consumer...<br/>post_rebalance callback<br/>ALL partitions have been REVOKED</span></pre><p id="943c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe lc ld le lf b">process</code>成功返回时的日志信息:</p><ol class=""><li id="8a64" class="ol om iq kh b ki kj kl km ko on ks oo kw op la pu or os ot bi translated">从分区3的偏移量52中接收到值为用户{ id: 5，电子邮件:"<a class="ae lb" href="mailto:user-5@foobar.com" rel="noopener ugc nofollow" target="_blank">user-5@foobar.com</a>" }的密钥用户-5</li><li id="18f5" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la pu or os ot bi translated">已成功处理用户信息用户{ id: 5，电子邮件:"<a class="ae lb" href="mailto:user-5@foobar.com" rel="noopener ugc nofollow" target="_blank">user-5@foobar.com</a>" }</li><li id="15c2" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la pu or os ot bi translated">分区3中的提交偏移量Offset(52)</li></ol><p id="2065" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于故障场景:</p><ol class=""><li id="962e" class="ol om iq kh b ki kj kl km ko on ks oo kw op la pu or os ot bi translated">从分区2的偏移量22接收到值为User { id: 1，email:"<a class="ae lb" href="mailto:user-1@foobar.com" rel="noopener ugc nofollow" target="_blank">user-1@foobar.com</a>" }的密钥user-1</li><li id="8eb5" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la pu or os ot bi translated">无法处理用户{ id: 1，电子邮件:"<a class="ae lb" href="mailto:user-1@foobar.com" rel="noopener ugc nofollow" target="_blank">user-1@foobar.com</a>" }的用户信息</li><li id="975c" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la pu or os ot bi translated">循环遇到处理错误。关闭消费者…</li></ol><p id="e0df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当处理失败时，我们最终停止了消费者？这里的问题是:</p><h2 id="e3ce" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">如何处理未被处理的消息？</h2><p id="32d7" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">请注意，失败可能由多种原因造成。其中一些是:</p><ul class=""><li id="f168" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">处理失败(这就是我们在本例中模拟的情况)，或者，</li><li id="336e" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">处理成功，但提交失败</li></ul><p id="5ee6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在失败的消息后继续我们的消费者循环，我们可能会丢失消息(数据丢失)。<strong class="kh ir">为什么？</strong>这是因为<code class="fe lc ld le lf b">commit_message</code>方法也将较小的偏移量(小于正在处理的偏移量)标记为已提交。例如，如果您有一个场景，其中来自分区<code class="fe lc ld le lf b">5</code>的偏移量<code class="fe lc ld le lf b">20</code>未能被处理(和提交)，您继续处理并且来自分区<code class="fe lc ld le lf b">5</code>的偏移量<code class="fe lc ld le lf b">21</code>被成功处理和提交，您将最终丢失来自偏移量<code class="fe lc ld le lf b">20</code>的数据——这是因为提交偏移量<code class="fe lc ld le lf b">21</code>也将提交偏移量<code class="fe lc ld le lf b">20</code>和更低的偏移量。即使在您重新启动应用程序后，这也不会被检测到。</p><h2 id="0ac7" class="nl ml iq bd mm oz pa dn mq pb pc dp mu ko pd pe mw ks pf pg my kw ph pi na pj bi translated">为了防止这种情况…</h2><p id="0780" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">您可以:</p><ul class=""><li id="8ab0" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">在检测到第一个故障后，暂停消费者进程。在本例中，我们通过退出消费者线程本身来实现这一点(尽管这对于现实世界的应用程序来说是不可接受的)。当您重新启动应用程序时，处理将从最后提交的偏移量开始，失败的消息将被拾取并重新处理。</li><li id="eb35" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">更好的是——您可以在<code class="fe lc ld le lf b">commit_callback</code>中通过将这些数据发送到另一个可以单独处理的Kafka主题(也称为“死信主题”)来处理这个问题。</li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="e112" class="mk ml iq bd mm mn nx mp mq mr ny mt mu jw nz jx mw jz oa ka my kc ob kd na nb bi translated">其他考虑</h1><p id="7f14" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这绝不是所有交付语义的详尽列表或覆盖范围:</p><ul class=""><li id="12e8" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">我们没有报道<code class="fe lc ld le lf b">at-most once</code>和<code class="fe lc ld le lf b">exactly once</code>。</li><li id="14bb" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">你可能想选择使用<a class="ae lb" href="https://docs.rs/rdkafka/0.26.0/rdkafka/consumer/enum.CommitMode.html#variant.Async" rel="noopener ugc nofollow" target="_blank">异步</a>提交模式——这有它自己的一套警告。</li><li id="a2dd" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">提交每一条消息(即使是异步的)都会带来开销。您可能希望成批提交消息/偏移量。和往常一样，您还需要处理许多棘手的问题。</li></ul><h1 id="1727" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">包裹</h1><p id="612f" class="pw-post-body-paragraph kf kg iq kh b ki nc jr kk kl nd ju kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这就是关于使用<code class="fe lc ld le lf b">rust-rdkafka</code>库开始使用Rust和Kafka的两部分系列的全部内容！在这一部分中，我们讨论了:</p><ul class=""><li id="8307" class="ol om iq kh b ki kj kl km ko on ks oo kw op la oq or os ot bi translated">简单的生产者</li><li id="32a8" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">具有交付回调的生产者</li><li id="5496" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">如何发送JSON有效负载</li><li id="0a3f" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">基本消费者</li><li id="b4d6" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">处理重新平衡和偏移提交回调</li><li id="b22f" class="ol om iq kh b ki ou kl ov ko ow ks ox kw oy la oq or os ot bi translated">探索手动提交和至少一次交付语义</li></ul></div></div>    
</body>
</html>