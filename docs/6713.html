<html>
<head>
<title>MikroORM 5: Stricter, Safer, Smarter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MikroORM 5:更严格、更安全、更智能</h1>
<blockquote>原文：<a href="https://itnext.io/mikro-orm-5-stricter-safer-smarter-b8412e84cca4?source=collection_archive---------2-----------------------#2022-02-06">https://itnext.io/mikro-orm-5-stricter-safer-smarter-b8412e84cca4?source=collection_archive---------2-----------------------#2022-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="39cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MikroORM的下一个主要版本刚刚发布。题目说:更严格，更安全，更聪明——为什么？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/d296387739508f0d63dc32217a8a6785.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/0*atMJ3hrlUosSpnQy.jpg"/></div></figure><ul class=""><li id="7afd" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">大大提高了类型安全性(例如，填充和部分加载提示)</li><li id="053d" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">自动刷新模式(这样我们就不会丢失内存中的更改)</li><li id="9244" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">自动刷新加载的实体(对<code class="fe lh li lj lk b">refresh: true</code>说再见)</li><li id="ef23" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">修改了模式差异，支持自动向下迁移</li><li id="bcf0" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">还有更多更多的 …</li></ul><blockquote class="lm ln lo"><p id="fe08" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">这一次花了将近一年的时间——V5的初始工作开始于2021年3月<a class="ae ll" href="https://github.com/mikro-orm/mikro-orm/issues/1623" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><h1 id="08e9" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">以防你不知道…</h1><p id="3cb9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果你从未听说过<a class="ae ll" href="https://github.com/mikro-orm/mikro-orm" rel="noopener ugc nofollow" target="_blank">mikro RM</a>，它是一个带有工作单元和身份映射的类型化数据映射ORM。它目前支持MongoDB、MySQL、PostgreSQL和SQLite驱动程序。ORM的主要特点是:</p><ul class=""><li id="9d7d" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><a class="ae ll" href="https://github.com/mikro-orm/mikro-orm#implicit-transactions" rel="noopener ugc nofollow" target="_blank">隐性交易</a></li><li id="a01b" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae ll" href="https://github.com/mikro-orm/mikro-orm#changeset-based-persistence" rel="noopener ugc nofollow" target="_blank">基于变更集的持久性</a></li><li id="961a" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae ll" href="https://mikro-orm.io/docs/identity-map/" rel="noopener ugc nofollow" target="_blank">身份地图</a></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/e2640baf18330045f5febbf3f6a69b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fKozvvTJns0y3w5U.png"/></div></div></figure><p id="abb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里阅读完整的<a class="ae ll" href="https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02" rel="noopener">介绍性文章</a>(但是请注意，自那篇文章发表以来，许多事情已经发生了变化)或者浏览文档。</p><h1 id="fc1d" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">4.x版本的快速摘要</h1><p id="faa5" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在我们深入了解v5之前，让我们回顾一下4.x版本中发生了什么:</p><ul class=""><li id="d6cc" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><a class="ae ll" href="https://mikro-orm.io/docs/caching/" rel="noopener ugc nofollow" target="_blank">结果缓存</a></li><li id="3283" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae ll" href="https://github.com/mikro-orm/mikro-orm/pull/959" rel="noopener ugc nofollow" target="_blank">自动交易上下文</a></li><li id="cab2" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae ll" href="https://mikro-orm.io/docs/embeddables/#nested-embeddables" rel="noopener ugc nofollow" target="_blank">嵌套的可嵌入内容</a>以及该领域的许多其他改进</li><li id="570e" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><a class="ae ll" href="https://mikro-orm.io/docs/configuration/#using-environment-variables" rel="noopener ugc nofollow" target="_blank">使用环境变量进行配置</a></li></ul><p id="a19d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">历史课已经讲够了，让我们来谈谈未来吧！</p><h1 id="bfa4" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">改进的类型安全性</h1><p id="a0a5" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">让我们直接进入最有趣的特性——几乎到处都是严格的类型！<code class="fe lh li lj lk b">em.create()</code>、<code class="fe lh li lj lk b">toJSON()</code>、<code class="fe lh li lj lk b">toObject()</code>、填充、部分加载和提示排序，所有这些(甚至更多！)现在严格打字。</p><p id="fc06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看下面的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="af55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们使用<code class="fe lh li lj lk b">em.create()</code>在一个步骤中构建整个实体图。它将验证有效负载的类型和可选性。实体上的一些属性可能有通过钩子或数据库函数提供的默认值——虽然我们可能想将它们定义为必需的属性，但它们在<code class="fe lh li lj lk b">em.create()</code>的上下文中应该是可选的。为了解决这个问题，我们可以通过<code class="fe lh li lj lk b">OptionalProps</code>符号来指定应该被认为是可选的属性:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="lm ln lo"><p id="dab8" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">有些属性名总是被认为是可选的:<code class="fe lh li lj lk b">id</code>、<code class="fe lh li lj lk b">_id</code>、<code class="fe lh li lj lk b">uuid</code>。</p></blockquote><p id="2981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们加载所有的<code class="fe lh li lj lk b">Author</code>实体，填充它们的图书和图书标签。这里所有的<code class="fe lh li lj lk b">FindOptions</code>都是严格类型化的，此外，我们甚至可以跳过<code class="fe lh li lj lk b">populate</code>提示，因为它可以从<code class="fe lh li lj lk b">fields</code>选项中自动推断出来。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/4dffb94c45ea336f6f9cb13423f65d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*3g12H4O5KrzmQMrk.jpg"/></div></figure><p id="0eb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可能仍然需要一些dto的类型转换。实体的序列化形式可能非常不可预测——有许多变量定义了实体将如何序列化，例如加载的关系与引用、属性序列化程序、惰性属性、自定义实体序列化程序/ <code class="fe lh li lj lk b">toJSON</code>方法、急切加载、递归检查……因此，<code class="fe lh li lj lk b">EntityDTO</code>类型上的所有关系都被视为已加载，这样做主要是为了更好地进行DX，就好像我们将所有关系都类型化为<code class="fe lh li lj lk b">Primary&lt;T&gt; | EntityDTO&lt;T&gt;</code>(例如<code class="fe lh li lj lk b">number | EntityDTO&lt;Book&gt;</code>)一样，这不可能从智能感知/自动建议中受益。想象一下这个场景:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="47b3" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">验证改进</h1><p id="5b85" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">除了编译时验证之外，我们还在启动插入查询之前进行了运行时验证，以确保所需的属性有它们的值。这主要在mongo中很重要，在那里我们没有模式级的可选性检查。</p><p id="664b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们尝试使用CLI而不在本地安装它时，我们也会收到警告。如果我们忘记更新一些ORM包，并以版本不匹配和安装了多个核心包而告终，该怎么办？我们现在也验证了这一点！</p><h1 id="61eb" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">返工模式差异</h1><p id="e5b9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">模式差异一直是最薄弱的环节之一。通常，会产生额外的查询，或者甚至不可能达到完全同步的状态。</p><p id="b777" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模式差异已经被完全重写，以解决所有当前已知的问题，并在此基础上添加了更多的<em class="lp">:</em></p><ul class=""><li id="eab0" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">不同的外键约束</li><li id="2f8f" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">适当的索引差异(在我们只比较名称之前)</li><li id="f515" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">自定义索引表达式</li><li id="8d8b" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">评论差异</li><li id="7c35" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">列长不同(如<code class="fe lh li lj lk b">numeric(10,2)</code>或<code class="fe lh li lj lk b">varchar(100)</code></li><li id="d355" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">更改主键类型</li><li id="095e" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">模式/名称空间差异(仅限Postgres)</li><li id="e507" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">自动向下迁移(尚不支持SQLite)</li><li id="25ec" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">检查约束支持(仅限Postgres)</li></ul><h1 id="cfdc" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">更智能的迁移</h1><p id="c7cd" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在生产环境中，我们可能希望使用编译的迁移文件。从v5开始，这几乎可以开箱即用，我们需要做的就是相应地配置迁移路径。执行的迁移现在忽略文件扩展名，因此我们可以在同一个数据库上使用node和ts-node。这是以向后兼容的方式完成的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b814" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建新迁移现在会自动将目标架构快照保存到migrations文件夹中。如果我们尝试创建新的迁移，而不是使用当前的数据库模式，将会使用该快照。这意味着，如果我们试图在运行未决迁移之前创建新的迁移，我们仍然会得到正确的模式差异(如果没有进行额外的更改，将不会创建迁移)。</p><blockquote class="lm ln lo"><p id="376f" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated">快照应该像常规迁移文件一样进行版本控制。</p></blockquote><h1 id="0727" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">自动冲洗模式</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ne"><img src="../Images/8fd22d2760efdd9e833eb39f3685d441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J74FKP7MaZoHO3Al.jpg"/></div></div></figure><p id="8592" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，刷新一直是一个显式的操作。使用v5，我们可以配置刷新策略，类似于JPA/hibernate的工作方式。我们有3种冲洗模式:</p><ul class=""><li id="bfb6" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><code class="fe lh li lj lk b">FlushMode.COMMIT</code>-<code class="fe lh li lj lk b">EntityManager</code>尝试延迟刷新，直到提交当前事务，尽管它也可能过早刷新。</li><li id="4ff8" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">FlushMode.AUTO</code> -这是默认模式，仅在必要时刷新<code class="fe lh li lj lk b">EntityManager</code>。</li><li id="6d80" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">FlushMode.ALWAYS</code> -每次查询前刷新<code class="fe lh li lj lk b">EntityManager</code>。</li></ul><p id="80d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lh li lj lk b">FlushMode.AUTO</code>将尝试检测我们正在查询的实体的变化，如果有重叠，则刷新:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="95d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文档中关于冲洗模式<a class="ae ll" href="https://mikro-orm.io/docs/unit-of-work/#flush-modes" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><h1 id="c701" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">自动刷新已加载的实体</h1><p id="35f6" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">以前，当一个实体被加载并且我们需要重新加载它时，需要在选项中提供显式的<code class="fe lh li lj lk b">refresh: true</code>。实体的刷新也有一个有问题的副作用——实体数据(用于计算变更集)总是根据新加载的实体进行更新，因此会忘记以前的状态(导致可能丢失刷新前对实体所做的更新)。</p><p id="40dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们总是将新加载的数据与当前状态合并，当我们看到更新的属性时，我们会保留更改后的值。此外，对于带有主键条件的<code class="fe lh li lj lk b">em.findOne()</code>,我们试图通过比较选项和已经加载的属性名来检测重新加载实体是否有意义。在这一步中，考虑了<code class="fe lh li lj lk b">fields</code>和<code class="fe lh li lj lk b">populate</code>选项，以支持部分加载和惰性属性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="455e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe lh li lj lk b">em.findOne()</code>中的复杂条件和通过<code class="fe lh li lj lk b">em.find()</code>的任何查询，我们总是无论如何都要进行查询，但是现在不是忽略数据以防这样的实体被加载，而是以同样的方式将它们合并。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="bba0" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">播种机包装</h1><p id="dee1" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">MikroORM v5现在有了一个新的包，可以用初始数据或测试数据植入数据库。它允许像往常一样通过相同的EntityManager API创建实体，添加对实体工厂的支持，并通过faker(最新发布的社区版本)生成假数据。</p><p id="f98a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多示例参见<a class="ae ll" href="https://mikro-orm.io/docs/seeding" rel="noopener ugc nofollow" target="_blank">播种机文档</a>。</p><h1 id="7bda" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">多态嵌入</h1><p id="2923" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">多态嵌入允许我们为一个嵌入的属性定义多个类，根据鉴别器列使用正确的类，类似于单表继承的工作方式。虽然这目前只适用于嵌入式，但对多态实体的支持可能会在5.x版本中增加。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c016" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<a class="ae ll" href="https://mikro-orm.io/docs/embeddables/#polymorphic-embeddables" rel="noopener ugc nofollow" target="_blank">文档</a>获取完整示例。</p><p id="23ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在可嵌入性方面还有许多其他小的改进，并且解决了许多问题。两个例子:</p><ul class=""><li id="4b2b" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">支持多对一关系(仅存储主键，并能够像使用常规实体一样填充关系)</li><li id="7075" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">支持<code class="fe lh li lj lk b">onCreate</code>和<code class="fe lh li lj lk b">onUpdate</code>属性选项</li></ul><h1 id="3878" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">填充惰性标量属性</h1><p id="6d76" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">以前，填充惰性标量属性的唯一方法是在包含实体的初始加载期间。如果这样的实体已经加载到身份映射中(没有这个属性)，我们需要刷新它的状态——可能会丢失一些状态。MikroORM v5也允许通过<code class="fe lh li lj lk b">em.populate()</code>填充这些属性。这样做永远不会覆盖我们可能对实体所做的任何内存中的更改。</p><h1 id="cc89" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">不使用EntityManager创建引用</h1><p id="b56e" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">当我们想要创建一个引用，即一个仅由其主键表示的实体时，我们总是必须能够访问当前的EntityManager实例，因为这样的实体总是需要被管理。</p><p id="b78b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多亏了<code class="fe lh li lj lk b">Reference</code>类上新的助手方法，我们现在可以在不访问<code class="fe lh li lj lk b">EntityManager</code>的情况下创建实体引用。如果您想从内部实体构造函数创建引用，这可能会很方便:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="lm ln lo"><p id="1ccc" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated"><code class="fe lh li lj lk b">Reference</code>包装器是一个可选的类，允许在关系上有更多的类型安全。或者，我们可以使用<code class="fe lh li lj lk b">Reference.createNakedFromPK()</code>。</p></blockquote><p id="26a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建一个非托管引用，一旦拥有实体被刷新，该引用将被合并到<code class="fe lh li lj lk b">EntityManager</code>中。注意，在我们刷新它之前，像<code class="fe lh li lj lk b">Reference.init()</code>或<code class="fe lh li lj lk b">Reference.load()</code>这样的方法将不可用，因为它们需要<code class="fe lh li lj lk b">EntityManager</code>实例。</p><h1 id="de6f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">更聪明的<code class="fe lh li lj lk b">expr</code>帮手</h1><p id="7a05" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><code class="fe lh li lj lk b">expr()</code>助手可以用来避开严格的输入。它是一个标识函数，除了返回它的参数之外什么也不做——它所做的只是告诉TypeScript该值实际上是一个不同的类型(准确地说是一个泛型<code class="fe lh li lj lk b">string</code>)。</p><p id="8585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以用另外两种方式使用助手:</p><ul class=""><li id="1e1f" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">使用回调签名来允许表达式的动态别名</li><li id="fdc6" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">使用数组参数来比较元组</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="6d3f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">一个合适的QueryBuilder</h1><p id="897c" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><code class="fe lh li lj lk b">QueryBuilder</code>现在知道它的类型，并且<code class="fe lh li lj lk b">getResult()</code>和<code class="fe lh li lj lk b">execute()</code>方法基于它被类型化。我们也可以直接等待<code class="fe lh li lj lk b">QueryBuilder</code>实例，它将自动执行QB并返回适当的响应。QB实例现在根据<code class="fe lh li lj lk b">select/insert/update/delete/truncate</code>方法的使用类型化为:</p><ul class=""><li id="22c4" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated"><code class="fe lh li lj lk b">SelectQueryBuilder</code> —等待生成实体数组</li><li id="6a6a" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">CountQueryBuilder</code> —等待产量编号</li><li id="4e99" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">InsertQueryBuilder</code> —等待产量<code class="fe lh li lj lk b">QueryResult</code></li><li id="a600" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">UpdateQueryBuilder</code> —等待收益<code class="fe lh li lj lk b">QueryResult</code></li><li id="7c06" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">DeleteQueryBuilder</code> —等待收益<code class="fe lh li lj lk b">QueryResult</code></li><li id="ff63" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">TruncateQueryBuilder</code> —等待产量<code class="fe lh li lj lk b">QueryResult</code></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nf"><img src="../Images/694c3a262cfbbbc54fd246ab92f2e5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jFsyXtSw1ZzZ9-cD.jpg"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="b5cf" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">通配符模式实体</h1><p id="fec9" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">到目前为止，我们能够在特定的模式中或者没有模式的情况下定义实体。然后这些实体使用基于ORM配置或<code class="fe lh li lj lk b">FindOptions</code>的模式。这允许我们从特定的模式中读取实体，但是我们忽略了工作单元的力量。</p><p id="0b72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在v5中，实体实例现在拥有模式名(作为<code class="fe lh li lj lk b">WrappedEntity</code>的一部分)。受管实体将拥有来自<code class="fe lh li lj lk b">FindOptions</code>的模式或元数据。像<code class="fe lh li lj lk b">em.create()</code>或<code class="fe lh li lj lk b">em.getReference()</code>这样创建新实体实例的方法现在有一个options参数来允许设置模式。我们也可以用<code class="fe lh li lj lk b">wrap(entity).getSchema()</code>和<code class="fe lh li lj lk b">wrap(entity).setSchema()</code>。</p><p id="7cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实体现在可以通过<code class="fe lh li lj lk b">@Entity({ schema: '*' })</code>指定通配符模式。这样，它们将在<code class="fe lh li lj lk b">SchemaGenerator</code>中被忽略，除非指定了<code class="fe lh li lj lk b">schema</code>选项。</p><ul class=""><li id="4830" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">如果我们指定模式，实体只存在于该模式中</li><li id="a616" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">如果我们定义<code class="fe lh li lj lk b">*</code>模式，实体可以存在于任何模式中，总是由参数控制</li><li id="8ba5" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">如果我们跳过模式选项，该值将从全局ORM配置中获取</li></ul><p id="7579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这个话题的更多信息可以在<a class="ae ll" href="https://mikro-orm.io/docs/next/multiple-schemas#wildcard-schema" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="7ec6" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">实体的深度赋值</h1><p id="2210" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">另一个弱点是给现有实体赋予新的价值。虽然<code class="fe lh li lj lk b">wrap().assign()</code>最初被设计用来更新单个实体及其值，但是很多用户想要分配一个实体图，在一个单独的步骤中更新关系。</p><p id="dc1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在v5中，<code class="fe lh li lj lk b">EntityAssigner</code>检测什么实体应该被更新的方式已经改变。默认情况下，分配一个深度实体图应该是可能的，不需要任何额外的选项。它的工作基于匹配的实体主键，所以如果你想更新一个关系而不是创建一个新的关系，确保你首先加载它并把它的主键传递给<code class="fe lh li lj lk b">assign</code>助手:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="594a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们希望总是更新实体，即使在<code class="fe lh li lj lk b">data</code>中没有实体PK，我们也可以使用<code class="fe lh li lj lk b">updateByPrimaryKey: false</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于此主题的更多示例可在文档中找到<a class="ae ll" href="https://mikro-orm.io/docs/entity-helper/#updating-deep-entity-graph" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b24f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">ES模块的实验支持</h1><p id="da55" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">虽然MikroORM v5仍然作为CommonJS编译和发布，但我们添加了几个改进，应该也允许它与ESM项目一起使用。也就是说，我们使用<code class="fe lh li lj lk b">gen-esm-wrapper</code>包来允许使用命名导入，并且我们使用一个讨厌的技巧来保持动态导入，而不是编译它们来要求语句——为此我们需要使用<code class="fe lh li lj lk b">MIKRO_ORM_DYNAMIC_IMPORTS</code> env var。这将允许我们对ES模块使用基于文件夹的发现，这在以前是不可能的。</p><h1 id="b4de" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">其他显著变化</h1><ul class=""><li id="711b" class="kt ku iq jp b jq mr ju ms jy ng kc nh kg ni kk ky kz la lb bi translated">联合装载策略的部分装载支持(<code class="fe lh li lj lk b">fields</code></li><li id="d850" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">AsyncLocalStorage</code>在<code class="fe lh li lj lk b">RequestContext</code>助手中默认使用</li><li id="7321" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b">onLoad</code>事件(类似于<code class="fe lh li lj lk b">onInit</code>，但是允许异步，只对加载的实体触发，而不是引用)</li><li id="1d82" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">从CLI配置中导出异步函数</li><li id="d877" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">SQL的可配置别名策略</li><li id="a9d9" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">允许提供<a class="ae ll" href="https://mikro-orm.io/docs/logging" rel="noopener ugc nofollow" target="_blank">自定义</a> <code class="fe lh li lj lk b"><a class="ae ll" href="https://mikro-orm.io/docs/logging" rel="noopener ugc nofollow" target="_blank">Logger</a></code> <a class="ae ll" href="https://mikro-orm.io/docs/logging" rel="noopener ugc nofollow" target="_blank">实例</a></li><li id="9c7c" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated"><code class="fe lh li lj lk b"><a class="ae ll" href="https://mikro-orm.io/docs/configuration/#persist-created-entities-automatically" rel="noopener ugc nofollow" target="_blank">persist</a></code> <a class="ae ll" href="https://mikro-orm.io/docs/configuration/#persist-created-entities-automatically" rel="noopener ugc nofollow" target="_blank">选项在</a> <code class="fe lh li lj lk b"><a class="ae ll" href="https://mikro-orm.io/docs/configuration/#persist-created-entities-automatically" rel="noopener ugc nofollow" target="_blank">em.create()</a></code> <a class="ae ll" href="https://mikro-orm.io/docs/configuration/#persist-created-entities-automatically" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe lh li lj lk b"><a class="ae ll" href="https://mikro-orm.io/docs/configuration/#persist-created-entities-automatically" rel="noopener ugc nofollow" target="_blank">persistOnCreate</a></code> <a class="ae ll" href="https://mikro-orm.io/docs/configuration/#persist-created-entities-automatically" rel="noopener ugc nofollow" target="_blank">全局配置</a></li><li id="a708" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">实体生成器中的多对多支持</li><li id="fd05" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">支持指定事务隔离级别</li><li id="08c7" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">控制<a class="ae ll" href="https://mikro-orm.io/docs/loading-strategies#population-where-condition" rel="noopener ugc nofollow" target="_blank">填充提示的条件</a></li><li id="1bf8" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">修改后的<a class="ae ll" href="https://mikro-orm.io/api" rel="noopener ugc nofollow" target="_blank"> API文档</a></li><li id="8eac" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">还有<em class="lp">很多很多</em>更，看这里的<a class="ae ll" href="https://github.com/mikro-orm/mikro-orm/blob/master/CHANGELOG.md#500-rc2-2022-02-03" rel="noopener ugc nofollow" target="_blank">全改版</a></li></ul><p id="d259" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也一定要检查<a class="ae ll" href="https://mikro-orm.io/docs/upgrading-v4-to-v5" rel="noopener ugc nofollow" target="_blank">升级指南</a>。</p><h1 id="c81f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">下一步是什么？</h1><p id="7b2d" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">以下是我希望继续关注的一些事情:</p><ul class=""><li id="8f52" class="kt ku iq jp b jq jr ju jv jy kv kc kw kg kx kk ky kz la lb bi translated">允许为M:N关系指定pivot实体(这样我们可以在那里有额外的列，但出于阅读的目的，仍然将其映射为M:N)</li><li id="2744" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">支持数据库视图(或者仅仅是代表SQL表达式的实体)</li><li id="1552" class="kt ku iq jp b jq lc ju ld jy le kc lf kg lg kk ky kz la lb bi translated">更多的驱动程序——也就是更好的——sqlite3和蟑螂听起来像是唾手可得的果实，因为knex现在本地支持它们</li></ul></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><blockquote class="lm ln lo"><p id="ec55" class="jn jo lp jp b jq jr js jt ju jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj kk ij bi translated"><em class="iq">喜欢</em><a class="ae ll" href="https://mikro-orm.io/" rel="noopener ugc nofollow" target="_blank"><em class="iq">MikroORM</em></a><em class="iq">？⭐️ </em> <a class="ae ll" href="https://github.com/mikro-orm/mikro-orm" rel="noopener ugc nofollow" target="_blank"> <em class="iq">在GitHub上明星it </em> </a> <em class="iq">分享这篇文章给你的朋友。如果你想在经济上支持这个项目，你可以通过GitHub赞助商来做。</em></p></blockquote></div></div>    
</body>
</html>