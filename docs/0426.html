<html>
<head>
<title>An introduction to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归入门</h1>
<blockquote>原文：<a href="https://itnext.io/recursion-263745d98999?source=collection_archive---------5-----------------------#2018-03-08">https://itnext.io/recursion-263745d98999?source=collection_archive---------5-----------------------#2018-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/04719ea0e7621b8cd52289e6375ef580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nU9vS-oq8vwnVwXRzQt-kg.jpeg"/></div></div></figure><div class=""/><p id="3a61" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于递归的解释，点击<a class="ae kw" href="https://medium.com/@OmisNomis/recursion-263745d98999" rel="noopener">这里</a>。</p><p id="4365" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Frecursion-263745d98999" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><h2 id="e4cf" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">为什么我刚刚花了一个小时点击一个链接，只是循环回到这个页面？！</h2><p id="6095" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">两个原因:</p><ol class=""><li id="43c5" class="lw lx jb ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">这就是递归。</li><li id="0b86" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">我希望它能给我更好的数据。</li></ol><p id="8d3c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不明白为什么这是递归，你真的花了一个小时点击同一个链接，那么这篇文章的目的是让你明白这个笑话。</p><h2 id="1112" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">我为什么要写这个？</h2><p id="340f" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">我在学开发的时候；递归一直是我能理解的东西之一，我认为它真的很棒，但就是找不到一个用例。</p><p id="26ed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近在解决一个问题，我需要将多维对象展平为平面结构。这个问题使用递归很容易解决；我认为这在博客文章中会很有用。</p><h2 id="6141" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">那么我们在建造什么？</h2><p id="189e" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">这部分很简单；我们将编写一个函数，给定一个多维对象，它将返回一个一维对象，其中包含嵌套对象的所有键值对。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e4ff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们只对实际上有关联值的键感兴趣；而不是分配给嵌套对象的那些。</p><h2 id="6003" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">该功能</h2><p id="0554" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">让我们看看整个功能，然后我们可以一起讨论每个步骤。</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="58f5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们一行一行地走一遍。</p><ol class=""><li id="4015" class="lw lx jb ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">创建一个我们将添加并返回的空对象。</li></ol><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="5383" class="ky kz jb mr b gy mv mw l mx my">let obj = {}; </span></pre><p id="788c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.获取已经传入函数的<code class="fe mz na nb mr b">object</code>的<code class="fe mz na nb mr b">keys</code>。如果你有一个对象<code class="fe mz na nb mr b">{one: 1, two: 2, three: { four: 4 }}</code>，那么键就是<code class="fe mz na nb mr b">one</code>、<code class="fe mz na nb mr b">two</code>和<code class="fe mz na nb mr b">three</code> ( <code class="fe mz na nb mr b">four</code>不是嵌套的)。然后我们使用<code class="fe mz na nb mr b">forEach</code>函数对每个<code class="fe mz na nb mr b">key</code>进行循环。</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="7524" class="ky kz jb mr b gy mv mw l mx my">Object.keys(object).forEach(key =&gt; {});</span></pre><p id="3d70" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.然后我们检查<code class="fe mz na nb mr b">value</code>的类型；如果它不是一个对象，那么我们把它添加到我们的<code class="fe mz na nb mr b">obj</code>对象中，然后我们继续。</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="9620" class="ky kz jb mr b gy mv mw l mx my">if (typeof object[key] !== 'object') {      <br/>    obj[key] = object[key];    <br/>}</span></pre><p id="fae0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.下一步是我们使用递归。如果<code class="fe mz na nb mr b">value</code>的类型是一个对象(例如<code class="fe mz na nb mr b">three: { four: 4 }</code>三是<code class="fe mz na nb mr b">key</code>并且它的<code class="fe mz na nb mr b">value</code>是一个对象)，那么我们递归调用<code class="fe mz na nb mr b">flattenObject</code>函数返回一个一维对象，然后我们可以将它与<code class="fe mz na nb mr b">obj</code>合并</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="a99c" class="ky kz jb mr b gy mv mw l mx my">else {      <br/>    obj = { ...obj, ...flattenObject(object[key]) };    <br/>}</span></pre><h2 id="4d6d" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">有道理！</h2><p id="6045" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">不，当然不是！连我都有点困惑。让我们更详细地讨论第四点。</p><p id="7a2f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与其我们的大对象，有多层次的嵌套对象，不如从一个简单的开始；</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="92d0" class="ky kz jb mr b gy mv mw l mx my">const obj = {one: 1, two: { three: 3}, four: 4}</span></pre><p id="7ce9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是当我们将它传递给我们的<code class="fe mz na nb mr b">flattenObject</code>函数时发生的情况</p><ul class=""><li id="fdd0" class="lw lx jb ka b kb kc kf kg kj ly kn lz kr ma kv nc mc md me bi translated"><code class="fe mz na nb mr b">obj</code>被分配给一个空对象</li><li id="8cc8" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">从<code class="fe mz na nb mr b">Object.keys(object)</code> ( <code class="fe mz na nb mr b">[one, two, four]</code>)返回一个数组</li><li id="76b9" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">然后我们使用<code class="fe mz na nb mr b">forEach</code>循环遍历这个数组</li><li id="0edc" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">第一个键(<code class="fe mz na nb mr b">one</code>)的值是<code class="fe mz na nb mr b">1</code>，不是对象，所以加到<code class="fe mz na nb mr b">obj</code>。</li><li id="b682" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated"><code class="fe mz na nb mr b">obj</code>现在等于<code class="fe mz na nb mr b">{one: 1}</code></li><li id="04ed" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">第二个键(<code class="fe mz na nb mr b">two</code>)有一个对象值，所以我们要递归调用<code class="fe mz na nb mr b">flattenObject</code>函数。</li><li id="dc75" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">用<code class="fe mz na nb mr b">object[key]</code>调用<code class="fe mz na nb mr b">flattenObject</code>函数，在本例中是<code class="fe mz na nb mr b">object[two]</code>，因此是<code class="fe mz na nb mr b">{three: 3 }</code></li><li id="27a6" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">再次创建一个变量(<code class="fe mz na nb mr b">obj</code>)，它等于一个空对象(<code class="fe mz na nb mr b">{}</code>)。值得注意的是，这个变量与第一次调用这个函数时的变量完全不同；每个调用在调用堆栈中都有自己的位置，因此也有自己的范围。</li><li id="ee78" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">从<code class="fe mz na nb mr b">Object.keys(object)</code> ( <code class="fe mz na nb mr b">[three]</code>)返回一个数组</li><li id="b56a" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">然后，我们使用<code class="fe mz na nb mr b">forEach</code>遍历该数组(您现在应该开始看到与上面要点的相似之处)</li><li id="62d5" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">第一个键(<code class="fe mz na nb mr b">three</code>)的值是<code class="fe mz na nb mr b">3</code>，不是对象，所以加到<code class="fe mz na nb mr b">obj</code>。</li><li id="c935" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">在数组中没有更多的项需要循环，所以返回<code class="fe mz na nb mr b">obj</code>。</li><li id="caed" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">记住，我们递归地调用了函数，然后将返回的对象传递给spread操作符</li></ul><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="d78b" class="ky kz jb mr b gy mv mw l mx my">// Changing this<br/>obj = { ...obj, ...flattenObject(object[key]) };</span><span id="b536" class="ky kz jb mr b gy nd mw l mx my">// To this<br/>obj = { ...{one: 1}, ...{three: 3} };</span></pre><ul class=""><li id="bfb2" class="lw lx jb ka b kb kc kf kg kj ly kn lz kr ma kv nc mc md me bi translated">因为<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>将两个对象连接在一起，obj现在等于<code class="fe mz na nb mr b">{one: 1, three: 3}</code></li><li id="ca65" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">第三个键(<code class="fe mz na nb mr b">four</code>)，记住我们传递的对象是<code class="fe mz na nb mr b">{one: 1, two: { three: 3}, four: 4}</code>，有一个值<code class="fe mz na nb mr b">4</code>不是对象，所以加到<code class="fe mz na nb mr b">obj</code>。</li><li id="a96b" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated"><code class="fe mz na nb mr b">obj</code>现在等于<code class="fe mz na nb mr b">{one: 1, three: 3, four: 4}</code>。</li><li id="1b2d" class="lw lx jb ka b kb mf kf mg kj mh kn mi kr mj kv nc mc md me bi translated">在数组中没有更多的项需要循环，所以返回<code class="fe mz na nb mr b">obj</code>。</li></ul><h2 id="6d25" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">快速警告</h2><p id="3ff3" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">虽然使用递归看起来很聪明，感觉也很棒，但是应该小心使用。请记住，每次递归调用都会向调用堆栈中添加另一个调用，这可能会让您大吃一惊(<strong class="ka jc">最大调用堆栈大小超过了</strong>)。你应该考虑阅读关于尾部递归的文章，或者我会写另一篇关于尾部递归的博文(敬请关注！).</p><h2 id="2aab" class="ky kz jb bd la lb lc dn ld le lf dp lg kj lh li lj kn lk ll lm kr ln lo lp lq bi translated">好了</h2><p id="fc36" class="pw-post-body-paragraph jy jz jb ka b kb lr kd ke kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv ij bi translated">这就是如何使用递归将多维对象变成一维对象。下面是代码:</p><figure class="mk ml mm mn gt is"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div></div>    
</body>
</html>