<html>
<head>
<title>On schedule</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按预定计划</h1>
<blockquote>原文：<a href="https://itnext.io/on-schedule-2ce0eb21c0b8?source=collection_archive---------5-----------------------#2019-11-17">https://itnext.io/on-schedule-2ce0eb21c0b8?source=collection_archive---------5-----------------------#2019-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a1a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">云中的重复任务调度:模式和反模式</strong></p><p id="f006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些事情只是需要重复发生。每日计算、每小时清理、每分钟导入作业和每月总结。这是计算界的老问题，但不是小事。令人惊讶的是，在我遇到的各种实现中，我看到了许多反模式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/9a0d31865e20438ab86925aba5d0bf25.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*pDlL3Y4Q_vxo4jDVoa-_sg.jpeg"/></div></figure><h1 id="f479" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">天真的方法</h1><p id="afe8" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">简单的方法是在你自己的主进程中调度，使用一些你的编程语言支持的事件循环或间隔机制。这种“解决方案”很少像预期的那样奏效。您的调度现在使用的内存、cpu和事件循环/线程与您的应用程序其余部分使用的相同。因此，调度的任务可能会使用可用于处理传入请求的cpu，更糟糕的是，如果您处于cpu密集型进程中，您的简单调度器将不会按时触发(或者根本不会触发)。当您将您的过程扩展到多个副本时，一个更加棘手的问题将会出现；并且您将获得任务的多次调用。</p><p id="f58d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以很明显，我们需要将调度任务从应用程序的常规生命周期中分离出来(除非这是我们的应用程序唯一要做的事情)。但是这并没有真正解决多个任务竞争一个有限的进程资源的问题，这也可能会阻止对队列中的下一个任务进行调度。对于任何超过几个短时间运行的、非cpu密集型的任务，我们需要将调度与已调度任务的执行分开。</p><h1 id="bd6a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">分离</h1><p id="e8e1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如何将调度和处理分开？这里有两种常见的解决方案(可能还有更多。)</p><ol class=""><li id="179a" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated"><strong class="jp ir">启动一个预定的作业专用进程。</strong> <br/>如何？这可以通过云本地orchestrator来完成:K8s作业、ECS任务、预定的云功能等。都是很好的解决方案。如果资源有限，您可能需要考虑正在运行的并发计划作业的数量；，并限制这种并发性。这种解决方案是可扩展的，易于推理，并且具有额外的优势，即任务在干净的环境中运行，没有来自先前任务的任何遗留状态。这个解决方案的主要缺点是启动时间。如果与实际任务的长度相比，您的容器(通常在这个解决方案中包含一个容器)有很长的启动时间，这将是不实际的，尤其是当您需要在紧张的时间表中运行很多很多预定的短任务时。</li><li id="d1c6" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">在这个模式中，调度器“告诉”一个来自工人池的现有工人运行一个任务。怎么会？一种常见的做法是使用消息而不是http/grpc来完成这一任务，因此如果没有可用的worker，消息会一直等待，直到有一个worker准备好。另一种解决方案可能是创建一个workers orchestrator，接收调度运行的请求，并对它们进行排队，直到worker准备就绪(然后，您必须考虑这个orchestrator进程的HA、分布式状态等)。这种解决方案通常适用于许多非常短的任务，尤其是在运行任务所需的流程/容器启动时间很长的情况下。对于1秒钟的作业，您不希望等待30秒钟来启动专用进程。但是我们确实需要考虑可用工人的数量；自动扩展与维护备用员工队伍的成本。在这里，你在一段时间内的时间安排的分布很重要。如果所有任务都在午夜12:00到12:30之间运行，那么每天将有23.5个小时没有使用工作人员。在这种情况下，响应迅速且经过良好调整的自动缩放/缩减解决方案将会派上用场。</li></ol><h1 id="8f17" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">常见陷阱</h1><p id="8718" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">所有计划任务解决方案都需要处理一些常见问题:任务并发性、错误处理和限制。对它们的推理真的取决于你的任务和需求。</p><ol class=""><li id="7f10" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">并发性:相同的调度任务可以与同一种类的任务并发运行吗？让我们假设您每10分钟有一个度量A的长时间运行的计算，如果在第一个任务还在运行的时候另一个相同类型的任务开始了(因为时间或者其他问题),会发生什么呢？如果任务涉及“获取所有未发送的通知并发送它们”，答案是否相同？</li><li id="bb24" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">错误处理:我们应该如何处理任务中的错误？重新运行？多少次了？忽略？停止进一步执行此计划任务的下一个实例？</li><li id="d19a" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">限制:除了重试的回退限制之外，这里还有其他相关的限制吗？如果一个任务在一天后仍在运行，这是一种预期的行为还是应该被终止？任务应该如何处理因部署而终止？</li></ol><p id="392e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">健壮的</strong>调度解决方案可能有助于相关的配置选项，允许您处理所有或部分配置选项；但是你仍然需要对它们进行推理，它们都有价格标签，没有银弹解决方案。通常可以归结为两种可选的语义:</p><ul class=""><li id="79b0" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mk mc md me bi translated">最多运行一次——运行多次或不按时运行的成本高于不运行的成本的任务，向客户端发送推送消息的非幂等任务可能是一个很好的例子。如果你走这条路，一定要有适当的监控，这样你就会知道哪些任务没有运行；最终，您将需要一个“手动”任务api，允许系统操作员填充缺失的任务。</li><li id="a129" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mk mc md me bi translated">至少运行一次—确保任务至少运行一次，并为它可能运行多次(可能是并发运行)做好准备。任务幂等性是这里的一个基本要求。</li></ul><h1 id="bbf1" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">你说什么时候？</h1><p id="9eca" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">另一个等待我们安排的陷阱是时区。调度的最佳实践是使用UTC，许多调度程序只是假设UTC，不允许围绕UTC进行配置。但是，如果您需要其他时区的时间表(如客户端时间)，那么您的时间表应该进行相应的调整，您可能需要一些自动化来处理夏令时的变化(除非您的时间表支持时区)。此问题的一个常见解决方案是不尝试安排在特定的时间(下午3:00)，而是安排在“每小时”模式，并在计划任务中检查这是否是运行的好时机。虽然常见。我认为这通常不是正确的解决方案，投资于自动调整计划时间以适应当前的UTC时间是更“正确”的解决方案。</p><h1 id="ef19" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">接受调度限制</h1><p id="b7ae" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在规划我们的调度解决方案时，一个重要的心态应该是接受调度的限制，其中最重要的是准确性，很难确保调度解决方案的高准确性。特别是在处理非常短的调度(秒)时，调度配置格式的事实上的标准:crontab不支持比一分钟更高的调度精度。但是，即使您的日程安排解决方案支持，也很难交付。如果在特定的一秒钟内安排了许多项目(例如，00:00 UTC是一个非常常见的安排目标),安排者可能无法在精确的时刻交付所有的项目，即使交付了，也是网络延迟、软件层等。可能会阻止您立即处理甚至接受任务。接受这个限制会使你的设计更加健壮。一个相关的问题是分散你的任务。我们倾向于在主要使用量下降时安排日常任务。但是除了计算“何时”之外，这实际上是当客户机跨越多个时区时的首选运行时间表。这通常会导致试图在一天的确切结束时运行任务，因此我们最终会有许多任务试图在该时间运行，结果由于巨大的峰值，其中一些任务无法按计划运行。如果每天的任务不依赖于跑步的时间，可能会更好。谷歌<a class="ae ml" href="https://landing.google.com/sre/sre-book/chapters/distributed-periodic-scheduling/" rel="noopener ugc nofollow" target="_blank"> SRE团队甚至扩展了受支持的crontab格式</a>,增加了“扩展”可接受的时间范围的能力，并允许系统选择最佳时机，以减轻“尖峰”影响(似乎成功有限)。</p><h1 id="17ef" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">高可用性调度</h1><p id="f909" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这是一个棘手的问题，你可能无法独自解决。</p><p id="f04d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除非你完全不在乎双重调度(这是调度非常罕见的情况)。您需要一个“主”发布时间表，以及一个“辅助”(或多个)发布时间表来替换它，而不需要重新发布相同的任务。所以现在你需要某种分布式状态和网络上的工作故障检测(这本身就是一个难题)。除非你想通过多提交paxos实现来实现一个高度可用的分布式系统(就像Google的“chubby”团队所做的那样，<a class="ae ml" href="https://static.googleusercontent.com/media/research.google.com/iw//archive/paxos_made_live.pdf" rel="noopener ugc nofollow" target="_blank">记录了他们在这种情况下实现多提交paxos的艰难旅程</a>作为对我们所有人的警告)，否则你可能应该使用一些基于云提供商的调度程序。也许触发一个事件触发您的工人的一个任务，或者启动一个容器在不同的场景中都有意义。在许多场景中，您并不真正需要高度可用的调度，或者不愿意支付复杂性成本。您最好监视可用性不高的调度程序。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="94d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">日程安排很棘手</strong>，迫使我们思考约束和需求。这种东西最终会渗透到任何长期存在的软件中。无论是在实现层面，还是在与利益相关者一起设计和提出限制时，都要准备好进行推理。如果你需要在一个分布式系统中考虑调度问题(现在几乎每一个本地部署的云系统都是分布式的)，你最好使用一个成熟的工具，而不是自己开发。</p><p id="1c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">额外阅读</strong> : <a class="ae ml" href="https://landing.google.com/sre/sre-book/chapters/distributed-periodic-scheduling/" rel="noopener ugc nofollow" target="_blank">谷歌SRE书籍中关于分布式调度的章节</a></p></div></div>    
</body>
</html>