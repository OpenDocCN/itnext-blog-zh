<html>
<head>
<title>Promises: The Definitive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">承诺:权威指南</h1>
<blockquote>原文：<a href="https://itnext.io/promises-the-definitive-guide-6a49e0dbf3b7?source=collection_archive---------2-----------------------#2019-03-05">https://itnext.io/promises-the-definitive-guide-6a49e0dbf3b7?source=collection_archive---------2-----------------------#2019-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/58d7723b2513905529fac2dfdcd8fc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcAVLAfcH5gZcVppRykWmg.png"/></div></div></figure><div class=""/><div class=""><h2 id="406e" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">没有你想象的那么强大</h2></div><p id="8e3a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">我不想指名道姓，但我读过的许多关于JavaScript中的异步的文章，尤其是那些在ES2015 (ES6)推出时的文章，都是完全错误的。我将通过展示对JavaScript中async工作方式的真实理解来澄清这个错误。</em></p><p id="25f4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lm">这一系列文章是基于我做的一个关于Redux-Observable </em>  <em class="lm">的演讲的幻灯片。我想更进一步，解释异步是如何工作的，以及为什么它是JavaScript编码的基础。</em></p><h1 id="989d" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">能力最差的方法</h1><p id="de51" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">承诺是惊人的，但极其有限。这些年来，我已经做了很多承诺，甚至在它们作为原生JavaScript的一部分在2015年普及之前。我最喜欢的一点是他们如何让异步变得更容易掌握。它修复了回调问题，并通过提供一个可以从上到下阅读的线性API，减少了由承诺引起的间接性。</p><p id="b3db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">算是吧。</p><p id="91bc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那么，为什么承诺是“最没有能力”的呢？因为它们有很多缺点。当你使用承诺时，你会看到更多的这些缺点，并渴望改正。虽然我以前用过蓝鸟，但它不能解决所有问题；这只是让承诺更加通用。</p><h1 id="19db" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">混乱</h1><p id="4af7" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">过去，存在许多不同的promise实现。我最熟悉jQuery版本，并对其进行了高度定制，使其更像是通过管道多次发送数据。它没有遵循A+规范，但最终在1.8中提供了这样做所必需的方法。</p><p id="6eb6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">安古拉杰也是如此。当它问世时，它使用了一种与我们今天所知的承诺完全不同的方法。版本1.6为A+承诺打开了大门，版本1.7完全抛弃了旧的方法！</p><p id="9c68" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可能熟悉或者听说过蓝鸟。这是一个非常棒的库，它添加了es 2015 promises实现中目前缺少的许多功能。甚至ES2018版本只增加了<code class="fe ml mm mn mo b">Promise.prototype.finally</code>；没有什么像蓝鸟提供的。</p><p id="4bd2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">同样，严格来说，蓝鸟是你的图书馆。但是外面并不只有承诺。JavaScript中还存在其他异步方法，虽然前景很好，但它们被可观的东西取代了。不过，到了紧要关头，A+ <code class="fe ml mm mn mo b">Promise</code>是ES2015的原生版本，它对observables等任何需要第三方库的东西都有明确的限制。</p><h1 id="5372" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">解决还是拒绝？这是个问题。</h1><p id="da0c" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">从来没有人问过这个问题。这些方法是什么，我如何访问它们？</p><p id="2373" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你从回拨中创造一个承诺，你会像这样创造一个<code class="fe ml mm mn mo b">Promise</code>:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fa69" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe ml mm mn mo b">new Promise</code>接受回调，所以就像回调一样，你需要把你的<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>代码放在回调中，而不是放在回调之外。</p><p id="9372" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">令人惊讶的是，当创建一个新的承诺时，你不仅给了它一个回调，而且在你的回调函数中也给了你两个回调。这就是我在<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">回调:权威指南</a>中提到的:JavaScript中的所有异步都基于回调。<code class="fe ml mm mn mo b">resolve</code>给出一个可输出的结果，而<code class="fe ml mm mn mo b">reject</code>向承诺链抛出一个错误，但不返回错误。下一节将详细介绍这一点。</p><p id="169d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不过我很少更新<code class="fe ml mm mn mo b">Promise</code>。相反，我选择语义上的<code class="fe ml mm mn mo b">Promise.resolve</code>和<code class="fe ml mm mn mo b">Promise.reject</code>。有时它们不符合您的需要，比如上面的例子，或者如果您从回调进行转换，但是它们对于调试非常好，并且当您需要从平面值创建承诺时非常有用。就像直接调用<code class="fe ml mm mn mo b">resolve</code>和<code class="fe ml mm mn mo b">reject</code>回调一样。</p><p id="54df" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它们看起来有点像这样:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="0132" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">然后表格</h1><p id="b24d" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">承诺被称为“thenable ”,这意味着您可以将一组<code class="fe ml mm mn mo b">then</code>语句链接起来，每个语句都接收前一个回调的返回值。在我之前关于回调的文章中，你会记得我说过有可能得到回调的返回值。因此，如果您保持回调同步，您就能够从回调中获取返回值，而不是调用另一个回调。</p><p id="e212" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这正是promise的<code class="fe ml mm mn mo b">then</code>函数使用的过程。它接受一个回调(也称为处理程序)，同步执行它，接受返回值，并将其传递给链上的下一个<code class="fe ml mm mn mo b">then</code>。如果任何一个回调出错，它将遍历整个链，直到找到一个<code class="fe ml mm mn mo b">catch</code>(或者一个<code class="fe ml mm mn mo b">then</code>的第二个参数)，并调用它的回调方法。</p><h2 id="f286" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">“catch”之后会发生什么？</h2><p id="86cd" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">对大多数人来说，这是奇怪的部分。我保证大多数JavaScript开发人员不知道这些信息。</p><p id="8e33" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你从一个<code class="fe ml mm mn mo b">catch</code>中<code class="fe ml mm mn mo b">throw</code>了一个错误，并且在链的某处还有另一个<code class="fe ml mm mn mo b">catch</code>，第二个捕捉将得到那个错误。但是假设你没有抛出一个错误，取而代之的只是<code class="fe ml mm mn mo b">console.error</code>。太糟糕了，现在你要去点击链中的下一个<code class="fe ml mm mn mo b">then</code>。</p><p id="6f23" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，虽然你可以继续处理错误，这很酷，但最糟糕的是你会一直处理下去。没有办法停止一个承诺，因为任何一个<code class="fe ml mm mn mo b">then</code>都会被调用，除非你已经完成了所有的任务，并且任何一个错误都会触发一个<code class="fe ml mm mn mo b">catch</code>，它可以继续下一个<code class="fe ml mm mn mo b">catch</code>或者<code class="fe ml mm mn mo b">then</code>。</p><p id="eeaa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这在过去已经抓住了我，并且是我停止在产品代码中使用承诺的核心原因之一(现在我使用observables)。如果你的整个应用程序是由一长串的承诺组成的，那么情况会变得更糟。这可能会非常棘手，但至少你的应用程序不会停止处理！👺</p><h2 id="3669" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">两个“then”参数还是“catch”？</h2><p id="987f" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">承诺的<code class="fe ml mm mn mo b">then</code>方法可以接受两个参数。我只推荐给它一个参数，因为第二个参数实际上和在<code class="fe ml mm mn mo b">then</code>后面加上<code class="fe ml mm mn mo b">catch</code>是一样的。</p><p id="c070" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以这两个例子为例:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f49f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它们是完全一样的东西，但是一个更好读，更易维护，并且在调试时不太可能被遗漏。相信我，当你处理复杂的异步bug时，你会想要尽可能少的疯狂代码。</p><p id="e4e7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不管出于什么原因，如果你的<code class="fe ml mm mn mo b">then</code>中有很长的匿名函数，你每次都会错过第二个参数。这是你团队中所有的开发人员，包括6个月后的你。</p><p id="6d7e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">老实说，在你的项目中做最适合你的团队的事情，但是我更喜欢语义的<code class="fe ml mm mn mo b">catch</code>而不是非语义的双参数<code class="fe ml mm mn mo b">then</code>，我真的认为你也应该这样做。如果没有一个可笑的好理由，我绝不会允许另一个开发人员使用双参数版本。</p><h1 id="7b8f" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">回报承诺</h1><p id="6210" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">为了避免回调，需要注意的是<code class="fe ml mm mn mo b">then</code>可以处理返回值和另一个承诺。当返回一个值时，它被传递到下一个<code class="fe ml mm mn mo b">then</code>，但是当返回一个承诺时，它实际上将你的下一个<code class="fe ml mm mn mo b">then</code>切换到承诺沿着链传递的值；而不是承诺本身。</p><p id="a5b8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">看起来是这样的:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c3bd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意你如何回复已解决和拒绝的承诺，它们会像平常一样回复下一个<code class="fe ml mm mn mo b">then</code>或<code class="fe ml mm mn mo b">catch</code>。这是一个强大的功能，因为它可以让你始终如一地保持你的承诺标签在大多数情况下都在左边。</p><h1 id="f358" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">回调-地狱</h1><p id="f9f9" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">我真的见过有人写这样的回电——让承诺见鬼去吧:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9405" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后，作为一个聪明的承诺开发者，你会进去解决它:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b99c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当你有范围问题时，问题就来了。例如，您可能已经在消息函数中使用了服务器和连接对象，因为您需要知道将响应发送回哪个连接以及调用了哪个服务器。即使您清理了代码，也丢失了以前值的范围。</p><p id="342b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有几种方法可以解决这个问题，但是最干净的方法之一可能是每次都将它们组合成一个新的对象:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="32c9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我以前用过这种方法，但从来没有喜欢过。当你因为你的<code class="fe ml mm mn mo b">then</code>回调变得太大而需要分割东西时，它就派上用场了。虽然它可以让你避免回调，但它是否真的更好还值得商榷。</p><p id="49d7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这与我在<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">回调:最终指南</a>中谈到的情况完全相同。回调-地狱不一定是一件坏事。尽管有人告诉你承诺可以规避，但事实并非如此。</p><h1 id="7815" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">反模式</h1><p id="9401" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">就像回调一样，承诺对<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>不起作用，不是大多数人使用它们的方式。</p><p id="48cf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里有一个您通常会看到的反模式:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="1db1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这应该写成:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e742" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是为什么呢？因为承诺总是异步的。绝对没有办法像你会香草回电一样同步作出承诺。知道这一点很重要，因为不使用<code class="fe ml mm mn mo b">Promise.prototype.catch</code>方法会让你。我经常在Node.js应用程序中遇到这类问题，因为大多数浏览器开发人员经常使用<code class="fe ml mm mn mo b">Promise.prototype.catch</code>。</p><h1 id="d923" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">最后</h1><p id="e3aa" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">回到ES2018之前，我们没有急需的<code class="fe ml mm mn mo b">finally</code>方法，现在我们<strong class="ks jc"> <em class="lm">终于</em> </strong>有了。简单地说，这个方法所做的就是在一对<code class="fe ml mm mn mo b">then</code>和<code class="fe ml mm mn mo b">catch</code>周围添加语法糖，但是不传递值。这类似于RxJS中的<code class="fe ml mm mn mo b">finalize</code>操作符，遗憾的是，它也不取值。考虑到我见过的没有它会导致问题的promise代码的数量，我想说它是ES2018的一个受欢迎的补充。</p><p id="5a2d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我要再说一遍，<code class="fe ml mm mn mo b">finally</code>回调不接收值。它不像RxJS中的<code class="fe ml mm mn mo b">tap</code>，它是一个无论代码成功还是出错都只帮助清理的方法。</p><p id="dbe7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它看起来是这样的:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0b39" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这可能不是你所期望的，但是每次一个<code class="fe ml mm mn mo b">finally</code>被传递，它就会执行。所以，如果你把它放在一串连锁的<code class="fe ml mm mn mo b">then</code>和<code class="fe ml mm mn mo b">catch</code>语句之前，它会在它们之前执行。除非<code class="fe ml mm mn mo b">then</code>，否则出错时也会执行。通常这些函数会传递到下一个<code class="fe ml mm mn mo b">catch</code>，但是它们也会执行所有的<code class="fe ml mm mn mo b">finally</code>函数。</p><p id="a1b3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在现实世界的应用程序中，如果你没有<code class="fe ml mm mn mo b">finally</code>，你可能会产生一堆内存泄漏和永无止境的加载指示器等等。这是因为大多数人从来不用<code class="fe ml mm mn mo b">catch</code>来结束他们的承诺，而只用<code class="fe ml mm mn mo b">then</code>。如果你的承诺出错，你的最后一个<code class="fe ml mm mn mo b">then</code>删除了你的装载指示器，它将永远不会消失。</p><p id="40a3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然<code class="fe ml mm mn mo b">finally</code>不一定要出现在承诺的末尾，但拥有它可以让你用它来代替<code class="fe ml mm mn mo b">then</code>，并确保你的应用在完成后清理干净。</p><h2 id="8108" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">尝试-捕捉-最终</h2><p id="9d43" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如果你还不知道的话，<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>还有一个<code class="fe ml mm mn mo b">finally</code>的方法。看起来是这样的:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cfed" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，必须按照<code class="fe ml mm mn mo b">try</code>，然后<code class="fe ml mm mn mo b">catch</code>，然后<code class="fe ml mm mn mo b">finally</code>的顺序。完全省略<code class="fe ml mm mn mo b">catch</code>或<code class="fe ml mm mn mo b">finally</code>是可能的，但不能两者都省略。</p><p id="9ef2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如你所见，无论你点击<code class="fe ml mm mn mo b">try</code>还是<code class="fe ml mm mn mo b">catch</code>，它都会执行。为什么会有这种情况？您完全可以在您的<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code>语句之后登录，而不是使用<code class="fe ml mm mn mo b">finally</code>。这是最重要的一点。如果您的<code class="fe ml mm mn mo b">catch</code>抛出一个错误，那么您的执行将立即停止，您的<code class="fe ml mm mn mo b">console.log</code>将永远不会发生。to确保即使在抛出一个错误后，你仍然可以执行一些东西。</p><p id="7a2f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那你为什么不把代码放在<code class="fe ml mm mn mo b">catch</code>而不是<code class="fe ml mm mn mo b">finally</code>里呢？因为您也想在您的<code class="fe ml mm mn mo b">try</code>中使用该代码。这可以防止代码重复，并确保只要<code class="fe ml mm mn mo b">try</code> - <code class="fe ml mm mn mo b">catch</code> - <code class="fe ml mm mn mo b">finally</code>语句存在，您的代码就会一直执行。</p><p id="8dcf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Promises更多地使用<code class="fe ml mm mn mo b">finally</code>作为一个更干净的助手函数，但是在这两种情况下，您仍然可能有一个需要关闭的数据库连接。这是它将被执行的地方(即使在<code class="fe ml mm mn mo b">catch</code>中抛出一个错误之后也是如此)来关闭那个连接。这在这种情况下是不可或缺的。</p><h1 id="bbaa" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">一切为了种族，种族为了一切</h1><p id="8a28" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如果您不知道，promise API中还隐藏了另外两个方法:<code class="fe ml mm mn mo b">Promise.race</code>和<code class="fe ml mm mn mo b">Promise.all</code>。它们都是处理承诺的<code class="fe ml mm mn mo b">Array</code>的方法——更具体地说，是承诺的迭代器，但我们不去那里。</p><h2 id="6a6d" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">全部</h2><p id="78b3" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated"><code class="fe ml mm mn mo b">Promise.all</code>获取承诺列表，等待所有承诺返回值，并将这些值的数组发送给下一个<code class="fe ml mm mn mo b">then</code>回调:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2d0a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">确保在使用<code class="fe ml mm mn mo b">Promise.all</code>时，传递一个承诺数组，因为它只接受一个参数。您的结果也返回到一个数组中，其中每个值都是前一个值的解析值。</p><p id="28de" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果有，我的意思是任何一个承诺失败，你的整个<code class="fe ml mm mn mo b">Promise.all</code>都处于拒绝(出错)状态，你的错误消息只是来自第一个出错的承诺。如果你有一个以上的错误，你就无从知道了。</p><h2 id="8811" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">人种</h2><p id="afe1" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated"><code class="fe ml mm mn mo b">Promise.race</code>获取承诺列表，并获取第一个承诺来产生一个值。如果你有一堆，其他的基本上会被取消:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="11d0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这可能是<code class="fe ml mm mn mo b">Promise.race</code>最常见的用例。我自己并没有经常使用这个操作符，但是它也有一些缺陷。首先，你必须记住像<code class="fe ml mm mn mo b">Promise.all</code>一样给它传递一个数组。第二，如果其中一个承诺了错误，这无关紧要，除非该错误首先发出。</p><p id="a816" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以如果你有两个承诺，一个成功，另一个错误，你会得到成功值。如果你有两个承诺，在另一个成功之前有一个错误，你的<code class="fe ml mm mn mo b">Promise.race</code>将处于拒绝状态。这是一个很大的怪癖，也可能是使用<code class="fe ml mm mn mo b">Promise.race</code>的人感到沮丧的原因。</p><h1 id="fe1f" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">蓝鸟</h1><p id="65c5" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">有很多promise库，但是到目前为止，最流行的，也可能是您将在产品中实际看到的，是Bluebird。这是一个非常棒的promise库，有很多特性，但是除非你在Node.js空间，否则你可能看不到它。</p><p id="77f3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">JavaScript原生承诺不是蓝鸟承诺，所以你必须转换它们。</p><p id="227b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用这个库有很多好处，最好的一个是<code class="fe ml mm mn mo b">Bluebird.promisify</code>函数。</p><p id="9dc8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">就我个人而言，我不建议遵循蓝鸟的官方最佳实践将其导入到您的项目中，为了您的利益，我已经写了一整篇关于它的文章:<br/> <a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/bluebirds-docs-suck-f9cc94b1af9">蓝鸟的不良实践文档</a></p><h1 id="1cf8" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">许多缺点</h1><p id="b01b" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">我所说的大部分都是优点，但是我给这篇文章加了副标题，意思是承诺有点糟糕。为什么？当他们看起来比试镜更好的时候会有什么不好呢？</p><h2 id="ce6b" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">一次搞定</h2><p id="9b73" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">首先，它们只能发射一次。正是因为这个原因，回调优于承诺，因为它们可以随着时间的推移处理事件。承诺受限于一次发射，这是我在很多场合遇到的致命缺陷。我想，每当我在大规模应用程序中做出承诺时，它就会出现。</p><h2 id="a758" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">调试是痛苦的</h2><p id="8db0" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">控制台日志记录(接入流)是困难的。调试承诺烂透了。虽然您可能认为<code class="fe ml mm mn mo b">Promise.prototype.finally</code>正是我们要找的，但是它没有从promise链接收任何数据，所以它不能用于日志目的。蓝鸟对此也没有解决方案。</p><p id="d243" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">RxJS observables最强大的一点是，您可以在其操作的任何一点接入流。每个<code class="fe ml mm mn mo b">Promise.prototype.then</code>都相当于一个<code class="fe ml mm mn mo b">map</code>和<code class="fe ml mm mn mo b">switchMap</code>，在这里你可以返回一个值或者另一个承诺。遗憾的是，这修改了链中传递的值，并且需要更复杂的逻辑来获得一些调试语句，如果操作不正确，这种逻辑会导致维护问题。</p><p id="aec2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">只有在调试时，我使用的作弊方法是这样的:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="b6da" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">它一直走啊走啊…</h2><p id="3544" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">承诺不会停止执行。这是一个捕捉错误和之后的问题。他们穿过链条，直到什么都没有了，而且完全没有办法中途停下来。</p><p id="e96b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您可以为promise对象本身分配一个“停止处理”值，但是这样您要么必须扩展<code class="fe ml mm mn mo b">Promise</code>类，要么将每个<code class="fe ml mm mn mo b">then</code>、<code class="fe ml mm mn mo b">catch</code>和<code class="fe ml mm mn mo b">finally</code>包装在一个“检查promise是否停止”函数中。</p><h2 id="b945" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">立即执行</h2><p id="b016" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">承诺在创造时立即执行。虽然可能不明显，但是如果你在promise声明中有一个<code class="fe ml mm mn mo b">setTimeout</code>，那么它一存在就会执行，而不是等待你的第一个<code class="fe ml mm mn mo b">then</code>存在。如果你没有预料到，这可能会造成一些损害。唯一的解决方法是创建一个函数，然后返回包装了<code class="fe ml mm mn mo b">setTimeout</code>的承诺。</p><h2 id="581d" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">从不同步</h2><p id="49ff" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">承诺即使和<code class="fe ml mm mn mo b">Promise.resolve</code>也从来不同步。这意味着在我们等待正式的ES实现时，他们不能被替换为本地管道操作者。</p><p id="d37f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我的文章中有更多关于这个的内容:<br/> <a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113">一个表情符号爱好者的函数式编程指南:第4部分</a></p><h2 id="ea71" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">并不能完全消除回调——见鬼</h2><p id="5f95" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">同样，回调需要闭包来摆脱回调地狱，承诺需要将返回数据映射到更复杂的对象中。由于变量的作用域，很容易陷入类似的回调——就像回调一样糟糕。</p><h2 id="12fb" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">在“那时”很难传递承诺</h2><p id="f262" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如果你真的想把一个承诺——而不是它的值——传递给下一个<code class="fe ml mm mn mo b">then</code>，你必须把它包装在一个数组或对象中，这样它就不会被自动转换。大多数人不会意识到这一点，可能会花几个小时试图找出为什么他们的代码不工作。我知道我有。</p><h2 id="1232" class="mv lp jb bd lq mw mx dn lu my mz dp ly kz na nb ma ld nc nd mc lh ne nf me ng bi translated">语义学</h2><p id="4042" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated"><code class="fe ml mm mn mo b">then</code>不是语义。当然，从语义上说“这发生了，<code class="fe ml mm mn mo b">then</code>这发生了”，但这不是我的意思。您传递到promise的<code class="fe ml mm mn mo b">then</code>中的每个函数要么是匿名的(即未命名的),要么是存在于您的应用程序中其他地方的已命名的函数。这导致了你在回调中发现的同样的间接性，由于操作的线性，这种间接性只会稍微好一点。</p><h1 id="cd89" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">结论</h1><p id="c1c0" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如果我有的只是承诺，我会利用它们。在我的书中，它们比回调更受欢迎，在我坚持使用它们的3年里，它们帮助我管理JavaScript中的异步，这是一个巨大的进步，但在我过去一年多写的所有东西中，我选择了observables，因为它们很好，超出了你可以从承诺中期望的任何东西的完整包。</p><p id="52a8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你的承诺越简单，就越容易实现。你的承诺越长，在应用程序中传递的次数越多，就越难追踪，也越不可靠。</p><p id="a8ba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">我喜欢承诺吗？<br/> </strong>是的。</p><p id="78eb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我认为可观察的更好吗？<br/> 当然。</p><p id="8d43" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我在使用回调，我会答应吗？<br/> 大概再也不会了。</p><h1 id="8b42" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">更多阅读</h1><p id="40ee" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">我还会收到更多这样的异步文章！前一个是关于回调的:</p><p id="7a7a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/the-definitive-guide-to-callbacks-in-javascript-44a39c065292">试听:权威指南</a></p><p id="9d0c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你喜欢你所读的，请查看我关于类似的令人大开眼界的主题的其他文章:</p><ul class=""><li id="e1de" class="nh ni jb ks b kt ku kw kx kz nj ld nk lh nl ll nm nn no np bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/feature-flags-be-truly-agile-820ff50294c">特性标志:真正敏捷</a></li><li id="f767" class="nh ni jb ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223">用食物表情符号制作便便</a></li><li id="86a2" class="nh ni jb ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/async-react-using-react-router-suspense-a86ade1176dc">使用React路由器的异步React&amp;暂停</a></li><li id="8184" class="nh ni jb ks b kt nq kw nr kz ns ld nt lh nu ll nm nn no np bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/using-transducers-to-speed-up-javascript-arrays-92677d000096">使用转换器加速JavaScript数组</a></li></ul></div></div>    
</body>
</html>