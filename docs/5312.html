<html>
<head>
<title>Easiest guide to .bashrc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最简单的指南。bashrc</h1>
<blockquote>原文：<a href="https://itnext.io/easiest-guide-to-bashrc-7ad0063d37eb?source=collection_archive---------0-----------------------#2021-02-07">https://itnext.io/easiest-guide-to-bashrc-7ad0063d37eb?source=collection_archive---------0-----------------------#2021-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我带着<code class="fe kl km kn ko b">.bashrc</code>文件的旅程充其量只能算是忙乱。消化如何构造一个<code class="fe kl km kn ko b">bash</code>程序的语法和逻辑一直是一个问题。我希望这能让人们的生活变得更轻松，让bash变得更简单。也就是说，我喜欢巴什。无数次，我有一长串终端命令需要得到<em class="kp">正确的</em>。人们说bash像一把锤子，所有东西看起来都像钉子。在这种情况下，它<em class="kp">是</em>一个钉子。</p><p id="1f12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向宗教人士讲述<code class="fe kl km kn ko b">bash</code>大会。是的，我打破它们，这是我个人的惯例。我认为<code class="fe kl km kn ko b">bash</code>是一次个人旅程，你可以用一种对你自己而不是别人来说最简单的方式来表达你想让你的电脑做什么。</p><h1 id="3fc6" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">内容</h1><p id="78b0" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在本指南中，我们将探索几个概念。我们不会讨论提示本身，因为这可能是我所知道的最糟糕的语法之一。我很乐意把这些留给一些在线模板，那里有很多。</p><p id="3b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将涵盖的内容:</p><ul class=""><li id="5987" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">基本bash语法</li><li id="c7a6" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">表达式(和环境变量)</li><li id="cd49" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">用线串</li><li id="d8c4" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">多档<code class="fe kl km kn ko b">.bashrc</code></li><li id="6f57" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">自动化</li></ul><p id="98b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将<strong class="jp ir">不</strong>涵盖的内容:</p><ul class=""><li id="7c71" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">外壳工具如<code class="fe kl km kn ko b">du</code>、<code class="fe kl km kn ko b">sed</code>、<code class="fe kl km kn ko b">awk</code>等。这些超出了本文的范围</li><li id="536f" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">提示符(在我的例子中为<code class="fe kl km kn ko b">oli-TM1701 10:36 ~ $</code>)</li></ul><h1 id="bec1" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">句法</h1><p id="188e" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">Bash有一种特殊的语法，这在大多数现代编程语言中并不常见。但是不要误解它，如果用一种干净的方式写，它的奇怪之处在于它的力量和简洁。</p><h2 id="bb6a" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">功能</h2><p id="7e54" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">我想从一个基本的函数开始，因为它们是每个程序的构造块，而且令人惊讶的是，在我看到的大多数shell脚本中最缺少的。我们只是打印函数的参数。</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="c604" class="mh kr iq ko b gy nb nc l nd ne">print_args() {<br/>  echo $0<br/>  echo $1<br/>  echo $2<br/>}</span></pre><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/341f0bdea6069d568c9c0984ea90827e.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*tmyIHr0it2Xasr_GCmZEQQ.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">输出</figcaption></figure><p id="8c2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe kl km kn ko b">$0</code>是执行命令的程序，那么参数被列为<code class="fe kl km kn ko b">$1</code>、<code class="fe kl km kn ko b">$2</code>等等。然后我们可以像这样创建一些基本的局部变量。</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="c25a" class="mh kr iq ko b gy nb nc l nd ne">print_args() {<br/>  local first=$1<br/>  echo $first<br/>}</span></pre><p id="35a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:如果在<code class="fe kl km kn ko b">first</code>、<code class="fe kl km kn ko b">=</code>和<code class="fe kl km kn ko b">$1</code> <strong class="jp ir">之间有空格，则该赋值无效。现在是下一个令人困惑的部分…</strong></p><h2 id="bd23" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">从函数返回值</h2><p id="7326" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">如果你认为可以像在大多数语言中一样，通过使用<code class="fe kl km kn ko b">return</code>语句从函数中获得一个<code class="fe kl km kn ko b">return</code>值，我不会责怪你。只是<code class="fe kl km kn ko b">bash</code>做事情有点不同。<strong class="jp ir"/><code class="fe kl km kn ko b">return</code><strong class="jp ir">语句仅用于返回代码</strong>。对于那些记得<code class="fe kl km kn ko b">C</code>或相关语言的人来说，这是一个<code class="fe kl km kn ko b">integer</code>。但这并不意味着它没有用。这里有一个使用非常常见的<code class="fe kl km kn ko b">&amp;&amp;</code>操作符连接bash操作的例子。</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="3aa1" class="mh kr iq ko b gy nb nc l nd ne">passes() {<br/>  return 0<br/>}</span><span id="1ad1" class="mh kr iq ko b gy nn nc l nd ne">fails () {<br/>  return 1<br/>}</span></pre><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d7e3e28069f80f0561939e8f173da843.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*U20x_m0prnxkkFXrE1zx1A.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">输出</figcaption></figure><p id="a048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到现在为止，你应该在想“那么我们如何获得返回值呢？”。答案是<code class="fe kl km kn ko b">stdout</code>，我们将在下一节看到。</p><h2 id="6158" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">评估表达式</h2><p id="ea8e" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">表达式对于任何干净的脚本来说都是至关重要的，但是，就像T9中的其他东西一样，语法并不是最好的。这将我们带到bash的核心原则之一。如果你能在控制台中看到它，你可以把它放在一个变量中。实质上是用<code class="fe kl km kn ko b">echo</code>变量的基本打印相当于一个<em class="kp">表达式</em>而不是一个<em class="kp">过程</em>。当我学习<code class="fe kl km kn ko b">bash</code>的时候，这是一个小小的大脑弯曲，但是唉，事情就是这样做的。这里有几个例子:</p><p id="d006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kl km kn ko b">$(expression)</code>操作器。</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="8ef6" class="mh kr iq ko b gy nb nc l nd ne">cool_string() {<br/>  echo "$1 is cool"<br/>}</span><span id="9a85" class="mh kr iq ko b gy nn nc l nd ne">very_cool_string() {<br/>  echo "$(cool_string Oli), very cool in fact."<br/>}</span></pre><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi np"><img src="../Images/5da4929674e55b7e90a884a06645d9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*YS4STn8M6sR1GjCbNkq2nQ.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">输出</figcaption></figure><p id="0b1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一些工具来做一些更奇特的事情。让我们来看看<code class="fe kl km kn ko b">eval</code>命令。<code class="fe kl km kn ko b">eval</code>简单地运行传递给它的任何内容，就像您将它直接键入终端一样。这里有一个有趣的例子，我们创建了一个函数，这个函数会无缘无故地创建环境变量:</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="aa35" class="mh kr iq ko b gy nb nc l nd ne">var() {<br/>  eval "export $1=\"$2\""<br/>}</span></pre><p id="3bc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您不知道<code class="fe kl km kn ko b">export</code>命令，那么这是一种为您的shell会话分配环境变量的方法。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/69109cae8c97fb0dc77b5c1be3ba398d.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*RcE0AIEiB4h2v6vDUNZpMw.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">输出</figcaption></figure><h2 id="ff20" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">用线串</h2><p id="b094" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">所以现在我们到了这一点，细心的读者意识到bash的一切都归结于拥有字符串、执行它们和/或将它们转换成不同的字符串。现在应该开始明白为什么Linux上有这么多工具来操作字符串了，比如<code class="fe kl km kn ko b">sed</code>、<code class="fe kl km kn ko b">awk</code>、<code class="fe kl km kn ko b">grep</code>等等。我们可以直接获取字符串，将它们处理成一个<code class="fe kl km kn ko b">bash</code>命令并执行它们，这就是<strong class="jp ir">闪电般的速度</strong>！</p><p id="d418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们像上面一样做一些字符串模板。</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="2e37" class="mh kr iq ko b gy nb nc l nd ne">date_strings() {<br/>  local date_arg="next Fri"<br/>  echo 'date --date="$date_arg"'<br/>  echo "date --date='$date_arg'"<br/>  echo `date --date="$date_arg"`<br/>  echo $(date --date="$date_arg")<br/>}</span></pre><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/7a19716895391cd5c072534f88842aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*OQC8emb0nm92TgD41Qzxkw.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">输出</figcaption></figure><p id="c5eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">'</code>:就是你所见即所得(WYSIWYG)的方式做字符串。</p><p id="dec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">"</code>:是字符串模板。就像python中的<code class="fe kl km kn ko b">f'template {variable}'</code>或者javascript中的<code class="fe kl km kn ko b">`template ${variable}`</code>。在这种情况下，曲线<code class="fe kl km kn ko b">{}</code>只是普通变量。</p><p id="ae5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">`</code>:同<code class="fe kl km kn ko b">$(expression)</code>。这可能看起来很混乱，因为它不是真正的字符串或字符串模板，而是函数调用/表达式求值。</p><h2 id="b5ce" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">条件式</h2><p id="6412" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">如果你希望这是直觉，那么我再次抱歉。条件句有点古怪，尤其是在引擎盖下。先来解释一个叫<code class="fe kl km kn ko b">[</code>的程序(对，一个程序)。</p><p id="d676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它接受像<code class="fe kl km kn ko b">[ arg1 -flag arg2 ]</code>这样的参数和标志，它们之间留有空格。这就是为什么当我们在终端中输入<code class="fe kl km kn ko b">["arg1"</code>时会出现这个可笑的错误，因为它不是语法错误。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/911c60dcce892a3944811bf670c6c27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*3i26-Vm0T_xY5jG6q29C0w.png"/></div></figure><p id="9a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用我们的先验知识来看看条件句。因为我们知道<code class="fe kl km kn ko b">[</code>是一个程序，并且程序有一个返回值(如果一切正常，则为0，否则为错误代码，如1)。让我们用几个参数运行<code class="fe kl km kn ko b">[</code>程序。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/737e4acbc843d8d15d8bcf9af25b0deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9h5EzxcgeuDgGeXMl809DQ.png"/></div></div></figure><p id="ea57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候看看<code class="fe kl km kn ko b">bash</code>中的<code class="fe kl km kn ko b">if</code>语句了。我们将使用<code class="fe kl km kn ko b">-f</code>标志，表示“这个文件存在吗？”然后用它平白无故写一个<code class="fe kl km kn ko b">import</code>函数。我们还将使用<code class="fe kl km kn ko b">.</code>来加载我们的文件。要查看您可以使用哪些标志，请查看此页面，其中的<code class="fe kl km kn ko b">-z</code>尤其有用。:)</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="3738" class="mh kr iq ko b gy nb nc l nd ne">import() {<br/>  local suffix='.bashrc'<br/>  local file_name="$1$suffix"<br/>  if [ -f $file_name ]<br/>  then<br/>    . $file_name<br/>  else<br/>    echo "ImportError: $file_name"<br/>  fi<br/>}</span></pre><p id="50a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将尝试加载我们的<code class="fe kl km kn ko b">~/.bashrc</code>和一个不存在的名为<code class="fe kl km kn ko b">something.bashrc</code>的文件。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e5df7d1b5606454c58a9732a443ba922.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*VFFTtBcxH5ETjKreYpBIpg.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">输出</figcaption></figure><p id="eb69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有另一个创造性的用于条件句的程序叫做<code class="fe kl km kn ko b">[[</code>，它有非常相似的语法，但是有不同的效果。在某些情况下，这是一个简单的比较。</p><h2 id="4f34" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">多文件。bashrc</h2><p id="cc69" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">好了，有了上面的工具和指定一个文件作为另一个<code class="fe kl km kn ko b">.bashrc</code>加载的<code class="fe kl km kn ko b">.</code>，你已经可以自己做了。:)</p><h2 id="d0b6" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">将它备份到。饭桶</h2><p id="8777" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">只要记得这么做，这很重要。</p><ul class=""><li id="1d22" class="lt lu iq jp b jq jr ju jv jy lv kc lw kg lx kk ly lz ma mb bi translated">让你的<code class="fe kl km kn ko b">~/.bashrc</code>尽可能的空。</li><li id="cef5" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">为您的<code class="fe kl km kn ko b">.bashrc</code>文件文件夹指定一个环境变量。</li><li id="3f4c" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">加载一个<code class="fe kl km kn ko b">index.bashrc</code>或者<code class="fe kl km kn ko b">__init__.bashrc</code>，如果你愿意的话，加载其余的。</li><li id="4048" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi">???</li><li id="c345" class="lt lu iq jp b jq mc ju md jy me kc mf kg mg kk ly lz ma mb bi translated">利润。</li></ul><h1 id="cda4" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">自动化</h1><p id="c1d9" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">现在你已经有了为你的<code class="fe kl km kn ko b">bashrc</code>创建小功能所需的大部分工具，试一试，创建一些非常基本的功能。使用上面的语法，你可以自动搜索你的<code class="fe kl km kn ko b">bash</code>历史记录…</p><pre class="mt mu mv mw gt mx ko my mz aw na bi"><span id="ff2b" class="mh kr iq ko b gy nb nc l nd ne">search_history() {<br/>  history | grep $1<br/>}</span></pre><p id="2182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建立和签署一个<code class="fe kl km kn ko b">android</code> apk。记住，就像其他事情一样:没有什么比练习更好的了。</p><p id="24a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。</p><h2 id="1608" class="mh kr iq bd ks mi mj dn kw mk ml dp la jy mm mn le kc mo mp li kg mq mr lm ms bi translated">进一步阅读</h2><p id="371d" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">5个小时的反复试验可以节省整整几分钟阅读文档的时间。<br/> * <a class="ae ny" href="https://linux.die.net/man/1/bash" rel="noopener ugc nofollow" target="_blank"> Bash docs(也可以通过</a> <code class="fe kl km kn ko b">man bash</code> <a class="ae ny" href="https://linux.die.net/man/1/bash" rel="noopener ugc nofollow" target="_blank">)在终端中访问</a></p><p id="f1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些书让我跨越了几年的经验。罗伯特·马丁的<br/> * <a class="ae ny" href="https://amzn.to/3z083SU" rel="noopener ugc nofollow" target="_blank">干净的代码</a> <br/> * <a class="ae ny" href="https://amzn.to/2UyrEdS" rel="noopener ugc nofollow" target="_blank">干净的架构</a></p><p id="31a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">———本文编辑— — <br/> 1。通过互联网的力量，我的文章中的错误暴露出来，我用更准确的信息更新了文章，比如使用局部变量。</p><p id="6cab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在文章中添加了我最喜欢的编程书籍。</p></div></div>    
</body>
</html>