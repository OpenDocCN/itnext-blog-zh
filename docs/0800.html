<html>
<head>
<title>Offline OCR with TesseractJS and Ionic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TesseractJS和Ionic的离线OCR</h1>
<blockquote>原文：<a href="https://itnext.io/offline-ocr-with-tesseractjs-and-ionic-5054fc7eef86?source=collection_archive---------3-----------------------#2018-05-31">https://itnext.io/offline-ocr-with-tesseractjs-and-ionic-5054fc7eef86?source=collection_archive---------3-----------------------#2018-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1bc19e8288998c1ccf27210670991b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMoNCz8nJYO3gLQklPJ63g.jpeg"/></div></div></figure><p id="9372" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能有一千个理由希望在你的下一个应用程序中使用光学字符识别(OCR ),谷歌和亚马逊都是完成这项任务的强大云工具。</p><p id="d325" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您处理敏感数据和/或需要您的应用程序100%离线运行时，事情会变得更加有趣。</p><p id="d762" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我开发识别数字的离线应用的过程中，我遇到了Ionic和Cordova的多个存储库。有些已经过时，有些根本不起作用。几乎所有的文本识别库都是基于<a class="ae kw" href="https://github.com/tesseract-ocr/tesseract" rel="noopener ugc nofollow" target="_blank">宇宙魔方</a>，包括流行的<a class="ae kw" href="https://github.com/naptha/tesseract.js" rel="noopener ugc nofollow" target="_blank">宇宙魔方</a>。</p><p id="9ad8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，TesseractJS已经有了很好的文档，应该很容易启动和运行。然而，在撰写本文时，您会在自述文件中提供的CDN链接上遇到404。此外，在为我的应用程序项目进行<em class="kx">本地安装</em>时，我遇到了其他几个障碍，我将在本文中解决这些问题。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="5979" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从爱奥尼亚开始</h1><p id="61bf" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated"><em class="kx">如果你对建立一个Ionic项目不感兴趣，你可以跳过这一部分。</em></p><p id="99fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你已经安装了<a class="ae kw" href="https://ionicframework.com/getting-started" rel="noopener ugc nofollow" target="_blank"> Ionic，</a>如果你还没有的话，继续创建一个新项目。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="45d2" class="mr lg iq mn b gy ms mt l mu mv">ionic start tesseractApp blank</span></pre><p id="a809" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的新项目中，我们将继续安装<code class="fe mw mx my mn b">tesseract.js</code>并创建一个<strong class="ka ir">提供者</strong>。如果你不知道提供者是什么，它是一个服务类，我们将在其中实现我们的OCR逻辑，以便稍后在整个应用程序的任何地方使用。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0044" class="mr lg iq mn b gy ms mt l mu mv">cd tesseractApp<br/>npm install tesseract.js --save<br/>ionic g provider OcrProvider</span></pre><p id="415d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您喜欢的编辑器中打开新的提供者<code class="fe mw mx my mn b">src/providers/ocr/ocr.ts</code>。让我们导入宇宙魔方，它看起来像这样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3a9c" class="mr lg iq mn b gy ms mt l mu mv"><strong class="mn ir">import </strong>{ Injectable } <strong class="mn ir">from </strong>'@angular/core';<br/><strong class="mn ir">import </strong>Tesseract <strong class="mn ir">from </strong>'tesseract.js';<br/><br/>@Injectable()<br/><strong class="mn ir">export class </strong>OcrProvider {</span><span id="ceed" class="mr lg iq mn b gy mz mt l mu mv">  constructor() {<br/>    console.log('Hello OcrProvider');<br/>  }</span><span id="7c62" class="mr lg iq mn b gy mz mt l mu mv">}</span></pre><p id="21e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，您实际上已经准备好在应用程序中使用Tesseract类了。但是我们还没有完成，我们想要一个本地的，100%离线安装。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="cd93" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让宇宙魔方离线工作</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/8b32b545c802b7c82cffdc9e56099603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5Rq7oJgWgOaH8bdPGo9-w.png"/></div></div></figure><p id="c33c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您阅读过GitHub上的TesseractJS自述文件，您会看到本地安装的说明，要求您在使用识别功能之前创建一个Tesseract实例。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="37cb" class="mr lg iq mn b gy ms mt l mu mv">Tesseract.create({<br/>    workerPath: '/path/to/worker.js',<br/>    langPath: '/path/to/lang/',<br/>    corePath: '/path/to/core.js',<br/>});</span></pre><h2 id="28e9" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">在爱奥尼亚启动宇宙魔方</h2><p id="0436" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在我们的Ionic项目中，让我们将上面的片段放在我们的<code class="fe mw mx my mn b">OcrProvider</code>的<code class="fe mw mx my mn b">constructor</code>中:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5d53" class="mr lg iq mn b gy ms mt l mu mv"><strong class="mn ir">import </strong>{ Injectable } <strong class="mn ir">from </strong>'@angular/core';</span><span id="f23a" class="mr lg iq mn b gy mz mt l mu mv">// Import Tesseract.<strong class="mn ir"><br/>import </strong>Tesseract <strong class="mn ir">from </strong>'tesseract.js';<br/><br/>@Injectable()<br/><strong class="mn ir">export class </strong>OcrProvider {</span><span id="191d" class="mr lg iq mn b gy mz mt l mu mv">  /**<br/>   * Add a variable for our tesseract instance.<br/>   */  <br/>  private readonly <strong class="mn ir">tesseract</strong>;</span><span id="1b78" class="mr lg iq mn b gy mz mt l mu mv">  constructor() {<br/>    console.log('Hello OcrProvider');</span><span id="711c" class="mr lg iq mn b gy mz mt l mu mv">    /**<br/>     * Create our tesseract instance.<br/>     */<br/>    <strong class="mn ir">this</strong>.tesseract = Tesseract.<strong class="mn ir">create</strong>({<br/>      <strong class="mn ir">workerPath</strong>: '/path/to/worker.js',<br/>      <strong class="mn ir">langPath</strong>: '/path/to/lang/',<br/>      <strong class="mn ir">corePath</strong>: '/path/to/core.js',<br/>    });</span><span id="a444" class="mr lg iq mn b gy mz mt l mu mv">  }</span><span id="7420" class="mr lg iq mn b gy mz mt l mu mv">}</span></pre><p id="89f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们在<code class="fe mw mx my mn b">OcrProvider</code>的开头声明了一个变量<code class="fe mw mx my mn b">tesseract</code>。如果你想知道<code class="fe mw mx my mn b">private readonly</code>的语法，<code class="fe mw mx my mn b">private</code>意味着变量只能从<code class="fe mw mx my mn b">OcrProvider</code>内部访问，<code class="fe mw mx my mn b">readonly</code>保护变量不被<code class="fe mw mx my mn b">constructor</code>之外的任何地方更改。</p><h2 id="c060" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">获取本地宇宙魔方文件</h2><p id="dbc0" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">对于我们的宇宙魔方安装，我们需要三种类型的文件。</p><ol class=""><li id="3f2a" class="nm nn iq ka b kb kc kf kg kj no kn np kr nq kv nr ns nt nu bi translated">TesseractJS工作者</li><li id="8ad0" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">训练有素的语言文件</li><li id="80f2" class="nm nn iq ka b kb nv kf nw kj nx kn ny kr nz kv nr ns nt nu bi translated">宇宙魔方核心</li></ol><p id="f23d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以从<em class="kx"> naptha </em>的GitHub repo的<a class="ae kw" href="https://github.com/naptha/tesseract.js/tree/master/dist" rel="noopener ugc nofollow" target="_blank"> dist文件夹</a>中直接抓取<code class="fe mw mx my mn b">worker.js</code>和<code class="fe mw mx my mn b">core.js</code>。</p><p id="57b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些文件在Ionic应用中的一个好位置可能是:<code class="fe mw mx my mn b">src/assets/lib</code>(新目录)。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/31fe234e1aa9c8d1faf0a62939a772ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y86Jwpq_Nmy-x4ZLto1kJg.png"/></div></div></figure><p id="2477" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要拿到语言文件。通常它们可以在<a class="ae kw" href="https://github.com/tesseract-ocr/tessdata_best" rel="noopener ugc nofollow" target="_blank"> tessdata_best </a>下的原始宇宙魔方存储库中找到。但是TesseractJS期望<strong class="ka ir">gzipped</strong><em class="kx"/>trained data，如果你想节省带宽或者保持你的应用包较小，这是很有意义的。</p><p id="6f7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们没有在本地配置中运行TesseractJS，我们可以从同一个地方获取那些gzipped traineddata语言文件，就像tessera ctjs会下载它们一样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="db6c" class="mr lg iq mn b gy ms mt l mu mv">https://cdn.rawgit.com/naptha/tessdata/gh-pages/3.02/</span></pre><p id="d902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说<em class="kx"> naptha </em>的另一个GitHub repo:</p><p id="4c04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/naptha/tessdata/tree/gh-pages/3.02" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">https://github.com/naptha/tessdata/tree/gh-pages/3.02</strong></a></p><p id="82be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取所有你需要的语言，并将它们保存在<code class="fe mw mx my mn b">assets</code>下的新<code class="fe mw mx my mn b">lib</code>文件夹中。为了清楚起见，我在我的文件前面加上了<em class="kx"> tesseract.js- </em>，所以<code class="fe mw mx my mn b">eng.traineddata.gz</code>变成了<code class="fe mw mx my mn b">tesseract.js-eng.traineddata.gz</code>。</p><p id="192c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，用新路径调整您的<code class="fe mw mx my mn b">OcrProvider</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3b2e" class="mr lg iq mn b gy ms mt l mu mv"><strong class="mn ir">this</strong>.tesseract = Tesseract.<strong class="mn ir">create</strong>({<br/>  <strong class="mn ir">workerPath</strong>: '/assets/lib/tesseract.js-worker_1.0.10.js',<br/>  <strong class="mn ir">langPath</strong>: '/assets/lib/lang/tesseract.js-',<br/>  <strong class="mn ir">corePath</strong>: '/assets/lib/tesseract.js-core_0.1.0.js',<br/>});</span></pre></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="63a7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用Tesseract.js从图像中识别文本</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/036f349630db783e126c294b4f40d1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*Ws71hRaKyIBU6BU_IFvnMg.png"/></div></figure><p id="ecfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在该喂野兽了。如果您有一个数据url (base64编码的图像)或一个HTML <code class="fe mw mx my mn b">&lt;img&gt;</code>元素，这两者都是好的。对于<code class="fe mw mx my mn b">&lt;img&gt;</code>元素，确保等待它加载。</p><p id="be48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Ionic或Angular中，您可以使用<code class="fe mw mx my mn b">(load)</code>事件发射器:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a783" class="mr lg iq mn b gy ms mt l mu mv"> <!-- -->&lt;img src="..." (load)="myOcr($event)" /&gt;</span></pre><p id="b9d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在普通的JavaScript中，您可以挂钩到<code class="fe mw mx my mn b">onload</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5eb6" class="mr lg iq mn b gy ms mt l mu mv">&lt;img src="..." onload="myOcr" /&gt;</span></pre><p id="d8f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们已经认识了一些数字！向您的OcrProvider添加一个方法，例如<code class="fe mw mx my mn b">public recognizeText(image)</code>，它与Tesseract交互，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4e8d" class="mr lg iq mn b gy ms mt l mu mv">const tesseractConfig = {<br/>  // If you want to set the language explicitly:<br/>  <strong class="mn ir">lang</strong>: 'eng', <br/>  // You can play around with half-documented options:<br/>  <strong class="mn ir">tessedit_char_whitelist</strong>: ' 0123456789',<br/>};</span><span id="f507" class="mr lg iq mn b gy mz mt l mu mv"><strong class="mn ir">this</strong>.tesseract.<strong class="mn ir">recognize</strong>(image, tesseractConfig)<br/>  .<strong class="mn ir">progress</strong>((v) =&gt; {<br/>    // v.status is a textual string of what Tesseract is doing<br/>    // v.progress is a 0 - 1 decimal representation of the progress.<br/>    // The progress resets for each new v.status,<br/>    // but the major event is v.status == "recognizing text<strong class="mn ir">".</strong></span><span id="fd39" class="mr lg iq mn b gy mz mt l mu mv">    console.log(v.status, status.<strong class="mn ir">progress</strong>);<strong class="mn ir"><br/></strong>  })<br/>  .<strong class="mn ir">catch</strong>((err) =&gt; {<br/>    console.error('OcrProvider: Failed to analyze text.', err);<br/>  })<br/>  .<strong class="mn ir">then</strong>((result) =&gt; {<br/>    // Result contains these elements:<br/>    // blocks: Array<br/>    // confidence: 0 - 100<br/>    // html: string<br/>    // lines: string[]<br/>    // oem: "DEFAULT"<br/>    // paragraphs: string[]<br/>    // psm: "SINGLE_BLOCK"<br/>    // symbols: Array<br/>    // text: string<br/>    // version: "3.04.00"<br/>    // words: string[]</span><span id="3f73" class="mr lg iq mn b gy mz mt l mu mv">    // I chose to use a regex to find the <br/>    // correct format out of result.text.  <br/>  });</span></pre><h2 id="3b43" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">接下来</h2><p id="5eee" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果你想看我如何使用Ionic Native <a class="ae kw" href="https://ionicframework.com/docs/native/camera-preview/" rel="noopener ugc nofollow" target="_blank">相机预览</a>插件让用户在自定义帧内查看、调整和拍摄某些东西，然后再将它们传送到宇宙魔方，请告诉我！</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="d536" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">让我们压扁一些虫子</h1><p id="9cdf" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">这里有几个问题，你最好早点想到，而不是像我一样，相信一切都正常，然后花几个小时调试。来自宇宙魔方的错误消息往往非常隐晦，甚至很难被识别为来自宇宙魔方。</p><h2 id="8b07" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">DataCloneError:无法克隆对象</h2><p id="4a34" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在完成了下载TesseractJS、语言训练数据文件和建立一个新的Ionic项目的所有工作之后，这个错误消息可能意味着任何事情。相反，它实际上表明一切都在工作——至少几乎是这样。宇宙魔方还活着，还在呼吸，但是你给了它一些它不理解的图像数据。Woops，说说清楚的错误信息。</p><p id="bf94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你碰巧用<code class="fe mw mx my mn b">@ViewChild('myImg') img;</code>得到了你的图像，确保用<code class="fe mw mx my mn b">this.img.nativeElement</code>提供宇宙魔方。</p><h2 id="7384" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">Tesseract.reconize不返回承诺</h2><p id="fd7b" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">它看起来很熟悉它的<code class="fe mw mx my mn b">catch</code>和<code class="fe mw mx my mn b">then</code>回调方法，但是和<code class="fe mw mx my mn b">progress</code>一起，它并不是一个常规的承诺。我试图把它链接成一个常规的承诺，结果有些混乱，所以我最后把它包装成这样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="afe7" class="mr lg iq mn b gy ms mt l mu mv">return new Promise&lt;string&gt;((resolve, reject) =&gt; {</span><span id="9565" class="mr lg iq mn b gy mz mt l mu mv">  <strong class="mn ir">this</strong>.tesseract.<strong class="mn ir">recognize</strong>(image)<br/>    .<strong class="mn ir">progress</strong>((v) =&gt; console.log(v))<br/>    .<strong class="mn ir">catch</strong>((err) =&gt; reject(err))<br/>    .<strong class="mn ir">then</strong>((result) =&gt; resolve(result.text));</span><span id="9a08" class="mr lg iq mn b gy mz mt l mu mv">});</span></pre><h2 id="e181" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">无法扩大内存阵列</h2><p id="8444" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">同样，很难找到任何关于这个错误的具体参考。我的结论是，宇宙魔方核心是用一些固定大小的内存数组编译的。我试图用各种建议的参数手动配置内存数组的大小，但是没有任何帮助。</p><p id="966d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我使用了缩放和裁剪相机拍摄的图像的组合。显然，为了保持宇宙魔方预测的准确性，我们不想过多地牺牲图像质量，但在我的例子中，我知道用户将要拍摄的媒体格式，并围绕它建立一个框架。当用户调整框架内的文本时，我可以通过编程将图像裁剪成三部分，并通过Tesseract一次运行一部分。</p><p id="8238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有人知道如何扩大内存数组，请告诉我！</p><h2 id="9477" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">语法错误:无法在“assets/lib/tessera CT . js-worker _ 1 . 0 . 10 . js”处加载工作脚本</h2><p id="fbce" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">因此，这个“语法错误”是那些真正让你毛骨悚然的神秘信息之一。当您从错误中复制/粘贴路径时，文件加载正常。但是Tesseract.js试图告诉您，它更喜欢本地文件的完整路径。</p><p id="8080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该解决方案将使主机可以在<code class="fe mw mx my mn b">Tesseract.create</code>中的三个路径中的每一个路径前添加前缀。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f1c9" class="mr lg iq mn b gy ms mt l mu mv">const host = window.location.protocol + '//' <br/>  + window.location.hostname<br/>  + (window.location.port ? ':' + window.location.port : '')<br/>  + '/';</span></pre><p id="adbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Woops，这个在安卓上不行。</strong></p><p id="9955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人正在努力寻找一个好方法来确定我们心爱的<code class="fe mw mx my mn b">assets</code>目录的完整路径，跨平台！以上用<code class="fe mw mx my mn b">ionic serve</code>就可以了，但是由于安卓的“主机”看起来更像<code class="fe mw mx my mn b">file://android_asset/</code>，所以上面的<code class="fe mw mx my mn b">host</code>就只是<code class="fe mw mx my mn b">file:///</code>。</p><p id="995c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个丑陋的<em class="kx">主机</em>适用于Android、iOS <em class="kx">和</em> <code class="fe mw mx my mn b">ionic serve</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1328" class="mr lg iq mn b gy ms mt l mu mv"><strong class="mn ir">const </strong>href = window.location.href;</span><span id="cf97" class="mr lg iq mn b gy mz mt l mu mv"><strong class="mn ir">const </strong>hashIndex = href.indexOf('#');</span><span id="15f3" class="mr lg iq mn b gy mz mt l mu mv"><strong class="mn ir">const </strong>lastSlashIndex = href.substr(0, <br/>  hashIndex &gt; -1 ? hashIndex : <strong class="mn ir">null<br/></strong>).lastIndexOf('/');</span><span id="e4b9" class="mr lg iq mn b gy mz mt l mu mv"><strong class="mn ir">const </strong>host = href.substr(0, <br/>  lastSlashIndex &gt; -1 ? lastSlashIndex : <strong class="mn ir">null <br/></strong>) + '/';</span></pre><h2 id="9af2" class="mr lg iq bd lh nb nc dn ll nd ne dp lp kj nf ng lt kn nh ni lx kr nj nk mb nl bi translated">Android上的Traineddata语言文件消失了</h2><p id="144b" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">另一个问题是关于它的文档很少，不是关于宇宙魔方，而是一般的Android！所以貌似安卓不喜欢<strong class="ka ir">。gz </strong>文件，有些人用它来完全阻止他们的项目构建。</p><p id="215e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Ionic/Cordova中，似乎这个问题已经通过剥离他们的<strong class="ka ir">文件而被<em class="kx">解决了。gz </em></strong>扩展。因此，我们的项目构建成功，只有当我们启动应用程序时，我们才意识到traineddata语言文件已被重命名，无法由Tesseract加载。</p><p id="7253" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我到处寻找如何包含<strong class="ka ir">。Android应用中的gz </strong>文件，最终放弃，发现了一些好消息！traineddata.gz文件不是由巨大的宇宙魔方核心加载的，而是由未缩小的<code class="fe mw mx my mn b">worker.js</code>加载的。</p><p id="c1fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它就在8421行的显眼位置:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ff29" class="mr lg iq mn b gy ms mt l mu mv">8420<strong class="mn ir">: var </strong>lang = req.options.lang;<br/>8421<strong class="mn ir">: var </strong>langfile = lang + '.traineddata.gz'; // Hello, friend!<br/>8422<strong class="mn ir">: var </strong>url = req.workerOptions.langPath + langfile;</span></pre><p id="7bed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决办法很明显！我只是重命名了我的traineddata语言文件，去掉了<strong class="ka ir">。gz </strong>扩展我自己，所以没有机器人可以为我做。然后剥离掉<strong class="ka ir">。gz </strong>在<code class="fe mw mx my mn b">worker.js</code>线8421也一样，瞧！</p><p id="869f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mw mx my mn b">tesseract.js-eng.traineddata.gz</code>变成了<code class="fe mw mx my mn b">tesseract.js-eng.traineddata</code></p><p id="5852" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(记住这仍然是一个gzip文件)。</p><p id="e2da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有人知道是怎么回事。gz-Android上的文件，请告诉我！</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="56de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你学到了一些东西，我知道我做到了。</p><p id="37a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这以任何方式帮助了你，请留下评论和一个或五个掌声。</p><p id="214a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我错过了什么吗？还是你在纠结一些我忘记掩盖的错误？告诉我，我会尽力帮忙的。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="f44e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更新:</strong>在多次请求演示该功能的工作库之后，我现在已经创建了一个:【https://github.com/westphalen/ionic-tesseract-app】T2</p></div></div>    
</body>
</html>