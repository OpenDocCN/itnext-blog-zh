<html>
<head>
<title>Create your first Serverless workflow with Durable functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建第一个具有持久功能的无服务器工作流</h1>
<blockquote>原文：<a href="https://itnext.io/durable-functions-stateful-long-running-functions-in-serverless-part-i-1f707b8878c7?source=collection_archive---------8-----------------------#2019-06-03">https://itnext.io/durable-functions-stateful-long-running-functions-in-serverless-part-i-1f707b8878c7?source=collection_archive---------8-----------------------#2019-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3c7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，很高兴接受您对主题或改进的建议/Chris</p><blockquote class="kp kq kr"><p id="6b20" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">持久函数是Azure函数的一个扩展，它允许你在一个无服务器的环境中编写有状态的函数。持久功能为您管理</em><code class="fe kw kx ky kz b"><em class="it">state</em></code><em class="it"/><code class="fe kw kx ky kz b"><em class="it">checkpoints</em></code><em class="it">，</em> <code class="fe kw kx ky kz b"><em class="it">restarts</em></code> <em class="it">。</em></p></blockquote><p id="bded" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你问这话是什么意思？</p><p id="fbc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着你可以拥有长时间运行的函数，比如真正的长时间运行的函数。它也有一个状态，这意味着它记得它在哪里，就像一个工作流。</p><p id="6202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个怎么样？想象一下你有这样一种情况，你需要通过将某样东西划分到不同的检查点来管理它。每个检查点都离被认为<em class="ks">已处理</em>更近了一步。更具体地想象一个游戏，例如，你需要加载一堆不同的资源，只有当所有的东西都被加载并准备好了，你才能玩这个游戏。</p><blockquote class="kp kq kr"><p id="0798" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">哦，好的，这就像一个工作流框架</em></p></blockquote><p id="a292" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，正是如此，它使您能够指定应该如何通过流程来执行某件事情。甚至有不同的架构模式被推荐给不同的流程。</p><blockquote class="kp kq kr"><p id="ca7e" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">听起来很贵，是吗？</p></blockquote><p id="9f30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不，不完全是，付费模式非常接近Azure Functions使用的模式，只在功能/工作流实际执行时付费。</p><blockquote class="kp kq kr"><p id="dbe1" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">听起来很棒，多告诉我一些</em></p></blockquote><p id="6365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将涵盖:</p><ul class=""><li id="b92a" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated">什么是持久功能，让我们讨论一下它是什么，核心概念是什么</li><li id="6b1b" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">它是如何工作的，我们将解释一下它是如何工作的</li><li id="1c08" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated">资源，我们会给你一些资源，这样你可以更深入地研究</li><li id="4173" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">实验室</strong>，我们将通过一个例子进行编码，这样你就可以看到使用中的主要概念以及当</li></ul><h1 id="7dcb" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">概念和高级解释</h1><p id="3b77" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">在处理持久函数时，我们需要了解一些概念。所有的概念都扮演着一个角色，共同使我们能够运行我们的持久功能。</p><ul class=""><li id="c5a1" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated"><strong class="js iu"> Orchestrator功能</strong>，这是一个我们定义工作流的功能，我们设置工作流中应该发生什么、要执行什么活动以及完成后发生什么</li><li id="e45c" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">活动功能</strong>，活动功能是持久功能编排中的基本<em class="ks">工作单元</em>。活动功能是流程中编排的功能和任务。您可以拥有任意多的活动功能。确保给它们起描述性的名字，代表你的流程中的步骤</li><li id="a9fc" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">客户端功能</strong>，客户端功能是创建编排新实例的触发功能。客户端功能是创建持久功能编排实例的入口点</li></ul><blockquote class="kp kq kr"><p id="8a8b" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">好的，我想我明白了，但是你能再解释一下吗？</p></blockquote><p id="0145" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，最好的解释方式是通过一个现实的例子和一幅图像。那么我们来说说<em class="ks">订单处理</em>。在<em class="ks">订单处理</em>中，我们假设要执行以下任务:</p><p id="34fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">鉴于我们知道订单是如何处理的，让我们向您展示这张图片，以便您对工作流程有所了解:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/4699e475fe91a625358db52536490ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZuznEf14udof1uyP.png"/></div></div></figure><p id="31d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，上面我们看到了一个客户端函数是如何被调用的。在创建订单的情况下，这通常是我们从应用程序中点击的HTTP端点。接下来要发生的事情是，客户端函数启动一个编排实例。这意味着我们将获得一个<code class="fe kw kx ky kz b">instance id</code>，我们对那个特定流的唯一引用。接下来要发生的事情是，我们尝试在流程编排中执行所有事情，比如<code class="fe kw kx ky kz b">checking the inventory</code>、<code class="fe kw kx ky kz b">charging the customer</code>和<code class="fe kw kx ky kz b">creating a shipment</code>。</p><h1 id="80ac" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">它是如何工作的</h1><p id="d22f" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">让我们更详细地讨论一下这在技术上是如何工作的。编排的问题在于，它编排的内容通常是异步的，这意味着我们不知道某件事情的确切完成时间。为了避免你为它支付运行成本，持久函数关闭并保存状态。</p><p id="710d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个编排功能被赋予更多的工作要做时(例如，接收到一个响应消息或一个持久定时器到期)，该编排器醒来并从头重新执行整个功能以重建本地状态。</p><blockquote class="kp kq kr"><p id="ad0f" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">等等，重新运行一切？</em></p></blockquote><p id="3a1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不用担心，在重放期间，如果代码试图调用一个函数(或做任何其他异步工作)，持久任务框架会查询当前编排的执行历史。如果发现activity函数已经执行并产生了结果，它会重放该函数的结果，orchestrator代码会继续运行。</p><blockquote class="kp kq kr"><p id="2ad9" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">哦，好的，听起来更好</p></blockquote><p id="6747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重放会一直继续，直到函数代码完成或者它已经调度了新的异步工作</p><h1 id="a4af" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">资源</h1><p id="7b0a" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">- <a class="ae ko" href="https://azure.microsoft.com/en-gb/free/?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">免费帐户Azure帐户</a>你需要在Azure上注册才能使用持久功能<br/> - <a class="ae ko" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/quickstart-js-vscode?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">用JavaScript创建你的第一个持久功能</a>快速入门，带你创建持久功能<br/> - <a class="ae ko" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-concepts?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">持久功能概念</a>在这里阅读更多关于概念和模式以及如何实现所述模式的内容。<br/> - [ <a class="ae ko" href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-checkpointing-and-replay#orchestrator-code-constraints?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank"> Orchestrator功能约束</a> ]您需要了解的约束。</p><h1 id="b381" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">实验室—简单的活动流程</h1><p id="2c40" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">我们相信最好的学习方法是用它来建立一些东西。那么我们该怎么做呢？嗯，很简单。使用VS代码，我们可以安装一个插件，让这个过程变得非常简单:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nd"><img src="../Images/0c290ee859342a44272fbf190b0489ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Surf3zWpTzaFVY4Jpx96MA.png"/></div></div></figure><h2 id="9fd8" class="ne lp it bd lq nf ng dn lu nh ni dp ly kb nj nk mc kf nl nm mg kj nn no mk np bi translated">创建我们的项目</h2><p id="7a55" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">打开命令面板或键入<code class="fe kw kx ky kz b">COMMAND + SHIFT + P</code>。</p><p id="215f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们选择以下选项，创建一个新项目</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/d6915a83dc307c13b8a3d85b5817ab43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rIlx0701vyBpJoJi.png"/></div></div></figure><p id="0358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是我们选择一种语言，我们来看一下<code class="fe kw kx ky kz b">javascript</code>。然后我们面临着一系列的选择:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/6f47d574adb47249a26817a1e17e4b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PGAhFHWonrvM5dqg.png"/></div></div></figure><p id="0e69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在上面看到的，我们突出显示了三个选项，因为这些是我们将在整个实验中使用的选项。我们需要一个入口点<code class="fe kw kx ky kz b">Durable Functions HTTP Start</code>，所以让我们先选择它:</p><p id="4722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们再次创建我们的orchestrator函数os，点击<code class="fe kw kx ky kz b">COMMAND + SHIFT + P</code>并选择<code class="fe kw kx ky kz b">Azure Functions: Create Function</code>和<code class="fe kw kx ky kz b">Durable Functions Orchestrator</code>，让我们将其命名为<code class="fe kw kx ky kz b">Orchestrator</code>。</p><p id="2e53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做时，将要求您选择一个存储帐户:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nq"><img src="../Images/39961573ca1b2ae2cac35116cdb323ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qkmCZ68ZP4NHyDD4LSeKBg.png"/></div></div></figure><p id="8fa8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要选择<code class="fe kw kx ky kz b">Subscription</code>、<code class="fe kw kx ky kz b">Storage account</code>和<code class="fe kw kx ky kz b">Resource group</code>。这样做的原因是，当您保存函数的状态时，需要将它保存在某个地方，以便以后恢复。</p><p id="d435" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们就快成功了，只差一件事来创建<code class="fe kw kx ky kz b">Activity function</code>。我们也可以用<code class="fe kw kx ky kz b">COMMAND+SHIFT+P</code>、<code class="fe kw kx ky kz b">Azure Functions: Create Function</code>和<code class="fe kw kx ky kz b">Durable functions activity</code>来创建它，当它要求我们给它命名时，我们就给它命名为<code class="fe kw kx ky kz b">Hello</code>。</p><p id="9d55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你跟着它走，它应该是这样的:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/85631ade340b364fa2c518feed45d098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CXPzzs0q4pmXtmny.png"/></div></div></figure><h2 id="0b76" class="ne lp it bd lq nf ng dn lu nh ni dp ly kb nj nk mc kf nl nm mg kj nn no mk np bi translated">解释艺术品</h2><p id="5b28" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">好了，我们创建了三个不同的工件，一个<em class="ks"> orchestrator </em>函数，一个<em class="ks"> HTTP start/client函数，</em>和一个<em class="ks">活动函数</em>。这一切是如何运作的？</p><p id="c3d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，这一切都始于<code class="fe kw kx ky kz b">HttpStart</code>功能，启动一切。然后，所述函数启动<code class="fe kw kx ky kz b">Orchestrator</code>,这又启动编排器中指定的<code class="fe kw kx ky kz b">Activity functions</code>。听起来有点理论化，但是让我们深入这些工件，看看代码中发生了什么。</p><h2 id="e361" class="ne lp it bd lq nf ng dn lu nh ni dp ly kb nj nk mc kf nl nm mg kj nn no mk np bi translated">HttpStart</h2><p id="e21e" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">如上所述，这是启动这一切的函数。让我们看看它的源代码，并讨论发生了什么:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="8851" class="ne lp it kz b gy nv nw l nx ny">// HttpStart/index.js</span><span id="f613" class="ne lp it kz b gy nz nw l nx ny">const df = require("durable-functions");<br/><br/>module.exports = async function (context, req) {<br/>    const client = df.getClient(context);<br/>    const instanceId = await client.startNew(<br/>      req.params.functionName, <br/>      undefined, req.body<br/>    );<br/><br/>    context.log(`Started orchestration with ID = '${instanceId}'.`);<br/><br/>    return client.createCheckStatusResponse(<br/>      context.bindingData.req, <br/>      instanceId<br/>    );<br/>};</span></pre><p id="8c95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面我们可以看到，我们通过调用从库<code class="fe kw kx ky kz b">durable-functions</code>导入的持久函数实例<code class="fe kw kx ky kz b">df</code>上的<code class="fe kw kx ky kz b">getClient</code>来获取对<code class="fe kw kx ky kz b">client</code>的引用。<br/>接下来，我们的<code class="fe kw kx ky kz b">client</code>实例调用<code class="fe kw kx ky kz b">startNew</code>，产生一个<code class="fe kw kx ky kz b">instanceId</code>。<code class="fe kw kx ky kz b">instanceId</code>是对这个特定函数调用的引用或<em class="ks">处理程序</em>。这对于本演示来说并不重要，但对于第二个演示，我们将使用该信息。最后要做的事情是我们创建一个HTTP响应。</p><p id="391b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看<code class="fe kw kx ky kz b">function.json</code>，我们的配置文件，在这里我们为我们的函数设置输入和输出:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="445c" class="ne lp it kz b gy nv nw l nx ny">// HttpStart/function.json</span><span id="d950" class="ne lp it kz b gy nz nw l nx ny">{<br/>  "bindings": [<br/>    {<br/>      "authLevel": "function",<br/>      "name": "req",<br/>      "type": "httpTrigger",<br/>      "direction": "in",<br/>      "route": "orchestrators/{functionName}",<br/>      "methods": [<br/>        "post",<br/>        "get"<br/>      ]<br/>    },<br/>    {<br/>      "name": "$return",<br/>      "type": "http",<br/>      "direction": "out"<br/>    },<br/>    {<br/>      "name": "starter",<br/>      "type": "orchestrationClient",<br/>      "direction": "in"<br/>    }<br/>  ]<br/>}</span></pre><p id="dc88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有两条有趣的信息。首先，我们有一个<code class="fe kw kx ky kz b">httpTrigger</code>，也就是说，我们可以通过一个HTTP调用，特别是通过一个名为<code class="fe kw kx ky kz b">orchestrators/{functionName}</code>的路由来访问这个函数。另一条有趣的信息是最后一个类型为<code class="fe kw kx ky kz b">orchestrationClient</code>的条目。这使我们能够在代码中获得一个<code class="fe kw kx ky kz b">client</code>引用，没有它我们就不能。因此，如果您需要一个客户机实例，请记住包含这个配置。</p><h2 id="73e0" class="ne lp it bd lq nf ng dn lu nh ni dp ly kb nj nk mc kf nl nm mg kj nn no mk np bi translated">管弦乐演奏家</h2><p id="94f5" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">接下来让我们看看管弦乐队。这是所有有趣的事情发生的地方，这是我们建立流程的地方，什么时候调用什么函数以及为什么调用。让我们看看代码:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="2b92" class="ne lp it kz b gy nv nw l nx ny">// Orchestrator/index.js</span><span id="dd54" class="ne lp it kz b gy nz nw l nx ny">const df = require("durable-functions");<br/><br/>module.exports = df.orchestrator(function* (context) {<br/>    const outputs = [];<br/><br/>    // Replace "Hello" with the name of your Durable Activity Function.<br/>    outputs.push(yield context.df.callActivity("Hello", "Tokyo"));<br/>    outputs.push(yield context.df.callActivity("Hello", "Seattle"));<br/>    outputs.push(yield context.df.callActivity("Hello", "London"));<br/><br/>    // returns ["Hello Tokyo!", "Hello Seattle!", "Hello London!"]<br/>    return outputs;<br/>});</span></pre><p id="dadd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们看到我们有一个方法<code class="fe kw kx ky kz b">orchestrator</code>,它采用了一个生成器函数。</p><blockquote class="kp kq kr"><p id="a8e2" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated">什么是发电机？</p></blockquote><p id="c4b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们是与<code class="fe kw kx ky kz b">async/await</code>非常相似的概念，允许你以一种看起来同步的方式执行异步代码。您可以通过将<code class="fe kw kx ky kz b">*</code>作为函数声明的一部分来识别它们，如下所示:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="7359" class="ne lp it kz b gy nv nw l nx ny">function*() {}</span></pre><p id="6713" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且使用了关键字<code class="fe kw kx ky kz b">yield</code>。<code class="fe kw kx ky kz b">yield</code>的用法和<code class="fe kw kx ky kz b">await</code>一样，意思是我们应该呆在这里，在代码中等待，直到我们的异步操作结束。</p><p id="0c62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么这对我们上面的代码意味着什么呢？让我们更仔细地看看:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="d27c" class="ne lp it kz b gy nv nw l nx ny">outputs.push(yield context.df.callActivity("Hello", "Tokyo"));</span></pre><p id="f7d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以看到，我们用参数<code class="fe kw kx ky kz b">Hello</code>调用了<code class="fe kw kx ky kz b">context.df.callActivity()</code>，用关键字<code class="fe kw kx ky kz b">yield</code>调用了<code class="fe kw kx ky kz b">Tokyo</code>。这仅仅意味着我们正在调用带有参数<code class="fe kw kx ky kz b">Tokyo</code>的活动函数<code class="fe kw kx ky kz b">Hello</code>。我们可以看到，还有两个对<code class="fe kw kx ky kz b">callActivity()</code>的调用在我们的活动函数结束之前不会执行。</p><h2 id="8a40" class="ne lp it bd lq nf ng dn lu nh ni dp ly kb nj nk mc kf nl nm mg kj nn no mk np bi translated">你好</h2><p id="ee3a" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">接下来我们有一个活动函数。这是我们进行所有繁重工作的地方。查看<code class="fe kw kx ky kz b">Hello</code>目录的<code class="fe kw kx ky kz b">index.js</code>,我们看到以下代码:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="e35a" class="ne lp it kz b gy nv nw l nx ny">module.exports = async function (context) {<br/>    return `Hello ${context.bindings.name}!`;<br/>};</span></pre><p id="180f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到它会立即返回，但它肯定会是一个长期运行的活动。关键是它是在一毫秒内运行还是需要一些时间，这都不重要，编排功能仍然要等待它结束。</p><h1 id="62e3" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">排除故障</h1><p id="530b" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">到目前为止，你可能认为你已经理解了所有的东西，但是当你看到调试流程发生时，你真的明白了。这就是我们接下来要做的，我们将从VS代码中启动我们的持久函数，您将能够看到断点是如何命中的以及何时命中的。</p><p id="7408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要做的第一件事是安装我们一直提到的<code class="fe kw kx ky kz b">durable-functions</code> NPM库，让我们开始吧:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="bd66" class="ne lp it kz b gy nv nw l nx ny">npm install durable-functions</span></pre><p id="1bfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经准备好调试，让我们点击调试按钮。</p><p id="8b1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们应该在终端中打印出这样的内容</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/7e5617dedd84cde8d75948b29137e83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dOOxQdEEZx-NEi0e.png"/></div></div></figure><p id="ae47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一件我们需要做的事情是通过点击我们的客户端函数路径来启动一切，如上所述<code class="fe kw kx ky kz b">orchestrators/{functionName}</code>。因为我们只有一个名为<code class="fe kw kx ky kz b">Orchestrator</code>的函数，所以我们需要通过在浏览器中调用以下URL来启动整个过程:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="0ba2" class="ne lp it kz b gy nv nw l nx ny"><a class="ae ko" href="http://localhost:7071/api/orchestrators/Orchestrator" rel="noopener ugc nofollow" target="_blank">http://localhost:7071/api/orchestrators/Orchestrator</a></span></pre><p id="b075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先发生的是我们的<code class="fe kw kx ky kz b">HttpStart</code>函数和它的<code class="fe kw kx ky kz b">index.js</code>函数被这样攻击:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/9ac0ae5725d0d30bad68c853718bdf89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_pxt6U9Pd6gfhO8m.png"/></div></div></figure><p id="ed47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们让调试器前进:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/f618475b8ac5b30e70deec272a3e0a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yz-VMJhUFACClhHk.png"/></div></div></figure><p id="103d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面我们看到了<code class="fe kw kx ky kz b">Orchestrator</code>号和它的<code class="fe kw kx ky kz b">index.js</code>号是如何被击中的。</p><p id="c62b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我们前进到下一个断点，我们看到我们的活动函数<code class="fe kw kx ky kz b">Hello</code>和它的<code class="fe kw kx ky kz b">index.js</code>下一次被点击。</p><p id="f1a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们推进了断点，发现自己又回到了编排功能中:</p><p id="0275" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将导致再次点击<code class="fe kw kx ky kz b">activity</code>函数，这次使用参数<code class="fe kw kx ky kz b">Seattle</code>，如下所示:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/007636583afb8b3cadfbfd51f2e5a438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5iY1UOonQgrRirI2.png"/></div></div></figure><p id="f483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，在活动函数和orchestrator之间会一直这样，直到orchestrator完成。</p><p id="936e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们前进通过所有的断点。</p><p id="6605" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们最终来到这样一个页面，这是来自名为<code class="fe kw kx ky kz b">HttpStart</code>的方法的HTTP响应</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/dbc88690570c6b1ac6f50cb96da7de0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VyoWZkMv1UW2BCBe.png"/></div></div></figure><p id="cb2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在想知道的有趣的是，我们最终生产了什么？答案就在那个叫<code class="fe kw kx ky kz b">statusQueryGetUri</code>的网址里。让我们跟随链接:</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/e18c14bdc2b718b6533cb265d54adbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v7_3EGNfy5zguLdP.png"/></div></div></figure><p id="712f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您在上面看到的，我们的<code class="fe kw kx ky kz b">Orchestration</code>函数的响应是一个由所有活动函数的响应组成的数组，如下所示:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="e029" class="ne lp it kz b gy nv nw l nx ny">"output": [<br/>  "Hello Tokyo!",<br/>  "Hello Seattle!",<br/>  "Hello London"<br/>]</span></pre><p id="38ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们构建代码的方式，我们这样写:</p><pre class="ms mt mu mv gt nr kz ns nt aw nu bi"><span id="bd39" class="ne lp it kz b gy nv nw l nx ny">outputs.push(yield context.df.callActivity("Hello", "Tokyo"));<br/>outputs.push(yield context.df.callActivity("Hello", "Seattle"));<br/>outputs.push(yield context.df.callActivity("Hello", "London"));<br/><br/>// returns ["Hello Tokyo!", "Hello Seattle!", "Hello London!"]<br/>return outputs;</span></pre><h1 id="6bec" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">摘要</h1><p id="9a0f" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">关于持久函数还有很多东西要学，但是我已经听到你们中的一些人在这一点上打鼾了，这就是为什么我们将把诸如应用程序模式和模式实现的主题留到下一部分。</p><p id="68ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我希望你对此感到兴奋。</p><h2 id="8996" class="ne lp it bd lq nf ng dn lu nh ni dp ly kb nj nk mc kf nl nm mg kj nn no mk np bi translated">感谢</h2><p id="fdc6" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">如果没有您在持久函数如何工作方面的指导，我不会写这篇文章。你们两个都是了不起的人。</p><p id="8321" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">——安东尼·朱<br/> <a class="ae ko" href="https://dev.to/anthony" rel="noopener ugc nofollow" target="_blank"> dev.to </a>，<br/><a class="ae ko" href="https://twitter.com/nthonyChu" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/>——杰里米·利克内斯<br/><a class="ae ko" href="https://dev.to/jeremylikness" rel="noopener ugc nofollow" target="_blank">dev . to</a><br/><a class="ae ko" href="https://twitter.com/jeremylikness" rel="noopener ugc nofollow" target="_blank">Twitter</a></p><p id="c0be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以给他们一个关注，他们真的知道他们的无服务器的东西</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="fdbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">原载于2019年6月3日</em><a class="ae ko" href="https://dev.to/softchris/durable-functions-stateful-long-running-functions-in-serverless-part-i-5bm" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://dev . to</em></a><em class="ks">。</em></p></div></div>    
</body>
</html>