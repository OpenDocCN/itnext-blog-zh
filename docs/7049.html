<html>
<head>
<title>Heap and heap: The 114 C++ algorithms series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆和堆:114 C++算法系列</h1>
<blockquote>原文：<a href="https://itnext.io/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d?source=collection_archive---------4-----------------------#2022-05-25">https://itnext.io/heap-and-heap-the-114-c-algorithms-series-1d4215ae9f0d?source=collection_archive---------4-----------------------#2022-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到114 C++算法系列的第七部分。今天我们将讨论提供最大堆数据结构语义的算法和在未初始化(不仅仅是堆)内存上操作的算法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4a20b0885f1607e8b0634fc104e9669e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zkE0feZBBwsGdV-heZC8w.png"/></div></div></figure><h2 id="366f" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">该系列:</h2><ul class=""><li id="fe08" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/the-114-standard-c-algorithms-introduction-2a75a2df4300">简介</a></li><li id="4b30" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/sorting-partitioning-the-114-c-algorithms-series-6503ad41cede">排序和分割算法</a></li><li id="8f1e" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/divide-conquer-and-sets-the-114-c-algorithms-series-d0085a38046e">对排序或分区范围进行操作的算法</a></li><li id="f7c1" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/transformations-the-114-c-algorithms-series-deacdbd4c373">转换算法</a></li><li id="5f59" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/left-folds-and-other-reductions-the-114-c-algorithms-series-6195724d324">左侧折叠和其他缩减</a></li><li id="dddd" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/generators-copies-and-moves-the-114-c-algorithms-series-1d0774472877">生成器、复制和移动</a></li><li id="6c9c" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">堆积和堆积</li><li id="a7f8" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated"><a class="ae mb" href="https://medium.com/@simontoth/8a6ed951ad40" rel="noopener">搜索和最小值-最大值</a></li><li id="ee3d" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">结论(即将发布)</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="2168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆和未初始化内存算法代表了整个算法库中的一个小类别，主要是因为标准库提供了更方便的替代方法，另一方面，提供了更少的控制。因此，如果您希望或需要该控件，可以使用这些算法作为自定义实现的基础。</p><h1 id="8ad6" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">堆数据结构</h1><p id="e9ed" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">该标准通过<em class="ni"> std::priority_queue </em>为最大堆数据结构提供了一个方便的包装器。然而，当使用<em class="ni"> std::priority_queue时，</em>我们失去了对底层数据的访问，这可能是不方便的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/fed837444319fd80ee3ec620620d08a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19LBtE7_pC0bewialJJ15w.png"/></div></div></figure><p id="fa0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了比较，让我们实现一个简单版本的<em class="ni"> topk </em>算法，它返回一个范围内的前k个元素(类似于<em class="ni"> partial_sort_copy </em>):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="91c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用优先级队列时，我们可以利用提供的简单的<em class="ni"> push() </em>和<em class="ni"> pop() </em>接口(第8行和第10行)。然而，只有通过重复应用<em class="ni"> pop() </em>直到队列为空(第17行)，才能从队列中提取所有数据。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用堆算法时，我们需要手动管理底层数据结构(第6–7行和第9–10行)。然而，我们不需要提取数据，除此之外，如果我们不需要排序顺序中的前k个元素，我们可以省略最后的<em class="ni"> sort_heap </em>(第15行)。</p><p id="34cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的示例没有利用<em class="ni"> std::make_heap </em>，因为我们从一个空范围开始，这是一个有效的堆。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/a6c782d9dfcc4742aaeb3d4441cbf75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHSA4z1cQxsU6j3v5hE9vA.png"/></div></div></figure><p id="9af2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个测试算法检查堆不变量。Max heap是一个二叉树，其中每个子元素等于或小于父元素。<em class="ni"> is_heap </em>变量返回一个布尔值，其中<em class="ni"> is_heap_until </em>返回一个迭代器，表示范围的前导部分，它满足最大堆不变量。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在应用<em class="ni"> make_heap </em>之前，只有第一个元素处于正确的堆顺序(2的父元素是1，这违反了最大堆不变量)。因此，<em class="ni"> is_heap </em>返回false(第3行)，而<em class="ni"> is_heap_until </em>返回第二个元素的迭代器(第4行)。</p><p id="c46c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用<em class="ni"> make_heap </em>后，整个范围都是堆顺序，<em class="ni"> is_heap </em>返回<em class="ni"> true </em>(第8行)，而<em class="ni"> is_heap_until </em>返回范围迭代器的结尾(第9行)。</p><p id="68ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，<em class="ni"> is_heap(begin，is_heap_until(begin，end)) </em>将始终返回<em class="ni"> true。</em></p><h1 id="5e2a" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">使用未初始化的内存</h1><p id="f17c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">我们今天要讨论的第二类算法是对未初始化内存进行操作的算法。像堆算法一样，您应该更喜欢高级别的抽象(例如多态内存资源)。然而，当使用未初始化的内存时，使用这些算法比从头开始实现所有功能更可取。</p><p id="85fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先需要获得一块未初始化的内存，在C++中有两种有效的方法。首先，我们可以用适当的<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/object" rel="noopener ugc nofollow" target="_blank">对齐方式</a>和大小分配一个<em class="ni"> char </em>数组。因为char*被允许作为任何其他指针类型的别名，所以我们可以<em class="ni">重新解释_转换</em>结果缓冲区为我们想要的类型。</p><p id="8f72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以使用全局<em class="ni">操作符new </em>，因为C++17接受一个对齐参数并返回一个指向void的指针。然后，我们可以使用<em class="ni"> static_cast </em>将该指针转换为所需的类型。</p><p id="cb6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个使用全局<em class="ni">操作符new </em>为十个<em class="ni"> std::string </em>对象分配(和释放)空间的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="46e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子包含了很多拼写，所以让我们一步一步来:</p><ul class=""><li id="7ab1" class="lq lr iq jp b jq jr ju jv jy nn kc no kg np kk lx ly lz ma bi translated">首先我们需要<em class="ni"> sizeof(std::string)*10 </em>字节，这是new运算符的第一个参数(第2行)。</li><li id="afff" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">每当分配原始内存时，我们必须确保要存储在该内存中的对象的对齐要求得到满足。</li><li id="050a" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">为了防止重载解析冲突，新操作符将alignment作为<em class="ni"> align_val_t </em>而不是的<em class="ni"> alignof返回的<em class="ni"> size_t </em>，所以我们需要使用一个额外的<em class="ni"> static_cast </em> (line3)。</em></li><li id="d3cb" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">最后，我们必须将void指针转换为所需的元素类型(第1行)。</li><li id="d50a" class="lq lr iq jp b jq mc ju md jy me kc mf kg mg kk lx ly lz ma bi translated">删除时，我们需要确保使用匹配版本(这里是数组版本)的<em class="ni">操作符delete </em>，并按照前面提到的相同逻辑提供对齐。</li></ul><p id="4b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个在堆栈上使用char缓冲区的示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为内存在堆栈中，所以我们不需要释放步骤。</p><p id="7972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是，在这两段代码中，我们所拥有的只是原始内存。没有创建或销毁类型为<em class="ni"> std::string </em>的对象。此外，请注意<em class="ni">静态转换</em>与<em class="ni">重新解释转换的区别。</em><em class="ni">static _ cast</em>用于相关类型之间的转换(<em class="ni"> void* </em>与所有指针类型相关)。<em class="ni"> reinterpret_cast </em>用于不相关类型之间的转换(<em class="ni"> char* </em>可以别名任何其他指针，但不是<em class="ni"> std::string* </em>的相关类型)。</p><h2 id="ba72" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">建造，摧毁</h2><p id="3b89" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated"><em class="ni"> construct_at </em>和<em class="ni"> destroy_at </em>算法将在给定的地址构造/销毁单个元素。如果指定了额外的参数，<em class="ni"> construct_at </em>将<em class="ni">将这些转发给</em>对象的构造函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="370c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，construct_at算法使用参数<em class="ni"> eight </em>和<em class="ni">‘X’</em>(第4行)创建了一个<em class="ni"> std::string </em>对象，这导致一个字符串填充了X字符的八个副本。</p><h2 id="62fb" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">未初始化_默认_构造，未初始化_值_构造，未初始化_填充，销毁</h2><p id="b0c8" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">这三个算法涵盖了<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/default_initialization" rel="noopener ugc nofollow" target="_blank">默认初始化</a>、<a class="ae mb" href="https://en.cppreference.com/w/cpp/language/value_initialization" rel="noopener ugc nofollow" target="_blank">值初始化</a>和元素的复制初始化。Destroy在不释放底层内存的情况下销毁对象。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/ed784f71674d5b9384603dc3f20b4056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTGi8h9sFrTV2slOxeY93w.png"/></div></div></figure><p id="2ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些算法都计算了接受迭代器和元素计数的变量:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="88f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<em class="ni"> std::string </em>，默认和数值初始化没有区别。在这两种情况下，我们都以空字符串结束。</p><h2 id="2d8e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">未初始化_复制，未初始化_移动</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/fdd28b1abe1fc7de65652f0bdfc0f92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_t8Ot64jgNdpfnLm6kvEnA.png"/></div></div></figure><p id="bc38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些算法遵循复制和移动算法的逻辑。但是，因为目标范围是未初始化的内存，所以它们变成了复制和移动构造，而不是复制和移动赋值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="9b45" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">交易行为</h2><p id="695b" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">使用未初始化内存算法的主要好处是它们可以正确处理事务行为。在对象的构造函数可能引发。如果其中一个对象构造失败，算法将通过析构已经构造好的对象来正确地回滚。</p><p id="a0ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过构建一个玩具类型来观察这种行为，该玩具类型包含第三个结构:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ac47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为自定义类在构造函数的第三次调用时抛出，我们将看到<em class="ni">STD::initialized _ default _ construct</em>算法创建两个实例，然后立即销毁<em class="ni">自定义</em>的两个实例，之后再次抛出异常。</p><h1 id="784b" class="mo ky iq bd kz mp mq mr lc ms mt mu lf mv mw mx li my mz na ll nb nc nd lo ne bi translated">感谢您的阅读</h1><p id="1160" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nf ka kb kc ng ke kf kg nh ki kj kk ij bi translated">不要忘记关注，这样你就不会错过本系列的其他文章。例如，下面的文章将介绍最后一组算法:搜索和最小-最大算法。</p><p id="248f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还在T4的YouTube上发布视频。你有问题吗？在Twitter或LinkedIn上联系我。</p></div></div>    
</body>
</html>