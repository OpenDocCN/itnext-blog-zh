<html>
<head>
<title>Rendering 3d offscreen: Getting max performance using canvas workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在屏幕外渲染3d:使用canvas workers获得最佳性能</h1>
<blockquote>原文：<a href="https://itnext.io/rendering-3d-offscreen-getting-max-performance-using-canvas-workers-88c207cbcdc2?source=collection_archive---------0-----------------------#2021-08-06">https://itnext.io/rendering-3d-offscreen-getting-max-performance-using-canvas-workers-88c207cbcdc2?source=collection_archive---------0-----------------------#2021-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e8e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas" rel="noopener ugc nofollow" target="_blank"> OffscreenCanvas Web API </a>使我们能够将画布DOM元素的所有权转移到<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank"> workers </a>中。</p><p id="bd4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于workers在一个单独的线程中运行(如果可能的话，使用您自己的CPU ),这意味着昂贵的应用程序相关的JS逻辑不会降低您的画布渲染性能，反之亦然:您的画布的昂贵逻辑不会影响您的应用程序的其余部分。</p><p id="3328" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的用例是图像操作以及呈现交互式图表或地图。由于Canvas也支持WebGL，使用屏幕外概念创建游戏引擎也是有意义的。</p><h1 id="500f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">内容</h1><ol class=""><li id="6142" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">介绍</li><li id="08be" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">浏览器支持</li><li id="0662" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">与框架相关的增强</li><li id="ff8e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">荣誉</li><li id="5903" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">创建基于neo.mjs的演示应用程序</li><li id="4459" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">创建自定义WebGlComponent</li><li id="889e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">看着画布。助手类</li><li id="378c" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">直接在浏览器中使用d3</li><li id="10f2" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">演示视频</li><li id="78d7" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">在线演示</li><li id="c0f1" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">最后的想法</li></ol><h1 id="f432" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.介绍</h1><p id="99dd" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">工人无权访问DOM → <code class="fe md me mf mg b">window</code>以及<code class="fe md me mf mg b">window.document</code>未定义。</p><p id="af1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有这个API实现多线程有点棘手。neo.mjs项目很好地解决了这个问题:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/e06510ff34c754727265a3a68fb6cc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*k9N8mCn8m290NcuYm28yhg.png"/></div></figure><p id="2064" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用应用程序工作者作为主要参与者会使主线程尽可能地空闲。虚拟DOM是实现这一点的必要条件，因为您的应用程序(包括您的组件)位于App worker内部。</p><p id="a190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了充分利用OffscreenCanvas Web API，我们需要以下列方式增强workers设置:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/e417736a895c465bfcd1a499b34a529a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3cYXN-03ykWUE0jVIwy6FQ.png"/></div></div></figure><p id="0339" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“将屏幕外的画布和应用程序工作者结合起来”也是这篇文章的合适标题，但是我们也将在这个设置中介绍如何创建一个基于WebGL的演示应用程序:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mu"><img src="../Images/e625d153a6e91798cc761d45593d51a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bM0spvoIEDghh3suzJfgg.png"/></div></div></figure><h1 id="a21a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.浏览器支持</h1><p id="64f2" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">Chromium (Chrome，Edge)已经很好地支持了新的API。</p><p id="7de8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然兼容性表乍一看很吓人，</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mv"><img src="../Images/06b5f55d47ec84f9ec2782b7fb4a035e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ml_IknkC8u1kCTVIVaReA.png"/></div></div></figure><p id="4605" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是要知道Mozilla (Firefox)和Webkit (Safari)团队都在积极推动这个话题。</p><div class="mw mx gp gr my mz"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1390089" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">1390089 -(屏幕外画布)[meta]屏幕外画布</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">核心画布中的新(没有人):WebGL。最后更新2021-07-29。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">bugzilla.mozilla.org</p></div></div></div></a></div><p id="6113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">估计:“最理想的是今年”</p><div class="mw mx gp gr my mz"><a href="https://bugs.webkit.org/show_bug.cgi?id=183720" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">183720 -完成屏幕外画布实现</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">错误183720:完成屏幕外画布实现</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">bugs.webkit.org</p></div></div></div></a></div><p id="1be4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“现在<a class="ae kl" href="https://bugs.webkit.org/show_bug.cgi?id=224178" rel="noopener ugc nofollow" target="_blank"> bug 224178 </a>已经登陆，我相信所有主要的屏幕外Canvas特性都已经实现，并在Linux平台上启用。巩固和优化这个实现还有相当多的工作要做，当然也要在所有平台上实现它，但是基础已经在那里了。万岁！”</p><p id="a1c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要时间来创建令人惊奇的实现，所以现在开始是有意义的。</p><h1 id="97b8" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.与框架相关的增强</h1><p id="7b75" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我们首先需要的是新的canvas worker:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/worker/Canvas.mjs" rel="noopener ugc nofollow" target="_blank">src/worker/canvas . mjs</a></p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的关键部分是使用<code class="fe md me mf mg b">afterConnect()</code>方法创建一个新的<code class="fe md me mf mg b">MessageChannel</code>，它在应用程序和Canvas workers之间建立了一个直接连接(postMessages不需要通过主线程传递)。</p><p id="155a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将画布节点存储在一个<code class="fe md me mf mg b">map</code>配置中，使用<br/> DOM (===组件id)作为键。</p><p id="f1be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要创建一个新的组件类:<br/><a class="ae kl" href="https://github.com/neomjs/neo/blob/dev/src/component/Canvas.mjs" rel="noopener ugc nofollow" target="_blank">src/Component/canvas . mjs</a></p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="956a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用默认为<code class="fe md me mf mg b">true</code>的<code class="fe md me mf mg b">offscreen</code>配置。</p><p id="ac31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个新的canvas组件被挂载后，<code class="fe md me mf mg b">afterSetMounted()</code>方法将被触发。如果<code class="fe md me mf mg b">offscreen</code>设置为true，它将请求canvas节点的所有权并将其传递给canvas worker(canvas worker将把它存储在刚才提到的map中)。</p><p id="6ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，<code class="fe md me mf mg b">offscreenRegistered</code> config将被设置为true，这样我们就可以使用<code class="fe md me mf mg b">afterSetOffscreenRegistered()</code>作为我们自己的组件实现的入口点。</p><p id="9d6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任务完成。</p><h1 id="f1fc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.荣誉</h1><p id="8c6a" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">由于我不想涵盖所有关于如何使用WebGL的逻辑(离题)，我正在寻找一个很好的和记录良好的演示。</p><p id="8961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很幸运！</p><p id="6e42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">克里斯·皮尔斯做了这么好的一件作品，真是太棒了！</p><div class="mw mx gp gr my mz"><a href="https://blog.scottlogic.com/2020/03/19/offscreen-canvas.html" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用屏幕外画布呈现图表</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">对于浏览器来说，呈现图表可能是一项非常密集的操作，尤其是在上下文中有多个图表小部件的情况下…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">blog.scottlogic.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np mn mz"/></div></div></a></div><p id="a4e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这篇文章已经发表一年了，但它在许多方面仍然是相关的。</p><p id="726c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈反对的一点是使用多个消息通道来覆盖不同的消息类别。在postMessages上使用自己的API是一种方法，并且在neo.mjs项目中实现。</p><p id="2cee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在此处找到Chris demo repo:</p><div class="mw mx gp gr my mz"><a href="https://github.com/chrisprice/offscreen-canvas" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub-Chris price/off screen-canvas:使用offscreen canvas呈现图表的示例</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">对于浏览器来说，呈现图表可能是一项非常密集的操作，尤其是在上下文中有多个图表小部件的情况下…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np mn mz"/></div></div></a></div><h1 id="f128" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.创建基于neo.mjs的演示应用程序</h1><p id="fe1b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">我从使用CLI开始，并使用<br/> <code class="fe md me mf mg b">npx neo-app</code>生成了一个新的工作区</p><p id="904a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到最终结果:</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/offscreen-canvas" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub - neomjs/offscreen-canvas:使用worker的演示应用程序。帆布</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用worker.Canvas演示应用程序。通过在GitHub上创建一个帐户，为neomjs/offscreen-canvas开发做出贡献。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np mn mz"/></div></div></a></div><p id="15b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于新的canvas worker是可选的，我们需要做的第一件事是在我们的<code class="fe md me mf mg b">neo-config.json</code>文件中激活它:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="440a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该框架使用一个<code class="fe md me mf mg b">app.mjs</code>文件作为应用工人的入口点:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，使用一个名为<code class="fe md me mf mg b">canvas.mjs</code>的文件作为新canvas worker的起点是有意义的:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="70f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个也使用了一个<code class="fe md me mf mg b">onStart()</code>方法，一旦工人准备好了，你就可以触发逻辑。</p><p id="a463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从<code class="fe md me mf mg b">MainContainer.mjs</code>视图开始:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="85e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在使用一个带有垂直框(vbox)布局的视口。</p><p id="df63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们使用d3，所以我们将自定义<code class="fe md me mf mg b">WebGlComponent</code>映射到一个容器(自定义<code class="fe md me mf mg b">d3-fc</code>标签)中，该容器负责根据需要调整画布节点的大小。</p><p id="6e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在底部放置一个带有几个按钮的工具栏。</p><p id="d344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到一些<code class="fe md me mf mg b">MyApp.canvas.Helper.*</code>方法被触发。这是基于远程方法访问(remotes API)的，我们将在后面更深入地讨论它。</p><p id="5529" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe md me mf mg b">onStopMainButtonClick()</code>将触发<code class="fe md me mf mg b">Neo.Main.alert()</code>，因为工人不能自己调用<code class="fe md me mf mg b">alert()</code>。这也是一个远程方法。显示警报将停止与JS执行相关的主线程。然而，它并没有停止与UI相关的渲染线程，所以我们的canvas worker仍然可以继续制作canvas节点的动画。</p><h1 id="a978" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">6.创建自定义WebGlComponent</h1><p id="bbe3" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">只需要几行代码:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f2f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">d3再次要求我们创建一个定制的包装器节点<br/> ( <code class="fe md me mf mg b">d3fc-canvas</code>标签)。</p><p id="ab24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用这个节点来应用定制的d3 <code class="fe md me mf mg b">measure</code> domListener，因此我们可以将我们的vdom根保持在顶层。</p><p id="e1f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们仍然需要内部canvas节点的惟一id，因为我们使用它来请求所有权转移。我在<code class="fe md me mf mg b">component.Canvas</code>层实现了<code class="fe md me mf mg b">getCanvasId()</code>方法，所以我们可以在这里指向我们的第一个子节点。</p><h1 id="6d76" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">7.看着画布。助手类</h1><p id="0610" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">希望您还记得，我们的<code class="fe md me mf mg b">canvas.mjs</code>入口点导入了<code class="fe md me mf mg b">canvas.Helper</code>。所以这个文件(singleton)将在canvas worker内部运行。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b99e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最重要的一点是第55行:我们将一些类方法名添加到了<code class="fe md me mf mg b">remote</code>配置中。</p><p id="93e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在目标worker内部注册名称空间，然后允许我们在新的范围内调用相同的名称空间和函数名作为承诺。</p><p id="d4a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想知道:</p><pre class="mi mj mk ml gt ns mg nt nu aw nv bi"><span id="b545" class="nw kn iq mg b gy nx ny l nz oa"><strong class="mg ir"><em class="ob">MyApp</em></strong>.<strong class="mg ir"><em class="ob">canvas</em></strong>.Helper.enableAnimation(enableAnimation);</span></pre><p id="47df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在MainContainer.mjs文件中，这是它的答案。</p><p id="9b7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在幕后，它将从app worker向canvas worker发送一个<code class="fe md me mf mg b">postMessage</code>，触发相关的方法，并发回一个包含返回值的回复<code class="fe md me mf mg b">postMessage</code>。</p><p id="713a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们的方法是一个承诺，我们可以使用<code class="fe md me mf mg b">then()</code>作为回调或者使用<code class="fe md me mf mg b">async</code>和<code class="fe md me mf mg b">await</code>工作。</p><p id="696b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦d3和d3fc文件被导入，我们将遵循Chris Scott的演示应用程序的逻辑。生成数据，系列，一旦画布节点的所有权到达，我们就可以渲染系列。</p><p id="89b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与原始演示的一个区别是，改变项目(点数)的数量不需要重新加载整个app(页面)，而是会动态生成一个新的canvas系列。我还添加了停止/重新启用动画功能。</p><p id="373d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是非常方便的，工人们得到了他们自己的<code class="fe md me mf mg b">requestAnimationFrame()</code>实现。我认为OffscreenCanvas是它的第一个也是唯一的用例。</p><h1 id="c1d5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">8.直接在浏览器中使用d3</h1><p id="9e19" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这可能是我花时间最多的项目。</p><p id="9b42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看着Chris演示:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a2a2de4e7e1d246644d800ccc938d1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*CaWOZjR2vIw4R3HUMIH-qg.png"/></div></figure><p id="0cbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[旁注] d3-collection在此处被弃用→不再需要。</p><p id="fde9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用基于JS模块的worker时，不可能/不允许使用<code class="fe md me mf mg b">importScripts()</code>。</p><pre class="mi mj mk ml gt ns mg nt nu aw nv bi"><span id="fd2b" class="nw kn iq mg b gy nx ny l nz oa"><em class="ob">new Worker('App.mjs', {type: 'module'})</em></span></pre><p id="95c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我尝试的第一件事是:</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8053f2df4095e8fa5ab097db4c4eab81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*IGZJi2kGDhM7rKrrBGuSMg.png"/></div></figure><p id="b232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在dev模式下工作得非常好(意味着直接在你的浏览器中运行，不需要任何编译或转换)。</p><p id="b92f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我也想让它在基于webpack的<code class="fe md me mf mg b">dist/development</code>和<code class="fe md me mf mg b">dist/production</code>环境中运行。</p><p id="1561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用静态导入创建了一个巨大的分割块，对我来说它不起作用(JS运行时错误)。</p><p id="0f0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决分块问题，我们需要切换到动态导入。</p><p id="e7a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">d3非常卑鄙，因为每个文件基本上都是一个嵌套函数，它会立即触发一个内部函数。每个内部函数都要求先前的导入已经存在。</p><p id="e6f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个解决方案，我们确实需要动态导入，它作为一个序列被处理。这就是为什么我在画布上添加了以下逻辑。帮助文件:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3dc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[旁注]我主要坚持使用“let”和逗号，而不是“const ”,以实现更小的文件大小。</p><p id="3179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将每个导入打包到一个函数中非常重要，例如<code class="fe md me mf mg b">() =&gt; import()</code>以确保导入不会立即执行。然后我们可以对每一个单独的变量使用<code class="fe md me mf mg b">await</code>。肯定会慢一点，但我们别无选择。</p><p id="cffc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然d3能够将其函数添加到全局d3名称空间中，但对于d3fc lib来说实际上并不相同。在dist envs中，它只是将函数添加到模块中，所以我们需要手动修复它。我将很快创建一个错误报告。</p><h1 id="b675" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">9.演示视频</h1><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="oe nj l"/></div></figure><p id="bad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个好东西在最后:</p><p id="0bc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在将canvas worker助手类登录到控制台中。</p><p id="cd62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在这里直接更改配置，UI会自动调整。</p><h1 id="ebca" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">10.在线演示</h1><p id="6262" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">请记住，演示目前只能在基于Chromium的浏览器中运行。</p><p id="2691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发模式(按原样运行代码):<br/><a class="ae kl" href="https://neomjs.github.io/pages2/workspace/neo-offscreen-canvas-demo/apps/myapp/index.html" rel="noopener ugc nofollow" target="_blank">https://neomjs . github . io/pages 2/workspace/neo-off screen-canvas-demo/apps/myapp/index . html</a></p><p id="2d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">dist/production(基于web pack):<br/><a class="ae kl" href="https://neomjs.github.io/pages2/workspace/neo-offscreen-canvas-demo/dist/production/apps/myapp/index.html" rel="noopener ugc nofollow" target="_blank">https://neomjs . github . io/pages 2/workspace/neo-off screen-canvas-demo/dist/production/apps/myapp/index . html</a></p><p id="7104" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我注意到画布动画在dev模式下运行起来更加流畅，尤其是当达到1M点的时候。</p><p id="f69d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我不是100%确定为什么。我的猜测是webpack创建包装器函数来访问每个模块→总共更多的函数调用，加起来确实有这么多调用。</p><p id="ae36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击“stop main”按钮会创建一个alert()来暂停计时器，同时我们的画布保持动画效果。</p><h1 id="53d5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">11.最后的想法</h1><p id="576c" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果您没有时间深入研究neo.mjs项目，您真的应该:</p><div class="mw mx gp gr my mz"><a href="https://github.com/neomjs/neo" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub - neomjs/neo:应用工人驱动的前端框架</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">neo.mjs使您能够使用一个以上的CPU创建可扩展的高性能应用程序。不需要照顾一个…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="of l nm nn no nk np mn mz"/></div></div></a></div><p id="6502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的canvas worker标记了v2.3版本(我将很快调整版本号)。</p><p id="9187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成日历将被推送到2.4版(已经很接近了)。</p><p id="247e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在已经有了在neo项目中创建图像、图表或游戏库的基本设置。</p><p id="c0d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人想成为这部分的贡献者，我们将不胜感激！</p><p id="8197" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我期待着看到演示或真正的应用程序建立了新的屏幕外画布工人！</p><p id="c719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最诚挚的问候&amp;快乐编码，<br/>托比亚斯</p></div></div>    
</body>
</html>