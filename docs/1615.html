<html>
<head>
<title>A Pragmatic Overview of Async Hooks API in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中异步钩子API的实用概述</h1>
<blockquote>原文：<a href="https://itnext.io/a-pragmatic-overview-of-async-hooks-api-in-node-js-e514b31460e9?source=collection_archive---------0-----------------------#2018-12-12">https://itnext.io/a-pragmatic-overview-of-async-hooks-api-in-node-js-e514b31460e9?source=collection_archive---------0-----------------------#2018-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8acda64cc13a9c77d799c5a77d22aab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WSM6gbwDbTgzJL-8"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">汤姆·昆特在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="bd28" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我写了一篇关于Node.js应用程序中请求id跟踪的<a class="ae jd" href="https://medium.com/@apechkurov/request-id-tracing-in-node-js-applications-c517c7dab62d" rel="noopener">帖子</a>。提议的解决方案是围绕<a class="ae jd" href="https://github.com/Jeff-Lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank"> cls挂钩的</a>库构建的，该库反过来使用node的内置异步挂钩API。所以，我决定更加熟悉异步钩子。在这篇文章中，我将分享我的发现，并描述这个API的一些真实用例。</p><p id="73d9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们以一个简短的介绍开始我们的旅程。</p><h1 id="ed70" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步钩子API简介</h1><p id="4f94" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae jd" href="https://nodejs.org/api/async_hooks.html" rel="noopener ugc nofollow" target="_blank"> Async Hooks </a>是一个实验性的API，从<a class="ae jd" href="https://nodejs.org/en/blog/release/v8.0.0/" rel="noopener ugc nofollow" target="_blank"> v8.0.0 </a>开始在Node.js中提供。因此，尽管是一个实验性的API，它已经存在了大约一年半的时间，看起来没有严重的性能问题和其他错误。实验状态意味着API在将来可能会有不向后兼容的变化，甚至可能被完全移除。但是，考虑到这个API有几个不那么幸运的前辈，<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node-v0.x-archive/pull/6011" rel="noopener ugc nofollow" target="_blank">process.addAsyncListener</a></code> ( &lt; v0.12)和<a class="ae jd" href="https://github.com/nodejs/node-eps/pull/18" rel="noopener ugc nofollow" target="_blank">Async wrap</a>(V6–7，非官方)，Async Hooks API不是第一次尝试，最终应该会成为一个稳定的API。</p><p id="0bae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async_hooks</code>模块的文档以下列方式描述了该模块的用途:</p><blockquote class="mi mj mk"><p id="669a" class="kd ke ml kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async_hooks</code>模块提供了一个API来注册跟踪Node.js应用程序内部创建的异步资源的生命周期的回调。</p><p id="e3c0" class="kd ke ml kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi">…</p><p id="63ce" class="kd ke ml kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi translated">异步资源表示具有关联回调的对象。这个回调可能被多次调用，例如，<code class="fe me mf mg mh b">net.createServer()</code>中的<code class="fe me mf mg mh b">'connection'</code>事件，或者像<code class="fe me mf mg mh b">fs.open()</code>中一样只被调用一次。还可以在调用回调之前关闭资源。<code class="fe me mf mg mh b">AsyncHook</code>没有明确区分这些不同的情况，而是将它们表示为资源的抽象概念。</p></blockquote><p id="0ed9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，异步钩子允许你跟踪任何(嗯，几乎任何)发生在你的节点应用中的异步东西。与代码中任何回调和本机承诺的注册和调用相关的事件可能会通过异步钩子监听。换句话说，这个API允许您将侦听器附加到宏任务和微任务生命周期事件。此外，API允许从节点的内置本机模块(如<code class="fe me mf mg mh b">fs</code>和<code class="fe me mf mg mh b">net</code>)监听<a class="ae jd" href="https://nodejs.org/api/async_hooks.html#async_hooks_type" rel="noopener ugc nofollow" target="_blank">低级异步资源</a>。</p><p id="b151" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">核心异步钩子API可以用下面的代码片段来表达(这个代码片段的简短版本，来自文档):</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="c39a" class="mx lc jg mh b gy my mz l na nb">const async_hooks = require('async_hooks')</span><span id="6e92" class="mx lc jg mh b gy nc mz l na nb">// ID of the current execution context<br/>const eid = async_hooks.executionAsyncId()<br/>// ID of the handle responsible for triggering the callback of the<br/>// current execution scope to call<br/>const tid = async_hooks.triggerAsyncId()</span><span id="af3f" class="mx lc jg mh b gy nc mz l na nb">const asyncHook = async_hooks.createHook({<br/>  // called during object construction<br/>  init: function (asyncId, type, triggerAsyncId, resource) { },<br/>  // called just before resource's callback is called<br/>  before: function (asyncId) { },<br/>  // called just after resource's callback has finished<br/>  after: function (asyncId) { },<br/>  // called when an AsyncWrap instance is destroyed<br/>  destroy: function (asyncId) { },<br/>  // called only for promise resources, when the `resolve`<br/>  // function passed to the `Promise` constructor is invoked<br/>  promiseResolve: function (asyncId) { }<br/>})</span><span id="b5e2" class="mx lc jg mh b gy nc mz l na nb">// starts listening for async events<br/>asyncHook.enable()<br/>// stops listening for new async events<br/>asyncHook.disable()<br/></span></pre><p id="34fc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到Async Hooks API中没有那么多函数，一般来说，它看起来很简单。</p><p id="565d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">executionAsyncId()</code>函数返回当前执行上下文的标识符。<code class="fe me mf mg mh b">triggerAsyncId()</code>函数返回负责调用当前正在执行的回调的资源的id(让我们称之为父id或触发器id)。在异步钩子的事件监听器中也有相同的id(参见<code class="fe me mf mg mh b">createHook()</code>函数)。</p><p id="0758" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用<code class="fe me mf mg mh b">executionAsyncId()</code>和<code class="fe me mf mg mh b">triggerAsyncId()</code>功能，而无需创建和启用异步挂钩。但是，在这种情况下，由于V8中promise自省API相对昂贵的特性，promise执行没有被分配异步id。</p><p id="8d04" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将把重点放在异步钩子的行为上，因为如何以及何时触发已创建钩子中的回调并不明显。下一步，我们将使用异步钩子做一些实验，并了解它们是如何工作的。</p><h1 id="bc27" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让我们来玩吧！</h1><p id="0674" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在做任何实验之前，我们将实现一个非常原始的异步钩子。它将在<code class="fe me mf mg mh b">init</code>调用时为事件存储必要的元数据，并将其输出到控制台供所有后续调用使用。为了最小化控制台输出，它还支持按事件类型过滤。这是:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="9b86" class="mx lc jg mh b gy my mz l na nb">const asyncHooks = require('async_hooks')</span><span id="e19d" class="mx lc jg mh b gy nc mz l na nb">module.exports = (types) =&gt; {<br/>  // will contain metadata for all tracked events<br/>  this._tracked = {}</span><span id="b945" class="mx lc jg mh b gy nc mz l na nb">  const asyncHook = asyncHooks.createHook({<br/>    init: (asyncId, type, triggerAsyncId, resource) =&gt; {<br/>      if (!types || types.includes(type)) {<br/>        const meta = {<br/>          asyncId,<br/>          type,<br/>          pAsyncId: triggerAsyncId,<br/>          res: resource<br/>        }<br/>        this._tracked[asyncId] = meta<br/>        printMeta('init', meta)<br/>      }<br/>    },<br/>    before: (asyncId) =&gt; {<br/>      const meta = this._tracked[asyncId]<br/>      if (meta) printMeta('before', meta)<br/>    },<br/>    after: (asyncId) =&gt; {<br/>      const meta = this._tracked[asyncId]<br/>      if (meta) printMeta('after', meta)<br/>    },<br/>    destroy: (asyncId) =&gt; {<br/>      const meta = this._tracked[asyncId]<br/>      if (meta) printMeta('destroy', meta)<br/>      // delete meta for the event<br/>      delete this._tracked[asyncId]<br/>    },<br/>    promiseResolve: (asyncId) =&gt; {<br/>      const meta = this._tracked[asyncId]<br/>      if (meta) printMeta('promiseResolve', meta)<br/>    }<br/>  })</span><span id="023a" class="mx lc jg mh b gy nc mz l na nb">  asyncHook.enable()</span><span id="368f" class="mx lc jg mh b gy nc mz l na nb">  function printMeta (eventName, meta) {<br/>    console.log(`[${eventName}] asyncId=${meta.asyncId}, ` +<br/>      `type=${meta.type}, pAsyncId=${meta.pAsyncId}, ` +<br/>      `res type=${meta.res.constructor.name}`)<br/>  }<br/>}</span></pre><p id="a287" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在实验中使用它作为一个模块，所以让我们把它放在一个名为<code class="fe me mf mg mh b">verbose-hook.js</code>的文件中。现在，我们准备好做实验了。为了简单起见，在我们的例子中，我们将主要使用定时器API(准确地说，是<code class="fe me mf mg mh b">setTimeout()</code>函数)。</p><p id="a519" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们看看单个计时器会发生什么:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="2011" class="mx lc jg mh b gy my mz l na nb">require('./verbose-hook')(['Timeout'])</span><span id="21bc" class="mx lc jg mh b gy nc mz l na nb">setTimeout(() =&gt; {<br/>  console.log('Timeout happened')<br/>}, 0)<br/>console.log('Registered timeout')</span></pre><p id="2340" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本将产生以下输出:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="ebd2" class="mx lc jg mh b gy my mz l na nb">[init] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>Registered timeout<br/>[before] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>Timeout happened<br/>[after] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>[destroy] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout</span></pre><p id="bf1f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，单个<code class="fe me mf mg mh b">setTimeout</code>操作的生命周期非常简单明了。它以一个(同步！)当异步操作(超时的回调)被添加到计时器队列中时，或者换句话说，当异步资源被创建时，调用<code class="fe me mf mg mh b">init</code>监听器。一旦回调将要被触发，就会触发<code class="fe me mf mg mh b">before</code>事件监听器，然后在回调执行完成时触发<code class="fe me mf mg mh b">after</code>和<code class="fe me mf mg mh b">destroy</code>事件的监听器。</p><p id="230d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能想知道，在嵌套操作的情况下会发生什么？让我们看看:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="00a3" class="mx lc jg mh b gy my mz l na nb">require('./verbose-hook')(['Timeout'])</span><span id="2579" class="mx lc jg mh b gy nc mz l na nb">setTimeout(() =&gt; {<br/>  console.log('Timeout 1 happened')<br/>  setTimeout(() =&gt; {<br/>    console.log('Timeout 2 happened')<br/>  }, 0)<br/>  console.log('Registered timeout 2')<br/>}, 0)<br/>console.log('Registered timeout 1')</span></pre><p id="8267" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个脚本将产生一个更长的输出，看起来像这样:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="b2d6" class="mx lc jg mh b gy my mz l na nb">[init] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>Registered timeout 1<br/>[before] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>Timeout 1 happened<br/>[init] asyncId=11, type=Timeout, pAsyncId=5, res type=Timeout<br/>Registered timeout 2<br/>[after] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>[destroy] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>[before] asyncId=11, type=Timeout, pAsyncId=5, res type=Timeout<br/>Timeout 2 happened<br/>[after] asyncId=11, type=Timeout, pAsyncId=5, res type=Timeout<br/>[destroy] asyncId=11, type=Timeout, pAsyncId=5, res type=Timeout</span></pre><p id="a5f4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出显示嵌套的异步操作在异步钩子API中有直接的相关性。根<code class="fe me mf mg mh b">setTimeout</code>操作(<code class="fe me mf mg mh b">asyncId=5</code>)的id充当嵌套操作(<code class="fe me mf mg mh b">asyncId=11</code>)的父(或触发器)id。该输出中显示的另一件有趣的事情是，根调用的<code class="fe me mf mg mh b">destroy</code>事件发生在嵌套的<code class="fe me mf mg mh b">destroy</code>之前。这是因为<code class="fe me mf mg mh b">destroy</code>监听器是在对应于异步操作的资源(在我们的例子中是<code class="fe me mf mg mh b">Timeout</code>对象)被销毁后调用的。</p><p id="c79b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe me mf mg mh b">destroy</code>事件相关的另一个需要注意的重要事情是，在某些情况下，它可能根本不会被触发。官方文件是这样说的:</p><blockquote class="mi mj mk"><p id="ae3f" class="kd ke ml kf b kg kh ki kj kk kl km kn mm kp kq kr mn kt ku kv mo kx ky kz la ij bi translated">一些资源依赖垃圾收集来清理，所以如果引用传递给<code class="fe me mf mg mh b">init</code>的<code class="fe me mf mg mh b">resource</code>对象，那么<code class="fe me mf mg mh b">destroy</code>可能永远不会被调用，导致应用程序内存泄漏。如果资源不依赖于垃圾收集，那么这就不是问题。</p></blockquote><p id="f8f5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，如果你正在开发一个基于异步钩子的库，你需要考虑你的库可能引入的内存泄漏问题。</p><p id="6d2c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在做点坏事怎么样？让我们试着创建一个超时，然后马上清除它，看看异步钩子将注册哪些事件:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="6e84" class="mx lc jg mh b gy my mz l na nb">require('./verbose-hook')(['Timeout'])</span><span id="2272" class="mx lc jg mh b gy nc mz l na nb">clearTimeout(<br/>  setTimeout(() =&gt; {<br/>    console.log('Timeout happened')<br/>  }, 0)<br/>)<br/>console.log('Registered timeout')</span></pre><p id="793a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此示例产生以下输出:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="c79f" class="mx lc jg mh b gy my mz l na nb">[init] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout<br/>Registered timeout<br/>[destroy] asyncId=5, type=Timeout, pAsyncId=1, res type=Timeout</span></pre><p id="89c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管超时被立即取消，但在异步挂钩术语中，超时仍然会创建一个异步资源。因此，<code class="fe me mf mg mh b">init</code>和<code class="fe me mf mg mh b">destroy</code>事件的监听器仍然被触发。这个例子也说明了<code class="fe me mf mg mh b">after</code>和<code class="fe me mf mg mh b">before</code>事件不能保证被调用。</p><p id="bbda" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们还没有看到任何<code class="fe me mf mg mh b">promiseResolve</code>事件。这是因为我们在例子中没有使用任何本地承诺。让我们从最简单的例子开始:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="770e" class="mx lc jg mh b gy my mz l na nb">require('./verbose-hook')(['PROMISE'])</span><span id="aaae" class="mx lc jg mh b gy nc mz l na nb">Promise.resolve()<br/>console.log('Registered Promise.resolve')</span></pre><p id="4cc1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本将以下内容输出到控制台:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="889c" class="mx lc jg mh b gy my mz l na nb">[init] asyncId=5, type=PROMISE, pAsyncId=1, res type=PromiseWrap<br/>[promiseResolve] asyncId=5, type=PROMISE, pAsyncId=1, res type=PromiseWrap<br/>Registered Promise.resolve</span></pre><p id="dac2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，在这个例子中，<code class="fe me mf mg mh b">promiseResolve</code>监听器是在<code class="fe me mf mg mh b">Promise.resolve()</code>函数执行期间同步运行的。正如文档中提到的，<code class="fe me mf mg mh b">promiseResolve</code>监听器将在传递给promise构造函数的<code class="fe me mf mg mh b">resolve</code>函数被调用时被触发(直接或通过其他方式解析Promise)。在我们的例子中，因为有了<code class="fe me mf mg mh b">Promise.resolve()</code>函数，所以<code class="fe me mf mg mh b">resolve</code>函数被同步调用。</p><p id="f182" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个结果是，当用<code class="fe me mf mg mh b">then</code> / <code class="fe me mf mg mh b">catch</code>链构建承诺链时，<code class="fe me mf mg mh b">promiseResolve</code>(和其他监听器)将在那些情况下被多次触发。为了说明这一点，让我们看下面的例子(这一次我们将使用<code class="fe me mf mg mh b">Promise.reject</code>来使这个例子与上一个例子有所不同):</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="0077" class="mx lc jg mh b gy my mz l na nb">require('./verbose-hook')(['PROMISE'])</span><span id="10b9" class="mx lc jg mh b gy nc mz l na nb">Promise.reject()<br/>  .catch(() =&gt; console.log('Promise.reject callback'))<br/>console.log('Registered Promise.reject')</span></pre><p id="8829" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本产生以下输出:</p><pre class="mp mq mr ms gt mt mh mu mv aw mw bi"><span id="725a" class="mx lc jg mh b gy my mz l na nb">[init] asyncId=5, type=PROMISE, pAsyncId=1, res type=PromiseWrap<br/>[promiseResolve] asyncId=5, type=PROMISE, pAsyncId=1, res type=PromiseWrap<br/>[init] asyncId=8, type=PROMISE, pAsyncId=5, res type=PromiseWrap<br/>Registered Promise.reject<br/>[before] asyncId=8, type=PROMISE, pAsyncId=5, res type=PromiseWrap<br/>Promise.reject callback<br/>[promiseResolve] asyncId=8, type=PROMISE, pAsyncId=5, res type=PromiseWrap<br/>[after] asyncId=8, type=PROMISE, pAsyncId=5, res type=PromiseWrap</span></pre><p id="e30c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如所料，我们在这里看到了两个异步资源的层次结构。第一个(<code class="fe me mf mg mh b">asyncId=5</code>)对应于<code class="fe me mf mg mh b">Promise.reject()</code>调用，而第二个(<code class="fe me mf mg mh b">asyncId=8</code>)代表连锁的<code class="fe me mf mg mh b">catch()</code>调用。</p><p id="968b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至此，您应该已经理解了异步钩子API背后的主要原理。不要犹豫，用其他场景和事件的<a class="ae jd" href="https://nodejs.org/api/async_hooks.html#async_hooks_type" rel="noopener ugc nofollow" target="_blank">类型做更多的实验。</a></p><p id="a706" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将讨论一些内部实现细节。</p><h1 id="7134" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">潜得更深一些</h1><p id="7989" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf jh">重要提示。</strong>我在下面的所有链接中使用了来自节点主分支的最新提交之一，因此在过去/未来的版本中内部可能会有所不同。此外，本节中没有代码片段，所以如果您有兴趣查看源代码，请随时跟进这些链接。</p><p id="c24b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想通过读取节点源代码来理解异步钩子是如何实现的，那么首先要检查的是<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/63b06551f4c51d8868f36b184a6539ebc51cf0b4/lib/internal/async_hooks.js" rel="noopener ugc nofollow" target="_blank">async_hooks</a></code>模块本身。它定义了描述由<code class="fe me mf mg mh b">createHook()</code>函数返回的对象的<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/async_hooks.js#L44" rel="noopener ugc nofollow" target="_blank">AsyncHook</a></code>类，以及所谓的<a class="ae jd" href="https://nodejs.org/api/async_hooks.html#async_hooks_javascript_embedder_api" rel="noopener ugc nofollow" target="_blank"> JS嵌入器API </a>。后者允许你扩展<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/async_hooks.js#L141" rel="noopener ugc nofollow" target="_blank">AsyncResource</a></code>类，这样你自己资源的生命期事件将由异步钩子API处理。</p><p id="da08" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你继续深入，你会发现<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/internal/async_hooks.js" rel="noopener ugc nofollow" target="_blank">internal/async_hooks</a></code>模块。这个模块由公共模块使用，充当本机代码和API的JS部分之间的桥梁。Async Hooks API的C++部分由<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/src/async_wrap.cc" rel="noopener ugc nofollow" target="_blank">async_wrap</a></code>本地模块表示，该模块还定义了公共的<a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/src/async_wrap.cc#L678" rel="noopener ugc nofollow" target="_blank"> C++嵌入器API </a>。本机API定义了我们稍后将考虑的<code class="fe me mf mg mh b">AsyncWrap</code>和<code class="fe me mf mg mh b">PromiseWrap</code>类。所以，这三个模块定义了异步钩子API实现的主要部分。</p><p id="a65c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一个调用链的具体例子，它发生在触发<code class="fe me mf mg mh b">init</code>监听器之前。</p><p id="b112" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JS端，<code class="fe me mf mg mh b">AsyncResource</code>类在构造函数中有一个对<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/async_hooks.js#L163" rel="noopener ugc nofollow" target="_blank">emitInit</a>()</code>函数的调用。该功能在<code class="fe me mf mg mh b">internal/async_hooks</code>模块的中定义<a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/internal/async_hooks.js#L316" rel="noopener ugc nofollow" target="_blank">。反过来，这个函数调用同一个模块的<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/internal/async_hooks.js#L131" rel="noopener ugc nofollow" target="_blank">emitInitNative()</a></code>函数。最后，这个函数同步迭代现有的活动钩子，并为每个钩子调用<code class="fe me mf mg mh b">init</code>监听器。这就是我们在实验中看到同步调用<code class="fe me mf mg mh b">init</code>监听器的原因。</a></p><p id="258a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在C++端，即对于本地异步资源，在异步资源构造函数中异步调用相同的<code class="fe me mf mg mh b">emitInitNative()</code>函数(从本地代码的执行角度来看)。我觉得这次没必要把整个调用链都过一遍，所以相信我(或者你自己查一下)调用最终是发生在<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/src/async_wrap.cc#L631" rel="noopener ugc nofollow" target="_blank">EmitAsyncInit()</a></code>函数里的。</p><p id="9c90" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如所料，Async Hooks API(即<code class="fe me mf mg mh b">AsyncWrap</code>本地类)被集成到所有标准Node.js模块中。例如，您可能会在本机模块的内部找到<code class="fe me mf mg mh b">AsyncWrap</code>，比如<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/lib/internal/crypto/pbkdf2.js#L33" rel="noopener ugc nofollow" target="_blank">crypto</a></code>和<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/src/node_file.cc#L101" rel="noopener ugc nofollow" target="_blank">fs</a></code>，以及许多其他地方。作为另一个例子，<code class="fe me mf mg mh b">promiseResolve</code>事件监听器基于本机承诺的<a class="ae jd" href="https://github.com/nodejs/node/blob/e570ae79f5b1d74fed52d2aed7f014caaa0836dd/src/async_wrap.cc#L236" rel="noopener ugc nofollow" target="_blank">钩子</a>。</p><p id="e195" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，任何发生在你的节点应用程序中的异步内容都可以通过异步钩子API进行列表。唯一的例外可能是一些第三方本机模块和它们周围的包装器。但是对于这些，您仍然可以使用嵌入式API将它们与异步挂钩集成在一起。</p><p id="7663" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，随着我们对异步钩子的内部结构和原理有了更好的理解，让我们考虑一些可以用这个API解决的实际问题。</p><h1 id="d534" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">但是异步钩子有什么用呢？</h1><p id="c4c1" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正如我们已经知道的，异步钩子的第一个用例是<a class="ae jd" href="https://github.com/Jeff-Lewis/cls-hooked" rel="noopener ugc nofollow" target="_blank">延续本地存储</a> (CLS)，这是多线程世界中众所周知的线程本地存储概念的异步变体。简而言之，cls挂钩库中的实现基于跟踪上下文对象和异步调用链之间的关联，异步调用链从特定的<a class="ae jd" href="https://github.com/Jeff-Lewis/cls-hooked#namespacebindcallback-context" rel="noopener ugc nofollow" target="_blank">函数</a>或<code class="fe me mf mg mh b"><a class="ae jd" href="https://github.com/Jeff-Lewis/cls-hooked#namespacebindemitteremitter" rel="noopener ugc nofollow" target="_blank">EventEmitter</a></code>对象的生命周期的执行开始。这里使用异步钩子API来监听异步操作，并在整个执行链中跟踪上下文。如果没有这个或类似的内置API，您将不得不处理Node.js中所有异步API的大量猴子补丁。</p><p id="f41d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个用例是关于分析和监控的。与<a class="ae jd" href="https://nodejs.org/api/perf_hooks.html" rel="noopener ugc nofollow" target="_blank">性能计时API </a>结合使用的异步挂钩可用于分析您的应用。这两个API允许收集应用程序中发生的异步操作的信息，并测量它们的持续时间。出于web应用程序监控的目的，我们可以构建一个中间件，以一种抽样的方式收集请求处理统计数据，即针对特定百分比的请求(不是所有请求)，从而最大限度地降低对应用程序的性能影响。这些信息可以写入文件或流入独立的服务，并在以后以多种方式可视化，例如作为<a class="ae jd" href="http://www.brendangregg.com/flamegraphs.html" rel="noopener ugc nofollow" target="_blank">火焰图</a>。</p><p id="8244" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为构建在Async Hooks API之上的剖析工具的真实示例，我可以将它命名为Bubbleprof工具，它是Clinic.js的一部分。查看<a class="ae jd" href="https://clinicjs.org/blog/introducing-bubbleprof/" rel="noopener ugc nofollow" target="_blank">这篇博客</a>文章，了解更多关于Bubbleprof的信息。</p><p id="5c81" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这篇文章能让你更好地理解异步钩子。正如我们所看到的，Async Hooks API是一个强大的开箱即用的特性，它允许以一种简洁的方式解决现实世界中的问题。</p><p id="51de" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，如果你知道异步钩子的其他真实使用案例，请在下面的评论中描述它们。我很想听听这些。</p></div></div>    
</body>
</html>