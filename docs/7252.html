<html>
<head>
<title>Maintainable React — A story about round-up (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的反应——关于综述的故事(下)</h1>
<blockquote>原文：<a href="https://itnext.io/maintainable-react-a-story-about-round-up-part-ii-c56fca93b830?source=collection_archive---------0-----------------------#2022-07-29">https://itnext.io/maintainable-react-a-story-about-round-up-part-ii-c56fca93b830?source=collection_archive---------0-----------------------#2022-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fcd6f16f1c0bc569b7a08d7735b638be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LYdtfLY3QDIxD46C"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@norevisions?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">未修改<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的</a>Unsplash</a></figcaption></figure><p id="9861" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">【更新11。现在整个系列都完成了，我在leanpub上为它创作了一本书</em><a class="ae kf" href="https://leanpub.com/react-clean-code" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">。你可以用</em> <a class="ae kf" href="https://leanpub.com/react-clean-code/c/mYXp686cMFw1" rel="noopener ugc nofollow" target="_blank"> <em class="le">这个链接七折获得一份</em> </a> <em class="le">。自从本文(和第二部分)首次发表以来，我已经做了许多修改，我真的相信新的方法要好得多。请读一读，我相信你会成为一个更高效、更优秀的开发人员。</em></p><p id="66d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新(2022年9月25日):我在这篇</em> <a class="ae kf" href="https://icodeit.ck.page/maintainable-react-tips" rel="noopener ugc nofollow" target="_blank"> <em class="le">可维护的React Cheatsheet </em> </a> <em class="le">中总结了7个小技巧，可以在这里</em>  <em class="le">免费下载</em> <a class="ae kf" href="https://icodeit.ck.page/maintainable-react-tips" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="40cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程的第一部分<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/a-not-too-short-story-about-rounding-up-24cb4bdfcb69">中，我们已经讨论了一个关于凑集和捐赠的特性。经过几次重构，我们的代码已经达到了处理业务逻辑和可维护的程度。但是我们的故事还没有结束。</a></p><h1 id="8b2e" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">新要求—丹麦货币</h1><p id="83bd" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">上面的代码并不完美，但它符合当前所有的业务需求。直到有一天，你听到你的老板谈论一些关于丹麦市场的事情。你没有太在意，但很快你意识到在丹麦，货币与你放入代码中的另外两种略有不同。</p><p id="d40d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，需要注意的是，他们使用逗号作为小数点分隔符，而在其他一些国家，如澳大利亚，我们使用点(或点)来代替。所以当我第一次看到比萨饼的价格时，我非常震惊。</p><p id="4615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">丹麦的新逻辑是，我们应该四舍五入到最接近的十位数。比如<code class="fe mp mq mr ms b">61,00</code>要上舍入到<code class="fe mp mq mr ms b">70,00</code>，<code class="fe mp mq mr ms b">70,00</code>要上舍入到<code class="fe mp mq mr ms b">80,00</code>。</p><p id="b01b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是啊，我知道。但是我们已经有了上面的日本例子，编写测试只是小菜一碟。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="ab0e" class="nb ln it ms b gy nc nd l ne nf">describe('DK', () =&gt; {<br/>    it('rounds up to nearest tens', () =&gt; {<br/>      const total = getRoundedUpTotalForDK(61)<br/>      expect(total).toEqual(70)<br/>    })</span><span id="da7f" class="nb ln it ms b gy ng nd l ne nf">    it('add 10 for integers', () =&gt; {<br/>      const total = getRoundedUpTotalForDK(70)<br/>      expect(total).toEqual(80)<br/>    })<br/>  })</span></pre><p id="7f31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现只是复制和粘贴:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5b89" class="nb ln it ms b gy nc nd l ne nf">export const getRoundedUpTotalForDK = (total: number) =&gt; Math.floor(total / 10 + 1) * 10</span></pre><p id="a973" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不想把<code class="fe mp mq mr ms b">getRoundedUpAmountForDK</code>放在这里让你感到厌烦，但是让我们仔细看看这些助手，看看我们是否可以简化它们一点。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="bc6e" class="nb ln it ms b gy nc nd l ne nf">export const getRoundedUpTotal = (total: number) =&gt; Math.floor(total + 1)</span><span id="ad3f" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpAmount = (total: number) =&gt; {<br/>  const roundedUpAmount = getRoundedUpTotal(total) - total<br/>  return parseFloat(roundedUpAmount.toPrecision(10))<br/>}</span><span id="0ee3" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpTotalForDK = (total: number) =&gt; Math.floor(total / 10 + 1) * 10</span><span id="a6fb" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpAmountForDK = (total: number) =&gt; {<br/>  const roundedUpAmount = getRoundedUpTotalForDK(total) - total<br/>  return parseFloat(roundedUpAmount.toPrecision(10))<br/>}</span><span id="0b3d" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpTotalForJP = (total: number) =&gt; Math.floor(total / 100 + 1) * 100</span><span id="bb51" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpAmountForJP = (total: number) =&gt; {<br/>  const roundedUpAmount = getRoundedUpTotalForJP(total) - total<br/>  return parseFloat(roundedUpAmount.toPrecision(10))<br/>}</span></pre><h1 id="e208" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">从小重构开始</h1><p id="b3cf" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如果忽略一些细节，太像了，形式上几乎一模一样吧？先从一些小动作开始。行<code class="fe mp mq mr ms b">parseFloat(roundedUpAmount.toPrecision(10))</code>出现了三次，所以最好有一个函数本身:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="9fef" class="nb ln it ms b gy nc nd l ne nf">const getPrecisionFixedValue = (number: number) =&gt; {<br/>  return parseFloat(number.toPrecision(10))<br/>}</span></pre><p id="99d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而<code class="fe mp mq mr ms b">getRoundedUpAmountForXXX</code>会被简化成:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="699d" class="nb ln it ms b gy nc nd l ne nf">export const getRoundedUpAmount = (total: number) =&gt; {<br/>  const roundedUpAmount = getRoundedUpTotal(total) - total<br/>  return getPrecisionFixedValue(roundedUpAmount)<br/>}</span></pre><p id="9f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道这不太令人兴奋，但我们已经取得了一些进展。实际上，我们可以做得更好。秘密武器是高阶函数。</p><h1 id="2fe1" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">高阶函数</h1><p id="4fa2" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">幸运的是，当我们使用JavaScript时，我们可以使用高阶函数和<code class="fe mp mq mr ms b">currying</code>来简化<code class="fe mp mq mr ms b">Math.floor</code>部分，就像，很多。</p><p id="ba19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你看这三个陈述，你看到了什么？</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="c937" class="nb ln it ms b gy nc nd l ne nf">Math.floor(total + 1)<br/>Math.floor(total / 10 + 1) * 10<br/>Math.floor(total / 100 + 1) * 100</span></pre><p id="99f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，为了让你更清楚，如果我把它改变一点点:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="c8fa" class="nb ln it ms b gy nc nd l ne nf">Math.floor(total / 1  + 1) * 1<br/>Math.floor(total / 10 + 1) * 10<br/>Math.floor(total / 100 + 1) * 100</span></pre><p id="a919" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="e6de" class="nb ln it ms b gy nc nd l ne nf">Math.floor(total / 10^0 + 1) * 10^0<br/>Math.floor(total / 10^1 + 1) * 10^1<br/>Math.floor(total / 10^2 + 1) * 10^2</span></pre><p id="3efa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以有一个接受(0，1或2)并返回上述表达式之一的函数:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="06d3" class="nb ln it ms b gy nc nd l ne nf">const getDonationAmountWithNearest = (exp: number) =&gt; (total: number) =&gt; {<br/>  const nearest = Math.pow(10, exp - 1)<br/>  return Math.floor(total / nearest + 1) * nearest<br/>}</span></pre><p id="7ed4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe mp mq mr ms b">Math.pow(base, exponent)</code> returns T函数返回底数的指数幂，就像在base^exponent，底数和指数都是十进制数字系统。</p><p id="329f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，基本上，我们可以定义一些更有用的小函数，比如:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="9550" class="nb ln it ms b gy nc nd l ne nf">const roundUpToNearestInteger = getDonationAmountWithNearest(1)<br/>const roundUpToNearestTen = getDonationAmountWithNearest(2)<br/>const roundUpToNearestHundred = getDonationAmountWithNearest(3)</span></pre><p id="4426" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在这里，通过使用高阶函数，我们创建了三个更通用和纯粹的算法，它们不与任何业务逻辑绑定，而是纯粹的数学公式。</p><h1 id="dfa0" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">又一轮高阶函数</h1><p id="40ee" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">正如我们已经注意到的，这些<code class="fe mp mq mr ms b">getRoundedUpAmountForXXX</code>几乎是相同的，因此使用相同的技术，我们可以将差异提取到新函数的参数中:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="531e" class="nb ln it ms b gy nc nd l ne nf">const getRoundedUpAmountWith = (getRoundedUpTotalFor: (total: number) =&gt; number) =&gt; (total: number) =&gt; {<br/>  const roundedUpAmount = getRoundedUpTotalFor(total) - total<br/>  return getPrecisionFixedValue(roundedUpAmount)<br/>}</span></pre><p id="8e70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，这个新定义的函数的返回值是一个<code class="fe mp mq mr ms b">function</code>，这个新函数可以做<code class="fe mp mq mr ms b">getRoundedUpAmountForXXX</code>所做的事情。例如:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="74d3" class="nb ln it ms b gy nc nd l ne nf">export const getRoundedUpAmountForJP = getRoundedUpAmountWith(getRoundedUpTotalForJP)<br/>export const getRoundedUpAmountForDK = getRoundedUpAmountWith(getRoundedUpTotalForDK)</span></pre><p id="0b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很酷，对吧？现在，这些助手只调用定制的高阶函数:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="3cf7" class="nb ln it ms b gy nc nd l ne nf">export const getRoundedUpTotal = getDonationAmountWithNearest(1)<br/>export const getRoundedUpAmount = getRoundedUpAmountWith(getRoundedUpTotal)</span><span id="52d7" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpTotalForDK = getDonationAmountWithNearest(2)<br/>export const getRoundedUpAmountForDK = getRoundedUpAmountWith(getRoundedUpTotalForDK)</span><span id="4a29" class="nb ln it ms b gy ng nd l ne nf">export const getRoundedUpTotalForJP = getDonationAmountWithNearest(3)<br/>export const getRoundedUpAmountForJP = getRoundedUpAmountWith(getRoundedUpTotalForJP)</span></pre><h1 id="8bc8" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">查找地图</h1><p id="5d05" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">你知道吗？我们甚至可以简化上面的代码。引入一个映射，然后查找该映射，而不是if-else或switch cases，可以进一步简化逻辑。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5d95" class="nb ln it ms b gy nc nd l ne nf">const algorithmMap = {<br/>  AU: roundUpToNearestInteger,<br/>  DK: roundUpToNearestTen,<br/>  JP: roundUpToNearestHundred<br/>}</span><span id="9c4e" class="nb ln it ms b gy ng nd l ne nf">const useRoundUp = (price: number, countryCode: CountryCode) =&gt; {<br/>  const [agreeWithDonation, setAgreeWithDonation] = useState&lt;boolean&gt;(false)<br/>  const updateDonationAgreement = () =&gt; setAgreeWithDonation(withDonation =&gt; !withDonation)</span><span id="ba9b" class="nb ln it ms b gy ng nd l ne nf">  const getRoundedUpTotal = algorithmMap[countryCode]<br/>  const getRoundedUpAmount = getRoundedUpAmountWith(getRoundedUpTotal)</span><span id="6258" class="nb ln it ms b gy ng nd l ne nf">  const roundedUpAmount = getRoundedUpAmount(price)<br/>  const total = agreeWithDonation ? getRoundedUpTotal(price) : price</span><span id="2146" class="nb ln it ms b gy ng nd l ne nf">  return {<br/>    agreeWithDonation,<br/>    updateDonationAgreement,<br/>    total,<br/>    roundedUpAmount<br/>  }<br/>}</span></pre><p id="99e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意我们是如何使用这两个就地生成的函数来动态计算价格和取整金额的:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="5085" class="nb ln it ms b gy nc nd l ne nf">const getRoundedUpTotal = algorithmMap[countryCode]<br/>  const getRoundedUpAmount = getRoundedUpAmountWith(getRoundedUpTotal)</span></pre><p id="7e7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这两个函数是动态生成的，我们不再需要预定义的<code class="fe mp mq mr ms b">getRoundedUpTotalForJP</code>函数族。</p><p id="bac4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法最漂亮的部分可能是，每当添加一个具有不同舍入算法的新市场时，我们只需要修改<code class="fe mp mq mr ms b">algorithmMap</code>(希望如此)，所有部分都保持不变。</p><p id="39b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您可能已经注意到，我们的测试仍然是绿色的，这是我们可以进行这些大的更改而不必太担心破坏任何现有功能的另一个原因。</p><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/cb303e8d397af20db3be108180482162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXvvBaeqZ3XwjWyynWzhRg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">不同国家的汇总逻辑不同</figcaption></figure><h1 id="c83a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="651a" class="pw-post-body-paragraph kg kh it ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在本教程中，我向您介绍了一个摘自真实项目特性的示例。说实话，接任务的时候没想太多(日本市场新要求)。当丹麦市场出现类似但不同的需求时，我重构了代码，使其更加通用和简洁，然后是最终结果。</p><p id="dbf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想并不是每一个特性都如此简单，或者仅仅是像这样的数学公式。不过，这个想法是，你应该始终注意小的变化，并意识到任何水平的重复。一旦你确定了一些，试着通过将代码提取到一个函数中或者使用更高阶的函数来摧毁它们。请注意，您不必一次完成所有清理工作。相反，你应该继续工作，反复检查你的解决方案，最终，你会比以前更好，整体代码库的质量也会更好。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="fb49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">【更新11。2022年11月]现在整个系列都完成了，我在leanpub上为它创作了一本书。你可以用<a class="ae kf" href="https://leanpub.com/react-clean-code/c/mYXp686cMFw1" rel="noopener ugc nofollow" target="_blank">这个链接打7折</a>得到一本。自从本文(和第二部分)首次发表以来，我已经做了许多修改，我真的相信新的方法要好得多。请读一读，我相信你会成为一个更高效、更优秀的开发人员。</p></div></div>    
</body>
</html>