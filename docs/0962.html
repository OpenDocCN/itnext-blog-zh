<html>
<head>
<title>Unit testing ReactJS Redux Actions, Reducers and Epics with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试用Jest还原动作、还原器和史诗</h1>
<blockquote>原文：<a href="https://itnext.io/unit-testing-redux-actions-reducers-and-epics-with-jest-484f8a59f1f2?source=collection_archive---------1-----------------------#2018-06-25">https://itnext.io/unit-testing-redux-actions-reducers-and-epics-with-jest-484f8a59f1f2?source=collection_archive---------1-----------------------#2018-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f69fdf52e6f2dca644a273a8cb5d8b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*QrHZNY1xRFOeeNftoqzdEQ.png"/></div></div></figure><p id="a2a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redux 是一种帮助复杂的单页面应用程序的流行模式，它允许状态、状态上的动作以及状态在UI中的呈现方式之间的清晰分离。</p><p id="da8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，当然，没有什么是免费的，Redux也有不好的一面。尽管Redux的核心原则简单明了，但它们通常隐藏在助手函数之后，这会使应用程序变得复杂且难以验证。这些帮助函数往往隐藏了实际发生的事情，开发人员失去了一些代码透明性，这使得随着代码的发展或新代码路径的创建(很少被触发，例如错误处理)，错误更容易蔓延。</p><p id="5654" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，如何快速测试和验证Redux类，而不需要建立应用程序的实例并使用Selenium等工具运行实时测试呢？(Selenium没什么不好——我是它的粉丝——但是我想用正确的工具完成正确的工作，为此我们需要更轻的东西)。</p><p id="c6d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的答案是一个叫做<a class="ae kz" href="https://facebook.github.io/jest/" rel="noopener ugc nofollow" target="_blank"> Jest </a>的单元测试框架。Jest允许我们定义测试并模拟提供底层XHR调用的类，这样我们可以在几秒钟内完全独立于任何浏览器运行我们的测试，所有这些都是我们CI/CD管道的一部分。作为一个额外的奖励，它还在报告代码覆盖率方面做得很好，允许开发人员找到那些没有运行的代码分支(这通常是导致问题的原因)。</p><p id="2de7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对我们的Redux类进行单元测试不仅有助于在代码交付之前对其进行测试，还可以作为一个永久的回归套件，防止无害的更改引入bug。我们还发现，对于描述Redux类应该如何工作，它是一个有用的参考点。</p><h1 id="a5a6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">数据加载器示例</strong></h1><p id="d0df" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了演示我们是如何测试和模仿Redux类的，让我们举一个例子。<em class="md"> DataLoader </em>类抽象了调用各种REST端点和更新UI的复杂性。<em class="md">数据加载器</em>类具有以下状态:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c350" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它定义了以下操作和缩减器来操纵状态:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9b89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md"> DataLoader </em>类也使用动作副作用来执行XHR调用，该调用在成功或失败时将调用进一步的动作:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ebd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个副作用代码一开始可能是难以理解的(其次..)看一下，但本质上是说在应用了<em class="md"> REQUEST_DATA </em>动作之后调用本地函数<em class="md"> _createDataRequest()，</em>并且在应用了<em class="md"> SET_DATA_LOADING </em>动作之后调用本地函数<em class="md"> _getData() </em>。这些函数进行所需的XHR调用(通过包装器<em class="md"> DataLoaderService </em>)并返回一个<em class="md">可观察值</em>，用于在成功或失败时触发另一个动作:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="05a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="md"> DataLoader </em>类的最后一部分是一组选择器，允许检查状态:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c67e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些，我们可以对几个方面进行单元测试:</p><ul class=""><li id="1f48" class="mk ml it kd b ke kf ki kj km mm kq mn ku mo ky mp mq mr ms bi translated"><strong class="kd iu">动作</strong>创作者</li><li id="70f0" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><strong class="kd iu">减速器</strong>状态操纵</li><li id="d154" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated"><strong class="kd iu">选择器</strong>返回正确值</li><li id="106d" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky mp mq mr ms bi translated">在稍微高一点的层次上，想想<strong class="kd iu">史诗</strong>中的<strong class="kd iu">动作副作用</strong>，这个<em class="md">数据加载器</em>类有几个可能的动作路径，帮助我们定义适当的单元测试。</li></ul><ol class=""><li id="1d75" class="mk ml it kd b ke kf ki kj km mm kq mn ku mo ky my mq mr ms bi translated">快乐路径:<em class="md">请求_数据</em>到<em class="md">设置_数据_加载</em>到<em class="md">设置_数据_可用。</em></li><li id="fbe2" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky my mq mr ms bi translated">错误路径:<em class="md">请求_数据</em> (XHR失败)到<em class="md">设置_错误。</em></li><li id="9fec" class="mk ml it kd b ke mt ki mu km mv kq mw ku mx ky my mq mr ms bi translated">错误路径:<em class="md">请求_数据</em>到<em class="md">设置_数据_加载</em> (XHR失败)<em class="md"> </em>到<em class="md">设置_错误。</em></li></ol><p id="ee04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(在所有情况下，根据需要应用<em class="md">关闭</em>动作进行清理)。</p><h1 id="17ca" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动作创建器单元测试</h1><p id="045e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最简单的单元测试是由助手类生成的动作创建函数。这些不需要模仿，可以使用一个简单的<em class="md">describe…test…expect Jest的</em>模式进行单元测试。我们添加这些，不仅是为了检查拼写错误，也是为了帮助理解Redux helper类在做什么。例如:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="cfa3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">减速器单元测试</h1><p id="c2b8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">像动作单元测试一样，减速器单元测试不需要模仿，可以使用一个简单的<em class="md">描述…测试…期望来自Jest的</em>模式进行单元测试。例如:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="f833" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">选择器单元测试</h1><p id="ff07" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">选择器单元测试也不需要模仿，可以使用简单的<em class="md">describe…test…expect Jest的</em>模式进行单元测试。例如:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="277a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">史诗中的动作副作用</h1><p id="309b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">动作副作用对单元测试来说更复杂，因为它们需要创建一个虚拟Redux存储，以及模拟底层XHR调用来模拟成功或失败。</p><p id="5b89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虚拟商店的创建相当简单。我们创建一个全局函数来完成创建，然后使用Jest在每次测试之前自动调用的<em class="md"> beforeEach() </em>回调来调用它:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5601" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦创建了虚拟存储，单元测试就可以涵盖每一个成功和失败的场景。重要的是，底层的<em class="md"> DataLoaderService </em>类是使用Jest模拟的，因此我们可以从它模拟成功和失败的响应，而不需要真正的XHR调用。一个成功场景单元测试的例子是:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b9f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，单元测试失败的一个例子是:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="8002" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">把所有的放在一起</h1><p id="05d4" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">随着单元测试的开发，它可以通过使用<a class="ae kz" href="https://www.npmjs.com/package/jest-cli" rel="noopener ugc nofollow" target="_blank"> Jest CLI </a>在insolation中运行，传递要运行的测试的文件名。忽略此操作将运行找到的所有测试:</p><pre class="me mf mg mh gt mz na nb nc aw nd bi"><span id="40cb" class="ne lb it na b gy nf ng l nh ni">jest dataloader.test.js --coverage</span></pre><p id="7e29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl na b">--coverage</code>标志意味着Jest也将报告加载的文件的覆盖范围:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d99d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管我不鼓励过分追求100%的代码覆盖率，但令人欣慰的是，我们在Redux类中编写的所有代码现在都有测试覆盖率。和所有的单元测试一样，开始是痛苦的，但是一旦你开始了，就你所生产的产品的质量而言，它是有回报的。</p></div></div>    
</body>
</html>