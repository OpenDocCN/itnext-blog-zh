<html>
<head>
<title>Collections in Dart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart中的集合</h1>
<blockquote>原文：<a href="https://itnext.io/collections-in-dart-1fd252cc4bff?source=collection_archive---------3-----------------------#2022-08-29">https://itnext.io/collections-in-dart-1fd252cc4bff?source=collection_archive---------3-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a58802b5852d209766786d021724e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CRfC0yJSq_5WOWuX"/></div></div></figure><h1 id="c5bd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/bb70174cc54bc3eb8dafe332dab22daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*DKPIGIBTIEp8-_Wu1tlXEQ.gif"/></div></figure><p id="d869" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">编程语言为我们如何在应用程序中组织数据提供了如此多的选择，Dart就是这些编程语言中的一种。像其他编程语言一样，Dart也为我们提供了一些对集合中的数据进行分组的方法，这也是本文要讨论的内容。<br/>在谈论集合之前，我们必须理解或回顾泛型编程。<br/>那么，让我们进入正题:</p><h1 id="822e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">通用编程</h1><p id="eca3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在学习Flutter或Dart时，您可能会发现类似于<code class="fe me mf mg mh b">Example&lt;T&gt;</code>或<code class="fe me mf mg mh b">Future&lt;T&gt;</code>的表达式，而<code class="fe me mf mg mh b">&lt;T&gt;</code>符号仅仅意味着字母<code class="fe me mf mg mh b">T</code>必须在编译时被替换为实际的实例。例如，如果我们有<code class="fe me mf mg mh b">Example&lt;String&gt;</code>，我们的意思是字母<code class="fe me mf mg mh b">T</code>将被<code class="fe me mf mg mh b">String</code>类型所取代。</p><p id="ee46" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以使用这个注释定义一个类，如下所示:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4ced" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们创建泛型类型类时，有可能在泛型类之间创建一个层次结构，但是我们必须意识到这一点:<br/>子类必须至少拥有与其超类定义的相同数量的参数化类型(如果<em class="mk">超类</em>定义了一个参数化类型，那么<em class="mk">子类</em>必须拥有一个或多个参数化类型)。<br/>子类必须用其超类定义的相同字母来声明，例如，如果我们有<code class="fe me mf mg mh b">Athlete&lt;T&gt;</code>，子类必须定义为<code class="fe me mf mg mh b">SoccerPlayer&lt;T,M&gt;</code> (SoccerPlayer扩展运动员)。<br/>你可以在超类中定义尽可能多的参数，只是不要忘记提到超类参数字母(s)；</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8e53" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">也可以使用<code class="fe me mf mg mh b">T</code>符号定义<a class="ae ml" href="https://dart.dev/guides/language/type-system#:~:text=The%20Dart%20language%20is%20type,optional%20because%20of%20type%20inference." rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">类型安全</strong> </a>类字段，我们只是不使用菱形<code class="fe me mf mg mh b">&lt; &gt;</code>，如下所示:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">字段personObject具有通用类型</figcaption></figure><p id="6690" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">此功能可用于定义类、字段、函数、列表、集合、映射等。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="1291" class="jy jz iq bd ka kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv bi translated">收集</h1><h2 id="b243" class="nc jz iq bd ka nd ne dn ke nf ng dp ki lm nh ni km lq nj nk kq lu nl nm ku nn bi translated">目录</h2><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ba5f62bec41f0f1b30b5f68ebda9ce4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*dj1_lxC3yrnykHGY1jKJXg.gif"/></div></figure><p id="c0e3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">List是一种有序的集合类型，允许我们在其中设置一组数据类型。</p><p id="4d25" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">定义列表</strong></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d33a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">numbers</code>不是泛型类型列表，这就是为什么我们可以像<code class="fe me mf mg mh b">String</code>一样添加不同的值，编译器不会抛出错误；</p><p id="5175" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">numbers.add(“a”);</code></p><p id="aa97" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">另一方面，<code class="fe me mf mg mh b">flutter </code>列表是类型<code class="fe me mf mg mh b">String</code>的通用列表。<br/>由于类型安全，我们不允许在其中添加不同的数据类型。<br/> <code class="fe me mf mg mh b">Flutter.add(3); //error</code></p><p id="387b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以使用<code class="fe me mf mg mh b">addAll() </code>方法或spread操作符来添加另一个列表的副本，而不是使用<code class="fe me mf mg mh b">add()</code>方法来插入一个值</p><p id="3fac" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用<code class="fe me mf mg mh b">addAll()</code>方法</p><p id="c3e3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">Numbers.addAll([1,2,3])</code></p><p id="7eeb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用扩展运算符将列表a的副本插入到数字列表中。<br/> <code class="fe me mf mg mh b">Numbers.addAll([…a]) // "a" is another list</code></p><p id="731e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第三个版本是在列表初始化中使用一个循环来插入值。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="40b0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">列表有<code class="fe me mf mg mh b">first</code>、<code class="fe me mf mg mh b">last</code>、<code class="fe me mf mg mh b">length</code>、<code class="fe me mf mg mh b">isEmpty</code>、<code class="fe me mf mg mh b">reversed</code>等多种礼节。也有很多方法如<code class="fe me mf mg mh b">add()</code>、<code class="fe me mf mg mh b">addAll()</code>、<code class="fe me mf mg mh b">clear()</code>、<code class="fe me mf mg mh b">asMap()</code>等。<br/>查阅<a class="ae ml" href="https://api.dart.dev/stable/2.17.7/dart-core/List-class.html" rel="noopener ugc nofollow" target="_blank"> <em class="mk">官方文献</em> </a>查看完整的方法和礼单。</p><p id="6d31" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">根据官方文件，清单可分为<strong class="ld ir">可增长清单</strong>和<strong class="ld ir">定长清单</strong>。</p><p id="1b22" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">可增长的</strong>列表是那些其<em class="mk">大小</em>没有在声明中指定，并且可以在程序生命周期中增加或减少的列表。</p><p id="c222" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">var l = [];<br/>var growable= &lt;int&gt;[];</code></p><p id="09f1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这两个列表都是可增长的，但是其中一个有类型，另一个没有。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a7a8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">固定列表</strong>是那些在定义中指定了大小的列表，并且这个大小在程序生命周期中不能改变。<br/> <code class="fe me mf mg mh b">List&lt;int&gt; fixed = List.filled(3,0);</code> <br/>这一行创建一个大小为3的列表，默认值为零。如果我们试图使用增加列表大小的方法，我们将会出错。<br/> <code class="fe me mf mg mh b">Fixed.add(1) //error</code> <br/>我们能做的就是更新列表的索引值。<br/>注意，fixed是类型<code class="fe me mf mg mh b"> List&lt;int&gt;</code>，我们不能在filled的第二个参数中设置不同的值类型。<br/> <code class="fe me mf mg mh b">List&lt;int&gt; fixed = List.filled(3,”a”); //error</code></p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h2 id="3956" class="nc jz iq bd ka nd ne dn ke nf ng dp ki lm nh ni km lq nj nk kq lu nl nm ku nn bi translated">一组</h2><p id="564b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">是对象的集合，其中每个对象只能出现一次。<br/>集合可以使用大括号直接初始化。</p><p id="e141" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">final uniqueKeys = {1,1, 2, 3, 4, 5};</code></p><p id="fc0f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">查看上面的<code class="fe me mf mg mh b">uniqueKeys</code>集合的定义，编译器自动显示一条诊断消息，通知集合集合可能有唯一的键，但是它不会在运行时抛出任何异常。因为它不允许我们重复值，当打印时，集合中的一个重复值不会被打印。</p><p id="1333" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">定义集合</strong></p><p id="9421" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">同样，我们可以定义泛型列表，也可以定义泛型集合。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="70ae" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">集合还支持扩展符号(…和…？)以及其中的if和for语句来决定哪些元素可以添加到集合中。</p><p id="767f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Dart中定义的集合包含以下属性:</p><p id="927b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">first</code> —获取集合中的第一个元素</p><p id="4515" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">isEmpty</code> —检查器械包是否为空</p><p id="7981" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">isNotEmpty</code> —检查器械包是否为空</p><p id="0826" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">last</code> —获取集合的最后一个元素</p><p id="2002" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">length</code> —获取集合的长度。</p><p id="acfe" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">single</code> —检查集合是否只有一个元素</p><p id="4d86" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">并有以下方法:</p><p id="9d57" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">difference(Set&lt;T?&gt; another)</code></p><p id="91be" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">containsAll()</code></p><p id="0f5b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">elementAt(int index)</code></p><p id="1f7f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这些不是集合的唯一属性和方法，<a class="ae ml" href="https://api.dart.dev/stable/2.17.7/dart-core/Set-class.html" rel="noopener ugc nofollow" target="_blank">"有关更多信息，请访问api.dart.dev" </a>。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h2 id="9357" class="nc jz iq bd ka nd ne dn ke nf ng dp ki lm nh ni km lq nj nk kq lu nl nm ku nn bi translated">地图</h2><p id="7479" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">地图集合在<em class="mk">键值对</em> <code class="fe me mf mg mh b">Map&lt;K,V&gt; </code>中存储数据。</p><p id="f3ec" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这意味着，它不使用传统的int索引，而是使用<strong class="ld ir">键</strong>来定位和访问<strong class="ld ir">值</strong>。如果您正在开发一个从API中检索数据的应用程序，您可能会使用Map集合来接收经过解析的JSON对象，并将其转换为一个对象(在工厂构造函数中)。</p><p id="fd88" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了访问地图集合的值，我们使用键，而不是索引。让我们看看这个例子:<br/>假设您正在从<em class="mk"> google books API </em>中检索图书，并且您想要将数据转换成一个对象。</p><p id="922c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Api <a class="ae ml" href="https://www.googleapis.com/books/v1/volumes?q=$query&amp;fields=kind,items(id,volumeInfo/title,volumeInfo/authors,volumeInfo/description,volumeInfo/categories,volumeInfo/averageRating,volumeInfo/imageLinks/thumbnail)" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir"> url </strong> </a>(点击我)</p><p id="f506" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">回应是这样的:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="209e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">所以，这将是解析成JSON后的主体响应。<br/>那么让我们来访问这些值。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="fb47" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">该方法接收一个Map集合作为参数，它有一个作为键的<code class="fe me mf mg mh b">String </code>和一个作为值的<code class="fe me mf mg mh b">dynamic </code>。</p><p id="8480" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你仔细观察<code class="fe me mf mg mh b">factory constructor</code>，你会注意到我们使用它的键而不是索引来访问<code class="fe me mf mg mh b">Map </code>值，就像我们在列表中做的一样。</p><p id="cc94" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">关于Map有趣的事实是，它们不接受重复的键，所以如果我们重复一个键(已经添加到Map中)试图将一个值与同一个键组合，我们实际上是在更新这个值。</p><p id="20df" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们看看下面的例子</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4d29" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这将是输出:</p><p id="3d39" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">{a: just another text, b: second letter}</code></p><p id="cc0d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">于是，<code class="fe me mf mg mh b">key</code> a的<code class="fe me mf mg mh b">value</code>被覆盖。</p><p id="4148" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">以下是您可以使用的地图类型:</p><p id="5b5f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">HashMap&lt;K,V&gt;</code> —这是一个无序的地图，这意味着我们在打印地图时得到的顺序与添加了键的顺序不同。</p><p id="b1fe" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">LinkedHasMap&lt;K,V&gt;</code>一个有序映射，它按照插入顺序迭代关键字。</p><p id="30a9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe me mf mg mh b">SplayTreeMap&lt;K,V&gt;</code>它按照关键字排序顺序迭代地图。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/643ec546b2d5eab2fa19d2ecf8ef53e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*W9BcrOx8a4IemCapQGNvfA.gif"/></div></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="38ab" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">谢谢！</strong>阅读这篇文章。我希望它对你有所帮助，甚至从不同的角度理解这个话题。</p><p id="20eb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你有任何疑问或者你可能觉得少了什么，你可以通过<a class="ae ml" href="https://twitter.com/a_azinar" rel="noopener ugc nofollow" target="_blank">推特</a>或者<a class="ae ml" href="https://t.me/albertoazinar" rel="noopener ugc nofollow" target="_blank">电报</a>联系我。我很乐意和你谈谈这件事。</p><p id="1ef0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> <em class="mk">一切都是Widget！</em> </strong></p></div></div>    
</body>
</html>