<html>
<head>
<title>A Day with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与科特林共度的一天</h1>
<blockquote>原文：<a href="https://itnext.io/a-day-with-kotlin-5a55eba1965e?source=collection_archive---------1-----------------------#2018-04-10">https://itnext.io/a-day-with-kotlin-5a55eba1965e?source=collection_archive---------1-----------------------#2018-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0a65" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Kotlin拥有而Java没有的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/b27bb0b49fd6b2c077d0157c301342f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*l43D4aghnL7hFSSZPYKedQ.jpeg"/></div></figure><p id="bcb8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以，我最近听说了很多关于科特林的事，并决定试一试。学习一门新语言会很有趣，也许我会发现它对某些产品或应用程序很有用。</p><p id="3850" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kotlin的官方<a class="ae lj" href="https://kotlinlang.org/docs/reference" rel="noopener ugc nofollow" target="_blank">文档</a>很棒，并且有许多关于Kotlin语言的介绍文章，所以我不会解释基础知识和语法，而是想展示一些Java没有的独特特性，这些特性使Kotlin脱颖而出。</p><h2 id="7c34" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">1.零安全</h2><p id="6aaf" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">包括Java在内的许多编程语言最常见的缺陷之一是，访问空引用会导致空引用异常。在Java中，这被称为<code class="fe mi mj mk ml b">NullPointerException</code>或NPE。</p><p id="5650" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kotlin的类型系统消除了代码中空引用的危险。只有在以下情况下，科特林才会抛出<code class="fe mi mj mk ml b">NullPointerException</code>:</p><ul class=""><li id="6f8b" class="mm mn iq kp b kq kr kt ku kw mo la mp le mq li mr ms mt mu bi translated">程序员显式调用<code class="fe mi mj mk ml b">throw NullPointerException();</code></li><li id="5454" class="mm mn iq kp b kq mv kt mw kw mx la my le mz li mr ms mt mu bi translated"><code class="fe mi mj mk ml b">!!</code>操作器的使用</li><li id="f4fd" class="mm mn iq kp b kq mv kt mw kw mx la my le mz li mr ms mt mu bi translated">关于初始化的一些数据不一致</li><li id="fb56" class="mm mn iq kp b kq mv kt mw kw mx la my le mz li mr ms mt mu bi translated">Java插值</li></ul><p id="38da" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">科特林区分了<code class="fe mi mj mk ml b">null</code>(可空引用)和非<code class="fe mi mj mk ml b">null</code>(非空引用)类型。默认情况下，类型是非空的，可以通过添加一个<code class="fe mi mj mk ml b">?</code>使其可为空</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="ca04" class="lk ll iq ml b gy ne nf l ng nh">var a: String = "abc"  // non-null reference by default<br/>a = null               // compile time error!</span><span id="289b" class="lk ll iq ml b gy ni nf l ng nh">// now if you call a method on a, its guaranteed not to cause a NPE<br/>var len = a.length     // fine</span><span id="63e9" class="lk ll iq ml b gy ni nf l ng nh">var b: String? = "abc" // nullable reference<br/>b = null               // okay</span><span id="1ab8" class="lk ll iq ml b gy ni nf l ng nh">// but if you access same property on b<br/>// that won't be safe and compiler throws an error!<br/>var len = b.length     // error: b can be null</span><span id="6aad" class="lk ll iq ml b gy ni nf l ng nh">// you can use safe call operator ?. though<br/>var len = b?.length    // okay, this will return the length<br/>// if b is not null and will return null otherwise</span></pre><h2 id="ac19" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">2.智能转换</h2><p id="8e32" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Kotlin跟踪您的逻辑，并在可能的情况下自动转换类型。不再像在Java中那样，在显式强制转换之后进行<code class="fe mi mj mk ml b">instanceof</code>检查。</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="f26a" class="lk ll iq ml b gy ne nf l ng nh">var s = "abc"<br/>if (s is String)<br/>    println(s.length)</span></pre><p id="f538" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kotlin跟踪<code class="fe mi mj mk ml b">is </code>检查，你不必使用显式的强制转换操作符。</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="0c4a" class="lk ll iq ml b gy ne nf l ng nh">fun demo(x: Any) {<br/>    if (x is String)<br/>        println(x.length) // x is automatically cast to String<br/>}</span></pre><h2 id="d996" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">3.字符串模板</h2><p id="659b" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">字符串可能包含模板表达式，即被评估的代码，其结果被连接到字符串中。</p><p id="6b64" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">模板表达式以一个<code class="fe mi mj mk ml b">$</code>符号开始，可以是一个简单的名称，如下所示:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="ded8" class="lk ll iq ml b gy ne nf l ng nh">val n = 10<br/>println("n = $n") // prints n = 10</span></pre><p id="aae9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者可以是大括号中的任意表达式，如下所示:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="be64" class="lk ll iq ml b gy ne nf l ng nh">val s = "abc"<br/>println("$s.length is ${s.length}") // prints abc.length is 3</span></pre><p id="2a89" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以像这样计算表达式:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="2722" class="lk ll iq ml b gy ne nf l ng nh">val a = 3<br/>val b = 5<br/>println("Sum of $a and $b is ${a + b}")<br/>// prints Sum of 3 and 5 is 8</span></pre><h2 id="199a" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">4.性能</h2><p id="f693" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Kotlin中的类可以有属性。不需要像在Java中那样用显式编写的getters和setters来扩充代码。属性可以使用<code class="fe mi mj mk ml b">var</code>关键字声明为可变的，或者使用<code class="fe mi mj mk ml b">val</code>关键字声明为只读的。</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="a0b6" class="lk ll iq ml b gy ne nf l ng nh">class Address {</span><span id="8ba0" class="lk ll iq ml b gy ni nf l ng nh">var name: String = ""<br/>    var street: String = ""<br/>    var city: String = ""<br/>    var state: String? = ""<br/>    var zip: String = ""</span><span id="89a3" class="lk ll iq ml b gy ni nf l ng nh">}</span></pre><p id="13c9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">用法:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="012d" class="lk ll iq ml b gy ne nf l ng nh">fun copyAddress(address: Address): Address {</span><span id="42ba" class="lk ll iq ml b gy ni nf l ng nh">val result = Address() // there is no new keyword in Kotlin!<br/>    result.name = address.name // accessors are called<br/>    result.street = address.street<br/>    // ...<br/>    return result</span><span id="7ee1" class="lk ll iq ml b gy ni nf l ng nh">}</span></pre><h2 id="f082" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">5.主构造函数</h2><p id="9f03" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Kotlin中的类声明包括:</p><ul class=""><li id="1084" class="mm mn iq kp b kq kr kt ku kw mo la mp le mq li mr ms mt mu bi translated">类别名</li><li id="4157" class="mm mn iq kp b kq mv kt mw kw mx la my le mz li mr ms mt mu bi translated">类头(主构造函数和其他类型参数)</li><li id="21b0" class="mm mn iq kp b kq mv kt mw kw mx la my le mz li mr ms mt mu bi translated">班级团体</li></ul><p id="3537" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kotlin中的类可以有一个主构造函数，如下所示:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="9e3e" class="lk ll iq ml b gy ne nf l ng nh">class Person(firstName: String) {</span><span id="f690" class="lk ll iq ml b gy ni nf l ng nh">}</span></pre><p id="5144" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以将initalizer块用作:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="5fb9" class="lk ll iq ml b gy ne nf l ng nh">class Customer(name: String) {</span><span id="567d" class="lk ll iq ml b gy ni nf l ng nh">val customerKey = name.toUpperCase()</span><span id="e8ef" class="lk ll iq ml b gy ni nf l ng nh">}</span></pre><p id="1c39" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">还有二级构造函数，看看。</p><h2 id="e543" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">6.类型推理</h2><p id="cda3" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">科特林推断变量和属性的数据类型。因此，您可以在任何您认为可以提高可读性的地方省略类型。</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="f679" class="lk ll iq ml b gy ne nf l ng nh"><strong class="ml ir">val</strong> a = "abc"                         // type inferred to String<br/><strong class="ml ir">val</strong> b = 4                             // type inferred to Int</span><span id="988a" class="lk ll iq ml b gy ni nf l ng nh"><strong class="ml ir">val</strong> c: Double = 0.7                   // type declared explicitly<br/><strong class="ml ir">val</strong> d: List&lt;String&gt; = ArrayList()     // type declared explicitly</span></pre><p id="04d8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">也支持显式转换。较小的类型不会隐式转换为较大的类型。这意味着我们不能将类型为<code class="fe mi mj mk ml b">Byte</code>的值赋给<code class="fe mi mj mk ml b">Int</code>变量，除非进行如下显式转换:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="0254" class="lk ll iq ml b gy ne nf l ng nh">val b: Byte = 1  // fine, literals are checked statically<br/>val i: Int = b   // Error!</span><span id="7580" class="lk ll iq ml b gy ni nf l ng nh">// use explicit conversions to widen numbers<br/>val i: Int = b.toInt()  // Okay, explicitly widened</span></pre><p id="55f2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kotlin从上下文中推断类型，算术运算被重载以进行适当的转换。例如</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="a326" class="lk ll iq ml b gy ne nf l ng nh">val num = 1L + 3  // Long + Int =&gt; Long</span></pre><h2 id="db71" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">7.范围</h2><p id="2ab9" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Kotlin中的范围表达式是用<code class="fe mi mj mk ml b">..</code>、<code class="fe mi mj mk ml b">in</code>和<code class="fe mi mj mk ml b">!in</code>运算符编写的。</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="e94b" class="lk ll iq ml b gy ne nf l ng nh">for (i in 1..10) // i ∈ [1, 10] both inclusive<br/>    println(i)</span></pre><p id="c03f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你想逆序迭代。使用<code class="fe mi mj mk ml b">downTo()</code>功能如下:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="e67b" class="lk ll iq ml b gy ne nf l ng nh">for (i in 4 downTo 1)<br/>    print(i) // prints 4321</span></pre><p id="80fa" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以任意步长迭代数字，而不是默认的1，使用<code class="fe mi mj mk ml b">step()</code>函数，如下所示:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="df4a" class="lk ll iq ml b gy ne nf l ng nh">for (i in 1..4 step 2)<br/>    print(i) // prints 13</span><span id="87f4" class="lk ll iq ml b gy ni nf l ng nh">for (i in 4 downTo 1 step 2)<br/>    print(i) // prints 42</span></pre><p id="95de" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要排除最后一个元素吗？使用<code class="fe mi mj mk ml b">until()</code>功能。</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="3ed0" class="lk ll iq ml b gy ne nf l ng nh">for (i in 1 until 10) // i ∈ [0, 10) 10 is excluded.<br/>    print(i) // prints 123456789</span></pre><p id="e9b4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">参见这里的其他重要功能<a class="ae lj" href="https://kotlinlang.org/docs/reference/ranges.html#utility-functions" rel="noopener ugc nofollow" target="_blank"/>。这就是为什么我喜欢说Kotlin是Java世界的Python！</p><h2 id="a87e" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">8.扩展功能</h2><p id="86a3" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Kotlin为您提供了用新功能扩展现有类的能力，而不必从该类继承或使用任何类型的设计模式，如Decorator。这是通过称为<em class="nj">扩展</em>的特殊声明来完成的。Kotlin提供了<em class="nj">扩展函数</em>和<em class="nj">扩展属性</em>。</p><p id="7dd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将<code class="fe mi mj mk ml b">swap</code>功能添加到<code class="fe mi mj mk ml b">MutableList&lt;Int&gt;</code>的示例如下:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="72a4" class="lk ll iq ml b gy ne nf l ng nh">fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {<br/>    val temp = this[index1] // 'this' corresponds to the list<br/>    this[index1] = this[index2]<br/>    this[index2] = temp<br/>}</span><span id="8fbc" class="lk ll iq ml b gy ni nf l ng nh">// now you can call such a function on any MutableList&lt;Int&gt; object<br/>val numbers = mutableListOf(1, 2, 3)<br/>numbers.swap(0, 2)<br/>println(numbers) // prints [3, 2, 1]</span></pre><h2 id="9a1a" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">9.运算符重载</h2><p id="9ccf" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">Java不支持运算符重载。科特林<em class="nj">做</em>。在Kotlin中使用操作符时，会调用其对应的成员函数。例如，表达式<code class="fe mi mj mk ml b">a + b</code>转换为引擎盖下的<code class="fe mi mj mk ml b">a.plus(b)</code>。<code class="fe mi mj mk ml b">plus</code>函数被重载，与各种Kotlin基本类型和<code class="fe mi mj mk ml b">String</code>一起工作。</p><p id="8baf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以为自己定义的类型重载运算符。例如</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="4dc3" class="lk ll iq ml b gy ne nf l ng nh">class Point(val x: Int = 0, val y: Int = 10) {</span><span id="cad2" class="lk ll iq ml b gy ni nf l ng nh">// overloading plus operator<br/>    operator fun plus(p: Point): Point {<br/>        return Point(x + p.x, y + p.y)<br/>    }</span><span id="abf5" class="lk ll iq ml b gy ni nf l ng nh">}</span><span id="ed8b" class="lk ll iq ml b gy ni nf l ng nh">// now you can add 2 Point's as<br/>val p1 = Point(3, -8)<br/>val p2 = Point(2, 9)</span><span id="166d" class="lk ll iq ml b gy ni nf l ng nh">val sum = Point()<br/>sum = p1 + p2<br/>println("sum = (${sum.x}, ${sum.y})") // prints sum = (5, 1)</span></pre><p id="17f2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里加号函数被标记为<code class="fe mi mj mk ml b">operator</code>以告诉编译器<code class="fe mi mj mk ml b">+</code>操作符在这里被重载。表情<code class="fe mi mj mk ml b">p1 + p2</code>转化为引擎盖下的<code class="fe mi mj mk ml b">p1.plus(p2)</code>。</p><h2 id="5536" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">10.析构声明</h2><p id="6f41" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">将一个对象析构成许多变量是很方便的。例如</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="2c36" class="lk ll iq ml b gy ne nf l ng nh">val (name, age) = person</span></pre><p id="9a2d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这被称为析构声明。析构声明被编译成以下代码:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="aa05" class="lk ll iq ml b gy ne nf l ng nh">val name = person.component1()<br/>val age = person.component2()</span></pre><p id="3b68" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">析构声明在for循环中也起作用，如下所示:</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="091c" class="lk ll iq ml b gy ne nf l ng nh">for ((a, b) in collection) { ... }</span></pre><p id="c737" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">穿越地图最好的方式可能是</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="6034" class="lk ll iq ml b gy ne nf l ng nh">for ((key, value) in map) {<br/>    // do something with key and value<br/>}</span></pre><p id="4ccb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">析构声明也有助于从函数中返回两个值。例如</p><pre class="kg kh ki kj gt na ml nb nc aw nd bi"><span id="1314" class="lk ll iq ml b gy ne nf l ng nh">data class Result(val result: Int, val status: Status)<br/>fun function(...): Result {<br/>    // other code<br/>    return Result(result, status)<br/>}</span></pre><p id="8c52" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">除了上面提到的主要特性，Kotlin还支持<code class="fe mi mj mk ml b">==</code>(结构等式)和<code class="fe mi mj mk ml b">===</code>(引用等式)、默认参数、命名参数、<code class="fe mi mj mk ml b">when</code>表达式作为更好的<code class="fe mi mj mk ml b">switch</code> case语句、lambdas和高阶函数。</p><h2 id="4eb6" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">结论</h2><p id="eb17" class="pw-post-body-paragraph kn ko iq kp b kq md jr ks kt me ju kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">总的来说，我认为Kotlin是一种很棒的语言，默认情况下是安全的，而且使用起来非常愉快。我在这里只谈了冰山一角，还有很多要谈的。如果你是一个Scala开发者，你可能不会在Kotlin中发现很多新东西。但是，如果你是一名Java开发人员，厌倦了样板文件和开始实际工作之前的所有仪式，那么Kotlin就是适合你的。</p><p id="8add" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">干杯！</p></div></div>    
</body>
</html>