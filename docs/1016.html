<html>
<head>
<title>Handling Long Running API Requests in Nodejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Nodejs中处理长时间运行的API请求</h1>
<blockquote>原文：<a href="https://itnext.io/handling-long-running-api-requests-in-nodejs-403bd566d47?source=collection_archive---------1-----------------------#2018-07-05">https://itnext.io/handling-long-running-api-requests-in-nodejs-403bd566d47?source=collection_archive---------1-----------------------#2018-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e3be539a7ca626b28bbe2bd8406dcfb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*lv4y-fWfvOn_YGnBdJOu_g.jpeg"/></div></figure><p id="2b42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我已经研究了<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/building-restful-web-apis-with-node-js-express-mongodb-and-typescript-part-1-2-195bdaf129cf">设计和部署RESTful API有一段时间了</a>。并且处理和呈现来自客户端的请求的数据是有趣的。今天，我收到一个问题，关于我应该如何处理一个需要一定时间处理的请求。我们不能让客户等10分钟才能得到回复。此外，在数据处理过程中，任何其他请求都必须等待，这可能会导致瓶颈。必须有一些方法来处理长时间运行的任务。</p><p id="54d4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在做了一些研究后，我发现在构建应用程序时，有两种交互模式可供我们使用:</p><ul class=""><li id="c824" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><strong class="jw ir">请求-响应(同步)</strong>:响应返回一个答案。例如，在电子商务应用程序中，如果提交的订单已被处理或有任何问题，用户会立即得到通知。</li><li id="1caf" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><strong class="jw ir">一劳永逸(异步)</strong>:请求已被接收，并提供了获取响应的替代方法。例如，当用户导入大量需要处理的数据时，他们会收到数据已收到的确认，并被指示检查导入队列以查看状态。或者，在导入完成时发送一条消息。</li></ul><p id="b4fe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这导致了<strong class="jw ir">消息队列</strong>的概念，它可以卸载处理并释放资源，以便应用程序可以处理其他请求。</p><p id="302e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个演示中，我将使用RabbitMQ来处理API请求。</p><p id="db35" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第一步:准备好RabbitMQ】</strong></p><p id="d800" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你既可以从<a class="ae ks" href="https://www.cloudamqp.com" rel="noopener ugc nofollow" target="_blank"> CloudAMQP </a>注册一个账户，也可以从本地机器从<a class="ae ks" href="https://www.rabbitmq.com/download.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>安装服务。</p><p id="a9b7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在从CloudAMQP创建了一个帐户和一个实例之后，您可以点击该实例并查看云托管的RabbitMQ信息。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lh"><img src="../Images/9376742f0a995da61e43e77b81a497b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWLf8sm_CQl8eSfXJncjdQ.png"/></div></div></figure><p id="9064" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您在本地安装RabbitMQ，安装完成后，RabbitMQ服务将自动在您的机器上运行。您可以通过应用程序中的<strong class="jw ir">“amqp://localhost”</strong>URL访问它。</p><p id="c322" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">步骤2:实现RESTful API的消息队列</strong></p><p id="7eca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个例子中，我假设我们将有一个很长的处理POST请求，可能需要几分钟才能完成。</p><p id="0dff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在做任何事情之前，我们需要安装amqp.node包</p><pre class="li lj lk ll gt lq lr ls lt aw lu bi"><span id="0c91" class="lv lw iq lr b gy lx ly l lz ma">npm install amqplib</span></pre><p id="25cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，在您的路线中，您需要导入包</p><pre class="li lj lk ll gt lq lr ls lt aw lu bi"><span id="427c" class="lv lw iq lr b gy lx ly l lz ma">// For TypeScript<br/>import * as amqp from 'amqplib/callback_api';</span><span id="2759" class="lv lw iq lr b gy mb ly l lz ma">// For JavaScript <br/>var amqp = require('amqplib/callback_api');</span></pre><p id="e88d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后编辑发布路线功能。例如:</p><pre class="li lj lk ll gt lq lr ls lt aw lu bi"><span id="9079" class="lv lw iq lr b gy lx ly l lz ma">app.route('/messages).post(req: Request, res: Response) {</span><span id="ecb7" class="lv lw iq lr b gy mb ly l lz ma"> amqp.connect('amqp://localhost', (err, conn) =&gt; {<br/>  conn.createChannel((err, ch) =&gt; {<br/>   const q = 'hello';<br/>   ch.assertQueue(q, {durable: false});</span><span id="f762" class="lv lw iq lr b gy mb ly l lz ma">   // I suppose the process will take about 5 seconds to finish<br/>   setTimeout(() =&gt; {<br/>    let msg = 'Get data from message queue!';<br/>    ch.sendToQueue(q, new Buffer(msg));<br/>    console.log(` [X] Send ${msg}`);<br/>   }, 5000)                       <br/>  });</span><span id="2b0b" class="lv lw iq lr b gy mb ly l lz ma">  // The connection will close in 10 seconds<br/>  setTimeout(() =&gt; {<br/>   conn.close();<br/>  }, 10000);<br/> });<br/> res.send('The POST request is being processed!');<br/>}</span></pre><p id="933a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们的API将监听一个POST请求。例如来自:<a class="ae ks" href="https://localhost:3000/messages'" rel="noopener ugc nofollow" target="_blank">https://localhost:3000/messages</a></p><p id="1d2a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了测试配置，我将使用<a class="ae ks" href="https://www.npmjs.com/package/request" rel="noopener ugc nofollow" target="_blank">请求包</a>从客户端发出POST请求。</p><pre class="li lj lk ll gt lq lr ls lt aw lu bi"><span id="b7d0" class="lv lw iq lr b gy lx ly l lz ma">// receive.js<br/>var amqp = require('amqplib/callback_api');<br/>var request = require('request');</span><span id="8444" class="lv lw iq lr b gy mb ly l lz ma">request.post('<a class="ae ks" href="https://localhost:3000/messages'" rel="noopener ugc nofollow" target="_blank">https://localhost:3000/messages'</a>, function (error, response, body) {</span><span id="8e26" class="lv lw iq lr b gy mb ly l lz ma">    console.log(response.body);</span><span id="498e" class="lv lw iq lr b gy mb ly l lz ma">    // Connect to the server and wait for the queue<br/>    amqp.connect('amqp://localhost', (err, conn) =&gt; {<br/>        conn.createChannel((err, ch) =&gt; {<br/>            var q = 'hello';</span><span id="fad4" class="lv lw iq lr b gy mb ly l lz ma">ch.assertQueue(q, {<br/>                durable: false<br/>            });<br/>            console.log(' [*] Waiting for messages in %s. To exit press CTRL+C', q);<br/>            ch.consume(q, msg =&gt; {<br/>                console.log(' [x] Received %s', msg.content);  <br/>                conn.close();            <br/>            }, {<br/>                noAck: true<br/>            });<br/>        });<br/>    })<br/>        <br/>});</span></pre><p id="ff94" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我运行测试服务器并发出示例POST请求。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mc"><img src="../Images/21c5ae76bb38e51125080aaad4463053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XEbw9GFkM1AiNVDxD59iA.png"/></div></div></figure><p id="8bd9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如你所看到的，5s后，API会分解出文本<strong class="jw ir">‘从消息队列获取数据！’</strong>、<strong class="jw ir">、</strong>和POST请求也从控制台日志中获取消息并打印出来。</p><p id="835b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管这只是一个测试项目，但您现在已经知道了一种在调用RESTful API应用程序时处理长时间运行过程的方法。</p><p id="3924" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">参考文献:</strong></p><ul class=""><li id="4f5c" class="kt ku iq jw b jx jy kb kc kf kv kj kw kn kx kr ky kz la lb bi translated"><a class="ae ks" href="https://www.devbridge.com/articles/messaging-with-rabbitmq-in-node-js/" rel="noopener ugc nofollow" target="_blank">node . js中RabbitMQ的消息传递</a></li><li id="081a" class="kt ku iq jw b jx lc kb ld kf le kj lf kn lg kr ky kz la lb bi translated"><a class="ae ks" href="https://www.rabbitmq.com/tutorials/tutorial-one-javascript.html" rel="noopener ugc nofollow" target="_blank"> RabbitMQ教程</a></li></ul><p id="0da0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="https://twitter.com/dale_nguyen" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">在Twitter上关注我</strong> </a>了解Angular、JavaScript &amp; WebDevelopment的最新内容👐</p></div></div>    
</body>
</html>