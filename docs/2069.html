<html>
<head>
<title>React Hooks — designing a simple forms API — part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react Hooks——设计简单的表单API——第1部分</h1>
<blockquote>原文：<a href="https://itnext.io/react-hooks-designing-a-simple-forms-api-part-1-307b04bc6007?source=collection_archive---------3-----------------------#2019-03-26">https://itnext.io/react-hooks-designing-a-simple-forms-api-part-1-307b04bc6007?source=collection_archive---------3-----------------------#2019-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fb41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您致力于创建功能组件而不是类组件，那么您需要深入钩子。您将使用大量的钩子，随着代码规模的增加，您可能需要创建自定义钩子。React钩子提供了一种抽象可重用逻辑的新方法。开始使用它们很容易，但是我发现随着用例复杂性的增加，抽象您的定制钩子变得更具挑战性。</p><p id="6435" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个由多个部分组成的系列中，我们将设计一个简单的useForm钩子，并讨论测试策略。我不建议您构建自己的自定义表单API，因为有许多React表单库，既有基于组件的，也有基于hook的，您可以开始使用。但是我相信设计和实现表单API是加深对React钩子理解的一个好方法。</p><p id="c7c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第1部分中，我们将从创建一个简单的useForm挂钩开始，并讨论如何在表单中使用它。我们还将讨论测试钩子的方法。我们开始吧！</p><p id="b684" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-2-1fe5d12f23d9"> part 2 </a>、<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-3-validation-and-a-running-example-18b835a3b817"> part 3 </a>和<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-designing-a-simple-forms-api-part-4-scaling-to-other-input-types-e738db0a3fc3"> part 4 </a>在线💪。</p><h1 id="b6f5" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤1 —设计公共API</h1><p id="9537" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我发现设计hooks APIs的最佳起点是首先理解你希望它做什么，然后你将如何使用它。所以让我们想象一个叫做<code class="fe ls lt lu lv b">useForm</code>的钩子。</p><h2 id="d21f" class="lw kq it bd kr lx ly dn kv lz ma dp kz kb mb mc ld kf md me lh kj mf mg ll mh bi translated">它会做什么？</h2><ul class=""><li id="e9a8" class="mi mj it js b jt ln jx lo kb mk kf ml kj mm kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>将是主要的API入口点</li><li id="5597" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>将向消费者提供输入状态，即名称和值。出于表单初始化的目的，输入状态必须能够传递给useForm钩子</li><li id="2431" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>将提供表单的整体UI状态，如“表单是否提交”、“表单是否提交”、“表单是否验证”</li><li id="e3f4" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>将尝试为表单提供合理的HTML属性</li><li id="a5ea" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>提供可访问性道具，如果消费者希望支持可访问性标准，如<a class="ae ko" href="https://medium.com/@shanplourde/strategies-for-building-accessible-websites-f0d256decae6" rel="noopener"> WCAG AA </a>，他们可以选择使用这些道具</li><li id="e908" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">消费者将通过<code class="fe ls lt lu lv b">useForm</code>钩子定义表单、输入和验证器</li><li id="cec5" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>将支持异步验证和提交</li><li id="7204" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>原料药应进行测试</li><li id="7dfa" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">API将完全是非可视化的，这样消费者就可以完全控制他们表单的外观和感觉</li></ul><p id="1362" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于第1部分的目的，我们将创建一个简单的钩子初始版本，它包括定制的onSubmit函数支持和测试策略。</p><h2 id="4184" class="lw kq it bd kr lx ly dn kv lz ma dp kz kb mb mc ld kf md me lh kj mf mg ll mh bi translated">我们将如何使用它？</h2><p id="7ef8" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我设想用法如下:</p><pre class="mw mx my mz gt na lv nb nc aw nd bi"><span id="1317" class="lw kq it lv b gy ne nf l ng nh">const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));</span><span id="9136" class="lw kq it lv b gy ni nf l ng nh">function SampleForm(props) {<br/>  const { settings } = props;</span><span id="16aa" class="lw kq it lv b gy ni nf l ng nh"><strong class="lv iu">const { getFormProps, formState, formSummary } = useForm("settingsForm", {<br/>    ...settings<br/>  });</strong></span><span id="c4bc" class="lw kq it lv b gy ni nf l ng nh">const onSubmit = async ({ evt, formState } =&gt; {<br/>    await sleep(2000);<br/>  };</span><span id="2e78" class="lw kq it lv b gy ni nf l ng nh">  return (<br/>    &lt;div&gt;<br/>      &lt;h2&gt;Sample form&lt;/h2&gt;<br/>      {<strong class="lv iu">formSummary.isSubmitting</strong> &amp;&amp; &lt;div&gt;Submitting&lt;/div&gt;}<br/>      &lt;form <strong class="lv iu">{...getFormProps({ onSubmit })}</strong>&gt;<br/>      /* form stuff here */<br/>      &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  );</span><span id="d27e" class="lw kq it lv b gy ni nf l ng nh">}</span></pre><p id="d67a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的表单API将通过<code class="fe ls lt lu lv b">useForm</code>钩子可用。在useForm钩子的第1部分中，<code class="fe ls lt lu lv b">formState</code>将返回当前的表单状态(此时将是一个空对象)。<code class="fe ls lt lu lv b">getFormProps</code>将被消费者用来设置一个表单的道具，比如<code class="fe ls lt lu lv b">onSubmit</code>，因为<code class="fe ls lt lu lv b">useForm</code>钩子将实现一个<code class="fe ls lt lu lv b">onSubmit</code>函数来包装消费者的<code class="fe ls lt lu lv b">onSubmit</code>回调，以便向消费者提供一些高级UI状态。</p><p id="593a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自定义的<code class="fe ls lt lu lv b">onSubmit</code>函数只是一个休眠2秒的存根。这对于异步测试表单很有用。</p><p id="a9a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ls lt lu lv b">formSummary</code>将表示表单的UI摘要。在第一个UI示例中，我们正在查看<code class="fe ls lt lu lv b">isSubmitting</code>道具，如果为真，我们将向消费者显示一条提交消息。这种属性可以通过其他方式实现。也许您的应用程序中有一个全局Redux store来跟踪端点何时被请求和完成，如果是这样，这可能是跟踪表单提交状态的另一种方法。但是为了保持一个全面的API，我们将包括它，但是如果用户不使用它，允许他们忽略它。</p><h1 id="cb02" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">首次实施</h1><p id="c406" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">让我们来看看<code class="fe ls lt lu lv b">useForm</code>钩子的初始版本:</p><pre class="mw mx my mz gt na lv nb nc aw nd bi"><span id="f68f" class="lw kq it lv b gy ne nf l ng nh">import { useState } from "react";</span><span id="5c36" class="lw kq it lv b gy ni nf l ng nh">export const defaultFormProps = {<br/>  autoComplete: "on"<br/>};<br/>export const useForm = (name, initialState = {}, props) =&gt; {<br/>  const [formState, setFormState] = useState({<br/>    values: initialState<br/>  });<br/>  const [formSummary, setFormSummary] = useState({<br/>    isSubmitting: false<br/>  });</span><span id="c40b" class="lw kq it lv b gy ni nf l ng nh">const getFormProps = (props = {}) =&gt; ({<br/>    ...defaultFormProps,<br/>    ...props,<br/>    onSubmit: async evt =&gt; {<br/>      evt.preventDefault();<br/>      try {<br/>        setFormSummary({ isSubmitting: true });<br/>        props.onSubmit &amp;&amp; (await props.onSubmit({ evt, formState }));<br/>      } finally {<br/>        setFormSummary({ isSubmitting: false });<br/>      }<br/>    }<br/>  });</span><span id="c395" class="lw kq it lv b gy ni nf l ng nh">return {<br/>    getFormProps,<br/>    formState: formState,<br/>    formSummary<br/>  };<br/>};</span></pre><p id="5a5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">钩子的初始版本支持defaultFormProps的API，默认情况下<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form" rel="noopener ugc nofollow" target="_blank">表单自动完成</a>属性为on。<code class="fe ls lt lu lv b">getFormProps</code>返回调用者可以扩展到表单上的表单属性。<code class="fe ls lt lu lv b">onSubmit</code>包装调用者<code class="fe ls lt lu lv b">onSubmit</code>，以便能够跟踪<code class="fe ls lt lu lv b">isSubmitting</code>。</p><h1 id="ecb8" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">测试</h1><p id="06f0" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">首先，我们将测试hooks API。当我们开始创建UI测试用例时，我们将保存UI测试以备后用。为了开始测试钩子，我们将使用<a class="ae ko" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> jest </a>和<a class="ae ko" href="https://www.npmjs.com/package/react-hooks-testing-library" rel="noopener ugc nofollow" target="_blank">react-hooks-testing-library</a>。建议使用react-hooks-testing-library测试钩子。</p><p id="b9d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们将使用setTimeout异步测试，所以我们将使用<code class="fe ls lt lu lv b">jest.useFakeTimers</code>，因为jest全局覆盖setTimeout以避免阻塞单元测试。</p><p id="d697" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，测试的目标是测试包含在<code class="fe ls lt lu lv b">useForm</code>钩子中的所有特性。这些测试验证以下内容:</p><ul class=""><li id="d61d" class="mi mj it js b jt ju jx jy kb nj kf nk kj nl kn mn mo mp mq bi translated">传入<code class="fe ls lt lu lv b">useForm</code>的表单状态被正确返回</li><li id="a025" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">自定义<code class="fe ls lt lu lv b">onSubmit</code>回调被调用</li><li id="dec1" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><code class="fe ls lt lu lv b">useForm</code>表单提交前后正确设置整体界面状态(<code class="fe ls lt lu lv b">isSubmitting</code> ) —适用于异步提交</li><li id="757e" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">由于端点故障而导致的承诺拒绝等错误得到了妥善处理</li></ul><p id="984b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有其他可以也应该做的测试，比如验证onSubmit回调的参数。随着API的进一步构建，这些将被添加到将来的部分中</p><pre class="mw mx my mz gt na lv nb nc aw nd bi"><span id="ba07" class="lw kq it lv b gy ne nf l ng nh">import { renderHook, cleanup, act } from "react-hooks-testing-library";<br/>import { useForm } from "./use-form";</span><span id="9306" class="lw kq it lv b gy ni nf l ng nh">const noop = () =&gt; {};</span><span id="2588" class="lw kq it lv b gy ni nf l ng nh">jest.useFakeTimers();</span><span id="0098" class="lw kq it lv b gy ni nf l ng nh">describe("useForm tests", () =&gt; {<br/>  afterEach(cleanup);</span><span id="353e" class="lw kq it lv b gy ni nf l ng nh">it("should return empty form state", () =&gt; {<br/>    const { result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps, formState } = result.current;<br/>    expect(getFormProps).toBeDefined();<br/>    expect(formState.values).toEqual({});<br/>  });</span><span id="631d" class="lw kq it lv b gy ni nf l ng nh">it("should return an initial formSummary", () =&gt; {<br/>    const { result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps, formSummary } = result.current;<br/>    expect(getFormProps).toBeDefined();<br/>    expect(formSummary).toEqual({<br/>      isSubmitting: false<br/>    });<br/>  });</span><span id="3612" class="lw kq it lv b gy ni nf l ng nh">it("should support custom form props", () =&gt; {<br/>    const { result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps } = result.current;<br/>    const formProps = getFormProps({ foo: "bar" });<br/>    expect(formProps.foo).toEqual("bar");<br/>  });</span><span id="7a35" class="lw kq it lv b gy ni nf l ng nh">it("should support custom onSubmit", async () =&gt; {<br/>    const { result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps, formSummary } = result.current;</span><span id="35d6" class="lw kq it lv b gy ni nf l ng nh">const onSubmit = jest.fn();</span><span id="822c" class="lw kq it lv b gy ni nf l ng nh">const formProps = getFormProps({ onSubmit });<br/>    expect(formProps.onSubmit).toBeDefined();</span><span id="db05" class="lw kq it lv b gy ni nf l ng nh">// Could be some weirdness right now due to<br/>    // <a class="ae ko" href="https://github.com/facebook/react/issues/14769" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/issues/14769</a><br/>    act(() =&gt; {<br/>      formProps.onSubmit({ preventDefault: noop });<br/>    });<br/>    expect(formSummary).toEqual({<br/>      isSubmitting: false<br/>    });<br/>    expect(onSubmit).toHaveBeenCalledTimes(1);<br/>  });</span><span id="bca5" class="lw kq it lv b gy ni nf l ng nh">it("should support async onSubmit", async () =&gt; {<br/>    const { waitForNextUpdate, result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps, formSummary } = result.current;</span><span id="5520" class="lw kq it lv b gy ni nf l ng nh">const onSubmit = evt =&gt;<br/>      new Promise(r =&gt; {<br/>        setTimeout(() =&gt; {<br/>          r();<br/>        }, 1000);<br/>      });</span><span id="b3ce" class="lw kq it lv b gy ni nf l ng nh">const formProps = getFormProps({ onSubmit });<br/>    expect(formProps.onSubmit).toBeDefined();</span><span id="0a83" class="lw kq it lv b gy ni nf l ng nh">// Could be some weirdness right now due to<br/>    // <a class="ae ko" href="https://github.com/facebook/react/issues/14769" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/issues/14769</a><br/>    act(() =&gt; {<br/>      formProps.onSubmit({ preventDefault: noop });<br/>    });<br/>    jest.runAllTimers();<br/>    expect(result.current.formSummary).toEqual({<br/>      isSubmitting: true<br/>    });<br/>    await waitForNextUpdate();<br/>    expect(formSummary).toEqual({<br/>      isSubmitting: false<br/>    });<br/>  });</span><span id="d5d5" class="lw kq it lv b gy ni nf l ng nh">it("should gracefully handle onSubmit errors", async () =&gt; {<br/>    const { result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps, formSummary } = result.current;</span><span id="c098" class="lw kq it lv b gy ni nf l ng nh">const onSubmit = evt =&gt; new Error();</span><span id="e8ff" class="lw kq it lv b gy ni nf l ng nh">const formProps = getFormProps({ onSubmit });<br/>    expect(formProps.onSubmit).toBeDefined();</span><span id="2e83" class="lw kq it lv b gy ni nf l ng nh">// Could be some weirdness right now due to<br/>    // <a class="ae ko" href="https://github.com/facebook/react/issues/14769" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/issues/14769</a><br/>    act(() =&gt; {<br/>      formProps.onSubmit({ preventDefault: noop });<br/>    });<br/>    expect(formSummary).toEqual({<br/>      isSubmitting: false<br/>    });<br/>  });</span><span id="b0f3" class="lw kq it lv b gy ni nf l ng nh">it("should gracefully handle async onSubmit errors", async () =&gt; {<br/>    const { waitForNextUpdate, result } = renderHook(() =&gt; useForm());<br/>    const { getFormProps, formSummary } = result.current;</span><span id="e8d2" class="lw kq it lv b gy ni nf l ng nh">const onSubmit = evt =&gt;<br/>      new Promise((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; {<br/>          reject();<br/>        }, 1000);<br/>      });</span><span id="e0cd" class="lw kq it lv b gy ni nf l ng nh">const formProps = getFormProps({ onSubmit });<br/>    expect(formProps.onSubmit).toBeDefined();</span><span id="b348" class="lw kq it lv b gy ni nf l ng nh">// Could be some weirdness right now due to<br/>    // <a class="ae ko" href="https://github.com/facebook/react/issues/14769" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/issues/14769</a><br/>    act(() =&gt; {<br/>      formProps.onSubmit({ preventDefault: noop });<br/>    });<br/>    jest.runAllTimers();<br/>    expect(result.current.formSummary).toEqual({<br/>      isSubmitting: true<br/>    });<br/>    await waitForNextUpdate();<br/>    expect(formSummary).toEqual({<br/>      isSubmitting: false<br/>    });<br/>  });<br/>});</span></pre><h1 id="3b02" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><p id="f5bb" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在第一篇文章中，我们设计了高级的<code class="fe ls lt lu lv b">useForm</code>钩子，设想了如何使用它，并创建了一些初始测试用例来验证<code class="fe ls lt lu lv b">useForm</code>钩子。</p><p id="6d3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何问题、反馈或建议，请告诉我。</p><p id="1b75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://medium.com/@shanplourde/react-hooks-designing-a-simple-forms-api-part-2-1fe5d12f23d9" rel="noopener">本系列的第2部分可以在这里找到</a>。</p></div></div>    
</body>
</html>