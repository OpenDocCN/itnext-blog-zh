<html>
<head>
<title>JavaScript Wizard: What’s up with ‘this’?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript向导:这是怎么回事？</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-wizard-whats-up-with-this-92ca309172d6?source=collection_archive---------2-----------------------#2019-02-04">https://itnext.io/javascript-wizard-whats-up-with-this-92ca309172d6?source=collection_archive---------2-----------------------#2019-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/09f9cb0f37cbbefa06aadd6a4059f63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bo3_iJbnmZ3OWGCmA_VudA.jpeg"/></div></div></figure><div class=""/><p id="cbf7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">臭名昭著的<code class="fe kw kx ky kz b">this</code>关键字JavaScript最让开发人员困惑的事情之一。通常情况下，<code class="fe kw kx ky kz b">this</code>看起来既不可预测又不合逻辑，而且它肯定不像在大多数其他编程语言中那样。如果你曾经因为<code class="fe kw kx ky kz b">this</code>而揪自己的头发，你肯定不是一个人。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="2490" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你能从上面的片段中找出打印出来的内容吗？<br/>这里有一个剧透:<br/> <code class="fe kw kx ky kz b">Hi, I'm undefined, and I'm a undefined</code> <br/>从代码的外观来看大概不是这个意思。<br/>为什么会这样？因为<code class="fe kw kx ky kz b">this</code>在路上的某个地方迷路了。</p><p id="6193" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么<code class="fe kw kx ky kz b">this</code>是怎么回事呢？</p><p id="0991" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将解释<code class="fe kw kx ky kz b">this</code>是如何被绑定的，以及在任何给定的上下文中，如何问自己4个问题，从中你总能确定<code class="fe kw kx ky kz b">this</code>指向什么。</p><h1 id="7ad5" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">词法范围与动态范围</h1><p id="ef20" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">首先，我们需要理解JavaScript中的作用域是如何工作的。<br/>和大多数编程语言一样，JavaScript使用<em class="mj">词法范围。</em></p><figure class="la lb lc ld gt is gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6f41678cd50d78535d1213d1d952617f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*e8vpz63LFGep4lY0h_asBA.png"/></div></figure><p id="1777" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着变量或函数只能在声明它的范围内被引用。<br/>作用域严格地相互嵌套，这也意味着可以从内部作用域引用变量或函数。<br/>最重要的是，作用域是在<em class="mj">编译时确定的，</em>因此作用域的结构在执行过程中不会改变。<br/>JavaScript中最外层的作用域被称为<em class="mj">全局作用域</em>，并且引用了<em class="mj">窗口</em>对象。</p><p id="1cc3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用动态作用域，我们可以引用的声明变量或函数的作用域是动态变化的。</p><p id="c911" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着用这个伪JavaScript做一个例子，假设它现在使用了<em class="mj">动态范围</em></p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="0db1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<code class="fe kw kx ky kz b">dynamicBuilding()</code>我们试图引用一个变量，它既没有在自己的作用域中声明，也没有在包装它的作用域中声明；全球范围。<br/>当我们刚刚调用这个函数的时候，这会返回<code class="fe kw kx ky kz b">undefined</code>或者抛出一个引用错误。但是，如果我们在调用函数的同一个作用域中声明变量，突然之间我们就不会再遇到引用错误了。<br/>这里关键的一点是，<code class="fe kw kx ky kz b">dynamicBuilding()</code>的行为因调用它的位置而异。<br/>调用函数的作用域——或<em class="mj">执行上下文</em> —称为函数的<em class="mj">调用点</em>。</p><p id="0a3c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mj"> NB。上面的例子是伪JavaScript。这不是JavaScript的工作方式，也不会像示例中那样执行。</em></p><h1 id="edfa" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">“这”的4种绑定方式</h1><p id="7546" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在这一点上，你可能想知道为什么我在谈论JavaScript中的作用域，而这篇文章是关于<code class="fe kw kx ky kz b">this</code>关键字的。<br/>原因是，JavaScript中的<em class="mj">词法作用域</em>原则——我们大多数人都习惯了，并且觉得非常自然——是我们在谈到<code class="fe kw kx ky kz b">this</code>时感到困惑的主要原因。</p><p id="cc19" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript不使用<em class="mj">动态范围，</em>并且它从来没有使用过，但是考虑到JavaScript使用绑定的方式，我们实际上已经非常接近于使用动态范围了。</p><p id="f446" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">于是就来了:<br/>用JavaScript，<code class="fe kw kx ky kz b">this</code>是由引用<code class="fe kw kx ky kz b">this</code>的函数的<em class="mj">调用点</em>决定的。<br/>也就是说，当<code class="fe kw kx ky kz b">this</code>在一个函数中使用时，<code class="fe kw kx ky kz b">this</code>将是对<em class="mj">执行上下文</em>的引用，该函数从该上下文执行。</p><p id="5fa7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中有4种不同的方式绑定<code class="fe kw kx ky kz b">this</code>,它们的行为都不同:</p><ul class=""><li id="3710" class="ml mm jb ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><strong class="ka jc"/><code class="fe kw kx ky kz b"><strong class="ka jc">new</strong></code><strong class="ka jc">关键词</strong></li><li id="3b95" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><strong class="ka jc">显式绑定</strong></li><li id="969b" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><strong class="ka jc">隐式绑定</strong></li><li id="94df" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><strong class="ka jc">默认绑定</strong></li></ul><p id="9703" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也意味着，在任何给定的环境中，这是你将自问的4个关键问题，以确定<code class="fe kw kx ky kz b">this</code>指向什么。让我们一个接一个地过一遍。</p><h1 id="db5b" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">“新”关键字</h1><p id="061a" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">当在函数中使用<code class="fe kw kx ky kz b">this</code>时，你需要问自己的第一件事是在调用函数时是否使用了<code class="fe kw kx ky kz b">new</code>关键字。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="0e9d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当应用<code class="fe kw kx ky kz b">new</code>关键字时，将创建一个用户自定义对象的实例，并且<code class="fe kw kx ky kz b">this</code>将被绑定到该对象。<br/>关键字<code class="fe kw kx ky kz b">new</code>将做<a class="ae mz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener ugc nofollow" target="_blank">以下4件事</a>:</p><ol class=""><li id="9c0e" class="ml mm jb ka b kb kc kf kg kj mn kn mo kr mp kv na mr ms mt bi translated">创建一个空白的普通JavaScript对象。</li><li id="7e1b" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv na mr ms mt bi translated">将此对象链接到另一个对象。</li><li id="4f76" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv na mr ms mt bi translated">将从<em class="mj">步骤1 </em>中新创建的对象作为<code class="fe kw kx ky kz b">this</code>上下文进行传递。</li><li id="e3e0" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv na mr ms mt bi translated">如果函数不返回自己的对象，则返回<code class="fe kw kx ky kz b">this</code>。</li></ol><p id="c5f2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们在上面的例子中看到的，<code class="fe kw kx ky kz b">this</code>将是一个对象的引用，该对象将通过用<code class="fe kw kx ky kz b">new</code>关键字调用<code class="fe kw kx ky kz b">thisGuard()</code>函数来创建。</p><p id="6223" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ES6中，<em class="mj">类</em>被引入。澄清一下:在JavaScript中，没有类这样的东西——这只不过是语法上的糖，做我们上面看到的事情。因此，<code class="fe kw kx ky kz b">this</code>的绑定方式与类完全一样。<br/>下面是上面代码片段的等效内容:</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="0004" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">显式绑定</h1><p id="3c31" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">如果你没有应用<code class="fe kw kx ky kz b">new</code>关键字，那么接下来你要问自己的是你是否使用了<em class="mj">显式绑定。<br/> </em>有几种方法可以调用一个函数，并明确定义<code class="fe kw kx ky kz b">this</code>在该函数中使用时应该引用什么。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="9950" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们通过调用<code class="fe kw kx ky kz b">thisGuard()</code>函数来使用<em class="mj">显式绑定</em>，因此使用了属于<code class="fe kw kx ky kz b">Function.prototype.</code>的<code class="fe kw kx ky kz b">apply()</code>方法</p><p id="fc94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是在调用函数，并把一个对象作为参数传入。从被调用的函数中，<code class="fe kw kx ky kz b">this</code>将被绑定到作为参数传递的对象。这是确保<code class="fe kw kx ky kz b">this</code>可预测地绑定到我们想要的对象的有效方法。</p><p id="82fc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常相似的方法<code class="fe kw kx ky kz b">call()</code>会导致相同的行为。<br/><code class="fe kw kx ky kz b">apply()</code>和<code class="fe kw kx ky kz b">call()</code>的主要区别在于，如果我们想给函数传入额外的参数，我们可以用两种不同的方式来实现:<br/>使用<code class="fe kw kx ky kz b">apply()</code>时，第二个参数将是额外参数的列表，而使用<code class="fe kw kx ky kz b">call()</code>时，额外参数将像我们通常所做的那样列出。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="b038" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mj">显式绑定</em>的另一种情况是通过使用方法<code class="fe kw kx ky kz b">bind()</code>，这是在ES5中引入的。我们一会儿会回到这个例子。</p><h1 id="cee6" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">隐式结合</h1><p id="547a" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">如果您在调用函数时没有使用<code class="fe kw kx ky kz b">new</code>关键字，也没有应用<em class="mj">显式绑定，那么</em>接下来要查看的是<code class="fe kw kx ky kz b">this</code>是否被隐式绑定。</p><p id="05c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当引用<code class="fe kw kx ky kz b">this</code>的函数是对象的方法时，会发生隐式绑定。</p><p id="8cc0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一下这篇文章的第一个例子，但是没有<code class="fe kw kx ky kz b">setTimeout()</code></p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="68da" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，<code class="fe kw kx ky kz b">identify()</code>是<code class="fe kw kx ky kz b">thisGuard</code>对象的方法，<code class="fe kw kx ky kz b">this</code>将被隐式绑定到该对象。</p><p id="ff3b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是<em class="mj">显式绑定</em>如何优先于<em class="mj">隐式绑定</em>，以及<em class="mj">硬绑定</em>如何优先于<em class="mj">显式绑定</em>。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="a1ab" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">默认绑定</h1><p id="afc5" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">最后，如果以上情况都不存在，您可以期望<code class="fe kw kx ky kz b">this</code>默认绑定到全局范围。也就是说，当引用<code class="fe kw kx ky kz b">this</code>时，你可以期待对<code class="fe kw kx ky kz b">window</code>对象的引用。<br/>如果你正在使用<em class="mj">严格模式</em>，你可以预期<code class="fe kw kx ky kz b">this</code>是未定义的。</p><p id="838a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们回顾一下本文的第一个例子，您可能会明白为什么它打印的是<code class="fe kw kx ky kz b">undefined</code>，而不是预期的<code class="fe kw kx ky kz b">firstName</code>和<code class="fe kw kx ky kz b">rank</code></p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="d787" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们将函数作为参数传递给<code class="fe kw kx ky kz b">setTimeout</code>时，我们不是调用函数，而是传递一个引用。<br/>一秒钟后，该函数将作为回调函数被调用，执行上下文将是全局范围，因此<code class="fe kw kx ky kz b">this</code>不会像我们预期的那样隐式绑定到<code class="fe kw kx ky kz b">thisGuard</code>。</p><p id="b12a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了关于<code class="fe kw kx ky kz b">this</code>在JavaScript中如何工作的知识，我们知道可以通过将<code class="fe kw kx ky kz b">this</code>硬绑定到<code class="fe kw kx ky kz b">thisGuard</code>对象来轻松解决这个问题。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="e1cb" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">箭头函数表达式</h1><p id="7ce5" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">最后，我想提一下<em class="mj">箭头函数表达式的使用。<br/> </em>在ES6中，引入了箭头功能。<br/>与常规函数表达式相比，使用箭头函数表达式的一个主要优点是<code class="fe kw kx ky kz b">this</code>，从箭头函数内部，将总是指向封闭的词法上下文。</p><p id="ee68" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个正则函数表达式的例子</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="a2aa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里看到对<code class="fe kw kx ky kz b">regularFunction()</code>的第一次调用如何使用<em class="mj">默认绑定</em>，第二次调用如何使用<em class="mj">隐式绑定</em>。<br/>结果是<code class="fe kw kx ky kz b">this</code>根据<em class="mj">调用站点</em>指向两个不同的上下文，正如我们所料。</p><p id="1441" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想确定<code class="fe kw kx ky kz b">this</code>将被<em class="mj">词汇绑定</em>，而不是<em class="mj">动态绑定</em>，我们可以使用一个箭头函数。</p><figure class="la lb lc ld gt is"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="b85a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在函数的<em class="mj">调用位置</em>不再影响<code class="fe kw kx ky kz b">this</code>在<code class="fe kw kx ky kz b">arrowFunction()</code>中使用时将要引用的内容。</p><h1 id="f7fb" class="lg lh jb bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="1f7b" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated"><code class="fe kw kx ky kz b">this</code>的值让我们困惑的主要原因是，JavaScript中的引用通常遵循<em class="mj">词法范围模型</em>，而<code class="fe kw kx ky kz b">this</code>是对调用函数的<em class="mj">执行上下文</em>的引用。从而<code class="fe kw kx ky kz b">this</code>被动态<em class="mj">确定，打破了JavaScript中引用的一般概念。</em></p><p id="cdff" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们总是可以通过查看<code class="fe kw kx ky kz b">this</code>可以绑定的4种方式来确定<code class="fe kw kx ky kz b">this</code>指向什么。<br/>或者，我们可以使用箭头函数来确保<code class="fe kw kx ky kz b">this</code>不会被动态绑定。</p><p id="2c33" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想了解更多关于JavaScript的知识，我建议你也浏览一下我的另一篇文章，<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/javascript-wizard-tips-and-tricks-1b91025a0d62"> <em class="mj"> JavaScript向导:技巧&amp;窍门</em> </a></p><p id="5950" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">就是这样！如果您有任何问题或反馈，请随时在下面评论。如果你喜欢这篇文章，请鼓掌👏扣几下吧！<br/>你也可以在</strong><a class="ae mz" href="https://twitter.com/silindsoftware" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">Twitter</strong></a><strong class="ka jc">上找到我，我会在那里发布更多类似的内容。</strong></p></div></div>    
</body>
</html>