<html>
<head>
<title>How I tried to validate React forms (with hooks)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何尝试验证React表单(用钩子)</h1>
<blockquote>原文：<a href="https://itnext.io/how-i-tried-to-validate-react-forms-with-hooks-31634fc5385b?source=collection_archive---------2-----------------------#2019-04-19">https://itnext.io/how-i-tried-to-validate-react-forms-with-hooks-31634fc5385b?source=collection_archive---------2-----------------------#2019-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a4cac85f28ca925cfc605f7cba2fbbc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNa3W12NDtGqlGm6yUGHXw.png"/></div></div></figure><p id="ccc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自Vue.js的背景，转变为React对我来说相当不愉快。我发现很难实现的许多事情之一是表单验证和数据绑定。如果你了解Vue，你就会知道它有一个神奇的东西叫做<strong class="kd iu"> v型</strong>。您还可以创建定制的v-model绑定，并创建自我验证的组件。如果你不知道Vue，但仍然代码反应，无论如何。这不是一篇Vue.js的文章，我保证。我会试试看。</p><p id="e318" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下班后的时间对我来说也差不多——谷歌“如何验证React表单”、“如何使用钩子进行表单验证”等等。我真的想找到或发明一种既节省时间又能提供高质量结果的方法。我的动机是在我的工作场所创建具有许多表单的ui，所以我想花更少的时间来实现数据绑定和表单验证，因为这已经变得相当耗时耗力。</p><p id="42ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不断地创建许多可配置的表单和输入组件，并且总是让自己不得不为自组装表单编写巨大的配置。他们确实工作了，但是他们没有给我提供多少布局配置选项——例如，如果我想对项目使用grid，就需要我编写额外的配置并让组件对它做出反应。我无法想象让我的同事用它工作，我也不想这样做。我想找到一种不那么笨拙的方法来验证我的表单。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0e92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">钩子。</p><p id="ca6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个词，是的。钩子。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="e574" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我受到了丹·阿布拉莫夫的输入挂钩的启发，它看起来应该是这样的(抱歉，我是这么想的):</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="858f" class="lp lq it ll b gy lr ls l lt lu"><strong class="ll iu">export function </strong><em class="lv">useInput</em>(initialValue = '') {<br/>  <strong class="ll iu">const </strong>[value, setValue] = <em class="lv">useState</em>(initialValue);<br/>  <strong class="ll iu">const </strong><em class="lv">onChange </em>= e =&gt; setValue(e.<strong class="ll iu">target</strong>.<strong class="ll iu">value</strong>);<br/>  <strong class="ll iu">return </strong>{ <em class="lv">onChange</em>, value }<br/>}</span></pre><p id="7d59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个开始。它是一个钩子，你可以像这样调用一个输入</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="abd3" class="lp lq it ll b gy lr ls l lt lu">&lt;<strong class="ll iu">input type="text" </strong>{...<em class="lv">useInput</em>(<strong class="ll iu">'initValue'</strong>)} /&gt;</span></pre><p id="7e07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将控制它的值——我们从钩子返回的是一个<em class="lv"> onChange </em>函数和输入的<em class="lv">值</em>，所以假设它将自我更新。您可以在其中添加一些错误处理(绑定一个错误类——例如，如果您使用的是bootstrap CSS，那么<strong class="kd iu">是无效的</strong>)),但仅此而已。你仍然没有双向绑定的形式，你只有一种自我控制的输入。不过，这是个开始。</p><h1 id="824f" class="lw lq it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">那么我创造了什么？</h1><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2c066ccf74a8428d80886ce49337a10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*mPUc2fU1VPbW6gjbw1DjeQ.gif"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><a class="ae my" href="https://media.giphy.com/media/12NUbkX6p4xOO4/giphy.gif" rel="noopener ugc nofollow" target="_blank">https://media.giphy.com/media/12NUbkX6p4xOO4/giphy.gif</a></figcaption></figure><p id="d02f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用钩子和验证函数创建了一个文件，看起来可能不太好，但它很好地满足了我的需要。我还在继续重构它。有利的一面是——我只需要编写一次代码，我将用它来验证我的表单，直到我找到/创造出更好的东西。它在组件中是这样使用的:</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><MaterialForm/>带验证的组件</figcaption></figure><p id="1b32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个具有两个(材质UI)字段和一个按钮的组件。如果字段无效，该按钮将被禁用。在我看来，这是一个非常短小精悍的代码。如果我们从数据绑定和验证的角度来说，这是一个开发者的梦想。</p><h2 id="dcd7" class="lp lq it bd lx nb nc dn mb nd ne dp mf km nf ng mj kq nh ni mn ku nj nk mr nl bi translated">那里到底发生了什么？</h2><p id="a579" class="pw-post-body-paragraph kb kc it kd b ke nm kg kh ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky im bi translated">我们首先调用<em class="lv"> useForm </em>钩子并传入我们的默认<em class="lv">值</em>。<em class="lv">使用形式</em>是很多所说的魔法发生的地方。它还返回一些东西— <em class="lv">值</em>，<em class="lv"> useInput </em> hook和<em class="lv"> isValid </em>布尔属性。(它返回更多，但我现在不会让你困惑，因为我们将只使用这3个。)</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="13db" class="lp lq it ll b gy lr ls l lt lu"><strong class="ll iu">const </strong>{ values, <em class="lv">useInput</em>, <strong class="ll iu">isValid </strong>} = <em class="lv">useForm</em>({<br/>  <strong class="ll iu">username</strong>: <strong class="ll iu">''</strong>,<br/>  <strong class="ll iu">email</strong>: <strong class="ll iu">''<br/></strong>});</span></pre><ul class=""><li id="aeab" class="nr ns it kd b ke kf ki kj km nt kq nu ku nv ky nw nx ny nz bi translated">值-值对象实时变化。这意味着你不需要任何<em class="lv"> onChange </em>和<em class="lv"> setState </em>处理程序，这一切都发生在我们的钩子中，它们只负责让你得到你唯一感兴趣的东西——你的价值捆绑在一起。</li><li id="562a" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">use input——一个你在输入中使用的钩子，就像我之前展示的那样。第一个参数是输入的<strong class="kd iu">名称</strong>，这也是将在<em class="lv">值</em>对象中访问的属性。第二个属性是验证，可以作为字符串或对象传递。</li></ul><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="7b0d" class="lp lq it ll b gy lr ls l lt lu">&lt;<strong class="ll iu">TextField<br/>  label="Username *"<br/>  </strong>{...<em class="lv">useInput</em>(<strong class="ll iu">'username'</strong>, <strong class="ll iu">'isRequired'</strong>)}<br/>/&gt;</span></pre><ul class=""><li id="18b0" class="nr ns it kd b ke kf ki kj km nt kq nu ku nv ky nw nx ny nz bi translated">isValid布尔验证结果。我用它来禁用提交按钮，这样用户就可以看到他们无法提交表单。</li></ul><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="f93d" class="lp lq it ll b gy lr ls l lt lu">&lt;<strong class="ll iu">Button type="submit" disabled=</strong>{!<strong class="ll iu">isValid</strong>}&gt;<br/>  Submit<br/>&lt;/<strong class="ll iu">Button</strong>&gt;</span></pre><p id="c9c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你在做简单的表格，这就是全部了。</p><p id="9d18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您对代码感兴趣，请继续阅读。如果没有，您可以滚动到文章底部预览现场演示。</p><h1 id="0be9" class="lw lq it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">useForm(默认值，无效)</h1><p id="967a" class="pw-post-body-paragraph kb kc it kd b ke nm kg kh ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky im bi translated">所以我告诉你我们正在传递默认值给<em class="lv">用户表单</em>钩子。我们还可以传递第二个属性——一个对象——它将是我们的错误属性，在输入无效的情况下附加到输入中。当使用Material UI组件时，我们感兴趣的是像这样将<em class="lv"> error="true" </em>添加到我们的组件中</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="1ad6" class="lp lq it ll b gy lr ls l lt lu">&lt;TextField error/&gt;</span></pre><p id="2d8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果我们使用Bootstrap、布尔玛、定制CSS或其他UI框架呢？我们可以用一种简单的方式传递我们的选择:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="30f4" class="lp lq it ll b gy lr ls l lt lu"><strong class="ll iu">const</strong> { values } = <em class="lv">useForm</em>(<br/>  { name: '' },<br/>  { className: 'is-invalid' }<br/>)</span></pre><p id="138f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以选择您需要的任何无效属性，或者组合多个值。</p><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a6ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我的整个<em class="lv">使用表单</em>代码。可以看到，有<strong class="kd iu"><em class="lv">values</em></strong><em class="lv"/>和<em class="lv"/><strong class="kd iu"><em class="lv">setValues</em></strong><em class="lv"/>变量(用于存储和更改值)<strong class="kd iu"> <em class="lv"> formErrors </em> </strong>和<strong class="kd iu"><em class="lv">setformer rors</em></strong>变量(用于存储和更改错误)以及一个<strong class="kd iu"> <em class="lv">挂载的</em> </strong>布尔</p><p id="5804" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个自定义<em class="lv">使用的表单</em>钩子的大部分功能是</p><ul class=""><li id="bb36" class="nr ns it kd b ke kf ki kj km nt kq nu ku nv ky nw nx ny nz bi translated">它控制安装状态(我添加这个是因为按钮最初在一毫秒内有效，我想避免它马上闪烁到无效——这会分散注意力)</li><li id="b38c" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated"><strong class="kd iu">它创建另一个(<em class="lv"> useInput </em>)钩子，并在</strong>中传递它的属性(比如formHandler或errorHandler，这样子输入可以重写值，或者我们的错误输入属性)</li><li id="48ee" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">它返回<em class="lv">值</em>，一个手动<em class="lv">设置值</em>的函数(如果你需要在提交后重置一个表单)<em class="lv">使用输入，错误</em>(一个包含字段及其第<strong class="kd iu">第</strong>未满足规则的对象)和<em class="lv">是一个有效的</em>布尔变量，它需要安装表单并且错误为空，以便<em class="lv">为真</em>。</li></ul><h1 id="6bcb" class="lw lq it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">使用输入(名称，验证)</h1><p id="d16f" class="pw-post-body-paragraph kb kc it kd b ke nm kg kh ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky im bi translated">因此，<em class="lv"> useForm </em>让我们可以访问这个<em class="lv"> useInput </em>钩子，它控制我们的值、错误并接受输入名称和验证标准。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/dad0197ffff7da07e77103fd1beb0bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*iLkeLwJ5bXg5cpz_mghp7Q.jpeg"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><a class="ae my" href="https://imgflip.com/memegenerator/Yo-Dawg-Heard-You" rel="noopener ugc nofollow" target="_blank">https://imgflip.com/memegenerator/Yo-Dawg-Heard-You</a></figcaption></figure><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4c07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里处理很多事情。我们想知道输入是否被聚焦、改变、模糊等——以控制值和错误显示。例如，如果您还没有触摸输入，我们不希望它发出红光。一些代码只是设置像<em class="lv"> handleBlur </em>或<em class="lv"> handleFocus </em>这样的值，我不会深入讨论这些。</p><p id="f852" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在挂载时验证输入，因为我们需要知道是否需要禁用按钮。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="71ab" class="lp lq it ll b gy lr ls l lt lu"><em class="lv">useEffect</em>(() =&gt; {<br/>  <em class="lv">handleValidation</em>();<br/>}, [handleValidation, name]);</span></pre><p id="1c3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也在每次改变值的时候验证它。<code class="fe og oh oi ll b"><strong class="kd iu">handleValidation()</strong></code> <strong class="kd iu">在每一次值改变</strong>时被重新创建，所以<code class="fe og oh oi ll b">useEffect</code>依赖数组会在我们需要的时候照顾我们的函数运行。</p><p id="540d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您在组件的某个地方使用来自<em class="lv"> useForm </em>的<em class="lv"> setValues </em>，我们还需要注意我们自身输入的外部变化。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="f0d1" class="lp lq it ll b gy lr ls l lt lu"><em class="lv">useEffect</em>(() =&gt; {<br/>  if (value !== formValue) {<br/>    <em class="lv">setValue</em>(formValue);<br/>    <em class="lv">setIsTouched</em>(false);<br/>    <em class="lv">setIsFocused</em>(false);<br/>  }<br/>}, [formValue, value, setValue, setIsFocused, setIsTouched]);</span></pre><p id="5da9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这会触发值更改并调用验证。</p><p id="1e99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有改变父对象的<em class="lv">值——handle change</em>期望获得一个事件(或任何具有目标:{ value }属性的对象),并调用父对象的函数<em class="lv"> setFormData </em>来更新整个对象。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="bc82" class="lp lq it ll b gy lr ls l lt lu"><strong class="ll iu">const</strong> handleChange = <em class="lv">useCallback</em>(({ target }) =&gt; {<br/>  <strong class="ll iu">const</strong> { value, checked, type } = target;<br/>  <strong class="ll iu">const</strong> newValue = type === 'checkbox' ? checked : value;</span><span id="55d4" class="lp lq it ll b gy oj ls l lt lu">  // using dot helps us change nested values</span><span id="7553" class="lp lq it ll b gy oj ls l lt lu">  <strong class="ll iu">let</strong> data;<br/>  <strong class="ll iu">const</strong> isNested = name.includes('.');<br/>  if (isNested) {<br/>    dot.override = true;<br/>    data = dot.<em class="lv">str</em>(name, newValue, { ...formData });<br/>  }<br/>  else data = { ...formData, [name]: newValue };</span><span id="1487" class="lp lq it ll b gy oj ls l lt lu">  <em class="lv">setValue</em>(newValue);<br/>  <em class="lv">setFormData</em>(data);<br/>}, [setValue, formData, setFormData, name]);</span></pre><p id="384a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">更新:验证也可以使用<em class="lv">点</em>库来处理嵌套的名称值。如果您对更多感兴趣，可以在本文末尾看到演示应用程序。是这样用的:</strong></p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="9514" class="lp lq it ll b gy lr ls l lt lu">&lt;input {...useInput('<strong class="ll iu">member.username</strong>', 'isRequired')}&gt;</span></pre><p id="024a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">验证本身被外包到我的<em class="lv"> validate </em>函数中，该函数要么返回第一个未满足的规则，要么返回null。如果我们有一个未满足的规则，我们将输入的<em class="lv">名称</em>和规则<em class="lv"> </em>添加到我们的错误对象中，该对象在<em class="lv"> useForm </em>钩子中。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="b619" class="lp lq it ll b gy lr ls l lt lu"><strong class="ll iu">const</strong> handleValidation = <em class="lv">useCallback</em>(() =&gt; {<br/>  <strong class="ll iu">const</strong> isValid = <em class="lv">validate</em>(value, validationRules);<br/>  <em class="lv">setIsValid</em>(isValid);<br/>  <em class="lv">handleError</em>(name, isValid);<br/>}, [setIsValid, validationRules, name, value, handleError]);</span></pre><h1 id="d8e1" class="lw lq it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">验证(值，验证)</h1><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="5167" class="lp lq it ll b gy lr ls l lt lu"><strong class="ll iu">export function </strong><em class="lv">validate</em>(value, validation) {<br/>  <strong class="ll iu">const </strong>fieldsToValidate = {};<br/>  <strong class="ll iu">let </strong>trimmedValidation;<br/><br/>  <strong class="ll iu">switch </strong>(<strong class="ll iu">typeof </strong>validation) {<br/>    <strong class="ll iu">case 'object'</strong>:<br/>      <strong class="ll iu"><em class="lv">Object</em></strong>.keys(validation).forEach(property =&gt; {<br/>        fieldsToValidate[property] = validation[property]<br/>      });<br/>      <strong class="ll iu">break</strong>;<br/><br/>    <strong class="ll iu">case 'string'</strong>:<br/>    <strong class="ll iu">default</strong>:<br/>      <strong class="ll iu">if </strong>(!validation.<strong class="ll iu">length</strong>) <strong class="ll iu">return null</strong>;<br/><br/>      trimmedValidation = validation.replace(/ /g, <strong class="ll iu">''</strong>);<br/>      trimmedValidation.split(<strong class="ll iu">','</strong>).forEach(fieldName =&gt; {<br/>        fieldsToValidate[fieldName.trim()] = <strong class="ll iu">true</strong>;<br/>      });<br/>  }<br/><br/>  <em class="lv">// check whether we do need to validate at all<br/>  </em><strong class="ll iu">const </strong>isRequired = fieldsToValidate.<strong class="ll iu">isRequired </strong>|| fieldsToValidate.<strong class="ll iu">isEmpty </strong>=== <strong class="ll iu">false</strong>;<br/>  <strong class="ll iu">if </strong>(!value &amp;&amp; !isRequired) <strong class="ll iu">return null</strong>;<br/><br/>  <strong class="ll iu">let </strong>unmetValidationRule = <strong class="ll iu">null</strong>;<br/>  <strong class="ll iu">let </strong>isValid = <strong class="ll iu">true</strong>;<br/><br/>  <strong class="ll iu"><em class="lv">Object</em></strong>.keys(fieldsToValidate).forEach(rule =&gt; {<br/>    <em class="lv">// don't proceed if we're already invalid<br/>    </em><strong class="ll iu">if </strong>(!isValid) <strong class="ll iu">return</strong>;<br/><br/>    <strong class="ll iu">const </strong>options = fieldsToValidate[rule];<br/><br/>    <strong class="ll iu">switch </strong>(rule) {<br/>      <strong class="ll iu">case 'isRequired'</strong>:<br/>        <strong class="ll iu">if </strong>(!value) isValid = <strong class="ll iu">false</strong>;<br/>        <strong class="ll iu">break</strong>;<br/><br/>      <strong class="ll iu">default</strong>:<br/>        <strong class="ll iu">switch </strong>(options) {<br/>          <strong class="ll iu">case true</strong>:<br/>          <strong class="ll iu">case null</strong>:<br/>            isValid = validator[rule](value);<br/>            <strong class="ll iu">break</strong>;<br/>          <strong class="ll iu">case false</strong>:<br/>            isValid = !validator[rule](value);<br/>            <strong class="ll iu">break</strong>;<br/>          <strong class="ll iu">default</strong>:<br/>            isValid = validator[rule](value, options);<br/>        }<br/>    }<br/><br/>    <strong class="ll iu">if </strong>(!isValid) unmetValidationRule = rule;<br/>  });<br/><br/>  <strong class="ll iu">return </strong>unmetValidationRule || <strong class="ll iu">null</strong>;<br/>}</span></pre><p id="46b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以基本上，如果我得到一个字符串，我把它解析成一个对象，如果我得到一个对象，我只是移动值。我使用的是<em class="lv">fields validate</em>变量，填充后看起来像这样</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="04f4" class="lp lq it ll b gy lr ls l lt lu">{<br/>  isRequired: true,<br/>  isLength: { min: 6 }<br/>}</span></pre><p id="da1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设它属于如下所示的输入(如果需要更复杂的规则，可以传递一个验证对象)</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="98c4" class="lp lq it ll b gy lr ls l lt lu">&lt;input {...useInput('username', {<br/>  isRequired: true,<br/>  isLength: { min: 6 }<br/>})}&gt;</span></pre><p id="15c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以看到我创建了我的自定义<em class="lv">是必需的</em>规则。如果我想通过字符串验证，我觉得用起来很舒服。我用的是<a class="ae my" href="https://www.npmjs.com/package/validator" rel="noopener ugc nofollow" target="_blank"> <em class="lv">验证器</em> </a> <em class="lv"> </em> npm包，里面有很多特性供你选择。如果没有值，并且规则中说它不是必需的，我也不会验证字段(通过使用' isRequired': true或验证器的' isEmpty': false)。然后，我将返回未满足的规则或空值。子对象从错误对象中添加或移除其错误，并且..就是这样！</p><h2 id="4085" class="lp lq it bd lx nb nc dn mb nd ne dp mf km nf ng mj kq nh ni mn ku nj nk mr nl bi translated">另一个表格示例</h2><figure class="lg lh li lj gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a2c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个有自定义的错误属性，使用<em class="lv"> isEmail </em> validator的方法和<em class="lv"> isInt。</em>你可以看到你可以传递<a class="ae my" href="https://www.npmjs.com/package/validator" rel="noopener ugc nofollow" target="_blank">验证器</a>接受的方法。由于传递了选项/参数，它可能无法与它们的所有方法一起工作。增强这段代码是可能的，如果你喜欢，你肯定可以这样做。现在我需要一些小而简单的东西。</p><h2 id="20f3" class="lp lq it bd lx nb nc dn mb nd ne dp mf km nf ng mj kq nh ni mn ku nj nk mr nl bi translated">代码是开源的</h2><p id="eecd" class="pw-post-body-paragraph kb kc it kd b ke nm kg kh ki nn kk kl km no ko kp kq np ks kt ku nq kw kx ky im bi translated">如果你想使用这个表单验证，它存在于我在GitHub—<a class="ae my" href="https://github.com/DJanoskova/React-validator-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/DJanoskova/React-validator-demo</a>的库中。您不必将本文中的代码拼凑在一起。</p><p id="936a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有更多的例子和一个位于<a class="ae my" href="https://react-form-hook-validator.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://react-form-hook-validator.herokuapp.com/</a>的现场演示。</p><p id="2f91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读，验证愉快！</p></div></div>    
</body>
</html>