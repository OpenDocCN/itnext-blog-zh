<html>
<head>
<title>Better Component Composition in VueJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VueJS中更好的组件组合</h1>
<blockquote>原文：<a href="https://itnext.io/better-composition-in-vue-fd35b9fe9c79?source=collection_archive---------3-----------------------#2020-09-02">https://itnext.io/better-composition-in-vue-fd35b9fe9c79?source=collection_archive---------3-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1bc0b09074bce0e316d8aa1b495d0720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*janl0y40OKFy4aID"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@uniqsurface?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> uniqsurface </a>拍摄的照片</figcaption></figure><p id="10ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le"> VueJS </em>中，组合组件和重用逻辑的方法很少。在本文中，我将演示一种在vue js(2 . 0)中提高合成的方法。*和3。*).</p><p id="db67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我真的很喜欢最近关于<em class="le">组合API </em>的提议，但我认为那可以是更广泛观点的一部分。</p><p id="de6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面，您可以找到一个实现一般用例的组件(从远程端点获取简单数据并显示不同的转换和数据)，尽管当相同的逻辑应用于其他位置或组件时，大多数逻辑总是与模板、数据和其他变量一起复制。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="939e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何重构这个组件并改进它？让我们一步一步来，使这个组件更可读和可重用。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h2 id="6e10" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">Vue组合API</h2><p id="a127" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">多亏了新的Vue Composition API，我们可以取出一些逻辑来重用它，而不会失去Vue组件提供的反应能力或特性。</p><p id="5d99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法有助于组织代码，使组件更具可读性，并有助于降低整体复杂性。作为一个建议，我相信这应该是重构庞大、复杂和混乱的组件时要做的第一件事。</p><p id="460e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将提取与数据获取和相关变量相关的部分(<em class="le">加载，错误</em>等…)，但我不想讨论什么是Composition API，有什么特性和优缺点。</p><p id="0e30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个简单的函数，它为获取反应变量提供了必要的东西:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="0304" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建的函数现在返回一组反应性变量(<em class="le"> loading、error、data </em>和<em class="le"> hasData </em>)，这些变量可以由我们的组件和一个异步函数使用，以便执行数据获取(<em class="le"> fetchData </em>，它将改变返回的反应性变量)。</p><p id="9240" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且，让我们重构我们的组件来使用组合API:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="b925" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所注意到的，我们的组件还包含setup方法，该方法调用<em class="le"> useFetchData </em>函数，同时析构返回的变量/函数并将它们返回给组件实例。</p><p id="f2f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我在挂载的生命周期钩子中使用了<em class="le"> fetchData </em>函数，但是它可以在任何你想要的地方被调用。每当调用的函数对某个东西进行评估/更改时，结果都会反映在我们的组件中，因为它们是反应性属性。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h2 id="b9fa" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">JSX和TSX</h2><p id="cb55" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">现在让我们假设我们想要将数据传递给一个内部组件。使用VueJS有多种方法可以做到这一点，但是我想重新构建一下，使用<em class="le"> TSX </em>(或者<em class="le"> JSX </em>，如果你喜欢的话:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="714c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道这可能看起来很像React，但我相信这为以更好的方式创作打开了许多大门。</p><p id="0679" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其实理解起来挺简单的，和模板是一回事，但是我们把HTML部分移到了Render函数里。</p><p id="d412" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还没有完成将它传递给内部组件的任务，我们实际上可以改进它，如下面这段代码，它将整个东西导出为一个我们可以重用的函数:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="1496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们把它带到了下一个层次，去掉<em class="le"> SFC </em>(单个文件组件文件)我们实际上可以提高合成。</p><p id="e7f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个阶段，我们使用defineComponent来创建一个使用组合API的组件，并依靠JSX/TSX来避免模板部分。这种方法的美妙之处在于，我们可以将组件视为一个函数，并依赖于函数式编程范式的原则(例如，一级函数、纯函数等)</p><p id="f114" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，Render函数也包含一个包含数据的div，但是想象一下将一个组件作为导出函数的参数传递，并在返回的JSX/TSX中使用它(将响应/数据作为道具传递给请求的组件)。</p><p id="3cd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可能看起来像这样:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="96fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们期待一个组件作为参数，并在Render函数的返回值中使用它。</p><p id="815a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以做得更多。</p><p id="088e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，我们还可以期望将<em class="le"> useFetchData </em>函数作为导出函数中的一个参数。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="cb8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些变化，在组件之上，作为一个可接受的参数，我们期待一个类型为<em class="le"> FetchData </em>的<em class="le">函数</em>，它返回一组期望的变量/函数/计算值，以便在我们的组件中使用。</p><p id="927f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于取代继承/扩展并依赖于更具功能性的方法非常有用。因此，我们实际上可以传入所需的组件和函数，而不是扩展已经存在的组件和覆盖组件的函数。Typescript在这里只帮助打字和推理，所以Javascript也足够了。</p><p id="3899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想使用它，它可能看起来像下面这样:</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="e4a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们把上面的最后一个例子叫做<em class="le"> withLoaderAndFetcher </em>，我们用它来传递3个不同的组件和3个不同的函数(期望在装饰器中实现想要的东西)。</p><p id="ce32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这甚至可以进一步推进，但我想展示如何可能达到这种状态，并增加功能组合的解决方案的数量。这是示例代码，可能不会完美地工作，但是想法和概念是最重要的。</p><p id="d568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯:)</p></div></div>    
</body>
</html>