<html>
<head>
<title>Reviewing JavaScript’s Key Array Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回顾JavaScript的关键数组操作符</h1>
<blockquote>原文：<a href="https://itnext.io/reviewing-javascripts-key-array-operators-1b29dc74115a?source=collection_archive---------2-----------------------#2019-03-29">https://itnext.io/reviewing-javascripts-key-array-operators-1b29dc74115a?source=collection_archive---------2-----------------------#2019-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cc2e4d4aa4d112355ab415a159328c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZs2KelckktaqcMtXmeZ_Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">太阳能电池板</figcaption></figure><p id="7f7b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">因为我是一个打字脚本专家，所以这篇文章将以打字脚本为重点，但是代码通常也可以与最新版本的JavaScript兼容。</em></p><p id="aed3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">JavaScript中有很多数组操作符。可能比你想象的要多。我看了一下名单，比我想象的要多。还会经常添加新的操作符，所以熟悉一些有规律的数组操作符(或方法)可能是个好主意。</p><p id="a6cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文将回顾我所认为的核心JavaScript数组操作符。这只是我的观点，我在这里省略的一些操作符可能对一些人更有价值，但是我发现人们经常没有意识到这些数组操作符，尽管它们在功能和语义上非常强大。</p><p id="880a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我会把这些分成对我有意义的类别。然后，对于每个操作员，我将提供:</p><ul class=""><li id="fe63" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">对其目的的解释</li><li id="cf9c" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">它是否<strong class="ke ir">就地修改了数组</strong></li><li id="7b62" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">一个关于<a class="ae lb" href="https://stackblitz.com" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com</a>的工作代码示例(如果你喜欢，你可以随意摆弄！)</li></ul><p id="07ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">注意数组的索引是0，但是我将从</em> <code class="fe lq lr ls lt b"><em class="la">array[0]</em></code> <em class="la">得到的元素称为第一个元素</em><strong class="ke ir"><em class="la"/></strong><em class="la"/><code class="fe lq lr ls lt b"><em class="la">array[1]</em></code><em class="la">称为第二个元素</em>  <em class="la">。我不会引用第0个元素。</em></p><h1 id="48e4" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">循环</h1><p id="0fe6" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">对于不熟悉的人来说，迭代是移动一组项目的过程。我的<a class="ae lb" href="https://medium.com/@ExplosionPills/map-vs-for-loop-2b4ce659fb03" rel="noopener"> map vs for loop </a>文章有更多关于什么是迭代以及它如何工作的细节。出于我们的目的，这些操作符在数组的每个元素上运行回调函数或谓词。</p><p id="68d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">迭代器的谓词通常有三个参数:</p><ul class=""><li id="f743" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">当前一轮迭代的数组元素</li><li id="f248" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">此数组元素的索引</li><li id="fae7" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">您对其调用运算符的整个数组</li></ul><p id="51ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有些谓词的参数比这个多，但是不用担心。如果出现这种情况，我会具体说明。</p><h2 id="435b" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated"><code class="fe lq lr ls lt b">map</code></h2><p id="2858" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">map</code>操作符遍历一个数组，并在数组的每个元素上应用or <em class="la">投射</em>谓词，并返回一个相同长度的新数组，该数组由每个元素的谓词函数的返回值组成。</p><p id="7bb1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">map</code>返回一个<em class="la">新的</em>数组，所以不用修改原来的数组就可以得到它的结果。</p><p id="f59f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您将经常使用<code class="fe lq lr ls lt b">map</code>以某种新的格式获得原始数据的表示。例如，您可能有一个从数据库中获得的姓名列表。您可能希望以全部大写的形式显示这些名称，但是您不知道它们最初是如何存储的。您可以使用<code class="fe lq lr ls lt b">map</code>来获得每个元素的全部大写表示。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1639" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">拥有一个对象数组并希望获得每个对象的特定属性也很常见。这通常被称为“挑选”，一些库有一个<code class="fe lq lr ls lt b">pluck</code>操作符。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3847" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请记住，传递给<code class="fe lq lr ls lt b">map</code>的谓词函数可能会返回一些东西。如果你不返回任何东西，你可能想使用<code class="fe lq lr ls lt b">forEach</code>或其他东西来代替，但是请参阅我的<a class="ae lb" href="https://medium.com/@ExplosionPills/map-vs-for-loop-2b4ce659fb03" rel="noopener"> map vs. for loop </a>文章来获得更多关于避免这种事情的细节。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="1c29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，<code class="fe lq lr ls lt b">.map</code>谓词函数的第二个参数是数组元素的索引，所以会是<code class="fe lq lr ls lt b">0</code>、<code class="fe lq lr ls lt b">1</code>、<code class="fe lq lr ls lt b">2</code>等。除了可能用于日志记录之外，我真的没有使用它的例子，所以我将在这里省略它，因为它是一个可能的反模式。</p><h2 id="0ca0" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">减少</h2><p id="e77f" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">reduce</code>与<code class="fe lq lr ls lt b">map</code>相似，它遍历源数组并返回一个新值。不同之处在于<code class="fe lq lr ls lt b">reduce</code>的谓词首先接受一个额外的参数。这个论点被称为一个<em class="la">累加器</em>。以下参数与map相同:当前数组元素、索引和整个数组。这个谓词通常被称为一个<strong class="ke ir">归约器</strong>函数。Redux用户可能对这个概念比较熟悉。</p><p id="8d32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想从你的收藏中创造价值，那么<code class="fe lq lr ls lt b">reduce</code>很有用。从谓词返回累加值，该值将成为下一个谓词调用的<em class="la">累加器</em>参数。</p><p id="1c22" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">reduce</code>最简单的例子是求和。<strong class="ke ir"><code class="fe lq lr ls lt b">reduce</code>与<code class="fe lq lr ls lt b">map</code>的一个重要区别在于，对谓词的第一次调用接受第一个和第二个数组元素。在下面的示例中，谓词被调用了三次，而不是四次:</strong></p><ol class=""><li id="bedf" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz np li lj lk bi translated">acc将为1，num将为2</li><li id="495a" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">acc将是3 (1 + 2)，num将是3</li><li id="8856" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">acc将是6 (3 + 3)，num将是4</li><li id="a269" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">返回最终值10 (6 + 4)</li></ol><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="05d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下面的例子中，我们将一个起始值传递给<code class="fe lq lr ls lt b">reduce</code>。这样做时，将为每个数组元素调用谓词，累加器从提供的值开始:</p><ol class=""><li id="023e" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz np li lj lk bi translated">acc将为0(初始值)，num将为1</li><li id="f84a" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">acc将为1，num将为2</li><li id="b282" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">acc将是3 (1 + 2)，num将是3</li><li id="163e" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">acc将是6 (3 + 3)，num将是4</li><li id="2d90" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz np li lj lk bi translated">返回最终值10 (6 + 4)</li></ol><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7219" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果数组元素的类型不同于累加器的类型，您可能需要提供一个初始值。我们可以用我们的采摘例子来说明这一点:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f1ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们没有提供初始值，代码将首先尝试执行<code class="fe lq lr ls lt b">{ name: 'Andrew', stars: 50 } + 20</code>，这将导致<code class="fe lq lr ls lt b">[object Object]20</code>。</p><p id="4116" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从<code class="fe lq lr ls lt b">reduce</code>返回的结果可以是任何东西。我们经常希望它是一个物体:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f0e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也没有理由<code class="fe lq lr ls lt b">reduce</code>不能返回一个数组…即使是一个长度比原始数组长的数组。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="cb8e" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">reduceRight</h2><p id="2192" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">reduceRight</code>与<code class="fe lq lr ls lt b">reduce</code>相同，只是它从数组的末尾开始，向后迭代。这相当于反转数组，然后使用<code class="fe lq lr ls lt b">reduce</code>。</p><p id="b320" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的例子和前面的例子一样，除了多莉的宠物将首先出现在输出数组中。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="6638" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">询问</h1><p id="5ad6" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">我要介绍的下一类数组操作符是我称之为<em class="la">查询</em>操作符的。<strong class="ke ir">查询操作符也是迭代操作符</strong>，因此它们遵循相同的规则，即接受带有特定参数的谓词。查询操作符返回原始数组的一个子集<em class="la">或</em>一些基于查询内容的值。</p><p id="bba3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有的查询操作符都可以用<code class="fe lq lr ls lt b">reduce</code>来完成，但是许多操作符名称有更好的语义并且更方便。</p><h2 id="1297" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">排序</h2><p id="8212" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"> 【T9】  is a bit of an old school operator that reorders the array according to the provided predicate.  【T10】  <strong class="ke ir"> <em class="la">修改原数组</em> </strong>。如果你想得到一个新的排序后的数组而不修改原来的数组，你可以使用concat操作符，例如<code class="fe lq lr ls lt b">const sortedArray = [...originalArray].sort()</code>。这是可行的，因为即使<code class="fe lq lr ls lt b">sort</code>就地更新数组，它也返回排序后的数组。</p><p id="8442" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">sort</code>的谓词函数不同于其他操作符，因为它只接受两个参数:第一个元素用于比较，第二个元素用于比较。<code class="fe lq lr ls lt b">sort</code>使用的算法是实现相关的，因此其时间和空间复杂度无法保证。如果您计划在大型阵列上使用<code class="fe lq lr ls lt b">sort</code>，请记住这一点。</p><p id="6bfe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过这种方式，<code class="fe lq lr ls lt b">sort</code>不一定按顺序迭代每个元素，因为它将取决于排序算法。然而，它仍然必须对每个元素至少迭代一次，排序通常是一个查询操作符，所以我将它包含在这个类别中。</p><p id="6507" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">sort</code>的谓词是可选的。如果不提供，它会将元素作为字符串进行比较，并根据它们的UTF-16代码单元值对它们进行排序。<strong class="ke ir"> <em class="la">记住这一点:</em> </strong> <em class="la"> </em>默认比较的不是数值。我们可以看到这是多么棘手:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="3790" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能希望数字被排序为<code class="fe lq lr ls lt b">1, 2, 4, 10</code>等…相反，它们被视为字符串并被排序为<code class="fe lq lr ls lt b">1, 10, 2, 20</code>等…</p><p id="d571" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="la">谓词为</em> </strong> <code class="fe lq lr ls lt b"><strong class="ke ir"><em class="la">sort</em></strong></code>应返回一个数。</p><ul class=""><li id="013e" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated">如果它返回一个负数，第一个元素将被放置在比第二个元素更早的索引处。</li><li id="e76f" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">如果它返回一个正数，第二个元素将被放置在比第一个元素更早的索引处。</li><li id="49ba" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated">如果它返回0，则第一个和第二个元素保留其当前位置，但它们仍将根据其他值进行排序。</li></ul><p id="7bbf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还要注意的是<code class="fe lq lr ls lt b">sort</code> <strong class="ke ir"> <em class="la">跳过了未定义的值</em> </strong>，它们被放在数组的末尾，没有为它们调用谓词。</p><p id="01b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于排序是基于正值和负值，这使得对数字进行排序非常容易，因为您只需减去它们:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5b8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对其他值进行排序时，可以比较第一个和第二个元素。通常，如果第一个元素出现在第二个元素之前，您将返回<code class="fe lq lr ls lt b">-1</code>，如果第二个元素出现在第一个元素之前，您将返回<code class="fe lq lr ls lt b">1</code>，但是这些可以是任何负数或正数。如果值匹配，也可以返回<code class="fe lq lr ls lt b">0</code>，但是这对于排序来说并不重要，所以经常被忽略。</p><p id="8896" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以使用典型的<code class="fe lq lr ls lt b">&lt;</code>和<code class="fe lq lr ls lt b">&gt;</code>来比较日期和字符串:</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a81b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我总是忘记到底是<code class="fe lq lr ls lt b">-1</code>还是<code class="fe lq lr ls lt b">1</code>会使第一个元素出现在第二个元素之前还是之后，但是这里有一个相当简单的记忆方法:-1出现在数字行的1之前。同样，如果谓词返回-1，第一个元素将首先出现。否则，第二个元素将首先出现。</p><h2 id="400e" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">过滤器</h2><p id="6923" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">您可以使用<code class="fe lq lr ls lt b">filter</code>根据过滤谓词获得一个元素数组。如果<em class="la">所有的</em>元素都通过了过滤器，那么你得到的数组最多和原始数组一样长，但是它通常会比原始数组短。它可能返回一个空数组。<code class="fe lq lr ls lt b">filter</code>不修改原数组，保留原数组中元素的相对顺序。</p><p id="8df1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从概念上讲，这将从数组中过滤掉您不想要的元素。</p><p id="654f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">传递给<code class="fe lq lr ls lt b">filter</code>的谓词函数应该返回一个布尔值。如果是<code class="fe lq lr ls lt b">true</code>，则元素保留在输出数组中。如果是<code class="fe lq lr ls lt b">false</code>，则不会被保留，也不会在输出数组中。</p><p id="7c02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe lq lr ls lt b">filter(Boolean)</code>是过滤掉虚假元素的常用机制。这将与<code class="fe lq lr ls lt b">filter(value =&gt; !!value)</code>相同。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="14b7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，你可以提供任何你想要的功能。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ed70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">startDate &lt; new Date('2016-01-01')</code>是布尔型。</p><p id="6b82" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果没有数组元素通过谓词，您将得到一个空数组。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9413" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谓词也接受一个索引和原始数组作为参数。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="d8e5" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">一些</h2><p id="7433" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b"><strong class="ke ir"><em class="la">some</em></strong></code> <strong class="ke ir"> <em class="la">返回布尔值。</em> </strong></p><p id="8ddd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">some</code>在功能上等同于<code class="fe lq lr ls lt b">array.filter(predicate).length &gt; 0</code>。您可以使用<code class="fe lq lr ls lt b">some</code>来确定数组中至少有一个元素满足某些条件。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5a23" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">some</code>的一个优点是，如果遇到谓词为<code class="fe lq lr ls lt b">true</code>的元素，它将短路，而不必对任何剩余的数组值运行谓词。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="2e81" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">包含</h2><p id="1ee4" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b"><strong class="ke ir"><em class="la">includes</em></strong></code> <strong class="ke ir"> <em class="la">返回布尔值。</em> </strong></p><p id="7521" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">includes</code>类似于<code class="fe lq lr ls lt b">some</code>,只是它不带谓词。它需要一个值。它的功能与<code class="fe lq lr ls lt b">array.some(val =&gt; val === providedValue)</code>相同。请记住，在比较对象时，<code class="fe lq lr ls lt b">{} != {}</code>因为对象是通过它们的引用进行比较的。如果你想查看一个数组是否有一个元素是匹配某些值的对象，使用<code class="fe lq lr ls lt b">some</code>。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="2f03" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">每个</h2><p id="9ac7" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b"><strong class="ke ir"><em class="la">every</em></strong></code> <strong class="ke ir"> <em class="la">返回一个布尔值</em> </strong></p><p id="2d35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">every</code>类似于<code class="fe lq lr ls lt b">some</code>，除了只有当<em class="la">的每个</em>数组元素都满足谓词时，它才会返回<code class="fe lq lr ls lt b">true</code>。</p><p id="7081" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">功能上相当于<code class="fe lq lr ls lt b">array.filter(predicate).length === array.length</code>。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e589" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">与<code class="fe lq lr ls lt b">some</code>类似，<code class="fe lq lr ls lt b">every</code>如果遇到从谓词返回<code class="fe lq lr ls lt b">false</code>的元素就会短路。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6e79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你不去想太多，你可能会认为<code class="fe lq lr ls lt b">array.some(predicate) === !array.every(predicate)</code>，但这是<strong class="ke ir"> <em class="la">不是真的</em> </strong>。比如<code class="fe lq lr ls lt b">[false].some(Boolean)</code>和<code class="fe lq lr ls lt b">[false].every(Boolean)</code>都为假，<code class="fe lq lr ls lt b">[true].some(Boolean)</code>和<code class="fe lq lr ls lt b">[true].every(Boolean)</code>都为真。它们以相似的方式工作，但是它们检查不同的东西。</p><h2 id="1811" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">查找和查找索引</h2><p id="3140" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">find</code>返回数组中的单个元素。我在标题中加入了<code class="fe lq lr ls lt b">findIndex</code>，因为除了<code class="fe lq lr ls lt b">find</code>返回数组元素本身而<code class="fe lq lr ls lt b">findIndex</code>返回元素所在的索引之外，它们的工作完全相同。从现在起，我将只提及<code class="fe lq lr ls lt b">find</code>，但我所说的一切也将适用于<code class="fe lq lr ls lt b">findIndex</code>。</p><p id="0e2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">find</code>像其他迭代操作符一样接受一个谓词。如果谓词返回一个真值，<code class="fe lq lr ls lt b">find</code>将短路并返回当前数组元素。否则，它将移动到下一个数组元素。如果没有元素匹配(对谓词的所有调用都返回falsey值)，<code class="fe lq lr ls lt b">find</code>将返回<code class="fe lq lr ls lt b">undefined</code>。</p><p id="a3d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> <code class="fe lq lr ls lt b"><strong class="ke ir">find</strong></code> <strong class="ke ir">返回第一个匹配元素<em class="la"/></strong>，即使有多个匹配元素。如果你想得到所有匹配的元素，使用<code class="fe lq lr ls lt b">filter</code>。如果你想对找到的值做一些等式检查，使用<code class="fe lq lr ls lt b">some</code>。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="ad8a" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">索引Of</h2><p id="9226" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">indexOf</code>不带谓语。这有点像是<code class="fe lq lr ls lt b">findIndex</code>和<code class="fe lq lr ls lt b">includes</code>的融合。它将返回与提供的值匹配的第一个元素的索引。记住，比较对象的时候，<code class="fe lq lr ls lt b">{} != {}</code>。如果你需要从一个对象数组中获取一个值，你可能需要<code class="fe lq lr ls lt b">findIndex</code>。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6302" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有一个<code class="fe lq lr ls lt b">lastIndexOf</code>将返回与提供的值匹配的最后一个元素<em class="la">。<code class="fe lq lr ls lt b">find</code>和<code class="fe lq lr ls lt b">findIndex</code>没有模拟。如果您想要最后一个匹配的元素，首先使用<code class="fe lq lr ls lt b">reverse</code>。</em></p><h1 id="2e4f" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">转换</h1><p id="9f3e" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">转换是通常根据一些公共功能修改数组的操作符。并不是所有的转换都会修改原始数组(下面我会指出是哪些转换)。许多这些都可以用<code class="fe lq lr ls lt b">reduce</code>来代替，但是下面的方法更加语义化和方便。</p><h2 id="6dfb" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">反向</h2><p id="34d3" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">这只是颠倒了数组。它获取最后一个数组元素并将其移动到第一个位置，获取倒数第二个数组元素并将其移动到第二个位置，依此类推。原始数组的第一个元素将被移动到最后一个位置。</p><p id="36de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以使用spread操作符来获得一个单独的反向数组，如<code class="fe lq lr ls lt b">reversedArray = [...array].reverse()</code>所示。<code class="fe lq lr ls lt b">reverse</code>返回反转的数组，即使它也修改原始数组。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="09d3" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">加入</h2><p id="7b3d" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">Join遍历每个数组元素，返回其字符串表示，并在每个数组值之间放置一些分隔符。默认情况下，分隔符是逗号(没有空格)。</p><p id="7949" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这与string <code class="fe lq lr ls lt b">split</code>操作符相反，它通过沿着提供的分隔符分割字符串来创建数组，其中每个数组元素都是分隔符之间的子字符串。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ea3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这对字符串数组很有用。如果你有一个对象数组，你可以首先使用<code class="fe lq lr ls lt b">map</code>映射到一个字符串数组并连接它。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="4066" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">推送、弹出、移动和取消移动</h2><p id="94d4" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">这些运算符专门用于在数组中添加和删除元素。这些都会修改数组本身。</p><p id="0543" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">push</code>将一个元素添加到数组的末尾(添加的值成为最后一个元素<em class="la">)。如今，<code class="fe lq lr ls lt b">push</code>大概没有spread那么普遍了。使用<code class="fe lq lr ls lt b">array.push(value)</code>是<code class="fe lq lr ls lt b">[...array, value]</code>的非不可变版本。<code class="fe lq lr ls lt b">push</code>返回新数组的长度。您可以一次推送多个值。</em></p><p id="62d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">pop</code>删除数组末尾的元素(数组的最后一个元素<em class="la">)。<code class="fe lq lr ls lt b">pop</code>修改原始数组并返回移除的值。</em></p><p id="9dce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">shift</code>与<code class="fe lq lr ls lt b">pop</code>相似，只是它从数组中移除了第一个元素<em class="la">。它就地修改数组并返回移除的值。</em></p><p id="0dbf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">unshift</code>与<code class="fe lq lr ls lt b">push</code>类似，只是在数组的开头添加了一个元素(添加的值成为第<em class="la">个</em>元素)。与<code class="fe lq lr ls lt b">push</code>类似，您可以使用spread: <code class="fe lq lr ls lt b">[value, ...array]</code>进行不可变的不移位操作。您可以一次取消转移多个值。不要被这个操作符名称中的<em class="la"> un </em>所迷惑:它向数组中添加一个值。和<code class="fe lq lr ls lt b">push</code>一样，<code class="fe lq lr ls lt b">unshift</code>返回更新后数组的长度。</p><h2 id="7394" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">薄片</h2><p id="523a" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated"><code class="fe lq lr ls lt b">slice</code>取出数组的一部分或一大块。<code class="fe lq lr ls lt b">slice</code>最多采用两个参数:切片起始索引和切片结束索引<em class="la">到</em>。</p><p id="7dc9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">两个参数都是可选的。如果不提供参数，<code class="fe lq lr ls lt b">slice</code>将返回数组的一个浅层副本，就像使用<code class="fe lq lr ls lt b">[...array]</code>一样。起始索引处的元素将作为切片的一部分返回。如果不包括结束索引，将包括从开始索引到数组结尾的所有元素。如果您提供一个结束索引，它将<em class="la">而不是</em>包含在数组中。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f619" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以使用<code class="fe lq lr ls lt b">slice</code>通过结合spread来帮助您将元素不变地添加到数组中。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="e46c" class="mx lv iq bd lw my mz dn ma na nb dp me kn nc nd mi kr ne nf mm kv ng nh mq ni bi translated">拼接</h2><p id="a806" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">我会放弃使用<code class="fe lq lr ls lt b">splice</code>，而使用带有spread的<code class="fe lq lr ls lt b">slice</code>。<code class="fe lq lr ls lt b">splice</code>与<code class="fe lq lr ls lt b">slice</code>相似，它返回原始数组的一部分或一大块。但是，您也可以选择在移除切片的位置插入新元素。</p><p id="ae61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我提到<code class="fe lq lr ls lt b">splice</code>,因为我认为在不变性作为一个概念真正出现之前，它更常用，所以我在这里不提供例子。如果你想从一个数组中删除元素并在适当的位置添加元素，使用spread和<code class="fe lq lr ls lt b">slice</code>来代替。我们可以修改上面的例子，通过改变我们使用的切片来插入<code class="fe lq lr ls lt b">Bryan</code>,其中<code class="fe lq lr ls lt b">Andrew</code>是。</p><p id="573f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我看来，这也更容易看到数组是如何被修改的。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="f38f" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">关于不变性</h1><p id="70af" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">不变性已经成为JavaScript开发中的核心概念。通常，您可以创建一个作为源数组副本的新数组，而不是修改原始数组。这允许您获得原始数组的新表示，而无需实际修改它。不变性在组件驱动的框架中是有用的，比如React和Angular，带有变化检测的概念。更改现有对象不会触发用于比较的更改检测。相反，您可以用修改后的元素创建一个新数组。</p><p id="c5d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一些例子包括:</p><ul class=""><li id="8a2b" class="lc ld iq ke b kf kg kj kk kn le kr lf kv lg kz lh li lj lk bi translated"><code class="fe lq lr ls lt b">array.push(value)</code>-&gt;-<code class="fe lq lr ls lt b">[...array, value]</code></li><li id="1cf7" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><code class="fe lq lr ls lt b">array.pop()</code>-&gt;-<code class="fe lq lr ls lt b">array.slice(array.length — 1)</code></li><li id="a885" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><code class="fe lq lr ls lt b">array.shift()</code>-&gt;-<code class="fe lq lr ls lt b">array.slice(1)</code></li><li id="20f2" class="lc ld iq ke b kf ll kj lm kn ln kr lo kv lp kz lh li lj lk bi translated"><code class="fe lq lr ls lt b">array.unshift(value)</code>-&gt;-<code class="fe lq lr ls lt b">[value, ...array]</code></li></ul><p id="725f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong>即传播算子，<code class="fe lq lr ls lt b">map</code>等。艾尔。创建原始数组的<em class="la">浅</em>副本。也就是说，虽然您可能无法修改原始数组，但如果数组元素是对象，您可以修改它们。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="768b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你应该在每一层编写不变的代码，在需要的地方创建副本。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fdc0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在某些情况下，创建对象(包括数组)的深层副本可能会很方便。您可以使用诸如immer或lodash之类的工具来帮助实现这一点，但是使用spread操作符是创建数组和对象的浅层副本的一种简单的本机方法。</p><h1 id="6b1a" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="77dd" class="pw-post-body-paragraph kc kd iq ke b kf ms kh ki kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz ij bi translated">除了我在这里列出的之外，还有很多数组操作符，我建议您查看MDN关于数组的文档，看看是否有您需要的或者可以用于您的给定情况的操作符。</p><p id="6e62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望这篇文章已经让一些人更加熟悉您可以使用的数组/集合的常见用例的一些优秀选项。还有其他优秀的库，如lodash和RxJS，它们提供了这些操作符和许多更有用的操作符，用于处理其他类型的集合，包括数组。</p></div></div>    
</body>
</html>