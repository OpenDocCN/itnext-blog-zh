<html>
<head>
<title>Easy undo feature with React and Immer.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Immer.js的轻松撤销功能</h1>
<blockquote>原文：<a href="https://itnext.io/easy-undo-feature-with-react-and-immer-js-9b467c080257?source=collection_archive---------2-----------------------#2021-05-24">https://itnext.io/easy-undo-feature-with-react-and-immer-js-9b467c080257?source=collection_archive---------2-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c9fec6c4a75acebd8b14b7dc2ad68bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ebH7QxC-AmCW_4bd7yPmg.png"/></div></div></figure><p id="f9ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从头开始为React应用程序添加撤销功能是一项相当复杂的任务。管理状态已经很棘手了，实现撤销意味着状态版本化和跟踪随时间的变化。幸运的是，Immer.js让它变得简单多了。</p><p id="f593" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们探索使用Immer.js来管理复杂的状态和处理撤销，同时构建一个有趣的小地牢爬虫游戏。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/b43d177dc17c7e80f19c1362e3e4477e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*m71nCPfOLPt21xxU68qlmA.gif"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">完成的游戏</figcaption></figure><h1 id="5d37" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是Immer.js？</h1><p id="6cbf" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">Immer.js是一个非常棒的库，有着广泛的应用。但是它的核心用例是提供无缝的<a class="ae ml" href="https://en.wikipedia.org/wiki/Immutable_object#:~:text=In%20object%2Doriented%20and%20functional,modified%20after%20it%20is%20created" rel="noopener ugc nofollow" target="_blank">不变性</a>。它允许您修改数据结构并返回副本，而不是改变原始数据。</p><p id="562c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能知道其他完成同样事情的库，主要是<a class="ae ml" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>。在众多选项中，Immer.js是一个更好的选择，主要原因是它可以处理本机对象类型。</p><p id="6f1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不可变的. js的最大缺点是它为每个数据结构提供了一个自定义类型。另一方面，Immer.js返回它接收到的相同的对象类型，这使得它很少受到干扰，并且更容易使用。</p><h2 id="c2ef" class="mm lj it bd lk mn mo dn lo mp mq dp ls km mr ms lw kq mt mu ma ku mv mw me mx bi translated">Immer.js的“生产”功能</h2><p id="0c7d" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">Immer.js的主要特点是<a class="ae ml" href="https://immerjs.github.io/immer/produce" rel="noopener ugc nofollow" target="_blank">产生</a>函数。该函数接受一个源对象和用于修改源的自定义处理程序。<code class="fe my mz na nb b">produce</code>返回一个新副本，同时保持源文件不变:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6f56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在处理程序中，您会收到一个draft参数，您可以使用它直接改变源代码，而不用担心副作用。经手人不必退回汇票。Immer.js足够聪明，可以在没有显式返回的情况下跟踪更改。</p><p id="73f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Immer使用<a class="ae ml" href="https://en.wikipedia.org/wiki/Copy-on-write" rel="noopener ugc nofollow" target="_blank">写时复制</a>机制，这使得复制对象具有性能。</p><p id="e76c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想了解更多关于Immer.js的知识，最好从他们的<a class="ae ml" href="https://immerjs.github.io/immer/" rel="noopener ugc nofollow" target="_blank">文档</a>开始。</p><h2 id="ba7f" class="mm lj it bd lk mn mo dn lo mp mq dp ls km mr ms lw kq mt mu ma ku mv mw me mx bi translated">修补程序概述</h2><p id="74e0" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">构建撤销特性需要使用Immer.js更高级的功能— <a class="ae ml" href="https://immerjs.github.io/immer/patches" rel="noopener ugc nofollow" target="_blank">补丁</a>。</p><p id="a7c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用补丁，Immer.js跟踪对状态所做的所有更改。补丁是JSON对象，遵循Immer.js理解的格式。补丁看起来是这样的:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e4a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用<code class="fe my mz na nb b">applyPatches</code>函数将这些补丁反馈给Immer.js来撤销或重新应用状态更改。</p><h1 id="a4a0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">辅导的</h1><p id="012a" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">完成了对Immer.js的基本概述，让我们开始我们的教程。</p><p id="6c81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，我们将构建一个简单的游戏。你在一个地牢里，面前有三扇门。其中一个有你要找的宝藏，另外两个背后有死敌。</p><p id="60e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个游戏最重要的特点(对我们来说)是你可以使用撤销按钮作弊。</p><h2 id="57c5" class="mm lj it bd lk mn mo dn lo mp mq dp ls km mr ms lw kq mt mu ma ku mv mw me mx bi translated">添加还原剂</h2><p id="4a5e" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们将使用<a class="ae ml" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> useReducer </a>来管理应用程序的状态。这是我们减速器的初始设置:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8ecf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的reducer使用<code class="fe my mz na nb b">produce</code>函数返回一个新的状态。所有的状态操作都发生在生产处理程序内部。请再次注意，我们可以自由地改变状态，但一切仍然正常。相当酷！</p><p id="e011" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe my mz na nb b">generateDoors</code>返回包含随机内容的门的数组。</p><p id="ed8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用减速器的方式和平时一样:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="f98e" class="mm lj it bd lk mn mo dn lo mp mq dp ls km mr ms lw kq mt mu ma ku mv mw me mx bi translated">添加补丁</h2><p id="1270" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">现在，让我们使用补丁。</p><p id="abb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个<code class="fe my mz na nb b">produce</code>函数实际上可以接受三个参数:</p><ol class=""><li id="cfad" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated">初始源对象。在我们的例子中，它是减速器的状态。</li><li id="8978" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">状态突变的处理函数。</li><li id="705d" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">接收补丁的第二个处理程序。我们需要保存这些补丁以备后用。</li></ol><p id="26e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">补丁处理函数接收两个参数:</p><ol class=""><li id="7354" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated">修补程序—具有最新状态更改的修补程序阵列。</li><li id="4e41" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">inversePatches —用于恢复最新状态更改的修补程序阵列。</li></ol><p id="ccf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，我们只关心<code class="fe my mz na nb b">inversePatches</code>数组。然而，如果您要实现重做，您也需要跟踪<code class="fe my mz na nb b">patches</code>。</p><p id="26f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们提供在逆向补丁到达时记录它们的处理程序:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="f5c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们需要调用<code class="fe my mz na nb b">enablePatches</code>来激活补丁特性。</p><p id="5206" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们检查以确保我们只跟踪可撤销操作的补丁。在我们的例子中，<code class="fe my mz na nb b">OPEN_DOOR</code>是唯一可撤销的动作。</p><p id="ee28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，当重置游戏时，我们希望清除<code class="fe my mz na nb b">RESET</code>动作中的补丁。</p><h2 id="5fda" class="mm lj it bd lk mn mo dn lo mp mq dp ls km mr ms lw kq mt mu ma ku mv mw me mx bi translated">添加撤消</h2><p id="bbd8" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">这里的最后一步是添加应用我们存储的反向补丁的<code class="fe my mz na nb b">UNDO</code>动作:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b9d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从<code class="fe my mz na nb b">inverseChanges</code>数组中弹出最新的逆向补丁并应用它。注意，调用<code class="fe my mz na nb b">applyPatches</code>时，Immer.js要求我们显式返回结果。更多信息请点击此处。</p><h1 id="3bbb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">包扎</h1><p id="c70b" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">本教程到此为止。我们看到添加撤销特性来与Immer.js交互是多么容易。</p><p id="517b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Immer.js是一个很棒的不变性库，补丁允许创建一些高级功能。您可以使用补丁来构建诸如通过WebSockets交流更新、跟踪/调试、版本控制等功能。</p><p id="e877" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个链接，链接到这个教程的完整代码的<a class="ae ml" href="https://codesandbox.io/s/immer-undo-66mbe" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="7401" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nz">原载于2021年5月24日https://isamatov.com</em><em class="nz">的</em> <a class="ae ml" href="https://isamatov.com/undo-with-react-and-immer/" rel="noopener ugc nofollow" target="_blank"> <em class="nz">。</em></a></p></div></div>    
</body>
</html>