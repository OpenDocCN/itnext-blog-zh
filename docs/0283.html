<html>
<head>
<title>What do need know about enumerations in TypeScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于TypeScript中的枚举需要知道什么？</h1>
<blockquote>原文：<a href="https://itnext.io/what-do-need-know-about-enumerations-in-typescript-48b554cec43b?source=collection_archive---------0-----------------------#2018-02-08">https://itnext.io/what-do-need-know-about-enumerations-in-typescript-48b554cec43b?source=collection_archive---------0-----------------------#2018-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bcb380730eff5d01532df0f4f5d19280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUeaUCxk-f5qVVXpkUk2vw.jpeg"/></div></div></figure><p id="051b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简短介绍...类型脚本中的类型定义技术；</p><p id="813c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fwhat-do-need-know-about-enumerations-in-typescript-48b554cec43b" rel="noopener ugc nofollow" target="_blank"> <em class="kx">点击这里在LinkedIn </em>上分享这篇文章</a></p><p id="c0d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">简单类:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b158" class="lh li iq ld b gy lj lk l ll lm">var UserType = (function(){<br/>    function UserType(){<br/>    }<br/>    /* some code */<br/>    return UserType;<br/>})();</span></pre><p id="ebdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">或枚举:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6e9d" class="lh li iq ld b gy lj lk l ll lm">var UserType;<br/>(function(){<br/>    /* other code */<br/>})(UserType || UserType = &lt;type_initializer&gt;);</span></pre><p id="de46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要匿名功能吗？：</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f473" class="lh li iq ld b gy lj lk l ll lm">var typeName = (function(){ ... })();</span></pre><p id="5746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript使用自调用匿名函数在函数执行后创建用户类型。Him函数是返回函数生成器或设置变量，它已作为参数接收。你可以在可自调用函数后看到括号`<em class="kx"> () </em>`。这需要在满足him时调用自调用函数。</p><p id="557e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">所以…转到枚举… </strong></p><p id="358b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">枚举是具有<strong class="ka ir">对象</strong>原型的简单对象。这是事实！看…</p><div class="ln lo gp gr lp lq"><a href="https://www.typescriptlang.org/play/#src=enum%20Names%20%7B%0D%0A%7D%0D%0Aconsole.log%28Names%29%3B" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">操场打字稿</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">在您的浏览器中尝试使用TypeScript！</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/cab62a94d73f3253ed77f834cd43d311.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*UFOch26g_FSHQ4NrXk3Vag.png"/></div></figure><h1 id="4f0a" class="ma li iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">实验后的命名约定:</strong></h1><p id="d0bb" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated"><em class="kx">对象是简单的字典，其中:</em></p><p id="e5b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kx">枚举键—对象键/对象属性。</em> </strong></p><p id="de20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kx">枚举值——自身对象的属性值。</em>T25】</strong></p><p id="5d85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开始之前，我们先看看TypeScript中的类和枚举有什么不同。</p><p id="6666" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript类定义:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c7bc" class="lh li iq ld b gy lj lk l ll lm">class User {<br/>}</span></pre><p id="2c0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传输到ES5:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="64d4" class="lh li iq ld b gy lj lk l ll lm">var User = (function () {<br/>    function User() {<br/>    }<br/>    return User;<br/>}());</span></pre><p id="96f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">键入枚举定义:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d66a" class="lh li iq ld b gy lj lk l ll lm">enum Names {<br/>}</span></pre><p id="d54e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传输到ES5:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="36fe" class="lh li iq ld b gy lj lk l ll lm">var Names;<br/>(function (Names) {<br/>})(Names || (Names = {}));</span></pre><p id="7400" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，枚举定义使用了一个自己的类型作为参数，一个自调用函数，它随后被修改(添加了键:值)。</p><h2 id="5e1e" class="lh li iq bd mb nc nd dn mf ne nf dp mj kj ng nh mn kn ni nj mr kr nk nl mv nm bi translated">所以…任何地方都很简单…需要添加成员…</h2><p id="5fbe" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated"><strong class="ka ir">打字稿:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="39fc" class="lh li iq ld b gy lj lk l ll lm">/*<br/> You can skip values initialization into enum definition.<br/> TypeScript use it as default enum declaration.<br/>*/<br/>enum Names {<br/>    Alex = 0,<br/>    Denis = 1<br/>}</span></pre><p id="a94d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES5:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="dc60" class="lh li iq ld b gy lj lk l ll lm">var Names;<br/>(function (Names) {<br/>    Names[Names["Alex"] = 0] = "Alex";<br/>    Names[Names["Denis"] = 1] = "Denis";<br/>})(Names || (Names = {}));</span></pre><p id="892f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以…它更感兴趣…我们看到了什么(简化为步骤)？：</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d90e" class="lh li iq ld b gy lj lk l ll lm">/*<br/>    No step. Only for example.<br/>    This is function will be created at run-time in memory really.<br/>*/<br/>function selfInvokable(enumType) {<br/>    <strong class="ld ir"><em class="kx">step 3</em></strong>: enumType["Alex"] = 0;<br/>    <strong class="ld ir"><em class="kx">step 4:</em></strong> enumType[enumType["Alex"]] = "Alex";<br/>    <strong class="ld ir"><em class="kx">step 5:</em></strong> enumType["Alex"] = 1;<br/>    <strong class="ld ir"><em class="kx">step 6:</em></strong> enumType[enumType["Denis"]] = "Denis";<br/>}</span><span id="a3b6" class="lh li iq ld b gy nn lk l ll lm"><strong class="ld ir"><em class="kx">step 0:</em></strong> var Names = undefined;<br/><strong class="ld ir"><em class="kx">step 1:</em></strong> if(!Names) { Names = {}; }<br/><strong class="ld ir"><em class="kx">step 2:</em></strong> selfInvokable(Names);</span></pre><p id="fde6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以枚举呈现为如下对象(原型成员已被排除):</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7388" class="lh li iq ld b gy lj lk l ll lm">var Names = {<br/>    "0":"Alex",<br/>    "1":"Denis",<br/>    "Alex":0,<br/>    "Denis":1<br/>};</span></pre><p id="bce3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用JSON.stringify()(没有序列化原型)来表示上面的图片。和Object.keys()来获取对象的keys数组。<strong class="ka ir">警告！不要使用for-in构造来获取枚举键，因为她会额外从prototype返回键。</strong></p><p id="4781" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以…可能有时候需要开发助手来处理枚举…一定要做！</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d3df" class="lh li iq ld b gy lj lk l ll lm">class EnumHelpers {</span><span id="ac50" class="lh li iq ld b gy nn lk l ll lm">    /**<br/>    * No instances guard.<br/>    */<br/>    private constructor() { }</span><span id="e4f5" class="lh li iq ld b gy nn lk l ll lm">    /**<br/>     * Get all keys from enumeration.<br/>     */<br/>    public static keys(enumType: object) {<br/>        const members = Object.keys(enumType);<br/>        return members.filter((x) =&gt; Number.isNaN(parseInt(x, 10)))<br/>    }<br/>}</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/67a412d30799bab8a2cd829f2a46aa15.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*U0uxHgGR5wdJ3_tBBY18uw.png"/></div></figure><p id="1473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不错…我们可以从枚举中得到键。然后让develop方法获得{ key，value }对象的数组。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a44c" class="lh li iq ld b gy lj lk l ll lm">/**<br/>* Get key-value array from enumeration.<br/>*/<br/>public static toKeyValueArray(enumType: object) {<br/>   return EnumHelpers.keys(enumType)<br/>       .map((key) =&gt; {<br/>           return { key, value: enumType[key] };<br/>        });<br/>}</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/818662a7ea55a888237418cddb807995.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*PMSTBAUjle82BG0Uu_-zsw.png"/></div></figure><p id="10b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">When方法从枚举类型中获取值:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4887" class="lh li iq ld b gy lj lk l ll lm">/**<br/>* Get values from enumeration.<br/>*/<br/>public static values(enumType: object) {<br/>   return EnumHelpers.toKeyValueArray(enumType)<br/>       .map((kv) =&gt; kv.value);<br/>}</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a65b772eeec1042342b1206089493375.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*Rhv1dfqNlsAMsDggouKSGQ.png"/></div></figure><p id="30ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以找到从枚举中获取密钥的其他解决方案，但是它们可能是不正确的。比如:<a class="ae kw" href="https://stackoverflow.com/a/18112157" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/18112157</a>。</p><p id="d256" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题:枚举值可以是负数。</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a1a1" class="lh li iq ld b gy lj lk l ll lm">enum Names {<br/>    Alex = 0,<br/>    Denis = -1<br/>}</span><span id="9faa" class="lh li iq ld b gy nn lk l ll lm">/**<br/> * Sample from stack overflow.<br/> * <a class="ae kw" href="http://twitter.com/see" rel="noopener ugc nofollow" target="_blank">@see</a> <a class="ae kw" href="https://stackoverflow.com/a/18112157" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/18112157</a><br/> */<br/>function getValues(enumType: object) {<br/>    for (var enumMember in enumType) {<br/>        var isValueProperty = parseInt(enumMember, 10) &gt;= 0<br/>        if (isValueProperty) {<br/>            console.log("enum member: ", enumType[enumMember]);<br/>        }<br/>    }<br/>}</span><span id="b4e7" class="lh li iq ld b gy nn lk l ll lm">getValues(Names);</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f900b13b9f3a40324fdd1bc44ddb4369.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*2INpYL5o2KE5O-c4J-Y6bQ.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">执行结果。</figcaption></figure><p id="057b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">预期:</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/1d954144848745769daa89543111f800.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*mwQaTH3MdIunDPYijU87BQ.png"/></div><figcaption class="ns nt gj gh gi nu nv bd b be z dk translated">预期结果。</figcaption></figure><p id="3af0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">修复:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cc7d" class="lh li iq ld b gy lj lk l ll lm"><strong class="ld ir">var isValueProperty = !Number.isNaN(parseInt(enumMember, 10));</strong></span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="7037" class="ma li iq bd mb mc oe me mf mg of mi mj mk og mm mn mo oh mq mr ms oi mu mv mw bi translated">2.4中新的TypeScript枚举功能。</h1><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/a9f8084e6c486a7bef7269995ac8313f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j58d7ZrTBAzHPg0i.jpg"/></div></div></figure><p id="e136" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在TypeScript 2.4之前，我们只能有数字枚举，但在TypeScript 2.4中，已经添加了字符串值作为枚举值。</p><p id="edc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TypeScript定义:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cb51" class="lh li iq ld b gy lj lk l ll lm">enum Names {<br/>    Alex = "a",<br/>    Denis = "d"<br/>}</span></pre><p id="2892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传输到ES5:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="497b" class="lh li iq ld b gy lj lk l ll lm">var Names;<br/>(function (Names) {<br/>    Names["Alex"] = "a";<br/>    Names["Denis"] = "d";<br/>})(Names || (Names = {}));</span></pre><p id="d6b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到枚举值没有被复制到对象键。所以，接下来需要重构我们的助手来处理字符串枚举:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0f79" class="lh li iq ld b gy lj lk l ll lm">/**<br/>* Check to numeral enumeration.<br/>*/<br/>private static isNumeral(enumType: object) {<br/>    const members = Object.keys(enumType);<br/>    if (!members.some((x) =&gt; true)) {<br/>        throw new TypeError("Invalid enumeration type.");<br/>    }</span><span id="f7e3" class="lh li iq ld b gy nn lk l ll lm">    let parsedCount = 0;<br/>    members.forEach((x) =&gt; {<br/>        const parsedValue = parseInt(x, 10);<br/>        if (!Number.isNaN(parsedValue)) {<br/>            parsedCount++;<br/>        }<br/>    });</span><span id="eb5e" class="lh li iq ld b gy nn lk l ll lm">    return parsedCount === members.length / 2;<br/>}</span><span id="aa3e" class="lh li iq ld b gy nn lk l ll lm">/**<br/> * Get all keys from enumeration.<br/> */<br/>public static keys(enumType: object) {<br/>    const members = Object.keys(enumType);<br/>    if (!EnumHelpers.isNumeral(enumType)) {<br/>        return members;<br/>    }<br/>       <br/>    const keys: string[] = [];<br/>    members.forEach((x) =&gt; {<br/>        const parsedValue = parseInt(x, 10);<br/>        if (Number.isNaN(parsedValue)) {<br/>            keys.push(x);<br/>        }<br/>    });<br/>    return keys;<br/>}</span></pre></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><h1 id="0cf0" class="ma li iq bd mb mc oe me mf mg of mi mj mk og mm mn mo oh mq mr ms oi mu mv mw bi translated"><strong class="ak">但这并没有结束…混合枚举… </strong></h1><p id="52a4" class="pw-post-body-paragraph jy jz iq ka b kb mx kd ke kf my kh ki kj mz kl km kn na kp kq kr nb kt ku kv ij bi translated">TypeScript定义:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e028" class="lh li iq ld b gy lj lk l ll lm">enum Size {<br/>    One = 1,<br/>    All = "all"<br/>}</span></pre><p id="6707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传输到ES5:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9185" class="lh li iq ld b gy lj lk l ll lm">var Size;<br/>(function (Size) {<br/>    Size[Size["One"] = 1] = "One";<br/>    Size["All"] = "all";<br/>})(Size || (Size = {}));</span></pre><p id="d8ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">嗯…助手不知道如何使用这个混血儿…需要调整一个键()方法。</em></p><p id="1c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解决方案:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="fd6f" class="lh li iq ld b gy lj lk l ll lm">/**<br/>* Get all keys from enumeration.<br/>*/<br/>public static keys(enumType: object) {<br/>    const members = Object.keys(enumType);</span><span id="5fc6" class="lh li iq ld b gy nn lk l ll lm">    let keys: string[];<br/>    if (!EnumHelpers.isNumeral(enumType)) {<br/>        keys = members;<br/>    } else {<br/>        keys = [];<br/>        members.forEach((x) =&gt; {<br/>            const parsedValue = parseInt(x, 10);<br/>            if (Number.isNaN(parsedValue)) {<br/>                keys.push(x);<br/>            }<br/>        });<br/>    }<br/>    // key of enumeration can't be number      <br/>    return keys.filter((x) =&gt; Number.isNaN(parseInt(x, 10)));<br/>}</span></pre><p id="151a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">看看评论上面返回的关键词^.</strong></p></div></div>    
</body>
</html>