<html>
<head>
<title>Let’s Migrate Symfony Project to Kubernetes! Part 3: Testing the Application.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们将Symfony项目迁移到Kubernetes！第3部分:测试应用程序。</h1>
<blockquote>原文：<a href="https://itnext.io/testing-symfony-application-d02317d4018a?source=collection_archive---------1-----------------------#2019-07-14">https://itnext.io/testing-symfony-application-d02317d4018a?source=collection_archive---------1-----------------------#2019-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7bde4435acd4efa80e0701604c9a2f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5EtjL-xR3fzlo1IzSj9yiQ.jpeg"/></div></figure><h1 id="8500" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">关于这个系列</h1><p id="da8f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这个系列中，我们将讨论现有Symfony项目到Kubernetes (K8s)的迁移。无论您当前在何处以及如何发布您的应用程序:裸机、VM或容器编排平台，通过遵循本指南，您将能够将其部署到K8s集群。<br/>这些* how to *文章的目标读者是那些已经了解Kubernetes、Docker和持续集成(CI)的一些基础知识、想要学习新技巧或只想完成工作的人。<br/>本系列的每一部分都致力于一个特定的主题:<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">构建Docker环境</a>，在不同级别测试应用程序，<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/publishing-symfony-application-with-helm-ecb525b34289">用Helm将应用程序部署到Kubernetes】，</a><a class="ae lq" href="https://medium.com/@babenko.i.a/building-continuous-delivery-pipeline-2cc05e213935" rel="noopener">构建CI管道</a>。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="cf46" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">关于第3部分</h1><p id="a17f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">测试是持续集成的关键部分。没有测试，我们就不能确定，我们向客户交付了一个稳定且正常工作的产品。</p><p id="3b0a" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">今天，我们有许多不同的工具、框架和方法，它们都服务于同一个目标——制造高质量的产品。在本文中，我们将采用其中的一些来测试我们的虚拟应用程序。我们将使用PHPUnit框架进行单元和集成测试，使用Postman / Newman进行端到端测试。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="deea" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">关于虚拟项目</h1><p id="97d3" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我为这个系列准备了一个简单的Symfony 4应用程序。它需要PHP-FPM，Nginx和MySQL来运行。更多详情，请参考<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">第1部分</a>。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5a1c" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">关于使用案例</h1><p id="bce6" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了使我们的应用程序更具交互性，我在<strong class="ku ir">产品</strong>控制器中添加了一个新方法:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f93a" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">我将省略表单类定义和模板代码，而是强调测试中必须考虑的关键点:</p><ul class=""><li id="2681" class="mo mp iq ku b kv md kz me ld mq lh mr ll ms lp mt mu mv mw bi translated">产品名称的长度必须为4-255个字符。</li><li id="b773" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">产品价格必须高于0。</li><li id="eb81" class="mo mp iq ku b kv mx kz my ld mz lh na ll nb lp mt mu mv mw bi translated">产品创建表单看起来像:</li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/324a8e0144b97601836e8a93f2a356b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBzhR_wL-LRmkKpbk-1V3A.jpeg"/></div></div></figure><p id="f0a7" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">我们将在测试中关注这个特定的动作，以展示不同层次上可能的测试场景:单元、集成、端到端。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5414" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">支持</h1><p id="8cbd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我们开始用测试覆盖应用程序之前，我想给你一个支持特征的概述，这可能在单元和集成测试中有所帮助。</p><h2 id="fc0c" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">内核性状</h2><p id="0f23" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="ku ir">内核</strong>特征在每个测试用例类之前启动Symfony内核，之后关闭它:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1f80" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">你可能想知道为什么不从框架提供的<strong class="ku ir"> KernelTestCase </strong>中扩展一个测试用例？问题在于被Symfony滥用的<strong class="ku ir"> bootKernel </strong>方法。例如，每次有人在<strong class="ku ir"> WebTestCase </strong>中创建一个客户端，内核就会重新启动，这将导致所有依赖关系、连接等的重新初始化。这使得不可能使用数据库事务，而我们在<strong class="ku ir">数据库</strong>特征中需要数据库事务。</p><h2 id="69e9" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">数据库特征</h2><p id="5926" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="ku ir">数据库</strong>特征在每次测试之前启动一个新的事务，并在测试完成时回滚它:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9b98" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">将每个测试封装在一个事务中可以防止数据库被不需要的数据污染。</p><h2 id="2be8" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">HTTP客户端特征</h2><p id="7904" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="ku ir"> HttpClient </strong>特征简化了客户端的创建:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="1d1a" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">路由器特征</h2><p id="e16f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="ku ir">路由器</strong>特性简化了URL生成:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="fce2" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">CSRF令牌管理器特征</h2><p id="f00d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当您需要创建跨站点请求伪造令牌时,<strong class="ku ir"> CsrfTokenManager </strong>特征非常方便，当这种类型的安全性被启用时，它在您的Symfony项目中的每种形式中都被使用:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="8ccb" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">试验</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/04f52f03aafe04f628033bd876e7f65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*zyV3vw4A7Up3KNa_25tJcg.jpeg"/></div></figure><h2 id="556f" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">单位</h2><blockquote class="nu nv nw"><p id="9363" class="ks kt nx ku b kv md kx ky kz me lb lc ny mf lf lg nz mg lj lk oa mh ln lo lp ij bi translated">单元测试是应用程序中最小的可测试部分，比如函数、类、过程、接口。单元测试是一种测试单个源代码单元以确定它们是否适合使用的方法。</p></blockquote><p id="676f" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">负责产品添加功能的虚拟应用程序的最小可测试部分是什么？是<strong class="ku ir"> ProductController::add </strong>方法！即使我们没有发出真正的HTTP请求，也没有数据库连接，我们仍然可以检查方法是否有预期的行为。</p><p id="0d4f" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">为了确保产品保存在数据库中，我们只需要测试是否调用了<strong class="ku ir"> EntityManager::persist </strong>方法。当我们在请求中提供有效的表单值时，我们期望调用<strong class="ku ir"> persist </strong>方法，否则它不能被触发:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="92c1" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">在上面的测试用例中，我们定义了两个数据集:一个包含有效表单值的列表，另一个包含无效值。然后我们描述了每个可能输入的<strong class="ku ir"> EntityManager </strong>模拟行为，以验证我们在每种情况下都正确地处理了产品。</p><p id="eec1" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">一般来说，将单元测试从集成测试中分离出来是一个好主意。这就是为什么我们在<strong class="ku ir">单元</strong>名称空间中创建测试，并在<strong class="ku ir"> phpunit.xml.dist </strong>中声明专用测试套件:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2c25" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">这个设置允许我们独立运行单元和集成测试。让我们利用PHP-FPM图像(我们在本系列的第一部分中创建的)来开始测试:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3d21" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">执行上面的命令后，您应该在终端中看到以下输出:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ob"><img src="../Images/c9b423f12416a5541dca977072388cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_yZlEvanGz1kfp-Q2f8kg.jpeg"/></div></div></figure><h2 id="3f2e" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">综合</h2><blockquote class="nu nv nw"><p id="19d3" class="ks kt nx ku b kv md kx ky kz me lb lc ny mf lf lg nz mg lj lk oa mh ln lo lp ij bi translated">集成测试确定独立开发的软件单元在相互连接时是否正常工作。</p></blockquote><p id="df55" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">在上一节中，我们成功测试了<strong class="ku ir"> ProductController::add </strong>方法。我们知道，如果提交有效的数据，该产品将被保存。但是我们确定数据库配置正确并且<strong class="ku ir">产品</strong>实体注释匹配相应的表定义吗？</p><p id="5db2" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">为了避免生产环境中令人不快的意外，我们可以测试数据库集成。如果我们向<strong class="ku ir">/产品/添加</strong>端点发送一个有效负载，一个新产品应该会出现在<strong class="ku ir">产品</strong>表中。让我们在<strong class="ku ir"> tests/Integration </strong>文件夹中创建一个新的测试用例，以涵盖上述场景:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e080" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">我们利用<strong class="ku ir"> HttpClient </strong>特性来模拟一个真实的HTTP查询，然后我们从数据库中获取一个与POST请求中相同名称的产品，并检查它是否具有给定的价格。最后，我们确保控制器会将我们重定向到新创建的产品页面。</p><p id="eb57" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">运行集成测试类似于运行单元测试:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c40f" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">输出也非常相似:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ob"><img src="../Images/7aead8442554ca65751ba01215d8ebcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e_0OY0JXPGhBrzO_zDCnaQ.jpeg"/></div></div></figure><h2 id="aaf3" class="nh jv iq bd jw ni nj dn ka nk nl dp ke ld nm nn ki lh no np km ll nq nr kq ns bi translated">首尾相连</h2><blockquote class="nu nv nw"><p id="ebce" class="ks kt nx ku b kv md kx ky kz me lb lc ny mf lf lg nz mg lj lk oa mh ln lo lp ij bi translated">端到端测试是一种用于测试应用程序的流程是否从头到尾都按照设计执行的方法。</p></blockquote><p id="a8d9" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">在上一节中，我们模拟了一个HTTP查询，但是如果我们想要进行一个真正的查询呢？如果我们想检查用户是否真的能看到表单错误，并在请求成功后被浏览器重定向到新的产品页面，该怎么办？</p><p id="37ff" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">在Postman和他的CLI兄弟Newman的帮助下，我们可以很容易地实现端到端的测试，这将涵盖所讨论的案例。让我们打开Postman，用<strong class="ku ir">产品/添加</strong>文件夹<strong class="ku ir"> </strong>创建一个新的<strong class="ku ir"> Symfony虚拟项目</strong>集合，并设置环境:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oc"><img src="../Images/d53e49d2185c1e8e484a7efdaad39812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgpWWBHixrgt7XIC4eum4Q.jpeg"/></div></div></figure><p id="f84d" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">当我们在项目中使用CSRF保护时，我们需要在请求体中提供正确的令牌。为了识别令牌，我们可以在<strong class="ku ir"> Add </strong>文件夹<strong class="ku ir"> : </strong>的<strong class="ku ir">预请求脚本</strong>选项卡中添加一个GET查询</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi od"><img src="../Images/fe69dc1038c0b1062f3ff5c2e686de98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kir_W8O6461acEEedHtVnQ.jpeg"/></div></div></figure><p id="6d28" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">我们使用<a class="ae lq" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"> Cheerio </a>遍历接收到的HTML，找到令牌并将其保存在一个变量中以备后用。</p><p id="6c2b" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">是时候添加我们的第一个带有无效表单数据的请求了:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oe"><img src="../Images/73bee372fd1c76e064fac531578262d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*usSjoxZ5HLNWswhxZ6fU-Q.jpeg"/></div></div></figure><p id="31f3" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">为了测试我们实际显示的错误，我们可以在<strong class="ku ir">测试</strong>选项卡中添加一些基本检查:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi of"><img src="../Images/fe9964f763331738e419b46e6ece66dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUhOFSKXG871oFIVU3iAyg.jpeg"/></div></div></figure><p id="b620" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">现在让我们用正确的数据添加另一个请求:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi og"><img src="../Images/18f2e0b535666c29300ad49f0c2e75d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVNUBTMiaDVb-lwQquKIYA.jpeg"/></div></div></figure><p id="8391" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">在这种情况下，我们必须重定向到新产品页面。我们可以测试所提供的名称和价格是否显示在页面上:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi of"><img src="../Images/fe53bfde3ec73e85cff0959f84c80ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFyS2TJONyUyVpfQdaiAow.jpeg"/></div></div></figure><p id="dfc2" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">为了触发测试，我们可以通过按下<strong class="ku ir">发送</strong>按钮一个接一个地发送请求，或者使用邮递员<strong class="ku ir">信使</strong>。另一种选择是使用名为Newman的CLI工具。这是测试集合的首选方式，因为它可以很容易地集成到CI管道中。</p><p id="03c2" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">在开始测试之前，让我们将集合和环境导出到项目中的<strong class="ku ir"> tests/EndToEnd </strong>文件夹:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oh"><img src="../Images/c566301b2f12ef38a61d1110e97888f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34za80qZAEQrirMcBO2afQ.png"/></div></div></figure><p id="8037" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">我们已经准备好使用Newman docker图像运行查询:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oi"><img src="../Images/6f070842ab5961f8d951b19b522cba7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RWr5wXVGETPlzBkUkzBzQ.jpeg"/></div></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5fa7" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">最后的想法</h1><p id="ee4f" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">即使你的项目被任何可能的测试类型很好的覆盖，尽可能的与QA工程师合作。他们可能会帮助你想出一些你从未想过的场景，并确保你现有的测试用例中没有任何缺陷。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="oj mn l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="000d" class="ju jv iq bd jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr bi translated">下一步是什么？</h1><p id="c56c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在之前的文章中，我们学习了如何使用Helm 将应用<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/containerizing-symfony-application-a2a5a3bd5edc">容器化</a>并<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/publishing-symfony-application-with-helm-ecb525b34289">部署到Kubernetes集群。今天我们讨论了软件测试主题。</a></p><p id="a889" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">是时候应用我们的经验了，在本系列的最后一部分通过构建CI渠道来自动化所有阶段。</p><p id="ba64" class="pw-post-body-paragraph ks kt iq ku b kv md kx ky kz me lb lc ld mf lf lg lh mg lj lk ll mh ln lo lp ij bi translated">感谢您的阅读，下次再见！</p></div></div>    
</body>
</html>