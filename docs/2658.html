<html>
<head>
<title>React Hooks: Optimizing for performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩:优化性能</h1>
<blockquote>原文：<a href="https://itnext.io/optimizing-react-code-with-hooks-3eaaf5978351?source=collection_archive---------1-----------------------#2019-07-06">https://itnext.io/optimizing-react-code-with-hooks-3eaaf5978351?source=collection_archive---------1-----------------------#2019-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/425e6319924037072c7abc4c6d77ea98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-jxKr0txTp9QkcZYMeIag.jpeg"/></div></div></figure><p id="dba2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你已经使用React钩子有一段时间了，你可能已经爱上它们了。几乎所有的开发人员现在都在使用它们，并尽可能地将基于类的组件变成功能组件。这很好，也是React团队所提倡的。功能性组件很容易理解，并且在您的代码库中需要的锅炉板代码要少得多。</p><p id="6555" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您已经使用React有一段时间了，那么您会很清楚这样一个事实，即在生产中，开发人员会尽可能地优化他们的组件。组件不应该被不必要的渲染，所以在基于类的组件中，生命周期方法，比如“shouldComponentUpdate()”被用来检查状态的变化。如果状态发生了变化，那么React会重新渲染组件，否则就保持不变。</p><h1 id="3096" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">React中重新渲染的工作方式</h1><p id="680f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在React中，当父组件重新呈现时，其所有子组件都会重新呈现(如果没有为子组件实现优化)。可以通过多种方式触发组件重新渲染，其中几种方式是:</p><ol class=""><li id="1ce5" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">组件状态的变化</li><li id="02bf" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">组件属性的变化</li></ol><p id="0033" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当你所有的组件都是功能组件时，会发生什么呢？记住，这里没有生命周期方法或钩子来帮助你。还是有？</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/06c733ced941dbe9e23d8390d82d88d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*xHY2LU643bQ5-MGGVjxR7g.gif"/></div></figure><p id="9562" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个具有某种状态的功能组件的例子，由于其状态的改变而重新呈现。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b2fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个功能组件有一些<code class="fe mx my mz na b">state</code>(计数器)，点击一个按钮，用户就可以改变它。还要注意<code class="fe mx my mz na b">formatCounter()</code>方法，我们很快就会谈到它。</p><p id="c2d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们一步一步来。</p><p id="1da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户点击按钮时，我们调用<code class="fe mx my mz na b">setCounter()</code>方法，该方法将使用新的<code class="fe mx my mz na b">counter</code>状态重新呈现组件。在功能组件中，重新渲染意味着整个功能将再次运行。</p><ol class=""><li id="0e16" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">因此，从顶部开始运行<code class="fe mx my mz na b">useState()</code>方法。由于钩子的固有特性，这将返回更新的<code class="fe mx my mz na b">counter</code>和缓存的<code class="fe mx my mz na b">setCounter()</code>方法。</li><li id="d580" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">接下来，<code class="fe mx my mz na b">formatCounter()</code>功能将被添加到内存中。</li><li id="b47c" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">最后，返回一些JSX。但是在<code class="fe mx my mz na b">&lt;button/&gt;</code>上，有一个<code class="fe mx my mz na b">onClick()</code>处理程序，是一个箭头函数。这个函数也将被添加到内存中。</li></ol><p id="a815" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次组件重新渲染时，所有这些步骤都会发生。作为一个好的开发者，你不能允许这样。您需要以某种方式缓存<code class="fe mx my mz na b">formatCounter()</code>和<code class="fe mx my mz na b">onClick()</code>方法，这样它们就不会在每次重新渲染时被添加到内存中。</p><h1 id="2f76" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">天真的解决方案</h1><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/8bebb69f565711c2ff9140966f12b1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OVzGM1W_QOMTvBOCaqnN6g.gif"/></div></div></figure><p id="88eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，首先想到的可能是将<code class="fe mx my mz na b">formatCounter()</code>和<code class="fe mx my mz na b">onClick()</code>处理程序移出组件。这样，这些函数只需创建一次。</p><p id="7c9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们现在做那件事。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2e6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mx my mz na b">formatCounter()</code>函数很容易提取。它不依赖于任何特定于组件的变量或方法。</p><p id="f5d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而对于<code class="fe mx my mz na b">onClick()</code>方法来说，情况并非如此。这要看<code class="fe mx my mz na b">setCounter()</code>的方法了！</p><p id="18e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个方法没有简单的提取方法。所以它需要存在于组件<em class="nc">和</em>中，它需要被缓存，这样它就不会在每次重新渲染时被添加到内存中。</p><h1 id="8bf6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">useCallback()</h1><p id="5029" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">类似于<code class="fe mx my mz na b">useState()</code> React提供了一个名为<code class="fe mx my mz na b">useCallback()</code>的钩子。这个名字一开始可能会令人困惑(对我来说也是如此)，但是它的本质是接受一个函数和一个包含变量和/或函数的依赖数组。如果变量或函数在依赖数组中的标识改变了(浅层检查)，你将得到一个新的函数，否则你将得到一个缓存的函数。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="23d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当这个组件重新渲染时，<code class="fe mx my mz na b">onClick()</code>和<code class="fe mx my mz na b">formatCounter()</code>都不再进入内存，这很好。</p><p id="a4ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果您对这个组件进行性能测试，优化与未优化，您会看到一个非常小的差异。然而，在现实生活中的项目，有巨大的组件树，它变得至关重要的缓存事件处理程序和功能，使重新渲染尽可能快。</p><p id="e367" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设一个组件在树中有15个组件。如果这个组件由于状态变化或属性变化而重新呈现，那么这15个组件中所有未优化的函数和事件处理程序都将被再次添加到内存中。这取决于特定的情况，当用户在屏幕上打字或点击时，可能会产生抖动或口吃。简而言之，未优化的函数越积越多。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/50d153534e58d82f4936099d68eda928.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*sbuDL0pr6iFHu-O3dRzQew.gif"/></div></figure><h1 id="5fa0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">旁白:依赖数组</h1><p id="8fdf" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果您知道依赖数组及其工作原理，那么继续下一节。</p><p id="679e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于依赖数组，你需要知道的是，如果数组中任何变量/函数/数组/对象的<em class="nc">标识</em>发生变化，你会得到新的东西。在<code class="fe mx my mz na b">useCallback()</code>钩子的情况下，你将得到一个新的函数，函数中的所有东西，变量/函数/数组/对象，都将被重新初始化。</p><p id="6492" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你提供一个空数组，你将总是收到钩子第一次运行时缓存的相同内容。</p><p id="1206" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用正确的依赖关系至关重要。React上的人发布了一个linter，它会让你知道你是否遗漏了什么或者添加了一些不必要的东西。就是这里:<a class="ae nd" href="https://www.npmjs.com/package/eslint-plugin-react-hooks" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react-hooks</a>。</p><p id="3fa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您使用的是新版本的<a class="ae nd" href="https://github.com/facebook/create-react-app/" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>(版本<a class="ae nd" href="https://github.com/facebook/create-react-app/releases/tag/v3.0.0" rel="noopener ugc nofollow" target="_blank"> 3.0.0 </a>和更高版本),那么这是预安装的</p><p id="bdf4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是根据一般的经验，如果在你提供给这些优化钩子的东西里面有一些变量/函数/对象/数组(在<code class="fe mx my mz na b">useCallback()</code>是函数的情况下),那么<em class="nc">需要</em>是最新的值，那么你需要提供它作为一个依赖。后面有一个例子说明了这一点！</p><h1 id="88ac" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">还有其他优化吗？</h1><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a0c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时候，当你初始化对象，数组，和/或做一些同步的繁重工作(解析，数学计算)时，你也想优化它。在每次重新渲染时，你可以告诉React只在某些情况下做初始化/繁重的工作。</p><p id="e9e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React提供了另一个类似于<code class="fe mx my mz na b">useCallback()</code>的钩子，叫做<code class="fe mx my mz na b">useMemo()</code>。它不是采用回调函数，而是采用返回某个值的普通函数。你应该总是从这个函数返回一些东西。</p><blockquote class="ne"><p id="eb38" class="nf ng it bd nh ni nj nk nl nm nn ky dk translated"><em class="no">如果你发现自己没有从这个函数返回任何东西，你可能想要使用</em> <code class="fe mx my mz na b"><em class="no">useCallback()</em></code> <em class="no">来代替。</em></p></blockquote><p id="3f1c" class="pw-post-body-paragraph kb kc it kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">经过一些练习，这两种钩子之间的区别变得很明显。</p><p id="1c2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，<code class="fe mx my mz na b">arrayOfNames</code>是一个数组，它在组件每次重新渲染时被初始化。在这个简单的例子中，简单的解决方案是将初始化从组件中移出。然而，如果初始化依赖于组件本身，你应该使用<code class="fe mx my mz na b">useMemo()</code>钩子并以这种方式优化它。现在我们还是用<code class="fe mx my mz na b">useMemo()</code>吧。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="645d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们考虑一个例子，其中初始化<em class="nc">依赖于组件本身。</em></p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="89f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子的有趣之处在于变量<code class="fe mx my mz na b">someRandomObject</code>完全依赖于<code class="fe mx my mz na b">state</code>。如果状态改变，那么这个对象<em class="nc">将</em>改变。</p><p id="0c9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于眼尖的人来说，这个组件正在接受一个名为<code class="fe mx my mz na b">text</code>的道具，这个道具正在被归还的JSX中使用。</p><p id="43b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在想象一下，由于某种原因，道具<code class="fe mx my mz na b">text</code>改变了。会发生什么？</p><p id="8aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">组件会重新渲染，对吗？<code class="fe mx my mz na b">someRandomObject</code>会怎么样？</p><p id="5e74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是的，你猜对了。它会被重新初始化并添加到内存中。但是一定要这样吗？我们需要重新初始化它吗？当然不是。让我们使用<code class="fe mx my mz na b">useMemo()</code>钩子来优化它。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="14db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给你。你的<code class="fe mx my mz na b">someRandomObject</code>变量现在已经优化好了，可以使用了。哦，但是等等...</p><p id="78f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果状态改变(通过点击按钮)，你认为优化后的<em class="nc"/><code class="fe mx my mz na b">someRandomObject</code>会反映正确的值吗？</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f931fe2de173648391c9ec4b039bcfbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/1*I4Jinw1PaizBC3pYuQvKAg.gif"/></div></figure><p id="b4b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不，不会的。</p><p id="8732" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么？</p><blockquote class="ne"><p id="7cf9" class="nf ng it bd nh ni nj nk nl nm nn ky dk translated"><em class="no">如果在你提供给这些优化钩子的东西里面有一些变量/函数/对象/数组，</em>需要<em class="no">成为最新的值，那么你需要把它作为一个依赖项来提供。</em></p></blockquote><p id="e05a" class="pw-post-body-paragraph kb kc it kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">为了让我的<code class="fe mx my mz na b">someRandomObject</code>正确，我需要<code class="fe mx my mz na b">state</code>变量的最新值。如果我不提供<code class="fe mx my mz na b">state</code>变量作为依赖项，<code class="fe mx my mz na b">someRandomObject</code>将始终是:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4e2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是第一次在<code class="fe mx my mz na b">state</code>变量被初始化为<code class="fe mx my mz na b">true</code>后初始化该变量。之后就再也不会变了。</p><p id="cf31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们希望它在<code class="fe mx my mz na b">state</code>变量改变时更新。因此，我们只提供<code class="fe mx my mz na b">state</code>作为依赖项，一切都很好。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bdf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以现在如果组件因为除了调用<code class="fe mx my mz na b">setState()</code>函数之外的任何原因而更新(因为这是<code class="fe mx my mz na b">state</code>可以改变的唯一时间)，那么<code class="fe mx my mz na b">someRandomObject</code>将总是返回缓存的值，并且它不会每次都被添加到内存中，就像属性<code class="fe mx my mz na b">text</code>改变时一样。</p><h1 id="c1a5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">裁决</h1><p id="0ecc" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我希望您现在已经了解了<code class="fe mx my mz na b">useCallback()</code>和<code class="fe mx my mz na b">useMemo()</code>的重要性，何时使用它们，如何处理依赖数组，以及何时从组件本身中取出东西。</p><p id="2162" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我也邀请你做一个心理练习，想想这些优化是必要的可能场景。这将帮助你获得视角，并帮助你理解这些挂钩的好处。</p><p id="b8d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在你离开之前给你一个警告，不要过早的优化，因为这是所有错误的根源。首先，尽可能用最简单的方式编写组件。确保所有的测试都在运行，并且组件按预期工作。只有这样，才能继续优化。从基本的开始。</p><p id="7ffe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">优化组件中的事件处理程序和初始化。看看你能否从组件中取出一些东西。</p><p id="1cdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">优化应该是一个迭代的过程。</p><p id="ba62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">优化→检查<br/>优化→检查<br/>优化→检查<br/>。<br/>。<br/>。</p><p id="fee9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读，我希望这给你们带来了价值。我很乐意听到你的评论和你可能不同意的事情。</p><h1 id="4fdc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">更新:</h1><p id="52ed" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我在Reddit上得到一些反馈，“这篇文章没有很好地解释这实际上何时提高了性能，何时损害了性能以及过早优化的代码可读性”。</p><p id="0a4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我明白为什么有些人会这样，我想详细说明一下这一点，因为它非常重要:)</p><blockquote class="ne"><p id="7e7c" class="nf ng it bd nh ni nj nk nl nm nn ky dk translated">每一行代码都是有代价的。尝试在不进行任何优化的情况下编写代码，然后在必要的地方开始优化。</p></blockquote><p id="b4d9" class="pw-post-body-paragraph kb kc it kd b ke np kg kh ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky im bi translated">例如，在用户正在输入域中键入某些内容，而屏幕的某些其他部分需要绘画/更新的情况下。这对于简单的渲染来说可能不是问题，但是如果有很多工作要做，那么最好对它们进行优化。</p><p id="48a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们公司，我确保我们不会优化任何组件，直到出现问题，或者如果我们认为引入的功能可能会影响渲染时间。</p><p id="edfe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">人们倾向于过度优化和预优化。<br/>我邀请你去看看<br/><a class="ae nd" href="https://reacttraining.com/blog/react-inline-functions-and-performance" rel="noopener ugc nofollow" target="_blank">https://react training . com/blog/react-inline-functions-and-performance</a><br/>，Ryan Florence在这里谈到过早优化。</p><p id="4a6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">优化挂钩会占用内存。例如，它实例化一个依赖数组，然后在每次呈现时检查依赖数组中的内容是否发生了变化。这些都是正在做的工作。</p><p id="f8b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，作为开发人员，你必须决定优化挂钩的成本是高还是低。</p><p id="9400" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p></div></div>    
</body>
</html>