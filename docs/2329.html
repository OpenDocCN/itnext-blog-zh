<html>
<head>
<title>Microservices with Spring Boot and Spring Cloud. From config server to OAuth2 server (without inMemory things) — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot和春天云的微服务。从配置服务器到OAuth2服务器(没有内存内容)—第3部分</h1>
<blockquote>原文：<a href="https://itnext.io/microservices-with-spring-boot-and-spring-cloud-441e3dabc67d?source=collection_archive---------2-----------------------#2019-05-07">https://itnext.io/microservices-with-spring-boot-and-spring-cloud-441e3dabc67d?source=collection_archive---------2-----------------------#2019-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/676e58898c0f3faf44c508f888526fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCKQ5BcIvBf0fLQxl7BjNg.png"/></div></div></figure><p id="7110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们到了。我们构建了一个认证服务，负责在微服务架构中对我们的用户和客户端进行认证和授权。</p><p id="051c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将构建帐户服务，这个人负责创建用户，并将为此保存业务逻辑，因为我们不会将业务逻辑放在负责身份验证/授权的服务上。我们可能要发送帐户激活电子邮件或短信，做其他处理，所以我们将这个逻辑分开。<br/>在第三部分中，我们将学习如何使用Spring Boot和Spring Cloud创建和配置资源服务器。</p><h2 id="f7cf" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创建帐户服务项目</h2><p id="92e9" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">像往常一样，我们将使用<a class="ae lu" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>为我们生成项目，如下图所示创建它。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/e0a372e62f56fc83e62d8af43169cc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tI7KvAH7XIhayjvhwzbTIA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">生成帐户服务项目</figcaption></figure><h2 id="6dde" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">添加应用程序的配置文件</h2><p id="902f" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">将<code class="fe me mf mg mh b">application.properties</code>文件重命名为<code class="fe me mf mg mh b">bootstrap.yml</code>,并添加以下配置:</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="de36" class="kw kx iq mh b gy mm mn l mo mp">spring:<br/>  application:<br/>    name: account-service<br/>  cloud:<br/>    config:<br/>      uri: http://localhost:8888<br/>      fail-fast: true<br/>      password: 1234<br/>      username: user<br/>  main:<br/>    allow-bean-definition-overriding: true #i dont remember why but i think there is a bug with spring cloud and OAuth2ClientContext</span></pre><p id="1d43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在配置服务应用程序中，创建<code class="fe me mf mg mh b">account-service.yml</code>文件来保存授权服务的配置。</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="a6d5" class="kw kx iq mh b gy mm mn l mo mp">security:<br/>  oauth2:<br/>    client:<br/>      clientId: account-service<br/>      clientSecret: 1234<br/>      accessTokenUri: http://localhost:8081/uaa/oauth/token<br/>      grant-type: client_credentials<br/>      scope: server<br/><br/>server:<br/>  servlet:<br/>    context-path: /accounts<br/>  port: 8082<br/><br/>feign:<br/>  hystrix:<br/>    enabled: true</span></pre><p id="1ffd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道为什么创建这些文件，我推荐你阅读这篇文章的第一部分。</p><p id="0865" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开配置服务项目中的文件<code class="fe me mf mg mh b">/resources/shared/application.yml</code>，添加以下信息:</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="9cc5" class="kw kx iq mh b gy mm mn l mo mp"><em class="mq">#This configuration file will hold common configs to be shared among all files<br/></em>eureka:<br/>  instance:<br/>    prefer-ip-address: false<br/>  client:<br/>    serviceUrl:<br/>      defaultZone: http://localhost:8761/eureka/<br/><br/>security:<br/>  oauth2:<br/>    resource:<br/>      user-info-uri: http://localhost:8080/uaa/user/current<br/>      token-info-uri: <a class="ae lu" href="http://auth-service/uaa/oauth/check_token" rel="noopener ugc nofollow" target="_blank">http://</a>localhost:8080<a class="ae lu" href="http://auth-service/uaa/oauth/check_token" rel="noopener ugc nofollow" target="_blank">/uaa/oauth/check_token</a> <strong class="mh ir">#add this information</strong></span></pre><p id="cb2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个URL将从我们的资源服务器中的auth服务向我们提供我们的UserDetails实现。</p><h2 id="07db" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">添加注释</h2><p id="bba2" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们的主要客户服务类是这样的:</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="69c7" class="kw kx iq mh b gy mm mn l mo mp">@SpringBootApplication<br/>@EnableDiscoveryClient<br/>@EnableOAuth2Sso<br/>@EnableFeignClients<br/>@EnableGlobalMethodSecurity(prePostEnabled = true)<br/>public class AccountServiceApplication {<br/>    public static void main(String[] args) {<br/>        SpringApplication.<em class="mq">run</em>(AccountServiceApplication.class, args);<br/>    }<br/>}</span></pre><p id="bcde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe me mf mg mh b">@EnableOAuth2Sso</code>将在一个使用Spring Security的web应用程序中为OAuth2客户端启用配置，并希望使用来自我们的auth-service的授权代码授权，并创建一个所有路径都安全的<code class="fe me mf mg mh b">WebSecurityConfigurerAdapter</code>。并且<code class="fe me mf mg mh b">@EnableFeignClients</code>扫描声明它们为假客户端的接口。</p><h2 id="8b3d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">配置资源服务器</h2><p id="fbb0" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">用以下内容创建一个名为<code class="fe me mf mg mh b">ResourceServerConfig</code>的类:</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="ef7d" class="kw kx iq mh b gy mm mn l mo mp">@Configuration<br/>@EnableResourceServer<br/>public class ResourceServerConfig extends ResourceServerConfigurerAdapter {<br/><br/>    private final ResourceServerProperties sso;<br/><br/>    private final OAuth2ClientContext oAuth2ClientContext;<br/><br/>    @Autowired<br/>    public ResourceServerConfig(ResourceServerProperties sso, OAuth2ClientContext oAuth2ClientContext) {<br/>        this.sso = sso;<br/>        this.oAuth2ClientContext = oAuth2ClientContext;<br/>    }<br/><br/>    @Bean<br/>    @ConfigurationProperties(prefix = "security.oauth2.client")<br/>    public ClientCredentialsResourceDetails clientCredentialsResourceDetails() {<br/>        return new ClientCredentialsResourceDetails();<br/>    }<br/><br/>    @Bean<br/>    public RequestInterceptor oauth2FeignRequestInterceptor() {<br/>        return new OAuth2FeignRequestInterceptor(oAuth2ClientContext, clientCredentialsResourceDetails());<br/>    }<br/><br/>    @Bean<br/>    public OAuth2RestOperations restTemplate(OAuth2ClientContext oauth2ClientContext) {<br/>        return new OAuth2RestTemplate(clientCredentialsResourceDetails(), oauth2ClientContext);<br/>    }<br/><br/>    @Bean<br/>    @Primary<br/>    public ResourceServerTokenServices resourceServerTokenServices() {<br/>        return new UserInfoTokenServices(sso.getUserInfoUri(), sso.getClientId());<br/>    }<br/><br/>    @Override<br/>    public void configure(HttpSecurity http) throws Exception {<br/>        http.authorizeRequests()<br/>                .antMatchers(HttpMethod.<em class="mq">POST</em>, "/").permitAll()<br/>                .antMatchers(HttpMethod.<em class="mq">OPTIONS</em>, "/").permitAll()<br/>                .anyRequest().authenticated();<br/>    }<br/>}</span></pre><p id="8871" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个类中，我们配置我们的资源服务器来允许任何POST请求到<code class="fe me mf mg mh b">/accounts/</code>路径，因为想要创建新帐户的人没有登录。任何其他请求都需要进行身份验证。<br/>此外，我们正在配置Feign使用一个<a class="ae lu" href="https://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/client/OAuth2RestTemplate.html" rel="noopener ugc nofollow" target="_blank"> OAuh2RestTemplate </a>来发出认证请求。</p><h2 id="4e01" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">在授权服务中插入帐户服务客户端详细信息</h2><p id="d719" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">由于我们正在创建另一个微服务，我们需要将其注册为我们的auth服务的客户端。<br/>打开auth service项目上的<code class="fe me mf mg mh b">InitialValuesChangeLog</code>类，添加另一个<code class="fe me mf mg mh b">ChangeSet</code>。</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="a29e" class="kw kx iq mh b gy mm mn l mo mp">@ChangeSet(order = "003", id = "insertAccountServiceClientDetails", author = "Marcus Hert Da Corégio")<br/>public void insertAccountServiceClientDetails(MongoTemplate mongoTemplate) {<br/>    AuthClientDetails accountServiceClientDetails = new AuthClientDetails();<br/>    accountServiceClientDetails.setClientId("account-service");<br/>    accountServiceClientDetails.setClientSecret("$2a$10$fWNTd3H.u7G/aNROVQSifebOkZ2xzU5nUPOCI2Ld42M8E25/ljJqK");<br/>    accountServiceClientDetails.setScopes("server");<br/>    accountServiceClientDetails.setGrantTypes("refresh_token,client_credentials");<br/><br/>    mongoTemplate.save(accountServiceClientDetails);<br/>}</span></pre><p id="58e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它与<strong class="ka ir">浏览器</strong>客户端几乎相同，但具有不同的<a class="ae lu" href="https://oauth.net/2/scope/" rel="noopener ugc nofollow" target="_blank">范围</a>和<a class="ae lu" href="https://oauth.net/2/grant-types/" rel="noopener ugc nofollow" target="_blank">授权类型</a>。</p><h2 id="c6d0" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">在身份验证服务中创建用户端点</h2><p id="881c" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在这里，我将向您列出需要对认证服务进行的更改。我不会把代码放在这里，因为它会变得太乱，相反，我会在资源库中附加类的链接。</p><ul class=""><li id="8469" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/AuthServiceApplication.java" rel="noopener ugc nofollow" target="_blank">在auth service主类</a>上添加 <code class="fe me mf mg mh b"><a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/AuthServiceApplication.java" rel="noopener ugc nofollow" target="_blank">@EnableResourceServer</a></code> <a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/AuthServiceApplication.java" rel="noopener ugc nofollow" target="_blank">注释。</a></li><li id="2f98" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">创建<a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/service/UserService.java" rel="noopener ugc nofollow" target="_blank">用户服务接口</a>及其<a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/service/UserServiceImpl.java" rel="noopener ugc nofollow" target="_blank">实现</a>。</li><li id="8f2c" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">为<a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/dto/UserRegistrationDto.java" rel="noopener ugc nofollow" target="_blank">用户注册</a>和<a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/dto/UserDto.java" rel="noopener ugc nofollow" target="_blank">返回用户</a>创建<a class="ae lu" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> DTO </a>。</li><li id="3726" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">创建用于处理HTTP请求的<a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot/blob/master/auth-service/src/main/java/com/marcusdacoregio/authservice/controller/UserController.java" rel="noopener ugc nofollow" target="_blank">用户控制器</a>。</li></ul><p id="fb25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这手牌，我们就可以转向客户服务了。如果你对此有任何问题，欢迎在评论区问我。</p><h2 id="a772" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创建虚拟客户端</h2><p id="eaf6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">现在的问题是，我们如何从帐户服务向auth service发出请求？为此，我们使用了<a class="ae lu" href="https://spring.io/projects/spring-cloud-openfeign" rel="noopener ugc nofollow" target="_blank"> Feign </a>，这是一个Java到HTTP的客户端绑定器，它使得为我们的服务之间的通信创建接口变得容易。</p><p id="a6c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始创建<code class="fe me mf mg mh b">AuthServiceFeignClient</code>接口。</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="53e6" class="kw kx iq mh b gy mm mn l mo mp">import com.marcusdacoregio.accountservice.dto.UserDto;<br/>import com.marcusdacoregio.accountservice.dto.UserRegistrationDto;<br/>import org.springframework.cloud.openfeign.FeignClient;<br/>import org.springframework.web.bind.annotation.PostMapping;<br/>import org.springframework.web.bind.annotation.RequestBody;<br/><br/>@FeignClient(name = "auth-service")<br/>public interface AuthServiceFeignClient {<br/><br/>    @PostMapping(value = "/uaa/user")<br/>    UserDto createUser(@RequestBody UserRegistrationDto user);<br/><br/>}</span></pre><p id="64a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe me mf mg mh b">@FeignClient</code>是一个接口注释，声明应该创建一个带有该接口的REST客户机。我们作为值传递的名称是在我们的注册表服务上注册的微服务的名称，这样我们就不需要使用我们在微服务环境中不知道的IP地址。</p><p id="4428" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经从auth service复制了dto，但是您可以创建一个子模块auth service，将dto放在其中，并作为account service的依赖项添加。</p><p id="cfe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建<code class="fe me mf mg mh b">AccountService</code>接口及其实现。</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="bcbf" class="kw kx iq mh b gy mm mn l mo mp">public interface AccountService {<br/><br/>    <em class="mq">/**<br/>     * Invokes Auth Service user creation<br/>     *<br/>     * </em><strong class="mh ir"><em class="mq">@param </em></strong><em class="mq">user<br/>     * </em><strong class="mh ir"><em class="mq">@return </em></strong><em class="mq">created account<br/>     */<br/>    </em>UserDto create(UserRegistrationDto user);<br/>}</span></pre></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><pre class="mi mh mj mk aw ml bi"><span id="9762" class="kw kx iq mh b gy nm nn no np nq mn l mo mp">@Service<br/>public class AccountServiceImpl implements AccountService {<br/><br/>    private final AuthServiceFeignClient authServiceFeignClient;<br/><br/>    public AccountServiceImpl(AuthServiceFeignClient authServiceFeignClient) {<br/>        this.authServiceFeignClient = authServiceFeignClient;<br/>    }<br/><br/>    @Override<br/>    public UserDto create(UserRegistrationDto user) {<br/>        return authServiceFeignClient.createUser(user);<br/>    }<br/>}</span></pre><p id="2ecc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和我们的控制器来处理请求:</p><pre class="lw lx ly lz gt mi mh mj mk aw ml bi"><span id="3dfc" class="kw kx iq mh b gy mm mn l mo mp">@RestController<br/>public class AccountController {<br/><br/>    private final AccountService accountService;<br/><br/>    public AccountController(AccountService accountService) {<br/>        this.accountService = accountService;<br/>    }<br/><br/>    @PostMapping<br/>    public UserDto createNewAccount(@RequestBody UserRegistrationDto user) {<br/>        return accountService.create(user);<br/>    }<br/><br/>}</span></pre><h2 id="014e" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">测试我们所做的</h2><p id="36c1" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">好了，打开<a class="ae lu" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>让我们做一个请求，测试一下东西是否工作。</p><p id="c34a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用用户名和密码主体向<code class="fe me mf mg mh b">http://localhost:8080/accounts/</code>创建POST请求:</p><h1 id="c54e" class="nr kx iq bd ky ns nt nu lb nv nw nx le ny nz oa lh ob oc od lk oe of og ln oh bi translated">请注意这个请求，因为它在URI<a class="ae lu" href="http://localhost:8080/accounts/" rel="noopener ugc nofollow" target="_blank"><em class="oi">http://localhost:8080/accounts</em><strong class="ak"><em class="oi">/</em></strong></a>的末尾有一个额外的斜线</h1><p id="883d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">如果你试图在没有斜线的上下文路径中做一个POST请求，比如<strong class="ka ir"> /uaa </strong>或者<strong class="ka ir"> /accounts </strong>，它将会失败，错误消息也不会很清楚(我仍然没有弄清楚为什么)。感谢乔治提醒我这件事！</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e406e57f757f135f029bd53f5367ef15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUZ1nV27i4gfsjhFW5qTiQ.png"/></div></div></figure><p id="4d85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切正常。如果您尝试使用相同的用户名创建一个新用户，您将会收到一条难看的响应消息，如下所示:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/137c8b25dd80af6fc8a0e3430728d36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dn1wFnl12ilE5zfKexEqg.png"/></div></div></figure><p id="8c8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为我们在auth服务上抛出的异常并没有映射到一个<a class="ae lu" href="https://www.baeldung.com/spring-response-entity" rel="noopener ugc nofollow" target="_blank"> ResponseEntity </a>之类的东西，而且Feign不知道如何处理另一个服务抛出的异常。我们可以使用<code class="fe me mf mg mh b"><a class="ae lu" href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc" rel="noopener ugc nofollow" target="_blank">@ExceptionHandler</a></code>注释来实现这一点。我会把这个作为你的家庭作业。</p><p id="6b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过创建此用户来请求令牌，以查看这是否有效并获得访问令牌。如果你不知道如何做到这一点，请查看本文的第二部分。</p><p id="d19a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以用这样的授权头向<code class="fe me mf mg mh b">http://localhost:8080/uaa/user/current</code>发出GET请求:<em class="mq"> Bearer your_access_token。</em></p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/4a27fc246c155638e081e8dbce67f6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXXumafyq5PZoQ0ZFCVX5A.png"/></div></div></figure><h2 id="dd6c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="bd65" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有什么问题随时和我分享，我想我什么都没忘。该代码可在<a class="ae lu" href="https://github.com/marcusdacoregio/oauth2-spring-boot" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。同样检查本条的第<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/microservices-with-spring-boot-and-spring-cloud-16d2c056ba12">第</a>和第<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/microservices-with-spring-boot-and-spring-cloud-20f689b17fc7">第二部分</a>。</p></div></div>    
</body>
</html>