<html>
<head>
<title>How to use patterns mediator and dataprovider with REST Assured.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何放心使用模式中介器和数据提供器？</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-patterns-mediator-and-dataprovider-with-rest-assured-d430ffcfb137?source=collection_archive---------2-----------------------#2019-11-01">https://itnext.io/how-to-use-patterns-mediator-and-dataprovider-with-rest-assured-d430ffcfb137?source=collection_archive---------2-----------------------#2019-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bfa564233c3860908aa51e052f706b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fbes4ES-c2GDXM3jbMFCvA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Artem Sapegin 在<a class="ae kc" href="https://unsplash.com/@sapegin" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="23b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> T </span>控制器方法本质上是一种实现中介模式的方法。也叫介体。</p><p id="c0df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">中介模式是一种行为设计模式，它允许您通过将这些关系转移到一个中间类来减少许多类之间的连接。中介模式使得对象之间不直接通信，而是通过一个独立的中介对象进行通信，该中介对象知道将特定的请求重定向给谁。正因为如此，系统的组件将只依赖于中介，而不依赖于许多其他组件。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/38febc77877fb171c43a56936e96ce85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gW7oSwVq6yHnaaAt1C7jkQ.png"/></div></div></figure><p id="43b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，主要目的是控制任何设施或油田的资源和转移。<br/>因此，中介器隐藏了程序的各个组件的类之间的所有复杂关系和依赖性。类的关系越少，修改、扩展和重用它们就越容易。</p><p id="6cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">示例</strong>:</p><p id="5ae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">降落或起飞飞机的飞行员不与其他飞行员直接沟通。相反，他们与调度员交流，调度员同时协调几架飞机的行动。如果没有控制器，飞行员将不得不时刻保持警惕，并独自监控周围的所有飞机，这将导致天空中频繁发生灾难。<br/>了解在整个飞行过程中不需要控制器是很重要的。它只涉及机场的区域，当你需要协调许多飞机的相互作用时。</p><p id="b194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">P  ros:</p><ul class=""><li id="e18b" class="lp lq iq kf b kg kh kk kl ko lr ks ls kw lt la lu lv lw lx bi translated">消除组件之间的依赖关系，允许它们被重用。</li><li id="ac0c" class="lp lq iq kf b kg ly kk lz ko ma ks mb kw mc la lu lv lw lx bi translated">简化组件之间的交互。</li><li id="3ec3" class="lp lq iq kf b kg ly kk lz ko ma ks mb kw mc la lu lv lw lx bi translated">将管理集中在一个地方。</li></ul><p id="1880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> C </span> ons:</p><ul class=""><li id="6f93" class="lp lq iq kf b kg kh kk kl ko lr ks ls kw lt la lu lv lw lx bi translated">中间人可以膨胀很多。</li></ul><p id="aa81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们结合放心考虑中介模式的实现。<br/>最初，我们需要为模型创建一个控制器。<br/>在该控制器中，将有执行一些操作的方法。本质上，如果我们谈论一个已经实现了方法<strong class="kf ir"> GET、POST、PUT、UPDATE、OPTIONS、DELETE </strong>等的标准化资源，他们将对资源执行操作。在一个课程中，将会有这些方法的便捷操作。</p><p id="ac3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，我们创建了一个与模型和资源一起工作的中介。</p><p id="bef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">创建控制器类:</strong></p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="2ffe" class="mi mj iq me b gy mk ml l mm mn"><strong class="me ir">public class </strong>Controller {</span><span id="c9ad" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">public </strong>Model addNew(Model newModel) {<br/>        <strong class="me ir">return </strong><em class="mp">given</em>().body().when().post().as(Model.<strong class="me ir">class</strong>);<br/>    }<br/>}</span></pre><p id="7f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将拥有的型号是<strong class="kf ir">型号</strong>，因为我们想得到回应并测试它。</p><p id="87cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子实现了一个将方法反序列化为模型的方法。</p><p id="597f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在控制器的参与下，我们还可以重新配置测试的基本设置。</p><p id="a9bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，这样的设置或者在控制器本身中进行，或者在抽象控制器类中进行。</p><p id="0be3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">示例控制器:</strong></p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="609a" class="mi mj iq me b gy mk ml l mm mn"><strong class="me ir">public class </strong>Controller {</span><span id="63fa" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">private </strong>RequestSpecification <strong class="me ir">requestSpecification</strong>;<br/>    <strong class="me ir">private </strong>Model <strong class="me ir">model</strong>;</span><span id="39e3" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">public </strong>Controller(Model testModel) {<br/>        <strong class="me ir">requestSpecification </strong>= <strong class="me ir">new </strong>RequestSpecBuilder()<br/>                .addHeader(<strong class="me ir">"Content-type"</strong>, <strong class="me ir">"application/json; charset=UTF-8"</strong>)<br/>                .setBaseUri(<strong class="me ir">"some base url"</strong>)<br/>                .setBasePath(<strong class="me ir">"some base path"</strong>)<br/>                .setContentType(ContentType.<strong class="me ir"><em class="mp">JSON</em></strong>)<br/>                .log(LogDetail.<strong class="me ir"><em class="mp">ALL</em></strong>).build();<br/>        RestAssured.<em class="mp">responseSpecification </em>= <strong class="me ir">new </strong>ResponseSpecBuilder()<br/>                .expectContentType(ContentType.<strong class="me ir"><em class="mp">JSON</em></strong>)<br/>                .expectResponseTime(Matchers.<em class="mp">lessThan</em>(15000L))<br/>                .build();<br/>        RestAssured.<em class="mp">defaultParser </em>= Parser.<strong class="me ir"><em class="mp">JSON</em></strong>;<br/>        <strong class="me ir">this</strong>.<strong class="me ir">model </strong>= testModel;<br/>    }<br/>}</span></pre><p id="41a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">抽象控制器的例子:</strong></p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="5785" class="mi mj iq me b gy mk ml l mm mn"><strong class="me ir">public abstract class </strong>AbstractController {<br/></span><span id="726f" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">static </strong>{<br/>        RestAssured.<em class="mp">requestSpecification </em>= <strong class="me ir">new </strong>RequestSpecBuilder()<br/>                .addHeader(<strong class="me ir">"Content-type"</strong>, <strong class="me ir">"application/json; charset=UTF-8"</strong>)<br/>                .setBaseUri(<strong class="me ir">"some base url"</strong>)<br/>                .setContentType(ContentType.<strong class="me ir"><em class="mp">JSON</em></strong>)<br/>                .log(LogDetail.<strong class="me ir"><em class="mp">ALL</em></strong>).build();</span><span id="b153" class="mi mj iq me b gy mo ml l mm mn">        RestAssured.<em class="mp">responseSpecification </em>= <strong class="me ir">new </strong>ResponseSpecBuilder()<br/>                .expectContentType(ContentType.<strong class="me ir"><em class="mp">JSON</em></strong>)<br/>                .expectResponseTime(Matchers.<em class="mp">lessThan</em>(15000L))<br/>                .build();<br/>        RestAssured.<em class="mp">defaultParser </em>= Parser.<strong class="me ir"><em class="mp">JSON</em></strong>;<br/>    }<br/>}</span></pre><p id="9c35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">自动化脚本如下所示:</strong></p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="bd4c" class="mi mj iq me b gy mk ml l mm mn">@Test(description = "The automation script for added new model")<br/><strong class="me ir">public void </strong>testAddNew(){<br/>        Model model=<strong class="me ir">new </strong>Model();<br/>        Controller controller=<strong class="me ir">new </strong>Controller(model);<br/>        controller.addNewElement(model);</span></pre><p id="2eaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">使用@DataProvider进行测试。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/5f685e516bdda8c6c0ee3fcbbf091340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n54e44_JhvFQY4LlDQocpQ.png"/></div></div></figure><p id="a627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在测试中，经常需要对不同的数据集进行操作。在某些情况下，数据可能是甜言蜜语，一些来自外部来源的阻力。在大多数情况下，对于代码优化和参数化，我使用数据驱动。</p><p id="2dc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试中一个很重要的功能就是实现数据驱动。数据驱动允许您使用不同的数据集多次运行相同的测试方法。</p><p id="6998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在framework TestNG中，这个功能是使用<code class="fe mr ms mt me b">dataProvider</code>实现的。在JUnit <code class="fe mr ms mt me b">Parameterized.class</code></p><p id="c9a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在测试中使用DataProvider函数，您必须用<a class="ae kc" href="http://twitter.com/DataProvider" rel="noopener ugc nofollow" target="_blank"> @DataProvider </a>注释声明一个方法，然后在测试方法中使用test注释中的“DataProvider”属性来使用该方法。</p><p id="ddaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们就当是个例子<a class="ae kc" href="https://restcountries.eu/" rel="noopener ugc nofollow" target="_blank">https://rest countries . eu</a></p><p id="326b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有法<a class="ae kc" href="https://restcountries.eu/rest/v2/aplha/{CODE" rel="noopener ugc nofollow" target="_blank">https://restcountries.eu/rest/v2/aplha/{<strong class="kf ir">C</strong>T25】颂}</a></p><p id="79d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">代码— </strong>这是端点。<strong class="kf ir"> </strong>按ISO 3166搜索–1个2个字母或3个字母的国家代码。</p><p id="9891" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自动化脚本的示例代码可能如下所示:</p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="0c79" class="mi mj iq me b gy mk ml l mm mn">@Test(dataProvider = <strong class="me ir">"verifyCountry"</strong>, dataProviderClass = DataProviders.<strong class="me ir">class</strong>)<br/><strong class="me ir">public void </strong>testRequestWithSeveralCountries(String name, String alpha2Code, String alpha3Code) {</span><span id="7f71" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">final </strong>String resultApiJson = getAllCountry(GET_ALPHA_CODE, alpha2Code);<br/>    <strong class="me ir">final </strong>ApiJson apiJson = ApiJson.from(resultApiJson);<br/>    <strong class="me ir">final </strong>CountryCode result = apiJson.getCountryCode();</span><span id="e44a" class="mi mj iq me b gy mo ml l mm mn">    assertEquals(result.getName(), name);<br/>    assertEquals(result.getAlpha2Code(), alpha2Code);<br/>    assertEquals(result.getAlpha3Code(), alpha3Code);<br/>}</span></pre><p id="2c3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法<strong class="kf ir"> getAllCountry </strong>可能如下所示:</p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="2bca" class="mi mj iq me b gy mk ml l mm mn"><em class="mp">/**<br/> * Country get all country with alpha2code request string.<br/> *<br/> * </em><strong class="me ir"><em class="mp">@param url        </em></strong><em class="mp">the url.<br/> * </em><strong class="me ir"><em class="mp">@param alpha2Code </em></strong><em class="mp">alpha2Code value.<br/> * </em><strong class="me ir"><em class="mp">@return </em></strong><em class="mp">the string<br/> */<br/></em><strong class="me ir">public static </strong>String getAllCountry(<strong class="me ir">final </strong>String url, <strong class="me ir">final </strong>String alpha2Code) {<br/>    <strong class="me ir">final </strong>String json = RestAssured<br/>            .given()<br/>            .then()<br/>            .statusCode(SUCCESS)<br/>            .log().all().when().get(url + alpha2Code).getBody().asString();</span><span id="64be" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">return </strong>json;<br/>}</span></pre><p id="291a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法<strong class="kf ir"> ApiJson </strong>可能如下所示:</p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="8859" class="mi mj iq me b gy mk ml l mm mn"><em class="mp">/**<br/> * From api json.<br/> *<br/> * </em><strong class="me ir"><em class="mp">@param json </em></strong><em class="mp">the json<br/> * </em><strong class="me ir"><em class="mp">@return </em></strong><em class="mp">the api json<br/> */<br/></em><strong class="me ir">public static </strong>ApiJson from(<strong class="me ir">final </strong>String json) {<br/>    <strong class="me ir">return new </strong>ApiJson(json);<br/>}<br/><em class="mp">/**<br/> * Gets country.<br/> *<br/> * </em><strong class="me ir"><em class="mp">@return </em></strong><em class="mp">the post<br/> */<br/></em><strong class="me ir">public </strong>CountryCode getCountryCode() {</span><span id="e352" class="mi mj iq me b gy mo ml l mm mn">    <strong class="me ir">return </strong>jsonPath.getObject(JSON_PATH, CountryCode.<strong class="me ir">class</strong>);<br/>}</span></pre><p id="e95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成后的类<strong class="kf ir"> ContryCode </strong>如下所示:</p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="3a34" class="mi mj iq me b gy mk ml l mm mn">@Generated(<strong class="me ir">"com.robohorse.robopojogenerator"</strong>)<br/>    <strong class="me ir">public class </strong>CountryCode{<br/>        ..........<br/>        <strong class="me ir">public </strong>List&lt;CurrenciesItem&gt; getCurrencies(){<br/>            <strong class="me ir">return </strong>currencies;<br/>        }<br/>    }</span></pre><p id="6e82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过@ <strong class="kf ir"> DataProvider </strong>得到的测试参数如下所示:</p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="7b01" class="mi mj iq me b gy mk ml l mm mn"><em class="mp">/**<br/> * Verify country object [ ] [ ].<br/> *<br/> * </em><strong class="me ir"><em class="mp">@return </em></strong><em class="mp">the object [ ] [ ]<br/> */<br/></em>@DataProvider(name = <strong class="me ir">"verifyCountry"</strong>)<br/><strong class="me ir">public static </strong>Object[][] verifyCountry() {<br/>    <strong class="me ir">return new </strong>Object[][]{<br/>            {<strong class="me ir">"Estonia"</strong>, <strong class="me ir">"EE"</strong>, <strong class="me ir">"EST"</strong>},<br/>            {<strong class="me ir">"Germany"</strong>, <strong class="me ir">"DE"</strong>, <strong class="me ir">"DEU"</strong>},<br/>            {<strong class="me ir">"Afghanistan"</strong>, <strong class="me ir">"AF"</strong>, <strong class="me ir">"AFG"</strong>}<br/>    };<br/>}</span></pre><p id="b8a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，测试方法运行了3次。测试方法运行的次数取决于DataProvider方法提供的数据集的数量。在我们的例子中，这个方法分别返回了3组数据，测试方法被执行了三次。</p><p id="0fe8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">重要的</strong>！DataProvider方法应该以对象类的二维数组的形式返回数据(Object[][])。第一个数组是一组数据，第二个数组包含参数值。</p><p id="a9b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">dataProvider的大减号是Object[][]。鉴于我们生活在2018年，用支持Stream API并且有很好的集合API的Java 8写。二维数组的对象并不严重。它仍然接受和编写不正确的代码。</p><p id="58fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但事实上，这种情况可以在<a class="ae kc" href="https://github.com/sskorol/test-data-supplier" rel="noopener ugc nofollow" target="_blank">测试数据供应商</a>库的帮助下得到纠正。它的作者是谢尔盖·科罗尔。</p><p id="deb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一下，如果您可以使用下面的语法来提供一些过滤和排序的数据到测试方法的签名中:</p><pre class="ll lm ln lo gt md me mf mg aw mh bi"><span id="2a95" class="mi mj iq me b gy mk ml l mm mn">@DataSupplier<br/><strong class="me ir">public </strong>Stream&lt;User&gt; getData() {<br/>    <strong class="me ir">return </strong>Stream.of(<br/>            <strong class="me ir">new </strong>User(<strong class="me ir">"Petya"</strong>, <strong class="me ir">"password2"</strong>),<br/>            <strong class="me ir">new </strong>User(<strong class="me ir">"Virus Petya"</strong>, <strong class="me ir">"password3"</strong>),<br/>            <strong class="me ir">new </strong>User(<strong class="me ir">"Mark"</strong>, <strong class="me ir">"password1"</strong>))<br/>            .filter(u -&gt; !u.getName().contains(<strong class="me ir">"Virus"</strong>))<br/>            .sorted(comparing(User::getPassword));<br/>}<br/><br/>@Test(dataProvider = <strong class="me ir">"getData"</strong>)<br/><strong class="me ir">public void </strong>shouldSupplyStreamData(<strong class="me ir">final </strong>User user) {<br/>    <em class="mp">// ...<br/></em>}</span></pre><p id="d72e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比二维数组或者迭代器好的多，灵活的多，不是吗？</p></div></div>    
</body>
</html>