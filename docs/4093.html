<html>
<head>
<title>Swagger java annotations in action.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大摇大摆的java注释。</h1>
<blockquote>原文：<a href="https://itnext.io/generate-api-docs-clients-server-code-using-swagger-java-annotations-f25ad69e00be?source=collection_archive---------1-----------------------#2020-04-26">https://itnext.io/generate-api-docs-clients-server-code-using-swagger-java-annotations-f25ad69e00be?source=collection_archive---------1-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3aa1df56e997ed69a9e402a00b9e6366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2tQEcKBRGeTQBk9KcU3SA.jpeg"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="214f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">gRPC，JSON，或者graphQL？每种方法都有其优点，JSON RESTful API是最简单、最古老和最常用的。然而，它的简单是有代价的。与REST API集成需要手动编写客户端代码，这需要进行测试。由于需要启动/停止web服务器，测试往往会变得很慢。此外，设计RESTful APIs有一些惯例和指导原则，一旦你破坏了一个惯例(例如，错误地在路径中包含了一个动词)并发布到产品中，改变它将需要破坏向后兼容性，这一点都不好玩。正因为如此。在实现之前审查设计好的API是这个过程中的一个重要步骤。然而，编写可以手动审查的API文档是乏味的，并且记住在每次更改时更新它们是徒劳的。</p><p id="7eeb" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi ld translated"><span class="l le lf lg bm lh li lj lk ll di"> O </span> <a class="ae lm" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> penApi </a>原名Swagger，试图通过从Api描述文件中生成api文档、客户端甚至模拟web服务器来解决这些问题并改善API用户的开发体验。然而，这个文件很快变得巨大而复杂。即使使用swagger-editor编辑它也是一件痛苦的事情，尤其是对于大型项目。</p><p id="cb27" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">OpenApi倡议的子项目，<a class="ae lm" href="https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations" rel="noopener ugc nofollow" target="_blank"> Swagger 2。X Annotations </a>使用反射从代码中生成OpenApi定义。带注释的类、值对象、方法和参数被用作swagger生成器的输入。输出是一个swagger定义文件，它可以用来生成客户机/服务器代码和API文档。让我们看一个例子。</p><h1 id="6125" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">服务定义</h1><ul class=""><li id="a299" class="ml mm iq kh b ki mn km mo kq mp ku mq ky mr lc ms mt mu mv bi translated"><code class="fe mw mx my mz b">GET /bananas/{id}</code></li><li id="f9b0" class="ml mm iq kh b ki na km nb kq nc ku nd ky ne lc ms mt mu mv bi translated"><code class="fe mw mx my mz b">POST /bananas</code></li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">简单的服务定义</figcaption></figure><p id="4866" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">没有依赖或框架。与HTTP头、路径参数或解析/编码请求/响应体无关。</p><p id="b177" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">请注意与gRPC服务定义的相似之处。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">gRPC服务定义</figcaption></figure><p id="15b1" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">Google protocol buffers编译器可以生成客户端和服务器代码，也可以使用<a class="ae lm" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> gRPC-gateway </strong> </a>以及一些protobuf注释来生成RESTful API桥甚至swagger定义。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">用google.api.http注释的rpc定义</figcaption></figure><p id="dc4b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">上面的比较只是为了强调从描述文件中生成客户机/服务器代码的思想。Swagger和gRPC的一个很好的对比可以在<a class="ae lm" href="https://medium.com/apis-and-digital-transformation/openapi-and-grpc-side-by-side-b6afb08f75ed" rel="noopener"> <strong class="kh ir">这里</strong> </a>。</p><h1 id="e0a8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">作为代码/ Swagger注释的API描述</h1><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">夸张的注释</figcaption></figure><p id="71f4" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这是我们在帖子开头定义的服务，用openApi注释进行了注释。它几乎被注释隐藏了，它们很冗长，可能会让不熟悉的读者感到困惑。但是，另一种方法是手动管理Swagger.yaml，这种方法更糟糕。</p><p id="06d2" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">开发人员已经习惯了IDE。代码完成、语法突出显示、代码格式化、代码折叠、快速导航、快速检查以及调用这些功能的键盘快捷键，极大地简化了注释服务的过程。此外，用反射扫描值对象和函数参数，如果它们改变，生成的API定义将自动改变。此外，swagger annotations项目有很好的文档记录，为了理解任何注释的角色，只需要“步入”它的定义并阅读它的javadoc注释。</p><h1 id="47d6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">生成Swagger定义(swagger.json)</h1><p id="9022" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated">为了生成Swagger定义，我们需要运行一个gradle任务。这里有一个完整的工作示例<a class="ae lm" href="https://github.com/viggin543/swagger/tree/master/bananas-service" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d1d6" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">本质上，Gradle配置使用了<a class="ae lm" href="https://github.com/swagger-api/swagger-core/tree/master/modules/swagger-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> swagger-gradle插件</a>，并且有一个任务需要配置。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">梯度构型</figcaption></figure><p id="3d92" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">通过运行<code class="fe mw mx my mz b">./gradle resolve</code>，插件将扫描<strong class="kh ir"> com.banana </strong>包，寻找用<code class="fe mw mx my mz b">@Path</code>注释标注的类，并生成<code class="fe mw mx my mz b">src/open-api/BananaAPI.json</code>。上面的例子只为两个简单的API端点生成了一个100行的JSON文件。</p><h1 id="d7c8" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">生成API文档</h1><blockquote class="ns nt nu"><p id="ac45" class="kf kg nv kh b ki kj kk kl km kn ko kp nw kr ks kt nx kv kw kx ny kz la lb lc ij bi translated"><em class="iq">Redoc——终于有了值得你骄傲的API文档。</em></p></blockquote><p id="97a3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">Redoc是一个从swagger定义中生成漂亮的静态api文档的工具。</p><p id="0c5e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">它的安装和使用非常简单:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/3fc295cbe42846bf800df8adb81c22a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8XlLUbBizQVNp2Nt2710A.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">安装redoc</figcaption></figure><p id="bcae" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这将生成如下所示的index.html文件:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/a8cb7ed0530f52475b89025b41d026e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UigY8TWForI2j1SLd9BGNQ.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">redoc文档</figcaption></figure><p id="85f5" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这些文档有深度链接、搜索、代码片段和其他很酷的功能。</p><h1 id="7111" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">生成客户端/服务器代码</h1><ul class=""><li id="1f9c" class="ml mm iq kh b ki mn km mo kq mp ku mq ky mr lc ms mt mu mv bi translated">使用swagger-cli</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">运行swagger代码生成</figcaption></figure><ul class=""><li id="e86b" class="ml mm iq kh b ki kj km kn kq ob ku oc ky od lc ms mt mu mv bi translated">使用<a class="ae lm" href="https://github.com/swagger-api/swagger-editor" rel="noopener ugc nofollow" target="_blank"> Swagger-Editor docker图像</a></li></ul><pre class="nf ng nh ni gt oe mz of og aw oh bi"><span id="dfb2" class="oi lo iq mz b gy oj ok l ol om">docker run -d -p 8089:8080 -e URL=/foo/BananaApi.json -v /Users/…/personal_projects/open_api_java_annotations/open-api/:/usr/share/nginx/html/foo swaggerapi/swagger-editor</span></pre><p id="e03f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">将启动一个装载了swagger定义文件的swagger编辑器容器。在<a class="ae lm" href="http://localhost:8089/" rel="noopener ugc nofollow" target="_blank"> localhost:8089/ </a>上打开浏览器，将显示编辑器UI。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/275bae73c18bef2a74c8d7b0bfa16a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CB4_o-st1JyIfFXEIrY5_w.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">招摇的编辑</figcaption></figure><p id="6274" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">可以使用这个UI生成代码，但是单击generate按钮将发出下面的HTTP请求:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">使用swagger公共api生成</figcaption></figure><p id="def5" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">swagger公共API，它接受JSON swagger定义文件作为输入，并返回包含生成的项目的zip文件。</p><h1 id="a085" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">生成的客户端示例用法(kotlin+vert.x)</h1><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">java客户端示例</figcaption></figure><h1 id="6c60" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">服务器存根生成</h1><p id="49fb" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated">gRPC优于openAPI的一大优势是，open API不仅需要支持几乎所有可能的语言，甚至Rust和Huskel。而且每个web框架都是如此，这是一个不可能的任务，因为框架总是在变化。另外，swagger不支持增量更新，所以一旦你更新了你的API。例如通过添加路线。虚张声势只能再次产生整个事情。解决这个问题的唯一方法是git将新生成的代码与主分支(包含以前的版本)合并，在我看来，所有这些努力都不值得。此外，自从我们编写值对象并对它们进行注释以来，已经完成了一半的工作。</p><h1 id="6ff7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">关于项目结构的一个注释</h1><p id="3b3d" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated">以上所有代码都可以在这里找到，这是一个gradle多<a class="ae lm" href="https://github.com/viggin543/swagger" rel="noopener ugc nofollow" target="_blank">项目</a>的例子。遵循鲍勃大叔在他的<a class="ae lm" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">清洁建筑</a>博客帖子中的指导方针。它有三个子项目</p><ul class=""><li id="d4fd" class="ml mm iq kh b ki kj km kn kq ob ku oc ky od lc ms mt mu mv bi translated">bananas-service(一个包含服务定义和swagger注释的库项目)</li><li id="7295" class="ml mm iq kh b ki na km nb kq nc ku nd ky ne lc ms mt mu mv bi translated">java客户端生成的(由swagger生成的库项目)</li><li id="5cfc" class="ml mm iq kh b ki na km nb kq nc ku nd ky ne lc ms mt mu mv bi translated">web服务器(web服务器，它使用上述库(插件))</li></ul><p id="eadc" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">不同项目的分离是有意的，业务逻辑应该对web服务器和web客户端一无所知。可以在不发送或接收HTTP请求、不启动/停止web服务器的情况下测试业务逻辑。</p><p id="e04f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">可以使用生成的客户端测试web服务器，它可以模拟业务逻辑，也可以使用真实的业务逻辑。在我看来，将不同的层分离到不同的项目有助于执行依赖规则(依赖指向内部)。但这既不必要也不充分。存在许多其它包装技术来实现相同的目标。</p><h1 id="ffbc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">模拟网络服务器</h1><p id="0bcb" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated">一个开源项目可以从一个swagger定义文件中旋转出一个模拟的web服务器。</p><pre class="nf ng nh ni gt oe mz of og aw oh bi"><span id="d630" class="oi lo iq mz b gy oj ok l ol om">#!/bin/bash<br/>npm install -g @stoplight/prism-cli<br/>prism mock /Users/domrevigor/tg/svc-payments/openApi/swagger.json</span></pre><p id="2b6e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">这将在本地启动一个web服务器，实现swagger json中定义的api，它将使用swagger注释中提供的示例值进行响应。如果有另一个团队在等待新的api准备好，他们可以在开发的第一天得到一个模拟的web服务器。</p><pre class="nf ng nh ni gt oe mz of og aw oh bi"><span id="51da" class="oi lo iq mz b gy oj ok l ol om">## example value taken from @Schema annotation<br/>@field:Schema(description = “price in USD”, maximum = “256”, example = “5”) val price: Double,</span></pre><h1 id="c7e4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">关于kotlin协程和swagger注释的一个注释。</h1><p id="f6c0" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated">Kotlin协同例程是该语言的一个惊人特性，它允许编写简单的异步代码，类似于javascript async/await机制，没有未来和承诺的复杂性。然而，当kotlin挂起函数被编译成字节码时，它们会被赋予一个额外的参数。延续对象，它完成了隐藏承诺和未来的肮脏工作。Swagger注释有<strong class="kh ir"> @Parameter(hidden = true) </strong>注释来处理不属于API定义的方法参数。然而，不可能注释只存在于字节码中的参数。我找到的解决方法是，要么从您的服务返回一个承诺，并保持它是一个常规函数，要么返回一个挂起闭包<strong class="kh ir">(注意= suspend {在下面的代码片段中)</strong></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="d9b1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">摘要</h1><p id="1c0a" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated">RESTfull web服务将继续存在。Swagger通过生成api文档和客户端代码来帮助其他人集成您的服务，使用swagger注释，过程甚至更简单，API文档由您的代码维护，不依赖于外部定义文件。它适用于任何支持注释的JVM语言，如Kotlin或Scala，并且不依赖于任何web框架。</p><h1 id="beb7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">资源</h1><p id="b3ed" class="pw-post-body-paragraph kf kg iq kh b ki mn kk kl km mo ko kp kq np ks kt ku nq kw kx ky nr la lb lc ij bi translated"><a class="ae lm" href="https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations" rel="noopener ugc nofollow" target="_blank">霸气API/霸气核心</a></p><p id="2fe0" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9" rel="noopener ugc nofollow" target="_blank"> RESTful API设计指南—最佳实践|黑客正午</a></p><p id="6368" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank">grpc-生态系统/grpc-网关</a></p><p id="1465" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://github.com/Redocly/redoc" rel="noopener ugc nofollow" target="_blank">重做/重做</a></p><p id="1f90" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://github.com/swagger-api/swagger-core/tree/master/modules/swagger-gradle-plugin" rel="noopener ugc nofollow" target="_blank">swagger-API/swagger-core</a></p><p id="eefb" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://github.com/swagger-api/swagger-editor" rel="noopener ugc nofollow" target="_blank">swagger-API/swagger-editor</a></p><p id="fdcf" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://medium.com/apis-and-digital-transformation/openapi-and-grpc-side-by-side-b6afb08f75ed" rel="noopener"> OpenAPI和gRPC并行</a></p><p id="a5ee" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净的程序员博客</a></p><p id="c915" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae lm" href="https://github.com/stoplightio/prism#readme" rel="noopener ugc nofollow" target="_blank"> prism —模拟服务器</a></p></div></div>    
</body>
</html>