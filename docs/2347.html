<html>
<head>
<title>Essential React Hooks Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本反应挂钩设计模式</h1>
<blockquote>原文：<a href="https://itnext.io/essential-react-hooks-design-patterns-a04309cc0404?source=collection_archive---------1-----------------------#2019-05-09">https://itnext.io/essential-react-hooks-design-patterns-a04309cc0404?source=collection_archive---------1-----------------------#2019-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/03f076bdc74719931c86844524b7b73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkbcOM9l9_QKglXaT95P4Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="d6f7" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">状态管理和异步I/O</h2></div><p id="dcac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">今天我们探索最近推出的<a class="ae lp" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React Hooks API </a>的通用设计模式。我们将涵盖创建真正的应用程序所需的所有基础知识，从状态管理到异步I/O的处理。最好在一些真实示例的上下文中完成，我们将以带有服务器端过滤的“选择用户”表单控件为例。在练习中，我们将识别设计问题，探索React Hooks API的所有主要部分，并了解它将如何减少我们每天为支付账单而编写的代码量。</p><h1 id="e3f4" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">选择用户概述</h1><p id="18a0" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated"><em class="mn"> &lt; PickUser/ &gt; </em>表单控件允许我们从数据库中挑选用户。在正常状态下，它只显示用户对象。当您单击它并开始输入时，它将从服务器获取过滤的用户，并显示为下拉列表，以便我们可以选择新值。这种行为与自动完成的下拉列表非常接近，只是数据集可能非常大，并且驻留在服务器上。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f4e48cf6b69315371db7863404c0a6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*EmEA9pwk4Kcai4HWJBIalQ.gif"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><PickUser/>用服务器端过滤控制</figcaption></figure><p id="25aa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">关于<em class="mn"> &lt; PickUser/ &gt; </em>有趣的一点是，它有一个外界不需要的非平凡状态。理想情况下，它应该被封装和隐藏，这样我们就可以像使用常规的&lt; <em class="mn">输入/ &gt; </em>一样简单地使用这个控件，并以相同的形式插入它，次数不限。像这样:</p><p id="1f33" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="mn">&lt;pick user value = { user } onChange = { setUser }/&gt;</em></p><p id="9caa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这意味着我们不能使用全局数据来存储状态，并且<em class="mn"> &lt; PickUser/ &gt; </em>应该依靠其本地状态来管理所有的交互。仅这一点，加上不小的副作用和I/O的存在，使得<em class="mn"> &lt; PickUser/ &gt; </em>成为一项颇具挑战性的任务，也是新React Hooks API的完美测试平台。</p><h1 id="3b80" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">有状态组件设计</h1><p id="5f42" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">鉴于我们<em class="mn">必须</em>使用本地状态的事实，我们面临一个非常实际的问题。肯定有一些正确和错误的方法来做这件事。<em class="mn">怎么做对？</em></p><p id="eb7e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">只要安装了组件，组件状态就会一直存在。当您决定某些数据是否应该成为特定组件状态的一部分时，您问自己的主要问题是:“<em class="mn">这些数据的寿命有多长？</em>“谁需要这些数据的问题”<em class="mn"/>”可能看起来同样重要，也更容易回答，但真正有助于做出最终决策的是数据的生命周期。</p><p id="d605" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那么，<em class="mn">数据的生命周期是多少？如果它与特定组件的生命周期相同，它应该是其本地状态的一部分，没有理由暴露它或提升它。</em></p><blockquote class="mx"><p id="fdc1" class="my mz je bd na nb nc nd ne nf ng lo dk translated">如果数据的生存期与组件的生存期相同，则数据应该属于组件的状态。如果数据的寿命比组件长，它应该作为一个属性被接收，并且可能是某个上层组件状态的成员。只有比任何特定组件存在时间更长的数据才应该全局存储。</p></blockquote><p id="80be" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">以我们的<em class="mn"> &lt; PickUser/ &gt; </em>为例。当前选中的用户显然可以比<em class="mn"> PickUser </em>活得更久，所以它被作为道具接收。仅仅为了显示用户，<em class="mn"> PickUser </em>还需要什么吗？没有。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="1877" class="no lr je bd ls np nq dn lw nr ns dp ma lc nt nu mc lg nv nw me lk nx ny mg nz bi translated">组件状态和useState()反应钩子</h2><p id="0fec" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">当我们单击控件时，它会切换模式并显示编辑过滤器的输入。这个“模式”绝对应该是国家的一部分。显然有更多的状态，但是<em class="mn">只在编辑过程中需要，这是相当罕见的</em>，所以不管它是什么，我们<em class="mn">只要把它推到</em> &lt; <em class="mn"> EditUser/ &gt;中，以后再考虑它。</em></p><blockquote class="mx"><p id="2f7a" class="my mz je bd na nb nc nd ne nf ng lo dk translated">如果不总是需要状态成员，就有机会将它下推到子组件状态。</p></blockquote><p id="9e60" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">现在，来认识一下第一个也是最受欢迎的React钩子— <a class="ae lp" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> useState </a>。这个钩子返回状态值和更新它的函数。如果你想要很多状态成员，只需多次使用状态。有一件重要的事情需要记住——所有的<em class="mn"> useSomething </em>调用必须只在顶层进行。永远不要在循环和如果中做。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="7c13" class="no lr je bd ls np nq dn lw nr ns dp ma lc nt nu mc lg nv nw me lk nx ny mg nz bi translated">编写自定义的React挂钩</h2><p id="44a5" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated"><em class="mn"> &lt; EditUser/ &gt; </em>会修改用户，所以我们需要同时传递<em class="mn"> selected </em>和<em class="mn"> setSelected() </em>通过。传递大量的状态元素可能会很快造成混乱，所以让我们将<em class="mn"> value </em>和<em class="mn"> setValue() </em>重新打包到一个可以作为单个值传递的对象中。这样的对象被称为[到状态]的链接，代表对状态元素的可变引用。</p><p id="65f8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是我们怎样才能以一种实际上适合使用的方式做到这一点呢？</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ccd4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是我们的第一个定制钩子——<em class="mn">use link</em>！一个“自定义钩子”只是一个在<em class="mn">内部调用其他React钩子的函数。在你的函数中使用钩子是没问题的，只要以“use”开始它们的名字就可以了，这样会很清楚它们也是“钩子”。</em></p><blockquote class="mx"><p id="b87f" class="my mz je bd na nb nc nd ne nf ng lo dk translated">链接是“可写道具”,代表对某些组件状态的可写引用。链接简化了将上层状态向下传递给子节点的过程。</p></blockquote><h2 id="d270" class="no lr je bd ls np oa dn lw nr ob dp ma lc oc nu mc lg od nw me lk oe ny mg nz bi translated">共享组件的状态</h2><p id="48c7" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated"><em class="mn"> &lt; EditUser/ &gt; </em>将处理编辑。该状态中唯一一个生存期与<em class="mn"> EditUser </em>的生存期相等的部分是<em class="mn">过滤器</em>。我们将需要<em class="mn"> &lt;输入/ &gt; </em>来改变<em class="mn">过滤器</em>，以及另一个组件<em class="mn"> &lt; UsersList/ &gt; </em>，每当其<em class="mn">过滤器</em>属性改变时，该组件将从服务器获取并显示过滤后的用户列表。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/355d7f8187234c62ed91d671bae53678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3PUuc9x1k0nDENeuz8beQ.png"/></div></div></figure><p id="5556" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，我们应该防止在用户输入过滤器时获取操作过于频繁。因此，我们不能使用普通的<em class="mn"> &lt; input/ &gt; </em>并需要一个类似的组件，它将延迟更改，直到用户停止输入。姑且称之为<em class="mn">&lt;DelayedInput/&gt;</em>。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0232" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里我们有一个两个组件以<em class="mn">共享状态运行的例子。</em>实际上，这样的状态必须提升到相互作用的部件的最近的公共根。<em class="mn">如果这个状态没有一直被使用</em>，就有机会重新思考组件的结构，创建新的子组件，它将封装这样一个状态，而不会违反“数据生存期规则”。机会不是一种义务，但如果你愿意利用它，可能会让这个系统变得更简单。</p><blockquote class="mx"><p id="fa88" class="my mz je bd na nb nc nd ne nf ng lo dk translated">在几个组件之间共享的状态应该提升到最近的公共根组件。当你这么做的时候，注意“数据生命周期规则”,必要的时候考虑重构。</p></blockquote><p id="1497" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">现在，当我们将问题缩小到两个不同的组件时，我们将分别处理I/O问题和延迟输入问题。这就是我们需要React Hooks全部力量的地方。</p><h1 id="309d" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated"><DelayedInput/></h1><p id="53f5" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">该控制应类似于常规的<em class="mn">输入</em>，但会将数值变化<em class="mn"> </em>延迟给定的毫秒数。如果用户在延迟期间再次输入，则延迟必须延长。因此，<em class="mn"> DelayedInput </em>从父节点接收它的值，但是它必须保持更改私有，直到延迟结束。但是，如果父节点因为其他原因要改变这个值，那么本地值也必须改变。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/2c144973a399d66762c3d790dd5f8735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZq4KEzw0s91UUqzUdXp2Q.png"/></div></div></figure><p id="a9d4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这意味着，我们需要一个与<em class="mn"> $value </em>属性单向同步的本地状态。让我们完成这个同步，将它包装在一个定制的钩子中。</p><h2 id="7440" class="no lr je bd ls np nq dn lw nr ns dp ma lc nt nu mc lg nv nw me lk nx ny mg nz bi translated">状态同步和useEffect() React挂钩</h2><p id="24e9" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">是时候见见<a class="ae lp" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React的<em class="mn"> useEffect() </em> hook </a>了。<em class="mn"> useEffects </em>()渲染后执行给定函数，只有当第二个参数中数组的元素发生变化时才会执行。这正是我们所需要的。我们将使用来跟踪<em class="mn"> $value </em>的变化并更新状态，我们将把这个逻辑包装到自定义钩子中。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="943b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">绑定状态链接在一个方面不同于普通链接:每当它的默认值改变时，它就改变底层状态，所以我们只需将prop值作为默认值传递，它就会完成工作。就这样，状态同步问题解决了。</p><blockquote class="mx"><p id="af9a" class="my mz je bd na nb nc nd ne nf ng lo dk translated">useEffect() React hook可以跟踪变化，因此您可以在渲染后轻松地将反应附加到道具变化上。这就是你在替换旧组件时要做的。</p></blockquote><p id="20dd" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">现在，让我们稍微了解一下<em class="mn"> Link </em>模式的威力。手动<em class="mn"> onChange </em>事件处理程序从来都不是React最令人兴奋的部分。如果<em class="mn">链接</em>不是一个普通的对象<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/react-hooks-and-two-way-data-binding-dd4210f0ed94">而是一个包含一些有用方法的类</a>会怎么样？它能为我们节省一些键入<em class="mn">为我们<em class="mn">生成</em> <em class="mn"> onChange </em> <em class="mn">事件处理程序</em>的时间吗？</em>如果你正在使用<a class="ae lp" href="https://github.com/VoliJS/NestedLink/blob/master/valuelink/API.md#-uselink-initvalue---link" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> useLink钩子</em> </a> <em class="mn"> </em>从<em class="mn"> </em> <a class="ae lp" href="https://www.npmjs.com/package/valuelink" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> NestedLink库</em> </a> <em class="mn">，答案是“是”。就这么办吧。</em></p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="8e20" class="no lr je bd ls np nq dn lw nr ns dp ma lc nt nu mc lg nv nw me lk nx ny mg nz bi translated">将状态同步回props</h2><p id="9a28" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated"><em class="mn">$ input value . props . onchange</em>处理程序在用户输入时更新<em class="mn"> $inputValue </em>状态。我们希望它这样做，但我们也希望为每次更改设置计时器，当它触发时，我们将更新父状态。如果在此之前发生了另一个状态更新，我们将取消计时器并创建新的计时器。</p><p id="0866" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果没有链接，我们将只是把这个逻辑放到输入的<em class="mn"> onChange中。</em>有了<a class="ae lp" href="https://github.com/VoliJS/NestedLink" rel="noopener ugc nofollow" target="_blank">嵌套链接</a>，我们又多了一个选项<a class="ae lp" href="https://github.com/VoliJS/NestedLink/blob/master/valuelink/API.md#-linkonchange-callback--any--void---link" rel="noopener ugc nofollow" target="_blank">将<em class="mn"> onChange </em>监听器直接连接到链接</a>。让我们这样做，假设我们有一个类似于<a class="ae lp" href="https://lodash.com/docs/4.17.11#throttle" rel="noopener ugc nofollow" target="_blank">洛达什_的东西。节流功能</a>。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="76a9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">可惜我们不能只用<em class="mn"> _。油门，多种原因不起作用</em>。为了取消之前的计时器，我们必须知道它的id，这听起来像是lodash完全不知道的另一个组件状态。</p><blockquote class="oh oi oj"><p id="7ea4" class="kt ku mn kv b kw kx kf ky kz la ki lb ok ld le lf ol lh li lj om ll lm ln lo im bi translated">有人可能会说，我们可以依靠<a class="ae lp" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">使用回调钩子</strong> </a> <strong class="kv jf"> </strong>来制作下划线/lodash _。节气门功能正常。不，我们不能。我们需要在组件将要卸载时取消计时器，以防止出现异常，而lodash不知道安装和卸载。</p></blockquote><p id="63f7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，我们将创建自定义的<em class="mn"> useThrottle hook，</em>现在我们来认识一下<a class="ae lp" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef React Hook </a>。</p><h2 id="f8bc" class="no lr je bd ls np nq dn lw nr ns dp ma lc nt nu mc lg nv nw me lk nx ny mg nz bi translated">useRef和清理效果</h2><p id="a89c" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated"><em class="mn"> useThrottle </em>获取该函数并生成另一个函数，该函数会将调用延迟给定的毫秒数。我们希望在组件的状态中存储timer <em class="mn"> id </em>以便在必要时取消它，但是<em class="mn">我们不希望组件在我们改变它的时候呈现</em>。我们希望它表现得像旧类<em class="mn">组件</em>中的原始类成员。这就是<a class="ae lp" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef React Hook </a>的设计初衷。</p><blockquote class="mx"><p id="33f2" class="my mz je bd na nb nc nd ne nf ng lo dk translated">useRef React hook与React类组件的常规类成员具有相同的含义</p></blockquote><p id="9698" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">另外，<em class="mn"> useThrottle </em>采用了一个奇怪的第三个参数[ $value.value ]。需要用它来处理竞争条件:如果在我们打字的时候父代的值改变了怎么办？我们将把它赋回一个旧值，因为我们还有一个定时器。相反，我们需要取消它，为此我们使用了<em class="mn">use effect</em>hook<em class="mn">clean up</em>。</p><blockquote class="mx"><p id="5b51" class="my mz je bd na nb nc nd ne nf ng lo dk translated">Clean-up是从useEffect主体返回的函数，它在下一次useEffect主体调用之前和卸载时被调用。</p></blockquote><figure class="on oo op oq or iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1984" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">无论您从<em class="mn"> useEffect </em>中的函数返回什么，都被视为一个<em class="mn">“清理”</em>函数。在调用useEffect主体之前，当<em class="mn"> useEffect </em>对更改和卸载做出反应时，将调用该函数。<em class="mn">cleanup和body的区别在于，clean up绑定到先前useEffect体调用的值。</em>所以，当用户关闭我们的控件时，我们不必担心另一个竞争条件，但是有延迟更新到dead状态。</p><p id="423b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><em class="mn">延迟输入</em>完成。有两条消息——好消息，也有好消息。首先，现在我们知道了关于钩子处理异步I/O所需的一切。其次，你再也不需要重复这个练习了。我在<a class="ae lp" href="https://github.com/VoliJS/NestedLink/tree/master/linked-controls" rel="noopener ugc nofollow" target="_blank">链接控制npm包</a>中添加了<em class="mn">使用节流</em>和<em class="mn">延迟输入</em>，所以如果你需要它们，就从那里抓取。</p><h1 id="6ba9" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated"><UsersList/></h1><p id="dff3" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated"><em class="mn"> &lt; UsersList/ &gt; </em>接受<em class="mn">过滤器</em>作为道具，并对其变化做出反应，从服务器获取过滤后的数据并显示出来。多亏了<em class="mn">&lt;DelayedInput/&gt;</em>这种事情不会发生得太频繁。</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/aab47e10c7cb03a93f6e02b681b688dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2129YWxqQpZ5ZtqRr7K3g.png"/></div></div></figure><p id="cbd0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们已经知道<em class="mn"> useEffect </em>可以用来跟踪道具的变化。但是我们想使用一个<em class="mn">异步</em>和<em class="mn">等待</em>来获取数据，这里有一个问题——<em class="mn">use effect</em>假设<em class="mn">无论你从内部返回什么都是一个清理函数。异步函数总是返回一个承诺。此外，知道I/O操作何时挂起以指示某个东西正在“加载…”也是有用的。让我们将这个逻辑包装在一个定制的useIO挂钩中。</em></p><blockquote class="mx"><p id="dbe9" class="my mz je bd na nb nc nd ne nf ng lo dk translated">不能在<em class="ot"> useEffect中使用async和await。但是您可以创建一个自定义挂钩来解决这个问题。</em></p></blockquote><figure class="on oo op oq or iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f0bf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我们编写代码时，我们注意到了另一个小问题——当组件将被卸载时，有一个挂起的I/O可能会出现异常。让我们用大写字母重复一遍:</p><blockquote class="mx"><p id="36ec" class="my mz je bd na nb nc nd ne nf ng lo dk translated">你不能只在I/O完成时更新你的状态。组件可能被卸载，您会得到一个异常。</p></blockquote><p id="1521" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">这听起来相当令人不安，但是我可以向你保证——对于我们刚刚获得的强大的定制钩子编程技能来说，这不成问题。让我们不要惊慌，看看我们能做什么。</p><h2 id="faaa" class="no lr je bd ls np nq dn lw nr ns dp ma lc nt nu mc lg nv nw me lk nx ny mg nz bi translated">检查组件是否已安装</h2><p id="a53a" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">为了防止异常，我们需要知道在执行link.set时组件是否被挂载了。要是我们有类似于<em class="mn">组件将卸载</em>的东西就好了……就是它！<em class="mn">清理的作用</em>是救援。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5ac4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，我们大概接触了最重要的<em class="mn">使用效果</em>用例之一:</p><blockquote class="mx"><p id="2342" class="my mz je bd na nb nc nd ne nf ng lo dk translated"><em class="ot"> useEffect( whenDidMount，[] ) </em>表现为<em class="ot"> componentDidMount，</em>并且其清理效果表现为<em class="ot"> componentWillUnmount。</em></p></blockquote><h2 id="db40" class="no lr je bd ls np oa dn lw nr ob dp ma lc oc nu mc lg od nw me lk oe ny mg nz bi translated">卸载组件时防止状态更新</h2><p id="760f" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">好吧。现在这个任务看起来很琐碎。让我们在另一个定制钩子中做一次，然后忘掉它。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><blockquote class="mx"><p id="b634" class="my mz je bd na nb ou ov ow ox oy lo dk translated">来自I/O功能的所有异步状态更新必须防止可能的组件卸载。</p></blockquote><h2 id="654f" class="no lr je bd ls np oa dn lw nr ob dp ma lc oc nu mc lg od nw me lk oe ny mg nz bi translated">带异步等待和加载指示器的I/O</h2><p id="8a3d" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">当承诺被解决时，useIO 将返回true，否则返回false。如果我们考虑到在前一个I/O操作完成之前可能会有<em class="mn">过滤器</em>的变化，那么这个小需求的实现就变得特别棘手。这意味着一次可能有多个未解决的I/O承诺。为了解决这个问题，我们将维护未解决的I/O承诺的计数器，如果它为零，我们就决定I/O结束。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="de80" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">哎呀，我们在这里使用的组件状态是在<em class="mn"> promise.finally()中修改的！</em>好的，那么把<em class="mn"> useLink </em>改成<em class="mn"> useSafeLink。没什么大不了的。不再是了。</em></p></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="ad42" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">很难相信，但我们完成了。<a class="ae lp" href="https://volijs.github.io/NestedLink/examples/autocomplete/index.html" rel="noopener ugc nofollow" target="_blank">这里是</a>，正在工作，<a class="ae lp" href="https://github.com/VoliJS/NestedLink/tree/master/examples/autocomplete/src" rel="noopener ugc nofollow" target="_blank">这里是源代码</a>。在这个练习中，我们使用了所有重要的React钩子，现在我们对新钩子API的能力有了大致的了解，并且知道了它的基本应用模式。此外，我们学习了有状态组件的设计和分解的基础知识，并且(我希望)理解了这些新的钩子到底是什么。</p><blockquote class="mx"><p id="64a5" class="my mz je bd na nb nc nd ne nf ng lo dk translated">React钩子对于React功能组件来说是非常强大的有状态混合，它能够以一种非常简洁优雅的方式封装复杂的设计模式。</p></blockquote><p id="f8e0" class="pw-post-body-paragraph kt ku je kv b kw nh kf ky kz ni ki lb lc nj le lf lg nk li lj lk nl lm ln lo im bi translated">此外，我们在这个练习中创建了一些非常有用的定制钩子。一遍又一遍地写它们会很丢人，所以我把它们添加到了<a class="ae lp" href="https://github.com/VoliJS/NestedLink" rel="noopener ugc nofollow" target="_blank"> NestedLink库</a>。快乐编码。</p><figure class="mp mq mr ms gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>