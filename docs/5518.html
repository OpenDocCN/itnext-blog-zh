<html>
<head>
<title>Azure Functions &amp; wkhtmltopdf: Convert HTML to PDF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure函数&amp; wkhtmltopdf:将HTML转换为pdf</h1>
<blockquote>原文：<a href="https://itnext.io/to-azure-functions-wkhtmltopdf-convert-html-to-pdf-9dc69bcd843b?source=collection_archive---------2-----------------------#2021-03-22">https://itnext.io/to-azure-functions-wkhtmltopdf-convert-html-to-pdf-9dc69bcd843b?source=collection_archive---------2-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/8326a467d2c45981934edc2cc76878fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*p4HTFOHGLxhC8WEGvYEn9w.jpeg"/></div></figure><p id="4381" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将使用Azure Functions &amp;<a class="ae ks" href="https://wkhtmltopdf.org/" rel="noopener ugc nofollow" target="_blank">wkhtmltopdf</a>工具从HTML文件生成pdf文件。出于多种原因，您可能需要创建PDF文件，例如为销售生成发票、为患者生成医疗报告、为客户生成保险表格等。有几种方法可以做到这一点。</p><p id="5158" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，你可以使用<a class="ae ks" href="https://www.adobe.com/in/acrobat/online/sign-pdf.html" rel="noopener ugc nofollow" target="_blank"> Adobe </a>的填充和签名工具来填写表格，但这主要需要人工交互，因此不可扩展，也不方便。</p><p id="7cc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二种选择是你直接创建一个pdf文件。基于您正在使用的平台，您将拥有直接创建pdf文件的工具。如果这是一个非常简单的pdf，你可以采取这种方法。</p><p id="9cd5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这让我们想到了最后一个也是最方便的选择。<a class="ae ks" href="https://wkhtmltopdf.org/" rel="noopener ugc nofollow" target="_blank"> wkhtmltopdf </a>是一个将HTML转换成pdf的非常棒的工具。因为它是免费的、开源的，并且可以在几乎所有平台上编译，所以它是我们的最佳选择。</p><h1 id="e847" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">先决条件</h1><ul class=""><li id="f13c" class="lr ls iq jw b jx lt kb lu kf lv kj lw kn lx kr ly lz ma mb bi translated">微软VS代码</li><li id="d70f" class="lr ls iq jw b jx mc kb md kf me kj mf kn mg kr ly lz ma mb bi translated">Azure门户网站<a class="ae ks" href="https://portal.azure.com/" rel="noopener ugc nofollow" target="_blank">上的账户</a></li><li id="82d6" class="lr ls iq jw b jx mc kb md kf me kj mf kn mg kr ly lz ma mb bi translated">Linux Basic (B1)应用服务计划。如果您已经有Windows Basic (B1)应用服务计划，您可以使用该计划。</li><li id="9963" class="lr ls iq jw b jx mc kb md kf me kj mf kn mg kr ly lz ma mb bi translated">Azure存储帐户。</li></ul><h1 id="8f93" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Azure函数</h1><p id="4b1e" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">由于将HTML转换成PDF是一项耗时的任务，我们不应该在我们的主web服务器上运行它。否则，它可能会开始阻塞其他重要的请求。Azure函数是委派此类任务的最佳方式。</p><p id="957c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了创建一个函数，你首先需要在你的机器上安装Azure函数。基于你的操作系统安装<a class="ae ks" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=macos%2Ccsharp%2Cbash#install-the-azure-functions-core-tools" rel="noopener ugc nofollow" target="_blank"> Azure功能核心工具</a>。安装完成后，打开命令行工具，启动下面的命令。html2pdf是您的项目名称。你可以用任何名字代替它。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9ffb" class="mt ku iq mp b gy mu mv l mw mx">func init html2pdf</span></pre><p id="a88c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在执行命令时，它会要求一个工作运行时。这里选择<em class="my"> 1。dotnet </em>作为微软的产品，它为dotnet提供了强大的支持。这将在当前目录中生成一个名为<em class="my"> html2pdf </em>的文件夹。由于Visual Studio代码允许直接发布到Azure函数，我们将使用它来编码和部署。</p><p id="4d5c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在VS代码中打开项目后，创建一个名为<em class="my"> Html2Pdf.cs </em>的文件。Azure函数提供了各种各样的<a class="ae ks" href="https://www.serverless360.com/blog/azure-functions-triggers-and-bindings" rel="noopener ugc nofollow" target="_blank">触发器</a>来执行函数。现在，我们将从http触发器开始，即可以通过HTTP协议直接调用该函数。在我们新创建的文件中粘贴以下内容。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="e17b" class="mt ku iq mp b gy mu mv l mw mx">using System;<br/>using Microsoft.Azure.WebJobs;<br/>using Microsoft.Azure.WebJobs.Extensions.Http;<br/>using Microsoft.Extensions.Logging;</span><span id="0ab6" class="mt ku iq mp b gy mz mv l mw mx">namespace Html2Pdf<br/>{<br/>    public class Html2Pdf<br/>    {<br/>        // The name of the function<br/>        [FunctionName("Html2Pdf")]<br/>        <br/>        // The first arugment tells that the functions can be triggerd by a POST HTTP request. <br/>        // The second argument is mainly used for logging information, warnings or errors<br/>        public void Run([HttpTrigger(AuthorizationLevel.Function, "POST")] Html2PdfRequest Request, ILogger Log)<br/>        {<br/>        }<br/>    }<br/>}</span></pre><p id="50a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们已经创建了一个框架，现在我们将在其中填充细节。您可能已经注意到，请求变量的类型是<em class="my"> Html2PdfRequest </em>。所以让我们创建一个模型<em class="my"> Html2PdfRequest.cs </em>类如下。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b0e4" class="mt ku iq mp b gy mu mv l mw mx">namespace Html2Pdf<br/>{<br/>    public class Html2PdfRequest<br/>    {<br/>        // The HTML content that needs to be converted.<br/>        public string HtmlContent { get; set; }<br/>      <br/>        // The name of the PDF file to be generated<br/>        public string PDFFileName { get; set; }<br/>    }<br/>}</span></pre><h1 id="9a50" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">丁克托普夫</h1><p id="32ab" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">为了从我们的托管代码中调用wkhtmltopdf，使用了一种称为P/Invoke的技术。简而言之，P/Invoke允许我们访问非托管库中的结构、回调和函数。有一个很好的P/Invoke包装器，名为<a class="ae ks" href="https://github.com/rdvojmoc/DinkToPdf" rel="noopener ugc nofollow" target="_blank"> DinkToPdf </a>，允许我们抽象出技术细节。</p><p id="7628" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以通过<a class="ae ks" href="https://www.nuget.org/packages/DinkToPdf/" rel="noopener ugc nofollow" target="_blank"> nuget </a>将DinkToPdf添加到您的项目中。只需从根文件夹中运行命令。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="e18d" class="mt ku iq mp b gy mu mv l mw mx">dotnet add package DinkToPdf --version 1.0.8</span></pre><p id="2aff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是时候在我们的类顶部添加一些代码了。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b6f5" class="mt ku iq mp b gy mu mv l mw mx">// Read more about converter on: <a class="ae ks" href="https://github.com/rdvojmoc/DinkToPdf" rel="noopener ugc nofollow" target="_blank">https://github.com/rdvojmoc/DinkToPdf</a><br/>// For our purposes we are going to use SynchronizedConverter<br/>IPdfConverter pdfConverter = new SynchronizedConverter(new PdfTools());</span><span id="0528" class="mt ku iq mp b gy mz mv l mw mx">// A function to convert html content to pdf based on the configuration pased as arguments<br/>// Arguments:<br/>// HtmlContent: the html content to be converted<br/>// Width: the width of the pdf to be created. e.g. "8.5in", "21.59cm" etc.<br/>// Height: the height of the pdf to be created. e.g. "11in", "27.94cm" etc.<br/>// Margins: the margis around the content<br/>// DPI: The dpi is very important when you want to print the pdf.<br/>// Returns a byte array of the pdf which can be stored as a file<br/>private byte[] BuildPdf(string HtmlContent, string Width, string Height, MarginSettings Margins, int? DPI = 180)<br/>{<br/>  // Call the Convert method of SynchronizedConverter "pdfConverter"<br/>  return pdfConverter.Convert(new HtmlToPdfDocument()<br/>            {<br/>                // Set the html content<br/>                Objects =<br/>                {<br/>                    new ObjectSettings<br/>                    {<br/>                        HtmlContent = HtmlContent<br/>                    }<br/>                },<br/>                // Set the configurations<br/>                GlobalSettings = new GlobalSettings<br/>                {<br/>                    // PaperKind.A4 can also be used instead PechkinPaperSize<br/>                    PaperSize = new PechkinPaperSize(Width, Height),<br/>                    DPI = DPI,<br/>                    Margins = Margins<br/>                }<br/>            });<br/>}</span></pre><p id="91d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我已经添加了行内注释，以便自我解释。如果你有任何问题，可以在下面的评论区问我。让我们从Run方法中调用上面创建的函数。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="2ee7" class="mt ku iq mp b gy mu mv l mw mx">// PDFByteArray is a byte array of pdf generated from the HtmlContent <br/>var PDFByteArray = BuildPdf(Request.HtmlContent, "8.5in", "11in", new MarginSettings(0, 0, 0,0));</span></pre><p id="6ea7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一旦生成了字节数组，让我们将它作为一个blob存储在Azure存储中。在上传blob之前，请创建一个容器。完成后，在PDFByteArray后添加以下代码。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1d11" class="mt ku iq mp b gy mu mv l mw mx">// The connection string of the Storage Account to which our PDF file will be uploaded<br/>// Make sure to replace with your connection string.<br/>var StorageConnectionString = "DefaultEndpointsProtocol=https;AccountName=&lt;YOUR ACCOUNT NAME&gt;;AccountKey=&lt;YOUR ACCOUNT KEY&gt;;EndpointSuffix=core.windows.net";</span><span id="c1ae" class="mt ku iq mp b gy mz mv l mw mx">// Generate an instance of CloudStorageAccount by parsing the connection string<br/>var StorageAccount = CloudStorageAccount.Parse(StorageConnectionString);</span><span id="0ce7" class="mt ku iq mp b gy mz mv l mw mx">// Create an instance of CloudBlobClient to connect to our storage account<br/>CloudBlobClient BlobClient = StorageAccount.CreateCloudBlobClient();</span><span id="f64b" class="mt ku iq mp b gy mz mv l mw mx">// Get the instance of CloudBlobContainer which points to a container name "pdf"<br/>// Replace your own container name<br/>CloudBlobContainer BlobContainer = BlobClient.GetContainerReference("pdf");</span><span id="a1dd" class="mt ku iq mp b gy mz mv l mw mx">// Get the instance of the CloudBlockBlob to which the PDFByteArray will be uploaded<br/>CloudBlockBlob Blob = BlobContainer.GetBlockBlobReference(Request.PDFFileName);</span><span id="969e" class="mt ku iq mp b gy mz mv l mw mx">// Upload the pdf blob<br/>await Blob.UploadFromByteArrayAsync(PDFByteArray, 0, PDFByteArray.Length);</span></pre><p id="ac93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">添加此代码后，您会看到一些错误和警告。首先，添加缺失的导入语句。其次，将<em class="my">运行</em>函数的返回类型从<em class="my"> void </em>改为<em class="my"> async Task </em>。下面是最终的<em class="my"> Html2Pdf.cs </em>文件的样子。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0e8b" class="mt ku iq mp b gy mu mv l mw mx">using Microsoft.Azure.WebJobs;<br/>using Microsoft.Azure.WebJobs.Extensions.Http;<br/>using Microsoft.Extensions.Logging;<br/>using DinkToPdf;<br/>using IPdfConverter = DinkToPdf.Contracts.IConverter;<br/>using Microsoft.WindowsAzure.Storage;<br/>using Microsoft.WindowsAzure.Storage.Blob;<br/>using System.Threading.Tasks;</span><span id="2a73" class="mt ku iq mp b gy mz mv l mw mx">namespace Html2Pdf<br/>{<br/>    public class Html2Pdf<br/>    {<br/>        // Read more about converter on: <a class="ae ks" href="https://github.com/rdvojmoc/DinkToPdf" rel="noopener ugc nofollow" target="_blank">https://github.com/rdvojmoc/DinkToPdf</a><br/>        // For our purposes we are going to use SynchronizedConverter<br/>        IPdfConverter pdfConverter = new SynchronizedConverter(new PdfTools());</span><span id="db53" class="mt ku iq mp b gy mz mv l mw mx">// A function to convert html content to pdf based on the configuration pased as arguments<br/>        // Arguments:<br/>        // HtmlContent: the html content to be converted<br/>        // Width: the width of the pdf to be created. e.g. "8.5in", "21.59cm" etc.<br/>        // Height: the height of the pdf to be created. e.g. "11in", "27.94cm" etc.<br/>        // Margins: the margis around the content<br/>        // DPI: The dpi is very important when you want to print the pdf.<br/>        // Returns a byte array of the pdf which can be stored as a file<br/>        private byte[] BuildPdf(string HtmlContent, string Width, string Height, MarginSettings Margins, int? DPI = 180)<br/>        {<br/>            // Call the Convert method of SynchronizedConverter "pdfConverter"<br/>            return pdfConverter.Convert(new HtmlToPdfDocument()<br/>            {<br/>                // Set the html content<br/>                Objects =<br/>                {<br/>                    new ObjectSettings<br/>                    {<br/>                        HtmlContent = HtmlContent<br/>                    }<br/>                },<br/>                // Set the configurations<br/>                GlobalSettings = new GlobalSettings<br/>                {<br/>                    // PaperKind.A4 can also be used instead of width &amp; height<br/>                    PaperSize = new PechkinPaperSize(Width, Height),<br/>                    DPI = DPI,<br/>                    Margins = Margins<br/>                }<br/>            });<br/>        }</span><span id="e168" class="mt ku iq mp b gy mz mv l mw mx">// The name of the function<br/>        [FunctionName("Html2Pdf")]</span><span id="73c8" class="mt ku iq mp b gy mz mv l mw mx">// The first arugment tells that the functions can be triggerd by a POST HTTP request. <br/>        // The second argument is mainly used for logging information, warnings or errors<br/>        public async Task Run([HttpTrigger(AuthorizationLevel.Function, "POST")] Html2PdfRequest Request, ILogger Log)<br/>        {<br/>            // PDFByteArray is a byte array of pdf generated from the HtmlContent <br/>            var PDFByteArray = BuildPdf(Request.HtmlContent, "8.5in", "11in", new MarginSettings(0, 0, 0, 0));</span><span id="a342" class="mt ku iq mp b gy mz mv l mw mx">// The connection string of the Storage Account to which our PDF file will be uploaded<br/>            var StorageConnectionString = "DefaultEndpointsProtocol=https;AccountName=&lt;YOUR ACCOUNT NAME&gt;;AccountKey=&lt;YOUR ACCOUNT KEY&gt;;EndpointSuffix=core.windows.net";<br/>            <br/>            // Generate an instance of CloudStorageAccount by parsing the connection string<br/>            var StorageAccount = CloudStorageAccount.Parse(StorageConnectionString);</span><span id="91d9" class="mt ku iq mp b gy mz mv l mw mx">// Create an instance of CloudBlobClient to connect to our storage account<br/>            CloudBlobClient BlobClient = StorageAccount.CreateCloudBlobClient();</span><span id="ed4f" class="mt ku iq mp b gy mz mv l mw mx">// Get the instance of CloudBlobContainer which points to a container name "pdf"<br/>            // Replace your own container name<br/>            CloudBlobContainer BlobContainer = BlobClient.GetContainerReference("pdf");<br/>            <br/>            // Get the instance of the CloudBlockBlob to which the PDFByteArray will be uploaded<br/>            CloudBlockBlob Blob = BlobContainer.GetBlockBlobReference(Request.PDFFileName);<br/>            <br/>            // Upload the pdf blob<br/>            await Blob.UploadFromByteArrayAsync(PDFByteArray, 0, PDFByteArray.Length);<br/>        }<br/>    }<br/>}</span></pre><p id="66f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">编码部分到此结束。</p><h1 id="d0ba" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">wkhtmltopdf</h1><p id="5d46" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">我们仍然需要在我们的项目中添加wkhtmltopdf库。在选择特定的Azure应用计划时，有一些注意事项。根据计划，我们将必须获得wkhtmltopdf库。出于我们的目的，我们选择了Linux基本(B1)应用服务计划，因为Windows基本(B1)应用服务计划的成本是它的5倍。</p><p id="7739" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在写这篇博客的时候，Azure App服务计划正在使用带有amd64架构的Debian 10。对我们来说很好，DinkToPdf为Linux、Windows和MacOS提供了预编译库。下载。所以把它放在你的项目的根文件夹中。我在MacOS上工作，所以我也下载了libwkhtmltox.dylib。如果您正在使用Windows，或者您已经在Windows应用服务计划上托管了Azure功能，则必须下载libwkhtmltox.dll。这是我们的项目结构的样子。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e531f0fc5728c25b7e63afbf574ba040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/0*22CD9GaS2qLnRdgO"/></div></figure><p id="ffb5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们创建一个构建时，我们需要包含。所以图书馆。为此，请打开csproj文件，并将以下内容添加到ItemGroup中。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1174" class="mt ku iq mp b gy mu mv l mw mx">&lt;None Update="./libwkhtmltox.so"&gt;<br/>    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>    &lt;CopyToPublishDirectory&gt;Always&lt;/CopyToPublishDirectory&gt;<br/>&lt;/None&gt;</span></pre><p id="ef05" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是完整的csproj文件:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5f4a" class="mt ku iq mp b gy mu mv l mw mx">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;<br/>  &lt;PropertyGroup&gt;<br/>    &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;<br/>    &lt;AzureFunctionsVersion&gt;v3&lt;/AzureFunctionsVersion&gt;<br/>  &lt;/PropertyGroup&gt;<br/>  &lt;ItemGroup&gt;<br/>    &lt;PackageReference Include="DinkToPdf" Version="1.0.8" /&gt;<br/>    &lt;PackageReference Include="Microsoft.NET.Sdk.Functions" Version="3.0.11" /&gt;<br/>  &lt;/ItemGroup&gt;<br/>  &lt;ItemGroup&gt;<br/>    &lt;None Update="host.json"&gt;<br/>      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>    &lt;/None&gt;<br/>    &lt;None Update="local.settings.json"&gt;<br/>      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>      &lt;CopyToPublishDirectory&gt;Never&lt;/CopyToPublishDirectory&gt;<br/>    &lt;/None&gt;<br/>    &lt;None Update="./libwkhtmltox.so"&gt;<br/>      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;<br/>      &lt;CopyToPublishDirectory&gt;Always&lt;/CopyToPublishDirectory&gt;<br/>    &lt;/None&gt;<br/>  &lt;/ItemGroup&gt;<br/>&lt;/Project&gt;</span></pre><h1 id="372f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建Azure Functions应用</h1><p id="f4c1" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">在我们部署Azure功能之前，我们必须在Azure门户中创建Azure功能。你可以去Azure门户网站开始创建<em class="my"> Azure Functions </em>资源。为了清晰起见，你可以看下面的截图。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/42998e0be6bd6253724ea4f906476c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fkjPQFLwWGkFbJmo"/></div></div></figure><p id="0ec7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下面的截图中，请确保在此处至少选择或创建<em class="my">基本</em>计划。其次，在操作系统中选择<em class="my"> Linux </em>。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/e596ca90926aac7224c5e8cffa0b3620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cNd8AaQtZdDRvfGk"/></div></div></figure><p id="dc51" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">拥有<em class="my">应用洞察</em>很好，因为您将能够查看日志和监控功能。此外，它几乎不花什么钱。如以下截图所示，如果您想启用它，请选择<em class="my">是</em>。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/92d07db9d5e8c7636369241056229d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UsDOO1siUEJPVu6y"/></div></div></figure><p id="6a6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">选择Next: Tags并再次单击Next，然后单击<em class="my"> Create </em>创建您的资源。创建<em class="my"> Azure Functions </em>资源可能需要几分钟时间。</p><h1 id="c5e0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">部署到Azure功能</h1><p id="a394" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">一旦创建完成，我们将通过VS代码将代码直接部署到Azure功能中。为此，你必须进入扩展并安装Azure Functions 扩展。在它的帮助下，我们将能够登录和管理Azure功能。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/5e743f4fc4d835e2474ee3031738bcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MD8P_oIh2hFlOEnV"/></div></div></figure><p id="b709" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">安装完成后，你会在边栏上看到Azure图标。当点击时，它将打开一个面板，其中有一个选项<em class="my">登录Azure </em>。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/b08effb2263ee1f079b5b199cf981e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_kGz1DtMlHdbdeMk"/></div></div></figure><p id="8c56" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">选择<em class="my">登录Azure </em>，这将打开一个浏览器，您可以在其中使用您的帐户登录。一旦登录，你可以回到VS代码，在你的侧面板中看到Azure函数列表。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/aa609b451770ea665ad8cef7bfb26775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/0*oObYp6GYS-5Xl13N"/></div></figure><p id="ae92" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对我来说，有4个功能应用程序。因为您可能只创建了一个，所以它将显示一个。是时候部署应用程序了。</p><p id="ca32" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">按下<em class="my"> F1 </em>打开带有操作列表的菜单。选择<em class="my">Azure Functions:Deploy to Function App…</em>这将打开一个Azure Functions列表，您可以部署到其中。选择我们新创建的Azure Funtions应用程序。这将要求弹出一个确认窗口，所以请继续部署它。部署你的应用需要几分钟时间。</p><h1 id="11db" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">配置wkhtmltopdf</h1><p id="f016" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">一旦你部署了Azure功能，还有最后一件事要做。我们需要将<em class="my"> libwkhtmltox.so </em>添加到Azure Functions应用程序的适当位置。登录Azure门户并导航到我们的Azure Functions应用程序。在侧面板上搜索SSH并点击<em class="my"> Go </em>按钮。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/aa01b7631ae032deb17d9ba6d27f088c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4-oV1Iy2i-FtUJSq"/></div></div></figure><p id="7f59" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这将在新选项卡中打开一个SSH控制台。我们的站点位于/home/site/wwwroot。因此，通过键入以下命令导航到该文件夹。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c281" class="mt ku iq mp b gy mu mv l mw mx">cd /home/site/wwwroot/bin</span></pre><p id="e734" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当您执行<em class="my"> ls </em>命令查看文件内容时，您不会看到<em class="my"> libwkhtmltox.so </em>文件。它实际上位于/home/site/wwwroot。</p><p id="f587" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这不是正确的立场。我们需要将它复制到bin文件夹中。为此，请执行以下命令。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9445" class="mt ku iq mp b gy mu mv l mw mx">cp ../libwkhtmltox.so libwkhtmltox.so</span></pre><p id="dcd0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你知道如何将文件放入bin文件夹的更好方法，请在下面的评论中提出建议。</p><p id="6bc8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就是这样！！！你已经有了一个全功能的Azure Functions应用。是时候从我们的演示网站项目中调用它了。</p><h1 id="e019" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">调用Azure函数</h1><p id="8980" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">尽管如此，我们仍然需要测试和调用我们的函数。在此之前，我们需要获得调用函数所需的<em class="my">代码</em>。代码<em class="my">是一个秘密，需要包含它来安全地调用函数。要获取<em class="my">代码</em>，请导航至Azure Portal并打开您的功能应用。在侧面板中搜索<em class="my">功能。</em></em></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/25165071f7f46a4ce8b966586f8c5030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yo0pZHYe6QR3p3_w"/></div></div></figure><p id="45e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您将在列表中看到<em class="my"> Html2Pdf </em>。单击该功能将打开详细视图。在侧面板中有一个<em class="my">功能键</em>的选项。选择该选项查看已经为您添加的隐藏默认<em class="my">代码</em>。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nh"><img src="../Images/bf202e41fb5240a562906507dbb9d421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*krf_O5Rxl9C5d31a"/></div></div></figure><p id="c045" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">复制代码并保存在手边，因为代码中会用到它。为了测试该功能，我为您创建了一个示例控制台应用程序。替换基本url，代码如下:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="669b" class="mt ku iq mp b gy mu mv l mw mx">using System;<br/>using System.Net;<br/>using System.Net.Http;<br/>using System.Net.Http.Headers;<br/>using System.Threading.Tasks;<br/>using Newtonsoft.Json;</span><span id="0748" class="mt ku iq mp b gy mz mv l mw mx">namespace Demo.ConsoleApp<br/>{<br/>    public class Program<br/>    {<br/>        public static async Task Main(string[] args)<br/>        {<br/>            string AzureFunctionsUrl = "https://&lt;Your Base Url&gt;/api/Html2Pdf?code=&lt;Replace with your Code&gt;";</span><span id="99b2" class="mt ku iq mp b gy mz mv l mw mx">using (HttpClient client = new HttpClient())<br/>            {<br/>                var Request = new Html2PdfRequest<br/>                {<br/>                    HtmlContent = "&lt;h1&gt;Hello World&lt;/h1&gt;",<br/>                    PDFFileName = "hello-world.pdf"<br/>                };<br/>                string json = JsonConvert.SerializeObject(Request);<br/>                var buffer = System.Text.Encoding.UTF8.GetBytes(json);<br/>                var byteContent = new ByteArrayContent(buffer);</span><span id="fccd" class="mt ku iq mp b gy mz mv l mw mx">byteContent.Headers.ContentType = new MediaTypeHeaderValue("application/json");</span><span id="5a26" class="mt ku iq mp b gy mz mv l mw mx">using (HttpResponseMessage res = await client.PostAsync(AzureFunctionsUrl, byteContent))<br/>                {<br/>                    if (res.StatusCode != HttpStatusCode.NoContent)<br/>                    {<br/>                        throw new Exception("There was an error uploading the pdf");<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }</span><span id="2118" class="mt ku iq mp b gy mz mv l mw mx">public class Html2PdfRequest<br/>    {<br/>        // The HTML content that needs to be converted.<br/>        public string HtmlContent { get; set; }</span><span id="253e" class="mt ku iq mp b gy mz mv l mw mx">// The name of the PDF file to be generated<br/>        public string PDFFileName { get; set; }<br/>    }</span><span id="4f08" class="mt ku iq mp b gy mz mv l mw mx">}</span></pre><p id="fe20" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样，代码应该是不言自明的。如果您有任何反馈或问题，请在下面的评论区提问。一旦你运行上面的控制台应用程序，它将在Azure Storage的<em class="my"> pdf </em>容器中创建一个<em class="my">hello-world.pdf</em>文件。</p><h1 id="38dc" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="6e2e" class="pw-post-body-paragraph ju jv iq jw b jx lt jz ka kb lu kd ke kf mh kh ki kj mi kl km kn mj kp kq kr ij bi translated">关于如何使用Azure函数将HTML转换成PDF的教程到此结束。对于任何反馈、问题或博客主题，您可以在下面留下评论。订阅时事通讯，了解即将推出的激动人心的新教程。</p><p id="0ac6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也可以关注我的<a class="ae ks" href="https://arjav-dave.medium.com/" rel="noopener">中</a>、<a class="ae ks" href="https://dev.to/arjavdave" rel="noopener ugc nofollow" target="_blank">dev . to</a>&amp;<a class="ae ks" href="https://blog.royalecheese.com/" rel="noopener ugc nofollow" target="_blank">hash node</a>。</p><p id="4fc6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">访问<a class="ae ks" href="https://arjavdave.com/" rel="noopener ugc nofollow" target="_blank">我的博客</a>获取更多这样的教程。</p></div></div>    
</body>
</html>