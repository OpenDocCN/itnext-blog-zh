<html>
<head>
<title>Generic Service Inheritance in Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring中的通用服务继承</h1>
<blockquote>原文：<a href="https://itnext.io/generic-service-inheritance-in-spring-7e8028c597dc?source=collection_archive---------3-----------------------#2021-04-11">https://itnext.io/generic-service-inheritance-in-spring-7e8028c597dc?source=collection_archive---------3-----------------------#2021-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a174778ad77f20ef0822bfa01e720d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtLAwt57yL-p2GUtNg-zgA.png"/></div></div></figure><p id="efa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几天前，我们讨论了与<a class="ae kw" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring框架</a>相关的<a class="ae kw" href="https://www.wikiwand.com/en/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>。这并不是一个简单的话题，因为Spring使用的托管beans很难在非托管对象中使用。许多程序员将<a class="ae kw" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" rel="noopener ugc nofollow" target="_blank">服务</a>与<a class="ae kw" href="https://www.wikiwand.com/en/Anemic_domain_model" rel="noopener ugc nofollow" target="_blank">贫血的领域模型</a>一起使用。许多开发人员——像纯粹的OOP爱好者——认为它是反模式的，其他人则喜欢腰带上的另一个工具。许多语言——像Kotlin、Java——甚至用数据/记录类这样的语言元素来支持它</p><p id="860a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们可能同意，当我们试图在兄弟类上实现丰富的服务工作时，有时服务会变得混乱。</p><p id="9933" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多概念让Spring更适合OOP范例，比如<a class="ae kw" href="https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/aop.html" rel="noopener ugc nofollow" target="_blank"> AOP </a>、<a class="ae kw" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes" rel="noopener ugc nofollow" target="_blank"> scoped beans </a>等等……我们也可以考虑混合函数式编程方法(这是我个人最喜欢的)。<br/>也有机会将对服务的引用放到域对象中，但是当代理类不能很好地工作时，我们很容易遇到问题(比如@Transactional注释函数……)。我们可以尝试使用托管原型域对象，这样我们可以注入必要的依赖关系，并且域对象可以——例如——自我保存。</p><p id="4485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在这篇文章中，我们将看到另一个概念。我们将把业务逻辑放到领域模型中，并将管理的功能分离到通用服务中。域模型将被持久化到不同的MongoDb集合中，但是它们将从同一个超类中继承。通用服务将使用不同的存储库接口对此实体进行操作。当然，我们可以使用switch-case语句来决定必须使用哪个存储库，但是这使得代码更难阅读、测试和维护。</p><p id="5a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们也将在服务和REST接口中使用域对象，并省略任何不必要的内容来理解示例。</p><p id="de47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该应用程序将传播一些端点，在那里我们可以使用CRUD操作并将车轮安装到车辆上。在收到安装请求时，我们将保留车轮库存中的车轮。之后，它将被安装到给定的车辆上，并从库存中删除。</p><p id="be4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建我们的领域模型。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/815f29db8605c8d65dae07d20a7e9cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*KoOfLZzX5bHG0_LPfSLjiA.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">领域模型</figcaption></figure><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">领域模型的超类</figcaption></figure><p id="141e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<em class="li"> putWheels </em>是一个普通的函数，它将轮子放在给定的车辆上。<em class="li"> getType </em>抽象方法<em class="li">T5】将每个孩子视为“不同的行为”。</em></p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">汽车领域模型。公共汽车和卡车相似</figcaption></figure><p id="c234" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建父存储库接口，并为每个模型创建子接口。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="f4a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们到现在也没看出什么特别。下一步，我们将创建一个通用的超级服务。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">车辆服务</figcaption></figure><p id="7771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们使用泛型来组成一个超级服务。该服务包含crud操作和<em class="li"> installWheels </em>方法，该方法从数据库加载必要的数据，然后调用给定车辆的<em class="li"> putWheels方法。它将安装精确数量的车轮。域对象知道轮子必须如何安装。托管功能从业务逻辑中提取出来，并放入这个服务中(比如加载和保存数据)，因此域模型可以保持不受管理。</em></p><p id="1c83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">域对象和存储库的类型将被最终的实现通用参数所取代。我们限制了域类型，因此它必须从Vehicle类继承，并且必须使用与域占位符相同的通用类型参数从VehicleRepostitory扩展存储库。</p><p id="208a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以创建我们的定制服务实现了。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="484e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些服务中，我们既可以使用公共的存储库函数，也可以使用单独的函数——正如你在<em class="li">car service . findbyenginecapacitygte-</em>中看到的，因为推断出了正确的类型，Spring将注入它来代替<em class="li"> RT </em>占位符。</p><p id="1151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们可能希望创建一个REST接口，在那里我们可以获取、发布…所有这些类型，我们不想创建switch/if…语句来选择正确的服务类型。</p><p id="ac92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<a class="ae kw" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/ServiceLocatorFactoryBean.html" rel="noopener ugc nofollow" target="_blank">服务定位器</a>发挥作用的地方。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="dcaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以将定位器注入到控制器中，控制器将根据实体类型选择正确的服务。在这个例子中，我们将使用一个查询参数来分隔域类型。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="18c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="li"> getService </em>方法将返回正确的服务。<br/>我们可以像<em class="li"> /api/v1/vehicle这样调用接口？</em> <strong class="ka ir"> <em class="li">型号=汽车</em> </strong></p><p id="8cdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们可以为每种类型创建单独的控制器。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="f257" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多情况下，当这些类型混合在一起时(在超类上),我们需要对它们进行操作，并调用由给定子类动态调度的方法。这在纯面向对象中很容易做到，但在这种情况下，我们需要做一些技巧。</p><figure class="ky kz la lb gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="6505" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们再次使用服务定位器来决定我们需要调用哪个服务。</p><p id="4dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们使用Spring时，这个模式只是皮带中的另一个工具。我们可以用它来实现常见的功能——比如crud操作——并在我们所有的服务中使用它。总是选择最符合要求的。</p><p id="6517" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub 上的源代码。</p></div></div>    
</body>
</html>