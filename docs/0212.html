<html>
<head>
<title>Filtering Meat for Carnivores</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为食肉动物过滤肉类</h1>
<blockquote>原文：<a href="https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839?source=collection_archive---------2-----------------------#2017-12-17">https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839?source=collection_archive---------2-----------------------#2017-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/340a0bbf86d5ec4926929328322c8f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPr1Dhzh8XB2BckHqZkrQ.png"/></div></div></figure><h2 id="51b9" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">表情符号爱好者的函数式编程指南</h2><div class=""/><div class=""><h2 id="1abd" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">使用数组筛选器、一些和每一个。</h2></div><p id="f2c9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">用表情符号和JavaScript学习函数式编程。代码示例应该足够简单，不需要任何先验知识就可以理解，但是我可以想象它看起来有点奇怪。还有，JavaScript实际上不允许表情符号作为JavaScript变量名。出于这个原因，这些代码示例不会在没有修改的情况下运行。</em></p><ul class=""><li id="97a8" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener"> <em class="lv">用食物表情符号制作便便。</em>T15】</a></li><li id="4cf2" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener"> <em class="lv">把暴风云变成晴朗的云。</em>T19】</a></li><li id="34ed" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener"> <em class="lv">用减速器建造独角兽！</em> </a></li><li id="f0f3" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener"> <em class="lv">现在是管道操作员！</em> </a></li><li id="cb51" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener"> <em class="lv">为食肉动物过滤肉类。</em> </a></li><li id="e0fe" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener"> <em class="lv">用归约器递归。</em> </a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="3f85" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有时你只想从数组中取出某些值。正如我们以前所做的那样，让我们先从程序上探讨这个想法，然后从功能上探讨。</p><p id="f1da" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">程序性:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="98db" class="nb nc jb mx b gy nd ne l nf ng">animals = [🐖, 🐄, 🐓, 🦃]<br/>pork = []</span><span id="f255" class="nb nc jb mx b gy nh ne l nf ng">isPork = animal =&gt; animal === 🐖</span><span id="5fe8" class="nb nc jb mx b gy nh ne l nf ng">addPork = animal =&gt; {<br/>    if (isPork(animal)) {<br/>        pork.push(animal)<br/>    }<br/>}</span><span id="f37b" class="nb nc jb mx b gy nh ne l nf ng">for (let i = 0, l = animals.length; i &lt; l; i++) {<br/>    addPork(animals[i])<br/>}</span><span id="c5b7" class="nb nc jb mx b gy nh ne l nf ng">[🐖] = pork</span></pre><p id="08ce" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">功能性:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e2ae" class="nb nc jb mx b gy nd ne l nf ng">isPork = animal =&gt; animal === 🐖</span><span id="768f" class="nb nc jb mx b gy nh ne l nf ng">[🐖] = [🐖, 🐄, 🐓, 🦃].filter(isPork)</span></pre><p id="b7c0" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">简单吧？<code class="fe ni nj nk mx b">filter</code>与<code class="fe ni nj nk mx b">map</code>相似，它接受一个数组，遍历每个值，然后返回另一个数组。不同之处在于，每当<code class="fe ni nj nk mx b">filter</code>运行时，只要我们给它的函数返回<code class="fe ni nj nk mx b">true</code>，该项就会出现在我们过滤后的数组中。</p><p id="3e51" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这里有一种情况，我们可以使用<code class="fe ni nj nk mx b">filter</code>来查看数组中是否有特定的项目:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="a98b" class="nb nc jb mx b gy nd ne l nf ng">isTurkey = animal =&gt; animal === 🦃</span><span id="6114" class="nb nc jb mx b gy nh ne l nf ng">😇 = (<br/>    [🐖, 🐄, 🐓, 🦃]<br/>    .filter(isTurkey)<br/>    .length &gt; 0<br/>)</span></pre><p id="efd9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这种方法的问题是，它必须循环每一项，而它本可以在第一项之后立即停止。此外，我们需要的只是来自<code class="fe ni nj nk mx b">filter</code>的<code class="fe ni nj nk mx b">true</code>或<code class="fe ni nj nk mx b">false</code>，我们不需要获取长度并检查它。更好的选择是<code class="fe ni nj nk mx b">some</code>和<code class="fe ni nj nk mx b">every</code>，它们会一直循环，直到找到自己的价值。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="467e" class="nb nc jb mx b gy nd ne l nf ng">animals = [🐖, 🐄, 🐓, 🦃]</span><span id="d871" class="nb nc jb mx b gy nh ne l nf ng">😇 = animals.some(isTurkey)</span><span id="cc2f" class="nb nc jb mx b gy nh ne l nf ng">👿 = animals.every(isTurkey)<br/></span><span id="ea64" class="nb nc jb mx b gy nh ne l nf ng">😱 = [🤡, 🤡, 🤡, 🤡].every(isClown)</span></pre><p id="a467" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们正在检查是否至少有一个动物是带<code class="fe ni nj nk mx b">some</code>的火鸡，或者是否每个动物都是带<code class="fe ni nj nk mx b">every</code>的火鸡，如果每个项目都是小丑，我们就有严重的问题了！虽然，谁真的在乎其中一个动物是火鸡？假设我们被困在一个岛上？那么我们真的只关心什么是可食用的:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b748" class="nb nc jb mx b gy nd ne l nf ng">isEdible = Boolean<br/></span><span id="aeb4" class="nb nc jb mx b gy nh ne l nf ng">animals = [🐖, 🐄, 🐓, 🦃]</span><span id="1971" class="nb nc jb mx b gy nh ne l nf ng">😇 = animals.every(isEdible)</span><span id="640b" class="nb nc jb mx b gy nh ne l nf ng">😇 = animals.every(isEdible)</span><span id="1657" class="nb nc jb mx b gy nh ne l nf ng">[🐖, 🐄, 🐓, 🦃] = animals.filter(isEdible)</span><span id="03c8" class="nb nc jb mx b gy nh ne l nf ng"><br/>graveyard = [🌙, ☠️, 👻]</span><span id="ff28" class="nb nc jb mx b gy nh ne l nf ng">😇 = graveyard.some(isEdible)</span><span id="6221" class="nb nc jb mx b gy nh ne l nf ng">👿 = graveyard.every(isEdible)</span><span id="04fa" class="nb nc jb mx b gy nh ne l nf ng">[🌙] = graveyard.filter(isEdible)</span></pre><p id="735e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们先解决这个问题。月亮是奶酪做的，那肯定是可以吃的。事实是，月亮曾经是由牛奶制成的，但是在过去的几亿年里它发霉了。很明显，我们不能吃死人，也不能吃不死生物，所以这些是不可能的。这就是为什么<code class="fe ni nj nk mx b">some</code>墓地物品是可食用的而<code class="fe ni nj nk mx b">every</code>墓地物品是不可食用的。</p><p id="88d8" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们还通过将<code class="fe ni nj nk mx b">Boolean</code>构造函数直接用作函数做了一些有趣的事情。我们可以做<code class="fe ni nj nk mx b">Boolean(🐖)</code>来检查<code class="fe ni nj nk mx b">🐖</code>是不是<code class="fe ni nj nk mx b">true</code>。由于在我们的表情符号示例中，任何可食用的东西都是<code class="fe ni nj nk mx b">true</code>，那么我们可以使用<code class="fe ni nj nk mx b">isEdible</code>，一个命名的函数，而不是<code class="fe ni nj nk mx b">Boolean</code>。</p><p id="5c32" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您将经常需要检查您的数组是否有某些类型的值，并过滤掉虚假的值，如<code class="fe ni nj nk mx b">undefined</code>、<code class="fe ni nj nk mx b">null</code>和<code class="fe ni nj nk mx b">false</code>。这就是<code class="fe ni nj nk mx b">.filter(Boolean)</code>派上用场的地方。当你的数组包含数字时，我建议使用<code class="fe ni nj nk mx b">Number.isFinite</code>而不是<code class="fe ni nj nk mx b">Boolean</code>，因为你很可能不希望<code class="fe ni nj nk mx b">0</code>算作<code class="fe ni nj nk mx b">false</code>。</p><p id="1d9f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">可能需要从数组中取出一个特定的值。用<code class="fe ni nj nk mx b">filter</code>当然可以，但用<code class="fe ni nj nk mx b">find</code>更干净:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="2ef9" class="nb nc jb mx b gy nd ne l nf ng">[🐄] = [🐖, 🐄, 🐓, 🦃].filter(isBeef)</span><span id="5a85" class="nb nc jb mx b gy nh ne l nf ng">🐄 = [🐖, 🐄, 🐓, 🦃].find(isBeef)</span></pre><p id="8812" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe ni nj nk mx b">find</code>采用与<code class="fe ni nj nk mx b">filter</code>完全相同的函数，但是当它得到一个真值时，它立即返回那个值。使用我们之前的<code class="fe ni nj nk mx b">Boolean</code>技巧，这可能是一个避免<code class="fe ni nj nk mx b">array[0]</code>的聪明方法:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="1a00" class="nb nc jb mx b gy nd ne l nf ng">🐖 = [🐖, 🐄, 🐓, 🦃].filter(Boolean)[0]</span><span id="37eb" class="nb nc jb mx b gy nh ne l nf ng">🐖 = [🐖, 🐄, 🐓, 🦃].find(Boolean)</span><span id="940d" class="nb nc jb mx b gy nh ne l nf ng"><br/>🐖 = [☠️, 🐖, 🐄, 🐓, 🦃].filter(Boolean)[0]</span><span id="4c37" class="nb nc jb mx b gy nh ne l nf ng">🐖 = [☠️, 🐖, 🐄, 🐓, 🦃].find(Boolean)</span></pre><p id="2fe6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然<code class="fe ni nj nk mx b">find</code>非常有用，但是它不允许与其他数组函数链接。在这种情况下，您会想要使用<code class="fe ni nj nk mx b">filter</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d616" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="a681" class="nb nc jb mx b gy nh ne l nf ng">sum = uncurry(add)</span><span id="011f" class="nb nc jb mx b gy nh ne l nf ng">cook = item =&gt; [item, 👨‍🍳, 🔪, 🍳].reduce(sum)</span><span id="7033" class="nb nc jb mx b gy nh ne l nf ng">🥓 = (<br/>    [🐖, 🐄, 🐓, 🦃]<br/>    .filter(isPork)<br/>    .map(cook)<br/>    .map(add(🍽️))<br/>    .find(Boolean)<br/>)</span></pre><p id="13eb" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们使用了ol' <code class="fe ni nj nk mx b">sum</code>和一个新函数<code class="fe ni nj nk mx b">cook</code>。然后我们<code class="fe ni nj nk mx b">map</code> <code class="fe ni nj nk mx b">cook</code>围着我们的猪肉和<code class="fe ni nj nk mx b">add</code>每只煮熟的猪一盘食物。完成后，我们从数组中取出第一盘猪肉，这就是熏肉！我打赌你不知道你可以用JavaScript做猪肉培根。我做到了。</p><p id="27a4" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">摸摸肉！</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="85a2" class="nb nc jb bd nl nm nn dn no np nq dp nr li ns nt nu lm nv nw nx lq ny nz oa jh bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener">点击此处进入第6部分！</a></h2><h1 id="af41" class="ob nc jb bd nl oc od oe no of og oh nr kq oi kr nu kt oj ku nx kw ok kx oa ol bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kz la jb lb b lc om kl le lf on ko lh li oo lk ll lm op lo lp lq oq ls lt lu ij bi translated">如果您对与函数式编程相关的更多主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="f12a" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-to-safely-refactor-old-code-part-1-a1a853263fec">安全重构旧代码:第1部分</a></li><li id="21e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="90dd" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div></div>    
</body>
</html>