<html>
<head>
<title>DIY node_modules cache for Docker in your CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在配置项中为DIY node _ modules缓存</h1>
<blockquote>原文：<a href="https://itnext.io/diy-node-modules-cache-for-docker-in-your-ci-f1505972b55e?source=collection_archive---------4-----------------------#2022-07-28">https://itnext.io/diy-node-modules-cache-for-docker-in-your-ci-f1505972b55e?source=collection_archive---------4-----------------------#2022-07-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/513cd6bb8c090dbc18e8036329063575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EVE2p8KlcxD9EQUr.jpg"/></div></div></figure><h1 id="78a4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">背景</h1><p id="4f85" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">虽然我不是DevOps专家，但我使用CI工具已经有一段时间了，在我的职业生涯中，我一直致力于在我的工作流和我构建的产品/web应用程序中实现最佳性能和效率。</p><p id="344f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然这绝不是一个完美的解决方案，老实说，它可能不是最好的，但在我的测试中，它确实工作得很好。</p><h1 id="c329" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题</h1><p id="d047" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们今天构建的大多数应用程序都尽可能地利用了自动化工作流的优势。从我们的测试到部署，以及最近在某种程度上我们的代码编写…</p><p id="0223" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我看到的一个问题是，当涉及到为基于JS的web应用程序构建图像时，比如Vue和React，就我个人而言，我已经与React合作多年，以前在Azure上工作时，我们的web应用程序的构建时间大约为12分钟，最近我一直在与Google Cloud合作，我看到的时间大约为10分钟。</p><p id="bf88" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，这可能与CI工具无关，而是与应用程序的规模和复杂性有关，因为大部分时间是由一个常见步骤<code class="fe lz ma mb mc b">npm install</code>占用的，并且考虑到这是一个在线操作，许多因素都会影响该步骤需要多长时间。</p><h1 id="4133" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案(？)</h1><p id="b9e2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最近在遛狗的时候，我有了一个为node创建自己的缓存容器的疯狂想法，我非常喜欢使用多阶段构建，并且刚刚更新了项目以解决这个问题，在更新之前，我们将构建的基本节点映像提升到大约1.6GB，切换到多阶段，并且将alpine容器提升到140mb。</p><p id="da72" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">虽然这个想法可能不太可行，或者至少对新的项目有益，但是旧的更成熟和稳定的项目可以看到这个想法的合理改进。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="d146" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先创建一个缓存映像，这是一个用所需的基本节点映像构建的简单映像，只需安装节点模块，然后将它们复制到alpine映像，我们就完成了。</p><pre class="mk ml mm mn gt mo mc mp mq aw mr bi"><span id="aa91" class="ms jz iq mc b gy mt mu l mv mw">FROM node:18 as build</span><span id="185a" class="ms jz iq mc b gy mx mu l mv mw">COPY package*.json ./</span><span id="36b5" class="ms jz iq mc b gy mx mu l mv mw">RUN npm install --no-audit --progress=false</span><span id="1b91" class="ms jz iq mc b gy mx mu l mv mw">FROM alpine as release</span><span id="a94f" class="ms jz iq mc b gy mx mu l mv mw">COPY --from=build /node_modules ./node_modules</span></pre><p id="bddf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这个映像成为我们的“缓存”映像，当在一个更稳定的项目中时，可以每周甚至每月重建一次，因为这些包是相当稳定的。</p><p id="32a2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">从那以后，您只需将它作为构建阶段的一部分，正如您将从第一行<code class="fe lz ma mb mc b">FROM node-cache as cache</code>中看到的，其中<code class="fe lz ma mb mc b">node-cache</code>是您提供给映像的任何名称，它可能需要包含对容器注册表的引用。</p><p id="0651" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">不要忘记，在CI上使用它之前，需要构建缓存映像并将其推送到容器注册中心。</p><pre class="mk ml mm mn gt mo mc mp mq aw mr bi"><span id="71a6" class="ms jz iq mc b gy mt mu l mv mw">FROM node-cache as cache<br/> ​<br/> <em class="my"># Build Stage</em><br/> FROM node:18 as build<br/> COPY --from=cache /node_modules ./node_modules<br/> COPY package*.json ./<br/> COPY . ./<br/> RUN npm install --no-audit --progress=false --prefer-offline<br/> RUN npm run build<br/> ​<br/> <em class="my"># Release stage</em><br/> FROM node:18-alpine as release<br/> <em class="my"># Copy files over from build stage</em><br/> COPY --from=build /build ./build<br/> COPY --from=build package*.json ./<br/> COPY --from=build /server.js ./server.js<br/> ​<br/> RUN npm install --only=production<br/> ​<br/> CMD [ "npm", "run", "prod" ]</span></pre><h1 id="51ab" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">构建阶段</h1><p id="c98a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是我们利用缓存的地方，在这一步中，我们使用了<code class="fe lz ma mb mc b">node-18</code>映像，这是构建原始缓存映像时使用的同一映像，其中的关键部分是第<code class="fe lz ma mb mc b">COPY --from=cache /node_modules ./node_modules</code>行，这一行将节点模块文件夹从我们的缓存复制到我们的构建阶段。</p><p id="6032" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这样做意味着我们现在可以在一个类似的环境中，在我们的构建阶段访问相关的安装包。然后，我们复制包文件，特别是目录中的剩余文件。</p><p id="97b3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还应该注意，您的项目应该包含一个<code class="fe lz ma mb mc b">dockerignore</code>文件，并且应该在该文件中指定<code class="fe lz ma mb mc b">node_modules</code>，否则<code class="fe lz ma mb mc b">COPY . ./</code>步骤将覆盖容器中的node_modules文件夹。</p><p id="0b24" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来我们运行<code class="fe lz ma mb mc b">npm install</code>步骤，额外的参数可以加快一点速度，但也指定npm需要在联机检查之前进行本地检查，这将确保只有添加或升级的包，因为缓存映像最后一次构建后才会被下载。</p><h1 id="6697" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">发布阶段</h1><p id="ae3b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果我们在发布阶段再往下看一点，前几个步骤是复制构建目录(我们编译的web应用程序)、package.json文件以及<code class="fe lz ma mb mc b">server.js</code>。</p><p id="0705" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">server.js</code>是一个小的<code class="fe lz ma mb mc b">express</code>服务器，允许我们从web访问docker容器中的应用程序。</p><pre class="mk ml mm mn gt mo mc mp mq aw mr bi"><span id="656c" class="ms jz iq mc b gy mt mu l mv mw"> const http = require('http');<br/> const Express = require("express");<br/> const path = require('path');<br/> ​<br/> const port = process.env.PORT || 7010;<br/> ​<br/> const app = Express();<br/> const server = http.createServer(app);<br/> ​<br/> server.listen(port, function () {<br/>     console.log(`Server listening on port ${port}`);<br/> });<br/> ​<br/> app.get('/', function(req, res) {<br/>     res.sendFile(path.join(__dirname, "build", "index.html"));<br/> });<br/> ​<br/> app.use(Express.static(path.join(__dirname, "build")));<br/> ​<br/> module.exports = server;</span></pre><p id="156d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">倒数第二个命令是<code class="fe lz ma mb mc b">RUN npm install --only=production</code>，包含的标志指示节点只安装在<code class="fe lz ma mb mc b">package.json</code>的“dependencies”键中列出的包，忽略“devDependencies”中的任何内容，因此对于这个特定的例子，只有<code class="fe lz ma mb mc b">express</code>被安装到<code class="fe lz ma mb mc b">alpine</code>映像中。</p><p id="9eff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了更好地工作，你需要确保你的<code class="fe lz ma mb mc b">package.json</code>被正确地分割，以确保只有必需的包被列为依赖项，其余的都应该是devDependencies。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="f7d5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我的本地测试中，这导致构建时间缩短了60%以上，平均构建时间从更新前的至少150秒缩短到更新后的不到50秒。</p><p id="3538" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在管道中，我们看到构建时间缩短了40–45 %,这是因为需要先下载图像。</p><p id="b8df" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于那些想要进一步了解，甚至测试这个解决方案的人，我已经使用标准的<a class="ae mz" href="http://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> CRA </a>创建了一个<a class="ae mz" href="https://github.com/RemeJuan/docker-cache-example" rel="noopener ugc nofollow" target="_blank">回购</a>，在这里你会找到类似的Docker文件，你可以按照自述文件中的步骤开始工作。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="1873" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我希望您对此感兴趣，如果您有任何问题、评论或改进，请随时发表评论。如果你有更好的解决方案，也可以分享给大家:微笑:</p><p id="6b5e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果你喜欢，一个喜欢会很棒。</p><p id="7cba" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">感谢阅读。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/up-your-testing-game-ae40cb5d4449"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">升级您的测试游戏</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">今天我们来看看Flutter测试提供的一个很棒的工具。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">itnext.io</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/widget-testing-dealing-with-renderflex-overflow-errors-9488f9cf9a29"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">小部件测试:处理Renderflex溢出错误</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">在单元测试中处理“一个RenderFlex被…溢出”的简单方法…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">itnext.io</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jw nd"/></div></div></a></div><p id="23c6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">照片由<a class="ae mz" href="https://unsplash.com/@timelabpro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Timelab Pro </a>在<a class="ae mz" href="https://unsplash.com/s/photos/container?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="50c2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="my">最初发布于2022年8月1日</em><a class="ae mz" href="https://remelehane.dev/posts/diy-node-cache-for-docker-ci/" rel="noopener ugc nofollow" target="_blank"><em class="my">https://remelehane . dev</em></a><em class="my">。</em></p></div></div>    
</body>
</html>