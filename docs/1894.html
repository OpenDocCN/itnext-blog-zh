<html>
<head>
<title>Docker &amp; Makefile | X-Ops — sharing infra-as-code parts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker &amp; Makefile | X-Ops —共享基础架构代码部分</h1>
<blockquote>原文：<a href="https://itnext.io/docker-makefile-x-ops-sharing-infra-as-code-parts-ea6fa0d22946?source=collection_archive---------0-----------------------#2019-02-19">https://itnext.io/docker-makefile-x-ops-sharing-infra-as-code-parts-ea6fa0d22946?source=collection_archive---------0-----------------------#2019-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/dfa4f3c1be0640ee97b09021643a9a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rYWn26XjeK8bqumw"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@zhenhu2424?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">甄虎</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="7de2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们作为X-Ops(即DevOps、CloudOps、GitOps、SysOps等角色)的生活中，我们专注于构建基础架构即代码。我们经常使用Docker来构建和测试，提交代码并从存储库中提取代码，当所有测试都通过时，基础架构就可以完全自动化地投入生产。</p><p id="2104" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在的一个大机会是扩展和整合我们的X-Ops团队。候选名单上的两个目标是:1.低门槛(最好是零门槛)，有助于吸引更多同事加入；2 .易于遵循的构建和测试习惯，更快地将零件投入生产并提高重复利用率。</p><p id="7aa1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将重点介绍几个简单的技术实践——即应用Docker、Makefile和正确使用UIDs根据我的经验，这些实践让我们更接近这些目标。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="dac9" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用Makefile</h1><p id="f8bf" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Docker为我们带来了快速有效地构建系统的自动化，我们甚至可以使用docker-compose来运行服务。</p><p id="44be" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在大多数生产环境中，都有一个单独的容器平台。我们在本地构建、测试和运行的容器是一个更大环境的一部分。一个经常出现的问题是，当你在一个团队或世界范围内共享docker代码部分时，你还需要解释你的容器需要如何运行。</p><p id="023f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就我个人而言，我希望我所有的项目都像这样运作:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b7cd" class="mu lj jg mq b gy mv mw l mx my">git pull &amp;&amp; make test &amp;&amp; make build &amp;&amp; make deploy</span></pre><p id="4505" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以这种格式使用一行程序是非常强大的。你可以很容易地让一个同事带着你的产品(组件)去兜风，而不需要他/她费力地阅读一大堆自述文件。要么成功，要么失败。</p><p id="0713" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入好的旧Makefile。一个有40年历史的经典，仍然太年轻而不能退休，现在正在自动化项目中重生(这方面的简短阅读很好:<a class="ae jd" href="https://localheinz.com/blog/2018/01/24/makefile-for-lazy-developers/" rel="noopener ugc nofollow" target="_blank">为懒惰的开发人员制作文件</a>)。</p><p id="9fd7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我版本的Makefile文件,与Docker配合得很好:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="551f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您不熟悉Makefile，这可能看起来有点吓人。在你开始之前，你需要Docker。Docker安装说明在这里:<a class="ae jd" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>，<a class="ae jd" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank"> Mac </a>或者<a class="ae jd" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank"> Windows </a>。我还假设，你也知道如何打开一个外壳，安装一个git客户端，并可以运行make。推荐Linux发行版，但是我也在Mac上测试过。如果您已经设置好了，可以尝试以下命令:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="fde7" class="mu lj jg mq b gy mv mw l mx my"># download our files<br/>git clone <a class="ae jd" href="https://github.com/LINKIT-Group/dockerbuild" rel="noopener ugc nofollow" target="_blank">https://github.com/LINKIT-Group/dockerbuild</a></span><span id="446d" class="mu lj jg mq b gy nb mw l mx my"># enter directory<br/>cd dockerbuild</span><span id="85ed" class="mu lj jg mq b gy nb mw l mx my"># build, test and run a command<br/>make build test shell cmd="whoami"</span><span id="7e26" class="mu lj jg mq b gy nb mw l mx my"># my favorite for container exploration<br/>make shell</span><span id="3030" class="mu lj jg mq b gy nb mw l mx my"># shell-target is the default (first item), so this also works: <br/>make cmd="whoami"<br/>make cmd="ls /"</span><span id="0fd9" class="mu lj jg mq b gy nb mw l mx my"># force a rebuild, test and cleanup<br/>make rebuild test clean</span></pre><p id="9707" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意我没有在任何地方使用“&amp;&amp;”字符？您可以使用单个make命令和一个目标列表(例如，构建、测试、清理)，一旦遇到错误就停止。</p><p id="0cc2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Makefile中，您可以定制在特定目标上运行的一行程序。就我个人而言，我总是喜欢在运行语句中添加“— rm”，以防止以一串废弃的容器结束。如果你仔细阅读Makefile，你会看到更多有趣的东西可以尝试。</p><p id="e3b9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该想要定制测试目标，并使测试成为标准实践。当您的构建部分被集成到CI/CD管道中时(最终，它会)，存在“make test”是非常有用的。</p><p id="911d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这里开始，添加部署目标只需要一步，将容器推到Docker-hub或类似的存储库。持续部署是真正令人兴奋的地方。不幸的是，这也需要更多的写作空间，这就是为什么我需要把它留到后续文章(或两篇)中。</p><p id="aac1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们转向部署之前，我们需要再了解一个基本的配置实践。注意到Makefile中的HOST_USER和HOST_UID变量了吗？这些在运行时被填充，并被重新导出供docker-compose读取。这让我想到了关于uid的下一章。</p><h1 id="652e" class="li lj jg bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated"><strong class="ak">处理uid</strong></h1><p id="c8b8" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当没有配置UserID (UID)时，Docker将容器默认为用户root。当您开始处理生产系统时，正确配置用户是必需的。你可以在<a class="ae jd" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">码头工人最佳实践清单</a>上读到它，K8s 的这篇文章也很好地涵盖了它。</p><p id="47c2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您在Mac上本地运行测试时，root被映射到您自己的用户，所以一切正常。生产平台应该配置为用户隔离，但这并不总是默认的。例如，如果您在Linux系统上运行您的测试(没有重新映射)，您很可能会遇到Docker生成的文件属于root 的问题。</p><p id="84a0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个系统上有多个用户时，您也会遇到问题。即使您不共享一个系统，运行并行测试也需要分离。此外，您如何传递凭证(例如，通过以~/的形式链接卷)。ssh和~/。aws)没有正确的UID设置？后者是处理基础架构部署时的常见模式。</p><p id="2e58" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你开始成为一个更密集的docker-consumer，你的团队会成长，事情会变得复杂，最终你会想要或者需要在你所有的项目中嵌入UID分离。</p><p id="c71c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，早期配置UID(相对)容易。虽然我花了一些时间进行良好的设置，但我现在有了一个模板(假设使用了Makefile)可以自动完成所有工作，几乎不费吹灰之力。</p><p id="f6b1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个可以使用的<strong class="kf jh"> docker-compose </strong>文件的副本:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ba01" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些神奇的东西就在这些变量语句中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4c30" class="mu lj jg mq b gy mv mw l mx my">${HOST_USER:-nodummy}<br/>${HOST_UID:-4000}</span></pre><p id="03cd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将从运行时复制变量，如果不存在，则分别默认为“nodummy”和“4000”。如果你不喜欢默认值，就这样做:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a64e" class="mu lj jg mq b gy mv mw l mx my">${HOST_USER:?You forgot to set HOST_USER in .env!}<br/>${HOST_UID:?You forgot to set HOST_UID in .env!}</span></pre><p id="0023" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意“HOST_”前缀。我避免直接使用用户和UID。这些变量不保证在运行时可用。用户通常在shell中可用，但是UID通常是Docker不会选择的环境变量。拥有一个单独的命名方案可以防止意外，并允许灵活地配置自动化管道。</p><p id="dda0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> Dockerfile </strong>看起来是这样的:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7d34" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们建立了一个小的(它只有10MB，微服务FTW！)添加了bash的Alpine container，用于娱乐和练习。我们应用所谓的<a class="ae jd" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">分阶段构建</a>的概念来保持基础映像(可重用的构建组件)与用户映像(为特定运行准备的映像)分离。</p><p id="ec69" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Makefile时，所有的变量都是自动设置的，如前一章所述。这个Dockerfile在没有Makefile的情况下也能很好地工作，但是用户仍然可以在他们自己的运行时或者一个单独的<a class="ae jd" href="https://docs.docker.com/compose/env-file/" rel="noopener ugc nofollow" target="_blank"> env-file </a>中配置变量。就我个人而言，我只是使用Makefiles，因为我喜欢零工作量。</p><p id="26bd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一件事。如果您处于开发模式，您可能会遇到某种障碍，需要您以root用户身份进行故障诊断。只需键入:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a7b9" class="mu lj jg mq b gy mv mw l mx my">make shell user=root</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="20c2" class="li lj jg bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">包装它</h1><p id="a8e5" class="pw-post-body-paragraph kd ke jg kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我希望这篇文章对你有用。完整代码可在<a class="ae jd" href="https://github.com/LINKIT-Group/dockerbuild" rel="noopener ugc nofollow" target="_blank"> github </a>获得。</p><p id="70c0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们构建一个新的服务时，我们可以简单地通过复制/粘贴这些文件(Makefile、Dockerfile和docker-compose.yml)来启动我们的项目，在需要的地方进行修改，并立即启动和运行我们的新服务。</p><p id="b916" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Docker+Makefile过程不仅使您的部分可移植，而且对您的团队(或整个世界)来说也是可重用的，并且允许附带测试规则的运输。欢迎来到X-Ops的世界！</p><p id="17f0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码愉快，下一篇文章再见！</p></div></div>    
</body>
</html>