<html>
<head>
<title>Simple Wizard Stepper for your Angular Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的Angular Web应用程序提供简单的向导步进器</h1>
<blockquote>原文：<a href="https://itnext.io/simple-wizard-stepper-for-your-angular-web-apps-31b9edaebd9a?source=collection_archive---------0-----------------------#2020-08-21">https://itnext.io/simple-wizard-stepper-for-your-angular-web-apps-31b9edaebd9a?source=collection_archive---------0-----------------------#2020-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9ae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在Angular中创建一系列Web组件，避免为其导入整个库。在这篇文章中，我将为你的Angular Web应用程序和PWAs(渐进式Web应用程序)创建一个简单的向导步进器，只使用“普通的”Angular组件和服务，以一种你可以在提供出色的用户体验的同时巩固你的视图的方式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/04f47d5b63a1b7d9d7e5ad08ed84b05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/1*Qzw3xfBjSYNAy0b7DJrAUA.gif"/></div></figure><blockquote class="kt ku kv"><p id="c9f1" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">从属关系:<a class="ae la" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角度CLI </a></p></blockquote><p id="810a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在Angular中为自己构建一个又酷又简单又灵活的向导步进器组件，同时学习一些重要的概念:</p><ul class=""><li id="ea95" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">创建相互无缝通信的封装的、解耦的组件</li><li id="987d" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">使用服务实现组件间的通信</li><li id="1aec" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">使用<a class="ae la" href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" rel="noopener ugc nofollow" target="_blank"> Flexbox模型</a>以灵活、快速的方式设计组件</li></ul><p id="d5b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始吧！</p><h1 id="1dc0" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建项目</h1><p id="b522" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">继续，通过Angular CLI使用命令创建项目</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="7ae4" class="mx lq iq mt b gy my mz l na nb">ng new simple-wizard-stepper</span></pre><p id="64be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在添加角度路由时选择<strong class="jp ir">是</strong>，并在项目创建过程中出现提示时选择<strong class="jp ir"> SCSS </strong>作为样式表格式。</p><p id="4f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将为这个项目使用一个光滑的<a class="ae la" href="https://fonts.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌字体</a>,并且我也将通过从CDN引用一些<a class="ae la" href="https://material.io/resources/icons/?style=baseline" rel="noopener ugc nofollow" target="_blank">材质图标</a>用于网络。将下面的链接放在项目的<strong class="jp ir">index.html</strong>的<strong class="jp ir"> <em class="kw"> &lt;头&gt; </em> </strong>标签内。稍后我们将展示如何使用它们。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="0c80" class="mx lq iq mt b gy my mz l na nb">&lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"&gt;</span><span id="81e4" class="mx lq iq mt b gy nc mz l na nb">&lt;link href="https://fonts.googleapis.com/css2?family=Alata&amp;display=swap" rel="stylesheet"&gt;</span></pre><p id="e8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的应用程序的主<strong class="jp ir">index.html</strong>应该是这样的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的根目录下，在<strong class="jp ir"> src/app </strong>文件夹中，我将为更好的项目结构创建几个目录。我将创建名为<strong class="jp ir">组件、模型、页面</strong>和<strong class="jp ir">服务</strong>的目录。你的结构应该看起来如下(从<strong class="jp ir"> <em class="kw"> src </em> </strong>根):</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="ae7d" class="mx lq iq mt b gy my mz l na nb">- src<br/>  - app<br/>    - components<br/>    - models<br/>    - pages<br/>    - services</span></pre><h1 id="254d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">建立基金会</h1><p id="3ac7" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们已经决定，我们将在这个应用程序中有几个页面和几个组件，以及路由，所以我们需要清理现有的应用程序组件页面(在项目创建期间生成)以适应这种变化。转到<strong class="jp ir">app.component.html</strong>文件，清除锅炉板内容并替换为:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<strong class="jp ir"> &lt;路由器出口&gt; </strong>接入Angular的路由框架来显示页面。现在，导航到<strong class="jp ir"> app.component.scss </strong>并用以下内容替换它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><blockquote class="kt ku kv"><p id="389f" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">我使用的策略是将最外层的容器(<strong class="jp ir"> app-page-container </strong>)绝对定位并拉伸到页面的边缘(<em class="iq">，方法是将</em> <strong class="jp ir"> <em class="iq">【顶部】</em> </strong> <em class="iq">，</em> <strong class="jp ir"> <em class="iq">右侧</em> </strong> <em class="iq">，</em> <strong class="jp ir"> <em class="iq">底部</em> </strong> <em class="iq">和</em> <strong class="jp ir"> <em class="iq">左侧</em> </strong> <em class="iq">设置为0 </em></p></blockquote><h1 id="2b5c" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建资产</h1><p id="93c1" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">这个文件夹应该已经作为初始项目创建的一部分存在，所以我喜欢用它来放置可共享的资产、图像、样式等。我可以在整个应用程序中利用它。继续在这个文件夹中创建一个名为<strong class="jp ir"> colors.scss </strong>的文件。该文件将包含两个值:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="9f2f" class="mx lq iq mt b gy my mz l na nb"><strong class="mt ir">$blue: </strong>rgb(62, 112, 155);<br/><strong class="mt ir">$white:</strong> #FFF;</span></pre><p id="af74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae la" href="https://sass-lang.com/guide" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>SCSS允许你用你的CSS值创建变量，这样它们可以在整个应用程序中重用，这非常方便。我们将在下面的应用程序的其他组件中导入此文件，以便您可以看到它的强大功能；).</p><h1 id="dfd6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建模型</h1><p id="59d3" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">让我们从<strong class="jp ir">型号</strong>文件夹开始。我将创建一个Typescript接口，该接口将定义step对象的模式。创建一个名为<strong class="jp ir"> step.model.ts </strong>的文件，内容如下:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c41c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想跟踪该步骤的索引(<strong class="jp ir"> <em class="kw"> stepIndex </em> </strong>)，以及该步骤是否完成(<strong class="jp ir"> <em class="kw"> isComplete </em> </strong>)。</p><h1 id="ed41" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建组件</h1><p id="028e" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我将首先创建保存步骤向导气泡的外壳组件，以及模拟各个步骤的外壳组件模板。让我们现在创建它们，稍后再详细讨论它们。使用Angular CLI命令创建步骤组件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="e99b" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate component steps</span></pre><p id="5684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将生成该组件所需的文件。现在创建步骤模板组件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="c459" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate component step-template</span></pre><p id="64ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后我们将更详细地讨论这些，并提供它们的实现。</p><h1 id="0526" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建服务</h1><p id="ecc9" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">现在让我们进入<strong class="jp ir">服务</strong>文件夹，以便创建将在全局级别保存步骤状态的服务。在文件夹中，通过发出以下命令创建服务</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="35ba" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate service steps</span></pre><p id="00a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将生成一个<strong class="jp ir"> steps.service.ts </strong>文件。在这个文件中，我们可以添加以下代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，在这个服务中，我们有两个属性<a class="ae la" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">、行为主体</strong> </a>、<strong class="jp ir">步骤$ </strong>和<strong class="jp ir">当前步骤$ </strong>，分别用于保存向导可用的步骤列表以及流程中的当前步骤。通过将它们创建为<a class="ae la" href="https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject" rel="noopener ugc nofollow" target="_blank"> BehaviorSubject </a>属性，我们允许它们成为“可订阅的”,这样无论何时它们发生变化，订阅者都可以获得它们的值，以及它们的初始值。</p><p id="ce32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用一个名为<strong class="jp ir">步骤</strong>的预定义步骤数组初始化<strong class="jp ir">步骤$ </strong>行为主题，用null初始化<strong class="jp ir">当前步骤$ </strong>。当用户订阅它们时，他们将分别收到初始步骤列表和空的当前步骤。</p><p id="1463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还围绕这些<strong class="jp ir"> BehaviorSubject </strong>属性创建了一套非常全面的方法，以便对它们进行封装，并使服务用户能够进行以下选择:</p><ul class=""><li id="7de6" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"><em class="kw"/></strong>:检索当前显示的步骤；返回一个<strong class="jp ir">可观察对象</strong>，它包装了一个<strong class="jp ir"> StepModel </strong>，这样用户就可以订阅它。</li><li id="d692" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"><em class="kw">setCurrentStep</em></strong>:通过传递一个<strong class="jp ir"> StepModel </strong>对象来设置当前步骤。此外，无论是谁通过调用<strong class="jp ir"><em class="kw">getCurrentStep</em></strong>方法订阅了currentStep$属性，他们都将收到当前步骤的内容。</li><li id="991f" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kw"> getSteps </em> </strong>:获取作为StepModel对象数组的可用步骤的完整列表；也作为一个<strong class="jp ir">可观察的&lt; StepModel[] &gt; </strong>返回，这样用户就可以订阅并接收来自它的更新。</li><li id="d35a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"><em class="kw">moveToNextStep</em></strong>:程序化移动到下一步；这个逻辑被封装到这个服务中，因此它可以被集中在服务中的一个动作触发，并且任何可以访问该服务的组件都可以调用它。</li><li id="ca5e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kw"> isLastStep </em> </strong>:检查我们是否处于向导的最后一步；返回一个布尔标志，以允许服务的使用者检查它。</li></ul><h1 id="282e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建页面</h1><p id="ce46" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">让我们继续处理<strong class="jp ir"> <em class="kw">页的</em> </strong>文件夹。在这个文件夹中，我将创建两个*页面，<strong class="jp ir"> <em class="kw">表单页面</em> </strong>，它将保存一个简单表单页面中的步骤，以及<strong class="jp ir"> <em class="kw">完成页面</em> </strong>，我们将在完成表单步骤后重定向到该页面。在此文件夹中导航，并通过在命令行中发出以下命令来创建组件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="7044" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate component form-page</span></pre><blockquote class="kt ku kv"><p id="52c6" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">*一个<strong class="jp ir">页面</strong>只是一个组件的符号名称，它代表整个屏幕，通过自己的路线进行导航，还包含其他更小的组件——但最终，页面只是另一个普通的ol '组件。</p></blockquote><p id="05e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在生成的Typescript文件(<strong class="jp ir"> form-page.component.ts </strong>)中，我们添加以下代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="edf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来剖析一下<strong class="jp ir"> FormPageComponent </strong>类。检查我们如何注入<strong class="jp ir"> <em class="kw">步骤服务</em></strong>——管理应用程序中步骤状态的单一“事实来源”服务。通过注入它，消费者可以利用我们公开的方法来订阅由<strong class="jp ir"> BehaviorSubject </strong>属性本身广播的更新。</p><p id="3b3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意在<strong class="jp ir"> ngOnInit </strong>中我们是如何订阅步骤服务的<em class="kw"> getCurrentStep() </em>的，它返回了<strong class="jp ir"> currentStep$ </strong>的行为主题的<strong class="jp ir">可观察值</strong>。</p><p id="f443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<strong class="jp ir"> onNextStep() </strong>检查我们是否处于最后一步，这样它就可以提交表单，如果不是，就无缝地前进到下一步。表单通过<strong class="jp ir"> onSubmit() </strong>方法提交(为了这个项目),只需导航到另一个页面——这是您发出HTTP POST请求的地方，成功后导航到下一个页面。</p><p id="01d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> showButtonLabel() </strong>方法根据向导是否处于最后一步，为我们稍后将设置的按钮返回正确的标签字符串。</p><blockquote class="kt ku kv"><p id="8aba" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">注意:</em> </strong>注意，在检索getCurrentStep()的可观察引用后，我没有取消订阅。这是因为我在表单的HTML中使用了Angular的<a class="ae la" href="https://angular.io/api/common/AsyncPipe" rel="noopener ugc nofollow" target="_blank">异步管道</a>，因为它会自动退订。尽可能使用这种方法。</p></blockquote><p id="dc43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个组件中的功能是如何协调和简化的——将所有繁重的工作委托给服务，并以非常封装的方式调用服务中的逻辑。</p><p id="dbfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为表单页面创建标记:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b6d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查我是如何在表单页面容器的顶部嵌入步骤组件的(<strong class="jp ir"> app-steps </strong>)，并且我使用一个非常简单的逻辑，根据当前步骤的索引使用一个简单的Angular <strong class="jp ir"> ngSwitch </strong>指令在可用的步骤之间切换。</p><blockquote class="kt ku kv"><p id="029b" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">对于本教程来说，这是一种简单的方法，更好的方法是使用子路由，并且每个步骤都是完全独立的组件。</p></blockquote><p id="b90e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我也开始使用步骤模板(<strong class="jp ir"> app-step-template </strong>)，并将当前步骤作为组件的输入传递给它(<strong class="jp ir"> step </strong>)。我们将在一分钟内实现该部分，请耐心等待！</p><p id="d047" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我想把你的注意力引向表单中的最后一个组件——按钮<strong class="jp ir">表单-继续-btn </strong>。我在这里使用了<strong class="jp ir"> showButtonLabel() </strong>，它根据步骤的当前状态返回正确的标签，并且我只在当前步骤完成时启用按钮，如果是这样，那么并且只有这样才能执行<strong class="jp ir"> onNextStep() </strong>方法。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="5535" class="mx lq iq mt b gy my mz l na nb">&lt;button<br/>   (click)="<strong class="mt ir">onNextStep()</strong>"<br/>   [disabled]="<strong class="mt ir">!(currentStep | async)?.isComplete</strong>"<br/>   class="form-continue-btn"&gt;<br/>   {{ <strong class="mt ir">showButtonLabel()</strong> }}<br/>&lt;/button&gt;</span></pre><p id="d672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看表单页面的CSS:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="96f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们是如何在文件顶部导入SCSS <strong class="jp ir"> colors.scss </strong>的，这样我们就可以在整个应用程序中重复使用<strong class="jp ir"> $blue </strong>颜色。接招吧，普通的老CSS！</p><h1 id="8634" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Flexbox模型正在运行！</h1><p id="a0a8" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">因为<strong class="jp ir">表单-页面-容器</strong>是上面描述的<strong class="jp ir">应用程序-页面-容器</strong>的子容器，它将在高度方向上伸展到100%以占据其父容器的高度。使用display: flex和flex-direction: column，我将允许其子组件以灵活的方式运行。</p><p id="4d40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">表单页面容器</strong>包含<strong class="jp ir"> app-steps </strong>组件、<strong class="jp ir"> step-page容器</strong>和<strong class="jp ir">表单-继续按钮</strong>。通过使step-page-container to<strong class="jp ir"><em class="kw">flex:1</em></strong>，它将占据父容器中的大部分空间，同时将其余组件推到边缘(将<strong class="jp ir"> app-steps </strong>推到顶部，将<strong class="jp ir"> form-continue-btn </strong>推到底部)。无论屏幕大小如何，<strong class="jp ir"> step-page-container </strong>将始终占据大部分视窗空间，并将其余元素推到边缘，这要归功于Flexbox模型策略。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/a454597088a04ddd1f3b1f433a592dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Gpgsi9S6bQDxa8klcN9Aw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">step-page-container上的flex: 1处理如何将顶部和底部组件推到它们的边缘，同时保持灵活性且不固定高度。</figcaption></figure><p id="62f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，创建<strong class="jp ir">完整页面</strong>页面组件:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="734c" class="mx lq iq mt b gy my mz l na nb">&gt; ng generate component complete-page</span></pre><p id="2117" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在生成的【complete-page.component.html】中，删除此内容:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="005c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在生成的<strong class="jp ir">complete-page . component . scss</strong>中，删除此内容:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0114" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">。通过将Flexbox属性<strong class="jp ir"> justify-content </strong>和<strong class="jp ir"> align-items </strong>设置为居中，complete-page </strong>容器拉伸以填充其父容器的尺寸，并以灵活的方式保持其子容器始终位于中心。</p><h1 id="6f3d" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">现在—回到组件！</h1><p id="c17c" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">让我们回到我们将使用的主要组件—步骤组件。导航到先前创建的<strong class="jp ir"> steps.component.ts </strong>并应用以下代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fd74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我在这里也注入了<strong class="jp ir"> StepsService </strong>并订阅了<strong class="jp ir"> getSteps </strong>以获得所有可用步骤的通知，以及<strong class="jp ir"> getCurrentStep </strong>以在当前步骤发生变化时获得通知。通过操纵<strong class="jp ir">当前步骤$ </strong>和<strong class="jp ir">步骤$ </strong> <strong class="jp ir">行为主题</strong>属性(参见<strong class="jp ir"> onStepClick </strong>)的方法，在应用程序内的任何地方执行的对<strong class="jp ir">步骤服务</strong>的更改将被广播给所有订阅的客户端——在这种情况下，包括表单页面和该组件——以解耦的方式使它们始终保持同步。</p><p id="1a26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些组件几乎彼此不了解，但仍然通过服务相互通信。</p><p id="29b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看步骤组件的标记(<strong class="jp ir">steps.component.html</strong>):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查我们如何利用获取可用步骤的订阅来渲染尽可能多的可用步骤的气泡(*<strong class="jp ir"><em class="kw">ngFor = " let step of steps | async</em></strong>")，以及我们如何渲染一个名为step-divider的容器，该容器仅显示尽可能多的可用步骤(减去1)，因为我们不想显示最后一个气泡的步骤分隔线。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi no"><img src="../Images/8215702755c46c2a2821c04063b5d20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wL18X_XbH12ArJflY1SGJg.png"/></div></div></figure><p id="4a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还利用Angular <strong class="jp ir"> ngClass </strong>指令，在步骤状态通过其阶段(当前、未完成和完成)变化时以编程方式设置类:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="d1fe" class="mx lq iq mt b gy my mz l na nb">[ngClass]=”{<br/> ‘step-complete’: <strong class="mt ir">step.isComplete</strong>, <br/> ‘step-incomplete’: <strong class="mt ir">!step.isComplete</strong>, <br/> ‘step-current’: <strong class="mt ir">(currentStep | async)?.stepIndex === step.stepIndex</strong> }”</span></pre><p id="8a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看我是如何使用<strong class="jp ir"> ngIf </strong>显示步骤气泡之间的分隔线的:</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="e2d6" class="mx lq iq mt b gy my mz l na nb">&lt;div *ngIf=”<strong class="mt ir">i &lt; (steps | async)?.length — 1</strong>" class=”step-divider”&gt;&lt;/div&gt;</span></pre><p id="b113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来看看支持这个组件的CSS:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="46a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的——你注意到了。我们也在进口颜色。我告诉尤雅会看到使用scss的好处！。我们重用了<strong class="jp ir"> $blue </strong>变量，这是一个优点——我们的应用程序在调色板方面是内聚的。</p><p id="5f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> form-steps-container </strong>使用Flexbox模型的<strong class="jp ir">显示:space-between </strong>展开呈现在该容器内的片段——每个可用的步骤加上它们的分隔线。太棒了。</p><p id="aa6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，同样重要的是，让我们创建代表我们实际步骤的模板组件。如上所述，各个步骤可以作为彼此独立的单独组件来实现，但是要利用StepsService来订阅当前步骤并利用所有功能。</p><p id="b6fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为这些组件做一个简单的逻辑。导航到之前创建的<strong class="jp ir">步骤-template.component.ts </strong>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f8ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明其他组件可以参与BehaviorSubjects的广播策略和可以从它们生成的可观察性，以及引用如何单向流入其他组件，我创建了一个名为<strong class="jp ir"> <em class="kw">步骤</em> </strong>的<strong class="jp ir"> @Input </strong>属性，该属性将从实际订阅当前步骤的另一个组件接收当前步骤的引用。</p><p id="5d74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir"> onCompleteStep() </strong>方法实际上可以修改这个引用，甚至通过简单地修改它可用的属性(将<strong class="jp ir"> Step.isComplete </strong>更改为<strong class="jp ir"> true </strong>)来影响它的状态，这最终将触发对任何其他人的更改，这些人都有对这个相同的step对象引用的引用。魔法，对吧？不，不是真的——只是好的旧对象引用。</p><p id="4048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为这个组件获取一些简单的标记:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aa50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们在这里也是如何使用步骤的<strong class="jp ir"> stepIndex </strong>和<strong class="jp ir"> isComplete </strong>属性来驱动关于当前步骤的逻辑。当当前步骤发生变化时，该组件会拾取这些变化并显示给用户。</p><p id="fab0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是CSS:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="2b2a" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">最后一击:路线</h1><p id="2ad4" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">由于我们使用的是表单页面(<strong class="jp ir"> FormPageComponent </strong>)，它在模拟提交后会将用户重定向到完成页面(<strong class="jp ir"> CompletePageComponent </strong>)，因此我们需要为这个应用程序建立路由策略。确保您的<strong class="jp ir"> app-routing.module.ts </strong>如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b5c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我为每个可用页面添加了一个路径，并确保在启动应用程序时，默认情况下它会立即转到表单。</p><p id="2109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伙计们，到此为止！我们确保涵盖了以下所有内容:</p><ul class=""><li id="2648" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kw">创建了相互无缝通信的封装的、解耦的组件</em> </strong>(步骤组件、表单组件和步骤模板组件彼此互不了解)。</li><li id="ab9f" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"/></li><li id="bd80" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kw">使用</em> </strong> <a class="ae la" href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="kw"> Flexbox模型</em> </strong> </a> <strong class="jp ir"> <em class="kw">以灵活、响应迅速的方式对组件进行样式化</em> </strong>(通过使用display的强大功能:flex及其可用属性，使组成组件的页面和组件完全响应)</li></ul><p id="fa4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一定要看看我的<a class="ae la" href="https://github.com/romanejaquez/simple-wizard-stepper" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>里面包含了这段代码提供的全部代码。</p><p id="2089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别忘了在下面鼓掌(直到手疼！)如果你觉得这个帖子有用，在社交媒体上关注我<a class="ae la" href="https://twitter.com/drcoderz" rel="noopener ugc nofollow" target="_blank"> @drcoderz </a>。</p><p id="6a7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！</p></div></div>    
</body>
</html>