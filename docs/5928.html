<html>
<head>
<title>Flutter x GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动x图QL</h1>
<blockquote>原文：<a href="https://itnext.io/flutter-x-graphql-a2dea05e6564?source=collection_archive---------0-----------------------#2021-07-01">https://itnext.io/flutter-x-graphql-a2dea05e6564?source=collection_archive---------0-----------------------#2021-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/efa4304aa5742b1402ca66b620eb1e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GV5VvApVnOhnSYzj_ypAQQ.png"/></div></div></figure><p id="d2a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名前端开发人员，我已经在很多使用<strong class="ka ir">REST API</strong>的项目上工作了很长时间，我已经注意到了一些与REST交互时的低效率。</p><ul class=""><li id="0ab4" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">源代码中有太多的端点，我需要处理它们。</li><li id="0478" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">尽管我只想在我的<strong class="ka ir"> UI </strong>上显示一个单独的字段，但是服务器可能会向我发送更多不必要的数据。</li><li id="cc7f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">与后端团队沟通以澄清API文档需要花费大量时间。</li><li id="d24a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">请求对象(前端)的结构必须依赖于服务器端。</li></ul><p id="e49b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你有没有因为以上原因浪费了很多时间？好吧，如果你已经回答了"<strong class="ka ir"> Yes </strong>"，那么GraphQL将会节省你的时间。</p><h2 id="2fa7" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><strong class="ak">那么，GraphQL到底是什么？</strong></h2><blockquote class="md me mf"><p id="6246" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">GraphQL是一种用于应用编程接口(API)的查询语言和服务器端运行时，它优先向客户端提供它们所请求的数据，而不是更多。</p><p id="0a03" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">GraphQL旨在使API快速、灵活且对开发人员友好。它甚至可以部署在一个称为GraphiQL的集成开发环境(IDE)中。作为REST的替代方案，GraphQL允许开发人员在一个API调用中构造从多个数据源提取数据的请求。</p><p id="78d0" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">——<a class="ae mk" href="http://redhat.com" rel="noopener ugc nofollow" target="_blank">redhat.com</a></p></blockquote><p id="5674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你阅读上面的定义时，我相信你会想到SQL(结构化查询语言)并回忆起“传奇”术语，如大学一年级时的<strong class="ka ir"> SELECT </strong>、<strong class="ka ir"> INSERT </strong>、<strong class="ka ir"> UPDATE </strong>、<strong class="ka ir"> DELETE、</strong>和<strong class="ka ir"> WHERE </strong>。</p><p id="60b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，这个定义会让你想起休息，我相信你会想到另一个传奇术语:<strong class="ka ir"> C.R.U.D </strong>，对吗？</p><p id="6bef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们有一个结合了所有这些传奇流行语的东西呢？没错，救了我一命的人诞生了<strong class="ka ir"> — GraphQL。</strong></p><p id="0eb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文的范围内，我们将从前端的角度开始介绍GraphQL的基本概念。</p><h1 id="5d8e" class="ml ll iq bd lm mm mn mo lp mp mq mr ls ms mt mu lv mv mw mx ly my mz na mb nb bi translated"><strong class="ak"> GraphQL操作</strong></h1><p id="66ae" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">GraphQL操作主要有三种:<strong class="ka ir">查询、变异、订阅。</strong></p><blockquote class="md me mf"><p id="0635" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">假设我们的模式中有一个模型<code class="fe nh ni nj nk b">ticket</code>，这个模型包含三个字段:<code class="fe nh ni nj nk b">id, status, created_at</code></p></blockquote><h2 id="bc23" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><strong class="ak">查询(只读获取)</strong></h2><p id="ceb6" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated"><strong class="ka ir"> 1。获取多个条目</strong></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。获取单个条目</strong></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="b077" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><strong class="ak">突变(先修改再提取)</strong></h2><p id="8094" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated"><strong class="ka ir"> 1。添加单个条目</strong></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="204b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。更新条目</strong></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。删除一个条目</strong></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="a546" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><strong class="ak">订阅(实时数据查询)</strong></h2><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="c758" class="ml ll iq bd lm mm mn mo lp mp mq mr ls ms mt mu lv mv mw mx ly my mz na mb nb bi translated"><strong class="ak">现在，让我们把它应用到颤振上</strong></h1><p id="3a45" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">首先，为了使用GraphQL，你需要一个服务器库(除非你有一个坚实的后端团队)。有很多受支持的服务器库，但是我善意地建议你使用<a class="ae mk" href="https://graphcms.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"/></a><strong class="ka ir">。</strong></p><p id="287c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，为了让你的Flutter项目能够使用GraphQL，你需要一个GraphQL客户端以便与服务器通信，在<strong class="ka ir"> pub.dev </strong>上有一些很棒的库，比如<a class="ae mk" href="https://pub.dev/packages/graphql_flutter" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">graph QL _ Flutter</strong></a>、<a class="ae mk" href="https://pub.dev/packages/ferry" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> ferry </strong> </a>。</p><h2 id="75d7" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><strong class="ak">编码时间！</strong></h2><p id="fdd8" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">(以下所有的脚本和相关的东西都可以在这个回购:<a class="ae mk" href="https://github.com/dubydu/fluttour" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">flutour</strong></a>)。开始之前，请先看一下自述文件。</p><p id="67c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的是:</p><ol class=""><li id="918f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nr lc ld le bi translated">创建一个基本GraphQLAPIClient。</li><li id="6b0e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nr lc ld le bi translated">创建一个异步函数，包含我们希望在GraphQLAPIClient扩展的类中执行的<em class="mg">突变/查询/订阅</em>文档。然后，处理异常并解析响应中的数据。</li><li id="8e21" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nr lc ld le bi translated">在从<strong class="ka ir"> ChangeNotifier </strong>扩展的provider类中创建另一个异步函数，在步骤2调用该函数并开始数据处理。</li><li id="9e89" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nr lc ld le bi translated">通知侦听器，来自服务器的数据可能已经更改。</li></ol><h2 id="2513" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated"><strong class="ak">创建一个基础GraphQLAPIClient </strong></h2><pre class="nl nm nn no gt ns nk nt nu aw nv bi"><span id="67b4" class="lk ll iq nk b gy nw nx l ny nz">&gt; <a class="ae mk" href="https://github.com/dubydu/fluttour/blob/6a2ed6f521665a2feaa3dae322807e4a9801cf22/lib/data/api/api_client.dart#L4" rel="noopener ugc nofollow" target="_blank">api_client.dart</a></span><span id="86ef" class="lk ll iq nk b gy oa nx l ny nz">GraphQLClient(<br/>     cache: GraphQLCache(<br/>       store: HiveStore(),<br/>     ),<br/>     link: _link,<br/>     defaultPolicies: DefaultPolicies(<br/>       watchQuery: policies,<br/>       query: policies,<br/>       mutate: policies,<br/>     ),<br/>   );<br/>}</span></pre><p id="a29d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们创建了一个私有的<strong class="ka ir"> _client </strong>函数，它返回一个GraphQLClient构造函数</p><ul class=""><li id="f4a8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">缓存:</strong>数据存储中使用的初始缓存。</li><li id="7e98" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">链接:</strong>将GraphQL文档解析为响应的链接。在这种情况下，我们使用<strong class="ka ir"> HttpLink </strong>，我们将把它与<a class="ae mk" href="https://github.com/dubydu/fluttour/blob/6a2ed6f521665a2feaa3dae322807e4a9801cf22/lib/data/api/api_client.dart#L11" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">AuthLink</strong></a><strong class="ka ir"/>连接起来，以便附加我们的<strong class="ka ir"> GraphCMS </strong>公共令牌。</li><li id="c7ea" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">默认策略:</strong>为每个客户端动作设置的默认策略。</li></ul><p id="d6c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们创建一个<a class="ae mk" href="https://github.com/dubydu/fluttour/blob/cd10d0f9cbc564645a26c1a7e5256a458ddd4e85/lib/data/api/api_client.dart#L37" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mg">查询</em> </strong> </a>函数来执行我们的查询。</p><pre class="nl nm nn no gt ns nk nt nu aw nv bi"><span id="c80b" class="lk ll iq nk b gy nw nx l ny nz">Future&lt;QueryResult&gt; query(String queries) async {<br/>  final WatchQueryOptions _options = WatchQueryOptions(<br/>    document: gql(queries),<br/>    pollInterval: Duration(seconds: 15),<br/>    fetchResults: true,<br/>  );<br/>  return await _client().query(_options);<br/>}</span></pre><p id="8b11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们创建一个<a class="ae mk" href="https://github.com/dubydu/fluttour/blob/cd10d0f9cbc564645a26c1a7e5256a458ddd4e85/lib/data/api/api_client.dart#L47" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mg">变异</em> </strong> </a>函数来将变异发送到服务器。</p><pre class="nl nm nn no gt ns nk nt nu aw nv bi"><span id="2f0e" class="lk ll iq nk b gy nw nx l ny nz">Future&lt;QueryResult&gt; mutation(String queries) async {<br/>  final MutationOptions _options = MutationOptions(<br/>    document: gql(queries),<br/>  );<br/>  return await _client().mutate(_options);<br/>}</span></pre><p id="40aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很酷吧？</p><h2 id="4cf1" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">创建请求</h2><p id="8660" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">在从GraphQLAPIClient扩展的类中，我们创建了一个请求函数来发送<code class="fe nh ni nj nk b">mutate/query/subscription</code>到服务器。</p><pre class="nl nm nn no gt ns nk nt nu aw nv bi"><span id="ecf9" class="lk ll iq nk b gy nw nx l ny nz">Future&lt;T&gt; get() async {<em class="mg"><br/>  </em>String your_query= """<br/>    query {<br/>          /// write your query<br/>      }<br/>  """;</span><span id="7731" class="lk ll iq nk b gy oa nx l ny nz">final result = await this.query(your_query);<br/>  if (result.hasException) {<br/>    handleException(result);<br/>    return [];<br/>  }<br/>  /// parse data &amp; return the T</span><span id="7dde" class="lk ll iq nk b gy oa nx l ny nz">}<br/>&gt;for example: <a class="ae mk" href="https://github.com/dubydu/fluttour/blob/develop/lib/data/api/request/signup_request.dart" rel="noopener ugc nofollow" target="_blank"><em class="mg">signup_request.dart</em></a></span></pre><p id="2a6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<strong class="ka ir"> <em class="mg">突变</em> </strong>，你要做的就是把<code class="fe nh ni nj nk b">this.query</code>改成<code class="fe nh ni nj nk b">this.mutation</code></p><h2 id="728f" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">数据处理/通知您的提供者类中的侦听器</h2><pre class="nl nm nn no gt ns nk nt nu aw nv bi"><span id="6320" class="lk ll iq nk b gy nw nx l ny nz">Future&lt;void&gt; get() async {<br/>  final result = await this._request.get();<br/>  if (result != null) { } else { }<br/>  // handle data &amp; notify the listeners here.<br/>  // there are a bunch of ways to notify the listeners, <br/>  // in this example, I'm using the delegation pattern and<br/>  // <a class="ae mk" href="https://api.flutter.dev/flutter/foundation/ChangeNotifier/notifyListeners.html" rel="noopener ugc nofollow" target="_blank">notifyListeners</a> function.</span><span id="16e9" class="lk ll iq nk b gy oa nx l ny nz">}<br/>&gt;for example: <a class="ae mk" href="https://github.com/dubydu/fluttour/blob/cd10d0f9cbc564645a26c1a7e5256a458ddd4e85/lib/pages/signup/signup_provider.dart#L70" rel="noopener ugc nofollow" target="_blank"><em class="mg">signup_provider.dart</em></a></span></pre><h1 id="ddd2" class="ml ll iq bd lm mm mn mo lp mp mq mr ls ms mt mu lv mv mw mx ly my mz na mb nb bi translated">陷阱</h1><p id="e0bd" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">1.为了运行这个项目，您需要在一个特定的环境中运行。</p><ul class=""><li id="c8b8" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">发展:<code class="fe nh ni nj nk b">flutter run -t lib/main_dev.dart</code></li><li id="9f46" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">生产:<code class="fe nh ni nj nk b">flutter run -t lib/main_prod.dart</code></li></ul><p id="3c8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.您需要一个个人访问令牌来对GraphCMS服务器进行身份验证。要得到一个，去https://graphcms.com/docs/authorization。</p><p id="879f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不想浪费你的时间，你可以用我的代币，这个代币在这个<a class="ae mk" href="https://github.com/dubydu/fluttour" rel="noopener ugc nofollow" target="_blank">回购</a>里有。</p><p id="2e81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">最后</strong>，享受你的工作，看看GraphQL有多不可思议。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h2 id="aec3" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">2021年9月29日更新</h2><blockquote class="md me mf"><p id="9393" class="jy jz mg ka b kb kc kd ke kf kg kh ki mh kk kl km mi ko kp kq mj ks kt ku kv ij bi translated">如果您在使用不同的GraphQL服务器库时遇到了这个问题:</p></blockquote><p id="2cf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nh ni nj nk b">Null value resolved for non-null field `__typename`</code></p><p id="3094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原因是<a class="ae mk" href="https://pub.dev/packages/graphql_flutter" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">graphql _ flutter</strong></a>库的<code class="fe nh ni nj nk b">gql document node</code>函数是自动添加<strong class="ka ir"> `__typename`s </strong>的，而上述这些graph QL服务器还没有支持这种类型。因此，为了解决这个问题，让我们定制另一个<code class="fe nh ni nj nk b">gql document node</code>函数。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div></div>    
</body>
</html>