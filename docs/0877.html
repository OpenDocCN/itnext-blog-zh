<html>
<head>
<title>Save on your AWS bill with Kubernetes Ingress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Kubernetes Ingress节省您的AWS账单</h1>
<blockquote>原文：<a href="https://itnext.io/save-on-your-aws-bill-with-kubernetes-ingress-148214a79dcb?source=collection_archive---------1-----------------------#2018-06-12">https://itnext.io/save-on-your-aws-bill-with-kubernetes-ingress-148214a79dcb?source=collection_archive---------1-----------------------#2018-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="a58c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">库伯内特斯的奇迹</h1><p id="5dce" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当你开始使用Kubernetes时，你学到的第一个概念是<a class="ae lj" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>。</p><p id="6687" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">内部服务允许pod发现和负载平衡。如果你需要让你的pod在互联网上可用，<strong class="kn ir">我认为</strong>，你应该使用类型为<code class="fe lp lq lr ls b">LoadBalancer</code>的服务。根据云提供商的不同，这将产生不同的影响；例如，在AWS上，它将为每个对外公开的<strong class="kn ir">服务创建一个ELB。</strong></p><blockquote class="lt lu lv"><p id="e3b9" class="kl km lw kn b ko lk kq kr ks ll ku kv lx lm ky kz ly ln lc ld lz lo lg lh li ij bi translated">ELBs很棒，但也不便宜。每月大约20美元(外加每GB数据处理的额外费用)。</p></blockquote><p id="f350" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你有几项服务，这将导致一笔<strong class="kn ir">巨额</strong> <strong class="kn ir">账单</strong>。</p><h1 id="d594" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">入口来了</h1><p id="7ecf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我花了一些时间来熟悉Kubernetes <a class="ae lj" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>。</p><blockquote class="lt lu lv"><p id="fd7f" class="kl km lw kn b ko lk kq kr ks ll ku kv lx lm ky kz ly ln lc ld lz lo lg lh li ij bi translated">Kubernetes擅长抽象常见的问题，并为您提供不同的具体实现。</p></blockquote><p id="4ecd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这正是Ingresses在使端点成为外部端点的上下文中所做的事情。您以一种通用格式指定某些服务应该如何被路由，并且您将实现这种路由的工作留给一个<strong class="kn ir">入口控制器</strong>。</p><p id="452c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">例如:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="40cd" class="mi jo iq ls b gy mj mk l ml mm">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>    nginx.ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  rules:<br/>  - host: foo.bar.com<br/>    http:<br/>      paths:<br/>      - path: /foo<br/>        backend:<br/>          serviceName: s1<br/>          servicePort: 80<br/>      - path: /bar<br/>        backend:<br/>          serviceName: s2<br/>          servicePort: 80</span></pre><p id="c879" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">该入口资源将期望接收对主机<code class="fe lp lq lr ls b">foo.bar.com</code>的请求，并根据请求路径将流量路由到服务<code class="fe lp lq lr ls b">s1</code>或<code class="fe lp lq lr ls b">s2</code>。您还可以基于主机进行路由(如下例所示)</p><p id="25a6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">需要明确的是，入口不能取代内部服务。你仍然希望你的每个应用/微服务都有一个内部服务——这意味着你的pod总是可以在同一个地址访问，不管它们是如何死亡或被创建的。然后入口会将外部流量路由到内部服务</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="97cc" class="mi jo iq ls b gy mj mk l ml mm">Request =&gt; Ingress =&gt; (Internal) Service =&gt; Pod</span></pre><p id="2f3e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">默认情况下，Kubernetes没有安装入口控制器。这是你的工作，选择一个(或者更多，如果你有更复杂的需求)。</p><h1 id="4142" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我的要求</h1><p id="bca0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们使用Kubernetes名称空间来分隔不同的环境。例如，在一个Kubernetes集群中，我们可能有一个<code class="fe lp lq lr ls b">test</code>、<code class="fe lp lq lr ls b">demo</code>和<code class="fe lp lq lr ls b">staging</code>名称空间。我不想每个人都有一个单独的ELB。这个太贵了。</p><p id="670c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我想将<code class="fe lp lq lr ls b">test</code>、<code class="fe lp lq lr ls b">demo</code>和<code class="fe lp lq lr ls b">staging</code>的DNS指向一个端点:</p><figure class="ma mb mc md gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mn"><img src="../Images/1820242fc18c4a7c53239897802bd477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PEkqkJNrf4uV_5vsSRF3PQ.jpeg"/></div></div></figure><h1 id="19a6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">ALB入口控制器</h1><p id="6c85" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我第一次遇到<a class="ae lj" href="https://github.com/kubernetes-sigs/alb-ingress-controller" rel="noopener ugc nofollow" target="_blank"> ALB入口控制器</a>，它听起来很有前途。它可以创建新的<a class="ae lj" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html" rel="noopener ugc nofollow" target="_blank">应用负载平衡器</a>，而不是创建弹性负载平衡器。</p><p id="bd6c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，该入口控制器可以转换入口资源，例如:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="eb5e" class="mi jo iq ls b gy mj mk l ml mm">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: test<br/>  annotations:<br/>    nginx.ingress.kubernetes.io/rewrite-target: /<br/>spec:<br/>  rules:<br/>  - host: foo.com<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: foo<br/>          servicePort: 80<br/>  - host: bar.com<br/>    http:<br/>      paths:<br/>      - path: /<br/>        backend:<br/>          serviceName: bar<br/>          servicePort: 80</span></pre><p id="dd26" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">一个ALB，有两个目标组:一个用于主机为<code class="fe lp lq lr ls b">foo.com</code>时的<code class="fe lp lq lr ls b">foo</code>服务，另一个用于主机为<code class="fe lp lq lr ls b">bar.com</code>时的<code class="fe lp lq lr ls b">bar</code>服务</p><p id="acae" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然而对我来说有一个主要的问题，因为在我写作的时候:</p><blockquote class="lt lu lv"><p id="3c4b" class="kl km lw kn b ko lk kq kr ks ll ku kv lx lm ky kz ly ln lc ld lz lo lg lh li ij bi translated">ALB入口控制器不支持跨多个名称空间的路由</p></blockquote><p id="be0b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果您在<code class="fe lp lq lr ls b">test</code>创建一个入口资源，在<code class="fe lp lq lr ls b">staging</code>创建一个入口资源，ALB入口控制器将创建两个ALB，这违背了整个要点。我已经在Github 上提出了这个<a class="ae lj" href="https://github.com/kubernetes-sigs/alb-ingress-controller/issues/329" rel="noopener ugc nofollow" target="_blank">问题，但是它似乎还没有进展。</a></p><h1 id="501f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案1: NGINX入口控制器</h1><p id="2f93" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不久前，我遇到了这个关于跨名称空间进入的Github问题，但不幸的是，我没有仔细阅读。读了第二遍后，我意识到这个解决方案非常简单，有了<a class="ae lj" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> NGINX入口控制器</a>。</p><p id="dfe9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">架构非常简单。您有一个指向NGINX的ELB，它在内部分发流量:</p><figure class="ma mb mc md gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mn"><img src="../Images/66d23628b9f1bf5a14f5ca219aa7d37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_iuAj3MRV6pREabpfpjmg.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">NGINX入口控制器</figcaption></figure><p id="ffe0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">好消息是这也很容易设置！</p><ol class=""><li id="d236" class="mz na iq kn b ko lk ks ll kw nb la nc le nd li ne nf ng nh bi translated">按照此处的<a class="ae lj" href="https://kubernetes.github.io/ingress-nginx/deploy/" rel="noopener ugc nofollow" target="_blank">说明安装NGINX入口控制器。</a></li><li id="acba" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li ne nf ng nh bi translated">在每个名称空间中定义一个入口资源</li></ol><p id="073c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于测试:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="478e" class="mi jo iq ls b gy mj mk l ml mm">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: api-ingresse-test<br/>  namespace: <strong class="ls ir">test</strong><br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>spec:<br/>  rules:<br/>  - host: test.blop.org<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: myApp<br/>          servicePort: 80<br/>        path: /</span></pre><p id="0b29" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于暂存:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="0e3e" class="mi jo iq ls b gy mj mk l ml mm">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: api-ingresse-staging<br/>  namespace: <strong class="ls ir">staging</strong><br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>spec:<br/>  rules:<br/>  - host: staging.blop.org<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: myApp<br/>          servicePort: 80<br/>        path: /</span></pre><p id="70f8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于演示:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="315b" class="mi jo iq ls b gy mj mk l ml mm">apiVersion: extensions/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: api-ingresse-demo<br/>  namespace: <strong class="ls ir">demo</strong><br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>spec:<br/>  rules:<br/>  - host: demo.blop.org<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: myApp<br/>          servicePort: 80<br/>        path: /</span></pre><p id="0420" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">瞧啊。没什么可做的了。NGINX入口控制器将处理这些资源，并自动创建单个ELB。然后，您只需将您的<code class="fe lp lq lr ls b">test</code>、<code class="fe lp lq lr ls b">demo</code>和<code class="fe lp lq lr ls b">staging</code> DNS指向ELB，工作就完成了！</p><p id="57dd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你想的话，你可以通过写配置映射来调优NGINX，但这不是必须的。它开箱即用。</p><p id="9b8b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了获得更好的可用性，您可以增加<code class="fe lp lq lr ls b">nginx-ingress-controller</code>的副本数量:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="8fd0" class="mi jo iq ls b gy mj mk l ml mm">kubectl -n ingress-nginx scale deploy nginx-ingress-controller --replicas=3</span></pre><h1 id="fd57" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">SSL终端</h1><p id="0a00" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您也可以轻松终止SSL流量。您可以选择在<a class="ae lj" href="https://kubernetes.github.io/ingress-nginx/deploy/#aws" rel="noopener ugc nofollow" target="_blank"> ELB级别</a>或者用<a class="ae lj" href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/tls.md" rel="noopener ugc nofollow" target="_blank"> NGINX </a>终止SSL。</p><p id="8e42" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">就个人而言，我更喜欢在ELB终止SSL，因为它非常容易设置(安装NGINX入口控制器时只需一个注释)。但是其他人可能喜欢NGINX提供的额外控制。</p><h1 id="eeb9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案2:大使</h1><p id="91a7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我遇到的第二个解决方案实际上并没有使用Ingress。</p><blockquote class="lt lu lv"><p id="835b" class="kl km lw kn b ko lk kq kr ks ll ku kv lx lm ky kz ly ln lc ld lz lo lg lh li ij bi translated"><a class="ae lj" href="https://www.getambassador.io/" rel="noopener ugc nofollow" target="_blank"> Ambassador </a>是一个构建在<a class="ae lj" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使代理</a>之上的Kubernetes-native微服务API网关。</p></blockquote><p id="4a2b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">它提供了与NGINX入口控制器相似的架构:</p><figure class="ma mb mc md gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mn"><img src="../Images/1ddd2ebeacbdcca60586d5fd139510b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2JVMoT33Z1ycuF9kZFkjQ.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">大使舱在你的集群中路由流量</figcaption></figure><p id="087f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先你需要安装大使，这很容易做到。</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="a452" class="mi jo iq ls b gy mj mk l ml mm">kubectl apply -f <a class="ae lj" href="https://getambassador.io/yaml/ambassador/ambassador-rbac.yaml" rel="noopener ugc nofollow" target="_blank">https://getambassador.io/yaml/ambassador/ambassador-rbac.yaml</a></span></pre><p id="1cac" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这将安装3个<code class="fe lp lq lr ls b">Ambassador</code>pod，它们将根据您的pod路由流量。这种冗余提供了高可用性，并有助于扩展负载。</p><p id="7839" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后您需要创建一个<code class="fe lp lq lr ls b">LoadBalancer</code>类型的服务来指向这些pod。对于AWS，您可以像<a class="ae lj" href="https://www.getambassador.io/reference/ambassador-with-aws" rel="noopener ugc nofollow" target="_blank">那样做</a>:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="feda" class="mi jo iq ls b gy mj mk l ml mm">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: ambassador-main<br/>  namespace: ambassador<br/>  annotations:<br/>    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "your_aws_cert_for_https"<br/>    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "*"<br/>    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"<br/>    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"<br/>    service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"<br/>    getambassador.io/config: |<br/>      ---<br/>      apiVersion: ambassador/v0<br/>      kind:  Module<br/>      name:  ambassador<br/>      config:<br/>        use_proxy_proto: lower<br/>        use_remote_address: true<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>  - name: ambassador<br/>    port: 443<br/>    targetPort: 80<br/>  selector:<br/>    service: ambassador</span></pre><p id="6cb7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这将创建一个单一的<code class="fe lp lq lr ls b">ELB</code>。如上所述，您可以将所有DNS名称指向该端点，并让Ambassador进行路由。</p><p id="b917" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">有了大使你<strong class="kn ir">不需要入口资源</strong>。您只需向服务添加注释。在我们的例子中，这个看起来像这样:</p><p id="26cd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果我们在<code class="fe lp lq lr ls b">test</code>、<code class="fe lp lq lr ls b">staging</code>和<code class="fe lp lq lr ls b">demo</code>中为我们的<code class="fe lp lq lr ls b">bar</code>应用程序提供了一个服务，我们将简单地添加<code class="fe lp lq lr ls b">getambassador.io/config</code>注释</p><p id="614e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于测试:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="6354" class="mi jo iq ls b gy mj mk l ml mm">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: test-bar<br/>  namespace: test<br/>  annotations:<br/>    getambassador.io/config: |<br/>      ---<br/>      apiVersion: ambassador/v0<br/>      kind:  Mapping<br/>      name:  test-bar<br/>      prefix: /<br/>      service: test-bar:8080<br/>      host: test.blop.org<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    app: bar<br/>  ports:<br/>    - protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080</span></pre></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="4f8e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于暂存:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="038a" class="mi jo iq ls b gy mj mk l ml mm">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: staging-bar<br/>  namespace: test<br/>  annotations:<br/>    getambassador.io/config: |<br/>      ---<br/>      apiVersion: ambassador/v0<br/>      kind:  Mapping<br/>      name:  staging-bar<br/>      prefix: /<br/>      service: staging-bar:8080<br/>      host: staging.blop.org<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    app: bar<br/>  ports:<br/>    - protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080</span></pre><p id="6159" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于演示:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="d36a" class="mi jo iq ls b gy mj mk l ml mm">kind: Service<br/>apiVersion: v1<br/>metadata:<br/>  name: demo-bar<br/>  namespace: demo<br/>  annotations:<br/>    getambassador.io/config: |<br/>      ---<br/>      apiVersion: ambassador/v0<br/>      kind:  Mapping<br/>      name:  demo-bar<br/>      prefix: /<br/>      service: demo-bar:8080<br/>      host: test.blop.org<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    app: bar<br/>  ports:<br/>    - protocol: TCP<br/>      port: 8080<br/>      targetPort: 8080</span></pre><p id="dd05" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Ambassador还提供了其他功能，如:</p><ul class=""><li id="2ecc" class="mz na iq kn b ko lk ks ll kw nb la nc le nd li nu nf ng nh bi translated">gRPC支持</li><li id="4381" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li nu nf ng nh bi translated">证明</li><li id="c972" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li nu nf ng nh bi translated">限速</li><li id="dbe6" class="mz na iq kn b ko ni ks nj kw nk la nl le nm li nu nf ng nh bi translated">Istio (服务网格)集成</li></ul><p id="d7b3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你想了解更多关于大使的信息，请点击这里查看。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="da4e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果你和我一样，已经使用多个ELB很长时间了，我希望这个简单的解决方案可以让你的AWS账单变得更轻一点！</p><p id="07a2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">不言而喻，这种架构也适用于GCE和Azure。</p><p id="ab68" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">PS:其他值得一提的入口控制器:</p></div></div>    
</body>
</html>