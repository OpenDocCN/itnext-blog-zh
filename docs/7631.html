<html>
<head>
<title>Creating Custom Scrollable Widget With Flutter (Not CustomScrollView)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flutter创建自定义可滚动小部件(不是CustomScrollView)</h1>
<blockquote>原文：<a href="https://itnext.io/creating-custom-scrollable-widget-with-flutter-not-customscrollview-229cb8f6c1fc?source=collection_archive---------1-----------------------#2022-12-01">https://itnext.io/creating-custom-scrollable-widget-with-flutter-not-customscrollview-229cb8f6c1fc?source=collection_archive---------1-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/238ed74777efa7eaa70a4fbb25c5f785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbrD995IdvMsEuq9_j7Gsw.png"/></div></div></figure><p id="e4cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所知，在Flutter中有许多可滚动的小部件。ListView、GridView等等。</p><p id="c2dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，有时这些小工具并不能满足我们的需求。例如，创建如下所示的视图，内置可滚动的小部件是不可能的。(至少我不会)。</p><p id="b90a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，通过尝试这个示例，您可以通过了解您所使用的可滚动小部件的错误原因以及这些小部件的工作逻辑来提高自己。</p><p id="63c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的示例中，黄色框在蓝色框上方滚动，红色框在蓝色框下方滚动。</p><div class="kw kx gp gr ky kz"><a href="https://youtube.com/shorts/wXEl-Q927sI" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">Flutter自定义可滚动小部件示例</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">阅读以了解如何创建这个小部件…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">youtube.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="d43b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些情况下，我们将使用一个小部件(以及其他可滚动的小部件):“scrollable”。</p><blockquote class="lo lp lq"><p id="45ea" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">也有人通过手势检测器和原始滚动信息来完成如此复杂的滚动。然而，为了实现无限滚动，使用滚动控制器并添加滚动物理特性，最好使用可滚动的而不是手势检测器。</p></blockquote><p id="73f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过这个例子来考察“可滚动”的用法。</p><h2 id="bf5c" class="lv lw iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">可滚动堆栈</h2><p id="db9d" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">首先，我用Stack创建了随像素信息随深度移动的小部件。</p><p id="58cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个小部件创建了我们想要的视图。但是还不能滚动。</p><p id="acc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们正确实现“pixels”getter时，小部件将是可滚动的。</p><p id="acb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是我们的主题，但是如果你想看看我是如何在这里创建盒子的:<a class="ae mt" href="https://dartpad.dev/?id=bf41c410306591caf9442a3642713627" rel="noopener ugc nofollow" target="_blank">镖靶</a></p><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="a09e" class="nd lw iq mz b be ne nf l ng nh"><br/>class ScrollableStack extends StatefulWidget {<br/>  const ScrollableStack({super.key});<br/><br/>  @override<br/>  State&lt;ScrollableStack&gt; createState() =&gt; _ScrollableStackState();<br/>}<br/><br/>class _ScrollableStackState extends State&lt;ScrollableStack&gt; {<br/>  <br/>  // We will use this to get scroll position<br/>  double get pixels =&gt; 0;<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Stack(<br/>      alignment: Alignment.center,<br/>      children: [<br/>        Positioned(<br/>            top: -pixels,<br/>            left: 0,<br/>            right: 0,<br/>            height: 100,<br/>            child: ...<br/>        )<br/>      ],<br/>    );<br/>  }<br/>}</span></pre><h2 id="f688" class="lv lw iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">使用可滚动</h2><p id="a153" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">“可滚动”小部件采用一个名为“viewportBuilder”的参数。这样我们就可以得到一个“视图端口偏移量”。</p><p id="e6b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须向滚动轴中的“ViewportOffset”声明一个维度和内容维度。</p><blockquote class="lo lp lq"><p id="fc6f" class="jy jz lr ka b kb kc kd ke kf kg kh ki ls kk kl km lt ko kp kq lu ks kt ku kv ij bi translated">在我的例子中，内容的总高度是3000。可以动态设置。</p></blockquote><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="31d6" class="nd lw iq mz b be ne nf l ng nh">Scrollable(<br/>    controller: controller,<br/>    viewportBuilder: (c, offset) {<br/>      offset!.applyViewportDimension(viewportHeight);<br/>      offset!.applyContentDimensions(0, 3000 - viewportHeight);<br/>       <br/>      return ScrollableStack();<br/>    })</span></pre><p id="0cac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们理解了您之前可能收到的错误的原因。</p><p id="b28a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的小部件在布局中必须有约束，这样我们才能给出视口的尺寸。现在我们需要知道极限，才能给出尺寸，如果我们不知道，就会出错。例如，如果我们在一个列中使用滚动视图(没有用展开的来包装它)，布局将没有垂直边界，并且滚动视图将给出一个错误，因为它不能获得垂直大小。</p><p id="84a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用LayoutBuilder来获取小部件的高度:</p><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="f55c" class="nd lw iq mz b be ne nf l ng nh">LayoutBuilder(builder: (context, constraints) {<br/>  assert(constraints.hasBoundedHeight,"Widget has not vertical boundaries");<br/>  return Scrollable(<br/>      viewportBuilder: (c, o) {<br/>        offset = o;<br/>        offset!.applyViewportDimension(constraints.maxHeight);<br/>        offset!.applyContentDimensions(0, 3000 - constraints.maxHeight);<br/>        return ScrollableStack();<br/>      });<br/>});</span></pre><p id="c817" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以为视口偏移创建监听器函数。</p><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="144b" class="nd lw iq mz b be ne nf l ng nh">class _ScrollableStackState extends State&lt;ScrollableStack&gt; {<br/>  ViewportOffset? offset;<br/><br/>  void _addListener(ViewportOffset offset) {<br/>    this.offset = offset;<br/>    offset.addListener(_listener);<br/>  }<br/><br/>  void _removeListener(ViewportOffset offset) {<br/>    offset.removeListener(_listener);<br/>  }<br/><br/>  void _listener() {<br/>    setState(() {});<br/>  }<br/><br/>  // ...<br/>}</span></pre><p id="e068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到达“_ScrollableStackState”方法:</p><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="988f" class="nd lw iq mz b be ne nf l ng nh">class _MyHomePageState extends State&lt;MyHomePage&gt; {<br/><br/>  /// Create key <br/>  final GlobalKey&lt;_ScrollableStackState&gt; _scrollableStackKey =<br/>      GlobalKey&lt;_ScrollableStackState&gt;();<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      body: LayoutBuilder(builder: (context, constraints) {<br/>          return Scrollable(<br/>              controller: controller,<br/>              viewportBuilder: (c, o) {<br/>                /// ...<br/>                return ScrollableStack(<br/>                  /// give the key<br/>                  key: _scrollableStackKey,<br/>                );<br/>              });<br/>        }),<br/>     );<br/>  }<br/>}</span></pre><p id="beeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">达到:</p><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="bdea" class="nd lw iq mz b be ne nf l ng nh">Scrollable(<br/>    controller: controller,<br/>    viewportBuilder: (c, o) {<br/>      /// ...<br/>      /// listen at the second frame<br/>      WidgetsBinding.instance.addPostFrameCallback((timeStamp) {<br/>        _scrollableStackKey.currentState?._addListener(viewportOffset);<br/>      });<br/>      return ScrollableStack(<br/>        key: _scrollableStackKey,<br/>      );<br/>    });</span></pre><p id="56f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取正确的像素:</p><pre class="mu mv mw mx gt my mz na bn nb nc bi"><span id="f220" class="nd lw iq mz b be ne nf l ng nh"><br/>class _ScrollableStackState extends State&lt;ScrollableStack&gt; {<br/>  ViewportOffset? offset;<br/><br/>  void _addListener(ViewportOffset offset) //..<br/><br/>  void _removeListener(ViewportOffset offset) //..<br/><br/>  void _listener() //..<br/><br/>  /// Get pixels<br/>  double get pixels =&gt; offset?.pixels ?? 0;<br/><br/>  @override<br/>  Widget build(BuildContext context) // ...<br/>}</span></pre><p id="f2c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧！</p><p id="78b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的可滚动部件已经准备好了。</p><p id="3445" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在这篇文章里写了一个非常简短的总结。如果你感兴趣，你可以回顾一下要点，看看如何管理性能，让第一个滚动开始，等等。</p><p id="bc95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要旨:【https://dartpad.dev/?id=bf41c410306591caf9442a3642713627 T2】</p></div></div>    
</body>
</html>