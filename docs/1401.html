<html>
<head>
<title>The Secret to Using Redux at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模使用Redux的秘密</h1>
<blockquote>原文：<a href="https://itnext.io/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a?source=collection_archive---------1-----------------------#2018-10-07">https://itnext.io/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a?source=collection_archive---------1-----------------------#2018-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3e66ebc10b04b313c9d3d8b85d18c674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*piBYd1VUgpXYEtwP"/></div></div></figure><div class=""/><div class=""><h2 id="2880" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">打开一个你从来不知道的工具。</h2></div><p id="00d5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每次我在Redux上看到一个演讲或观看一个视频，或者在React中使用哪种状态，都是一样的——谈论什么时候使用组件状态、新的上下文API或Redux。</p><p id="77ca" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我觉得人们忽略了一些东西，真的。这就是<code class="fe lm ln lo lp b">createNamespaceReducer</code>的用武之地。当<strong class="ks jc">你总是可以使用Redux </strong>的时候，为什么要选择3个完全不同的状态系统中的哪一个呢？</p><p id="6361" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文并不是专门讨论在Redux中处理所有状态，而是使用<code class="fe lm ln lo lp b">createNamespaceReducer</code>来帮助将所有状态放入Redux中。</p><p id="d101" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我看到了组件状态的很多好处，但是我不喜欢处理<code class="fe lm ln lo lp b">this</code>或者使用JavaScript类(解释在另一篇文章中)。</p><p id="9f94" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当使用Redux构建数据驱动的应用程序时，您会很快发现reducer的能力有限，并且很难选择要为每个状态部分创建多少个reducer。你最不想要的就是把你的组件结构和你的减速器连接起来。我创造了<code class="fe lm ln lo lp b">createNamespaceReducer</code>来解决这些问题。</p><p id="d646" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lq">免责声明:你为什么要把所有东西都放在Redux里？除非它能解决你的问题。我不是说你应该这样做，我只是给这样做的人一个选择。</em></p><h1 id="b2d6" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">分离逻辑</h1><p id="b908" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">我看到了业务逻辑和视图逻辑的巨大分离。Redux的全部目的是实际开发一个独立于底层视图模型的“<strong class="ks jc"> Redux app </strong>”。</p><p id="bf7e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">直接来自文件(有一点解释):</p><blockquote class="mo mp mq"><p id="bbf7" class="kq kr lq ks b kt ku kc kv kw kx kf ky mr la lb lc ms le lf lg mt li lj lk ll ij bi translated">Redux可以用作任何UI层的数据存储。最常见的用法是与React和React Native一起使用，但也有可用于Angular、Angular 2、Vue、Mithril等的绑定。Redux只是提供了一个订阅机制，任何其他代码都可以使用。也就是说，当与可以从状态变化推断UI更新的声明性视图实现结合使用时，它是最有用的，比如React或可用的类似库之一。</p></blockquote><p id="6520" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">没有明说，但是暗示了。如果你有一个独立于用户界面层的数据存储层，你的<strong class="ks jc">应用程序是真正的反应还是冗余的</strong>？</p><p id="a6fb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">例如，我必须在一个项目中工作，在这个项目中，所有公司项目共享逻辑。所有这些逻辑都在Redux中，但应用程序可能会使用传统的AngularJS、React，或者两者都使用。我需要在许多应用程序中统一这些结构的方法，React的组件状态和上下文API都不适合我们。</p><p id="f3ab" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">用Redux做任何事情还有其他好处。由于Redux处理所有的状态变化，我的业务逻辑可以由纯无状态函数组成，这使得单元测试非常简单。这些类型的函数很容易推理。</p><p id="8c3d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">单元测试功能也比反应组件容易得多。你也可以对简单的缩减器进行单元测试，这比复杂的要容易得多。<code class="fe lm ln lo lp b">createNamespaceReducer</code>消除了对复杂减速器的大量需求，特别是当与异步中间件库配对时，如<a class="ae mu" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Observable </a>、<a class="ae mu" href="https://www.npmjs.com/package/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux-Thunk </a>或<a class="ae mu" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>。</p><p id="6d17" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一个好处是调试。Redux有一些很棒的devtools来计算出你的应用程序发生了什么变化，状态是什么，以及总体上发生了什么。你也有能力回到过去，调度自己的行动，看看会发生什么。React的组件状态和上下文API都没有这样的东西。</p><p id="aa46" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最重要的是，我只需要训练同事改变状态的一种方法，我也知道他们只有一种方法。它简化了很多事情，因为我可以编写一点应用程序逻辑，每个人都可以在我们所有的应用程序中重用。这是相同的动作创建者和相同的执行方式，相同的调试方式和相同的查找问题的地方。</p><p id="9e9a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我所看到的唯一缺点是当你必须向精通React组件状态的人解释时。对我来说，<code class="fe lm ln lo lp b">createNamespaceReducer</code>开启了无数的可能性，但是如果你在Redux中处理你的所有状态，对一些人来说会觉得有局限性，因为它带走了他们习惯使用的工具。用函数式编程和面向对象编程的相同方式来思考这个问题。当您不能将函数参数和对象属性设置为您想要的任何值时，这将极大地限制您的第一次尝试。</p><p id="67fe" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我说的听起来不寻常或古怪，这和你在Redux文档中看到的是一样的:</p><blockquote class="mo mp mq"><p id="cd11" class="kq kr lq ks b kt ku kc kv kw kx kf ky mr la lb lc ms le lf lg mt li lj lk ll ij bi translated">它帮助您编写行为一致、在不同环境(客户机、服务器和本机)中运行、易于测试的应用程序。最重要的是，它提供了很好的开发者体验，比如结合了时间旅行调试器的<a class="ae mu" href="https://github.com/reduxjs/redux-devtools" rel="noopener ugc nofollow" target="_blank">实时代码编辑</a>。</p></blockquote><p id="686a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那我做了什么？</p><h1 id="96c1" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">释放力量</h1><p id="9700" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">最重要的第一步是了解<code class="fe lm ln lo lp b">createNamespaceReducer</code>如何运作:</p><pre class="mv mw mx my gt mz lp na nb aw nc bi"><span id="f346" class="nd ls jb lp b gy ne nf l ng nh">createNamespaceReducer(<br/>  reducer,<br/>  initialNamespacedState,<br/>)</span></pre><p id="722d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是你如何真正使用它呢？</p><p id="ae41" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，编写一个简单的reducer:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9c35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这大概是你以前写过的。它只关心一件事:应用程序是已加载还是正在加载？</p><p id="cf03" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">接下来，我们设置加载状态操作:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="fc24" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这再简单不过了。我们为应用程序的加载状态创建了一个有限状态机。</p><p id="08a1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">问题是，整个应用程序只有一个加载状态。如果我们想在应用程序的其他部分使用这个reducer和其他组件，我们将不得不一遍又一遍地编写它。我甚至看到过<code class="fe lm ln lo lp b">isLoading</code>几乎是每个减速器上的道具的项目！这意味着你会看到复制粘贴逻辑无处不在。</p><p id="ed83" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是<code class="fe lm ln lo lp b">createNamespaceReducer</code>的威力发挥的地方。它防止你到处重写相同的逻辑。</p><p id="8243" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是一个使用与我们之前相同的加载状态缩减器和操作的示例:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ae37" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">行动现在需要有一个<code class="fe lm ln lo lp b">namespace</code>道具；否则，您的名称空间缩减器将不知道如何对您正在更改的状态进行分类。另一方面，您的减速器只需要一个改变:将它包在<code class="fe lm ln lo lp b">createNamespaceReducer</code>中。</p><p id="e0e3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了防止内存泄漏，还需要对reducer进行一个重要的修改。注意我们的减速器是如何使用<code class="fe lm ln lo lp b">initialState</code>而不是<code class="fe lm ln lo lp b">false</code>进入<code class="fe lm ln lo lp b">LOADED</code>状态的？在这种特殊的减速器中，<code class="fe lm ln lo lp b">initialState</code>和<code class="fe lm ln lo lp b">false</code>完全相同，但在其他减速器中，情况可能并非如此。例如，如果您的初始状态是一个对象或数组，那么您将需要返回到<code class="fe lm ln lo lp b">initialState</code>，以便您的命名空间缩减器将它从底层状态对象中移除。</p><p id="d047" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一件要注意的事情是，我是如何从命名空间缩减器中单独导出缩减器的。如果您只导出命名空间缩减器，那么您的单元测试必须测试命名空间缩减器以及<code class="fe lm ln lo lp b">isLoadingReducer</code>。单元测试的最佳实践是永远不要对别人的库进行单元测试，因为你想测试的只是你自己的功能，所以要把它们分开。</p><p id="f635" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请注意，您的命名空间缩减器总是返回到它以前的状态，除非您传入一个<code class="fe lm ln lo lp b">namespace</code>prop；因此，传递一个undefined的<code class="fe lm ln lo lp b">namespace</code>会返回之前的状态，而不管动作类型如何。</p><h1 id="432a" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">它是如何工作的</h1><p id="7034" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">为了理解<code class="fe lm ln lo lp b">createNamespaceReducer</code>是如何工作的，你需要首先理解你的状态在使用它时是什么样子的。</p><p id="bc03" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">之前:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bd62" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">之后:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9359" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">很简单。它让您将一个<code class="fe lm ln lo lp b">namespace</code>绑定到一个状态段。它真的像一个减速器一样工作。它比较前一个和下一个状态，并选择返回一个新的或相同的命名空间对象，就像您通常在reducer中做的那样。</p><p id="d4eb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在引擎盖下，它实际上只是一个带有一些有用逻辑的对象，但它也可以是其他任何东西，如<code class="fe lm ln lo lp b">Map</code>或不可变对象。事实上，我在Node.js中使用了一个<code class="fe lm ln lo lp b">createMappedNamespaceReducer</code>,因为我可以使用WebSocket连接对象引用来命名空间，而不必为每个WebSocket连接提供一个随机字符串。</p><p id="f1df" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你甚至可以使用辅助工具<code class="fe lm ln lo lp b">createNamespaceReducerCreator</code>编写自己的<code class="fe lm ln lo lp b">createNamespaceReducer</code>。我不打算深入讨论你是如何做的，但是在GitHub项目中有相当多的<a class="ae mu" href="https://github.com/Sawtaytoes/Ghadyani-Framework-Redux-Utils" rel="noopener ugc nofollow" target="_blank">例子。</a></p><h1 id="e1ad" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">从REST调用更新状态</h1><p id="d60b" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">当您从REST调用中获得一些东西时，如果您想更新一个条目列表，实际上是一个有效负载，该怎么办呢？与其为你要调用的每一个东西创建一个单独的缩减器，为什么不创建一个超级简单的缩减器，它接受一个<code class="fe lm ln lo lp b">payload</code>，并真正地把它放入状态？</p><p id="8b8d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">看起来是这样的:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3bdc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这实际上与我们最近在一个数据驱动的项目中使用的非常相似，该项目与REST API挂钩。它帮助我们快速开发应用程序，并担心我们的异步中间件中的所有AJAX调用。</p><p id="86d0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们能够将这一点推进得更远:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e216" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">很明显，我大大简化了这部史诗的逻辑。它肯定少了很多东西。如果想了解更多，可以查看我的文章: <a class="ae mu" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> <em class="lq"> Redux-Observable可以解决你的状态问题</em> </a> <em class="lq">。</em></p><p id="31bb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们有一个专门用于获取列表项的动作，仅此而已。没有存储和重置操作，因为我们的有效负载缩减器处理它。我们所要做的就是让我们的fetch动作调用一个<code class="fe lm ln lo lp b">storePayload</code>动作，当它使用正确的名称空间时，我们就可以开始了！</p><p id="d0ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们有一个<code class="fe lm ln lo lp b">fetchListItems</code>动作而不是<code class="fe lm ln lo lp b">fetchPayload</code>动作的唯一原因是，对于其他类型的数据，这个epic不需要以相同的方式触发。如果我展示更多关于实际epic的外观，它可能会以不同的方式处理错误，或者在触发AJAX调用之前设置加载状态。它也可能以不同的方式格式化返回的数据。重点是，我们可以在状态最终被放入通用Redux状态容器之前使用动作来改变状态。</p><p id="a00b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当处理WebSocket连接时，如果我想做更复杂的同步逻辑，我会编写更复杂的reducers。正因为如此，使用<code class="fe lm ln lo lp b">createNamespaceReducer</code>可以将缩减器简化为可读状态，并减少每种数据类型的大量复制-粘贴逻辑。</p><h1 id="9a17" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">从命名空间状态中选择</h1><p id="9b2e" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">如果你熟悉我的<code class="fe lm ln lo lp b">ReduxConnection</code>组件，这是它和<code class="fe lm ln lo lp b">payloadReducer</code>一起使用时的样子:</p><figure class="mv mw mx my gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8231" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lm ln lo lp b">createNamespaceSelector</code>提供了一种通过名称空间抓取项目的机制。通常你会得到一个带有属性<code class="fe lm ln lo lp b">payload</code>的对象，但是现在你可以得到与你的名称空间同名的属性。</p><p id="78e7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lq">如果你想了解更多关于</em> <code class="fe lm ln lo lp b"><em class="lq">ReduxConnection</em></code> <em class="lq">和选择器的知识，请查看我的文章:</em> <a class="ae mu" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener"> <em class="lq">为什么你不需要从React-Redux </em> </a> <em class="lq">连接。</em></p><h1 id="5c47" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">缺点</h1><p id="603b" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">我总是确保记录下使用我所建立的某个系统的所有缺点。我认为使用名称空间系统的权衡比创建单独的reducers更重要。</p><p id="af80" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们丢失了一些调试。因为这是实现Redux状态的一种不寻常的方式，Redux devtools不知道什么是<code class="fe lm ln lo lp b">namespace</code>,除非你点击一个动作，否则不会显示出来。这意味着你必须经历许多名字非常相似的行为，才能找到你在乎的那个。这对我来说是一个主要的缺点，但并不是什么大不了的事情。我做了几个命名的归约器，即使很相似，也能提供一点点的分离，尤其是在存储不同类型的数据时。</p><p id="d9c0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">名称空间冲突怎么办？这是一个很好的问题！在过去的9个月里，我们一直在使用它，这并不是一个问题，但我可以看到它会出现在哪里。如果这是一个特定于组件的动作，我们的过程是将名称空间与组件的名称1:1联系起来，如果我们使用数据来控制加载或有效负载状态，我们为正在获取的数据传入一个语义名称，比如<code class="fe lm ln lo lp b">'permissions'</code>或<code class="fe lm ln lo lp b">'accessToken'</code>。</p><p id="0a4f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">两个组件可以被命名为相同的，但同样，它没有出现。解决这样的问题实际上比您想象的要容易，因为您知道名称空间和动作创建者。这很简单，只需搜索其中任何一个，就能很好地理解名称空间冲突可能会在哪里引起问题。</p><h1 id="c981" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">释放您自己应用的潜能</h1><p id="0f6b" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">代码最终比我计划的更复杂；肯定不是你想自己写的东西，所以我创建了几个带有单元测试的实用函数，并开源给每个人使用。</p><p id="42ba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您可以在这里找到它们:</p><div class="ip iq gp gr ir nk"><a href="https://github.com/Sawtaytoes/Ghadyani-Framework-Redux-Utils/blob/master/utils/createNamespaceReducer.js" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd jc gy z fp np fr fs nq fu fw ja bi translated">sawtaytoes/Ghadyani-Framework-Redux-Utils</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Redux助手函数和中间件。通过创建……为Sawtaytoes/Ghadyani-Framework-Redux-Utils的开发做出贡献</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ix nk"/></div></div></a></div><h1 id="aaf7" class="lr ls jb bd lt lu lv lw lx ly lz ma mb kh mc ki md kk me kl mf kn mg ko mh mi bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kq kr jb ks b kt mj kc kv kw mk kf ky kz ml lb lc ld mm lf lg lh mn lj lk ll ij bi translated">如果你喜欢你所读的，你也应该检查我的其他文章；尤其是关于Redux的任何事情:</p><ul class=""><li id="f564" class="nz oa jb ks b kt ku kw kx kz ob ld oc lh od ll oe of og oh bi translated"><a class="ae mu" href="https://medium.com/@Sawtaytoes/why-you-shouldnt-need-connect-from-react-redux-498876de9e4e" rel="noopener">为什么不需要React-Redux的“连接”</a></li><li id="dc1d" class="nz oa jb ks b kt oi kw oj kz ok ld ol lh om ll oe of og oh bi translated"><a class="ae mu" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="9b7b" class="nz oa jb ks b kt oi kw oj kz ok ld ol lh om ll oe of og oh bi translated"><a class="ae mu" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="c5b4" class="nz oa jb ks b kt oi kw oj kz ok ld ol lh om ll oe of og oh bi translated"><a class="ae mu" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li><li id="b18e" class="nz oa jb ks b kt oi kw oj kz ok ld ol lh om ll oe of og oh bi translated">函数式编程的表情爱好者指南:第一部分</li></ul></div></div>    
</body>
</html>