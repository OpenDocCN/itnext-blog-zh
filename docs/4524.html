<html>
<head>
<title>Kubernetes Resource Use and Management in Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes在生产中的资源使用和管理</h1>
<blockquote>原文：<a href="https://itnext.io/kubernetes-resource-management-in-production-d5382c904ed1?source=collection_archive---------0-----------------------#2020-07-19">https://itnext.io/kubernetes-resource-management-in-production-d5382c904ed1?source=collection_archive---------0-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="792c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">请求、限制、超量承诺、闲置/浪费、节流</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fbd35c9d68ea05b3052d034c4f5ad51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLM2MvlJsLkRiFndCPGCJA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">https://unsplash.com/photos/QwoNAhbmLLo<a class="ae ky" href="https://unsplash.com/photos/QwoNAhbmLLo" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="1aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们将Kubernetes应用程序投入生产之前，我们应该了解K8s资源管理。<strong class="lb iu">核心是理解Kubernetes调度程序如何处理资源请求和限制</strong>，然后其他一切都有意义了。所以，让我们开始吧！</p><h2 id="8ad6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">读完这篇文章后，你将会:</h2><ul class=""><li id="a9d9" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">理解要求和限制</li><li id="1b65" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">了解k8s调度程序如何处理资源</li><li id="58b7" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">有关于如何提高集群使用率和稳定性的想法吗</li></ul><h2 id="e11e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">TL；速度三角形定位法(dead reckoning)</h2><ul class=""><li id="64a8" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">设置内存请求=限制</li><li id="2904" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">不设置CPU限制或禁用kubelet中的CPU限制实施</li><li id="3e23" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">使用率应低于请求数</li><li id="dc0a" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">使用HPA / VPA缩放</li><li id="bb8a" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">监控/提醒pod资源使用情况</li></ul><h1 id="a721" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">豆荚资源</h1><p id="6ce1" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在k8s中，一个pod可以有一个或多个容器，通常由Docker运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/856391ea681c29b408ed6bf641e45a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*hXEPVeiASmMf5sTmTtRWqQ.png"/></div></figure><p id="4656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pod可以被看作是紧密协作的容器的包装器，这就是为什么它们应该运行在同一台机器(节点)上。这意味着总的pod资源是其所有容器资源的总和。</p><h2 id="a88c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资源请求和限制</h2><p id="f7bb" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">将为每个容器指定资源请求和限制，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/716362512810167750b68a7aeef0b102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pGnfKL-JX8hxkNpXz24aw.png"/></div></div></figure><p id="9caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">请求</strong>是保证和保留的资源。没有其他豆荚可以使用这些。</p><p id="5f0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">限制</strong>是允许使用比请求更多的资源。如果一个容器达到其指定的限制，它将被限制CPU和驱逐内存。</p><h1 id="662a" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">调度程序</h1><p id="1915" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">k8s调度程序负责决定哪个pod可以在哪个节点上运行。它通过查看各种配置(如亲和力、污点、容忍度)来做到这一点，但我们将只查看主要的一个:自由资源。</p><p id="5f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当调度器做出关于“空闲资源”的决定时，它只查看两个数字:<strong class="lb iu">节点可分配</strong>和<strong class="lb iu">资源请求</strong>。</p><h2 id="18b8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">节点可分配性与容量</h2><p id="ebc0" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">调度程序查看节点可分配性，它只是整个节点容量减去硬定义的(在kubelet中)数量或百分比，即“系统预留”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/545c064b9f241c222fd246c3af1a48db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Y4_9Sk0nqtAWfetvROAaw.png"/></div></div></figure><p id="4ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地通过查看像<code class="fe nv nw nx ny b">kubectl get node worker1 -oyaml</code>这样的节点来查看可分配的容量。重要的是，无论节点上运行多少pod，这些数字都不会改变。只要节点通过kubelet注册，它们就是固定的。</p><h2 id="dfbe" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">根据调度程序释放资源</h2><p id="1fa1" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><code class="fe nv nw nx ny b">free = node allocatable — sum(all pod resource requests)</code></p><p id="1f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着调度程序实际上永远不会直接查看节点或pods的CPU/内存使用情况，而只会考虑所请求的内容。</p><h1 id="b3b4" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">调度程序正在运行</h1><p id="c9ee" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们来看一个调度决策工作流的例子，它有两个节点，在开始时完全是空的。</p><p id="9eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(<a class="ae ky" href="https://www.youtube.com/watch?v=eBChCFD9hfs&amp;t=2167s" rel="noopener ugc nofollow" target="_blank">图像来源</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2c1372210e7016beb240507a92513194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EujmEjZKFytWpqFpLjOhFA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">蓝色pod有资源请求，在节点1上进行计划</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9b1884be7bc98856e85aaf6c34d5813d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYps-qyTez3WIpYIk4IUHg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">绿色单元被安排在节点2上</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a57561b01cfef61066145051adb9a82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJ12TwQSQOIcgQ0rlT_hUQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">紫色pod被安排在节点1上</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8194390f15fcd0a415c31fa1ce520eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxoOCxD7U9X_W-0wFh_U_A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">调度程序尝试在节点2上调度红色pod</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/425e3607e71e47688208aa2cf91cf722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*unapZAUcyNZwDuPNuV3i6w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">…但是没有更多的资源可用，所以它仍处于挂起状态</figcaption></figure><p id="8459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看上面的图片，其中节点1有两个pod，节点2有一个pod在运行。节点上显示的所有颜色代表资源<strong class="lb iu">请求</strong>，由于调度程序忽略了这些限制，所以看不到限制。因此，我们现在可以理解懈怠和过度承诺。</p><h1 id="ff39" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">K8s中的松弛和超量承诺</h1><p id="bbc2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">下图显示了可视化松弛和超量承诺的示例指标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6e3a1f73989d6176e79f326571df69d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a4wiYHxYomVJOkblhidbA.png"/></div></div></figure><p id="e63a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将更详细地讨论这个示例指标和其他指标。但首先，我们将更深入地探究懈怠和过度承诺，以彻底理解它们。</p><h1 id="eb08" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">松弛的</h1><p id="5f59" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">浪费的资源称为时差。k8s中的Slack描述了被请求但未被使用的资源。让我们看看下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/7c98c6c69a025af74cbce8cb297c5e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAA25jz1znqr5RJgQOIXbA.png"/></div></div></figure><p id="57a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到在节点1上安排了两个pod。蓝色部分显示了pod1的资源请求。但是pod1实际上只使用了它所请求的大约1/3，这意味着其余部分是空闲的。</p><p id="483e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？因为k8s调度器不查看实际的使用情况，它只查看指定的请求值。</p><h1 id="9869" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">过度承诺</h1><p id="237c" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">过量使用意味着如果所有单元都开始使用所有可能的资源，我们将在一个节点上安排更多的单元。这只有在不是所有的豆荚同时消耗所有它们能消耗的资源时才有效，所以这是一场赌博。让我们来看一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/87a003fa2105ba4216b810f4b1575c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNPJhOEgvUYmZ-0SzgjPHQ.png"/></div></div></figure><p id="0ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到蓝色pod的CPU使用率实际上超过了请求，这意味着它使用了过量的资源。这是可能的，因为我们指定的限制高于请求。</p><p id="2de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以认为这一切都还好，对吗？但是k8s调度程序将只查看请求，它可能认为在没有空闲资源的情况下仍然有足够的空闲资源，并在该节点上调度新的pods。</p><h2 id="13e8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">CPU过量使用扑克</h2><p id="973b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">只要超额使用不超过节点的容量，CPU超额使用就不会出现问题。让我们来看看这样一个场景:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/7e6bc802101e72f8eaf1b04bd704a255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhqYGAe-KeMeOpyoWdZeSg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实际使用量超过容量:导致CPU节流</figcaption></figure><p id="84b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，节点上的两个pod都将被抑制。每个pod都可以被调节到它所请求的值，因为只有这个值是有保证的。因此，CPU过量使用可能并不太糟糕，它只会导致节流。</p><p id="d504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是即使在这种情况下，k8s调度器可能仍然认为node1有足够的“空闲CPU”用于另一个pod，因为:它只查看请求。</p><h2 id="5598" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">内存过量使用扑克</h2><p id="8ac7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">对于内存来说，这有点不同，因为内存不能像CPU一样被节流。它不是一个基于时间的值，但它包含不能简单地收缩或扩展的实际数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/69d4bcd15d227811ada19cba9ddb5aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8Sy0MTPVdZajnPJ27GpVA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实际使用量超过容量:导致pod驱逐、终止或OOM异常</figcaption></figure><p id="af43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">kubelet是一个在VM上运行的进程，它通过与k8s API通信将VM注册为一个节点。在这之后，它从API接收pod规范来运行。</p><p id="8e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">kubelet有一些处理OOM情况的机制，如上图所示。它可以注意到它的pod是否开始使用比请求更多的内存，以及它是否会很快用完。如果是这样，它就可以根据优先级驱逐pod。它还可以给自己条件<code class="fe nv nw nx ny b">MemoryPressure</code>，调度器将考虑该条件(更多关于进一步向下的节点压力)。</p><p id="35db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但是！不能保证kubelet有足够的时间注意到这一点并驱逐pod。可能发生的情况是，节点本身遇到内存不足的问题，操作系统本身开始杀死随机进程(<a class="ae ky" href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#node-oom-behavior" rel="noopener ugc nofollow" target="_blank">源</a>)。</strong></p><p id="14a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么建议永远不要允许内存过量使用，所以总是设置<code class="fe nv nw nx ny b">requests=limits</code>。</p><h2 id="d8f8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">基于优先级的Kubelet pod驱逐</h2><p id="cfed" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">kubelet考虑QoS ( <a class="ae ky" href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" rel="noopener ugc nofollow" target="_blank">服务质量</a>)和<a class="ae ky" href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/" rel="noopener ugc nofollow" target="_blank">优先级</a>来决定驱逐哪些pod以释放资源。</p><blockquote class="oi oj ok"><p id="2870" class="kz la ol lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated">唯一同时考虑QoS和Pod优先级的组件是<a class="ae ky" href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/" rel="noopener ugc nofollow" target="_blank"> kubelet资源不足驱逐</a>。kubelet首先根据pod对饥饿资源的使用是否超过请求，然后根据优先级，最后根据相对于pod的调度请求的饥饿计算资源的消耗，对要驱逐的pod进行排序。(<a class="ae ky" href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#interactions-of-pod-priority-and-qos" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><h1 id="e905" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">CPU限制导致不必要的CPU节流</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/85355ece0712eb983ebe9ad5797d1d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*-xfbMvwAg__WDICzLRTSKQ.png"/></div></figure><p id="38d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以成为你最大的k8s兔洞之一，一定要小心；)关于这个有一个公开的<a class="ae ky" href="https://github.com/kubernetes/kubernetes/issues/67577" rel="noopener ugc nofollow" target="_blank"> Github问题</a>。</p><p id="6485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简而言之:</strong>如果我们为一个pod设置任何CPU限制，它可能会受到抑制，即使使用量没有接近限制。比如，如果一个pod使用限制为<code class="fe nv nw nx ny b">1000 millicpu</code>的<code class="fe nv nw nx ny b">200 millicpu</code>，它可能仍然会受到限制，导致延迟/性能问题。</p><p id="bfaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Youtube 上有一个来自Zalando的Henning Jacobs关于这个的非常棒的<a class="ae ky" href="https://www.youtube.com/watch?v=eBChCFD9hfs" rel="noopener ugc nofollow" target="_blank">演讲，我建议观看。</a></p><p id="5c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">因此，建议不定义CPU限制</strong>或通过<code class="fe nv nw nx ny b">--cpu-cfs-quota=false</code>禁用kubelet中的CPU限制。但是在使用托管云集群时，后者可能是不可能的。</p><h2 id="7c58" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">那么如何防止一个pod使用过多的CPU呢？</h2><ul class=""><li id="203a" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">监控pod的使用情况，并在使用量超过请求量时发出警报。如果有，请提出要求</li><li id="fb89" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">通过HPA/VPA实施扩展</li></ul><p id="58ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/k8s-monitor-pod-cpu-and-memory-usage-with-prometheus-28eec6d84729">我对使用Prometheus </a>监控pod资源使用情况的介绍。</p><h1 id="d8a9" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">设定适当的要求和限制</h1><p id="c0f7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们看几个场景，讨论这些场景是好是坏。<strong class="lb iu">这些只是一般观察，对于特定的使用情形可能会有所不同！</strong></p><h2 id="84e4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">常见场景#1</h2><p id="db62" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们有很高的松弛度，我们允许过度承诺，这并不好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4eb09800a3de8554b33770a921abf14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQ0IEf4WUgu7SKlxcd-O0Q.png"/></div></div></figure><h2 id="b982" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">常见场景#2</h2><p id="d34b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们没有懈怠，但我们实际上利用了过量的资源，这并不好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/393728457c38a18616c16599e0a683ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGmAdU_p--g_DzYoGg0sZg.png"/></div></div></figure><h2 id="b734" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">接近最佳方案</h2><p id="3389" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们为内存设置了<code class="fe nv nw nx ny b">requests=limits</code>。对于CPU，如果我们在Kubelets中禁用了限制强制(<code class="fe nv nw nx ny b">cpuCfsQuota=false</code>)，我们可以做同样的事情。否则我们不会为CPU定义任何限制。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/a0be03132357491a9e6a3d25c3888daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5qvxzBh6cf3eCmCeKUWtQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">对于CPU，根本不要设置限制或禁用限制实施</figcaption></figure><h2 id="2fda" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">更现实的场景</h2><p id="97d6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这种用法可能永远不会是好的和稳定的，而是波动的。在这种情况下，我们仍然应该注意使用率总是低于我们的要求。是的，为了可预测性和稳定性，这将导致更高的松弛度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/198df22f0c5d9a3cc2b624930accf4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2T84ZTzaBlqnJiepaQXhIg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">对于CPU，根本不要设置限制或禁用限制实施</figcaption></figure><h2 id="77c2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">通过缩放减少松弛</h2><p id="1e13" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了拉平使用曲线并使其低于要求，我们可以使用HPA之类的扩展。一旦它注意到使用朝着请求/限制上升，它将创建更多的实例来分散负载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5cdf04834b48a39204aad300f8bb3d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8eWLfaR9f-BcnXQ3DeqnQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">对于CPU，根本不要设置限制或禁用限制实施</figcaption></figure><p id="3ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了一个单元的资源使用情况。如果创建更多副本，所有pod使用的资源总量将会上升。有了HPA，单个pod的使用曲线可以变平，因此可以更高效地进行调度。</p><h2 id="23b2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Pod在初始化期间使用更多资源</h2><p id="3683" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">这是一个棘手的问题。如果你有好的解决方案，请在评论中告诉我们。</p><p id="5ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个pod在初始化期间使用了更多的资源，那么将请求设置为较高的初始化使用率将在所有进一步的运行时间中导致较高的松弛度。因此，在这种情况下，允许CPU过载是可以的，但不允许内存过载。</p><p id="0123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有人可能认为应该可以将init-logic移动到一个在实际应用程序容器之前运行的<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers" rel="noopener ugc nofollow" target="_blank"> initContainer </a>中，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/75914c751134eebf902abd7bddd5b532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1HiMl7jW8UvOc8D-TDHng.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">总的pod资源请求将是初始容器资源请求</figcaption></figure><p id="d66b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这实际上并没有降低总的pod资源请求，因为调度程序是这样计算总的pod资源请求的(<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/" rel="noopener ugc nofollow" target="_blank"> source1 </a>，<a class="ae ky" href="https://www.magalix.com/blog/kubernetes-patterns-the-init-container-pattern" rel="noopener ugc nofollow" target="_blank"> source2 </a>):</p><pre class="kj kk kl km gt ou ny ov ow aw ox bi"><span id="8445" class="lv lw it ny b gy oy oz l pa pb">pod requests = max(max(initContainers), sum(containers))</span></pre><h1 id="e2fd" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">丙戊酸；虚拟个人助理</h1><p id="43c7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">HPA(水平Pod自动缩放器)非常适合无状态和现代服务。但是如果我们有一个有状态的或者单一的服务，这就不那么容易了。</p><p id="e4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VPA(垂直Pod自动缩放器)可以调整正在运行的Pod的资源请求，而不是创建更多副本。它还可用于仅推荐最佳请求值。更多尽在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/k8s-vertical-pod-autoscaling-fd9e602cbf81">我的VPA介绍文章</a>。</p><h1 id="1973" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">节点压力</h1><p id="b9c8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我在本文中经常提到，k8s调度程序从不查看节点上的实际资源使用情况，它只查看节点可分配和pod请求。</p><p id="9cf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这基本上是对的，但是一个节点可以给自己一个类似于<code class="fe nv nw nx ny b">MemoryPressure</code>或者<code class="fe nv nw nx ny b">DiskPressure</code>的条件(<a class="ae ky" href="https://kubernetes.io/docs/concepts/architecture/nodes/#condition" rel="noopener ugc nofollow" target="_blank"> source1，</a>T14】source 2)。如果一个节点有这种情况，调度器将认为它不是最佳候选。但是需要注意的是，没有 <code class="fe nv nw nx ny b">CpuPressure</code>条件，也没有基于CPU的pod驱逐。</p><h1 id="7708" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">为什么连资源都有限制？</h1><p id="9bb3" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果为了最佳的可预测性和安全性，最好是永远不允许过度承诺(<code class="fe nv nw nx ny b">request&lt;limits</code>)，那么为什么还要存在限制呢？</p><h2 id="0743" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">轻松开始</h2><p id="0c02" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有了广泛的请求和限制，开始开发应用程序就更容易了，因为我们还不知道真正的用途。</p><h2 id="6c38" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">优化资源使用</h2><p id="7f32" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">理论上，让非关键pod利用超量承诺来减少空闲时间是一个好主意。那么，如果一个节点处于压力之下，允许过量使用的pod将首先被逐出(<a class="ae ky" href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/" rel="noopener ugc nofollow" target="_blank"> QoS </a>)。</p><p id="7801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果kubelet在未来变得“完美”,能够预测OOM问题并驱逐正确的pod，那么允许内存过量使用可能会变得可行。</p><h1 id="76e9" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">工具</h1><p id="9717" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">有一个<a class="ae ky" href="https://github.com/hjacobs/kube-resource-report" rel="noopener ugc nofollow" target="_blank"> Kube资源报告</a>，它很容易安装到集群中(<a class="ae ky" href="https://github.com/hjacobs/kube-resource-report/tree/main/unsupported/chart/kube-resource-report" rel="noopener ugc nofollow" target="_blank">掌舵图</a>)，并提供了一个关于使用和空闲的很好的概述。这有助于与我们创建自己的Prometheus仪表盘进行对比，以进行监控和警报。</p><h1 id="0a52" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">结论</h1><p id="62a6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">深入研究k8s如何管理资源可能相当复杂。一般来说，我们总是希望使用率低于要求，至少为了最好的可预测性和稳定性。一旦我们的应用程序在生产中稳定运行，我们就可以尝试优化松弛部分。</p><p id="1390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不同意我在这里写的东西，有不同的意见或处理方式，请在下面的评论中告诉我们！</p><h1 id="79cc" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">来源</h1><ul class=""><li id="a414" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">我非常推荐观看来自Zalando的Henning Jacobs的精彩演讲:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><ul class=""><li id="eca2" class="mo mp it lb b lc ld lf lg li pe lm pf lq pg lu mv mw mx my bi translated">Kubernetes调度解释:<a class="ae ky" href="https://www.oreilly.com/content/kubernetes-scheduling-magic-revealed/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/content/kubernetes-scheduling-magic-discovered</a></li><li id="63cc" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">引擎盖下的Kubernetes调度程序，查看源代码:<a class="ae ky" href="https://www.mgasch.com/post/sched-reconcile/" rel="noopener ugc nofollow" target="_blank">https://www.mgasch.com/post/sched-reconcile</a></li><li id="d899" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">Kubelet资源不足处理:<a class="ae ky" href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#scheduler" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/administrator-cluster/资源不足</a></li></ul><h1 id="4f6e" class="ne lw it bd lx nf ng nh ma ni nj nk md jz nl ka mg kc nm kd mj kf nn kg mm no bi translated">成为Kubernetes认证</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://killer.sh"><div class="gh gi ph"><img src="../Images/cf3901a56841fcb55f9e4e17b9f07672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kbj17_6VncUuoBqNsAzzg.png"/></div></a><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://killer.sh" rel="noopener ugc nofollow" target="_blank"> https://killer.sh </a></figcaption></figure></div></div>    
</body>
</html>