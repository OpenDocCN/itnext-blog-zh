# 安全胜于担忧:在运行时记录所有依赖项的版本

> 原文：<https://itnext.io/on-the-safe-side-log-your-3rd-party-package-versions-8b70ebdc9e1d?source=collection_archive---------2----------------------->

*简而言之:如何在运行时* *轻松获得 log4j2 和其余 Java 依赖项* ***版本的教程。***

![](img/bd7c830454cd8a75e76730912be724e6.png)

鉴于最近的 [log4j2 漏洞](https://logging.apache.org/log4j/2.x/security.html)，经常发生的情况是，您必须升级某个第三方依赖项的版本，以便缓解最近发现的漏洞。

但是如何确定版本更新确实发生了呢？现在有了复杂的依赖规则，即使你在某个地方指定了一个显式的包版本，你选择的包管理器(例如 Maven，Gradle)可能会决定将你的包版本设置为某个较低的版本，以符合你使用的另一个包的一些公共依赖。

# 在构建时列出依赖项

如果你使用 Maven，你可以运行`mvn dependency:resolve`，`maven-dependency-plugin`会列出你的依赖项。但是这只适用于构建时。

建议将此命令添加到您的构建工作流中，以便在构建时已经清楚地记录了所有依赖项。

# 在运行时列出依赖项

对于您的应用程序来说，在**运行时打印/记录所有**加载的**包**的版本是一个很好的实践，这样您就可以随时查看生产环境的日志，并确保有正确的版本。****

## **Kotlin/Java 实现**

**可以使用反射来获取所有加载的包。然后，对于每个包，从它的 JAR 清单中读取并打印实现元数据。下面是一个实现这一点的 Kotlin 示例代码。在演示中，我排除了内置的 Java 包。**

**这是输出:**

****重要提示**:上面的代码只打印在调用时加载到 JVM 的包。所以，在你的应用程序开始的时候，你想把它叫做**而不是**，但是只有在第三方组件已经初始化或启动之后。**

## **更好的格式**

**打印所有已加载的包版本可能会太冗长，因为您可能有数百个已加载的包。我还准备了另一种风格，它根据产品(标题)和版本对所有包进行分组。它还允许您决定是否打印每个产品中的所有包装。**

**输出—无详细信息:**

**输出—包含详细信息(剪辑):**

## **保留依赖关系的清单**

**由于上述方法依赖于 JAR 清单文件，如果您将应用程序打包到一个带有`maven-assembly-plugin`(“big-JAR”)的 JAR 文件中，它将无法正常工作。相反，您将获得所有`implementation*`字段的`null`值。这是因为每个 JAR 可以有一个单独的清单文件，并且每个依赖项的原始清单在打包过程中会被忽略。
解决方法:不要生成一个大的 jar，而是使用`maven-dependency-plugin`将依赖项的 JAR 复制到应用专用 JAR 文件下的`lib`文件夹中。此外，使用`maven-jar-plugin`将`lib`文件夹添加到类路径中，如下所示。如果你有一个大罐子的解决方案，我很乐意知道。**

**还建议如上图所示为`maven-jar-plugin`设置`<addDefaultImplementationEntries>true</addDefaultImplementationEntries>`指令。这将从`pom.xml`文件更新您自己的 JAR 中的`MANIFEST.MF`文件中的`Implementation-*`字段——这样您自己的包也将被正确地版本化。**

## **更简单的解决方案**

**但是等等——如果我们已经使用`maven-dependency-plugin`复制了 app.jar 下的每个依赖 JAR，还有一个更简单的解决方案！只记录`.jar`文件的文件名。当使用依赖项管理器时，它们已经包含了版本号。与之前的方法相比，这种方法还有其他优点:**

*   **它记录任何 JAR 的版本，不管它是否被加载。**
*   **许多作者懒得在他们的 JAR 清单中设置`implementation`字段，但是 MavenCentral 中的每个库都有一个文件版本，它被正确地保存在目录结构中。**

**下面是实现过程:**

**输出(削波):**

## **摘要**

**无论您使用哪种语言，记录所有依赖项的版本都是一个很好的做法，这样可以确保已知的漏洞得到适当的缓解。我用 Kotlin 演示了几个实现替代方案。第一种方法基于打印加载到 JVM 中的包的版本。使用它你可以绝对确定每个软件包的版本。然而，它不如后一种简单地将依赖关系 jar 复制到一个已知的位置并打印它们的文件名的方法健壮。**

**所以不要等下一个漏洞被发现！现在将依赖版本日志添加到您的引导代码中，您将能够立即确定是否需要缓解。**