<html>
<head>
<title>Micro Frontends in OutSystems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外部系统中的微前端</h1>
<blockquote>原文：<a href="https://itnext.io/micro-frontends-in-outsystems-a6aafd0d0e65?source=collection_archive---------1-----------------------#2021-11-23">https://itnext.io/micro-frontends-in-outsystems-a6aafd0d0e65?source=collection_archive---------1-----------------------#2021-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a8b05a70e05c7cfec048813fde583d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0liV7eu77Ca382HRMstuDw.png"/></div></div></figure><div class=""/><div class=""><h2 id="9704" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">对于我们在外部系统中常用的传统整体方法，有一些替代方法。</h2></div><p id="46f3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们从定义什么是微前端开始。该术语于2016年首次被提及，例如，与微服务相比，它仍然是最近才出现的。</p><p id="a35a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从https://micro-frontends.org/的网站上我们可以读到:</p><blockquote class="ln lo lp"><p id="c157" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated">…作为<strong class="ks jc">的网站或网络应用，由<strong class="ks jc">独立团队</strong>拥有的功能</strong>组成。每个团队都有自己关心和擅长的<strong class="ks jc">不同的业务领域</strong>或<strong class="ks jc">任务</strong>。一个团队是<strong class="ks jc">跨职能</strong>的，从数据库到用户界面，端到端地开发其功能<strong class="ks jc">。</strong></p></blockquote><p id="8f29" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从文章<a class="ae lm" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/articles/micro-frontends.html</a>中，我可以强调以下几点:</p><blockquote class="ln lo lp"><p id="e7c8" class="kq kr lq ks b kt ku kc kv kw kx kf ky lr la lb lc ls le lf lg lt li lj lk ll ij bi translated">正如微服务一样，微前端的独立可部署性是关键。这缩小了任何给定部署的范围，从而降低了相关的风险。不管您的前端代码是如何托管的，也不管在哪里托管，每个微前端都应该有自己的持续交付管道，在生产过程中构建、测试和部署它。</p></blockquote><h1 id="08db" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">这是什么意思？</h1><p id="8808" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">这些概念使应用程序可以像下图这样进行组装:</p><ul class=""><li id="beb0" class="mr ms jb ks b kt ku kw kx kz mt ld mu lh mv ll mw mx my mz bi translated"><strong class="ks jc">React开发的App1 </strong>可以从<strong class="ks jc">域</strong>服务，由<strong class="ks jc">团队A </strong>开发，有自己的<strong class="ks jc">部署周期</strong>、<strong class="ks jc">测试</strong>等…</li><li id="1079" class="mr ms jb ks b kt na kw nb kz nc ld nd lh ne ll mw mx my mz bi translated">用Angular开发的<strong class="ks jc"> App 4 </strong>可以从<strong class="ks jc">域B </strong>服务，由<strong class="ks jc">团队B </strong>开发<strong class="ks jc">、有自己的<strong class="ks jc">部署周期</strong>、<strong class="ks jc">测试</strong>等…</strong></li></ul><p id="5c13" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">搜索</strong>模块<strong class="ks jc"> </strong>可以用<strong class="ks jc">技术A </strong>完成，<strong class="ks jc">认证</strong>模块可以用<strong class="ks jc">技术B </strong>完成，以此类推。</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/6ff35179413d09abe307d4081c49bbf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BAwlh31ExpjRSCmh"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">图片来自<a class="ae lm" href="https://frontend-architecture.com/2020/02/13/micro-frontends/" rel="noopener ugc nofollow" target="_blank">https://frontend-architecture . com/2020/02/13/micro-frontends/</a></figcaption></figure><p id="f215" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">就架构而言，这种关注点的分离定义了清晰的范围和责任，允许不同的团队更快地交付<strong class="ks jc"/>和更频繁地交付<strong class="ks jc"/>。😎</p><figure class="ng nh ni nj gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/a7eb08a332737033e56c9ce1e07a903a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rj_iDWvU4SRp8ZIV.jpg"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">图片来自<a class="ae lm" href="https://www.cygnismedia.com/blog/micro-frontends-development/" rel="noopener ugc nofollow" target="_blank">https://www . cygnismedia . com/blog/micro-frontends-development/</a></figcaption></figure><p id="0806" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">良好的E2E测试策略可以保证质量，每个人都乐于一起工作，不需要插手其他团队的事情。🧀</p><p id="2017" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">(每当另一个团队告诉我“不要发布这个！只有下周。”，我一直记得这本<a class="ae lm" href="https://en.wikipedia.org/wiki/Who_Moved_My_Cheese%3F" rel="noopener ugc nofollow" target="_blank">书</a>。)</p><p id="c083" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好的，听起来不错。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="da97" class="lu lv jb bd lw lx nw lz ma mb nx md me kh ny ki mg kk nz kl mi kn oa ko mk ml bi translated">外部系统呢</h1><p id="abef" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">有时候我会听到这些问题:<br/>——我可以在OS中使用Tailwind吗？<br/> -我可以在操作系统中使用Firebase推送通知吗？<br/> -可以在OS中实现WebGL和Three.js这样的JavaScript库吗？<br/>你明白了…</p><p id="a5a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">答案很简单:如果它运行在全能的浏览器上，无论如何，我们都可以使用我们心爱的平台来实现它。🥰 <br/>考虑到这一点，我们可以在外部系统中拥有类似微前端的东西。但是有一些警告。</p><h1 id="f06d" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">这是一个单页应用程序(SPA)</h1><p id="1ab2" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">我在当前平台中错过的一件事是生成一个<strong class="ks jc">组件</strong>与一个<strong class="ks jc">应用程序的可能性。</strong>我指的是在浏览器上运行的<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> web组件</a>。</p><p id="503d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当我们创建一个外部系统反应式Web应用程序时，实际上，我们生成了一个单页面应用程序(SPA ),完全封装了它自己的路由。<br/>我们无法创建一个可用于另一种技术的组件。一个web块(甚至在一个库中)，只能被另一个外部系统工件使用。</p><p id="bbed" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我所看到的混合不同技术并且看起来像微前端的例子都依赖于iframes😢。</p><p id="88dc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> 🥳解决方案:<br/> </strong>我们总是可以选择使用高级代码和纯JavaScript(或TypeScript)来生成组件😍).你可以用像<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement" rel="noopener ugc nofollow" target="_blank">document . createelement()</a>这样的方法做很多事情。</p><p id="c3ba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该脚本可以托管在CDN的其他地方，然后使用<strong class="ks jc"> require </strong>或<strong class="ks jc"> appendChild“注入”到我们的反应式Web应用程序中。</strong></p><h1 id="178a" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">沟通</h1><p id="7b14" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">常规的外部系统反应式Web应用被封装，并且其上下文/状态是封闭的，并且不允许外部源改变它。即使是另一个同类的反应式网络应用也不行。</p><p id="2da1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一件事是在一个窗口中注入HTML、JavaScript和CSS，但我们如何让它们交互以实现由多个独立部分组成的一个统一应用程序的目标。</p><p id="c0ce" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">页面的不同部分需要通过用户操作或其他事件进行交互。</p><p id="bda1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> 🥳解决方案:<br/> </strong>幸运的是，在过去的几年里，网络有了很大的发展，有如此多的网络应用编程接口和设计模式可供我们使用。我们有自定义事件、观察对象、web workers……都使用了成熟的PubSub设计模式。</p><p id="a22d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我最喜欢的处理同一个全局窗口中不同对象之间通信的选项是<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="noopener ugc nofollow" target="_blank"> <strong class="ks jc"> postMessage </strong> </a>。</p><p id="4fd3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当我们需要跨不同来源进行通信时，这尤其有用，例如使用<strong class="ks jc"> iframes </strong>。是啊！您可以在页面和iframe之间进行通信😉。</p><p id="ab6a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在开发这样的应用程序时，状态处理总是很棘手，假设反应式Web应用程序将拥有所有的核心特性和数据，对我来说，将所有的状态管理集中在那里是有意义的。</p><p id="6aa0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些都是高层次的概念，但如果你想深入研究并更上一层楼，请查看<a class="ae lm" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。</p><h1 id="a77e" class="lu lv jb bd lw lx ly lz ma mb mc md me kh mf ki mg kk mh kl mi kn mj ko mk ml bi translated">半铸钢ˌ钢性铸铁(Cast Semi-Steel)</h1><p id="dbce" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">对于一个“感觉”统一的应用程序，所有部分必须共享视觉元素，如颜色、字体、控件等…</p><p id="c7ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于用户来说，下拉菜单是来自外部系统的反应式Web应用程序还是本地JavaScript并不重要。只要它的行为和外观相同，它总是相同的应用程序。</p><p id="2a2c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">理解CSS加载顺序和特殊性以避免意外冲突是很重要的。</p><p id="e25d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> 🥳解决方案:</strong></p><p id="6bba" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果想要完全分离封装，可以使用<a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank"> shadow DOM </a>。这样，每个部分都有自己的DOM树，并且完全独立，不会与其范围之外的任何内容发生冲突。如果你对这个概念不熟悉，看看这篇文章。</p><p id="c895" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">另一种选择是在CSS类命名中使用<a class="ae lm" href="https://devopedia.org/bem-methodology" rel="noopener ugc nofollow" target="_blank"> BEM方法</a>。假设你有一个名为“搜索”的组件和另一个名为“侧边菜单”的组件，如果每个组件都将所有CSS类封装在类中，比如。<strong class="ks jc">搜索- </strong>标题-线索-高亮“，”。<strong class="ks jc">搜索- </strong>字幕-推广-叠加”等……<br/>。<strong class="ks jc">旁白-菜单</strong>-选项-项目“，”。<strong class="ks jc">旁白-菜单</strong>-叠加-促销-标题”等…</p><p id="7a5c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">结果将意味着更长的类名，但是非常特定于目标，并且继承问题更少。所有范围都被控制并包含在给定的组件中。</p><p id="8c0b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过这种方式，我们将所有的CSS集中在一个文件中，颜色或排版等通用设置可以在所有组件之间共享，保持一致性。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="6371" class="lu lv jb bd lw lx nw lz ma mb nx md me kh ny ki mg kk nz kl mi kn oa ko mk ml bi translated">结论</h1><p id="8dc9" class="pw-post-body-paragraph kq kr jb ks b kt mm kc kv kw mn kf ky kz mo lb lc ld mp lf lg lh mq lj lk ll ij bi translated">我们能在外部系统中实现微前端吗？是的，我们可以。</p><p id="1fbb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个过程中会有一些挑战，但是通过正确的工具集，我们可以利用平台所提供的优势(主要是在服务器端),并交付一个由不同部分组成、由不同团队开发并具有独立生命周期的应用程序。</p><p id="65f2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">离真正的持续集成和交付又近了一步。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="6cb7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你对此有什么想法？</p><p id="eb72" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你想让我在某个特定的话题上更进一步吗？<br/>查看<a class="ae lm" href="https://antonio-carvalho.medium.com/" rel="noopener">其他文章</a>并在评论中联系我！</p></div></div>    
</body>
</html>