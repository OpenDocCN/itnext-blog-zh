<html>
<head>
<title>8 propositions that will improve your React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高React应用的8个建议</h1>
<blockquote>原文：<a href="https://itnext.io/8-propositions-that-will-improve-your-react-application-fc22f6a79bd9?source=collection_archive---------0-----------------------#2018-11-28">https://itnext.io/8-propositions-that-will-improve-your-react-application-fc22f6a79bd9?source=collection_archive---------0-----------------------#2018-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir"><div class="bz fp l di"><div class="is it l"/></div></figure><figure class="iv iw ix iy gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="iz ja di jb bf jc"><div class="gh gi iu"><img src="../Images/84815e8ceca31902e3fca2aa0b66ac30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fxa6oJFh2lRD7EnAcZIcQg.png"/></div></div></figure><div class=""/><p id="5b2a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在使用React为一系列项目开发web和移动应用程序之后，我遇到了许多典型的挑战和处理它们的好方法。在这篇文章中，我总结了8个可能对你的React项目有用的建议，无论你是React新手还是中级React开发人员。</p><h1 id="77b0" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.使用创建-反应-应用程序</h1><p id="7a3a" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">不要在配置上浪费不必要的时间，破坏你的好心情！<br/>除非您对您的应用程序有非常具体的要求，否则每次您需要启动一个新项目时，花费大量精力一遍又一遍地设置您的环境是没有意义的。<br/> <a class="ae mf" href="https://facebook.github.io/create-react-app/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> Create-react-app </a>是一个官方支持的样板文件，可以帮你启动你的新项目。您将在几秒钟内准备好编写代码。</p><p id="2ea4" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你肯定会发现开发者不同意我的观点，但是我仍然坚持我的观点！我95%的时间都在使用<a class="ae mf" href="https://facebook.github.io/create-react-app/docs/getting-started" rel="noopener ugc nofollow" target="_blank">创建-反应-应用</a>。</p><p id="d1cf" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">查看脸书的官方页面，了解如何从<a class="ae mf" href="https://facebook.github.io/create-react-app/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>中获益。</p><h1 id="fd93" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.随时了解React生态系统</h1><p id="1d64" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">React生态系统非常庞大，而且还在不断扩大。<br/>您可以找到一个现成的解决方案来解决各种问题，包括样式、工具、状态管理和预构建组件。</p><p id="ae5f" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">看看这个<a class="ae mf" href="https://github.com/enaqx/awesome-react" rel="noopener ugc nofollow" target="_blank">令人敬畏的反应</a>列表，看看它是否提供了适合你的项目的解决方案。总的来说，我建议在开始自己解决问题之前，问问自己是否有人已经为你的问题找到了合适的解决方案。谷歌几乎只需点击几下鼠标。</p><h1 id="1c39" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.使用属性类型</h1><p id="0414" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">随着代码库的增长，通过类型检查可以为您节省大量捕捉bug的时间。</p><p id="0217" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对于大规模解决方案，我建议使用JavaScript扩展，比如<a class="ae mf" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，尽管使用React的内置类型检查大有帮助。</p><p id="43f0" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae mf" href="https://reactjs.org/docs/typechecking-with-proptypes.html" rel="noopener ugc nofollow" target="_blank"> PropTypes </a>真的很好用。<br/>我们来看一个例子。</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="cefe" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这个例子中，我们希望确保道具<code class="fe mg mh mi mj b">blogTitle</code>和<code class="fe mg mh mi mj b">blogID</code>分别属于<code class="fe mg mh mi mj b">string</code>和<code class="fe mg mh mi mj b">number</code>类型。<br/>此外，我们想要确保<code class="fe mg mh mi mj b">blogTitle</code>总是通过简单地链接<code class="fe mg mh mi mj b">isRequired</code>来提供</p><p id="9336" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">任何违反上述内容的行为都将导致控制台中出现警告消息。</p><h1 id="ba89" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.使用功能组件</h1><p id="ae98" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">如果你的组件不需要任何内部状态或生命周期挂钩，比如<code class="fe mg mh mi mj b">componentDidMount</code>，那么就使用功能性组件，而不是常规的类组件。</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="fff5" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这个例子中，我们看到了如何通过用功能组件替换类组件来避免不必要的复杂性和代码行。</p><p id="87ca" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这样，您使用了越来越少的可读代码，从而避免了<code class="fe mg mh mi mj b">this</code>绑定。只要有可能，你应该总是努力使用功能组件。通过这种方式，你也迫使自己重新考虑一个组件是否应该是有状态的，并且避免意外地在一个组件上存储你不应该或者不必存储的状态。</p><h1 id="cd13" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">5.当心setState</h1><p id="9684" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">当使用<code class="fe mg mh mi mj b">setState()</code>更新状态时，注意对<code class="fe mg mh mi mj b">setState()</code>的调用可能是异步的。<br/>因为React会尝试将多个<code class="fe mg mh mi mj b">setState()</code>调用批处理成一个更新，所以您不应该依赖于立即更新的state的值。</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="a071" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这个例子中，我们可能会遇到麻烦。因为在将值传递给下一行的<code class="fe mg mh mi mj b">addToTotalViews()</code>函数之前，我们不能依赖于正在更新的<code class="fe mg mh mi mj b">postViews</code>状态。</p><p id="2075" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里有3个简单的方法可以解决这个问题。</p><p id="5774" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ji"> 1。将包装在回调函数中的后续语句传递给</strong> <code class="fe mg mh mi mj b"><strong class="kg ji">setState()</strong></code></p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="acfd" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe mg mh mi mj b">setState()</code>将一个回调函数作为第二个参数，一旦状态被有效更新，该函数就会被调用。这使得对<code class="fe mg mh mi mj b">addToTotalViews()</code>的调用变得可靠。</p><p id="7fc9" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ji"> 2。传递一个函数给</strong> <code class="fe mg mh mi mj b"><strong class="kg ji">setState()</strong></code> <strong class="kg ji">而不是一个对象文字。</strong></p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="d3e3" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在我们想要基于当前状态更新状态的情况下，我们应该使用相同的技术来避免潜在的竞争情况。</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="9d00" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ji"> 3。创建一个返回承诺的异步包装函数</strong></p><p id="ddc5" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">就我个人而言，我非常喜欢这个小技巧。<br/>简单地将<code class="fe mg mh mi mj b">setState</code>包装在一个函数中，该函数返回一个承诺，当状态被有效地更新时，该承诺就会解决。</p><p id="8f80" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里有一个两个版本的包装函数的例子:ES7使用async关键字，ES6返回一个新的承诺。</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="dc85" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">您还可以选择使用一个更通用的异步包装函数来设置任何状态并返回一个承诺。</p><h1 id="aef4" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">6.避免渲染中的箭头函数和绑定</h1><p id="1932" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">在<code class="fe mg mh mi mj b">render()</code>方法中使用箭头函数或绑定似乎很简单，这种情况很常见。<br/>以下是这种用法的例子</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="75b1" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这两种方法都简单、清晰、易读，但仍应避免。<br/>原因是，在两种情况下<strong class="kg ji">都分配了一个新功能</strong>，这导致了性能影响。<br/>这似乎不是一个大问题，在许多情况下，性能问题不太可能引人注目。</p><p id="b334" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">但是想象一下，你正在使用<code class="fe mg mh mi mj b">map()</code>来呈现一个很大的组件列表，并且为每个组件多次这样做，或者你——随着你的应用程序的增长，最终到处都这样做。这将使垃圾收集器承受额外的压力，因此将匿名函数传递给<code class="fe mg mh mi mj b">blogPost</code>将导致额外的重新渲染，所有这些都可能导致渲染性能显著下降。</p><p id="dfa1" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">因此，不要去讨论你的底线在哪里，简单地考虑一下这个不好的实践，避免在<code class="fe mg mh mi mj b">render()</code>方法中使用箭头函数和绑定。</p><p id="6ddf" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">有几种方法可以实现这一点，这取决于你如何组织你的代码。<br/>一个例子可能是</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><h1 id="372d" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">7.计算属性名</h1><p id="1f8e" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">ES6中引入的许多很酷的东西之一是计算属性名。<br/>用<code class="fe mg mh mi mj b">[]</code>包装属性名，JavaScript将动态评估属性名。</p><p id="517b" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在下面的例子中，我演示了受控组件伸缩时出现的一个典型问题</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="130a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对于我们希望包含在这样的受控组件中的每个输入，我们引入一个函数来处理它的变化。<br/>这些功能几乎完全相同，最终占用了大量空间。</p><p id="6350" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这种情况下，我们可以通过用一个通用函数替换所有这些函数来处理使用计算属性名的输入更改，从而减少许多代码行。<br/>然后我们需要做的就是给输入元素一个<code class="fe mg mh mi mj b">name</code>属性，带有它应该更新的状态值。</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><h1 id="f4e2" class="lc ld jh bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">8.使用HOC的</h1><p id="63d0" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">一个特设，或称<a class="ae mf" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，是React中更先进的技术之一。<br/>然而，当你使用了一段时间后，你会发现这种方法是多么的强大。</p><p id="9f6e" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果您对函数式编程感兴趣，您可能会熟悉高阶函数的概念，即给定一个函数，返回一个新函数。</p><p id="0d5d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">同样，HOC是一个接受一个组件并返回一个新组件的函数。</p><p id="7235" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当我们想要在不同类型的组件上重用功能时，这个想法非常有用。<br/>我们可以通过将我们的<strong class="kg ji"> <em class="mk">表示组件</em> </strong>包装在一个包含我们希望重用的功能的<strong class="kg ji"> <em class="mk">容器组件</em> </strong>中来实现这一点。</p><p id="22c4" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">假设我们有一个<em class="mk"> blogPosts </em>对象的列表，我们有一个基于作者过滤这些<em class="mk"> blogPosts </em>的函数，我们有不同的组件来显示过滤后的列表。</p><p id="e141" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">除了复制这个过滤功能，我们可以定义一个HOC，它接受一个表示组件，即<em class="mk"> blogPosts </em>和<em class="mk"> authorName，</em>，并对其应用过滤逻辑</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="665d" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">HOC现在作为一个原型组件，我们可以用它来组成具有相同共享内部逻辑的不同组件。</p><p id="0037" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">注意我们返回的类没有名字。这是一个匿名类。<br/>还要注意的是，我们将任何额外的道具传递给包装的组件，因为我们不关心它接受了什么其他的道具。</p><p id="f8d4" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在我们可以像这样使用我们的HOC</p><figure class="iv iw ix iy gt ir"><div class="bz fp l di"><div class="is it l"/></div></figure><p id="3d0f" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ji">就是这样！如果您有任何问题或反馈，请随时在下面评论。如果你喜欢这篇文章，请鼓掌👏扣几下吧！</strong></p></div></div>    
</body>
</html>