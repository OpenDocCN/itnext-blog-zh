# 你应该做参数化测试

> 原文：<https://itnext.io/you-should-be-doing-parameterised-testing-79680a6f162e?source=collection_archive---------2----------------------->

编写具有良好覆盖率并能在代码的所有维度上工作的测试是耗时的、重复的、乏味的，并且受制于收益递减法则。

![](img/43f4a2d2b8ef6777f472dcb77e39c0f1.png)

当我们作为开发人员开始编写测试时，我们倾向于采用每个案例一个测试的方法，并将相关的测试聚合到套件中。例如，您可能会看到这样一个套件:

```
class TestMyCode(TestCase):

    def test_first_case(self):
        assert some_stuff()

    def test_second_case(self):
        assert some_other_stuff()

    def test_third_case(self):
        assert yet_more_stuff()
```

每个测试用例需要执行所有的定制准备、执行和断言阶段。如果这些情况密切相关，这可能导致大量的代码重复(其中一些可以在套件范围的`setUp`和`tearDown`方法中减轻，但绝不是全部)。

这种方法导致非常大的测试代码库，大量的重复，以及每当事情发生变化时的维护问题。

有更好的办法:**参数化测试**。

参数化测试要求您生成一个**单个**测试，它可以接受一组参数来配置运行。假设我们有一个相当简单的函数想要测试；类似于:

```
def compute(a, b):
    return (a + b) / (a * b)
```

为了测试这一点，我们想尝试一些场景，看看函数是如何工作的:

*   测试一些正数
*   测试一些负数
*   它对长整数和常规整数都有效吗
*   它对浮动有效吗？
*   如果其中一个或两个数字都为零，会发生什么？
*   如果一个或两个参数都没有定义，会发生什么？
*   如果其中一个或两个参数都是字符串或其他对象呢？

如果我们用传统的方法来做，我们会有一个很长的瘦函数测试列表。但是，如果我们参数化，我们可以写一个简短的测试并输入参数。

```
def test_compute(self, a, b, expected, raises=None):
    if raises is not None:
        with self.assertRaises(raises):
            compute(a, b)
    else:
        assert compute(a, b) == expected
```

这里是您可以传入的参数集的选择。真正的清单会更长，这取决于你想要的详尽程度。在这个例子中，我为`a`选择了一个好的范围，然后为`b`选择了一些随机配对。

```
a           | b   | expected | raises
------------+-----+----------+-------
-2          | 2   | 0        |
0           | 2   |          | ZeroDivisionError
2           | 2   | 1        |
0.5         | 0.4 | 4.5      |
None        | 2   |          | TypeError
"10"        | "1" |          | TypeError
3000000000L | 2   | 0.5      |
```

事情在这里开始得很好:我们期待一个足够合理的`ZeroDivisionError`，几个`TypeErrors`，加上一堆明智的回应。也许，经过思考，我们会更改函数来做一些更好的输入验证，这样我们就不必处理这些错误类型了。

当我们到达表格的最后一行时，事情变得很奇怪。我们假设 30000000000 和 2 给我们 0.5(近似值，我们一会儿会回到这个问题上)，但是如果我们真的把它代入我们的函数，我们得到的是 0，我们的测试失败了。问题是由于`a`和`b`都是整数，在 Python 中除法总是产生整数输出，0.5 变成 0。我们发现了我们函数的一个实际概念问题:

*   它应该总是有一致的输出吗？总是整数还是总是浮点数？
*   我们提供输出的精确度是多少？因为我们期望的 0.5 实际上将是`0.5000000003333334`。

我们如何解决这个问题并不是这篇文章的重点，如果你想让这个功能更加连贯，请在评论中提出你的解决方案。

什么是**什么是**重点是，使用参数化测试，我们能够创建一个简单的测试用例，并快速生成和传递一些困难的用例，以供功能完成。结果，我们首先发现了一个关于功能的目的和范围的根本问题。

当然，虽然你可以通过传统的测试方法达到这个位置，但我认为参数化测试将你思考测试的*方式*从代码本身推向了参数值空间。在这个空间中，更容易构思和组合边缘和角落案例，以进行真正有效的测试。

事实上，有很多很好的理由说明参数化测试是很棒的，您应该这样做。

正如我们在上面学到的，它能做的第一件事是迫使你更清楚地思考函数中所有可能的值。这使得思考和测试所有边缘情况(如大整数)、错误情况(如未定义的输入)及其奇怪和不一致的组合(如整数和浮点数)变得更加容易。

除此之外，它将你的思维更多地推向你的函数正在执行的过程，而不是实际执行它的代码。它不是仅仅想象哪些输入可能会破坏函数，而是要求你预测在各种情况下你的函数*应该*做什么，并帮助你推理你通常预期的行为，而不是代码本身实际会做什么。正是这种想法帮助我们揭示了上面函数的概念问题——我们是否应该只使用浮动；如果不是，那么我们在接收整数和浮点数的组合上的立场是什么？

我特别喜欢参数化测试的另一个方面。如果您生成了要测试的参数的详尽组合，您很可能会发现代码中您最初从未想过要测试的方面。要么是因为这些组合过于深奥(因此陷入了编写测试的“收益递减”阶段)，要么是因为它们看起来微不足道。在前一种情况下，你可能会发现一些新的东西，或者在后一种情况下，给你的测试增加一个角度，这有助于长期回归测试。假设当您编写测试时，一个案例是无关紧要的，那么由于一些其他的改变，下面的线不再是无关紧要的——您现在已经有了它的测试！

这些好处的一个结果是，你产生的单一测试肯定是**更难写**。你必须同时考虑更多的事情，你的单个测试比你以前写的任何单个测试都要长。但这也是一个好处——编写一个好的参数化测试的额外认知工作本身就是对您正在测试的代码的一个很好的调查，并且几乎从来没有这样的情况，在我第一次运行测试之前，我没有改进我正在测试的代码。

这种方法的第二个也是最重要的好处是，它减少了总的代码量，并且留给你的代码非常[枯燥](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)。在减少代码量的同时，它增加了一套详细和详尽的测试的可能性。添加新的测试用例相对简单——在大多数情况下，您只需扩展测试代码并传递任何新的参数。

你现在确信(显然)从现在开始，你应该以这种方式编写你所有的测试。怎么会？

如果你用 Python 工作，那么你可以使用[参数化](https://pypi.org/project/parameterized/)，这使得过程非常简单。您可以通过测试套件中方法的装饰器来传递参数:

```
class TestSuite(TestCase):
    @parameterized.expand([
        ("test_1", 0, 0, 0),
        ("test_2", 0, 1, 1)
    ])
    def test_my_feature(self, name, in_1, in_2, expected):
        assert my_feature(in_1, in_2) == expected
```

你也可以给`expand`一个函数来生成你的测试用例。我将所有参数放在 CSV 中，并在需要时加载它们，如下所示:

```
def load_test_cases():
    return load_from_csv("my_feature_parameters.csv")class TestSuite(TestCase):
    @parameterized.expand(load_test_cases)
    def test_my_feature(self, name, in_1, in_2, expected):
        assert my_feature(in_1, in_2) == expected
```

其他语言有自己的工具来支持这种测试方法，下面是一些流行的工具:

*   红宝石——帕尔马干酪[https://github.com/jpace/paramesan](https://github.com/jpace/paramesan)
*   Java—JUnitParams[https://github.com/Pragmatists/JUnitParams](https://github.com/Pragmatists/JUnitParams)
*   JavaScript —摩卡参数[https://www.npmjs.com/package/mocha-param](https://www.npmjs.com/package/mocha-param)

一旦你采用这种方法，它可以彻底改变你的测试，在以后的文章中，我们将讨论如何正确地分析你正在测试的函数。我们还将了解如何将您的测试参数作为 CSV 进行管理，甚至使用形态学分析的方法从规则集中自动生成完整的集合。

*理查德是软件开发咨询公司* [*山寨实验室*](https://cottagelabs.com) *的创始人和高级合伙人，该公司专注于数据生命周期的各个方面。他偶尔会在推特上发*[*@ Richard _ d _ Jones*](https://twitter.com/richard_d_jones)