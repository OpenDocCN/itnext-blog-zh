<html>
<head>
<title>Test-Driven Development 101 with jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jest测试驱动开发101</h1>
<blockquote>原文：<a href="https://itnext.io/test-driven-development-101-with-jest-a6e666d090a5?source=collection_archive---------1-----------------------#2020-05-08">https://itnext.io/test-driven-development-101-with-jest-a6e666d090a5?source=collection_archive---------1-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9493" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">这段摘录来自我的书</em> <a class="ae kp" href="https://www.apress.com/gp/book/9781484269718" rel="noopener ugc nofollow" target="_blank">用React </a> <em class="ko">测试驱动开发。这是本书的基础部分——关于应用TDD的端到端示例，请点击</em> <a class="ae kp" href="https://www.apress.com/gp/book/9781484269718" rel="noopener ugc nofollow" target="_blank"> <em class="ko">此链接</em> </a> <em class="ko">了解更多细节。</em></p><p id="f517" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一章中，我们将通过一步一步的指导，一起学习如何在你的日常开发程序中应用<code class="fe kq kr ks kt b">TDD</code>。通过这个演示，您将了解如何将一个大任务分割成相对较小的任务，并通过一组通过测试和一点重构技术来完成每个任务。在我们深入研究代码之前，让我们对如何编写一个合适的测试有一些基本的了解。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/cb265fa66f34721c1f9933119b66193e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*njZnmN1NNhbdEhu7"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">由<a class="ae kp" href="https://unsplash.com/@marvelous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marvin Meyer </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="feef" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">如何写出一份像样的试卷？</h1><p id="194f" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">那么，如何开始编写测试呢？通常需要3个步骤(一如既往，甚至把大象放进冰箱)。首先，做一些准备工作，如建立数据库，初始化被测对象或加载一些夹具数据。第二，调用被测试的方法/函数，你通常会把结果赋给一些变量。最后做一些断言，看看结果是不是预期的。</p><p id="9383" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常描述为<code class="fe kq kr ks kt b">Given</code>、<code class="fe kq kr ks kt b">When</code>、<code class="fe kq kr ks kt b">Then</code>或所谓的<code class="fe kq kr ks kt b">3A</code> s格式，其中<code class="fe kq kr ks kt b">3A</code> s代表<code class="fe kq kr ks kt b">Arrange</code>、<code class="fe kq kr ks kt b">Action</code>和<code class="fe kq kr ks kt b">Assertion</code>。这两种方式基本上描述的是同一个东西。</p><p id="7987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kq kr ks kt b">Given</code>子句中，你可以描述所有的准备(设置依赖)工作。在步骤<code class="fe kq kr ks kt b">When</code>中，你触发动作或者改变被测对象的状态，通常是带有准备好的参数的函数调用。最后，在<code class="fe kq kr ks kt b">Then</code>中，您检查结果，看它是否在某些方面与预期的结果匹配(确切地等于某个值，或者包含特定的模式，或者抛出一个错误，等等)</p><p id="fcb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，假设我们有以下代码片段:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="8ddf" class="mr ll it kt b gy ms mt l mu mv"><em class="ko">// given </em><br/>const user = User.create({ name: 'Juntao', address: 'ThoughtWorks Software Technologies (Melbourne)' })</span><span id="456f" class="mr ll it kt b gy mw mt l mu mv"><em class="ko">// when</em><br/>const name = user.getName()<br/>const address = user.getAddress()</span><span id="4b7b" class="mr ll it kt b gy mw mt l mu mv"><em class="ko">// then</em><br/>expect(name).toEqual('Juntao')<br/>expect(address).toEqual('ThoughtWorks Software Technologies (Melbourne)')</span></pre><p id="84d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，您可以将带有许多断言的测试用例分割成几个独立的用例，并让每个用例有一个单独的断言，就像:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="3467" class="mr ll it kt b gy ms mt l mu mv">it('creates user name', () =&gt; {<br/>  <em class="ko">// given </em><br/>  const user = User.create({ name: 'Juntao', address: 'ThoughtWorks Software Technologies (Melbourne)' })</span><span id="59d4" class="mr ll it kt b gy mw mt l mu mv">  <em class="ko">// when</em><br/>  const name = user.getName()</span><span id="1b9a" class="mr ll it kt b gy mw mt l mu mv">  <em class="ko">// then</em><br/>  expect(name).toEqual('Juntao')<br/>});</span><span id="6ac4" class="mr ll it kt b gy mw mt l mu mv">it('creates user address', () =&gt; {<br/>  <em class="ko">// given </em><br/>  const user = User.create({ name: 'Juntao', address: 'ThoughtWorks Software Technologies (Melbourne)' })</span><span id="532a" class="mr ll it kt b gy mw mt l mu mv">  <em class="ko">// when</em><br/>  const address = user.getAddress()</span><span id="113d" class="mr ll it kt b gy mw mt l mu mv">  <em class="ko">// then</em><br/>  expect(address).toEqual('ThoughtWorks Software Technologies (Melbourne)')<br/>});</span></pre><h1 id="6132" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">三角测量</h1><p id="af77" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">有几种方法可以编写测试并驱动实现。一种普遍接受的方法叫做<code class="fe kq kr ks kt b">triangulation</code>。让我们用一些例子来仔细看看如何做。</p><p id="622c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们正在用<code class="fe kq kr ks kt b">TDD</code>实现一个计算器。对<code class="fe kq kr ks kt b">addition</code>的测试可能是一个理想的起点。</p><h1 id="1412" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">第一次测试</h1><p id="800c" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">所以<code class="fe kq kr ks kt b">addition</code>的规格可以是</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="2419" class="mr ll it kt b gy ms mt l mu mv">describe('addition', () =&gt; {<br/>  it('return 5 when add 2 and 3', () =&gt; {<br/>      const a = 2, b = 3<br/>      const result = add(a, b)<br/>      expect(result).toEqual(5)<br/>  })<br/>})</span></pre><p id="58fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最简单的实现甚至可以是</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="09f5" class="mr ll it kt b gy ms mt l mu mv">const add = () =&gt; 5</span></pre><p id="2b0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会说这样写代码没有意义，但是现在请耐心听我说。那么第二个测试会是什么呢？</p><p id="a188" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以再写一个<code class="fe kq kr ks kt b">addition</code>的例子:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="56d7" class="mr ll it kt b gy ms mt l mu mv">it('return 6 when add 2 and 4', () =&gt; {<br/>    const a = 2, b = 4<br/>    const result = add(a, b)<br/>    expect(result).toEqual(6)<br/>})</span></pre><p id="952c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了通过测试，最简单的解决方案是:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="3f0a" class="mr ll it kt b gy ms mt l mu mv">const add = (a, b) =&gt; 2 + b</span></pre><p id="ae4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法是编写一个失败但具体的测试，在每一步中驱动实现代码更加通用。因此，现在的实现比第一步更通用。但是，它仍然有改进的空间。</p><p id="9631" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三个测试可能是这样的:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="4870" class="mr ll it kt b gy ms mt l mu mv">it('return 7 when add 3 and 4', () =&gt; {<br/>    const a = 3, b = 4<br/>    const result = add(a, b)<br/>    expect(result).toEqual(7)<br/>})</span></pre><p id="9bcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，测试数据中不再有模式可循，我们必须编写一些更复杂的东西来使它通过。实现结果是:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="9725" class="mr ll it kt b gy ms mt l mu mv">const add = (a, b) =&gt; a + b</span></pre><p id="59f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在实现更加通用，可以覆盖大多数<code class="fe kq kr ks kt b">addition</code>情况。在未来，我们的计算器可能需要支持虚数的<code class="fe kq kr ks kt b">addition</code>，我们仍然可以通过添加更多的测试来以同样的方式得出解决方案。</p><p id="3ffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种写测试的方法被称为<code class="fe kq kr ks kt b">Triangulation</code>:你写一个失败的测试，然后写足够的代码来通过测试，然后你写另一个测试来从另一个角度驱动变化。这反过来会让你的实现更通用一点。您以这种方式一步一步地工作，直到代码变得足够通用，能够支持大多数能够满足业务需求的情况。</p><p id="8abc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">乍一看，这样做可能太简单太慢，但是这是一个你可以并且应该依赖的坚实基础。对于一个简单的任务，你这样做，对于更复杂的任务，你仍然应用同样的方法。这是一种将简化任务和将大任务分割成小块的能力。</p><p id="4202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，让我们更进一步，看看一个复杂的例子，并学习如何在相对困难的场景中应用<code class="fe kq kr ks kt b">TDD</code>。</p><h1 id="fa69" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">通过示例分配任务</h1><p id="4abf" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">在我目前从事的项目中，我们的团队使用一种非常简单的方式来跟踪每个用户故事所付出的努力(一小块可以独立完成的工作)。通常，一张卡在其生命周期中可能处于以下状态:<code class="fe kq kr ks kt b">analysis</code>、<code class="fe kq kr ks kt b">doing</code>、<code class="fe kq kr ks kt b">testing</code>、<code class="fe kq kr ks kt b">done</code>。然而，当它所依赖的东西未完成或尚未准备好时，它可能是<code class="fe kq kr ks kt b">block</code>。</p><p id="1e84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用的对故事的努力的测量是非常简单的。基本上，我们跟踪开发人员在编码上花了多少时间，或者它被阻塞了多少天。这样，项目经理就有机会了解项目的进展情况，以及项目的整体健康状况，也许还可以采取进一步的措施来改进。</p><p id="5a29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在一张卡片的标题中用小写的<code class="fe kq kr ks kt b">d</code>表示已经在<code class="fe kq kr ks kt b">development</code>下半天，大写的<code class="fe kq kr ks kt b">D</code>表示一整天。不出意外，<code class="fe kq kr ks kt b">q</code>半天<code class="fe kq kr ks kt b">QA</code>，一整天<code class="fe kq kr ks kt b">Q</code>。因此，在任何给定的时刻，你都会在卡片的标题上看到类似这样的内容<code class="fe kq kr ks kt b">[ddDQbq] Allow user login to their profile page</code>，<code class="fe kq kr ks kt b">b</code>在这里当然是被封锁了。</p><p id="5898" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，让我们构建一个解析器，它可以读取跟踪标记<code class="fe kq kr ks kt b">ddDQbq</code>并将其翻译成一些人类可读的格式，如下所示:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="8b81" class="mr ll it kt b gy ms mt l mu mv">{<br/>  "Dev days": 2.0,<br/>  "QA days": 1,<br/>  "Blocked": 0.5<br/>}</span></pre><p id="38ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看起来很简单，对吧？迫不及待地跳起来写代码？等等，让我们先做个测试，了解一下在这种情况下如何应用<code class="fe kq kr ks kt b">TDD</code>。</p><p id="0892" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，第一个问题可能是:<strong class="js iu">我们如何将这样的任务分成更小的任务，以便于实现和验证？当然，有不止一种方法可以做到这一点，合理的拆分可以是:</strong></p><ol class=""><li id="e6f1" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">编写一个测试来确保我们可以将<code class="fe kq kr ks kt b">d</code>转换为半天开发时间</li><li id="7fa2" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">编写一个测试来确保我们可以将<code class="fe kq kr ks kt b">D</code>转换为一个开发日</li><li id="d2cd" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">编写一个测试来处理多个标记，如<code class="fe kq kr ks kt b">dD</code></li><li id="09ff" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">编写一个测试来处理<code class="fe kq kr ks kt b">q</code></li><li id="e6e5" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">编写一个测试来处理<code class="fe kq kr ks kt b">qQ</code></li><li id="ae36" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">写一个测试来处理<code class="fe kq kr ks kt b">ddQ</code></li></ol><p id="54ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在第一章中所讨论的，拆分对于应用TDD是必不可少的。小任务可以以不同的方式吸引和鼓励你:</p><ol class=""><li id="5ae3" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">这很有趣(已经证明小成就可以通过一种叫做多巴胺的化学物质来愉悦你的大脑)</li><li id="a478" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">确保你得到快速的反馈</li><li id="4281" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">知道在任何给定的时间任务的进展如何</li></ol><h1 id="40df" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">第一次测试</h1><p id="2298" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">好了，说够了，让我们动手吧。根据<code class="fe kq kr ks kt b">tasking</code>步骤的输出，第一次测试应该是</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="9048" class="mr ll it kt b gy ms mt l mu mv">it('translate d to half dev day', () =&gt; {<br/>  expect(translate('d')).toEqual({'Dev': 0.5})<br/>})</span></pre><p id="93c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常简单的是，实现可能很简单:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="a835" class="mr ll it kt b gy ms mt l mu mv">const translate = () =&gt; ({'Dev': 0.5})</span></pre><p id="4692" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它忽略输入并返回一个哑元<code class="fe kq kr ks kt b">{'Dev': 0.5}</code>，但是你不得不佩服它正好满足了当前子任务的要求。又快又脏，但很管用。</p><h2 id="2763" class="mr ll it bd lm nl nm dn lq nn no dp lu kb np nq ly kf nr ns mc kj nt nu mg nv bi translated">第二个测试</h2><p id="b47a" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">让我们检查一下任务列表中的第一个待办事项，然后继续。</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="0187" class="mr ll it kt b gy ms mt l mu mv">it('translate D to one dev day', () =&gt; {<br/>  expect(translate('D')).toEqual({'Dev': 1.0})<br/>})</span></pre><p id="83d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你想到的最直接的解决方案是什么？没错！</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="3e3e" class="mr ll it kt b gy ms mt l mu mv">const translate = (c) =&gt; (c === 'd' ? {'Dev': 0.5}: {'Dev': 1.0})</span></pre><p id="a397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道用这种方式写代码看起来相对“愚蠢”。然而，正如您所看到的，我们的实现是由相关的测试驱动的，只要测试通过——这意味着需求得到满足——我们就可以称之为满意。我们编写代码的唯一原因是满足一些业务需求，对吗？</p><p id="09a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然测试现在已经通过了，如果你发现有可以改进的地方，比如<code class="fe kq kr ks kt b">magic numbers</code>，方法体太长等等，你可以做一些重构。然而，现在，我想我们可以继续。</p><p id="6503" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以第三个测试可能是:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="ed1d" class="mr ll it kt b gy ms mt l mu mv">it('translate dD to one and a half dev day', () =&gt; {<br/>  expect(translate('dD')).toEqual({'Dev': 1.5})<br/>})</span></pre><p id="4294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，现在事情变得更复杂了，我们必须单独解析字符串，并对结果求和。下面的代码片段应该可以解决问题:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="f028" class="mr ll it kt b gy ms mt l mu mv">const translate = (input) =&gt; {<br/>  let sum = 0;<br/>  input.split('').forEach((c) =&gt; sum += c === 'd' ? 0.5: 1.0)<br/>  return {'Dev': sum}<br/>}</span></pre><p id="2844" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的程序可以毫无问题地处理所有的<code class="fe kq kr ks kt b">d</code>或<code class="fe kq kr ks kt b">D</code>组合序列，如<code class="fe kq kr ks kt b">ddd</code>或<code class="fe kq kr ks kt b">DDdDd</code>。接下来是任务4:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="8b18" class="mr ll it kt b gy ms mt l mu mv">it('translate q to half qa day', () =&gt; {<br/>    expect(translate('q')).toEqual({'QA': 0.5})<br/>  })</span></pre><p id="71b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">似乎我们需要为每种状态设置一个<code class="fe kq kr ks kt b">sum</code>函数，例如<code class="fe kq kr ks kt b">Dev</code>中的<code class="fe kq kr ks kt b">sum</code>，以及<code class="fe kq kr ks kt b">QA</code>中的<code class="fe kq kr ks kt b">sum</code>。如果我们能稍微重构一下代码，使更改变得更容易，那就更方便了。TDD最漂亮的部分出现了——您不必担心意外破坏现有的功能，因为您有测试来覆盖它们。</p><h2 id="6ca5" class="mr ll it bd lm nl nm dn lq nn no dp lu kb np nq ly kf nr ns mc kj nt nu mg nv bi translated">重构</h2><p id="d0c9" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">让我们将解析部分提取出来作为一个函数本身，并在<code class="fe kq kr ks kt b">translate</code>中使用该函数。</p><p id="1196" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重构后，函数<code class="fe kq kr ks kt b">translate</code>可能是这样的:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="5df4" class="mr ll it kt b gy ms mt l mu mv">const parse = (c) =&gt; {<br/>  switch(c) {<br/>    case 'd': return {status: 'Dev', effort: 0.5}<br/>    case 'D': return {status: 'Dev', effort: 1}<br/>  }<br/>}</span><span id="5c29" class="mr ll it kt b gy mw mt l mu mv">const translate = (input) =&gt; {<br/>  const state = {<br/>    'Dev': 0,<br/>    'QA': 0<br/>  }</span><span id="6d15" class="mr ll it kt b gy mw mt l mu mv">  input.split('').forEach((c) =&gt; {<br/>    const {status, effort} = parse(c)<br/>    state[status] = state[status] + effort<br/>  })</span><span id="ba16" class="mr ll it kt b gy mw mt l mu mv">  return state<br/>}</span></pre><p id="e7fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，通过新的测试应该不难了。我们可以在<code class="fe kq kr ks kt b">parse</code>中增加一个新的<code class="fe kq kr ks kt b">case</code>:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="f30b" class="mr ll it kt b gy ms mt l mu mv">const parse = (c) =&gt; {<br/>  switch(c) {<br/>    case 'd': return {status: 'Dev', effort: 0.5}<br/>    case 'D': return {status: 'Dev', effort: 1}<br/>    case 'q': return {status: 'QA', effort: 0.5}<br/>  }<br/>}</span></pre><p id="854c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">酷，我喜欢。</p><h1 id="585d" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">更进一步</h1><p id="2bde" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">同样，标记<code class="fe kq kr ks kt b">Q</code>也是如此。事实上，对于包含不同标记的任务，根本不需要修改代码。然而，作为一个体面的程序员，我们可以不断清理代码，直到达到理想状态。例如，我们可以将解析提取为一些查找字典:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="c90f" class="mr ll it kt b gy ms mt l mu mv">const dict = {<br/>  'd': {<br/>    status: 'Dev',<br/>    effort: 0.5<br/>  },<br/>  'D': {<br/>    status: 'Dev',<br/>    effort: 1.0<br/>  },<br/>  'q': {<br/>    status: 'QA',<br/>    effort: 0.5<br/>  },<br/>  'Q': {<br/>    status: 'QA',<br/>    effort: 1.0<br/>  }<br/>}</span></pre><p id="4ba5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将把<code class="fe kq kr ks kt b">parse</code>简化为类似于</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="324a" class="mr ll it kt b gy ms mt l mu mv">const parse = (c) =&gt; dict[c]</span></pre><p id="74b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了清晰起见，您甚至可以将<code class="fe kq kr ks kt b">dict</code>作为数据提取到一个名为<code class="fe kq kr ks kt b">constants</code>的单独文件中，并导入到<code class="fe kq kr ks kt b">translator.js</code>中。对于函数<code class="fe kq kr ks kt b">translate</code>中的<code class="fe kq kr ks kt b">forEach</code>，我们可以使用<code class="fe kq kr ks kt b">Array.reduce</code>使其更短:</p><pre class="kv kw kx ky gt mn kt mo mp aw mq bi"><span id="6935" class="mr ll it kt b gy ms mt l mu mv">const translate = (input) =&gt; {<br/>  const items = input.split('')<br/>  return items.reduce((accumulator, current) =&gt; {<br/>    const { status, effort } = parse(current)<br/>    accumulator[status] = (accumulator[status] || 0) + effort<br/>    return accumulator<br/>  }, {})<br/>}</span></pre><p id="2575" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">又漂亮又干净，对吧？</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/eb1c9c9c90dfeaeb2e935c23db52162a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*hRguxaJJ2dEQ1QSTq4F0Rw.png"/></div></figure><h1 id="74a3" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">摘要</h1><p id="2903" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">我们学习了编写正确测试的三个基本步骤。现在了解如何使用<code class="fe kq kr ks kt b">Triangulation</code>在测试中推出不同的路径。然后我们学习了如何执行<code class="fe kq kr ks kt b">tasking</code>来帮助我们编写测试。还有，我们一步一步地按照<code class="fe kq kr ks kt b">TDD</code>的方式走过一个合理的小程序，最终得到了一个现实场景中有用的东西。</p><p id="030b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，<a class="ae kp" href="https://www.apress.com/gp/book/9781484269718" rel="noopener ugc nofollow" target="_blank">如果你觉得这篇文章有帮助，多读读这本书</a>。</p></div></div>    
</body>
</html>