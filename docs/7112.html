<html>
<head>
<title>Version 1.18 Refresh for Go Programmers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Go程序员的1.18版本更新</h1>
<blockquote>原文：<a href="https://itnext.io/version-1-18-refresh-for-go-programmers-f1b0fcfa3b4a?source=collection_archive---------0-----------------------#2022-06-16">https://itnext.io/version-1-18-refresh-for-go-programmers-f1b0fcfa3b4a?source=collection_archive---------0-----------------------#2022-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">离开围棋编程有一段时间了吗？让我们看看你可能已经忘记的东西。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da6dbe2d3ccde4222b2cf00e78096ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuPYpyEv6Ugo5BN-gZNdEA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">https://github.com/egonelbre/gophers<a class="ae ky" href="https://github.com/egonelbre/gophers" rel="noopener ugc nofollow" target="_blank">埃贡·厄尔布尔的艺术作品</a></figcaption></figure><p id="6ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">我在不同的语言间跳跃，当我回到一门我已经有一段时间没用过的语言时，有些东西我没有忘记，而其他的东西更容易忘记。这是你在围棋中可能会感到困惑的事情，因为它们在过去几年里发生了很大的变化。</p><p id="1032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主题故事:<a class="ae ky" href="https://erik-engheim.medium.com/refreshing-your-swift-and-cocoa-programming-skills-f80b041fd24a" rel="noopener">刷新你的Swift和Cocoa编程技能</a></p><p id="3d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我喜欢谈论的一些话题:</p><ul class=""><li id="0d85" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">GOROOT</code>和<code class="fe mn mo mp mq b">GOPATH</code>环境变量。还需要它们吗？</li><li id="ab23" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">模块和包</li><li id="64d6" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">命令行工具—构建、获取依赖项和运行测试</li><li id="235f" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">使用指针时的陷阱</li><li id="b525" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">记录</li><li id="5ba9" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">错误处理</li><li id="1610" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">枚举</li><li id="e7e0" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">在Go二进制文件中嵌入数据文件</li></ul><h2 id="ce7b" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">GOROOT和GOPATH的区别，我们还需要它们吗？</h2><p id="3f33" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">出于某种原因，我总是把Go环境变量相互混淆，而且自从引入模块以来，我总是忘记是否需要它们。</p><ul class=""><li id="ae0f" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">GOROOT</code> -你的Go SDK的位置。如果您安装了多个版本的Go，这将非常有用。</li><li id="6974" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">GOPATH</code> -个人工作区的根目录。在Linux和macOS上默认为<code class="fe mn mo mp mq b">~/go</code>。</li></ul><p id="0ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以自己设置这些变量。在我的Mac上<code class="fe mn mo mp mq b">GOROOT</code>没有设置任何东西，Go工作正常。你不需要<code class="fe mn mo mp mq b">GOPATH</code>指向你开发代码的目录。我把我的go代码放在<code class="fe mn mo mp mq b">~/Dev/go</code>里，但是你需要一个地方来安装第三方Go工具和包。这就是<code class="fe mn mo mp mq b">GOPATH</code>的用武之地。我将我的<code class="fe mn mo mp mq b">GOPATH</code>设置为<code class="fe mn mo mp mq b">~/.go</code> in:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="71b4" class="mw mx it mq b gy ny nz l oa ob"># Added to my ~/.config/fish/config.fish<br/>set -x GOPATH $HOME/.go</span></pre><p id="53b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在前面加了一个点，让它看不见(只在Unix系统上有效)。原因是您很少需要进入<code class="fe mn mo mp mq b">GOPATH</code>目录，因为您将自己的代码分开保存。您可以使用<code class="fe mn mo mp mq b">tree</code>命令查看内容。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="5c5e" class="mw mx it mq b gy ny nz l oa ob">❯ tree -L 1 $GOPATH<br/>~/.go<br/>├── bin<br/>├── pkg<br/>└── src</span></pre><p id="cdb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该将<code class="fe mn mo mp mq b">$GOPATH/bin</code>添加到您的<code class="fe mn mo mp mq b">PATH</code>中，以确保Go二进制文件可以被您的shell发现并运行。下面是我如何配置我的fish shell来查找go二进制文件:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="b050" class="mw mx it mq b gy ny nz l oa ob"># To run home-made go commands and installed go programs<br/>set -x PATH $PATH /usr/local/go/bin $GOPATH/bin</span></pre><h2 id="55d9" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">Go v1.18中的命令行工具和模块</h2><p id="f13d" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">Go中模块的引入极大地改变了我们在Go中使用命令行工具和环境变量的方式。它降低了环境变量的重要性，如<code class="fe mn mo mp mq b">GOPATH</code>。让我们看看我如何构建我的<code class="fe mn mo mp mq b">rocket</code> Go项目的不同部分。为了创建这个项目，我将执行以下操作:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="c166" class="mw mx it mq b gy ny nz l oa ob">❯ cd $GOPATH/src<br/>❯ mkdir rocket<br/>❯ cd rocket<br/>❯ go mod init github.com/ordovician/rocket</span></pre><p id="a338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦填充了源代码文件，它将类似于下面的清单:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="2a0a" class="mw mx it mq b gy ny nz l oa ob">❯ tree -L 2 rocket/<br/>rocket/<br/>├── README.md<br/>├── go.mod<br/>├── go.sum<br/>├── cmd<br/>│   ├── launcher<br/>│   └── server<br/>├── engine<br/>│   ├── engine.go<br/>│   ├── engine_example_test.go<br/>│   ├── merlin_engine.go<br/>│   └── rutherford_engine.go<br/>├── math<br/>│   └── math.go<br/>├── physics<br/>│   ├── equations.go<br/>│   ├── motion.go<br/>│   ├── rigidbody.go<br/>│   └── rigidbody_test.go<br/>├── propulsion.go<br/>├── stagedrocket.go<br/>├── stagedrocket_test.go<br/>├── tank<br/>│   ├── flexitank.go<br/>│   ├── tank.go<br/>│   └── tanks_test.go<br/>├── types.go<br/>└── util_test.go</span></pre><p id="ce73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顶层的源代码如<code class="fe mn mo mp mq b">propulsion.go</code>和<code class="fe mn mo mp mq b">stagedrocket.go</code>属于<code class="fe mn mo mp mq b">rocket</code>包。这反映在它们在目录层次结构中的位置以及源代码中。我的<code class="fe mn mo mp mq b">stagedrocket.go</code>文件的开头是这样的:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="6e48" class="mw mx it mq b gy ny nz l oa ob">package rocket<br/><br/>import (<br/>	. "github.com/ordovician/rocket/engine"<br/>	. "github.com/ordovician/rocket/physics"<br/>	. "github.com/ordovician/rocket/tank"<br/>)<br/><br/>type MultiStaged struct {<br/>	payload Rocket<br/>	Propulsion<br/>}</span></pre><p id="0ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe mn mo mp mq b">rocket</code>下的每个子目录定义了不同的包。下面是从<code class="fe mn mo mp mq b">flexitank.go</code>文件开始的:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="bc79" class="mw mx it mq b gy ny nz l oa ob">package tank<br/><br/>import (<br/>	. "github.com/ordovician/rocket/physics"<br/>)<br/><br/>// A tank with flexible size<br/>type FlexiTank struct {<br/>	DryMass    Kg<br/>	TotalMass  Kg<br/>	propellant Kg<br/>}</span></pre><p id="6a11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模块和包之间有重叠。<code class="fe mn mo mp mq b">github.com/ordovician/rocket</code>是包含<code class="fe mn mo mp mq b">rocket</code>包的模块。但这不是它包含的唯一的包。例如，它还包含<code class="fe mn mo mp mq b">physics</code>、<code class="fe mn mo mp mq b">tank</code>和<code class="fe mn mo mp mq b">math</code>包。</p><h2 id="8fca" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">cmd中的命令行工具</h2><p id="a4ee" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated"><code class="fe mn mo mp mq b">rocket/cmd</code>目录很有趣，因为每个目录都包含创建可执行文件的文件。这要求<code class="fe mn mo mp mq b">main</code>功能存在。但是，您不能在任何包中拥有<code class="fe mn mo mp mq b">main</code>功能。它需要在<code class="fe mn mo mp mq b">main</code>包中。这就是为什么我们正在构建的每个命令在<code class="fe mn mo mp mq b">rocket/cmd</code>下都有一个单独的目录。</p><h2 id="83e8" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">构建包和命令行工具</h2><p id="7386" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们可以用<code class="fe mn mo mp mq b">go build</code>命令构建整个包、单个文件、子包或命令行工具。当创建一个模块时，你要为它指定一个名字，这个名字应该反映出你要把这个模块放到什么地方。例如，我的<code class="fe mn mo mp mq b">rocket</code>模块用<code class="fe mn mo mp mq b">go mod init</code>命令命名为<code class="fe mn mo mp mq b">github.com/ordovician/rocket</code>,因为那是我将存储包的git库。因为这是模块的实际名称，所以在构建、运行或测试时通常使用它。你会写:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="6401" class="mw mx it mq b gy ny nz l oa ob">❯ go build github.com/ordovician/rocket</span></pre><p id="a982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这个<strong class="lb iu">只有当你在一个有<code class="fe mn mo mp mq b">go.mod</code>文件的目录中时</strong>才起作用，这个文件实际上定义了这个模块。这个构建命令不构建不是<code class="fe mn mo mp mq b">rocket</code>的包，比如我们在<code class="fe mn mo mp mq b">cmd</code>子目录中的命令行工具。要构建特定的命令，我们必须指定完整的包路径。导入Go包时使用的相同路径:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="e782" class="mw mx it mq b gy ny nz l oa ob">❯ go build github.com/ordovician/rocket/cmd/server</span></pre><p id="bd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，每次都这样写完整路径可能会很尴尬。幸运的是，我们可以使用相对路径。你必须从<code class="fe mn mo mp mq b">./</code>开始，因为Go会把<code class="fe mn mo mp mq b">cmd/server</code>或<code class="fe mn mo mp mq b">/cmd/server</code>当作一个包名，而不是一个本地定义的包。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="68e7" class="mw mx it mq b gy ny nz l oa ob">❯ go build .              # build rocket package<br/>❯ go build ./engine/      # build engine package<br/>❯ go build ./cmd/server   # build server binary</span></pre><p id="be1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法也适用于<code class="fe mn mo mp mq b">test</code>和<code class="fe mn mo mp mq b">run</code>命令。让我们看看在<code class="fe mn mo mp mq b">_test.go</code>文件中定义的运行测试(缩短的输出):</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="4b01" class="mw mx it mq b gy ny nz l oa ob">❯ go test -v ./tank<br/>=== RUN   TestMakeMediumTank<br/>--- PASS: TestMakeMediumTank (0.00s)<br/>=== RUN   TestMakeLargeTank<br/>--- PASS: TestMakeLargeTank (0.00s)<br/>=== RUN   ExampleMediumTank_Consume<br/>--- PASS: ExampleMediumTank_Consume (0.00s)<br/>PASS<br/>ok  	github.com/ordovician/rocket/tank	(cached)<br/><br/>❯ go test -v .<br/>=== RUN   TestStageSeparation<br/>--- PASS: TestStageSeparation (0.00s)<br/>=== RUN   TestThrustTooLowForGravity<br/>--- PASS: TestThrustTooLowForGravity (0.00s)<br/>=== RUN   TestPlentyPowerful<br/>--- PASS: TestPlentyPowerful (0.00s)<br/>=== RUN   TestCompareWithNewtonMotionEquations<br/>--- PASS: TestCompareWithNewtonMotionEquations (0.00s)<br/>PASS<br/>ok  	github.com/ordovician/rocket	(cached)</span></pre><p id="ba01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行单独的测试，添加<code class="fe mn mo mp mq b">-run</code>标志。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="7d95" class="mw mx it mq b gy ny nz l oa ob">❯ go test -v -run TestStageSeparation<br/>=== RUN   TestStageSeparation<br/>--- PASS: TestStageSeparation (0.00s)<br/>PASS<br/>ok  	github.com/ordovician/rocket	0.116s</span></pre><p id="6125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也适用于子包。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="7d67" class="mw mx it mq b gy ny nz l oa ob">❯ go test -v -run TestMakeLargeTank ./tank<br/>=== RUN   TestMakeLargeTank<br/>--- PASS: TestMakeLargeTank (0.00s)<br/>PASS<br/>ok  	github.com/ordovician/rocket/tank	0.164s</span></pre><p id="063a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以以类似的方式使用<code class="fe mn mo mp mq b">go run</code>命令。如果你在不断地改变和开发一个可执行文件，那么做一个先构建后运行的两步过程是很笨拙的。最好将编译和运行合并到一个步骤中。这里我将展示一个来自我的<code class="fe mn mo mp mq b">cryptools</code>模块的例子，它包含了一些用于加密和解密的小命令。在这个例子中，我生成了一个以base64格式存储的16字节长的加密和解密密钥。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="f9b3" class="mw mx it mq b gy ny nz l oa ob">❯ go run ./cmd/generate -keylen 16 -encoding base64 key.txt</span></pre><p id="882e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于以下两步过程:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="03f5" class="mw mx it mq b gy ny nz l oa ob">❯ go build ./cmd/generate<br/>❯ ./generate -keylen 16 -encoding base64 key.txt</span></pre><h2 id="7c67" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">安装Go模块和工具</h2><p id="85d8" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在过去，你可以使用<code class="fe mn mo mp mq b">go get</code>来获得任何你想安装的Go工具。在modern Go中，我们只使用<code class="fe mn mo mp mq b">go get</code>来安装你开发的模块的依赖项。假设你正在开发一个依赖于GTK GUI工具包的医疗应用程序。首先，我将创建项目:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="377a" class="mw mx it mq b gy ny nz l oa ob">❯ mkdir medical<br/>❯ cd medical<br/>❯ go mod init github.com/ordovician/medical</span></pre><p id="2a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我添加GTK依赖项:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="ef50" class="mw mx it mq b gy ny nz l oa ob">❯ go get github.com/gotk3/gotk3<br/>go: downloading github.com/gotk3/gotk3 v0.6.1<br/>go: added github.com/gotk3/gotk3 v0.6.1</span></pre><p id="6bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到,<code class="fe mn mo mp mq b">go.mod</code>文件被修改以包含这个依赖关系:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="2d75" class="mw mx it mq b gy ny nz l oa ob">❯ cat go.mod<br/>module github.com/ordovician/medical<br/><br/>go 1.18<br/><br/>require github.com/gotk3/gotk3 v0.6.1 // indirect</span></pre><p id="454c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于很多老的go项目，你会看到README文件说你应该写<code class="fe mn mo mp mq b">go get</code>来安装它们，但是这不再适用了。相反，您使用<code class="fe mn mo mp mq b">go install</code>并且您必须用一个<code class="fe mn mo mp mq b">@</code>符号指定您想要的版本。使用<code class="fe mn mo mp mq b">@latest</code>获取最新信息。我习惯使用TextMate编辑器，这意味着我需要安装<code class="fe mn mo mp mq b">gocode</code>才能在我的编辑器中完成命令。我是这样做的:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="70f2" class="mw mx it mq b gy ny nz l oa ob">❯ go install github.com/stamblerre/gocode@latest</span></pre><p id="905e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你可能想安装许多其他有趣的Go工具。拥有一个调试器是有用的。Delve是目前最受欢迎的围棋:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="0206" class="mw mx it mq b gy ny nz l oa ob">❯ go install github.com/go-delve/delve/cmd/dlv@latest</span></pre><p id="4d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想安装一个特定的版本，你可以写:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="4821" class="mw mx it mq b gy ny nz l oa ob">❯ go install github.com/go-delve/delve/cmd/dlv@v1.7.3</span></pre><h2 id="b08c" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">删除和添加所需的依赖项</h2><p id="c497" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">您可能希望根据模块实际使用的内容来删除或添加依赖项。为此，您可以使用<code class="fe mn mo mp mq b">go mod tidy</code>。它删除了任何源代码中没有使用的依赖项，实际上添加了您需要的依赖项。了解更多信息，请访问:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="7bc5" class="mw mx it mq b gy ny nz l oa ob">❯ go help mod tidy</span></pre><h2 id="d20d" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">使用指针的陷阱</h2><p id="b2a2" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我在休息一段时间后重新开始编程时犯的第一个错误是错误地使用指针，所以这里有一个警告和提醒来帮助你避免同样的问题。我专门建造了你们所说的竞技场分配器。这是一种快速分配相同大小的对象的方法。它对于像二叉树这样的东西很有用，因为Go垃圾收集器做得不如Java。</p><p id="1198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">竞技场分配器跟踪空闲内存块的列表。每当你释放一个块，它会被放回到这个列表中。这段代码使用了Go泛型，因此它也是对Go泛型的一次有益更新:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="cd3a" class="mw mx it mq b gy ny nz l oa ob">type Arena[T any] struct {<br/>	blocks Stack[*T]  // NOTE: Stack is a collection I made<br/>}<br/><br/>func (arena *Arena[T]) Alloc() *T {<br/>	if arena.blocks.IsEmpty() {<br/>		var blocks [8]T<br/>		for i, _ := range blocks {<br/>			arena.blocks.Push(&amp;blocks[i])<br/>		}<br/>	}<br/>	b, _ := arena.blocks.Top()<br/>	arena.blocks.Pop()<br/><br/>	return b<br/>}<br/><br/>func (arena *Arena[T]) Free(block *T) {<br/>	if block == nil {<br/>		panic("Cannot free nil pointer")<br/>	}<br/><br/>	arena.blocks.Push(block)<br/>}</span></pre><p id="4e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个变体是有效的，但是在我最初的变体中，我写的for-loop是错误的:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="8de0" class="mw mx it mq b gy ny nz l oa ob">// DON'T do this, block will be a copy of blocks[i]<br/>var blocks [8]T<br/>for i, block := range blocks {<br/>	arena.blocks.Push(&amp;block)<br/>}</span></pre><p id="f573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有什么不好？那不是更优雅吗？这里的问题是Go没有引用。<code class="fe mn mo mp mq b">block</code>不是对元素<code class="fe mn mo mp mq b">blocks[i]</code>的引用，而是该元素的副本。因此，<code class="fe mn mo mp mq b">&amp;block</code>将是这个副本的地址。因为每个<code class="fe mn mo mp mq b">blocks[i]</code>元素在迭代时被复制到相同的内存位置，所以我最终将完全相同的地址推送到<code class="fe mn mo mp mq b">arena.blocks</code>堆栈对象上。因此<code class="fe mn mo mp mq b">Alloc</code>方法总是返回完全相同的对象。调试和发现每当我修改一个返回的对象时，所有其他分配的对象都会被修改，这真的令人困惑。</p><h2 id="89b7" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">记录</h2><p id="259d" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">作为一个经常编写Julia代码的人，我必须说我对登录Go并不感到兴奋。Julia自带内置日志记录，它有日志记录级别，使用LISP，就像宏一样，这使得编写日志记录代码变得非常方便。Go的内置日志有点过于简单，而以我个人的浅见，像<a class="ae ky" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank"> Zap </a>这样的流行第三方日志工具并不容易设置，也不容易使用。Zap最基本的用法很简单:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="537e" class="mw mx it mq b gy ny nz l oa ob">logger, _ := zap.NewProduction()<br/>defer logger.Sync() // flushes buffer, if any<br/>sugar := logger.Sugar()<br/>sugar.Infow("failed to fetch URL",<br/>  // Structured context as loosely typed key-value pairs.<br/>  "url", url,<br/>  "attempt", 3,<br/>  "backoff", time.Second,<br/>)<br/>sugar.Infof("Failed to fetch URL: %s", url)</span></pre><p id="39a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我发现一旦我想做更复杂的事情，我不太明白代码在做什么，文档也没有很好地解释。但是对于任何认真编写大型应用程序的人来说，你应该投资学习Zap，因为它给了你结构化的日志。结构化日志记录是以结构化的格式给出日志记录数据，因此可以很容易地被工具分析。</p><p id="af38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不愿意花大量时间学习错综复杂的日志技术，那么我认为内置日志框架更好。你只需要学会如何定制它。下面是我如何用内置的Julia日志系统模拟日志级别。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="fcf7" class="mw mx it mq b gy ny nz l oa ob">var (<br/>	DebugLog *log.Logger<br/>	WarnLog  *log.Logger<br/>	InfoLog  *log.Logger<br/>	ErrorLog *log.Logger<br/>)<br/><br/>// Called first in any package<br/>func init() {<br/>	file, err := os.OpenFile("logs.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)<br/>	if err != nil {<br/>		log.Fatal(err)<br/>	}<br/><br/>	flags := log.Ldate|log.Ltime|log.Lshortfile<br/><br/>	DebugLog = log.New(io.Discard, "DEBUG: ", flags)<br/>	InfoLog  = log.New(io.Discard, "INFO: ", flags)<br/>	WarnLog  = log.New(file, "WARNING: ", flags)<br/>	ErrorLog = log.New(file, "ERROR: ", flags)<br/>}<br/><br/>func main() {<br/>	InfoLog.Println("Starting up")<br/>    WarnLog.Println("Shutting down")<br/>}</span></pre><p id="3b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个设置中，我正在记录一个名为<code class="fe mn mo mp mq b">logs.txt</code>的文件。创建记录器的函数如下所示:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="a2a6" class="mw mx it mq b gy ny nz l oa ob">func New(out io.Writer, prefix string, flag int) *Logger</span></pre><p id="627f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数<code class="fe mn mo mp mq b">out</code>表示将日志输出发送到哪里。你可能会注意到，对于<code class="fe mn mo mp mq b">WarnLog</code>和<code class="fe mn mo mp mq b">ErrorLog</code>，我将它设置为<code class="fe mn mo mp mq b">file</code>，这是指我的<code class="fe mn mo mp mq b">logs.txt</code>文件，而其他的都设置为<code class="fe mn mo mp mq b">io.Discard</code>。<code class="fe mn mo mp mq b">io.Discard</code>有点像<code class="fe mn mo mp mq b">dev/null</code>，任何送到那里的东西都会消失。这是禁用日志记录的简单方法。所以在我的例子中，<code class="fe mn mo mp mq b">InfoLog</code>和<code class="fe mn mo mp mq b">DebugLog</code>已经被禁用。</p><h2 id="6e04" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">Go中的错误处理</h2><p id="fe88" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">虽然在Go中处理错误往往只是返回一个错误对象，但是有很多关于如何做的模式，记住这些模式是很有用的。</p><p id="d373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java、C#和Python等许多编程语言中，我们倾向于为每个错误创建全新的类型。Go非常简单，所以Go中的不同错误往往只是简单的实例值。以下是一些常见输入/输出错误的定义:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="c141" class="mw mx it mq b gy ny nz l oa ob">// End of File. When you cannot read more<br/>var EOF = errors.New("EOF")<br/><br/>// ErrUnexpectedEOF means that EOF was encountered in the<br/>// middle of reading a fixed-size block or data structure.<br/>var ErrUnexpectedEOF = errors.New("unexpected EOF")</span></pre><p id="9e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，<code class="fe mn mo mp mq b">errors.New</code>总是返回一个新的对象，所以您必须与特定的<code class="fe mn mo mp mq b">EOF</code>实例进行比较，以查看您是否到达了文件的末尾。您还需要在自定义代码中实际返回这个值。这里我从一个TCP/IP套接字读入一个缓冲区，并得到读取的字节数<code class="fe mn mo mp mq b">n</code>和任何可能的错误<code class="fe mn mo mp mq b">err</code>。因为错误可能是<a class="ae ky" href="https://pkg.go.dev/errors" rel="noopener ugc nofollow" target="_blank">嵌套对象</a>，所以应该使用<code class="fe mn mo mp mq b">errors.Is</code>进行比较，而不是使用<code class="fe mn mo mp mq b">err == io.EOF</code>。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="e677" class="mw mx it mq b gy ny nz l oa ob">n, err := socket.Read(buffer)<br/>if errors.Is(err, io.EOF) {<br/>	break<br/>}</span></pre><p id="31f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该熟悉<a class="ae ky" href="https://pkg.go.dev/errors" rel="noopener ugc nofollow" target="_blank">错误</a>包中的所有这些错误函数:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="54f5" class="mw mx it mq b gy ny nz l oa ob">func As(err error, target any) bool<br/>func Is(err, target error) bool<br/>func New(text string) error<br/>func Unwrap(err error) error</span></pre><p id="4f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用带有<code class="fe mn mo mp mq b">%w</code>格式化程序的<code class="fe mn mo mp mq b">fmt.Errorf</code>函数包装错误。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="5f31" class="mw mx it mq b gy ny nz l oa ob">newerr := fmt.Errorf("Stuff went wrong because %w", err)</span></pre><p id="a2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设已经嵌套了几个错误对象，并且在嵌套深处的某个地方有一个<code class="fe mn mo mp mq b">fs.PathError</code>错误，您希望获得导致该错误的<code class="fe mn mo mp mq b">Path</code>。你可以用<code class="fe mn mo mp mq b">As</code>方法做到这一点:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="4efe" class="mw mx it mq b gy ny nz l oa ob">var perr *fs.PathError<br/>if errors.As(err, &amp;perr) {<br/>	fmt.Println(perr.Path)<br/>}</span></pre><p id="5b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您可以使用<code class="fe mn mo mp mq b">fmt.Errorf</code>返回错误对象，但有时您需要创建带有特殊字段的自定义错误对象。对于匹配<code class="fe mn mo mp mq b">error</code>接口的对象，它只需要实现<code class="fe mn mo mp mq b">Error()</code>方法，返回描述错误的字符串。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="ac23" class="mw mx it mq b gy ny nz l oa ob">type MyError struct {<br/>	When time.Time<br/>	What string<br/>}<br/><br/>func (e MyError) Error() string {<br/>	return fmt.Sprintf("%v: %v", e.When, e.What)<br/>}</span></pre><h2 id="461c" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">围棋中的枚举</h2><p id="a30c" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">与errors非常相似，enums在Go中非常简单。事实上，并不真正支持特殊的枚举类型。相反，您需要处理的是一组关于常量的常见实践和约定。这里有一个为一些对象定义“枚举”的例子，这些对象是我在模拟Unix命令时创建的，这些命令在执行后必须返回一个结果。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="9cdb" class="mw mx it mq b gy ny nz l oa ob">//go:generate stringer -type=ExitCode<br/><br/>type ExitCode int<br/><br/>const (<br/>	Ok      ExitCode = iota // normal result<br/>	Failure                 // Command could not complete task<br/>	Quit                    // request to quit shell<br/>)</span></pre><p id="e6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<code class="fe mn mo mp mq b">OK</code>、<code class="fe mn mo mp mq b">Failure</code>和<code class="fe mn mo mp mq b">Quit</code>不是被定义为简单的整数值，而是自定义的<code class="fe mn mo mp mq b">ExitCode</code>类型。为什么这么做？这样，就更容易避免意外地传递超出范围的常规整数。使用<code class="fe mn mo mp mq b">iota</code>这些常量得到值0、1和2。除此之外，我们不要其他价值。</p><p id="d7bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是一个万无一失的系统，因为有人可以只写<code class="fe mn mo mp mq b">ExitCode(42)</code>并将其作为参数传递。就我个人而言，我不认为这是个问题。关键是不要意外地传递无效值。</p><h2 id="8448" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">满足纵梁接口</h2><p id="4158" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">想要一个文本字符串版本的枚举值是很常见的。您可以将<code class="fe mn mo mp mq b">String()</code>方法添加到<code class="fe mn mo mp mq b">Exit</code>代码中，从而满足<code class="fe mn mo mp mq b">Stringer</code>接口。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="c71d" class="mw mx it mq b gy ny nz l oa ob">type Stringer interface {<br/>	String() string<br/>}</span></pre><p id="bc99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更方便的方法是使用与Go捆绑在一起的<a class="ae ky" href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer" rel="noopener ugc nofollow" target="_blank"> stringer命令</a>来自动生成它。一个简单的方法是:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="7dcc" class="mw mx it mq b gy ny nz l oa ob">❯ stringer -type=ExitCode</span></pre><p id="d402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将在当前目录中查找定义<code class="fe mn mo mp mq b">ExitCode</code>类型的文件，并查看与之相关的常量以添加一个<code class="fe mn mo mp mq b">String()</code>方法。它被放在<code class="fe mn mo mp mq b">exitcode_string.go</code>文件中。所以只是名称的小写版本加上<code class="fe mn mo mp mq b">_string.go</code>。</p><p id="75cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令并不总是有效。我的代码有些问题。它有助于将枚举放在一个单独的文件中，并显式指定该文件名。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="371b" class="mw mx it mq b gy ny nz l oa ob">❯ stringer -type=ExitCode<br/>stringer: internal error: package "bytes" without types was imported from "github.com/ordovician/mainframe"<br/><br/># Fix error by specifying source code file directly<br/>❯ stringer -type=ExitCode exitcode.go</span></pre><p id="7602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为每种枚举类型调用<a class="ae ky" href="https://pkg.go.dev/golang.org/x/tools/cmd/stringer" rel="noopener ugc nofollow" target="_blank"> stringer </a>可能会让人难以理解。我们当然可以制作类似于<code class="fe mn mo mp mq b">Makefile</code>的东西，但是Go的哲学是尽量避免使用复杂的构建脚本。Go解决方案是使用<code class="fe mn mo mp mq b">go generate</code>命令行工具。您将想要运行的命令放在源代码文件中。这就是为什么您会看到我们的枚举定义以:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="206c" class="mw mx it mq b gy ny nz l oa ob">//go:generate stringer -type=ExitCode<br/>type ExitCode int</span></pre><p id="5810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go惯例是以<code class="fe mn mo mp mq b">go:</code>和<code class="fe mn mo mp mq b">json:</code>开头的注释可以被各种Go工具读取。您可以通过JSON封送和解封看到这一点。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="4157" class="mw mx it mq b gy ny nz l oa ob">type User struct {<br/>    Name string `json:"full_name"`<br/>    Age int `json:"age,omitempty"`<br/>    Active bool `json:"-"`<br/>    lastLoginAt string<br/>}</span></pre><p id="926e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从命令行运行<code class="fe mn mo mp mq b">go generate</code>，它将访问所有Go源代码文件并运行<code class="fe mn mo mp mq b">//go:generate</code>之后的命令。这样，我们可以在代码受到影响的情况下继续构建指令，并避免复杂的构建系统与要构建的源代码脱节。您可以将一个单独的源代码文件移动到另一个项目中，它将携带如何构建它需要的相关工件的指令。</p><h2 id="9559" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">使用非整数枚举</h2><p id="4037" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">你的枚举不一定是数字。他们可以是任何东西。这里我用的是绳子。当它们表示来自用户或文件的字符串输入时，这是很有用的。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="2934" class="mw mx it mq b gy ny nz l oa ob">type Encoding string<br/><br/>const (<br/>	PEM    Encoding = "pem"<br/>	Hex    Encoding = "hex"<br/>	Base32 Encoding = "base32"<br/>	Base64 Encoding = "base64"<br/>)</span></pre><p id="9d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您将需要验证您所读取的内容是否在有效范围内。</p><h2 id="d17b" class="mw mx it bd my mz na dn nb nc nd dp ne li nf ng nh lm ni nj nk lq nl nm nn no bi translated">在Go二进制文件中嵌入数据文件</h2><p id="0b8b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">要制作自包含的二进制文件，您可以轻松地四处移动，将数据与它们捆绑在一起是很有用的。这通常意味着将它硬编码到源代码中，但这可能会变得混乱、丑陋和不切实际。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="c1d9" class="mw mx it mq b gy ny nz l oa ob">import "embed"<br/><br/>//go:embed data<br/>var storage embed.FS</span></pre><p id="ffc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码允许我从我的包源代码中的一个目录读取文件，如下所示:</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="9bf5" class="mw mx it mq b gy ny nz l oa ob">data/<br/>├── agents.aes<br/>└── launchcodes.txt</span></pre><p id="6a39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe mn mo mp mq b">storage</code>变量来访问嵌入的数据，就像访问普通文件一样。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="4acc" class="mw mx it mq b gy ny nz l oa ob">file, _ := storage.Open("data/launchcodes.txt")<br/>text, _ := io.ReadAll(file)</span></pre><p id="dfe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以字符串形式嵌入文件的文件中，我们需要改变导入<code class="fe mn mo mp mq b">embeded</code>的方式，因为如果代码中没有引用导入的包，Go编译器会抱怨。它在注释字段中被引用不会被编译器发现。</p><pre class="kj kk kl km gt nu mq nv nw aw nx bi"><span id="02c2" class="mw mx it mq b gy ny nz l oa ob">import _ "embed"<br/><br/>//go:embed key.txt<br/>var cryptKey string</span></pre><p id="13fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">破折号<code class="fe mn mo mp mq b">_</code>只是让Go编译器闭嘴的一种方式。</p><h1 id="87f2" class="oc mx it bd my od oe of nb og oh oi ne jz oj ka nh kc ok kd nk kf ol kg nn om bi translated">摘要</h1><p id="9144" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了便于参考，让我以更简洁的形式总结一下我在这里介绍的内容:</p><ul class=""><li id="bd95" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">将<code class="fe mn mo mp mq b">GOPATH</code>设置为<code class="fe mn mo mp mq b">~/.go</code>，为已安装的第三方包和工具保留一个隐藏目录</li><li id="cb8f" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">保持你自己的项目在说<code class="fe mn mo mp mq b">~/Dev/go</code></li><li id="3855" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated">在你的<code class="fe mn mo mp mq b">PATH</code>中包含<code class="fe mn mo mp mq b">$GOPATH/bin</code>，这样Go命令行工具就可以轻松运行。</li><li id="6a17" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">go mod init github.com/user/package</code> -初始化Go模块</li><li id="aac6" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">go mod tidy</code> -根据源代码使用的包添加和删除依赖项</li><li id="8ecb" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">go build github.com/user/package/subpackage</code> -建立一个包或者<code class="fe mn mo mp mq b">go build ./subpackage</code></li><li id="d07e" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">go test -v -run TestFoobar ./subpackage</code> -运行子包<code class="fe mn mo mp mq b">subpackage</code>中编写的特定测试<code class="fe mn mo mp mq b">TestFoobar</code></li><li id="99fd" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">go install github.com/user/tool@latest</code> -安装用Go编写的工具或命令</li><li id="efac" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">io.Discard</code> -丢弃丢弃写入writer对象的数据。禁用记录器时很有用。</li><li id="cc18" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">//go:generate stringer -type=EnumName</code> -使enum实现<code class="fe mn mo mp mq b">Stringer</code>接口</li><li id="c6d2" class="me mf it lb b lc mr lf ms li mt lm mu lq mv lu mj mk ml mm bi translated"><code class="fe mn mo mp mq b">//go:embed fileOrDir</code> -在二进制文件中嵌入文件或整个目录</li></ul><p id="bfb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一次，我可能会尝试涵盖Go泛型中容易忘记或混淆的部分。许多人都知道这些特性，但是需要一个快速的提醒。</p></div></div>    
</body>
</html>