<html>
<head>
<title>Building An End-to-end Application with LoopBack &amp; React.js — Part 3: Pagination in GitHub API Results</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用LoopBack &amp; React.js构建端到端应用程序—第3部分:GitHub API结果中的分页</h1>
<blockquote>原文：<a href="https://itnext.io/building-an-end-to-end-application-with-loopback-react-js-90cfd7a4813c?source=collection_archive---------5-----------------------#2021-06-29">https://itnext.io/building-an-end-to-end-application-with-loopback-react-js-90cfd7a4813c?source=collection_archive---------5-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c0d3f1eba9559532ba53227e8b143c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uS-hYcT-8wFc_vui5KZQ8A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kaunglay1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">昂素敏</a>在<a class="ae kc" href="https://unsplash.com/s/photos/pages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://mobilediana.medium.com/building-an-end-to-end-application-with-loopback-react-js-part-2-creating-service-proxy-7ffac2bd7980" rel="noopener">在之前的</a>中，我们在一个回送应用程序中创建了连接到GitHub APIs的服务代理。默认情况下，结果每页包含30个项目。我们可以增加这个数字，但最多只能增加到100。在本文中，我将向您展示如何遍历页面以获取我们需要的所有项目。</p><p id="e152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想看看完成后的应用程序是什么样子，你可以点击<a class="ae kc" href="https://github.com/dhmlau/loopback4-example-github" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="9640" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">关于GitHub API分页的基本知识</strong></h1><p id="7f23" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在我们开始之前，让我们看看GitHub API中分页是如何工作的。</p><p id="6edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据这个关于GitHub API分页的文档<a class="ae kc" href="https://docs.github.com/en/rest/guides/traversing-with-pagination" rel="noopener ugc nofollow" target="_blank">https://docs . GitHub . com/en/rest/guides/traversing-with-pagination</a>，分页信息在<code class="fe ml mm mn mo b">Link</code>头中。例如</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="14f6" class="mx lj iq mo b gy my mz l na nb">Link: &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=2&gt;; rel="next",<br/>  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel="last"</span></pre><p id="ca81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，如果一个<code class="fe ml mm mn mo b">Link</code>头存在，我们可以使用<code class="fe ml mm mn mo b">rel="next"</code>的url作为下一个API调用来获得下一组结果。为了获得所有结果，我们将继续检查响应上的<code class="fe ml mm mn mo b">Link</code>头，直到不再有“next”链接。</p><h1 id="4dcd" class="li lj iq bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated">回顾一下我们为数据源创建的内容</h1><p id="3d3e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在回顾我们之前创建的<a class="ae kc" href="https://github.com/dhmlau/loopback4-example-github/blob/main/src/datasources/githubds.datasource.ts" rel="noopener ugc nofollow" target="_blank">数据源</a>时，有两点需要注意:</p><ul class=""><li id="6298" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><code class="fe ml mm mn mo b">fullResponse:true</code>:这是必需的，因为分页信息在响应头中</li><li id="f4be" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe ml mm mn mo b">getIssuesByURL</code>函数:由于下一组结果的API端点已经可用，如果我们有这个额外的函数，可能会更容易。</li></ul><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="56c8" class="li lj iq bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated">在GHQueryController中添加新函数</h1><p id="1945" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们将在<code class="fe ml mm mn mo b">GHQueryController</code>中做一些改变，这样我们就可以继续评估<code class="fe ml mm mn mo b">Link</code>头以获得下一页结果。</p><p id="9f96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将创建以下3个函数:</p><ul class=""><li id="90cd" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">这实际上与分页无关，而是整理我们之前创建的代码，因为这会在多个地方被调用。</li><li id="c4a1" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe ml mm mn mo b">getNextLink</code>:这个新函数检查<code class="fe ml mm mn mo b">Link</code>头并找到与<code class="fe ml mm mn mo b">rel="next"</code>相关的url。当我们到达最后一页时，这个函数返回null。</li><li id="1903" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe ml mm mn mo b">getIssueByURL</code>:这个函数映射到我们之前创建的服务代理。在我们获得“下一个”链接后，这个函数将被调用以获得更多的结果。</li></ul><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="a559" class="li lj iq bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated">把东西放在一起</h1><p id="f0fa" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在我们已经准备好了一切，让我们对<code class="fe ml mm mn mo b">getIssuesByLabel</code>函数进行更多的修改，以利用我们在上一节中创建的函数。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="d5af" class="mx lj iq mo b gy my mz l na nb"><br/>  <a class="ae kc" href="http://twitter.com/get" rel="noopener ugc nofollow" target="_blank">@get</a>('/issues/repo/{repo}/label/{label}')<br/>  async getIssuesByLabel(<br/>    <a class="ae kc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a>.path.string('repo') repo: string,<br/>    <a class="ae kc" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a>.path.string('label') label:string): Promise&lt;QueryResult&gt; {<br/>    let result:QueryResponse = await this.queryService.getIssuesByLabel(repo, label);<br/>    let queryResult = new QueryResult();<br/>    queryResult.items = [];<br/>    queryResult.total_count = result.body.total_count;<br/>    result.body.items.forEach(issue =&gt; {<br/>      this.addToResult(issue, queryResult);<br/>    });</span><span id="cf99" class="mx lj iq mo b gy nx mz l na nb">// check if there is next page of the results<br/>    const nextLink = this.getNextLink(result.headers.link);<br/>    if (nextLink == null) return queryResult;<br/>    await this.getIssueByURL(nextLink, this.queryService, queryResult);<br/>    return queryResult;<br/>  }</span></pre><p id="2706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以找到完整的控制器:<a class="ae kc" href="https://github.com/dhmlau/loopback4-example-github/blob/main/src/controllers/gh-query.controller.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/dhmlau/loopback 4-example-github/blob/main/src/controllers/GH-query . controller . ts</a>。</p><h1 id="22b5" class="li lj iq bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated">让我们来测试一下！</h1><p id="acd1" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在，如果我们用相同的值调用端点(就像我下面的这个)，你会得到和以前相似的结果，只是如果<code class="fe ml mm mn mo b">total_count</code>大于30，你在结果中得到的<code class="fe ml mm mn mo b">items</code>大小将和<code class="fe ml mm mn mo b">total_count</code>相同。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/c1776de942ad8f16271d3a9e4a87f5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olVjpstVv9WU-fSIqbko0A.png"/></div></div></figure><h1 id="0754" class="li lj iq bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated">结论</h1><p id="ddbf" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">到目前为止，我们已经创建了一个REST API，它将GitHub org+repo名称和标签作为路径参数，并返回一个符合标准的问题(和拉请求)列表。在本文中，我们遍历结果页面来获取所有项目，而不是前30个项目。</p><p id="ad49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个API有点原始，但我认为它是构建一个与该API对话的前端应用程序的良好起点。我们总能不断改进应用程序。</p><h1 id="9130" class="li lj iq bd lk ll nc ln lo lp nd lr ls lt ne lv lw lx nf lz ma mb ng md me mf bi translated">参考</h1><p id="1f5d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">本博客系列之前的文章:</p><ul class=""><li id="ee34" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated">第1部分—为GitHub API创建数据源:<a class="ae kc" href="https://mobilediana.medium.com/building-an-end-to-end-application-with-loopback-react-js-7a22d726c35d" rel="noopener">https://mobilediana . medium . com/building-an-end-to-end-application-with-loopback-react-js-7a 22d 726 c35d</a></li><li id="f573" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated">第二部分—创建服务代理:<a class="ae kc" href="https://mobilediana.medium.com/building-an-end-to-end-application-with-loopback-react-js-part-2-creating-service-proxy-7ffac2bd7980" rel="noopener">https://mobilediana . medium . com/building-an-end-to-end-application-with-loopback-react-js-part-2-Creating-Service-Proxy-7 ffac 2 BD 7980</a></li></ul></div></div>    
</body>
</html>