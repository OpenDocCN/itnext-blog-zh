# C++脚本替代方案:易于绑定的 C++脚本

> 原文：<https://itnext.io/c-scripting-alternatives-easy-to-bind-scripting-binding-chaiscript-and-wren-into-a-small-game-174c86b0ecd7?source=collection_archive---------0----------------------->

# 将 ChaiScript 和 Wren 绑定到一个小游戏中

![](img/a3247350dd7161e1cb3b8343694bcac9.png)

[卡斯帕鲁宾](https://unsplash.com/@casparrubin)在 [Unsplash](https://unsplash.com/) 上的照片

大家好，

由于我一直在尝试一些脚本语言来编写一个小游戏，并积累了一些经验，我想在这里分享我的经验，希望有人可以找到有用的。

本文关注的是相对容易与 C++绑定的脚本 API，无论是本地绑定还是与助手库绑定。

为了编写一个小型纸牌游戏的脚本，我尝试并测试了将 c++ API 暴露给外语。

## 为什么要编写脚本？

对于不熟悉脚本的人:脚本通常用于加速你自己程序的开发。

这可能非常有效，因为除了消除(显式)编译步骤之外，您还可以用一种更简单易用的语言对其中的逻辑进行编码。

记住这一点，通过消除编译步骤，脚本可以大大加快编辑-编译-调试的迭代。想想你对代码所做的任何改变+重新编译，但是去掉了编译步骤。事情变得几乎是瞬间的。

# 游戏

该游戏是一个联网的 4 人游戏，其中每个玩家轮流玩他们手中的一张牌，并且牌一直玩到该副牌被完全用完。

这是一种叫做[guinote](https://es.wikipedia.org/wiki/Gui%C3%B1ote)的游戏，在西班牙的一些地区很流行。它有许多变体，如 Brisca、Tute 等，尽管这对于我将在文章中解释的内容并不十分重要。

这篇文章的目的是分享我绑定 C++ API 并将其公开到脚本语言中的经验。

免责声明:请记住，我不是绑定 API 方面的专家，因此我可能会忽略一些知识。

# 关于引擎架构的相关要点(用于绑定目的)

游戏由一个加载屏幕的控制器组成。**每个屏幕由一个控制屏幕逻辑的脚本**代表。

该脚本使用游戏视图和游戏模型，除了一些网络 API(通过 [Capnproto](https://capnproto.org/) 编写)，如果我有实力写一篇关于它的文章，请继续关注！)

游戏的 C++端通过一个控制器进入一个屏幕，在那个时候，它加载屏幕并把控制权交给脚本引擎。

虚拟机是在加载屏幕之前创建的，从那里开始，脚本负责处理。

脚本完成后，会返回几个字符串:

1.  要加载的下一个屏幕
2.  下一个屏幕的参数(相当于 C++中 main 中的 argv)

控制在返回后返回到 C++端。为了使脚本正常工作，一些额外的数据通过环境作为全局数据公开:基本上是运行时配置和记录器，它们对脚本引擎是可用的。

当一个屏幕结束时，虚拟机被销毁。这样，在屏幕运行之间没有状态保持活动。这也使我的调试更容易，等等。

基本上，我想加速我的屏幕代码逻辑编写。

从脚本的角度来看，这意味着:

1.  能够在运行时从文件中加载脚本(开发时)
2.  能够从内存中加载脚本(在最终的二进制文件中嵌入代码时)
3.  能够向脚本主函数传递参数。
4.  除了使用之外，C++类型必须在脚本端被构造/销毁
5.  C++端已经存在的全局数据必须暴露给脚本环境。

可以把这些脚本中的一个想象成一个程序，它本身可以获得输入参数，并且有一些环境(例如，log、config)。它就像 C++、Java、C#等中的 main。它执行一些操作，然后将信息返回给控制器，以便控制器知道下一步要加载哪个屏幕。

# 候选人脚本

我想选择一种尽可能满足以下要求的脚本语言:

1.  **易绑定 C++** 。我不想一直反对集成，也不想浪费大量时间来纠正它。这大概是最重要的一点。
2.  **对轻量级并发的支持**是一个非常大的优势，几乎和绑定的便利性一样重要。
3.  它**不可能是 Python** ，因为根据我的信息，它可能**很难移植到 Web Assembly** 上，所以我直接丢弃了它。
4.  熟悉:与标准实践相比，它不应该看起来太怪异:像 javascript-ey、C-like 或 pythonic 这样的东西是可以的。除了语法，语义也不应该奇怪。
5.  比起静态类型，我更喜欢动态类型，因为静态类型会降低编码速度:当类型和重构变得更加严格时，它会让你考虑类型。
6.  从一个公开的 C++函数中绑定语言回调是一个很好的优势。如果它能开箱即用，那太好了。否则，这应该很容易实现。
7.  性能不重要。我不需要它。

## 考虑的语言

*   [卢阿](https://www.lua.org/) + [索尔 2](https://github.com/ThePhD/sol2) 。因为 3 它被丢弃了。它有不熟悉的语法，但更糟糕的是，不熟悉的语义:没有类，使用表，从 1 开始索引和其他奇怪的东西，就像能够用错误数量的参数调用函数并在途中返回 nil。此外，对哈希表和数组都使用表。它很强大，不要误解我，Lua 支持很好的并发性。因为上面提到的事情，这不是我想要的。
*   [松鼠](http://www.squirrel-lang.org/)。语言看起来真的很好。但因为 1 而被丢弃。支持更好绑定的项目看起来并不完整。它支持良好的并发性，看起来很像 C++/Lua 的混合体。但是更接近 C++(基于类)
*   [天使脚本](https://www.angelcode.com/angelscript/)。这个是静态类型的，但是我真的想不出如何在不打扰的情况下绑定它。
*   [楷书](https://chaiscript.com/)。从所有的列表中，这是唯一一个被设计成与 C++绑定的。这降低了创建绑定的障碍。在这方面，它提供了，尽管有非常好的 C++绑定到最初的纯 C 脚本语言，接近 ChaiScript。我会说，它是一种 javascript 风格的脚本语言，但是有自己的东西。不好的一面是…继续读。
*   [鹪鹩](https://wren.io/) + [鹪鹩 17](https://github.com/matusnovak/wrenbind17) 。在所有的列表中，我认为这个和 Squirrel 在脚本方面最接近我的理想，因为它们都支持良好的并发性，而且看起来非常自然，用起来也不奇怪。此外，Wren 文档不是很大，但相当不错，IMHO。我可以很容易地找到脚本语言支持的 API，并理解特性是如何工作的。感谢 wrenbind17，它让我尝试绑定 C++变得可行。没有它，这是不可能的。

在这个列表中，我最终选择了 ChaiScript，因为它很容易绑定。

# 功能概述

## 柴书

Chaiscript 具有(大致)以下特性:

*   正如广告宣传的那样，开箱即可轻松装订。只要您告诉 ChaiScript 这种关系，ChaiScript 将足够智能，知道您何时实例化某个基类的派生类，甚至知道如何调用仅派生的方法。基本的 API 就是调用*chai . add(fun | const _ var | base _ cass…)。如果你调用一个和你的类一样的函数，它就变成了一个构造函数。只要不想克隆东西，就不需要注册复制构造函数。也可以使用 lambdas 或 free 函数，并注册为类的实例方法，只要签名匹配。*

在 ChaiScript 中公开 C++类型

*   自由函数(类型是可选的，将被选中):

ChaiScript 中的自由函数

*   带防护装置的功能

ChaiScript 中的函数保护

*   与 C++异常处理集成的异常处理:在 ChaiScript 中捕捉 C++异常！甚至你自己的不是从异常中派生的类型也可以被捕获。

ChaiScript 中的异常处理

*   类支持数据和函数，但不支持静态函数(因为有免费的函数！)

ChaiScript 中的类示例。不允许使用静态函数，因为可以使用自由函数。

*   类是非常动态的，不像 Wren。它支持通过*方法 _ 缺失* (a-la-Ruby)动态调度不存在的函数。这个类将获得一些 Json 字符串，并通过 *myjson.varx.vary.varz* 访问它。虽然效率不是很高，但它确实有效，并且说明了不存在的函数的动态对象访问的重要性:

纯 ChaiScript 中的动态 Json 类实现。您可以通过 method_missing 委托来访问 Json 字段

*   可以公开自己的向量类型(std::vector <mytype>实例化)。我想对 Wren 来说也是如此，但我目前还不需要它。</mytype>
*   通过 std::function <>进行函数回调！！老实说，据我所知，这在 C++的脚本绑定中是独一无二的，它只适用于 ChaiScript。这意味着你可以拥有这个:

将 C++中带有 std::function 参数的函数暴露给 ChaiScript 接受 Chaiscript lambdas 和函数

*   语言控制流支持基于范围的 *for* 循环、 *while* 、 *if* 以及类似的 C++中熟悉的东西

## 鹪鹩

Wren 通过栈式协程支持类、静态函数、令人惊讶的控制流和良好的并发性，并有一个清晰的迭代器协议。

它还支持具有易用语法的列表和词典。您可以从 C++端和语言中重载操作符，就像在 ChaiScript 中一样。它支持范围和过滤，转换等。通过序列。我发现它比 ChaiScript 更精致一些。

简单的 Wren 类示例

下面我想重点介绍一下 Wren 和 ChaiScript 之间的区别。

1.  Wren 更像是基于类的，因为你也可以通过变量使用自由函数，但是你有静态函数。据我所知，自由函数是不可能从 C++中暴露出来的。
2.  当你返回一个基类的时候，继承在 Wren 中并不是现成的，尽管这里有一个技巧
3.  在我看来，模块化和如何导入在 Wren 中更好，尽管我不确定它们是否等价。
4.  它支持 arity 重载，但不支持函数守护 a-la ChaiScript。我不确定 ChaiScript 是否支持重载。
5.  Wren **通过光纤支持完整的协程**。
6.  绑定 Wren 的最初方式是通过 C API。它很快(在运行时)等等，但使用起来很糟糕:让绑定对我来说可行的是 [wrenbind17](https://github.com/matusnovak/wrenbind17)
7.  在 Wren 中你不能直接从 C++中使用 *std::function < >* 。这迫使在 C++中使用一些包装类。
8.  公开全局变量(下面脚本中的 Env 是一个全局变量)并不像它应该的那样简单。为了设置一个全局变量，我使用了一个技巧，即发出代码并从纯 Wren 代码中获取一个静态函数集的类，它将公开一个 C++端变量。
9.  在 Wren 中，你只能公开一个构造函数。这通常不是问题。但是，不能公开不可复制类型的构造函数。它会失败。解决方法是创建一个返回*STD::shared _ ptr<your type>*的 C++函数，并在 Wren 中将其公开为静态函数。
10.  异常处理没有像 ChaiScript 中那样集成
11.  Wren 类不是动态的(但是具有更快的查找速度):方法/字段是在加载代码时确定的。

下面是鹪鹩的味道。我认为代码是不言自明的

雷恩游戏菜单屏幕

这就是我如何在 Wren 端公开 C++端状态，即一个类实例。我花了一段时间才找到不使用静态变量的方法。这达到了目的:

通过一个技巧从 C++公开 Wren 中的现有状态

# ChaiScript 和 Wren 中的问题

*   在 Wren 中，你需要一个可复制构造的类型来通过构造函数公开。不过，本文中解释了一个变通方法。
*   在 Wren 中，将状态从 C++暴露给 Wren 并不是显而易见的(本文中也有记录)
*   在 ChaiScript 中，一旦你设置了变量的类型，如果你试图分配一个不同的无关类型，它将抛出。但是第一次可以设置一个未定义的。这将失败:

```
auto vec = []
vec.push_back(MyClass()) // Works
vec[0] = 5 // Failsvar aVar // is_var_undefined() == true
aVar = Mytype() // It works, now aVar has MyType()
aVar = 3 // Fails
```

*   在 ChaiScript 中，带有或不带有全局变量的顶级变量表现不同。例如，在 lambdas 中捕捉时要小心。全球不需要。
*   在 ChaiScript C++中，暴露的变量和在 ChaiScript 中创建的类的行为略有不同。例如:

```
v = CppExposedClass() //Call copy constructor
w = PureChaiClass() // no copy constructor called!v := CppExposedClass() // No copy constructor called, used :=
```

*   在 ChaiScript 中，按值捕获 vs 引用不是太明显。有时它似乎试图复制，有时它不。有时候我最终会做这样的事情:

```
// Uses reference semantics for C++-side classes. In ChaiScript// classes you always avoid the copy constructor
var v := something// These two are equivalent:
var & v = somethingauto & v = something var lmbda = [v]() { ...} // No copy in capture for sure
```

*   在 Wren 中，您可以创建自由函数，但是没有非可变样式的语法 AFAIK，并且您不能直接调用 via():

```
var f = Fn.new {
    ....
}// This fails, you cannot call itf()//Use explicit syntax
f.call()
```

# 开发工作流程

Wren 和 ChaiScript 都做了他们宣传的事情。虽然我发现了一些基本的差异，依我拙见，强烈支持任。

1.  在 ChaiScript 中，如果你得到一个错误，**你得不到**，至少在默认情况下，**错误的位置**。这使得**调试非常困难**，以至于会耗尽你的生产力。
2.  另一方面，从 ChaiScript 公开代码稍微容易一些，并且集成了异常。
3.  在 Wren 中，错误的位置一目了然。
4.  Wren 中的**并发真的很不错**。

# 结论

我认为两者都是有用的工具，但是区别在于 3。和 4 与 1 相比。用楷书。对我来说，这破坏了相当多的经验。

在 ChaiScript 中，很难跟踪代码崩溃的地方，所以我必须用日志消息填充所有部分。在雷恩，我根本不需要它。

此外，ChaiScript 中缺乏并发性使得代码充满了回调，我不得不在不支持协程的情况下在 C++端生成任务。这使得代码流变得不自然、反向和基于回调。我记得，这也产生了一些问题，因为我必须处理回调代码，否则它会崩溃。但是我现在不确定。

在 Wren 中，如果你看到代码清单，你会发现它看起来很自然，很容易理解。该代码对应于游戏菜单屏幕。

假设 ChaiScript 修复了行号错误，如果我打算利用并发性，我仍然会选择 Wren，因为我的情况就是这样。

但是，如果您需要大量带有回调的代码，ChaiScript 可以为您节省一些现成的样板文件，因为它不需要回调包装，它通过 *std::function < >* 完全集成。此外，ChaiScript 支持异常。

总而言之，如果 ChaiScript 修复了行号位置，并且您不打算利用并发性，我可以推荐这两种方法。此外，据我目前所知，如果速度是一个问题，ChaiScript 应该比 Wren 慢得多。

但是考虑到事情的现状和现实情况，我认为 Wren 比 ChaiScript 更适合生产:它比 ChaiScript 更快(如果这是一个问题的话),它使用纯解释而不是字节码，它支持并发性，并显示错误发生的位置。

感谢阅读！