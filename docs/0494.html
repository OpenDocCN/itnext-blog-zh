<html>
<head>
<title>You don’t ( always ) need Jest, Mocha, Chai… for TDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不(总是)需要笑话、摩卡、茶…来进行TDD</h1>
<blockquote>原文：<a href="https://itnext.io/you-dont-always-need-jest-mocha-chai-for-tdd-27e6b2a8c5fb?source=collection_archive---------2-----------------------#2018-03-19">https://itnext.io/you-dont-always-need-jest-mocha-chai-for-tdd-27e6b2a8c5fb?source=collection_archive---------2-----------------------#2018-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4c4263a241f3b4653aa8920235d2f8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKde8ouZNhElfn2apqGUqw.png"/></div></div></figure><blockquote class="jy jz ka"><p id="da9c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fyou-dont-always-need-jest-mocha-chai-for-tdd-27e6b2a8c5fb" rel="noopener ugc nofollow" target="_blank">点击这里在LinkedIn上分享这篇文章</a></p></blockquote><p id="7dd3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果你想成为一名更好的软件开发人员，从编写单元测试开始。他们会给你一个不同的代码视图，大多数时候他们会显示你的代码有外部依赖，如果不嘲笑他们你就无法测试。重构之后，你应该得到单元可测试的纯函数。</p><p id="bcf7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">每当你写一个函数或者方法的时候，问问你自己你是否能为它写测试。如果答案是否定的，那你就做错了。</p><p id="a92e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">你不需要用单元测试覆盖整个应用，因为你不能测试外部依赖，也不需要测试从外部库生成的样板文件。这毫无意义。说到这里，我们只需要关注我们的业务逻辑和为应用程序编写的定制代码。</p><p id="018d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在很多情况下，我们使用Jest或Mocha这样的库。然而，尽管它们非常方便，我们并不总是需要它们。</p><p id="f773" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们可以使用本机断言库表单节点，并遵循一些标准。</p><h1 id="8555" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将您的测试文件放在您的特征文件旁边</h1><p id="212e" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">在本例中，我们将制作一个小脚本，将MongoDB集合模式转换为GraphQL模式。</p><p id="8da8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们的文件夹结构看起来像:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/4996745439ddaba9af129d3f4cd88159.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*olL3nLw1HfuXQ_0zVbR56g.png"/></div></figure><h1 id="6b86" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">编写只做一件事的函数</h1><p id="54da" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">接下来，我们将在convert.js文件中添加几个函数，第一个函数接受MongoDB find()函数的结果，并返回所有不同的键及其类型。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fae9" class="mr lf iq mn b gy ms mt l mu mv"><strong class="mn ir">function </strong><em class="kd">filterOutDistinctKeys</em>(data) {<br/><br/>    <strong class="mn ir">const </strong>items = data || [];<br/>    <strong class="mn ir">const </strong>distinctItems = [];<br/><br/>    <strong class="mn ir">for </strong>(<strong class="mn ir">const </strong>item <strong class="mn ir">of </strong>items) {<br/><br/>        <strong class="mn ir">for </strong>(<strong class="mn ir">const </strong>key <strong class="mn ir">of <em class="kd">Object</em></strong>.keys(item)) {<br/><br/>            <strong class="mn ir">const </strong>dataKey = <em class="kd">toCamelCase</em>(key);<br/>            <strong class="mn ir">const </strong>dataType = <em class="kd">capitilize</em>(<strong class="mn ir">typeof </strong>item[key]);<br/><br/>            <strong class="mn ir">if </strong>(distinctItems.findIndex((item) =&gt; item.<strong class="mn ir">dataKey </strong>=== dataKey) &lt; 0) {<br/>                distinctItems.push({ dataKey, dataType });<br/>            }<br/>        }<br/>    }<br/><br/>    <strong class="mn ir">return </strong>distinctItems;<br/>}</span></pre><p id="38e5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们要添加的第二、第三和第四个函数更简单。他们的名字暗示了他们的目的。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a2fc" class="mr lf iq mn b gy ms mt l mu mv"><strong class="mn ir">function </strong><em class="kd">capitilize</em>(name) {<br/>    <strong class="mn ir">return </strong>name[0].toUpperCase() + name.slice(1).toLowerCase();<br/>}</span><span id="e797" class="mr lf iq mn b gy mw mt l mu mv"><strong class="mn ir">function </strong><em class="kd">toCamelCase</em>(name) {<br/>    <strong class="mn ir">const </strong>fragmented = name.split(<strong class="mn ir">' '</strong>);<br/><br/>    <strong class="mn ir">if </strong>(fragmented.length === 1) {<br/>        <strong class="mn ir">return </strong><em class="kd">fistSmallLetter</em>(name);<br/>    }<br/><br/>    <strong class="mn ir">const </strong>uppercase = fragmented.map((piece) =&gt; <em class="kd">capitilize</em>(piece));<br/>    uppercase[0] = uppercase[0].toLowerCase();<br/><br/>    <strong class="mn ir">return </strong>uppercase.join(<strong class="mn ir">''</strong>);<br/>}</span><span id="2a91" class="mr lf iq mn b gy mw mt l mu mv"><strong class="mn ir">function </strong><em class="kd">fistSmallLetter</em>(name) {<br/>    <strong class="mn ir">return </strong>name[0].toLowerCase() + name.slice(1);<br/>}</span></pre><p id="f329" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">一旦我们有了合适的函数，正如你所看到的，它们有干净的输入和干净的输出，我们可以在convert.spec.js文件中添加一些测试来测试它们的功能。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d6e3" class="mr lf iq mn b gy ms mt l mu mv"><strong class="mn ir">const convert </strong>= <em class="kd">require</em>(<strong class="mn ir">'./convert'</strong>);<br/><strong class="mn ir">const </strong><em class="kd">assert </em>= <em class="kd">require</em>(<strong class="mn ir">'assert'</strong>);<br/><br/>(<strong class="mn ir">function </strong>testCapitilize() {<br/><br/>    <strong class="mn ir">const </strong>name = <strong class="mn ir">convert</strong>.<em class="kd">capitilize</em>(<strong class="mn ir">'Jobs'</strong>);<br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'Jobs'</strong>, name);<br/><br/>})();<br/><br/>(<strong class="mn ir">function </strong>testDistinct() {<br/><br/>    <strong class="mn ir">const </strong>mockData = [{<br/>        <strong class="mn ir">'Name'</strong>: <strong class="mn ir">'John'</strong>,<br/>        <strong class="mn ir">'Age'</strong>: 22,<br/>        <strong class="mn ir">'Married'</strong>: <strong class="mn ir">true<br/>    </strong>}, {<br/>        <strong class="mn ir">'Name'</strong>: <strong class="mn ir">'Alan'</strong>,<br/>        <strong class="mn ir">'Age'</strong>: 21,<br/>        <strong class="mn ir">'Married'</strong>: <strong class="mn ir">false<br/>    </strong>}];<br/><br/>    <strong class="mn ir">const </strong>distinct = <strong class="mn ir">convert</strong>.<em class="kd">filterOutDistinctKeys</em>(mockData);<br/><br/>    <em class="kd">assert</em>.equal(3, distinct.<strong class="mn ir">length</strong>);<br/>    <em class="kd">assert</em>.deepEqual({ <strong class="mn ir">dataKey</strong>: <strong class="mn ir">'name'</strong>, <strong class="mn ir">dataType</strong>: <strong class="mn ir">'String'</strong>}, distinct[0]);<br/><br/>    <strong class="mn ir">const </strong>emptyCollection = <strong class="mn ir">convert</strong>.<em class="kd">filterOutDistinctKeys</em>([]);<br/>    <em class="kd">assert</em>.equal(0, emptyCollection.<strong class="mn ir">length</strong>);<br/>})();<br/><br/>(<strong class="mn ir">function </strong>testFistSmallLetter() {<br/><br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'myName'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">fistSmallLetter</em>(<strong class="mn ir">'MyName'</strong>));<br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'myname'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">fistSmallLetter</em>(<strong class="mn ir">'myname'</strong>));<br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'tEST'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">fistSmallLetter</em>(<strong class="mn ir">'TEST'</strong>));<br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'two Words'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">fistSmallLetter</em>(<strong class="mn ir">'Two Words'</strong>));<br/>})();<br/><br/>(<strong class="mn ir">function </strong>testToCamelCase() {<br/><br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'myName'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">toCamelCase</em>(<strong class="mn ir">'MyName'</strong>));<br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'twoWords'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">toCamelCase</em>(<strong class="mn ir">'Two Words'</strong>));<br/>    <em class="kd">assert</em>.equal(<strong class="mn ir">'threeDistinctWords'</strong>, <strong class="mn ir">convert</strong>.<em class="kd">toCamelCase</em>(<strong class="mn ir">'Three Distinct Words'</strong>));<br/>})();</span></pre><p id="96c7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">注意，我们使用本地节点断言库来检查函数的结果，并且我们用前缀test和我们将要测试的函数名来命名我们的测试函数。</p><p id="6d0b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">接下来，让我们在package.json中注册我们的测试脚本，并使用<strong class="ke ir"> npm运行测试</strong>来运行它</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="156d" class="mr lf iq mn b gy ms mt l mu mv"><strong class="mn ir">"scripts"</strong>: {<br/>  <strong class="mn ir">"test"</strong>: <strong class="mn ir">"node ./src/**/*.spec.js"<br/></strong>},</span></pre><p id="98ae" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果一切正常，我们的脚本将返回<strong class="ke ir">退出代码0 </strong>，这意味着所有测试都已通过。</p><p id="3cef" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在我们可以将我们的库附加到CI系统。</p></div></div>    
</body>
</html>