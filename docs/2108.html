<html>
<head>
<title>How to create React custom hooks for data fetching with useEffect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用useEffect为数据提取创建React自定义挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-create-react-custom-hooks-for-data-fetching-with-useeffect-74c5dc47000a?source=collection_archive---------1-----------------------#2019-04-02">https://itnext.io/how-to-create-react-custom-hooks-for-data-fetching-with-useeffect-74c5dc47000a?source=collection_archive---------1-----------------------#2019-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f447" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">react-hooks-async库简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/01291bcb7c4d890f77edf9df09395ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rc43vbLqRTPJrnW8AeMymQ.png"/></div></div></figure><h2 id="fa9b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">背景</h2><p id="1e14" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">React 16.8增加了一个新的API，Hooks。如果你还没有学会钩子，在继续这篇文章之前，去官方网站阅读整个文档。</p><div class="mj mk gp gr ml mm"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">介绍钩子-反应</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">reactjs.org</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="bf8b" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">这篇文章是关于如何为数据获取创建定制钩子的。如<a class="ae ng" href="https://reactjs.org/blog/2018/11/27/react-16-roadmap.html" rel="noopener ugc nofollow" target="_blank">路线图</a>中所述，React正计划在不久的将来发布react-cache和暂挂以获取数据。这将成为React中数据获取的标准方式，然而，在某些获取数据的生命周期与组件生命周期相同的用例中，使用useEffect获取数据仍然很有用。在这种用例中，缓存并不重要，我们可以安全地将获取的数据存储在组件本地状态中。</p><p id="faa6" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">这篇文章描述了一个用于数据获取的自定义钩子的简单实现，它的局限性，一个关于可移植异步函数的API建议和为API实现的库。</p><h2 id="e055" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">一个天真的定制钩子</h2><p id="464e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">如果你对React钩子有很好的理解，下面这样的实现很容易实现。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="08c1" class="ku kv it ni b gy nm nn l no np">const useFetch = (url) =&gt; {<br/>  const [data, setData] = useState(null);<br/>  useEffect(() =&gt; {<br/>    (async () =&gt; {<br/>      const res = await fetch(url);<br/>      const data = await res.json();<br/>      setData(data);<br/>    })();<br/>  }, [url]);<br/>  return data;<br/>};</span></pre><p id="f1e5" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">注意，为了简单起见，这段代码中省略了错误处理和加载状态。</p><p id="2fa6" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">带有这个钩子的数据只存在于组件状态中，并且在组件被卸载时被丢弃。为了避免为卸载的组件设置状态，通常会引入一个如下所示的标志。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="172b" class="ku kv it ni b gy nm nn l no np">const useFetch = (url) =&gt; {<br/>  const [data, setData] = useState(null);<br/>  useEffect(() =&gt; {<br/>    let mounted = true;<br/>    (async () =&gt; {<br/>      const res = await fetch(url);<br/>      const data = await res.json();<br/>      if (mounted) setData(data);<br/>    })();<br/>    const cleanup = () =&gt; { mounted = false; };<br/>    return cleanup;<br/>  }, [url]);<br/>  return data;<br/>};</span></pre><p id="40be" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">这确实有效，但实际上并没有停止数据获取。如果我们真的能在浏览器中停止取数据就更好了。<a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank"> AbortController </a>启用它，代码如下。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4a31" class="ku kv it ni b gy nm nn l no np">const useFetch = (url) =&gt; {<br/>  const [data, setData] = useState(null);<br/>  useEffect(() =&gt; {<br/>    let mounted = true;<br/>    const abortController = new AbortController();<br/>    (async () =&gt; {<br/>      const res = await fetch(url, {<br/>        signal: abortController.signal,<br/>      });<br/>      const data = await res.json();<br/>      if (mounted) setData(data);<br/>    })();<br/>    const cleanup = () =&gt; {<br/>       mounted = false;<br/>       abortController.abort();<br/>    };<br/>    return cleanup;<br/>  }, [url]);<br/>  return data;<br/>};</span></pre><h2 id="a73a" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">可移植异步函数的通用API</h2><p id="6055" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">让我们概括一下，让AbortController支持任何异步函数。我们定义了一个API，它是一个在第一个参数中接收AbortController实例并返回一个承诺的函数。</p><p id="0ccd" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">使用这个API，fetch的实现如下:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ab39" class="ku kv it ni b gy nm nn l no np">// this is pseudo code<br/>const abortableFetch = (url) =&gt; async (abortController) =&gt; {<br/>  const res = await fetch(url, { signal: abortController.signal });<br/>  const data = await res.json();<br/>  return data;<br/>};</span></pre><p id="0ada" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">类似地，<a class="ae ng" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>有一个不同的取消机制，可以这样实现:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b588" class="ku kv it ni b gy nm nn l no np">// this is pseudo code<br/>const abortableAxios = (url) =&gt; async (abortController) =&gt; {<br/>  const source = axios.CancelToken.source();<br/>  abortController.signal.addEventListener('abort', () =&gt; {<br/>    source.cancel('canceled');<br/>  );<br/>  const { data } = await axios({ url, cancelToken: source.token });<br/>  return data;<br/>};</span></pre><h2 id="66ae" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><em class="nq">可移植异步函数的定制钩子</em></h2><p id="d400" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">我们现在用这个API创建自定义挂钩。有两个钩子；一个被称为<code class="fe nr ns nt ni b">useAsyncTask</code>以准备一个准备启动的异步函数，另一个被称为<code class="fe nr ns nt ni b">useAsyncRun</code>以实际启动它。由<code class="fe nr ns nt ni b">useAsyncTask</code>返回的对象<code class="fe nr ns nt ni b">task</code>包含异步函数的状态以及启动和中止它的方法。</p><h2 id="51fb" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">useAsyncTask挂钩</h2><p id="691d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">现在，我们实现第一个钩子。除了异步函数的结果，我们还处理挂起状态和错误。</p><p id="b787" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">最初的<code class="fe nr ns nt ni b">task</code>定义如下。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c258" class="ku kv it ni b gy nm nn l no np">const initialTask = {<br/>  started: false, // if this async function is started<br/>  pending: true,  // if this async function is not finished<br/>  error: null,    // error of this async function<br/>  result: null,   // result of this async function<br/>  start: null,    // a method to start this async function<br/>  abort: null,    // a method to abort this async function<br/>};</span></pre><p id="f94d" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">我们使用术语<code class="fe nr ns nt ni b">pending</code>和<code class="fe nr ns nt ni b">result</code>而不是<code class="fe nr ns nt ni b">loading</code>和<code class="fe nr ns nt ni b">data</code>，因为<code class="fe nr ns nt ni b">task</code>不仅用于数据获取。</p><p id="3516" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">与用于<code class="fe nr ns nt ni b">task</code>的useReducer一起使用的减速器定义如下。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="784e" class="ku kv it ni b gy nm nn l no np">const reducer = (task, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'init':<br/>      return initialTask;<br/>    case 'ready':<br/>      return {<br/>        ...task,<br/>        start: action.start,<br/>        abort: action.abort,<br/>      };<br/>    case 'start':<br/>      return {<br/>        ...task,<br/>        started: true,<br/>      };<br/>    case 'result':<br/>      return {<br/>        ...task,<br/>        pending: false,<br/>        result: action.result,<br/>      };<br/>    case 'error':<br/>      return {<br/>        ...task,<br/>        pending: false,<br/>        error: action.error,<br/>      };<br/>    default:<br/>      throw new Error(`unexpected action type: ${action.type}`);<br/>  }<br/>};</span></pre><p id="a070" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">有了以上这些，我们的定制钩子就实现了。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4ecb" class="ku kv it ni b gy nm nn l no np">const useAsyncTask = (func, deps) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, initialTask);<br/>  useEffect(() =&gt; {<br/>    let dispatchSafe = action =&gt; dispatch(action);<br/>    let abortController = null;<br/>    const start = async () =&gt; {<br/>      if (abortController) return;<br/>      abortController = new AbortController();<br/>      dispatchSafe({ type: 'start' });<br/>      try {<br/>        const result = await func(abortController);<br/>        dispatchSafe({ type: 'result', result });<br/>      } catch (e) {<br/>        dispatchSafe({ type: 'error', error: e });<br/>      }<br/>    };<br/>    const abort = () =&gt; {<br/>      if (abortController) {<br/>        abortController.abort();<br/>      }<br/>    };<br/>    dispatch({ type: 'ready', start, abort });<br/>    const cleanup = () =&gt; {<br/>      dispatchSafe = () =&gt; null; // avoid to dispatch after stopped<br/>      dispatch({ type: 'init' });<br/>    };<br/>    return cleanup;<br/>  }, deps);<br/>  return state;<br/>};</span></pre><p id="b489" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">在这个实现中，我们简单地接收<code class="fe nr ns nt ni b">deps</code>作为第二个参数，并将其传递给useEffect。这是一个避免使用<a class="ae ng" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> useMemo </a>的设计选择，对于语义保证不推荐使用。</p><h2 id="3c19" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">useAsyncRun挂钩</h2><p id="9f57" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">第二个钩子相对容易实现。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5621" class="ku kv it ni b gy nm nn l no np">const useAsyncRun = (asyncTask) =&gt; {<br/>  const start = asyncTask &amp;&amp; asyncTask.start;<br/>  const abort = asyncTask &amp;&amp; asyncTask.abort;<br/>  useEffect(() =&gt; {<br/>    if (start) start();<br/>    const cleanup = () =&gt; {<br/>      if (abort) abort();<br/>    };<br/>    return cleanup;<br/>  }, [start]);<br/>};</span></pre><p id="1367" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">这个钩子不是必须使用的。您可以在事件回调中调用task对象中的start和abort方法。参考:<a class="ae ng" href="https://github.com/dai-shi/react-hooks-async/tree/master/examples/03_startbutton" rel="noopener ugc nofollow" target="_blank">例</a>。</p><h2 id="23da" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">useFetch挂钩</h2><p id="2fb2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">基于上面描述的两个钩子，我们可以实现<code class="fe nr ns nt ni b">useAsyncTaskFetch</code>和<code class="fe nr ns nt ni b">useFetch</code>。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="86f8" class="ku kv it ni b gy nm nn l no np">const defaultInit = {};<br/>const defaultReadBody = body =&gt; body.json();<br/><br/>const useAsyncTaskFetch = (<br/>  input,<br/>  init = defaultInit,<br/>  readBody = defaultReadBody,<br/>) =&gt; useAsyncTask(<br/>  async (abortController) =&gt; {<br/>    const response = await fetch(input, {<br/>      signal: abortController.signal,<br/>      ...init,<br/>    });<br/>    if (!response.ok) {<br/>      throw new Error(response.statusText);<br/>    }<br/>    const body = await readBody(response);<br/>    return body;<br/>  },<br/>  [input, init, readBody],<br/>);<br/><br/>const useFetch = (...args) =&gt; {<br/>  const asyncTask = useAsyncTaskFetch(...args);<br/>  useAsyncRun(asyncTask);<br/>  return asyncTask;<br/>};</span></pre><p id="5eba" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">useAxios挂钩也可以类似地实现。参考:<a class="ae ng" href="https://github.com/dai-shi/react-hooks-async/blob/master/src/use-async-task-axios.js" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><h2 id="4336" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="4e5b" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">react-hooks-异步库</h2><p id="f7ed" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">本文中描述的钩子的实现可以作为一个库获得。</p><div class="mj mk gp gr ml mm"><a href="https://github.com/dai-shi/react-hooks-async" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">戴式/反应式挂钩异步</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">一个带有React Hooks的异步函数库</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="nw l mx my mz mv na ks mm"/></div></div></a></div><p id="7113" class="pw-post-body-paragraph lq lr it ls b lt nb ju lv lw nc jx ly ld nd ma mb lh ne md me ll nf mg mh mi im bi translated">这个库不仅仅是为了获取数据。它为可移植的异步函数和一些实用函数提供了一个通用的API。一个值得注意的用例是提前输入搜索。查看回购中的示例以了解更多信息。</p><h2 id="c5f8" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">最后的想法</h2><p id="2228" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">使用useEffect获取数据有很多建议和实现，React可能会正式提供一个。自己实现一个是可能的，但不是微不足道的。从各种库中选择一个也不是小事。我希望这篇文章有助于理解如何用钩子实现可移植的fetch。我期待着任何关于Twitter或GitHub问题库的反馈。</p></div></div>    
</body>
</html>