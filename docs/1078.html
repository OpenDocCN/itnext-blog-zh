<html>
<head>
<title>Compiling your specification from source</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从源代码编译您的规范</h1>
<blockquote>原文：<a href="https://itnext.io/compiling-your-specification-from-source-94d7028acaa6?source=collection_archive---------1-----------------------#2018-07-17">https://itnext.io/compiling-your-specification-from-source-94d7028acaa6?source=collection_archive---------1-----------------------#2018-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22a9ca2a3c8d3d0218619282b744d49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcztjtzT38KvgDfR3gom6Q.jpeg"/></div></div></figure><p id="fe82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">规格，尤其是<em class="kw">开放</em> <em class="kw">标准</em>而不是一次性的，必须非常具体和详细。它们还必须清楚地展示出来，以便实施者有机会做对。</p><p id="8f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为细节要求的结果，规范包含了许多细节，这些细节适用于某些上下文，而不适用于其他上下文，并且为了清楚起见，这些信息在上下文中重复出现。</p><p id="bea8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这反过来给规范的所有者带来了维护上的麻烦。随着想法和需求的发展(正如他们应该<em class="kw">，</em>通过不断的社区反馈)，在保持内部一致性的同时更新文档变得非常具有挑战性。规格越大，问题越大，有些<a class="ae kx" href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000428.shtml" rel="noopener ugc nofollow" target="_blank">规格非常非常大</a>，需要大量支持信息。</p><p id="46da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我抽象地谈论这一点，但是我想用一个具体的用例来说明下面的内容:SWORD 3.0规范。SWORD 3.0是一种协议，使客户端和服务器能够围绕复杂的数字对象进行通信，特别是在支持将这些对象存放到类似数字存储库的服务方面。我一直是这个规范的2.0和3.0版本的技术负责人，所以亲眼目睹了汇编文档的挑战。</p><p id="c497" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我想分享一些经验和方法，我们采取了最大限度地提高剑3.0规格的准确性，同时尽量减少维护工作。</p><h1 id="13c2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">标准化</h1><p id="fe80" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">你能做的最重要的一件事就是尽可能地将你的规范中的信息规范化。这可以最大限度地减少原始资料中的重复，从而最大限度地提高规范的准确性。</p><p id="e87b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是打住，我们刚才不是说了为了帮助实现者，需要上下文中的重复吗？</p><p id="32fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，一旦我们使上下文正常化，我们将引入一些机制来产生最终的文档，它需要所有的重复，并且没有管理开销。</p><h2 id="f8e6" class="mb kz iq bd la mc md dn le me mf dp li kj mg mh lm kn mi mj lq kr mk ml lu mm bi translated">将专业知识以专业形式呈现</h2><p id="14c6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">规范通常是用散文写的(尽管这是一种高度技术性的风格)，而实现是用代码写的。这给实现者造成了巨大的鸿沟。我们可以通过尽可能用代码编写我们的规范来跨越这个鸿沟。</p><p id="9f0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我的意思是您应该尽可能使用现有的标准来记录规范。在我们针对SWORD 3.0的具体案例中，我们使用了以下代码:</p><ol class=""><li id="4c30" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><a class="ae kx" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>为规范定义的REST API。</li><li id="6574" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><a class="ae kx" href="http://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON模式</a>为规范定义的所有JSON文档的结构</li></ol><p id="26c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这样做，我们可以在可能需要这些文档的地方简化实现过程，并使那些工件<strong class="ka ir"> <em class="kw">成为规范</em> </strong> <em class="kw">的主要信息来源。</em></p><h2 id="1163" class="mb kz iq bd la mc md dn le me mf dp li kj mg mh lm kn mi mj lq kr mk ml lu mm bi translated">制作可重复使用的示例</h2><p id="e327" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">你应该写出可重用的例子，并在适当的上下文中展示给读者，而不是编写内联用法的例子。例如，如果您已经定义了JSON格式，那么在您的规范源代码树中，将它们的完整的具体例子存储为实际的<code class="fe nb nc nd ne b">.json</code>文件。</p><h2 id="a66a" class="mb kz iq bd la mc md dn le me mf dp li kj mg mh lm kn mi mj lq kr mk ml lu mm bi translated">将内容列表</h2><p id="c12f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">规范内容的主要部分是定义、解释或扩展特定的术语或术语组合。所有这些都适合制表，我的意思是<strong class="ka ir">把它放入电子表格</strong>。我建议将您的工作表作为CSV文件存储在您的源代码树中，这样它们就可以被机器读取了。</p><p id="3f94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您有一组在整个文档中使用的URL，请在如下表格中定义它们</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="cd9f" class="mb kz iq ne b gy nn no l np nq">| URL          | Definition                                      |<br/>| ------------ | ----------------------------------------------- |<br/>| Service-URL  | The root URL for the service                    |<br/>| Resource-URL | The URL to be used to access a defined resource |</span></pre><p id="1819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以机器可读的方式这样做的好处是，当我们将我们的规范编译成HTML(这就是我们的方向)时，我们总是可以链接回这些定义，或者在我们讨论规范的另一个方面时在上下文中呈现它们，所有的<em class="kw">都不必实际重复内容本身。</em></p><p id="d9a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以用这种列表方法做非常复杂的事情，你可以阅读我的帖子<a class="ae kx" href="https://medium.com/@richard.jones/normalising-requirements-in-multi-operation-protocol-specs-191136e22729" rel="noopener">关于我们如何为SWORD 3.0做这件事</a>来获得一些想法。</p><h1 id="2a17" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定义您的输出</h1><p id="1991" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">除了标准化内容之外，我们还需要决定我们想要产生什么样的输出。对于规范，这可能包括以下内容</p><ul class=""><li id="0298" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv nr mt mu mv bi translated">规格说明:这将是你正式的、没有虚饰的、纯粹的规格说明定义。这不会完全正常化，毫无疑问会有一些重复，我们会尽量减少。</li><li id="1006" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated"><strong class="ka ir">附录和支持信息</strong>:这可能包括以前的工作，如需求列表或用例，或背景阅读，或对规范领域结果的深入研究。</li><li id="507d" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated"><strong class="ka ir">实施指南</strong>:大规格可能会很枯燥，让实施者不知道从哪里开始。附加文档，如实现指南、教程或工作示例，可以增加获得高质量实现的机会。</li><li id="31c1" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated"><strong class="ka ir">演示和营销材料</strong>:信不信由你，成功的规范(尤其是开放的规范)需要大量的营销。演示文稿、博客帖子、信息表等。</li></ul><p id="ac7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你很快就会明白，相同类型的内容会在不同的上下文中反复出现。</p><p id="c3c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您已经定义了一组用于与一组API端点交互的规则，并且您已经在主规范中抽象了这些规则，那么实现者可能不会立即清楚哪些规则适用于特定的<em class="kw">端点。在这种情况下，您可以在一个单独的文档中重用主规范中的相同内容，以绝对明确地说明如何实现每个端点。你可以在我的另一篇文章中看到关于这种方法的详细讨论，这里有一个简单的例子:</em></p><p id="b214" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们有以下(简单的、人为的)规则:</p><ol class=""><li id="008b" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated">所有端点都必须进行身份验证</li><li id="7489" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">发送正文内容的客户端必须提供<code class="fe nb nc nd ne b">Content-Length</code>头</li><li id="4861" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">发送JSON的客户端必须提供头<code class="fe nb nc nd ne b">X-JSON-Type</code>(我们只是为了讨论才发明的头)</li><li id="ea5e" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated">发送二进制内容的客户端必须提供<code class="fe nb nc nd ne b">Content-Type</code>头</li></ol><p id="5ff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在我的支持信息中，我可以提供一个部分，内容如下:</p><blockquote class="ns nt nu"><p id="e12d" class="jy jz kw ka b kb kc kd ke kf kg kh ki nv kk kl km nw ko kp kq nx ks kt ku kv ij bi translated"><strong class="ka ir">向资源URL发送二进制内容</strong></p><p id="2e57" class="jy jz kw ka b kb kc kd ke kf kg kh ki nv kk kl km nw ko kp kq nx ks kt ku kv ij bi translated">1.必须认证</p><p id="13c6" class="jy jz kw ka b kb kc kd ke kf kg kh ki nv kk kl km nw ko kp kq nx ks kt ku kv ij bi translated">2.必须提供<code class="fe nb nc nd ne b">Content-Length</code>标题</p><p id="6ba1" class="jy jz kw ka b kb kc kd ke kf kg kh ki nv kk kl km nw ko kp kq nx ks kt ku kv ij bi translated">3.必须提供<code class="fe nb nc nd ne b">Content-Type</code>表头</p></blockquote><p id="6e65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是，当我改变主规范中的一个规则时，支持文档也得到更新。这是我们规范化我们的规范内容，并将其转换成机器可读格式的强大动力，否则我们必须手动完成。</p><h1 id="9eb5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定义编译过程</h1><p id="c4ae" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在我们知道了我们需要什么样的文档，并且我们在规范化的数据源中有了所有的基础信息，是时候开始将它们编译成最终的文档了。</p><p id="1a3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我将简单描述一下我们的SWORD 3.0编译器。我们的编译器是为这个目的定制的，尽管它与静态站点生成器有很多相似之处，你也可以使用类似于Jekyl或Hugo的工具。我将在以后的文章中详细描述我们的编译器。</p><p id="94e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个文档，例如主规范或实施者指南，都有自己的文本文件，其中包含所有的程序集信息。我们的是用<a class="ae kx" href="https://daringfireball.net/projects/markdown/syntax" rel="noopener ugc nofollow" target="_blank"> Markdown </a>写的，摆脱了手工写HTML的需要。它们还包含自定义标签，告诉我们的编译器做什么。这些文档中的每一个都被输入到编译器中，编译器最终输出HTML。</p><p id="dfe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是需要采取的基本步骤:</p><ol class=""><li id="a973" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv ms mt mu mv bi translated"><strong class="ka ir">读入输出文件</strong>的主文件。在很大程度上，我们的主文件只是一个按适当顺序排列的部分列表</li><li id="dbab" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">导入包含文件</strong>。includes也是包含规范文本的Markdown文件，以及告诉编译器从标准化的源数据生成什么文档的函数。</li><li id="d6ad" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">索引文档</strong>。这意味着我们寻找所有的标题，并在它们前面加上合适的章节号(如<code class="fe nb nc nd ne b">2.4.17</code>)，然后存储所有的信息，以便以后生成一个目录。</li><li id="0c30" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">运行文档中的所有功能。</strong>这将从标准化的源中生成所有文本。这包括如下操作:从OpenAPI规范中描述API，或者包括定义表，或者在部分之间创建链接。</li><li id="b6a4" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv ms mt mu mv bi translated"><strong class="ka ir">将文件渲染成HTML </strong>。将结果文件从Markdown转换成HTML，启用一些有用的扩展，比如那些覆盖表和代码块的扩展(这些不是基本Markdown语言的一部分)。</li></ol><p id="0077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给你一个更具体的描述，下面是主规范文件的一个片段:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="e544" class="mb kz iq ne b gy nn no l np nq">Last modified: {% date now,%Y-%m-%d %}<br/>{% include sections/INTRODUCTION.md %}<br/>{% include sections/TERMINOLOGY.md %}<br/>{% include sections/STRUCTURE.md %}<br/>{% include sections/HTTP_HEADERS.md %}<br/>{% include sections/PROTOCOL_OPERATIONS.md %}<br/>{% include sections/PROTOCOL_REQUIREMENTS.md %}</span></pre><p id="4f95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它基本上说:为构建打印一个时间戳，然后按顺序包含以下部分。</p><p id="7c92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您深入研究这些文件，您会发现如下函数:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="5391" class="mb kz iq ne b gy nn no l np nq">{% json_extract<br/>    source=examples/service-document.json,<br/>    keys=byReferenceDeposit<br/>%}</span></pre><p id="7834" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="a858" class="mb kz iq ne b gy nn no l np nq">{% http_exchange<br/>    source=schemas/openapi.json,<br/>    method=get,<br/>    url=/Service-URL,<br/>    response=200<br/>%}</span></pre><p id="780e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些命令告诉编译器从我们的标准化源数据中代入一些信息。</p><p id="5bfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，<code class="fe nb nc nd ne b">json_extract</code>函数加载指定的JSON文件，并在引用的块中打印其中的一个或多个键。例如，您可以用它来解释一个特定的特性在文档中是如何表示的。该函数的上述用法用于描述“byReferenceDeposits”是如何在服务描述中公布的，并为我们提供:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="1150" class="mb kz iq ne b gy nn no l np nq">{<br/>    "byReferenceDeposit": true<br/>}</span></pre><p id="9106" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做的好处是，如果我们选择更改示例文件中该字段的值，摘录中的值也会得到更新。</p><p id="04a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者考虑一下<code class="fe nb nc nd ne b">http_exchange</code>——它为我们提供了一个关于OpenAPI规范的视图，这是规范中常见的一种形式；它详细描述了客户机和服务器之间通过HTTP进行的在线交互。上面的函数调用将输出如下内容:</p><pre class="nf ng nh ni gt nj ne nk nl aw nm bi"><span id="072c" class="mb kz iq ne b gy nn no l np nq">GET /Service-URL HTTP/1.1 <br/>Authorization: ... <br/>On-Behalf-Of: ...   <br/></span><span id="67d3" class="mb kz iq ne b gy ny no l np nq">HTTP/1.1 200 <br/>Content-Type: application/json  </span><span id="6513" class="mb kz iq ne b gy ny no l np nq">[Service Document]</span></pre><p id="19cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，这是利用了标准化的数据，如果我们选择将HTTP头、主体内容或此交换的任何其他方面添加到OpenAPI定义中，这些将会反映在我们的示例中。</p><h1 id="cf4f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">来自SWORDv3的示例</h1><p id="0339" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">要看一些具体的例子，你可以看一下我们的SWORD规范git库(如果你这样管理你的规范，版本控制也很容易):</p><ul class=""><li id="2a6c" class="mn mo iq ka b kb kc kf kg kj mp kn mq kr mr kv nr mt mu mv bi translated">使用开放标准的标准化源数据的目录</li><li id="3112" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated">一份<a class="ae kx" href="https://github.com/swordapp/swordv3/tree/master/src/tables" rel="noopener ugc nofollow" target="_blank">目录列表</a>来源数据</li><li id="cd34" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated">来自规范的文件类型的示例的<a class="ae kx" href="https://github.com/swordapp/swordv3/tree/master/src/examples" rel="noopener ugc nofollow" target="_blank">目录</a></li><li id="2125" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated">主规范<a class="ae kx" href="https://raw.githubusercontent.com/swordapp/swordv3/master/src/MAIN.md" rel="noopener ugc nofollow" target="_blank">来源</a>和<a class="ae kx" href="https://swordapp.github.io/swordv3/swordv3.html" rel="noopener ugc nofollow" target="_blank">结果文档</a></li><li id="eeec" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated">详细说明每个可能的协议操作要求的实施者支持指南:<a class="ae kx" href="https://raw.githubusercontent.com/swordapp/swordv3/master/src/BEHAVIOURS.md#" rel="noopener ugc nofollow" target="_blank">来源</a>和<a class="ae kx" href="https://swordapp.github.io/swordv3/swordv3-behaviours.html" rel="noopener ugc nofollow" target="_blank">结果文档</a></li><li id="1d14" class="mn mo iq ka b kb mw kf mx kj my kn mz kr na kv nr mt mu mv bi translated">根据与主规范相同的标准化源材料构建的概述演示:<a class="ae kx" href="https://raw.githubusercontent.com/swordapp/swordv3/master/src/presentations/OVERVIEW.md#" rel="noopener ugc nofollow" target="_blank">源</a>和<a class="ae kx" href="https://swordapp.github.io/swordv3/overview" rel="noopener ugc nofollow" target="_blank">结果演示</a></li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="3df8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">多年来，我参与了许多规范工作。不仅是剑1到3，还有<a class="ae kx" href="https://www.openarchives.org/ore/" rel="noopener ugc nofollow" target="_blank"> OAI矿石</a>，以及<a class="ae kx" href="http://www.openarchives.org/rs/toc" rel="noopener ugc nofollow" target="_blank">资源同步</a>(通过正式<a class="ae kx" href="https://www.niso.org/" rel="noopener ugc nofollow" target="_blank"> NISO </a>程序)。更不用说许多特定于客户端的API定义了。在所有这些版本中，都需要管理大量的文档，而在SWORD 3.0中，我们有机会探索一种使这变得更容易的方法。</p><p id="b508" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这种方法可以帮助您完成这类工作，并且您会发现它不仅适用于开放标准，而且适用于技术规范的所有方面。</p><p id="5636" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着时间的推移，我们也许能够正式发布组装规范的软件。现在这是一个专门为SWORD 3.0编写的原型，尽管欢迎你来<a class="ae kx" href="https://github.com/swordapp/swordv3/blob/master/builder/builder.py" rel="noopener ugc nofollow" target="_blank">看一看</a>。</p><p id="4667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">理查德是软件开发咨询公司</em><a class="ae kx" href="https://cottagelabs.com" rel="noopener ugc nofollow" target="_blank"><em class="kw">Cottage Labs</em></a><em class="kw">的创始人和高级合伙人，专门研究数据生命周期的各个方面。他偶尔会在推特上发</em><a class="ae kx" href="https://twitter.com/richard_d_jones" rel="noopener ugc nofollow" target="_blank"><em class="kw">@ Richard _ d _ Jones</em></a></p></div></div>    
</body>
</html>