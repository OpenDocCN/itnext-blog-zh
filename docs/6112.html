<html>
<head>
<title>React polymorphic components with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用类型脚本反应多态组件</h1>
<blockquote>原文：<a href="https://itnext.io/react-polymorphic-components-with-typescript-f7ce72ea7af2?source=collection_archive---------2-----------------------#2021-08-22">https://itnext.io/react-polymorphic-components-with-typescript-f7ce72ea7af2?source=collection_archive---------2-----------------------#2021-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5e5f0eb5ec631146ca23440b4a7341b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1Q5mIrOZmVPrMMGf_9FCQ.png"/></div></div></figure><p id="e7b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多态组件是一种流行的反应模式。即使您从未听说过它，您也很可能在代码中遇到过它。简而言之，该模式允许您指定使用哪个HTML标记来使用<code class="fe kz la lb lc b">as</code> prop呈现组件。</p><p id="8786" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多态组件的灵活性也使得它很容易被误用，这就是TypeScript可以帮助我们的地方。让我们看看如何使用TypeScript和泛型来编写强类型多态组件。</p><h2 id="f542" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">多态组件概述</h2><p id="5824" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">首先，让我们看看如何使用多态组件。假设您有一个想要呈现为HTML链接的<code class="fe kz la lb lc b">Button</code>组件。如果<code class="fe kz la lb lc b">Button</code>是多态组件，可以这样写:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/fc0d93fe4a3760001e986b01226e5312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PykKLB3S-9ImGZRTs5l_sg.png"/></div></div></figure><p id="d2f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的按钮将呈现为<code class="fe kz la lb lc b">a</code>标签，并接受与<code class="fe kz la lb lc b">a</code>标签相同的道具，如<code class="fe kz la lb lc b">href</code>。</p><h2 id="17ef" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">简单实现</h2><p id="5c97" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">现在让我们开始实现。如果没有类型检查，该模式很难实现:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/8ed11ae14bd26a66ed2f071d0f0e4d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaFphHB87Gj9eO-kXdsCfw.png"/></div></div></figure><p id="0b46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，我们通过将组件props类型设置为<code class="fe kz la lb lc b">any</code>来避免任何类型检查。</p><p id="b18e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是让我们的模式工作的代码行:</p><p id="929c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">const Component = as || "button";</code></p><p id="c7b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用<code class="fe kz la lb lc b">as</code>属性的值或者使用<code class="fe kz la lb lc b">button</code>标签作为后备来呈现我们的组件。这就是我们使这个实现工作所需的全部内容。</p><p id="ac74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法的问题是没有机制来防止客户端传递不正确的属性:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/a4aa2e581ed2a5b7afcbc26f885d9a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60JssOfLNbg30RNuCqr6Tw.png"/></div></div></figure><p id="8d53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们指定了属于<code class="fe kz la lb lc b">a</code>标签的<code class="fe kz la lb lc b">href</code>属性，而没有设置我们的<code class="fe kz la lb lc b">as</code>属性。理想情况下，TypeScript会立即捕捉到这个错误，我们会看到一个错误。</p><h2 id="69f1" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">使用TypeScript进行类型检查</h2><p id="bb4a" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">我们的下一步是加强对组件的属性类型检查。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/430392eb00aad948bc0619bfcc405631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UI8_oqtXelbSTzziFvZn-w.png"/></div></div></figure><p id="eded" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码引入了泛型。我们在下面的代码行中使我们的组件通用化:</p><p id="81cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">const Button = &lt;T extends ElementType = "button"&gt;</code></p><p id="fe0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">元素类型是React的一个实用类型。我们将泛型参数<code class="fe kz la lb lc b">T</code>设置为ElementType，以确保我们的按钮只接受HTML标签和其他React组件类型。</p><p id="1319" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将<code class="fe kz la lb lc b">T</code>传递给<code class="fe kz la lb lc b">MyButtonProps</code>类型，它存储我们手动定义的属性。在<code class="fe kz la lb lc b">MyButtonProps</code>中，我们将<code class="fe kz la lb lc b">as</code>道具的类型设置为<code class="fe kz la lb lc b">T</code>，这将它们粘合在一起。</p><p id="79e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Button</code>道具的最终类型是<code class="fe kz la lb lc b">MyButtonProps&lt;T&gt; &amp; ComponentPropsWithoutRef&lt;T&gt;</code>。这个类型是我们手动指定的道具和<a class="ae mh" href="https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase/#wrappingmirroring-a-html-element" rel="noopener ugc nofollow" target="_blank">ComponentPropsWithoutRef</a>的组合。<code class="fe kz la lb lc b">ComponentPropsWithoutRef</code>是React库中的一个类型，包含React组件的一组基本道具。</p><p id="25c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，我们的<code class="fe kz la lb lc b">Button</code>组件可以根据<code class="fe kz la lb lc b">as</code>的值动态计算它接受的道具。如果我们早点尝试我们的客户端示例，我们会看到一个我们应该看到的错误:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/43c21ff2a0df1db39a99e83e6444005a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6M8xXzkWbQ-UwUJevuJRA.png"/></div></div></figure><p id="71db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">错误信息错综复杂，但重要的部分是:<code class="fe kz la lb lc b">Property 'href' does not exist on type 'IntrinsicAttributes &amp; MyButtonProps&lt;"button"&gt;</code>。</p><p id="fa89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的<code class="fe kz la lb lc b">Button</code>组件不再接受<code class="fe kz la lb lc b">href</code>属性，因为它没有将自己呈现为链接。如果我们加上<code class="fe kz la lb lc b">as="a"</code>，误差就消失了。</p><h2 id="43c8" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">避免名称冲突</h2><p id="49e5" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">我们的组件看起来不错，但是还有一点需要改进。我们要确保我们手动指定的道具和<code class="fe kz la lb lc b">ComponentPropsWithoutRef</code>提供的道具之间没有名称冲突。名称冲突会导致令人困惑的类型脚本警告。</p><p id="0a85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">修复错误很简单:我们需要做的就是调整组件道具的最终类型，以使用<a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys" rel="noopener ugc nofollow" target="_blank">省略</a>:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/2248a1f2c8b2a5b0a8dd19f535d14f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZ5Pq3Q6v7dgR8k-yOuFaw.png"/></div></div></figure><p id="c6fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Omit</code>是一个TypeScript实用程序，它通过从<code class="fe kz la lb lc b">ComponentPropsWithoutRef</code>中排除<code class="fe kz la lb lc b">MyButtonProps</code>中的任何属性键来构造一个新类型。使用<code class="fe kz la lb lc b">Omit</code>，我们确保避免了两种类型之间的名称冲突。查看我的帖子，了解更多关于在React 中有用的<a class="ae mh" href="https://isamatov.com/typescript-utility-types-for-react" rel="noopener ugc nofollow" target="_blank"> TypeScript实用程序类型。</a></p><p id="549b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们的<code class="fe kz la lb lc b">Button</code>组件准备好了！</p><h2 id="a292" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">结论</h2><p id="b71d" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">在这篇文章中，我们学习了使用TypeScript和泛型来编写强类型多态组件。</p><p id="04c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一般来说，使用这种方法并在React中使用TypeScript肯定需要更多的前期工作。但最终这一切都是值得的，因为我们通过在代码中提供额外的保证来改善我们的开发体验。</p><p id="40da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="8d52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mq">原载于2021年8月22日</em><a class="ae mh" href="https://isamatov.com/polymorphic-components-react-typescript/" rel="noopener ugc nofollow" target="_blank"><em class="mq">【https://isamatov.com】</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>