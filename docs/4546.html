<html>
<head>
<title>Security Zones in OpenShift worker nodes — Part II — Grouping Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift工人节点中的安全区域—第二部分—工人分组</h1>
<blockquote>原文：<a href="https://itnext.io/security-zones-in-openshift-worker-nodes-part-ii-grouping-workers-8e97f1d601ba?source=collection_archive---------3-----------------------#2020-07-21">https://itnext.io/security-zones-in-openshift-worker-nodes-part-ii-grouping-workers-8e97f1d601ba?source=collection_archive---------3-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a042bd1a08787c277cebe65f9a34df3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q91wYm5pMIaupPFMIQjLcw.jpeg"/></div></div></figure><p id="9b11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是关于如何在OpenShift workers中创建安全区域的系列文章的第二部分。如果您错过了介绍，请查看一下:</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@luis.ariz/security-zones-in-openshift-worker-nodes-part-i-introduction-4f85762962d7" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">OpenShift工作节点中的安全区域—第一部分—简介</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">在这个系列文章中，您将看到如何将OpenShift工作人员分成多个安全区域。</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="c2d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为第一个配置步骤，我们将创建两组不同的工作人员。</p><h1 id="c8a2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">概观</h1><p id="8cd5" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">首先，我们需要一种方法来对新区域的工作节点进行分组。我们需要从默认的体系结构…</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/45905eac7cf22727facd216b9a6c41e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*Qir-37hqPIBnMKBywEMfoA.png"/></div></figure><p id="fb28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…到另一个领域，我们有一组与众不同的节点，用户可以在需要时放置工作负载:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/066db8e1de958361d4cc96341153c8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64xD9pBflPqdqJaowRNU6g.png"/></div></div></figure><blockquote class="mx my mz"><p id="100e" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:该图显示了用户如何成为“普通员工”来访问工作负载，即使在访问安全区域应用时也是如此，因为默认入口控制器(OpenShift路由器)将在那里运行。我们将在下一节中通过执行一些网络配置来改变这种行为。</p></blockquote><p id="64ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kubernetes中有多种方法可以对节点进行分组并影响POD调度，以便将它们用于某些特定的工作负载、用户、项目等:</p><ul class=""><li id="9406" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">节点标签+节点选择器</li><li id="6659" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">节点标签+节点关联性</li><li id="5f10" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">节点污染+容忍</li></ul><p id="3923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">节点标签+节点选择器</strong></p><p id="39d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NodeSelector可以与节点标签一起使用，要求调度程序将我们的工作负载放在我们需要的节点子集中，例如，因为我们的应用程序需要使用那些节点中存在的东西(GPU、网络访问等)。</p><p id="c39e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法可行，但也有一些缺点:</p><ul class=""><li id="d333" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">如果我们需要在部署中将附加标签配置为NodeSelector，那么除了其他标签之外，我们还需要记住常规区域安全区域标签</li><li id="a3ba" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">使用nodeSelector时，我们的标签中只允许使用“AND”运算符，因此，例如，我们不能在设置中使用两个标签，一个用于安全工作节点+访问节点，另一个用于安全工作节点，而只是对调度程序说，将此工作负载放在其中一个中。</li><li id="c5a7" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">它只是强制执行，因此您不能有“首选”节点或软要求，例如，在我们上面的示例中，我们不能说将此应用程序放在安全工作节点+访问节点或安全工作节点中，但如果可能，最好将它放在安全工作节点中</li></ul><p id="7f26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管有这些缺点，这个解决方案还是不错的，但是没有任何NodeSelector的其他工作负载会怎么样呢？如果没有配置NodeSelector，那么工作负载可以放在我们的任何工作节点上。</p><p id="05a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着，如果我们想要阻止任何默认工作负载(没有配置nodeSelector)在安全区域中运行，我们需要配置污点(下面解释)。按照这种方法，我们将只能在指定的时候使用我们的安全工作节点。</p><p id="a73f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用labels+ <em class="na"> nodeSelectors </em>我们可以允许用户在需要的时候使用该区域，但是如果我们希望防止任何不属于某个组的用户使用该区域，或者如果我们希望避免不可信的用户工作负载，会发生什么情况呢？…当我们谈到污点时，我们会看到这个问题的答案，但首先，让我们来看看节点亲和性。</p><p id="d17b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">节点标签+节点关联</strong></p><p id="69c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以采取另一种方式来改变POD节点的位置，类似于<em class="na">节点选择器</em>:节点关联。</p><p id="cce5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它通过添加更多选项来最小化<em class="na"> nodeSelector </em>的上述缺点，例如，它允许使用or运算符、首选节点，并可以限制调度或调度+执行(您可以阻止调度，但让已经调度的工作负载继续在那些节点上运行)。</p><p id="a055" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">污点和宽容</strong></p><p id="72f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Taints采用了与<em class="na"> nodeSelector </em>或Node Affinity相反的方法，它们允许节点排斥节点上的一组pod，从而确保工作负载不会被放置在“不合适的节点”中。我们可以在部署中配置<em class="na">容忍度</em>，这样我们就允许一些部署在带有某些污点的节点上运行。</p><p id="a919" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是要注意，容忍是一种允许，它不是强制在那些节点上调度我们的应用程序，这必须通过使用<em class="na"> nodeSelector </em>或节点关联来完成。这意味着它们是互补的，通过<em class="na">节点选择器</em>和节点关联，我们允许用户指定节点来运行他们的工作负载，当出现污点时，我们会阻止工作负载在某些主机上运行，但如果用户在部署中配置“容忍”，这些规则可能会被覆盖。</p><p id="28a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们同时使用labels+<em class="na">node selectors</em>/node affinity和Taints+tolerances时，我们可以创建“专用节点”,因为我们使用Taints+tolerances来防止工作负载，并使用labels+node selectors/node affinity来执行调度，这正是我们的用例所需要的。</p><p id="d58d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，当我们配置一个<em class="na">节点选择器</em>或节点亲缘关系时，我们说“<em class="na">这个工作负载必须在一个带有XXX标签</em>的节点上运行，当我们配置一个容错时，我们说“<em class="na">这个工作负载允许在带有YYYY污点</em>的节点上运行”，例如，想象一下之前的GPU示例，这与说“请在一个带有GPU的节点上运行我的工作负载”(因为否则 我的GPU设置不会工作)比“不使用GPU的工作负载在这个主机中是不允许的”(因为如果它与GPU负载无关，我不想使用那个节点中的资源)。</p><p id="6d99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在我们的用例中,</strong>污点+容忍和标签+节点选择器/节点关联性</p><p id="1de1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何在设计中运用这些概念？</p><p id="3855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们安全区域设置的实际想法是:</p><ul class=""><li id="594f" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">在所有安全区域工作线程中设置一个Taint <strong class="ka ir"> NoSchedule </strong>,以便只有打算在安全区域中运行的工作负载可以通过使用容错来使用这些节点(默认情况下将使用常规区域)。</li><li id="ac4a" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">在安全访问+工作节点中包含第二个污点<strong class="ka ir"> PreferNoSchedule </strong>，因此默认情况下，工作负载将“优先”放置在安全工作节点中，而不是访问+工作节点中。</li><li id="16ff" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">在安全区域工作者中包括标签，以将他们与其他工作者(“常规工作者”)区分开，并且还创建两组安全区域工作者(安全访问+工作者节点和安全节点)。如果需要，这些标签将使在access+worker节点中强制运行工作负载成为可能。当我们希望安全区域工作负载使用安全区域工作器时，这些标签以及污点将使配置<em class="na">节点选择器</em>/节点关联性和容忍度成为可能</li></ul><p id="1dba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DMZ和不受信任的OCP用户用例呢？</p><p id="f80f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DMZ用例可以使用相同的步骤，但是对于不受信任的用户用例，我们需要修改其中的一些步骤，例如，我们需要在不属于不受信任的用户工作人员(“常规工作人员”)的所有节点中配置污点，而不是在新创建的区域中配置污点，以防止那些不受信任的客户端使用尚未分配给它们的资源。</p><p id="188b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你已经理解了<em class="na">节点选择器</em>和污点/容忍，我们可以开始配置了吗？嗯，在对节点进行分组时，我们需要在OpenShift中考虑更多的东西，例如机器API。</p><p id="bb01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">open shift中的machine API</strong></p><p id="a16e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您查看了上面提到的infra-node过程，或者如果您回顾了如何在我的“<a class="ae ns" href="https://medium.com/@luis.ariz/enhanced-platform-awareness-epa-in-openshift-part-i-hugepages-a28e640fabf6" rel="noopener">OpenShift-第一部分，HugePages </a>中增强平台意识(EPA)”帖子中创建EPA节点，您可能会注意到我们也影响了调度程序(在这种情况下使用节点标签+ <em class="na">节点选择器</em>),但是，除了标记节点，我们还包括了与机器集和/或机器配置相关的附加配置。我们的用例中需要这些吗？</p><p id="b9f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始解释MachineSet配置，但是首先，我们需要理解什么是Machine API。OpenShift中的Machine API在集群安装完成后执行所有节点主机供应管理操作。这意味着OpenShift提供了一种灵活、动态的节点配置方法，可以从OpenShift配置您的底层操作系统。</p><p id="ddc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果OpenShift在支持它的基础设施之上运行(基本上，如果OpenShift是使用IPI方法安装的)<strong class="ka ir">，并且如果您在您的worker节点中使用Red Hat CoreOS作为操作系统，则机器API将可用<strong class="ka ir">。</strong></strong></p><p id="d173" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，在OpenShift 4中，我们在为员工选择操作系统时有两个选项:Red Hat CoreOS或Red Hat Enterprise Linux(对于主用户，我们需要使用Red Hat CoreOS)。建议总是安装Hat CoreOS (RHCOS ),因为在这种情况下，您会获得很多好处，不仅有机会使用Machine API创建新节点，还可以获得自动节点配置(我们将在下一节中看到MachineConfig)、自动升级和修补，以及与OpenShift的其他集成。</p><p id="b288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这对我们有好处，你可能会问:为什么红帽企业版Linux (RHEL)仍然是一个选择？嗯，RHCOS是不可变的操作系统，也就是说操作系统是以只读模式挂载的！，因此您不能更改基本操作系统上的任何内容(不可变)。这增加了抵御意外损坏和某些类型的恶意攻击的能力，但你如何在上面安装新软件呢？…作为容器。这意味着您想要在RHCOS上运行的任何软件都必须被容器化。现在考虑一些人用来在Linux机器上运行的“代理”(备份代理、监控代理、安全合规性等)，如果您想将它们包含在您的RHCOS工作节点上，就必须将它们容器化。</p><p id="2c88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好消息是，这些代理中的许多都不再需要了，例如，让我们将重点放在备份代理上。对于RHCOS，节点配置由OpenShift管理，open shift将配置存储在ETCD数据库中，因此执行节点备份没有意义(您应该备份ETCD)。或者现在想想监控，节点监控化包含在OpenShift可观察性工具中，所以你也不需要。仍然有一些代理仍然可以在RHCOS上运行，在这种情况下，我们应该调查是否有可能将它们容器化，只有在不可能的情况下，我们才应该考虑将RHEL作为我们节点中的操作系统。</p><p id="a6e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到机器API和机器集…</p><p id="1cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MachineSet是一个机器API资源，它决定了必须在集群上运行的节点数量。机器集对于机器就像复制集对于pod一样。如果您需要更多的机器或者必须缩小它们的规模，您可以更改MachineSet上的replicas字段来满足您的计算需求。</p><p id="a28c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MachineSets定义了机器CRDs，因此它包括除副本数量之外的更多信息，例如，我们可以找到我们向底层基础设施请求的“节点模板”(包括CPU、内存)或必须放置节点的基础设施可用性区域，还有节点标签和污点(这是我们感兴趣的部分)。</p><p id="92bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用MachineAPI (OpenShift IPI安装)时，应该在您的MachineSet定义中配置节点标签和污点，以便在节点创建期间添加它们，从而保证您的节点将准备好预期的元数据，而不涉及进一步的手动步骤。</p><p id="c3a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，如果您使用IPI安装部署了OpenShift，请配置额外的机器集，并在其中添加将用于影响Kubernetes POD计划的标签和污点，如果您使用UPI部署，则只需在节点中手动包含标签和污点。</p><p id="a49d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> OpenShift节点角色</strong></p><p id="bd23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经说过，我们的想法是在我们的安全区域节点中设置几个污点和标签，所以让我们定义它们:</p><p id="9716" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在安全工作节点中:</p><ul class=""><li id="175a" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">污点:</li></ul><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="7670" class="ny lp iq nu b gy nz oa l ob oc">securityzone=secure:NoSchedule</span></pre><ul class=""><li id="663b" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">标签:</li></ul><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="f15b" class="ny lp iq nu b gy nz oa l ob oc">node-role.kubernetes.io/secure-worker=''</span></pre><p id="efb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在安全访问+工作节点中:</p><ul class=""><li id="1d13" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">污点:</li></ul><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="ec0b" class="ny lp iq nu b gy nz oa l ob oc">securityzone=secure:NoSchedule<br/>ingressaccess=true:PreferNoSchedule</span></pre><ul class=""><li id="59a6" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">标签:</li></ul><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="9bfc" class="ny lp iq nu b gy nz oa l ob oc">node-role.kubernetes.io/secure-worker=''<br/>ingressaccess=true</span></pre><p id="a600" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会问，为什么我选择node-role.kubernetes.io/secure-worker=''标签<em class="na">而不是比如<em class="na"> secure-worker=true </em>？</em></p><p id="f9c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，<em class="na">node-role.kubernetes.io/&lt;角色名&gt; </em>是一个特殊的键名(没有值)，它给一个节点分配一个角色，当你执行<em class="na">“oc get nodes”时，这是可见的。</em></p><blockquote class="mx my mz"><p id="877f" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:如果您必须用这个角色标签配置一个机器集，您不要把它配置成一个常规标签，因为角色标签是特殊的。您可以在这里看到<a class="ae ns" href="https://docs.openshift.com/container-platform/4.5/machine_management/creating-infrastructure-machinesets.html" rel="noopener ugc nofollow" target="_blank">一个如何创建具有新角色</a>的机器集的示例。您可能会注意到，角色名包含在与机器API相关的其他标签中。如果您使用常规标签而不是角色标签，您只需将其添加到“标签”部分。</p></blockquote><p id="5502" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Kubernetes中创建角色很方便，但它在OpenShift中还有另一层含义(这就是为什么有些人说maybe没有那么方便，更喜欢使用其他种类的标签)。你还记得当我们使用RHCOS时，我们在OpenShift中有自动配置和升级吗？这些升级是对已知角色执行的，并带有与之相关联的配置。</p><p id="55b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果我创建一个新角色，将它分配给一个节点并删除“worker”角色，会发生什么呢？(您的节点中可以有多个角色，当您向节点添加新角色时，它将具有旧角色和您在顶部添加的角色)，在这种情况下，我们将拥有仅分配给新角色的节点，但我们没有说“此新角色的配置是XXXX”，那么仅附加到新角色的那些节点将不会升级。</p><p id="7d62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是我们需要讨论OpenShift中的节点配置的时候了。</p><p id="a24d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">open shift中的machine config</strong></p><p id="887c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在开始讨论Machine API时提到了MachineConfigs。当您在节点中使用RHCOS作为操作系统时，machine config是管理操作系统配置的部分，因此，如果您有RHCOS，则可以使用machine config，无论您是使用IPI还是UPI安装。</p><p id="3fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">"<em class="na">machineconfig</em>"由"<em class="na"> Machine Config操作员</em>"管理，自动更新和节点中的操作系统配置更改，因此您不必使用ssh或ansible跳转到节点来更改它们，您只需从OpenShift创建或修改CRD。</p><p id="26e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这些MachineConfigs，我们可以修改网络配置、允许的ssh密钥等，因此它们对于根据需要修改我们的安全区域工作器的配置非常有用。</p><p id="270d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们如何将配置绑定到节点呢？因为该信息不包含在Machineconfig定义中…嗯，这是由“MachineConfigPool”CRD完成的。这意味着我可以在MachineConfig对象中定义“allow this ssh key ”,通过使用例如标签来创建一组节点，并通过配置MachineConfigPool将带有ssh密钥定义的MachineConfig分配给具有该标签的节点组，MachineConfig pool表示该machine config应用于具有该标签的节点。</p><p id="1c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是与我们相关的部分，因为我们可能需要/想要将MachineConfigs分配给我们新创建的角色。我说可能是因为我们不必从节点中删除“worker”角色，我们可以保留两个角色，即“worker”角色和新创建的角色，在这种情况下，我们已经有了一个MachineConfigPool，它将节点与配置绑定在一起(默认的worker MachineConfigurationPool)。</p><p id="8374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想要完全删除“worker”角色，我们需要创建一个新的MachineConfigPool或更改默认的MachineConfigPool，使其包含新角色。</p><p id="7fe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在为您的新区域寻找单独的节点配置(即配置审计、不同的SSH密钥等)，您还必须复制所有worker角色MachineConfigs，并将它们关联到一个新的MachineConfigPool ( <a class="ae ns" href="https://github.com/lbohnsac/OCP4/tree/master/infrastructure-node-setup" rel="noopener ugc nofollow" target="_blank">您可以在此处查看一个示例，其中按照此方法创建了一个新的infra角色</a>)。</p><p id="c836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总而言之，在创建新角色时，我们有三个关于节点配置的选项:</p><ul class=""><li id="f138" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">更少的配置选项:不要删除“worker”角色并添加新角色，将两者都保留在我们的节点中。</li><li id="f7b7" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">中期选项:删除“worker”角色，只配置新角色+将新角色包含在默认“worker”MachineConfigPool中</li><li id="24a5" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">Most配置灵活选项:删除“worker”角色，只配置新角色+为新角色创建新的MachineConfigPool</li></ul><p id="9aeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们目前的情况下，拥有不同的配置可能是有用的，因为我们可能希望在安全区域工作器中包含更多的安全调整，但我不想有“重复的”配置(即一个ssh配置对象用于普通工作人员，另一个用于安全区域工作人员)，所以我要做的是向节点添加新角色，删除工作人员角色，创建新的MachineConfigPool，但我并没有复制所有“工作人员”MachineConfigPool，而是指向新MachineConfigPool中的那些工作人员配置，这为我仅向新区域节点添加配置打开了方便之门(无需复制所有MachineConfigs，如在之前所示的示例中的<a class="ae ns" href="https://github.com/lbohnsac/OCP4/tree/master/infrastructure-node-setup" rel="noopener ugc nofollow" target="_blank">)。除了节点中的基本配置之外，我不会配置任何其他内容，但是让我的环境为该选项做好准备是很好的，以防我将来想要这样做。</a></p><p id="4133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道如何配置它，那么我们需要进入下一部分:OpenShift配置。</p><h1 id="5efa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak"> OpenShift配置(工人分组)</strong></h1><blockquote class="mx my mz"><p id="8626" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">注意:我们将使用具有集群管理员权限的OpenShift用户来完成所有这些配置</p></blockquote><p id="b579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们记住配置点:</p><ul class=""><li id="b837" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">在节点中设置标签(在我们的例子中是节点角色)和污点，以创建一个新的工人组</li><li id="c8c2" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">由于我们将创建一个新角色(不是常规标签),并希望删除“工作人员”角色，并且我们希望有机会在我们的新区域工作人员中拥有专用配置，因此我将创建一个新的<em class="na"> MachineConfigPool </em>,但它也指向“常规工作人员”配置。</li></ul><p id="4568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">1-标签和污点</strong></p><p id="ae7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从标签和污点配置开始，所以我们需要知道我们是否将使用Machine API来创建/销毁新节点。那么答案很简单:“没有”。为什么不呢？因为我的<a class="ae ns" href="https://github.com/luisarizmendi/ocp-kvm-bm-upi" rel="noopener ugc nofollow" target="_blank">实验室是使用UPI </a> OpenShift安装方法部署的(记住，如果OpenShift没有与提供者集成，那么您使用UPI安装方法安装，您将无法使用MachineSets)。</p><p id="3af2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你只有一个KVM来设置你的实验室(像我一样)<a class="ae ns" href="https://medium.com/@luis.ariz/deploying-an-openshift-4-lab-in-a-kvm-node-using-libvirt-ipi-652f0476e8a5" rel="noopener">你也可以用libvirt IPI </a>部署OpenShift，它使用了我创建的一个<a class="ae ns" href="https://github.com/luisarizmendi/ocp-libvirt-ipi-role" rel="noopener ugc nofollow" target="_blank">角色来简化这种部署</a>。您可以在该部署中获得机器API，但它确实是有限的，例如创建新的机器集，因此显示我们想要配置的内容是无效的。请记住，libvirt IPI是打算只用于测试和开发。另外，请注意，MachineSet定义会根据您使用的基础设施提供者而变化。</p><p id="18e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何配置标签和污点？我们可以使用<em class="na"> oc或kubectl </em> CLIs或OpenShift Web控制台。让我们从命令行界面开始。</p><p id="ba15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，看看您的节点和角色:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="8c4b" class="ny lp iq nu b gy nz oa l ob oc">oc get nodes</span></pre><p id="e417" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我实验室的输出:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="0e80" class="ny lp iq nu b gy nz oa l ob oc">$ oc get nodes                                                 <br/>NAME                                STATUS   ROLES    AGE   VERSION                    <br/>master0.ocp.136.243.40.222.nip.io   Ready    master   87m   v1.18.3+6025c28            <br/>master1.ocp.136.243.40.222.nip.io   Ready    master   87m   v1.18.3+6025c28            <br/>master2.ocp.136.243.40.222.nip.io   Ready    master   87m   v1.18.3+6025c28<br/>worker0.ocp.136.243.40.222.nip.io   Ready    worker   78m   v1.18.3+6025c28<br/>worker1.ocp.136.243.40.222.nip.io   Ready    worker   78m   v1.18.3+6025c28<br/>worker2.ocp.136.243.40.222.nip.io   Ready    worker   78m   v1.18.3+6025c28<br/>worker3.ocp.136.243.40.222.nip.io   Ready    worker   78m   v1.18.3+6025c28<br/>worker4.ocp.136.243.40.222.nip.io   Ready    worker   78m   v1.18.3+6025c28</span></pre><p id="e618" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后向您的节点添加新角色"<em class="na">安全工作者</em>:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="164f" class="ny lp iq nu b gy nz oa l ob oc">oc label node &lt;nodename&gt; node-role.kubernetes.io/secure-worker=''</span></pre><p id="a71d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我实验室的输出:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="b1c0" class="ny lp iq nu b gy nz oa l ob oc">$ oc label node worker2.ocp.136.243.40.222.nip.io node-role.kubernetes.io/secure-worker=''</span><span id="96ca" class="ny lp iq nu b gy od oa l ob oc">node/worker2.ocp.136.243.40.222.nip.io labeled</span><span id="7b4c" class="ny lp iq nu b gy od oa l ob oc">$ oc label node worker3.ocp.136.243.40.222.nip.io node-role.kubernetes.io/secure-worker=''</span><span id="f196" class="ny lp iq nu b gy od oa l ob oc">node/worker3.ocp.136.243.40.222.nip.io labeled</span><span id="0a57" class="ny lp iq nu b gy od oa l ob oc">$ oc label node worker4.ocp.136.243.40.222.nip.io node-role.kubernetes.io/secure-worker=''</span><span id="9f71" class="ny lp iq nu b gy od oa l ob oc">node/worker4.ocp.136.243.40.222.nip.io labeled</span></pre><p id="90a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查新角色是否已添加到节点中。我实验室的输出:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="65e6" class="ny lp iq nu b gy nz oa l ob oc">$ oc get node<br/>NAME                                STATUS   ROLES                     AGE     VERSION<br/>master0.ocp.136.243.40.222.nip.io   Ready    master                    3h10m   v1.18.3+6025c28<br/>master1.ocp.136.243.40.222.nip.io   Ready    master                    3h10m   v1.18.3+6025c28<br/>master2.ocp.136.243.40.222.nip.io   Ready    master                    3h10m   v1.18.3+6025c28<br/>worker0.ocp.136.243.40.222.nip.io   Ready    worker                    3h1m    v1.18.3+6025c28<br/>worker1.ocp.136.243.40.222.nip.io   Ready    worker                    3h1m    v1.18.3+6025c28<br/>worker2.ocp.136.243.40.222.nip.io   Ready    secure-worker,worker   3h1m    v1.18.3+6025c28<br/>worker3.ocp.136.243.40.222.nip.io   Ready    secure-worker,worker   3h1m    v1.18.3+6025c28<br/>worker4.ocp.136.243.40.222.nip.io   Ready    secure-worker,worker   3h1m    v1.18.3+6025c28</span></pre><p id="1584" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，节点同时具有<em class="na">工作者</em>和<em class="na">安全工作者</em>角色，我想只保留后者，所以删除工作者角色标签:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="0b5a" class="ny lp iq nu b gy nz oa l ob oc">oc label node &lt;nodename&gt; node-role.kubernetes.io/worker-</span></pre><p id="0132" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我实验室的输出:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="5c18" class="ny lp iq nu b gy nz oa l ob oc">$ oc label node worker4.ocp.136.243.40.222.nip.io node-role.kubernetes.io/worker-</span><span id="7668" class="ny lp iq nu b gy od oa l ob oc">node/worker4.ocp.136.243.40.222.nip.io labeled</span><span id="db84" class="ny lp iq nu b gy od oa l ob oc">$ oc label node worker3.ocp.136.243.40.222.nip.io node-role.kubernetes.io/worker-</span><span id="c4eb" class="ny lp iq nu b gy od oa l ob oc">node/worker3.ocp.136.243.40.222.nip.io labeled</span><span id="4863" class="ny lp iq nu b gy od oa l ob oc">$ oc label node worker2.ocp.136.243.40.222.nip.io node-role.kubernetes.io/worker-</span><span id="611f" class="ny lp iq nu b gy od oa l ob oc">node/worker2.ocp.136.243.40.222.nip.io labeled</span></pre><p id="95ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次检查节点的角色。这是我的输出:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="b541" class="ny lp iq nu b gy nz oa l ob oc">$ oc get nodes<br/>NAME                                STATUS   ROLES              AGE     VERSION<br/>master0.ocp.136.243.40.222.nip.io   Ready    master             3h29m   v1.18.3+6025c28<br/>master1.ocp.136.243.40.222.nip.io   Ready    master             3h29m   v1.18.3+6025c28<br/>master2.ocp.136.243.40.222.nip.io   Ready    master             3h29m   v1.18.3+6025c28<br/>worker0.ocp.136.243.40.222.nip.io   Ready    worker             3h20m   v1.18.3+6025c28<br/>worker1.ocp.136.243.40.222.nip.io   Ready    worker             3h20m   v1.18.3+6025c28<br/>worker2.ocp.136.243.40.222.nip.io   Ready    secure-worker   3h20m   v1.18.3+6025c28<br/>worker3.ocp.136.243.40.222.nip.io   Ready    secure-worker   3h20m   v1.18.3+6025c28<br/>worker4.ocp.136.243.40.222.nip.io   Ready    secure-worker   3h20m   v1.18.3+6025c28</span></pre><p id="7c01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们让所有安全区域工作人员都担任了新的角色，但是请记住，我们在该区域中有两个子组:access+worker安全节点和worker安全节点。这里我们有多种选择，我们可以为access+worker节点创建一个新角色并附加到这些节点，或者我们可以只为它们配置一个标签。</p><p id="d8bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们已经看到了如何配置角色，所以我将坚持第二个选项，只配置一个标签来区分这些节点和安全区域中的其他节点。</p><p id="ad71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用worker2和worker3作为access+worker节点，因此我将它们标记为:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="4927" class="ny lp iq nu b gy nz oa l ob oc">$ oc label node worker2.ocp.136.243.40.222.nip.io ingressaccess=true</span><span id="d5cb" class="ny lp iq nu b gy od oa l ob oc">node/worker2.ocp.136.243.40.222.nip.io labeled</span><span id="9f0d" class="ny lp iq nu b gy od oa l ob oc">$ oc label node worker3.ocp.136.243.40.222.nip.io ingressaccess=true</span><span id="fd53" class="ny lp iq nu b gy od oa l ob oc">node/worker3.ocp.136.243.40.222.nip.io labeled</span></pre><p id="0145" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们已经在节点中设置了标签，现在是时候配置污点了，您可以使用命令来完成</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="9e70" class="ny lp iq nu b gy nz oa l ob oc">oc adm taint nodes &lt;nodename&gt; &lt;key&gt;=&lt;value&gt;:&lt;taint&gt;</span></pre><p id="9f28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的例子中，如果部署没有<em class="na"> securityzone=secure </em>标签，我必须用NoSchedule来标记所有安全区域主机:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="5d45" class="ny lp iq nu b gy nz oa l ob oc">$  oc adm taint node worker2.ocp.136.243.40.222.nip.io securityzone=secure:NoSchedule</span><span id="1411" class="ny lp iq nu b gy od oa l ob oc">node/worker2.ocp.136.243.40.222.nip.io tainted</span><span id="115d" class="ny lp iq nu b gy od oa l ob oc">$  oc adm taint node worker3.ocp.136.243.40.222.nip.io securityzone=secure:NoSchedule</span><span id="eb67" class="ny lp iq nu b gy od oa l ob oc">node/worker3.ocp.136.243.40.222.nip.io tainted</span><span id="22b3" class="ny lp iq nu b gy od oa l ob oc">$  oc adm taint node worker4.ocp.136.243.40.222.nip.io securityzone=secure:NoSchedule</span><span id="b570" class="ny lp iq nu b gy od oa l ob oc">node/worker4.ocp.136.243.40.222.nip.io tainted</span></pre><p id="416d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，在access+worker安全区域节点中，我需要说明的是，如果可能的话，最好不要在这些节点(worker2和worker3)中安排pod:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="5bf8" class="ny lp iq nu b gy nz oa l ob oc">$  oc adm taint node worker2.ocp.136.243.40.222.nip.io ingressaccess=true:PreferNoSchedule</span><span id="6790" class="ny lp iq nu b gy od oa l ob oc">node/worker2.ocp.136.243.40.222.nip.io tainted</span><span id="d03b" class="ny lp iq nu b gy od oa l ob oc">$  oc adm taint node worker3.ocp.136.243.40.222.nip.io ingressaccess=true:PreferNoSchedule</span><span id="7d08" class="ny lp iq nu b gy od oa l ob oc">node/worker3.ocp.136.243.40.222.nip.io tainted</span></pre><p id="e531" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的节点被标记和污染了。</p><p id="cce2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想使用Web控制台执行此配置。以下是如何修改节点中的标签的示例(该示例显示了如何添加标签，但您也可以从中删除标签):</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/e8b566cd3f683914d8bfba63b84a95ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ytleJrWRP_pcVBEae8s6pw.gif"/></div></div></figure><p id="d2ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用Web控制台包含污点，您必须编辑节点对象，您可以看看worker3中的一个示例，我们必须配置这两个污点:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/dfc59568b83491bce88ac454763c8a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3DeiwTEQgun4aryiF6_xiw.gif"/></div></div></figure><p id="8a53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2-MachineConfigPool </strong></p><p id="ff96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着新角色的出现，我们希望配置一个新的<em class="na"> MachineconfigPool </em>，但是由于我们之前讨论的原因，它指向常规worker节点的MachineConfigs。这是定义:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="3df1" class="ny lp iq nu b gy nz oa l ob oc">apiVersion: machineconfiguration.openshift.io/v1<br/>kind: MachineConfigPool<br/>metadata:<br/>  name: secure-worker<br/>spec:<br/>  machineConfigSelector:<br/>    matchExpressions:<br/>      - {key: machineconfiguration.openshift.io/role, operator: In, values: [worker,secure-worker]}<br/>  nodeSelector:<br/>    matchLabels:<br/>      node-role.kubernetes.io/secure-worker: ""<br/>  paused: false</span></pre><p id="b186" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们将MachineConfigPool链接到节点(<em class="na">节点选择器</em>链接到带有【node-role.kubernetes.io/secure-worker:】标签的节点)和MachineConfigs(对于带有标签<em class="na">machineconfiguration.openshift.io/role=worker</em>或<em class="na">machineconfiguration.openshift.io/role=secure-worker</em>的MachineConfig对象)。通过这种方式，我们可以将常规的worker节点配置“附加”到新角色的节点上，而且我们还可以创建仅适用于新角色worker的配置。</p><p id="47b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用CLI创建/应用此对象(或任何其他对象)，方法是创建一个具有上述定义的文件并使用"<em class="na">oc create-f&lt;filename&gt;</em>"或者，如果您不想创建文件只是为了创建对象，您可以运行<em class="na"> oc create </em>并将内容包括在同一个命令中，方法如下(无需创建文件):</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="2353" class="ny lp iq nu b gy nz oa l ob oc">oc create -f - &lt;&lt;EOF<br/>apiVersion: machineconfiguration.openshift.io/v1<br/>kind: MachineConfigPool<br/>metadata:<br/>  name: secure-worker<br/>spec:<br/>  machineConfigSelector:<br/>    matchExpressions:<br/>      - {key: machineconfiguration.openshift.io/role, operator: In, values: [worker,secure-worker]}<br/>  nodeSelector:<br/>    matchLabels:<br/>      node-role.kubernetes.io/secure-worker: ""<br/>  paused: false<br/>EOF</span></pre><p id="c3cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用描述符通过Web控制台创建对象，您可以通过三种方式来完成:</p><ul class=""><li id="8dda" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">转到菜单中的MachineConfigPool部分</li></ul><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/1a67efc37ee5e840bd5ab379f8f52b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*erlrofrf4j6pTA1_zOK1ug.gif"/></div></div></figure><ul class=""><li id="f29c" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">转到“Explore”菜单，搜索种类<em class="na"> MachineConfigPool </em>，创建一个新的实例，您可以对任何有效的对象使用这种技术</li></ul><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/a492958a0d409b0f10bb672f03a0f31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UGzNcZBmPy3S7ff2ujh-9w.gif"/></div></div></figure><ul class=""><li id="ff56" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">使用“+”号并复制您的定义，这可以用于任何有效的对象，而不仅仅是MachineConfigPools:</li></ul><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/fb735f19659e88328eb19255c59280ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bJQ3mmS2qC4H6_8shiwvAQ.gif"/></div></div></figure><p id="dbe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后两个选项非常好，因为您可以使用它们来配置我们的配置中需要的任何对象，但是使用Web控制台而不是CLI。</p><p id="d672" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在创建了<em class="na"> MachineConfigPool </em>之后，您可以检查链接到它的节点数量是否如预期的那样为3(角色为<em class="na"> secure-worker </em>的节点)并且配置检查正在进行(“更新”)，您只需要运行:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="0f26" class="ny lp iq nu b gy nz oa l ob oc">oc get machineconfigpools</span></pre><p id="2578" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以等待，直到所有的配置都被强制执行(同样，因为他们使用的配置与普通工作人员相同)，并确保没有“降级的”节点，或者您可以继续配置并在以后进行检查。</p><h1 id="a35e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">配置测试(工人分组)</strong></h1><p id="2ff0" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">我们已经完成了配置(对于这一部分),因此我们必须测试一切是否按预期工作:</p><ul class=""><li id="8a23" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">如果一个用户部署了没有<em class="na">节点选择器</em>的东西，那么它必须被安排给普通工人</li><li id="9e59" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">用户可以使用正确的<em class="na">节点选择器</em>和容忍度将某些东西部署到安全区域(我们将在下面的另一节中对一些用户进行限制)，默认情况下，工作负载将被放置在安全区域工作器中(而不是安全访问+工作器节点中)</li><li id="630e" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">如果安全工作节点中没有剩余空间，并且用户想要使用安全区域，则可以将工作负载放置在安全访问+工作节点中</li><li id="96f1" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">用户可以强制工作负载在安全访问+工作节点中运行，尽管安全工作节点中仍有资源</li></ul><p id="1496" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的测试，我将创建一个新项目:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="af56" class="ny lp iq nu b gy nz oa l ob oc">oc new-project tests</span></pre><p id="6067" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从第一个测试开始。我将创建一个包含5个副本的部署，没有其他配置</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="2a47" class="ny lp iq nu b gy nz oa l ob oc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: test<br/>  labels:<br/>    app: test<br/>spec:<br/>  replicas: 5<br/>  selector:<br/>    matchLabels:<br/>      app: test<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<br/>    spec:<br/>      containers:<br/>      - name: test<br/>        image: <!-- -->centos/tools<br/>        <!-- -->command: ["/bin/bash", "-c", "sleep 9000000"]</span></pre><p id="0a06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用以下命令检查如何将所有pod调度给“常规工作人员”(工作人员0和工作人员1):</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="6089" class="ny lp iq nu b gy nz oa l ob oc">oc get pod  -o wide</span></pre><p id="b3ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的实验室里(我用管道与AWK缩短输出):</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="115e" class="ny lp iq nu b gy nz oa l ob oc">$ oc get pod  -o wide | awk {'print $1" " $7'} | column -t<br/>NAME                  NODE<br/>test-96477d59f-74sdw  worker1.ocp.136.243.40.222.nip.io<br/>test-96477d59f-btstd  worker1.ocp.136.243.40.222.nip.io<br/>test-96477d59f-klt85  worker0.ocp.136.243.40.222.nip.io<br/>test-96477d59f-qgfvq  worker1.ocp.136.243.40.222.nip.io<br/>test-96477d59f-vhvq7  worker0.ocp.136.243.40.222.nip.io</span></pre><p id="cd2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移除测试，以便用一个干净的项目开始下一个测试:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="b58a" class="ny lp iq nu b gy nz oa l ob oc">oc delete deployment test</span></pre><p id="dc35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于第二个测试，我们希望在安全区域创建pod。我们将重复使用之前测试的部署，但是:</p><ul class=""><li id="5b01" class="ne nf iq ka b kb kc kf kg kj ng kn nh kr ni kv nj nk nl nm bi translated">包括允许在安全区域内安排运输舱</li><li id="012e" class="ne nf iq ka b kb nn kf no kj np kn nq kr nr kv nj nk nl nm bi translated">在<em class="na">节点选择器</em>上包含安全区域标签，以强制使用新区域的工作者:</li></ul><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="159d" class="ny lp iq nu b gy nz oa l ob oc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: test<br/>  labels:<br/>    app: test<br/>spec:<br/>  replicas: 5<br/>  selector:<br/>    matchLabels:<br/>      app: test<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<br/>    spec:<br/>      containers:<br/>      - name: test<br/>        image: <!-- -->centos/tools<br/>        <!-- -->command: ["/bin/bash", "-c", "sleep 9000000"]<br/><strong class="nu ir">    </strong><strong class="nu ir">  tolerations:<br/>        - key: "</strong><strong class="nu ir">securityzone</strong><strong class="nu ir">"<br/>          operator: "Equal"<br/>          value: "secure"<br/>          effect: "NoSchedule"</strong><br/><strong class="nu ir">      nodeSelector:<br/>        node-role.kubernetes.io/secure-worker: ''</strong></span></pre><p id="4662" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们创建pod时，我们可以看到它们是如何被放置在worker4中的，为什么？因为它是安全区域中的工作节点，而不是访问+工作节点(这些是非首选节点):</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="35fa" class="ny lp iq nu b gy nz oa l ob oc">oc get pod  -o wide | awk {'print $1" " $7'} | column -t<br/>NAME                  NODE<br/>test-995bc4654-2nz7c  worker4.ocp.136.243.40.222.nip.io<br/>test-995bc4654-k7zpl  worker4.ocp.136.243.40.222.nip.io<br/>test-995bc4654-rnr52  worker4.ocp.136.243.40.222.nip.io<br/>test-995bc4654-tvn9c  worker4.ocp.136.243.40.222.nip.io<br/>test-995bc4654-x79f9  worker4.ocp.136.243.40.222.nip.io</span></pre><p id="0e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">删除部署并继续下一个测试。</p><p id="61da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要创建足够的PODs来耗尽安全worker (worker4)资源，然后我们将看到如何在安全访问+worker nodes(worker 2或worker3)中开始调度PODs。</p><p id="2c1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用我们在前面的测试中使用的相同的部署对象，并且只增加副本的数量，直到我们填充worker4，但是我们要做的是在POD定义中包括一个最小CPU请求，这样我们就不必创建大量的POD。</p><p id="5a5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的工作人员有4个内核，但由于默认情况下kubelet保留了0.5个内核，我们只能使用3.5个内核，我们可以在我的实验室中使用以下命令检查它:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="1733" class="ny lp iq nu b gy nz oa l ob oc">$ oc get node -o yaml | grep -i cpu | grep m | head -n 1<br/>      cpu: 3500m</span></pre><p id="7096" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将为每个单元配置一个完整的核心请求，因此我们每个工作人员最多只能托管3个单元的部署，不能再多了:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="730c" class="ny lp iq nu b gy nz oa l ob oc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: test<br/>  labels:<br/>    app: test<br/>spec:<br/>  replicas: 5<br/>  selector:<br/>    matchLabels:<br/>      app: test<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<br/>    spec:<br/>      containers:<br/>      - name: test<br/>        image: <!-- -->centos/tools<br/>        <!-- -->command: ["/bin/bash", "-c", "sleep 9000000"]<!-- -->  <br/><strong class="nu ir">        resources:<br/>          limits:<br/>            cpu: "1"<br/>          requests:<br/>            cpu: "1"</strong><br/>    <!-- -->  tolerations:<br/>        - key: "<!-- -->securityzone<!-- -->"<br/>          operator: "Equal"<br/>          value: "secure"<br/>          effect: "NoSchedule"<br/>      nodeSelector:<br/>        node-role.kubernetes.io/secure-worker: ''</span></pre><p id="bbc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如预期的那样，我们的worker4中将有3个pod，但是剩余的2个pod被安排在worker2和worker3中(安全访问+worker节点)</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="870a" class="ny lp iq nu b gy nz oa l ob oc">$ oc get pod  -o wide | awk {'print $1" " $7'} | column -t<br/>NAME                   NODE<br/>test-6977f84b64-5jqht  worker4.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-8fcd9  worker4.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-q6rfm  worker4.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-x5r25  worker3.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-zq2s7  worker2.ocp.136.243.40.222.nip.io</span></pre><p id="2688" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以借此机会运行一个额外的测试，如果我们尝试旋转此部署的10个pod会发生什么情况？我们的安全区域中只有9个完整内核可用…</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="9326" class="ny lp iq nu b gy nz oa l ob oc">$  oc scale --replicas=10 deployment/test<br/>deployment.apps/test scaled</span></pre><p id="95d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第10个POD调度将失败，因为我们强制在安全区域中使用我们的部署，但我们没有足够的资源来放置更多此类工作负载，这使我们可以确保我们的应用程序不会在“常规区域”中运行，即使该区域中没有更多资源可用:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="e10f" class="ny lp iq nu b gy nz oa l ob oc">$ oc get pod  -o wide | awk {'print $1" " $7'} | column -t<br/>NAME                   NODE<br/>test-6977f84b64-5jqht  worker4.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-7sz6j  worker3.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-8fcd9  worker4.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-h6xfs  &lt;none&gt;<br/>test-6977f84b64-kzgfx  worker2.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-mrbtm  worker3.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-np6mb  worker2.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-q6rfm  worker4.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-x5r25  worker3.ocp.136.243.40.222.nip.io<br/>test-6977f84b64-zq2s7  worker2.ocp.136.243.40.222.nip.io</span></pre><p id="cadd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的最后一个测试，从我们的测试项目中删除部署，并创建另一个项目，其中我们为我们的安全访问+工作者节点包含了<em class="na">节点选择器</em>，这样我们可以测试，即使我们在安全工作者节点中有空闲资源，也可以强制在这些工作者中运行工作负载:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="8ec2" class="ny lp iq nu b gy nz oa l ob oc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: test<br/>  labels:<br/>    app: test<br/>spec:<br/>  replicas: 5<br/>  selector:<br/>    matchLabels:<br/>      app: test<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: test<br/>    spec:<br/>      containers:<br/>      - name: test<br/>        image: <!-- -->centos/tools<br/>        <!-- -->command: ["/bin/bash", "-c", "sleep 9000000"]<!-- -->  <br/>        resources:<br/>          limits:<br/>            cpu: "1"<br/>          requests:<br/>            cpu: "1"<br/>    <!-- -->  tolerations:<br/>        - key: "<!-- -->securityzone<!-- -->"<br/>          operator: "Equal"<br/>          value: "secure"<br/>          effect: "NoSchedule"<br/>      nodeSelector:<br/>        node-role.kubernetes.io/secure-worker: ''<br/>       <strong class="nu ir"> ingressaccess: "true"</strong></span></pre><p id="40f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查是否在这些工人(我实验室中的工人2和工人3)上创建了pod:</p><pre class="ms mt mu mv gt nt nu nv nw aw nx bi"><span id="f057" class="ny lp iq nu b gy nz oa l ob oc">$ oc get pod  -o wide | awk {'print $1" " $7'} | column -t<br/>NAME                   NODE<br/>test-5b7bf7b7fc-2lxtn  worker2.ocp.136.243.40.222.nip.io<br/>test-5b7bf7b7fc-64ndt  worker3.ocp.136.243.40.222.nip.io<br/>test-5b7bf7b7fc-v78pn  worker3.ocp.136.243.40.222.nip.io<br/>test-5b7bf7b7fc-vp7m9  worker2.ocp.136.243.40.222.nip.io<br/>test-5b7bf7b7fc-z4d98  worker2.ocp.136.243.40.222.nip.io</span></pre><p id="aba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个最终测试之后，再次删除部署来清理测试项目。</p><h1 id="04a7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">我们继续吗？</h1><p id="a067" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在下一篇文章中，我们将继续我们的配置，包括我们的OpenShift集群中的一些变化，以便能够分离入口和出口流量，以及配置网络限制以防止不希望的连接。</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/@luis.ariz/security-zones-in-openshift-worker-nodes-part-iii-network-configuration-3a887854a4d" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">OpenShift工作节点中的安全区域—第三部分—网络配置</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">在本帖中，我们将重点讨论在我们的安全系统中分离入站和出站流量所需的网络配置…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="of l lk ll lm li ln jw kz"/></div></div></a></div></div></div>    
</body>
</html>