<html>
<head>
<title>The subtleties of ensuring zero downtime during pod lifecycle events in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes的pod生命周期事件中确保零停机时间的微妙之处</h1>
<blockquote>原文：<a href="https://itnext.io/the-subtleties-of-ensuring-zero-downtime-during-pod-lifecycle-events-in-kubernetes-6461c12f7736?source=collection_archive---------2-----------------------#2021-05-31">https://itnext.io/the-subtleties-of-ensuring-zero-downtime-during-pod-lifecycle-events-in-kubernetes-6461c12f7736?source=collection_archive---------2-----------------------#2021-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/114844d6951fb3cc61250c6264b3e5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGrgGkxQor3JbzIFXj2s_A.jpeg"/></div></div></figure><p id="492a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我感兴趣的一个话题是确保web应用程序的正常运行时间。kubernetes调度程序有许多正当的理由需要终止一个健康的容器。一些这样的事件是——版本更新、自动缩放和集群<a class="ae kw" href="https://kubernetes.io/docs/concepts/scheduling-eviction/resource-bin-packing/" rel="noopener ugc nofollow" target="_blank">装箱</a>(其中pod可以在工作节点周围移动)。这使得最重要的是确保吊舱确实能够<em class="kx">优雅地退出</em> <em class="kx">！</em>虽然<a class="ae kw" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/" rel="noopener ugc nofollow" target="_blank">滚动更新</a>部署策略为零停机部署提供了框架，但即使是最流行的反向代理&amp; WSGI框架也存在一些微妙之处，如果不进行微调，可能会在此类事件中导致少量错误。此外，直到应用程序在高负载/流量环境中运行时，这些问题才会显现出来。在此，我想强调其中的一些。</p><p id="1892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们看看kubernetes pod的生命周期。具体来说，我们想放大一个pod终止时会发生什么:</p><ol class=""><li id="d618" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">pod从所有服务的端点列表中删除，并置于<code class="fe lh li lj lk b">Terminating</code>状态。这意味着pod不再接收任何新的流量。</li><li id="09c9" class="ky kz iq ka b kb ll kf lm kj ln kn lo kr lp kv ld le lf lg bi translated">接下来，如果定义了一个<code class="fe lh li lj lk b"><a class="ae kw" href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks" rel="noopener ugc nofollow" target="_blank">preStop</a></code>钩子，它将被执行。</li><li id="1f63" class="ky kz iq ka b kb ll kf lm kj ln kn lo kr lp kv ld le lf lg bi translated">一个<code class="fe lh li lj lk b">TERM</code>信号被发送到pod中每个容器内的主过程(pid 1)。这是应用程序启动正常关机的提示。</li><li id="cbeb" class="ky kz iq ka b kb ll kf lm kj ln kn lo kr lp kv ld le lf lg bi translated">然后调度程序等待<code class="fe lh li lj lk b">terminationGracePeriodSeconds</code>(默认为30秒)。</li><li id="c4a0" class="ky kz iq ka b kb ll kf lm kj ln kn lo kr lp kv ld le lf lg bi translated">如果应用程序仍然没有完成关闭，一个<code class="fe lh li lj lk b">KILL</code>信号被发送到pod以强制关闭应用程序，并且pod被移除。</li></ol><p id="2344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只要应用程序服务完所有在上述步骤1之前进入的<em class="kx">进行中的</em>请求，并在步骤5之前优雅地关闭，这一切都很棒。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="ae12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而在实践中，有一些陷阱。</p><p id="21a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然大多数应用程序处理一个<code class="fe lh li lj lk b">TERM</code>信号并启动正常关机，但由于使用<code class="fe lh li lj lk b">TERM</code>信号时悬空套接字的问题，一个广泛使用的反向代理nginx设计了不同的<code class="fe lh li lj lk b">STOPSIGNAL,</code>。即<a class="ae kw" href="https://github.com/nginxinc/docker-nginx/blob/3fb70ddd7094c1fdd50cc83d432643dc10ab6243/stable/alpine/Dockerfile#L122" rel="noopener ugc nofollow" target="_blank"> nginx使用</a> <code class="fe lh li lj lk b">SIGQUIT</code>启动正常关机。那么，我们该怎么处理呢？这就是<code class="fe lh li lj lk b">preStop</code>钩子派上用场的地方。如果您使用nginx作为缓冲反向代理，它位于一个pods中的WSGI框架的前面，那么对nginx容器使用下面的<code class="fe lh li lj lk b">preStop</code>钩子:</p><pre class="lx ly lz ma gt mb lk mc md aw me bi"><span id="04e1" class="mf mg iq lk b gy mh mi l mj mk">preStop:<br/>  exec:<br/>    command:<br/>      - nginx<br/>      - -s<br/>      - quit</span></pre><p id="800c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本质上，我们拦截了nginx的终止生命周期，并在kubernetes调度程序向它发送<code class="fe lh li lj lk b">TERM</code>信号之前向它发送了<code class="fe lh li lj lk b">QUIT</code>信号，从而确保了正常关闭</p><p id="1aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，大多数WSGI框架都有一个<a class="ae kw" href="https://docs.gunicorn.org/en/stable/settings.html#backlog" rel="noopener ugc nofollow" target="_blank">待定连接的backlog </a>。在高流量环境中，在pod终止开始后，在backlog <em class="kx">中发现一些连接并不罕见，请注意，这些请求会在上述步骤1之前到达。在这里，我们只需要给应用程序足够的时间，在它从调度程序接收到一个<code class="fe lh li lj lk b">TERM</code>信号之前完成处理backlog。时间的长短实际上取决于用例/应用。<code class="fe lh li lj lk b">preStop</code>钩再次出手相救。请留出足够的时间让您的应用程序完成对任何飞行中请求的服务:</em></p><pre class="lx ly lz ma gt mb lk mc md aw me bi"><span id="363b" class="mf mg iq lk b gy mh mi l mj mk">preStop:<br/>  exec:<br/>    command:<br/>      - /bin/sh<br/>      - -c<br/>      - sleep 9</span></pre><p id="2e71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，我最喜欢的一个陷阱来自于编写<code class="fe lh li lj lk b">Dockerfile</code>时使用的模式！经常会看到一个名为<code class="fe lh li lj lk b">entrypoint.sh</code>的shell脚本，它是应用程序的<code class="fe lh li lj lk b"><a class="ae kw" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">ENTRYPOINT</a></code>。当shell脚本启动应用程序时，应用程序本身成为shell的子进程，因此不会收到发送给父进程的任何信号！因此，当kubernetes调度程序向PID 1(shell)发送一个<code class="fe lh li lj lk b">TERM</code>信号时，应用程序本身没有启动正常关闭的提示！处理这个问题的一个很好的方法是使用<a class="ae kw" href="https://ss64.com/bash/exec.html" rel="noopener ugc nofollow" target="_blank"> bash内置</a> <code class="fe lh li lj lk b"><a class="ae kw" href="https://ss64.com/bash/exec.html" rel="noopener ugc nofollow" target="_blank">exec</a></code>从shell scirpt中启动您的应用程序(如果您必须这样做的话)。<code class="fe lh li lj lk b">exec</code>内置用提供给它的命令替换shell，从而使您的应用程序成为容器中的主进程(因此，能够接收来自kubernetes调度程序的信号)。</p><p id="d1df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上只是几个例子，说明了在kubernetes集群中正常pod终止期间，一些容易忽略的事情会如何影响应用程序的正常运行时间。有没有和上面类似的例子？如果是这样，我很想在评论区听到他们的消息！</p></div></div>    
</body>
</html>