# 在 React 应用中集中 API 错误处理

> 原文：<https://itnext.io/centralizing-api-error-handling-in-react-apps-810b2be1d39d?source=collection_archive---------0----------------------->

![](img/6830aec9130a5188b774a18894a5cd09.png)

在本文中，我将向您展示一种以集中且易于扩展的方式一次性处理 API 错误的方法，而不考虑状态管理库(Redux、Apollo 等)。)您正在使用的。

几乎每一个现代应用程序都与 API 交互以满足其数据需求；无论是 RESTful API 还是 graph QL API，在 web 上触发请求是大多数应用程序的基本功能。大多数情况下，事情进展顺利，您的请求被成功返回，但也有事情进展不顺利的时候。我说的是 API 可以返回的那些可怕的 404、403 和 500，它们反过来必须呈现给用户。由于这类响应的性质，在一个地方处理它们是最理想的。

不幸的是，在 React 应用程序中管理这一点比它应该做的要难，每个应用程序都有完全不同的方法。在本文中，我将向您展示一种以集中且易于扩展的方式一次性处理 API 错误的方法，而不考虑状态管理库(Redux、Apollo 等)。)您正在使用的。此外，我们将采用的方法可以在您的所有应用程序中重复使用，无论您是实现客户端还是服务器端渲染。所以事不宜迟，让我们直接开始吧。

# 设置场景

出于本文的目的，我将假设存在一个带有常见 HTTP 错误状态代码的 RESTful API，但是类似的概念也适用于 GraphQL 和任何其他 API。我还假设使用了`react-router`，但是完全相同的概念也适用于`@reach/router`或任何其他 React 路由库。

假设我们想写一个有 2 页的小应用程序。第一页将向我们展示一个狗品种的列表。当我们点击一个品种，我们将被重定向到这个品种的页面，这将显示该品种的狗的随机照片。该应用程序将如下所示(不要太担心代码或 UI，因为这超出了本文的范围) :

简单的应用示例

我们的应用程序可以工作，但我们还没有处理 404 案例。当用户访问一个不存在的页面时，我们希望向他们显示我们自己的 404 页面，并显示文本“Four:oh:four”。该页面应在以下两种情况下显示:

*   用户访问了一个无效的 URL 正则表达式(即`/cats/husky/`)。
*   用户访问了一个有效的 URL 正则表达式，但使用了一个无效的品种(如果用户从地址栏手动调整 URL，就会发生这种情况)。

第一种情况很容易处理。像大多数教程推荐的那样，我们将添加一条“无所不包”的路线作为我们应用程序的**最后一条路线**，并且我们将使用 react-router 的`<Switch />`组件包装我们所有的路线。这看起来会像这样:

包罗万象的路线

现在，每当用户输入一个除了`/`和`/dogs/<BREED>`之外的 URL，他们就会被重定向到 404 页面。

第二种情况有点难以处理，因为它依赖于我们的 API。我们事先不知道用户作为 URL 参数输入的品种是否有效，因为我们不知道世界上存在的所有品种(或者至少假设我们不知道)。为了显示 404 页面，我们必须等待服务器对我们返回的状态做出响应和反应(没有双关语的意思)。修改`<DogPage />`组件，如下所示:

检查 API 404s

通过存储响应代码，我们现在可以对其值做出反应，并呈现不同的组件。在上面的例子中，如果状态代码是 404，我们简单地呈现 404 页面。这种方法可以工作，但是如果你以前用过，我可以保证你遇到过问题。给你总结一下:

*   **在嵌套组件** 中处理 404 从顶层组件渲染`<Page404 />`很容易，但是如果这个组件在组件树的“深处”会发生什么？然后`<Page404 />`将作为父组件的一部分呈现，这意味着不仅*而不是*是全屏的，而且它还将允许许多其他组件与它一起呈现它们的 UI。
*   **重复代码&逻辑** 目前，我们已经在一个组件中处理了 404，但是我们应该为**我们所有的**有 API 调用的组件/页面都这样做。这意味着跨多个组件的大量重复代码。
*   **处理其他错误响应** 404 只是最常见的一个，但是我们应该可以对 401、403、500 等做同样的事情。这意味着我们应该添加**甚至更多的**代码&逻辑来处理那些情况。
*   **在组件
    外部进行 API 调用时，难以将状态作为属性传递**这里，API 调用在组件内部执行，但是在 redux 场景中，该 API 调用将发生在 thunk、saga 或 observable 内部。我们如何能够以一种干净、简单、一次性的非持久方式将它传递给我们的组件呢？

# “重定向”解决方案

人们做的最简单也是最常见的事情，就是简单地将用户重定向到一个呈现了`<Page404 />`的`/404` url。这是可行的，但是用户会失去他们所处的环境。他们看到一个 404 页面，但是他们最初访问的 URL 已经改变，所以当他们看到 404 时，他们不知道“哪个东西没有找到”。我们想要的是一个解决方案，其中 404 页面可以显示，而他们访问的原始 url 保持原样。

# “挂钩”解决方案

我们要采取的第一种方法是使用一个可重用的定制钩子，以避免必须将 API 状态代码的处理重写到每个组件中。这个钩子(在一个非常基本的实现中)看起来像这样:

可重复使用的用户查询展示

这样就可以很容易地在我们的`<DogPage />`组件中使用:

这解决了我们处理状态代码时的重复逻辑，但对于根据状态代码呈现错误页面的重复逻辑没有太大帮助。这仍然需要在每个组件中单独实现。此外，钩子在基于类的组件中是不可用的，所以如果你有一个旧的代码库，这可能会带来一个问题。

# “渲染道具”解决方案

为了与基于类的组件兼容并进一步减少重复代码的数量，render-props 组件可能会有所帮助。因此，使用我们之前创建的`useQuery`钩子，我们现在可以创建以下简化版本的渲染属性组件:

可重用查询组件

我们可以像这样在我们的`<DogPage />`组件中使用它:

现在，这个解决方案允许我们删除任何重复的逻辑，处理任何 HTTP 错误代码，与基于类的组件兼容，并且总体上有干净的代码。然而，我们唯一没有解决的事情是，我们如何确保`<Page404 />`在**隔离**中渲染。概括地说，404 页面是代替我们的 DogPage 组件呈现的，但是如果 DogPage 不是顶级组件，而是有许多其他祖先，会发生什么呢？那么 404 页面将作为整个 UI 的一部分，与其他组件一起呈现。

# “顶级状态”解决方案

为了解决最后一个问题，我们唯一的选择是在任何其他页面有机会呈现之前呈现 404 页面。为此，我们需要某种状态管理库，它将允许组件树中较低的组件通知顶级组件它应该显示一个错误页面(404、403、500 等。).为此，我们可以使用任何库，但是让我们使用内置的上下文 API。

我们需要的是一个组件，它将确保根据状态代码呈现正确的错误页面，并为任何组件提供一种方式来触发此行为(错误页面的显示)。为了实现它，我们将从创建一个高级组件开始，该组件将通过上下文公开所需的行为。看起来可能是这样的:

这个组件有点复杂，所以请确保阅读行内注释以获得更清晰的理解。

要使用这个组件，我们要用它包装我们的核心逻辑，如下所示:

此外，我们需要修改`useQuery`钩子，以便在返回错误状态代码时自动“触发”错误页面显示。这将意味着我们当地的州不再需要`statusCode`，因为它不是由`ErrorHandler`管理的。我们需要做的就是触发一个动作来设置错误状态代码。

最后，现在我们在`ErrorHandler`组件中有了错误处理，我们不再需要对组件中的错误状态做出反应。因此，我们的`<DogPage />`组件可以通过去掉任何状态检查来实现它的最终形式:

现在你有了一种集中错误处理的方法，通过一种简单的(钩子)、自动化的(不需要在任何未来的组件中处理)和可伸缩的方式(因为你可以在`ErrorHandler`中处理任何你需要的错误)。

# 通用解决方案(最后一个，我保证)

上面的解决方案工作得很好，但是它不能在所有的 React 项目中重用。事实是，当获取保持在 React 的边界内时，上面的方法工作得很好，但是当在 redux 世界中进行 API 调用时，它就变得乏味了。如何从 redux thunk 中触发`setErrorStatus`？你就是不能。您需要做的是触发一个改变 redux 状态的动作，并让`ErrorHandler`从 redux 状态中读取数据，但这将涉及大量样板代码。想象一下阿波罗也是如此。这将涉及到使用`apollo-link-state`和调度一个突变，仅仅是为了这个奇怪的状态代码更新。

考虑到这一点，让我们后退一步，想一想我们到底想要实现什么。我们希望将 URL 与状态代码联系起来，并根据附加到它们上面的代码的值来决定呈现什么。事实证明，通过利用一个我们中没有多少人使用的浏览器原生功能，这是非常容易的。

**当前位置的状态。**

在浏览器的本地历史 API 中，每个位置都有一个状态键，可以存储我们想要的任何东西。为什么不利用它来存储`statusCode`而不是本地状态呢？这种方法的好处是:

*   不需要进行状态清理，因为当您离开时，位置会发生变化，因此新位置具有干净的状态。
*   后退按钮会自动显示 404 页面，甚至不需要 API 请求(因为先前位置的状态存储在浏览器的历史堆栈中)。
*   正因为我们以强制的方式将状态分配给一个位置，所以我们可以很容易地将这种方法与任何状态管理库集成。
*   可配置性和可伸缩性极强，因为我们可以存储和处理任何我们想要的键(不仅仅是状态码)。这意味着我们还可以存储将作为道具传递给错误页面组件的数据。

考虑到这一点，我们可以简化我们的`ErrorHandler`:

我们系统中的任何模块(不管它是否存在于 React 中)都可以通过获取当前位置、向其添加状态并替换当前历史条目来将错误代码附加到页面上。为了展示这一点，我们将修改我们的`useQuery`来做到这一点:

这个解决方案的好处是`useQuery`钩子甚至不知道`ErrorHandler`组件的存在。它所做的只是作为副作用修改位置，以便将某个状态添加到当前的历史条目中。这意味着`ErrorHandler`和`useQuery`并不相互依赖，所以你可以将它们中的任何一个切换出来而不会有任何问题。此外，您可以在`ErrorHandler`中添加任何您想要的定制逻辑。例如，您可以添加一个您想要忽略其 404 错误的白名单查询列表，或者一个处理多个并发错误的策略。每个应用程序的需求都不同，因此这种特定的逻辑与您的业务紧密相关。

所以你有它。仅仅使用`ErrorHandler`和`useQuery`钩子，你现在就有了一个集中式的 API 错误处理模块。应该提到的是，如果你正在使用一个状态管理库，你很可能**不会**使用`useQuery`钩子。相反，作为 HTTP 获取逻辑的一部分，您必须手动触发`history.replace`,这因库而异。让我们看看在一些最流行的例子中你会如何处理这个问题:

# 对于 Redux 用户

要在 redux 中实现这个解决方案，您需要访问您的历史记录。有多种方法可以做到这一点，要么将历史记录作为参数传递给`createStore`函数并创建一个中间件，要么简单地利用 [connected-react-router](https://github.com/supasate/connected-react-router) ，它公开一个动作创建器来直接修改您的历史记录。只要用正确的参数启动这个动作，你就可以开始了！文档中已经详细介绍了如何做到这一点。

# 对于阿波罗用户

为了在 Apollo 客户机中处理这个问题，您需要利用 [apollo-link-error](https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-error) 并创建一个可以访问历史记录的错误链接，以便调用`history.replace`。最简单的方法是创建一个历史实例(如果使用`react-router`，则通过`createBrowserHistory`)并在链接中直接使用它。同一个实例需要传递给`<Router>`组件。如果您不想这样做，另一个选择是从`useHistory`钩子中读取历史，将其作为参数传递给客户端(需要在 react 组件中创建)，然后将其转发给错误链接。只有当您希望依靠路由器来提供历史实例时，才应该考虑后者，这将允许您为生产和测试环境保持相同的 Apollo 客户机(由于依赖注入)。

# 结束语

尽管我们在本文中编写的许多代码在最后都没有使用，但是有必要展示我在那里看到的许多方法的问题。这篇文章的目标是给你一个很好的方法来一劳永逸地处理所有 React 应用程序中的 API 错误。你现在可以忘记上下文，状态，重新渲染，钩子和所有的事情。处理 api 错误所需要的只是一个顶级组件，它读取当前位置的状态并做出相应的反应，再加上任何一种可以修改历史记录的中央“API 模块”。这个解决方案很好，不仅因为它没有强制组件耦合，还因为它非常抽象和通用，可以很容易地移植到任何框架中。到目前为止，这在我的大多数应用程序中运行良好，我真的很高兴，但我很想知道你的想法。最终解决方案的代码可以在[这里](https://codesandbox.io/s/determined-shaw-6kmjc?autoresize=1&fontsize=14&moduleview=1)找到:

请随时询问任何问题或推荐更好的方法来解决这个问题；我很高兴听到他们的消息。

非常感谢你的阅读！

*👋 ***嗨，我是***[***Aggelos***](https://aggelosarvanitakis.me/)***！如果你喜欢这个，可以考虑在推特上关注我或者*** [***中***](https://medium.com/@aggelosarvanitakis) **😀***