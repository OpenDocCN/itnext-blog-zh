<html>
<head>
<title>Create a squishy, responsive, cyberpunk button in Flutter with the responsive_styled_widget package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用responsive_styled_widget包在Flutter中创建一个黏糊糊的、有反应的赛博朋克按钮</h1>
<blockquote>原文：<a href="https://itnext.io/create-a-squishy-responsive-cyberpunk-button-in-flutter-590488b44a78?source=collection_archive---------4-----------------------#2021-02-28">https://itnext.io/create-a-squishy-responsive-cyberpunk-button-in-flutter-590488b44a78?source=collection_archive---------4-----------------------#2021-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi ju"><img src="../Images/d12337119967f3c1594bb3e4ec3c9e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*TiGBChu1cDR1NfTB4Su-og.gif"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">一个灵敏的赛博朋克按钮</figcaption></figure><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="kg kh l"/></div></figure><p id="cf1a" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">你想在Flutter中快速创建一个这样的按钮吗？它有圆角，四个不同的边界与四个梯度填充，一个梯度阴影，文字与不同的字母间距和阴影。此外，该按钮实际上是响应性的，具有自动高度和评估为max(屏幕宽度的50%，500px)的宽度。如果您将鼠标指针移到它上面，光标也会变成单击手势。下面是我能想到的一些使用Flutter out of the box来实现这一点的步骤。</p><ol class=""><li id="f74d" class="lg lh iq kk b kl km kp kq kt li kx lj lb lk lf ll lm ln lo bi translated">计算宽度并不难。使用MediaQuery获得屏幕宽度，然后做一些简单的数学运算就可以了。</li><li id="df7b" class="lg lh iq kk b kl lp kp lq kt lr kx ls lb lt lf ll lm ln lo bi translated">四个边框可以使用四个带有渐变填充的自定义画笔绘制。圆角可以使用带有圆角的容器小部件来实现。文本位置需要在点击后移动，所以你也需要计算移动。</li><li id="3ef3" class="lg lh iq kk b kl lp kp lq kt lr kx ls lb lt lf ll lm ln lo bi translated">目前的抖动阴影只使用单一颜色，所以为了实现这种渐变阴影，我们可以在按钮下堆叠一个带有图像过滤模糊的渐变容器。</li><li id="ffb7" class="lg lh iq kk b kl lp kp lq kt lr kx ls lb lt lf ll lm ln lo bi translated">使用MouseRegion小部件来实现鼠标光标的改变。</li></ol><p id="058c" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">使用CSS，你可以更容易地实现这个按钮样式，因为CSS支持响应长度单位，圆角加上不同颜色的边框，带有伪选择器和模糊的渐变阴影，等等。如果我们创建一个能够轻松实现Flutter中所有这些特性的小部件会怎么样？</p><p id="6f5f" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">首先，让我们处理一下响应性。我建议你看看这篇<a class="ae lu" href="https://kevinvan.medium.com/dimension-a-css-inspired-distance-calculating-package-for-flutter-e0604f62e707" rel="noopener">文章</a>，在那里我介绍了<a class="ae lu" href="https://pub.dev/packages/dimension" rel="noopener ugc nofollow" target="_blank">维度</a>包。简而言之，这个包允许您定义各种响应距离测量。</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="12c1" class="ma mb iq lw b gy mc md l me mf">///10% of the screen width<br/>var length = 10.toVWLength;<br/>///maximum of two lengths<br/>length = Dimension.max(10.toVWLength, 100.toPXLength);<br/>///nested expression with clamp, min, addition of lengths<br/>length = Dimension.clamp(100.toPXLength, 20.toPercentLength + 10.toPXLength, Dimension.min(500.toPXLength, 50.toVWLength));</span></pre><p id="2d22" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">使用此软件包，您可以精确控制想要使用的尺寸。使用style类描述小部件样式:</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="7e8c" class="ma mb iq lw b gy mc md l me mf">class Style {<br/>  bool? visible;<br/>  double? opacity;<br/><br/>  Alignment? alignment;<br/><br/>  Dimension? width;<br/>  Dimension? height;<br/><br/>  EdgeInsets? margin;<br/>  EdgeInsets? padding;<br/><br/>  BoxDecoration? backgroundDecoration;<br/>  BoxDecoration? foregroundDecoration;</span><span id="7270" class="ma mb iq lw b gy mg md l me mf">  List&lt;ShapeShadow&gt;? shadows;<br/>  List&lt;ShapeShadow&gt;? insetShadows;<br/>  MorphableShapeBorder? shapeBorder;<br/><br/>  SmoothMatrix4? transform;<br/>  Alignment? transformAlignment;<br/><br/>  Alignment? childAlignment;<br/>  DynamicTextStyle? textStyle;<br/>  TextAlign? textAlign;<br/><br/>  SystemMouseCursor? mouseCursor;<br/>}</span></pre><p id="0d8f" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">它非常类似于容器小部件使用的参数。然后可以使用StyleContainer小部件来构造最终的小部件:</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="c848" class="ma mb iq lw b gy mc md l me mf">Widget widget = StyledContainer(<br/>    style: style,<br/>    child: Text("Hello World")<br/>);</span></pre><p id="6792" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">还有AnimatedStyledContainer，它将在您提供的不同样式之间平滑地动画化，类似于AnimatedContainer小部件。</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="33c3" class="ma mb iq lw b gy mc md l me mf">Widget widget = GestureDetector(<br/>  onTapDown: (TapDownDetails details) {<br/>    setState(() {<br/>      toggleStyle = false;<br/>    });<br/>  },<br/>  onTapUp: (TapUpDetails details) {<br/>    setState(() {<br/>      toggleStyle = true;<br/>    });<br/>  },<br/>  child: AnimatedStyledContainer(<br/>      duration: Duration(milliseconds: 100),<br/>      style: toggleStyle ? beginStyle : endStyle,<br/>      child: Text("Hello World")),<br/>);</span></pre><p id="3826" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">当在开始样式和结束样式之间切换时，AnimatedStyledContainer将在它们之间平滑动画。请注意，由于样式可以是在不同屏幕尺寸下映射到不同样式的样式映射，因此如果您调整应用程序窗口的大小，动画也可能会触发。这就是一开始用来实现霓虹按钮的东西。</p><p id="b291" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">那么这个按钮的样式看起来怎么样呢？看起来是这样的:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="mh kh l"/></div></figure><p id="4363" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">乍一看可能有点长，但是大部分代码是用来配置这个按钮使用的四个边框和三个文本阴影的。</p><h1 id="92a8" class="mi mb iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">带转换的样式</h1><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="kg kh l"/></div></figure><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="kg kh l"/></div></figure><div class="jv jw jx jy gt ab cb"><figure class="nf jz ng nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/ee4f6e8abe955b7ba07908fa10991bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/1*Gx2Fa1ZV59an6tt_hj-l6w.gif"/></div></figure><figure class="nf jz np nh ni nj nk paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/4fd037be1ee16eb696c4a9d3d4ca4d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/1*w6NyKZeUWUOgd2W_psCVdA.gif"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk nq di nr ns translated">左:旋转变换。右图:内部阴影发光</figcaption></figure></div><p id="2396" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">您还可以使用SmoothMatrix4类在样式中插入转换。它与Flutter用来描述变换的Matrix4类有一个几乎相同的接口，但它只允许可以平滑动画化的变换(缩放、平移和旋转)。此外，它使用Dimension类来描述翻译，因此您可以编写如下内容:</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="1d17" class="ma mb iq lw b gy mc md l me mf">SmoothMatrix4()..translate(-100.toVWLength)</span></pre><p id="b168" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">以确保无论屏幕大小如何，动画总是在屏幕外开始。</p><h1 id="9623" class="mi mb iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">样式序列化/反序列化</h1><p id="f264" class="pw-post-body-paragraph ki kj iq kk b kl nt kn ko kp nu kr ks kt nv kv kw kx nw kz la lb nx ld le lf ij bi translated">如果你关注过我过去的文章，你会知道我发布的UI包都支持序列化。而这么做的原因就是为了这个<a class="ae lu" href="http://responsive_styled_widget" rel="noopener ugc nofollow" target="_blank">包</a>(名为responsive_styled_widget)。通过调用以下命令，可以很容易地将neon按钮样式序列化为JSON字符串:</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="ae4f" class="ma mb iq lw b gy mc md l me mf">style.toJson();</span></pre><p id="d794" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">其实风格图也可以序列化:</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="0709" class="ma mb iq lw b gy mc md l me mf">styles.toJson();</span></pre><p id="a01b" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">要取回样式/样式映射，请使用此函数:</p><pre class="jv jw jx jy gt lv lw lx ly aw lz bi"><span id="118f" class="ma mb iq lw b gy mc md l me mf">dynamic? parsePossibleStyleMap(Map&lt;String, dynamic&gt;? style);</span></pre><p id="f63c" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">这将为您提供单个样式或样式映射，您可以将它们插入StyledContainer小部件。</p><h1 id="e35d" class="mi mb iq bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">有什么意义？</h1><p id="b521" class="pw-post-body-paragraph ki kj iq kk b kl nt kn ko kp nu kr ks kt nv kv kw kx nw kz la lb nx ld le lf ij bi translated">你可能会认为这个样式表违反了Flutter的组成思想，并把我们带回了CSS，我同意你的观点。但是我认为这个样式表主要是由三个广泛使用的Flutter部件组成的:容器、DefaultTextStyle和Transform。我所做的是增加响应性(通过Dimension类和ScreenScope类)，边界和阴影的渐变着色，形状变形和可序列化。Style类包含了您可以设置的大多数UI样式，但是Flutter创建自定义UI的能力不会因为使用这个包而受到影响。如果你不喜欢样式表的想法，你仍然可以使用<a class="ae lu" href="https://pub.dev/packages/dimension" rel="noopener ugc nofollow" target="_blank"> dimension </a>包和<a class="ae lu" href="https://pub.dev/packages/morphable_shape" rel="noopener ugc nofollow" target="_blank"> morphable_shape </a>包来创建响应距离和各种形状边界。</p><p id="2008" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">我能想到的关于这个包的一些额外用例是:</p><ol class=""><li id="73b5" class="lg lh iq kk b kl km kp kq kt li kx lj lb lk lf ll lm ln lo bi translated">CSS样式的转换器。这个包支持各种CSS样式，如边距、填充、宽度、高度、背景装饰(颜色、渐变、图像)、边框样式、阴影、文本样式、变换。它还支持@media规则和维度计算，如(calc，min，max，clamp)。编写一个可以将一些复杂的CSS样式转换成Flutter的转换器应该是相当容易的。</li><li id="6a95" class="lg lh iq kk b kl lp kp lq kt lr kx ls lb lt lf ll lm ln lo bi translated">一个UI库。您可以生成一个想要使用的常见UI样式的列表，并将它们保存在JSON中，就像tailwind css正在做的那样。然后，您可以在应用程序中的任何地方重用这些样式。制作这些样式的动画很容易，因为您手边有AnimatedStyledContainer小部件(或者使用显式动画)。修改这些样式也很简单，因为Style类为您提供了copyWith和merge方法来快速生成新的样式。</li><li id="1297" class="lg lh iq kk b kl lp kp lq kt lr kx ls lb lt lf ll lm ln lo bi translated">如果你想更极端，你可以在整个框架中使用样式，给每个小部件一个id、一个类或其他选择器，并使用一个状态管理框架来提供所有的样式。然后Dart代码只提供javascript的功能。</li></ol><p id="d5b4" class="pw-post-body-paragraph ki kj iq kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ij bi translated">今天的文章就到这里。谢谢大家！</p></div></div>    
</body>
</html>