<html>
<head>
<title>Autoscale Kubeless Functions With Prometheus Adapter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Prometheus适配器的自动缩放无Kubeless功能</h1>
<blockquote>原文：<a href="https://itnext.io/autoscale-kubeless-functions-with-prometheus-adapter-f99507a23db6?source=collection_archive---------2-----------------------#2020-09-20">https://itnext.io/autoscale-kubeless-functions-with-prometheus-adapter-f99507a23db6?source=collection_archive---------2-----------------------#2020-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/49f2fde12deb0e115df26c2e34a4c695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wDk-IzFIKBL_TXN0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@alschim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexander Schimmeck </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6a82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为web生态系统的一部分，我们主要关心的是如何创建一个处理更多请求的应用程序，以及如何让它保持运行。我错了吗？</p><p id="9ed8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论你有什么，比如整体材料、微服务或功能，你都需要找到解决问题的方法。你可以在你的基础设施中添加一台新机器(请不要说，<em class="le">“ok boomer”</em>，我不是！)或者观看监控系统的操作，然后单击红色按钮:自动部署新实例并分流流量！或者，你可以在混乱之前创建你的规则，自动缩放，放松并享受它！</p><h1 id="85bf" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Kubernetes宇宙怎么样？</h1><p id="f3b7" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">如果你住在Kubernetes，它会帮助你处理与HorizontalPodAutoscaler的交易。你可以轻松地说<em class="le">“嘿！如果我的应用程序的内存/CPU消耗超过X，请添加新的Pod！”</em>如果您使用<strong class="ki iu">metric-server</strong>cluster add-on，您可以通过<code class="fe mi mj mk ml b">metrics.k8s.io</code> API获得这些值。</p><h2 id="020b" class="mm lg it bd lh mn mo dn ll mp mq dp lp kr mr ms lt kv mt mu lx kz mv mw mb mx bi translated">如果我的需求与CPU或内存消耗不同怎么办？</h2><p id="839f" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">例如，我想根据每分钟传入的请求来扩展我的应用程序。这是网络最自然的愿望，不是吗？或者，这是这个故事的主要目标，我想通过总调用计数来扩展我的功能。</p><p id="58c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们向<em class="le">自定义指标</em>问好。您可以创建您自己的定制适配器来收集您自己的指标，或者您可以使用<a class="ae kf" href="https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api" rel="noopener ugc nofollow" target="_blank">已知的解决方案</a>。在这条路的尽头，您用<code class="fe mi mj mk ml b">custom.metrics.k8s.io</code> API达到了这些值。</p><p id="4cea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在整个故事中，我们将使用<strong class="ki iu"> Prometheus Adapter </strong>作为已知的解决方案来收集<strong class="ki iu">kubless</strong>功能度量并自动缩放功能。</p><h1 id="8aba" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我们开始吧！</h1><p id="73d5" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在卷起袖子之前，我需要列出环境:</p><blockquote class="my mz na"><p id="2835" class="kg kh le ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">Kubernetes版本为<em class="it"> 1.16.13 </em></p><p id="5132" class="kg kh le ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">普罗米修斯版本是<em class="it"> 2.20.1 </em></p><p id="9020" class="kg kh le ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">无库版本是<em class="it"> 1.0.7 </em></p><p id="ae9d" class="kg kh le ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">头盔版本为<em class="it"> 2.16.1 </em></p><p id="14d3" class="kg kh le ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">普罗米修斯适配器版本为<em class="it"> 0.7.0 </em></p></blockquote><p id="6922" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">我假设您有一个现成的Kubernetes集群和Prometheus服务器。如果没有，网上有很多有用的文章可以帮助你设置它们。</em></p><h2 id="c9f8" class="mm lg it bd lh mn mo dn ll mp mq dp lp kr mr ms lt kv mt mu lx kz mv mw mb mx bi translated">在集群上安装Kubeless，创建你的第一个函数</h2><p id="ff07" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Kubeless是“功能即服务”——又名FaaS<em class="le"/>——框架。您可以用它在Kubernetes上构建FaaS应用程序。这是KNative和OpenFaaS解决方案的强大替代方案。</p><p id="93fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是故事中最短的部分。没有自定义的步骤来完成它。你可以按照说明去做，<a class="ae kf" href="https://kubeless.io/docs/quick-start/" rel="noopener ugc nofollow" target="_blank">就在这里</a>。同样，你可以用一个基本的UI来管理你的功能。<code class="fe mi mj mk ml b">kubectl create -f <a class="ae kf" href="https://raw.githubusercontent.com/kubeless/kubeless-ui/master/k8s.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kubeless/kubeless-ui/master/k8s.yaml</a></code>命令可以用来安装它。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/af04c097c033a2a5d80eea4cd5fff226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2G6cs8duBp_0Il2Td1T5w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">截图自Kubeless-UI</figcaption></figure><p id="1b8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">"如何在Kubeless上创建复杂的函数？"不是故事的一部分。所以我们不关注它。您可以按照<a class="ae kf" href="https://kubeless.io/docs/quick-start/" rel="noopener ugc nofollow" target="_blank">演练</a>来创建您的第一个函数。</p><h2 id="b8ac" class="mm lg it bd lh mn mo dn ll mp mq dp lp kr mr ms lt kv mt mu lx kz mv mw mb mx bi translated">安装Prometheus适配器</h2><p id="5387" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Prometheus adapter使用自定义规则从您的Kubernetes集群中收集自定义指标。您可以使用舵轮图以默认值安装它。但是；</p><ul class=""><li id="8a42" class="nj nk it ki b kj kk kn ko kr nl kv nm kz nn ld no np nq nr bi translated"><em class="le">如果您的Prometheus服务器没有运行在默认名称空间上，或者没有使用默认端口(9090)。</em></li><li id="0eab" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated"><em class="le">如果您想仅将它用于自定义指标(它可以作为metric-server的替代方案)。</em></li><li id="7165" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated"><em class="le">如果您想重新列出不同时间间隔内的指标(默认值为1分钟)。</em></li><li id="547b" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated"><em class="le">为了定义你的自定义规则(Prometheus查询来收集指标)。</em></li></ul><p id="9041" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你需要用你的变量来改变一些变量。</p><blockquote class="my mz na"><p id="437e" class="kg kh le ki b kj kk kl km kn ko kp kq nb ks kt ku nc kw kx ky nd la lb lc ld im bi translated">图表库中的<a class="ae kf" href="https://github.com/helm/charts/issues/20557" rel="noopener ugc nofollow" target="_blank">有问题</a>。当您使用<code class="fe mi mj mk ml b"><em class="it">--set-file</em></code>参数将您的定制规则文件传递给<code class="fe mi mj mk ml b"><em class="it">helm install</em></code>命令时，它会放置管道符号(|)并破坏生成的模板。所以我们将克隆它(<code class="fe mi mj mk ml b"><em class="it">git clone https://github.com/helm/charts.git</em></code>)并修改<a class="ae kf" href="https://github.com/prometheus-community/helm-charts/blob/main/charts/prometheus-adapter/templates/custom-metrics-configmap.yaml" rel="noopener ugc nofollow" target="_blank">这个文件</a>。你得把<code class="fe mi mj mk ml b"><em class="it">toYaml</em></code>功能换成<code class="fe mi mj mk ml b"><em class="it">tpl</em></code>。比如说；<code class="fe mi mj mk ml b"><em class="it">{{toYaml .Values.rules.custom | indent 4 }}</em></code>必须是<code class="fe mi mj mk ml b"><em class="it">{{tpl .Values.rules.custom . | indent 4 }}</em></code>。</p></blockquote><p id="b6a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kubeless将函数的总调用作为一个度量来公开。它被命名为<code class="fe mi mj mk ml b">function_calls_total</code>，作为一个计数器工作。当你的第一个电话打来时，它就开始计数了。当然，它提供了更多的指标，但我们将把它用于自动缩放功能。</p><p id="e07e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目的是在最后一分钟得到总呼叫数。普罗米修斯这边的对等物是:<code class="fe mi mj mk ml b">sum(increase(function_calls_total{kubernetes_namespace="kubeless-fn",function!="",kubernetes_pod_name!=""}[1m])) by (kubernetes_namespace,kubernetes_pod_name,function)</code></p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/e327093a31d4fcfbfb3c781d6ab7e4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3W5_Hm7xNVsUrnnUhkzZaw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">查询的输出</figcaption></figure><p id="66df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在适配器中使用查询，让我们定义我们的规则:</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6253" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并保存为<em class="le"> custom-rule.yaml </em>。</p><p id="4638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，你的文件夹结构应该是这样的；</p><p id="5b82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> &gt;图表<br/> |_。circleci <br/> |_。github<br/>…<br/>&gt;custom-rule . YAML</em></p><p id="3492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在文件夹中运行下面的脚本并生成yaml文件。它将用于设置Prometheus适配器。</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="49ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们的普罗米修斯服务器运行在 <code class="fe mi mj mk ml b"><em class="le">monitoring</em></code> <em class="le">命名空间上。</em></p><p id="b26d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，运行它:<code class="fe mi mj mk ml b">kubectl apply -f 1-install-prometheus-adapter.yaml</code></p><p id="eabc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几分钟后，我们检查适配器是否可以到达定制的度量API:<code class="fe mi mj mk ml b">kubectl logs kubeless-adapter-prometheus-adapter-[RS_RANDOM_STRING]-[POD_ID] -c prometheus-adapter</code>。如果一切正常，您将不会看到任何错误。</p><h2 id="a437" class="mm lg it bd lh mn mo dn ll mp mq dp lp kr mr ms lt kv mt mu lx kz mv mw mb mx bi translated">创建虚拟指标</h2><p id="a345" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在我们收集指标之前，我们将多次调用该函数。您可以将您的函数公开为带有入口对象的服务，但是对于测试场景，我们将使用<code class="fe mi mj mk ml b">port-forward</code>选项:<code class="fe mi mj mk ml b">kubectl port-forward -n kubeless-fn get-python-[RS_RANDOM_STRING]-[POD_ID] 8080:8080</code></p><p id="119f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后你可以使用这个脚本来调用你的函数:<code class="fe mi mj mk ml b">while true;do sleep 0.3;curl "http://localhost:8080";done</code>。你的函数一分钟大概会被调用90~100次。</p><p id="540e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一分钟后检查API结果:<code class="fe mi mj mk ml b">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1/namespaces/kubeless-fn/pods/*/calls_total_per_minute" &gt; api-result.json</code>。输出应该是这样的；</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="582e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">value</code>田说；<code class="fe mi mj mk ml b"><em class="le">get-python</em></code> <em class="le">功能每分钟被调用91.6次！</em></p><p id="27f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有多个功能，每个功能的指标都会显示在那里。</p><h2 id="09a9" class="mm lg it bd lh mn mo dn ll mp mq dp lp kr mr ms lt kv mt mu lx kz mv mw mb mx bi translated">定义HPA对象</h2><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c33e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想用这个宣言说:<em class="le">如果</em> <code class="fe mi mj mk ml b"><em class="le">get-python</em></code> <em class="le">部署的每分钟总调用数超过20，则向上扩展应用程序，直到副本数达到20。</em></p><p id="b2e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据上面的输出(91.6)，副本数应该是5 ( <code class="fe mi mj mk ml b">Math.round(91.6 / 20)</code>)。用这个命令检查结果:<code class="fe mi mj mk ml b">kubectl describe hpa -n kubeless-fn get-python-hpa</code></p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/e89edba686d7354393474b98c413d6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwWJ37qGjj81g0g-uRDeSA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">扩大规模</figcaption></figure><p id="2ade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，停止你的<code class="fe mi mj mk ml b">while…</code>命令，等待几分钟。当您重新运行<code class="fe mi mj mk ml b">describe</code>命令时，您将在pods: 0 / 20  输出上看到<strong class="ki iu"><em class="le">“calls _ total _ per _ minute”。此外，您将看到所需的副本数量没有改变！</em></strong></p><p id="6d02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是关于稳定窗口的。Kubernetes <a class="ae kf" href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#stabilization-window" rel="noopener ugc nofollow" target="_blank">文档</a>说；</p><blockquote class="ob"><p id="9f78" class="oc od it bd oe of og oh oi oj ok ld dk translated">当用于缩放的度量保持波动时，稳定窗口用于限制副本的摆动。自动缩放算法使用稳定窗口来考虑从过去计算的期望状态，以防止缩放。</p></blockquote><p id="09b5" class="pw-post-body-paragraph kg kh it ki b kj ol kl km kn om kp kq kr on kt ku kv oo kx ky kz op lb lc ld im bi translated">默认值为300秒/5分钟。如果你在5分钟后运行<code class="fe mi mj mk ml b">describe</code>命令，你会看到期望的计数下降了:</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/d255ae7171d7a8e8b715eb406a2245e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sxOqUlrpdTSbYhdUKpCdg.png"/></div></div></figure><p id="b99d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是时候躺下来享受了。</p><p id="7d42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢大家！</p></div></div>    
</body>
</html>