<html>
<head>
<title>How It Works — kubectl exec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作原理— kubectl exec</h1>
<blockquote>原文：<a href="https://itnext.io/how-it-works-kubectl-exec-e31325daa910?source=collection_archive---------0-----------------------#2020-01-30">https://itnext.io/how-it-works-kubectl-exec-e31325daa910?source=collection_archive---------0-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f74a13ffb188f74c0362a464dec5da66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lb4hCN0SraUuG50ds2ocag.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">“kubectl exec”如何工作</figcaption></figure><div class=""/><p id="8e59" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你有兴趣了解<code class="fe ld le lf lg b">kubectl exec</code>是如何工作的，那么我希望这篇文章对你有用。我们将通过检查kubectl、K8s API服务器、Kubelet和容器运行时接口(CRI) Docker API中的相关代码来研究该命令是如何工作的。</p><h1 id="0e2c" class="lh li ji bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">关于此命令</h1><p id="f3e1" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">对于我们这些经常在Kubernetes上处理容器化工作负载的人来说,<code class="fe ld le lf lg b">kubectl exec</code>命令是一个非常有用的工具。它允许我们通过执行容器内部的命令来检查<em class="mk"> </em>和调试我们的应用程序<em class="mk"> </em>。</p><p id="3fc3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们用<code class="fe ld le lf lg b">kubectl</code> v1.15.0运行一个例子:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">` kubectl exec '示例</figcaption></figure><p id="e05a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个<code class="fe ld le lf lg b">exec</code>命令在我的Nginx容器中运行一个<code class="fe ld le lf lg b">date</code>命令。第二个<code class="fe ld le lf lg b">exec</code>命令使用<code class="fe ld le lf lg b">-i</code>和<code class="fe ld le lf lg b">-t</code>标志来获取我的Nginx容器的shell。</p><h1 id="592d" class="lh li ji bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">CLI代码</h1><p id="e8c2" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">让我们以更高的日志详细度重复该命令:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">带有详细输出的“kubectl exec”</figcaption></figure><p id="2831" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，有两个HTTP请求:</p><ol class=""><li id="1990" class="mr ms ji kh b ki kj km kn kq mt ku mu ky mv lc mw mx my mz bi translated">一个<code class="fe ld le lf lg b">GET</code>请求<a class="ae na" href="https://github.com/kubernetes/kubectl/blob/4f155a6381d3caaf46f37df8e575abdad9b24b3f/pkg/cmd/exec/exec.go#L287-L306" rel="noopener ugc nofollow" target="_blank">获取pod </a></li><li id="73cf" class="mr ms ji kh b ki nb km nc kq nd ku ne ky nf lc mw mx my mz bi translated">一个<code class="fe ld le lf lg b">POST</code>请求<a class="ae na" href="https://github.com/kubernetes/kubectl/blob/4f155a6381d3caaf46f37df8e575abdad9b24b3f/pkg/cmd/exec/exec.go#L345-L349" rel="noopener ugc nofollow" target="_blank">到</a>吊舱的 <code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubectl/blob/4f155a6381d3caaf46f37df8e575abdad9b24b3f/pkg/cmd/exec/exec.go#L345-L349" rel="noopener ugc nofollow" target="_blank">exec</a></code> <a class="ae na" href="https://github.com/kubernetes/kubectl/blob/4f155a6381d3caaf46f37df8e575abdad9b24b3f/pkg/cmd/exec/exec.go#L345-L349" rel="noopener ugc nofollow" target="_blank">子资源。</a></li></ol><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/4ddc607e6b69e9f0ab5fc076bdf66377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsL6SwCQltvreWGmOSUx-g.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://kubernetes.io/docs/reference/using-api/api-concepts/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/reference/using-API/API-concepts/</a></figcaption></figure><p id="f931" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">服务器以101 <code class="fe ld le lf lg b">Upgrade</code>响应报头响应，向客户端指示它已经切换到SPDY协议。</p><h1 id="18b1" class="lh li ji bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">API服务器代码</h1><p id="4f4a" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">让我们检查API服务器的代码，看看它是如何注册<code class="fe ld le lf lg b">rest.ExecRest</code>处理程序来处理<code class="fe ld le lf lg b">/exec</code>子资源请求的。这个处理程序用来确定<code class="fe ld le lf lg b">exec</code>要到达的节点端点。</p><p id="f28d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/324b5921c1ae9b76acc074e0dfb116c0266ca1e5/cmd/kube-apiserver/app/server.go#L214-L222" rel="noopener ugc nofollow" target="_blank">启动</a>时，API服务器所做的事情之一是指示其嵌入的<code class="fe ld le lf lg b">GenericAPIServer</code>安装“遗留”API:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/324b5921c1ae9b76acc074e0dfb116c0266ca1e5/pkg/master/master.go#L364-L366" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/324 b 5921 C1 AE 9 b 76 ACC 074 E0 DFB 116 c 0266 ca1e 5/pkg/master/master . go # L364-L366</a></figcaption></figure><p id="e8c1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在API安装过程中，<code class="fe ld le lf lg b">LegacyRESTStorage</code>类型的一个实例被<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/324b5921c1ae9b76acc074e0dfb116c0266ca1e5/pkg/master/master.go#L450-L453" rel="noopener ugc nofollow" target="_blank">实例化</a>，这就创建了一个<code class="fe ld le lf lg b">storage.PodStorage</code>实例:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1934ad6a9cde42e6d92054f9cff1e4d101005ffc/pkg/registry/core/rest/storage_core.go#L171-L179" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/1934 ad 6 a9 CDE 42 e6d 92054 f 9 CFF 1 E4 d 101005 ffc/pkg/registry/core/rest/storage _ core . go # L171-L179</a></figcaption></figure><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/4239555a88bb831f1a72678826cbaf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEf6XL7wF4IYHl9LiWp-xg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/apiserver/blob/d65a85b44b2088665850402025c97aa9f6f32ba4/pkg/registry/generic/registry/store.go#L72-L77" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/API server/blob/master/pkg/registry/generic/registry/store . go # L72-L77</a></figcaption></figure><p id="204c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后这个<code class="fe ld le lf lg b">storage.PodStorage</code>实例被添加到<code class="fe ld le lf lg b">restStorageMap</code>地图中。注意，在这个映射中，<code class="fe ld le lf lg b">pods/exec</code>路径被映射到<code class="fe ld le lf lg b">podStorage</code>的<code class="fe ld le lf lg b">rest.ExecRest</code>处理程序:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1934ad6a9cde42e6d92054f9cff1e4d101005ffc/pkg/registry/core/rest/storage_core.go#L271-L280" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/1934 ad 6 a9 CDE 42 e6d 92054 f 9 CFF 1 E4 d 101005 ffc/pkg/registry/core/rest/storage _ core . go # L271-L280</a></figcaption></figure><p id="0020" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后这个映射成为一个<code class="fe ld le lf lg b">apiGroupInfo</code>实例的一部分，这个实例被添加到<code class="fe ld le lf lg b">GenericAPIServer</code>:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/apiserver/blob/8ebac2550a3117540987649ada8d78cd13366f6b/pkg/server/genericapiserver.go#L433-L439" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/API server/blob/8 ebac 2550 a 3117540987649 ada 8d 78 CD 13366 f6b/pkg/server/generica piserver . go # L433-L439</a></figcaption></figure><p id="7730" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">GoRestfulContainer</code> <a class="ae na" href="https://github.com/kubernetes/apiserver/blob/8ebac2550a3117540987649ada8d78cd13366f6b/pkg/server/handler.go#L79-L87" rel="noopener ugc nofollow" target="_blank">有一个</a> <code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/apiserver/blob/8ebac2550a3117540987649ada8d78cd13366f6b/pkg/server/handler.go#L79-L87" rel="noopener ugc nofollow" target="_blank">ServeMux</a></code>，它知道如何将传入的请求URL映射到不同的处理程序。</p><p id="6ae5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们仔细看看<code class="fe ld le lf lg b">rest.ExecRest</code>处理程序是如何工作的。它的<code class="fe ld le lf lg b">Connect()</code>方法调用<code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1934ad6a9cde42e6d92054f9cff1e4d101005ffc/pkg/registry/core/pod/strategy.go#L463-L473" rel="noopener ugc nofollow" target="_blank">pod.ExecLocation()</a></code>函数来确定pod容器的<code class="fe ld le lf lg b">exec</code>子资源URL:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1590c7b31cb40259397ccef602b6d6dc2a9f9d72/pkg/registry/core/pod/rest/subresources.go#L133-L144" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/1590 c 7 b 31 CB 40259397 ccef 602 b 6d 6 DC 2 a 9 F9 d 72/pkg/registry/core/pod/rest/sub resources . go # L133-L144</a></figcaption></figure><p id="f253" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由<code class="fe ld le lf lg b">pod.ExecLocation()</code>函数返回的<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1934ad6a9cde42e6d92054f9cff1e4d101005ffc/pkg/registry/core/pod/strategy.go#L524-L529" rel="noopener ugc nofollow" target="_blank"> URL </a>被API服务器用来确定连接到哪个节点。</p><p id="7c00" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在让我们来看看Kubelet代码。</p><h1 id="f9f2" class="lh li ji bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">库伯莱特密码</h1><p id="edd7" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">Kubelet如何注册它的<code class="fe ld le lf lg b">exec</code>处理程序？它和Docker API的交互是什么样子的？</p><p id="ef05" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Kubelet初始化过程非常复杂。以下两项职能与本职位最相关:</p><ol class=""><li id="46e0" class="mr ms ji kh b ki kj km kn kq mt ku mu ky mv lc mw mx my mz bi translated"><code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L760-L769" rel="noopener ugc nofollow" target="_blank">PreInitRuntimeService</a>()</code>使用<code class="fe ld le lf lg b">dockershim</code>包初始化CRI</li><li id="bcd2" class="mr ms ji kh b ki nb km nc kq nd ku ne ky nf lc mw mx my mz bi translated"><code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L771-L773" rel="noopener ugc nofollow" target="_blank">RunKubelet</a>()</code>注册处理程序并启动服务器</li></ol><h2 id="7e35" class="ni li ji bd lj nj nk dn ln nl nm dp lr kq nn no lv ku np nq lz ky nr ns md nt bi translated">设置处理程序</h2><p id="a9f8" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">当Kubelet启动时，它的<code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L1043-L1048" rel="noopener ugc nofollow" target="_blank">RunKubelet()</a></code>函数调用未导出的<code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L1125" rel="noopener ugc nofollow" target="_blank">startKubelet()</a></code>函数到<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L1131-L1135" rel="noopener ugc nofollow" target="_blank">启动<code class="fe ld le lf lg b">kubelet.Kubelet</code>实例的</a> <code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L1131-L1135" rel="noopener ugc nofollow" target="_blank">ListenAndServe</a>()</code> <a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/9162c5d7f4a91213f258243119d484fbc3fc1c93/cmd/kubelet/app/server.go#L1131-L1135" rel="noopener ugc nofollow" target="_blank">方法</a>。该方法然后<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1590c7b31cb40259397ccef602b6d6dc2a9f9d72/pkg/kubelet/kubelet.go#L2226-L2229" rel="noopener ugc nofollow" target="_blank">调用</a> <code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1590c7b31cb40259397ccef602b6d6dc2a9f9d72/pkg/kubelet/kubelet.go#L2226-L2229" rel="noopener ugc nofollow" target="_blank">ListenAndServeKubeletServer</a>()</code> <a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1590c7b31cb40259397ccef602b6d6dc2a9f9d72/pkg/kubelet/kubelet.go#L2226-L2229" rel="noopener ugc nofollow" target="_blank">函数</a>，该函数使用<code class="fe ld le lf lg b">NewServer()</code>构造函数来安装“调试”处理程序:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/be26fbc638ff5ed952ccae70e68baa712b3c60c8/pkg/kubelet/server/server.go#L234-L241" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/be 26 FBC 638 ff 5 ed 952 ccae 70 e 68 baa 712 B3 c 60 c 8/pkg/kube let/server/server . go # L234-L241</a></figcaption></figure><p id="1156" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">InstallDebuggingHandlers()</code>函数向<code class="fe ld le lf lg b">getExec()</code>处理程序注册HTTP请求模式:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/be26fbc638ff5ed952ccae70e68baa712b3c60c8/pkg/kubelet/server/server.go#L375-L390" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/be 26 FBC 638 ff 5 ed 952 ccae 70 e 68 baa 712 B3 c 60 c 8/pkg/kube let/server/server . go # L375-L390</a></figcaption></figure><p id="8267" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">getExec()</code>处理程序调用<code class="fe ld le lf lg b">s.host</code>实例的<code class="fe ld le lf lg b">GetExec()</code>方法:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/be26fbc638ff5ed952ccae70e68baa712b3c60c8/pkg/kubelet/server/server.go#L733-L738" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/be 26 FBC 638 ff 5 ed 952 ccae 70 e 68 baa 712 B3 c 60 c 8/pkg/kube let/server/server . go # L733-L738</a></figcaption></figure><p id="a4c9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">s.host</code>被实例化为<code class="fe ld le lf lg b">kubelet.Kubelet</code>类型的一个实例。它有一个对<code class="fe ld le lf lg b">StreamingRuntime</code> <a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1590c7b31cb40259397ccef602b6d6dc2a9f9d72/pkg/kubelet/container/runtime.go#L120-L127" rel="noopener ugc nofollow" target="_blank">接口</a>的嵌套引用，接口被<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/1590c7b31cb40259397ccef602b6d6dc2a9f9d72/pkg/kubelet/kubelet.go#L683-L710" rel="noopener ugc nofollow" target="_blank">实例化为<code class="fe ld le lf lg b">kubeGenericRuntimeManager </code>实例。这个运行时管理器是与Docker API交互的关键组件。它实现了<code class="fe ld le lf lg b">GetExec()</code>方法:</a></p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/4e45328e651abaf0ca72dfd37d132f96599c7161/pkg/kubelet/kuberuntime/kuberuntime_container.go#L771-L787" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/4e 45328 e 651 abaf 0 ca 72 DFD 37d 132 f 96599 c 7161/pkg/kube lett/kuberuntime/kuberuntime _ container . go # L771-L787</a></figcaption></figure><p id="8388" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个方法调用<code class="fe ld le lf lg b">runtimeService.Exec()</code>方法。经过进一步调查，我们发现<code class="fe ld le lf lg b">runtimeService</code>是CRI包中定义的一个<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/4e45328e651abaf0ca72dfd37d132f96599c7161/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L116" rel="noopener ugc nofollow" target="_blank">接口</a>。<code class="fe ld le lf lg b">kuberuntime.kubeGenericRuntimeManager</code>的<code class="fe ld le lf lg b">runtimeService</code>对象被实例化为<code class="fe ld le lf lg b">kuberuntime.instrumentedRuntimeService</code>类型，它实现了<code class="fe ld le lf lg b">runtimeService.Exec()</code>方法:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/f4db8212be53c69a27d893d6a4111422fbce8008/pkg/kubelet/kuberuntime/instrumented_services.go#L161-L168" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/f4db 8212 be 53 c 69 a 27d 893 d6a 4111422 fbce 8008/pkg/kube let/kuberuntime/instrumented _ services . go # L161-L168</a></figcaption></figure><p id="1e16" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，该<code class="fe ld le lf lg b">instrumentedRuntimeService</code>实例的嵌套<code class="fe ld le lf lg b">service</code>对象被<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/962a61f51fc2cd7c9a6784ed59b37a09f5c3d801/pkg/kubelet/kubelet.go#L392-L394" rel="noopener ugc nofollow" target="_blank">实例化为<code class="fe ld le lf lg b">remote.RemoteRuntimeService</code>类型的实例。这个类型拥有一个<code class="fe ld le lf lg b">Exec()</code>方法:</a></p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/962a61f51fc2cd7c9a6784ed59b37a09f5c3d801/pkg/kubelet/remote/remote_runtime.go#L366-L384" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/962 a61 f 51 fc 2 CD 7 C9 a 6784 ed 59 b 37 a 09 F5 C3 d 801/pkg/kube let/remote/remote _ runtime . go # L366-L384</a></figcaption></figure><p id="83e3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个<code class="fe ld le lf lg b">Exec()</code>方法向<code class="fe ld le lf lg b">/runtime.v1alpha2.RuntimeService/Exec</code>端点发出一个<a class="ae na" href="https://github.com/kubernetes/cri-api/blob/master/pkg/apis/runtime/v1alpha2/api.pb.go#L7446-L7453" rel="noopener ugc nofollow" target="_blank"> GRPC调用</a>，以准备一个将用于执行容器中命令的流端点。(有关将Docker shim设置为GRPC服务器的更多信息，请参见下一小节<em class="mk">设置Docker shim </em>。)</p><p id="43c5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">GRPC服务器<a class="ae na" href="https://github.com/kubernetes/cri-api/blob/de6519080ceb33d843ca275a9d8a8cd016558ad8/pkg/apis/runtime/v1alpha2/api.pb.go#L7927-L7943" rel="noopener ugc nofollow" target="_blank">通过调用<code class="fe ld le lf lg b">RuntimeServiceServer.Exec()</code>方法来处理</a>这个问题。该方法由<code class="fe ld le lf lg b">dockershim.dockerService</code>结构实现:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/579e0c74c150085b3fac01f6a33b66db96922f93/pkg/kubelet/dockershim/docker_streaming.go#L105-L115" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/579 E0 c74c 150085 B3 fac 01 f 6a 33 b 66 db 96922 f 93/pkg/kube let/docker shim/docker _ streaming . go # L105-L115</a></figcaption></figure><p id="291a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第10行的<code class="fe ld le lf lg b">streamingServer</code>是一个<code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/d24fe8a801748953a5c34fd34faa8005c6ad1770/pkg/kubelet/server/streaming/server.go#L42-L60" rel="noopener ugc nofollow" target="_blank">streaming.Server</a></code>接口。它在<code class="fe ld le lf lg b">dockershim.NewDockerService()</code>构造函数中被实例化:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/579e0c74c150085b3fac01f6a33b66db96922f93/pkg/kubelet/dockershim/docker_service.go#L225-L232" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/579 E0 c74c 150085 B3 fac 01 f 6a 33 b 66 db 96922 f 93/pkg/kube let/docker shim/docker _ service . go # L225-L232</a></figcaption></figure><p id="aacd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们看看它的<code class="fe ld le lf lg b">GetExec()</code>方法的实现:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/d24fe8a801748953a5c34fd34faa8005c6ad1770/pkg/kubelet/server/streaming/server.go#L179-L190" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/d 24 Fe 8a 801748953 a5c 34 FD 34 FAA 8005 c 6 ad 1770/pkg/kube let/server/streaming/server . go # L179-L190</a></figcaption></figure><p id="e0b0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是构建流端点并将其返回给GRPC客户端的地方。</p><p id="b37e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如上所述，<code class="fe ld le lf lg b">restful.WebService</code>实例然后将pod <code class="fe ld le lf lg b">exec</code>请求路由到这个端点。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/be26fbc638ff5ed952ccae70e68baa712b3c60c8/pkg/kubelet/server/server.go#L375-L390" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/be 26 FBC 638 ff 5 ed 952 ccae 70 e 68 baa 712 B3 c 60 c 8/pkg/kube let/server/server . go # L375-L390</a></figcaption></figure><h2 id="5c99" class="ni li ji bd lj nj nk dn ln nl nm dp lr kq nn no lv ku np nq lz ky nr ns md nt bi translated">设置Docker垫片</h2><p id="ed94" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated"><code class="fe ld le lf lg b">PreInitRuntimeService()</code>函数<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/63df40077862c378dd0e7d22a1dc5d2557000694/pkg/kubelet/kubelet.go#L355-L361" rel="noopener ugc nofollow" target="_blank">创建并启动</a>Docker shim，作为<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/ae95a4bfcac12bf6b19e2d5acf6404359b1a8c3b/pkg/kubelet/dockershim/remote/docker_server.go#L64-L70" rel="noopener ugc nofollow" target="_blank">GRPC服务器</a>。在实例化<code class="fe ld le lf lg b">dockershim.dockerService</code>类型的实例时，其嵌套的<code class="fe ld le lf lg b">streamingRuntime</code>实例被赋予了对<code class="fe ld le lf lg b">dockershim.NativeExecHandler</code>实例的引用，该实例实现了<code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/63df40077862c378dd0e7d22a1dc5d2557000694/pkg/kubelet/dockershim/exec.go#L33-L36" rel="noopener ugc nofollow" target="_blank">dockershim.ExecHandler</a></code>接口:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/63df40077862c378dd0e7d22a1dc5d2557000694/pkg/kubelet/dockershim/docker_service.go#L207-L210" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/63df 40077862 c 378 DD 0 e 7d 22 a1 dc5d 2557000694/pkg/kube let/docker shim/docker _ service . go # L203-L216</a></figcaption></figure><p id="61af" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">NativeExecHandler.ExecInContainer()</code>方法是使用Docker的<code class="fe ld le lf lg b">exec</code> API在容器中执行命令的关键:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/63df40077862c378dd0e7d22a1dc5d2557000694/pkg/kubelet/dockershim/exec.go#L97-L108" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/63df 40077862 c 378 DD 0 e 7d 22 a1 dc5d 2557000694/pkg/kube let/docker shim/exec . go # L97-L108</a></figcaption></figure><p id="bfe8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最终，这是Kubelet调用Docker <code class="fe ld le lf lg b">exec</code> API的地方。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="da71" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要的最后一块拼图是弄清楚<code class="fe ld le lf lg b">streamingServer</code>如何处理<code class="fe ld le lf lg b">exec</code>的请求。为此，我们需要找到它的<code class="fe ld le lf lg b">exec</code>处理程序。让我们从<code class="fe ld le lf lg b">streaming.NewServer()</code>构造函数开始。这是<code class="fe ld le lf lg b">/exec/{token}</code>路径绑定到<code class="fe ld le lf lg b">serveExec</code>处理程序的地方:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/d24fe8a801748953a5c34fd34faa8005c6ad1770/pkg/kubelet/server/streaming/server.go#L125-L133" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/d 24 Fe 8a 801748953 a5c 34 FD 34 FAA 8005 c 6 ad 1770/pkg/kube let/server/streaming/server . go # L125-L133</a></figcaption></figure><p id="348b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有发送到<code class="fe ld le lf lg b">dockershim.dockerService</code>实例的<code class="fe ld le lf lg b">exec</code>请求都将在<code class="fe ld le lf lg b">streamingServer</code>结束，因为<code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/579e0c74c150085b3fac01f6a33b66db96922f93/pkg/kubelet/dockershim/docker_service.go#L456-L462" rel="noopener ugc nofollow" target="_blank">dockerService.ServeHTTP()</a></code>方法调用了<code class="fe ld le lf lg b">streamingServer</code>实例的<code class="fe ld le lf lg b">ServeHTTP()</code>方法。</p><p id="e885" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">serveExec</code>处理程序<a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/d24fe8a801748953a5c34fd34faa8005c6ad1770/pkg/kubelet/server/streaming/server.go#L285-L297" rel="noopener ugc nofollow" target="_blank">调用</a> <code class="fe ld le lf lg b"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/d24fe8a801748953a5c34fd34faa8005c6ad1770/pkg/kubelet/server/streaming/server.go#L285-L297" rel="noopener ugc nofollow" target="_blank">remoteCommand.ServeExec</a>()</code> <a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/d24fe8a801748953a5c34fd34faa8005c6ad1770/pkg/kubelet/server/streaming/server.go#L285-L297" rel="noopener ugc nofollow" target="_blank">函数</a>。这个函数是做什么的？它调用了我们之前讨论过的<code class="fe ld le lf lg b">Executor.ExecInContainer()</code>方法。记住，<code class="fe ld le lf lg b">ExecInContainer()</code>方法是知道如何与Docker <code class="fe ld le lf lg b">exec</code> API对话的方法:</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae na" href="https://github.com/kubernetes/kubernetes/blob/6ecdd22978783ea51efc34f56f13eb4d9baa446a/pkg/kubelet/server/remotecommand/exec.go#L52-L77" rel="noopener ugc nofollow" target="_blank">https://github . com/kubernetes/kubernetes/blob/6 ecdd 22978783 ea 51 EFC 34 f 56 f 13 EB 4d 9 baa 446 a/pkg/kube let/server/remote command/exec . go # L52-L77</a></figcaption></figure><h1 id="1d8e" class="lh li ji bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="848d" class="pw-post-body-paragraph kf kg ji kh b ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky mj la lb lc im bi translated">在这篇文章中，我们通过检查kubectl、K8s API服务器、Kubelet和CRI Docker API的代码，了解了<code class="fe ld le lf lg b">kubectl exec</code>命令是如何工作的。</p><p id="5e3b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们没有介绍Docker <code class="fe ld le lf lg b">exec</code> API的细节，也没有介绍<code class="fe ld le lf lg b">docker exec</code>是如何工作的。</p><p id="d413" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">kubectl CLI向K8s API服务器发出了一个<code class="fe ld le lf lg b">GET</code>和<code class="fe ld le lf lg b">POST</code>请求。作为响应，服务器向客户端发送了一个101 <code class="fe ld le lf lg b">Upgrade</code>头，指示切换到SPDY协议。</p><p id="edf2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">K8s API服务器使用<code class="fe ld le lf lg b">storage.PodStorage</code>和<code class="fe ld le lf lg b">rest.ExecRest</code>来提供处理程序映射和逻辑。<code class="fe ld le lf lg b">rest.ExecRest</code>处理程序将<code class="fe ld le lf lg b">exec</code>的节点端点确定为。</p><p id="9f24" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Kubelet从Docker shim请求一个流端点，并将<code class="fe ld le lf lg b">exec</code>请求转发给Docker <code class="fe ld le lf lg b">exec</code> API。</p><p id="9824" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然这篇文章只关注了<code class="fe ld le lf lg b">exec</code>命令，但是值得注意的是，其他命令如<code class="fe ld le lf lg b">attach</code>、<code class="fe ld le lf lg b">port-forward</code>和<code class="fe ld le lf lg b">logs</code>也遵循类似的实现模式。</p><h1 id="6495" class="lh li ji bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">参考</h1><ol class=""><li id="5e3e" class="mr ms ji kh b ki mf km mg kq ob ku oc ky od lc mw mx my mz bi translated">我使用了这篇<a class="ae na" href="https://stackoverflow.com/a/155655/1144203" rel="noopener ugc nofollow" target="_blank">文章</a>中提供的定义来区分<em class="mk">函数</em>和<em class="mk">方法</em>。</li><li id="e346" class="mr ms ji kh b ki nb km nc kq nd ku ne ky nf lc mw mx my mz bi translated">我用这个<a class="ae na" href="https://erkanerol.github.io/post/how-kubectl-exec-works/" rel="noopener ugc nofollow" target="_blank">帖子</a>来验证我对部分代码的理解。这篇文章讨论了CRI-O源代码，而这篇文章关注的是Docker shim。</li></ol></div></div>    
</body>
</html>