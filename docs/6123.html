<html>
<head>
<title>How Valtio Proxy State Works (Vanilla Part)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Valtio代理状态如何工作(普通部分)</h1>
<blockquote>原文：<a href="https://itnext.io/how-valtio-proxy-state-works-vanilla-part-585ee38bd080?source=collection_archive---------2-----------------------#2021-08-27">https://itnext.io/how-valtio-proxy-state-works-vanilla-part-585ee38bd080?source=collection_archive---------2-----------------------#2021-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="400b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向可变状态添加不变性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a257e4fe50dd3fd24e0d88d35f95ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IIRQwXo6iab-VOmv.jpg"/></div></div></figure><h1 id="8f56" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="99d3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Valtio是一个全局状态库，主要用于React。它最初被建模为与<a class="ae mi" href="https://github.com/reactjs/rfcs/blob/master/text/0147-use-mutable-source.md" rel="noopener ugc nofollow" target="_blank"> useMutableSource </a> API相匹配。然而，事实证明这是一个新的API，它为可变状态增加了不变性。</p><p id="424a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">什么是不可变状态？JavaScript不支持作为语言的不变性，所以它只是一个编码契约。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="338a" class="mt kv it mp b gy mu mv l mw mx">const immutableState1 = { count: 0, text: 'hello' };</span><span id="4145" class="mt kv it mp b gy my mv l mw mx">// update the state<br/>const immutableState2 = { ...immutableState1, count: immutableState1.count + 1 };</span><span id="f806" class="mt kv it mp b gy my mv l mw mx">// update it again<br/>const immutableState3 = { ...immutableState2, count: immutableState2.count + 1 };</span></pre><p id="b928" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">有些人可能对这种模式很熟悉，也可能对其他人来说是新的。我们总是在不修改现有对象的情况下创建一个新对象。这允许我们比较状态对象。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8d7f" class="mt kv it mp b gy mu mv l mw mx">immutableState1 === immutableState2 // is false<br/>immutableState2 === immutableState3 // is false</span><span id="9a1b" class="mt kv it mp b gy my mv l mw mx">// decrement count<br/>const immutableState4 = { ...immutableState3, count: immutableState3.count - 1 };</span><span id="8c1d" class="mt kv it mp b gy my mv l mw mx">console.log(immutableState4); // shows "{ count: 1, text: 'hello' }"<br/>console.log(immutableState2); // shows "{ count: 1, text: 'hello' }"</span><span id="9889" class="mt kv it mp b gy my mv l mw mx">// however their references are different<br/>immutableState2 === immutableState4 // is false</span></pre><p id="3fd6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">不可变状态的好处是您可以将状态对象与<code class="fe mz na nb mp b">===</code>进行比较，以了解其中的任何内容是否可以更改。</p><p id="1b1b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">与不可变状态相反，可变状态是JavaScript对象，在更新时没有任何契约。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="bbb7" class="mt kv it mp b gy mu mv l mw mx">const mutableState = { count: 0, text: 'hello' };</span><span id="6833" class="mt kv it mp b gy my mv l mw mx">// update the state<br/>mutableState.count += 1;</span><span id="f832" class="mt kv it mp b gy my mv l mw mx">// update it again<br/>mutableState.count += 1;</span></pre><p id="090f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">与不可变状态不同，我们改变状态并保持相同的对象。因为JavaScript对象本质上就是可变的，所以可变状态更容易处理。可变状态的问题是不可变状态好处的另一面。如果你有两个可变的状态对象，你需要比较所有的属性，看看它们是否有相同的内容。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6fb1" class="mt kv it mp b gy mu mv l mw mx">const mutableState1 = { count: 0, text: 'hello' };<br/>const mutableState2 = { count: 0, text: 'hello' };</span><span id="8da1" class="mt kv it mp b gy my mv l mw mx">const isSame = Object.keys(mutableState1).every(<br/>  (key) =&gt; mutableState1[key] === mutableState2[key]<br/>);</span></pre><p id="ca33" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这对于嵌套对象是不够的，而且键的数量可以不同。你需要所谓的deepEqual来比较两个可变对象。</p><p id="cf72" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">对于大型对象，deepEqual不是很有效。不可变对象在这里大放异彩，因为这种比较既不依赖于对象的大小也不依赖于对象的深度。</p><p id="7842" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">因此，我们的目标是在可变状态和不可变状态之间架起一座桥梁。更准确地说，我们希望从可变状态自动创建不可变状态。</p><h1 id="8c7a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">检测突变</h1><p id="882d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">代理是一种捕获对象操作的方法。我们使用<code class="fe mz na nb mp b">set</code>处理程序来检测突变。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="29f8" class="mt kv it mp b gy mu mv l mw mx">const p = new Proxy({}, {<br/>  set(target, prop, value) {<br/>    console.log('setting', prop, value);<br/>    target[prop] = value;<br/>  },<br/>});</span><span id="1a67" class="mt kv it mp b gy my mv l mw mx">p.a = 1; // shows "setting a 1"</span></pre><p id="cea4" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们需要跟踪对象是否发生了变异，所以它有一个版本号。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="4810" class="mt kv it mp b gy mu mv l mw mx">let version = 0;<br/>const p = new Proxy({}, {<br/>  set(target, prop, value) {<br/>    ++version;<br/>    target[prop] = value;<br/>  },<br/>});</span><span id="131c" class="mt kv it mp b gy my mv l mw mx">p.a = 10;<br/>console.log(version); // ---&gt; 1<br/>++p.a;<br/>console.log(version); // ---&gt; 2</span></pre><p id="38b2" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这个版本号是针对对象本身的，并不关心哪个属性被更改。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="bc58" class="mt kv it mp b gy mu mv l mw mx">// continued<br/>++p.a;<br/>console.log(version); // ---&gt; 3<br/>p.b = 20;<br/>console.log(version); // ---&gt; 4</span></pre><p id="8deb" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">由于我们现在可以跟踪突变，下一步是创建一个不可变的状态。</p><h1 id="285a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建快照</h1><p id="69da" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们称可变状态的不可变状态为快照。如果我们检测到突变，即版本号改变时，我们会创建一个新的快照。</p><p id="1a66" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">创建快照基本上就是复制一个对象。为了简单起见，让我们假设我们的对象不是嵌套的。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="01e0" class="mt kv it mp b gy mu mv l mw mx">let version = 0;<br/>let lastVersion;<br/>let lastSnapshot;<br/>const p = new Proxy({}, {<br/>  set(target, prop, value) {<br/>    ++version;<br/>    target[prop] = value;<br/>  },<br/>});<br/>const snapshot = () =&gt; {<br/>  if (lastVersion !== version) {<br/>    lastVersion = version;<br/>    lastSnapshot = { ...p };<br/>  }<br/>  return lastSnapshot;<br/>};</span><span id="d70b" class="mt kv it mp b gy my mv l mw mx">p.a = 10;<br/>console.log(snapshot()); // ---&gt; { a: 10 }<br/>p.b = 20;<br/>console.log(snapshot()); // ---&gt; { a: 10, b: 20 }<br/>++p.a;<br/>++p.b;<br/>console.log(snapshot()); // ---&gt; { a: 11, b: 21 }</span></pre><p id="0e86" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><code class="fe mz na nb mp b">snapshot</code>是一个创建快照对象的函数。值得注意的是，快照对象仅在调用<code class="fe mz na nb mp b">snapshot</code>时创建。在那之前，我们可以做尽可能多的突变，这只会增加<code class="fe mz na nb mp b">version</code>。</p><h1 id="2a67" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">订阅</h1><p id="96fe" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这一点上，我们不知道突变何时发生。通常情况下，如果状态发生变化，我们会想做些什么。对此，我们有订阅。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="24a9" class="mt kv it mp b gy mu mv l mw mx">let version = 0;<br/>const listeners = new Set();<br/>const p = new Proxy({}, {<br/>  set(target, prop, value) {<br/>    ++version;<br/>    target[prop] = value;<br/>    listeners.forEach((listener) =&gt; listener());<br/>  },<br/>});<br/>const subscribe = (callback) =&gt; {<br/>  listeners.add(callback);<br/>  const unsubscribe = () =&gt; listeners.delete(callback);<br/>  return unsubscribe;<br/>};</span><span id="60fa" class="mt kv it mp b gy my mv l mw mx">subscribe(() =&gt; {<br/>  console.log('mutated!');<br/>});</span><span id="0d17" class="mt kv it mp b gy my mv l mw mx">p.a = 10; // shows "mutated!"<br/>++p.a; // shows "mutated!"<br/>p.b = 20; // shows "mutated!"</span></pre><p id="db9a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">组合<code class="fe mz na nb mp b">snapshot</code>和<code class="fe mz na nb mp b">subscribe</code>允许我们连接可变状态来做出反应。</p><p id="d13c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们将在另一篇文章中介绍valtio如何使用React。</p><h1 id="4b09" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">处理嵌套对象</h1><p id="5e4a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">到目前为止，我们的例子是简单对象，其属性是原始值。实际上，我们希望使用嵌套对象，这是不可变状态的好处。</p><p id="3561" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">嵌套对象看起来像这样。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8799" class="mt kv it mp b gy mu mv l mw mx">const obj = {<br/>  a: { b: 1 },<br/>  c: { d: { e: 2 } },<br/>};</span></pre><p id="6494" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们也想使用数组。</p><p id="33ce" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">Valtio支持嵌套对象和数组。如果您对它是如何实现的感兴趣，请查看源代码。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/pmndrs/valtio" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">GitHub - pmndrs/valtio:💊Valtio为React和Vanilla简化了代理状态</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">npm i valtio使代理状态变得简单valtio把你传递的对象变成一个自我感知的代理。你可以做出改变…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><h1 id="d343" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="6550" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这篇博文中，我们在示例中使用了简单的代码。该实现做了更多的事情来处理各种情况。它仍然是最低的。</p><p id="e4b6" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">实际的API非常接近示例代码。下面是TypeScript中粗略的类型定义。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="82a7" class="mt kv it mp b gy mu mv l mw mx">function proxy&lt;T&gt;(initialObject: T): T;</span><span id="af9a" class="mt kv it mp b gy my mv l mw mx">function snapshot&lt;T&gt;(proxyObject: T): T;</span><span id="cbeb" class="mt kv it mp b gy my mv l mw mx">function subscribe&lt;T&gt;(proxyObject: T, callback: () =&gt; void): () =&gt; void;</span></pre><p id="e610" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">在这篇文章中，我们讨论了valtio的香草部分。希望尽快写下反应部分。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="0849" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated"><em class="ob">原载于2021年8月27日</em><a class="ae mi" href="https://blog.axlight.com/posts/how-valtio-proxy-state-works-vanilla-part/" rel="noopener ugc nofollow" target="_blank"><em class="ob">【https://blog.axlight.com】</em></a><em class="ob">。</em></p></div></div>    
</body>
</html>