<html>
<head>
<title>A short time learning Haskell can shortly IMPROVE your Typescript skills!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">短时间学习Haskell可以很快提高您的打字技能！</h1>
<blockquote>原文：<a href="https://itnext.io/a-short-time-learning-haskell-can-shortly-improve-your-typescript-skills-523505900ac0?source=collection_archive---------1-----------------------#2020-01-03">https://itnext.io/a-short-time-learning-haskell-can-shortly-improve-your-typescript-skills-523505900ac0?source=collection_archive---------1-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fccfd0c2ab3e34f44332593a5c262b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfWkCwvExCc5Xa3OAOcD8g.png"/></div></div></figure><p id="15a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几周前，我决定挑战自己学习Haskell <strong class="ka ir">。</strong>我的动机是更好地掌握功能模式。(这样的<strong class="ka ir">函子</strong>或者<strong class="ka ir">单子</strong>这里还有很多→ <a class="ae kw" href="https://github.com/thma/LtuPatternFactory#the-patternopedia" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">模式库</strong> </a>)。在Haskell的一行代码中，你可以描述抽象的概念——这是非常强大的。</p><p id="77a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Haskell不同于我所熟悉的其他语言。但我最终还是想出了一个在TS中实现仿函数的尝试，我称之为<a class="ae kw" href="https://stackblitz.com/edit/functor-explained" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">【列表仿函数】</strong> </a> <strong class="ka ir">。</strong>你可以在我的<a class="ae kw" href="http://degoes.net/articles/fp-glossary" rel="noopener ugc nofollow" target="_blank">上一篇</a>上找到解释。顺便看看下面这个令人印象深刻的项目<a class="ae kw" href="https://github.com/gcanti/fp-ts/blob/master/src/Functor.ts" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> fp-ts </strong> </a>。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/b97bf819c57f43b47a0ed7ddcb364c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*7jXxOePHJxy9hLsd4UrsTw.png"/></div></figure><h2 id="9004" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">那么，学习一门纯函数式语言如何改进您在Typescript中的思维方式呢？</h2><blockquote class="lv"><p id="ff6f" class="lw lx iq bd ly lz ma mb mc md me kv dk translated">在纯粹的函数式编程中，你不告诉计算机做什么，而是告诉它什么东西是。</p></blockquote><h2 id="014c" class="lc ld iq bd le lf mg dn lh li mh dp lk kj mi lm ln kn mj lp lq kr mk ls lt lu bi translated">任何东西都可以被输入，让我们重新考虑一下我们的功能:</h2><p id="c6cf" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">学习Haskell很短的时间，你就会开始到处看到类型。我立即开始在我写的任何TS函数上寻找类型模式。</p><p id="91c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们探索下面的Haskell片段:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="d63f" class="lc ld iq mr b gy mv mw l mx my">add <strong class="mr ir">:: Integer -&gt; Integer -&gt; Integer   </strong><em class="mz">--function declaration<br/></em>add x y =  x <strong class="mr ir">+ </strong>y                       <em class="mz">--function definition</em></span></pre><p id="8b5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> add </strong>函数声明的<strong class="ka ir">类型为:</strong>整数，另一个整数输出两个整数中的一部分。</p><p id="7c50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在TS中，它将是:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="7fcd" class="lc ld iq mr b gy mv mw l mx my"><strong class="mr ir">type </strong>Add = (a: <strong class="mr ir">number</strong>, b: <strong class="mr ir">number</strong>) =&gt; <strong class="mr ir">number</strong>; <em class="mz">// type signature <br/></em><strong class="mr ir">export const </strong><em class="mz">add</em>: Add = (num1, num2) =&gt; num1 + num2;<br/><em class="mz">add</em>(<strong class="mr ir">'foo'</strong>, 1); <em class="mz">// type error<br/>add</em>(2, 1); <em class="mz">// boom</em></span></pre><p id="7936" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以访问下面的TS <a class="ae kw" href="https://www.typescriptlang.org/play/index.html?e=26#example/typing-functions" rel="noopener ugc nofollow" target="_blank"> playground </a>记录函数形状的例子！</p><h2 id="de52" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">将类型视为变量给我们带来了灵活性</h2><p id="ae97" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">在Haskell中，<strong class="ka ir">类型变量</strong>类似于<strong class="ka ir">泛型</strong>(由<strong class="ka ir">小写字母</strong>定义)。</p><p id="5f7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下代码片段表示元组的第一个项<strong class="ka ir">:</strong></p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="dc20" class="lc ld iq mr b gy mv mw l mx my">first :: (a, b) -&gt; a</span></pre><p id="ad92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变量'<strong class="ka ir"> a </strong>'可以是任何类型。</p><p id="f371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在typescript中，它可能看起来像:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="e87f" class="lc ld iq mr b gy mv mw l mx my"><strong class="mr ir">type </strong>first = &lt;T, X&gt; ([a, b]: [T, X]) =&gt;  T<br/><strong class="mr ir">const </strong><em class="mz">fst</em>: first = ([a, b]) =&gt; a;<br/><strong class="mr ir"><em class="mz">console</em></strong>.log(<em class="mz">fst</em>([<strong class="mr ir">'foo'</strong>, 666]));</span></pre><p id="411b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们要描述一个更复杂的函数，比如<strong class="ka ir"> map() </strong>函数，它看起来会像:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="cf03" class="lc ld iq mr b gy mv mw l mx my">map(transformFn: &lt;T, V&gt; (arg: T) =&gt; V ): MyFunctorContext&lt;T&gt; {<br/>    <strong class="mr ir">const </strong>newItems = [];<br/><br/>    <strong class="mr ir">for </strong>(<strong class="mr ir">const </strong>item <strong class="mr ir">of this</strong>.<strong class="mr ir">items</strong>) {<br/>        newItems.push(transformFn(item));<br/>    }<br/><br/>    <strong class="mr ir">return new </strong>MyFunctorContext(newItems);<br/>}</span></pre><p id="8555" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">放大<strong class="ka ir">变压器Fn </strong>类型描述:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="d115" class="lc ld iq mr b gy mv mw l mx my">&lt;T, V&gt; (arg: T) =&gt; V </span></pre><p id="9129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">变换函数的<strong class="ka ir">输入</strong>可以是任何类型(T)。因此，变换后的<strong class="ka ir">输出</strong> (V)可以是任何类型，但不同于输入类型！</p><h2 id="c3c6" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated"><strong class="ak">类型约束:</strong></h2><p id="8bf3" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">让我们关注一下 a类型的某个<strong class="ka ir">行为。如果我们将某个行为包含在一组<strong class="ka ir">类型</strong>中，我们就可以实现一个通用函数(多态函数)来操作它们。</strong></p><p id="7107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">说一个类型需要的某个<strong class="ka ir">行为(或属性)</strong>实际上是在添加类型“约束”。</p><p id="4585" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个在TS中添加类型约束的例子:(使用“extends”关键字)。</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="a6cf" class="lc ld iq mr b gy mv mw l mx my"><strong class="mr ir">interface </strong>Instrument {<br/>    <strong class="mr ir">play</strong>: () =&gt; <strong class="mr ir">void</strong>;<br/>}</span><span id="4f30" class="lc ld iq mr b gy na mw l mx my"><strong class="mr ir">type </strong>PlayFn = &lt;I <strong class="mr ir">extends </strong>Instrument&gt;(instruments: I[]) =&gt; <strong class="mr ir">void</strong>;</span><span id="7d28" class="lc ld iq mr b gy na mw l mx my"><strong class="mr ir">class </strong>Guitar <strong class="mr ir">implements </strong>Instrument {<br/>    play() {}<br/>}<br/><br/><strong class="mr ir">class </strong>Drums <strong class="mr ir">implements </strong>Instrument {<br/>    play() {}<br/>}<br/><br/><strong class="mr ir">const </strong><em class="mz">playPart</em>:PlayFn = (instrumets) =&gt; {<br/>    instrumets.forEach(instrument =&gt; instrument.<strong class="mr ir">play</strong>());<br/>};<br/><br/><em class="mz">playPart</em>([<strong class="mr ir">new </strong>Guitar(), <strong class="mr ir">new </strong>Drums()]);</span></pre><p id="4ed9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，在TS中，约束可以优雅地添加到函数类型的一行表示中:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="dc49" class="lc ld iq mr b gy mv mw l mx my"><strong class="mr ir">type </strong>PlayFn = &lt;I <strong class="mr ir">extends </strong>Instrument&gt;(instruments: I[]) =&gt; <strong class="mr ir">void</strong>;</span></pre><p id="24c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Haskell的中，我们通过使用<a class="ae kw" href="http://learnyouahaskell.com/types-and-typeclasses" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">类型类</strong> </a> <strong class="ka ir">，</strong>来引用约束，这通常被比作<strong class="ka ir">接口。</strong></p><blockquote class="nb nc nd"><p id="0302" class="jy jz mz ka b kb kc kd ke kf kg kh ki ne kk kl km nf ko kp kq ng ks kt ku kv ij bi translated">类型类是一种定义某些行为的接口。如果一个类型是typeclass的一部分，这意味着它<strong class="ka ir">支持并实现了typeclass </strong>描述的行为。</p></blockquote><p id="795c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个使用类型变量约束的单行Haskell示例:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="19b5" class="lc ld iq mr b gy mv mw l mx my">read :: (Read a) =&gt; String -&gt; a</span></pre><p id="d97a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Read是Haskell lang标准的一部分，它提供了解析字符串的操作，以获得它们可能表示的值。</p><p id="bf28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数<strong class="ka ir"> read </strong>的类型为:[(Read a) = &gt; String - &gt; a]，它可以接受<strong class="ka ir">实现</strong>Read行为的任何类型(‘a’)(作为约束)。</p><h2 id="e149" class="lc ld iq bd le lf lg dn lh li lj dp lk kj ll lm ln kn lo lp lq kr lr ls lt lu bi translated">重新思考功能模式:</h2><p id="e928" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv ij bi translated">如果您对模式感兴趣，您将会非常欣赏以下资源:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/thma/LtuPatternFactory#the-patternopedia" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">thma/LtuPatternFactory</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">我的第一个编程语言是Lisp、Scheme和ML。当我后来开始用面向对象语言工作时，比如C++和…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jw nk"/></div></div></a></div><p id="f242" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函子是不同类型的函数表示，可以被映射。</p><p id="15e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Haskell的仿函数Typeclass实现是:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="2daa" class="lc ld iq mr b gy mv mw l mx my"><strong class="mr ir">class </strong>Functor f where<br/>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="00d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/recognising-functional-patterns-functors-for-dummies-2a829c875767">我实现了一个“列表函子”</a>，它包含了‘映射’功能，但它仅限于任何类型的列表，列表是一个函子实现。</p><p id="5ab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个不是列表的仿函数实现的例子是<strong class="ka ir">或者</strong>仿函数:</p><pre class="ky kz la lb gt mq mr ms mt aw mu bi"><span id="242e" class="lc ld iq mr b gy mv mw l mx my"><strong class="mr ir">instance Functor Maybe where  <br/>    fmap </strong>f (<strong class="mr ir">Just </strong>x) = <strong class="mr ir">Just </strong>(f x)  <br/>    <strong class="mr ir">fmap </strong>f <strong class="mr ir">Nothing </strong>= <strong class="mr ir">Nothing</strong></span></pre><p id="69a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">也许</strong>“盒子”既可以返回某个值，也可以不返回任何值。</p><p id="29dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是这篇文章的全部内容，</p><p id="47f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p><p id="f751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，你可能会喜欢:</p><div class="nh ni gp gr nj nk"><a href="https://dev.to/lironn_h/type-thinking-p2-typeclass-p76" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">类型思维🤔P2型</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">在这篇文章中，我简单地比较了一下:多态性-(多种形式)“多态性是提供一个单一的接口给…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">开发到</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny jw nk"/></div></div></a></div><p id="c6b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯！</p><p id="52bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">利伦。</p></div></div>    
</body>
</html>