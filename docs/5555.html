<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://itnext.io/javascript-lessons-arrays-fd50f8b7becc?source=collection_archive---------1-----------------------#2021-04-02">https://itnext.io/javascript-lessons-arrays-fd50f8b7becc?source=collection_archive---------1-----------------------#2021-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/eccf471b1c88a12d24d3c92989456ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-AmZwXXD0OQfTkw5uhTwA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">JavaScript课程:数组</figcaption></figure><p id="03fd" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">欢迎来到这个关于JavaScript的新系列的第一篇文章，我们称之为JavaScript课程，在这里你将能够学习JavaScript的基础知识，成为一名更好的开发人员，并更新一些最常用主题的知识。</p><p id="5310" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们从基础开始。如果你是一个更有经验的开发人员，你可以跳过这一部分，或者留下来更新一些知识。</p><h1 id="15ff" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是数组？</h1><p id="9c46" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">JavaScript中的一个<code class="fe lf lg lh li b">Array</code>是一个用于列表构造的全局对象。</p><p id="f865" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">Array</code>的原型或核心功能包括对列表中的元素进行读、写、列表和变异的方法。数组的类型和长度可以随时改变，数据可以存储在不连续的位置。</p><p id="dd38" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">JavaScript中的数组是零索引的，这意味着数组的第一个位置总是零。</p><h1 id="f926" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">创建数组</h1><p id="e214" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">用JavaScript创建数组不费吹灰之力。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="eb09" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Rafael', 'May'];</span></pre><p id="00b2" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">people</code>变量现在保存一个数组，其中有4个字符串类型的元素，索引如下:</p><ol class=""><li id="7fe8" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb mb mc md me bi translated">亚历克斯</li><li id="39bf" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">丹尼尔（男子名）</li><li id="4dc9" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">拉斐尔</li><li id="f3db" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">五月</li></ol><p id="50ae" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">如您所见，数组的第一个位置，索引零，对应于字符串<code class="fe lf lg lh li b">Alex</code>。这个数组的长度是四。</p><p id="a78c" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">如果您想创建一个空数组，您必须:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="e557" class="lr kd jf li b gy ls lt l lu lv">const people = [];</span></pre><p id="405d" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">这将创建一个空数组。该数组的长度为零。</p><h1 id="8276" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">获取数组的长度</h1><p id="ada1" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">要获得一个数组的长度，你可以使用<code class="fe lf lg lh li b">length</code>属性:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="2b42" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="46d3" class="lr kd jf li b gy mk lt l lu lv">people.length; // 4</span></pre><h1 id="84fe" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">通过索引访问元素</h1><p id="2382" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">为了通过索引访问数组中的元素，我们应该如下操作:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="9106" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="9e87" class="lr kd jf li b gy mk lt l lu lv">people[1]; // Daniel</span></pre><p id="be4e" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">如果您试图通过元素的索引来访问元素，但是在给定的索引处没有元素，那么您将得到一个<code class="fe lf lg lh li b">undefined</code>作为返回。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b5ad" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="378f" class="lr kd jf li b gy mk lt l lu lv">people[4]; // undefined</span></pre><p id="4eb4" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">如果你有一个动态数组，你想访问数组中的最后一个元素，你可以用length属性得到数组中的元素个数，然后减1，因为如果你还记得的话，数组是零索引的，这就是为什么我们需要从数组长度中减1。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="faf7" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="641d" class="lr kd jf li b gy mk lt l lu lv">people[people.length - 1]; // May</span></pre><p id="080f" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们看看如果不从<code class="fe lf lg lh li b">people.length</code>属性中减去1会发生什么。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="da77" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="f525" class="lr kd jf li b gy mk lt l lu lv">people[people.length]; // undefined</span></pre><p id="de6d" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">people.length</code>将返回4，<code class="fe lf lg lh li b">people</code>数组的第4个位置实际上是<code class="fe lf lg lh li b">undefined</code>。</p><h1 id="4c8d" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">迭代数组</h1><p id="7b54" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">有几种方法可以迭代数组，我们将学习如何使用<code class="fe lf lg lh li b">for loop</code>和<code class="fe lf lg lh li b">forEach</code>回调函数进行迭代。还有一些其他的，但是我们将在后面更详细地讨论迭代一个数组的其他可能性。</p><h1 id="9442" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="fe lf lg lh li b">for loop</code>对数组进行迭代</h1><p id="23ad" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">用<code class="fe lf lg lh li b">for loop</code>迭代一个数组是目前为止最有效和最快的方法。</p><p id="9eed" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">首先，我们应该得到数组的长度。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="25a1" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];<br/>const amountOfPeople = people.length; // 4;</span></pre><p id="d345" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们需要构造<code class="fe lf lg lh li b">for loop</code>。这是学习计算机科学时你将学到的最基本的东西之一。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="95c4" class="lr kd jf li b gy ls lt l lu lv">for (let index = 0; index &lt;= amountOfPeople - 1; index++) {}</span></pre><p id="39f2" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们来看看一个<code class="fe lf lg lh li b">for loop</code>的签名。</p><ul class=""><li id="3250" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb ml mc md me bi translated"><code class="fe lf lg lh li b">for</code>:这是JavaScript中用来声明<code class="fe lf lg lh li b">for loop</code>的保留词。</li><li id="6a1a" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated"><code class="fe lf lg lh li b">let index = 0</code>:这是一个变量声明，它将用于保存当前的迭代索引。</li><li id="990e" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated"><code class="fe lf lg lh li b">index &lt;= amountOfPeople - 1</code>:这个谓词用来决定循环是应该继续执行还是结束迭代，如果谓词等于<code class="fe lf lg lh li b">true</code>它将继续执行，如果谓词等于<code class="fe lf lg lh li b">false</code>它将结束执行。</li><li id="8e1c" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated"><code class="fe lf lg lh li b">index++</code>:这是迭代结束时将执行的动作，通常，你可以用它来将<code class="fe lf lg lh li b">indexing</code>变量增加1或你想要的任何数字。</li></ul><p id="76fb" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在让我们把所有的东西粘在一起，构造一个<code class="fe lf lg lh li b">for loop</code>，它将在浏览器的控制台中显示所有人的名字。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="a9b7" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];<br/>const amountOfPeople = people.length; // 4;</span><span id="a45c" class="lr kd jf li b gy mk lt l lu lv">for (let index = 0; index &lt;= amountOfPeople - 1; index++) {<br/>  console.log(people[index]);<br/>}</span></pre><p id="5c9a" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">如果在节点终端或REPL中执行这段代码，应该会看到如下输出:</p><ol class=""><li id="0548" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb mb mc md me bi translated">亚历克斯</li><li id="3605" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">丹尼尔（男子名）</li><li id="d47f" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">上等的</li><li id="f8c5" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">五月</li></ol><h1 id="a4a7" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="fe lf lg lh li b">forEach</code>回调函数迭代数组</h1><p id="2867" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">用<code class="fe lf lg lh li b">forEach</code>回调函数迭代数组不如<code class="fe lf lg lh li b">for loop</code>有效，但是有人会说它更具视觉吸引力和可读性，如果性能不重要并且你的目标是可读性，那么你应该用<code class="fe lf lg lh li b">forEach</code>。但是记住，<code class="fe lf lg lh li b">forEach</code>回调函数不能是<code class="fe lf lg lh li b">asynchronous</code>，如果你试图<code class="fe lf lg lh li b">async/await</code>它，它肯定会给你带来不止一两个麻烦。</p><p id="e32d" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">我们来看看如何使用<code class="fe lf lg lh li b">forEach</code>回调函数。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="5100" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="8083" class="lr kd jf li b gy mk lt l lu lv">people.forEach(function (element, index, array) {<br/>  console.log(element);<br/>});</span></pre><p id="50bb" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在让我们看看<code class="fe lf lg lh li b">forEach</code>回调函数的签名，就像我们对<code class="fe lf lg lh li b">for loop</code>所做的那样。</p><ul class=""><li id="f428" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb ml mc md me bi translated"><code class="fe lf lg lh li b">people.forEach()</code>:正如你在这里看到的，<code class="fe lf lg lh li b">.forEach()</code>是来自<code class="fe lf lg lh li b">Array</code>原型(核心功能)的一个方法，你可以使用它，因为<code class="fe lf lg lh li b">people</code>变量是一个<code class="fe lf lg lh li b">Array</code>对象。</li><li id="797e" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated"><code class="fe lf lg lh li b">function(element, index, array)</code>:为数组中的每个元素调用的回调函数。该函数将获得3个参数供您使用，这些参数是:</li></ul><ol class=""><li id="40c2" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb mb mc md me bi translated"><code class="fe lf lg lh li b">element</code>:本次迭代中数组的当前元素。</li><li id="e939" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated"><code class="fe lf lg lh li b">index</code>:本次迭代的当前索引。</li><li id="6e4b" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated"><code class="fe lf lg lh li b">array</code>:整个数组将被传递给这个属性，以防你需要访问它。</li></ol><p id="3635" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">正如你所看到的，它可能比<code class="fe lf lg lh li b">for loop</code>更具可读性，但是如果性能不重要，可以根据需要随意依赖它。您甚至可以使用带有隐式返回的<code class="fe lf lg lh li b">arrow function</code>使它更短🙃</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="e01b" class="lr kd jf li b gy ls lt l lu lv">const people = ['Alex', 'Daniel', 'Jake', 'May'];</span><span id="47ca" class="lr kd jf li b gy mk lt l lu lv">people.forEach((element, index, array) =&gt; console.log(element));</span></pre><h1 id="de87" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">向数组中添加元素</h1><p id="ae4f" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">为了向数组中添加元素，我们有多种方法，我们可以将一个元素放在最后一个位置，我们可以基于索引将一个元素存储到特定数组的位置，或者我们可以将一个元素放在数组的第一个位置。让我们来看看向数组中添加元素的一些方法。</p><h1 id="7116" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><code class="fe lf lg lh li b">push</code>元素成数组</h1><p id="9041" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们将使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">push()</code>方法向数组末尾添加一个元素。假设我们有一个包含一个苹果的水果数组🍎一个梨🍐一个柠檬🍋，我们买了一些杂货，还想加一根香蕉🍌，我们不在乎把它放在哪里，所以我们最后只打算<code class="fe lf lg lh li b">push</code>它。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="7513" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍎', '🍐', '🍋'];</span><span id="7065" class="lr kd jf li b gy mk lt l lu lv">fruit.push('🍌');</span></pre><p id="57a5" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">fruit</code>数组现在将包含一个苹果🍎一个梨🍐一个柠檬🍋和一根香蕉🍌。</p><h1 id="05a0" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">基于索引位置存储元素</h1><p id="a840" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们将使用数组的<code class="fe lf lg lh li b">index</code>位置来存储西瓜🍉我们刚刚买入了我们之前创建的<code class="fe lf lg lh li b">fruit</code>数组中的一个特定位置。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="eb15" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍎', '🍐', '🍋', '🍌'];</span><span id="5372" class="lr kd jf li b gy mk lt l lu lv">fruit[4] = '🍉';</span></pre><p id="0730" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">数组现在将包含一个苹果🍎一个梨🍐一个柠檬🍋一根香蕉🍌在数组的第四个位置，是一个西瓜🍉。</p><p id="28f9" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们想象我们已经购买了西瓜🍉但是冰箱里没有空间了，所以我们需要拿出一个水果来存放西瓜🍉。我们如何做到这一点？让我们假设我们不想要更多的柠檬🍋。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="49b2" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍎', '🍐', '🍋', '🍌'];</span><span id="e055" class="lr kd jf li b gy mk lt l lu lv">fruit[2] = '🍉';</span></pre><p id="08e3" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">更改之后，<code class="fe lf lg lh li b">fruit</code>数组现在将包含一个苹果🍎一个梨🍐一个西瓜🍉和一根香蕉🍌。柠檬🍋因为我们用它的<code class="fe lf lg lh li b">index</code>位置告诉数组，在那个特定的位置我们想要一个西瓜🍉而不是柠檬🍋。</p><h1 id="6b14" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><code class="fe lf lg lh li b">unshift</code>元素成阵</h1><p id="ae1e" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们将使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">unshift()</code>方法向数组的开头添加一个元素。假设我们仍然有这个水果数组，但是我们想要添加更多的水果，因为我们已经购买了一个新的水果，一个橙子🍊，我们想把它留到最后，因为它是最新的水果，你应该总是在新水果之前买的水果。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="c622" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍎', '🍐', '🍉', '🍌'];</span><span id="4b18" class="lr kd jf li b gy mk lt l lu lv">fruit.unshift('🍊');</span></pre><p id="aa3b" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">fruit</code>数组现在将包含一个橙色🍊一个苹果🍎一个梨🍐一个西瓜🍉和一根香蕉🍌。</p><h1 id="0fdf" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">从数组中移除元素</h1><p id="01d4" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们将使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">pop()</code>方法来移除数组中的最后一个元素。假设我们仍然有这个水果阵列，但我们想开始吃水果，但我们想吃我们最近购买的水果(水果不是一个好主意！).</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b497" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="166f" class="lr kd jf li b gy mk lt l lu lv">fruit.pop();</span></pre><p id="7736" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">fruit</code>数组现在将包含一个橙色🍊一个苹果🍎一个梨🍐和一个西瓜🍉，但是香蕉会不见了，因为我们刚刚把它吃了😋。</p><h1 id="ff44" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">按位置移除各种元素</h1><p id="6750" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">splice(from, amount)</code>方法，我们可以通过一个索引范围移除数组中元素的子集。我们提供减法将开始的索引<code class="fe lf lg lh li b">from</code>和我们希望从起始点减去的元素的<code class="fe lf lg lh li b">amount</code>。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="7363" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="347c" class="lr kd jf li b gy mk lt l lu lv">let removedElements = fruit.splice(1, 3); // ['🍎', '🍐', '🍉']</span><span id="4a05" class="lr kd jf li b gy mk lt l lu lv">fruit; // ['🍊', '🍌'];</span></pre><p id="febe" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">splice</code>方法取出给定的元素并返回它们，这样您就可以将它们作为一个新数组单独使用。</p><p id="9140" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">📣抬头！<code class="fe lf lg lh li b">splice</code>方法改变了原始数组，这可能会导致代码中的错误。您应该尝试在代码中实现不变性，以便轻松识别bug。</p><h1 id="8858" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">查找数组中元素的索引</h1><p id="2c63" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">假设你想知道苹果在哪里🍎在你的冰箱里，你会怎么做？幸运的是，<code class="fe lf lg lh li b">Array</code>对象有一个非常方便的方法来告诉你数组中元素的索引，这个方法是<code class="fe lf lg lh li b">indexOf</code>并且给定一个元素，它将返回你数组中该元素的索引，或者如果在数组中没有找到该元素，返回<code class="fe lf lg lh li b">-1</code>。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b1e6" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="6d03" class="lr kd jf li b gy mk lt l lu lv">let appleIndex = fruits.indexOf('🍎'); // 1</span></pre><p id="848e" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们想找到西瓜在哪里🍉是at！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="afef" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="7d3c" class="lr kd jf li b gy mk lt l lu lv">let watermelonIndex = fruits.indexOf('🍉'); // 3</span></pre><p id="46c0" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">我们有柠檬吗🍋？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="ab1d" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="6255" class="lr kd jf li b gy mk lt l lu lv">let lemonIndex = fruits.indexOf('🍋'); // -1</span></pre><p id="3dce" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">我们没有柠檬🍋这就是为什么<code class="fe lf lg lh li b">lemonIndex</code>变量会保存一个<code class="fe lf lg lh li b">-1</code>。</p><p id="e7db" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">📣抬头！<code class="fe lf lg lh li b">indexOf</code>方法将返回数组中匹配的第一个元素的<code class="fe lf lg lh li b">index</code>。如果有许多相同的元素，那么返回的<code class="fe lf lg lh li b">index</code>将是从索引<code class="fe lf lg lh li b">0</code>到索引<code class="fe lf lg lh li b">n</code>中最先匹配的那个。</p><h1 id="21bd" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">寻找数组中元素索引的另一种方法</h1><p id="5342" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">想象一下，你知道你有一个苹果🍎但是你实际上不知道它在冰箱上的什么位置。你会怎么做？幸运的是，我们在<code class="fe lf lg lh li b">Array</code>对象中有<code class="fe lf lg lh li b">findIndex(predicate)</code>方法，它将允许您获取给定元素的数组中的索引。这个方法将一个回调函数作为主要和唯一的参数，作为一个谓词来检查我们想要获取其索引的元素，如果在数组中没有找到该元素，则返回匹配元素的索引或<code class="fe lf lg lh li b">-1</code>。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="0040" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="df06" class="lr kd jf li b gy mk lt l lu lv">let appleIndex = fruits.findIndex('🍎'); // 1</span></pre><p id="5c42" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">柠檬在哪里🍋在我们的冰箱里？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="8d98" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="5be0" class="lr kd jf li b gy mk lt l lu lv">let lemonIndex = fruits.findIndex('🍋'); // -1</span></pre><p id="7e95" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">📣抬头！<code class="fe lf lg lh li b">indexOf</code>方法将返回数组中匹配的第一个元素的<code class="fe lf lg lh li b">index</code>。如果有多个相同的元素，那么返回的<code class="fe lf lg lh li b">index</code>将是从索引<code class="fe lf lg lh li b">0</code>到索引<code class="fe lf lg lh li b">n</code>中最先匹配的元素。</p><h1 id="df6b" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">复制数组</h1><p id="81df" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">复制数组是许多应用程序和场景中的常见用例。复制数组是一项简单的任务，可以用不同的方式完成。我们可以使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">slice()</code>方法将数组的副本创建到一个新变量中，或者我们可以使用新的ES6 <code class="fe lf lg lh li b">spread operator (...)</code>特性将数组的副本创建到一个新变量中。</p><h1 id="fdce" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="fe lf lg lh li b">slice</code>复制一个数组</h1><p id="c351" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们可以使用<code class="fe lf lg lh li b">slice</code>方法来复制数组。这个方法没有改变原始数组，所以它保持完整，因此，它是不可变的，更好地避免了错误🐞</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="f29a" class="lr kd jf li b gy ls lt l lu lv">let basketOne = ['🍊', '🍎', '🍐', '🍉', '🍌'];<br/>let basketTwo = basketOne.slice();</span><span id="2c7a" class="lr kd jf li b gy mk lt l lu lv">basketOne; // ['🍊', '🍎', '🍐', '🍉', '🍌']<br/>basketTwo; // ['🍊', '🍎', '🍐', '🍉', '🍌']</span></pre><h1 id="e63b" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="fe lf lg lh li b">slice</code>复制数组的一部分</h1><p id="8158" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们可以使用<code class="fe lf lg lh li b">slice(start, end)</code>方法将数组的一部分从起点(含)复制到终点(不含)。这个方法没有改变原始数组，所以它保持完整，因此，它是不可变的，更好地避免了错误🐞</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="29e8" class="lr kd jf li b gy ls lt l lu lv">let basketOne = ['🍊', '🍎', '🍐', '🍉', '🍌'];<br/>let basketTwo = basketOne.slice(1, 3);</span><span id="e334" class="lr kd jf li b gy mk lt l lu lv">basketOne; // ['🍊', '🍎', '🍐', '🍉', '🍌']<br/>basketTwo; // ['🍎', '🍐']</span></pre><h1 id="76e0" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="fe lf lg lh li b">spread operator</code>复制一个数组</h1><p id="045a" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们可以使用ES6 <code class="fe lf lg lh li b">spread operator (...)</code>来复制一个数组。这个方法也不会改变原始数组，所以它保持完整，因此，它是不可变的，更好地避免了错误🐞</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="8c92" class="lr kd jf li b gy ls lt l lu lv">let basketOne = ['🍊', '🍎', '🍐', '🍉', '🍌'];<br/>let basketTwo = [...basketOne];</span><span id="d2ee" class="lr kd jf li b gy mk lt l lu lv">basketOne; // ['🍊', '🍎', '🍐', '🍉', '🍌']<br/>basketTwo; // ['🍊', '🍎', '🍐', '🍉', '🍌']</span></pre><p id="1302" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">正如您所看到的，这两个选项在结果上是相同的，并且在性能上没有区别，因此您可以决定使用哪一个🤗</p><h1 id="c088" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">用<code class="fe lf lg lh li b">concat</code>连接数组</h1><p id="2566" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们可以使用<code class="fe lf lg lh li b">concat(Array)</code>方法将多个数组连接在一起，这样我们就可以获得一个由其他数组组合而成的数组。这个方法没有改变任何原始数组，所以它保持完整，因此，它是不可变的，更好地避免了错误🐞</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="67d1" class="lr kd jf li b gy ls lt l lu lv">let basketOne = ['🍊', '🍎'];<br/>let basketTwo = ['🍐', '🍉', '🍌'];</span><span id="cb2a" class="lr kd jf li b gy mk lt l lu lv">let combinedBasket = basketOne.concat(basketTwo);</span></pre><p id="1f8a" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">在一个数组上使用<code class="fe lf lg lh li b">.concat(array)</code>方法并传递将要连接的数组后，它将返回一个新的数组，而不是修改原来的数组。这样，<code class="fe lf lg lh li b">combinedBasket</code>将包含以下项目:’🍊', '🍎', '🍐', '🍉', '🍌并且<code class="fe lf lg lh li b">basketOne</code>和<code class="fe lf lg lh li b">basketTwo</code>将保持完整。</p><h1 id="0f58" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">用<code class="fe lf lg lh li b">spread operator</code>连接数组</h1><p id="2062" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">我们可以使用ES6 <code class="fe lf lg lh li b">spread operator (...)</code>将多个数组连接在一起，这样我们就可以获得一个由其他数组组合而成的数组。这个方法没有改变任何原始数组，所以它保持完整，因此，它是不可变的，更好地避免了错误🐞</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="5584" class="lr kd jf li b gy ls lt l lu lv">let basketOne = ['🍊', '🍎'];<br/>let basketTwo = ['🍐', '🍉', '🍌'];</span><span id="2b70" class="lr kd jf li b gy mk lt l lu lv">let combinedBasket = [...basketOne, ...basketTwo];</span></pre><p id="1c01" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">在一个阵列上使用ES6 <code class="fe lf lg lh li b">spread operator (...)</code>后，将两个阵列扩展成一个新阵列将产生与使用<code class="fe lf lg lh li b">.concat(array)</code>方法相同的效果。请记住，扩展数组不会修改原始数组。这样，<code class="fe lf lg lh li b">combinedBasket</code>将包含以下项目: '🍊', '🍎', '🍐', '🍉', '🍌并且<code class="fe lf lg lh li b">basketOne</code>和<code class="fe lf lg lh li b">basketTwo</code>将保持完整。</p><h1 id="ca99" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">寻找数组中的所有元素</h1><p id="aa73" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">find(predicate)</code>方法，我们可以找到匹配谓词的第一个元素，并将其作为参数传递给<code class="fe lf lg lh li b">find</code>函数。如果数组中没有任何元素与谓词<code class="fe lf lg lh li b">undefined</code>匹配，那么<code class="fe lf lg lh li b">find</code>函数将返回该值。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="8cc1" class="lr kd jf li b gy ls lt l lu lv">let basket = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="fbbd" class="lr kd jf li b gy mk lt l lu lv">let watermelon = basket.find(function (element) {<br/>  return element === '🍉';<br/>});</span><span id="9897" class="lr kd jf li b gy mk lt l lu lv">let basket = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="f11a" class="lr kd jf li b gy mk lt l lu lv">let lemon = basket.find(function (element) {<br/>  return element === '🍋';<br/>});</span><span id="1af2" class="lr kd jf li b gy mk lt l lu lv">lemon; // undefined</span></pre><p id="d396" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">我们可以用带有隐式返回的<code class="fe lf lg lh li b">arrow functions</code>使这个更短！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="8ca0" class="lr kd jf li b gy ls lt l lu lv">let basket = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="6b60" class="lr kd jf li b gy mk lt l lu lv">let watermelon = basket.find((element) =&gt; element === '🍉');</span><span id="974c" class="lr kd jf li b gy mk lt l lu lv">let basket = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="56f6" class="lr kd jf li b gy mk lt l lu lv">let lemon = basket.find((element) =&gt; element === '🍋');</span><span id="7160" class="lr kd jf li b gy mk lt l lu lv">lemon; // undefined</span></pre><h1 id="d3f3" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">检查数组中的<code class="fe lf lg lh li b">some</code>元素</h1><p id="aaf1" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">some(predicate)</code>方法，我们可以确定数组中的一些元素是否匹配给定的谓词。这个方法返回<code class="fe lf lg lh li b">true</code>或<code class="fe lf lg lh li b">false</code>，这取决于是否有匹配谓词的元素。该方法还为空数组上的任何谓词返回<code class="fe lf lg lh li b">false</code>。</p><p id="4337" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">假设我们想要检查我们是否有一些苹果🍎在我们的冰箱里。我们如何做到这一点？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="f602" class="lr kd jf li b gy ls lt l lu lv">let fridge = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="83f8" class="lr kd jf li b gy mk lt l lu lv">let fridgeHasApples = fridge.some(function (element) {<br/>  return element === '🍎';<br/>});</span><span id="61a1" class="lr kd jf li b gy mk lt l lu lv">fridgeHasApples; // true</span></pre><p id="95dc" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们检查一下我们的冰箱是否也有一些柠檬🍋在里面！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="0146" class="lr kd jf li b gy ls lt l lu lv">let fridge = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="d421" class="lr kd jf li b gy mk lt l lu lv">let fridgeHasLemons = fridge.some(function (element) {<br/>  return element === '🍋';<br/>});</span><span id="6804" class="lr kd jf li b gy mk lt l lu lv">fridgeHasLemons; // false</span></pre><p id="2c0a" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">啊哦！我们需要买些杂货，因为柠檬用完了🍋！</p><h1 id="9754" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">检查数组中的<code class="fe lf lg lh li b">every</code>元素</h1><p id="f4ac" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">every(predicate)</code>方法，我们可以确定数组中的每个元素是否都匹配给定的谓词。这个方法返回<code class="fe lf lg lh li b">true</code>或<code class="fe lf lg lh li b">false</code>，这取决于是否所有的元素都匹配谓词。这个方法还为空数组上的任何谓词返回<code class="fe lf lg lh li b">true</code>。</p><p id="041f" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">假设我们想检查冰箱里所有的水果是否都是苹果🍎。我们如何做到这一点？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="be99" class="lr kd jf li b gy ls lt l lu lv">let fridge = ['🍎', '🍎', '🍎', '🍎', '🍎'];</span><span id="cfa2" class="lr kd jf li b gy mk lt l lu lv">let everythingIsApple = fridge.every(function (element) {<br/>  return element === '🍎';<br/>});</span><span id="1360" class="lr kd jf li b gy mk lt l lu lv">everythingIsApple; // true</span></pre><p id="80b0" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们检查一下冰箱，里面有更多不同的水果。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="0b4e" class="lr kd jf li b gy ls lt l lu lv">let fridge = ['🍊', '🍎', '🍐', '🍉', '🍌'];</span><span id="2b88" class="lr kd jf li b gy mk lt l lu lv">let everythingIsApple = fridge.every(function (element) {<br/>  return element === '🍎';<br/>});</span><span id="5be1" class="lr kd jf li b gy mk lt l lu lv">everythingIsApple; // false</span></pre><h1 id="60b1" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用<code class="fe lf lg lh li b">fill</code>改变数组中的元素</h1><p id="2ab5" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">fill(element, from, to)</code>方法，我们可以改变数组中的值。</p><p id="dd16" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们试着在冰箱里装满苹果🍎！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="910c" class="lr kd jf li b gy ls lt l lu lv">let fridge = ['', '', '', '', ''];</span><span id="702d" class="lr kd jf li b gy mk lt l lu lv">fridge.fill('🍎');</span><span id="5665" class="lr kd jf li b gy mk lt l lu lv">fridge; // ['🍎', '🍎', '🍎', '🍎', '🍎']</span></pre><p id="fb79" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在让我们试着在冰箱里放些梨🍐但是就在冰箱的2到4号空间里！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="4346" class="lr kd jf li b gy ls lt l lu lv">let fridge = ['', '', '', '', ''];</span><span id="a693" class="lr kd jf li b gy mk lt l lu lv">fridge.fill('🍐', 1, 3);</span><span id="1146" class="lr kd jf li b gy mk lt l lu lv">fridge; // ['🍎', '🍐', '🍐', '🍐, '🍎']</span></pre><p id="297f" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">关于<code class="fe lf lg lh li b">fill</code>方法，你现在应该知道一些有趣的事情。</p><ul class=""><li id="ab3a" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb ml mc md me bi translated">如果不使用<code class="fe lf lg lh li b">from</code>，默认为0(零)。</li><li id="a6f5" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">如果<code class="fe lf lg lh li b">from</code>为负，则计算为<code class="fe lf lg lh li b">array.length + from</code>。</li><li id="ddc2" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">如果不使用<code class="fe lf lg lh li b">to</code>，默认使用<code class="fe lf lg lh li b">array.length</code>。</li><li id="d078" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">如果<code class="fe lf lg lh li b">to</code>为负，则计算为<code class="fe lf lg lh li b">array.length + to</code>。</li><li id="9d32" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">方法<code class="fe lf lg lh li b">fill</code>改变了数组，应该小心使用，以免引入错误🐞。</li><li id="4824" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">如果<code class="fe lf lg lh li b">element</code>是一个对象，它将复制它的引用并用对它的引用填充数组。</li></ul><h1 id="3e52" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">对数组中的元素排序</h1><p id="2283" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">sort(function(a, b) { })</code>方法，我们可以对数组中的元素进行排序。如果你不把一个排序函数作为主要的和唯一的参数传递给<code class="fe lf lg lh li b">sort</code>方法，它将使用基于它的Unicode位置的字符串值。这个方法改变了原始数组，应该小心使用，以免引入错误🐞。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="a253" class="lr kd jf li b gy ls lt l lu lv">let numbers = [4, 2, 3, 5, 1, 6, 9];</span><span id="c9be" class="lr kd jf li b gy mk lt l lu lv">numbers.sort(); // [1, 2, 3, 4, 5, 6, 9]</span></pre><p id="e23c" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们看看另一个例子，但这次数组将包含字符串。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="179d" class="lr kd jf li b gy ls lt l lu lv">let fruit = ['bananas', 'lemons', 'apples'];</span><span id="fb41" class="lr kd jf li b gy mk lt l lu lv">fruit.sort(); // ["apples", "bananas", "lemons"]</span></pre><p id="99ea" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们要引入我们自己的<code class="fe lf lg lh li b">compare function</code>，这样我们就可以让<code class="fe lf lg lh li b">sort</code>方法像我们想要的那样运行。假设我们有一个包含柱子的数组，柱子是具有以下形状的对象:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="0312" class="lr kd jf li b gy ls lt l lu lv">let post = {<br/>  title: 'Hello there',<br/>  createdAt: new Date('03/23/2021'),<br/>  content: '...'<br/>};</span><span id="d229" class="lr kd jf li b gy mk lt l lu lv">let posts = [<br/>  { title: 'Hello there 3', createdAt: new Date('05/23/2021'), content: '...' },<br/>  { title: 'Hello there 2', createdAt: new Date('04/23/2021'), content: '...' },<br/>  { title: 'Hello there 4', createdAt: new Date('06/23/2021'), content: '...' },<br/>  { title: 'Hello there 1', createdAt: new Date('03/23/2021'), content: '...' }<br/>];</span><span id="1398" class="lr kd jf li b gy mk lt l lu lv">posts.sort(function (postA, postB) {<br/>  if (postA.createdAt.getTime() === postB.createdAt.getTime()) return 0;<br/>  if (postA.createdAt.getTime() &gt; postB.createdAt.getTime()) return -1;<br/>  if (postA.createdAt.getTime() &lt; postB.createdAt.getTime()) return 1;<br/>});</span></pre><p id="dc48" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">我们实现了一个排序函数，通过<code class="fe lf lg lh li b">createdAt</code>属性对文章进行排序，因为该属性包含一个<code class="fe lf lg lh li b">Date</code>对象，所以我们可以使用它的<code class="fe lf lg lh li b">getTime</code>函数来检索自Unix时间(1970年1月1日)以来经过的毫秒数，然后我们使用这个数字来比较哪个更大。排序函数希望您以特定的方式返回一个数字:</p><ul class=""><li id="7ca6" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb ml mc md me bi translated">如果比较函数返回一个小于0的数字，它将把<code class="fe lf lg lh li b">postA</code>放在比<code class="fe lf lg lh li b">postB</code>更低的索引中。</li><li id="aff5" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">如果比较函数返回一个大于0的数字，它将把<code class="fe lf lg lh li b">postB</code>放在比<code class="fe lf lg lh li b">postA</code>更低的索引中。</li><li id="2a68" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">如果比较函数返回0，它不会改变<code class="fe lf lg lh li b">postA</code>或<code class="fe lf lg lh li b">postB</code>索引。</li><li id="9704" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb ml mc md me bi translated">给定一对特定的元素a和b以及它们的参数，compare函数总是需要返回相同的值。</li></ul><p id="58d5" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">了解了这一点，您就可以按照自己喜欢的任何方式对数组进行排序。在上面的例子中，我们颠倒了<code class="fe lf lg lh li b">-1</code>和<code class="fe lf lg lh li b">1</code>，通过这样做，我们以降序的方式对数组进行排序。</p><h1 id="0970" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><code class="fe lf lg lh li b">Map</code>(迭代)数组中的元素</h1><p id="ef85" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">map(function(element, index))</code>方法，我们可以迭代元素，并将函数调用的结果应用于每个元素，并返回一个包含结果的新数组。</p><p id="4c29" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">假设我们有一篮子水果，但这一次，每个水果都是一个JavaScript对象，如下所示:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="de42" class="lr kd jf li b gy ls lt l lu lv">let fruitObject = {<br/>  fruit: '🍎',<br/>  amount: 1<br/>};</span></pre><p id="58fb" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">fruitObject</code>将包含两个属性，一个名为<code class="fe lf lg lh li b">fruit</code>的属性包含水果本身，另一个名为<code class="fe lf lg lh li b">amount</code>的属性包含我们有多少水果。在上面的例子中，我们有一个(<code class="fe lf lg lh li b">amount: 1</code>)苹果(<code class="fe lf lg lh li b">fruit: '🍎'</code>)。</p><p id="9ee3" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们把冰箱装满水果吧！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="a1b5" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 1 },<br/>  { fruit: '🍎', amount: 1 },<br/>  { fruit: '🍐', amount: 1 },<br/>  { fruit: '🍉', amount: 1 },<br/>  { fruit: '🍌', amount: 1 }<br/>];</span></pre><p id="6c9e" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们的冰箱里装满了美味多汁的水果😋让我们买些杂货，因为你应该总是试着让你的冰箱装满健康的水果。我们需要考虑到我们的冰箱没有足够的空间来存放所有的水果，所以除了西瓜，我们将每种水果买5件🍉，我们只需要两个，因为它太大了，我们无法把它们都放在冰箱里。我们如何做到这一点？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="37af" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 1 },<br/>  { fruit: '🍎', amount: 1 },<br/>  { fruit: '🍐', amount: 1 },<br/>  { fruit: '🍉', amount: 1 },<br/>  { fruit: '🍌', amount: 1 }<br/>];</span><span id="1125" class="lr kd jf li b gy mk lt l lu lv">let fridgeFullOfFruit = fridge.map(function (fruitObject) {<br/>  if (fruitObject.fruit !== '🍉') {<br/>    return {<br/>      fruit: fruitObject.fruit,<br/>      amount: 5<br/>    };<br/>  } else {<br/>    return {<br/>      fruit: fruitObject.fruit,<br/>      amount: 2<br/>    };<br/>  }<br/>});</span></pre><p id="ed32" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们消化一下上面所做的。我们已经创建了一个名为<code class="fe lf lg lh li b">fridgeFullOfFruit</code>的新变量，在这里我们将存储买完杂货后的所有水果。然后我们对存储在<code class="fe lf lg lh li b">fridge</code>变量中的<code class="fe lf lg lh li b">fruitObjects</code>进行<code class="fe lf lg lh li b">map</code>(迭代)，正如我们已经知道的，来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">map</code>方法是一个回调函数，最多有三个参数:</p><ol class=""><li id="00db" class="lw lx jf jg b jh ji jl jm jp ly jt lz jx ma kb mb mc md me bi translated">当前正在迭代的元素。</li><li id="bfcf" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">迭代的索引。</li><li id="90d5" class="lw lx jf jg b jh mf jl mg jp mh jt mi jx mj kb mb mc md me bi translated">被迭代的数组。</li></ol><p id="8124" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">在这个特定的场景中，我们只使用当前正在迭代的元素，所以我们可以安全地忽略其他两个参数，这就是为什么我们的回调函数有下面的签名<code class="fe lf lg lh li b">function(fruitObject) {}</code>，因为我们在迭代过程中只使用当前元素。</p><p id="bbe8" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">然后，我们需要在函数中创建逻辑，并将其应用于数组中的每个元素:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b461" class="lr kd jf li b gy ls lt l lu lv">if (fruitObject.fruit !== '🍉') {<br/>  return {<br/>    fruit: fruitObject.fruit,<br/>    amount: 5<br/>  };<br/>} else {<br/>  return {<br/>    fruit: fruitObject.fruit,<br/>    amount: 2<br/>  };<br/>}</span></pre><p id="bc46" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">我们正在检查<code class="fe lf lg lh li b">fruitObject</code>中的<code class="fe lf lg lh li b">fruit</code>属性是否不是西瓜🍉如果不是，我们将返回一个带有相应水果和数量5的<code class="fe lf lg lh li b">fruitObject</code>,这是我们想为除西瓜之外的所有水果购买的水果数量🍉其数量应该是2。</p><p id="7f06" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">为了这个例子，我们已经使这个代码更加显式，但是我们可以利用带有隐式返回的<code class="fe lf lg lh li b">arrow functions</code>和一个三元运算符来使这个代码更加紧凑。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="461b" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 1 },<br/>  { fruit: '🍎', amount: 1 },<br/>  { fruit: '🍐', amount: 1 },<br/>  { fruit: '🍉', amount: 1 },<br/>  { fruit: '🍌', amount: 1 }<br/>];</span><span id="f3d9" class="lr kd jf li b gy mk lt l lu lv">let fridgeFullOfFruit = fridge.map((fruitObject) =&gt; ({<br/>  ...fruitObject,<br/>  amount: fruitObject.fruit !== '🍉' ? 5 : 2<br/>}));</span></pre><h1 id="ea39" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><code class="fe lf lg lh li b">filter</code>查找元素的数组</h1><p id="3a39" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">filter(function(element, index))</code>方法，我们可以迭代元素，并通过返回<code class="fe lf lg lh li b">true</code>或<code class="fe lf lg lh li b">false</code>返回与回调函数上实现的条件相匹配的元素。这个<code class="fe lf lg lh li b">filter</code>方法会像<code class="fe lf lg lh li b">map</code>方法一样生成一个新的数组。</p><p id="597b" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们想象一下，我们有与之前在<code class="fe lf lg lh li b">map</code>示例中相同的<code class="fe lf lg lh li b">fruitObject</code>元素。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="1590" class="lr kd jf li b gy ls lt l lu lv">let fruitObject = {<br/>  fruit: '🍎',<br/>  amount: 1<br/>};</span></pre><p id="b264" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们将所有相应的水果放入冰箱，但这一次，其中一些水果的数量为0(零),我们将使用这个<code class="fe lf lg lh li b">amount</code>属性来过滤我们需要购买的元素，以便我们可以将水果重新放入冰箱。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="3e30" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 0 },<br/>  { fruit: '🍎', amount: 1 },<br/>  { fruit: '🍐', amount: 0 },<br/>  { fruit: '🍉', amount: 1 },<br/>  { fruit: '🍌', amount: 0 }<br/>];</span></pre><p id="6123" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们需要<code class="fe lf lg lh li b">filter</code>所有这些<code class="fe lf lg lh li b">fruitObjects</code>来确定我们需要根据每个对象的<code class="fe lf lg lh li b">amount</code>属性购买哪些对象。我们如何做到这一点？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="d780" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 0 },<br/>  { fruit: '🍎', amount: 1 },<br/>  { fruit: '🍐', amount: 0 },<br/>  { fruit: '🍉', amount: 1 },<br/>  { fruit: '🍌', amount: 0 }<br/>];</span><span id="27aa" class="lr kd jf li b gy mk lt l lu lv">let shoppingList = fridge.filter(function (fruitObject) {<br/>  if (fruitObject.amount === 0) {<br/>    return true;<br/>  } else {<br/>    return false;<br/>  }<br/>});</span></pre><p id="9afc" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">在用给定的回调函数过滤了<code class="fe lf lg lh li b">fridge</code>数组后，我们将有一个新的数组(<code class="fe lf lg lh li b">shoppingList</code>变量)包含以下内容:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b9e2" class="lr kd jf li b gy ls lt l lu lv">[<br/>  { fruit: '🍊', amount: 0 },<br/>  { fruit: '🍐', amount: 0 },<br/>  { fruit: '🍌', amount: 0 }<br/>];</span></pre><p id="5855" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">作为一个奖励，现在我们可以通过这个新的<code class="fe lf lg lh li b">shoppingList</code>数组来做一些杂货！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="f248" class="lr kd jf li b gy ls lt l lu lv">let shoppingList = [<br/>  { fruit: '🍊', amount: 0 },<br/>  { fruit: '🍐', amount: 0 },<br/>  { fruit: '🍌', amount: 0 }<br/>];</span><span id="651c" class="lr kd jf li b gy mk lt l lu lv">let shoppingBasket = shoppingList.map((fruitObject) =&gt; ({<br/>  ...fruitObject,<br/>  amount: 5<br/>}));</span></pre><p id="e08a" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们有一个装满新鲜多汁水果的购物篮了！😋</p><h1 id="31c7" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><code class="fe lf lg lh li b">reduce</code>数组值为单个值</h1><p id="0f77" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">reduce(function(accumulator, value, index), initialValue)</code>方法，我们可以迭代元素并返回一个值。<code class="fe lf lg lh li b">reduce</code>函数的第二个参数是<code class="fe lf lg lh li b">initialValue</code>，它将被用作累加器的初始值。如果你没有传递任何东西作为这个参数，它将使用数组的第一个值，它将被跳过。我的建议是，总是传递一些东西给这个参数，只是为了更清楚你最终期望得到什么，另外，如果你使用TypeScript，你会得到非常好的智能感知🙃</p><p id="15dc" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们再次想象一下，我们有一个装满水果的冰箱，形状像一个javascript对象，如下所示:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="d20d" class="lr kd jf li b gy ls lt l lu lv">let fruitObject = {<br/>  fruit: '🍎',<br/>  amount: 1<br/>};</span></pre><p id="0aeb" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在我们想检查一下冰箱里总共储存了多少水果。我们如何做到这一点？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="82d3" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 2 },<br/>  { fruit: '🍎', amount: 4 },<br/>  { fruit: '🍐', amount: 1 },<br/>  { fruit: '🍉', amount: 0 },<br/>  { fruit: '🍌', amount: 3 }<br/>];</span><span id="fc5e" class="lr kd jf li b gy mk lt l lu lv">let amountOfFruits = fridge.reduce(function (accumulated, fruitObject) {<br/>  return accumulated + fruitObject.amount;<br/>}, 0);</span><span id="3e8a" class="lr kd jf li b gy mk lt l lu lv">amountOfFruits; // 2 + 4 + 1 + 0 + 3 = 10</span></pre><p id="4776" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">当你想操作数组以从它们那里获得一些值时，<code class="fe lf lg lh li b">reduce</code>方法是一个非常方便的函数，但是你必须记住，这个函数的计算开销非常大，所以，如果你的CPU预算很低或者你想让你的应用程序尽可能地保持最佳性能，你应该尽量避免使用它。作为一个更高性能的选择，你可以使用如下的<code class="fe lf lg lh li b">for loop</code>,因为它是值得的👌🏻</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="d3e4" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 2 },<br/>  { fruit: '🍎', amount: 4 },<br/>  { fruit: '🍐', amount: 1 },<br/>  { fruit: '🍉', amount: 0 },<br/>  { fruit: '🍌', amount: 3 }<br/>];</span><span id="7d20" class="lr kd jf li b gy mk lt l lu lv">let amountOfFruits = 0;<br/>let fruitsOnTheFridge = fridge.length;</span><span id="19dc" class="lr kd jf li b gy mk lt l lu lv">for (let index = 0; index &lt;= fruitsOnTheFridge; index++) {<br/>  amountOfFruits += fridge[index].amount;<br/>}</span><span id="e81c" class="lr kd jf li b gy mk lt l lu lv">amountOfFruits; // 2 + 4 + 1 + 0 + 3 = 10</span></pre><h1 id="d162" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">用一个<code class="fe lf lg lh li b">for of</code>循环迭代一个数组</h1><p id="40f8" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">另一种迭代数组的方法是使用<code class="fe lf lg lh li b">for of</code>循环，这是一种非常简单易读的循环类型。</p><p id="f74a" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们迭代一下冰箱上的水果！</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="377b" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  { fruit: '🍊', amount: 2 },<br/>  { fruit: '🍎', amount: 4 },<br/>  { fruit: '🍐', amount: 1 },<br/>  { fruit: '🍉', amount: 0 },<br/>  { fruit: '🍌', amount: 3 }<br/>];</span><span id="7b41" class="lr kd jf li b gy mk lt l lu lv">for (let fruit of fridge) {<br/>  console.log(fruit);<br/>}</span><span id="4f37" class="lr kd jf li b gy mk lt l lu lv">// {fruit: "🍊", amount: 2}<br/>// {fruit: "🍎", amount: 4}<br/>// {fruit: "🍐", amount: 1}<br/>// {fruit: "🍉", amount: 0}<br/>// {fruit: "🍌", amount: 3}</span></pre><p id="3c01" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">从上面的代码片段可以看出，这是一种更简单的迭代数组的方式。对于每一次迭代，它将当前索引元素的值存储在<code class="fe lf lg lh li b">fruit</code>变量中，您可以随意使用它来操作它。</p><h1 id="6c10" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">创建数组<code class="fe lf lg lh li b">from</code></h1><p id="f741" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">from(arrayLikeObject, mapFunction)</code>方法，我们可以从一个可迭代对象创建一个新的<code class="fe lf lg lh li b">Array</code>。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="75c3" class="lr kd jf li b gy ls lt l lu lv">let fruitsString = '🍊🍎🍐🍉🍌';<br/>let fruits = Array.from(fruitsString);</span><span id="8a45" class="lr kd jf li b gy mk lt l lu lv">fruits; // ['🍊', '🍎', '🍐', '🍉', '🍌']</span></pre><p id="7e74" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">在上面的例子中，我们使用了一个字符串，在JavaScript中，字符串是一个类似数组的对象，因为它有一个<code class="fe lf lg lh li b">length</code>属性，但是也可以使用任何有<code class="fe lf lg lh li b">length</code>属性或索引元素的对象。这里也可以使用<code class="fe lf lg lh li b">Map</code>和<code class="fe lf lg lh li b">Set</code>对象，因为它们是可迭代的，因此完全有效。</p><p id="cd55" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated"><code class="fe lf lg lh li b">from</code>方法的第二个参数是一个回调函数，用于在元素创建后对其进行迭代，这意味着我们可以对每个元素应用一些逻辑，如下所示:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="945f" class="lr kd jf li b gy ls lt l lu lv">let fruitsString = '🍊🍎🍐🍉🍌';<br/>let fruits = Array.from(fruitsString, function (element) {<br/>  return {<br/>    fruit: element,<br/>    amount: 5<br/>  };<br/>});</span><span id="5c6d" class="lr kd jf li b gy mk lt l lu lv">// {fruit: "🍊", amount: 5}<br/>// {fruit: "🍎", amount: 5}<br/>// {fruit: "🍐", amount: 5}<br/>// {fruit: "🍉", amount: 5}<br/>// {fruit: "🍌", amount: 5}</span></pre><p id="6879" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">正如我们在上面的代码片段中看到的，这个方法非常灵活和强大，我们已经创建了一个带有我们想要的自定义属性的对象数组。</p><p id="32bb" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">##将数组中的元素连接成字符串</p><p id="46fa" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">join(separator)</code>方法，我们可以将一个数组的元素连接成一个字符串。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="5959" class="lr kd jf li b gy ls lt l lu lv">let fruits = ['🍊', '🍎', '🍐', '🍉', '🍌'];<br/>let fruitsString = fruits.join();</span><span id="2946" class="lr kd jf li b gy mk lt l lu lv">fruitsString; // "🍊,🍎,🍐,🍉,🍌"</span></pre><p id="2be9" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">从上面的代码片段中我们可以看出，当没有提供<code class="fe lf lg lh li b">separator</code>参数时，<code class="fe lf lg lh li b">join</code>方法的行为有点奇怪，这是因为如果我们不提供任何参数，它将使用<code class="fe lf lg lh li b">,</code> (coma)来分隔元素。例如，如果您想将它们放在一起，您可以告诉<code class="fe lf lg lh li b">join</code>方法使用一个空字符串<code class="fe lf lg lh li b">''</code>作为分隔符。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="15db" class="lr kd jf li b gy ls lt l lu lv">let fruits = ['🍊', '🍎', '🍐', '🍉', '🍌'];<br/>let fruitsString = fruits.join('');</span><span id="0997" class="lr kd jf li b gy mk lt l lu lv">fruitsString; // "🍊🍎🍐🍉🍌"</span></pre><h1 id="83ab" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">检查值是否为<code class="fe lf lg lh li b">Array</code>。</h1><p id="3305" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">isArray(object)</code>方法，我们可以确定作为主参数传递的对象是否是一个<code class="fe lf lg lh li b">Array</code>。该方法将根据<code class="fe lf lg lh li b">object</code>是否满足要求返回<code class="fe lf lg lh li b">true</code>或<code class="fe lf lg lh li b">false</code>。</p><p id="b3c8" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们看看这在不同的正面(<code class="fe lf lg lh li b">true</code>)场景中的实际表现:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="e59a" class="lr kd jf li b gy ls lt l lu lv">Array.isArray([]); // true<br/>Array.isArray(['🍎']); // true<br/>Array.isArray(new Array()); // true<br/>Array.isArray(new Array('🍎', '🍐', '🍊')); // true<br/>Array.isArray(new Array(4)); // true<br/>Array.isArray(Array.prototype); // true</span></pre><p id="24e2" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在让我们看看这在不同的负面(<code class="fe lf lg lh li b">false</code>)场景中的实际表现:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b699" class="lr kd jf li b gy ls lt l lu lv">Array.isArray(); // false<br/>Array.isArray({}); // false<br/>Array.isArray(undefined); // false<br/>Array.isArray(null); // false<br/>Array.isArray(4); // false<br/>Array.isArray('OTPfy'); // false<br/>Array.isArray(true); // false<br/>Array.isArray(false); // false</span></pre><h1 id="8a80" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">展平数组</h1><p id="e920" class="pw-post-body-paragraph jd je jf jg b jh la jj jk jl lb jn jo jp lc jr js jt ld jv jw jx le jz ka kb ij bi translated">使用来自<code class="fe lf lg lh li b">Array</code>对象的<code class="fe lf lg lh li b">flat(depth)</code>方法，我们可以展平一个包含更多数组(子数组)作为值的数组。</p><p id="aa03" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">让我们想象一下，我们的冰箱里有不同的袋子，每个袋子里都装着水果，我们想从这些袋子里取出所有的水果，然后用这些水果做些事情。我们如何做到这一点？</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="e974" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  ['🍎', '🍎', '🍎', '🍎'], // apples bag<br/>  ['🍐', '🍐'], // pears bag<br/>  ['🍊'] // oranges bag<br/>];</span><span id="8910" class="lr kd jf li b gy mk lt l lu lv">let allFruits = fridge.flat();</span><span id="fb6d" class="lr kd jf li b gy mk lt l lu lv">allFruits; // ["🍎", "🍎", "🍎", "🍎", "🍐", "🍐", "🍊"]</span></pre><p id="4110" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">正如我们在上面的代码片段中看到的，当我们想要获得一个没有任何嵌套的单个数组时，<code class="fe lf lg lh li b">flat</code>方法变得非常方便。让我们看一个更复杂的例子:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="358d" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  ['🍎', '🍎', '🍎', '🍎'], // apples bag<br/>  ['🍐', ['🍐', '🍐']], // pears bag<br/>  [['🍊', ['🍊']], '🍊'] // oranges bag<br/>];</span><span id="096b" class="lr kd jf li b gy mk lt l lu lv">let allFruits = fridge.flat();</span><span id="2939" class="lr kd jf li b gy mk lt l lu lv">allFruits; // ["🍎", "🍎", "🍎", "🍎", "🍐", ["🍐", "🍐"], ["🍊", ["🍊"]], "🍊"]</span></pre><p id="7487" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">通过查看上述代码片段的输出，我们可以确定，如果我们不向<code class="fe lf lg lh li b">flat</code>方法的<code class="fe lf lg lh li b">depth</code>参数传递任何数值，它将只对数组元素的第一级行执行flatten操作。</p><p id="c9c0" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">现在让我们来看看如果我们向<code class="fe lf lg lh li b">depth</code>属性传递一个值会发生什么。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="3ca0" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  ['🍎', '🍎', '🍎', '🍎'], // apples bag<br/>  ['🍐', ['🍐', '🍐']], // pears bag<br/>  [['🍊', ['🍊']], '🍊'] // oranges bag<br/>];</span><span id="82a4" class="lr kd jf li b gy mk lt l lu lv">let allFruits = fridge.flat(2);</span><span id="2f64" class="lr kd jf li b gy mk lt l lu lv">allFruits; // ["🍎", "🍎", "🍎", "🍎", "🍐", "🍐", "🍐", "🍊", ["🍊"], "🍊"]</span></pre><p id="75b7" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">正如我们从输出中看到的，通过将<code class="fe lf lg lh li b">2</code>作为<code class="fe lf lg lh li b">depth</code>属性传递，它也在数组元素的第二级行上展平数组，但是，我们的数组是一个三级深度数组。让我们用三的<code class="fe lf lg lh li b">depth</code>拉平它，看看会发生什么。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="a5e3" class="lr kd jf li b gy ls lt l lu lv">let fridge = [<br/>  ['🍎', '🍎', '🍎', '🍎'], // apples bag<br/>  ['🍐', ['🍐', '🍐']], // pears bag<br/>  [['🍊', ['🍊']], '🍊'] // oranges bag<br/>];</span><span id="36e4" class="lr kd jf li b gy mk lt l lu lv">let allFruits = fridge.flat(2);</span><span id="02f8" class="lr kd jf li b gy mk lt l lu lv">allFruits; // ["🍎", "🍎", "🍎", "🍎", "🍐", "🍐", "🍐", "🍊", "🍊", "🍊"]</span></pre><p id="829b" class="pw-post-body-paragraph jd je jf jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ij bi translated">太好了，我们已经实现了将数组完全扁平化为单一深度数组的目标！</p></div></div>    
</body>
</html>