<html>
<head>
<title>Libraries and Using for in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图书馆与图书馆的使用</h1>
<blockquote>原文：<a href="https://itnext.io/libraries-and-using-for-in-solidity-5c954da04128?source=collection_archive---------2-----------------------#2019-04-24">https://itnext.io/libraries-and-using-for-in-solidity-5c954da04128?source=collection_archive---------2-----------------------#2019-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b027c1223c488e468f972d9eac161e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jwA-xx-16cVLVsxPNeJSkg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片取自<a class="ae kf" href="https://www.bennettinstitute.cam.ac.uk/blog/why-are-uks-public-libraries-declining/" rel="noopener ugc nofollow" target="_blank">https://www . bennettinstitute . cam . AC . uk/blog/why-are-uks-public-libraries-decning/</a></figcaption></figure><p id="d9f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">solidity是一种面向对象的高级语言，用于实现智能合约。智能合约是在以太坊状态下管理账户行为的程序。在本文中，我们将通过涵盖以下主题来了解两个可靠性特性<code class="fe le lf lg lh b">Libraries</code>和<code class="fe le lf lg lh b">Using for</code>:</p><ul class=""><li id="07ae" class="li lj it ki b kj kk kn ko kr lk kv ll kz lm ld ln lo lp lq bi translated">图书馆</li><li id="e861" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">用于</li><li id="6410" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">Solidity库和Solidity使用，例如在<a class="ae kf" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"> Remix </a>上。</li></ul><h1 id="8840" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">固体图书馆</h1><p id="2313" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Solidity库类似于契约，但是它们的目的是在一个特定的地址只部署一次，它的代码被不同的契约重用。如果调用库函数，它们的代码将在调用契约的上下文中执行。由于库是源代码的一个孤立部分，所以它只能访问调用契约的状态变量，如果它们被显式提供的话</p><blockquote class="mz na nb"><p id="af89" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">库不能有状态变量；他们不支持继承，也不能接收以太。但是，它们可以包含结构和枚举。</p></blockquote><p id="0a4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Solidity库一旦部署到区块链，任何人都可以使用，假设您知道它的地址并有源代码(只有原型或完整的实现)。solidity编译器需要源代码，这样它可以确保你试图访问的方法确实存在于库中</p><p id="b0b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实体库具有以下格式</p><pre class="ng nh ni nj gt nk lh nl nm aw nn bi"><span id="9a47" class="no lx it lh b gy np nq l nr ns">library libraryName<br/>{</span><span id="9871" class="no lx it lh b gy nt nq l nr ns">// struct and or enum declaration</span><span id="375b" class="no lx it lh b gy nt nq l nr ns">// function definition with body<br/>}</span></pre><blockquote class="mz na nb"><p id="532a" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><code class="fe le lf lg lh b">libraryName</code>可以改成自己喜欢的名字。库主体可以包含struct和/或enum声明，以及将在库中执行各种操作的函数。</p></blockquote><h2 id="3d04" class="no lx it bd ly nu nv dn mc nw nx dp mg kr ny nz mk kv oa ob mo kz oc od ms oe bi translated">可靠性库使用案例/优势</h2><p id="7e6f" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Solidity库有以下优点/用例</p><p id="5c83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">可用性</strong>:一个库中的函数可以被很多契约使用。如果您有许多包含一些公共代码的契约，那么您可以将这些公共代码部署为一个库。</p><p id="041f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经济实惠:将公共代码部署为库将节省汽油，因为汽油也取决于合同的大小。使用基础契约而不是库来分割公共代码不会节省汽油，因为在Solidity中，继承通过复制代码来工作。</p><p id="e307" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">好的插件</strong> : Solidity库可以用来给数据类型添加成员函数。</p><blockquote class="mz na nb"><p id="0046" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">Solidity库被称为使用它的契约的基础契约，因为它的函数具有内部可见性，并且它的所有结构和枚举都被复制到使用它的契约。此外，如果一个库只包含内部函数和/或结构/枚举，那么就不需要部署这个库，因为库中的所有内容都被复制到使用它的契约中。</p></blockquote><h2 id="d088" class="no lx it bd ly nu nv dn mc nw nx dp mg kr ny nz mk kv oa ob mo kz oc od ms oe bi translated"><strong class="ak"> Solidity库示例代码</strong></h2><p id="e671" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">将下面的代码复制到名为<code class="fe le lf lg lh b">libraryF.sol</code>的文件中</p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><ul class=""><li id="dc49" class="li lj it ki b kj kk kn ko kr lk kv ll kz lm ld ln lo lp lq bi translated">我们首先提到使用<code class="fe le lf lg lh b">pragma Solidity</code>指令编写代码的编译器版本</li><li id="5186" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">我们使用<code class="fe le lf lg lh b">library</code>关键字定义我们的库，并将其命名为<code class="fe le lf lg lh b">count</code></li><li id="c441" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">我们的库有一个结构和两个功能。</li></ul><blockquote class="mz na nb"><p id="4949" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><strong class="ki iu">注意</strong>函数<code class="fe le lf lg lh b">subUint</code>如何接收一个结构体作为参数。在Solidity v0.4.24中，这在契约中是不可能的，但在Solidity库中是可能的</p></blockquote><p id="d4be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.openzeppelin.org/docs/math_safemath" rel="noopener ugc nofollow" target="_blank">在<a class="ae kf" href="https://openzeppelin.org/" rel="noopener ugc nofollow" target="_blank">open zeppelin smart contracts collection</a>中可用的SafeMath </a>库是一个流行的solidity库，用于防止<a class="ae kf" href="https://ethereumdev.io/safemath-protect-overflows/" rel="noopener ugc nofollow" target="_blank">溢出</a>。</p><h1 id="a7c0" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">坚固性用于</h1><p id="e7a2" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Solidity库可以和Solidity <code class="fe le lf lg lh b">using for</code>一起使用。指令意味着我们附加库函数(从库A到任何类型B)。当这种情况发生时，这些函数将接收调用它们的对象作为它们的第一个参数，很像Python中的变量<code class="fe le lf lg lh b">self</code>。</p><blockquote class="mz na nb"><p id="5de3" class="kg kh nc ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><code class="fe le lf lg lh b">using A for *;</code>的作用是来自库A的函数被附加到所有类型上。</p></blockquote><p id="d377" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论哪种方式，每个单独的函数，包括那些第一个参数的类型与对象的类型不匹配的函数，都会被附加。调用函数时，除了执行函数重载解析之外，还会检查类型。</p><p id="9ba7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">比如:</strong>利用上面的<code class="fe le lf lg lh b">libraryF.sol</code>。我们可以对类型uint使用指令using for libraryF，如下所示；</p><pre class="ng nh ni nj gt nk lh nl nm aw nn bi"><span id="7e3a" class="no lx it lh b gy np nq l nr ns">import {count} from  './libraryF.sol';</span><span id="a914" class="no lx it lh b gy nt nq l nr ns">using count for uint;</span><span id="f89e" class="no lx it lh b gy nt nq l nr ns">uint a = 10;<br/>uint b= 10;</span><span id="5824" class="no lx it lh b gy nt nq l nr ns">uint c = a.subUint(b);</span></pre><p id="b61e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意</strong>:我们仍然可以做<code class="fe le lf lg lh b">uint c = a - b;</code>，它将返回相同的结果<code class="fe le lf lg lh b">0</code>。然而，我们的库有一些额外的属性，以防止溢出，例如；<code class="fe le lf lg lh b">assert(a &gt;= b);</code>检查以确保第一个操作数<code class="fe le lf lg lh b">a</code>大于或等于第二个操作数<code class="fe le lf lg lh b">b</code>，这样减法运算不会产生负值。</p><h1 id="ff0c" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">实度库和实度在混音上的应用。</h1><p id="9589" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我们学习了<code class="fe le lf lg lh b">Solidity libraries</code>和<code class="fe le lf lg lh b">Solidity using for</code>。现在是时候把所有的放在一起了。我们将使用<a class="ae kf" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"> Remix </a>，这是一个基于浏览器的编译器和IDE，使用户能够用Solidity语言构建以太坊契约并调试事务。</p><h2 id="2182" class="no lx it bd ly nu nv dn mc nw nx dp mg kr ny nz mk kv oa ob mo kz oc od ms oe bi translated">设置混音</h2><p id="fb5d" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在浏览器上打开<a class="ae kf" href="https://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"> Remix </a>并进行以下设置:</p><p id="1a12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择一个编译器(在本例中是版本:0.4.24)</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/c82d7f53598946f5604139bbb65d44a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEg6y4H9ANrNelQwYE5lZg.png"/></div></div></figure><p id="abae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建两个名为<code class="fe le lf lg lh b">libraryF.sol</code>和<code class="fe le lf lg lh b">article_tuts.sol</code>的文件。要创建一个文件，你应该点击左上方的加号图标，如下图所示。这些文件将在<strong class="ki iu">浏览器</strong>下的左侧面板中找到并易于访问</p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/c233a0985432a368f1fdf7215788de43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbGu2Vn6VLuDY8Ywjgmv0A.png"/></div></div></figure><h2 id="3d49" class="no lx it bd ly nu nv dn mc nw nx dp mg kr ny nz mk kv oa ob mo kz oc od ms oe bi translated">编写您的可靠性函数</h2><p id="1762" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">将上面<strong class="ki iu">实体库示例代码</strong>中提供的代码行复制到文件<code class="fe le lf lg lh b">libraryF.sol</code>中</p><p id="f349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将下面的代码行复制到文件<code class="fe le lf lg lh b">article_tuts.sol</code></p><figure class="ng nh ni nj gt ju"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="255a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于上面的代码，我们应该知道一些事情</p><ul class=""><li id="8743" class="li lj it ki b kj kk kn ko kr lk kv ll kz lm ld ln lo lp lq bi translated">我们已经从文件<code class="fe le lf lg lh b">libraryF.sol</code>中导入了我们的库<strong class="ki iu">计数</strong></li><li id="6d2c" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">我们使用<code class="fe le lf lg lh b">using for</code>将我们的库计数链接到一个<code class="fe le lf lg lh b">struct</code>和<code class="fe le lf lg lh b"> uint</code>类型。</li><li id="fc5f" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">第一个函数<code class="fe le lf lg lh b">add</code>将调用我们的库函数<code class="fe le lf lg lh b">addUint</code>，这将把<code class="fe le lf lg lh b">b</code>添加到<code class="fe le lf lg lh b">a</code>。注意这里我们使用格式<code class="fe le lf lg lh b">a.addUint(b);</code>,意思是<code class="fe le lf lg lh b">a</code>作为库函数的第一个参数被自动传递。</li><li id="f440" class="li lj it ki b kj lr kn ls kr lt kv lu kz lv ld ln lo lp lq bi translated">第二个功能<code class="fe le lf lg lh b">subHold</code>与第一个功能相同。因为这个库函数接受一个struct对象作为第一个参数，这就是为什么我们使用了<code class="fe le lf lg lh b">hh[0].subUint(a);</code>，其中<code class="fe le lf lg lh b">hh[0]</code>是自动作为第一个参数传递的struct对象。</li></ul><h2 id="56df" class="no lx it bd ly nu nv dn mc nw nx dp mg kr ny nz mk kv oa ob mo kz oc od ms oe bi translated">部署并运行</h2><p id="aa2e" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">选择环境<strong class="ki iu"> JavaScrip VM </strong></p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/e31c1a5007ca74a72867b1d6b32f7283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FAWwKasgirtcxk92hVRpdQ.png"/></div></div></figure><p id="300d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">部署合同<strong class="ki iu">数学</strong></p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/2e2afcab6c9b152b2484fbde0cfb0172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMUgz2D27xkYy6WO7b_oFQ.png"/></div></div></figure><p id="6e2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">执行各种操作(<strong class="ki iu">添加</strong>和<strong class="ki iu">子保持</strong></p><figure class="ng nh ni nj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/34f3ca9371a2b8bec6343d0d7c4a7fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7qZBztQmOg2PTyIOIl2uA.png"/></div></div></figure><h1 id="4dd5" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">谢谢你</h1><p id="6b32" class="pw-post-body-paragraph kg kh it ki b kj mu kl km kn mv kp kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">干得好！！🙌</p><p id="edd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢你的阅读，我希望这篇文章能帮助你理解<code class="fe le lf lg lh b">using for </code>和<code class="fe le lf lg lh b">libraries</code>。</p><p id="ca7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快乐编码😇</p></div></div>    
</body>
</html>