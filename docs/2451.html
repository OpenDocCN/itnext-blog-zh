<html>
<head>
<title>Angular &amp; RxJS: Detecting Memory Leaks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular &amp; RxJS:检测内存泄漏</h1>
<blockquote>原文：<a href="https://itnext.io/angular-rxjs-detecting-memory-leaks-bdd312a070a0?source=collection_archive---------1-----------------------#2019-05-27">https://itnext.io/angular-rxjs-detecting-memory-leaks-bdd312a070a0?source=collection_archive---------1-----------------------#2019-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经使用RxJS构建了一个示例Angular应用程序来模拟各种内存泄漏。这些技术中的大多数都适用于任何使用RxJS的基于组件的框架。</p><p id="67d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://github.com/Everduin94/memory-leaks-rxjs" rel="noopener ugc nofollow" target="_blank">下载源代码🚀</a></p><p id="9386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将涵盖:</p><ol class=""><li id="19e4" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">检测内存泄漏的策略</li><li id="dce6" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">取消订阅和垃圾收集</li><li id="07f2" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">解决基于订阅的内存泄漏的解决方案</li></ol><h1 id="d139" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">检测内存泄漏的策略</h1><p id="cdd8" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在谷歌浏览器中使用谷歌浏览器开发工具🛠 (Ctrl+Shift+I)</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/671722bcd886924201a2956703bb9734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*Vdpx6qWXaG8Vgr612FlMSg.png"/></div></figure><h2 id="a21d" class="mo le it bd lf mp mq dn lj mr ms dp ln kb mt mu lr kf mv mw lv kj mx my lz mz bi translated"><strong class="ak">分配时间表📈</strong></h2><p id="9462" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">分配时间表允许我们查看堆的最小大小是否随着时间的推移而增长。在创建或销毁任何组件之前，我们将从基线开始。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/ec0cb722cecda3ee5a98fc9cf24e7b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wJuyDE4eSxijssxdP8UKg.png"/></div></div></figure><p id="f75f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当时间线运行时，我们将多次创建/销毁LargeLeak组件。注意，我在过滤器中输入了large，因为我们正在寻找LargeLeakComponent的分配</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nf"><img src="../Images/a6642712caf963df6b051fbacd7cc17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llr0aXPbsxkingnCbJ_WSg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">LargeLeakComponent.ts</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nk"><img src="../Images/2b36bd24e752723819c8fe1143914761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BO3vR8RBXPWLFV0qjTsf9g.png"/></div></div></figure><p id="7dcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们回到起点(销毁LargeLeakComponent) →手动运行垃圾收集(左上角的🗑垃圾桶图标)→重新启动分配时间线(左上角的⚫圈图标)。我们可以看到我们的最小堆大小增加了，分配没有被释放。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/1a2c221f4b3ef11a404963f78b18f1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBu2ckm9fsFgEgDTOfuEZw.png"/></div></div></figure><h2 id="b067" class="mo le it bd lf mp mq dn lj mr ms dp ln kb mt mu lr kf mv mw lv kj mx my lz mz bi translated"><strong class="ak">堆快照📸</strong></h2><p id="58f6" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">一旦我们确定了泄漏，堆快照就非常有用。不同于分配时间表🐌，当我们与应用程序交互时，堆快照不会导致延迟。最终，快照和分配时间表都可以用来检测泄漏。</p><p id="a89f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在应用程序中做任何事情之前，我们将从堆快照开始。这将是我们的基线或起点。我们可以看到已经分配了0个ServiceObservableLeak组件。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/a44f117dffc944032a5f83b3bd485558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZswZXkVnYbHLQEfKK417w.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">ServiceObservableLeak.ts</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/83720a96ac7735c30d21d2cab792d2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Adn3R1c5QUmygfjhN1F_uA.png"/></div></div></figure><p id="f562" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多次切换创建/销毁后→手动运行垃圾收集🗑→并拍摄另一个⚫.快照我们可以看到组件没有通过垃圾收集来释放。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/0bb9e82e791351b96c1e8f762d2838dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwsguLButwYr3KpMpymzsQ.png"/></div></div></figure><p id="06a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，只搜索组件并不总是查找内存泄漏的有效方法。如果我们假设存在内存泄漏，我们还应该检查内存中的订阅者数量。🔍使用快照比较(筛选器旁边的下拉菜单)，我们可以比较两个独立的快照。这表明我们已经分配了30个订户，删除了0个。在“取消订阅和垃圾收集”中有更多关于这方面的内容。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi np"><img src="../Images/504198017b340bc48eadbac1b0be585d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCa53K2eFIaHJL9f5d8Abw.png"/></div></div></figure><h1 id="c5a3" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">取消订阅和垃圾收集</strong></h1><p id="1ce8" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">人们经常提到，订阅持有对组件的引用。因此，组件不能被释放，造成内存泄漏。不能释放任何一个相互引用的对象称为循环。<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">【1】</a></p><p id="e61b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">周期是“引用计数垃圾收集”算法的一个限制。现代浏览器使用“标记-清除”算法🎯。标记和清除算法将从根(全局对象)收集所有不可到达的对象。这解决了循环的局限性。</p><p id="1855" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过测试局部有限可观察值来验证垃圾收集器处理周期的想法。当我们切换本地有限组件→手动运行垃圾收集🗑→时，获取堆快照⚫.</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/69c8bbd8b4307ec47a3951621dd47941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlBEXQdubKn1SVmEJvKYRQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">FiniteObservableComponent.ts</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nr"><img src="../Images/8f3844a296a649f33acfd67f36be84dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0xqb0-41cnJzSwIBoxksQ.png"/></div></div></figure><p id="9008" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到组件没有泄漏，即使我们没有使用订阅管理策略(比如取消订阅)。</p><blockquote class="ns nt nu"><p id="d77f" class="jq jr nv js b jt ju jv jw jx jy jz ka nw kc kd ke nx kg kh ki ny kk kl km kn im bi translated">“所以我可以让垃圾收集来管理我的订阅？”</p></blockquote><p id="cc04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">号</strong></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/548460b0a31079ae514e787222347ebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*Ff1G3XhbyobCrSl-eTuTQg.gif"/></div></figure><p id="137e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果订阅/组件仍然有一些对根的引用，它将不会被垃圾收集。我们可以在前一个示例的ServiceObservableLeak组件中看到这一点。因为我们的observable (observable$)是在服务(SourceService)中分配的，所以组件仍然有一个通过observable返回到根的引用。我们需要取消订阅组件(ServiceObservableLeakComponent)才能进行垃圾收集。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oa"><img src="../Images/58650bee0dbf4262eb315cac1d42e8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_TxSruza9lrfFtZLPdjBw.png"/></div></div></figure><p id="41eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不管理订阅是一种不好的做法，应该避免。以FromEvent组件为例。该组件初始化一个本地可观察对象，该对象在FromEventComponent中监视按钮上的点击事件。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi ob"><img src="../Images/ada1fc6033fb7cac1f43af2cc59a6273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFLR2OrVSsqrc6z5SpWHJQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">FromEventComponent.ts</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oc"><img src="../Images/aaa1d3026086af8a7bbf45d9d2f1db28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nh5DWQ0OtThb0EiUD6_2mg.png"/></div></div></figure><p id="ea2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，组件被释放，但是订户没有被释放。更复杂的是，只有当点击事件至少被触发一次时，订阅者才会泄漏。这造成了很难跟踪的内存泄漏。—解决方案是始终管理您的订阅。</p><h1 id="e240" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">解决方案</strong></h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b1b3f5ba4c2a76692a90f03e395cccfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*wcP6X0HAqUQGm2usP-jhbA.gif"/></div></figure><p id="0e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我计划在以后的文章中更详细地介绍这些方法。现在，这里是一个高层次的概述。🌎</p><h2 id="eb02" class="mo le it bd lf mp mq dn lj mr ms dp ln kb mt mu lr kf mv mw lv kj mx my lz mz bi translated">取消订阅</h2><p id="c384" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">取消订阅ngOnDestroy方法中的所有订阅是一种有效的策略。这类似于异步管道在组件级所做的事情。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi oe"><img src="../Images/192638b1af7bb4eea867f77c31c3346d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePafZp5DswpHRrjgxZM-lw.png"/></div></div></figure><h2 id="8b5c" class="mo le it bd lf mp mq dn lj mr ms dp ln kb mt mu lr kf mv mw lv kj mx my lz mz bi translated">异步管道</h2><p id="7b93" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">将根据与之关联的DOM元素的生命周期来管理您的订阅。无论在哪里声明，异步管道都将进行新的订阅。使用“as”重复使用提供的值。</p><p id="c551" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经写了关于异步管道以及如何使用它的详细内容<a class="ae ko" href="https://medium.com/@erxk_verduin/angular-rxjs-async-pipe-deep-dive-2510b56f793a" rel="noopener">在这里【2】</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi of"><img src="../Images/c0843b7805aefe7781af377857f675e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h_gZJTcdaB39ejXkRQZnxQ.png"/></div></div></figure><h2 id="32b2" class="mo le it bd lf mp mq dn lj mr ms dp ln kb mt mu lr kf mv mw lv kj mx my lz mz bi translated">拿</h2><p id="fb36" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">take、takeUntil和takeWhile都将根据满足的条件自动管理订阅。例如，takeUntil将一个可观察对象作为参数，并维持一个订阅，直到该可观察对象发出一个值。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nq"><img src="../Images/6cdbf0a48f9d9b2579c1446213ed8152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_XXCKo_cdGswxhwNyf55w.png"/></div></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><blockquote class="ns nt nu"><p id="b077" class="jq jr nv js b jt ju jv jw jx jy jz ka nw kc kd ke nx kg kh ki ny kk kl km kn im bi translated">☁️<a class="ae ko" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flotes</a>——尝试演示，不需要登录。或者免费报名。Flotes是我记笔记和高效学习的方式，即使在我很忙的时候。</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi on"><img src="../Images/8e468f6e74135bbbc2ecbfce7e2db2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wGqAj2R16w33dIiKDnHEUA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae ko" href="https://flotes.app" rel="noopener ugc nofollow" target="_blank">flots</a></figcaption></figure><h1 id="d798" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">资源/参考资料</strong></h1><ul class=""><li id="3de7" class="kp kq it js b jt mb jx mc kb oo kf op kj oq kn or kv kw kx bi translated">[1]:<a class="ae ko" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Memory _ Management</a></li><li id="6c50" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn or kv kw kx bi translated">[2]:<a class="ae ko" href="https://medium.com/@erxk_verduin/angular-rxjs-async-pipe-deep-dive-2510b56f793a" rel="noopener">https://medium . com/@ erxk _ verduin/angular-rxjs-async-pipe-deep-dive-2510 b 56 f 793 a</a></li><li id="50df" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn or kv kw kx bi translated">语法高亮图像由<a class="ae ko" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank"> https://carbon.now.sh </a>生成</li></ul></div></div>    
</body>
</html>