# Linux:处理核心转储、systemd-coredump 和 Debian

> 原文：<https://itnext.io/linux-processes-core-dumps-systemd-coredump-and-debian-cf2ddb11ef9e?source=collection_archive---------3----------------------->

![](img/2ae50e2de4a88a58b3a26616c4125865.png)

需要从 Debian 9 上的 fro ma PHP 进程中获取一个转储。

在这篇文章中，我们将采用 Linux 内核机制来创建和管理进程转储。

内核的转储是以另一种方式创建的，请查看 [Kdump](https://wiki.archlinux.org/index.php/Kdump) на Arch Wiki。

## Linux 核心转储

如果内核执行了无效的操作并且必须停止，它将创建一个进程转储。

为此，内核将向这样一个进程发送一个特殊的信号，以便该进程可以自己或使用标准机制来处理它，并将使内核应用该机制来创建该进程的内存转储。

完整的列表可以在内核源代码的`[SIG_KERNEL_COREDUMP_MASK](https://elixir.bootlin.com/linux/v5.5.8/source/include/linux/signal.h#L413)`宏中找到:

```
...
#define SIG_KERNEL_COREDUMP_MASK (\
        rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \
  rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \
        rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \
  rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \
        rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \
  SIGEMT_MASK	
...
```

由`[sig_kernel_coredump](https://elixir.bootlin.com/linux/v5.5.8/source/include/linux/signal.h#L433)`宏使用:

```
...
#define sig_kernel_coredump(sig)	siginmask(sig, SIG_KERNEL_COREDUMP_MASK)
...
```

该函数在出现致命错误时被调用，并依次调用`[do_coredump()](https://elixir.bootlin.com/linux/v5.5.8/source/kernel/signal.c#L2716)`函数:

```
...
  fatal:
                ...
    if (sig_kernel_coredump(signr)) {
      if (print_fatal_signals)
        print_fatal_signal(ksig->info.si_signo);
      proc_coredump_connector(current);
                        ...
      do_coredump(&ksig->info);
    }
...
```

而`[do_coredump()](https://elixir.bootlin.com/linux/v5.5.8/source/fs/coredump.c#L565)`将创建一个内存转储，并将它保存在硬盘上。

## 信号和转储创建

让我们检查它是如何工作的。

以一个简单的 C 代码为例:

```
#include <stdio.h>
#include <unistd.h>

int main() {

    while(1) {
        pid_t pid = getpid();
        printf ("Working with PID %lu\n", pid);
        sleep(5);
    }
}
```

构建并运行:

```
$ gcc make_dump.c -o make_dump
./make_dump
Working with PID 2714790
```

在另一个终端—发送一个信号，例如`[SIGSEGV](https://ru.wikipedia.org/wiki/SIGSEGV)` ( *分段冲突*)，代码 11:

```
$ kill -s SIGSEGV 2714790
```

在运行应用程序的终端中检查其输出:

```
$ ./make_dump
Working with PID 2714790
…
Working with PID 2714790
Segmentation fault (core dumped)
```

检查转储文件:

```
$ ls -l /tmp/ | grep 2714790
-rw — — — — 1 setevoy setevoy 380928 Mar 10 11:24 coredump-make_dump.2714790
```

同样，您可以为任何已经运行的进程创建一个转储，例如——run`sleep`:

```
$ sleep 100 &
[1] 2761144$ kill -s SIGSEGV 2761144\
[1]+ Segmentation fault (core dumped) sleep 100$ file /tmp/coredump-sleep.2761144/tmp/coredump-sleep.2761144: ELF 64-bit LSB core file, x86–64, version 1 (SYSV), SVR4-style, from ‘sleep 100’, real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: ‘/usr/bin/sleep’, platform: ‘x86_64’
```

## GDB —创建核心转储

除了发送信号之外，您还可以使用`[gdb](https://rtfm.co.ua/c-otladka-s-gdb-primery/)`中的`gcore`:

```
$ sleep 100 &
[1] 2762961$ sudo gcore 2762961
…
Saved corefile core.2762961
file core.2762961
core.2762961: ELF 64-bit LSB core file
```

## GDB —读取核心转储

要检查转储的内容，您可以使用`gdb`并将可执行文件作为第一个参数传递，将转储文件的路径作为第二个参数传递:

```
$ gdb make_dump coredump-make_dump.2714790
…
[New LWP 2714790]
Core was generated by `./make_dump’.
Program terminated with signal SIGSEGV, Segmentation fault.
0 0x00007f50d566e27e in clock_nanosleep@GLIBC_2.2.5 () from /usr/lib/libc.so.6
(gdb)
```

## `kernel.core_pattern`

在转储创建期间，内核将检查决定如何处理转储的参数`kernel.core_pattern`。

在这里你可以用指定符指定一个路径和一个文件名，或者给它传递外部转储处理程序，比如`[systemd-coredump](https://www.freedesktop.org/software/systemd/man/systemd-coredump.html)` (рассмотрим ниже).

查看*核心转储文件的命名*文档[此处> > >](http://man7.org/linux/man-pages/man5/core.5.html) 。

这里最常用的选项是:

*   `%e`可执行文件的文件名(不带路径前缀)
*   `%p`转储进程的 PID，如进程所在的 PID 名称空间所示
*   `%t`转储时间，以自纪元 1970-01-01 00:00:00 +0000 (UTC)以来的秒数表示

我们在上面的 GDB 中观察到的文件*/tmp/coredump-make _ dump . 2714790*由`kernel.core_pattern = /tmp/coredump-%e.%p`组成:

1.  `/tmp`目录
2.  `%e` -文件名以 *coredump* 开头+一个可执行名факла*make _ dump*
3.  `%p` -和一个被终止的进程 PID - *2714790*

此外，不使用直接路径和文件名，您可以通过管道`|`将转储数据传递给`/dev/null`或类似于`systemd-coredump`的处理程序。

## `limits.conf`

在创建转储之前，内核还将检查`/etc/security/limits.conf`中`core`的*软*和*硬*限制:

```
$ cat /etc/security/limits.conf | grep core
- core — limits the core file size (KB)
* soft core 0
```

或者直接在您当前的环境中检查:

```
$ ulimit -c
unlimited
```

一个运行过程的极限可以从`/proc`中找到其极限:

```
$ ./make_dump
Working with PID 2753034
```

和限制:

```
$ cat /proc/2753034/limits
Limit Soft Limit Hard Limit Units
…
Max core file size unlimited unlimited bytes
…
```

## `fs.suid_dumpable`

有时，如果进程进行了 suid 操作，例如使用`[setuid()](http://man7.org/linux/man-pages/man2/seteuid.2.html)` syscall，则无法创建转储。

在这种情况下，行为由`fs.suid_dumpable`控制:

```
$ sysctl fs.suid_dumpable
fs.suid_dumpable = 2
```

它可以接受 0、1 或 2，参见[手册 proc](http://man7.org/linux/man-pages/man5/proc.5.html) :

*   0: ( *默认*)这提供了传统的(Linux 2.6.13 之前)行为。不会为已更改凭据(通过调用 seteuid 或类似方法)或其二进制文件未启用读取权限的进程生成核心转储。
*   1: (" *调试*")所有进程尽可能转储内核。
*   2: (" *suidsafe* ")任何通常不会被转储的二进制文件(见上面的“0”)都被转储为只对 root 可读。

## `systemd-coredump`

当然，`[systemd](https://www.freedesktop.org/software/systemd/man/systemd-coredump.html)`有它自己的转储处理器——已经提到过`[systemd-coredump](https://www.freedesktop.org/software/systemd/man/systemd-coredump.html)`。

在 Arch 上默认使用 Linux，因为 Debian 9 可以安装`apt`:

```
$ sudo apt -y install systemd-coredump
```

配置文件— `/etc/systemd/coredump.conf`。

安装后配置内核—通过管道将转储发送到`systemd-coredump`:

```
root@bttrm-production-app-1:/home/admin# echo ‘|/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %e’ > /proc/sys/kernel/core_pattern
```

检查一下:

```
root@bttrm-production-app-1:/home/admin# cat /proc/sys/kernel/core_pattern
|/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %e
```

创建一些转储:

```
root@bttrm-production-app-1:/home/admin# sleep 10 &
[1] 27117root@bttrm-production-app-1:/home/admin# kill -s 11 27117
[1]+ Segmentation fault (core dumped) sleep 10
```

## `coredumpctl`

要使用由`systemd-coredump`管理的转储，可以使用`coredumpctl`实用程序:

```
root@bttrm-production-app-1:/home/admin# coredumpctl
TIME PID UID GID SIG COREFILE EXE
Mon 2020–03–09 20:10:16 EET 20882 0 0 11 present /home/admin/dump_test
…
Tue 2020–03–10 09:04:14 EET 16786 1003 1003 11 present /usr/sbin/php-fpm7.4
Tue 2020–03–10 12:23:43 EET 27117 0 0 11 present /bin/sleep
```

在 *SIG* 列中，我们可以看到一个信号被发送到被终止的进程，在这些情况下，它是 *11* == `SIGSEGV`。

转储文件位于`/var/lib/systemd/coredump`目录下:

```
root@bttrm-production-app-1:/home/admin# ll /var/lib/systemd/coredump/
total 125376
-rw-r — — — 1 root root 25208 Mar 9 20:10 core.dump_test.0.6bb23c691d354e9dbf4382d109a5c1d4.20882.1583777416000000000000.lz4
…
-rw-r — — — 1 root root 33962 Mar 10 12:23 core.sleep.0.6bb23c691d354e9dbf4382d109a5c1d4.27117.1583835823000000000000.lz4
```

要观察转储的内容，请使用带有某些匹配条件的信息，例如 PID:

```
root@bttrm-production-app-1:/home/admin# coredumpctl info 27117
PID: 27117 (sleep)
UID: 0 (root)
GID: 0 (root)
Signal: 11 (SEGV)
Timestamp: Tue 2020–03–10 12:23:43 EET (3min 3s ago)
Command Line: sleep 10
Executable: /bin/sleep
…
Hostname: bttrm-production-app-1
Storage: /var/lib/systemd/coredump/core.sleep.0.6bb23c691d354e9dbf4382d109a5c1d4.27117.1583835823000000000000.lz4
Message: Process 27117 (sleep) of user 0 dumped core.
Stack trace of thread 27117:
0 0x00007fc1a8053270 __nanosleep (libc.so.6)
1 0x000056159fa6f91f n/a (sleep)
2 0x000056159fa6f700 n/a (sleep)
3 0x000056159fa6c9a4 n/a (sleep)
4 0x00007fc1a7fbb2e1 __libc_start_main (libc.so.6)
5 0x000056159fa6ca7a n/a (sleep)
```

## Debian —没有创建核心转储

上面描述的一切在两台装有 Arch Linux 的笔记本电脑上运行良好，但是在我项目的装有 Debian 9 的服务器上，转储是以一种通常的方式创建的，没有`systemd-coredump`。

`core_pattern`配置:

```
root@bttrm-production-app-1:/home/admin# cat /proc/sys/kernel/core_pattern
/tmp/core-%e.%p
```

运行一个进程，用 11 信号杀死它，检查`/tmp` -这里没有转储。

再次运行应用程序:

```
root@bttrm-production-app-1:/home/admin# ./dump_test
Working with PID 27954
```

并检查其极限:

```
root@bttrm-production-app-1:/home/admin# cat /proc/27954/limitsLimit Soft Limit Hard Limit Units
…
Max core file size 0 unlimited bytes
…
```

*软*限制被设置为零值，例如，由于内核对转储文件的使用不能超过 0 字节，转储被完全禁用。

将其设置为*无限制*:

```
root@bttrm-production-app-1:/home/admin# ulimit -S -c unlimited
```

再次运行应用程序，立即检查限制:

```
root@bttrm-production-app-1:/home/admin# ./dump_test 1>/dev/null &
[3] 28399root@bttrm-production-app-1:/home/admin# cat /proc/$!/limits
Limit Soft Limit Hard Limit Units
Max cpu time unlimited unlimited seconds
Max file size unlimited unlimited bytesMax data size unlimited unlimited bytes
Max stack size 8388608 unlimited bytes
Max core file size unlimited unlimited bytes
…
```

创建转储:

```
root@bttrm-production-app-1:/home/admin# sleep 10 &
[4] 28613root@bttrm-production-app-1:/home/admin# kill -s 11 $!
```

检查一下:

```
root@bttrm-production-app-1:/home/admin# ls -l /tmp/coredump-sleep.28613
-rw — — — — 1 root root 380928 Mar 10 12:47 /tmp/coredump-sleep.28613
```

完成了。

## 有用的链接

*   [了解并配置 Linux 上的核心转储](https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/)
*   [猎杀核心](https://www.fromdual.com/hunting-the-core)
*   [核心转储](https://wiki.archlinux.org/index.php/Core_dump) (Arch Wiki)
*   [在 PHP-FPM 中的 segfaults 上生成 PHP 核心转储](https://ma.ttias.be/generate-php-core-dumps-segfaults-php-fpm/)
*   [生成 gdb 回溯](https://bugs.php.net/bugs-generating-backtrace.php)
*   [проблемасe 加速器и генерация核心转储для php-fpm](https://blog.amet13.name/2015/05/eaccelerator-coredump-php-fpm.html)
*   [如何在 Linux 上获得 segfault 的核心转储](https://jvns.ca/blog/2018/04/28/debugging-a-segfault-on-linux/)
*   [终止:创建核心转储](https://bencane.com/2011/09/22/kill-creating-a-core-dump/)

*最初发布于* [*RTFM: Linux，devo PSисистемноеадммиитиииииованниое*](https://rtfm.co.ua/en/linux-processes-core-dumps-systemd-coredump-and-debian/)*。*