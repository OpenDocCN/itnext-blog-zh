<html>
<head>
<title>How to use JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JavaScript承诺</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-use-javascript-promises-82e0a0ba8aa5?source=collection_archive---------7-----------------------#2020-02-17">https://itnext.io/how-to-use-javascript-promises-82e0a0ba8aa5?source=collection_archive---------7-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="295f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于这个伟大的JS特性，你需要知道什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7bfd306216a0d4cb7b1cb5b5d2e0bc68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPkHy-CTpySLHTJnUxqkWw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</figcaption></figure><h2 id="df46" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h2><p id="8dde" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">JavaScript承诺为开发人员提供一种优雅的方法来处理异步代码或执行某种冗长计算的代码。在使用JavaScript时，我们经常会遇到这种代码。</p><p id="71f8" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">一个典型的例子是对远程服务器的HTTP调用。我们期望服务器发回一个响应，但是我们不知道确切的时间，我们不希望我们的代码等待它。</p><h2 id="ee86" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我如何创造一个承诺？</h2><p id="6899" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">创造承诺很容易。你这样调用Promise构造函数。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5e5d" class="ky kz it mt b gy mx my l mz na">let myFirstPromise = new Promise((resolve, reject) =&gt; {<br/>  // now we do some work</span><span id="8c3c" class="ky kz it mt b gy nb my l mz na">  if(WorkCompletedSuccessfully){<br/>    resolve('everything worked');<br/>  } else {<br/>    reject('There was a problem.');<br/>  }</span><span id="2534" class="ky kz it mt b gy nb my l mz na">})</span></pre><p id="1aa6" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们传递给Promise构造函数的函数称为<strong class="lw iu"> <em class="nc"> executor函数。</em> </strong>这个代码给了我们一个新创建的承诺。一旦我们有了承诺，我们可以使用配置它接受解决或拒绝状态。然后接着。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ee1f" class="ky kz it mt b gy mx my l mz na">myFirstPromise<br/>  .then(response =&gt; console.log(response) &lt;--called for resolve()<br/>  .catch(err =&gt; console.log(err));        &lt;--called for reject()</span></pre><p id="8134" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">如果你使用过像<a class="ae nd" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>这样的HTTP库，基于Promise的浏览器和node.js的HTTP客户端，这些代码可能看起来很熟悉。每次在Axios中调用一个函数，都会得到一个承诺。</p><p id="a349" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">让我们看看另一个代码示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="be8e" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这里我们将模拟一个耗时一秒半的HTTP调用。第1行到第8行设置了我们的承诺。请注意，fakeHttpOne()函数会立即返回一个新的承诺。这给了我们链接方法的能力。然后()和。抓住承诺。在浏览器中运行这段代码会产生以下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/65e4f0293f14b0739044ec7e3d7693b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*djl6GQXmHae5hBB6Lmpgeg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">耶！它工作了。</figcaption></figure><p id="3379" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">那就好！现在让我们看一个实际的HTTP调用，以及我们如何将数据从一个HTTP调用传递到下一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9306" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">在这个例子中，第1行到第24行只是设置了一个名为getJSON的函数。注意，我们在第2行做的第一件事是<strong class="lw iu"> <em class="nc">返回一个新的承诺。</em>T9】</strong></p><p id="00ae" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">然后，我们设置使用浏览器的本地XMLHttpRequest对象发出HTTP请求。你可以在这里阅读所有关于XMLHttpRequest的内容。</p><p id="4d33" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这里要注意的行是我们调用resolve()或reject()的地方，这取决于我们从服务器得到的响应。</p><p id="7b80" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们唯一一次调用resolve是在第9行，当时我们得到一个状态代码200，这意味着一切正常。然后我们使用JSON.parse来解析从服务器返回的JSON。如果在任何时候抛出一个异常，我们在第14行捕捉它并调用reject()。</p><p id="693d" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">最后，在第26行，我们设置了baseUri变量并调用了getJSON函数。</p><p id="1777" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><a class="ae nd" href="https://jsonplaceholder.typicode.com/guide.html" rel="noopener ugc nofollow" target="_blank"><strong class="lw iu"><em class="nc">jsonplaceholder.typicode.com</em></strong></a><strong class="lw iu"><em class="nc">非常适合测试的东西，顺便说一句。看看这个。</em> </strong></p><p id="8785" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">当我们运行这段代码时，下面是我们在控制台中得到的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/731d22e7f16f93b9c68298875760c331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*v179Cp6226SW3XsdGzRimA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从jsonplaceholder返回的数据</figcaption></figure><p id="e67b" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">太好了！我们收到了100条回复。</p><h2 id="9ad2" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">让我们做一些链接！</h2><p id="4d6e" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">我们有柱子。现在让我们假设我们想要获得与id为1的帖子相关联的所有评论。我们对getJSON的调用需要如何改变？方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">给我评论或者给我一个404！</figcaption></figure><p id="ac90" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这里发生了什么？在第3行，我们从服务器获得第一个响应，并将其传递给变量<em class="nc">数据</em>中的箭头函数。然后，我们使用<em class="nc">数据</em>创建正确的Uri来获取评论，并将其传递给另一个getJSON()调用，该调用反过来发送第二个HTTP请求。</p><p id="ae52" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><em class="nc">有趣的是，当你调用。然后()它隐式返回一个新的承诺。</em></p><p id="f8af" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated"><em class="nc">这样我们就可以打电话了。然后又()。</em></p><blockquote class="ni"><p id="78e3" class="nj nk it bd nl nm nn no np nq nr mm dk translated">亲爱的读者，这就是连锁承诺的魔力！</p></blockquote><p id="1519" class="pw-post-body-paragraph lu lv it lw b lx ns ju lz ma nt jx mc lh nu me mf ll nv mh mi lp nw mk ml mm im bi translated">这在控制台中给了我们什么？让我们来看看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/b533eecd3d1590afc3d94fc7554289b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIcuDnPkgF2RwBMMHx0p_g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们得到了5条评论</figcaption></figure><p id="9c20" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们得到了与该帖子相关的5条评论。非常酷，非常有用，而且非常容易做到。</p><p id="9b78" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">但是，就像<a class="ae nd" href="https://en.wikipedia.org/wiki/Ron_Popeil" rel="noopener ugc nofollow" target="_blank">罗布·波佩尔</a>常说的那样:</p><blockquote class="ni"><p id="c109" class="nj nk it bd nl nm nn no np nq nr mm dk translated">但是等等，还有呢！</p></blockquote><h2 id="c7cc" class="ky kz it bd la lb ny dn ld le nz dp lg lh oa lj lk ll ob ln lo lp oc lr ls lt bi translated">依赖的承诺</h2><p id="5650" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">如果我们正在开发一个应用程序，在继续之前需要完成一堆HTTP请求，该怎么办？</p><p id="78cc" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们应该举手告诉老板他疯了吗？</p><p id="5067" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">不。这个很简单。我们可以用<a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"> Promise.all() </a>。看一看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">promise.all和假HTTP调用</figcaption></figure><p id="e8a2" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">对于这个例子，我已经切换回虚假的HTTP调用。</p><p id="4bdd" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我创建了3个fakeHttp()函数，每个函数都使用不同持续时间的setTimeout来模拟真实Http调用的延迟。</p><p id="4d12" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">然后在第30行，我调用Promise.all()并传递给它一个<strong class="lw iu"> <em class="nc">函数数组</em> </strong>。有了这些，代码将不会继续，直到我们得到所有的响应，或者直到出现问题并调用reject()为止。</p><p id="c27d" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">想着没有承诺我会怎么做这个. all()真的让我头疼，所以这个很牛逼。这是我们在控制台上看到的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a79cb077b53ed48d4fd0a31296bd08eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*Ylu3iNBJVHAdaIVapoLbgA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">promise.all的输出()</figcaption></figure><p id="14d7" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">请注意，中的console.log()语句。然后()不运行，直到<strong class="lw iu"> <em class="nc">所有的响应</em> </strong>都返回。</p><blockquote class="ni"><p id="ec15" class="nj nk it bd nl nm nn no np nq nr mm dk translated">承诺给了我们超能力！算是吧。</p></blockquote><figure class="of og oh oi oj kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/fafd58363ab118c7cc623b06e12ffdb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bba8ml8JgW51mWdf"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae nd" href="https://unsplash.com/@king_lip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">王唇</a>在<a class="ae nd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="28b9" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">就一个怎么样？</h2><p id="de52" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc lh md me mf ll mg mh mi lp mj mk ml mm im bi translated">当老板看到你穿着蓝色紧身衣在办公室里蹦蹦跳跳的时候，他回来对你说，等待所有HTTP呼叫的回复是个问题。你在想什么？</p><p id="b0e6" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">应用程序应该接受它得到的第一个响应，然后继续前进。</p><p id="7361" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">你微笑着向他竖起大拇指。</p><p id="3f5f" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">没问题，老板！。</p><p id="f8d9" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">过了一会儿，你回到了你的办公椅上。调整cape后，将代码更改如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c91a" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">我们在第1行用Promise.race()替换了Promise.all()。现在，我们的代码将只等待一个响应，或者一个对reject()的调用，然后继续。</p><p id="3f94" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">和输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c00fa5cb163e56cb03429395bc75e7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*ckq9kP4cF86TGHdEI4wlrA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">赛车！！轰鸣！</figcaption></figure><p id="c88c" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">请注意，fakeHttp3首先完成，尽管fakeHttp1在它之前开始。另外，请注意，您可以添加额外的。就像我在第6行和第7行所做的那样。这些。无论成功还是失败，then()函数都将运行。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="3d8f" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">这就是了。快速浏览JavaScript承诺以及它们如何在处理异步代码时简化您的生活。</p><h2 id="ac5a" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">关键要点</h2><ol class=""><li id="75ec" class="os ot it lw b lx ly ma mb lh ou ll ov lp ow mm ox oy oz pa bi translated">在使用JavaScript时，我们必须经常处理长时间运行的计算和异步代码。</li><li id="f424" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">承诺提供了一种优雅的处理代码的方式，它将在未来的某个时候为我们提供一个价值。</li><li id="c68c" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">通过调用Promise构造函数，创建Promise很容易。</li><li id="fe13" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">调用resolve()或reject()从承诺返回结果。</li><li id="f27b" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">一旦你有了一个承诺对象，配置。然后()和。catch()方法来处理承诺的结果。</li><li id="78fb" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">。then()隐式返回一个新的承诺。</li><li id="7a70" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">当您有许多相互依赖的长时间运行的操作时，请使用Promise.all()。代码执行将不会继续，直到所有承诺都已解决或一个承诺已被拒绝。</li><li id="2c66" class="os ot it lw b lx pb ma pc lh pd ll pe lp pf mm ox oy oz pa bi translated">当您只关心对许多操作获得单个响应时，请使用Promise.race()。</li></ol><h2 id="c8ba" class="ky kz it bd la lb lc dn ld le lf dp lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源</h2><div class="pg ph gp gr pi pj"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">承诺</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">Promise对象表示异步操作的最终完成(或失败),及其结果…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">developer.mozilla.org</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div><p id="a474" class="pw-post-body-paragraph lu lv it lw b lx mn ju lz ma mo jx mc lh mp me mf ll mq mh mi lp mr mk ml mm im bi translated">一如既往，感谢您的阅读，如果您喜欢这篇文章，请查看我在Medium上的其他作品。</p><div class="pg ph gp gr pi pj"><a href="https://medium.com/@aritzcovan" rel="noopener follow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">亚历克斯·里茨科万-中等</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">阅读Alex Ritzcovan在媒体上的文章。高级软件顾问、作家、丈夫和父亲。我喜欢编码…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">medium.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ks pj"/></div></div></a></div></div></div>    
</body>
</html>