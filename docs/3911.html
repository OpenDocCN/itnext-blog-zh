<html>
<head>
<title>Before you use Kustomize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在使用Kustomize之前</h1>
<blockquote>原文：<a href="https://itnext.io/before-you-use-kustomize-eaa9529cdd19?source=collection_archive---------2-----------------------#2020-03-24">https://itnext.io/before-you-use-kustomize-eaa9529cdd19?source=collection_archive---------2-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e402" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">流行的Kubernetes配置管理工具Kustomize的优缺点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e41ce88e2e66c82eed56ff91bbe8eae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2P6_eyzkcQWmKGtYIcbPQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">信用:<a class="ae ky" href="https://www.pexels.com/photo/man-wearing-black-and-white-stripe-shirt-looking-at-white-printer-papers-on-the-wall-212286/" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure><p id="171e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize是一个用来管理和定制YAML文件的工具——尤其是Kubernetes的配置YAML文件。它在过去的两年中迅速流行起来，并且从1.14版开始成为kubectl的一部分。因此，当我们的组织考虑放弃我们内部的Kubernetes配置管理工具时，Kustomize是我们候选列表中的第一个。这是我在对Kustomize进行研究和原型制作后的发现。</p><h1 id="d1ac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">TD；LR </strong></h1><p id="473a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Kustomize依靠“选择和修补”机制来简化和重构Kubernetes的配置YAML文件。虽然这种强大的方法提供了许多好处，但它对于某些任务也有局限性。</p><h1 id="e249" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">问题</strong></h1><p id="1f97" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的团队在许多不同的环境中部署了多种微服务。查看配置文件后，我们发现:</p><ul class=""><li id="37e0" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">不同微服务的配置之间的共性，例如标签和注释。</li><li id="e8a4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">不同环境中相同微服务的配置之间的共性，如DNS、CPU和内存设置。</li></ul><p id="bd6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们理想的工具应该利用这些来重构，避免重复我们自己(<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY </a>)。</p><h1 id="afe4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">无模板解决方案</strong></h1><p id="74d8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">受文章“<a class="ae ky" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/declarative-application-management.md" rel="noopener ugc nofollow" target="_blank">Kubernetes</a>中的声明式应用程序管理”的启发，Kustomize鄙视复杂模板的使用，并通过将YAML文件分解为基本YAML文件和覆盖YAML文件来解决问题，然后根据情况组装它们。一般来说，Kustomize有三种类型的文件:</p><ul class=""><li id="cf9b" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">基本YAML文件:</strong>这些定义了库贝YAML文件的框架。</li><li id="6af4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">覆盖YAML文件</strong>:这些是Kube YAML文件的一小部分，比如卷安装或容器的规格。</li><li id="bfa1" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">库定制文件</strong>:定义了叠加文件如何应用到基础文件，以生成最终的YAML文件，称为变体。它们还可以包含轻量级的覆盖，如公共标签和注释，以及生成配置映射和秘密。通常，每个环境都有自己的定制文件来调整该环境的配置。例如，dev kustomization文件向特定部署添加了一个sidecar容器，而production kustomization文件则没有。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/365886684d76d927b5abb4a0dbc9b7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aw9cD6ItGkBupxCeJUuf5g.png"/></div></div></figure><p id="926b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize与一般的YAML文件合并的区别在于Kustomize理解Kube YAML语法。例如，Kustomize中一个名为<a class="ae ky" href="https://github.com/kubernetes-sigs/kustomize/blob/master/examples/patchMultipleObjects.md#target-selector" rel="noopener ugc nofollow" target="_blank"> Target Selector </a>的特性允许用户只对Kube元数据中包含特定标签或注释的部署文件应用覆盖。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c9ce6ed768b0f1d7d5778655a078c190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6IYZJAtMuhlW9m5VhuRFA.png"/></div></div></figure><h1 id="3d2f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">有什么好吃的</strong></h1><p id="f9e1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与模板解决方案相比，Kustomize迫使人们在编写配置文件时避免常见的陷阱。典型的模板化配置文件由3部分组成:</p><ul class=""><li id="31df" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">渲染后不变的部分(文本)</li><li id="fa20" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">渲染后更改的部分(模板)</li><li id="22e0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">组合它们的控制逻辑</li></ul><p id="6a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当文件中充满了模板和if…else语句来处理不同的场景时，它变得非常难以阅读和维护。与此同时，缺乏与Kube语法的集成也使得一些任务(如为所有Kube资源添加名称前缀)变得繁琐且容易出错，因为用户需要检查所有文件并手动添加名称前缀的模板。</p><p id="7838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize通过分离模板化配置文件的三个部分来促进良好实践。由于Kustomize只能组合原始的无模板Kubernetes YAML文件，所以所有的控制逻辑，如if…else语句，必须留在Kustomize文件中。在基础YAML和覆盖YAML的帮助下，Kustomize鼓励将固定的文本放入基础YAML，将变化的部分放入覆盖YAML。与此同时，Kustomize有一系列理解Kube语法的便捷转换器。它们可以用来避免人为错误，并像普通标签一样对所有Kube资源进行更改。</p><h1 id="f1ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">有什么不太好的</strong></h1><p id="1eb3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">权衡是所有软件设计都必须承受的负担，Kustomize也不例外。Kustomize可以帮助重构和定制不同环境的配置，但在重构微服务之间共享的配置时，它有局限性。</p><p id="f217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kustomize允许用户创建覆盖YAML，并使用kustomize文件来决定如何将它们应用到基本YAML。利用这一点并将Kube资源的一些公共属性提取到覆盖文件中似乎是一个好主意，比如标签、安全上下文和环境变量。然而，这只有在Kustomize可以将提取的部分放回原位时才有效。这听起来可能非常简单，但使用Kustomize并不总是那么简单。</p><p id="6bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以让Kustomize知道在哪里应用覆盖:</p><ul class=""><li id="7d79" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">通过路径</strong>:基于路径的方法允许用户在覆盖文件的YAML结构中嵌入要覆盖的路径，或者用<a class="ae ky" href="https://github.com/kubernetes-sigs/kustomize/blob/master/examples/jsonpatch.md" rel="noopener ugc nofollow" target="_blank"> Json6902 </a>转换器在库定制化文件中显式声明该信息。这种方法对重构没有太大帮助，因为它要求覆盖和基本YAMLs中的路径之间有一对一的映射，并且没有部分可以共享。</li><li id="ad62" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">通过选择器<strong class="lb iu">:选择器方法，比如<a class="ae ky" href="https://github.com/kubernetes-sigs/kustomize/blob/master/examples/patchMultipleObjects.md#target-selector" rel="noopener ugc nofollow" target="_blank">目标选择器</a>，更适合重构。它允许用户指定一个选择器，例如，带有特定注释的所有部署，并对这些部署应用覆盖。</strong></li></ul><p id="a8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，并不是Kube config YAMLs中的所有元素都是“可选择的”，因为选择器总是依赖于一些属性，比如Kube YAML的种类、标签或注释来选择Kube元素。尽管如此，并不是所有的Kube元素都有这些。例如，Kube部署可以有一个容器列表，但是这些容器上没有类似注释的属性供Kustomize选择器使用。为了在多个部署中对容器应用公共覆盖，容器必须具有相同的名称。这使得诸如公共环境变量或容器安全上下文之类的重构任务变得几乎不可能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/6cb862fc5cc1bbc6904c0a7ade4ed7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmDc5CS0Q7Rbo8rR5qX-KA.png"/></div></div></figure><h1 id="6685" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我应该使用Kustomize吗？</h1><p id="bfc3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上面提到的问题并非完全不可解，但多少有些根本性。为了使Kube YAML的每个部分都“可选择”，它需要对Kube对象模式进行更改或修改，例如，为每个对象添加类似注释的字段，或者重用一些现有字段作为注释，然后扩展Kustomize以支持它们。</p><p id="a1e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，只有当微服务的复杂度达到一定程度时，问题才有可能出现。总的来说，我认为Kustomize的优点仍然大于缺点，尤其是如果你的团队还没有尝试Kube配置管理解决方案的话。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="b046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，<a class="ae ky" href="https://medium.com/@nealhu" rel="noopener">在Medium上跟随我</a>！我撰写关于分布式系统和软件架构的文章，例如:</p><ul class=""><li id="d40e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/why-should-you-build-your-own-kubernetes-operator-f60c25df0b1c">为什么要建立自己的Kubernetes运营商</a>。这比你想象的更容易，也更有益</li><li id="d22e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/automation-friendly-software-systems-and-how-to-build-them-7a7c5e3c1a15">自动化友好的软件系统以及如何构建它们</a>。向更好的自动化方向设计软件系统的技巧</li><li id="8fd4" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/minimalist-software-architecture-426888684e60">极简软件架构</a>。构建大规模多区域分布式系统的经验教训</li></ul></div></div>    
</body>
</html>