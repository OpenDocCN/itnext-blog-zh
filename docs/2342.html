<html>
<head>
<title>Moving from RxJava to Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从RxJava迁移到协程</h1>
<blockquote>原文：<a href="https://itnext.io/moving-from-rxjava-to-coroutines-4e1c34419111?source=collection_archive---------3-----------------------#2019-05-08">https://itnext.io/moving-from-rxjava-to-coroutines-4e1c34419111?source=collection_archive---------3-----------------------#2019-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/554fe0f9a6365cdaf733924cb95fe014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eg710_lwOyq2izWA1aEqaQ.jpeg"/></div></div></figure><p id="e19c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到如下的拉取请求会让我对我将会看到的可怕的事情感到恐惧。那是去年的事了，因为协程现在可以帮助我们编写干净、健壮和可伸缩的代码，就像RxJava一样。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/ee52eda072badf963388d02d3744df19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0lG-ciAvuZza5D4o"/></div></div></figure><p id="0e60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将讲述我从RxJava迁移到协程的步骤，这是我最近发表在Github <a class="ae lb" href="https://github.com/dimkonomis/NewsSync" rel="noopener ugc nofollow" target="_blank"> NewsSync </a>上的一个宠物项目。</p><h1 id="4f13" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">App</strong></h1><p id="795e" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">首先，我将简单介绍一下这个应用程序是如何设计的。</p><p id="ed02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据层由负责从数据源获取和映射数据的存储库组成。源由翻新服务和存储从网络获取的数据的房间数据库组成。两个源总是返回类似于<code class="fe mf mg mh mi b">Flowable</code>(为了监听数据库变化)或<code class="fe mf mg mh mi b">Completable</code>的可观察值。</p><p id="0f3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用例持有业务逻辑，因为它们负责与存储库通信，线程化并将适当的响应返回给表示层。</p><p id="c2c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，表示层由视图模型组成，这些视图模型从用例中请求数据，并通过ReactiveStreams将其映射到LiveData <a class="ae lb" href="https://github.com/dimkonomis/NewsSync/blob/master/app/src/main/java/com/dk/newssync/presentation/common/State.kt" rel="noopener ugc nofollow" target="_blank"> State </a>变量。</p><h1 id="0df1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">从数据源开始</strong></h1><p id="c871" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我最初的想法是从应用程序的底层、数据层和数据源开始应用更改。</p><p id="328f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望从版本2.1.0开始，Room支持开箱即用的协程(你可以在这里阅读更多关于它的信息)，为了改进，我们可以使用由Jake Wharton创建的<a class="ae lb" href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter" rel="noopener ugc nofollow" target="_blank">协程适配器</a>，它可以应用于Room。所以我可以走了。</p><h1 id="079b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">暂停功能</strong></h1><p id="55fd" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在阅读协程的时候，我意识到真正神奇的事情发生在挂起函数上。</p><p id="1f9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">挂起函数是可以挂起协程的执行，而不阻塞它们正在其上运行的线程的函数，并且当协程完成时，继续函数的其余部分。</p><p id="580e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我所做的是改变存储库的功能，从正常到暂停。</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="42af" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">fun </strong>appendStories(q: String?): Flowable&lt;List&lt;Story&gt;&gt;</span><span id="24d9" class="mn ld iq mi b gy ms mp l mq mr"><strong class="mi ir">suspend fun </strong>appendStories(q: String?): List&lt;Story&gt;</span></pre><p id="172e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以运行异步任务，比如网络和数据库请求，并从调用中返回实际的响应。</p><p id="1df6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以不是从我们的网络请求中返回一个可流动的</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="2959" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">override fun </strong>appendStories(q: String?): Flowable&lt;List&lt;Story&gt;&gt; {<br/>    <strong class="mi ir">return networkSource</strong>.searchArticles(q)      <br/>        .doOnNext <strong class="mi ir">{ data -&gt; <br/>            localSource</strong>.insertStories(<strong class="mi ir">data</strong>.<em class="mt">articles</em>).subscribe()<br/>        <strong class="mi ir">}<br/></strong>}</span></pre><p id="c16b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以获得实际的响应，立即将其存储在我们的数据库中并返回。</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="07cb" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">override suspend fun </strong>appendStories(q: String?): List&lt;Story&gt; {<br/>    <strong class="mi ir">val </strong>data = <strong class="mi ir">networkSource</strong>.searchArticles(q).await()<br/>    <strong class="mi ir">localSource</strong>.insertStories(<strong class="mi ir">data.articles</strong>)<br/>    return data.articles<br/>}</span></pre><p id="a78f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<code class="fe mf mg mh mi b">await()</code>所做的是等待返回<code class="fe mf mg mh mi b"><a class="ae lb" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" rel="noopener ugc nofollow" target="_blank">Deferred</a></code>的调用完成，而不阻塞线程。当调用完成时，它返回调用的值，并继续函数的其余部分。</p><h1 id="c7d7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">错误处理</strong></h1><p id="3810" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">上面代码的问题是，如果其中一个源代码抛出异常，那么应用程序就会崩溃。在RxJava中，我们可以使用OnError回调来处理可能的异常，但在这里是不可能的。对此，一个可能的解决方案是将我们的每个调用包装在一个try-catch块中，但这将使我们的代码变得难看，而且几乎不可读。</p><p id="263e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，我们可以在一个名为Result的密封类中传播我们的调用响应，它有一个成功和一个错误状态。</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="d196" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">sealed class </strong>Result&lt;<strong class="mi ir">out </strong>T&gt; {<br/><br/>    <strong class="mi ir">data class </strong>Success&lt;<strong class="mi ir">out </strong>T&gt;(<strong class="mi ir">val data</strong>: T) : Result&lt;T&gt;()<br/>    <strong class="mi ir">data class </strong>Error(<strong class="mi ir">val exception</strong>: Exception) : Result&lt;Nothing&gt;()<br/><br/>    <strong class="mi ir">companion object </strong>{<br/>        <strong class="mi ir">fun </strong>&lt;T&gt; success(data: T): Result&lt;T&gt; =<br/>            Success(data)<br/><br/>        <strong class="mi ir">fun </strong>error(exception: Exception) : Result&lt;Nothing&gt; =<br/>            Error(exception)<br/>    }<br/>}</span></pre><p id="8708" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我使用了高阶函数，这些函数将一个挂起或<code class="fe mf mg mh mi b"><a class="ae lb" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/" rel="noopener ugc nofollow" target="_blank">Deferred</a></code>函数作为参数，并返回一个结果类</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="cbfd" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">suspend fun </strong>&lt;T&gt; requestAwait(<br/>    call: () -&gt; Deferred&lt;T&gt;<br/>): Result&lt;T&gt;  {<br/>    <strong class="mi ir">return try </strong>{<br/>        <strong class="mi ir">val </strong>result = call().await()<br/>        Result.success(result)<br/>    } <strong class="mi ir">catch </strong>(exception: Exception) {<br/>        Timber.e(exception)<br/>        Result.error(exception)<br/>    }<br/>}<br/><br/><strong class="mi ir">suspend fun </strong>&lt;T&gt; request(<br/>    call: <strong class="mi ir">suspend </strong>() -&gt; T<br/>): Result&lt;T&gt;  {<br/>    <strong class="mi ir">return try </strong>{<br/>        Result.success(call())<br/>    } <strong class="mi ir">catch </strong>(exception: Exception) {<br/>        Timber.e(exception)<br/>        Result.error(exception)<br/>    }<br/>}</span></pre><p id="5d5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以存储库的挂起函数最终看起来像这样</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="6dc2" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">override suspend fun </strong>appendStories(q: String?): Result&lt;List&lt;Story&gt;&gt; {<br/>    <strong class="mi ir">val </strong>response = requestAwait <strong class="mi ir">{ networkSource</strong>.searchArticles(q) <strong class="mi ir">}<br/>    return when </strong>(response) {<br/>        <strong class="mi ir">is </strong>Result.Success -&gt; {<br/>            <strong class="mi ir">val </strong>articles = response.<strong class="mi ir">data</strong>.<strong class="mi ir">articles<br/>            </strong>request <strong class="mi ir">{ localSource</strong>.insertStories(articles) <strong class="mi ir">}<br/>            </strong>Result.success(articles)<br/>        }<br/>        <strong class="mi ir">is </strong>Result.Error -&gt; response<br/>    }<br/>}</span></pre><h1 id="96ec" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">穿线</strong></h1><p id="7c5e" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">RxJava的一个关键特性是使用subscribeOn和observeOn操作符来指定要运行的线程是多么容易。</p><p id="fdea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">缺省情况下，协程使用一个名为default的调度程序，它由JVM上的一个共享线程池提供支持。协程允许我们更改调度程序，其中一种方法是使用<code class="fe mf mg mh mi b">withContext</code>函数。</p><p id="cb87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">withContext</code>是一个函数，它允许我们改变运行协程代码的上下文，从而使用不同的线程。</p><p id="eed9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以代替这个</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="b5c7" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">fun </strong>requestStories(q: String?): Flowable&lt;List&lt;Story&gt;&gt; {<br/>    <strong class="mi ir">return </strong>storiesRepository.searchStories(q)<br/>        .subscribeOn(Schedulers.io())<br/>        .observeOn(AndroidSchedulers.mainThread())<br/>}</span></pre><p id="e21d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用例的代码现在看起来如下</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="8b7d" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">suspend fun </strong>requestStories(q: String?): Result&lt;List&lt;Story&gt;&gt; {<br/>    <strong class="mi ir">return </strong><em class="mt">withContext</em>(Dispatchers.<strong class="mi ir">Main</strong>) <strong class="mi ir">{<br/>        return</strong>@withContext <strong class="mi ir">storiesRepository</strong>.searchStories(q)<br/>    <strong class="mi ir">}<br/></strong>}</span></pre><p id="ea67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<code class="fe mf mg mh mi b">Dispatchers.Main</code>是协程将运行的主线程。我在这里使用<code class="fe mf mg mh mi b">suspend</code>的原因也是因为一个挂起函数，也就是searchStories，只能从协程或另一个挂起函数中调用。</p><h1 id="5116" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">移动到表示层</h1><p id="cb8d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">离开RxJava的最后一步是将其从视图模型中移除。视图模型从用例中请求数据，这些数据被映射到一个密封的类状态，然后通过ReactiveStreams转换成LiveData，如下图所示</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="2ac4" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">val </strong>stories: LiveData&lt;State&lt;List&lt;Story&gt;&gt;&gt; <strong class="mi ir">by </strong><em class="mt">lazy </em><strong class="mi ir">{<br/>    searchUseCase</strong>.requestStories(<strong class="mi ir">q</strong>)<br/>        .<em class="mt">toState</em>()<br/>        .toLiveData()<br/><strong class="mi ir">}</strong></span></pre><p id="1682" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我想删除RxJava，所以不需要ReactiveStreams和到LiveData的转换。因此，我决定使用一个常规的postValue来更新LiveData变量，以便尽可能地保持简单。</p><pre class="kx ky kz la gt mj mi mk ml aw mm bi"><span id="087c" class="mn ld iq mi b gy mo mp l mq mr"><strong class="mi ir">private val _stories </strong>= MutableLiveData&lt;State&lt;List&lt;Story&gt;&gt;&gt;()<br/><br/><strong class="mi ir">val stories</strong>: LiveData&lt;State&lt;List&lt;Story&gt;&gt;&gt;<br/>    <strong class="mi ir">get</strong>() = <strong class="mi ir">_stories</strong></span><span id="f623" class="mn ld iq mi b gy ms mp l mq mr"><strong class="mi ir">fun </strong>getStories() = <em class="mt">viewModelScope</em>.<em class="mt">launch </em><strong class="mi ir">{<br/>    _stories</strong>.postValue(State.loading())<br/>    <strong class="mi ir">_stories</strong>.postValue(<strong class="mi ir">searchUseCase</strong>.requestStories(<strong class="mi ir">q</strong>).<em class="mt">toState</em>())<br/><strong class="mi ir">}</strong></span></pre><p id="7609" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mf mg mh mi b">viewModelScope</code>是与ViewModel的生命周期相关联的<code class="fe mf mg mh mi b"><a class="ae lb" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" rel="noopener ugc nofollow" target="_blank">CoroutineScope</a></code>，当ViewModel被清除时，它将被取消。我在这里使用它的原因是，正如我之前提到的，<code class="fe mf mg mh mi b">suspend</code>函数只能从协程或另一个挂起函数中调用。因此，<code class="fe mf mg mh mi b">viewModelScope</code>启动一个协程，以便调用挂起函数。</p><p id="08dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你感兴趣，你可以在这里找到库的协同程序版本<a class="ae lb" href="https://github.com/dimkonomis/NewsSync/tree/coroutines" rel="noopener ugc nofollow" target="_blank"/>，你可以在这里看到将应用从RxJava迁移到协同程序的提交:</p><div class="mu mv gp gr mw mx"><a href="https://github.com/dimkonomis/NewsSync/commit/0b83173273d878fb9316d595f048d954cc43fe3d" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">从RxJava迁移到协程dimkonomis/NewsSync@0b83173</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">使用RxJava和架构组件的MVVM模式示例应用程序</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jw mx"/></div></div></a></div><h1 id="076a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">测试</h1><p id="49de" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">在下一部分中，我们将看到必要的变更，以便在迁移之后，项目的单元测试能够再次通过。</p></div></div>    
</body>
</html>