<html>
<head>
<title>Terragrunt — Inter-module dependency management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Terragrunt —模块间依赖性管理</h1>
<blockquote>原文：<a href="https://itnext.io/terragrunt-inter-module-dependency-management-36528693acdf?source=collection_archive---------2-----------------------#2020-12-15">https://itnext.io/terragrunt-inter-module-dependency-management-36528693acdf?source=collection_archive---------2-----------------------#2020-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db8952543e370a63cf0230a8eef183af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jG3lh3-h93nsKqunh9AMhg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">样本地形图</figcaption></figure><p id="84a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Terraform提供了一个相当智能的图形引擎。当您在另一个资源中使用一个资源的属性时，它会在部署图中生成隐含的依赖关系。这可能是这种语言最好的特性之一。如果你有code ARM模板(Azure的JSON DSL)，你会生动地记得在哪里必须手工定义所有的依赖关系。</p><p id="fdc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您不知道Terraform的绘图方法，请使用您最喜欢的模块并运行以下命令。它将生成一个图表，您可以在浏览器中打开它来查看依赖关系。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="6dc7" class="lj lk iq lf b gy ll lm l ln lo">terraform graph | dot -Tsvg <strong class="lf ir">&gt;</strong> graph.svg</span></pre><p id="567d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您部署大型基础设施的组件时，通常需要将输出从一个部署传递到另一个部署。这可以使用远程状态配置来实现，但这也有其自身的挑战。</p><p id="57af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您可以更干净地传递信息，并且不使用远程状态引用污染您的代码，会怎么样？</p><p id="8c06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Terragrunt又来救援了！</p><h1 id="6de2" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Terragrunt的依赖性方法</h1><p id="c104" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">Terragrunt允许您为一个部署定义一个到多个依赖项。对于大型基础设施的各种组件，依赖性管理在很大程度上取决于文件夹层次结构</p><p id="65b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦定义了依赖项，您现在就可以访问依赖项的输出，并可以将它们用作输入。让我们看一个例子。首先，使用<em class="mr">依赖关系</em>资源定义依赖关系。该资源需要配置该依赖项的路径(terragrunt.hcl所在的位置)。这将允许运行时检索部署的地形状态，并导出模块的输出。</p><p id="7ab5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，在<em class="mr">输入</em>部分，您可以访问依赖关系中的任何属性，如下所示:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="daa0" class="lj lk iq lf b gy ll lm l ln lo">dependency.&lt;dependency_name&gt;.outputs.&lt;attribute_name&gt;</span></pre><p id="fd0a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">示例:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="54d0" class="lj lk iq lf b gy ll lm l ln lo"># Snippet 1 - The dependency definition<br/>dependency "core-routing" {<br/>  config_path = "../core-routing"<br/>}</span><span id="112e" class="lj lk iq lf b gy ms lm l ln lo">inputs = {<br/>  department_code = local.config.global.department_code<br/>  environment     = local.config.dns.nonp.environment</span><span id="2d9e" class="lj lk iq lf b gy ms lm l ln lo">location = local.config.dns.nonp.location</span><span id="694a" class="lj lk iq lf b gy ms lm l ln lo">tags = local.config.global.tags</span><span id="e66a" class="lj lk iq lf b gy ms lm l ln lo"># Configure DNS only once in the primary region folder.<br/>  public_dns_zone = local.config.dns.nonp.public</span><span id="dd53" class="lj lk iq lf b gy ms lm l ln lo"># Configure DNS only once in the primary region folder.<br/>  private_dns_zone = local.config.dns.nonp.private</span><span id="c1f7" class="lj lk iq lf b gy ms lm l ln lo">vnet_id_to_link_to_private_dns_zone = {<br/>    # Snippet 2 - referencing a dependency's output       </span><span id="e903" class="lj lk iq lf b gy ms lm l ln lo">associate_with_vnet_id = dependency.core-routing.outputs.vnet.id<br/>    registration_enabled   = true<br/>  }<br/>}</span></pre><h1 id="f456" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">先决条件</h1><p id="6280" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">为了让Terragrunt检索之前部署的输出，该部署需要以前已经部署过(否则输出将不存在)</p><p id="feee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果以前没有部署过，可以在依赖项配置中添加模拟来帮助计划工作。这不是我探索了很多的东西。如果您使用模拟，请确保模拟的输出与模块输出的结构(属性和内容)相匹配。</p><p id="2b67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有关模拟输出的更多信息，请参见Terragrunt文档。<a class="ae mt" href="https://terragrunt.gruntwork.io/docs/features/execute-terraform-commands-on-multiple-modules-at-once/#unapplied-dependency-and-mock-outputs" rel="noopener ugc nofollow" target="_blank">https://terra grunt . grunt work . io/docs/features/execute-terra form-commands-on-multi-modules-once/# unapplied-dependency-and-mock-outputs</a></p><h1 id="9222" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">绘制图形</h1><p id="27cd" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">由于Terragrunt是Terraform的扩展，它还可以绘制组件之间的依赖关系。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3e65" class="lj lk iq lf b gy ll lm l ln lo">terragrunt graph-dependencies | dot -Tsvg &gt; graph.svg</span></pre><p id="37c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">输出文件可以在浏览器中打开。让我们看一个样品。下图非常简单。随着基础设施的增长，依赖矩阵也会增长。使用工具来绘制层次结构图有助于理解部署的顺序。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/01d221fbbf34092436e9dc3ca9935475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*kRie6EnY0Q781ZjsLO7wOg.png"/></div></figure><h1 id="1fb7" class="lp lk iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="d93a" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">Terragrunt提供了一种将输出从一个模块连接到另一个模块的本地方法，同时保持每个部署的独立性。它将Terraform的依赖性管理提升到了一个新的水平，并允许大型基础设施的编排。</p></div></div>    
</body>
</html>