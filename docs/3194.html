<html>
<head>
<title>Strongly Typed Meteor Methods using Conditional types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用条件类型的强类型流星方法</h1>
<blockquote>原文：<a href="https://itnext.io/strong-typed-meteor-methods-8acafb36c494?source=collection_archive---------6-----------------------#2019-10-21">https://itnext.io/strong-typed-meteor-methods-8acafb36c494?source=collection_archive---------6-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5eed280162648653b247e4f1f3555ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fWGiV3nu9w9QjviGNOGujw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@averieclaire?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> averie woodard </a>在<a class="ae kc" href="https://unsplash.com/s/photos/meteor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b9ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文的目的是介绍一种类型化meteor方法的模式，以使Typescript知道哪些方法是可用的，以及哪些参数可以传递给特定的Meteor方法或从特定的Meteor方法接收。</p><p id="9016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种模式不仅仅适用于流星项目。我认为这更像是一次尝试，看看Typescript的类型系统可以扩展到什么程度。这里的大部分想法可以应用到与Meteor没有任何共同之处的其他项目中。</p><p id="8342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使您的项目还没有使用Typescript，您仍然可以通过<code class="fe lb lc ld le b">@ts-check</code>指令使用这种模式。这在文末有所论述。</p><p id="79ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ValidatedMethod包是创建meteor方法的默认包装器，所以我们将使用它来创建方法，而不是依赖原始的meteor选项。</p><p id="ede5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一部分“设置”解释了如何设置一个项目，以便您可以跟进。可以浏览一下，这样你就可以知道文件是如何构成的(尽管文件不会很多)。</p><p id="e5f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以检查<a class="ae kc" href="https://github.com/nicu-chiciuc/typed-meteor-methods" rel="noopener ugc nofollow" target="_blank">NICU-chic iuc/typed-meteor-methods</a>库来查看最终版本。</p><h1 id="b819" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置</h1><p id="3d37" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我已经创建了一个新的流星项目，使用:</p><p id="fd93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">meteor create --release 1.8.2-rc.0 --typescript typed-meteor-methods</code></p><p id="d484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特定的发布版本用于访问<code class="fe lb lc ld le b">--typescript</code>选项。虽然这取决于你什么时候读这篇文章，但这可能是不必要的。</p><p id="2df9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装ValidatedMethod包:<code class="fe lb lc ld le b">meteor add mdg:validated-method</code></p><p id="b63b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加文件<code class="fe lb lc ld le b">/imports/api/methods/getRandomNumber.js</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="dc5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对<code class="fe lb lc ld le b">validate</code>方法使用SimpleSchema，但是本文的重点不在此，所以它可以被定义为<code class="fe lb lc ld le b">null</code>。在生产中，不应该这样做。</p><p id="e4de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">样板项目包含的文件比我们需要的多。出于测试目的，我们需要一个在后端运行的文件和一个在前端运行的文件。</p><p id="a6c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于前面我有<code class="fe lb lc ld le b">/imports/ui/App.tsx</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="683d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于服务器，我有<code class="fe lb lc ld le b">/server/main.ts</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="b598" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">键入验证的方法</h1><p id="7b19" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我在这里找到了最初的类型:<a class="ae kc" href="https://github.com/meteor-typings/validated-method/blob/master/main.d.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/meteor-typing s/validated-method/blob/master/main . d . ts</a>。它们是由戴夫·艾伦创造的。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="077b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在一个名为<code class="fe lb lc ld le b">/@types/meteor-validated-method.d.ts</code>的文件中添加了这些类型。</p><p id="356e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型定义已经足够好了，但是有可能使它们通用化，所以让我们试试。</p><p id="373e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是上面链接的一个的修改版本。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="80c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Meteor.call</code>方法可以通过多个参数传递，但是对于<code class="fe lb lc ld le b">ValidatedMethod</code>，标准是传递具有多个属性的单个对象。这使得输入变得更加容易，因为我们有一个输入参数类型变量(<code class="fe lb lc ld le b">TRunArg</code>)和一个返回参数类型变量(<code class="fe lb lc ld le b">TRunReturn</code>)。</p><p id="9e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe lb lc ld le b">ValidatedMethod</code>也可以被传递mixin，以及属于那些mixin的选项，这些选项也应该被输入，但是这超出了本文的范围。</p><p id="206c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Typescript现在知道了<code class="fe lb lc ld le b">getRandomNumber.call</code>的返回值。如果传递了不正确的参数，它也会出错。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/8735acfaacc35ebd9a889d12f805a934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqUs5J5qxUcf4_3Yv2RW6Q.png"/></div></div></figure><p id="aadf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，让我们在<code class="fe lb lc ld le b">Meteor.call</code>上添加一个小包装。</p><h1 id="0f42" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">callAsync</code>包装器</h1><p id="1bea" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">根据文档，<code class="fe lb lc ld le b">Meteor.call</code>应该接收一个字符串作为第一个参数，后面跟着一些参数传递给方法，最后还可以传递一个回调。可以创建一个简单的承诺包装器，而不是试图解决这些需求:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="45fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我在<a class="ae kc" href="https://planable.io/" rel="noopener ugc nofollow" target="_blank"> Planable </a>的一个同事介绍的，事实证明非常有用。可以使用承诺来代替调用<code class="fe lb lc ld le b">App.tsx</code>中的<code class="fe lb lc ld le b">Meteor.call</code>并传递回调:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">callAsync</code>知道它应该接收一个字符串，然后是一个<code class="fe lb lc ld le b">any</code>类型的参数，它将返回一个无类型的承诺。对于大多数人来说，这种强有力的打字水平可能已经足够了，在一段时间内，我们也是如此。但是，<code class="fe lb lc ld le b">callAsync</code>知道声明了什么方法名以及什么类型可以传递给特定的方法不是很好吗？</p><p id="8654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在许多方面，meteor方法类似于REST API调用。因为我并不期望有很多尝试来键入meteor方法，因为meteor并没有考虑使用typescript，所以我开始寻找使用Typescript来键入REST APIs的方法。</p><p id="88ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现的大多数文章和github库都依赖于一个全局接口的存在，这个接口包含了所有REST端点的名称、参数和返回值的所有数据。</p><p id="2e20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将是一个聪明的方法。但是强迫手工编目所有的方法，然后保持实现同步似乎太麻烦了。更好的方法是让实现保持原样，提取所需的类型以备将来使用。</p><h1 id="9bde" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">键入函数的名称</h1><p id="0267" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">现在最酷的部分来了。必须扩充类型定义，以便它知道函数名是字符串，而不是字符串。与大多数其他类型化语言相比，Typescript具有字符串文字的概念，例如，它允许像这样键入信号量颜色:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个额外的泛型类型变量似乎可以做到这一点:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ddb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Typescript正确地将名称的类型推断为字符串文字而不是字符串:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/94250687ffe07856eea6c6fb03a0bc06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqwGWpu7pshMKOHCqmeTBw.png"/></div></div></figure><p id="e581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一需要输入的是run函数的参数，如果必须执行的话，可能还需要输入它的返回类型。</p><h1 id="fc88" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于TName的注释</h1><p id="70c5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当我开始写这篇文章时，我错误地认为Typescript将名称的类型推断为一个简单的字符串。为了克服这个问题，我必须做一些技巧来加强它。</p><p id="771f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了以下代码:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="44eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后按如下方式键入<code class="fe lb lc ld le b">name</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4459" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://stackoverflow.com/a/56375136/2659549" rel="noopener ugc nofollow" target="_blank">这篇StackOverflow回答</a>中了解更多。</p><p id="5e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，我错了，Typescript正确地将方法的名称推断为字符串文字。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="d030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使每个特定的方法都是完全类型化的，我们还是需要收集所有的实例并创建一个统一的类型，以便<code class="fe lb lc ld le b">callAsync</code>知道发生了什么。</p><p id="f390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案受到了Brian Terlson的文章<a class="ae kc" href="https://medium.com/@bterlson/strongly-typed-event-emitters-2c2345801de8" rel="noopener">“具有条件类型的强类型事件发射器”的启发，在这篇文章中，他提出了一个针对事件发射器的类似问题的解决方案。</a></p><p id="53de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是文章节选:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7f69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Events</code>接口中的键表示事件的名称，值表示应该从该特定名称的事件传递和接收的值的类型。</p><p id="5a37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最重要的部分发生在<code class="fe lb lc ld le b">on</code>方法定义中，它必须被传递一个类型为<code class="fe lb lc ld le b">K</code>的参数，该参数应该是<code class="fe lb lc ld le b">Events</code>接口中的一个键。之后，对<code class="fe lb lc ld le b">on</code>方法进行类型化，以便它知道侦听器的类型。同样的方法也适用于<code class="fe lb lc ld le b">emit</code>方法和所有其他方法。</p><p id="f95f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这个逻辑应用到<code class="fe lb lc ld le b">ValidatedMethods</code>中，我们可以想象一个类似这样的界面:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d9e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，我们有2个值要处理，参数类型和返回类型。一个自然的选择是将值存储为函数类型。</p><h1 id="e374" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于标记联合的注释</h1><p id="50ec" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">另一种方法是使用联合类型，如下所示:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bcd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在项目中广泛使用了联合类型，但是对于这个特殊的问题，它们似乎更难处理。</p><h1 id="ecef" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">提取ValidatedMethod类型</h1><p id="105d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">现在的问题归结为以某种方式转换一个如下所示的类型:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转换成类似这样的类型:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="aa4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">条件类型似乎是唯一的方法。我们可以使用以下实用程序类型提取每个特定类型:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c8ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，例如，下面的测试类型</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="eba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会有以下类型:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/9e05b881090d919c592d4c212cd2444c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59yg4N9FefWGOKVfaVq-vg.png"/></div></div></figure><p id="46fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他两个泛型类型以同样的方式工作。如果你想知道更多关于<code class="fe lb lc ld le b">infer</code>关键字如何工作的信息，请查阅官方文档中条件类型中的<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" rel="noopener ugc nofollow" target="_blank">类型推断。</a></p><h1 id="0be5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">组装新型号</h1><p id="9fc0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">因为我们可以提取泛型类型变量，所以我们可以将它们组装回我们想要的类型，如下所示:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9ab6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对此进行测试，看看它是否工作正常:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/d7cb66f335f058bda3f5f315310c8b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Tkg2ofg2FWfneMzlj9x2w.png"/></div></div></figure><h1 id="8364" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构建最终的API</h1><p id="79cc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">既然我们可以将<code class="fe lb lc ld le b">ValidatedMethod</code>泛型转换成我们需要的类型，剩下的工作就是组装所有的类型。</p><p id="9260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在<code class="fe lb lc ld le b">imports</code>文件夹的根目录下定义一个<code class="fe lb lc ld le b">methodTypes.d.ts</code>。因为它不包含任何实际运行的代码，所以它可以使用<code class="fe lb lc ld le b">.d.ts</code>扩展。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="93e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe lb lc ld le b">&amp;</code>(交集操作符)来扩充类型。基本上是这样:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="565b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将“等于”这个:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="a0fa" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">打字<code class="fe lb lc ld le b">callAsync</code></h1><p id="2f6e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">必须更新前面定义的<code class="fe lb lc ld le b">callAsync</code>包装器，以便它知道这个<code class="fe lb lc ld le b">KnownMethods</code>类型:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能更难消化，但让我们试一试。<code class="fe lb lc ld le b">TName</code>应该是<code class="fe lb lc ld le b">KnownMethods</code>中的一个键，也就是应该是一个已定义的<code class="fe lb lc ld le b">ValidatedMethods</code>的名称。这是<code class="fe lb lc ld le b">methodName</code>参数的类型。</p><p id="d1d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">FirstArgument</code>实用程序类型定义如下:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="aaa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它与之前定义的<code class="fe lb lc ld le b">ValidatedMethodArg</code>非常相似。它尝试提取第一个参数的类型，如果不能，则返回<code class="fe lb lc ld le b">never</code>类型。</p><p id="b4e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">ReturnType</code>带有Typescript，但也可以类似地定义:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c22e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">KnownMethods[TName]</code>从我们定义的<code class="fe lb lc ld le b">KnownMethods</code>类型中返回特定函数名的值。例如，如果<code class="fe lb lc ld le b">TName</code>是<code class="fe lb lc ld le b">"global.getRandomNumber"</code>，那么<code class="fe lb lc ld le b">KnownMethods[TName]</code>就是<code class="fe lb lc ld le b">(arg: {min: number; max: number}) =&gt; number</code>。</p><p id="2515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们只需要参数的类型，所以我们使用<code class="fe lb lc ld le b">FirstArgument&lt;KnownMethods[TName]&gt;</code>，在我们的具体例子中它将变成<code class="fe lb lc ld le b">{min: number; max: number}</code>。</p><p id="c46d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们使用<code class="fe lb lc ld le b">ReturnType&lt;KnownMethods[TName]&gt;</code>键入了<code class="fe lb lc ld le b">Promise</code>构造函数，所以<code class="fe lb lc ld le b">callAsync</code>的返回值是隐含的。逻辑和之前一样。</p><p id="4b60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数的代码保持不变。一个不幸的事情是<code class="fe lb lc ld le b">Promise</code>只接受一个泛型类型，所以我们不能输入错误值。<code class="fe lb lc ld le b">Meteor.call</code>回调返回的不是简单的<code class="fe lb lc ld le b">Error</code>而是<code class="fe lb lc ld le b">Meteor.Error</code>。不幸的是，我们无法捕捉到这一点。你可以在接下来的GitHub问题中找到更多相关信息。</p><h1 id="f5c8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">Promise&lt;Promise&lt;T&gt;&gt;</code>抓到你了</h1><p id="4859" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">不是所有的<code class="fe lb lc ld le b">ValidatedMethods</code>都是同步的，有些可能会返回一个承诺，Typescript可能会混淆。假设<code class="fe lb lc ld le b">getStringLength</code>方法(之前简要提及)定义如下:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fd53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Typescript将报告以下类型:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/e637cd0c8f5d3943780d743675ed9dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZgFD4_8jL8OBEKbV_KEegQ.png"/></div></div></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/7f435811b35b5d67e0daac129272036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8-SToJWyfdpW_xN8JE5ow.png"/></div></div></figure><p id="1f26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是不正确的，因为被另一个承诺包围的承诺仍然是一个承诺。</p><p id="21e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用另一种实用程序类型来解决这个问题:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="df7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lb lc ld le b">T</code>是<code class="fe lb lc ld le b">Promise</code>，返回其装箱类型，否则返回<code class="fe lb lc ld le b">T</code>。将其插入将导致以下<code class="fe lb lc ld le b">callAsync</code>的最终版本:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8c63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然有点乱，但它完成了任务。</p><h1 id="29bb" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">测试<code class="fe lb lc ld le b">callAsync</code></h1><p id="c0cd" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">现在一切似乎都已就绪，我们可以检查它是否真的像预期的那样工作了。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/f3e0e44be13213897a36cd827b89c952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGPYVj5BnFnLrb_R8OhcCg.png"/></div></div></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/d001fc35bc81f18d3d9f5eb0bf831276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsK1j0Vi7aL7n-6CiB6TtQ.png"/></div></div></figure><p id="df2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它知道应该传递的参数的类型，甚至在事情不正确时出错。看起来是个不错的组合。</p><h1 id="38bf" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">打字注意事项<code class="fe lb lc ld le b">Meteor.call</code></h1><p id="5aaa" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以尝试将相同的模式应用于<code class="fe lb lc ld le b">Meteor.call</code>方法:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="979d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里可以看到这种工作方式:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/44d555398fc909a80ffe87724e5d5a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThWON0NH3EAj7sZEe8KryQ.png"/></div></div></figure><p id="384e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，其中一个问题是，如果其中一个参数不正确，它将不会显示任何错误，因为它将默认为<code class="fe lb lc ld le b">@types/meteor</code>中定义的重载:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以通过使用后安装脚本(我们没有采用它，因为它对我们来说太麻烦了)删除该行、创建另一个包装器并键入它，或者使用另一种创造性的方法来解决。</p><h1 id="6286" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">关于<code class="fe lb lc ld le b">@ts-check</code>的笔记</h1><p id="0761" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">即使你的meteor项目还没有使用typescript，你仍然可以通过使用<code class="fe lb lc ld le b">@ts-check</code>注释来使用这个模式。它与VsCode配合使用效果最佳。例如，下面的方法也是完全类型化的。你可以在这里阅读更多关于<code class="fe lb lc ld le b">@ts-check</code><a class="ae kc" href="https://github.com/microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="613a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">整理笔记</h1><p id="8fa6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这种模式最薄弱的地方是必须手动将<code class="fe lb lc ld le b">ValidatedMethods</code>的类型添加到<code class="fe lb lc ld le b">KnownMethods</code>中。我尽了最大努力来寻找某种方法，让Typescript在创建新方法时自动聚合定义，但不幸的是，我没有找到任何方法来解决这个问题。一个选择是使用自动创建<code class="fe lb lc ld le b">typedMethods.d.ts</code>文件的codemod，尽管找到一个更简单的解决方案会更好。</p><p id="362c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对如何改进有任何想法和/或建议，请留言或通过邮件或其他方式联系我。</p></div></div>    
</body>
</html>