<html>
<head>
<title>Delegates vs Closure Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">委托vs闭包回调</h1>
<blockquote>原文：<a href="https://itnext.io/delegates-vs-closure-callbacks-f36f9029217d?source=collection_archive---------0-----------------------#2018-08-16">https://itnext.io/delegates-vs-closure-callbacks-f36f9029217d?source=collection_archive---------0-----------------------#2018-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="74ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得Objective-C中的代理模式有多棒吗？通过将您可能希望控制的部分委托出去，使类具有高度的可重用性。这是它在Cocoa Touch上无处不在的原因，它实在是太棒了！</p><p id="8922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有一种新的模式似乎正在悄悄地取代代表模式。我不确定它是否有正式名称，但我称它为:</p><p id="3872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">关闭回调模式</em></p><p id="2a13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能知道我指的是哪一个，但是如果你需要复习，这里有一些做事的方法:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="39fe" class="kv kw iq kr b gy kx ky l kz la">protocol ImageDownloaderDelegate: class {<br/>    func imageDownloader(_ downloader: ImageDownloader, didDownloadImage image: UIImage)<br/>}</span><span id="a54f" class="kv kw iq kr b gy lb ky l kz la">class ImageDownloader {</span><span id="828d" class="kv kw iq kr b gy lb ky l kz la">    weak var delegate: ImageDownloaderDelegate?</span><span id="f56c" class="kv kw iq kr b gy lb ky l kz la">    func downloadImage(url: URL) {<br/>        // download the image asynchronously then...<br/>        delegate?.imageDownloader(self, didDownloadImage: theImage)<br/>    }<br/>}</span></pre><p id="ab1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是闭包回调的方式:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="927a" class="kv kw iq kr b gy kx ky l kz la">class ImageDownloader {</span><span id="da75" class="kv kw iq kr b gy lb ky l kz la">    var didDownload: ((UIImage?) -&gt; Void)?</span><span id="9ea1" class="kv kw iq kr b gy lb ky l kz la">    func downloadImage(url: URL) {<br/>        // download the image asynchronously then...<br/>        didDownload?(theImage)<br/>    }<br/>}</span></pre><p id="4b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像其他人一样，当Swift问世时，我尝试了闭包回调模式，在我以前可能使用委托的地方使用它，以寻求不断增加的“迅捷”。尽管如此，我还是不满意。有时候感觉是一种进步，有时候不是。委托或闭包回调是更好的模式吗？我猜，嗯，<em class="kl">看情况</em>。</p><p id="cdd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">不过要看什么</em>？？？让我们比较这两种方法，看看我们是否可以学到一些东西。</p><h1 id="f168" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">打破保留周期</h1><p id="8179" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">每当两个对象相互引用时，其中一个必须持有对另一个的弱引用，否则我们就会得到一个保留循环。这两种模式对此的处理有天壤之别。</p><p id="3417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">委托模式是如何做到的:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="4577" class="kv kw iq kr b gy kx ky l kz la">class ImageDownloader {<br/>    weak var delegate: ImageDownloaderDelegate?<br/>    //...<br/>}</span><span id="7e5e" class="kv kw iq kr b gy lb ky l kz la">class ImageViewer: ImageDownloaderDelegate {</span><span id="f1af" class="kv kw iq kr b gy lb ky l kz la">    let downloader: ImageDownloader()</span><span id="be9f" class="kv kw iq kr b gy lb ky l kz la">    init(url: URL) {<br/>        downloader.delegate = self<br/>        downloader.downloadImage(url: url)<br/>    }</span><span id="4783" class="kv kw iq kr b gy lb ky l kz la">    func imageDownloader(_ downloader: ImageDownloader, didDownloadImage image: UIImage) {<br/>        // view the downloaded image...<br/>    }<br/>}</span></pre><ul class=""><li id="deaa" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated"><code class="fe mn mo mp kr b">ImageDownloader</code>负责通过持有对其委托的<code class="fe mn mo mp kr b">weak</code>引用来打破保留循环</li><li id="e837" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">弱/强关系只需要在一个地方定义</li><li id="9496" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">大会是为了让代表们保持虚弱，如果你忘记这样做，像<a class="ae mv" href="https://github.com/realm/SwiftLint" rel="noopener ugc nofollow" target="_blank"> SwiftLint </a>这样的短绒会警告你</li></ul><p id="9a8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">闭包回调是如何做到的:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="332d" class="kv kw iq kr b gy kx ky l kz la">class ImageDownloader {<br/>    var didDownload: ((UIImage?) -&gt; Void)?<br/>    //...    <br/>}</span><span id="9910" class="kv kw iq kr b gy lb ky l kz la">class ImageViewer {</span><span id="73ca" class="kv kw iq kr b gy lb ky l kz la">    let downloader: ImageDownloader</span><span id="9934" class="kv kw iq kr b gy lb ky l kz la">    init(url: URL) {<br/>        downloader = ImageDownloader()<br/>        downloader.downloadImage(url: url)<br/>        downloader.didDownload = { [weak self] image in<br/>            // view the image<br/>        }<br/>    }<br/>}</span></pre><ul class=""><li id="15be" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated"><code class="fe mn mo mp kr b">ImageViewer</code>负责确保它在回调中弱引用自己</li><li id="6ffe" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">弱/强关系必须在每次回调中正确实施</li><li id="0003" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">很容易出错，导致内存泄漏</li></ul><p id="b43b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能是做事情的老方法，但是委托模式在这方面是一个明显的赢家。<code class="fe mn mo mp kr b">weak</code>关系只定义一次，出错的难度要大得多。</p><p id="4b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过还有很多要考虑的，让我们看看闭包回调是否能自我救赎…</p><h1 id="f849" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一对多关系</h1><p id="9d9d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果一个类需要使用多个<code class="fe mn mo mp kr b">ImageDownloader</code>怎么办，我们的两种模式如何公平？</p><p id="3557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，代表模式:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="fa17" class="kv kw iq kr b gy kx ky l kz la">class ProfilePage: ImageDownloaderDelegate {</span><span id="be94" class="kv kw iq kr b gy lb ky l kz la">    let profilePhotoDownloader = ImageDownloader()<br/>    let headerPhotoDownloader = ImageDownloader()</span><span id="2dbd" class="kv kw iq kr b gy lb ky l kz la">    init(profilePhotoUrl: URL, headerPhotoUrl: URL) {</span><span id="d62e" class="kv kw iq kr b gy lb ky l kz la">        profilePhotoDownloader.delegate = self<br/>        profilePhotoDownloader.downloadImage(url: profilePhotoUrl)</span><span id="6d6b" class="kv kw iq kr b gy lb ky l kz la">        headerPhotoDownloader.delegate = self<br/>        headerPhotoDownloader.downloadImage(url: headerPhotoUrl)<br/>    }</span><span id="21e7" class="kv kw iq kr b gy lb ky l kz la">    func imageDownloader(_ downloader: ImageDownloader, didDownloadImage image: UIImage) {</span><span id="a79d" class="kv kw iq kr b gy lb ky l kz la">        if downloader === profilePhotoDownloader {<br/>            // show the profile photo...<br/>        } else if downloader === headerPhotoDownloader {<br/>            // show the profile photo...<br/>        }<br/>    }<br/>}</span></pre><p id="c877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须检查在每次回调中是哪个<code class="fe mn mo mp kr b">ImageDownloader</code>实例在调用我们。如果你有一大堆委托方法，这将变得非常乏味。另外，你很可能会犯错误。</p><p id="1493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我敢肯定，我们以前都在一个应用程序上工作过，同一个对象是多个<code class="fe mn mo mp kr b">UITableView</code>的代表。这不酷。</p><p id="c717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看闭包回调模式能否拯救我们:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="3185" class="kv kw iq kr b gy kx ky l kz la">class ProfilePage {</span><span id="7202" class="kv kw iq kr b gy lb ky l kz la">    let profilePhotoDownloader = ImageDownloader()<br/>    let headerPhotoDownloader = ImageDownloader()</span><span id="398f" class="kv kw iq kr b gy lb ky l kz la">    init(profilePhotoUrl: URL, headerPhotoUrl: URL) {</span><span id="40d0" class="kv kw iq kr b gy lb ky l kz la">        profilePhotoDownloader.didDownload  = { [weak self] image in<br/>            // show the profile image<br/>        }<br/>        profilePhotoDownloader.downloadImage(url: profilePhotoUrl)</span><span id="b6fa" class="kv kw iq kr b gy lb ky l kz la">        headerPhotoDownloader.didDownload  = { [weak self] image in<br/>            // show the header image<br/>        }<br/>        headerPhotoDownloader.downloadImage(url: headerPhotoUrl)<br/>    }<br/>}</span></pre><p id="bde6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一场明显的胜利。这两个实例的回调是完全独立的，所以我们不可能把它们搞混。</p><p id="80d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关闭回调赢得了这一次。现在是1比1。让我们看看接下来会发生什么:</p><h1 id="1839" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据源</h1><p id="350f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">好吧，这些不是严格意义上的委托模式，但是我也见过用于向对象提供信息的闭包回调函数，所以我把它们包括进来。</p><p id="d771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个基于<code class="fe mn mo mp kr b">protocol</code>的数据源模式:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="fdcd" class="kv kw iq kr b gy kx ky l kz la">protocol SerialImageUploaderDataSource: class {<br/>    var numberOfImagesToUpload: Int { get }<br/>    func image(atIndex index: Int) -&gt; UIImage<br/>    func caption(atIndex index: Int) -&gt; String<br/>}</span><span id="9193" class="kv kw iq kr b gy lb ky l kz la">class SerialImageUploader {</span><span id="8837" class="kv kw iq kr b gy lb ky l kz la">    weak var dataSource: SerialImageUploaderDataSource?</span><span id="8a75" class="kv kw iq kr b gy lb ky l kz la">    init(dataSource: SerialImageUploaderDataSource) {<br/>        self.dataSource = dataSource<br/>    }</span><span id="b16c" class="kv kw iq kr b gy lb ky l kz la">    func startUpload() {</span><span id="2075" class="kv kw iq kr b gy lb ky l kz la">        guard let dataSource = dataSource else { return }</span><span id="a6ed" class="kv kw iq kr b gy lb ky l kz la">        for index in 0..&lt;dataSource.numberOfImagesToUpload {<br/>            let image = dataSource.image(atIndex: index)<br/>            let caption = dataSource.caption(atIndex: index)<br/>            upload(image: image, caption: caption)<br/>        }<br/>    }</span><span id="a3b9" class="kv kw iq kr b gy lb ky l kz la">    func upload(image: UIImage, caption: String) {<br/>        // Upload the image...<br/>    }<br/>}</span></pre><ul class=""><li id="789f" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">协议方法都是必需的，所以如果<code class="fe mn mo mp kr b">dataSource</code>存在，那么我们知道它已经实现了我们需要的所有方法</li><li id="7f4a" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">我们将数据源传递给了<code class="fe mn mo mp kr b">init</code>方法，所以我们向这个类的用户明确表示数据源是必需的</li><li id="f534" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">如果我们稍后将所需的方法添加到datasource协议中，我们将会得到一个编译器错误，直到我们实现它们</li></ul><p id="81c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在用闭包实现了一个数据源:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="9c62" class="kv kw iq kr b gy kx ky l kz la">class SerialImageUploader {</span><span id="a99a" class="kv kw iq kr b gy lb ky l kz la">    var numberOfImagesToDownload: (() -&gt; Int)?<br/>    var imageAtIndex: ((Int) -&gt; UIImage)?<br/>    var captionAtIndex: ((Int) -&gt; String)?</span><span id="5d5e" class="kv kw iq kr b gy lb ky l kz la">    func startUpload() {</span><span id="f08b" class="kv kw iq kr b gy lb ky l kz la">        guard<br/>            let numberOfImagesToDownload = numberOfImagesToDownload,<br/>            let imageAtIndex = imageAtIndex,<br/>            let captionAtIndex = captionAtIndex<br/>            else {<br/>                return<br/>        }</span><span id="c7ba" class="kv kw iq kr b gy lb ky l kz la">        for index in 0..&lt;numberOfImagesToDownload() {<br/>            let image = imageAtIndex(index)<br/>            let caption = captionAtIndex(index)<br/>            upload(image: image, caption: caption)<br/>        }<br/>    }</span><span id="e038" class="kv kw iq kr b gy lb ky l kz la">    func upload(image: UIImage, caption: String) {<br/>        // Upload the image...<br/>    }<br/>}</span></pre><p id="7bef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个有点像火车残骸。我们相信所有三个闭包都是非零的，所以我不得不<code class="fe mn mo mp kr b">guard</code>反对所有的闭包。我本可以在<code class="fe mn mo mp kr b">init</code>中全部通过，并使它们不可选，但我认为这有点可笑。</p><p id="64c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您只需要一个闭包，那么您可以在<code class="fe mn mo mp kr b">init</code>中提供它作为非可选的，否则使用协议显然是更好的方法。</p><h1 id="237e" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可量测性</h1><p id="c782" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">所以，我们现在只有一个方法，但是如果将来我们有10个呢？我们的协议现在看起来像这样:</p><p id="b8a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">委托人:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="6410" class="kv kw iq kr b gy kx ky l kz la">protocol ImageDownloaderDelegate: class {<br/>    func imageDownloader(_ downloader: ImageDownloader, didDownloadImage image: UIImage)<br/>    func imageDownloaderDidFail(_ downloader: ImageDownloader)<br/>    func imageDownloaderDidPause(_ downloader: ImageDownloader)<br/>    func imageDownloaderDidResume(_ downloader: ImageDownloader)<br/>}</span><span id="5a1a" class="kv kw iq kr b gy lb ky l kz la">extension ViewController: ImageDownloaderDelegate {</span><span id="ad64" class="kv kw iq kr b gy lb ky l kz la">    func imageDownloader(_ downloader: ImageDownloader, didDownloadImage image: UIImage) {<br/>    }</span><span id="2313" class="kv kw iq kr b gy lb ky l kz la">    func imageDownloaderDidFail(_ downloader: ImageDownloader) {<br/>    }</span><span id="cc57" class="kv kw iq kr b gy lb ky l kz la">    func imageDownloaderDidPause(_ downloader: ImageDownloader) {<br/>    }</span><span id="62c8" class="kv kw iq kr b gy lb ky l kz la">    func imageDownloaderDidResume(_ downloader: ImageDownloader) {<br/>    }<br/>}</span></pre><ul class=""><li id="d97a" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">我们已经将所有的委托方法巧妙地包装在一个扩展中</li><li id="bd3f" class="me mf iq jp b jq mq ju mr jy ms kc mt kg mu kk mj mk ml mm bi translated">这一切是如何运作的，真的很清楚</li></ul><p id="2e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关闭回调:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="8e22" class="kv kw iq kr b gy kx ky l kz la">class ImageDownloader {<br/>    var didDownload: ((UIImage?) -&gt; Void)?<br/>    var didFail: (() -&gt; ())?<br/>    var didPause: (() -&gt; ())?<br/>    var didResume: (() -&gt; ())?<br/>}</span><span id="7eef" class="kv kw iq kr b gy lb ky l kz la">class ViewController: UIViewController {</span><span id="40b5" class="kv kw iq kr b gy lb ky l kz la">    let downloader = ImageDownloader()</span><span id="04c7" class="kv kw iq kr b gy lb ky l kz la">    override func viewDidLoad() {<br/>        super.viewDidLoad()</span><span id="45c5" class="kv kw iq kr b gy lb ky l kz la">        downloader.didDownload = {<br/>            //...<br/>        }</span><span id="cc02" class="kv kw iq kr b gy lb ky l kz la">        downloader.didFail = {<br/>            //...<br/>        }</span><span id="8bc0" class="kv kw iq kr b gy lb ky l kz la">        downloader.didPause = {<br/>            //...<br/>        }</span><span id="ca4d" class="kv kw iq kr b gy lb ky l kz la">        downloader.didResume = {<br/>            //...<br/>        }<br/>    }<br/>}</span></pre><p id="ace6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我一点也不喜欢这样。我们甚至不清楚应该把所有回调的设置代码放在哪里。也许我们可以做一个叫做<code class="fe mn mo mp kr b">setupDelegateCallbacks()</code>的方法？对我来说，这一切都有点乱。</p><p id="88ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代表模式的又一个胜利。</p><p id="f765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是我们的最后一项测试！</p><h1 id="9015" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">强制执行合同</h1><p id="4c3e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">任何与另一种类型一起工作的类型都应该期望另一种类型遵守约定。这样，如果契约没有履行，编译器可以在编译时通知我们，我们可以避免运行时令人讨厌的意外。</p><p id="1b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这两种方法的类型安全程度。</p><p id="8f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代表:</strong></p><p id="45eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">增加一个新方法，得到一个编译器错误，甜！</p><figure class="km kn ko kp gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mw"><img src="../Images/b5b8e6531711469990fd7365c088c7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6E3eY_XoPLm1J9HnlX_hQ.png"/></div></div></figure><p id="234a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">闭包回调:</strong></p><p id="39aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加一个新的回调，你会幸福地意识到你还没有实现它。这可能会产生不良后果。希望这不重要！</p><h1 id="0888" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">那么哪个更好呢？</h1><p id="8dbb" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">那么哪个最好呢？正如我们已经知道的，<em class="kl">这取决于</em>！但希望我们现在对什么有了更好的想法，所以让我们试着制定一些指导方针:</p><h1 id="7514" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">场景1:</h1><p id="27ca" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">你有一个单一的回调</strong></p><p id="8d1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回调闭包模式在这里是最好的。在初始化器中传递它，你甚至可以使它不可选:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="108b" class="kv kw iq kr b gy kx ky l kz la">class ImageDownloader {</span><span id="7956" class="kv kw iq kr b gy lb ky l kz la">    var onDownload: (UIImage?) -&gt; Void</span><span id="413f" class="kv kw iq kr b gy lb ky l kz la">    init(onDownload: @escaping (UIImage?) -&gt; Void) {<br/>        self.onDownload = onDownload<br/>    }<br/>}</span></pre><h1 id="969f" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">场景2:</h1><p id="9363" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">你的回访更像是通知</strong></p><p id="e25f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的回调更像是“通知”或者“触发器”,当其他事情发生时触发，那么闭包回调可能是一个侵入性较小的选择。让它们可选，你可以只实现你感兴趣的那些。</p><p id="0c96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的委托人说<em class="kl">嘿，我刚刚顺便做了这件事，让你知道</em>，而不是<em class="kl">我真的需要你现在做点什么！一个可选的闭包可以让你在需要的时候订阅那个回调，或者在不需要的时候不订阅。</em></p><h1 id="0077" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">场景3:</h1><p id="f569" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">你需要成为多个实例的代表</strong></p><p id="498a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里闭包回调是更好的模式。但是要小心，这确实是你所需要的。您可以始终拥有一个专用的委托或数据源对象，并拥有许多这样的实例。</p><h1 id="1dce" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">场景3:</h1><p id="ea9d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">您的委托实际上是一个数据源</strong></p><p id="10ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用一个协议，它在两种类型之间实施一个更强的契约，并且编译器可以帮助你发现错误。</p><h1 id="9252" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">场景4:</h1><p id="db60" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir">你有许多回调，它们可能会在未来发生变化</strong></p><p id="7ba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用协议。如果你将来忘记实现新的方法，编译器会告诉你而不是你的用户。</p><h1 id="623d" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">还有什么，或者你不确定:</h1><p id="5939" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果有疑问，使用协议。定义一个协议可以保证一致性类型已经实现了指定的方法。如果将来协议要求改变了，编译器会要求你更新你的类型。它还简化了弱/强关系，允许您在一个地方定义它。</p><h1 id="b0ce" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c4aa" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">回调闭包模式似乎无处不在。这可能是降低复杂性、处理一对多关系并使代码更具可读性的一个好方法。不过，我仍然认为协议更适合大多数情况。</p><p id="cb96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为正确的工作选择书写工具，如果你只记得这篇文章中的一件事——永远不要成为两个<code class="fe mn mo mp kr b">UITableView</code>的代表！</p><h1 id="635d" class="lc kw iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">进一步阅读</h1><p id="c452" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Oleg Dreyman的这个帖子提出了一个很好的解决方案，使用闭包回调来避免弱/强舞蹈的陷阱</p><p id="95a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">John Sundell的这个帖子有一些关于闭包回调和委托的很好的例子。</p><p id="629d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想法/评论/抱怨/只是想聊天？给我发微博。</p></div></div>    
</body>
</html>