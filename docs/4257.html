<html>
<head>
<title>Inject —Scalable dependency injection with Swift + support for singletons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">注入——可扩展的依赖注入，Swift +支持单例</h1>
<blockquote>原文：<a href="https://itnext.io/inject-scalable-dependency-injection-with-swift-support-for-singletons-9aa1015d8342?source=collection_archive---------3-----------------------#2020-05-25">https://itnext.io/inject-scalable-dependency-injection-with-swift-support-for-singletons-9aa1015d8342?source=collection_archive---------3-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5e2987622cb3fcf465c2610ab6126e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZMWmEeJOC8nakVu1UQIyA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用注入进行依赖注入</figcaption></figure><p id="4a0d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">大家好！，感谢@ </strong> <a class="ae la" href="https://medium.com/@Yves.sinkgraven?source=post_page-----204cb6374975----------------------" rel="noopener"> <strong class="ke ir">伊夫·辛克莱文</strong> </a> <strong class="ke ir">给我写文章的机会</strong> <a class="ae la" href="http://ITNEXT.IO" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> ITNEXT。IO</strong>T12<strong class="ke ir">。</strong></a></p><p id="3c8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Inject是我几天前做的一个小程序库，它提供了一种使用依赖解析器注入依赖的简单方法。</p><h1 id="91f8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">这个想法</h1><p id="fb2e" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">这个想法是在我阅读一篇<a class="ae la" href="https://link.medium.com/ZT3o3zkPD6" rel="noopener"> medium文章</a>时产生的，这篇文章解释了依赖注入如何使用属性包装器为Swift工作。</p><p id="5c18" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还在学习使用C#的ASP.NET核心，我真的很喜欢向你的服务注入依赖关系是多么容易:</p><div class="mf mg mh mi gt ab cb"><figure class="mj jr mk ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/1b99c33ddde7c10e54e4e741f4fcfac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*0iEW8fx1P0FmRD2u_Co3_Q.png"/></div></figure><figure class="mj jr mp ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/5309c827aeb6c74a93eed17bc57d87ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*HdqiXon1RH6OuwGp950NgQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk mq di mr ms translated">用C#在ASP.NET核上进行依赖注入</figcaption></figure></div><p id="acfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">带着这些想法，我决定为Swift设计一个图书馆。</p><p id="f6aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是首先，<strong class="ke ir">什么是依赖注入？为此我需要使用任何外部库吗？这个图书馆提供什么？</strong></p><h1 id="ceba" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">依赖注入</h1><p id="6a5a" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">(这只是一个简单的解释，如果你已经知道是怎么回事，你可以跳过这一节)</p><p id="191e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，假设您的应用程序中有一个视图/视图控制器，您想在其中检索从远程服务或数据库中获取的用户数据，这样您以后可以在标签或按钮等上使用它。您可能想要使用<strong class="ke ir">存储库模式，</strong>，在其中您创建不同的类来封装访问或修改数据源的逻辑。</p><p id="fb67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以做的一件事是在您的视图中创建该存储库的一个实例，这样每当您想要使用一些数据(检索用户、修改等)时，您就可以使用该存储库。</p><p id="65cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对此的一个改进是不在视图类中实例化存储库，因为视图不应该知道存储库是如何实现或创建的，而只是想使用它。基本上，我们应该将<strong class="ke ir"> <em class="lb">依赖倒置原则</em> </strong>付诸实践，在这种情况下，就像将依赖的实例化(我们的存储库)移动到视图构造函数中一样简单，类似于<code class="fe mt mu mv mw b">MyView(userRepository: SomeUserRepository()).</code></p><p id="e9fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">另一项改进是在Swift中为您的存储库</strong>(存储库或任何依赖关系)创建一个接口/协议。所以你可以用一个真实的实现或者一个模拟的实现来伪造一些数据。或者您可以有一个实现，现在使用本地数据库，但以后使用远程数据库或只是一些web服务。为您的依赖项提供一个公共接口是一个非常好的选择。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/58f861a8ea3fdd51a899f159ce16af6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxQ78sfMeKrPGfks-r8oMg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Swift上简单的原生依赖注入</figcaption></figure><p id="b4d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">作为另一项改进，我们甚至可以使用<strong class="ke ir">工厂模式</strong>为我们的存储库创建一个工厂类，因此我们不用直接实例化回购，而是在一个集中的地方完成。<strong class="ke ir">优点</strong>:如果你想改变应用程序中使用的所有存储库实例，你只需要在一个地方改变它。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/d3bd6fec369f46995ea17184e181b489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gh_kKbnALEnXR2tzuDq3_A.png"/></div></div></figure><p id="4bd2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">几乎同样的情况也适用于单例，但是需要一个共享实例。</p><h1 id="8f27" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">注射</h1><p id="4fc8" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">在解释<em class="lb">为什么</em>你可能想要使用我的库之前，首先让我给你介绍一个关于如何添加你的依赖项和使用它的小例子。这相当于我们之前讨论过的，但是使用了inject。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/5eb23c6e56f6d9ed45325963247e2491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEuxitY-ZxT2wGURYD1qEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用注入添加依赖项</figcaption></figure><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/8c2a9414003aea1f8466b59e138ad640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bFUIh2tCS4VlCbcAI_Fcg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用依赖项进行注入</figcaption></figure><p id="5161" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们<strong class="ke ir">通过使用协议及其实现</strong>来添加依赖关系。稍后<strong class="ke ir">我们在我们想要使用它们的类上声明它们，并使用注入属性包装器</strong>，从这一点开始，你可以正常地在你的类中使用你的依赖项(你只需要在你的init方法中使用$yourDependency，实际上这样做是可选的)。</p><p id="97ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">它是如何工作的？</strong></p><p id="9622" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Inject使用依赖解析器，您必须静态实例化它才能使用它。它基本上注册了你的依赖关系以及如何构建它们，以便以后可以解决它。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/1f9eca692eeee84a853aea44835a0eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vb7DekZtz8PPDlaRWbrY1A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">依赖关系解析器—注入</figcaption></figure><p id="c91b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是注入属性包装器真正的工作方式，它使用在构造函数中传递的依赖解析器，稍后当您使用变量时，它解析依赖实现。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/2d082e4ebbc9f5b922714814b58f5149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_JnoFqeoixplXe87j1STg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">注入属性包装</figcaption></figure><p id="1f77" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你不想一直传递依赖解析器，你可以创建一个本地扩展，在一个空的构造函数中使用它。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/14698553d077cd07604489272eb829f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnmZvXSI0gYRzAcPjFqhTw.png"/></div></div></figure><p id="7e29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">同样，单身者</strong></p><p id="f341" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单身族呢？<code class="fe mt mu mv mw b">Inject</code>支持他们。您只需要创建一个类(或者甚至是一个结构，并将其包装在一个<code class="fe mt mu mv mw b">Box&lt;T&gt;</code>类型中)，创建一些方法，并使用一个单独的解析器添加它。您可以直接添加类型实现或使用协议，就像前面的例子一样。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/df5aede3d6b51eca679b447603bcc80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9h2zv8ELdsU4hpEyXgKQww.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">带有注入的单例示例</figcaption></figure><p id="56a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你不需要一个静态变量，你也可以为你的singleton使用一个协议。</p><p id="a7d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，单例解析器将在整个应用程序中存储单例实例的引用值。不像普通的解析器，它只保存一个函数来建立一个新的依赖关系。</p><p id="5c6f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">但是等等！还有更多</strong></p><p id="23d0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嵌套依赖！</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/a1790598057deb73959d630bf80090dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCx8PF7xVSgLRWrELCRhHg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">嵌套依赖示例—注入</figcaption></figure><p id="61db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，我们有一个存储库，它本身依赖于数据库管理器类或其他东西。多亏了inject，我们只需添加所有的依赖项并神奇地使用注入的仓库:)</p><p id="a16c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">更多的东西</strong></p><p id="8aac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您也可以使用<code class="fe mt mu mv mw b">@AutoWired</code>，它是另一个没有setter的属性包装器。我不太推荐它，因为你不能像使用inject那样轻易改变它的值，但是有些人可能更喜欢这样。</p><h1 id="3bd1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论——优点、缺点、为什么您可能想使用注射</h1><p id="7cbf" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated"><strong class="ke ir">缺点</strong>:</p><ul class=""><li id="60df" class="ng nh iq ke b kf kg kj kk kn ni kr nj kv nk kz nl nm nn no bi translated">对于有几个依赖项的简单/小型项目来说，可能有太多的东西。</li><li id="053d" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">这是一个项目依赖，它需要像swift一样更新(我希望它会更新)。</li></ul><p id="7e90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">优点</strong>:</p><ul class=""><li id="b449" class="ng nh iq ke b kf kg kj kk kn ni kr nj kv nk kz nl nm nn no bi translated">一旦设置好就很容易使用。</li><li id="199f" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">Swift包管理器支持。</li><li id="5365" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">它使用某种工厂模式，但是在幕后，你只需要添加你的依赖项并使用它们。</li><li id="1485" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">特别支持<strong class="ke ir">单线态</strong>，不需要使用为它们创建更多的静态变量；<strong class="ke ir">就把它们当做普通依赖吧！</strong></li><li id="086a" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">懒散地解决你的依赖。</li><li id="c092" class="ng nh iq ke b kf np kj nq kn nr kr ns kv nt kz nl nm nn no bi translated">强大的嵌套依赖支持。</li></ul><p id="46f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，今天就到这里吧！如果你仍然感兴趣，并且认为Inject适合你，请在这里查看它的github repo:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/illescasDaniel/Inject-Swift" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">illescasDaniel/Inject-Swift</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">swift的简单依赖注入，兼容结构和类。定义您的协议定义一个类(或…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol jw nx"/></div></div></a></div><p id="daa6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个使用它的项目示例:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/illescasDaniel/Inject-Swift-example" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">illes cas Daniel/Inject-Swift-example</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">注入Swift示例。通过在GitHub上创建一个帐户，为illescasDaniel/Inject-Swift-example开发做出贡献。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol jw nx"/></div></div></a></div><p id="b57d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！:D</p></div></div>    
</body>
</html>