<html>
<head>
<title>Implementing Event Store in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中实现事件存储</h1>
<blockquote>原文：<a href="https://itnext.io/implementing-event-store-in-c-8a27138cc90?source=collection_archive---------0-----------------------#2020-03-15">https://itnext.io/implementing-event-store-in-c-8a27138cc90?source=collection_archive---------0-----------------------#2020-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d7ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是怎么回事？</p><p id="f58a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在寻找Event Sourcing实现中EventStore的例子时，你可能会发现很多，理论上非常详细，但缺乏实际实现。在这篇文章中，我的目标是解释如何实现简单而健壮的事件存储，测试它，以及根据我自己的经验，你会遇到哪些陷阱。</p><p id="c701" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里介绍的事件存储将在中实现。NET核心，C#和MS SQL LocalDB服务器作为数据库。</p><p id="d5f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包含工作解决方案的完整项目可在我的<a class="ae kl" href="https://github.com/bolicd/eventstore" rel="noopener ugc nofollow" target="_blank"> github </a>上获得</p><p id="75ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="km">事件采购简介</em> </strong></p><p id="8147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会详细讨论什么是事件采购，因为这个主题在网上的许多书籍和文章中都有涉及。</p><p id="899f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，在考虑实现一个实际的事件存储时，我将把重点放在什么是重要的。但是，尽管如此，我将快速总结事件采购背后的主要思想和主要挑战。</p><p id="31b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">骨料被认为是一个由骨料根代表的整体。从概念上讲，聚合是以整体形式加载和保存的。(埃文斯，2001年)。</em></p><p id="a256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件源是一种软件架构模式，它规定应用程序的状态应该作为事件序列持久化。活动采购的主要优势是:</p><ul class=""><li id="626a" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><em class="km">可审核性</em> —由于状态是由事件序列构成的，因此可以提取从请求到当前日期的详细日志</li><li id="4807" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><em class="km">预测/查询</em> —有可能在不同的时间框架内重建状态，因为我们从一开始就有所有的事件。例如，可以检查一年前的银行账户状态。这也允许生成一些我们在启动系统时从未想过的查询/报告，因为所有的数据都在事件中。</li><li id="7709" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><em class="km">插入数据时的性能</em> —由于EventStore是带有乐观锁定的append only存储，我们希望发生的死锁(或并发异常)会少得多。此外，不再运行在多个表中插入数据图表事务。</li><li id="3f9a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><em class="km">平面数据库结构</em> —我们通常使用1个(或最多2个表)作为事件存储。在这两种情况下，它都是非规范化形式，使用某种形式的弱序列化字段来存储事件的有效负载，例如JSON。这意味着在向数据库添加新字段时，不需要将它们添加到任何表中——只需调整事件并添加所需字段，就可以将其保存到JSON中。这允许更快的写入端开发时间</li></ul><p id="a265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与每种模式一样，我们必须意识到局限性/挑战。如果使用不当，事件源可能会弊大于利。因此，我们应该牢记的主要挑战是:</p><ul class=""><li id="eda7" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><em class="km">存储增长</em> —由于数据存储仅追加，表将无限增长。这可以通过使用快照或保留策略来缓解。</li><li id="9055" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><em class="km">重放事件</em> —如果用于构建聚合的事件数量很大，则在重建聚合的当前状态时可能会导致一些性能问题。这可以通过使用快照来缓解。</li><li id="5bc4" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><em class="km">事件版本控制和事件处理</em> —当改变现有事件，或添加/删除特征时，必须有一个映射旧事件的代码，因为它用于将状态重建到实际状态。这意味着，如果某个功能被否决，其代码不能被删除，因为它用于重建当时的状态。这个挑战有点难以克服，但可以减轻。</li></ul><p id="25fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="km">事件存储注意事项</em> </strong></p><p id="e639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件存储的要求如下:</p><ul class=""><li id="af14" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">它是仅追加的，这意味着没有仅更新插入</li><li id="f759" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">它应该存储聚合状态，并允许按保存顺序提取给定聚合的事件。</li><li id="68c6" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">它应该使用乐观并发检查:乐观并发检查不使用数据库级别的锁定，因此降低了死锁的风险。相反，并发检查是在保存时进行的。</li></ul><p id="b03f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="km">乐观并发检查</em> </strong></p><p id="abb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当插入到存在多个客户端的数据库中时，可能会发生2个或更多客户端尝试修改同一个聚合的情况。因为我们不使用悲观并发检查，所以不会有锁和等待，但是检查本身会在尝试持久保存实际数据时应用。</p><p id="a088" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明问题，让我们考虑一个例子:</p><p id="9553" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设有两个请求想要修改同一个名为aggregate的聚合。<em class="km">应该在数据库级实现并发检查。</em></p><ol class=""><li id="717f" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated">它们都将从为1的事件存储中获取当前版本</li><li id="ad29" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">保存第一个聚合，第二个聚合版本设置为2</li><li id="5ff4" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated">在这种情况下，第二个聚合将无法通过并发检查，因为它的版本是2，而预期的版本是3。这表示数据自读取后已被更改。在这种情况下，保存第二个聚合应该会因并发异常而失败。</li></ol><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/f825c5d0453edaff50492e208cb6ed31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*SNF5uoXqsei6TcOCgvtpDg.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">使用聚合版本的乐观检查示例</figcaption></figure><p id="0d68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据库模式</strong></p><p id="cc72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件存储将是一个表，<em class="km">仅追加</em>，这允许每个集合的版本跟踪，并在数据库级别实现并发检查。</p><p id="df32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有数据JSON字段的事件存储表的SQL(这是事件有效负载被序列化的地方):</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">事件存储的SQL示例表</figcaption></figure><p id="0c78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AggregateId和Version是用于并发检查的两个字段。我们用这两个字段创建唯一的索引。AggregateId是我们聚合的Id，可以是我们想要的任何值(因此它被定义为string)。根据域的不同，它可以是GUID、int或两者的组合，这并不重要。</p><p id="7794" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，AggregateId被定义为nvarchar(250)</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">在数据库级别上，对表的Version和AggregateId字段强制使用唯一索引</figcaption></figure><p id="7a32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用这一点，我们可以确保永远不会保存相同的aggregate id/版本组合。相反，数据库会引发唯一索引检查失败异常。<strong class="jp ir"> <em class="km">这是一个暂时性的错误</em> </strong>，意味着可以(也应该)在客户端实现重试机制(见重试模式)。</p><p id="716e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">范例项目简介</strong></p><p id="fa3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目是使用。网芯3.1。</p><p id="de51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">项目架构是分层的，并具有控制反转。</p><p id="8094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图层:</p><ul class=""><li id="e6c9" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><strong class="jp ir"> RestAPI </strong> —包含DTO和REST控制器定义的Web API</li><li id="1006" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">基础设施</strong> —工厂、数据库模型和存储库实现在此定义</li><li id="1e25" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">核心</strong> —包含业务逻辑以及聚合的存储库接口。这个项目没有引用任何其他项目或任何其他第三方库(除了战术DDD nuget这是纯C#代码)</li></ul><p id="bcc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他项目:</p><ul class=""><li id="bea7" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><strong class="jp ir">数据库迁移</strong> —用于初始化数据库的迁移项目</li><li id="b21a" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir"> EventStoreTests </strong> —测试项目，演示事件存储的集成测试</li></ul><p id="34ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于核心业务逻辑，只有一个名为<strong class="jp ir"> Person </strong>的聚合和两个域事件:</p><ol class=""><li id="964e" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated"><em class="km">人员创建</em> —人员创建时发布此事件</li><li id="8d9c" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated"><em class="km"> AddressChanged </em> —当给定人员的地址改变时，发布此事件</li></ol><p id="8f6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何设置和运行项目可以在github资源库的readme文件中找到。</p><p id="1f08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">事件存储实现</strong></p><p id="b2ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下实现事件存储的实际代码。我在这里只放代码片段，而完整功能的项目可以在我的<a class="ae kl" href="https://github.com/bolicd/eventstore" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p><p id="ba7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">事件存储库</em>的接口可以定义为:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4f25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接口定义了两种方法。</p><ul class=""><li id="7927" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><strong class="jp ir"> <em class="km"> SaveAsync </em> </strong>方法用于将聚合持久化为事件流。集合本身被描述为域事件的集合，具有唯一的名称。</li><li id="79ff" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir"> <em class="km"> LoadAsync </em> </strong>方法使用AggregateId作为参数从事件存储中提取聚合，并将其作为事件数组发出。该数组可用于加载聚合。</li></ul><p id="5f60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km"> IEntityId </em>和<em class="km"> IDomainEvent </em>都是从一个<a class="ae kl" href="https://www.nuget.org/packages/TacticalDDD/" rel="noopener ugc nofollow" target="_blank">战术DDD nuget </a>中导入的，这个我强烈推荐给C#中的DDD。这两个都是简单的接口，标记了<em class="km"> EntityId </em>类和<em class="km"> DomainEvent </em>类。</p><p id="01bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们分析一下这两种方法的实际实现:</p><p id="0e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">持续事件</strong></p><p id="8afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将聚合持久化到EventStore中，我们需要3个参数:</p><ol class=""><li id="0fde" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk lb kt ku kv bi translated"><em class="km">聚合Id </em> —这是聚合的Id。在我们的例子中，它将是实现<em class="km"> IEntityId </em>接口的类</li><li id="f603" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated"><em class="km"> OriginatingVersion </em> —这是正在保存的聚合版本。一旦保存的版本增加1。如前所述，这用于开放式并发检查</li><li id="9ee7" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk lb kt ku kv bi translated"><em class="km">IReadOnlyCollection&lt;IDomainEvent&gt;</em>—这是需要持久化到数据库中的事件的实际列表。每个事件都作为新行保存。</li></ol><p id="7904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">实现SaveAsync </em></p><p id="2a6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此方法的完整实现可以在EventStoryRepository.cs文件中找到。</p><p id="00c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，使用提供的参数创建插入查询。为此，我们使用micro ORM <a class="ae kl" href="https://www.nuget.org/packages/Dapper/" rel="noopener ugc nofollow" target="_blank"> Dapper </a>，它允许使用@符号映射参数。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="572f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参数名称(例如@Name)与对象特性匹配并被映射。这就是为什么在下一行中，<em class="km">创建了一个匿名对象列表，其属性与query中定义的属性相同。</em></p><p id="f6e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">属性包括:</p><ul class=""><li id="31f8" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated"><strong class="jp ir">聚合</strong> -这是一个聚合的字符串名称。</li><li id="5295" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">创建日期</strong> —是创建事件的日期/时间</li><li id="720c" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">数据</strong> —这是事件负载，序列化为JSON字符串。使用提供的jsonSettings将完整事件序列化到JSON中。</li><li id="6a0e" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir"> Id </strong> —这可以是任何类型的Id。对于这个例子，我使用了Guid。</li><li id="b720" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">名称</strong> —这是实际的事件名称</li><li id="1252" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">聚合Id </strong> —这是聚合的Id。使用此字段，可以过滤给定聚合的事件。</li><li id="44b5" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated"><strong class="jp ir">版本</strong> —给定集合的每次增量。用于开放式并发检查。</li></ul><p id="2aea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，使用以下方法将事件列表映射到实际查询:</p><blockquote class="lq lr ls"><p id="4cdb" class="jn jo km jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">等待连接。ExecuteAsync(查询，列表事件)；</p></blockquote><p id="c1d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这行代码使用Dapper ORM中的<em class="km"> ExecuteAsync </em>方法，该方法将使用查询字符串中定义的参数映射<em class="km"> listOfEvents </em>属性，并创建实际的查询。</p><p id="2434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当以这种方式持久化时，每个事件都作为新行持久化在EventStore表中，并带有实际事件的数据有效负载。它看起来是这样的:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/76ebda513736bd833664800f3240b69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xe9QgezGNLy99CvF2Ql8CQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">每个事件都作为新行保存在数据库中。每个聚合和序列的版本更改总是递增的</figcaption></figure><p id="61c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查数据列时，这是有效载荷:</p><blockquote class="lq lr ls"><p id="cdf5" class="jn jo km jp b jq jr js jt ju jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj kk ij bi translated">{ <br/> "$type ":"核心。person . domain events . person created，Core "，<br/>" PersonId ":" d91f 903 f-3fb 1–4b 68–9a 59-c 1818 c 94 f 104 "，<br/>"名字":" damir6 "，<br/>"姓氏":" bolic7 "，<br/>" created at ":" 2020–02–20t 07:24:54.0490305 z "<br/>}</p></blockquote><p id="1f4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该事件的有效负载实际上是从PersonCreated事件映射而来的，该事件是在创建新人员时发出的:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">创建新的人员集合时，将发布此域事件</figcaption></figure><p id="0d9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DomainEvent类可以定义如下:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="dd1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，CreatedAt是基于DDD战术nuget的IDomainEvent添加的。</p><p id="602a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">装载骨料</strong></p><p id="9afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用AggregateId加载聚合。对于给定的aggregate，加载所有事件，然后使用这些事件构造Aggregate，进而在内存中生成新的Aggregate对象。</p><p id="14f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用SQL查询加载聚合，作为使用<em class="km">事件存储库的事件列表。LoadAsync() </em>方法。当事件从JSON反序列化并转换为DomainEvent对象时，真正的奇迹发生了:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">选择聚合的所有事件，并将它们转换为域事件</figcaption></figure><p id="6081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，事件被提取为对象的EventStoreDao列表，然后使用<em class="km"> TransformEvent </em>方法将其转换为<em class="km">域事件</em>:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="03c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，事件<em class="km"> eventSelected的实际有效载荷。数据</em>被反序列化为对象，然后被转换为<em class="km"> IDomainEvent </em>接口。<em class="km">注意，如果转换失败，它将返回null。</em></p><p id="18e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦获取了域事件列表，就可以构建人员集合。</p><p id="b9be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">测试</strong></p><p id="2a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试事件存储并不难。</p><p id="135d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于单元测试，它定义了可以被模仿的接口<em class="km"> IEventStore </em>。</p><p id="ee86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于集成测试，可以使用内存数据库。在示例项目中，<a class="ae kl" href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <em class="km"> LocalDB </em> </a>用于测试和实际项目中。这位于<em class="km">eventstoregintegrationtests . cs</em>文件中。</p><p id="3ed3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总结</strong></p><p id="ddbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇博客的目的是用具体的例子展示如何用C#实现简单的事件存储。为此，我们使用了一些DDD概念，如集合、存储库、实体和值对象。</p><p id="b4a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本博客包含的示例项目旨在简单演示这里定义的原则。</p></div></div>    
</body>
</html>