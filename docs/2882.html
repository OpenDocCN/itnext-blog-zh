<html>
<head>
<title>React and Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Web组件</h1>
<blockquote>原文：<a href="https://itnext.io/react-and-web-components-3e0fca98a593?source=collection_archive---------1-----------------------#2019-08-21">https://itnext.io/react-and-web-components-3e0fca98a593?source=collection_archive---------1-----------------------#2019-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/edb53e2b163809d7b1b2f93ca7e42215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1rI5hFdLTum23BUZ_vf3Q.png"/></div></div></figure><div class=""/><p id="ceae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Web组件变得越来越流行，而且它们肯定会继续流行下去。<br/>正如我们所说的，对Web组件的支持正在增长，而且更多的资源、库和工具正变得对那些有兴趣创建和发布他们自己的Web组件的开发者可用。</p><p id="6031" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将介绍如何使用React创建一个小应用程序，并将其构建为Web组件。</p><p id="875c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将假设React和Webpack的基本经验。</p><h1 id="515f" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">TL；博士</strong></h1><p id="e79d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您可以构建一个React应用程序，并将其包装在一个Web组件中——只需稍加调整就能使其正常工作。</p><p id="c13d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最简单的方法是使用<a class="ae lz" href="https://direflow.io/" rel="noopener ugc nofollow" target="_blank">方向流</a></p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/4ab5cc9a81ccc94f46baf8c0d25ec3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BarMohttHm6rUB4NiiTsVg.gif"/></div></div></figure><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="af41" class="mk kx jb mg b gy ml mm l mn mo">npm i -g direflow-cli</span><span id="6b05" class="mk kx jb mg b gy mp mm l mn mo">direflow create</span></pre><h1 id="f25d" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是Web组件？</h1><p id="124c" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Web组件是一种构建自定义的、可重用的、封装的HTML标签的方式，可在网页和web应用程序中使用。<br/> Web组件基于现有的Web标准，可以与任何支持HTML的JavaScript库或框架结合使用。因此，它们是框架不可知的。</p><p id="efee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有主流浏览器都支持基于Web组件标准构建的组件。</p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/aa04ddcc1feb314b03848cc91efea0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQzKxqCFpcZD4OcVciROAw.png"/></div></div></figure><p id="e88b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过创建自定义HTML元素来使用Web组件，然后可以简单地将其用作任何其他HTML标记:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c781" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦构建了Web组件，就可以将其发布到在线注册表，以便其他开发人员可以在他们的项目中使用Web组件。<br/>同样，您可以找到许多已经制作好并随时可以使用的Web组件。</p><p id="efeb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Web Components的官方网页上可以看到更多这些美好的东西<a class="ae lz" href="https://www.webcomponents.org/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f1c5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何创建Web组件？</h1><p id="791d" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">创建一个简单的Web组件实际上非常容易。<br/>我们将使用JavaScript来定义一个新的HTML元素及其标签。</p><p id="7363" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建一个新的自定义HTML元素，我们将执行以下操作</p><ul class=""><li id="1e2e" class="mt mu jb ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">创建一个新的<code class="fe nc nd ne mg b">class</code>并扩展<code class="fe nc nd ne mg b">HTMLElement</code></li><li id="e024" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated">使用此类创建组件及其逻辑</li><li id="bb00" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated">使用全局函数<code class="fe nc nd ne mg b">customElements.define()</code>定义新元素</li></ul><p id="454d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3d06" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。<br/>现在我们可以像这样在页面中使用新的Web组件:<br/> <code class="fe nc nd ne mg b">&lt;top-menu&gt;&lt;/top-menu&gt;</code></p><p id="1e46" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们使用了一个<em class="nk">影子DOM </em>，它是Web组件使用的四个主要概念之一。<br/>详细介绍请参考<a class="ae lz" href="https://www.webcomponents.org/introduction" rel="noopener ugc nofollow" target="_blank"> Web组件官方网页</a></p><p id="baba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，像这样构建更复杂的组件很快就会变得很麻烦。<br/>幸运的是，使用<a class="ae lz" href="https://lit-element.polymer-project.org/" rel="noopener ugc nofollow" target="_blank">聚合物项目</a>中的Lit元素，这变得非常方便和容易。</p><h1 id="7e21" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用React创建Web组件</h1><p id="af3e" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">但是反应呢？如果我们可以使用React构建组件逻辑，然后将其构建为Web组件，这不是很棒吗？<br/>嗯，绝对！</p><p id="ffb3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，这不是我们能做的事情。<br/> React使用了一个<a class="ae lz" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank"> <em class="nk">虚拟DOM </em> </a> <em class="nk">，</em>这是实际DOM的一个虚拟表示。这经常与影子DOM的工作方式相冲突，导致诸如使用样式和事件之类的问题。</p><p id="05e1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，这是可以做到的。我们只需要稍微调整一下🤓</p><p id="92ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让React正常工作，我们需要进行以下更改:</p><ul class=""><li id="8185" class="mt mu jb ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated"><strong class="ka jc">创建并定义一个新的自定义元素</strong></li><li id="f2f0" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated"><strong class="ka jc">将React应用程序安装到元素上</strong></li><li id="2b9b" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated"><strong class="ka jc">让我们的React应用对属性和特性的变化做出反应</strong></li><li id="9227" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated"><strong class="ka jc">确保css被正确应用</strong></li><li id="febb" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated"><strong class="ka jc">确保反应事件正确发出</strong></li></ul><p id="16a8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从顶部开始，一步一步地完成这个列表。</p><p id="dc90" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">创建并定义一个新的自定义元素</strong></p><p id="f63c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们假设我们已经将顶部菜单组件构建为一个React组件<code class="fe nc nd ne mg b">&lt;TopMenuComponent /&gt;</code>。继续定义一个扩展了<code class="fe nc nd ne mg b">HTMLElement</code>的<code class="fe nc nd ne mg b">class</code>，并使用<code class="fe nc nd ne mg b">window.customElement.define()</code>定义它的元素，就像我们之前做的一样。</p><p id="88fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在<code class="fe nc nd ne mg b">index.jsx</code>(或者你的React应用的入口点)做这件事。<br/>这是我们通常将React应用安装到文档中id为<code class="fe nc nd ne mg b">root</code>的<code class="fe nc nd ne mg b">div</code>元素的地方。</p><p id="abcc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">将React应用程序安装到元素上</strong></p><p id="e926" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将React应用程序安装到我们定义的自定义元素上，而不是安装到<code class="fe nc nd ne mg b">div</code>上。<br/>根据以下内容更改代码:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="844d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们转到id为<code class="fe nc nd ne mg b">root</code>的<code class="fe nc nd ne mg b">div</code>所在的<code class="fe nc nd ne mg b">index.html</code>文件，并将该div改为我们的Web组件。</p><p id="be51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">移除:<br/>T11】</p><p id="e44f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加:<br/>T12】</p><p id="561d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">注意:如果你使用Webpack，确保你的包被注入到你的HTML文件的</em> <code class="fe nc nd ne mg b">&lt;head&gt;</code> <em class="nk">部分。</em></p><p id="0daf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该会呈现您的Web组件！然而——它可能看起来很奇怪，因为仍然需要修改样式。<br/>别担心——我们一会儿会回到这个话题。</p><p id="d90b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">让我们的React应用程序对属性和特性的变化做出反应</strong></p><p id="5a0c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们先来听听属性变化。在这种情况下，我们希望Web组件能够接收两个属性:<code class="fe nc nd ne mg b">menutitle</code>和<code class="fe nc nd ne mg b">menucolor</code>。</p><p id="3b68" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将对<code class="fe nc nd ne mg b">index.jsx</code>文件进行如下修改:</p><ul class=""><li id="35a3" class="mt mu jb ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">创建一个实例变量<code class="fe nc nd ne mg b">attributes</code>。</li><li id="7d70" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated">创建一个方法<code class="fe nc nd ne mg b">attributeChangedCallback()</code>，用新的属性更新变量<code class="fe nc nd ne mg b">attributes</code>。</li><li id="e8da" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated">创建一个静态getter方法<code class="fe nc nd ne mg b">observedAttributes()</code>，该方法返回一个属性列表以观察变化。<br/> ( <em class="nk">注意观察到的属性必须是小写</em>)。</li><li id="6bab" class="mt mu jb ka b kb nf kf ng kj nh kn ni kr nj kv my mz na nb bi translated">最后，将更新的属性作为道具传递给我们的React应用程序</li></ul><p id="59bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置完属性后，我们还想再次调用<code class="fe nc nd ne mg b">mountReactApp()</code>方法，以确保rerender被触发。</p><p id="891c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果将如下所示:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="01e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们还想处理属性。在这种情况下，我们希望Web组件能够接收一个字符串列表作为属性，这将是Web组件中菜单项的标题。</p><p id="a02e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过为我们的属性创建一个setter来处理这个问题。我们设想我们可能也想从Web组件中获取那个值，所以让我们也创建一个getter。</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="83ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们确保在设置属性值后调用<code class="fe nc nd ne mg b">mountReactApp()</code>来触发rerender。此外，我们将属性作为道具传递下去，就像我们对属性所做的那样。</p><p id="2214" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe nc nd ne mg b">index.jsx</code>文件现在完整地看起来像这样:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0cc1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利！<br/>尝试转到您的<code class="fe nc nd ne mg b">index.html</code>文件，并使用我们的一个属性:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2f93" class="mk kx jb mg b gy ml mm l mn mo">&lt;top-menu menutitle="Cool menu"&gt;&lt;/div&gt;</span></pre><p id="d886" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在转到你的React组件:<code class="fe nc nd ne mg b">TopMenuComponent</code>，并<code class="fe nc nd ne mg b">console.log</code>出道具。<br/>你现在应该可以看到<code class="fe nc nd ne mg b">'Cool menu'</code>作为道具的价值了！<br/>同样的，一个改变的属性也应该可以通过道具获得。</p><p id="582a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试它，在您的<code class="fe nc nd ne mg b">index.html</code>文件的底部添加这个脚本标签:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9023" class="mk kx jb mg b gy ml mm l mn mo">&lt;script&gt;</span><span id="716a" class="mk kx jb mg b gy mp mm l mn mo">const topMenu = document.querySelector('top-menu');<br/>topMenu.menuItems = ['Home', 'About', 'Log out'];</span><span id="50eb" class="mk kx jb mg b gy mp mm l mn mo">&lt;/script&gt;</span></pre><p id="7ca1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都好！我们的Web组件现在可以对属性和特性做出反应，我们可以将它们作为道具传递给react应用程序👐</p><p id="7e13" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">确保正确应用CSS</strong></p><p id="1e09" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能已经注意到，样式可能没有得到应有的应用。所以一切看起来有点乱。<br/>这是因为Shadow DOM封装了它下面的所有东西，如果你在Webpack中使用<code class="fe nc nd ne mg b">style-loader</code>、<code class="fe nc nd ne mg b">css-loader</code>或类似的东西，这些样式就不会被应用。</p><p id="d171" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，有一个圆滑的小变通办法。<br/>我们将使用一个名为<a class="ae lz" href="https://www.npmjs.com/package/style-it" rel="noopener ugc nofollow" target="_blank"> style-it </a>的包将我们的样式直接注入到DOM中。</p><p id="0974" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，请继续安装带有npm或yarn的style-it。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d8a1" class="mk kx jb mg b gy ml mm l mn mo">yarn add style-it</span></pre><p id="fedf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将更改我们的Webpack配置文件，以使用<a class="ae lz" href="https://www.npmjs.com/package/to-string-loader" rel="noopener ugc nofollow" target="_blank">来加载字符串</a>。</p><p id="3848" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更新我们的Webpack配置以使用to-string-loader插件:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2651" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在使用create-react-app，您将需要首先弹出。</p><p id="80c5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将应用样式，如下例所示:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7f69" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将简单地在我们的组件上注入一个<code class="fe nc nd ne mg b">&lt;style&gt;</code>标签。<br/>还将生成一个唯一的ID来限定css类名的范围。试着检查一下DOM，看看它——它很酷😁</p><p id="a6d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">确保反应事件正确发出</strong></p><p id="4be8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">影子DOM的另一个特性是事件被重定向并封装在影子中。这是影子DOM的预期行为，然而，这与React的工作方式相冲突。<br/>不幸的副作用是，从React应用程序调用的事件委托在影子中“丢失”。<br/>结果是，当在Web组件中包装React时，单击和更改事件最终没有效果。</p><p id="3e34" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们需要主动地将阴影中的事件重新定位到React可以到达的范围。</p><p id="0feb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好消息是，这个变通办法已经被做成一个小的NPM包，我们可以非常容易地实现。</p><p id="2e9e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续安装<a class="ae lz" href="https://github.com/spring-media/react-shadow-dom-retarget-events" rel="noopener ugc nofollow" target="_blank">反应-阴影-DOM-重定目标-事件</a>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d772" class="mk kx jb mg b gy ml mm l mn mo">yarn add react-shadow-dom-retarget-events</span></pre><p id="562e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们将在我们的<code class="fe nc nd ne mg b">mountReactApp()</code>方法中使用它:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f2fe" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将得到一个完整的<code class="fe nc nd ne mg b">index.jsx</code>文件，看起来像这样:</p><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4b4e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本就是这样！现在我们已经准备好疯狂使用React，并最终将这一切构建成一个Web组件！🤟</p><h1 id="113e" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用直接流</h1><p id="6261" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这整件事可能有点麻烦，尤其是如果你想在不止一个场合做这件事。</p><p id="adf6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我亲自着手为这种事情构建了一个样板文件！随着我在这个样板文件的基础上不断构建，它很快就变成了一个在React中创建和管理Web组件的小型框架。</p><p id="1549" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我来介绍一下<strong class="ka jc">导演。</strong></p><figure class="mb mc md me gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ma"><img src="../Images/4ab5cc9a81ccc94f46baf8c0d25ec3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BarMohttHm6rUB4NiiTsVg.gif"/></div></div></figure><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1911" class="mk kx jb mg b gy ml mm l mn mo">npm i -g direflow-cli</span><span id="c31f" class="mk kx jb mg b gy mp mm l mn mo">direflow create</span></pre><p id="7d8c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为你引导一个基于上述所有实践的模板，因此一堆其他的事情已经被处理了。</p><p id="e358" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模板使用<em class="nk"> react-scripts </em>来获得最佳性能，您可以选择使用TypeScript或常规JavaScript来构建您的Web组件。<br/>这也意味着包含了IE11支持所需的所有聚合填充物。</p><p id="41d5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注册属性变得非常简单——你把它们放在一个文件中，它们将被自动观察并通过props提供给底层的React应用程序👌</p><p id="0285" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，您可以非常容易地从React发出事件，当您使用Web组件时，可以为其添加侦听器🤙</p><p id="8607" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">你可以在这里阅读更多关于这个项目的信息</strong><br/><a class="ae lz" href="https://direflow.io/" rel="noopener ugc nofollow" target="_blank">https://direflow.io/</a></p><h1 id="6c15" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在网页上使用Web组件</h1><p id="4202" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在您已经完成了React应用程序，并准备好构建您的Web组件。</p><p id="2137" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">捆绑Web组件最简单的方法是简单地使用通常捆绑应用程序的相同Webpack设置。</p><p id="291a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在使用<a class="ae lz" href="https://create-react-web-component.com/" rel="noopener ugc nofollow" target="_blank">create-react-web-component</a>，您可以通过使用以下命令来触发构建</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="15d9" class="mk kx jb mg b gy ml mm l mn mo">yarn build</span></pre><p id="9cf9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果将是项目的<code class="fe nc nd ne mg b">dist</code>文件夹中的一个JavaScript文件，带有组件的名称。<br/>例如<code class="fe nc nd ne mg b">dist/TopMenu.js</code></p><p id="0422" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在你的网页中使用这个组件，你所要做的就是在你的HTML文档的<code class="fe nc nd ne mg b">&lt;head&gt;</code>标签中导入这个JavaScript文件，然后直接使用你的Web组件:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="103a" class="mk kx jb mg b gy ml mm l mn mo">&lt;script <em class="nk">src</em>="TopMenu.js"&gt;&lt;/script&gt;</span><span id="44db" class="mk kx jb mg b gy mp mm l mn mo">&lt;TopMenu&gt;&lt;/TopMenu&gt;</span></pre><p id="9308" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用Redux制作了两个通过属性和事件发射进行交互的Web组件的实例。</p><p id="e731" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自己尝试一下，或者<a class="ae lz" href="https://codesandbox.io/s/direflow-demo-67kfu" rel="noopener ugc nofollow" target="_blank">在代码沙箱上检查一下</a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fe02" class="mk kx jb mg b gy ml mm l mn mo">&lt;head&gt;<br/>  // Import bundle<br/>  &lt;script src='https://direflow.io/demo-bundle.js' /&gt;<br/>&lt;/head&gt;<br/><br/>&lt;body&gt;<br/>  // Use directly in browser<br/>  &lt;crypto-cart /&gt;<br/>  &lt;crypto-items /&gt;<br/>&lt;/body&gt;</span></pre><figure class="mb mc md me gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c0b16f6b9774150af90956ec653c44bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*LTrkAdEV5tD757AnNCuBJw.png"/></div></figure><h1 id="3105" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">发布您的Web组件</h1><p id="5eb9" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最后，如果你想发布你的Web组件，让任何人都可以使用你出色的工作，那么最好的地方可能是在webcomponents.org</p><p id="9912" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击蓝色<a class="ae lz" href="https://www.webcomponents.org/publish" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">发布元素</strong> </a> <strong class="ka jc"> </strong>按钮开始。</p><p id="9a14" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以浏览社区中其他开发人员构建并发布的大量Web组件，供您免费使用！</p><p id="6ed6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，如果你喜欢这篇文章，请鼓掌👏扣几下吧！</p><p id="ff62" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">如果您使用了</strong> <a class="ae lz" href="https://direflow.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">导演</strong> </a> <strong class="ka jc">并喜欢它，请在</strong><a class="ae lz" href="https://github.com/Silind-Software/direflow" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">GitHub</strong></a><strong class="ka jc">上给该项目打一颗星。你的支持意义重大🙏😊</strong></p><p id="edc0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">你也可以在</strong><a class="ae lz" href="https://twitter.com/silindsoftware" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">Twitter</strong></a><strong class="ka jc">上找到我，我会在那里发布更多类似的内容。</strong></p></div></div>    
</body>
</html>