<html>
<head>
<title>Introducing kubectl warp — live develop code in Kubernetes!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">kubectl warp简介Kubernetes中的实时开发代码！</h1>
<blockquote>原文：<a href="https://itnext.io/introducing-kubectl-warp-live-develop-code-in-kubernetes-9846c16d4bec?source=collection_archive---------5-----------------------#2019-01-01">https://itnext.io/introducing-kubectl-warp-live-develop-code-in-kubernetes-9846c16d4bec?source=collection_archive---------5-----------------------#2019-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a8f75b9102b3ea562bfd6dbf0718dd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*kfrXgBt6ktAPEzIDglRHJw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">kubectl在Kubernetes中运行代码的插件</figcaption></figure><p id="e4a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Warp是一个kubectl插件，它允许你在Kubernetes中直接执行你的本地代码，而不需要缓慢的映像构建过程。这是MIT授权的，可以在 <a class="ae kx" href="https://github.com/ernoaapa/kubectl-warp" rel="noopener ugc nofollow" target="_blank"> <em class="kw"> GitHub </em> </a> <em class="kw">买到。</em></p><p id="f751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，我会面临一些我非常想解决的问题。这一次，我在用Kubernetes帮助我们在<a class="ae kx" href="https://polarsquad.com" rel="noopener ugc nofollow" target="_blank">极地小组</a>的客户时遇到了问题</p><blockquote class="ky kz la"><p id="843a" class="jy jz kw ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">如何在Kubernetes上直接执行我的本地代码？<br/> -随机开发者</p></blockquote><p id="9eae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能是开发人员在本地使用Docker时已经习惯的事情，但是使用Kubernetes，所有容器都运行在集群中的某个服务器上。</p><p id="fbb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经解决过一次了，当我在和艾略特项目一起工作的时候。因此，我所需要做的就是在Kubernetes上重新实现它，这就是我如何创建了<code class="fe le lf lg lh b"><a class="ae kx" href="https://github.com/ernoaapa/kubectl-warp" rel="noopener ugc nofollow" target="_blank">kubectl warp</a></code>插件。</p><h2 id="d134" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">…听起来很容易</h2><p id="74fb" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">假设你想用 Kubernetes中的<strong class="ka ir">来开发软件</strong></p><ul class=""><li id="e1e1" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">我在本地有源代码(可能是从GitHub克隆的)…</li><li id="54e2" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">…我想将代码转移到Kubernetes的一个容器中…</li><li id="92c3" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">… <strong class="ka ir">构建</strong>并开始项目和…</li><li id="f673" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">…对源文件进行<strong class="ka ir">更改</strong>,然后…</li><li id="0a6a" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">…实时重新加载代码，然后<strong class="ka ir">看到</strong>结果！</li></ul><h2 id="7ddf" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">没那么容易…</h2><p id="5ab1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">要实现上述功能，您需要</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mu"><img src="../Images/d17b9cfda2830fb5222aeb684288d8f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hu1_Kh8_6ueOPMRl6mMIJg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">正常更新流程</figcaption></figure><ul class=""><li id="187a" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">构建源代码</li><li id="4bb6" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">创建Docker图像</li><li id="c505" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">将图像推送到Docker存储库</li><li id="ab30" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">将新版本部署到Kubernetes</li><li id="5ed0" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">等待滚动更新</li><li id="d9af" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">看结果</li></ul><p id="6694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你需要在一分钟内多次这样做，你的开发周期就太慢了，而且你会开始怀念只有一个大型monolith应用程序的日子，那些你可以在本地轻松运行的程序。但是要在本地运行现在的“微服务”，你需要复制所有的依赖项(其他服务、数据库、存储等等。)来获得一个真正的“类生产”环境。</p><h1 id="3a6b" class="nd lj iq bd lk ne nf ng ln nh ni nj lq nk nl nm lt nn no np lw nq nr ns lz nt bi translated">我为什么需要这个？</h1><p id="4e84" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><a class="ae kx" href="https://telepresence.io" rel="noopener ugc nofollow" target="_blank">网真</a>很好地解决了这个问题<strong class="ka ir">，它在本地运行你的项目</strong>并将所有来自/去往Kubernetes的流量隧道传输到你的本地进程。</p><p id="1208" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这在很多情况下都很好，但是如果您想要真正的“产品化”呢？如果要匹配内存/CPU限制怎么办？CPU架构？附加磁盘？传感器？突然间<strong class="ka ir">有能力在Kubernetes </strong>中运行项目听起来不错。</p><p id="9645" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您正在构建比简单的web应用程序稍微复杂一点的东西时，就是这种情况。尤其是当您在特殊环境中工作、针对高负载进行优化或构建物联网解决方案时。</p><h1 id="48da" class="nd lj iq bd lk ne nf ng ln nh ni nj lq nk nl nm lt nn no np lw nq nr ns lz nt bi translated">它是如何工作的？</h1><p id="1cf1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">好了，让我们停止闲聊，让我们看看它是如何工作的。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mu"><img src="../Images/d7c6fae39c94c29c69c5c7559864f638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l__NBXvvCNwk_sLPL_vOpQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">翘曲通过避免跳过缓慢的步骤来加速这个过程</figcaption></figure><p id="aa99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望它尽可能简单。例如，您可以使用共享NFS实现同样的事情(这在物联网开发中非常常见)，但是设置和拆除它是一个非常复杂的过程(猜猜有多少物联网设备仍在运行Samba服务器？).如果我们在引擎盖下有Kubernetes，一定有更简单的方法。</p><p id="545f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">kubectl warp</code> command在容器中运行你的命令，方式和<code class="fe le lf lg lh b">kubectl run</code>一样，但是在执行命令之前，它会将你所有的文件同步到容器中。</p><blockquote class="ky kz la"><p id="503d" class="jy jz kw ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe le lf lg lh b"><em class="iq">kubectl warp</em></code><strong class="ka ir">=</strong><code class="fe le lf lg lh b"><em class="iq">kubectl run</em></code><strong class="ka ir">+</strong><code class="fe le lf lg lh b"><em class="iq">rsync</em></code></p></blockquote><p id="50c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，要在Kubernetes中运行并实时重新加载<a class="ae kx" href="https://github.com/ernoaapa/kubectl-warp/tree/master/examples/nodejs" rel="noopener ugc nofollow" target="_blank"> NodeJS项目</a>，您可以</p><pre class="mv mw mx my gt nu lh nv nw aw nx bi"><span id="492f" class="li lj iq lh b gy ny nz l oa ob">$ kubectl warp -i -t --image node -- npm run watch</span><span id="32c4" class="li lj iq lh b gy oc nz l oa ob"><em class="kw"># Start editing files and it live reloads the changes!</em></span></pre><p id="6bb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">kubectl warp</code>创建<em class="kw"> Pod </em>其中，除了实际的容器，还有<code class="fe le lf lg lh b">sshd</code>容器运行(使用一次性SSH密钥)，因此我们可以用<code class="fe le lf lg lh b">rsync</code>将文件同步到<em class="kw"> Pod </em>。</p><h1 id="6c87" class="nd lj iq bd lk ne nf ng ln nh ni nj lq nk nl nm lt nn no np lw nq nr ns lz nt bi translated">挑战</h1><p id="896d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">实现它比我想象的要复杂。最初，我计划用一个简单的bash脚本来实现它😀</p><h2 id="251a" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">初始同步</h2><p id="7e28" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">首先，我需要在实际的容器启动之前同步文件一次，这样当实际的容器使用定义的命令启动时，文件就已经可用了。<br/>所以我需要<code class="fe le lf lg lh b">sshd</code>容器成为init-container，并在第一次同步完成时完成它。这很容易，感谢<code class="fe le lf lg lh b">sshd -d</code>调试标志，除了它提出了另一个问题…</p><h2 id="b6d4" class="li lj iq bd lk ll lm dn ln lo lp dp lq kj lr ls lt kn lu lv lw kr lx ly lz ma bi translated">访问初始化容器</h2><p id="1e04" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我需要一种方法来访问<code class="fe le lf lg lh b">sshd</code> init-container，但是Kubernetes只在<em class="kw">就绪</em>状态时将流量路由到<em class="kw"> Pod </em>，但是当init-container正在运行时，它处于<em class="kw"> Init </em>状态。<br/>幸运的是，我发现，可以通过Kubernetes API向init-container进行端口转发(<code class="fe le lf lg lh b">kubectl port-forward</code>只在客户端阻止这一点)。<a class="ae kx" href="https://github.com/kubernetes/kubernetes/issues/72461" rel="noopener ugc nofollow" target="_blank">创建了一个Github问题</a>，希望在未来，我们可以用普通的<code class="fe le lf lg lh b">kubectl port-forward</code>打开到init-container的端口转发。</p><p id="4ce5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，它最终甚至比开始弄乱<em class="kw">入口</em>配置更好，这实际上是特定于环境的。<br/>创建<em class="kw"> Pod </em>后，<code class="fe le lf lg lh b">warp</code>开始从本地随机端口向<code class="fe le lf lg lh b">sshd</code>集装箱港口22转发端口，并在本地执行<code class="fe le lf lg lh b">rsync</code>命令。然后，当第一次同步完成时，init-container成功完成，实际的容器启动。厉害！🎉</p><h1 id="9d7e" class="nd lj iq bd lk ne nf ng ln nh ni nj lq nk nl nm lt nn no np lw nq nr ns lz nt bi translated">入门指南</h1><p id="d9e6" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">使用MacOS和Brew(其他请参见<a class="ae kx" href="https://github.com/ernoaapa/kubectl-warp#linux--macos-without-brew" rel="noopener ugc nofollow" target="_blank">文档</a>)，您可以安装它</p><pre class="mv mw mx my gt nu lh nv nw aw nx bi"><span id="dae4" class="li lj iq lh b gy ny nz l oa ob">brew install rsync ernoaapa/kubectl-plugins/warp</span></pre><p id="7ef8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<a class="ae kx" href="https://github.com/ernoaapa/kubectl-warp/tree/master/examples/nodejs" rel="noopener ugc nofollow" target="_blank">这里</a>获取示例NodeJS项目</p><pre class="mv mw mx my gt nu lh nv nw aw nx bi"><span id="f414" class="li lj iq lh b gy ny nz l oa ob">kubectl warp -i -t --image node demo -- npm install &amp;&amp; npm run watch</span></pre><h1 id="904e" class="nd lj iq bd lk ne nf ng ln nh ni nj lq nk nl nm lt nn no np lw nq nr ns lz nt bi translated">结论</h1><p id="a228" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">期待得到一些关于<code class="fe le lf lg lh b">kubectl warp</code>的反馈。这是早期的工作版本，并没有实现<code class="fe le lf lg lh b">kubectl run</code>的所有功能，例如，需要实现一个<a class="ae kx" href="https://github.com/ernoaapa/kubectl-warp/issues/1" rel="noopener ugc nofollow" target="_blank">功能来使用<em class="kw">持久卷</em>来更快地启动</a>，以使它变得更好。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c91da59d6d718c4737df33f984d4f11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*GkH34V7Xsz9kXaJAsATWEA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">kubiot.io —面向物联网的Kubernetes</figcaption></figure><p id="cf22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这只是<a class="ae kx" href="https://www.kubiot.io/" rel="noopener ugc nofollow" target="_blank">Kubiot——物联网的Kubernetes</a>的一个开源部分。<br/> <strong class="ka ir">在</strong><a class="ae kx" href="https://www.kubiot.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">kubiot . io</strong></a><strong class="ka ir">报名提前获取！</strong></p></div></div>    
</body>
</html>