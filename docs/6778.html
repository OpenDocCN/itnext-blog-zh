<html>
<head>
<title>Easier Service Worker caching with Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更轻松的服务人员缓存和路由</h1>
<blockquote>原文：<a href="https://itnext.io/easier-service-worker-caching-with-routing-323d347d95d3?source=collection_archive---------7-----------------------#2022-02-22">https://itnext.io/easier-service-worker-caching-with-routing-323d347d95d3?source=collection_archive---------7-----------------------#2022-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/431353e86c3a345234a3665b476d189c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOuhqmCo4X-RE4a-7MyJEA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">https://pxhere.com/en/photo/187030?utm_content=shareClip&amp;UTM _ medium = referral&amp;UTM _ source = px here</figcaption></figure><p id="1f1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务人员是浏览器工具箱中一个非常强大的工具，但是您可能很难理解它，尤其是以可维护的方式建模和组织不同的流程。使用基于路由的模式(类似于Node Express框架中的模式)可以帮助您做到这一点。这就是我在这里做的实验。类似的事情以前也做过。例如，像Workbox这样的库将路由作为API的一部分来实现。但是这里我将探索一个<em class="lb">路由优先选择</em>来创建一个更加灵活和轻量级的选项。</p><p id="dffb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我使用了<em class="lb"> itty路由器</em>(<a class="ae kc" href="https://github.com/kwhitley/itty-router" rel="noopener ugc nofollow" target="_blank">https://github.com/kwhitley/itty-router</a>)。itty router 是一个非常小、轻量级、但仍然强大的路由库，我是在与Cloudflare Workers一起试验时偶然发现的。Cloudflare Workers是一个基于Service Worker API的FaaS平台，因此<em class="lb"> itty router </em>可以在浏览器中使用，无需任何额外的工作。</p><h1 id="e0c7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">itty路由器简介</h1><p id="8aa6" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">使用<em class="lb"> itty路由器</em>，单条路由可以这样定义:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="937e" class="mo ld iq mk b gy mp mq l mr ms">router.get('/hello', request =&gt; {<br/>  return new Response('Hello World!')<br/>})</span></pre><p id="8f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">itty router 有两个特别的方面使它在服务人员中非常有用。第一，它使用中间件模式，因此您可以链接处理程序。如果第一个没有返回响应，请求将被转移到下一个:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="82f1" class="mo ld iq mk b gy mp mq l mr ms">router.get('/hello', handler1, handler2)</span></pre><p id="2684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一件重要的事情是，虽然请求是处理程序唯一期望的参数，但是可以用将沿着链传递的附加参数注册主路由器处理程序:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0a7c" class="mo ld iq mk b gy mp mq l mr ms">router.get('/hello', (request, user) =&gt; {<br/>  return new Response(`Hello ${ user.name }!`)<br/>})</span><span id="2fb7" class="mo ld iq mk b gy mt mq l mr ms">addEventListener('fetch', event =&gt;<br/>  event.respondWith(router.handle(event.request, user))<br/>)</span></pre><h1 id="2709" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基本设置</h1><p id="1719" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">因此，记住这一点，我们可以看到它如何帮助我们实现与服务工作者相关的不同模式/策略，如CacheFirst或NetworkFirst。但首先是基本的设置。可以像这样从HTML加载和注册服务工作者:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ad58" class="mo ld iq mk b gy mp mq l mr ms">&lt;script type="module"&gt;<br/>    const reg = await navigator.serviceWorker.register('/sw.js', {<br/>        type: 'module',<br/>    });<br/>&lt;/script&gt;</span></pre><p id="2fdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个PoC中，我使用ES模块，这必须反映在脚本标记和服务人员的注册中。服务人员的根源非常简单:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="72ff" class="mo ld iq mk b gy mp mq l mr ms">import { cacheName, coreAssets } from './config.js';<br/>import router from './router';</span><span id="3f4f" class="mo ld iq mk b gy mt mq l mr ms">self.addEventListener('install', function (event) {<br/>    // Cache core assets<br/>    event.waitUntil(caches.open(cacheName).then(function (cache) {<br/>        for (let asset of coreAssets) {<br/>            let req = new Request(asset)<br/>            cache.add(req);<br/>        }<br/>        return cache;<br/>    }));<br/>});</span><span id="a2ed" class="mo ld iq mk b gy mt mq l mr ms">self.addEventListener('fetch', async event =&gt; {<br/>    event.respondWith(router.handle(event.request, {onLine: navigator.onLine}, event))<br/>})</span></pre><p id="00df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预缓存的一些配置，以及在上下文对象上设置的在线状态。主要工作由导入的路由器完成，可能如下所示:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fee3" class="mo ld iq mk b gy mp mq l mr ms">import { Router } from 'itty-router';<br/>import { handler1, handler2 } from './handlers.js';</span><span id="f005" class="mo ld iq mk b gy mt mq l mr ms">const router = Router()</span><span id="4450" class="mo ld iq mk b gy mt mq l mr ms">//Add routes<br/>router.get('/assets', handler1 )<br/>router.get('*', handler2)<br/>...</span><span id="e2e9" class="mo ld iq mk b gy mt mq l mr ms">export default router;</span></pre><h1 id="adc5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">基本软件策略</h1><p id="a7cf" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">那么，CacheFirst和NetworkFirst。让我们首先定义一个从缓存中检索响应的处理程序:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ffe2" class="mo ld iq mk b gy mp mq l mr ms">const ifCacheRespond = async (request, context, event) =&gt; {<br/>    const response = await caches.match(request);<br/>    if (response) {<br/>        return response<br/>    }<br/>}</span></pre><p id="bf77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似于网络响应的处理程序。它在启动提取之前检查在线状态:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="098c" class="mo ld iq mk b gy mp mq l mr ms">const ifNetworkRespond = async (request, context, event) =&gt; {<br/>    if(context.onLine){<br/>        let response = await fetch(request);<br/>        if (response &amp;&amp; response.ok) {<br/>            return response;<br/>        }<br/>    }<br/>}</span></pre><p id="a0b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，CacheFirst策略可以表达如下:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a6b1" class="mo ld iq mk b gy mp mq l mr ms">router.get('/assets/*', ifCacheRespond, ifNetworkRespond, handleError)</span></pre><p id="1735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe mu mv mw mk b">ifCacheRespond</code>在缓存中找到一个响应，它将返回这个响应。如果没有，它将请求传递给<code class="fe mu mv mw mk b">ifNetworkRespond</code>。<code class="fe mu mv mw mk b">handleError</code>有没有以这样或那样的方式收拾彻底的失败。或者，您可以在末尾使用默认路由来处理这些情况，因为如果有问题的路由没有返回任何响应，路由器会将请求传递到下一个路由。</p><p id="0f80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们如何表达网络优先战略呢？是的，当然，我们可以交换顺序😁：</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="bbbb" class="mo ld iq mk b gy mp mq l mr ms">router.get('/assets/*', ifNetworkRespond, ifCacheRespond, handleError)</span></pre><p id="5dfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于稍微复杂一点的策略，我们需要增加流程。但是它们仍然可以用类似的方式来表达。例如，对于CacheAsYouGo，您需要在返回响应之前将其添加到缓存中。启用此策略的路线可以定义如下:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7a31" class="mo ld iq mk b gy mp mq l mr ms">router.get('/articles/*', ifCacheRespond, getNetworkResponse, addToCache, ifNetworkRespond, handleError)</span></pre><p id="0eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个和以前一样。如果您在缓存中有响应，就提供它。如果没有，流程将转到下一个处理程序:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f0b8" class="mo ld iq mk b gy mp mq l mr ms">const getNetwork = async (request, context, event) =&gt; {<br/>    if (context.onLine) {<br/>        const response = context.networkResponse || await fetch(request);<br/>        if (response &amp;&amp; response.ok) {<br/>            console.log("response.ok", response)<br/>            context.networkResponse = response;<br/>        }<br/>    }<br/>}</span></pre><p id="6ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个处理程序不返回网络响应，而是将它添加到上下文中，供链中更下游的处理程序使用，如<code class="fe mu mv mw mk b">addToCache</code>:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2b88" class="mo ld iq mk b gy mp mq l mr ms">const addToCache = async (request, context, event) =&gt; {<br/>    const response = context.networkResponse;<br/>    if (response &amp;&amp; response.ok) {<br/>        let responseClone = response.clone();<br/>        caches.open(cacheName).then(async (cache) =&gt; {<br/>            cache.put(request, responseClone);<br/>        });<br/>    }<br/>}</span></pre><p id="cd7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要更改<code class="fe mu mv mw mk b">ifNetworkRespond</code>来使用上下文对象上的响应(如果可用的话):</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="db2a" class="mo ld iq mk b gy mp mq l mr ms">const ifNetworkRespond = async (request, context, event) =&gt; {<br/>    if (context.onLine) {<br/>        const response = context.networkResponse || await fetch(request);<br/>        if (response) {<br/>            context.networkResponse = response;<br/>        }<br/>        if (response &amp;&amp; response.ok) {<br/>            return response;<br/>        }<br/>    }<br/>}</span></pre><p id="55fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要启用StaleWhileRevalidate这样的策略，我们需要稍微扩展一下。使用StaleWhileRevalidate时，您希望使用缓存，但在后台更新缓存而不等待它，以便下一次命中将使用更新的资源:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="506e" class="mo ld iq mk b gy mp mq l mr ms">router.get('/', revalidateCache, ifCache, <!-- -->ifNetworkRespond<!-- -->, handleError)</span></pre><p id="2d75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，您希望开始重新验证，但如果有缓存，就不要等待。所以<code class="fe mu mv mw mk b">revalidateCache</code>为它创造了一个承诺，然后继续前进:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="16b2" class="mo ld iq mk b gy mp mq l mr ms">const revalidateCache = async (request, context, event) =&gt; {<br/>    if (context.onLine) {<br/>        const cache = await caches.open(cacheName);<br/>        const networkResponsePromise = fetch(request);<br/>        context.networkResponsePromise = networkResponsePromise;<br/>        event.waitUntil(async function () {<br/>            const networkResponse = await networkResponsePromise;<br/>            await cache.put(request, networkResponse.clone());<br/>        }());<br/>    }<br/>}</span></pre><p id="cb93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe mu mv mw mk b">ifNetworkRespond</code>也需要处理承诺，所以它不会在没有缓存响应可用的情况下开始新的获取，而是使用重新验证缓存的相同获取:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9d1d" class="mo ld iq mk b gy mp mq l mr ms">const ifNetworkRespond = async (request, context, event) =&gt; {<br/>    if (context.onLine) {<br/>        let response;<br/>        if (context.networkResponsePromise) {<br/>            response = await context.networkResponsePromise<br/>        } else {<br/>            response = context.networkResponse || await fetch(request);<br/>        }<br/>        if (response) {<br/>            context.networkResponse = response;<br/>        }<br/>        if (response &amp;&amp; response.ok) {<br/>            return response;<br/>        }<br/>    }<br/>}</span></pre><h1 id="0e6f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">标题过滤</h1><p id="7f86" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">服务工作者使用缓存的另一种典型方式是不使用路由，而是使用头字段。比如用<code class="fe mu mv mw mk b">Content-Type: text/html</code>缓存一切。这在这里也是可能的。您可以在具有可缓存内容类型的初始上下文对象中添加一个数组，并在缓存之前检查该数组:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3089" class="mo ld iq mk b gy mp mq l mr ms">self.addEventListener('fetch', async event =&gt; {<br/>    event.respondWith(router.handle(event.request, {onLine: navigator.onLine, cachableContent: ['text/html']}, event))<br/>})</span></pre><p id="9361" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以使用一个“全部捕获”路径来缓存所有HTML:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1afa" class="mo ld iq mk b gy mp mq l mr ms">router.get('/*', ifCacheRespond, getNetworkResponse, addToCache, ifNetworkRespond, handleError)</span></pre><p id="74ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于更细粒度的处理，结合头和路由，过滤器可以改为在流中首先设置一个句柄:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ac92" class="mo ld iq mk b gy mp mq l mr ms">const cacheHTMLOnly = async (request, context, event) =&gt; {<br/>    context.cachableContent = ['text/html'];<br/>}</span><span id="77d8" class="mo ld iq mk b gy mt mq l mr ms">router.get('/assets/*', cacheHTMLOnly, ifCacheRespond, getNetworkResponse, addToCache, ifNetworkRespond, handleError)</span></pre><h1 id="ac95" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">更高级</h1><p id="9ecf" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这是非常粗略的，一个完整的实现当然需要添加更多的东西，比如处理缓存到期头等。尤其是您需要管理缓存版本控制和删除，这样您就不会在需要更改时陷入糟糕的状态，也不会突然无法更新客户端上的资源。</p><p id="5fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，像Workbox这样的库支持更高级的bookeeping功能，比如限制将被缓存的请求的数量，保存由于网络故障而失败的post-requests，添加自己的过期处理等等。为此，您需要像IndexedDB这样的东西作为流程的一部分。我不会在这里详细介绍，但我会用下面的场景来描述一下，如果网络中断，您希望能够离线存储新文章:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="d304" class="mo ld iq mk b gy mp mq l mr ms">router.post('/article/*', ifNetworkRespond, saveRequestForLater, handleError)</span></pre><p id="75b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe mu mv mw mk b">ifNetworkRespond</code>没有返回，<code class="fe mu mv mw mk b">saveRequestForLater</code>将获取请求并保存到IndexedDB中。这是一个非常简化的版本。您可能需要保存更多的请求，比如头、参数等。这很大程度上取决于相关的应用和功能:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a6e7" class="mo ld iq mk b gy mp mq l mr ms">const <!-- -->saveRequestForLater<!-- --> = async (request, context, event) =&gt; {<br/>    if(!context.onLine){<br/>        event.waitUntil(async function () {<br/>            const payload = await request.clone().json();<br/>            const dbrequest = indexedDB.open("articles");<br/>            dbrequest.onsuccess = async (event) =&gt; {<br/>                const db = event.target.result;<br/>                const tx = db.transaction('createarticle', 'readwrite');<br/>                const store = tx.objectStore('createarticle');<br/>                store.add(payload)<br/>            } <br/>        }());       <br/>    }<br/>}</span></pre><p id="c6a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这里最重要的是，当应用程序再次上线时，要有某种机制来采取行动，然后重放请求。但这也可能是基于应用程序的要求和特定的功能。</p><h1 id="641e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">缓存过期和边车请求</h1><p id="df90" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">缓存处理可能需要考虑响应的缓存头，但是如果您不想在服务工作器本身中添加单独的过期处理，该怎么办呢？挑战在于，在将响应放入缓存之前，您不能通过设置自定义头来修改响应，因为它是只读的。一种替代方法是使用IndexedDB获取额外的元数据，另一种方法是创建一个<em class="lb"> sidecar请求</em>来缓存额外的元数据:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8451" class="mo ld iq mk b gy mp mq l mr ms">const addToCache = async (request, context) =&gt; {<br/>    const response = context.networkResponse;<br/>    if (response &amp;&amp; response.ok) {<br/>        let responseClone = response.clone();<br/>        caches.open(cacheName).then(async (cache) =&gt; {<br/>            cache.put(request, responseClone);<br/>            const sidecarReq = new Request(request.url + '-sidecar', {<br/>                method: "GET",<br/>            });<br/>            const sidecarResp = new Response(null, {<br/>                status: 200,<br/>                headers: {<br/>                    'x-sw-expires': Date.now() + context.cacheMaxAgeMS,<br/>                },<br/>            });<br/>            cache.put(sidecarReq, sidecarResp);<br/>        });<br/>    }<br/>}</span></pre><p id="876d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在检查缓存时检查边车中的标题。</p><p id="84bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="lb"> NB！但是要确保这样的sidecar-routes不会被其他处理程序无意中缓存，或者用于存储认证或其他敏感的东西，因为它显然会被篡改。</em></strong></p><h1 id="73a8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="f501" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">所以使用像<em class="lb"> itty router </em>这样的路由器在编写服务人员时肯定会有所帮助。与使用像Workbox这样的库相比，它让您更接近平台工作，并且非常灵活和可定制。但是它仍然让您以一种接近更高级工具的可读性的方式组织流程。并且仍然是非常轻量级的，与它可以帮助您节省的下载字节相比，它只增加了很少的开销。</p></div></div>    
</body>
</html>