<html>
<head>
<title>The observer pattern in NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS中的观察者模式</h1>
<blockquote>原文：<a href="https://itnext.io/the-observer-pattern-in-nodejs-c0cfffb4744a?source=collection_archive---------0-----------------------#2019-11-30">https://itnext.io/the-observer-pattern-in-nodejs-c0cfffb4744a?source=collection_archive---------0-----------------------#2019-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b00e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是Node的支柱之一，对于使用许多核心模块至关重要，因此由于其重要性而将其隔离。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f8480a44a005cc078911ac246c6bf605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2150vmydZ230xV2x.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">观察者模式</figcaption></figure><p id="148f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">观察者是一种行为模式，这意味着关注对象之间的<strong class="js iu">交流</strong>。</p><p id="7d50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是建模节点反应性质的理想解决方案，也是回调的补充。</p><p id="3907" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，它负责一个<strong class="js iu">主体</strong>(或可观察的)和多个<strong class="js iu">观察者</strong>之间的通信。</p><p id="9472" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主题目标是通知观察者状态的变化。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi le"><img src="../Images/b4c26b31bb6c818b9ce8538a279698f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/0*xZtT5YojRzFsLeE8.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">事件流</figcaption></figure><p id="dd26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">观察者可以<strong class="js iu">订阅</strong>主题，以便跟踪主题可能发生的任何潜在状态变化。观察者也可以<strong class="js iu">取消订阅</strong>，停下来<em class="lf">观察</em>主题。</p><p id="dca3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在面向对象编程中，观察者模式需要<strong class="js iu">接口、</strong>具体的<strong class="js iu">类</strong>和<strong class="js iu">层次结构</strong>。您可能注意到JavaScript没有接口，或者类实际上是函数。这可以被视为一种阻碍，但这与事实相去甚远。</p><p id="8e5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在NodeJS中，一切都变得简单多了。观察者模式已经内置到内核中，可以通过<a class="ae lg" href="https://nodejs.org/api/events.html#events_class_eventemitter" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> EventEmitter </strong> </a>类获得。</p><p id="fe0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">EventEmitter允许将函数注册为<strong class="js iu">监听器</strong>，当特定的<strong class="js iu">事件</strong>被触发时，将调用这些监听器。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/96cedcfde4feea068b1e8ed45c7acf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*9sNEu5C1LWsxixBE.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">事件发射器</figcaption></figure><p id="1ebb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">EventEmitter类由<em class="lf">事件</em>模块定义和公开。一些方法是:</p><ul class=""><li id="b351" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn ln lo lp lq bi translated"><code class="fe lr ls lt lu b">on(eventName:string, listener: Function)</code>:将<em class="lf">监听器</em>函数添加到名为<em class="lf"> eventName </em>的事件的监听器数组的末尾。不检查是否已经添加了侦听器。多个调用通过<em class="lf">事件名称</em>和<em class="lf">监听器</em>的相同组合将导致监听器被添加和调用多次。</li><li id="5f64" class="li lj it js b jt lv jx lw kb lx kf ly kj lz kn ln lo lp lq bi translated"><code class="fe lr ls lt lu b">once(eventName:string, listener: Function)</code>:为名为<em class="lf"> eventName </em>的事件增加一个一次性<em class="lf">监听器</em>功能。下次触发eventName时，将删除该侦听器，然后调用它。</li><li id="5155" class="li lj it js b jt lv jx lw kb lx kf ly kj lz kn ln lo lp lq bi translated"><code class="fe lr ls lt lu b">emit(eventName:string, [...args])</code>:按照注册的顺序，同步调用为名为<em class="lf"> eventName </em>的事件注册的每个监听器，并将提供的<em class="lf">参数</em>传递给每个监听器。</li><li id="4cc6" class="li lj it js b jt lv jx lw kb lx kf ly kj lz kn ln lo lp lq bi translated"><code class="fe lr ls lt lu b">removeListener(eventName:string, listener: Function)</code>:从名为<em class="lf"> eventName </em>的事件的<em class="lf">监听器</em>数组中删除指定的监听器。</li></ul><p id="7697" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前面所有的方法都将返回EventEmitter <strong class="js iu">实例</strong>以允许<strong class="js iu">链接</strong>。<em class="lf">监听器</em>函数具有签名<code class="fe lr ls lt lu b">function([arg1], [...])</code>，因此它只接受事件发出时提供的参数。在<em class="lf">监听器</em>中，<code class="fe lr ls lt lu b"> this</code>是指产生事件的<strong class="js iu">事件发射器</strong>的<strong class="js iu">实例</strong>。</p><p id="ecc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">直接从EventEmitter类创建一个observable是不够的，因为当我们想要创建一个不仅仅是创建新事件的东西时，这是不灵活的。因此，创建一个通用对象<strong class="js iu"> observable </strong>是大多数情况下的解决方案。这可以通过扩展EventEmitter类来实现。</p><p id="dd52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解释这是如何工作的，我举了一个例子。这个可观察的物体将会是一个比萨饼🍕。完整的<a class="ae lg" href="https://gist.github.com/boxgames1/95ea88f202f36f55c70af70f0f2f2b13" rel="noopener ugc nofollow" target="_blank">代码文件在这里</a>。让我们按部分来看代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/d67a63b916dba310f59a47d479950c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*0E7o33gK2AEn6ANRAW8y3Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">构造函数和类型定义</figcaption></figure><p id="8c0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没有什么特别的，除了Pizza类是从EventEmitter扩展而来的(如果你记得上面的评论，它来自于<em class="lf"> events </em>模块)。我跳过了与这个模式无关的私有方法和静态大小。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/8cf89dfeca1f4a6824646dc6b335893f.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*eNBpM4XizdTijCPMmQ9UAA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">添加方法</figcaption></figure><p id="d691" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果比萨饼没有达到配料的最大数量，那么作为参数传递的配料将被添加到列表中，并发出一个事件。否则，也会发出一个事件。返回实例以允许链接。这发生在所有公共方法中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/7eae177fd6cd1039c31ff94776921bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*zRekJITrx_jsc5_x_Yfdpg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">移除方法</figcaption></figure><p id="3fd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常类似于add方法。如果成分存在于列表中，它将被删除并发出一个事件。如果它不存在，则发出其他事件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/82f2347fccf25009d052c81a44f0093d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*uVszigzwUMmWc_7mcH9zkg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">烹饪方法</figcaption></figure><p id="91ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧！最有趣的部分来了，我们的比萨饼正在进入烤箱😋<br/>一个事件注意到了这种情况，并设置了超时。一旦烤箱时间到期，回调被执行并发出另一个超时的事件<em class="lf"> numberId </em>。那个会在发布时间过后触发。如果超时没有被清除，我们的比萨饼将被烧焦，事件也被发出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2d442968f6720483ab24a280c0dcd344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*PagdDYtE8GA4jPL_T7yZFA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">快乐之路</figcaption></figure><p id="7613" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行时间！现在我们的Pizza类已经创建，我们可以实例化它了。这一大块看起来有点乱，但是我鼓励你获取完整的代码示例并在你的本地环境中运行来看看结果。</p><p id="dff2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建了一些<strong class="js iu">听众</strong>来了解<strong class="js iu">发生在我们披萨上的一切</strong>。然后，我们添加/删除一些成分，并开始烹饪阶段。</p><p id="8000" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有趣的部分是在<code class="fe lr ls lt lu b"> cookFinished</code>监听器中。除了日志之外，我们正在使用作为参数接收的<em class="lf"> numberId </em>清除超时。我们马上就做，避免我们的披萨被烧焦。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/d37114933030e157f8e4f6e3152332d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*_Pi66dC7ytbd8-XCbmrGQA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">角落案例</figcaption></figure><p id="e0ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们在没有清除超时的情况下管理<code class="fe lr ls lt lu b"> cookFinished</code>监听器，所以比萨饼不会按时从烤箱中拿出来😟</p><p id="3043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经看到，通过继承EventEmitter的功能，Pizza对象除了是可观察的之外，还拥有一整套方法。</p><p id="8e2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Alert </strong> ⚠️我们绝不能在同一个EventEmitter中混合使用同步和异步方法，这一点至关重要，但更重要的是，当发出相同的事件类型时，要避免产生同步问题，使我们的函数<strong class="js iu">变得不可预测。</strong></p><p id="eb62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发出同步和异步事件的主要区别在于侦听器的注册方式。当事件被异步发出<strong class="js iu"/>时，即使在EventEmitter被初始化之后，程序也有足够的时间来注册新的监听器，因为事件被保证在事件循环的下一个周期之前不会被触发。它代表了大多数Node.js模块中使用的一种常见方法。</p><p id="0fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，同步发出事件<strong class="js iu"/>需要在EventEmitter函数开始发出任何事件之前注册所有侦听器，就像在我们的<strong class="js iu"> Pizza </strong>类中一样。以这种同步方式使用EventEmitter很有用，在某些场景中很有意义。</p><p id="cacc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于这个原因，在文档中清楚地突出我们的EventEmitter的行为以避免混淆和潜在的错误使用是非常重要的。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="9f6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是奥利弗·阿隆索，在西班牙远程工作的软件工程师。你可以在<a class="ae lg" href="https://oliveralonso.dev/" rel="noopener ugc nofollow" target="_blank">我的网络</a>或<a class="ae lg" href="https://github.com/boxgames1" rel="noopener ugc nofollow" target="_blank"> Github账户中找到更多关于我的信息。</a></p><p id="abb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！</p></div></div>    
</body>
</html>