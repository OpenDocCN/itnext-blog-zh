<html>
<head>
<title>Fetch Shared Data in Next.js With Single Request</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用单个请求获取Next.js中的共享数据</h1>
<blockquote>原文：<a href="https://itnext.io/fetch-shared-data-in-next-js-with-single-request-833433fa8ed1?source=collection_archive---------1-----------------------#2021-03-05">https://itnext.io/fetch-shared-data-in-next-js-with-single-request-833433fa8ed1?source=collection_archive---------1-----------------------#2021-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0fb4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看一看在Next.js前面有NodeJS层的缓存策略</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/96aef764a35a409c68a4777516a78322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiKzv9CkoZJBQhrrnUVIaQ@2x.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@gordonplant" rel="noopener ugc nofollow" target="_blank">戈登工厂</a>在<a class="ae kv" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="c16d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在回顾我当前项目的构建过程时，我注意到用<code class="fe ls lt lu lv b">getStaticProps</code>生成页面会对一个端点产生许多请求。对我来说，这不是一个大问题，因为我们的后端相当快，但谷歌搜索这个问题表明，一些人正在努力解决这个问题。例如，如果数据库很慢，或者后端无法处理每秒100个请求，问题可能会很严重。所以我决定尝试解决这个问题，并改善我的项目的构建时间。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="893a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">为什么这么多要求？</h1><p id="b19b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在深入Next.js的构建过程之前，让我们看看另一个静态站点生成器Gatsby是如何做类似的事情的。只有当Next.js作为一个SSR框架启动时，Gatsby才有一个非常不同于SSG的机制。</p><p id="ba7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Gatsby有几个构建过程步骤，但主要的两个是:提取数据并用数据填充组件，然后呈现。Gatsby插件通常使用GraphQL数据层来存储来自数据源的数据(当然你可以不用GraphQL数据层而使用非结构化数据来构建)。Gatsby运行数据插件，然后它们获取数据并将其放在数据层。然后，它从页面获取GraphQL查询，并为模板准备数据。之后，用数据填充组件。这种构建页面的方式看起来简单明了。但是Next.js的工作方式正好相反。</p><p id="2015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我之前说过的，Next.js最初是一个只有SSR的框架，后来添加了SSG特性。它有API，在那里你可以得到数据，并把它传递给每一页，但这种方法打破了SSG优化。我说的是<code class="fe ls lt lu lv b">getInitialData</code>用在<code class="fe ls lt lu lv b">_app.js</code>内部的时候</p><p id="9e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了拥有SSG页面，我们只使用<code class="fe ls lt lu lv b">getStaticProps</code>或者只制作没有数据获取的页面。当Next.js构建页面时，如果它在页面文件中，它将运行数据获取函数，然后使用这些数据呈现页面。并且该过程一页接一页地重复。因此，如果数据是共享的，它将会在每个页面上被请求。如果应用程序中的页面数量在增加，那么请求的数量也在增加。</p><p id="91be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的应用程序要求在每一页上显示城市列表，这些城市应该在服务器上定义。我知道Gatsby是如何工作的，并且想添加一个类似的机制，但是更简单，并且没有GraphQL🙂</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d59a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">我的第一次尝试</h1><p id="aa74" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">第一个想法非常简单。例如，当第一个页面调用<code class="fe ls lt lu lv b">fetchCities</code>时，我将<code class="fe ls lt lu lv b">fetch</code>返回的承诺保存到模块范围的变量中。当下一页调用<code class="fe ls lt lu lv b">fetchCities</code>时，我检查我们的变量是否指向承诺，如果是，就返回它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例显示了如何在模块范围内保存请求。</figcaption></figure><p id="5486" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">概念很简单。我们只是在模块范围内保存请求承诺，然后将其返回给所有后续调用。问题是——这种方法行不通。原因是工人。Next.js在自己的worker中运行每个页面构建。这意味着我无法在页面之间共享数据，并且我无法访问一个无需付出巨大努力就可以在员工之间共享数据的地方。此外，我检查我们的请求在CI中是否有效，因为在重新验证时可能会调用<code class="fe ls lt lu lv b">fetchCities</code>，在这种情况下，我希望每次都能获得新的数据。</p><h1 id="f283" class="md me iq bd mf mg nc mi mj mk nd mm mn jw ne jx mp jz nf ka mr kc ng kd mt mu bi translated">或许谷歌能帮上忙？</h1><p id="004c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我有更多的想法，但我决定谷歌一下。也许我不是第一个面临这个问题的人。我发现其他人也在思考同样的问题，他们有不同的理由去做这件事。有人刚刚开始使用Next.js，它的后端无法满足大量的请求。其他人试图从Gatsby过渡到Next，并意识到他们的后端对于300 RPS来说不是太快。我知道盖茨比是怎么工作的，因为我在前一份工作中遇到过。盖茨比的做法不同。首先，通过将数据收集到本地缓存来准备构建，在这种情况下，所有资源只提取一次。以便每个页面都能从这个缓存中获取数据。我的想法类似，但我不需要在Next.js上添加缓存。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b086" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">在文件中缓存数据</h1><p id="a77e" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">解决这个问题的一个潜在方法是在文件中进行缓存。我们需要在构建过程中增加一个步骤，并编写类似这样的代码。</p><p id="72fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们运行获取数据并将其保存到文件中的脚本。这种方法的缺点是，我们需要收集其中的所有端点来获取数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦收集了数据，我们就可以运行服务器，它将为构建我们的应用程序提供缓存数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些选择都很好，但也有自己的缺点。例如，我们应该收集所有用于缓存的端点并更新它们。或者您应该等到所有资源都被缓存。另一方面，所有资源都缓存在磁盘上，不会留在内存中。我想分享这段代码只是为了向你展示所有的选项。</p><h1 id="5eb1" class="md me iq bd mf mg nc mi mj mk nd mm mn jw ne jx mp jz nf ka mr kc ng kd mt mu bi translated">构建时将其缓存在内存中</h1><p id="37c9" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">是的，这是最容易和最快的方法来缓存您的数据，而不是等待任何东西。只需在建造阶段通过不同的<code class="fe ls lt lu lv b">API_PATH</code>，并在运行<code class="fe ls lt lu lv b">next build</code>之前运行缓存服务器。</p><p id="c186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们服务器的代码可能如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d2fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个想法和第一个是一样的——我们只是在不同的层次上存储数据。所有请求都将调用我们的缓存代理。当请求被接收时，它被存储在一个映射中，并且对同一资源的所有后续请求将得到相同的响应。它应该非常快，但如果你请求大量数据，你应该小心内存。否则，您可以通过及时缓存数据并将其存储在磁盘而不是内存中，来混合使用这两种方法。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="3e06" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="9273" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">实际上，Next.js团队计划在<code class="fe ls lt lu lv b">_app.js</code>中增加使用<code class="fe ls lt lu lv b">getStaticProps</code>的能力。在那之后，整个问题可以不需要任何额外的努力就能解决。我一直在关注这个<a class="ae kv" href="https://github.com/vercel/next.js/discussions/10949#discussioncomment-44898" rel="noopener ugc nofollow" target="_blank">讨论</a>，但它仍然被搁置。</p><p id="bba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许您的数据源也有类似的问题，如果这篇文章对您有所帮助，我会很高兴。目标不仅仅是解决问题，而是尝试使用不同的方法。我希望我展示了一些新的东西，也许它会启发你解决一些问题，做一些“头脑”练习。当您需要缓存数据时，这些示例可能有助于解决其他问题。您可以使用它们，并根据需要进行修改。<br/> <a class="ae kv" href="https://github.com/akellbl4/cache-proxy" rel="noopener ugc nofollow" target="_blank">完整示例</a>存储在GitHub上。</p></div></div>    
</body>
</html>