<html>
<head>
<title>My personal definitive guide to (java)Exceptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我个人的(java)异常权威指南</h1>
<blockquote>原文：<a href="https://itnext.io/my-personal-definitive-guide-to-java-exceptions-d2e4131393c7?source=collection_archive---------3-----------------------#2021-02-28">https://itnext.io/my-personal-definitive-guide-to-java-exceptions-d2e4131393c7?source=collection_archive---------3-----------------------#2021-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前提:</p><ul class=""><li id="3a62" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">我主要是比较C和Java这两种主要的语言有无例外。你可以交换你最喜欢的两种语言，我个人并不是在挑C语言或什么的。</li><li id="52b2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">本文中的c或Java代码片段不一定能正确编译，可以认为它更像是伪代码。</li><li id="3bd7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">我知道异常早于Java。我只是说我最精通的语言。</li><li id="fc86" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">请原谅我的英语错误，这不是我的母语。</li><li id="3cb6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">这里的一切都是我的看法，当我说“事情应该是这样的”是“我认为事情应该是这样的”的捷径。</li></ul><p id="c55b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">异常是Java中最难理解的概念之一。即使是有经验的专业人士也很难使用它们，而且很少有人正确使用它们，主要是因为有大量关于如何“正确”使用它们的错误信息，这使得它们的使用方式没有预期的那么有效。我感觉很多程序员对异常的憎恨源于他们使用Java的第一天。在最初的日子里，我们都被“未检查的异常”编译器错误所重创，你不可能写出最简单的方法而不被它所阻碍。随着时间的推移，你学会了如何应对，但对例外的不愉快感觉依然存在。这是一件坏事，因为异常真的很好。</p><p id="2639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我要说的是，你可以通过观察java程序员如何使用异常来判断他们有多优秀。</p><p id="8fa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么会出现异常</strong></p><p id="e58c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Java或C++出现之前，C. C不提供任何类型的错误处理支持，你只能使用基于常规编码工具的定制解决方案来处理你的错误，比如，大多数情况下，函数返回值(或者有时指针参数等)。事情看起来是这样的:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="4425" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有标准的tho:</p><ul class=""><li id="3717" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">有些库会在成功时返回0，在失败时返回一些错误代码</li><li id="fee7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">其他人会在失败时返回0，在成功时返回非0</li><li id="bd6c" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">其他函数需要将错误状态与实际的业务返回值混合，因此函数可能会在失败时返回NULL，在成功时返回有效的指针。</li></ul><p id="710b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，这是一个烂摊子，一个典型的视频游戏设置功能，例如，看起来像这样:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="62cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这显示了您必须处理非常现实的错误处理机制组合。还要注意，除了将返回值完全分配给错误处理(因此基本上完全放弃了正确的函数)之外，您没有简单的方法来描述您的错误，除了它发生了。因此，像全局“errcode”变量这样更丑陋的解决方案被用来传递更多的信息。</p><p id="03f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以基本上，在C中，<strong class="jp ir">对于每个函数或API调用，你需要手动检查错误，并以适当的方式处理或恢复它</strong>。你真的没有其他选择。因为，一般来说，代码主要是调用函数和api(除了一些赋值和算法？)，这意味着您有两个选择:要么到处用错误处理样板文件来破坏您的代码，要么不正确地处理错误。在最坏的情况下，任何一屏C代码都可能有70%的错误处理和30%的实际代码(这些数字显然是我刚刚编造的)。</p><p id="87f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，在某些情况下，返回值不提供“空闲位置”来分配给错误处理(比如返回一个nil指针)，因为有效返回值的范围覆盖了返回类型的整个域。举个简单的例子:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="f385" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有办法向调用者报告错误，例如整数溢出，除了增加第三个参数或全局变量之外。</p><p id="8062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记加入资源管理，也就是:你分配的在返回之前需要释放的资源。如果你分配了一个工作缓冲区(比如操作字符串)，你最好记住不要只在函数结束时释放它，而是在需要时在每次错误检查时释放它:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="d42b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，随着您获得的每个资源，错误处理块变得越来越大，越来越复杂。显然，代码可以重构一点，但你能清理的也就这么多了，因为资源必须以相反的顺序正确地释放，而且只能释放那些实际获得的资源。</p><p id="1804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C语言的另一个问题是，仅仅通过查看签名(有时甚至通过快速查看源代码)是不可能知道一个函数是如何报告错误的，所以你必须回头检查文档。签名上没有告诉你如何管理错误的合同。Java实际上试图将错误声明添加到方法签名中，这有它自己的问题(参见后面的检查异常)。</p><p id="62ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的C程序在业务代码和错误处理代码之间不断跳跃。由于错误处理是您必须经常做的手动任务，所以很容易时不时地忘记，尤其是对新手来说，这会导致代码中潜伏着定时炸弹。你要关注的是业务逻辑，而不是错误处理。顺便说一下，这与自动内存管理和垃圾收集器的推理是一样的(“您希望专注于业务逻辑，而不是内存管理”)。</p><p id="2b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人认为这是使用C的最大障碍之一(除了可能缺乏模块化和命名空间)，否则它肯定仍然有它的用法和<em class="lg">存在的理由</em>。</p><p id="72a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这是发明例外的第一个也是唯一的原因:</p><ol class=""><li id="51a6" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk lh kr ks kt bi translated"><strong class="jp ir">让程序员不必为每个函数调用编写样板错误处理代码。</strong></li></ol><p id="fb18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。请记住这一点。</p><p id="29c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做，它们提供了一些附加值，比如统一和形式化错误处理机制，以及将错误处理代码归入它自己的独立块。</p><p id="d5cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">它们是如何工作的</strong></p><p id="e49f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，每种有异常的语言都有自己的风格，但是一些通用的东西是所有语言共有的，主要是:一种发出错误信号(超出函数签名的范围)的方法，该方法中断当前流程，并将其转移到错误处理例程，以及关于错误的一些信息。现在，如果只是调用一个处理函数，也可以用C来完成，问题是:处理函数完成后去哪里。您不能像常规中断处理程序一样恢复执行。因此，设计人员设计了一种方法，通过让您定义一个“catch”块来指定这一点，该块将成为在其try块中发生的任何错误的跳转目标(即使是在嵌套调用中)。Catch块不像代码的其余部分那样是“线性的”,而是调用堆栈被“展开”到最近的“catch”块。它遍历调用堆栈，这是让你写一个单一的，捕捉所有具有适当语义的处理程序。</p><p id="2dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是让我们看看上面的例子。在java中，可能是这样的:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="ef0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想没有人会不同意这是一个巨大的进步。错误处理不会妨碍业务，错误处理被很好地归入他自己的(小)块中，可读性显著提高。</p><p id="7485" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，异常真正闪光的地方是当你有嵌套调用时，例如:方法A调用方法B，方法B调用方法c。</p><p id="54f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你用C编程，异常处理与函数调用是相反的:主函数必须处理它，A函数必须处理它，B和C函数也一样。每个人都有自己的假设和/或早期回报以及通常的样板文件。</p><p id="f2b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Java中，你可以考虑整个调用链，并决定哪一点是放置catch块的最佳点(典型地，无论你正在编程的逻辑“主要”是什么，稍后会有更多介绍)，就这样。子函数A、B和C不需要以任何方式处理错误。你可能会对此感到惊讶，因为毕竟你的代码充满了“捕捉”和错误处理。这是关于异常的第一个、最大的和最重要的“错误信息”:</p><p id="5174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">你经常被鼓励写CATCH BLOCKS，这是错误的。</strong></p><p id="f0fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有两个原因:第一个主要是人的原因:如果你不放置catch块，感觉你没有正确处理错误。他们“逃跑”了！如果你写了一个服务函数，比如“downloadFile”，或者“produceReport”，而它不包含catches，你的老板会看着它说“嘿，你忘了处理异常，这是一个新手的错误”。编译器本身也鼓励这种文化，这带来了第二个原因:编译器实际上很难正确处理异常，因为有一种东西叫做检查异常。</p><p id="28aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您必须编写一个接受url的函数“downloadDocument”。这是你的老板给你实现的一个接口。它的签名可能是:</p><pre class="kz la lb lc gt li lj lk ll aw lm bi"><span id="004a" class="ln lo iq lj b gy lp lq l lr ls">byte[] downloadDocument(String url) throws CompanySpecificException</span></pre><p id="e8d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它实际上会抛出一个公司代码通常在内部使用的检查异常。</p><p id="ee05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，你开始实施它:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="f9d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是，它不能编译，因为“下载”实际上会抛出一个IOException。您面临着所有其他java程序员都曾面临的困境:如何处理未处理的异常。这是大多数开发者的误区。他们通常添加一个catch语句，以某种方式“管理”异常。但这是错误的，因为90%的时候，那不是放接球的正确位置。</p><p id="ff12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面对未处理的异常时，正确的做法是传播它，而不是捕捉它。</p><p id="5169" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这是非常重要的，正确的做法是在抛出声明列表中添加IOException。这是第二个错误信息:触及抛出条款就像是一个超级禁忌，只有你工作场所的专家才被允许考虑。这是错误的，因为所有的异常都是由方法内部的代码抛出的，应该在throw子句中报告，让它们“冒泡”到调用者，这就是异常的意义所在(参见第1点)。如果你添加定制代码来处理一个异常(当你不需要处理它的时候),你就违背了它们的用法。您正在添加样板代码，而这些代码正是异常想要让您摆脱的。</p><p id="a604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是回到我们的例子:你是一个优秀的程序员，你继续将异常添加到throws子句中，修改接口并冒着激怒你的老板的风险:</p><pre class="kz la lb lc gt li lj lk ll aw lm bi"><span id="157c" class="ln lo iq lj b gy lp lq l lr ls">byte[] downloadDocument(String url) throws CompanySpecificException, IOException</span></pre><p id="ba49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在您有了另一个问题:使用您的“downloadDocument”的调用站点现在无法编译，因为它在另一个只抛出CompanySpecificException的方法(prepareReport())内部。您想把事情做好，所以您变得更加大胆，您更改了prepareReport()，将IOException添加到它声明的异常中。但是wops，原来prepareReport()也被公司软件的一个完全不同的分支使用，由不同的团队管理。现在怎么办？</p><p id="7fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你现在看到照片了吗？许多人会告诉你检查异常是不好的，但是很少有人会给你正确的理由。</p><p id="1ed6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">受控异常糟糕的真正原因是它们干扰了异常的自然冒泡。</strong></p><p id="4206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，面对两个不同开发团队的愤怒，即使对最勇敢的程序员来说也是太多了，你很快恢复你的更改并做下一件最好的事情:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="0be9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您捕获异常并抛出一个您允许抛出的不同的异常(在本例中是CompanySpecificException，但在没有throws声明的方法的最坏情况下，它将是RuntimeException)。如果你是一个优秀的程序员，你可以把原来的包在新的包里(把它们链接起来)，这样堆栈跟踪就会揭示真正的错误位置。如果你没有，就这样做:</p><pre class="kz la lb lc gt li lj lk ll aw lm bi"><span id="5ec7" class="ln lo iq lj b gy lp lq l lr ls">throw new CompanySpecificException(“Error downloading document”);</span></pre><p id="4609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么堆栈跟踪将在那里结束，让您对错误的真正来源一无所知。这是一个非常常见的错误。我经常看到我的同事做这个。因为整个事情很容易出错。如果他们真的很可怕或者真的是新手，他们甚至可能在异常世界犯下最严重的暴行:默默地吃掉异常:</p><pre class="kz la lb lc gt li lj lk ll aw lm bi"><span id="180e" class="ln lo iq lj b gy lp lq l lr ls">catch(Exception e)<br/>{<br/>  // nothing or perhaps e.printStacktrace();<br/>}</span></pre><p id="fd15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我肯定你见过这个。这是最糟糕的事情，因为错误被默默地忽略了，其他的事情会在稍后中断，报告一个异常和一个与错误的真正原因无关的堆栈跟踪。你好调试！</p><p id="f1d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，你必须做的这个容易出错的“捕捉游戏”是完全没有任何附加价值的，你必须这么做是因为有缺陷的检查异常系统。这纯粹是样板文件，直接违背了异常存在的首要原因(参见上面的第1点)。</p><p id="a136" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使是ide也经常出错。例如，在Eclipse中，当您遇到未处理的异常时，它会为您提供以下两种选择:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/3c85534232ad9cd5d058716bde6c18a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/0*N3Eax7YJyXBDC8x2"/></div></figure><p id="75b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，正确地说，将它添加到throws声明中是第一选择，但是如果您决定将它括起来，您会得到这样的结果:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="213a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个心烦意乱的程序员，或者一个赶时间的人来说，这现在可以编译了，所以它是“正确的”。除了不是，例外都被吃了！是的，你有待办事项提醒，但我的工作场所代码库中有上千个，我可以告诉你，它们在以后吸引开发人员的注意力方面并不太有效。更明智的违约应该是:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="28b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至少现在，如果程序员只是盲目地使用它，它会正确地处理异常并链接它，以便它报告正确的来源。</p><p id="e3d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这里的主要外卖课程如下:</p><p id="c373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JAVA中处理异常的正确方法应该是什么都不做，让它们冒泡到正确的捕捉位置。</p><p id="0cc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真的，我们有一个很棒的系统，以最好的方式解决了一个丑陋的问题:什么都不做。我们浪费了它。</p><p id="7081" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，这也受到检查异常系统的阻碍。它的问题是限制性太强。我仍然需要“throws”声明，但是它应该作为一个“契约”来使用，以记录函数可以抛出哪些类型的错误，这样调用者就可以区分它们，并以不同的方式处理它们，但是不应该限制要抛出的其他异常，也不应该要求调用者显式地声明它们。例如，这样一种方法:</p><pre class="kz la lb lc gt li lj lk ll aw lm bi"><span id="d51b" class="ln lo iq lj b gy lp lq l lr ls">public void socketConnect(…) throws HostNotFoundException, TimeoutException, NoNetworkException</span></pre><p id="340f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对开发人员是有帮助的:如果需要的话，他们可以正确区分行为，但是传播异常仍然是主要的事情。</p><p id="8bb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论上，整个服务库应该是可写的，没有一个“catch”块(或者很少几个),因为catch块属于调用者，属于某个服务的最终用户。</p><p id="b3ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以说:嘿，但是如果我像FancyExcel一样使用我喜欢的库，我希望它的方法抛出FancyExcelException，对吗？嗯，有一段时间是这样的(看看Jasper JRException就是一个例子)，但是现在人们开始想到要么抛出RuntimeException，要么根据需要简单地声明机构异常(IOException等)，没有包装。例如，Gson有自己的JsonParseException，但它扩展了RuntimeException。它在Throws子句中声明了它！你现在能做的最好的是:<a class="ae lw" href="https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonParser.html)" rel="noopener ugc nofollow" target="_blank">https://www . javadoc . io/doc/com . Google . code . gson/gson/latest/com . Google . gson/com/Google/gson/JSON parser . html</a></p><p id="3cc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你考虑一下，包装一个异常只是抛出一个带有你定制的公司/库名的异常，实际上用途有限，相反，它使得栈跟踪更难读取。如果一个库从不做自己的“捕捉”,那么在它内部生成的stacktrace将会是清晰的、线性的和直截了当的，就像它们被设计的那样。链接异常还会污染最终的错误消息。你见过类似“Java . lang . runtime exception:fancy . library . fancylibrary exception:Java . io . io exception:Java . foo . bar . file not found exception:找不到文件”的东西吗？我做到了。</p><p id="3eaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，捕捉并再抛出在某些情况下可能是有用的，特别是在长过程中，一个“没有发现数据异常”可能来自许多不同的系统。类似于“检索客户端详细信息时出错:未找到数据”这样的内容对于初次评估肯定更有帮助。堆栈跟踪仍然是这两种情况下的主要证据。</p><p id="f26c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">异常让你可以通过什么都不做来正确地处理错误，所以你可以随意抛出它们，但是只在你绝对需要的时候捕获它们。</p><p id="6f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一个JAVA程序应该有足够多的抛出，但极少有捕捉。</strong></p><p id="fdcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我甚至可以说，java程序的质量可以通过它所拥有的“catch”的数量来衡量(至少，其中一个度量可以是它)。</p><p id="bcbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">那么，哪些地方是“捕捉”es的好地方呢？</strong></p><p id="c6a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">捕捉应该发生在一个逻辑“单元”的最顶层，如果不捕捉就会将异常传播给最终用户或者退出整个批处理程序。如果你理解例外，在哪里放渔获应该是非常自然的，无论如何一些好的地方应该是:</p><ul class=""><li id="02dd" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">就在返回用户发起的动作之前:如果用户按下“打印报告”按钮，该按钮(希望是异步的)调用printReport()，那么print report()是放置catch的好地方。</li><li id="d9cf" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在循环处理项目列表时，当一个有问题的项目不应该阻塞整个过程时。例如，如果您正在解析一个包含股票信息行的文件，您可能希望跳过给出错误的行，并在处理所有其他行时报告它们。然后在循环中使用catch并处理错误。</li><li id="65cb" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在事件系统中，主事件循环肯定会有一个catch来捕获单个事件的错误，而不会终止自身。</li><li id="3e4d" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">servlet需要一个catch来捕获页面生成(或任何启动的“动作”)的问题，以便向用户显示正确的错误消息。</li></ul><p id="208e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向最终用户展示什么？</p><p id="8673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，一个重要的问题是当异常发生时向用户显示什么。嗯，你有很多选择，这也取决于你在编程什么，你的典型用户是谁。但是有一点应该明确:异常是程序员的工具，而不是错误报告工具。显示未处理的异常消息或堆栈跟踪很少是正确的做法。这一次，他们暴露了系统的内部架构:他们可以告诉黑客你在使用哪种语言，哪个库，框架等等。安全漏洞也是如此。不要这样:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="lx lf l"/></div></figure><p id="538a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向用户显示的最安全的东西是一般的消息，并将实际的错误和堆栈跟踪转移到日志记录系统。另一种选择是使用RuntimeException的自定义子类，并添加额外的字段(是的，您可以这样做),如错误代码或用户消息。</p><p id="d09f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">关于资源管理的一句话</strong></p><p id="0d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，资源管理与异常管理密切相关。释放资源是你无论如何都要做的事情，它会干扰异常传播。出于这个原因，通常异常都带有一个“finally”语句，允许您执行代码(这反过来会引发异常，但这是另一个棘手的问题)。我通常做的是，因为我不怎么使用“catch ”,所以我使用try finally变体，就像这样:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="4fd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有一个不幸的“特性”, try作用域中声明的变量在finally中不可用，这迫使您将声明上移，这更像是样板文件。半新的“try-with-resources”构造已经提供了一些帮助，但是它需要来自实际资源的明确支持(它必须实现Autoclosable)。我在其他语言中看到的，也是我非常喜欢的，是将获取和释放委托给实际的资源类，并传递一个lambda表达式/闭包和代码来执行资源。在java中可能是这样的:</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="c102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“with()”方法将打开文件，调用闭包并在最后关闭文件。好的一面是，通过将管理委托给资源，它从客户端转移到了服务端，所以即使是分心的程序员也是安全的，并且不会忘记清理。希望我们也能在java中看到这种模式，现在它有了lambdas。</p><p id="8f03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">其他方法</strong></p><p id="9650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些语言正在尝试其他方法，可能最显著的是使用代数数据类型。例如，使用ADT，您可以有一个不固定的返回类型，但可以是列表中的几个类型之一。一个例子可能是:</p><pre class="kz la lb lc gt li lj lk ll aw lm bi"><span id="c30b" class="ln lo iq lj b gy lp lq l lr ls">Error|String readFileContent(File file)</span></pre><p id="84bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，您的方法可以返回字符串或错误。根据返回类型，您可以发出出错或一切正常的信号，并且您拥有可用于实际内容的完整字符串域。现在，依我看，这比C语言稍微好一点:它允许您添加一个关于如何报告错误的契约(从签名中可以立即看出)，并为您提供一个完整的错误对象，包括消息等。有些语言让你用“Error|？”来连锁调用返回值，遇到错误时自动停止并返回(注意？。语法):</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="7deb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在调用链的末尾返回字符串，或者返回由中间调用返回的任何错误。</p><p id="de27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法肯定有一些优点，我要明确地说，我对此没有太多的经验，但让我吃惊的是，尽管有所有的语法糖和编译器支持，使用这种方法，您又回到了在每个调用级别上处理错误，就像C一样。在对一个方法的每一次调用中，您都需要显式地处理可能的错误，无论多么简洁。</p><p id="fe71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，我鼓励你把例外想成是你通常扔出去很少接住的东西，而不是相反。有疑问的时候，让打电话的人去处理。这不是“别人会那样做”的心态，而是例外是如何起作用的。拥抱RuntimeExceptions，直到它们清理了被检查的异常系统(就像大多数其他JVM语言已经做的那样)。</p><p id="8388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想想你正在开发的程序，试着找出其中哪些是好的“捕捉”网站，并与你实际拥有的“捕捉”进行比较。</p><p id="1f03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>