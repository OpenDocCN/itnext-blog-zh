<html>
<head>
<title>🔥 The Evolution of Asynchronous Patterns in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">🔥JavaScript中异步模式的演变</h1>
<blockquote>原文：<a href="https://itnext.io/the-evolution-of-asynchronous-patterns-in-javascript-64efc8938b16?source=collection_archive---------0-----------------------#2021-10-31">https://itnext.io/the-evolution-of-asynchronous-patterns-in-javascript-64efc8938b16?source=collection_archive---------0-----------------------#2021-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd05" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们谈谈JavaScript中使用的异步模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7bea7270b8d1a0c29aff500b154107d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WU6zwl3v07nm8MBaJT4llA.jpeg"/></div></div></figure><div class="kr ks gp gr kt ku"><a href="https://medium.com/subscribe/@easy-web" rel="noopener follow" target="_blank"><div class="kv ab fo"><div class="kw ab kx cl cj ky"><h2 class="bd ir gy z fp kz fr fs la fu fw ip bi translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。</h2><div class="lb l"><h3 class="bd b gy z fp kz fr fs la fu fw dk translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="lc l"><p class="bd b dl z fp kz fr fs la fu fw dk translated">medium.com</p></div></div><div class="ld l"><div class="le l lf lg lh ld li kp ku"/></div></div></a></div></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="ad1b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">内容</h1><ul class=""><li id="670d" class="mi mj iq mk b ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"><a class="ae na" href="#1ef5" rel="noopener ugc nofollow"> <strong class="mk ir">简介</strong> </a></li><li id="4e2e" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#dff6" rel="noopener ugc nofollow"> <strong class="mk ir">关于异步JavaScript的神话</strong> </a></li><li id="a330" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#fe21" rel="noopener ugc nofollow"> <strong class="mk ir">影响JavaScript </strong> </a>的异步模式</li><li id="71f5" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#650c" rel="noopener ugc nofollow"> <strong class="mk ir">不要挂断或者我们可以给你回电话</strong> </a>🤙</li><li id="1525" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#c1e3" rel="noopener ugc nofollow"> <strong class="mk ir">我们答应叫你</strong> </a> <strong class="mk ir"> </strong>📞</li><li id="81ca" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#bf6d" rel="noopener ugc nofollow"> <strong class="mk ir">我会观察，有什么变化就给你打电话</strong> </a> <strong class="mk ir"> </strong>👀</li><li id="753a" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#3c5d" rel="noopener ugc nofollow"> <strong class="mk ir">结论</strong> </a></li><li id="e5cf" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><a class="ae na" href="#faeb" rel="noopener ugc nofollow"> <strong class="mk ir">了解更多</strong> </a></li></ul></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="1ef5" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">介绍</h1><p id="51db" class="pw-post-body-paragraph ng nh iq mk b ml mm jr ni mn mo ju nj mp nk nl nm mr nn no np mt nq nr ns mv ij bi translated">异步调用就像一根快速不停漂浮的水管。这些管道也相互连接，可以合并成一个大管道。相互缠绕的管道越多，就越难避免漏水。让我们找出如何指导和连接管道的方法，管道系统足够灵活，这样我们就永远不必叫水管工了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="dff6" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">关于异步JavaScript的神话</h1><p id="dd63" class="pw-post-body-paragraph ng nh iq mk b ml mm jr ni mn mo ju nj mp nk nl nm mr nn no np mt nq nr ns mv ij bi translated">很多前端面试中最常见的刁钻问题之一:<em class="nv">JavaScript是异步语言吗？对于一些人来说，这可能会令人困惑，因为你必须处理不阻塞UI的API调用，所以逻辑上JS必须是异步的。从最终用户的角度来看，这种看法是正确的。但Js实际上是一个单线程，JS引擎滥用了2个内存数据结构:<em class="nv">函数</em> <em class="nv">栈</em>和<em class="nv">任务</em> <em class="nv">队列</em>。与<em class="nv">堆栈</em>和<em class="nv">队列</em>的交互也被称为<em class="nv">事件循环</em>。</em></p><p id="8f55" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">概念很简单。想象你的代码正在执行一组<em class="nv">嵌套函数</em>，一个函数在另一个函数内部被调用。每个函数调用都将被推入<em class="nv">内存堆栈</em>，以保持调用<em class="nv">顺序</em>。例如:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="1b09" class="og lr iq oc b gy oh oi l oj ok">function fooB(){<br/>    console.log('fooB: called');<br/>}</span><span id="c3ac" class="og lr iq oc b gy ol oi l oj ok">function fooA(){<br/>    fooB();<br/>    console.log('fooA: called');<br/>}</span><span id="6d63" class="og lr iq oc b gy ol oi l oj ok">fooA();<br/>// -&gt; fooB: called<br/>// -&gt; fooA: called</span></pre><p id="d7b4" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">JS引擎说:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="8714" class="og lr iq oc b gy oh oi l oj ok">1. push <em class="nv">fooA</em> to stack<br/><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooA|</strong> &lt;- push</span><span id="a6e9" class="og lr iq oc b gy ol oi l oj ok">2. push <em class="nv">fooB</em> to stack<br/><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooB|</strong> &lt;- push<br/>|fooA|</span><span id="3acb" class="og lr iq oc b gy ol oi l oj ok">3. pop <em class="nv">fooB </em>from stack and execute<br/><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooB|</strong> &lt;- pop<br/>|fooA|</span><span id="affa" class="og lr iq oc b gy ol oi l oj ok">// -&gt;<strong class="oc ir"> fooB: called<br/>&lt;stack&gt;</strong><br/>|fooA|</span><span id="e538" class="og lr iq oc b gy ol oi l oj ok">4. pop <em class="nv">fooA</em> from stack and execute<br/><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooA|</strong> &lt;- pop</span><span id="c8ab" class="og lr iq oc b gy ol oi l oj ok">// -&gt; <strong class="oc ir">fooA: called</strong></span><span id="6066" class="og lr iq oc b gy ol oi l oj ok">&lt;stack&gt;<br/>|   | <strong class="oc ir">&lt;- stack is empty</strong></span></pre><p id="e39f" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">我们发现所有的函数调用都被推入<em class="nv">函数栈</em>。但是什么会进入任务队列呢？做这件事有不同的方法:</p><ul class=""><li id="54e1" class="mi mj iq mk b ml nw mn nx mp om mr on mt oo mv mw mx my mz bi translated"><strong class="mk ir">设置超时</strong></li><li id="2801" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><strong class="mk ir">设置间隔</strong></li><li id="5514" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><strong class="mk ir">承诺</strong></li><li id="1f4f" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated">ajax </li><li id="5645" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><strong class="mk ir"> DOM事件</strong></li></ul><p id="2f2a" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">让我们看看这个例子:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="0111" class="og lr iq oc b gy oh oi l oj ok">function fooB(){<br/>    <strong class="oc ir">setTimeout(()=&gt;console.log('API call B'));</strong><br/>    console.log('fooB: called');<br/>}</span><span id="b3bb" class="og lr iq oc b gy ol oi l oj ok">function fooA(){<br/>    <strong class="oc ir">setTimeout(()=&gt;console.log('API call A'));</strong><br/>    fooB();<br/>    console.log('fooA: called');<br/>}</span><span id="5d82" class="og lr iq oc b gy ol oi l oj ok">fooA();<br/>// -&gt; fooB: called<br/>// -&gt; fooA: called<br/>// -&gt; <strong class="oc ir">API call A</strong><br/>// -&gt; <strong class="oc ir">API call B</strong></span></pre><p id="a3f8" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">现在，让我们看看幕后发生了什么:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="567b" class="og lr iq oc b gy oh oi l oj ok">1. push <em class="nv">fooA</em> to stack</span><span id="2657" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooA|</strong> &lt;- push</span><span id="7167" class="og lr iq oc b gy ol oi l oj ok">2. push <strong class="oc ir">'API call A' </strong>to queue</span><span id="aa41" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;queue&gt;</strong>|<strong class="oc ir">'API call A'</strong>| &lt;- push</span><span id="af29" class="og lr iq oc b gy ol oi l oj ok">3. push <em class="nv">fooB</em> to stack<br/>&lt;stack&gt;<br/><strong class="oc ir">|fooB|</strong> &lt;- push<br/>|fooA|</span><span id="de0e" class="og lr iq oc b gy ol oi l oj ok">4. push <strong class="oc ir">'API call B' </strong>to queue</span><span id="9fcc" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;queue&gt;</strong>|<strong class="oc ir">'API call A'</strong>|<strong class="oc ir">'API call B'|</strong> &lt;- push</span><span id="6c88" class="og lr iq oc b gy ol oi l oj ok">5. pop <em class="nv">fooB </em>from stack and execute<br/><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooB|</strong> &lt;- pop<br/>|fooA|</span><span id="addb" class="og lr iq oc b gy ol oi l oj ok">// -&gt;<strong class="oc ir"> fooB: called</strong></span><span id="84aa" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;stack&gt;</strong><br/>|fooA|</span><span id="3d54" class="og lr iq oc b gy ol oi l oj ok">6. pop <em class="nv">fooA</em> from stack and execute<br/><strong class="oc ir">&lt;stack&gt;</strong><br/><strong class="oc ir">|fooA|</strong> &lt;- pop</span><span id="02cb" class="og lr iq oc b gy ol oi l oj ok">// -&gt; <strong class="oc ir">fooA: called</strong></span><span id="8f46" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;stack&gt; &lt;- stack is empty<br/>|   |</strong></span><span id="7aa4" class="og lr iq oc b gy ol oi l oj ok">7. pop <strong class="oc ir">'API call A' </strong>from<strong class="oc ir"> </strong>queue and execute</span><span id="b83d" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;queue&gt;</strong>|<strong class="oc ir">'API call A'</strong>| &lt;- pop |'API call B'|<br/>// -&gt; <strong class="oc ir">API call A</strong></span><span id="806f" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;queue&gt;</strong>|'API call B'|</span><span id="cc1c" class="og lr iq oc b gy ol oi l oj ok">8. pop <strong class="oc ir">'API call B' </strong>from<strong class="oc ir"> </strong>queue and execute</span><span id="7bf2" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;queue&gt;</strong>|<strong class="oc ir">'API call B'</strong>| &lt;- pop<br/>// -&gt; <strong class="oc ir">API call B</strong></span><span id="3564" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">&lt;queue&gt;</strong>|   | &lt;- queue is empty</span></pre><p id="5eff" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">如果我们把它形象化，就会清楚得多:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/3cd883346bf294687eefb1f1d268ae4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*02F5vZVEEKXGjSkl-78ndg.gif"/></div></div></figure><p id="64c9" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">在简要概述了异步JavaScript之后，让我们深入了解不同的模式和数据结构如何利用JS异步模型。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="fe21" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">影响JavaScript的异步模式</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq nu l"/></div></figure><p id="8345" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">在我们知道JavaScript中事件内存是如何工作的之后，我们需要弄清楚如何编写异步代码——简洁而高效。我们将发现处理异步数据的更多缺点，并概述最有效的模式和数据结构。我们将主要关注API调用场景来说明主要的挑战，但是用例并不仅限于这些例子。</p><p id="4194" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">JavaScript中目前使用以下模式和数据结构:</p><ul class=""><li id="bcad" class="mi mj iq mk b ml nw mn nx mp om mr on mt oo mv mw mx my mz bi translated"><strong class="mk ir"> <em class="nv">回调</em> </strong></li><li id="0d38" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><strong class="mk ir"> <em class="nv">许诺</em> </strong></li><li id="a68e" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><strong class="mk ir"> <em class="nv">观察者</em> </strong></li></ul><p id="0665" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">每一个都是前一个的延伸。让我们更详细地回顾一下。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="650c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">不要挂断，否则我们会再打给你🤙</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="or nu l"/></div></figure><p id="e58b" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">当我们向呼叫中心寻求帮助解决问题并需要遵循机器人的指令时，我们都有这种心理创伤。大多数通常会给你两个选择。选项1——你是不是<em class="nv">呆在队伍里</em>听着单调的旋律，这能让你发疯🤯。即使等待，什么也不做只是浪费时间，大多数人倾向于选择这个选项，因为他们觉得他们已经花了足够的时间来连接，并且不信任这个服务。更有效的选择是要求<em class="nv">回电，</em>在这种情况下，你可以畅通无阻地做任何你想做的事情，同时等待一个代表给你打电话。</p><p id="0c52" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">JavaScript <em class="nv">回调</em>中使用了相同的模式。例如，您有一个<em class="nv"> callApiFoo </em>函数，并传递两个<em class="nv">函数</em>作为参数，<em class="nv">成功、</em>和<em class="nv">失败、</em>，根据API调用是否成功执行，它将调用相应的<em class="nv">回调</em>。</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="3775" class="og lr iq oc b gy oh oi l oj ok">function <strong class="oc ir">success</strong>(<!-- -->res<!-- -->){<br/>    console.log("API call successful");<br/>}</span><span id="be7c" class="og lr iq oc b gy ol oi l oj ok">function <strong class="oc ir">fail</strong>(<!-- -->err<!-- -->){<br/>    console.log("API call failed");<br/>}</span><span id="0054" class="og lr iq oc b gy ol oi l oj ok">function <strong class="oc ir">callApiFoo</strong>(success, fail){<br/>    <!-- -->fetch(url)<br/>      .then(res =&gt; <strong class="oc ir">success</strong>(<!-- -->res<!-- -->)<!-- -->)<br/>      .catch(err =&gt; <strong class="oc ir">fail</strong>(err));<br/>};</span><span id="3271" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">callApiFoo(success, fail)</strong>;</span></pre><p id="261f" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">当一个API调用依赖于另一个API调用时，这种方法有一个缺点。这将迫使我们嵌套这些调用。如果只有几个这样的电话可能还可以，但是当我们有很多这样的电话时会发生什么呢？通过嵌套每个回调函数，我们将得到一个意大利面条式的代码:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="9f5f" class="og lr iq oc b gy oh oi l oj ok"><strong class="oc ir">callApiFooA((resA)=&gt;{<br/>    callApiFooB((resB)=&gt;{<br/>        callApiFooC((resC)=&gt;{<br/>            console.log(resC);<br/>        }), fail)</strong>;<br/>    <strong class="oc ir">}), fail)</strong>;<br/><strong class="oc ir">}), fail)</strong>;</span></pre><p id="0ebc" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">这看起来像一场灾难，但有一个解决办法。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="c1e3" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">我答应给你打电话📞</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os nu l"/></div></figure><p id="2815" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">如何摆脱这个筑巢的地狱😈，因为在web开发中，我们必须非常频繁地组合API调用。这个概念是，我们可以<em class="nv">链接</em>调用，而不是<em class="nv">嵌套</em>调用。这就是<em class="nv">承诺</em>发挥作用的地方。它们是可以将结果作为另一个<em class="nv">承诺</em>返回的数据结构。让我们看看这个例子:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="90bd" class="og lr iq oc b gy oh oi l oj ok"><strong class="oc ir">function callApiFooA(){<br/>    return </strong><strong class="oc ir">fetch(url); // </strong>JS<strong class="oc ir"> fetch </strong>method returns a Promise<strong class="oc ir"><br/></strong><strong class="oc ir">}</strong></span><span id="577a" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooB(</strong><strong class="oc ir">resA</strong><strong class="oc ir">){<br/>    return </strong><strong class="oc ir">fetch(</strong><strong class="oc ir">url+'/'+</strong><strong class="oc ir">resA.id);  <br/></strong><strong class="oc ir">}</strong></span><span id="0a54" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooC(</strong><strong class="oc ir">resB</strong><strong class="oc ir">){<br/>    return </strong><strong class="oc ir">fetch(url</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resB.id);  <br/></strong><strong class="oc ir">}</strong></span><span id="09eb" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">callApiFooA()<br/>    .then(callApiFooB)<br/>    .then(callApiFooC)<br/>    .catch(fail)</strong></span></pre><p id="0e47" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">这要好得多，并且提供了更具可伸缩性的解决方案。我们可以根据自己的需要，将<em class="nv">承诺</em>链接多次。<em class="nv">如果一个调用依赖于两个或多个其他API调用会怎么样？</em>然后我们想在一个调用中合并多个<em class="nv">承诺</em>，并在另一个调用中对它们进行后处理。</p><p id="d3c9" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">让我们看看使用<strong class="mk ir"> Promise.all </strong>的例子:</p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="77e7" class="og lr iq oc b gy oh oi l oj ok"><strong class="oc ir">function callApiFooA(){<br/>    return </strong><strong class="oc ir">fetch(urlA); <br/></strong><strong class="oc ir">}</strong></span><span id="6776" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooB(){<br/>    return </strong><strong class="oc ir">fetch(</strong><strong class="oc ir">urlB</strong><strong class="oc ir">);  <br/></strong><strong class="oc ir">}</strong></span><span id="67f0" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooC(</strong><strong class="oc ir">[resA, resB]</strong><strong class="oc ir">){<br/>    return </strong><strong class="oc ir">fetch(url</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resA.id</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resB.id);  <br/></strong><strong class="oc ir">}</strong></span><span id="fd07" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooD(</strong><strong class="oc ir">resC</strong><strong class="oc ir">){<br/>    return </strong><strong class="oc ir">fetch(url</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resC.id);  <br/></strong><strong class="oc ir">}</strong></span><span id="c9e4" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">Promise.all([callApiFooA(), callApiFooB()])</strong><br/>    <strong class="oc ir">.then(callApiFooC)<br/>    .then(callApiFooD)<br/>    .catch(fail)</strong></span></pre><p id="3a18" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">它看起来很整洁，但我们还没说完。我们甚至可以更进一步，可能想要改变我们从一个承诺调用传递到另一个承诺调用的数据流。例如，我们<em class="nv">过滤</em>一个承诺响应，只获取特定类型的数据，然后<em class="nv">映射</em>过滤后的数据，只获取id。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="bf6d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">我会观察并在有变化时通知你👀</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os nu l"/></div></figure><p id="0d26" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">处理多个异步变化的数据流可能具有挑战性。尤其是当它们相互依赖时，我们必须以更复杂的方式将它们结合起来。为了解决这个问题，我们使用另一种数据结构，如<em class="nv"> Observer </em>。<em class="nv">观察者</em>创建一个数据变更流，其他消费者可以<em class="nv">订阅</em>该流，以便<em class="nv">监听</em>和<em class="nv">检索</em>最新的<em class="nv">变更</em>。<strong class="mk ir">顺便说一句，如果你还没有在medium中跟随我，如果今天学到了一些新东西，明天还想学更多，就跟随我吧</strong>😉<strong class="mk ir">。</strong>让我们更仔细地看一下<strong class="mk ir"> </strong>，为了演示起见，我们将使用<a class="ae na" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="mk ir"> RxJs库</strong> </a> <strong class="mk ir"> : </strong></p><pre class="kg kh ki kj gt ob oc od oe aw of bi"><span id="6688" class="og lr iq oc b gy oh oi l oj ok"><strong class="oc ir">function callApiFooA(){<br/>    return </strong><strong class="oc ir">fetch(urlA); <br/></strong><strong class="oc ir">}</strong></span><span id="4904" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooB(){<br/>    return </strong><strong class="oc ir">fetch(</strong><strong class="oc ir">urlB</strong><strong class="oc ir">);  <br/></strong><strong class="oc ir">}</strong></span><span id="d061" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooC(</strong><strong class="oc ir">[resAId, resBId]</strong><strong class="oc ir">){<br/>    return </strong><strong class="oc ir">fetch(url</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resAId</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resBId);  <br/></strong><strong class="oc ir">}</strong></span><span id="3208" class="og lr iq oc b gy ol oi l oj ok"><strong class="oc ir">function callApiFooD(</strong><strong class="oc ir">resC</strong><strong class="oc ir">){<br/>    return </strong><strong class="oc ir">fetch(url</strong><strong class="oc ir">+'/'+</strong><strong class="oc ir">resC.id);  <br/></strong><strong class="oc ir">}</strong></span><span id="ff1e" class="og lr iq oc b gy ol oi l oj ok">Observable.from(Promise.all([<strong class="oc ir">callApiFooA()</strong>, <strong class="oc ir">callApiFooB()</strong>])).<strong class="oc ir">pipe</strong>(<br/>    <strong class="oc ir">map</strong>(([<strong class="oc ir">resA</strong>, <strong class="oc ir">resB</strong>]) =&gt; ([<strong class="oc ir">resA.id</strong>, <strong class="oc ir">resB.id</strong>])), // &lt;- extract ids<br/>    <strong class="oc ir">switchMap</strong>((<strong class="oc ir">resIds</strong>) =&gt; Observable.from(<strong class="oc ir">callApiFooC(</strong><strong class="oc ir">resIds</strong><strong class="oc ir">)</strong>)),<br/>    <strong class="oc ir">switchMap</strong>((<strong class="oc ir">resC</strong>) =&gt; Observable.from(<strong class="oc ir">callApiFooD(</strong><strong class="oc ir">resC</strong><strong class="oc ir">)</strong>)),<br/>    <strong class="oc ir">tap</strong>((<strong class="oc ir">resD</strong>) =&gt; console.log(<strong class="oc ir">resD</strong>))<br/>).<strong class="oc ir">subscribe</strong>();</span></pre><ul class=""><li id="cdf1" class="mi mj iq mk b ml nw mn nx mp om mr on mt oo mv mw mx my mz bi translated"><em class="nv"> Observable.from </em>将把一个<em class="nv">承诺的数组</em>转换成<em class="nv">可观察的</em>，即一个来自<strong class="mk ir"> </strong> <em class="nv"> callApiFooA </em>和<em class="nv"> callApiFooB的结果数组。</em></li><li id="9995" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><em class="nv"> map — </em>从API函数A和B的响应中提取<em class="nv">id</em></li><li id="2643" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated">switchMap —使用先前结果的id调用<em class="nv"> callApiFooC </em>，并返回一个新的<em class="nv">可观察值</em>和函数<em class="nv"> callApiFooC </em>的结果</li><li id="7e9a" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated">switchMap —使用函数<em class="nv"> callApiFooC </em>的结果调用<em class="nv"> callApiFooD </em></li><li id="98a8" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><em class="nv">点击</em> —获取之前执行的结果，并在控制台中打印出来</li><li id="d0c4" class="mi mj iq mk b ml nb mn nc mp nd mr ne mt nf mv mw mx my mz bi translated"><em class="nv">订阅</em> —开始收听观察</li></ul><p id="d8a7" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated">这种模式在处理异步数据流时更加强大和灵活。它也很受欢迎，在Angular这样的前端框架中使用。<strong class="mk ir">如果你有兴趣阅读更多关于可观测量的高级用法，请发表评论</strong>👍<strong class="mk ir">。</strong></p><h1 id="3c5d" class="lq lr iq bd ls lt ot lv lw lx ou lz ma jw ov jx mc jz ow ka me kc ox kd mg mh bi translated">结论</h1><p id="854e" class="pw-post-body-paragraph ng nh iq mk b ml mm jr ni mn mo ju nj mp nk nl nm mr nn no np mt nq nr ns mv ij bi translated">我们浏览了JavaScript中异步模式的历史。使用可观测量的现代方法足以涵盖最复杂的情况。如果你今天学到了一些新的东西，请不要害羞地跟随我，将来我会用更多关于web开发的精彩话题来回报你。😎</p><div class="kr ks gp gr kt ku"><a href="https://medium.com/subscribe/@easy-web" rel="noopener follow" target="_blank"><div class="kv ab fo"><div class="kw ab kx cl cj ky"><h2 class="bd ir gy z fp kz fr fs la fu fw ip bi translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。</h2><div class="lb l"><h3 class="bd b gy z fp kz fr fs la fu fw dk translated">每当维塔利·舍甫琴科发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="lc l"><p class="bd b dl z fp kz fr fs la fu fw dk translated">medium.com</p></div></div><div class="ld l"><div class="oy l lf lg lh ld li kp ku"/></div></div></a></div></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="faeb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma jw mb jx mc jz md ka me kc mf kd mg mh bi translated">了解更多信息</h1><div class="kr ks gp gr kt ku"><a rel="noopener  ugc nofollow" target="_blank" href="/how-micro-frontend-changes-the-future-of-angular-bb4deb2cfdad"><div class="kv ab fo"><div class="kw ab kx cl cj ky"><h2 class="bd ir gy z fp kz fr fs la fu fw ip bi translated">🔥微前端如何改变Angular的未来？</h2><div class="lb l"><h3 class="bd b gy z fp kz fr fs la fu fw dk translated">让我们看看为什么Angular最适合微前端</h3></div><div class="lc l"><p class="bd b dl z fp kz fr fs la fu fw dk translated">itnext.io</p></div></div><div class="ld l"><div class="oz l lf lg lh ld li kp ku"/></div></div></a></div><div class="kr ks gp gr kt ku"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-scale-angular-without-limits-e6a6ca15111"><div class="kv ab fo"><div class="kw ab kx cl cj ky"><h2 class="bd ir gy z fp kz fr fs la fu fw ip bi translated">🔥如何无限制地缩放角度</h2><div class="lb l"><h3 class="bd b gy z fp kz fr fs la fu fw dk translated">极限总是在你的头脑中，清空你的头脑和秤</h3></div><div class="lc l"><p class="bd b dl z fp kz fr fs la fu fw dk translated">itnext.io</p></div></div><div class="ld l"><div class="pa l lf lg lh ld li kp ku"/></div></div></a></div><p id="4169" class="pw-post-body-paragraph ng nh iq mk b ml nw jr ni mn nx ju nj mp ny nl nm mr nz no np mt oa nr ns mv ij bi translated"><em class="nv">更多内容请看</em><a class="ae na" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir"><em class="nv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>