<html>
<head>
<title>A script to secure Docker daemon connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护Docker守护程序连接的脚本</h1>
<blockquote>原文：<a href="https://itnext.io/a-script-to-secure-docker-daemon-connections-c3d77fb9d260?source=collection_archive---------4-----------------------#2022-07-21">https://itnext.io/a-script-to-secure-docker-daemon-connections-c3d77fb9d260?source=collection_archive---------4-----------------------#2022-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5cab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安全总是很重要，尤其是当你在上网的时候。</p><p id="3ee2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里找到代码:<a class="ae kl" href="https://github.com/hosein-yousefii/docker-daemon-tls" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> GITHUB </strong> </a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f486018d47ad40296ebdd2fc8bc2f424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjXe8ifAfDUaPMtbsKzoJg.png"/></div></div></figure><p id="e8df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，管理员更喜欢远程连接到docker守护进程来完成他们的工作，但是，如果没有TLS，这将是一个大错误。</p><p id="24d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望对docker守护进程实现TLS(自签名),以保护远程连接。</p><p id="4bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么它很重要？！！</strong></p><p id="2e48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从安全角度来看，互联网上任何没有加密的东西都是危险的。想象一下，你连接到docker守护进程，一个黑客在中间监听，所以，黑客可以读取你发送到docker守护进程的所有信息，这一点都不好！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/c14cb9fd309fe98a4bf9e6f71d2734ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*ESBTGJxV5KEyTeST4PjUhw.png"/></div></figure><p id="14cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这幅图中，我们用TLS保护了与服务器的连接，以便加密客户机和docker引擎之间的流量。</p><p id="5ed5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写了一个脚本来帮助实现TLS到docker守护进程。从我的<a class="ae kl" href="https://github.com/hosein-yousefii/docker-daemon-tls" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> GITHUB </strong> </a>下载。</p><p id="415d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">首先:<br/> </strong>我们需要更改“/etc/docker/daemon.json”中的docker引擎配置文件，以添加几行代码来使用tls。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="5f1a" class="le lf iq la b gy lg lh l li lj">if [[ -e /etc/docker/daemon.json  ]]<br/>then<br/> <br/> cp /etc/docker/daemon.json /etc/docker/daemon.json.bk<br/> <br/> if [[ $(grep -ari 'tls' /etc/docker/daemon.json) ]]<br/> then</span><span id="8199" class="le lf iq la b gy lk lh l li lj">  echo "INFO: Probably your docker already has tls configuration"<br/>  echo "INFO: Please check /etc/docker/daemon.json, and ensure there isn't any tls configuration."</span><span id="0800" class="le lf iq la b gy lk lh l li lj">  rm -rf /etc/docker/daemon.json.bk<br/>  exit 0</span><span id="37d1" class="le lf iq la b gy lk lh l li lj"> else</span><span id="b5c0" class="le lf iq la b gy lk lh l li lj">  sed -i '2 i \"tls\": true,\n' /etc/docker/daemon.json<br/>  sed -i '2 i \"tlscacert\": \"/etc/docker/tls/ca.pem\",\n' /etc/docker/daemon.json<br/>  sed -i '2 i \"tlscert\": \"/etc/docker/tls/server-cert.pem\",\n' /etc/docker/daemon.json<br/>  sed -i '2 i \"tlskey\": \"/etc/docker/tls/server-key.pem\",\n' /etc/docker/daemon.json<br/>  sed -i '2 i \"tlsverify\": false,\n' /etc/docker/daemon.json</span><span id="7a7b" class="le lf iq la b gy lk lh l li lj"> fi<br/> <br/> if [[ ! $(grep -ari 'hosts' /etc/docker/daemon.json) ]]<br/> then</span><span id="a813" class="le lf iq la b gy lk lh l li lj">  sed -i '2 i \"hosts\": [\"fd://\",\"unix:///var/run/docker.sock\",\"tcp://0.0.0.0:2376\"],\n' /etc/docker/daemon.json </span><span id="d682" class="le lf iq la b gy lk lh l li lj"> fi</span><span id="652e" class="le lf iq la b gy lk lh l li lj">if [[ ! $(grep -ari 'live-restore' /etc/docker/daemon.json) ]]<br/> then</span><span id="6296" class="le lf iq la b gy lk lh l li lj">  sed -i '2 i \"live-restore\": true,\n' /etc/docker/daemon.json </span><span id="56e7" class="le lf iq la b gy lk lh l li lj"> fi</span><span id="e984" class="le lf iq la b gy lk lh l li lj">else</span><span id="e986" class="le lf iq la b gy lk lh l li lj">        echo -e "{\n  \"live-restore\": true,\n  \<br/>  \"hosts\": [\"fd://\",\"unix:///var/run/docker.sock\",\"tcp://0.0.0.0:2376\"],\n  \<br/>  \"tls\": true,\n  \<br/>  \"tlscacert\": \"/etc/docker/tls/ca.pem\",\n  \<br/>  \"tlscert\": \"/etc/docker/tls/server-cert.pem\",\n  \<br/>  \"tlskey\": \"/etc/docker/tls/server-key.pem\",\n  \<br/>  \"tlsverify\": false\n  \<br/>  }" &gt;&gt; /etc/docker/daemon.json</span><span id="12da" class="le lf iq la b gy lk lh l li lj">fi</span></pre><p id="d8b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">其次:<br/> </strong>我们应该根据docker主机IP地址为服务器、客户端和CA(证书颁发机构)创建密钥和证书，因为它是自签名的。</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="850e" class="le lf iq la b gy lg lh l li lj">### CA certificate                             <br/>openssl genrsa -out ca-key.pem 4096 &amp;&gt; /dev/null                             openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem -subj "/CN=$DOCKER_ADDRESS" &amp;&gt; /dev/null                                                           </span><span id="c8b4" class="le lf iq la b gy lk lh l li lj">### SERVER certificate                             <br/>openssl genrsa -out server-key.pem 4096 &amp;&gt; /dev/null                             openssl req -subj "/CN=$DOCKER_ADDRESS" -sha256 -new -key server-key.pem -out server.csr &amp;&gt; /dev/null                             </span><span id="3dba" class="le lf iq la b gy lk lh l li lj">echo subjectAltName = DNS:IP:127.0.0.1,IP:$DOCKER_ADDRESS &gt; extfile.cnf                             <br/>echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf                             </span><span id="b80e" class="le lf iq la b gy lk lh l li lj">openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem   -CAcreateserial -out server-cert.pem -extfile extfile.cnf &amp;&gt; /dev/null                                                           </span><span id="ed7c" class="le lf iq la b gy lk lh l li lj">### CLIENT certificate                             <br/>openssl genrsa -out key.pem 4096 &amp;&gt; /dev/null                             openssl req -subj '/CN=client' -new -key key.pem -out client.csr &amp;&gt; /dev/null                             </span><span id="0427" class="le lf iq la b gy lk lh l li lj">echo extendedKeyUsage = clientAuth &gt; extfile-client.cnf                             </span><span id="b323" class="le lf iq la b gy lk lh l li lj">openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem   -CAcreateserial -out cert.pem -extfile extfile-client.cnf &amp;&gt; /dev/null                                                           </span><span id="ae44" class="le lf iq la b gy lk lh l li lj">chmod 0400 ca-key.pem key.pem server-key.pem ca.pem server-cert.pem cert.pem</span></pre><p id="c1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最后:<br/> </strong>重启docker守护进程后，将客户端证书复制到“/etc/docker/tls/client”中你想要远程连接的地方。<br/>然后使用以下命令连接到docker守护程序:</p><pre class="kn ko kp kq gt kz la lb lc aw ld bi"><span id="fe1e" class="le lf iq la b gy lg lh l li lj">docker -H tcp://$(hostname -I|awk '{print $1}'):2376 --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem ps</span></pre><p id="2558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝贺你，现在你可以安全地连接到守护进程了。</p><p id="cc65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议使用脚本来实现TLS。</p><p id="f309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你今天过得愉快！</p></div></div>    
</body>
</html>