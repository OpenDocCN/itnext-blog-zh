<html>
<head>
<title>Experiments with Dart Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dart微服务实验</h1>
<blockquote>原文：<a href="https://itnext.io/experiments-with-dart-microservices-fa117aa408c7?source=collection_archive---------3-----------------------#2019-10-04">https://itnext.io/experiments-with-dart-microservices-fa117aa408c7?source=collection_archive---------3-----------------------#2019-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">减小容器尺寸的方法</h2></div><h1 id="6d7d" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">从颤振到飞镖</h1><p id="4927" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">像许多人一样，<a class="ae lt" href="https://www.adaptant.io" rel="noopener ugc nofollow" target="_blank">我们</a>是通过Flutter被引入Dart的，随着我们的应用程序复杂性的增长，我们逐渐发现有必要将应用程序端的逻辑剥离到热路径之外，这可以通过后端可用的专用微服务来更好地解决。</p><p id="80af" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">到目前为止，我们所有的后台微服务都是混合使用Golang和Python实现的。虽然我们知道Dart对服务器端应用程序开发的支持，但它并没有得到太多的关注。另一个挑战是，Flutter和Dart之间的确切界限并不总是很明显(正如我们发现的那样，<a class="ae lt" href="https://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub </a>上的许多插件标榜自己是Flutter插件，并添加了显式的Flutter依赖关系——包括在Flutter中模拟应用程序示例，而底层插件逻辑对Flutter没有实际的依赖关系)。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/4215af23abad0565f631fe78bc6c03eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTCR_WyQe-yi56orL8vKmQ.png"/></div></div></figure><p id="1a2c" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">最后，最惯用的方法似乎是:</p><ol class=""><li id="d2f8" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls mq mr ms mt bi translated">将相关的应用程序逻辑分离到一个库包中，该库包可由Flutter和Dart端应用程序直接使用；和</li><li id="136e" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">开发一个小的服务垫片，将一个简单的REST API封装在库包中，并处理其他基本的服务供应和工具问题(服务发现和注册、日志记录、健康检查、公开抓取指标等)。).</li></ol><h1 id="98c5" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">Dart运行时和容器化</h1><p id="1fc6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Google提供了许多Docker基本映像，以开始服务器端Dart应用程序的容器化。这些包括<a class="ae lt" href="https://hub.docker.com/r/google/dart-runtime" rel="noopener ugc nofollow" target="_blank"> google/dart-runtime </a>和<a class="ae lt" href="https://hub.docker.com/r/google/dart-runtime-base" rel="noopener ugc nofollow" target="_blank"> google/dart-runtime-base </a>图像。</p><h2 id="920d" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">最初集装箱化</h2><p id="eda1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们使用的初始Dockerfile只是对<code class="fe nl nm nn no b">google/dart-runtime</code>图像的扩展，允许参数传递到容器:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">带有JIT编译和参数传递的服务器端Dart应用程序的Dockerfile</figcaption></figure><p id="f7a2" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们的<a class="ae lt" href="https://github.com/adaptant-labs/vin-decoder-service" rel="noopener ugc nofollow" target="_blank"> VIN解码微服务</a>的初始版本(包括Dart运行时)重达220MB与我们在Golang世界中习惯的大约10MB的容器映像相去甚远！</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/c8cfeba440a7cf8cfe19bcaf7f5c23f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*pfHbCjPnR1nCQEtD0FUibg.png"/></div></figure><h2 id="b3ea" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">从JIT到AOT</h2><p id="1868" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">可以理解的是，JIT编译环境(包括Dart运行时的整体)的容器大小还有待改进。幸运的是，AOT编译已经被Flutter使用，并在Dart的早期版本中得到支持，从今年早些时候的Dart 2.3 SDK版本开始，它已经被重新使用并以<code class="fe nl nm nn no b">dart2aot</code>二进制文件的形式重新引入(在下面的GitHub问题中提到):</p><ul class=""><li id="c057" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls nw mr ms mt bi translated"><a class="ae lt" href="https://github.com/dart-lang/sdk/issues/34343#issuecomment-490958724" rel="noopener ugc nofollow" target="_blank">https://github . com/dart-lang/SDK/issues/34343 # issue comment-490958724</a></li></ul><p id="2822" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">因此，第一步是从JIT转换到AOT编译，以便通过多阶段构建尽可能多地丢弃运行时。顺便提一下，我们并不是第一个有这种想法的人，我们在下面的GitHub gist中偶然发现了一个概念证明:</p><ul class=""><li id="e7a4" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls nw mr ms mt bi translated"><a class="ae lt" href="https://gist.github.com/renatoathaydes/10598c963ba10e48501795e8e1bdf2b1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/renatothaydes/10598 c 963 ba 10 e 48501795 e 8 E1 BDF 2 b 1</a>:</li></ul><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">具有AOT编译的服务器端Dart应用程序的多级docker文件</figcaption></figure><p id="aa65" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">使用这种方法，得到的容器映像降低到稍微容易接受的75MB——这是一个好的开始，但仍然不够好。</p><h2 id="2b2d" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">从AOT到本土</h2><p id="900d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">剩下的运行时工件现在仅限于<code class="fe nl nm nn no b">server.aot</code>二进制文件、<code class="fe nl nm nn no b">dartaotruntime</code>二进制文件，以及由<code class="fe nl nm nn no b">bitnami/minideb</code>映像提供的一组最小的必需共享库:</p><pre class="ma mb mc md gt nx no ny nz aw oa bi"><span id="0c0b" class="mz kg iq no b gy ob oc l od oe">$ ls -la server.aot<br/>-rw-rw-r-- 1 pmundt pmundt 3838560 Oct  4 10:25 server.aot<br/>$ ls -la `which dartaotruntime`<br/>-rwxr-xr-x 1 root root 4781944 Sep 26 10:02 /usr/lib/dart/bin/dartaotruntime</span></pre><p id="d1e9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">许多人已经表达了对单一组合二进制文件的兴趣，下面的GitHub问题跟踪了这方面的进展:</p><ul class=""><li id="3efc" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls nw mr ms mt bi translated"><a class="ae lt" href="https://github.com/dart-lang/sdk/issues/36915" rel="noopener ugc nofollow" target="_blank">https://github.com/dart-lang/sdk/issues/36915</a></li></ul><p id="0c01" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这导致了编译的<code class="fe nl nm nn no b">dart2native</code>模式的发展，该模式能够产生集成的共享二进制文件，而不再依赖于Dart运行时环境:</p><pre class="ma mb mc md gt nx no ny nz aw oa bi"><span id="4a92" class="mz kg iq no b gy ob oc l od oe">$ dart2native bin/server.dart -o server<br/>Generated: /home/pmundt/devel/git/vin-decoder-service/server<br/>$ ls -la server<br/>-rwxrwxr-x 1 pmundt pmundt 8622704 Oct  4 10:31 server<br/>$ ldd server<br/>    linux-vdso.so.1 (0x00007ffcb0de2000)<br/>    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff826bb3000)<br/>    /lib64/ld-linux-x86-64.so.2 (0x00007ff8273ff000)<br/>    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007ff826a65000)<br/>    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007ff826a44000)<br/>    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007ff826a3e000)</span></pre><p id="b8f7" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">虽然单二进制编译并没有为我们节省任何映像大小，但是对Dart运行时组件依赖性的放松意味着我们现在可以更积极地剥离最终的容器。</p><h2 id="7f4a" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">使用Alpine进一步减少集装箱</h2><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi of"><img src="../Images/0459c5439ab61f30306d806b1272dc0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AU4MjCTaAK49F5b1a72zoA.png"/></div></div></figure><p id="45ed" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">虽然<code class="fe nl nm nn no b">bitnami/minideb</code>基础图给了我们一个合理的开始基础，但最终的容器仍然太大。由于我们现在只有一个带<code class="fe nl nm nn no b">dart2native</code>编译的二进制文件，没有额外的依赖项，我们可以使用Alpine提供的一个最小的glibc环境来进一步降低这个要求:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">使用Alpine为服务器端Dart应用程序提供多级Dockerfile和本机编译</figcaption></figure><p id="2760" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们现在的最终结果是一个只有20MB的容器——比我们开始时大了一个数量级。还不错！</p><h2 id="fa01" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">后续步骤</h2><p id="a8a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在剩下的最后一个障碍是:</p><ul class=""><li id="0859" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls nw mr ms mt bi translated">由<code class="fe nl nm nn no b">dart2native</code>构建器生成静态链接的二进制文件，这将允许我们切换到<code class="fe nl nm nn no b">scratch</code>映像，并丢弃容器中剩余的支持库/二进制文件——这将缩小与Golang容器的大小差距；和</li><li id="7f28" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls nw mr ms mt bi translated">功能<code class="fe nl nm nn no b">strip</code> -ping生成的原生ELF二进制文件——目前的实验是剥离调试符号、矮化DWO对象或<code class="fe nl nm nn no b">.eh_frame</code>破坏生成的二进制文件。理论上，Dart VM中的堆栈展开在功能上不应该依赖于DWARF CFI，尽管这无疑需要Dart内部更有能力的人进行进一步的调查。</li></ul><h2 id="3085" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">性能呢？</h2><p id="eb53" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然我们几乎主要关注大小，但我们还没有提到任何关于性能的内容，或者更具体地说，不同编译模式对应用程序运行时性能的影响。这是我们目前正在评估的事情之一，作为我们在<a class="ae lt" href="https://sodalite.eu/" rel="noopener ugc nofollow" target="_blank">方钠石</a>项目中工作的一部分，并计划在不久的将来有一个关于此事的后续博客。</p><h2 id="6db6" class="mz kg iq bd kh na nb dn kl nc nd dp kp lg ne nf kr lk ng nh kt lo ni nj kv nk bi translated">结论</h2><p id="08a5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑到容器的大小，通过精心制作docker文件和剥离运行时环境，服务器端Dart应用程序可以以可管理的大小进入现实世界的部署。</p><p id="70a8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这仍然是一个持续发展的领域，我们完全期待取得进一步的进展，特别是随着服务器端Dart的其他用例开始出现(例如，作为FaaS函数的语言运行时，这也是我们正在积极研究的领域)。</p></div></div>    
</body>
</html>