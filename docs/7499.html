<html>
<head>
<title>Different test scopes in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铁锈的不同测试范围</h1>
<blockquote>原文：<a href="https://itnext.io/different-test-scopes-in-rust-6a5fc87472af?source=collection_archive---------0-----------------------#2022-10-12">https://itnext.io/different-test-scopes-in-rust-6a5fc87472af?source=collection_archive---------0-----------------------#2022-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8f149f52bdbde517114be3d2bb29d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xu0-fM4MulehIKRY3SWn8A.jpeg"/></div></div></figure><p id="2087" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还在学Rust。除了句法，学习一门语言需要熟悉它的习惯用法和生态系统。我现在想探索Rust中的测试。</p><h1 id="d9e2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最初的问题</h1><p id="954e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们已经在JVM上使用依赖注入<em class="lz">很多年了。即使您没有使用框架，依赖注入也有助于分离组件。这里有一个基本的例子:</em></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b06a" class="mj kx iq mf b gy mk ml l mm mn">class Car(private val engine: Engine) {</span><span id="ea71" class="mj kx iq mf b gy mo ml l mm mn">    fun start() {<br/>        engine.start()<br/>    }<br/>}</span><span id="2924" class="mj kx iq mf b gy mo ml l mm mn">interface Engine {<br/>    fun start()<br/>}</span><span id="3d13" class="mj kx iq mf b gy mo ml l mm mn">class CarEngine(): Engine {<br/>    override fun start() = ...<br/>}</span><span id="dfcf" class="mj kx iq mf b gy mo ml l mm mn">class TestEngine(): Engine {<br/>    override fun start() = ...<br/>}</span></pre><p id="7363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在常规代码中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a010" class="mj kx iq mf b gy mk ml l mm mn">val car = Car(CarEngine())</span></pre><p id="d73b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在测试代码中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6ef2" class="mj kx iq mf b gy mk ml l mm mn">val dummy = Car(TestEngine())</span></pre><p id="ef72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DI是根据上下文执行不同的代码片段。</p><h1 id="baa4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">生锈测试</h1><p id="8430" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Rust与Kotlin方法有两点不同:</p><ul class=""><li id="ac2c" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">大多数DI框架发生在运行时，Dagger 2是我所知道的唯一例外。Rust专注于编译时。</li><li id="a178" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">Rust不是面向对象的</li></ul><p id="d3ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这两个原因，我们不能复制上述方法。然而，Rust擅长宏。对于测试，它提供了<code class="fe nd ne nf mf b">test</code>宏。</p><blockquote class="ng nh ni"><p id="e917" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq">要将一个函数更改为测试函数，在fn前的行上添加</em> <code class="fe nd ne nf mf b"><em class="iq">#[test]</em></code> <em class="iq">。当您使用</em> <code class="fe nd ne nf mf b"><em class="iq">cargo test</em></code> <em class="iq">命令运行测试时，Rust会构建一个运行带注释的函数的测试运行器二进制文件，并报告每个测试函数是通过还是失败。</em></p><p id="d41c" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq">——</em>——<a class="ae nm" href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#the-anatomy-of-a-test-function" rel="noopener ugc nofollow" target="_blank">——<em class="iq">解剖测试功能</em>——</a></p></blockquote><p id="f8b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最基本的层面上，它允许定义测试函数。这些功能仅在调用<code class="fe nd ne nf mf b">cargo test</code>时有效:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e593" class="mj kx iq mf b gy mk ml l mm mn">fn main() {<br/>    println!("{}", hello());<br/>}</span><span id="959b" class="mj kx iq mf b gy mo ml l mm mn">fn hello() -&gt; &amp;'static str {<br/>    return "Hello world";<br/>}</span><span id="02e4" class="mj kx iq mf b gy mo ml l mm mn">#[test]<br/>fn test_hello() {<br/>    assert_eq!(hello(), "Hello world");<br/>}</span></pre><p id="1cdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nd ne nf mf b">cargo run</code>产量如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="da68" class="mj kx iq mf b gy mk ml l mm mn">Hello world</span></pre><p id="f220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，<code class="fe nd ne nf mf b">cargo run</code>产量:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="28e5" class="mj kx iq mf b gy mk ml l mm mn">running 1 test<br/>test test_hello ... ok</span><span id="a6c9" class="mj kx iq mf b gy mo ml l mm mn">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s<br/></span><span id="6267" class="mj kx iq mf b gy mo ml l mm mn">running 0 tests</span><span id="6baf" class="mj kx iq mf b gy mo ml l mm mn">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.01s</span></pre><p id="4622" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们的主要问题是不同的:我们想根据它是否是一个测试环境来编码。</p><p id="4fdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nd ne nf mf b">test</code>宏不是我们要找的解决方案。</p><h1 id="f077" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用<code class="fe nd ne nf mf b">cfg</code>宏</h1><p id="4c0e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Rust区分了“单元”测试和“集成”测试。我加了双引号，因为我认为语义可能会误导人。他们的意思是:</p><ul class=""><li id="aec2" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">单元测试与主测试写在同一个文件中。您用<code class="fe nd ne nf mf b">#[test]</code>宏对它们进行注释，并调用<code class="fe nd ne nf mf b">cargo test</code>，如上所示</li><li id="d427" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">集成测试在要测试的代码之外。您可以用<code class="fe nd ne nf mf b">#[cfg(test)]</code>宏注释代码作为集成测试的一部分。</li></ul><p id="1fa9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入<code class="fe nd ne nf mf b">cfg</code>宏:</p><blockquote class="ng nh ni"><p id="920d" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq">在编译时评估配置标志的布尔组合。</em></p><p id="409a" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq">除了</em> <code class="fe nd ne nf mf b"><em class="iq">#[cfg]</em></code> <em class="iq">属性，该宏还允许配置标志的布尔表达式评估。这通常会减少重复代码。</em></p><p id="7e9d" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae nm" href="https://doc.rust-lang.org/std/macro.cfg.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">宏标准::cfg </em> </a></p></blockquote><p id="ad4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nd ne nf mf b">cfg</code>宏提供了许多现成的配置变量:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/cdd0b7fdf903946ab4aa8b8ea5e123ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir54Nnuol_qwluLVckZ95A.png"/></div></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/a309308b5b128d4b4a0abd1a09bab1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*895ZQU2EvbF4F7_mhPbmgA.png"/></div></div></figure><p id="6212" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到了众多变量中的<code class="fe nd ne nf mf b">test</code>旗。要编写集成测试，用<code class="fe nd ne nf mf b">#[cfg(test)]</code>宏注释代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="14e5" class="mj kx iq mf b gy mk ml l mm mn">#[cfg(test)]<br/>fn test_something() {<br/>    // Whatever<br/>}</span></pre><p id="db0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也可以使用宏在<code class="fe nd ne nf mf b">test</code>上下文中提供替代代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a7b7" class="mj kx iq mf b gy mk ml l mm mn">fn hello() -&gt; &amp;'static str {<br/>    return "Hello world";<br/>}</span><span id="fda8" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(test)]<br/>fn hello() -&gt; &amp;'static str {<br/>    return "Hello test";<br/>}</span></pre><p id="828e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的片段在<code class="fe nd ne nf mf b">cargo run</code>期间有效，但在<code class="fe nd ne nf mf b">cargo test</code>期间无效。在第一种情况下，第二个函数被忽略；在第二种情况下，它不是，Rust试图用相同的签名编译两个函数。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8943" class="mj kx iq mf b gy mk ml l mm mn">error[E0428]: the name `hello` is defined multiple times<br/>  --&gt; src/lib.rs:10:1<br/>   |<br/>5  | fn hello() -&gt; &amp;'static str {<br/>   | -------------------------- previous definition of the value `hello` here<br/>...<br/>10 | fn hello() -&gt; &amp;'static str {<br/>   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ `hello` redefined here<br/>   |<br/>   = note: `hello` must be defined only once in the value namespace of this module</span></pre><p id="8e22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，<code class="fe nd ne nf mf b">cfg</code>宏提供了布尔逻辑。因此，我们可以否定第一个函数的<code class="fe nd ne nf mf b">test</code>配置:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="57d3" class="mj kx iq mf b gy mk ml l mm mn">fn main() {<br/>    println!("{}", hello());<br/>}</span><span id="4279" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(not(test))]<br/>fn hello() -&gt; &amp;'static str {<br/>    return "Hello world";<br/>}</span><span id="0d50" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(test)]<br/>fn hello() -&gt; &amp;'static str {<br/>    return "Hello test";<br/>}</span><span id="6033" class="mj kx iq mf b gy mo ml l mm mn">#[test]<br/>fn test_hello() {<br/>    assert_eq!(hello(), "Hello test");<br/>}</span></pre><ul class=""><li id="4a41" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><code class="fe nd ne nf mf b">cargo run</code>产量<code class="fe nd ne nf mf b">Hello world</code></li><li id="67f2" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><code class="fe nd ne nf mf b">cargo test</code> <em class="lz">编译</em>然后成功执行测试</li></ul><p id="1d61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然它解决了我们的问题，但它有明显的缺陷:</p><ul class=""><li id="4781" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">它是二进制的——测试上下文与否</li><li id="6e05" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">它不可伸缩:在特定的规模之后，大量的注释将使项目难以管理</li></ul><h1 id="a2b6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">完善设计</h1><p id="b292" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了改进设计，让我们想象一个我在JVM上多次遇到的简单场景:</p><ul class=""><li id="10ed" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">在常规运行期间，代码连接到生产数据库，<em class="lz">，例如</em>，Postgres</li><li id="e85d" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">对于集成测试，代码使用本地数据库<em class="lz">，例如</em>，SQLite</li><li id="e4fa" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">对于单元测试，代码不使用数据库，而是使用模拟</li></ul><p id="a477" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是设计的基础:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="deba" class="mj kx iq mf b gy mk ml l mm mn">fn main() {<br/>    // Get a database implementation                          // 1<br/>    db.do_stuff();<br/>}</span><span id="cd47" class="mj kx iq mf b gy mo ml l mm mn">trait Database {<br/>    fn doStuff(self: Self);<br/>}</span><span id="9698" class="mj kx iq mf b gy mo ml l mm mn">struct MockDatabase {}<br/>struct SqlitDatabase {}<br/>struct PostgreSqlDatabase {}</span><span id="d240" class="mj kx iq mf b gy mo ml l mm mn">impl Database for MockDatabase {<br/>    fn doStuff(self: Self) {<br/>        println!("Do mock stuff");<br/>    }<br/>}</span><span id="cfc7" class="mj kx iq mf b gy mo ml l mm mn">impl Database for SqlitDatabase {<br/>    fn doStuff(self: Self) {<br/>        println!("Do stuff with SQLite");<br/>    }<br/>}<br/></span><span id="ff99" class="mj kx iq mf b gy mo ml l mm mn">impl Database for PostgreSqlDatabase {<br/>    fn doStuff(self: Self) {<br/>        println!("Do stuff with PostgreSQL");<br/>    }<br/>}</span></pre><ol class=""><li id="44e5" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv np mv mw mx bi translated">如何根据上下文得到正确的实现？</li></ol><p id="1112" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有三个上下文，而<code class="fe nd ne nf mf b">cfg[test]</code>只提供了一个布尔标志。是时候采用新的方法了。</p><h1 id="6907" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">利用货物特征</h1><p id="ffd3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当我寻找解决方案时，我在Rust Slack频道上询问。威廉·狄龙很友好地回答了这个问题，并建议我看看货物的特征。</p><blockquote class="ng nh ni"><p id="cd2e" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq"> Cargo“特征”提供了一种表达条件编译和可选依赖的机制。一个包在</em> <code class="fe nd ne nf mf b"><em class="iq">Cargo.toml</em></code> <em class="iq">的</em> <code class="fe nd ne nf mf b"><em class="iq">[features]</em></code> <em class="iq">表中定义了一组命名的特性，每个特性可以被启用或禁用。正在构建的包的特性可以在命令行上使用标志来启用，例如</em> <code class="fe nd ne nf mf b"><em class="iq">--features</em></code> <em class="iq">。在</em> <code class="fe nd ne nf mf b"><em class="iq">Cargo.toml</em></code> <em class="iq">的依赖关系声明中可以启用依赖关系的特性。</em></p><p id="e3a1" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae nm" href="https://doc.rust-lang.org/cargo/reference/features.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">特征</em> </a></p></blockquote><h1 id="a11f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义特征</h1><p id="c734" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">第一步是定义我们将使用什么功能。在<code class="fe nd ne nf mf b">Cargo.toml</code>文件中配置它们:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4573" class="mj kx iq mf b gy mk ml l mm mn">[features]<br/>unit = []<br/>it = []<br/>prod = []</span></pre><h1 id="553d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用代码中的功能</h1><p id="7712" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了使用该功能，我们利用了<code class="fe nd ne nf mf b">cfg</code>宏:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="41dc" class="mj kx iq mf b gy mk ml l mm mn">fn main() {<br/>    #[cfg(feature = "unit")]                   // 1<br/>    let db = MockDatabase {};<br/>    #[cfg(feature = "it")]                     // 2<br/>    let db = SqlitDatabase {};<br/>    #[cfg(feature = "prod")]                   // 3<br/>    let db = PostgreSqlDatabase {};<br/>    db.do_stuff();<br/>}</span><span id="71e5" class="mj kx iq mf b gy mo ml l mm mn">trait Database {<br/>    fn do_stuff(self: Self);<br/>}</span><span id="e161" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(feature = "unit")]                       // 1<br/>struct MockDatabase {}</span><span id="0e88" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(feature = "unit")]                       // 1<br/>impl Database for MockDatabase {<br/>    fn do_stuff(self: Self) {<br/>        println!("Do mock stuff");<br/>    }<br/>}</span><span id="e2d5" class="mj kx iq mf b gy mo ml l mm mn">// Abridged for brevity's sake                 // 2-3</span></pre><ol class=""><li id="7a5b" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv np mv mw mx bi translated">仅在激活<code class="fe nd ne nf mf b">unit</code>功能时编译</li><li id="3a6b" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv np mv mw mx bi translated">仅在激活<code class="fe nd ne nf mf b">it</code>功能时编译</li><li id="9688" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv np mv mw mx bi translated">仅在激活<code class="fe nd ne nf mf b">prod</code>功能时编译</li></ol><h1 id="b939" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">激活功能</h1><p id="fff6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您必须使用<code class="fe nd ne nf mf b">-F</code>标志来激活一个功能。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="66be" class="mj kx iq mf b gy mk ml l mm mn">cargo run -F unit</span><span id="761d" class="mj kx iq mf b gy mo ml l mm mn">Do mock stuff</span></pre><h1 id="209b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">默认功能</h1><p id="a4ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">“生产”特性应该是最简单的。因此，默认设置它是至关重要的。</p><p id="734d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它在过去咬了我一口:当你的同事休假，而你需要构建/部署时，阅读代码以理解哪些标志是强制性的是一片混乱。</p><p id="cf41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rust允许设置默认功能。它们不需要被激活；默认情况下，它们是打开的。神奇的事情发生在<code class="fe nd ne nf mf b">Cargo.toml</code>文件中。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5486" class="mj kx iq mf b gy mk ml l mm mn">[features]<br/>default = ["prod"]                             # 1<br/>unit = []<br/>it = []<br/>prod = []</span></pre><ol class=""><li id="496a" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv np mv mw mx bi translated"><code class="fe nd ne nf mf b">prod</code>功能被设置为默认</li></ol><p id="fc56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以运行程序，而无需显式设置<code class="fe nd ne nf mf b">prod</code>功能:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d413" class="mj kx iq mf b gy mk ml l mm mn">cargo run</span><span id="4493" class="mj kx iq mf b gy mo ml l mm mn">Do stuff with PostgreSQL</span></pre><h1 id="9cd3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">独家功能</h1><p id="eb95" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这三个功能都是互斥的:一次只能激活一个。要禁用默认标志，我们需要一个额外的标志:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a64e" class="mj kx iq mf b gy mk ml l mm mn">cargo run --no-default-features -F unit</span><span id="5282" class="mj kx iq mf b gy mo ml l mm mn">Do mock stuff</span></pre><p id="94d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该文档提供了避免同时激活独占功能的多种方法:</p><blockquote class="ng nh ni"><p id="fec9" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated">在极少数情况下，功能可能会互相不兼容。如果可能的话，应该避免这种情况，因为它需要在依赖图中协调包的所有使用，以避免同时启用它们。如果不可能，考虑添加一个编译错误来检测这种情况。</p><p id="e1c4" class="jy jz lz ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq"> — </em> <a class="ae nm" href="https://doc.rust-lang.org/cargo/reference/features.html#mutually-exclusive-features" rel="noopener ugc nofollow" target="_blank"> <em class="iq">互斥特性</em> </a></p></blockquote><p id="d449" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="70b5" class="mj kx iq mf b gy mk ml l mm mn">#[cfg(all(feature = "unit", feature = "it"))]<br/>compile_error!("feature \"unit\" and feature \"it\" cannot be enabled at the same time");<br/>#[cfg(all(feature = "unit", feature = "prod"))]<br/>compile_error!("feature \"unit\" and feature \"prod\" cannot be enabled at the same time");<br/>#[cfg(all(feature = "it", feature = "prod"))]<br/>compile_error!("feature \"it\" and feature \"prod\" cannot be enabled at the same time");</span></pre><p id="a0e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们试图在默认的<code class="fe nd ne nf mf b">prod</code>功能启用时使用<code class="fe nd ne nf mf b">unit</code>功能运行:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c546" class="mj kx iq mf b gy mk ml l mm mn">cargo run -F unit</span><span id="9279" class="mj kx iq mf b gy mo ml l mm mn">error: feature "unit" and feature "prod" cannot be enabled at the same time<br/> --&gt; src/main.rs:4:1<br/>  |<br/>4 | compile_error!("feature \"unit\" and feature \"prod\" cannot be enabled at the same time");<br/>  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></pre><h1 id="f060" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">修复上述设计</h1><p id="6550" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面的设计没有那么轻微的误导。在测试中，入口点不是<code class="fe nd ne nf mf b">main</code>函数，而是测试函数本身。</p><p id="ab18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们像在初始阶段一样重新添加一些测试。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="058b" class="mj kx iq mf b gy mk ml l mm mn">#[cfg(feature = "prod")]                            // 1<br/>fn main() {<br/>    let db = PostgreSqlDatabase {};<br/>    println!("{}", db.do_stuff());<br/>}</span><span id="f849" class="mj kx iq mf b gy mo ml l mm mn">trait Database {<br/>    fn do_stuff(self: Self) -&gt; &amp;'static str;        // 2<br/>}</span><span id="dbe7" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(feature = "unit")]<br/>struct MockDatabase {}<br/>#[cfg(feature = "prod")]<br/>struct PostgreSqlDatabase {}</span><span id="07c4" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(feature = "unit")]<br/>impl Database for MockDatabase {<br/>    fn do_stuff(self: Self) -&gt; &amp;'static str {<br/>        "Do mock stuff"<br/>    }<br/>}</span><span id="5b37" class="mj kx iq mf b gy mo ml l mm mn">#[cfg(feature = "prod")]<br/>impl Database for PostgreSqlDatabase {<br/>    fn do_stuff(self: Self) -&gt; &amp;'static str {<br/>        "Do stuff with PostgreSQL"<br/>    }<br/>}</span><span id="844a" class="mj kx iq mf b gy mo ml l mm mn">#[test]<br/>#[cfg(feature = "unit")]<br/>fn test_unit() {<br/>    let db = MockDatabase {};<br/>    assert_eq!(db.do_stuff(), "Do mock stuff");     // 3<br/>}</span><span id="45b0" class="mj kx iq mf b gy mo ml l mm mn">// it omitted for brevity</span></pre><ol class=""><li id="8fc7" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv np mv mw mx bi translated">当任何测试功能被激活时，<code class="fe nd ne nf mf b">PostgreSqlDatabase</code>结构不可用</li><li id="f3b5" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv np mv mw mx bi translated">更改签名以便能够测试</li><li id="3d29" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv np mv mw mx bi translated">测试！</li></ol><p id="fed8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们可以运行不同的命令:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="de4b" class="mj kx iq mf b gy mk ml l mm mn">cargo test --no-default-features -F unit            #1<br/>cargo test --no-default-features -F it              #2<br/>cargo run                                           #3</span></pre><ol class=""><li id="275b" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv np mv mw mx bi translated">运行单元测试</li><li id="7ac3" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv np mv mw mx bi translated">运行“集成测试”测试</li><li id="454a" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv np mv mw mx bi translated">运行应用程序</li></ol><h1 id="01d4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="fda1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这篇文章中，我描述了由不同的测试套件引起的问题，关注不同的范围。默认的<code class="fe nd ne nf mf b">test</code>配置变量是二进制的:要么作用域是<code class="fe nd ne nf mf b">test</code>，要么不是。当一个人需要在单元测试和集成测试之间进行分离时，这是不够的，每一个都需要不同的特征实现。</p><p id="b619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rust的特性是解决这个问题的一种方法。一个特性允许保护标签后面的一些代码，这可以在命令行上每次运行时启用。</p><p id="824d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">老实说，我不知道Rust特性是否是实现不同测试范围的正确方法。无论如何，它是有效的，让我更好地理解了Rust生态系统。</p><p id="d87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的完整源代码可以在<a class="ae nm" href="https://github.com/ajavageek/rust-test-suites" rel="noopener ugc nofollow" target="_blank"> GitHub </a>找到。</p><p id="210c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="3df8" class="mp mq iq ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated"><a class="ae nm" href="https://doc.rust-lang.org/book/ch11-00-testing.html" rel="noopener ugc nofollow" target="_blank">生锈测试</a></li><li id="4fc1" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><a class="ae nm" href="https://doc.rust-lang.org/rust-by-example/testing.html" rel="noopener ugc nofollow" target="_blank">生锈示例:测试</a></li><li id="7625" class="mp mq iq ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated"><a class="ae nm" href="https://doc.rust-lang.org/reference/conditional-compilation.html" rel="noopener ugc nofollow" target="_blank">有条件编译</a></li></ul></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="6264" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lz">原载于</em> <a class="ae nm" href="https://blog.frankel.ch/different-test-scopes-rust/" rel="noopener ugc nofollow" target="_blank"> <em class="lz">一个Java极客</em></a><em class="lz">2022年10月9日</em></p></div></div>    
</body>
</html>