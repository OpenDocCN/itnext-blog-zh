<html>
<head>
<title>Creating an infinite grid on iOS — Using UICollectionView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS上创建无限网格—使用UICollectionView</h1>
<blockquote>原文：<a href="https://itnext.io/infinite-grid-using-uicollectionview-155801e4f7f4?source=collection_archive---------1-----------------------#2018-08-21">https://itnext.io/infinite-grid-using-uicollectionview-155801e4f7f4?source=collection_archive---------1-----------------------#2018-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6de6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为我之前教程《在iOS上创建无限网格》的后续:<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/creating-an-infinite-grid-on-ios-2bd6db28c581">https://it next . io/Creating-an-infinite-grid-on-iOS-2 BD 6 db 28 c 581</a>；根据用户的评论，我决定看看是否有可能使用UICollectionView来做同样的事情。</p><p id="3d16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一些华丽的失败之后(试图在iPhone上使用50.5GB的内存不可能顺利)，我设法让示例代码只使用76MB的内存运行。</p><h1 id="4bec" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">重新定义要求:</h1><ul class=""><li id="a940" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">必须只使用UIKit本机类</li><li id="3aa1" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">滚动应该有预期的滚动视图的感觉</li><li id="d50a" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">用户必须有这样的印象，他们可以永远滚动</li><li id="1248" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">必须是内存高效的</li><li id="39ef" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">内容必须以平铺方式生成，以便构建网格</li><li id="6650" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">初始坐标应该是可指定的</li><li id="a8a8" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">EXTRA:必须使用UICollectionView</li><li id="ed3e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">额外:每个网格图块必须是UICollectionViewCell</li><li id="5b1d" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">EXTRA: UICollectionViewCell分配/取消分配必须由UICollectionView管理，并且可重用</li></ul><h1 id="7be4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">了解更新的约束条件:</h1><p id="fc65" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">根据之前的教程，我们有一些防止我们变得太野的因素:</p><ul class=""><li id="0749" class="lk ll iq jp b jq jr ju jv jy md kc me kg mf kk lr ls lt lu bi translated">UICollectionView在必须“重新加载数据”之前，需要有限的一组节和每个节的项</li><li id="1166" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">指定大量的部分，每个部分包含大量的项目，这需要太多的内存，并且不适合无限网格实现</li><li id="b22e" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">默认情况下，UICollectionView将只水平或垂直滚动，在两个轴上滚动将需要一个自定义的UICollectionViewLayout</li><li id="7049" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">UICollectionView是UIScrollView的子类，因此当用户到达边缘时，视图会停止或反弹；我们需要无限滚动</li></ul><h1 id="7877" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">入门，设置UICollectionView</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/c5303437355c5ca38814b43d0ebf77de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_0g8E19aCwZzEX0ZYUQZQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Xcode项目—单视图应用程序</figcaption></figure><p id="b1fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从一个“单一视图”iOS应用程序开始，我们将创建一个名为<strong class="jp ir"> InfiniteGrid </strong>的自定义UICollectionView类:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGrid.swift —基本文件</figcaption></figure><p id="51b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后更新基本视图控制器来初始化我们的空网格:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi my"><img src="../Images/33aba3606cd7d15406342226e1e643a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*NlSd_xwThd3nbwuzIb_3Lw.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">基本应用程序-还没有看到什么！</figcaption></figure><p id="129b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还没什么好看的。您可以通过更改InfiniteGrid.swift第8行中的背景颜色来确认UICollectionView是否正确托管。</p><h1 id="4f42" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">注册和显示单元格</h1><p id="8d5f" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">现在让我们来定义我们细胞的基础。为此，我们将匹配上一个教程的设计，它只是显示一个带有坐标的UILabel。首先，让我们定义<strong class="jp ir"> GridCoordinates </strong>数据类型:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">GridCoordinates.swift —基础和最终实施</figcaption></figure><p id="2cd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的教程中，<strong class="jp ir"> GridCoordinates </strong>数据类型将被用来表示网格块的x，y坐标。接下来是UICollectionViewCell子类，它在标签上显示GridCoordinates:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGridCell.swift —基础和最终实施</figcaption></figure><p id="a286" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一些可能需要解释的代码。</p><ul class=""><li id="1fc0" class="lk ll iq jp b jq jr ju jv jy md kc me kg mf kk lr ls lt lu bi translated"><strong class="jp ir">infinitegridcell . register(with:)</strong>可用于向集合视图注册单元，以便我们稍后可以轻松地将其出队</li><li id="6813" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir">infinitegridcell . dequeue(…)</strong>允许从集合视图中轻松地将单元出队，并设置坐标以显示在单元上。</li><li id="e0bd" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir"> coordinatesLabel() </strong>函数用于在代码中实例化一个UILabel或访问一个先前创建的UILabel。</li><li id="e42a" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir"> coordinates </strong>变量保存与该网格单元相关联的坐标，并在更新时用文本表示自动更新标签。</li></ul><p id="3930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们为集合视图创建一个临时数据源，这样我们就可以显示单元格并确认该部分工作。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGridDataSource.swift显示一个单元格</figcaption></figure><p id="dd57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并更新InfiniteGrid.swift来定义数据源和注册单元:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGrid.swift —更新了单元注册和数据源</figcaption></figure><p id="df5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行我们的应用程序，我们现在可以确认单元格显示了一个标签，指示我们的数据源中指定的坐标:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi my"><img src="../Images/81e5c35a424c2808f28f7e5acc3fd98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*gLioIjSyqdyDfQE6X0WDSA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">应用程序屏幕截图-在左上角显示一个单元格</figcaption></figure><p id="f08d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据截图，我们可以看到在InfiniteGridDataSource.swift第12行中指定的坐标3，-2。</p><h1 id="fb39" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">引入自定义UICollectionViewLayout</h1><p id="4eac" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了让我们的解决方案工作，我们需要提供一个自定义的UICollectionViewLayout，它将允许用户垂直和水平滚动。作为第一步，让我们定义一个任意大的网格工作区，并在其中心放置一个单元格:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGridLayout.swift基本布局文件</figcaption></figure><p id="3b01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在将更新<strong class="jp ir"> InfiniteGrid </strong>以使用我们的自定义布局:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGrid.swift使用InfiniteGridLayout更新</figcaption></figure><p id="8244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第8行通过用自定义的<strong class="jp ir"> InfiniteGridLayout() </strong>替换UICollectionViewFlowLayout()进行了更新。</p><p id="35f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还添加了一个<strong class="jp ir"> scrollToCenter() </strong>，可以随时调用它来重新聚焦到网格工作区的中心。更新ViewController以确保网格以viewDidAppear为中心:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">ViewController.swift —添加了scrollToCenter()</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi my"><img src="../Images/4efc7d5e52b20fca1fe175fcb115958a.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*vWIkCiBn3sGenhpDNjzR_Q.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">应用程序屏幕截图-显示基础InfiniteGridLayout使用情况</figcaption></figure><h1 id="94bc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">添加我们的网格</h1><p id="bea5" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">到目前为止，我们使用3，-2作为坐标显示在我们的演示网格单元上，当我们开始构建完整的网格时，我们将使用0，0作为中心，因为这样更容易确认正确的实现。</p><p id="e571" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为第一步，让我们为无限网格定义一个中心坐标:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGrid.swift中心坐标</figcaption></figure><p id="6ead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要更新<strong class="jp ir"> InfiniteGridDataSource </strong>来保存一个与<strong class="jp ir"> GridCoordinates </strong>相匹配的IndexPath的本地缓存，以及将单元格出队并分配适当的坐标:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGridDataSource.swift —网格坐标跟踪的索引路径</figcaption></figure><p id="cb1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第4行，我们为我们的<strong class="jp ir"> pathsCacheSize </strong>赋值，虽然确切的值并不重要，但它应该大于UICollectionView在任何时间点缓存的单元格数。如果该值太小，某些单元格在滚动时将无法正常显示。</p><p id="0441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> assignPath(to:) </strong>函数为IndexPath记录一个<strong class="jp ir"> GridCoordinates </strong>，这样就可以在<strong class="jp ir">collection view(:cellForItemAt:)中检索它。</strong></p><p id="4f8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第27行做了一些索引魔术，将pathsCacheIndex增加到下一个IndexPath，并确保它在pathsCacheSize递增后换行到0。%执行模除— <em class="mz">抱歉，我忍不住在这里做了一个小小的优化！</em></p><p id="5d48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要实现<strong class="jp ir"> InfiniteGridLayout </strong>计算:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGridLayout.swift网格布局计算</figcaption></figure><p id="4c81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UICollectionView调用<strong class="jp ir">layoutAttributesForElements(in:)</strong>函数，我们计算矩形原点和相对端的坐标，然后返回每个网格单元的UICollectionViewLayoutAttributes列表。</p><p id="779d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我们如何使用<strong class="jp ir">data source . assign path(to:)</strong>函数从<strong class="jp ir"> InfiniteGridDataSource </strong>请求下一个可用的索引路径。</p><p id="4c63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行应用程序，我们现在看到一个网格！</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi my"><img src="../Images/7a29bfbdbbbe35a3c6f9bc229bf35df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*jnnGaULgPh2bHIuhChwmJQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">应用程序截图，工作网格</figcaption></figure><p id="d32c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们抽查一下我们的内存使用情况:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e288e043f4c0585a6bc48a66547db163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*DSMNpTCia-qK7UYMgtg0Uw.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">性能指标和内存要求</figcaption></figure><p id="7a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来不错！我们唯一要解决的问题是将我们相对较大的网格变成一个无限的网格。</p><h1 id="df18" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">让我们的网格变得无限</h1><p id="0651" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">到目前为止，我们创建了一个有限的网格，如果用户足够坚持，拖动一段时间后，我们会碰到边缘并反弹。由于UICollectionView基于UIScrollView，我们可以使用一些UIScrollViewDelegate函数来检测拖动何时结束，并重置contentOffset和centerCoordinates:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGridDelegate.swift —基础和最终实施</figcaption></figure><p id="eb7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们也更新我们的InfiniteGrid，以自动实例化和设置自定义委托:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">InfiniteGrid.swift —最终实施</figcaption></figure><p id="e99d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终结果是，每当收藏视图不再活跃时，它就会被重置为居中。视觉上，唯一的变化是滚动视图指示器被重置为中间。</p><p id="e7d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更容易地测试和确认实现是否正常工作，打开InfiniteGridLayout.swift并将gridSize更改为大约2000 x 2000。当集合视图滚动时，滚动指示器将达到它们的极限，视图最终将反弹。一旦没有拖动操作发生，滚动指示器应该重置到中心，集合视图再次可拖动。<em class="mz"> —完成后不要忘记重置gridSize！</em></p><p id="94db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成无限网格的实现，应该隐藏scrollview指示器。</p><h1 id="9444" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">源代码</h1><p id="392e" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">这个项目的源代码托管在GitHub上:<a class="ae kl" href="https://github.com/freshcode/Infinite-CollectionViewGrid-Swift" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/fresh code/Infinite-collection view grid-Swift</a></p><h1 id="a77e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">关于作者</h1><p id="a364" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">戴夫·普瓦里耶是一名高级软件开发人员，目前正在<a class="ae kl" href="http://idfusion.com" rel="noopener ugc nofollow" target="_blank"> ID Fusion软件公司</a>开发一些真正有趣的iOS应用程序。</p><p id="d7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的移动应用软件开发需要帮助吗？访问我们在http://idfusion.com<a class="ae kl" href="http://idfusion.com" rel="noopener ugc nofollow" target="_blank">的网站</a></p></div></div>    
</body>
</html>