<html>
<head>
<title>Redis Streams in Action — Part 3 (Tweets processor app)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis Streams的应用——第3部分(Tweets处理器应用)</h1>
<blockquote>原文：<a href="https://itnext.io/redis-streams-in-action-part-3-tweets-processor-app-254161838973?source=collection_archive---------1-----------------------#2021-06-10">https://itnext.io/redis-streams-in-action-part-3-tweets-processor-app-254161838973?source=collection_archive---------1-----------------------#2021-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8666" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Java应用程序处理来自Redis流的推文</h2></div><p id="2556" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎阅读这一系列的博客文章，这些文章通过一个实际的例子介绍了<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis Streams </a>。我们将使用一个示例应用程序来实时搜索和查询Twitter数据。<a class="ae lb" href="https://redisearch.io/" rel="noopener ugc nofollow" target="_blank"> RediSearch </a>和<a class="ae lb" href="https://redis.io/topics/streams-intro" rel="noopener ugc nofollow" target="_blank"> Redis Streams </a>是该解决方案的主干，由几个合作组件组成，我们将在一篇专门的博客文章中介绍每一个组件。</p><ul class=""><li id="4570" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-1-intro-and-overview-135f66d3ab58">第一部分</a></li><li id="0030" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-2-tweets-consumer-app-674fd3b45f6f">第二部分</a></li><li id="f5d0" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">第3部分—本博客</li><li id="3500" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/redis-streams-in-action-part-4-serverless-monitoring-service-faef52ee58db">第四部分</a></li></ul><blockquote class="lq lr ls"><p id="b694" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">本GitHub回购中有代码—</em><a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://github.com/abhirockzz/redis-streams-in-action</em></a></p></blockquote><p id="7dad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇博文将介绍一个基于Java的tweets处理器应用程序，它的作用是从Redis流中提取Tweets并存储它们(作为一个<code class="fe lx ly lz ma b">HASH</code>)，这样就可以使用<code class="fe lx ly lz ma b">RediSearch</code>对它们进行查询(在<code class="fe lx ly lz ma b">RediSearch</code>中，准确的术语是“索引文档”)。您将把应用程序部署到Azure，验证它，运行一些<code class="fe lx ly lz ma b">RediSearch</code>查询来搜索tweets。最后，有一个部分，我们将通过代码来理解“事情是如何工作的”。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/12f66c2917c7d99cf88185d18b68d8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5_0fV7Sm3HNr8txy.jpg"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">高层建筑</figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="9f49" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">先决条件</h1><p id="d7cb" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">请务必阅读本系列的第2部分，并启动和运行Tweets消费者应用程序。这个应用程序将从Twitter流API中读取推文，并将它们推送到Redis流。我们的tweets处理器应用程序(在这篇博客中描述的那个)将会接管。</p><p id="88c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你需要一个Azure账户<a class="ae lb" href="https://dev.to/abhirockzz/(https://azure.microsoft.com/free/?WT.mc_id=data-17927-abhishgu)" rel="noopener ugc nofollow" target="_blank">，你可以免费获得这个账户</a>和<a class="ae lb" href="https://docs.microsoft.com/cli/azure/install-azure-cli?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure CLI </a>。与之前的应用程序一样，这个应用程序也将使用常规Docker CLI命令部署到<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/container-instances-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure容器实例</a>。Docker和Azure 之间的<a class="ae lb" href="https://docs.docker.com/engine/context/aci-integration/" rel="noopener ugc nofollow" target="_blank">集成实现了这一功能。只要确保你有Docker桌面版2.3.0.5或更高版本，用于</a><a class="ae lb" href="https://desktop.docker.com/win/edge/Docker%20Desktop%20Installer.exe" rel="noopener ugc nofollow" target="_blank"> Windows </a>、<a class="ae lb" href="https://desktop.docker.com/mac/edge/Docker.dmg" rel="noopener ugc nofollow" target="_blank"> macOS </a>，或者安装<a class="ae lb" href="https://docs.docker.com/engine/context/aci-integration/#install-the-docker-aci-integration-cli-on-linux" rel="noopener ugc nofollow" target="_blank"> Docker ACI集成CLI用于Linux </a>。</p><h1 id="4305" class="my mz iq bd na nb nv nd ne nf nw nh ni jw nx jx nk jz ny ka nm kc nz kd no np bi translated">将应用部署到Azure容器实例</h1><p id="17c8" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">如果你一直在关注上一篇博文，你应该已经使用这个快速入门为Redis设置了Azure Cache的企业层。完成此步骤后，请确保保存以下信息:Redis主机名和访问密钥</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oa"><img src="../Images/f183df69cf1d8bde9fe5b4532076dab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FQwbSorh5wfhdESo.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">企业级:用于Redis的Azure缓存</figcaption></figure><p id="50cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序可以作为一个<a class="ae lb" href="https://hub.docker.com/r/abhirockzz/tweets-redis-streams-consumer-java" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>获得——最简单的方法就是简单地重用它。如果你想建立自己的形象，请使用GitHub repo 上的<code class="fe lx ly lz ma b"><a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/blob/master/tweets-processor/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code> <a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/blob/master/tweets-processor/Dockerfile" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="lq lr ls"><p id="1393" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">如果您选择构建自己的映像，请确保首先使用Maven ( </em> <code class="fe lx ly lz ma b"><em class="iq">mvn clean install</em></code> <em class="iq">)构建JAR文件</em></p></blockquote><p id="c0db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将它部署到Azure容器实例真的很方便，这允许你在一个托管的、无服务器的Azure环境中按需运行Docker容器。</p><p id="f5d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保您<a class="ae lb" href="https://docs.microsoft.com/azure/container-instances/quickstart-docker-cli?WT.mc_id=data-17927-abhishgu#create-azure-context" rel="noopener ugc nofollow" target="_blank">创建了一个Azure上下文</a>来将Docker与Azure订阅和资源组相关联，这样您就可以创建和管理容器实例。</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="f186" class="of mz iq ma b gy og oh l oi oj">docker login azure<br/>docker context create aci aci-context<br/>docker context use aci-context</span></pre><p id="4f83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置环境变量—确保根据您的帐户更新Redis主机和凭据:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="e3f2" class="of mz iq ma b gy og oh l oi oj">export STREAM_NAME=tweets_stream # don't change<br/>export STREAM_CONSUMER_GROUP_NAME=redisearch_app_group # don't change</span><span id="b71b" class="of mz iq ma b gy ok oh l oi oj">export REDIS_HOST=&lt;redis host port e.g. my-redis-host&gt;<br/>export REDIS_PORT=&lt;redis port&gt;<br/>export REDIS_PASSWORD=&lt;redis access key (password)&gt;<br/>export SSL=true</span></pre><p id="930d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">..然后使用<code class="fe lx ly lz ma b">docker run</code>将容器部署到Azure:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="3f75" class="of mz iq ma b gy og oh l oi oj">docker run -d --name redis-streams-consumer \<br/>-e STREAM_NAME=$STREAM_NAME \<br/>-e STREAM_CONSUMER_GROUP_NAME=$STREAM_CONSUMER_GROUP_NAME \<br/>-e REDIS_HOST=$REDIS_HOST \<br/>-e REDIS_PORT=$REDIS_PORT \<br/>-e REDIS_PASSWORD=$REDIS_PASSWORD \<br/>-e SSL=$SSL \<br/>abhirockzz/tweets-redis-streams-consumer-java</span></pre><p id="b365" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建容器时，您应该会看到类似如下的输出:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="e5d3" class="of mz iq ma b gy og oh l oi oj">[+] Running 2/2<br/> ⠿ Group redis-streams-consumer  Created                                                                             5.2s<br/> ⠿ redis-streams-consumer        Created                                                                            10.5s</span></pre><p id="9bc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Azure门户对此进行验证:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi oa"><img src="../Images/9d500e0e818a86d51e0cce4408dbc3a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2mwZ7cgIDagTYa19.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">在Azure容器实例中运行的Tweets处理器应用程序</figcaption></figure><p id="cd44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查容器日志，您可以使用常见的<code class="fe lx ly lz ma b">docker logs</code>命令:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="56ba" class="of mz iq ma b gy og oh l oi oj">docker logs redis-streams-consumer</span></pre><p id="7cd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该会看到类似如下的输出:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="357a" class="of mz iq ma b gy og oh l oi oj">Reading from stream tweets_stream with XREADGROUP<br/>saved tweet to hash tweet:1393089239324282880<br/>Reading from stream tweets_stream with XREADGROUP<br/>saved tweet to hash tweet:1393089243539517441<br/>Reading from stream tweets_stream with XREADGROUP<br/>not processed - tweet:1393089247721132033<br/>Reading from stream tweets_stream with XREADGROUP<br/>saved tweet to hash tweet:1393089256105693184<br/>Reading from stream tweets_stream with XREADGROUP<br/>saved tweet to hash tweet:1393089260304179200<br/>....</span></pre><blockquote class="lq lr ls"><p id="e64b" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">注意到</em> <code class="fe lx ly lz ma b"><em class="iq">not processed</em></code> <em class="iq">的日志了吗？我们将在下一节</em>中讨论它们</p></blockquote><p id="7bd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦应用程序启动并运行，它将开始从<code class="fe lx ly lz ma b">tweets_stream</code> Redis流中消费，并将每条推文信息存储在一个单独的<code class="fe lx ly lz ma b">HASH</code>中，然后由<code class="fe lx ly lz ma b">RediSearch</code>进行索引。在继续之前，使用<a class="ae lb" href="https://redis.io/topics/rediscli" rel="noopener ugc nofollow" target="_blank"> redis-cli </a>登录Redis实例:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="9cff" class="of mz iq ma b gy og oh l oi oj">redis-cli -h &lt;hostname&gt; -p 10000 -a &lt;password&gt; --tls</span></pre></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="f796" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">情况怎么样？</h1><p id="f89a" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">如果您仔细查看日志，您应该能够找到<code class="fe lx ly lz ma b">HASH</code>(基于tweet ID)的名称，例如<code class="fe lx ly lz ma b">tweet:&lt;tweet id&gt;</code>。用<code class="fe lx ly lz ma b">HGETALL</code>检查其内容即可:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="e604" class="of mz iq ma b gy og oh l oi oj">redis-cli&gt; TYPE tweet:1393089163856056320<br/>redis-cli&gt; hash<br/>redis-cli&gt; HGETALL tweet:1393089163856056320</span></pre><p id="421d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果将看起来像任何其他的<code class="fe lx ly lz ma b">HASH</code>。例如</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="4a40" class="of mz iq ma b gy og oh l oi oj">1) "location"<br/> 2) "Nairobi, Kenya"<br/> 3) "text"<br/> 4) "RT @WanjaNjubi: #EidMubarak \xf0\x9f\x99\x8f\nMay peace be upon you now and always.\n#EidUlFitr https://t.co/MlL0DbM2aS"<br/> 5) "id"<br/> 6) "1393089163856056320"<br/> 7) "user"<br/> 8) "Hot_96Kenya"<br/> 9) "hashtags"<br/>10) "EidMubarak,EidUlFitr"</span></pre><p id="1b0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，是时候用<code class="fe lx ly lz ma b">RediSearch</code>查询推文了！让我们使用几个命令来搜索<code class="fe lx ly lz ma b">tweets-index</code>索引:</p><ul class=""><li id="7905" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated"><code class="fe lx ly lz ma b">FT.SEARCH tweets-index hello</code> -将返回哪些推文</li><li id="f1c1" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe lx ly lz ma b">FT.SEARCH tweets-index hello|world</code> -同上，只是适用于“你好”或“世界”</li><li id="c40a" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">如果您对来自特定<code class="fe lx ly lz ma b">location</code>的推文感兴趣，请使用<code class="fe lx ly lz ma b">FT.SEARCH tweets-index "@location:India"</code></li><li id="b1c3" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe lx ly lz ma b">FT.SEARCH tweets-index "@user:jo* @location:India"</code> -这结合了<code class="fe lx ly lz ma b">location</code>和用户名应该以<code class="fe lx ly lz ma b">jo</code>开头的标准</li><li id="13eb" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><code class="fe lx ly lz ma b">FT.SEARCH tweets-index "@user:jo* | @location:India"</code>——这是上面的微妙变化。<code class="fe lx ly lz ma b">|</code>表示一个<code class="fe lx ly lz ma b">OR</code>标准</li><li id="020b" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">您也可以使用散列标签进行搜索— <code class="fe lx ly lz ma b">FT.SEARCH tweets-index "@hashtags:{cov*}</code></li><li id="93cd" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">包括多个这样的散列标签— <code class="fe lx ly lz ma b">FT.SEARCH tweets-index "@hashtags:{cov*|Med*}"</code></li></ul><p id="b25c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些只是几个例子。我强烈建议您参考<a class="ae lb" href="https://oss.redislabs.com/redisearch/Query_Syntax/" rel="noopener ugc nofollow" target="_blank">重新搜索文档</a>并尝试其他查询。</p><h1 id="24e4" class="my mz iq bd na nb nv nd ne nf nw nh ni jw nx jx nk jz ny ka nm kc nz kd no np bi translated">让我们横向扩展</h1><p id="8c9a" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">使用Redis流的主要好处之一是利用其消费者群体特性。这意味着您可以简单地向应用程序添加更多实例(横向扩展)来提高处理能力——实例数量越多，tweets处理得越快。每个应用程序将使用同一个Redis流的不同部分(<code class="fe lx ly lz ma b">tweets_stream</code>)，因此工作负载(几乎)均匀地分布在所有实例中——这为您提供了线性扩展的能力。</p><p id="95a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试试这个。要启动另一个实例，使用<code class="fe lx ly lz ma b">docker run</code> -确保使用不同的名称:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="6c78" class="of mz iq ma b gy og oh l oi oj">docker run -d --name redis-streams-consumer_2 \<br/>-e STREAM_NAME=$STREAM_NAME \<br/>-e STREAM_CONSUMER_GROUP_NAME=$STREAM_CONSUMER_GROUP_NAME \<br/>-e REDIS_HOST=$REDIS_HOST \<br/>-e REDIS_PORT=$REDIS_PORT \<br/>-e REDIS_PASSWORD=$REDIS_PASSWORD \<br/>-e SSL=$SSL \<br/>abhirockzz/tweets-redis-streams-consumer-java</span></pre><blockquote class="lq lr ls"><p id="b05a" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">注意，我用了一个不同的名字</em> <code class="fe lx ly lz ma b"><em class="iq">--name redis-streams-consumer_2</em></code></p></blockquote><p id="df1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事情会像以前一样继续——只是快了一点，因为我们有了另一只援助之手。您也可以检查新实例的日志— <code class="fe lx ly lz ma b">docker logs redis-streams-consumer_2</code>。</p><p id="0fb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以继续进一步试验，尝试扩展到更多实例。</p><h1 id="c5f9" class="my mz iq bd na nb nv nd ne nf nw nh ni jw nx jx nk jz ny ka nm kc nz kd no np bi translated">是时候深入挖掘一下了</h1><p id="3f58" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">我们可以使用<a class="ae lb" href="https://redis.io/commands/XPENDING" rel="noopener ugc nofollow" target="_blank"> XPENDING </a>命令自省Redis流:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="b4a7" class="of mz iq ma b gy og oh l oi oj">XPENDING tweets_stream redisearch_app_group</span></pre><p id="03a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将得到类似如下的输出:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="9ecc" class="of mz iq ma b gy og oh l oi oj">1) (integer) 25<br/>2) "1618572598902-0"<br/>3) "1618573768902-0"<br/>4) 1) 1) "consumer-b6410cf9-8244-41ba-b0a5-d79b66d33d65"<br/>      2) "20"<br/>   2) 1) "consumer-e5a872d4-b488-416e-92ee-55d2902b338f"<br/>      2) "5"</span></pre><p id="7efa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您是Redis Streams的新手，这个输出可能没有什么意义。对<code class="fe lx ly lz ma b">XPENDING</code>的调用返回由我们的处理应用程序<em class="lt">接收到</em>但还没有<em class="lt">处理过</em>(并且<a class="ae lb" href="https://redis.io/commands/xack" rel="noopener ugc nofollow" target="_blank">确认了</a>)的消息的数量。在这种情况下，我们有两个应用程序实例(它们随机生成UUIDs ),并且分别有<code class="fe lx ly lz ma b">20</code>和<code class="fe lx ly lz ma b">5</code>未处理的消息(当然，在您的情况下，数字会有所不同)。</p><p id="2b34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在生产场景中，应用程序故障可能由于多种原因而发生。然而，在我们的示例应用程序中，下面的代码片段用于模拟这种情况——它随机选择(大约20%的概率)不处理从Redis流接收的tweet:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="cc67" class="of mz iq ma b gy og oh l oi oj">if (!(random.nextInt(5) == 0)) {<br/>    conn.hset(hashName, entry.getFields());<br/>    conn.xack(streamName, consumerGroupName, entry.getID());<br/>}</span></pre><p id="368a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么你会看到<code class="fe lx ly lz ma b">XPENDING</code>数量缓慢但稳定地增加。在生产中，如果一个(或多个)实例崩溃，这些实例的<code class="fe lx ly lz ma b">XPENDING</code>计数将停止增加，但保持<em class="lt">不变</em>。这意味着，这些消息现在未被处理——在这个具体的例子中，这意味着tweet信息在<code class="fe lx ly lz ma b">RediSearch</code>中无法供您查询。</p><h2 id="4e42" class="of mz iq bd na ol om dn ne on oo dp ni ko op oq nk ks or os nm kw ot ou no ov bi translated">Redis前来救援</h2><p id="7985" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">Redis Streams提供可靠的消息传递。它存储每个消费者的状态——这正是你用<code class="fe lx ly lz ma b">XPENDING</code>看到的！如果您使用相同的组和消费者名称启动另一个消费者实例，您将能够<em class="lt">重放</em>相同的消息并重新处理它们，以确保tweets存储在Redis中。这不需要你做任何不同的/额外的事情。</p><p id="c172" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个选择是拥有一个专用的应用程序，它可以定期<em class="lt">检查</em>消费者群体状态(<code class="fe lx ly lz ma b">XPENDING</code>)，<a class="ae lb" href="https://redis.io/commands/xclaim" rel="noopener ugc nofollow" target="_blank">声明</a>已经被放弃的消息，重新处理并且(最重要的是)确认(<code class="fe lx ly lz ma b">XACK</code>)它们。在本系列的下一部分(最后一部分),我们将探索如何构建一个应用程序来实现这一点！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="2264" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">那么，它是如何工作的呢？</h1><p id="c516" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">这是快速浏览代码的好时机。</p><blockquote class="lq lr ls"><p id="59c9" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">可以参考</em> <a class="ae lb" href="https://github.com/abhirockzz/redis-streams-in-action/tree/master/tweets-processor" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub回购</em> </a>中的代码</p></blockquote><p id="665e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序使用<a class="ae lb" href="https://github.com/RediSearch/JRediSearch" rel="noopener ugc nofollow" target="_blank"> JRediSearch </a>，它抽象了<code class="fe lx ly lz ma b">RediSearch</code>模块的API。我们要做的第一件事是建立与Redis的连接:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="132d" class="of mz iq ma b gy og oh l oi oj">GenericObjectPoolConfig&lt;Jedis&gt; jedisPoolConfig = new GenericObjectPoolConfig&lt;&gt;();</span><span id="f77b" class="of mz iq ma b gy ok oh l oi oj">JedisPool pool = new JedisPool(jedisPoolConfig, redisHost, Integer.valueOf(redisPort), timeout, redisPassword, isSSL);</span><span id="190b" class="of mz iq ma b gy ok oh l oi oj">Client redisearch = new Client(INDEX_NAME, pool);</span></pre><p id="c71c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个<a class="ae lb" href="https://www.javadoc.io/doc/com.redislabs/jredisearch/latest/io/redisearch/Schema.html" rel="noopener ugc nofollow" target="_blank">模式</a>和<a class="ae lb" href="https://www.javadoc.io/doc/com.redislabs/jredisearch/latest/io/redisearch/client/IndexDefinition.html" rel="noopener ugc nofollow" target="_blank">索引定义</a>。</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="3b56" class="of mz iq ma b gy og oh l oi oj">Schema sc = new Schema().addTextField(SCHEMA_FIELD_ID, 1.0).addTextField(SCHEMA_FIELD_USER, 1.0)<br/>                .addTextField(SCHEMA_FIELD_TWEET, 1.0).addTextField(SCHEMA_FIELD_LOCATION, 1.0)<br/>                .addTagField(SCHEMA_FIELD_HASHTAGS);</span><span id="bdda" class="of mz iq ma b gy ok oh l oi oj">        IndexDefinition def = new IndexDefinition().setPrefixes(new String[] { INDEX_PREFIX });</span><span id="a725" class="of mz iq ma b gy ok oh l oi oj">        try {<br/>            boolean indexCreated = redisearch.createIndex(sc, Client.IndexOptions.defaultOptions().setDefinition(def));</span><span id="9df5" class="of mz iq ma b gy ok oh l oi oj">            if (indexCreated) {<br/>                System.out.println("Created RediSearch index ");<br/>            }<br/>        } catch (Exception e) {<br/>            System.out.println("Did not create RediSearch index - " + e.getMessage());<br/>        }</span></pre><blockquote class="lq lr ls"><p id="ff3a" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated"><em class="iq">探究Redis流API(</em><code class="fe lx ly lz ma b"><em class="iq">xgroupCreate</em></code><em class="iq">，</em> <code class="fe lx ly lz ma b"><em class="iq">xreadGroup</em></code> <em class="iq">等)。)由Jedis库曝光，看看它的</em><a class="ae lb" href="https://www.javadoc.io/doc/redis.clients/jedis/latest/redis/clients/jedis/commands/JedisCommands.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">javadocs</em></a></p></blockquote><p id="2d59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，我们创建一个Redis流消费者组(使用<code class="fe lx ly lz ma b">xgroupCreate</code>)——这是强制性的。使用者组代表一组“协同工作”的应用程序，它们相互协作以分担处理负载:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="6493" class="of mz iq ma b gy og oh l oi oj">try {<br/>    conn = pool.getResource();<br/>    String res = conn.xgroupCreate(streamName, consumerGroupName, StreamEntryID.LAST_ENTRY, true);<br/>}</span></pre><p id="2b3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">消费者群体中的每个app都需要唯一标识。虽然可以手动分配名称，但我们会生成一个随机的消费者名称。</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="52ec" class="of mz iq ma b gy og oh l oi oj">String consumerName = "consumer-" + UUID.randomUUID().toString();</span></pre><p id="1157" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">消费者应用程序的主要部分是使用<code class="fe lx ly lz ma b">xreadGroup</code>从Redis流中读取数据的循环。请注意<code class="fe lx ly lz ma b">StreamEntryID.UNRECEIVED_ENTRY</code> -这意味着我们将要求Redis返回组中任何其他消费者<em class="lt">没有</em>收到的流条目。此外，我们对<code class="fe lx ly lz ma b">15 seconds</code>的调用被阻塞，我们选择每次调用<code class="fe lx ly lz ma b">XREADGROUP</code>最多获得<code class="fe lx ly lz ma b">50</code>条消息(当然，您可以根据需要更改这一点)。</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="954f" class="of mz iq ma b gy og oh l oi oj">while (true) {</span><span id="90cf" class="of mz iq ma b gy ok oh l oi oj">    List&lt;Entry&lt;String, List&lt;StreamEntry&gt;&gt;&gt; results = conn.xreadGroup(consumerGroupName, consumerName, 50,<br/>                        15000, false, Map.entry(streamName, StreamEntryID.UNRECEIVED_ENTRY));</span><span id="f856" class="of mz iq ma b gy ok oh l oi oj">    if (results == null) {<br/>        continue;<br/>    }<br/>    ....<br/>}</span></pre><p id="bf4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个流条目都需要保存到Redis <code class="fe lx ly lz ma b">HASH</code>(使用<code class="fe lx ly lz ma b">hset</code>)。好的一面是读取一个流条目会返回一个<code class="fe lx ly lz ma b">HashMap</code>，这也正是<code class="fe lx ly lz ma b">HSET</code> API所期望的。所以我们能够重复使用<code class="fe lx ly lz ma b">HashMap</code>！</p><p id="6437" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这还没完，请注意<code class="fe lx ly lz ma b">xack</code>方法——这是调用<code class="fe lx ly lz ma b">XACK</code>并告知我们已经成功处理消息的方法:</p><pre class="mc md me mf gt ob ma oc od aw oe bi"><span id="7bde" class="of mz iq ma b gy og oh l oi oj">for (Entry&lt;String, List&lt;StreamEntry&gt;&gt; result : results) {<br/>                    List&lt;StreamEntry&gt; entries = result.getValue();<br/>                    for (StreamEntry entry : entries) {<br/>                        String tweetid = entry.getFields().get("id");<br/>                        String hashName = INDEX_PREFIX + tweetid;</span><span id="872d" class="of mz iq ma b gy ok oh l oi oj">                        try {<br/>                            // simulate random failure/anomaly. ~ 20% will NOT be ACKed<br/>                            if (!(random.nextInt(5) == 0)) {<br/>                                conn.hset(hashName, entry.getFields());<br/>                                conn.xack(streamName, consumerGroupName, entry.getID());<br/>                            }<br/>                        } catch (Exception e) {<br/>                            continue;<br/>                        }<br/>                    }<br/>                }</span></pre><blockquote class="lq lr ls"><p id="2950" class="kf kg lt kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">这里有很大的优化空间。例如，您可以通过为每批(比如50条消息)生成一个线程来使这个过程成为多线程的</p></blockquote><p id="8ec1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个博客到此为止！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="35a4" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">对最后部分感兴趣吗？</h1><p id="60e8" class="pw-post-body-paragraph kf kg iq kh b ki nq jr kk kl nr ju kn ko ns kq kr ks nt ku kv kw nu ky kz la ij bi translated">到目前为止，我们在第1部分介绍了高级概述，在第2部分介绍了tweets consumer Rust应用程序，以及一个处理来自Redis流的tweets的Java应用程序。正如所承诺的，该系列的最后一部分将涵盖一个应用程序，以监控流程并重新处理被放弃的消息，以保持我们的整体系统健壮——这将是一个部署到<a class="ae lb" href="https://docs.microsoft.com/azure/azure-functions/functions-overview?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>的<a class="ae lb" href="https://docs.microsoft.com/azure/azure-functions/functions-custom-handlers?WT.mc_id=data-17927-abhishgu" rel="noopener ugc nofollow" target="_blank">无服务器Go应用程序</a>。敬请期待！</p></div></div>    
</body>
</html>