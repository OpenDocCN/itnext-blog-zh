<html>
<head>
<title>Horizontal Pod Autoscale with Custom Prometheus Metrics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有自定义Prometheus指标的水平Pod自动缩放</h1>
<blockquote>原文：<a href="https://itnext.io/horizontal-pod-autoscale-with-custom-metrics-8cb13e9d475?source=collection_archive---------1-----------------------#2019-01-04">https://itnext.io/horizontal-pod-autoscale-with-custom-metrics-8cb13e9d475?source=collection_archive---------1-----------------------#2019-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d1c3a2f894f673fee070438d852dfb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hiO1WxZpt7uPCWjx_kFGw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">图片引自Amazon.com</em></figcaption></figure><p id="ea96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae le" href="https://medium.com/@zhimin.wen/custom-prometheus-metrics-for-apps-running-in-kubernetes-498d69ada7aa" rel="noopener">的上一篇论文</a>中，我探讨了如何创建应用程序的定制指标，并在Grafana仪表板中呈现结果。在本文中，我将根据选定的自定义指标实现水平Pod自动缩放(HPA)目标。</p><p id="0399" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些步骤总结如下</p><ol class=""><li id="6527" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">更新并安装Prometheus-Adapter helm图表，以便HPA使用自定义指标。</li><li id="61ed" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">定义和创建自定义指标</li><li id="158d" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">创建HPA对象</li><li id="b9f7" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">横向扩展测试。</li></ol><p id="a68c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们开始吧。</p><h2 id="8951" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated"><strong class="ak"> 1。</strong>普罗米修斯适配器</h2><p id="2e68" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><a class="ae le" href="https://github.com/DirectXMan12/k8s-prometheus-adapter" rel="noopener ugc nofollow" target="_blank"> Prometheus适配器</a>通过实现<a class="ae le" href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/instrumentation/custom-metrics-api.md" rel="noopener ugc nofollow" target="_blank">自定义指标</a> API来扩展Kubernetes，这使得HorizontalPodAutoscaler控制器能够使用“custom . metrics . k8s . io”API来检索指标。通过适配器的配置定义我们自己的指标，我们能够让HPA基于我们的自定义指标进行扩展。</p><p id="69a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的Kubernetes环境是IBM云私有(ICP) 3.1.1。尽管在这个版本中安装了Prometheus适配器，但是创建定制指标的配置并没有公开。我们将根据<a class="ae le" href="https://github.com/helm/charts/tree/master/stable/prometheus-adapter" rel="noopener ugc nofollow" target="_blank">最新舵图</a>安装适配器。</p><blockquote class="mr ms mt"><p id="dc45" class="kg kh mu ki b kj kk kl km kn ko kp kq mv ks kt ku mw kw kx ky mx la lb lc ld im bi translated">通过重新安装，一些重复的Kubernets对象将被覆盖。如果集群用于探索之外的其他目的，您需要确保这些默认pod指标没有被使用。</p></blockquote><p id="b126" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如本白皮书中<a class="ae le" href="https://medium.com/@zhimin.wen/https-client-certificate-authentication-with-sidecar-9b07d82a6389" rel="noopener">所述，ICP中的Prometheus需要客户端认证身份验证，我们需要更新helm图表以允许客户端认证身份验证的配置。</a></p><p id="f6b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">克隆存储库并在values.yaml文件中引入新变量。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4201" class="lt lu it nd b gy nh ni l nj nk">prometheus:<br/>  url: <a class="ae le" href="http://prometheus.default.svc" rel="noopener ugc nofollow" target="_blank">http://prometheus.default.svc</a><br/>  port: 9090<br/><strong class="nd iu">  clientAuthentication:<br/>    use: true<br/>    ca: |-<br/>      # CA<br/>    cert: |-<br/>      #cert of client<br/>    key: |-<br/>      # key for the cert</strong></span></pre><p id="50c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用额外的命令参数更新部署yaml文件，以允许Prometheus身份验证。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="b4b7" class="lt lu it nd b gy nh ni l nj nk">#...<br/>        - /adapter<br/>        - --secure-port=6443<br/>{{- if .Values.tls.enable }}<br/>        - --tls-cert-file=/var/run/serving-cert/tls.crt<br/>        - --tls-private-key-file=/var/run/serving-cert/tls.key<br/>{{- end }}<br/>        - --cert-dir=/tmp/cert<br/>        - --logtostderr=true<br/>        - --prometheus-url={{ .Values.prometheus.url }}:{{ .Values.prometheus.port }}<br/>        - --metrics-relist-interval={{ .Values.metricsRelistInterval }}<br/>        - --v={{ .Values.logLevel }}<br/>        - --config=/etc/adapter/config.yaml<br/><strong class="nd iu">{{- if .Values.prometheus.clientAuthentication.use }}<br/>        - --prometheus-auth-config=/etc/prometheus/prometheus.kubecfg.yaml<br/>{{- end }}</strong></span><span id="f43b" class="lt lu it nd b gy nl ni l nj nk">#...</span></pre><p id="2c94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于用户来说,“prometheus-auth-config”利用kubecfg文件格式与prometheus服务器对话并不明显。(<em class="mu">有个</em> <a class="ae le" href="https://github.com/DirectXMan12/k8s-prometheus-adapter/issues/144" rel="noopener ugc nofollow" target="_blank"> <em class="mu">讨论</em> </a> <em class="mu">接着来解决这个</em>)。这里，我在图表中创建新的configMap文件，</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0507" class="lt lu it nd b gy nh ni l nj nk">{{- if .Values.prometheus.clientAuthentication.use -}}<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: {{ template "k8s-prometheus-adapter.prometheus.kubecfg" . }}<br/>  labels:<br/>    app: {{ template "k8s-prometheus-adapter.name" . }}<br/>    chart: {{ template "k8s-prometheus-adapter.chart" . }}<br/>    release: {{ .Release.Name }}<br/>    heritage: {{ .Release.Service }}<br/>data:<br/>  prometheus.kubecfg.yaml: |-<br/>    apiVersion: v1<br/>    kind: Config<br/>    preferences: {}<br/>    clusters:<br/>    - cluster:<br/>        # insecure-skip-tls-verify: true<br/>        certificate-authority-data: {{ b64enc .Values.prometheus.clientAuthentication.ca }}<br/>        server: {{ .Values.prometheus.url }}<br/>      name: prometheus-server<br/>    users:<br/>    - name: with-cert<br/>      user:<br/>        client-certificate-data: {{ b64enc .Values.prometheus.clientAuthentication.cert  }}<br/>        client-key-data: {{ b64enc .Values.prometheus.clientAuthentication.key }}<br/>    contexts:<br/>    - context:<br/>        cluster: prometheus-server<br/>        user: with-cert<br/>      name: promethues-server-connection<br/>    current-context: promethues-server-connection<br/>{{- end -}}</span></pre><p id="d81c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在配置图中，群集服务器指向由prometheus.url变量定义的URL。它还定义了CA证书、客户端证书和客户端密钥。</p><p id="a8c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CA证书是Prometheus使用的CA。查看Kubernetes对象定义，是“cluster-ca-cert”的秘密。检索CA证书及其私钥，</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e166" class="lt lu it nd b gy nh ni l nj nk"><em class="mu"># Save the following output as ca.pem<br/>kubectl -n kube-system get secret cluster-ca-cert -o jsonpath="{ .data.tls\.crt }" | base64 -di</em></span><span id="88bc" class="lt lu it nd b gy nl ni l nj nk"># Save the following output as ca.key<br/><em class="mu">kubectl -n kube-system get secret cluster-ca-cert -o jsonpath="{ .data.tls\.key }" | base64 -di</em></span></pre><p id="395b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用此CA和cfssl工具创建客户端证书和密钥。(详见<a class="ae le" href="https://medium.com/@zhimin.wen/https-client-certificate-authentication-with-sidecar-9b07d82a6389" rel="noopener">论文</a>)</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="267e" class="lt lu it nd b gy nh ni l nj nk"><em class="mu">cfssl gencert -ca=ca.pem -ca-key=ca.key -config=ca-config.json -profile=client -hostname="" clientRequest.json | cfssljson -bare prometheus-client</em></span></pre><p id="53e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更新图表中的部署文件，以将此配置图作为供Prometheus使用的文件进行装载。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="acc6" class="lt lu it nd b gy nh ni l nj nk">        volumeMounts:<br/>        - mountPath: /etc/adapter/<br/>          name: config<br/>          readOnly: true<br/>        - mountPath: /tmp<br/>          name: tmp<br/>{{- if .Values.tls.enable }}<br/>        - mountPath: /var/run/serving-cert<br/>          name: volume-serving-cert<br/>          readOnly: true<br/>{{- end }}<br/><strong class="nd iu">{{- if .Values.prometheus.clientAuthentication.use }}<br/>        - mountPath: /etc/prometheus<br/>          name: prometheus-client-authentication<br/>          readOnly: true<br/>{{- end }}</strong></span><span id="5c83" class="lt lu it nd b gy nl ni l nj nk"># ...</span><span id="97c7" class="lt lu it nd b gy nl ni l nj nk"><strong class="nd iu">{{- if .Values.prometheus.clientAuthentication.use }}<br/>      - name: prometheus-client-authentication<br/>        configMap:<br/>          name: {{ template "k8s-prometheus-adapter.prometheus.kubecfg" . }}<br/>{{- end }}</strong></span></pre><p id="7c1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个vars.yaml文件，如下所示，</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7d0a" class="lt lu it nd b gy nh ni l nj nk">prometheus:<br/>  url: <a class="ae le" href="https://monitoring-prometheus.kube-system" rel="noopener ugc nofollow" target="_blank">https://monitoring-prometheus.kube-system</a><br/>  port: 9090<br/>  clientAuthentication:<br/>    use: true<br/>    ca: |-<br/>      -----BEGIN CERTIFICATE-----<br/>      MIIFmzCCA4OgAwIBAgIJAMVsH80dT0MRMA0GCSqGSIb3DQEBCwUAMGMxCzAJBgNV<br/>      ...<br/>      -----END CERTIFICATE-----</span><span id="16a0" class="lt lu it nd b gy nl ni l nj nk">    cert: |-<br/>      -----BEGIN CERTIFICATE-----<br/>      MIIEnjCCAoagAwIBAgIULumvDA5hcKj4JmGMsH8SN2CtN90wDQYJKoZIhvcNAQEN<br/>      ...<br/>      -----END CERTIFICATE-----</span><span id="77ae" class="lt lu it nd b gy nl ni l nj nk">    key: |-<br/>      -----BEGIN RSA PRIVATE KEY-----<br/>      MIIEpAIBAAKCAQEAqJJw+u2NHy3CEQwZgE76ZzkleBmls+nMGY5qHdCI0XEF2oLH<br/>      ...<br/>      -----END RSA PRIVATE KEY-----</span><span id="8378" class="lt lu it nd b gy nl ni l nj nk">replicas: 1<br/>rbac:<br/>  create: true</span><span id="1639" class="lt lu it nd b gy nl ni l nj nk">serviceAccount:<br/>  create: true<br/>  name:</span><span id="b82f" class="lt lu it nd b gy nl ni l nj nk">rules:<br/>  default: true<br/>  custom: []</span><span id="3f76" class="lt lu it nd b gy nl ni l nj nk">tls:<br/>  enable: false</span><span id="c56f" class="lt lu it nd b gy nl ni l nj nk">nodeSelector:<br/>  management: "true"<br/>tolerations:<br/>  - key: dedicated<br/>    value: infra<br/>    effect: "NoSchedule"</span><span id="bd5e" class="lt lu it nd b gy nl ni l nj nk">logLevel: 10</span></pre><p id="e008" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Prometheus URL是“https ”,服务器名称是群集中Prometheus的服务名称，因为适配器pod将在同一个群集中运行。</p><p id="cf22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复制yaml文件中的证书。</p><p id="55dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将在专用管理节点上部署pod，这就是为什么要应用nodeSelectot和tolerations。</p><p id="1c7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行helm命令来安装图表。“Prometheus-adapter . chart . updated”是更新后的图表所在的目录。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="53b4" class="lt lu it nd b gy nh ni l nj nk">helm install prometheus-adapter.chart.updated --tls --values var.yaml</span></pre><p id="6440" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验证pod正在运行。现在定制指标API可用了。通过运行的命令来验证它</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d926" class="lt lu it nd b gy nh ni l nj nk">kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1 | jq .</span></pre><p id="890c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该会看到适配器的默认指标列表。</p><h2 id="2bc1" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">2.创建自定义指标</h2><p id="4e1b" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">为了简单起见，我将删除所有默认的自定义指标，只从我上一篇文章中的示例应用程序创建一个指标。</p><p id="c1cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">准备以下配置映射文件，替换{{。chart }}和{{。release }}包含helm创建的默认配置映射文件的内容。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7f30" class="lt lu it nd b gy nh ni l nj nk">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  labels:<br/>    app: prometheus-adapter<br/>    chart: {{ .chart }}<br/>    heritage: Tiller<br/>    release: {{ .release}}<br/>  name: {{ .release }}-prometheus-adapter<br/>  namespace: default<br/>data:<br/>  config.yaml: |<br/>    rules:<br/><strong class="nd iu">    - seriesQuery: '{__name__= "myapp_client_connected"}'<br/>      seriesFilters: []<br/>      resources:<br/>        overrides:<br/>          k8s_namespace:<br/>            resource: namespace<br/>          k8s_pod_name:<br/>            resource: pod<br/>      name:<br/>        matches: "myapp_client_connected"<br/>        as: ""<br/>      metricsQuery: &lt;&lt;.Series&gt;&gt;{&lt;&lt;.LabelMatchers&gt;&gt;,container_name!="POD"}</strong></span></pre><p id="18ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从Prometheus中选择名为“myapp_client_connected”的指标。给命名空间分配标签“k8s_namespace”，给pod分配标签“k8s _ pod _ name”<em class="mu">(参考普罗米修斯relabel_config的最后一篇论文，了解如何定义标签)</em></p><p id="5b5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用相同的指标名称“myapp _ client _ connected”<strong class="ki iu"/>，不使用任何正则表达式替换。最后是metricQuery，它使用PromQL类型的查询来获取指标的值。</p><p id="2a5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用此新配置图替换旧配置图。删除旧的pod以生成新的pod，从而使配置更改生效。现在我们可以测试自定义指标API了。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="dc2f" class="lt lu it nd b gy nh ni l nj nk">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1  | jq<br/>{<br/>  "kind": "APIResourceList",<br/>  "apiVersion": "v1",<br/>  "groupVersion": "custom.metrics.k8s.io/v1beta1",<br/>  "resources": [<br/>    {<br/>      "name": "namespaces/myapp_client_connected",<br/>      "singularName": "",<br/>      "namespaced": false,<br/>      "kind": "MetricValueList",<br/>      "verbs": [<br/>        "get"<br/>      ]<br/>    },<br/>    {<br/>      "name": "pods/myapp_client_connected",<br/>      "singularName": "",<br/>      "namespaced": true,<br/>      "kind": "MetricValueList",<br/>      "verbs": [<br/>        "get"<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="a5f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并通过调用进一步列出该值</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7421" class="lt lu it nd b gy nh ni l nj nk">$ kubectl get --raw /apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/myapp_client_connected  | jq<br/>{<br/>  "kind": "MetricValueList",<br/>  "apiVersion": "custom.metrics.k8s.io/v1beta1",<br/>  "metadata": {<br/>    "selfLink": "/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/%2A/myapp_client_connected"<br/>  },<br/>  "items": [<br/>    {<br/>      "describedObject": {<br/>        "kind": "Pod",<br/>        "namespace": "default",<br/>        "name": "hpa-sim-5cd9d7c47b-nd6c7",<br/>        "apiVersion": "/v1"<br/>      },<br/>      "metricName": "myapp_client_connected",<br/>      "timestamp": "2019-01-04T17:16:11Z",<br/>      "value": "0"<br/>    },<br/>    {<br/>      "describedObject": {<br/>        "kind": "Pod",<br/>        "namespace": "default",<br/>        "name": "hpa-sim-5cd9d7c47b-nfc9h",<br/>        "apiVersion": "/v1"<br/>      },<br/>      "metricName": "myapp_client_connected",<br/>      "timestamp": "2019-01-04T17:16:11Z",<br/>      "value": "0"<br/>    },<br/>    {<br/>      "describedObject": {<br/>        "kind": "Pod",<br/>        "namespace": "default",<br/>        "name": "hpa-sim-5cd9d7c47b-wlqqp",<br/>        "apiVersion": "/v1"<br/>      },<br/>      "metricName": "myapp_client_connected",<br/>      "timestamp": "2019-01-04T17:16:11Z",<br/>      "value": "0"<br/>    }<br/>  ]<br/>}</span></pre><p id="e21f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，所有三个pod的指标都已返回。</p><h2 id="29a8" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated"><strong class="ak"> 3。为部署创建HPA</strong></h2><p id="6eac" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">回想在上一篇论文中，我已经部署了“hpa-sim”。准备好自定义指标后，我们可以根据定义的指标自动扩展它。在这里，我只需选择活动会话的数量。HPA定义如下:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="fe96" class="lt lu it nd b gy nh ni l nj nk">apiVersion: autoscaling/v2beta1<br/>kind: HorizontalPodAutoscaler<br/>metadata:<br/>  name: hpa-sim<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    apiVersion: apps/v1<br/>    kind: Deployment<br/>    name: hpa-sim<br/>  minReplicas: 1<br/>  maxReplicas: 10<br/>  metrics:<br/>  - type: Pods<br/>    pods:<br/>      metricName: myapp_client_connected<br/>      targetAverageValue: 20</span></pre><p id="a765" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将名为“hpa-sim”的部署从1个副本扩展到10个副本。这些指标将基于pod类型的自定义指标。指标名称为“myapp_client_connected ”,测量基于所有相关pod的平均值。<em class="mu">(实际上只支持平均值目标)</em>。将targetAverageValue设置为20。因此，当HTTP处理程序的平均并发会话数超过20时，就会触发HPA。</p><p id="76d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应用配置，监控HPA开始收集度量值，</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="5106" class="lt lu it nd b gy nh ni l nj nk">k get hpa hpa-sim<br/>NAME      REFERENCE            TARGETS   MINPODS   MAXPODS   REPLICAS   AGE<br/>hpa-sim   Deployment/hpa-sim   0/20      1         10        1          3h</span></pre><h2 id="3928" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">4.泵送负载并监控结垢</h2><p id="df8a" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">让我们用一些Golang函数使用<a class="ae le" href="https://github.com/magefile/mage" rel="noopener ugc nofollow" target="_blank"> magefile </a>任务来测试一下。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="04ea" class="lt lu it nd b gy nh ni l nj nk">func (Load) T01_PumpUniformLoad() {<br/> var wg sync.WaitGroup<br/> for index := 0; index &lt; config.LoadCount; index++ {<br/>  wg.Add(1)<br/>  go func() {<br/>   url := fmt.Sprintf("<a class="ae le" href="http://192.168.64.244:30543/service?cost=%f" rel="noopener ugc nofollow" target="_blank">http://192.168.64.244:30543/service?cost=%f</a>", config.FixedLatency)<br/>   _, err := http.Get(url)<br/>   if err != nil {<br/>    log.Printf("Request Failed")<br/>   }<br/>   wg.Done()<br/>  }()<br/> }</span><span id="21c3" class="lt lu it nd b gy nl ni l nj nk"> wg.Wait()<br/> log.Printf("ALL request are returned.")<br/>}</span></pre><p id="7df8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认的LoadConfig设置为100，FixedLatency设置为120。环境文件。运行法师任务，触发持续120秒的100并发连接。打开另一个shell，在前2分钟加载完成之前运行相同的任务以保持加载。</p><p id="281c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上一篇文章中创建的Grafana仪表板进行监视，</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/47c2abf5c9985b1bc6e83c6debe13f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*lwTFYpWVZXAVtAV-p55ZZQ.png"/></div></figure><p id="12ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以清楚地看到，这些单元从一个单元扩大到多个单元，然后又缩小到一个单元。运行命令<code class="fe nn no np nd b">kubectl get hpa hpa-sim -w</code>，下面显示了pod如何在峰值期间增长并在峰值后减少。</p><figure class="my mz na nb gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/91916b89c1756890dd436e1081f341c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*XO0yOcnMunjxSrBW8eyPYw.png"/></div></figure><h2 id="82ba" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">结论</h2><p id="c852" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在4篇文章中，我研究了Prometheus、使用客户端API的自定义指标、Grafana的自定义指标和HPA的自定义指标，并对这些主题有了一些透彻的理解。希望你喜欢阅读，并和我一起学习一些东西。</p></div></div>    
</body>
</html>