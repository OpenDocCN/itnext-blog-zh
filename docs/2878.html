<html>
<head>
<title>Angular Search &amp; Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度搜索和分页</h1>
<blockquote>原文：<a href="https://itnext.io/angular-search-pagination-41572ef0078f?source=collection_archive---------1-----------------------#2019-08-20">https://itnext.io/angular-search-pagination-41572ef0078f?source=collection_archive---------1-----------------------#2019-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1be6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有用法示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08ff836f74bdd05dc0c0c50d06093f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qWvAZeeNtWy86wyorT3aFA.png"/></div></div></figure><p id="926a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在现实世界的应用程序中，处理大量数据并为用户提供搜索和分页的可能性是很常见的。因此，在本文中，我将展示一种方法，如何创建一个处理带有<em class="lq">去抖</em>的搜索输入的<strong class="kw iu">搜索组件</strong>，以及一个处理不同数据页面请求的<strong class="kw iu">分页组件</strong>；两个人一起工作。</p><h1 id="f598" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak">搜索组件</strong></h1><p id="9dab" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们从我们的<em class="lq">搜索组件</em>开始。我们这里的目标是为用户提供一个输入，这样他就可以输入一个搜索字符串来过滤大集合的结果。然而，我们必须注意到，通过使用直接属性绑定，我们不会得到用户输入的每个字符之间的时间间隔(<em class="lq">去抖时间)。</em></p><p id="e986" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数时候这是一个问题，因为我们可能会根据提供的输入向服务器发出请求，而您希望等待用户完成输入；<strong class="kw iu">这既是为了不做许多不必要的请求，也是为了提供更好的可用性。</strong></p><p id="e091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过<em class="lq"> rxjs </em>很简单的解决这个问题。首先，我们需要在组件中创建一个类型为<em class="lq"> string的<em class="lq">主题</em>。</em>这是我们要用来<strong class="kw iu">订阅输入值</strong>的变化，并处理我们的<em class="lq">去抖</em>。</p><blockquote class="mo mp mq"><p id="14ba" class="ku kv lq kw b kx ky ju kz la lb jx lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">“每一个主体都是可观察的和观察者。你可以<strong class="kw iu">给</strong>订阅一个<strong class="kw iu">主题</strong>，你可以调用<strong class="kw iu">下一个</strong>来馈入<strong class="kw iu">值</strong>以及错误并完成。”</p></blockquote><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="339b" class="mz ls it mv b gy na nb l nc nd">private _searchSubject: Subject&lt;string&gt; = new Subject();</span></pre><p id="19e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们将向我们的组件添加一个<strong class="kw iu">输出</strong>，它将在去抖动 之后发出一个带有输入值<strong class="kw iu"> <em class="lq">的事件。这样，在用户输入完</em></strong>之后，就可以将我们需要的任何请求(或者处理过滤器逻辑，如果分页是在前端完成的话)绑定到提供的搜索字符串<strong class="kw iu">上。</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3647" class="mz ls it mv b gy na nb l nc nd">@Output() setValue: EventEmitter&lt;string&gt; = new EventEmitter();</span></pre><p id="76a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们需要创建订阅本身。我们将使用<em class="lq"> rxjs中的<strong class="kw iu"> <em class="lq">管道()</em> </strong>函数来完成。</em></p><blockquote class="mo mp mq"><p id="5874" class="ku kv lq kw b kx ky ju kz la lb jx lc mr le lf lg ms li lj lk mt lm ln lo lp im bi translated">“您可以使用<strong class="kw iu">管道</strong>将操作员连接在一起。管道允许您将多个函数组合成一个函数。<code class="fe ne nf ng mv b">pipe()</code>函数将您想要组合的函数作为其参数，并返回一个新函数，该函数在执行时会按顺序运行组合的函数。</p></blockquote><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7a7e" class="mz ls it mv b gy na nb l nc nd">constructor() {<br/>  this._setSearchSubscription();<br/>}</span><span id="0d4b" class="mz ls it mv b gy nh nb l nc nd">private _setSearchSubscription() {<br/>  this._searchSubject.pipe(<br/>    debounceTime(500)<br/>  ).subscribe((searchValue: string) =&gt; {<br/>    // Filter Function<br/>  });<br/>}</span></pre><p id="8b3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还使用了<strong class="kw iu"><em class="lq"/></strong>，一个由<em class="lq"> rxjs </em>库提供的操作符；其接收在触发订阅之前应该等待多少毫秒的输入。这里我们使用的是<em class="lq">500毫秒</em>，我相信这是一个相当不错的等待“按键间隔”的时间。</p><p id="6159" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq"> Angular Docs有一个关于rxjs库的简单页面，你可以查看下面的链接:</em><a class="ae ni" href="https://angular.io/guide/rx-library" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://angular.io/guide/rx-library</em></a><em class="lq"><br/>深入解释RxJS不是本文的目的，但是你可以在他们的文档中找到更多:</em><a class="ae ni" href="https://rxjs-dev.firebaseapp.com/api" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://rxjs-dev.firebaseapp.com/api</em></a></p><p id="fee6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们需要创建<strong class="kw iu">方法</strong>我们将<strong class="kw iu">将</strong>绑定到HTML <strong class="kw iu">输入</strong>，当用户在搜索栏(HTML输入元素)上键入时，它将<strong class="kw iu">触发我们的<em class="lq">主题</em> </strong>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c10c" class="mz ls it mv b gy na nb l nc nd">public updateSearch(searchTextValue: string) {<br/>  this._searchSubject.next( searchTextValue );<br/>}</span></pre><p id="b922" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有别忘了在<strong class="kw iu"> <em class="lq"> onDestroy </em> </strong>上<strong class="kw iu">退订它</strong>以免内存泄露<em class="lq">；</em>正如我之前在<a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/understanding-angular-life-cycle-hooks-91616f8946e3">理解角度生命周期挂钩</a>中所写的。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9aae" class="mz ls it mv b gy na nb l nc nd">ngOnDestroy() {<br/>  this._searchSubject.unsubscribe();<br/>}</span></pre><p id="9706" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要我们的模板标记，在这个例子中，这将是非常简单的；但是当然，在实际应用中，人们会相应地定制和设计它。为了将<strong class="kw iu">与<strong class="kw iu"> <em class="lq"> updateSearch </em> </strong>方法绑定，我们将使用<strong class="kw iu"> <em class="lq"> keyup </em> </strong>方法。</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3cb2" class="mz ls it mv b gy na nb l nc nd">&lt;input<br/>  type="text"<br/>  (keyup)="updateSearch($event.target.value)"<br/>/&gt;</span></pre><h2 id="52eb" class="mz ls it bd lt nj nk dn lx nl nm dp mb ld nn no md lh np nq mf ll nr ns mh nt bi translated">最终代码</h2><p id="cdcb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">因此，把我们所有的部分放在一起，这将是实现了<em class="lq">去抖</em>策略的搜索输入组件的最终代码。<em class="lq">使用时，该组件提供一个输入，该输入将触发一个事件，表明用户已经完成键入，因此我们可以向其添加任何我们需要的逻辑。</em></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a1de" class="mz ls it mv b gy na nb l nc nd">@Component({<br/>  selector: 'app-search-input',<br/>  template: `<br/>    &lt;input<br/>      type="text"<br/>      [placeholder]="placeholder"<br/>      (keyup)="updateSearch($event.target.value)"<br/>    /&gt;`<br/>})<br/>export class SearchInputComponent implements OnDestroy {</span><span id="8480" class="mz ls it mv b gy nh nb l nc nd">  // Optionally, I have added a placeholder input for customization <br/>  @Input() readonly placeholder: string = '';<br/>  @Output() setValue: EventEmitter&lt;string&gt; = new EventEmitter();</span><span id="8069" class="mz ls it mv b gy nh nb l nc nd">  private _searchSubject: Subject&lt;string&gt; = new Subject();</span><span id="092a" class="mz ls it mv b gy nh nb l nc nd">  constructor() {<br/>    this._setSearchSubscription();<br/>  }</span><span id="b197" class="mz ls it mv b gy nh nb l nc nd">  public updateSearch(searchTextValue: string) {<br/>    this._searchSubject.next( searchTextValue );<br/>  }</span><span id="52f3" class="mz ls it mv b gy nh nb l nc nd">  private _setSearchSubscription() {<br/>    this._searchSubject.pipe(<br/>      debounceTime(500)<br/>    ).subscribe((searchValue: string) =&gt; {<br/>      this.setValue.emit( searchValue );<br/>    });<br/>  }</span><span id="34f4" class="mz ls it mv b gy nh nb l nc nd">  ngOnDestroy() {<br/>    this._searchSubject.unsubscribe();<br/>  }</span><span id="ca28" class="mz ls it mv b gy nh nb l nc nd">}</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="6059" class="lr ls it bd lt lu ob lw lx ly oc ma mb jz od ka md kc oe kd mf kf of kg mh mi bi translated">分页组件</h1><p id="48bd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对于我们的分页组件，我们必须做两件主要的事情:<strong class="kw iu">呈现</strong>所有可能的<strong class="kw iu">页码</strong>供用户选择，以及<strong class="kw iu">检测</strong>何时<strong class="kw iu">页面已经改变</strong>以便从选择的页面中检索数据。</p><p id="82bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将向组件添加一个<em class="lq">输入</em>属性，以接收创建分页所需的信息:页面大小的<strong class="kw iu">和项目总数</strong>的<strong class="kw iu">。</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e62e" class="mz ls it mv b gy na nb l nc nd">export interface MyPagination {<br/>  itemsCount: number;<br/>  pageSize: number;<br/>}</span><span id="0d5f" class="mz ls it mv b gy nh nb l nc nd">export class PaginationComponent {</span><span id="86ff" class="mz ls it mv b gy nh nb l nc nd">  public pagesArray: Array&lt;number&gt; = [];<br/>  public currentPage: number = 1;</span><span id="df33" class="mz ls it mv b gy nh nb l nc nd">  @Input() set setPagination(pagination: MyPagination) {<br/>    if (pagination) {<br/>      const pagesAmount = Math.ceil(<br/>        pagination.itemsCount / pagination.pageSize<br/>      );</span><span id="3153" class="mz ls it mv b gy nh nb l nc nd">      this.pagesArray = new Array(pagesAmount).fill(1);<br/>    }<br/>  }<br/>}</span></pre><p id="0303" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到，我使用了一个setter来拦截接收到的输入属性，而不是直接输入属性。这是因为两件事:用<strong class="kw iu">对<em class="lq">pagesAmount</em></strong><em class="lq"/>进行舍入(如果由于任何原因它还没有舍入的话)，以及用<em class="lq"> pagesAmount </em>填充一个数字数组。</p><p id="f564" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，那我们为什么需要一组数字呢？以便为用户呈现所有可能的页面。在Angular中，我们不能直接获取一个数字，并要求一个*<em class="lq">NGF循环</em>特定的次数，所以这是我通常用来克服这个问题的一个策略。</p><p id="0ac9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们所做的是:使用一个数字数组，我们可以循环遍历它，并使用<em class="lq">索引</em>来检索我们想要的数字。因为我们想要的只是一个常规的有序数字列表，所以很容易实现，如下面的标记所示。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="c7e5" class="mz ls it mv b gy na nb l nc nd">&lt;span<br/>  *ngFor="let page of pagesArray; let index = index"<br/>  [ngClass]="{ 'active': currentPage === index + 1 } <br/>  (click)="setPage(index + 1)"<br/>&gt;<br/>  {{ index + 1 }}<br/>&lt;/span&gt;</span></pre><p id="db78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个标记中，我们<strong class="kw iu">呈现所有可能的页面</strong>供用户选择。我们添加了一个<em class="lq"> ngClass </em>来设置当前选中页面的样式，以便让用户知道他当前在哪个页面。此外，我们还插入了一个<strong class="kw iu"> <em class="lq">点击</em>动作</strong>，它将<strong class="kw iu">发出一个事件</strong>，让父组件知道所选页面已经更改。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3cec" class="mz ls it mv b gy na nb l nc nd">@Output() goToPage = new EventEmitter&lt;number&gt;();</span><span id="d971" class="mz ls it mv b gy nh nb l nc nd">public setPage(pageNumber: number): void {</span><span id="7ca1" class="mz ls it mv b gy nh nb l nc nd">  // Prevent changes if the same page was selected<br/>  if (pageNumber === this.currentPage)<br/>    return;</span><span id="4882" class="mz ls it mv b gy nh nb l nc nd">  this.currentPage = pageNumber;<br/>  this.goToPage.emit(pageNumber);<br/>}</span></pre><p id="e313" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们也添加<strong class="kw iu">两个箭头</strong>，让我们的用户生活更轻松；一到<strong class="kw iu">后退</strong>一页，一到<strong class="kw iu">前进</strong>一页。但是，当我们当前位于<strong class="kw iu">第一页</strong>时，我们将<strong class="kw iu">隐藏</strong><strong class="kw iu"><em class="lq">左箭头</em> </strong> <em class="lq"> </em>，当我们当前位于<strong class="kw iu">最后一页</strong>时，<strong class="kw iu">隐藏</strong><strong class="kw iu"><em class="lq">右箭头</em> </strong>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2adb" class="mz ls it mv b gy na nb l nc nd">&lt;span<br/> *ngIf="currentPage !== 1"<br/> (click)="setPage(currentPage - 1)"<br/>&gt;<br/>  &amp;lt; &lt;!-- This is the simbol for '&lt;' icon --&gt;<br/>&lt;/span&gt;</span><span id="4d16" class="mz ls it mv b gy nh nb l nc nd">&lt;span<br/>  *ngFor="let page of pagesArray; let index = index"<br/>  [ngClass]="{ 'active': currentPage === index + 1 } <br/>  (click)="setPage(index + 1)"<br/>&gt;<br/>  {{ index + 1 }}<br/>&lt;/span&gt;</span><span id="0750" class="mz ls it mv b gy nh nb l nc nd">&lt;span <br/>  *ngIf="currentPage !== pagesArray.length"<br/>  (click)="setPage(currentPage + 1)"<br/>&gt;<br/>  &amp;gt; &lt;!-- This is the simbol for '&gt;' icon --&gt;<br/>&lt;/span&gt;</span></pre><p id="77b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们这里还有一个<strong class="kw iu">问题</strong>！如果我们的<em class="lq"> itemsAmount </em>是几百，而我们的<em class="lq"> pageSize </em>很小怎么办？或者甚至成千上万个项目？我们将会一次<strong class="kw iu">呈现所有的页面</strong>，并且我们将会有一个非常糟糕的可用性，因为所有的数字都挂在那里。</p><p id="4403" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个问题有一些可能的设计解决方案，比如隐藏中间的页面，或者在某个数字后隐藏最后的页面。我要展示的这个很容易实现，我相信在某些情况下会很有趣；也就是<strong class="kw iu">将数字</strong>从打印改为使用一个<strong class="kw iu"> <em class="lq">选择html元素</em>，每页</strong>作为一个选项。</p><p id="e02d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，回到我们的标记，我们将在呈现页码的部分添加以下更改:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4f1d" class="mz ls it mv b gy na nb l nc nd">&lt;!-- Here I decided the max pages amount before changing the rendering strategy to be 10, but you could change it however you want it and even create an environment variable if necessary --&gt;<br/>&lt;ng-container *ngIf="pagesArray.length &lt;= 10" &gt;<br/>  &lt;span<br/>    *ngFor="let page of pagesArray; let index = index"<br/>    [ngClass]="{ 'active': currentPage === index + 1 }"<br/>    (click)="setPage(index + 1)"<br/>  &gt;<br/>    {{ index + 1 }}<br/>  &lt;/span&gt;<br/>&lt;/ng-container&gt;</span><span id="7a66" class="mz ls it mv b gy nh nb l nc nd">&lt;ng-container *ngIf="pagesArray.length &gt; 10" &gt;<br/>  &lt;select<br/>    [ngModel]="currentPage"<br/>    (ngModelChange)="setPage($event.target.value)"<br/>  &gt;<br/>    &lt;option<br/>      *ngFor="let p of pagesArray; let index = index"<br/>      [value]="(index + 1)" &gt;<br/>      {{ index + 1 }}<br/>    &lt;/option&gt;<br/>  &lt;/select&gt;<br/>&lt;/ng-container&gt;</span></pre><h2 id="181a" class="mz ls it bd lt nj nk dn lx nl nm dp mb ld nn no md lh np nq mf ll nr ns mh nt bi translated">最终代码</h2><p id="faa3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">因此，把我们所有的部分放在一起，这将是一个简单而有效的分页组件实现的最终代码。<em class="lq">它接收页面大小和项目总数的输入，并允许用户选择他想要查看的页面，触发指示所选页面的事件，以便处理所需的分页逻辑/请求。</em></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f75e" class="mz ls it mv b gy na nb l nc nd">export interface MyPagination {<br/>  itemsCount: number;<br/>  pageSize: number;<br/>}</span><span id="f12e" class="mz ls it mv b gy nh nb l nc nd">@Component({<br/>  selector: 'app-pagination',<br/>  template: `<br/>    &lt;div class="pagination" &gt;<br/>      &lt;span<br/>        *ngIf="currentPage !== 1"<br/>        (click)="setPage(currentPage - 1)"<br/>      &gt;<br/>        &amp;lt;<br/>      &lt;/span&gt;</span><span id="ea32" class="mz ls it mv b gy nh nb l nc nd">      &lt;ng-container *ngIf="pagesArray.length &lt;= 10" &gt;<br/>        &lt;span<br/>          *ngFor="let page of pagesArray; let index = index"<br/>          [ngClass]="{ 'active': currentPage === index + 1 }"<br/>          (click)="setPage(index + 1)"<br/>        &gt;<br/>          {{ index + 1 }}<br/>        &lt;/span&gt;<br/>      &lt;/ng-container&gt;</span><span id="be79" class="mz ls it mv b gy nh nb l nc nd">      &lt;ng-container *ngIf="pagesArray.length &gt; 10" &gt;<br/>        &lt;select<br/>          [ngModel]="currentPage"<br/>          (ngModelChange)="setPage($event.target.value)"<br/>        &gt;<br/>          &lt;option<br/>            *ngFor="let p of pagesArray; let index = index"<br/>            [value]="(index + 1)" &gt;<br/>            {{ index + 1 }}<br/>          &lt;/option&gt;<br/>        &lt;/select&gt;<br/>      &lt;/ng-container&gt;</span><span id="164c" class="mz ls it mv b gy nh nb l nc nd">      &lt;span <br/>        *ngIf="currentPage !== pagesArray.length"<br/>        (click)="setPage(currentPage + 1)"<br/>      &gt;<br/>        &amp;gt;<br/>      &lt;/span&gt;`,<br/>  styleUrls: ['./pagination.component.scss']<br/>})<br/>export class PaginationComponent {</span><span id="4fc9" class="mz ls it mv b gy nh nb l nc nd">  public pagesArray: Array&lt;number&gt; = [];<br/>  public currentPage: number = 1;</span><span id="a78c" class="mz ls it mv b gy nh nb l nc nd">  @Input() set setPagination(pagination: MyPagination) {<br/>    if (pagination) {<br/>      const pagesAmount = Math.ceil(<br/>        pagination.itemsCount / pagination.pageSize<br/>      );</span><span id="5af9" class="mz ls it mv b gy nh nb l nc nd">      this.pagesArray = new Array(pagesAmount).fill(1);<br/>    }<br/>  }</span><span id="6478" class="mz ls it mv b gy nh nb l nc nd">  public setPage(pageNumber: number): void {<br/>    if (pageNumber === this.currentPage)<br/>      return;</span><span id="69d0" class="mz ls it mv b gy nh nb l nc nd">    this.currentPage = pageNumber;<br/>    this.goToPage.emit(pageNumber);<br/>  }<br/>}</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="6256" class="lr ls it bd lt lu ob lw lx ly oc ma mb jz od ka md kc oe kd mf kf of kg mh mi bi translated">用法示例</h1><p id="8ccb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为了提供一个实际的例子，我将创建一个示例组件，其中我们有一个人员的分页列表，并希望允许用户搜索一个人的姓名，选择一个页面并过滤列表结果。</p><h2 id="4d1e" class="mz ls it bd lt nj nk dn lx nl nm dp mb ld nn no md lh np nq mf ll nr ns mh nt bi translated">搜索和分页模块</h2><p id="88fd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">首先，我们将为这些组件创建一个<strong class="kw iu">模块</strong>，我们可以将它导入到我们需要的模块中。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3d48" class="mz ls it mv b gy na nb l nc nd">@NgModule({<br/>  declarations: [<br/>    SearchInputComponent,<br/>    PaginationComponent<br/>  ],<br/>  imports: [<br/>    BrowserModule<br/>  ],<br/>  exports: [<br/>    SearchInputComponent,<br/>    PaginationComponent<br/>  ]<br/>})<br/>export class SearchAndPaginationModule { }</span></pre><p id="83c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，导入<strong class="kw iu">模块。</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b430" class="mz ls it mv b gy na nb l nc nd">...</span><span id="f918" class="mz ls it mv b gy nh nb l nc nd">@NgModule({<br/>  declarations: [<br/>    ...<br/>    ListComponent<br/>  ],<br/>  imports: [<br/>    ...<br/>    SearchAndPaginationModule<br/>  ],<br/>  providers: [<br/>    ...<br/>    MyService<br/>  ],<br/>  ...<br/>})<br/>export class ExampleModule { }</span></pre><p id="034d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们假设我们有一个<strong class="kw iu">服务</strong>与服务器通信来检索用户的信息。假设该方法接收一个<strong class="kw iu">搜索字符串</strong>和<strong class="kw iu">当前页面</strong>作为参数来过滤列表结果。</p><p id="36d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们将保持我们的标记非常简单，只是为了展示我们创建的组件可以如何使用。下面是一个组件的最终代码，它同时使用了我们的<strong class="kw iu">搜索组件</strong> <strong class="kw iu"> &amp; </strong> <strong class="kw iu">分页组件。</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="aa3f" class="mz ls it mv b gy na nb l nc nd">@Component({<br/>  selector: 'app-list',<br/>  template: `<br/>    &lt;app-search-input<br/>      placeholder="Search by name"<br/>      (setValue)="filterList($event)"<br/>    &gt;&lt;/app-search-input&gt;</span><span id="0549" class="mz ls it mv b gy nh nb l nc nd">    &lt;ul&gt;<br/>      &lt;li *ngFor="let user of users" &gt;<br/>        {{ user.name }}<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;</span><span id="912f" class="mz ls it mv b gy nh nb l nc nd">    &lt;app-pagination<br/>      [setPagination]="{<br/>        'itemsCount': totalUsersAmount,<br/>        'pageSize': 10<br/>      }"<br/>      (goToPage)="goToPage($event)"<br/>    &gt;&lt;/app-pagination&gt;</span><span id="f2bb" class="mz ls it mv b gy nh nb l nc nd">`<br/>})<br/>export class ListComponent implements OnInit {</span><span id="6d38" class="mz ls it mv b gy nh nb l nc nd">  public users: Array&lt;User&gt;;<br/>  public totalUsersAmount: number = 0;</span><span id="f47d" class="mz ls it mv b gy nh nb l nc nd">  private _currentPage: number = 1;<br/>  private _currentSearchValue: string = '';</span><span id="bd16" class="mz ls it mv b gy nh nb l nc nd">  constructor(<br/>    private _myService: MyService<br/>  ) { }</span><span id="8224" class="mz ls it mv b gy nh nb l nc nd">  ngOnInit() {<br/>    this._loadUsers(<br/>      this._currentPage,<br/>      this._currentSearchValue<br/>    );<br/>  }</span><span id="d550" class="mz ls it mv b gy nh nb l nc nd">  public filterList(searchParam: string): void {<br/>    this._currentSearchValue = searchParam;</span><span id="db20" class="mz ls it mv b gy nh nb l nc nd">    this._loadUsers(<br/>      this._currentPage,<br/>      this._currentSearchValue<br/>    );<br/>  }</span><span id="b1a2" class="mz ls it mv b gy nh nb l nc nd">  public goToPage(page: number): void {<br/>    this._currentPage = page;</span><span id="bd68" class="mz ls it mv b gy nh nb l nc nd">    this._loadUsers(<br/>      this._currentPage,<br/>      this._currentSearchValue<br/>    );<br/>  }</span><span id="8da4" class="mz ls it mv b gy nh nb l nc nd">  private _loadUsers(<br/>    page: number = 1, searchParam: string = '' <br/>  ) {<br/>    this._myService.getUsers(<br/>      page, searchParam<br/>    ).subscribe((response) =&gt; {<br/>      this.users = response.data.users;<br/>      this.totalUsersAmount = response.data.totalAmount;</span><span id="e350" class="mz ls it mv b gy nh nb l nc nd">    }, (error) =&gt; console.error(error));<br/>  }</span><span id="772b" class="mz ls it mv b gy nh nb l nc nd">}</span></pre><p id="edde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望有帮助😉</p><h2 id="20ff" class="mz ls it bd lt nj nk dn lx nl nm dp mb ld nn no md lh np nq mf ll nr ns mh nt bi translated"><strong class="ak">参考文献</strong></h2><p id="9c5f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae ni" href="https://angular.io/guide/rx-library" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://angular.io/guide/rx-library</em></a><em class="lq"><br/></em><a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/understanding-angular-life-cycle-hooks-91616f8946e3">https://it next . io/understanding-angular-life-cycle-hooks-91616 f 8946 E3</a><br/><a class="ae ni" href="https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter" rel="noopener ugc nofollow" target="_blank">https://angular . io/guide/component-interaction # intercept-input-property-changes-with-a-setter</a></p></div></div>    
</body>
</html>