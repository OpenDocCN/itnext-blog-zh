<html>
<head>
<title>Javascript Asynchronous Method Comparison: Callbacks, Promises, Async/Await, &amp; Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript异步方法比较:回调、承诺、异步/等待和生成器</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-asynchronous-method-comparison-callbacks-promises-async-await-generators-e689d579aba7?source=collection_archive---------9-----------------------#2018-03-06">https://itnext.io/javascript-asynchronous-method-comparison-callbacks-promises-async-await-generators-e689d579aba7?source=collection_archive---------9-----------------------#2018-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="76db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些只想快速比较的人，这里有TL；博士:</p><p id="2639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fjavascript-asynchronous-method-comparison-callbacks-promises-async-await-generators-e689d579aba7" rel="noopener ugc nofollow" target="_blank"> <em class="km">点击这里在LinkedIn </em>上分享这篇文章</a></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/44ed10b9f8cdbcd6044495f3f874169e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpv7JoS0UWTvUfEP8scbAw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">函数的定义以及如何使用每种方法的示例</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/84790c4a2897a19c4a7ffe5b07ce09f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Ejj9gtD9atsy2nC8bzvxNA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">用作回调的logData数据函数及其输出</figcaption></figure><p id="49a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释:</p><p id="b1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写这篇文章的目的是让读者对Javascript中的异步方法有一些简单的了解。每当我们使用异步函数时，这些方法都有巨大的潜在应用，异步函数是指不一定按照代码在屏幕上出现的顺序来执行代码的函数。异步方法的几种用法包括向外部API发出HTTP请求，从服务器检索数据，或者允许使用setTimeout延迟操作。我用函数getJSON模拟检索JSON。</p><p id="a812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="c501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示我们的<strong class="jp ir"> <em class="km"> getJSON </em> </strong>函数的用法，让我们创建一个日志记录函数来记录它的输出:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="84fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想调用这个函数五次，我们将开始看到圣诞树，或者“回调地狱”出现:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="8756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于许多调用来说，这显然不太理想，因为这些嵌套调用越来越深，而且没有简单的方法来适应for循环的使用。这让我们有了承诺:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="aad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们上面的getJSONPromise函数类似于getJSON，但是我们没有调用传入的回调，而是使用resolve参数，该参数将在将来的某个时候返回fakeJSON数据。同样，我们可以使用我们的<strong class="jp ir"> <em class="km"> LogData </em> </strong>函数，但是我们也需要让它返回一个承诺。我们的async代码的promise版本比callback版本短，它在页面中是线性的，而不是不断扩展的圣诞树，并且它可以很容易地适用于<strong class="jp ir"> <em class="km"> for循环</em> </strong>:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="2727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Async/Await与承诺并没有什么不同。它的语法类似于同步函数，在同步函数中，将调用的输出设置为等于一个变量。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="c720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要测试这个函数，只需调用。没有回调地狱，也没有长长的承诺链。因为每个调用都在等待下一个调用，所以我们也可以在这里使用一个<strong class="jp ir"> <em class="km"> for循环</em> </strong>:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="3bc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们有发电机。并非巧合的是，这段代码看起来非常类似于promises和async/await。在幕后，async/await使用生成器。当<strong class="jp ir"> <em class="km">发生时，setTimeout内部的异步行为发生。next() </em> </strong>被调用，返回<strong class="jp ir"> <em class="km"> yield </em> </strong>定义的值。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="cd4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试它，我们必须创建一个生成器函数来确定当我们<strong class="jp ir"> <em class="km">产生</em> </strong>时的行为，并调用我们的函数。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="bb3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望您喜欢这篇描述Javascript异步方法的文章。将来，我想通过探索每种方法的错误处理来扩展这一点，并额外探索RxJS可观察性。感谢阅读！</p></div></div>    
</body>
</html>