<html>
<head>
<title>Reducing Flutter App Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少抖动应用程序的大小</h1>
<blockquote>原文：<a href="https://itnext.io/reducing-flutter-app-size-570db9810ebb?source=collection_archive---------0-----------------------#2020-04-11">https://itnext.io/reducing-flutter-app-size-570db9810ebb?source=collection_archive---------0-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0a9e756f6bb9ed0e02de572575a2ddd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*mbnwW96IMQG4NcldNAI3ZA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">减少抖动应用程序的大小</figcaption></figure><p id="7bf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序的大小非常重要。它有两个维度:下载大小play store上应用程序的大小/下载时/安装时的大小，以及安装大小——这是当你下载应用程序、解压缩、编译和优化它时会发生的事情。这大大扩展了应用程序，可以是安装大小的两倍、三倍甚至更多。你为什么要关心这些尺寸呢？</p><h1 id="dcf7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">下载大小</h1><p id="be1b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当用户在play store上安装应用程序时，他会看到加载栏和实际的应用程序大小。应用程序越大，下载失败/取消的几率就越大。作为开发者，我们希望让应用程序变小，这样我们的应用程序就能获得尽可能多的分发。</p><h1 id="8cb1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安装尺寸</h1><p id="7e18" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这也有类似的现象。用户用视频、音频、图像填充他们的手机，在某个时间点，他们会尝试安装一个新的应用程序，但糟糕的是没有空间了😪😪😪。他们会去寻找空间，去设置，检查哪个应用程序消耗更多的空间。即使在试图从play store下载时，它也建议他们删除一些应用程序以适应新的应用程序，甚至给他们一些建议。</p><h1 id="75ea" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们来分析一些APK</h1><p id="847a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">因此，我将分析一个发布应用程序的签名apk。我将使用ncovid应用程序——一个新冠肺炎新闻应用程序，带有统计数据和跟踪仪表板，其GitHub repo可用于<a class="ae lz" href="https://github.com/Mastersam07/ncovid" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">这里</strong> </a>。你可以查看回购协议上的发行标签。我们将在这里 分析预发布版本0.8可用的<a class="ae lz" href="https://github.com/Mastersam07/ncovid/releases/tag/v0.8" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">。</strong></a></p><p id="6b1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们启动android studio并打开项目。在android studio上打开项目，点击Build &gt;&gt; Analyze Apk并选择Apk。我将要分析的apk在<a class="ae lz" href="https://github.com/Mastersam07/ncovid/releases/tag/v0.8" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">这里</strong> </a>可用。您应该会看到一个与下图类似的屏幕。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/72c7d52461401d6d5db238c875d38873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDi74sJoVKb19rSwnY0gNQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">分析Apk</figcaption></figure><p id="7b44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到95%的应用程序大小被<strong class="ka ir"> lib占用。</strong>展开<strong class="ka ir"> lib </strong>，我们看到三个不同的编译二进制文件。这告诉我们什么？🤔🤔🤔…….用于构建发布应用程序的命令应该是<code class="fe mj mk ml mm b">flutter build apk --release</code>。分析还告诉我们，该应用程序是一个胖apk，包括android-arm、android-arm64和android-x64的二进制文件。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/29710182ae136e644e58abc586ed7e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSnb4CPFtAuSYiUtAb0mSw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">分析Apk</figcaption></figure><h2 id="bd92" class="mn kx iq bd ky mo mp dn lc mq mr dp lg kj ms mt lk kn mu mv lo kr mw mx ls my bi translated">解决fat apk问题</h2><p id="246c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了解决这个问题，如果我们上传到playstore，我们可以构建一个应用捆绑包，或者我们可以按照abi拆分apk，将apk拆分为x64和x86位代码。</p><p id="3fa6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了构建app bundle，我们运行命令<code class="fe mj mk ml mm b">flutter build appbundle</code>，该命令包含为<a class="ae lz" href="https://developer.android.com/ndk/guides/abis#v7a" rel="noopener ugc nofollow" target="_blank"> armeabi-v7a </a> (ARM 32位)、<a class="ae lz" href="https://developer.android.com/ndk/guides/abis#arm64-v8a" rel="noopener ugc nofollow" target="_blank"> arm64-v8a </a> (ARM 64位)和<a class="ae lz" href="https://developer.android.com/ndk/guides/abis#86-64" rel="noopener ugc nofollow" target="_blank">x86–64</a>(x86 64位)编译的flutter运行时的dart代码，或者我们也可以使用命令<code class="fe mj mk ml mm b">flutter build appbundle --target-platform android-arm,android-arm64,android-x64</code>拆分app bundle。</p><p id="6873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了分割apk，我们运行命令<code class="fe mj mk ml mm b">flutter build apk --split-per-abi</code>。这将显著减小应用程序的大小。此处 有<a class="ae lz" href="https://github.com/Mastersam07/ncovid/releases/tag/v0.9" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">的拆分apk。</strong></a></p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="052c" class="kw kx iq bd ky kz ng lb lc ld nh lf lg lh ni lj lk ll nj ln lo lp nk lr ls lt bi translated">处理图像资产</h1><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/e07d05e607d80542ebf1345c6a10a586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xIPO803e60Te91RCsAgxQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">分析资产</figcaption></figure><p id="dc9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看上面的图像，它说资产占用了大约439.5kb，其中图像占48.7kb，文档占1.4kb，字体占61.5kb。这就引出了一个问题“如果使用了应用程序图像，它们在哪里？”。</p><p id="22e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案很简单。除了将图像资产捆绑在应用程序中，用户可以将图像托管在firebase等外部服务上，并使用包<strong class="ka ir"> cached_network_image在应用程序中调用这些图像。</strong>第一次启动应用程序时，软件包会从提供的URL获取图像并缓存，因此您在后续使用应用程序时会获得缓存的图像，因此这些图像不会占用下载空间，因为它们没有捆绑在应用程序中。你可以在这里  <strong class="ka ir">查看pub.dev <a class="ae lz" href="https://pub.dev/packages/cached_network_image" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">上的包。</strong></a></strong></p><h1 id="c572" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">压缩png和jpg</h1><p id="c83d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">每当你不得不在应用程序中使用图像，比如漫游屏幕，并且你不想从外部主机调用图像时，你应该压缩你的png和jpg，因为高质量的png和jpg会增加应用程序的大小。你可以在谷歌上快速搜索压缩png和jpg的工具。</p><h1 id="36ac" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用。svg格式图标</h1><p id="a573" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们应该对矢量绘图说欢迎，对png说再见，因为使用它们有很多好处。人们不需要担心不同的设备DPI，这也有助于减少apk的大小。</p><p id="0b3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你从谷歌<a class="ae lz" href="https://design.google.com/icons/" rel="noopener ugc nofollow" target="_blank">材质设计图标库</a>下载系统app图标时，下载。svg格式，而不是。png</p><h1 id="f96b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用特定的库</h1><p id="9f8d" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">应该避免调用我们的pubspec.yaml文件中不需要或不使用的包。一旦构建好你的应用程序，你应该检查你的pubspec.yaml并删除那些没有被使用的库/包。</p><h1 id="b9d1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用谷歌字体</h1><p id="1335" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">字体是应用程序膨胀的一个来源。它们很重，卡在app里。当然，你的UX需要它们。你可能想使用google_fonts包，而不是在应用程序中捆绑字体。使用<code class="fe mj mk ml mm b">google_fonts</code>包，<code class="fe mj mk ml mm b">.ttf</code>或<code class="fe mj mk ml mm b">.otf</code>文件不需要存储在assets文件夹中，也不需要映射到pubspec.yaml文件中。相反，它们可以在运行时通过HTTP获取一次，并缓存在应用程序的文件系统中。这类似于原生android开发中的可下载字体。可以在 这里查看pub.dev <a class="ae lz" href="https://pub.dev/packages/google_fonts" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">上的包。</strong></a></p><h1 id="44fa" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用Proguard</h1><p id="fd7f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Proguard是一个java程序优化器。它以不改变功能的方式优化您的代码，但是改变表示使它更紧凑。它混淆了类型、字段、方法的名称，其中原始名称并不重要，因此为了提高效率，长名称被替换为短字符串，如a和b。包和类可能有一个很长的名字，但是不应该妨碍效率。它还从依赖项中删除了未使用的java代码。要设置proguard，请确保您的<app dir=""> /android/app/build.gradle中的构建类型如下所示:</app></p><pre class="mb mc md me gt nl mm nm nn aw no bi"><span id="f2ff" class="mn kx iq mm b gy np nq l nr ns">buildTypes {<br/>        release {<br/>            minifyEnabled true // add this<br/>            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' // add this<br/>            signingConfig signingConfigs.release // this is default for release<br/>        }<br/>    }</span></pre><p id="eff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同一个目录中，创建proguard-rules.pro文件，并添加以下代码:</p><pre class="mb mc md me gt nl mm nm nn aw no bi"><span id="ade3" class="mn kx iq mm b gy np nq l nr ns">## Flutter wrapper<br/> -keep class io.flutter.app.** { *; }<br/> -keep class io.flutter.plugin.** { *; }<br/> -keep class io.flutter.util.** { *; }<br/> -keep class io.flutter.view.** { *; }<br/> -keep class io.flutter.** { *; }<br/> -keep class io.flutter.plugins.** { *; }<br/># -keep class com.google.firebase.** { *; } // uncomment this if you are using firebase in the project<br/> -dontwarn io.flutter.embedding.**<br/> -ignorewarnings</span></pre><p id="6d85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还应该转到gradle.properties，并将下面的代码片段添加到其中:</p><pre class="mb mc md me gt nl mm nm nn aw no bi"><span id="2094" class="mn kx iq mm b gy np nq l nr ns">extra-gen-snapshot-options=--obfuscate</span></pre><h1 id="f05f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">资源萎缩</h1><p id="3696" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这将proguard的死代码消除的概念扩展到了资源。在<app dir=""> /android/app目录下的build.gradle文件中，您的构建类型应该是这样的:</app></p><pre class="mb mc md me gt nl mm nm nn aw no bi"><span id="4480" class="mn kx iq mm b gy np nq l nr ns">buildTypes {<br/>        release {<br/>            minifyEnabled true // added previously<br/>            shrinkResources true // add this<br/>            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' // added previously<br/>            signingConfig signingConfigs.release // added previously<br/>        }<br/>    }</span></pre><p id="af2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们想要的🙂🙂🙂。在所有这些调整和配置之后，您应该运行“<strong class="ka ir">解决fat apk问题</strong>”中提到的发布命令。如果您打算发送到playstore或在必要时拆分apk，请生成一个应用捆绑包。</p><p id="6824" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有任何问题，请随时发表评论🙂。</p><h1 id="a8d7" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">有益链接</h1><p id="5b48" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://flutter.dev/docs/deployment/android" rel="noopener ugc nofollow" target="_blank">构建并发布一款android应用</a> <br/> <a class="ae lz" href="https://flutter.dev/docs/perf/app-size" rel="noopener ugc nofollow" target="_blank">测量你的应用大小</a> <br/> <a class="ae lz" href="https://flutter.dev/docs/deployment/obfuscate" rel="noopener ugc nofollow" target="_blank">混淆飞镖代码</a> <br/> <a class="ae lz" href="https://www.youtube.com/watch?v=AdfKNgyT438" rel="noopener ugc nofollow" target="_blank">精简你的应用大小的最佳实践(Google I/O’17)</a></p></div></div>    
</body>
</html>