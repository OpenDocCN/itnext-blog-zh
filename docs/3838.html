<html>
<head>
<title>Untangling SQL deadlocks — Consultancy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开SQL死锁—咨询</h1>
<blockquote>原文：<a href="https://itnext.io/untangling-sql-deadlocks-consultancy-db5c83de5a7e?source=collection_archive---------4-----------------------#2020-03-07">https://itnext.io/untangling-sql-deadlocks-consultancy-db5c83de5a7e?source=collection_archive---------4-----------------------#2020-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/019adfb8b9478b83f8e8ecaacf16ec87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vT-_LOgZBNzgMlPfgt7ghA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.reddit.com/r/pics/comments/6qulze/traffic_deadlock/" rel="noopener ugc nofollow" target="_blank"> Reddit </a>的交通僵局图片</figcaption></figure><h1 id="9b8a" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">简报会</h1><p id="c845" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">客户是一家大型运输公司，该咨询公司的目标是解决SQL Server 2008上的间歇性死锁，当这些死锁发生在交易中时，将会损失金钱、公司形象和员工时间。</p><p id="fc64" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">操作这个数据库的应用程序被编写成以COM+运行的Vb.net。是的，COM+，我也不知道这是什么，这是一种将应用程序作为软件组件运行的技术，由微软于1993年推出。<a class="ae kf" href="https://en.wikipedia.org/wiki/Component_Object_Model" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="aa36" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这家公司位于离巴西圣保罗很近的一个城市，所以我一大早就坐车去了那里。我在公司的第一天，我的死锁知识非常基础，我知道什么是概念，但是我不知道数据库引擎锁定的细节。</p><h1 id="b74f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">初步调查</h1><p id="43c4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我首先询问开发人员他们认为死锁的原因是什么，我得到的答案是:“这是数据库故障”，您可以猜到DBA的答案很简单:“这是应用程序故障”。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8248cbcc7b1948ad24df0b49cb9e3f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*MzjgCp8QadFdx3ah"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">两个男人互相指着对方— <a class="ae kf" href="https://rabblerouserruminations.wordpress.com/2016/10/24/%F0%9F%91%89-finger-pointing-phonies-%F0%9F%91%88-open-thread/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="554b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">DBA向我展示了发生死锁时的现有SQL Profiler会话，有正常的查询，但没有任何关于死锁发生原因的明显信息。</p><p id="6bd6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我的第一轮调查只是简单地看了一下代码。从中我发现了一些非常糟糕的做法，它们会浪费应用程序内存、网络使用，并且可维护性很低:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/c01cfc12972422e43d725010a30e9084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6-wSmM_q1QtXZUZQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有不良字符串连接的VB.net内联SQL查询</figcaption></figure><p id="9488" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但尽管如此，我还是离死锁更近了一步，所以我回家后在回家的公交车上看了一堂关于死锁的课程。这给了我解决这个问题所需的所有工具，因为它教会了我SQL 使用的<a class="ae kf" href="https://technet.microsoft.com/en-us/library/ms175519(v=sql.105).aspx" rel="noopener ugc nofollow" target="_blank">类型的锁、它们的粒度，尤其是如何使用SQL Profiler(<strong class="lg iu">Deadlock graph event)捕获死锁的可视化表示。</strong></a></p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/bbac832c0f0af5d834f7154969e4abb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1HHmB8mfWDI6PKKb.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">SQL事件探查器死锁图形事件</figcaption></figure><p id="8d38" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">SQL Profiler给我的几乎所有死锁的图表如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/272c510bc3e02fb2ee64cb590264a074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zhr8WGTTq9E8HMpx.png"/></div></div></figure><p id="45b9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">非常好的代表性不是吗？它不仅能告诉你谁阻塞了什么，还能给出发生冲突的锁的类型。诊断中奇怪的是这个“请求模式:范围-S”，这意味着一个键范围共享锁。为什么我们会有这样的锁？</p><p id="a477" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">以下是关于Key-range的<a class="ae kf" href="https://docs.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver15#Lock_Engine" rel="noopener ugc nofollow" target="_blank"> MSDN文档</a>:</p><blockquote class="mp mq mr"><p id="35b3" class="le lf ms lg b lh mc lj lk ll md ln lo mt me lr ls mu mf lv lw mv mg lz ma mb im bi translated">使用<strong class="lg iu">可序列化事务隔离级别</strong>时，保护查询读取的行的范围。确保在可序列化事务的查询再次运行时，其他事务无法插入符合该查询的行。</p></blockquote><p id="2264" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您不知道事务<a class="ae kf" href="https://docs.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver15#Lock_Basics" rel="noopener ugc nofollow" target="_blank">隔离级别</a>定义了什么:</p><blockquote class="mp mq mr"><p id="ee81" class="le lf ms lg b lh mc lj lk ll md ln lo mt me lr ls mu mf lv lw mv mg lz ma mb im bi translated">事务指定一个隔离级别，该级别定义了一个事务必须与其他事务所做的资源或数据修改隔离的程度。隔离级别是根据允许哪些并发副作用(如脏读或幻像读)来描述的。</p></blockquote><p id="7595" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">记住，我们在死锁图上得到的锁来自一个<strong class="lg iu">可串行化事务级别</strong>，这是定义:</p><ul class=""><li id="c73f" class="mw mx it lg b lh mc ll md lp my lt mz lx na mb nb nc nd ne bi translated"><strong class="lg iu">可串行化</strong> —事务彼此完全隔离的最高级别。SQL Server数据库引擎保留对选定数据获取的读写锁，以便在事务结束时释放。当SELECT操作使用范围内的WHERE子句时，会获得范围锁，特别是为了避免幻像读取。</li></ul><p id="f573" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在同一个MSDN链接上，您可以看到其他类型的事务处理级别:</p><ul class=""><li id="ca58" class="mw mx it lg b lh mc ll md lp my lt mz lx na mb nb nc nd ne bi translated"><strong class="lg iu"> Read uncommitted </strong> —最低的隔离级别，其中事务被隔离，仅足以确保物理损坏的数据不被读取。在这个级别中，允许脏读，因此一个事务可能会看到其他事务所做的尚未提交的更改。</li><li id="c871" class="mw mx it lg b lh nf ll ng lp nh lt ni lx nj mb nb nc nd ne bi translated"><strong class="lg iu"> Read committed(默认)</strong> —允许一个事务读取另一个事务先前读取(未修改)的数据，而无需等待第一个事务完成。SQL Server数据库引擎保持写锁(对所选数据获取的锁)直到事务结束，但是读锁会在执行SELECT操作后立即释放。</li><li id="b0d2" class="mw mx it lg b lh nf ll ng lp nh lt ni lx nj mb nb nc nd ne bi translated"><strong class="lg iu">可重复读取</strong>—SQL Server数据库引擎保持对所选数据获取的读写锁，直到事务结束。但是，因为范围锁不受管理，所以可能会发生幻像读取。</li></ul><p id="30e8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">好吧，还是很奇怪，为什么事务使用最严格的事务隔离级别？我向数据库管理员展示了我的发现，他们仍然指责应用程序。我问了开发人员，他们归咎于数据库。</p><p id="3f40" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，我们检查了数据库中的默认隔离级别，它是“ReadCommited”，这是正确的。所以我的范围是为什么有些事务是可序列化的？</p><p id="44e7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我灵光一现，记起我们使用的是COM+，于是我谷歌了一下“COM+默认事务隔离级别”，然后<a class="ae kf" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms685131(v=vs.85).aspx" rel="noopener ugc nofollow" target="_blank">得到了这个</a>:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/66140272e794d39a6fba1b04fb7acf78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fXIpeBJTmyIxs_Ov.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">MSDN文档— COM+将默认隔离级别设置为Serializable</figcaption></figure><p id="0365" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">所以这只是COM+的默认隔离级别。迁移到不同于默认隔离级别的隔离级别可以阻止死锁的发生，因为现在锁没有那么严格了。</p><h2 id="f236" class="nl kh it bd ki nm nn dn km no np dp kq lp nq nr ku lt ns nt ky lx nu nv lc nw bi translated">结论</h2><p id="1de8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">希望在这里您可以第一次接触到事务级的一些内部知识，锁定SQL Server，以及如何在需要时捕获死锁事件。</p><p id="943a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有时，问题会跨越不同角色的边界，在这种情况下是在DBA和开发人员之间。我相信一种更加合作的态度可以帮助你跨越界限，为你的公司解决问题。</p></div></div>    
</body>
</html>