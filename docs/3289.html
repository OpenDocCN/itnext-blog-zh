<html>
<head>
<title>Getting Started with Express JS for the Impatient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为不耐烦的人开始使用Express JS</h1>
<blockquote>原文：<a href="https://itnext.io/getting-started-with-express-js-for-the-impatient-9177fc0e1b49?source=collection_archive---------3-----------------------#2019-11-14">https://itnext.io/getting-started-with-express-js-for-the-impatient-9177fc0e1b49?source=collection_archive---------3-----------------------#2019-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个快速代码和许多链接</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2bef58aa88914d864b9bffdfe340c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WYBwGuz6_DH1QkE8hvOJw.png"/></div></div></figure><p id="f0ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你是否知道另一个框架，比如Rails或Django，但是想看看在Express中使用fullstack js是什么感觉？太好了，你就是目标观众。我们将涉及很多内容，但请不要着急，请<em class="lq">边走边查看链接。</em></p><h2 id="cb0f" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">概观</h2><ol class=""><li id="c777" class="mk ml it kw b kx mm la mn ld mo lh mp ll mq lp mr ms mt mu bi translated">最简单的应用程序</li><li id="dc43" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated">解释中间件</li><li id="6cf2" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated">服务静态资产</li><li id="fb42" class="mk ml it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated">使用路由器和路由</li></ol><p id="6878" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目标是有一个静态的主页和一个API对话。我假设你有<a class="ae na" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">节点安装</a>和JS经验，所以我们不会处理那个。</p><h1 id="f1f7" class="nb ls it bd lt nc nd ne lw nf ng nh lz jz ni ka mc kc nj kd mf kf nk kg mi nl bi translated">0.文件结构和安装</h1><p id="2b37" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">制作这些文件:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="c22e" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu"><em class="lq">public/</em></strong><br/> └ index.html<br/> └ styles.css<br/><strong class="nq iu"><em class="lq">src/</em></strong><br/> └ index.js<br/> └ <strong class="nq iu"><em class="lq">routes/</em></strong><br/>   └ index.js<br/>   └ <strong class="nq iu"><em class="lq">users/</em></strong><br/>     └ get.js<br/>     └ list.js<br/>     └ index.js<br/>package.json</span></pre><p id="cc54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将它们留空，但将它复制到您的<code class="fe ny nz oa nq b">package.json</code>:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="7369" class="lr ls it nq b gy nu nv l nw nx">{<br/>  "name": "express-practice",<br/>  "version": "0.0.0",<br/>  "private": true,<br/>  "scripts": {<br/>    "start": "nodemon src/server.js"<br/>  },<br/>  "dependencies": {<br/>    "express": "~4.16.1"<br/>  },<br/>  "devDependencies": {<br/>    "nodemon": "^1.19.4"<br/>  }<br/>}</span></pre><p id="73d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行<code class="fe ny nz oa nq b">npm install</code>就大功告成了！(<a class="ae na" href="https://nodemon.io" rel="noopener ugc nofollow" target="_blank"> nodemon文档</a>)。</p><h1 id="1df8" class="nb ls it bd lt nc nd ne lw nf ng nh lz jz ni ka mc kc nj kd mf kf nk kg mi nl bi translated">1.最简单的应用程序</h1><p id="33bd" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">想在3秒钟内编写一个express应用程序吗？复制这个:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="1015" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu"><em class="lq">/* src/server.js */<br/></em></strong>const <strong class="nq iu">express</strong> = require('<em class="lq">express</em>');</span><span id="9296" class="lr ls it nq b gy ob nv l nw nx">const <strong class="nq iu">app</strong> = <strong class="nq iu">express</strong>();</span><span id="2315" class="lr ls it nq b gy ob nv l nw nx"><em class="lq">/* home route */</em><br/><strong class="nq iu">app.</strong>get('/', (<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>, <strong class="nq iu">next</strong>) =&gt; {<br/>  <strong class="nq iu">res</strong>.send('<em class="lq">hello there</em>');<br/>});</span><span id="d678" class="lr ls it nq b gy ob nv l nw nx"><em class="lq">/* start the app */</em><br/>const <strong class="nq iu">port</strong> = <strong class="nq iu">process</strong>.env.<strong class="nq iu">PORT </strong>|| 4321;<br/>const <strong class="nq iu">host</strong> = '<em class="lq">0.0.0.0</em>';<br/>app.listen(<strong class="nq iu">port</strong>, <strong class="nq iu">host</strong>, () =&gt; {<br/>  <strong class="nq iu">console</strong>.log(`<a class="ae na" href="http://localhost:${port}`);" rel="noopener ugc nofollow" target="_blank"><em class="lq">http://localhost:</em>${<strong class="nq iu">port</strong>}<em class="lq">`</em>);</a><br/>});</span></pre><p id="8d34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行<code class="fe ny nz oa nq b">npm start</code>，你应该会在主页面上看到文本。现在它运行了，我们来解释一下:</p><h2 id="ae83" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">快递和app</h2><p id="bede" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我们需要<code class="fe ny nz oa nq b">express</code>，它返回一个对象。如果我们调用它，一个顶层函数返回一个<code class="fe ny nz oa nq b">express</code>应用程序的实例。99%的时间它被称为<code class="fe ny nz oa nq b">app</code>，所以叫它，除非你想变得困难。这个<code class="fe ny nz oa nq b">app</code>是我们放所有东西的地方，比如我们的(临时)回家路线。</p><h2 id="c907" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">。获取和路由处理程序</h2><p id="0f69" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我们使用<code class="fe ny nz oa nq b">app.get</code>方法，它采用一个路径和一个中间件函数。<a class="ae na" href="http://expressjs.com/en/4x/api.html#app.METHOD" rel="noopener ugc nofollow" target="_blank">有所有的http动词</a>，所以<code class="fe ny nz oa nq b">.post</code>、<code class="fe ny nz oa nq b">.delete</code>等等，但是我们会保持简单，只使用<code class="fe ny nz oa nq b">.get</code>。我们也只使用了一个中间件回调，但是有可能使用多个。这又是我们的:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b223" class="lr ls it nq b gy nu nv l nw nx">(<strong class="nq iu">request, response, next</strong>) =&gt; {<strong class="nq iu"><br/>  response.</strong>send('<em class="lq">hello there</em>');<strong class="nq iu"><br/></strong>});</span></pre><p id="f919" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它总是接受这三个参数，即<code class="fe ny nz oa nq b">request</code>对象、<code class="fe ny nz oa nq b">response</code>对象和<code class="fe ny nz oa nq b">next</code>函数(稍后会详细介绍)。<a class="ae na" href="https://expressjs.com/en/4x/api.html#req" rel="noopener ugc nofollow" target="_blank">请求对象</a>保存有用的东西，比如你的参数；您的<a class="ae na" href="https://expressjs.com/en/4x/api.html#res" rel="noopener ugc nofollow" target="_blank">响应对象</a>包含了<a class="ae na" href="http://expressjs.com/en/guide/routing.html#response-methods" rel="noopener ugc nofollow" target="_blank">响应方法</a>。您将使用最多的是<code class="fe ny nz oa nq b">res.send()</code>，因为它可以发送JSON。这里我们只是向客户端发送文本。</p><h2 id="ecd9" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">启动应用程序</h2><p id="49c0" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">最后，我们通过告诉我们的应用程序在主机<code class="fe ny nz oa nq b">‘0.0.0.0’</code>上监听<a class="ae na" href="https://stackoverflow.com/questions/18864677/what-is-process-env-port-in-node-js" rel="noopener ugc nofollow" target="_blank">端口环境变量</a>来结束它。你不必包括主机，它默认为<code class="fe ny nz oa nq b">localhost</code>但是<code class="fe ny nz oa nq b">‘0.0.0.0’</code> <a class="ae na" href="https://stackoverflow.com/questions/20778771/what-is-the-difference-between-0-0-0-0-127-0-0-1-and-localhost" rel="noopener ugc nofollow" target="_blank">防止Docker问题</a>。您还可以在它启动时给它一个回调来运行。我写下了网址，这样我就可以从<a class="ae na" href="https://iterm2.com/" rel="noopener ugc nofollow" target="_blank"> iterm </a>用cmd+点击它。</p><p id="54dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有它！那是你的第一个快递应用。但是你不了解中间件就不能使用Express，所以我们就多谈谈这个吧。</p><h1 id="dfab" class="nb ls it bd lt nc nd ne lw nf ng nh lz jz ni ka mc kc nj kd mf kf nk kg mi nl bi translated">2.解释中间件</h1><p id="cf4d" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">中间件是模块化的答案。你实际上是告诉你的应用程序使用一系列的函数来做一些事情，比如记录或者修改请求。在每个函数结束时，它调用下一个函数，<strong class="kw iu"> <em class="lq">总是</em> </strong>调用<code class="fe ny nz oa nq b">next</code>。最终，请求将前进到实际的路由(它本身是一个中间件功能)并向客户端发送响应。<em class="lq">中间件</em> <strong class="kw iu"> <em class="lq">必须</em> </strong> <em class="lq">通过调用</em> <code class="fe ny nz oa nq b"><em class="lq">next</em></code> <em class="lq">回调或者向客户端发送响应来结束。</em></p><h2 id="61ed" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">添加一些中间件:</h2><p id="b229" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我们打算这样做，以便每次我们找到一个路由时，我们将记录到节点控制台的路径。为了演示，我将向<code class="fe ny nz oa nq b">request</code>对象添加一个属性，我们稍后可以访问:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="076c" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu"><em class="lq">/* src/server.js */</em></strong><br/>const <strong class="nq iu">express</strong> = require('<em class="lq">express</em>');</span><span id="7069" class="lr ls it nq b gy ob nv l nw nx">const <strong class="nq iu">app</strong> = <strong class="nq iu">express</strong>();</span><span id="4271" class="lr ls it nq b gy ob nv l nw nx"><em class="lq">/* new logging middleware */</em><br/><strong class="nq iu">app</strong>.use((<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>, <strong class="nq iu">next</strong>) =&gt; {<br/>  <strong class="nq iu">console.</strong>log(`<em class="lq">hit: </em>${<strong class="nq iu">req</strong>.originalUrl}`);<br/>  <strong class="nq iu">req</strong>.test = '<em class="lq">wow</em>';<br/>  <strong class="nq iu">next</strong>();<br/>});</span><span id="51a4" class="lr ls it nq b gy ob nv l nw nx"><em class="lq">/* home route */</em><br/><strong class="nq iu">app.</strong>get('/', (<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>, <strong class="nq iu">next</strong>) =&gt; {<br/>  <strong class="nq iu">console</strong>.log('<em class="lq">req.test</em>: ', <strong class="nq iu">req.</strong>test);<br/>  res.send('<em class="lq">hello there</em>');<br/>});</span><span id="c836" class="lr ls it nq b gy ob nv l nw nx">// ...rest of app...</span></pre><p id="3142" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过调用<code class="fe ny nz oa nq b"><a class="ae na" href="https://stackoverflow.com/questions/11321635/nodejs-express-what-is-app-use" rel="noopener ugc nofollow" target="_blank">app.use</a></code>,我们向应用程序注册了中间件。我们调用了<code class="fe ny nz oa nq b">next</code>函数，这样请求将在我们登录后继续它们的路由。请注意，我们没有给出路线参数，这意味着这个中间件将应用于应用程序上的每一条路线。但这并不总是需要的，所以有时您需要一个路由参数:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="59d5" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu">app</strong>.use('/<em class="lq">specific</em>', (<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>, <strong class="nq iu">next</strong>) =&gt; {</span></pre><p id="4787" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要记住的最重要的事情是顺序很重要。<strong class="kw iu">中间件按顺序处理</strong>。如果你把它写在回家的路线下面，<code class="fe ny nz oa nq b">res.send</code>将结束这个链，我们的伐木工将永远不会被调用。</p><h2 id="11de" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">app。<httpmethod> vs app.use</httpmethod></h2><p id="286c" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">你会注意到<code class="fe ny nz oa nq b">app.use</code>的行为很像<code class="fe ny nz oa nq b">app.get</code>，那么有什么不同呢？阅读这个<a class="ae na" href="https://stackoverflow.com/questions/15601703/difference-between-app-use-and-app-get-in-express-js" rel="noopener ugc nofollow" target="_blank"> stackoverflow问题可以得到一个很好的解释</a>，但是TL；博士，不同的方法让事情有条理，意图清晰。</p><h1 id="cc0e" class="nb ls it bd lt nc nd ne lw nf ng nh lz jz ni ka mc kc nj kd mf kf nk kg mi nl bi translated">3.服务静态资产</h1><p id="fde8" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">在我们添加一些真正的中间件之前，请将它复制到您的<code class="fe ny nz oa nq b">/public/index.html</code>:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="43db" class="lr ls it nq b gy nu nv l nw nx">&lt;!DOCTYPE html&gt;<br/>&lt;head&gt;<br/>  &lt;link <br/>    rel="stylesheet" <br/>    type="text/css" <br/>    href="styles.css"<br/>  &gt;<br/>  &lt;title&gt;Hi&lt;/title&gt;<br/>&lt;/head&gt;</span><span id="e997" class="lr ls it nq b gy ob nv l nw nx">&lt;body&gt;<br/>  &lt;h1&gt;Hello world&lt;/h1&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="f3b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后把这个加到<code class="fe ny nz oa nq b">/public/styles.css</code>:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="a3bc" class="lr ls it nq b gy nu nv l nw nx">h1 {<br/> color: red;<br/>}</span></pre><p id="799d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单得令人惊叹。好了，现在我们要用一些静态中间件来替换我们原来的本地路由:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="12f4" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu"><em class="lq">// src/server.js<br/>const path = require('path');</em></strong><br/>const <strong class="nq iu">express</strong> = require('<em class="lq">express</em>');<br/>const <strong class="nq iu">app</strong> = <strong class="nq iu">express</strong>();</span><span id="39ca" class="lr ls it nq b gy ob nv l nw nx">/* <br/>  <em class="lq">unchanged logger</em> <br/>*/</span><span id="fcf7" class="lr ls it nq b gy ob nv l nw nx"><strong class="nq iu">/* set up static files router <br/> * </strong><a class="ae na" href="https://stackoverflow.com/questions/39110801/path-join-vs-path-resolve-with-dirname" rel="noopener ugc nofollow" target="_blank"><strong class="nq iu"><em class="lq">path</em></strong></a><strong class="nq iu"><em class="lq"> and </em></strong><a class="ae na" href="https://stackoverflow.com/questions/8131344/what-is-the-difference-between-dirname-and-in-node-js" rel="noopener ugc nofollow" target="_blank"><strong class="nq iu"><em class="lq">dirname</em></strong></a><strong class="nq iu"><em class="lq"> links</em><br/> */<br/>app.</strong>use<strong class="nq iu">(<br/>  express.</strong>static<strong class="nq iu">(<br/>    path.</strong>join<strong class="nq iu">(<br/>      __dirname,<br/>     '..',<br/>     '</strong><em class="lq">public</em><strong class="nq iu">',<br/>    )<br/>  )<br/>);</strong></span><span id="9ab5" class="lr ls it nq b gy ob nv l nw nx">/* <br/>  <em class="lq">unchanged start app</em> <br/>*/</span></pre><p id="cf72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原谅不可靠的间距，我试图使这个工作在移动，但在全屏静态功能看起来像:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="2086" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu">app</strong>.use(<strong class="nq iu">express</strong>.static(<strong class="nq iu">path</strong>.join(<strong class="nq iu">__dirname</strong>, '..', '<em class="lq">public</em>')));</span></pre><p id="cdbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的关键<a class="ae na" href="https://expressjs.com/en/starter/static-files.html" rel="noopener ugc nofollow" target="_blank">是</a> <code class="fe ny nz oa nq b"><a class="ae na" href="https://expressjs.com/en/starter/static-files.html" rel="noopener ugc nofollow" target="_blank">express.static</a></code>，一个内置的中间件功能，让我们托管资产。它只需要一个可选的挂载路径、一个要检查的目录字符串和一个<a class="ae na" href="https://expressjs.com/en/4x/api.html#express.static" rel="noopener ugc nofollow" target="_blank">选项对象</a>。通常，默认选项就可以了。我们没有提供挂载路径，所以这将在根目录<code class="fe ny nz oa nq b">‘/public’</code>下托管我们的静态文件，但是您不必这样做。你可以有不止一个，<a class="ae na" href="https://expressjs.com/en/starter/static-files.html" rel="noopener ugc nofollow" target="_blank">查看码头了解更多信息</a>。</p><h2 id="62e5" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">对…的简要解释。静电</h2><p id="6cfe" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">对<code class="fe ny nz oa nq b">‘/’ </code>的客户端请求将在<code class="fe ny nz oa nq b">public</code>文件夹中查找默认文件并服务于<code class="fe ny nz oa nq b">‘/public/index.html’</code> ( <code class="fe ny nz oa nq b">index</code>是默认文件名，<code class="fe ny nz oa nq b">.html</code>是默认扩展名)。然后html页面对<code class="fe ny nz oa nq b">‘styles.css’</code>的请求会在公共文件夹中找到<code class="fe ny nz oa nq b">/public/styles.css</code>。</p><p id="7962" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，类似<code class="fe ny nz oa nq b">‘/users’</code>的请求是api路由，而不在<code class="fe ny nz oa nq b">public</code>中。所以，static会首先检查<code class="fe ny nz oa nq b">‘/public/users.html’</code>，什么也没找到，然后继续检查常规的api路由。</p><h1 id="0efe" class="nb ls it bd lt nc nd ne lw nf ng nh lz jz ni ka mc kc nj kd mf kf nk kg mi nl bi translated">4.使用路由器和路由</h1><p id="6cda" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">对于本项目的最后一部分，我们将使用带有<code class="fe ny nz oa nq b"><a class="ae na" href="https://expressjs.com/en/api.html#router" rel="noopener ugc nofollow" target="_blank">express.Router</a></code>的<a class="ae na" href="https://expressjs.com/en/api.html#router" rel="noopener ugc nofollow" target="_blank">路由器</a>来设置API。虽然我们已经看到了如何使用<code class="fe ny nz oa nq b">app.get</code>向我们的主应用程序中添加路由，但是还有另一种方法可以让事情更有条理。</p><p id="c2db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个想法是，每个子路由，像<code class="fe ny nz oa nq b">/users</code>一样，都将托管在自己的<code class="fe ny nz oa nq b">router</code>上。我们会将所有相关的路线添加到其中，然后调用<code class="fe ny nz oa nq b">app.use</code>:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="371b" class="lr ls it nq b gy nu nv l nw nx">app.use('/users', userRouter);</span></pre><p id="4e06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当请求url符合基本情况时，我们的主应用程序切换到路由器的子路由。抛开理论不谈，让我们来看看路由器的现实世界模式。我们将从上到下，从单个路由到服务器文件。</p><h2 id="5990" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">src/routes/user/get . js和list.js</h2><p id="8a63" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">这两条是实际的<code class="fe ny nz oa nq b">user</code>路线。这两个文件都导出以路由器为参数的函数。所有的功能都是将其路线添加到给定的<code class="fe ny nz oa nq b">router</code>中。我们本质上是在做<code class="fe ny nz oa nq b">app.get</code>，但是用<code class="fe ny nz oa nq b">router</code>代替<code class="fe ny nz oa nq b">app</code>。</p><p id="1831" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意路径是<code class="fe ny nz oa nq b">/:id</code>和<code class="fe ny nz oa nq b">/</code>，而不是<code class="fe ny nz oa nq b">/users/:id</code>和<code class="fe ny nz oa nq b">/users</code>。在Express中，基本路由<code class="fe ny nz oa nq b">/users</code>是在应用层添加的，因此可以在路由器上的路由之间共享。还要注意在<code class="fe ny nz oa nq b">get.js</code>中有一个<a class="ae na" href="https://expressjs.com/en/guide/routing.html#route-parameters" rel="noopener ugc nofollow" target="_blank">动态路由:id' param </a>和一个<a class="ae na" href="https://expressjs.com/en/5x/api.html#req.query" rel="noopener ugc nofollow" target="_blank">查询参数</a>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f101" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu"><em class="lq">/* /src/routes/users/get.js */</em></strong><br/><em class="lq">// get a single user</em></span><span id="1297" class="lr ls it nq b gy ob nv l nw nx"><strong class="nq iu">module</strong>.exports = (<strong class="nq iu">router</strong>) =&gt; {<br/>  <strong class="nq iu">router</strong>.get('<em class="lq">/:id</em>', (<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>) =&gt; {<br/>    <strong class="nq iu">res</strong>.send({<br/>      <strong class="nq iu">id</strong>: <strong class="nq iu">req</strong>.params.id,<br/>      <strong class="nq iu">name</strong>: <strong class="nq iu">req</strong>.query.name,<br/>    });<br/>  });<br/>};<br/></span><span id="3da3" class="lr ls it nq b gy ob nv l nw nx">---------------------------------<br/><strong class="nq iu"><em class="lq">/* src/routes/users/list.js */</em></strong><br/><em class="lq">// list all users </em></span><span id="a857" class="lr ls it nq b gy ob nv l nw nx"><strong class="nq iu">module</strong>.exports = (<strong class="nq iu">router</strong>) =&gt; {<br/>  <strong class="nq iu">router</strong>.get('/', (<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>) =&gt; {<br/>    <strong class="nq iu">res.</strong>send([<br/>      {<br/>        <strong class="nq iu">id</strong>: 1,<br/>        <strong class="nq iu">name</strong>: '<em class="lq">tom</em>',<br/>      },<br/>    ]);<br/>  });<br/>};</span></pre><h2 id="06a4" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">src/routes/users/index.js</h2><p id="d587" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">为了保持整洁，我们将在我们的<code class="fe ny nz oa nq b">/users/index.js</code>文件中创建用户路由器，然后将其导出:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e8a2" class="lr ls it nq b gy nu nv l nw nx"><strong class="nq iu"><em class="lq">/* src/routes/users/index.js */</em></strong><br/><em class="lq">// add the routes to the router</em></span><span id="9ed7" class="lr ls it nq b gy ob nv l nw nx">const <strong class="nq iu">express</strong> = require('<em class="lq">express</em>');<br/>const <strong class="nq iu">router</strong> = <strong class="nq iu">express</strong>.Router();</span><span id="d876" class="lr ls it nq b gy ob nv l nw nx">/* user only middleware */<strong class="nq iu"><br/>router.</strong>use((<strong class="nq iu">req</strong>, <strong class="nq iu">res</strong>, <strong class="nq iu">next</strong>) =&gt; {<br/>  <strong class="nq iu">console</strong>.log('<em class="lq">User middleware</em>');<br/>  <strong class="nq iu">next</strong>();<br/>});</span><span id="5abf" class="lr ls it nq b gy ob nv l nw nx"><strong class="nq iu">require</strong>('<em class="lq">./list</em>')(<strong class="nq iu">router</strong>);<br/><strong class="nq iu">require</strong>('<em class="lq">./get</em>')(<strong class="nq iu">router</strong>);</span><span id="57db" class="lr ls it nq b gy ob nv l nw nx"><strong class="nq iu">module.</strong>exports = <strong class="nq iu">router</strong>;</span></pre><p id="933e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ny nz oa nq b"><strong class="kw iu">require</strong>(x)(y)</code>看起来很奇怪，但是在现实世界中你会添加很多文件，像这样的请求和调用是很庞大的:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="b1e2" class="lr ls it nq b gy nu nv l nw nx">const <strong class="nq iu">route</strong> = require(‘./<em class="lq">route</em>’)<!-- -->; <br/><strong class="nq iu">route</strong>(<strong class="nq iu">router</strong>)<strong class="nq iu">;</strong></span></pre><p id="1975" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也是您使用<code class="fe ny nz oa nq b">router.use</code>添加路由器特定中间件的文件。只要记住在添加路线之前放置中间件，顺序很重要！</p><h2 id="fb70" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">src/路线/索引</h2><p id="045f" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">在<code class="fe ny nz oa nq b">routes</code>文件夹的<code class="fe ny nz oa nq b">index.js</code>中，我们将导出一个采用app的函数，然后将所有路由器添加到其中。在这种情况下，我们只有一个路由器，但是随着应用程序的增长，您会列出每个额外的路由器。这是<em class="lq">最后</em>我们添加基本路线<code class="fe ny nz oa nq b">/users</code>的地方:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e50f" class="lr ls it nq b gy nu nv l nw nx">/* src/routes/index.js */<br/>// add the routers to an app </span><span id="d57f" class="lr ls it nq b gy ob nv l nw nx">const <strong class="nq iu">addAllRoutes</strong> = (app) =&gt; {<br/>  <strong class="nq iu">app</strong>.use(<br/>    '<em class="lq">/users</em>', <br/>    <strong class="nq iu">require</strong>('./users')<br/>  );<br/>};</span><span id="a420" class="lr ls it nq b gy ob nv l nw nx">module.exports = addAllRoutes;</span></pre><p id="0781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将函数添加到我们的<code class="fe ny nz oa nq b">src/server.js</code>:</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="49b2" class="lr ls it nq b gy nu nv l nw nx">const path = require('path');<br/>const express = require('express');<br/><strong class="nq iu">const addAllRoutes = require('./routes');</strong><br/>// ...unchanged app</span><span id="edbe" class="lr ls it nq b gy ob nv l nw nx"><strong class="nq iu">/* register all routes */<br/>addAllRoutes(app);</strong></span><span id="9d54" class="lr ls it nq b gy ob nv l nw nx">/* start the app */<br/>const <strong class="nq iu">port</strong> = <strong class="nq iu">process</strong>.env.<strong class="nq iu">PORT</strong> || 4321;<br/>// ......unchanged app</span></pre><p id="9f9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哒哒！那是我们完成的项目！我希望这能给你一个好的起点。一些直接的下一步将是引入一个创建-反应-应用程序而不是index.html，并查看<a class="ae na" href="http://www.passportjs.org" rel="noopener ugc nofollow" target="_blank"> passport.js的auth </a>！</p><p id="3ce2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="e970" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>