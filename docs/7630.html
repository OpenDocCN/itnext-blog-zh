<html>
<head>
<title>If I Could Teach Only One Thing To A Beginner Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我只能教一个初学者一样东西</h1>
<blockquote>原文：<a href="https://itnext.io/if-i-could-only-teach-one-thing-to-a-beginner-developer-1f98d4ff6cb7?source=collection_archive---------0-----------------------#2022-12-01">https://itnext.io/if-i-could-only-teach-one-thing-to-a-beginner-developer-1f98d4ff6cb7?source=collection_archive---------0-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e5fe7f3f64fb7ba62559f9b06581a0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hmapJCFQPUA82Nxq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@uxindo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">印尼UX</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="57e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几周前，当我写一篇关于如何<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-more-reusable-code-73f936283eff">抽象你的代码</a>使之更容易重用的博文时，我有了一个有趣的想法。我想知道其他开发人员认为他们应该教给新手开发人员的最重要的原则是什么，以及为什么他们会选择这个设计原则。</p><p id="c29c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我做了一些不同的“采访”，一些是通过微信，一些是通过谷歌表单，其余的是通过内部的谷歌聊天T21。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/dd78a1943a8fd8bcb3a81e1faa179858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zF9AE3kC90nN_CCGSBmEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">数据收集和分析</figcaption></figure><h1 id="0ee7" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">单一责任原则</h1><p id="c486" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">结果超级刺激。首要原则是“单一责任原则”，简称SRP。尽管有其他的解释，通常，SRP意味着你应该保持你的函数，类或者模块尽可能的简单和一致。</p><p id="c796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个具体的例子是我在谷歌聊天线程中使用的:</p><blockquote class="mk ml mm"><p id="fab2" class="kd ke lb kf b kg kh ki kj kk kl km kn mn kp kq kr mo kt ku kv mp kx ky kz la ij bi translated"><em class="iq"> … </em> <strong class="kf ir"> <em class="iq">我建议他们给自己的函数起一个有意义的名字(与第一点有关)，看看他们是否必须使用连词like和/或来定义函数正在做什么。如果是这样的话，他们应该拆分那个功能… </em> </strong></p></blockquote><p id="e34e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也适用于代码的不同层次。例如，一个类不应该做两件不同的不相关的事情。一个数据类<code class="fe mq mr ms mt b">Person</code>可能有<code class="fe mq mr ms mt b">name</code>、<code class="fe mq mr ms mt b">address</code>和<code class="fe mq mr ms mt b">dob</code>，但是方法<code class="fe mq mr ms mt b">deliver</code>就太多了。</p><p id="1594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面是我在本文中讨论的一个例子<a class="ae kc" href="https://medium.com/javascript-in-plain-english/did-someone-say-composition-c7843d898b2" rel="noopener">，一个<code class="fe mq mr ms mt b">Avatar</code>组件包含一个<code class="fe mq mr ms mt b">Tooltip</code>，当<code class="fe mq mr ms mt b">props.name</code>被提供时就会显示出来。通过应用SRP，您可能希望将与<code class="fe mq mr ms mt b">Tooltip</code>相关的代码分发给消费者，并确保<code class="fe mq mr ms mt b">Avatar</code>只关心与角色相关的逻辑。</a></p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/1008154610a9d9ebde92d71c35fb7574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*faJ3SdsGSJHtS-6L8MIcog.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">通过应用SRP简化您的代码</figcaption></figure><h1 id="a9e8" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">包装</h1><p id="af90" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">第二高的主题是封装。天真地说，这可能意味着不要使用分散的数据或函数，它们需要封装在一个类中。但是除此之外，这也意味着您需要知道什么数据和方法需要放在哪里。</p><p id="3657" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在这里使用我的另一篇文章中的例子，并展示我们如何使用<code class="fe mq mr ms mt b">class</code>来轻松封装这些公开的数据。</p><p id="2b2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些小的数据转换函数和React组件是很常见的，随着前端使用这些数据的方式发生变化(映射缩写为全名或在需要时添加if-else逻辑)，这些小的顶级函数开始难以维护。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/94d9812f26286df290b2ac39ee4fe695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1e1Z_SRW8dEMKIb1IKWkew.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">转换地址功能</figcaption></figure><p id="899e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以为所有的数据和转换函数准备一个<code class="fe mq mr ms mt b">class</code>。如果转换逻辑发生变化，我们只需在一个地方进行修改。设置测试也更容易——您可以定义一些变化的输入，并验证该类的公共方法的输出。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/1ba5b091a69a7f6e7f337603f8bf1ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16B3mKc4QuAq1D6RpJdRGA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将地址逻辑封装到一个类中</figcaption></figure><h1 id="de5f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">不要重复你自己</h1><p id="8b9c" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">单子上的第三条是干的——不要重复。我们都讨厌在编码时做重复的工作，尤其是当我们必须手工做的时候。一般来说，三个的<a class="ae kc" href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)" rel="noopener ugc nofollow" target="_blank">法则适用于大多数情况，这意味着你只能接受少于三个的重复实例。</a></p><p id="0703" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里要注意的一件事，就像软件开发中的其他原则一样，就是你应该首先寻求理解复制背后的目的，然后拆除那个复制。有一些有趣的阅读资料(我已经把它们放在底部的参考资料部分)说明了在什么情况下不应该删除重复的内容。</p><p id="4aa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现不同的编程语言提供了使工作变得更容易或更困难的机制。例如，在函数式编程语言中，你可以像传递变量一样传递它们，因为函数是一级的，这在纯面向对象语言中是不可能的。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/34de37ee5017cf1c9fde535f390ea6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEvKJmtnW83bw9M4ULrMyg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">高阶函数</figcaption></figure><p id="d137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后你可以传入<strong class="kf ir">任何</strong>函数来避免重复，比如:</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/7290ab2e2c3849762b7e9c9825f9239c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yvl0hiDgq8kALqGyqRiVKQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">像变量一样传入函数</figcaption></figure><p id="cc55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而在Java中，例如(如果我的Java知识需要更新，请评论让我知道)，你必须首先创建一个接口，并传入实现该接口的类来实现它，这相当麻烦。</p><h1 id="d6a7" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">摘要</h1><p id="ffa2" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这三大原则根植于大多数开发人员的头脑中，尽管因人而异的解释略有不同。</p><p id="c91e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SRP确保你只专注于一件事，并把它做得完美，如果做得好，可测试性和可组合性都会随之而来。虽然封装有助于将连贯的内容、算法、数据和逻辑放在一个中心位置，但它也有助于更容易理解代码。最后，DRY使代码始终保持简单和简洁的状态。还有，修改的时候也不用担心忘记更新其他地方。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="24c3" class="lh li iq bd lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma ng mc md me bi translated">参考资料:</h1><ul class=""><li id="2731" class="nh ni iq kf b kg mf kk mg ko nj ks nk kw nl la nm nn no np bi translated"><a class="ae kc" href="https://www.plutora.com/blog/understanding-the-dry-dont-repeat-yourself-principle" rel="noopener ugc nofollow" target="_blank">不要重复自己</a></li><li id="678b" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><a class="ae kc" href="https://overreacted.io/goodbye-clean-code/" rel="noopener ugc nofollow" target="_blank">再见干净代码</a></li><li id="a93e" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><a class="ae kc" href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction" rel="noopener ugc nofollow" target="_blank">错误的抽象</a></li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="a13e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果你喜欢阅读，请</strong> <a class="ae kc" href="https://icodeit.com.au/#subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">报名参加我的邮件列表</strong> </a> <strong class="kf ir">。我每周通过</strong> <a class="ae kc" href="https://juntao-qiu.medium.com/" rel="noopener"> <strong class="kf ir">博客</strong></a><strong class="kf ir"/><a class="ae kc" href="https://leanpub.com/u/juntao" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">书籍</strong> </a> <strong class="kf ir">和</strong> <a class="ae kc" href="https://www.youtube.com/@icodeit.juntao" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">视频</strong> </a> <strong class="kf ir">分享干净代码和重构技术。</strong></p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="695e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，可以考虑注册<a class="ae kc" href="https://medium.com/@juntao-qiu/membership" rel="noopener">成为</a>中的一员。每月只需5美元，你就可以无限制地访问我在Medium上的所有文章——以及上述作者和其他人的所有文章！</p></div></div>    
</body>
</html>