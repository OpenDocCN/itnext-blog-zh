<html>
<head>
<title>I will split you into the pieces!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我会把你撕成碎片！</h1>
<blockquote>原文：<a href="https://itnext.io/i-will-spilt-you-into-the-pieces-dfa1ae97bede?source=collection_archive---------0-----------------------#2018-01-25">https://itnext.io/i-will-spilt-you-into-the-pieces-dfa1ae97bede?source=collection_archive---------0-----------------------#2018-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="dc92" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">640 kB对任何人来说都足够了。</p></blockquote><figure class="jz ka kb kc kd ke gh gi paragraph-image"><div class="gh gi jy"><img src="../Images/907de3acdf694f7a9cf129e95c614193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*iwVNShnhbhAukZJzzQWFFA.jpeg"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">剪刀手爱德华，高级分裂者。</figcaption></figure><p id="cbde" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated"><a class="ae li" href="https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fi-will-spilt-you-into-the-pieces-dfa1ae97bede" rel="noopener ugc nofollow" target="_blank"> <em class="lj">点击这里在LinkedIn上分享这篇文章</em> </a></p><p id="6be1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">代码分裂是最近流行的谣言。更清楚地说</p><blockquote class="lk ll lm"><p id="b9a8" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">代码分割不是你应该知道的事情。</p><p id="b012" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">代码分割是你应该使用的东西。</p></blockquote><p id="1cc4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">这里我们遇到了一个问题——从一个角度来看——现代的代码分割很容易做到——只需使用动态<code class="fe lq lr ls lt b">import</code>。从另一个角度来看，您实际上想要归档什么？</p><blockquote class="jn"><p id="33ad" class="jo jp iq bd jq jr lu lv lw lx ly jx dk translated">你想分什么。你需要推迟什么？</p></blockquote><p id="b280" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh jx ij bi translated">有两个答案——JavaScript代码和资产。你知道，现在资产也可以是javascript代码。</p><p id="7ff7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">但换句话说，区别更简单——<em class="lj">web pack控制资源</em>和不控制资源，就像静态图像一样。</p><blockquote class="lk ll lm"><p id="f6c2" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">现在我们将忘记第二部分，只要处理它是CDN的职责。</p></blockquote><p id="22da" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">那第一部分呢？关于JS-bundles的代码拆分？我可以说——你弄错了。不要误解这个想法——你只是忘记检查一些实现的细节。</p><blockquote class="lk ll lm"><p id="fcc0" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">剧透——你使用代码分割越多，你可能实现的代码分割就越少。</p></blockquote><p id="ab56" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">而根本问题是<strong class="kn ir">代码重复</strong>，或者说代码去重复，你也想实现。</p><p id="ec70" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">让我告诉你一个你从未听过的故事。以前…其实以前没有问题。</p><h1 id="a8ae" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">之前。</h1><p id="f736" class="pw-post-body-paragraph kl km iq kn b ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ng lg lh jx ij bi translated">以前没有模块。无模块==无忧。只有脚本标签。</p><p id="d5e3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">每个人都在创建一个巨大的javascript文件，或者在源HTML中一个接一个地包含十几个小文件。</p><blockquote class="lk ll lm"><p id="e1fc" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">“模块”是后来发明的。至少在JS诞生10年后。</p></blockquote><p id="2341" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">我几乎不记得google closure编译器或dojo的“模块”是什么意思了。但是第一个“普通的”commonjs模块是nodejs自带的，没有办法在浏览器中使用它们。</p><p id="15ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">点击此链接，简要了解JavaScript模块——</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/sungthecoder/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">JavaScript模块简史</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">你是JavaScript新手，对模块、模块加载器和模块捆绑器感到困惑吗？或者你一直在为一个…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kf nk"/></div></div></a></div><p id="8019" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">因此，前端有两种生存选择:</p><ul class=""><li id="89c5" class="nz oa iq kn b ko kp ks kt kw ob la oc le od jx oe of og oh bi translated">使用browsery(gulp，webpack)将所有资源打包成一个大文件。</li><li id="99ae" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx oe of og oh bi translated">使用AMD/RequireJS/SystemJS并要求模块作为模块，从前端一个接一个。</li></ul><p id="4da0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">而第二条路却不是这样。它慢了很多。比单个包慢N到M倍，其中N是模块数量，M是<em class="lj">嵌套</em>层级。M更重要，我们可以并行加载十几个模块，但是我们不能加载它们的依赖关系。为什么？我们不认识他们。</p><p id="9bcc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">在中位数项目中，M约为10。所以要求至少慢10倍。使用HTTP/2。不要试图在没有HTTP/2的情况下使用Require.js。</p><p id="dacd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">记住，HTTP/2在Require.js出现时还不存在——所以BUNDLERS赢了！</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/webpack/webpack-http-2-7083ec3f3ce6" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">webpack &amp; HTTP/2</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">让我们从一个关于HTTP/2的神话开始:</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div></div></a></div><h1 id="e406" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">一捆就能统治所有人！</h1><figure class="oo op oq or gt ke gh gi paragraph-image"><div class="gh gi on"><img src="../Images/57bb7fd968efd972ff120d0cb49c2fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*qdAfcTRck6UwIB8TdUelqQ.jpeg"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">整体捆绑包装</figcaption></figure><p id="b22a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">Webpack是当今事实上的标准。接受吧。有无数不同的文章介绍如何正确设置它，然后处理它。最复杂的是关于长期缓存、提取公共/供应商数据块以及将整个应用程序拆分成一组“异步”数据块。</p><p id="0881" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">也许我在webpack上读到的关于“CommonChunking”的最好的文章是Adam Rackis的文章，你也必须读一读。</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/@adamrackis/vendor-and-code-splitting-in-webpack-2-6376358f1923" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">webpack 2中的供应商和代码拆分</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Webpack是一个雄心勃勃的强大工具，用于捆绑现代web应用程序。不幸的是，它的复杂性会使它…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="ou l nv nw nx nt ny kf nk"/></div></div></a></div><p id="8624" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">所以——答应我，你会读它。但简而言之，这篇文章解释了如何将应用程序切割成碎片。<strong class="kn ir">适当的</strong>切成<strong class="kn ir">正确的</strong>块。</p><figure class="oo op oq or gt ke gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/0bbf9411041c0462411279d0212a1c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*vlosWyKDZ1TViFBYO7LTNA.png"/></div></figure><p id="6469" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">Adam从入口点提取了所有的东西，接下来他可以只加载他“现在”需要的代码。这是手工杰作的惊人范例。</p><blockquote class="jn"><p id="7fb7" class="jo jp iq bd jq jr lu lv lw lx ly jx dk translated">你能看出这里的问题吗？</p></blockquote><p id="dc54" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh jx ij bi translated">问题的名称是“使用两次”。在本例<strong class="kn ir">中，它将包含在异步块</strong>中多次使用的所有依赖关系。</p><p id="d117" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">其实这样挺好的。零重复。但是你可能会下载一些你现在不需要的代码，因为另一个程序块需要它，你迟早会需要的。</p><p id="48aa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">您仍然可以手动提取大的“依赖项”作为单独的块(如本例中的<em class="lj"> react-dnd </em>)，您可以调优公共块的创建，尝试控制模块和块之间的依赖项..</p><blockquote class="jn"><p id="c316" class="jo jp iq bd jq jr lu lv lw lx ly jx dk translated">但是你会失败的</p></blockquote><p id="9a2e" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh jx ij bi translated">迟早你会失去控制。应用程序代码可能非常混乱，不同的模块经常访问相同的模块。</p><div class="nh ni gp gr nj nk"><a href="https://github.com/webpack/webpack/issues/690" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">展示你的模块树问题#690网络包/网络包</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">web pack-JavaScript和朋友的捆绑器。将许多模块打包成几个捆绑资产。代码分割允许…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="ow l nv nw nx nt ny kf nk"/></div></div></a></div><p id="1c0a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated"><a class="ae li" href="http://webpack.github.io/analyse/" rel="noopener ugc nofollow" target="_blank"> Webpack bundle analyzer </a>可以可视化您的应用。你可能会发现，它看起来像…一个图表。</p><figure class="oo op oq or gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="oy oz di pa bf pb"><div class="gh gi ox"><img src="../Images/30854f206031c08fa08f7bc904d74601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjE8D25tXIhayTJpCQAfSQ.png"/></div></div></figure><p id="dc51" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">结果——在没有特殊控制的情况下，“使用两次”或普通的“CommonChunkPlugin”将在每次引入新的分割点时增长。</p><p id="7aeb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">例如，React-loadable鼓励你添加尽可能多的吐丝点，如果你觉得有必要的话。这是正确的，但有时不是“必要的”。</p><figure class="oo op oq or gt ke gh gi paragraph-image"><div role="button" tabindex="0" class="oy oz di pa bf pb"><div class="gh gi pc"><img src="../Images/020bb96ebce3dc1dddad9353ba6185f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ds7SEAHT1RbIdPVeAuQWmw.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">使用react-loadable进行代码拆分</figcaption></figure><p id="8704" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">您将从坚如磐石的应用程序开始，要求用户在页面加载时下载10Mb。接下来，您将第一次拆分应用程序，第二次拆分应用程序，推迟所有可以推迟的组件，结果会是什么呢？</p><blockquote class="lk ll lm"><p id="fd7f" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">您拥有的块越多，使用相同模块的块就越多。使用两次的模块越多——越多的模块是公共的并被提取为公共的。</p></blockquote><p id="6f86" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">这可能会导致将所有node _ modules或应用程序的大部分代码移动到CommonChunk中。或者两者都有。</p><figure class="oo op oq or gt ke gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/2c98e765147e674cf1aa59f9ca32e762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*TPWce304O2bOWcEVWTCnUg.png"/></div></figure><p id="99b4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">这可能有点不公平，也不是你想要的结果。</p><blockquote class="lk ll lm"><p id="9fe8" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">代码分割就像可变状态或多重继承——方便的工具，已经有数百万人使用过。但是可能会给你带来麻烦</p></blockquote><h1 id="a8b1" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">哦不</h1><p id="65c9" class="pw-post-body-paragraph kl km iq kn b ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ng lg lh jx ij bi translated">它仍然很容易修复。只需运行bundler analizer，引入更多的公共块，考虑添加或删除一些分割点。</p><blockquote class="jn"><p id="49a6" class="jo jp iq bd jq jr lu lv lw lx ly jx dk translated">保留你的手工杰作——杰作。</p></blockquote><p id="51fe" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh jx ij bi translated">你能看出这里的问题吗？这是手工制作的中的一个错别字。应该是#0CJS。</p><blockquote class="lk ll lm"><p id="54dd" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">但是default webpack的automagics会让事情变得更糟。</p></blockquote><p id="50fd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">其实不是“会”，而是“曾”。与此同时，CommonChunkPlugin很方便，但在web pack 2–3中很难处理——它刚刚从Webpack 4 中删除了。</p><p id="2a88" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">争取你阅读这篇文章的时间——它可能已经过时了。完全过时了。</p><figure class="oo op oq or gt ke"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="3b10" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">Webpack v4重新思考了大部分事情，不仅会自动将你的代码分割成块，还会自动分割块，并解决我上面描述的大部分问题。</p><blockquote class="lk ll lm"><p id="0f0d" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">正如我所说的——web pack是当今事实上的标准。接受吧。</p></blockquote><p id="8edf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">我对新方法没有足够的信息和信心，但它应该在没有任何配置的情况下接近完美。你仍然可以通过一些配置来完善它。</p><p id="8eec" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">这里唯一的问题是——默认配置。如果出现以下情况，将会出现附加块:</p><ul class=""><li id="1027" class="nz oa iq kn b ko kp ks kt kw ob la oc le od jx oe of og oh bi translated">可以共享新的块或来自<code class="fe lq lr ls lt b">node_modules</code>文件夹的模块</li><li id="0b68" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx oe of og oh bi translated">新块将大于30kb(在min+gz之前)</li><li id="b407" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx oe of og oh bi translated">按需加载块时的最大并行请求数将小于或等于5</li><li id="22f6" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx oe of og oh bi translated">初始页面加载时的最大并行请求数将小于或等于3</li></ul><p id="25ed" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">它可能产生比你需要的更多的块，也可能产生比你需要的更少的块。应该对99.9%的情况起作用，但它仍然是一个好主意，在它之后观看。</p><p id="e8f3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">你可能没有注意到这个问题，但是webpack要解决这个问题，俗称<strong class="kn ir">背包问题</strong>或者<strong class="kn ir">背囊问题。</strong></p><figure class="oo op oq or gt ke gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/33be13e4268e8264ee8f37e70c594792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*KTI0r78CCzQfY0YtKEMoCA.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">现在——打包！</figcaption></figure><p id="beef" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">你唯一应该知道的是—</p><blockquote class="lk ll lm"><p id="c145" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">背包问题的<a class="ae li" href="https://en.wikipedia.org/wiki/Decision_problem" rel="noopener ugc nofollow" target="_blank">决策问题</a>形式是<a class="ae li" href="https://en.wikipedia.org/wiki/NP-complete" rel="noopener ugc nofollow" target="_blank">NP-完全</a>，因此不存在在所有情况下都正确且快速(多项式时间)的已知算法。</p></blockquote><h1 id="f4e5" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">另一种方式。</h1><p id="d5c5" class="pw-post-body-paragraph kl km iq kn b ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ng lg lh jx ij bi translated">另一种方法是研究出图论，并在<a class="ae li" href="https://en.wikipedia.org/wiki/Bridge_(graph_theory)" rel="noopener ugc nofollow" target="_blank">桥</a>上进行拆分。</p><figure class="oo op oq or gt ke gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/0e3a5b8545652621fed5ebde7cba4cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*D8tBBNB68JcjEgvcxKGUeg.png"/></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">一个有16个顶点和6个桥的图(用红色突出显示)</figcaption></figure><p id="a16a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">只需分析包，找到“可切割”的部分…并切割它们。</p><p id="9007" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">好的方面是——这是100%纯的#0CJS。</p><p id="f9ef" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">糟糕的是，没有办法实际控制分割过程。应用程序通常是如此复杂，以至于可能根本没有桥梁。</p><h1 id="3e47" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">另一种方式</h1><p id="08fb" class="pw-post-body-paragraph kl km iq kn b ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ng lg lh jx ij bi translated">在“又一个指数”(Yandex)中，我们开发了另一种方法来解决这个问题。我们从2011年开始在生产中使用它，我仍然不明白为什么没有其他人也这样做。</p><p id="bc6e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">我们的问题很简单——我们正在开发地图API，类似于你可能会使用的谷歌地图，而且那个API非常庞大。和“一个大文件”。</p><p id="34ad" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">仅供参考:地图API通常包括</p><ol class=""><li id="a2a9" class="nz oa iq kn b ko kp ks kt kw ob la oc le od jx ph of og oh bi translated">“地图”。几十个服务和瓦片引擎。</li><li id="6092" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx ph of og oh bi translated">“图形”。SVG，画布，VML，WebGL</li><li id="177b" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx ph of og oh bi translated">“模板”。像一个反应或反应王国</li><li id="e464" class="nz oa iq kn b ko oi ks oj kw ok la ol le om jx ph of og oh bi translated">“魔法”。至少有点魔力。</li></ol><p id="0864" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">当你的站点正在加载时，你不需要这个列表中的3/4。你不需要这个列表中的2/4..你只是通常不需要大部分的东西。此外，我们必须在现代浏览器中支持IE6–7–8，并且不希望向现代客户提供多填充和简化的模板。或者反过来。</p><p id="c5b7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">我们找到的解决方案简单明了。它不需要任何火箭科学或图形计算。我们只是把所有的依赖暴露给frontend，让frontend计算它需要加载另一个模块列表的模块列表，即顶层逻辑所需要的。</p><blockquote class="lk ll lm"><p id="d7ae" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">如果模块A依赖于模块B并作出反应——我们必须加载模块A、B并作出反应，才能得到模块A。</p></blockquote><p id="6d74" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">这个问题(这不是问题)被<strong class="kn ir"> ym、</strong>或者仅仅是<a class="ae li" href="https://github.com/ymaps/modules" rel="noopener ugc nofollow" target="_blank"> Yandex模块</a>解决了。这只是AMD模块系统，类似于SystemJS。事实上这不是AMD，而是LMD(懒惰)，但这不算文章。</p><pre class="oo op oq or gt pi lt pj pk aw pl bi"><span id="73fd" class="pm mf iq lt b gy pn po l pp pq">['geoXml.util', '4e', '5!'],<br/>['graphics.csg', '4f', '*_8!4T8H'],<br/>['islets.traffic.layout.settings.slider.html', '4g', '1)1w14'],<br/>['theme.islands.control.layout.routePanel.Button.css', '4h', '7u'],<br/>['graphics.render.abstract.shape', '4k', ''],<br/>['graphics.renderManager.canvasTile', '4l', '*X*18H4m4p'],</span></pre><blockquote class="lk ll lm"><p id="aab6" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">曝光的<a class="ae li" href="https://api-maps.yandex.ru/2.1.60/map.js?callback=ym_map_fallback_url=https___api-maps_yandex_ru_2_1_60_map_js_filter=*&amp;filter=*" rel="noopener ugc nofollow" target="_blank">模块图</a>表，一小部分。</p></blockquote><p id="f16f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">第二个问题是实际加载所需的模块。不是作为一个包，因为我们的目标不是这样做。而不是小块，因为它们根本不存在。</p><p id="a721" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">我们没有找到更好的方法，只是将“模块组合器”暴露在互联网上。如果你需要A、B和React——只需加载“<code class="fe lq lr ls lt b">combine?module=A,B,React"</code>”，它就会把需要的模块串联起来并发回。还有什么比这更简单的呢？</p><pre class="oo op oq or gt pi lt pj pk aw pl bi"><span id="3d4c" class="pm mf iq lt b gy pn po l pp pq"><a class="ae li" href="https://api-maps.yandex.ru/2.1.60/" rel="noopener ugc nofollow" target="_blank">https://api-maps.yandex.com/2.1.60/</a>combine.js?load=0d9c0h,j1Q(M9d1Z2b2f(L(H2h9f(K2n2p9k2s2w361n5k$C1h3$1v2,2j0b0e9r2C9m9o9u9v9x2H9p2F9t0u0n2S9A9C9D9F9G9K2Y9L219M25(N(O(P(R9O9P272$2_2(2)2:2@2I9U9T9V2q9X9Y91929396979R2i2Q2J993a0k9_9$3c9.3d9!9(3g3h(V(S(T(U(W9)&amp;callback_prefix=ymaps_loader</span></pre><blockquote class="lk ll lm"><p id="31f0" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">这是一个真实的网址。“模块”被重命名为2符号长度的别名。</p></blockquote><p id="bc13" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">具有<strong class="kn ir">完美异步分块和零复制</strong>的模块系统已经完成。只要在它前面放一个小代理层，它就会<strong class="kn ir">承受任何负荷</strong>。</p><p id="6126" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">模块映射创建由<a class="ae li" href="https://www.npmjs.com/package/ymb" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> ymb </strong> </a>处理，而服务器和客户端代码生成(又名“webpack-internals”)由<a class="ae li" href="https://www.npmjs.com/package/yms" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> yms </strong> </a>处理。这两个包在几年前都是开源的。但是你不能用它们！🙀！</p><h1 id="9104" class="me mf iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">瓦特？</h1><p id="5787" class="pw-post-body-paragraph kl km iq kn b ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ng lg lh jx ij bi translated">令人惊讶的是，你可能会发现yms实际上没有任何文档。而且ymb的README也不是一个(可以理解的)东西。</p><blockquote class="lk ll lm"><p id="63dd" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">它们不是为你设计的。所以没有人真正使用它们。</p></blockquote><p id="166d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">这些工具不支持babel、源地图、长期缓存、TypeScript、CommonJs(这就是为什么”🙀”)，以及所有这些东西，使word class bundler成为世界级的bundler。</p><p id="9ab7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">即使ym/ymb/yms是一个方便的东西——它们从未在我们构建的产品之外使用过。我们的构建工具从来没有“外部”客户。从未想过其他团队的要求。</p><blockquote class="lk ll lm"><p id="349c" class="kl km lj kn b ko kp kq kr ks kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh jx ij bi translated">我希望你明白我的意思——永远不要用它。</p></blockquote><p id="4397" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jx ij bi translated">我写这些，只是为了让你更好地理解事情是如何运作的。</p><blockquote class="jn"><p id="fb42" class="jo jp iq bd jq jr lu lv lw lx ly jx dk translated">package的普通分块是如何工作的？</p></blockquote><p id="90b9" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh jx ij bi translated">PS:但是我还是不明白，为什么每个人都“捆绑”静态捆绑包，而没有人使用“主动”服务器端。为什么不呢？</p></div></div>    
</body>
</html>