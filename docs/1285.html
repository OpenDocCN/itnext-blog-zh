<html>
<head>
<title>Flow types for generators and coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成器和协程的流类型</h1>
<blockquote>原文：<a href="https://itnext.io/flow-types-for-generators-and-coroutines-ddee13c30ba1?source=collection_archive---------8-----------------------#2018-08-28">https://itnext.io/flow-types-for-generators-and-coroutines-ddee13c30ba1?source=collection_archive---------8-----------------------#2018-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cc18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从ECMAScript 6引入了<code class="fe kl km kn ko b">yield</code>关键字，协程变得更加常见。最著名的例子可能是用于并发的<code class="fe kl km kn ko b">async</code> / <code class="fe kl km kn ko b">await</code>框架，但是协程也构成了<a class="ae kp" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>的主干，并且已经进入了<a class="ae kp" href="http://bluebirdjs.com/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> bluebird </a>。</p><p id="9a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎很少有关于如何将<a class="ae kp" href="https://flow.org/en/docs/" rel="noopener ugc nofollow" target="_blank">流</a>类型添加到生成器或协程的文档。这篇文章通过给出许多不同类型生成器的例子来缓解这个问题。代码测试在<a class="ae kp" href="https://github.com/pbugnion/flow-types-for-coroutines" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><h1 id="715d" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">生成器与协程</h1><p id="d55a" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">协程和生成器是非常不同的概念。<em class="lt">生成器</em>让你创建消费者看来像迭代器的函数。</p><p id="f33d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">协程是传统函数概念的扩展。一个函数将通过<code class="fe kl km kn ko b">return</code>语句把控制权交还给它的调用者一次。协程可以通过调用<code class="fe kl km kn ko b">yield</code>将控制权交还任意次。当协程让步时，它的内部状态被保留。</p><p id="46dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成器的消费者将根据需要从生成器中获取数据。协程的调用者将<em class="lt">将</em>数据推入协程。</p><p id="8762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成器和协程经常被混为一谈，因为它们使用相同的底层机制。例如，在Python和JavaScript中，都使用<code class="fe kl km kn ko b">yield</code>关键字来移交控制权。生成器和协程都可以暂停，稍后再继续。</p><p id="25dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管有这些相似之处，但它们在不同的上下文中使用:生成器用于轻松创建迭代器。协程用于引入并发或复杂的控制流。</p><p id="aa7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉协程和生成器，我发现<em class="lt">探索JavaScript </em>的<a class="ae kp" href="http://exploringjs.com/es6/ch_generators.html#sec_overview-generators" rel="noopener ugc nofollow" target="_blank">这一章</a>非常有用。</p><h1 id="4435" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">一种类型来统治他们</h1><p id="183f" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">因为协程和生成器使用相同的底层机制，所以在Flow中只有一个通用类型:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="96b5" class="mc kr iq ko b gy md me l mf mg">Generator&lt;Yield, Return, Next&gt;</span></pre><p id="3bd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里:</p><ul class=""><li id="9f30" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Yield</code>是生成器生成的数据类型。如果您的生成器/协程中有类似于<code class="fe kl km kn ko b">yield "my-string"</code>的语句，<code class="fe kl km kn ko b">Yield</code>将会是<code class="fe kl km kn ko b">string</code>。</li><li id="5000" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Return</code>是生成器返回语句的类型。如果你有一个类似于<code class="fe kl km kn ko b">return "my-string"</code>的语句，<code class="fe kl km kn ko b">Return</code>的类型就会是<code class="fe kl km kn ko b">string</code>。</li><li id="e0c0" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Next</code>是由<code class="fe kl km kn ko b">yield</code>注入函数的值的类型。如果你有一个类似于<code class="fe kl km kn ko b">const nextItem: string = yield</code>的语句，<code class="fe kl km kn ko b">Next</code>的类型就会是<code class="fe kl km kn ko b">Yield</code>。</li></ul><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="755f" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">function</strong>* example: Generator&lt;string, boolean, number&gt; {<br/>  <strong class="ko ir">const</strong> toYield = 'this is a string'<br/>  <strong class="ko ir">const</strong> received: number = <strong class="ko ir">yield</strong> toYield<br/>  <strong class="ko ir">return</strong> false<br/>}</span></pre><figure class="lu lv lw lx gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/ec0314f338ce88516428f917f2bff499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VhiCx7ZJS4i6PuBO.jpg"/></div></div></figure><h1 id="3d1f" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">打字生成器</h1><p id="3772" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">生成器发布数据。从简单(也很无聊)开始，让我们创建一个发布偶数的生成器:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="1485" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">function</strong>* evens(): Generator&lt;number, <strong class="ko ir">void</strong>, <strong class="ko ir">void</strong>&gt; {<br/>  <strong class="ko ir">let</strong> current = 0;<br/>  <strong class="ko ir">while</strong> (<strong class="ko ir">true</strong>) {<br/>    <strong class="ko ir">yield</strong> current;<br/>    current += 2;<br/>  }<br/>}</span></pre><p id="de7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们:</p><ul class=""><li id="cadf" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">产量数字</li><li id="0a0c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">不要退回任何东西</li><li id="f5bd" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">当我们让步时，不要期望注入任何东西(没有变量绑定到<code class="fe kl km kn ko b">yield</code>的左边)。</li></ul><p id="cfae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的发电机类型是<code class="fe kl km kn ko b">Generator&lt;number, void, void&gt;</code>。对于生成器，<code class="fe kl km kn ko b">Next</code>类型参数通常是<code class="fe kl km kn ko b">void</code>:很少将值注入到生成器中(尽管我们确实看到许多人为的例子，人们试图重新开始一个斐波那契数列)。</p><p id="63cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试试稍微复杂一点的。我们可以创建一个递归遍历文件树的生成器:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="4e65" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">import</strong> fs from 'fs'<br/><strong class="ko ir">import</strong> path from 'path'<br/><br/><strong class="ko ir">function</strong>* walkDirectories(root: string): Generator&lt;string, <strong class="ko ir">void</strong>, <strong class="ko ir">void</strong>&gt; {<br/>  <strong class="ko ir">for</strong> (<strong class="ko ir">const</strong> name <strong class="ko ir">of</strong> fs.readdirSync(root)) {<br/>    <strong class="ko ir">const</strong> filePath = path.join(root, name)<br/>    <strong class="ko ir">const</strong> stat = fs.lstatSync(filePath)<br/>    <strong class="ko ir">if</strong> (stat.isFile()) {<br/>      <strong class="ko ir">yield</strong> filePath<br/>    } <strong class="ko ir">else</strong> <strong class="ko ir">if</strong> (stat.isDirectory()) {<br/>      <strong class="ko ir">yield</strong>* walkDirectories(filePath)<br/>    }<br/>  }<br/>}</span></pre><p id="43fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们读取根目录的内容，对于每一项，如果它是一个文件，就发布它；如果它是一个目录，就递归地发布它的内容。我们仍然不返回任何东西，或者绑定到<code class="fe kl km kn ko b">yield</code>语句，所以我们的生成器仍然是<code class="fe kl km kn ko b">Generator&lt;?, void, void&gt;</code>。我们要么直接产生字符串，要么子目录中的任何内容也是字符串。因此<code class="fe kl km kn ko b">Yield</code>的类型参数为<code class="fe kl km kn ko b">string</code>，构成整体类型<code class="fe kl km kn ko b">Generator&lt;string, void, void&gt;</code>。</p><h1 id="419b" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输入消耗生成器的函数</h1><p id="6911" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">我们现在有了函数<code class="fe kl km kn ko b">walkDirectories</code>的类型。我们发电机的消费者呢？让我们编写一个函数，按文件扩展名对文件进行分组，并计算每个扩展名的文件数:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="36e3" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">function</strong> countFilesByExtension(files): {[string]: number} {<br/>  <strong class="ko ir">const</strong> total = {};<br/>  <strong class="ko ir">for</strong> (<strong class="ko ir">const</strong> f <strong class="ko ir">of</strong> files) {<br/>    <strong class="ko ir">const</strong> extension = path.extname(f)<br/>    <strong class="ko ir">const</strong> currentCount = total[extension] || 0<br/>    total[extension] = currentCount + 1<br/>  }<br/>  <strong class="ko ir">return</strong> total<br/>}</span></pre><p id="5ab2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，参数<code class="fe kl km kn ko b">files</code>是我们的生成器。<code class="fe kl km kn ko b">files</code>是什么类型的？当然，我们可以将其输入为:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="c865" class="mc kr iq ko b gy md me l mf mg">// overly specific</span><span id="9234" class="mc kr iq ko b gy nd me l mf mg">function countFilesByExtension(<br/>  files: Generator&lt;string, void, void&gt;<br/>): {[string]: number} { // ...</span></pre><p id="4e28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，更好的说法是:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="3b41" class="mc kr iq ko b gy md me l mf mg">// still overly specific </span><span id="3f6f" class="mc kr iq ko b gy nd me l mf mg">function countFilesByExtension(<br/>  files: Generator&lt;string, any, any&gt;<br/>): {[string]: number} { // ...</span></pre><p id="5dd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但实际上，我们只关心<code class="fe kl km kn ko b">files</code>是否可以被迭代。例如，传入一个数组是合法的。因此，推荐使用的类型是<code class="fe kl km kn ko b">Iterator</code>:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="dc96" class="mc kr iq ko b gy md me l mf mg">function countFilesByExtension(<br/>  files: Iterator&lt;string&gt;<br/>): {[string]: number} { // ...</span></pre><p id="088c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将与我们的生成器一起工作，因为<code class="fe kl km kn ko b">Generator&lt;T, any, any&gt;</code>实现了<code class="fe kl km kn ko b">Iterator&lt;T&gt;</code>接口。</p><p id="e264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以如下使用整个管道:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="0f6d" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">import</strong> os from 'os'<br/><br/><strong class="ko ir">const</strong> rootDirectory = os.homedir()<br/><br/>console.log(<br/>  countFilesByExtension(<br/>    walkDirectories(rootDirectory)<br/>  )<br/>)</span></pre><figure class="lu lv lw lx gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/7cf88693a9de97e23eb9640c9579f330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FGnH89jF10zC27Yf.jpg"/></div></div></figure><h1 id="2a91" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">键入协程</h1><p id="8959" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在围绕生成器构建的程序中，信息是由消费者拉取的。在围绕协程构建的程序中，信息被推送给消费者。让我们创建一个管道，打印出给定目录中的文件。我们将在节点的<code class="fe kl km kn ko b"><a class="ae kp" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">fs</a></code>模块中包装异步的、基于回调的函数。本节中的示例大致基于<em class="lt">探索JavaScript </em>的<a class="ae kp" href="http://exploringjs.com/es6/ch_generators.html#sec_overview-generators" rel="noopener ugc nofollow" target="_blank">生成器部分</a>。</p><p id="7af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，协程管道中的阶段采用一个<code class="fe kl km kn ko b">target</code>参数来标识管道中的下一个阶段。因此，如果我们有一个函数将类型为<code class="fe kl km kn ko b">T</code>的数据推入管道，那么该函数的类型签名将是:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="0190" class="mc kr iq ko b gy md me l mf mg">function (target: Generator&lt;any, any, T&gt;): void { /* ... */ }</span></pre><p id="ffef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从编写源函数开始。源本身通常不是一个协程，但是它将一个协程作为目标。</p><p id="9df4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用Node的<code class="fe kl km kn ko b">fs.readdir</code>将一个给定目录中所有条目的列表推送到目标:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="7959" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">const</strong> pushFiles = <strong class="ko ir">function</strong>(<br/>  directory: string,<br/>  target: Generator&lt;any, any, string&gt;<br/>): <strong class="ko ir">void</strong> {<br/>  fs.readdir(<br/>    directory,<br/>    { encoding: 'utf-8' },<br/>    (error, fileNames) =&gt; {<br/>      <strong class="ko ir">if</strong> (error) {<br/>        <strong class="ko ir">throw</strong> error<br/>      } <strong class="ko ir">else</strong> {<br/>        <strong class="ko ir">for</strong> (<strong class="ko ir">const</strong> fileName <strong class="ko ir">of</strong> fileNames) {<br/>          <strong class="ko ir">const</strong> filePath = path.join(directory, fileName)<br/>          target.next(filePath)  <em class="lt">// push file paths to a coroutine</em><br/>        }<br/>      }<br/>    }<br/>  )<br/>}</span></pre><p id="d8d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，目标必须是一个<code class="fe kl km kn ko b">Generator&lt;any, any, string&gt;</code>:它必须接受yield语句左侧的字符串。目标将包括如下陈述:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="83eb" class="mc kr iq ko b gy md me l mf mg">const file: string = yield</span></pre><p id="18c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们创建一个协程，它只记录传递给它的所有内容:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="61a4" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">const</strong> log = <strong class="ko ir">function</strong>* (): Generator&lt;<strong class="ko ir">void</strong>, <strong class="ko ir">void</strong>, any&gt; {<br/>  <strong class="ko ir">while</strong> (<strong class="ko ir">true</strong>) {<br/>    <strong class="ko ir">const</strong> item: any = <strong class="ko ir">yield</strong><br/>    console.log(item)<br/>  }<br/>})</span></pre><p id="daf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的协程类型是<code class="fe kl km kn ko b">Generator&lt;void, void, any&gt;</code>:</p><ul class=""><li id="e500" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Yield</code>是无效的，因为它不产生任何东西</li><li id="99af" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Return</code>无效，因为函数不返回</li><li id="e6e6" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Next</code>是<code class="fe kl km kn ko b">any</code>，因为它接受来自上游的任何类型。</li></ul><p id="3c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有点烦人的是，我们不能不初始化就直接使用我们的<code class="fe kl km kn ko b">log</code>协程，因为协程需要前进到第一个产出。我们需要写:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="ea74" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">const</strong> logCoroutine = log()<br/>logCoroutine.next() <em class="lt">// initialize coroutine</em><br/><br/><em class="lt">// Read files in home directory and push them to logCoroutine</em><br/>pushFiles(os.homedir(), logCoroutine)</span></pre><p id="6f47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了减少这种样板文件，通常编写一个助手函数来创建生成器，通过调用它的<code class="fe kl km kn ko b">next</code>方法来初始化它并返回它:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="0b69" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">function</strong> coroutine(generatorFunction) {<br/>  <strong class="ko ir">return</strong> <strong class="ko ir">function</strong>(...args) {<br/>    <strong class="ko ir">const</strong> generator = generatorFunction(...args)<br/>    generator.next()<br/>    <strong class="ko ir">return</strong> generator<br/>  }<br/>}</span></pre><p id="5ea5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">键入这个helper方法有点棘手。我们真正要告诉Flow的是，我们返回一个与<code class="fe kl km kn ko b">generatorFunction</code>同类型的函数。我们还需要指定<code class="fe kl km kn ko b">generatorFunction</code>是一个接受变量类型并返回生成器的函数。例如，我们可以写:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="2091" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">function</strong> coroutine&lt;G: Generator&lt;any, any, any&gt;&gt;(<br/>  generatorFunction: ((...args: Array&lt;any&gt;) =&gt; G)<br/>) {<br/>  <strong class="ko ir">return</strong> <strong class="ko ir">function</strong>(...args: Array&lt;any&gt;): G {<br/>    <strong class="ko ir">const</strong> generator = generatorFunction(...args)<br/>    generator.next()<br/>    <strong class="ko ir">return</strong> generator<br/>  }<br/>}</span></pre><p id="77f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们指定<code class="fe kl km kn ko b">generatorFunction</code>必须是返回任何生成器的函数，并且我们的协程函数将自己返回返回该生成器的函数。不幸的是，在Flow中没有好的方法来对多态变量函数进行类型化(见<a class="ae kp" href="https://github.com/facebook/flow/issues/1251" rel="noopener ugc nofollow" target="_blank">本期</a>)，所以我们在<code class="fe kl km kn ko b">generatorFunction</code>的参数中失去了类型安全性。我们可以通过显式地键入协程来避免这种泄漏到程序的其他部分。我们的<code class="fe kl km kn ko b">log</code>功能现在变成了:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="1198" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">const</strong> log: () =&gt; Generator&lt;<strong class="ko ir">void</strong>, <strong class="ko ir">void</strong>, any&gt; = coroutine(<strong class="ko ir">function</strong>* () {<br/>  <strong class="ko ir">while</strong> (<strong class="ko ir">true</strong>) {<br/>    <strong class="ko ir">const</strong> item: any = <strong class="ko ir">yield</strong><br/>    console.log(item)<br/>  }<br/>})</span></pre><p id="7953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，通过将类型移至<code class="fe kl km kn ko b">log</code>，而不是直接基于<code class="fe kl km kn ko b">coroutine</code>的参数，我们可以在程序的剩余部分以类型安全的方式使用<code class="fe kl km kn ko b">log</code>。</p><p id="bfbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在不再需要初始化我们的协程来使用它了:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="5df7" class="mc kr iq ko b gy md me l mf mg">pushFiles(os.homedir(), log())</span></pre><p id="2572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们在管道中创建一个中间步骤，过滤掉不是简单文件的任何内容:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="70b4" class="mc kr iq ko b gy md me l mf mg"><strong class="ko ir">const</strong> isFile: (Generator&lt;any, any, string&gt; =&gt; Generator&lt;<strong class="ko ir">void</strong>, <strong class="ko ir">void</strong>, string&gt;) =<br/>  coroutine(<strong class="ko ir">function</strong>* (target) {<br/>    <strong class="ko ir">while</strong> (<strong class="ko ir">true</strong>) {<br/>      <strong class="ko ir">const</strong> fileMaybe: string = <strong class="ko ir">yield</strong><br/>      fs.lstat(fileMaybe, (error, stat) =&gt; {<br/>        <strong class="ko ir">if</strong> (error) {<br/>          <strong class="ko ir">throw</strong> error<br/>        } <strong class="ko ir">else</strong> <strong class="ko ir">if</strong> (stat.isFile()) {<br/>          target.next(fileMaybe)<br/>        }<br/>      })<br/>    }<br/>  })</span></pre><p id="1822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的函数接受任何接受字符串的协程作为其目标(因为这是它推出的内容)。其返回类型为<code class="fe kl km kn ko b">Generator&lt;void, void, string&gt;</code>:</p><ul class=""><li id="da44" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Yield</code>是空的，因为它不产生任何东西</li><li id="8b85" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Return</code>无效，因为函数不返回</li><li id="2f7a" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe kl km kn ko b">Next</code>是<code class="fe kl km kn ko b">string</code>，因为它期望从上游获得字符串。</li></ul><p id="8e13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Generator&lt;void, void, string&gt;</code>将满足我们在<code class="fe kl km kn ko b">pushFiles</code>中的<code class="fe kl km kn ko b">target</code>参数上指定的约束<code class="fe kl km kn ko b">Generator&lt;any, any, string&gt;</code>。</p><p id="88a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以构建我们的协程管道:</p><pre class="lu lv lw lx gt ly ko lz ma aw mb bi"><span id="ed6d" class="mc kr iq ko b gy md me l mf mg">pushFiles(os.homedir(), isFile(log()))</span></pre><h1 id="88c6" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="05ef" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">流量很大。它捕捉了大量单元测试或手工QA会遗漏的错误。这也使得新用户更容易阅读代码。</p><p id="f9db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，对于更复杂的类型，很少有好的例子。如果您很难将流类型添加到一个构造中，请写下来，以便社区可以从中受益！</p><h1 id="60ee" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">更多！</h1><p id="53c3" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">有关更多信息:</p><p id="ce43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于发电机的<a class="ae kp" href="https://flow.org/blog/2015/11/09/Generators/" rel="noopener ugc nofollow" target="_blank">流程文件</a>是有用的进一步阅读材料。</p><p id="e744" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经提到过<a class="ae kp" href="http://exploringjs.com/es6/ch_generators.html#sec_overview-generators" rel="noopener ugc nofollow" target="_blank">探索JavaScript </a>。代码样本可以在<a class="ae kp" href="https://github.com/rauschma/generator-examples/tree/gh-pages/node" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="5731" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了更深入地理解协程，David Beazley有一些很棒的幻灯片。这些是针对Python的，但是概念是非常可移植的。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="e190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lt">最初发表于</em><a class="ae kp" href="https://pascalbugnion.net/blog/flow-types-for-generators-and-coroutines.html" rel="noopener ugc nofollow" target="_blank">T5【pascalbugnion.net】</a><em class="lt">。</em></p></div></div>    
</body>
</html>