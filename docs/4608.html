<html>
<head>
<title>Containerizing Multi-Arch Base Accelerator Run-Time Environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器化多拱基础加速器运行时环境</h1>
<blockquote>原文：<a href="https://itnext.io/containerizing-multi-arch-base-accelerator-run-time-environments-f814aa02706e?source=collection_archive---------8-----------------------#2020-08-03">https://itnext.io/containerizing-multi-arch-base-accelerator-run-time-environments-f814aa02706e?source=collection_archive---------8-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9b8b5d5a8e58f866977046bf7aae3872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cO8FbT0SHXGxrU71dWszrw.jpeg"/></div></div></figure><div class=""/><p id="abcf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" href="https://sodalite.eu/" rel="noopener ugc nofollow" target="_blank">方钠石H2020项目</a>中，我们处理利用各种异构加速器的应用部署的部署和重新配置。虽然大多数加速器都提供了易于安装的环境来支持其运行，但我们观察到了以下局限性:</p><ul class=""><li id="55ae" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">大多数加速器运行时环境都不是以现成的容器化格式提供的。</li><li id="887b" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">尽管没有特定的架构依赖性，但许多加速器运行时环境并不是开箱即用的多拱感知环境。</li><li id="3296" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">加速后的应用程序花在docker文件上的时间和花在应用程序需求上的时间一样多，导致了大量不必要的样板文件，很快就过时了。</li><li id="ba88" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">加速的应用程序可能能够利用不同的加速器来完成相同的任务，特别是当加速器不可知的框架，如<a class="ae kz" href="https://onnx.ai/" rel="noopener ugc nofollow" target="_blank"> ONNX </a>被越来越多地采用时。</li><li id="8c6c" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">支持以特定加速器类型为目标的预配置映像变体，允许在异构Kubernetes集群中细粒度地放置和执行应用容器，例如基于节点标签放置。</li></ul><p id="32ff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑到这一点，我们决定谨慎地尝试将加速器运行时环境和应用程序逻辑的设置分离，建立一组易于扩展的最小加速器特定基本容器，在这些容器上放置加速的应用程序。</p><h1 id="a9bf" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤1:为多拱准备minideb</h1><p id="5ed1" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">最小debian环境的一个流行选项是<code class="fe mr ms mt mu b">bitnami/minideb</code>。由于大多数供应商为他们的运行时环境提供debian包，我们决定坚持使用<code class="fe mr ms mt mu b">minideb</code>(而不是其他解决方案，如Alpine)作为加速器映像的基础。然而，到目前为止，多拱支持还不是<code class="fe mr ms mt mu b">minideb</code>的优先事项——GitHub有一个问题专门跟踪这个问题:</p><div class="is it gp gr iu mv"><a href="https://github.com/bitnami/minideb/issues/76" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jf gy z fp na fr fs nb fu fw jd bi translated">Arm64支持问题#76 bitnami/minideb</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">解散GitHub是超过5000万开发者的家园，他们一起工作来托管和审查代码，管理项目，以及…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ja mv"/></div></div></a></div><p id="0148" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们被迫创建自己的多拱建筑，并在清单后面发布。最终结果是<a class="ae kz" href="https://hub.docker.com/repository/docker/adaptant/minideb/general" rel="noopener ugc nofollow" target="_blank">adaptent/minideb</a>映像，它包括对amd64和arm64的开箱即用支持(如果您觉得这很有用，并且希望看到其他目标架构得到支持，请在我们的<a class="ae kz" href="https://github.com/adaptant-labs/accelerator-base-containers/issues" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>中打开一个问题)。</p><h1 id="bdab" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤2:准备加速器基础容器</h1><p id="780c" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">建立了多拱起点之后，下一步是深入研究不同加速器的运行时环境。出于这一目的，并且为了使其他人不必经历同样的过程，我们建立了一个专门用于管理这些内容的存储库:</p><div class="is it gp gr iu mv"><a href="https://github.com/adaptant-labs/accelerator-base-containers" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jf gy z fp na fr fs nb fu fw jd bi translated">适配器-实验室/加速器-基础-容器</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">各种异构加速器的基本容器和它们各自的运行时这个项目旨在提供一个…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ja mv"/></div></div></a></div><p id="a7fd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然这只是一个开始，但我们希望这对其他人有用，并欢迎PRs添加新配置！</p><h1 id="4bfa" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤3:在实践中使用基本容器</h1><p id="379b" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">以EdgeTPU为例，我们可以使用<a class="ae kz" href="https://coral.ai/docs/edgetpu/api-intro/" rel="noopener ugc nofollow" target="_blank"> EdgeTPU Python API </a>(在加速器基本容器中提供)编写一个简单的Python脚本来查询运行时版本并显示检测到的设备:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="574e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将其容器化，我们只需要构建一个适当的基本容器(在本例中为<code class="fe mr ms mt mu b">acceleratorbase/edgetpu-std</code>)并且只需要添加与我们的应用程序逻辑相关的部分:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="22f4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完整的代码示例可以在<a class="ae kz" href="https://github.com/adaptant-labs/accelerator-base-containers/tree/master/examples/edgetpu-devicequery" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="6669" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了生成多拱图像，我们使用<a class="ae kz" href="https://docs.docker.com/buildx/working-with-buildx/" rel="noopener ugc nofollow" target="_blank"> Docker Buildx </a>来执行构建:</p><pre class="nl nm nn no gt nr mu ns nt aw nu bi"><span id="b3c5" class="nv lp je mu b gy nw nx l ny nz">$ docker buildx build -t acceleratorbase/example-edgetpu-devicequery --platform linux/amd64,linux/arm64 .<br/>[+] Building 3.2s (9/9) FINISHED<br/> =&gt; [internal] load .dockerignore                             <br/> =&gt; =&gt; transferring context: 2B                   <br/> =&gt; [internal] load build definition from Dockerfile<br/> =&gt; =&gt; transferring dockerfile: 31B<br/> =&gt; [linux/amd64 internal] load metadata for docker.io/acceleratorbase/edgetpu-std:latest                                                                                                             <br/> =&gt; [linux/arm64 internal] load metadata for docker.io/acceleratorbase/edgetpu-std:latest<br/> =&gt; [internal] load build context          <br/> =&gt; =&gt; transferring context: 36B<br/> =&gt; [linux/arm64 1/2] FROM docker.io/acceleratorbase/edgetpu-std@sha256:6f4103ab071d4b6fd7f8797e8858554ceb6d3c255c9c190276bf77716158267c     <br/> =&gt; =&gt; resolve docker.io/acceleratorbase/edgetpu-std@sha256:6f4103ab071d4b6fd7f8797e8858554ceb6d3c255c9c190276bf77716158267c   <br/> =&gt; [linux/amd64 1/2] FROM docker.io/acceleratorbase/edgetpu-std@sha256:6f4103ab071d4b6fd7f8797e8858554ceb6d3c255c9c190276bf77716158267c<br/> =&gt; =&gt; resolve docker.io/acceleratorbase/edgetpu-std@sha256:6f4103ab071d4b6fd7f8797e8858554ceb6d3c255c9c190276bf77716158267c<br/> =&gt; CACHED [linux/amd64 2/2] ADD devicequery.py /<br/> =&gt; CACHED [linux/arm64 2/2] ADD devicequery.py /</span></pre><p id="4c39" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用在<code class="fe mr ms mt mu b">acceleratorbase/example-edgetpu-devicequery</code>映像名称下生成的多拱映像，我们现在可以在带有USB连接的EdgeTPU的amd64机器上运行相同的映像:</p><pre class="nl nm nn no gt nr mu ns nt aw nu bi"><span id="eaa9" class="nv lp je mu b gy nw nx l ny nz">$ uname -m<br/>x86_64<br/>$ docker run --privileged acceleratorbase/example-edgetpu-devicequery<br/>BuildLabel(COMPILER=5.4.0 20160609,DATE=redacted,TIME=redacted,CL_NUMBER=291256449), RuntimeVersion(13)<br/>Available EdgeTPU Devices:<br/>/sys/bus/usb/devices/1-9</span></pre><p id="ed8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者在基于arm64的Coral开发板上集成EdgeTPU:</p><pre class="nl nm nn no gt nr mu ns nt aw nu bi"><span id="5016" class="nv lp je mu b gy nw nx l ny nz">$ uname -m<br/>aarch64<br/>$ docker run --privileged acceleratorbase/example-edgetpu-devicequery<br/>BuildLabel(COMPILER=6.3.0 20170516,DATE=redacted,TIME=redacted,CL_NUMBER=291256449), RuntimeVersion(13)<br/>Available EdgeTPU Device(s):<br/>/dev/apex_0</span></pre><h1 id="b152" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">步骤4:用方钠石生成图像变体</h1><p id="b357" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">虽然步骤3中的示例演示了我们如何能够提供一个多arch感知的基础来进行构建，但是如果我们想要为同一应用程序支持不同的加速器或加速器配置呢？</p><h2 id="ebad" class="nv lp je bd lq oa ob dn lu oc od dp ly km oe of mc kq og oh mg ku oi oj mk ok bi translated">静态设备时钟的动态重新配置(EdgeTPU)</h2><p id="91d1" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">例如，基于USB的EdgeTPU依靠专有库的静态时钟来配置加速器时钟速率。提供了该库的两种变体:</p><ul class=""><li id="ba2f" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><code class="fe mr ms mt mu b">libedgetpu1-std</code>以标准时钟速率运行。</li><li id="8a34" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><code class="fe mr ms mt mu b">libedgetpu1-max</code>以最大时钟速率运行。</li></ul><p id="8dec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如预期的那样，<code class="fe mr ms mt mu b">-std</code>变体产生的热量比<code class="fe mr ms mt mu b">-max</code>变体少，但运行速度也是后者的一半。由于EdgeTPU的温度容差相当窄，因此必须监控温度，并根据工作负载的热属性和容差来降低(或提高)时钟频率。允许设备超出其容差会导致难以调试的问题，包括随机推理失败，或者更糟的是，损坏物理设备本身。</p><blockquote class="ol om on"><p id="95b3" class="kb kc oo kd b ke kf kg kh ki kj kk kl op kn ko kp oq kr ks kt or kv kw kx ky im bi translated">因此，应用程序必须能够提供针对任一时钟场景预先配置的映像变量，以便在实现最佳性能的同时降低运行时推理失败的风险。</p></blockquote><p id="bc28" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，所需的时钟速率和性能模式在应用程序启动时配置，并由应用程序所链接的库决定。</p><h2 id="989a" class="nv lp je bd lq oa ob dn lu oc od dp ly km oe of mc kq og oh mg ku oi oj mk ok bi translated">方钠石图像生成器中的图像变体</h2><p id="d505" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">幸运的是，<a class="ae kz" href="https://github.com/SODALITE-EU/image-builder" rel="noopener ugc nofollow" target="_blank">方钠石图像生成器</a>为我们提供了一种机制，通过基本图像重载从应用docker文件生成多个容器图像变体:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/5d48435a90c8ceb0e16453f26282c221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKRCJubKzAHF0oYaMSGMgw.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">方钠石图像生成器—图像变体生成工作流程</figcaption></figure><p id="375d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在其核心，image builder通过解析一个输入模板来工作，该模板为它提供了关于Docker文件的位置、要从中克隆源代码的存储库(或者本地路径，如果没有使用git的话)、要推送的Docker注册表、要生成的图像变量等基本信息。每个图像变体都包括它自己的标签和一个基础图像覆盖。输入文件的格式是:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a88a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在幕后，映像构建器为映像的实际构建编排和部署一个可行的剧本。通过获取主docker文件并为每个变体配置的基础映像的构建时重载动态重写它，可以启用映像变体(为<code class="fe mr ms mt mu b">latest</code>标记保留默认基础映像，除非另有说明)。下面更详细地概述了实现这一点的精确过程:</p><figure class="nl nm nn no gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/8c45752f6654faaa6b0411bf569e4e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Iplm4lVYynCymcFUY8W2w.png"/></div></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">为docker文件提供一个可重载的BASE_IMAGE</figcaption></figure><p id="f86c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值得注意的是，映像构建器负责在构建时为基础映像重载修改docker文件，不需要手动修改docker文件。它还能够处理单阶段和多阶段tracker文件，并且应该能够处理任何扔向它的东西(但是，如果您设法破坏了它，我们将很高兴在<a class="ae kz" href="https://github.com/SODALITE-EU/image-builder/issues" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>中收到您的报告)。</p><h2 id="60a3" class="nv lp je bd lq oa ob dn lu oc od dp ly km oe of mc kq og oh mg ku oi oj mk ok bi translated">使用方钠石图像生成器构建图像变体</h2><p id="0c72" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">尽管并非绝对必要，但出于实验的目的，我们在继续之前启动了一个本地图像注册表，并将使用它将我们的图像推送到:</p><pre class="nl nm nn no gt nr mu ns nt aw nu bi"><span id="9685" class="nv lp je mu b gy nw nx l ny nz">$ docker run -d -p 5000:5000 --restart=always --name registry registry:2</span></pre><p id="f224" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以使用本地注册表为映像构建器准备一个输入文件，并生成<code class="fe mr ms mt mu b">-std</code>和<code class="fe mr ms mt mu b">-max</code>变量:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="07b6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，在这种情况下，我们已经将我们的应用程序推出到GitHub，并将让image builder在构建时直接获取存储库，因为这最像真实世界的应用程序。但是，也可以使用本地构建上下文:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="f8c9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了调用图像构建器，我们可以使用一个<a class="ae kz" href="https://raw.githubusercontent.com/SODALITE-EU/image-builder/master/image-builder-cli.sh" rel="noopener ugc nofollow" target="_blank">便利的包装器</a>，它利用了图像构建器的自包含版本:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="34d6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以构建图像变体:</p><pre class="nl nm nn no gt nr mu ns nt aw nu bi"><span id="c106" class="nv lp je mu b gy nw nx l ny nz">$ ./image-builder-cli.sh edgetpu-devicequery-image-variants.yaml<br/>[Worker_0]   Deploying my-workstation_0<br/>[Worker_0]   Deployment of my-workstation_0 complete<br/>[Worker_0]   Deploying image-builder_0<br/>[Worker_0]     Executing create on image-builder_0<br/>[Worker_0]   Deployment of image-builder_0 complete</span></pre><p id="fcc0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将生成两个版本的应用程序容器:</p><ul class=""><li id="5434" class="la lb je kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><code class="fe mr ms mt mu b">adaptant/edgetpu-devicequery:std</code>层层叠加<code class="fe mr ms mt mu b">acceleratorbase/edgetpu-std</code>(默认)。</li><li id="85f8" class="la lb je kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><code class="fe mr ms mt mu b">adaptant/edgetpu-devicequery:max</code>层层叠叠<code class="fe mr ms mt mu b">acceleratorbase/edgetpu-max</code>。</li></ul><p id="c711" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并将它们推送到本地注册表。我们现在可以从注册中心查询存储库和标记，确认每个变体都已成功生成和推送:</p><pre class="nl nm nn no gt nr mu ns nt aw nu bi"><span id="daeb" class="nv lp je mu b gy nw nx l ny nz">$ curl -X GET localhost:5000/v2/_catalog<br/>{"repositories":["adaptant/edgetpu-devicequery"]}</span><span id="4359" class="nv lp je mu b gy oy nx l ny nz">$ curl -X GET localhost:5000/v2/adaptant/edgetpu-devicequery/tags/list<br/>{"name":"adaptant/edgetpu-edgetpu-devicequery","tags":["std","max"]}</span></pre><h2 id="a720" class="nv lp je bd lq oa ob dn lu oc od dp ly km oe of mc kq og oh mg ku oi oj mk ok bi translated">限制</h2><p id="d4bb" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">由于Ansible Docker插件的当前版本不支持<a class="ae kz" href="https://docs.docker.com/buildx/working-with-buildx/" rel="noopener ugc nofollow" target="_blank"> Docker Buildx </a>，所以目前仍然必须手工创建和推出多拱清单。目前，我们通过在每个目标体系结构上运行image builder实例，同时使用共享注册表，然后手动协调清单来实现这一点。虽然这是一个权宜之计，但它不是长期的，随着Ansible中插件支持的改进，我们将更新多拱的图像生成器。</p><h1 id="be15" class="lo lp je bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="a9b1" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在本文中，我们试图解决我们在现成的加速器基础容器中观察到的差距，并展示了应用程序如何直接构建在我们的基础容器和分层方法之上，以便专注于与应用程序逻辑更具体相关的方面，同时简化应用程序order文件。</p><p id="766b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还进一步展示了使用方钠石图像生成器如何进一步完善这一工作流程，为应用程序提供一种机制来创建基于不同基础图像的图像变体，允许应用程序提供不同的容器图像，以便在特定类型的加速器上运行。</p><h2 id="4fc1" class="nv lp je bd lq oa ob dn lu oc od dp ly km oe of mc kq og oh mg ku oi oj mk ok bi translated">接下来</h2><p id="3325" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在下一篇文章中，我们将探讨SODALITE运行时监控器和重构器如何利用Prometheus和AlertManager对部署的应用程序进行热量监控，以便动态地重新配置部署，使其保持在推理引擎的热量容差范围内。</p><h2 id="5eea" class="nv lp je bd lq oa ob dn lu oc od dp ly km oe of mc kq og oh mg ku oi oj mk ok bi translated">承认</h2><p id="da93" class="pw-post-body-paragraph kb kc je kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">本项目获得了欧盟地平线2020研究与创新计划的资助，资助协议号为825480(<a class="ae kz" href="https://www.sodalite.eu" rel="noopener ugc nofollow" target="_blank"><em class="oo"/></a><em class="oo">)。</em></p></div></div>    
</body>
</html>