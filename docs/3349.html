<html>
<head>
<title>How to make a cross-platform serverless video sharing app with Flutter, Firebase and Publitio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Flutter，Firebase，Publitio做一个跨平台无服务器的视频分享app</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68?source=collection_archive---------7-----------------------#2019-11-26">https://itnext.io/how-to-make-a-cross-platform-serverless-video-sharing-app-with-flutter-firebase-and-publitio-900a9fa0dd68?source=collection_archive---------7-----------------------#2019-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f2affae57d11e18345ca588bc652a060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n6H6y-y8FVIGtSzh.png"/></div></div></figure><h1 id="6513" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们正在建造的东西</h1><p id="e85f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将看到如何构建一个跨平台的移动应用程序，允许用户上传和共享视频。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/884fbd29d9c8889c8f1c7388f89386af.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*xjuUh4J6Y4lrQJ7p.gif"/></div></figure><h1 id="5aad" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">堆栈</h1><ul class=""><li id="afec" class="mc md it lb b lc ld lg lh lk me lo mf ls mg lw mh mi mj mk bi translated"><a class="ae ml" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank">Flutter</a>——谷歌新的跨平台移动应用开发框架，使用Dart语言。</li><li id="adf9" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated"><a class="ae ml" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a> —无服务器实时数据库，用于存储和同步客户端之间的视频元数据。</li><li id="2946" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated"><a class="ae ml" href="https://publit.io?fpr=jonathan43" rel="noopener ugc nofollow" target="_blank"> Publitio </a> —我们将用于存储和发布视频的托管平台。</li></ul><h2 id="a92c" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">摆动</h2><p id="ff9d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Flutter为我们提供了一种为iOS和Android编写一个代码库的方法，而不必复制逻辑或UI。相对于Cordova等解决方案的优势在于，它针对移动性能进行了优化，提供了类似本机的响应。与React Native等产品相比，它的优势在于您可以编写一次UI，因为它完全避开了OS原生UI组件。Flutter还有一流的开发体验，包括热重装和在VSCode中调试，很牛逼。</p><h2 id="a9ff" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">重火力点</h2><p id="cca7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">保持无服务器对应用程序的开发时间和可伸缩性有巨大的好处。我们可以专注于我们的应用程序，而不是服务器开发。Firebase让我们无需服务器端代码就可以在客户端之间同步数据，包括离线同步功能(这很难实现)。Flutter也有一组firebase插件，使它可以很好地与Flutter小部件配合使用，因此当另一个客户端更改数据时，我们可以实时同步客户端UI。</p><h2 id="d3bc" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">公共报</h2><p id="cca3" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将使用Publitio作为我们的媒体资产管理API。Publitio将负责托管我们的文件，使用其CDN、缩略图/封面图像生成、转换/裁剪和其他视频处理功能将文件交付给客户。</p><p id="4989" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">通过使用API，我们不用在内部重新发明视频处理。</p><h2 id="234e" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">安全警告</h2><p id="bf5b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这个方法将您的publitio API密钥和机密存储在客户机上。这涉及到安全问题。除非你同意理论上所有客户端都可以查看和修改你的所有文件，否则你应该使用我在下一篇文章<a class="ae ml" rel="noopener ugc nofollow" target="_blank" href="/serverless-video-upload-and-encoding-with-firebase-storage-cloud-functions-and-publitio-a4b2997b1508">中描述的云函数从服务器端调用publitio。</a></p><h1 id="b44b" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们开始吧</h1><p id="0758" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，使用flutter的<a class="ae ml" href="https://flutter.dev/docs/get-started/install" rel="noopener ugc nofollow" target="_blank">入门</a>，确保你已经建立了一个可用的Flutter环境。</p><p id="e7d1" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在让我们创建一个名为<code class="fe ni nj nk nl b">flutter_video_sharing</code>的新项目。在终端运行中:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="356e" class="mr kc it nl b gy nq nr l ns nt">flutter create --org com.learningsomethingnew.fluttervideo --project-name flutter_video_sharing -a kotlin -i swift flutter_video_sharing</span></pre><p id="2d82" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">要检查项目是否已成功创建，请运行<code class="fe ni nj nk nl b">flutter doctor</code>，并查看是否有任何问题。</p><p id="c05f" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在使用<code class="fe ni nj nk nl b">flutter run</code>运行基本项目，进行一点完整性检查(您可以使用仿真器或真实设备，Android或iOS)。</p><blockquote class="nu nv nw"><p id="088b" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it">这是初始化git存储库并进行第一次提交的好时机。</em></p></blockquote><h1 id="908c" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">拍摄视频</h1><p id="c230" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了使用设备摄像头拍摄视频，我们将使用<a class="ae ml" href="https://pub.dev/packages/image_picker" rel="noopener ugc nofollow" target="_blank">图像拾取器插件进行抖动</a>。</p><p id="62c4" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">在<code class="fe ni nj nk nl b">pubspec.yaml</code>依赖项部分，添加一行代码(更改为插件的最新版本):</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="4b5e" class="mr kc it nl b gy nq nr l ns nt">image_picker: ^0.6.1+10</span></pre><blockquote class="nu nv nw"><p id="de4b" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it">你可能会注意到，还有一个</em> <a class="ae ml" href="https://pub.dev/packages/camera" rel="noopener ugc nofollow" target="_blank"> <em class="it">相机插件</em> </a> <em class="it">。我发现这个插件目前很不稳定，并且在许多android设备上有严重的视频质量限制，因为它只支持camera2 API。</em></p></blockquote><h2 id="bdc3" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">iOS配置</h2><p id="d338" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">对于iOS，我们必须在<code class="fe ni nj nk nl b">ios/Runner/Info.plist</code>中添加摄像头和麦克风的使用说明:</p><blockquote class="nu nv nw"><p id="eaa5" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it">为了在iOS上测试摄像头，你必须使用真实的设备，因为模拟器没有摄像头</em></p></blockquote><h2 id="0923" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">使用插件</h2><p id="66d2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在<code class="fe ni nj nk nl b">lib/main.dart</code>中用下面的代码编辑<code class="fe ni nj nk nl b">_MyHomePageState</code>类:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3162" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">这是怎么回事:</p><ul class=""><li id="e4ba" class="mc md it lb b lc nd lg ne lk od lo oe ls of lw mh mi mj mk bi translated">我们用<code class="fe ni nj nk nl b">_takeVideo</code>代替了<code class="fe ni nj nk nl b">_incrementCounter</code>方法，并把它变成了<code class="fe ni nj nk nl b">async</code>。这就是当我们点击浮动操作按钮时发生的情况。</li><li id="fa9b" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">我们在和<code class="fe ni nj nk nl b">await ImagePicker.pickVideo(source: ImageSource.camera);</code>拍视频。</li><li id="76e7" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">我们将视频文件路径保存在小部件状态下的<code class="fe ni nj nk nl b">_videos</code>列表中。我们调用<code class="fe ni nj nk nl b">setState</code>,这样小部件将重新构建，更改将反映在UI中。</li><li id="a589" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">为了获得一些视觉反馈，我们用一个使用<code class="fe ni nj nk nl b">ListView.builder</code>的<code class="fe ni nj nk nl b">ListView</code>替换了脚手架的主<code class="fe ni nj nk nl b">Column</code>，这将有效地呈现我们的动态列表。</li></ul><p id="4687" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">在此阶段运行将如下所示:</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ede467500991ed5559cbbe1583939b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/0*ihR97qhLy9Q5G97m.png"/></div></figure><h1 id="1d35" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">添加出版物</h1><p id="66b2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在<a class="ae ml" href="https://publit.io?fpr=jonathan43" rel="noopener ugc nofollow" target="_blank"> Publit.io </a>创建一个免费帐户，并从仪表盘获取您的凭证。</p><blockquote class="nu nv nw"><p id="b7c3" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it">注意:上面的链接有我的推荐代码。如果我的写作对你有价值，你可以用这个链接来支持。当然，你可以创建一个没有我的账户😭</em></p></blockquote><h2 id="03b6" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">添加包</h2><p id="182f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">将<a class="ae ml" href="https://pub.dev/packages/flutter_publitio" rel="noopener ugc nofollow" target="_blank"> flutter_publitio </a>插件添加到您的<code class="fe ni nj nk nl b">pubspec.yaml</code>依赖部分:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="97b2" class="mr kc it nl b gy nq nr l ns nt">dependencies:<br/>    flutter_publitio: ^1.0.0</span></pre><h2 id="bcbc" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">创建一个环境文件</h2><p id="0006" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">存储应用程序配置的一个好方法是使用<code class="fe ni nj nk nl b">.env</code>文件，并用<a class="ae ml" href="https://pub.dev/packages/flutter_dotenv" rel="noopener ugc nofollow" target="_blank"> flutter_dotenv </a>加载它们，这反过来又实现了来自<a class="ae ml" href="http://www.12factor.net/" rel="noopener ugc nofollow" target="_blank">十二因素应用程序</a>的指导方针。这个文件将包含我们的API密钥和秘密，因此不应该提交给源代码控制。因此，在项目的根目录下创建一个<code class="fe ni nj nk nl b">.env</code>文件，并将您的凭证放入其中:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="97e9" class="mr kc it nl b gy nq nr l ns nt">PUBLITIO_KEY=12345abcd<br/>PUBLITIO_SECRET=abc123</span></pre><p id="dd83" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在添加<code class="fe ni nj nk nl b">flutter_dotenv</code>作为依赖项，同时在<code class="fe ni nj nk nl b">pubspec.yaml</code>中添加<code class="fe ni nj nk nl b">.env</code>文件作为资产:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="f8c5" class="mr kc it nl b gy nq nr l ns nt">dependencies:<br/>  flutter_dotenv: ^2.0.3<br/><br/>  ...<br/><br/>flutter:<br/>  assets:<br/>    - .env</span></pre><h2 id="ad82" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">iOS配置</h2><p id="bdfd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">对于iOS，从<code class="fe ni nj nk nl b">Info.plist</code>开始加载密钥。为了将我们的配置保存在我们的环境中，而不是提交到我们的存储库中，我们将从一个<code class="fe ni nj nk nl b">xcconfig</code>文件中加载密钥:</p><ul class=""><li id="8007" class="mc md it lb b lc nd lg ne lk od lo oe ls of lw mh mi mj mk bi translated">在XCode中，打开<code class="fe ni nj nk nl b">ios/Runner.xworkspace</code>(这是已经生成的XCode项目Flutter)，右键点击Runner - &gt;新建文件- &gt;其他- &gt;配置设置文件- &gt; Config.xcconfig</li><li id="da8f" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">在<code class="fe ni nj nk nl b">Config.xcconfig</code>中，像在<code class="fe ni nj nk nl b">.env</code>文件中一样添加密钥:</li></ul><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="374f" class="mr kc it nl b gy nq nr l ns nt">PUBLITIO_KEY = 12345abcd<br/>PUBLITIO_SECRET = abc123</span></pre><p id="ba19" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在，我们将从<code class="fe ni nj nk nl b">ios/Flutter/Debug.xcconfig</code>和<code class="fe ni nj nk nl b">ios/Flutter/Release.xcconfig</code>中导入这个配置文件，方法是将这一行添加到它们的底部:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="0c41" class="mr kc it nl b gy nq nr l ns nt">#include "../Runner/Config.xcconfig"</span></pre><blockquote class="nu nv nw"><p id="a636" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it">将Config.xcconfig添加到。gitignore这样你就不会在git中有你的密钥了</em></p></blockquote><p id="21a2" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">最后一步是将配置键添加到<code class="fe ni nj nk nl b">ios/Runner/Info.plist</code>:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="cbaf" class="mr kc it nl b gy nq nr l ns nt">&lt;key&gt;PublitioAPIKey&lt;/key&gt;<br/>&lt;string&gt;$(PUBLITIO_KEY)&lt;/string&gt;<br/>&lt;key&gt;PublitioAPISecret&lt;/key&gt;<br/>&lt;string&gt;$(PUBLITIO_SECRET)&lt;/string&gt;</span></pre><h2 id="645a" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">Android配置</h2><p id="10b7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在Android中，我们所要做的就是在<code class="fe ni nj nk nl b">android/app/build.gradle</code>中将<code class="fe ni nj nk nl b">minSdkVersion</code>从16改为19。</p><blockquote class="nu nv nw"><p id="2c36" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated">是我的问题还是安卓系统总是让一切变得更简单？</p></blockquote><h2 id="a659" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">上传文件</h2><p id="7f8b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们已经添加了publitio，让我们上传从ImagePicker获得的文件。</p><p id="9a73" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">在<code class="fe ni nj nk nl b">main.dart</code>中，在<code class="fe ni nj nk nl b">_MyHomePageState</code>类中，我们将添加一个保存上传状态的字段:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="04f6" class="mr kc it nl b gy nq nr l ns nt">bool _uploading = false;</span></pre><p id="b8ab" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在我们将覆盖<code class="fe ni nj nk nl b">initState</code>并调用一个异步函数<code class="fe ni nj nk nl b">configurePublitio</code>来加载API键:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6f66" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">我们将添加一个函数<code class="fe ni nj nk nl b">_uploadVideo</code>来调用publitio API的<code class="fe ni nj nk nl b">uploadFile</code>:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="fe94" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">我们将调用代码添加到我们的<code class="fe ni nj nk nl b">_takeVideo</code>函数中:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="435d" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">请注意，来自publitio API的响应将以键值映射的形式出现，从中我们只保存了<code class="fe ni nj nk nl b">url_preview</code>，这是查看托管视频的url。我们将它保存到我们的<code class="fe ni nj nk nl b">_videos</code>集合中，并在上传完成后将<code class="fe ni nj nk nl b">_uploading</code>返回false。</p><p id="6f4c" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">最后，只要<code class="fe ni nj nk nl b">_uploading</code>为真，我们就将浮动动作按钮改为微调按钮:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="0079" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">添加缩略图</h2><p id="9d66" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Publitio使之变得容易的一件事是服务器端视频缩略图提取。您可以使用它的URL转换特性来获取任意大小的缩略图，但是为此我们将使用上传响应中接收到的默认缩略图。</p><p id="c385" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">既然我们希望每个列表项都有一个url和一个缩略图，那么为每个视频条目提取一个简单的POCO类是有意义的。创建一个新文件<code class="fe ni nj nk nl b">lib/video_info.dart</code>:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6027" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">我们将把<code class="fe ni nj nk nl b">_videos</code>系列从<code class="fe ni nj nk nl b">String</code>改为<code class="fe ni nj nk nl b">VideoInfo</code>:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="2515" class="mr kc it nl b gy nq nr l ns nt">List&lt;VideoInfo&gt; _videos = &lt;VideoInfo&gt;[];</span></pre><p id="f658" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">在获得上传响应后，我们将添加一个包含url和缩略图url的VideoInfo对象:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3564" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">最后，我们将缩略图显示添加到列表构建器项目:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e216" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">这里有几件事:</p><ul class=""><li id="16ea" class="mc md it lb b lc nd lg ne lk od lo oe ls of lw mh mi mj mk bi translated">我们使用<code class="fe ni nj nk nl b">ClipRRect</code>给缩略图一个漂亮的圆形边框</li><li id="0365" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">我们正在显示一个<code class="fe ni nj nk nl b">CircularProgressIndicator</code>，它在缩略图加载时显示(加载后它将被图像隐藏)</li><li id="658c" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">为了一个漂亮的淡入淡出效果，我们使用了包<code class="fe ni nj nk nl b">transparent_image</code>中的<code class="fe ni nj nk nl b">kTransparentImage</code>(需要添加到<code class="fe ni nj nk nl b">pubspec.yaml</code>)</li></ul><p id="eb31" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在列表中有了漂亮的缩略图:</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/50258f910c2e4d4f0cbc83f485fdc715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/0*PM2kgnm0NipAUSya.png"/></div></figure><h1 id="a123" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">播放视频</h1><p id="9331" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们有了视频列表，我们想在点击列表卡时播放每个视频。</p><p id="e29e" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">我们将使用<a class="ae ml" href="https://pub.dev/packages/chewie" rel="noopener ugc nofollow" target="_blank"> Chewie插件</a>作为我们的播放器。朱伊将<a class="ae ml" href="https://pub.dev/packages/video_player" rel="noopener ugc nofollow" target="_blank"> video_player插件</a>包装成具有本机外观的UI，用于播放、跳过和全屏。它还支持根据设备方向自动旋转视频。它不能做的(odly)，是自动计算出视频的长宽比。所以我们会从公开的结果中得到答案。</p><blockquote class="nu nv nw"><p id="aa88" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it">注意:Flutter的video_player包还不支持缓存，所以重播视频会导致重新下载。这个应该很快就能解决:</em><a class="ae ml" href="https://github.com/flutter/flutter/issues/28094" rel="noopener ugc nofollow" target="_blank"><em class="it">https://github.com/flutter/flutter/issues/28094</em></a></p></blockquote><p id="37fd" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">所以补充到<code class="fe ni nj nk nl b">pubspec.yaml</code>:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="4ab0" class="mr kc it nl b gy nq nr l ns nt">video_player: ^0.10.2+5<br/>chewie: ^0.9.8+1</span></pre><p id="16c2" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">对于iOS，我们还需要将以下内容添加到<code class="fe ni nj nk nl b">Info.plist</code>中，以允许加载远程视频:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="6261" class="mr kc it nl b gy nq nr l ns nt">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;<br/>&lt;dict&gt;<br/>  &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;<br/>  &lt;true/&gt;<br/>&lt;/dict&gt;</span></pre><p id="c49c" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在我们将添加一个新的小部件来容纳朱伊。创建新文件<code class="fe ni nj nk nl b">chewie_player.dart</code>:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="ccaf" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">需要注意一些事情:</p><ul class=""><li id="5e55" class="mc md it lb b lc nd lg ne lk od lo oe ls of lw mh mi mj mk bi translated"><code class="fe ni nj nk nl b">ChewiePlayer</code>期望得到<code class="fe ni nj nk nl b">VideoInfo</code>，即要播放的视频。</li><li id="4244" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">纵横比从输入<code class="fe ni nj nk nl b">VideoInfo</code>开始初始化。我们将很快添加该字段。</li><li id="0fe0" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">当视频加载时，我们显示一个占位符图像。我们将使用publitio API来生成封面图像。</li><li id="0694" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">我们有一个<code class="fe ni nj nk nl b">IconButton</code>将通过调用<code class="fe ni nj nk nl b">Navigator.pop(context)</code>来关闭这个小部件</li><li id="3ad9" class="mc md it lb b lc mm lg mn lk mo lo mp ls mq lw mh mi mj mk bi translated">我们必须通过重写<code class="fe ni nj nk nl b">dispose()</code>方法来处理<code class="fe ni nj nk nl b">VideoPlayerController</code>和<code class="fe ni nj nk nl b">ChewieController</code></li></ul><p id="633d" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">在<code class="fe ni nj nk nl b">video_info.dart</code>中，我们将添加<code class="fe ni nj nk nl b">aspectRatio</code>和<code class="fe ni nj nk nl b">coverUrl</code>字段:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="cab8" class="mr kc it nl b gy nq nr l ns nt">String coverUrl; <br/>double aspectRatio;</span></pre><p id="68fa" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在在<code class="fe ni nj nk nl b">main.dart</code>中，我们将首先导入新的<code class="fe ni nj nk nl b">chewie_player</code>:</p><pre class="ly lz ma mb gt nm nl nn no aw np bi"><span id="9208" class="mr kc it nl b gy nq nr l ns nt">import 'chewie_player.dart';</span></pre><p id="945e" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">添加一个<code class="fe ni nj nk nl b">aspectRatio</code>的计算:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8d9d" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">添加一个从publitio API获取封面图像的方法(这只是将视频的扩展替换为<code class="fe ni nj nk nl b">jpg</code>——publi TiO完成所有工作):</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9943" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">用一个<code class="fe ni nj nk nl b">GestureDetector</code>包装我们的列表项<code class="fe ni nj nk nl b">Card</code>来响应卡片上的点击，并调用<code class="fe ni nj nk nl b">Navigator.push</code>来路由到我们新的<code class="fe ni nj nk nl b">ChewiePlayer</code>小部件:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="2d91" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">添加Firebase</h1><p id="1166" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">既然我们可以上传和播放视频，我们希望应用程序的用户能够查看其他用户发布的视频。为了做到这一点(并保持应用程序无服务器)，我们将使用Firebase。</p><h2 id="365f" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">Firebase设置</h2><p id="6669" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">首先，按照此处所述<a class="ae ml" href="https://firebase.google.com/docs/flutter/setup" rel="noopener ugc nofollow" target="_blank">设置Firebase。这包括创建一个firebase项目，在项目中注册您的移动应用程序(Android和iOS ),并为Android和iOS项目配置凭据。然后我们将添加颤振包</a><a class="ae ml" href="https://pub.dev/packages/firebase_core" rel="noopener ugc nofollow" target="_blank"> firebase_core </a>和<a class="ae ml" href="https://pub.dev/packages/cloud_firestore" rel="noopener ugc nofollow" target="_blank"> cloud_firestore </a>。</p><blockquote class="nu nv nw"><p id="1f6e" class="kz la nx lb b lc nd le lf lg ne li lj ny nf lm ln nz ng lq lr oa nh lu lv lw im bi translated"><em class="it"> Cloud Firestore是Firebase实时数据库的新版本。你可能需要在你的</em> <code class="fe ni nj nk nl b"><em class="it">build.gradle</em></code> <em class="it">中设置</em> <code class="fe ni nj nk nl b"><em class="it">multiDexEnabled true</em></code> <em class="it">。</em></p></blockquote><h2 id="33f6" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">将视频信息保存到Firebase</h2><p id="a8a8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将把视频信息保存到<code class="fe ni nj nk nl b">videos</code>集合中的一个新的Firebase文档中，而不是保存到我们自己的州:</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="601c" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated"><code class="fe ni nj nk nl b">document()</code>方法将在<code class="fe ni nj nk nl b">videos</code>集合中创建一个新的随机命名的文档。</p><p id="485e" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">这是文档在Firebase控制台中的外观:</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/05a7988e64745359a23acb1a685e2bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hNRvJDlGmfBdAlUj.png"/></div></div></figure><h2 id="94fe" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">显示Firebase中的视频列表</h2><p id="ad7c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在，在我们的<code class="fe ni nj nk nl b">initState</code>方法中，我们想要启动一个Firebase查询来监听<code class="fe ni nj nk nl b">videos</code>集合。每当Firebase SDK触发数据变化时，它将调用<code class="fe ni nj nk nl b">updateVideos</code>方法，这将更新我们的<code class="fe ni nj nk nl b">_videos</code>状态(并且Flutter将重建UI):</p><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="57fb" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">现在所有的视频都分享了！</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/8174960787cf594da3b60c979cce66b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*nCo5fM0kwLaUxzzf.gif"/></div></figure><h1 id="4b16" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">重构</h1><p id="6c61" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在一切都正常了，是时候进行一些重构了。这是一个非常小的应用程序，但仍然有一些明显的东西脱颖而出。我们将数据访问和业务逻辑都放在同一个地方，这绝不是一个好主意。最好将我们的API/数据访问放在单独的模块中，为业务逻辑层提供所需的服务，同时它可以保持对实现细节的不可知性(以及与实现细节的松散耦合<a class="ae ml" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">】。</a></p><p id="6beb" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">为了保持这篇文章的简短，我不会在这里包括这些变化，但是你可以在GitHub的最终代码中看到它们</p><h1 id="dc7e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">未来的改进:客户端编码</h1><p id="556b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在上传之前，我们可以在客户端使用FFMpeg对视频进行编码。这将节省存储空间并加快传送速度，但需要患者上传用户。如果你想知道如何做到这一点，请在下面写下评论。</p><p id="9d27" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated">感谢阅读！完整代码可以在<a class="ae ml" href="https://github.com/syonip/flutter_video_sharing" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。如有疑问，欢迎留言评论！</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="82b1" class="pw-post-body-paragraph kz la it lb b lc nd le lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw im bi translated"><em class="nx">最初发表于</em><a class="ae ml" href="https://www.learningsomethingnew.com/how-to-make-a-cross-platform-video-sharing-app-with-flutter-and-firebase" rel="noopener ugc nofollow" target="_blank">T5【https://www.learningsomethingnew.com】</a><em class="nx">。</em></p></div></div>    
</body>
</html>