<html>
<head>
<title>Why React’s new Hooks API is a game changer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么React的新Hooks API是一个游戏改变者</h1>
<blockquote>原文：<a href="https://itnext.io/why-reacts-hooks-api-is-a-game-changer-8731c2b0a8c?source=collection_archive---------0-----------------------#2018-10-28">https://itnext.io/why-reacts-hooks-api-is-a-game-changer-8731c2b0a8c?source=collection_archive---------0-----------------------#2018-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="904c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最后，我们在React中去掉了第二速率编码模式</h2></div><blockquote class="kf kg kh"><p id="4f5a" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">React的新<a class="ae lf" href="https://reactjs.org/hooks" rel="noopener ugc nofollow" target="_blank"> Hooks API </a>允许我们最终分享行为，而没有任何之前困扰社区的内在问题</p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/4782a60a69ecafdddb4cd96cc4296b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdxGK0au6i57vgCU6-t8xw.jpeg"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">https://www.flickr.com/photos/elevationmann/<a class="ae lf" href="https://www.flickr.com/photos/elevationmann/" rel="noopener ugc nofollow" target="_blank">摄影</a></figcaption></figure><h1 id="6334" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">组件间共享行为</h1><p id="4d8d" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">从早期开始，我就一直使用React进行开发，在此期间，影响者和核心团队都曾多次尝试改进开发人员用来创建软件的API和模式。我们面临的最大挑战之一是如何在组件之间整齐地共享行为，以实现重用，甚至只是关注点的分离。到目前为止提出的每一个解决方案都有一些相关的问题。</p><p id="74d8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">幸运的是，React刚刚发布了一个<a class="ae lf" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">他们的新API </a>，用于在React组件中共享行为，解决了我们过去遇到的许多问题。</p><p id="2503" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">看起来是这样的:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">https://reactjs.org提供的新钩子API的例子<a class="ae lf" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="c720" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">首先让我们来看看我们是如何走到这一步的…</p><h2 id="aabd" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">混合和魔术方法</h2><p id="8715" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">React第一次发布时，ES5中没有类，所以React附带了自己的类创建方法，包括将一个对象中的一堆方法合并到您创建的组件中的能力。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">旧mixin API的一个例子</figcaption></figure><p id="653e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">不幸的是，这导致了你在经典继承中发现的类似问题；主要是间接从神奇的未记录的方法中出现，并在组件上使用。开发人员不知道什么功能对他们可用，更重要的是什么不可用。</p><p id="ccac" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">这种<a class="ae lf" href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" rel="noopener ugc nofollow" target="_blank">味道是如此糟糕</a>React团队决定<a class="ae lf" href="https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750" rel="noopener">完全移除mixin</a>当他们引入一个新的基于ES6类的API时。</p><h2 id="04fb" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">情况有所好转，但仍有问题</h2><p id="8ffc" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">最近在组件之间共享功能的尝试，即<a class="ae lf" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>和<a class="ae lf" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>，也因为几个原因在API级别上有所欠缺。</p><h2 id="8e80" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">高阶分量仍然会导致间接性</h2><p id="6ecd" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">高阶组件(或hoc)试图将<a class="ae lf" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">高阶函数</a>的函数编程概念应用于反应组件。其思想是，通过将组件包装在提供行为的外部组件中，组成原始组件，并将行为的结果作为新的道具传递给原始组件，来改变组件。这与高阶函数通过闭包传递数据的方式类似。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">高阶元件示例由https://reactjs.org<a class="ae lf" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">提供</a></figcaption></figure><p id="9cd2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">高阶组件的伟大之处在于，您可以看到数据作为道具进入组件。它不再像混血儿一样神奇。</p><p id="6294" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">然而，还有一些问题。高阶元件的主要问题包括:</p><ul class=""><li id="8956" class="nk nl iq kl b km kn kp kq mq nm ms nn mu no le np nq nr ns bi translated">它们设置起来很复杂。</li><li id="73c0" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">您无法区分来自特设的数据和传递给组件的数据。</li><li id="07d8" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">特设是组件的外部，但组件仍然依赖于特设。拆除悬挂夹具，如果该部件依赖于HOCs数据，它将不会总是工作。</li><li id="44f8" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">当行为组件包含渲染组件时，你最终会得到巨大的渲染树。</li></ul><h2 id="2838" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">渲染道具和末日金字塔</h2><p id="d763" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">渲染道具是一个相对较新的趋势，它为hoc可能导致的一些依赖性和间接性问题提供了答案。它们是通过使一个组件接受一个它将用来呈现其子组件的函数属性来创建的。这允许组件为其子组件提供闭包以及一些行为和新数据。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4c80" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">然而，它们可能被滥用。请看这个(事件虽然做作，不幸却相当典型)阿波罗反应的例子:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">一个渲染道具末日金字塔的例子！</figcaption></figure><p id="9860" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">如果你曾经和我一起工作过，你可能知道我对使用渲染道具的犹豫。我认为它在某些情况下可能是一种有用的模式，但是它有几个主要问题:</p><ul class=""><li id="8187" class="nk nl iq kl b km kn kp kq mq nm ms nn mu no le np nq nr ns bi translated">它声明了错误的层次结构。末日金字塔。</li><li id="a2f4" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">鼓励将内联函数传递给子组件，如果不检查，可能会导致性能问题。</li><li id="e156" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">创建混乱的闭包结构，它实际上应该是内联的。</li><li id="60c5" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">导致非常冗长的组件JSX</li></ul><h2 id="0cbf" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">事实上，类生命周期方法也很糟糕</h2><p id="ada9" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">自诞生以来，React就包含了各种生命周期方法，供开发人员根据React中呈现的组件生命周期内的特定执行时间来挂起代码。能够支持这种异步行为是React组件一开始就被建模为类的原因。这个模型很简单，它提供了一种直观的方式将行为代码附加到组件上。</p><p id="f27a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">然而，这种方法存在一些问题。实际上，与特定功能相关的代码最终会分散在类的各种生命周期方法中，并且通常紧挨着不相关行为的代码。无论您是否使用hoc或渲染道具组件，这通常都会发生。此外，通过使用类，您不可避免地需要使用JavaScript <code class="fe ny nz oa ob b">this</code>对象，这意味着您需要理解并注意在将处理程序传递给子组件时绑定它们。</p><p id="4b40" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">React 14引入了无状态的功能组件来解决这个问题，但是它们没有提供访问生命周期方法的途径，这使得它们只能用在不会发展成需要复杂行为的组件上</p><h1 id="4a32" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">进入React“钩子”API</h1><p id="2614" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">在<a class="ae lf" href="https://conf.reactjs.org/" rel="noopener ugc nofollow" target="_blank"> ReactConf 2018 </a>上，React团队公布了他们新的<a class="ae lf" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> hooks API </a>。React的新API试图通过淘汰hoc和渲染道具来解决这些问题。新的API允许真正的状态驱动行为共享，同时还:</p><ul class=""><li id="3c2a" class="nk nl iq kl b km kn kp kq mq nm ms nn mu no le np nq nr ns bi translated">提供了一种访问状态托管道具的方法，并能够轻松地准确跟踪该状态的来源。</li><li id="920f" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">返回内存化函数，避免下游纯组件的性能损失</li><li id="e902" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">不是创造一个死亡金字塔</li><li id="f8dd" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">不碰道具。你在JSX传递给组件的就是你在道具中得到的。</li><li id="8081" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">没有创造任何神奇的行为方法。</li><li id="e42f" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">这导致了更简单的JSX，它更关心组件的呈现，而不太关心行为。</li><li id="5c8e" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">消除分层包装组件的性能开销。</li><li id="4f15" class="nk nl iq kl b km nt kp nu mq nv ms nw mu nx le np nq nr ns bi translated">允许将自定义行为捆绑到它们自己的函数中，这些函数可以由库导出。</li></ul><h2 id="8460" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">钩子API的例子</h2><p id="4158" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">以下是如何创建自定义挂钩的示例:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">示例礼貌<a class="ae lf" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">https://reactjs.org</a></figcaption></figure><h2 id="df6e" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">新的API有几个小缺点</h2><p id="38ce" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">使用hooks API的主要缺点是所有的“hooks”方法<strong class="kl ir">必须在每次组件渲染</strong>时以相同的顺序运行。</p><p id="158d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">这意味着<a class="ae lf" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">你不能在if块中调用钩子函数，或者在你的功能组件中调用循环。</a></p><p id="b9f7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">事实上，当我第一次听到这个消息时，我有点担心。我不喜欢我必须遵守的潜规则。我认为这意味着刚接触API的人会很难理解为什么他们的代码不能工作。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oc"><img src="../Images/6bb8fd23a758f714fa48e7c327bcc37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBItSFo-AWia0SJHchmVMg.png"/></div></div></figure></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><blockquote class="ok"><p id="b420" class="ol om iq bd on oo op oq or os ot le dk translated">在思考了这个问题并通读了一些文档后，我想我开始理解为什么React团队走上了这条路。</p></blockquote><p id="4269" class="pw-post-body-paragraph ki kj iq kl b km ou jr ko kp ov ju kr mq ow ku kv ms ox ky kz mu oy lc ld le ij bi translated">React团队表示，他们将提供一套林挺插件来支持我们。然而，并不是每个人都使用linters，尽管在运行时检测一点代码是否在条件中是不可能的，但我认为他们最终至少会尝试包含一些友好的运行时错误。所以这是一种耻辱。也许随着时间的推移，React团队会想出聪明的方法来防止代码库出错，以及防止新开发人员加入API。在思考了这个问题并通读了一些文档后，我想我开始理解为什么React团队走上了这条路。可选的语法实现将涉及更多的样板文件，公平地说，这个解决方案实际上相当巧妙。</p><h2 id="333b" class="my lx iq bd ly mz na dn mc nb nc dp mg mq nd ne mi ms nf ng mk mu nh ni mm nj bi translated">结论</h2><p id="b1ee" class="pw-post-body-paragraph ki kj iq kl b km mo jr ko kp mp ju kr mq mr ku kv ms mt ky kz mu mv lc ld le ij bi translated">hooks API中提出的思想对React开发人员来说是一个福音。最后，我们有一个相对自由的API来开发React组件。我们不再需要担心从功能组件到类的重构，并且可以共享行为而不会混淆间接性。</p><p id="78c5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">我期待看到像ApolloClient和Redux这样的库开发自己的hooks API组件来实现行为。</p><p id="bc24" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated">有关更多信息，您可以查看他们在<a class="ae lf" href="https://reactjs.org/hooks" rel="noopener ugc nofollow" target="_blank"> React网站</a>上的文章，并观看下面的发布演示:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="oz mx l"/></div></figure></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="97ea" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated"><em class="kk">这篇文章是一篇活的文档，如果你想投稿或者在这里看到任何不准确的地方，请联系我。</em></p><p id="1374" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr mq kt ku kv ms kx ky kz mu lb lc ld le ij bi translated"><em class="kk">你可以在Twitter上以</em><a class="ae lf" href="https://twitter.com/rudiyardley" rel="noopener ugc nofollow" target="_blank"><em class="kk">@ Rudi Yardley</em></a><em class="kk">关注rudiyardley或者在Github上以</em><a class="ae lf" href="https://github.com/ryardley" rel="noopener ugc nofollow" target="_blank"><em class="kk">@</em>ryardley</a></p></div></div>    
</body>
</html>