<html>
<head>
<title>Log Requests and Responses in ASP.NET Core 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心3中的日志请求和响应</h1>
<blockquote>原文：<a href="https://itnext.io/log-requests-and-responses-in-asp-net-core-3-a1bebd49c996?source=collection_archive---------0-----------------------#2019-12-30">https://itnext.io/log-requests-and-responses-in-asp-net-core-3-a1bebd49c996?source=collection_archive---------0-----------------------#2019-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="30d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将是ASP.NET核心文章中<a class="ae kl" href="https://elanderson.net/2017/02/log-requests-and-responses-in-asp-net-core/" rel="noopener ugc nofollow" target="_blank">日志请求和响应的更新，后者不再适用于更现代版本的ASP.NET核心。在很大程度上，这篇文章将完全符合原来的，但代码位更新。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ab72ccf3c26a336eefbf6954c4614ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoup2JaQarWY4z7F2zd-bA.png"/></div></div></figure><p id="e496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为调试工作的一部分，我需要一种方法来记录请求和响应。编写一个中间件似乎是解决这个问题的好方法。处理请求和响应机构也比我预期的要复杂。</p><h2 id="8e8b" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">中间件</h2><p id="bca0" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在ASP.NET核心<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware" rel="noopener ugc nofollow" target="_blank">中间件</a>是组成HTTP管道的组件，处理应用程序的请求和响应。每个被调用的中间件都可以选择在调用下一个中间件之前对请求进行一些处理。在执行从对下一个中间件的调用返回之后，有机会对响应进行处理。</p><p id="6cef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序的HTTP管道在Startup类的Configure函数中设置。运行、映射和使用是三种可用的中间件类型。Run应仅用于终止管道。Map用于管道分支。Use似乎是最常见的中间件类型，它执行一些处理并调用队列中的下一个中间件。更多细节见官方<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware" rel="noopener ugc nofollow" target="_blank">文件</a>。</p><h2 id="2368" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">创建中间件</h2><p id="61ab" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">中间件可以作为lambda直接在Configure函数中实现，但更常见的是，它是作为一个类实现的，该类使用IApplicationBuilder上的扩展方法添加到管道中。这个例子将使用类路由。</p><p id="41bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子是一个中间件，它使用ASP.NET核心的内置日志记录来记录请求和响应。创建一个名为<strong class="jp ir">requestresponselogginmiddleware</strong>的类。</p><p id="3700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该类需要一个带两个参数的构造函数，这两个参数都将由ASP.NET核心的依赖注入系统提供。第一个是RequestDelegate，它将是管道中的下一个中间件。第二个是ILoggerFactory的实例，它将用于创建记录器。RequestDelegate存储在类level _next变量中，loggerFactory用于创建存储在类level _logger变量中的记录器。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="3418" class="ky kz iq lx b gy mb mc l md me">public class RequestResponseLoggingMiddleware<br/>{<br/>    private readonly RequestDelegate _next;<br/>    private readonly ILogger _logger;<br/><br/>    public RequestResponseLoggingMiddleware(RequestDelegate next,<br/>                                            ILoggerFactory loggerFactory)<br/>    {<br/>        _next = next;<br/>        _logger = loggerFactory<br/>                  .CreateLogger&lt;RequestResponseLoggingMiddleware&gt;();<br/>    }<br/>}</span></pre><p id="3e72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加一个Invoke函数，当您的中间件由管道运行时，这个函数将被调用。下面的函数除了调用管道中的下一个中间件之外什么也不做。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="aed8" class="ky kz iq lx b gy mb mc l md me">public async Task Invoke(HttpContext context)<br/>{<br/>     //code dealing with the request<br/><br/>     await _next(context);<br/><br/>     //code dealing with the response<br/>}</span></pre><p id="5339" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，添加一个静态类来简化将中间件添加到应用程序管道的过程。这与内置中间件使用的模式相同。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="3c1d" class="ky kz iq lx b gy mb mc l md me">public static class RequestResponseLoggingMiddlewareExtensions<br/>{<br/>    public static IApplicationBuilder UseRequestResponseLogging(this IApplicationBuilder builder)<br/>    {<br/>        return builder.UseMiddleware&lt;RequestResponseLoggingMiddleware&gt;();<br/>    }<br/>}</span></pre><h2 id="3146" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">添加到管道中</h2><p id="791d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">要将新的中间件添加到管道中，打开<strong class="jp ir"> Startup.cs </strong>文件，并将下面一行添加到<strong class="jp ir">配置</strong>函数中。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="fc72" class="ky kz iq lx b gy mb mc l md me">app.UseRequestResponseLogging();</span></pre><p id="41b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，中间件的添加顺序会影响应用程序的行为。因为这篇文章讨论的中间件是日志，所以我把它放在管道的开始处。</p><h2 id="bbc3" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">记录请求和响应</h2><p id="cef5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在，我们的新中间件的设置工作已经完成，我们将回到它的调用函数。正如我上面所说的，这比我想象的要复杂得多，但是谢天谢地我找到了<a class="ae kl" href="http://www.sulhome.com/blog/10/log-asp-net-core-request-and-response-using-middleware" rel="noopener ugc nofollow" target="_blank">这个</a>作者<a class="ae kl" href="https://twitter.com/sulhome" rel="noopener ugc nofollow" target="_blank"> Sul Aga </a>的文章，它真的帮助我解决了我遇到的问题，还有很多关于这篇文章最初版本的反馈。</p><p id="bfdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章最初版本的反馈之一是关于<a class="ae kl" href="https://stackoverflow.com/a/52328142/1291838" rel="noopener ugc nofollow" target="_blank">潜在的内存泄漏和使用可回收内存流</a>。首先，添加一个对微软的NuGet引用。IO .可回收内存流包。接下来，我们将添加一个类级变量来保存我们将在构造函数中创建的一个<strong class="jp ir">recycllablememorystreammanager</strong>的实例。以下是更新后的类视图，其中包含这些更改以及对日志记录方法的<strong class="jp ir"> Invoke </strong>函数和存根的更改。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="cc24" class="ky kz iq lx b gy mb mc l md me">public class RequestResponseLoggingMiddleware<br/>{<br/>    private readonly RequestDelegate _next;<br/>    private readonly ILogger _logger;<br/>    private readonly RecyclableMemoryStreamManager _recyclableMemoryStreamManager;<br/><br/>    public RequestResponseLoggingMiddleware(RequestDelegate next,<br/>                                            ILoggerFactory loggerFactory)<br/>    {<br/>        _next = next;<br/>        _logger = loggerFactory<br/>                  .CreateLogger&lt;RequestResponseLoggingMiddleware&gt;();<br/>        _recyclableMemoryStreamManager = new RecyclableMemoryStreamManager();<br/>    }<br/><br/>    public async Task Invoke(HttpContext context)<br/>    {<br/>        await LogRequest(context);<br/>        await LogResponse(context);<br/>    }<br/>  <br/>    private async Task LogRequest(HttpContext context) {}<br/>    private async Task LogResponse(HttpContext context) {}<br/>}</span></pre><p id="c934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们要看一下<strong class="jp ir"> LogRequest </strong>函数，以及它使用的一个助手函数。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="4901" class="ky kz iq lx b gy mb mc l md me">private async Task LogRequest(HttpContext context)<br/>{<br/>    context.Request.EnableBuffering();<br/><br/>    await using var requestStream = _recyclableMemoryStreamManager.GetStream();<br/>    await context.Request.Body.CopyToAsync(requestStream);<br/>    _logger.LogInformation($"Http Request Information:{Environment.NewLine}" +<br/>                           $"Schema:{context.Request.Scheme} " +<br/>                           $"Host: {context.Request.Host} " +<br/>                           $"Path: {context.Request.Path} " +<br/>                           $"QueryString: {context.Request.QueryString} " +<br/>                           $"Request Body: {ReadStreamInChunks(requestStream)}");<br/>    context.Request.Body.Position = 0;<br/>}<br/><br/>private static string ReadStreamInChunks(Stream stream)<br/>{<br/>    const int readChunkBufferLength = 4096;<br/><br/>    stream.Seek(0, SeekOrigin.Begin);<br/><br/>    using var textWriter = new StringWriter();<br/>    using var reader = new StreamReader(stream);<br/><br/>    var readChunk = new char[readChunkBufferLength];<br/>    int readChunkLength;<br/><br/>    do<br/>    {<br/>        readChunkLength = reader.ReadBlock(readChunk, <br/>                                           0, <br/>                                           readChunkBufferLength);<br/>        textWriter.Write(readChunk, 0, readChunkLength);<br/>    } while (readChunkLength &gt; 0);<br/><br/>    return textWriter.ToString();<br/>}</span></pre><p id="57fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让这个函数工作并允许读取请求体的关键是<strong class="jp ir">上下文。Request.EnableBuffering() </strong>允许我们从流的开头开始读取。函数的其余部分非常简单。</p><p id="7ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个函数是<strong class="jp ir"> LogResponse </strong>，它用于执行管道中中间件的下一位，使用<strong class="jp ir"> await _next(context) </strong>，然后在管道的其余部分运行后记录响应体。</p><pre class="kn ko kp kq gt lw lx ly lz aw ma bi"><span id="55dd" class="ky kz iq lx b gy mb mc l md me">private async Task LogResponse(HttpContext context)<br/>{<br/>    var originalBodyStream = context.Response.Body;<br/><br/>    await using var responseBody = _recyclableMemoryStreamManager.GetStream();<br/>    context.Response.Body = responseBody;<br/><br/>    await _next(context);<br/><br/>    context.Response.Body.Seek(0, SeekOrigin.Begin);<br/>    var text = await new StreamReader(context.Response.Body).ReadToEndAsync();<br/>    context.Response.Body.Seek(0, SeekOrigin.Begin);<br/><br/>    _logger.LogInformation($"Http Response Information:{Environment.NewLine}" +<br/>                           $"Schema:{context.Request.Scheme} " +<br/>                           $"Host: {context.Request.Host} " +<br/>                           $"Path: {context.Request.Path} " +<br/>                           $"QueryString: {context.Request.QueryString} " +<br/>                           $"Response Body: {text}");<br/><br/>    await responseBody.CopyToAsync(originalBodyStream);<br/>}</span></pre><p id="c7db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，读取响应正文的技巧是用新的内存流替换正在使用的流，然后将数据复制回原始正文流。我不知道这会对性能产生多大影响，在生产环境中使用它之前，我会确保研究它是如何扩展的。</p><h2 id="e70e" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">包扎</h2><p id="0346" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我希望这篇更新的文章能像原来的一样有用。这一轮我在GitHub repo中有代码，可以在<a class="ae kl" href="https://github.com/elanderson/ASP.NET-Core-Basics-Refresh/commit/c1b24de0d44dfc45d379b91d721842656c4ba3d8" rel="noopener ugc nofollow" target="_blank">这里</a>找到相关变更的提交。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="2a78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mm">原载于</em> <a class="ae kl" href="https://elanderson.net/2019/12/log-requests-and-responses-in-asp-net-core-3/" rel="noopener ugc nofollow" target="_blank"> <em class="mm">安德森</em> </a> <em class="mm">。</em></p></div></div>    
</body>
</html>