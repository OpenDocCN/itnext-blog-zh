<html>
<head>
<title>Vue Route Component Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue路由组件挂钩</h1>
<blockquote>原文：<a href="https://itnext.io/vue-custom-route-hooks-3f50cc30bb87?source=collection_archive---------1-----------------------#2018-12-18">https://itnext.io/vue-custom-route-hooks-3f50cc30bb87?source=collection_archive---------1-----------------------#2018-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f9e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在通用web应用程序中请求数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/165c3d511b7a861c4f71dd701adb8708.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*K0h5Fu4PlC34qyI1Ijli-w.png"/></div></figure><p id="8903" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用Vue构建通用web应用程序的最具挑战性的部分之一是确定在路由的生命周期中使用哪个Vue和Vue路由器生命周期挂钩来请求数据。</p><p id="1c77" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要解决这个问题，您应该很好地理解路由生命周期，以及何时调用所有Vue和Vue路由器生命周期挂钩。</p><p id="338e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们将讨论这些主题，以及如何创建定制的<strong class="kp ir">路由组件挂钩</strong>到<strong class="kp ir"> </strong>，以一种对您的应用程序有意义的方式请求数据。</p><h2 id="d66c" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">阅读前要知道的事情:</strong></h2><ul class=""><li id="1e7f" class="md me iq kp b kq mf kt mg kw mh la mi le mj li mk ml mm mn bi translated">本文涵盖高级主题，要求熟悉<a class="ae lj" href="https://vuejs.org/v2/guide/" rel="noopener ugc nofollow" target="_blank"> Vue </a>、<a class="ae lj" href="https://router.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue路由器</a>、<a class="ae lj" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>、<a class="ae lj" href="https://ssr.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue服务器端渲染</a>和<a class="ae lj" href="https://ssr.vuejs.org/guide/routing.html#routing-with-vue-router" rel="noopener ugc nofollow" target="_blank">代码分割</a>。</li><li id="738d" class="md me iq kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated">为了简单起见，我将把<a class="ae lj" href="https://vuejs.org/v2/api/#Options-Lifecycle-Hooks" rel="noopener ugc nofollow" target="_blank"> Vue生命周期挂钩</a>和<a class="ae lj" href="https://router.vuejs.org/guide/advanced/navigation-guards.html" rel="noopener ugc nofollow" target="_blank"> Vue路由器导航护板/挂钩</a>都称为生命周期挂钩。</li></ul><h1 id="389c" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated">路线生命周期</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0d9bf990bc55d71bde104e3aeaea2bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*DuhhVkPtaSVYoBCBam1rRw.png"/></div></figure><p id="0e79" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">路由生命周期始于对路由器的导航请求。路由器会找到匹配的路由，并解析异步路由成分。如果导航未被拒绝，则确认到匹配路线的导航，并呈现路线组件。酷毙了。那么，我们应该在路由生命周期的哪个阶段请求数据呢？</p><h1 id="a4a3" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated">将您的数据分类</h1><p id="9dba" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">根据我的经验，任何给定路由的数据都可以分为三类:许可、关键和懒惰。</p><p id="e09f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">权限</strong> —确定用户是否有权访问路线所需的数据。这些数据应该在导航被确认之前被请求并可用，以便确定他们是否可以进入该航线。</p><p id="d478" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">关键</strong> —一条路线的用户体验最重要的数据。一旦确认了航行，就应该请求这些数据。这些数据是否需要在渲染前可用取决于您和您希望您的用户拥有的体验。</p><p id="da68" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">懒</strong> —对用户体验不关键的补充数据。该数据应该在关键数据之后被请求，并且不应该阻塞呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f261c32963821e9c8559be2efaa2b381.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*HGqLujaqlgu33FcnvcUT5g.png"/></div></figure><p id="23bb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一个基本模型，用于确定在路径的生命周期中何时应该请求数据。</p><h1 id="d2b7" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated"><strong class="ak">实际上……四条路线的生命周期</strong></h1><p id="b3a1" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">事实证明，在Vue通用web应用程序中，任何给定的路由都可以有四个不同的路由生命周期。以下是生命周期及其主要差异的简要总结:</p><h2 id="5ef3" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">服务器请求</strong></h2><p id="9d61" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">在应用程序的服务器入口点，处理一个请求，并通过路由生命周期返回初始路由数据和html。在这个生命周期中，关键数据<em class="nj">必须在渲染之前</em>可用，并且不应该请求惰性数据，因为我们不希望它阻碍渲染。</p><h2 id="0c72" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">客户端初始化</strong></h2><p id="055c" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">在应用程序的客户端入口点，会发生另一个路由生命周期来初始化应用程序。权限和关键数据不必被请求，因为它们已经被服务器请求了。当应用程序初始化时，可以为初始路由请求惰性数据。</p><h2 id="18b1" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">客户端导航</strong></h2><p id="4d55" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">客户端初始化后，用户导航到一个新的路由，该路由使用与当前路由不同的<em class="nj">组件。在这种情况下，我们在请求许可、关键数据和惰性数据的客户机上经历一个完整的路由生命周期。与服务器请求生命周期不同，在呈现路径组件之前，关键数据是否必须可用取决于您。</em></p><h2 id="45cf" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">客户端更新导航</strong></h2><p id="f108" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">与客户端导航生命周期相同，除了用户导航到使用与当前路线相同的组件的<em class="nj">路线(例如/profile/123/-&gt;/profile/456/)。在这种情况下，调用一组不同的更新挂钩，因为已经输入了路由，并且已经创建了组件。</em></p><p id="6e01" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们更新我们的模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/f97c452607969df1d8966f764bca9b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nG9EmN_iTflJsJH6FBw_aA.png"/></div></div></figure><h1 id="c8a2" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated"><strong class="ak">生命周期挂钩</strong></h1><p id="54d4" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">现在我们已经有了一个何时应该请求数据的模型，让我们看看在这些点上哪个生命周期钩子最适合请求数据。下图显示了每个路由生命周期调用的Vue和Vue路由器生命周期挂钩。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi np"><img src="../Images/9474ddf5088e83a610f01e2a49efbc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X08cLwuYvIhL5MsT9mmQqw.png"/></div></div></figure><p id="a132" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">关于此图的几点注意事项:</p><ul class=""><li id="f93b" class="md me iq kp b kq kr kt ku kw nq la nr le ns li mk ml mm mn bi translated">如果匹配的路线没有被拒绝，则导航确认隐含在<strong class="kp ir"> onReady </strong>钩内。</li><li id="a594" class="md me iq kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated"><strong class="kp ir"> beforeEach </strong>、<strong class="kp ir"> beforeResolve </strong>和<strong class="kp ir"> afterEach </strong>通常用于在客户端导航。</li><li id="3041" class="md me iq kp b kq mo kt mp kw mq la mr le ms li mk ml mm mn bi translated">在客户端导航生命周期中被调用的<strong class="kp ir"> beforeRouteLeave </strong>、<strong class="kp ir"> beforeDestroy </strong>和<strong class="kp ir">destroy</strong>生命周期挂钩被有意省略。这些钩子在路由的生命周期结束时被调用，这使得它们不是请求数据的最佳选择。</li></ul><h1 id="99a8" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated">我应该使用哪些挂钩？</h1><p id="f2d6" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">有了生命周期钩子何时被调用的完整描述，我们可以开始明白为什么有些生命周期钩子比其他的更适合请求数据。</p><h2 id="87de" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">组件解析后发生的挂钩</strong></h2><p id="ed26" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">路由的请求逻辑应该存在于路由组件中，以便可以对其进行代码拆分。在路由组件被解析之前发生的任何生命周期挂钩都不是一个好的选择，因为您最终会用路由特定的代码来膨胀您的初始脚本。</p><p id="8b94" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">取消资格:在每个之前，在进入之前</p><h2 id="e71d" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">在服务器请求和客户端初始化之间没有冗余的挂钩</strong></h2><p id="32b7" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">任何在服务器请求生命周期和客户机初始化生命周期中被调用的生命周期挂钩都可能被取消资格。每当我们在这些钩子中请求数据时，我们要么再次请求它，要么必须添加一个条件来检查代码是运行在服务器端还是客户端，以避免重复请求。</p><p id="a056" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">取消资格:beforeEnter，beforeRouteEnter，beforeCreate，已创建</strong></p><h2 id="6740" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated"><strong class="ak">客户端导航和客户端更新导航一致的挂钩</strong></h2><p id="f7bc" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">接下来，我们可以取消任何在客户端导航和客户端更新导航生命周期之间不一致的生命周期挂钩。如果您将请求逻辑放在这些钩子中，您的数据要么不会在一个生命周期中被请求，要么您将不得不在多个生命周期钩子中重复您的请求逻辑。</p><p id="b47d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">取消资格:beforeEnter，beforeRouteEnter，beforeRouteUpdate，beforeCreate，created，watch $route，beforeMount，mounted，beforeUpdate，updated </strong></p><p id="6831" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们还剩下什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nt"><img src="../Images/4178d42b610b4653b5334bef62a55081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T22VoDZyz2grG2_yoLQ0BA.png"/></div></div></figure><p id="2c55" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">onReady、beforeResolve和afterEach钩子能让我们像模型中描述的那样请求数据吗？借助一些自定义的<strong class="kp ir">路由组件钩子</strong>，绝对可以。</p><h1 id="63cd" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated">路由组件挂钩</h1><p id="308f" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">路线组件挂钩是自定义功能，可以选择在路线组件中定义，以便在路线生命周期中使用。</p><h1 id="dda8" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated">把这一切联系在一起</h1><p id="90a5" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">我们已经定义了在路线生命周期中我们想要获取数据的位置，并且我们知道使用什么生命周期挂钩。然而，我们不能在全局生命周期钩子中定义每一个路由的请求逻辑。相反，我们应该在它自己的定制路由组件钩子中定义每个路由的逻辑，并让生命周期钩子调用它们。</p><p id="5ce3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的服务器请求生命周期中，我们可以使用onReady生命周期挂钩来调用权限和关键数据路由组件挂钩。</p><p id="2706" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的客户机初始化生命周期中，我们可以使用onReady生命周期钩子来调用lazyData路由组件钩子。我们还可以订阅beforeResolve和afterEach生命周期挂钩，它们将在后续导航期间调用permissions、criticalData和lazyData路由组件挂钩。</p><p id="b81a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看代码示例中的所有内容。</p><h1 id="d6b8" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated">代码</h1><p id="ec2d" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">下面的代码示例显示了通过通用web应用程序的服务器和客户端入口点设置自定义路由组件挂钩是多么简单。</p><h2 id="9c01" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">服务器入口点</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="ddac" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">客户端入口点</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="fa09" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">示例路由组件</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="5eb0" class="lk ll iq bd lm ln lo dn lp lq lr dp ls kw lt lu lv la lw lx ly le lz ma mb mc bi translated">路线组件挂钩的好处</h2><p id="bfe2" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated"><strong class="kp ir">代码分割</strong> —所有用于请求数据的路由特定代码都可以存在于路由组件中，因此很容易进行代码分割。</p><p id="03ee" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">可读性</strong>——通过查看路由组件，用户可以轻松识别路由数据请求的位置。</p><p id="52f5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">可维护</strong> —在设计路线组件时，请求数据的代码被添加到一组可预测的函数中，并将在所有路线生命周期中工作。</p><p id="b90d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">性能</strong> —导航仅在需要时被阻止，并且请求尽可能在路线的匹配组件之间并行发出。</p><h1 id="8791" class="mt ll iq bd lm mu mv mw lp mx my mz ls jw na jx lv jz nb ka ly kc nc kd mb nd bi translated"><strong class="ak">收尾思路</strong></h1><p id="a02b" class="pw-post-body-paragraph kn ko iq kp b kq mf jr ks kt mg ju kv kw nf ky kz la ng lc ld le nh lg lh li ij bi translated">虽然本文包含了固执己见的模型和代码示例，但总体思路是灵活的，我鼓励您根据自己的目的对它们进行调整。</p><p id="35c4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望这篇文章对你有所帮助，我渴望听到Vue社区的想法。</p></div></div>    
</body>
</html>