<html>
<head>
<title>Choosing a cache — capabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">选择缓存—功能</h1>
<blockquote>原文：<a href="https://itnext.io/choosing-a-cache-capabilities-1-547f741ac862?source=collection_archive---------2-----------------------#2021-10-24">https://itnext.io/choosing-a-cache-capabilities-1-547f741ac862?source=collection_archive---------2-----------------------#2021-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/56354b7d8d6f8e52441ca97db13940df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5swFO3jo8CHjQhxBkgnbQ.jpeg"/></div></div></figure><p id="b8b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我想就如何选择缓存解决方案提供一些帮助。我将把它分为两部分:</p><ul class=""><li id="2652" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">在本帖中，我们将列出缓存必须具备的特性以及它可以选择提供的特性。大多数标准都是通用的，可以在不考虑技术栈的情况下使用，而有几个标准是特定于JVM的。</li><li id="cf8b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在第二部分中，我将列出提供者并验证它们各自的能力</li></ul><h1 id="533d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">为什么要缓存？</h1><p id="7288" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">首先，让我们打破一个常见的神话。使用缓存并不是设计糟糕的系统<em class="mn">本身</em>的标志，尽管事实可能如此。与许多设计决策一样，缓存是一种权衡。</p><p id="cd7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最喜欢的例子是通过微服务架构实现的电子商务商店。每个功能都是一个微服务:</p><ul class=""><li id="8e20" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">目录</li><li id="0cdc" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">手推车</li><li id="9241" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">检验</li><li id="bb8f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">定价</li><li id="2e7b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">支付</li></ul><p id="ee0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设用户的购物车中有商品，点击结账。在服务器端，<em class="mn"> checkout </em>服务向<em class="mn"> pricing </em>服务发送请求，以获取购物车的报价。此时，我们有两个要求:</p><ol class=""><li id="3d39" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv mo lc ld le bi translated">定价数据必须<strong class="ka ir">可用</strong>:如果定价服务停止，结账和销售都会失败。</li><li id="6aaf" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv mo lc ld le bi translated">定价数据必须快速可用:如果服务启动，但用户等待时间太长，他们可能会放弃。虽然术语“长”是主观的，但100毫秒的延迟对销售有决定性的影响。</li></ol><p id="f548" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从科学的角度来说，错误的数据是很可怕的。从一个电商来说，卖稍微过时的价格总比销量下降好。</p><p id="c632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，缓存是一种折衷，即接受陈旧数据以使它们可用/快速。</p><h1 id="138f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">强制缓存功能</h1><p id="19c7" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">你可能对这句名言很熟悉，“不要开发自己的加密库”。它暗示设计这样一个库乍看起来可能很简单，但是如果您不是安全专家，您可能会犯一个重大的安全错误——即使如此。您也不应该设计自己的缓存，但原因略有不同。</p><p id="9d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能认为缓存只是内存中的键值存储。这就是哈希表数据结构的确切含义。根据语言的不同，结构有不同的名称:Go中的<a class="ae mp" href="https://golang.org/ref/spec#Map_types" rel="noopener ugc nofollow" target="_blank"> map </a>，Python中的<a class="ae mp" href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" rel="noopener ugc nofollow" target="_blank">dictionary</a>，Java中的<a class="ae mp" href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" rel="noopener ugc nofollow" target="_blank">T0</a>和<a class="ae mp" href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" rel="noopener ugc nofollow" target="_blank"> Rust </a>，Ruby中的<a class="ae mp" href="https://ruby-doc.org/core-3.0.2/Hash.html" rel="noopener ugc nofollow" target="_blank"> Hash </a>等。无论堆栈是什么，我们都可以用这样的结构来建模一个缓存。</p><p id="a5b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名初级开发人员，我也相信这一点，但从那以后我改变了主意。专业缓存提供了普通哈希表所没有的额外功能。</p><h1 id="d7a6" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">尺寸限制</h1><p id="7ddd" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">先说一个简单的特性。</p><p id="869a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序运行的时间越长，其缓存可能会增长得越大。根据确切的用途，例如，如果用不同的关键字缓存许多条目，它甚至可以增长更多。无限制的缓存会与您的应用程序在内存使用方面发生竞争，直到再也没有可用的内存。这是你想要避免的！</p><h1 id="95ed" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">驱逐策略</h1><p id="4425" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当缓存达到其大小限制时，当新条目到达时，我们应该删除哪个条目？选择要移除的条目被称为<strong class="ka ir">驱逐</strong>策略。一些这样的策略非常普遍:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/cf548fd12a5346ccefb9bd66b1166670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nt81hu3G3QCosGWwN0SMxg.png"/></div></div></figure><p id="31be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在维基百科上找到其他可能的策略。</p><h1 id="bdd2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">生存时间</h1><p id="d8ea" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">你可能知道这句名言:</p><blockquote class="mz na nb"><p id="e56f" class="jy jz mn ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated"><em class="iq">计算机科学有两个硬东西:</em></p><p id="9841" class="jy jz mn ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated"><em class="iq"> 1。缓存失效</em></p><p id="a13e" class="jy jz mn ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated"><em class="iq"> 2。命名事物</em></p><p id="50e2" class="jy jz mn ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated"><em class="iq"> 3。和一个误差</em></p></blockquote><p id="215d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它与缓存在删除某个条目之前认为该条目有效的时间有关。当您将条目添加到缓存中时，您应该设置条目过期后的持续时间。</p><p id="2a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种可能的实现是为每个条目添加一个字段:条目将过期的时间戳(当前时间+ TTL)。线程可能偶尔会访问条目，并急切地删除过期的条目。或者，当高速缓存需要更多空间时，它可以缓慢地驱逐过期的条目。</p><h1 id="3d84" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">其他标准</h1><p id="a8a5" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">其他标准是可选的，但仍然值得考虑。他们在这里，没有特定的顺序。</p><h1 id="9c04" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">配置</h1><p id="d240" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">虽然配置不是一个特性，但它会影响<em class="mn">开发者体验</em>。因此，它应该是任何有关缓存选择的分析的一部分。</p><p id="25c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些缓存可能能够使用合理的默认值即时运行，但其他缓存可能需要显式配置。在所有情况下，您可能都需要配置几个参数，比如大小限制。</p><p id="5b67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两种选择:基于文件的配置和编程配置。当然，第三种选择是两者都提供。</p><h1 id="b7cf" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">与缓存抽象的集成</h1><p id="12ba" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">JVM生态系统有一个官方的缓存API，被称为<a class="ae mp" href="https://github.com/jsr107/jsr107spec" rel="noopener ugc nofollow" target="_blank"> JCache </a>，或JSR 107。它是一个API规范，描述了四个注释，<em class="mn">，即</em>、<code class="fe mq mr ms mt b">@CacheResult</code>、<code class="fe mq mr ms mt b">@CachePut</code>、<code class="fe mq mr ms mt b">@CacheRemove</code>和<code class="fe mq mr ms mt b">@CacheRemoveAll</code>。供应商将实施该规范。</p><p id="d958" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring框架在JVM生态系统中相当普遍。它还提供了一个缓存API。从历史上看，它早于JCache。虽然有所不同，但这个API与JCache非常相似。Spring为几个缓存提供了现成的集成代码，而其他几个确实提供了Spring集成。</p><h1 id="5aae" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">缓存模式</h1><p id="76c7" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我在下面的演讲中描述了几种缓存模式。</p><figure class="mv mw mx my gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d569" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为挺长的，这里总结一下:</p><ul class=""><li id="dc0b" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">备用缓存</li><li id="e505" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">缓存直通</li><li id="867d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">通读</li><li id="d46b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">提前刷新</li><li id="c32f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">提前缓存</li></ul><p id="c0b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，人们从缓存备用开始，<em class="mn">即</em>，应用程序在缓存和真实来源之间编排读/写。然而，缓存的真正威力在于更高级的模式。</p><h1 id="e6b2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">分布式与本地</h1><p id="fc99" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">早期的缓存与应用程序共享相同的运行时。然后，架构师设计了在他们的进程中运行的缓存。并行地，您可以从单节点和分布式缓存中进行选择，分布式缓存由属于同一个集群的节点组成。</p><p id="af3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">分布式缓存背后的想法是将多个节点汇集在一起，作为单个存储单元出现。如果需要更多存储，可以添加更多节点。这就是<em class="mn">水平缩放</em>背后的原理。</p><p id="ef19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然在概念上很简单，但它提供了许多新的选择。例如，您可以<em class="mn">跨多个节点复制</em>条目，这样一个节点的故障并不意味着数据丢失。另一种可能的能力是根据条目的属性将条目放在特定的节点上:这种能力被称为<em class="mn">分片</em>。这样，查找条目变得更快，因为缓存不需要向每个节点请求数据，但知道数据位于哪个节点上。当然，集群可以提供复制和分片。</p><p id="8fb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，如果有足够大的存储容量，可以将缓存用作内存数据库。缓存是一个键值存储:通常的用例是通过键值来检索条目。历史上，数据库有更大的范围，并提供查询能力，<em class="mn">，即</em>，<code class="fe mq mr ms mt b">SELECT * FROM Foo</code>。因此，分布式缓存也可以通过专用的API或类似SQL的语法提供这样的功能。</p><p id="9f2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦缓存能够跨节点共享内存，它也可以共享CPU。此时，缓存已经变成了一个<em class="mn">数据网格</em>。可以发送任务，集群在其节点上并行执行这些任务。最重要的是，缓存可以确保任务在它们访问的数据附近运行，从而消除网络流量。</p><p id="93aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于分布式缓存，体系结构是客户机-服务器:应用程序是客户机；缓存就是服务器。为了最大化您的投资，您可能希望在多个客户端之间共享您的数据。客户端可以属于不同的语言，Java和JVM语言，但也可以是其他语言:C#、C、C++、Ruby、Python、Go、Rust、Erlang等。有必要检查一下缓存提供了哪些关于您正在使用的语言的绑定。</p><p id="d691" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这些功能都不是“免费”的。分布式缓存是一个分布式系统，并带有所有的缺陷。要研究的一个重要标准是节点如何在网络上形成集群。例如:</p><ul class=""><li id="a7d0" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">有自动发现机制吗？</li><li id="fc95" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果有，可以禁用吗？</li><li id="04c2" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">能否在同一个网络上配置多个集群？</li><li id="eb1a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">对Kubernetes有效吗？</li><li id="870b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">等等。</li></ul><h1 id="75a8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">非阻塞API</h1><p id="79c6" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">缓存的目的是提高性能，因为访问本地内存中的数据比访问磁盘上或网络上的数据更快。如果数据访问需要很长时间，无论是读还是写，阻塞都会降低整个客户端代码的速度。为了解决这个问题，缓存可以提供一个非阻塞的API。</p><p id="9aa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你需要考虑几个方面；最重要的是缓存使用的API。比如<code class="fe mq mr ms mt b">CompletableFuture</code>需要Java 8。根据您正在使用的堆栈，您可能更喜欢集成了RxJava、Project Reactor、Kotlin coroutines或其任意组合的缓存。</p><h1 id="31c3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">标准项目的健康指标</h1><p id="c33f" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">除了上面提到的所有标准，我建议你考虑应该成为每个产品评估一部分的指标:</p><ul class=""><li id="7115" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><strong class="ka ir">许可</strong>:主要是开源和商业许可，但根据您的使用情况，并不是每个开源许可都兼容</li><li id="77c1" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">定价</strong>，如果是商业性的</li><li id="7f3a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">项目成熟度</strong>:检查项目的开始日期。理由是，比起昨天创建的项目，你可能更依赖于一个“老”项目。</li><li id="a4cb" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">活动</strong>:核心<em class="mn">提交者的数量</em>—<a class="ae mp" href="https://en.wikipedia.org/wiki/Bus_factor" rel="noopener ugc nofollow" target="_blank">总线因素</a>，非核心提交者的数量，提交者的提交历史，开放问题的数量，修复它们的平均时间，如果核心提交者停止了项目工作，等等。</li><li id="bd58" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">文档</strong>:虽然这个术语非常通用，但是好的文档是由<em class="mn">参考资料</em>、<em class="mn">教程</em>、<em class="mn">操作指南</em>和<em class="mn">解释</em>组成的。如果你以前从未遇到过这些术语，请阅读此<a class="ae mp" href="https://documentation.divio.com/" rel="noopener ugc nofollow" target="_blank">页面</a>或观看此<a class="ae mp" href="https://www.youtube.com/watch?v=t4vKPhjcMZg" rel="noopener ugc nofollow" target="_blank">视频</a>。我是在看完讲座后才开始获取文档的。</li><li id="4674" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">社区:有多大？有多活跃？有多大帮助？</li><li id="23da" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><strong class="ka ir">支持</strong>:支持渠道有哪些？Stackoverflow？Google Groups？懈怠？问题多久会有答案？</li><li id="5fde" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">等等。</li></ul><h1 id="bdbc" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="7ecf" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在这篇文章中，我描述了几个选择缓存提供者的标准。在下一篇文章中，我将尝试列出并比较JVM生态系统中最常见的开源缓存提供者。</p><p id="f878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢我的同事Marko Topolnik的评论。</p><p id="e269" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更进一步:</strong></p><ul class=""><li id="e45c" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated"><a class="ae mp" href="https://en.wikipedia.org/wiki/Cache_(computing)" rel="noopener ugc nofollow" target="_blank">缓存上的维基百科页面</a></li><li id="88ae" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mp" href="https://en.wikipedia.org/wiki/Cache_replacement_policies" rel="noopener ugc nofollow" target="_blank">缓存替换策略列表</a></li><li id="9ae9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mp" href="https://www.youtube.com/watch?v=na2HqjBexbU" rel="noopener ugc nofollow" target="_blank">缓存模式指南(视频)</a></li><li id="499e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mp" href="https://hazelcast.com/glossary/jcache-java-cache/" rel="noopener ugc nofollow" target="_blank"> JCache </a></li><li id="8f6e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated"><a class="ae mp" href="https://docs.spring.io/spring-framework/docs/5.3.x/reference/html/integration.html#cache" rel="noopener ugc nofollow" target="_blank"> Spring的缓存抽象</a></li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="f899" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">原载于</em> <a class="ae mp" href="https://blog.frankel.ch/choose-cache/1/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">一个Java极客</em></a><em class="mn">2021年10月24日</em></p></div></div>    
</body>
</html>