<html>
<head>
<title>Trying new tools for building and automating the deployment in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes中尝试构建和自动化部署的新工具</h1>
<blockquote>原文：<a href="https://itnext.io/trying-new-tools-for-building-and-automate-the-deployment-in-kubernetes-f96f9684e580?source=collection_archive---------4-----------------------#2020-01-15">https://itnext.io/trying-new-tools-for-building-and-automate-the-deployment-in-kubernetes-f96f9684e580?source=collection_archive---------4-----------------------#2020-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d1c705bfb4f33ed4537ff6caf341327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HJu_pzhe660WFJZ2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯托夫·高尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="cfff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗨！<br/>最近，许多很酷的自动化工具已经发布，既用于构建Docker映像，也用于部署到Kubernetes。在这方面，我决定稍微玩一下Gitlab，研究一下它的功能，当然还有配置管道。</p><p id="ef31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个作品的灵感来源是网站<a class="ae kc" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> kubernetes.io </a>，它是从<a class="ae kc" href="https://gist.github.com/kvaps/github.com/kubernetes/website" rel="noopener ugc nofollow" target="_blank">源代码</a>自动生成的。对于每个新的pullrequest，机器人会自动生成一个预览版本，并提供一个链接供查看。</p><p id="220f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我试图从头开始构建一个类似的过程，但完全建立在Gitlab CI和免费工具的基础上，我过去常常使用这些工具在Kubernetes中部署应用程序。今天，我最终会告诉你更多关于他们的事情。</p><p id="b2af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将考虑具有动态环境特性的<strong class="kf ir"> Hugo </strong>、<strong class="kf ir"> qbec </strong>、<strong class="kf ir"> kaniko </strong>、<strong class="kf ir"> git-crypt </strong>和<strong class="kf ir"> GitLab CI </strong>等工具。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="fc83" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内容</h1><ol class=""><li id="284c" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated"><a class="ae kc" href="#f1d2" rel="noopener ugc nofollow"> <strong class="kf ir">雨果入门</strong> </a></li><li id="ded1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#2dc8" rel="noopener ugc nofollow"> <strong class="kf ir"> Dockerfile准备</strong> </a></li><li id="0afd" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#9bf2" rel="noopener ugc nofollow"><strong class="kf ir">kaniko</strong></a>入门</li><li id="37a7" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#4c4b" rel="noopener ugc nofollow"><strong class="kf ir">qbec入门</strong> </a></li><li id="2d6f" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#f626" rel="noopener ugc nofollow"> <strong class="kf ir">用Kubernetes-executor </strong> </a>尝试Gitlab-runner</li><li id="7fcf" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#e4f1" rel="noopener ugc nofollow"> <strong class="kf ir">用qbec </strong>部署舵图</a></li><li id="41b9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#29ed" rel="noopener ugc nofollow"><strong class="kf ir">git-crypt入门</strong> </a></li><li id="cedf" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#f67c" rel="noopener ugc nofollow"> <strong class="kf ir">准备工具箱图像</strong> </a></li><li id="ebd3" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#fef1" rel="noopener ugc nofollow"> <strong class="kf ir">我们先对管线和建筑图片使用标签</strong> </a></li><li id="e2c6" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#3880" rel="noopener ugc nofollow"> <strong class="kf ir">部署自动化</strong> </a></li><li id="ed1d" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#83a1" rel="noopener ugc nofollow"> <strong class="kf ir">构件和建筑上推的主</strong> </a></li><li id="3bc6" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="#a684" rel="noopener ugc nofollow"> <strong class="kf ir">动态环境</strong> </a></li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f1d2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.Hugo入门</h1><p id="7f3f" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">作为我们项目的一个例子，我们将尝试创建一个网站来发布基于Hugo的文档。<a class="ae kc" href="https://gohugo.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Hugo </strong> </a>是一个静态站点生成器。</p><p id="13a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些不熟悉静电发生器的人，我给你讲一点。不同于普通的带有数据库的站点引擎和一些PHP，它们会根据用户的请求动态生成页面，静态生成器的工作方式有所不同。<br/>他们允许获取源文本，比如说<strong class="kf ir"> Markdown </strong>标记和主题模板中的一组文件，然后将它们编译成一个完整的站点。</p><p id="b246" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，在输出端你会得到一个目录结构和一组生成的HTML文件，这些文件可以简单地上传到任何便宜的主机上，并得到一个工作站点。</p><p id="90db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Hugo可以在本地安装并试用:</p><p id="3ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初始化新网站:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2548" class="ni lj iq ne b gy nj nk l nl nm">hugo new site docs.example.org</span></pre><p id="6911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有git-repository:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="546c" class="ni lj iq ne b gy nj nk l nl nm">cd docs.example.org<br/>git init</span></pre><p id="9726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的网站是空的，如果我们想让一些东西出现在上面，首先我们需要连接一个主题。主题它只是一套模板和预设规则生成我们的网站。</p><p id="d300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<a class="ae kc" href="https://themes.gohugo.io/hugo-theme-learn/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">学习</strong> </a>主题，这在我看来是最适合一个有文档的站点的。</p><p id="4247" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们不需要将主题文件保存在我们的存储库中，相反，我们可以使用<strong class="kf ir"> git子模块</strong>简单地连接它:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="f4e7" class="ni lj iq ne b gy nj nk l nl nm">git submodule add <a class="ae kc" href="https://github.com/matcornic/hugo-theme-learn" rel="noopener ugc nofollow" target="_blank">https://github.com/matcornic/hugo-theme-learn</a> themes/learn</span></pre><p id="74e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在我们的存储库中，只有与我们的项目直接相关的文件，没有其他的。连接的主题将只是一个到特定存储库和提交散列的链接，因此，它总是可以从原始源中提取，而不用担心不兼容的更改。</p><p id="60e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编辑配置<code class="fe nn no np ne b">config.toml</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9482" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以访问http://localhost:1313/ 并查看我们新创建的站点。目录中的所有更改都会自动更新浏览器中的页面，非常方便！</p><p id="f2d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试着创建一个标题页<code class="fe nn no np ne b">content/_index.md</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="a314" class="ni lj iq ne b gy nj nk l nl nm"># My docs site</span><span id="8572" class="ni lj iq ne b gy ns nk l nl nm">## Welcome to the docs!</span><span id="2a5b" class="ni lj iq ne b gy ns nk l nl nm">You will be very smart :-)</span></pre><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/895a8d8531e267f6426192b4a156da1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e45irTV8cuHMervB.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">创建页面的屏幕截图</figcaption></figure><p id="b0aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要生成一个站点，只需运行:</p><p id="f26a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目录<code class="fe nn no np ne b">public/</code>中的内容就是你的站点。</p><p id="5e5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便补充一下<code class="fe nn no np ne b">.gitignore</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="4760" class="ni lj iq ne b gy nj nk l nl nm">echo /public &gt; .gitignore</span></pre><p id="95b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="28eb" class="ni lj iq ne b gy nj nk l nl nm">git add .<br/>git commit -m "New site created"</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="2dc8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.Dockerfile文件准备</h1><p id="4313" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">是时候确定我们的存储库的结构了。通常我会用这样的词:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="6f52" class="ni lj iq ne b gy nj nk l nl nm">.<br/>├── deploy<br/>│   ├── app1<br/>│   └── app2<br/>└── dockerfiles<br/>    ├── image1<br/>    └── image2</span></pre><ul class=""><li id="717a" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><code class="fe nn no np ne b">dockerfiles/</code> —包含docker文件目录和构建docker映像所需的一切。</li><li id="671a" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">deploy/</code> —包含将我们的应用程序部署到Kubernetes的目录</li></ul><p id="c70e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将沿着路径<code class="fe nn no np ne b">dockerfiles/website/Dockerfile</code>创建第一个docker文件</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，docker文件包含两个<code class="fe nn no np ne b">FROM</code>，这个机会被称为<a class="ae kc" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">多阶段构建</strong> </a>并允许你从最终的docker映像中排除一切不必要的东西。因此，最终的图像将只包含我们静态生成的站点和<strong class="kf ir"> darkhttpd </strong>(轻量级HTTP-server)的内容。</p><p id="5657" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e7d0" class="ni lj iq ne b gy nj nk l nl nm">git add dockerfiles/website<br/>git commit -m "Add Dockerfile for website"</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="9bf2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.kaniko入门</h1><p id="6a80" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">我决定使用<a class="ae kc" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> kaniko </strong> </a>来构建docker映像，因为它不需要运行docker守护进程。构建可以在任何主机上完成，这些层可以直接缓存在docker-registry中，不再需要完整的持久存储。</p><p id="ee42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要构建映像，只需用<strong class="kf ir"> kaniko executor </strong>启动容器，并将当前的构建上下文传递给它，您可以在本地使用docker:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8616" class="ni lj iq ne b gy nj nk l nl nm">docker run -ti --rm \<br/>  -v $PWD:/workspace \<br/>  -v ~/.docker/config.json:/kaniko/.docker/config.json:ro \<br/>  gcr.io/kaniko-project/executor:v0.15.0 \<br/>  --cache \<br/>  --dockerfile=dockerfiles/website/Dockerfile \<br/>  --destination=registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1</span></pre><p id="fa0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe nn no np ne b">registry.gitlab.com/kvaps/docs.example.org/website</code>是您的docker映像的名称，在构建之后，它将被自动推送到docker注册表中。</p><p id="88e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选项<code class="fe nn no np ne b">--cache</code>允许缓存docker注册表中的层，对于给定的例子，它将保存在<code class="fe nn no np ne b">registry.gitlab.com/kvaps/docs.example.org/website/cache</code>中，但您可以使用选项<code class="fe nn no np ne b">--cache-repo</code>指定另一个。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/0b55b5fcf516130bb572e9295a81d388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dSWUYBc8KEziXSWz.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">docker-registry屏幕截图</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="4c4b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">4.qbec入门</h1><p id="4b50" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">Qbec  是一个部署工具，它允许你以声明的方式描述你的应用程序清单，并将它们部署到Kubernetes。使用Jsonnet作为主要语法可以简化对几种环境差异的描述，并且几乎完全消除了代码的重复性。</p><p id="5a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您需要将一个应用程序部署到几个具有不同参数的集群中，并且希望用Git声明性地描述它们时，这非常有用。</p><p id="9f71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Qbec也允许你通过传递必要的参数来渲染舵图，然后像操作通常的宣言一样操作它们。它允许您为它们添加一些突变，并且消除了使用ChartMuseum的需要。通过这种方式，您可以直接从git中存储和呈现图表，因为它们在git中占有非常重要的位置。</p><p id="a3fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，我们将所有部署存储在一个目录<code class="fe nn no np ne b">deploy/</code>中:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5985" class="ni lj iq ne b gy nj nk l nl nm">mkdir deploy<br/>cd deploy</span></pre><p id="07db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们初始化我们的第一个应用程序:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="816b" class="ni lj iq ne b gy nj nk l nl nm">qbec init website<br/>cd website</span></pre><p id="6296" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们的应用程序的结构如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5718" class="ni lj iq ne b gy nj nk l nl nm">.<br/>├── components<br/>│   ├── gitlab-runner.jsonnet<br/>├── environments<br/>│   ├── base.libsonnet<br/>│   └── default.libsonnet<br/>├── params.libsonnet<br/>├── qbec.yaml<br/>├── secrets<br/>│   └── base.libsonnet<br/>└── vendor<br/>    └── gitlab-runner (submodule)</span></pre><p id="b5cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看文件<code class="fe nn no np ne b">qbec.yaml</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="4a77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们主要对<code class="fe nn no np ne b">spec.environment</code>感兴趣，qbec已经创建了一个默认环境，并从我们当前的kubeconfig中获取了我们的名称空间和服务器地址。<br/>现在，当使用<strong class="kf ir">默认</strong>环境时，qbec将总是部署到指定的Kubernetes集群和名称空间。这样，您不再需要在应用配置之前切换名称空间和上下文。<br/>如有必要，您可以随时更新该文件中的设置。</p><p id="e6b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的所有环境都应该在<code class="fe nn no np ne b">qbec.yaml</code>和<code class="fe nn no np ne b">params.libsonnet</code>文件中描述，其中包含在哪里为它们获取参数的信息。</p><p id="ec33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们看到两个目录:</p><ul class=""><li id="9346" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><code class="fe nn no np ne b">components/</code> —我们应用程序的所有清单都将存储在这里，我们可以使用jsonnet和普通的yaml文件来描述它们</li><li id="852f" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">environments/</code> —这里我们将描述我们环境的所有变量(参数)。</li></ul><p id="9697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，我们有两个文件:</p><ul class=""><li id="0fd2" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><code class="fe nn no np ne b">environments/base.libsonnet</code> —包含所有环境的一般参数</li><li id="84f9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">environments/default.libsonnet</code> —包含<strong class="kf ir">默认</strong>环境的参数覆盖</li></ul><p id="d08c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们打开<code class="fe nn no np ne b">environments/base.libsonnet</code>，在那里添加第一个组件的参数:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="09ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建我们的第一个组件<code class="fe nn no np ne b">components/website.jsonnet</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="97e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个文件中，我们描述了三个Kubernetes实体，它们是:<strong class="kf ir">部署</strong>、<strong class="kf ir">服务</strong>和<strong class="kf ir">入口</strong>。我们可以把它们分成不同的部分，但是在这个阶段，一个就足够了。</p><p id="d606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语法<strong class="kf ir"> jsonnet </strong>与常规json非常相似。原则上，常规json已经是有效的jsonnet，所以首先使用一些在线服务，如<strong class="kf ir"> yaml2json </strong>来将您通常的yaml清单转换为json格式，或者如果您的组件不包含任何变量，它们可以完全作为通常的yaml文件放置。</p><blockquote class="nz oa ob"><p id="542b" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">我强烈推荐你为你的编辑器安装一个插件来使用jsonnet。</p><p id="261c" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">例如，vim有一个很好的插件<strong class="kf ir"> vim-jsonnet </strong>，它打开语法高亮显示，并在每次保存时自动运行<code class="fe nn no np ne b">jsonnet fmt</code>(它需要安装<strong class="kf ir"> jsonnet </strong>二进制文件)。</p></blockquote><p id="cf74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始部署的一切准备就绪:</p><p id="1eeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查看具体会应用什么，只需运行:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ef9a" class="ni lj iq ne b gy nj nk l nl nm">qbec show default</span></pre><p id="f7af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在输出中，您将看到呈现的YAML-manifest，它将应用于默认集群。</p><p id="2cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好，现在申请:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="c0ce" class="ni lj iq ne b gy nj nk l nl nm">qbec apply default</span></pre><p id="2c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在输出中，您将始终看到在您的集群中将进行哪些更改，qbec将要求您接受这些更改。通过输入<code class="fe nn no np ne b">y</code>你可以确认。</p><p id="5bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成，现在我们的应用程序已经部署好了！</p><p id="97b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">描述发生任何变化后，您都可以:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2a24" class="ni lj iq ne b gy nj nk l nl nm">qbec diff default</span></pre><p id="6f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看这些更改将如何影响当前部署</p><p id="b648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2a36" class="ni lj iq ne b gy nj nk l nl nm">cd ../..<br/>git add deploy/website<br/>git commit -m "Add deploy for website"</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f626" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">5.尝试用Kubernetes-executor运行Gitlab-runner</h1><p id="918b" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">直到最近，我只在一台准备好的机器(LXC容器)上使用普通的gitlab-runner，它带有shell-或docker-executor。<br/>从一开始，我们就在Gitlab中定义了几个这样的跑步者。他们为我们所有的项目建立docker图像。</p><p id="5a50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但实践表明，无论从实用性还是安全性来看，这种情况都不太理想。为每一个项目，甚至每一个环境部署单独的运行人员，这是更好的，也是更符合意识形态的。</p><p id="e582" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，这根本不是问题，因为现在我们将直接把<strong class="kf ir"> gitlab-runner </strong>作为我们应用程序的一部分直接部署到Kubernetes。</p><p id="2688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Gitlab提供了在Kubernetes中部署gitlab-runner的导航图。因此，您需要做的就是在<strong class="kf ir">设置→ CI / CD → Runners </strong>中找到我们项目的<strong class="kf ir">注册令牌</strong>，并将其传递给Helm:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ee9d" class="ni lj iq ne b gy nj nk l nl nm">helm repo add gitlab <a class="ae kc" href="https://charts.gitlab.io" rel="noopener ugc nofollow" target="_blank">https://charts.gitlab.io</a></span><span id="174d" class="ni lj iq ne b gy ns nk l nl nm">helm install gitlab-runner \<br/>  --set gitlabUrl=<a class="ae kc" href="https://gitlab.com" rel="noopener ugc nofollow" target="_blank">https://gitlab.com</a> \<br/>  --set runnerRegistrationToken=yga8y-jdCusVDn_t4Wxc \<br/>  --set rbac.create=true \<br/>  gitlab/gitlab-runner</span></pre><p id="f2b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中:</p><ul class=""><li id="be1b" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><code class="fe nn no np ne b">https://gitlab.com</code> —是您的Gitlab服务器的地址。</li><li id="68c1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">yga8y-jdCusVDn_t4Wxc</code> —是您项目的注册令牌。</li><li id="5f61" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">rbac.create=true</code> —为跑步者提供所有必要的权限，以便使用Kubernetes-executor创建新的pod并执行我们的工作。</li></ul><p id="acbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一切正常，您应该在项目设置页面的<strong class="kf ir">跑步者</strong>部分看到注册的跑步者。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/a60592e012a9fedc73d98e6e5913bb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9f0nN4wjmDMrbCIY.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://habrastorage.org/webt/at/lx/g_/atlxg_u6rjn4n0pkcpn8--2gare.png" rel="noopener ugc nofollow" target="_blank">新增跑步者截图</a></figcaption></figure><p id="9401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有这么简单吗？———对，就这么简单！不再有手动跑步者注册的麻烦，因为现在所有的跑步者都将被自动创建和销毁。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="e4f1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">6.用qbec部署舵图</h1><p id="2ccb" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">既然我们决定将<strong class="kf ir"> gitlab-runner </strong>作为我们项目的一部分，现在是时候在我们的Git-repository中描述它了。</p><p id="10ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把它描述为<strong class="kf ir">网站</strong>的一个独立组件，但是将来我们计划经常部署<strong class="kf ir">网站</strong>的不同副本，不像<code class="fe nn no np ne b">gitlab-runner</code>，每个Kubernetes集群只部署一次。所以让我们为它初始化一个单独的应用程序:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7f89" class="ni lj iq ne b gy nj nk l nl nm">cd deploy<br/>qbec init gitlab-runner<br/>cd gitlab-runner</span></pre><p id="4eda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次我们不会手动描述Kubernetes实体，而是使用一个现成的舵图。qbec的优势之一是能够直接从Git存储库呈现舵图。</p><p id="14cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们使用git子模块来连接它:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9f12" class="ni lj iq ne b gy nj nk l nl nm">git submodule add <a class="ae kc" href="https://gitlab.com/gitlab-org/charts/gitlab-runner" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/gitlab-org/charts/gitlab-runner</a> vendor/gitlab-runner</span></pre><p id="f425" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在,<code class="fe nn no np ne b">vendor/gitlab-runner</code>目录包含了到带有gitlab-runner图表的存储库的链接。</p><blockquote class="nz oa ob"><p id="cb7f" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">类似的方式，你可以和其他存储库连接，例如，整个存储库用官方图表<a class="ae kc" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">https://github.com/helm/charts</strong></a></p></blockquote><p id="60a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来描述一下组件<code class="fe nn no np ne b">components/gitlab-runner.jsonnet</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b9cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">expandHelmTemplate</code>的第一个参数是图表的路径，然后是从环境参数中获取的<code class="fe nn no np ne b">params.values</code>，然后是一个带有</p><ul class=""><li id="5df4" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><code class="fe nn no np ne b">nameTemplate</code> —发布名称</li><li id="d918" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">namespace</code> —名称空间传递给掌舵人</li><li id="c6a9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">thisFile</code> —传递当前文件路径的必需参数</li><li id="7983" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">verbose</code> —呈现图表时将显示<code class="fe nn no np ne b">helm template</code>命令及其所有参数</li></ul><p id="1c4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们描述一下<code class="fe nn no np ne b">environments/base.libsonnet</code>中组件的参数:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="68c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意我们从外部文件<code class="fe nn no np ne b">secrets/base.libsonnet</code>中取出<code class="fe nn no np ne b">runnerRegistrationToken</code>，让我们创建它:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1b7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查一切是否正常:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="becf" class="ni lj iq ne b gy nj nk l nl nm">qbec show default</span></pre><p id="22b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一切正常，那么我们可以移除早期部署的头盔释放装置:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="4e53" class="ni lj iq ne b gy nj nk l nl nm">helm uninstall gitlab-runner</span></pre><p id="8db8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并再次部署它，但是使用qbec:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="db4b" class="ni lj iq ne b gy nj nk l nl nm">qbec apply default</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="29ed" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">7.git-crypt入门</h1><p id="78e6" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><a class="ae kc" href="https://github.com/AGWA/git-crypt" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Git-crypt </strong> </a>是一个允许你为你的存储库配置透明加密的工具。</p><p id="e330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，gitlab-runner的目录结构如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ad93" class="ni lj iq ne b gy nj nk l nl nm">.<br/>├── components<br/>│   ├── gitlab-runner.jsonnet<br/>├── environments<br/>│   ├── base.libsonnet<br/>│   └── default.libsonnet<br/>├── params.libsonnet<br/>├── qbec.yaml<br/>├── secrets<br/>│   └── base.libsonnet<br/>└── vendor<br/>    └── gitlab-runner (submodule)</span></pre><p id="56b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在Git中保存秘密并不安全，不是吗？所以我们需要通过适当的方式对它们进行加密。</p><blockquote class="nz oa ob"><p id="66fd" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">通常只对单个变量没有多大意义，因为你可以使用CI系统的环境变量将秘密传递给<strong class="kf ir"> qbec </strong>。</p><p id="6187" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">但是请注意，可能有更复杂的项目，其中可能包含更多的秘密。使用环境变量很难通过所有的测试。</p><p id="e643" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">同样在这种情况下，我也不能告诉你像<strong class="kf ir"> git-crypt </strong>这样一个奇妙的工具。</p><p id="9161" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">Git-crypt 也非常方便，因为它允许你保存秘密的整个历史，以及以与使用标准Git相同的方式比较、合并和解决冲突。</p></blockquote><p id="38cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装<strong class="kf ir"> git-crypt </strong>后的第一步，我们需要为我们的存储库生成密钥:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="bfdf" class="ni lj iq ne b gy nj nk l nl nm">git crypt init</span></pre><p id="1631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有PGP-key，那么您可以立即将自己添加为此项目的合作者:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="42c0" class="ni lj iq ne b gy nj nk l nl nm">git-crypt add-gpg-user kvapss@gmail.com</span></pre><p id="b7e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您总是可以使用您的私钥解密这个存储库。</p><p id="26f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您没有PGP-key，也不打算拥有它，那么您可以使用另一种方法导出项目密钥:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="60db" class="ni lj iq ne b gy nj nk l nl nm">git crypt export-key /path/to/keyfile</span></pre><p id="21e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，任何拥有导出的<strong class="kf ir">密钥文件</strong>的人都可以解密您的存储库。</p><p id="c18c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是时候配置我们的第一个秘密了。<br/>记住我们仍然在目录<code class="fe nn no np ne b">deploy/gitlab-runner/</code>中，这里有目录<code class="fe nn no np ne b">secrets/</code>，让我们加密里面的所有文件。为了实现这一点，我们应该创建包含以下内容的文件<code class="fe nn no np ne b">secrets/.gitattributes</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aa65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从内容中可以看出，所有文件掩码<code class="fe nn no np ne b">*</code>都将通过<strong class="kf ir"> git-crypt </strong>运行，除了<code class="fe nn no np ne b">.gitattributes</code>本身</p><p id="d9c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过执行以下命令验证这一点:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e893" class="ni lj iq ne b gy nj nk l nl nm">git crypt status -e</span></pre><p id="cb31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在输出中，我们看到存储库中所有启用了加密的文件的列表</p><p id="3b03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是全部，现在我们可以勇敢地提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b4c7" class="ni lj iq ne b gy nj nk l nl nm">cd ../..<br/>git add .<br/>git commit -m "Add deploy for gitlab-runner"</span></pre><p id="7e51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要锁定存储库，只需执行以下操作:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d543" class="ni lj iq ne b gy nj nk l nl nm">git crypt lock</span></pre><p id="24d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有加密的文件都将变成二进制对象，人们将无法读取它们。要解密存储库，请执行以下操作:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3e3f" class="ni lj iq ne b gy nj nk l nl nm">git crypt unlock</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="f67c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">8.准备工具箱图像</h1><p id="de67" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">工具箱映像就是这样一个映像，它包含了在我们的项目中执行部署操作所需的所有工具。gitlab-runner将使用它来执行典型的部署任务。</p><p id="b4af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里一切都很简单，用以下内容创建一个新的<code class="fe nn no np ne b">dockerfiles/toolbox/Dockerfile</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ae35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这张图片包含了我们用来部署应用程序的所有工具。我们在这里不仅仅需要kubectl，但是您可能想在管道设置阶段使用它。</p><p id="0864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，为了能够与Kubernetes通信并执行部署操作，我们需要为gitlab-runner创建的pod配置角色。</p><p id="946b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，请使用gitlab-runner转到目录:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ffd1" class="ni lj iq ne b gy nj nk l nl nm">cd deploy/gitlab-runner</span></pre><p id="de9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并添加新组件<code class="fe nn no np ne b">components/rbac.jsonnet</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将描述<code class="fe nn no np ne b">environments/base.libsonnet</code>中的新参数，现在看起来像是:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="87bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注<code class="fe nn no np ne b">$.components.rbac.name</code>是指部件<code class="fe nn no np ne b">rbac</code>的<code class="fe nn no np ne b">name</code></p><p id="5d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看发生了什么变化:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2e9a" class="ni lj iq ne b gy nj nk l nl nm">qbec diff default</span></pre><p id="e920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并将我们的更改应用到Kubernetes:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ef5f" class="ni lj iq ne b gy nj nk l nl nm">qbec apply default</span></pre><p id="7a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，不要忘记将我们的更改提交给Git:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="92a2" class="ni lj iq ne b gy nj nk l nl nm">cd ../..<br/>git add dockerfiles/toolbox<br/>git commit -m "Add Dockerfile for toolbox"<br/>git add deploy/gitlab-runner<br/>git commit -m "Configure gitlab-runner to use toolbox"</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="fef1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">9.我们第一个使用标签的管道和建筑图像</h1><p id="71d7" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">在项目的根目录中，我们将创建包含以下内容的<code class="fe nn no np ne b">.gitlab-ci.yml</code>:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="87cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，对于那些需要在执行前显式初始化子模块的作业，我们使用<code class="fe nn no np ne b">GIT_SUBMODULE_STRATEGY: normal</code>。</p><p id="b2be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="c6fb" class="ni lj iq ne b gy nj nk l nl nm">git add .gitlab-ci.yml<br/>git commit -m "Automate docker build"</span></pre><p id="7554" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想我们有足够的勇气称之为版本<code class="fe nn no np ne b">v0.0.1</code>并加上一个标签:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="220d" class="ni lj iq ne b gy nj nk l nl nm">git tag v0.0.1</span></pre><p id="b9d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们需要发布新版本时，我们都会使用标签。Docker图像中的标签将被粘贴到Git标签上。每一次使用新标签的推送都将使用该标签初始化图像构建。</p><p id="7108" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<code class="fe nn no np ne b">git push --tags</code>，看看我们的第一条管道:</p><blockquote class="nz oa ob"><p id="c893" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">注意，使用标签适合构建docker图像，但不适合在Kubernetes中部署应用程序。由于新标签可以添加到旧的提交中，因此它们的管道将启动旧版本的部署过程。</p><p id="225c" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">为了解决这个问题，通常docker图像构建连接到标签，并且应用部署到<strong class="kf ir">主</strong>分支，其中图像版本在配置中被硬编码。在这种情况下，您将能够通过初始化<strong class="kf ir">主</strong>分支的简单恢复来回滚。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="3880" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">10.部署自动化</h1><p id="bdaa" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">为了允许Gitlab-runner解密我们的秘密，我们需要导出存储库密钥并将其添加到我们的CI环境变量中:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7c6f" class="ni lj iq ne b gy nj nk l nl nm">git crypt export-key /tmp/docs-repo.key<br/>base64 -w0 /tmp/docs-repo.key; echo</span></pre><p id="38a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出的字符串应该保存在Gitlab中，我们来看看我们项目的设置:<strong class="kf ir">设置→ CI / CD →变量</strong></p><p id="cf5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并创建一个新变量:</p><ul class=""><li id="5992" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><strong class="kf ir">类型:</strong>T3】</li><li id="ea0b" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><strong class="kf ir">关键:</strong>T4】</li><li id="4137" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><strong class="kf ir">值:</strong>T5】</li><li id="62b1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><strong class="kf ir">保护:</strong> <code class="fe nn no np ne b">true</code> <em class="oc">(对于训练可以是</em> <code class="fe nn no np ne b"><em class="oc">false</em></code> <em class="oc"> ) </em></li><li id="cfa9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><strong class="kf ir">蒙面:</strong> <code class="fe nn no np ne b">true</code></li><li id="3087" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><strong class="kf ir">范围:</strong> <code class="fe nn no np ne b">All environments</code></li></ul><p id="0acb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在更新我们的<code class="fe nn no np ne b">.gitlab-ci.yml</code>补充一下:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2f3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们为qbec使用了几个新选项:</p><ul class=""><li id="be0f" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated"><code class="fe nn no np ne b">--root some/app</code> —允许用应用程序定义目录</li><li id="a57a" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">--force:k8s-context __incluster__</code> —这是一个神奇的变量，表示强制部署到运行gtilab-runner的同一个集群。必须这样做，否则qbec会试图在kubeconfig中寻找合适的Kubernetes服务器</li><li id="1668" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">--wait</code> —让qbec等待，直到创建的资源变为就绪状态，然后以成功退出代码退出。</li><li id="a186" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated"><code class="fe nn no np ne b">--yes</code> —禁用交互外壳<strong class="kf ir">您确定吗？</strong>展开期间</li></ul><p id="f859" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e094" class="ni lj iq ne b gy nj nk l nl nm">git add .gitlab-ci.yml<br/>git commit -m "Automate deploy"</span></pre><p id="a40a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe nn no np ne b">git push</code>之后，我们将看到我们的应用程序是如何部署的:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/8d00318ae10c907bfadb00695d4e6252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*msC8soDex4NkOxdZ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第二个管道的屏幕截图</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="83a1" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">11.工件和基于主推的构建</h1><p id="1ff2" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">通常上述步骤足以构建和交付几乎任何微服务，但我们不想每次需要更新站点时都添加一个标签。<br/>因此，我们将采用更动态的方式，直接在主分支机构中配置基于摘要的部署。</p><p id="6859" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想法很简单:现在我们的<strong class="kf ir">网站</strong>的图像会在你每次推送到<strong class="kf ir"> master </strong>时重建，之后它会自动部署到Kubernetes。</p><p id="a1b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在<code class="fe nn no np ne b">.gitlab-ci.yml</code>中更新这两个作业:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="10a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们将我们的<strong class="kf ir">主</strong>分支添加到<code class="fe nn no np ne b">refs</code>用于<code class="fe nn no np ne b">build_website</code>工作，现在我们也使用<code class="fe nn no np ne b">$CI_COMMIT_REF_NAME</code>而不是<code class="fe nn no np ne b">$CI_COMMIT_TAG</code>。这样我们就不再对docker图像使用Git标记，现在它们将使用每个管道的提交分支名称来创建。它还将与<strong class="kf ir">标签</strong>一起工作，这将允许我们在docker-registry中保存特定网站版本的快照。</p><p id="d863" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">qbec的选项<code class="fe nn no np ne b">--vm:ext-str digest="$DIGEST"</code>—允许您将外部变量传递给jsonnet。</p><p id="2b0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们希望将应用程序的每个版本都应用到集群中，所以我们不能再使用标记名，因为它们不会改变。我们需要为每个部署操作指定确切的映像版本，以便在发生变化时触发滚动更新。</p><p id="06e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们将使用Kaniko的功能将图像的摘要保存到一个文件中(选项<code class="fe nn no np ne b">--digest-file</code> ) <br/>，然后我们将传递这个文件并在部署阶段读取它。</p><p id="a51d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们更新<code class="fe nn no np ne b">deploy/website/environments/base.libsonnet</code>的参数，现在看起来像这样:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fdf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成，现在对<strong class="kf ir"> master </strong>的任何提交都将触发<strong class="kf ir">网站</strong>的docker映像构建，然后将其部署到Kubernetes。</p><p id="23ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><p id="ca49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查一下，在<code class="fe nn no np ne b">git push</code>之后我们应该会看到这样的内容:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/9aa8ba99ff027790d1111aabce01cf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QuDOENYxY0SbuvwY.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">主管道的屏幕截图</figcaption></figure><p id="2a95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要每次都重新部署gitlab-runner，当然，除非它的配置没有任何变化，所以让我们在<code class="fe nn no np ne b">.gitlab-ci.yml</code>中修复它:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5f15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">changes</code>允许您监控<code class="fe nn no np ne b">deploy/gitlab-runner/</code>中的变化，并仅在这种情况下触发作业:</p><p id="5c2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="41f7" class="ni lj iq ne b gy nj nk l nl nm">git add .<br/>git commit -m "Configure dynamic build"</span></pre><p id="6ab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">git push</code>，这样更好:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/2c8cfc12473c58407c65a3463c792f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2ZEyZHmfg4fus84l.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新后的管道截图</figcaption></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a684" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">12.动态环境</h1><p id="5ab9" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">是时候让我们的渠道在动态环境中多样化了。</p><p id="f0f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，更新我们的<code class="fe nn no np ne b">.gitlab-ci.yml</code>中的<code class="fe nn no np ne b">build_website</code>作业，从中移除<code class="fe nn no np ne b">only</code>块，这将迫使Gitlab在任何分支中的任何提交时触发它:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="20e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后更新作业<code class="fe nn no np ne b">deploy_website</code>，在那里添加<code class="fe nn no np ne b">environment</code>块:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="41a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将允许Gitlab将作业与<strong class="kf ir"> prod </strong>环境相关联，并显示到它的正确链接。</p><p id="16ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在再添加两个作业:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1f7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们将在除master之外的任何分支上运行，并将部署站点的预览版本。</p><p id="5c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到了qbec的一个新选项:<code class="fe nn no np ne b">--app-tag</code> —它允许您为应用程序的已部署版本添加特定的标签，并且只在这个标签的上下文中工作。因此，我们可以不为每个评审创建单独的环境，而是简单地重用同一个环境。</p><p id="d26a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们还使用了<code class="fe nn no np ne b">qbec apply review</code>，而不是<code class="fe nn no np ne b">qbec apply default</code> —这就是我们如何准确描述我们的环境(审查和默认)的差异:</p><p id="1ae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<strong class="kf ir">评审</strong>环境添加到<code class="fe nn no np ne b">deploy/website/qbec.yaml</code></p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f65b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe nn no np ne b">deploy/website/params.libsonnet</code>中声明:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0c4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在<code class="fe nn no np ne b">deploy/website/environments/review.libsonnet</code>中为其编写自定义参数:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="103a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再仔细看看<strong class="kf ir"> stop_review </strong>作业，它会在移除分支时触发。为了迫使Gitlab不尝试在它上面签出，我们使用<code class="fe nn no np ne b">GIT_STRATEGY: none</code>，稍后我们克隆<strong class="kf ir">主</strong>分支并使用它来删除审查版本部署。<br/>这有点难看，但我还没有找到更漂亮的办法。<br/>另一种方法是将每个审查版本部署到单独的名称空间，然后从应用程序中删除整个名称空间。</p><p id="717b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9fd1" class="ni lj iq ne b gy nj nk l nl nm">git add .<br/>git commit -m "Enable automatic review"</span></pre><p id="7d6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">git push</code>、<code class="fe nn no np ne b">git checkout -b test</code>、<code class="fe nn no np ne b">git push origin test</code>，检查这个:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/f86617bd601917a7c8ed6bb7fca8bb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wI0jleGkmLc6a5mf.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Gitlab中已创建环境的屏幕截图</figcaption></figure><p id="5164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切正常吗？— —很好，删除我们的测试分支:<code class="fe nn no np ne b">git checkout master</code>，<code class="fe nn no np ne b">git push origin :test</code>，检查环境移除是否无误完成。</p><blockquote class="nz oa ob"><p id="63ca" class="kd ke oc kf b kg kh ki kj kk kl km kn od kp kq kr oe kt ku kv of kx ky kz la ij bi translated">这里我想马上澄清，任何能够在项目中创建分支的开发人员也可以更改这个分支中的<code class="fe nn no np ne b">.gitlab-ci.yml</code>文件，并获得对秘密变量的访问权。<br/>因此，强烈建议您仅允许它们用于受保护的分支，例如在<strong class="kf ir">主</strong>中，或者为每个环境提供一组单独的变量。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="e39e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">13.查看应用程序</h1><p id="696d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><a class="ae kc" href="https://docs.gitlab.com/ee/ci/review_apps/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">查看应用</strong> </a>就是这样一个特性，它允许您为存储库中的每个文件添加一个按钮，以便在部署的环境中快速查看它。<br/>要让这些按钮出现，你需要创建一个文件<code class="fe nn no np ne b">.gitlab/route-map.yml</code>并在其中描述所有的路径转换，在我们的例子中这将非常简单:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记提交我们的更改:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="110a" class="ni lj iq ne b gy nj nk l nl nm">git add .gitlab/<br/>git commit -m "Enable review apps"</span></pre><p id="7fd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nn no np ne b">git push</code>，又查:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/5b4c57a57bec15e045aa1cabddf731fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5KY_CxTfztSKzUfp.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">查看应用程序按钮的屏幕截图</figcaption></figure><h1 id="2619" class="li lj iq bd lk ll og ln lo lp oh lr ls lt oi lv lw lx oj lz ma mb ok md me mf bi translated">任务完成了。</h1><p id="7165" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><strong class="kf ir">本作品来源:</strong></p><ul class=""><li id="91cd" class="mg mh iq kf b kg kh kk kl ko nu ks nv kw nw la nx mo mp mq bi translated">在Gitlab上:<a class="ae kc" href="https://gitlab.com/kvaps/docs.example.org" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/kvaps/docs.example.org</a></li><li id="0916" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la nx mo mp mq bi translated">在GitHub上:<a class="ae kc" href="https://github.com/kvaps/docs.example.org" rel="noopener ugc nofollow" target="_blank">https://github.com/kvaps/docs.example.org</a></li></ul><p id="083a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的关注，希望您喜欢😉</p></div></div>    
</body>
</html>