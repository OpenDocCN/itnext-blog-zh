<html>
<head>
<title>Set in Go, map[]bool and map[]struct{} performance comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Set in Go、map[]bool和map[]struct{}性能比较</h1>
<blockquote>原文：<a href="https://itnext.io/set-in-go-map-bool-and-map-struct-performance-comparison-5315b4b107b?source=collection_archive---------1-----------------------#2021-06-14">https://itnext.io/set-in-go-map-bool-and-map-struct-performance-comparison-5315b4b107b?source=collection_archive---------1-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c8be7508964ca4629be9b5bbabed97b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oA-xwE-aZnS1jp_JVppwZQ.png"/></div></div></figure><blockquote class="kb kc kd"><p id="a9bc" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">TL；当遇到大数据集时，DR <code class="fe ld le lf lg b">map[]struct{}</code>比<code class="fe ld le lf lg b">map[]bool</code>在时间上快5%,内存消耗少10%。</p></blockquote><p id="96fe" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">围棋中没有内置的Set已经不是什么秘密，所以围棋开发者用<code class="fe ld le lf lg b">map</code>来模仿Set的行为。使用<code class="fe ld le lf lg b">map</code>实现Set意味着map的值并不重要，我们只需要关注key的存在。大多数时候，人们可能会选择<code class="fe ld le lf lg b">bool</code>，因为它是内存消耗最少的类型，但在围棋中，还有一个选择是使用空的<code class="fe ld le lf lg b">struct</code>。在这篇文章中，我们将对它们进行基准测试，看看是否有什么不同。</p><h1 id="02ce" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">设置</h1><p id="2923" class="pw-post-body-paragraph ke kf it kh b ki mi kk kl km mj ko kp lh mk ks kt li ml kw kx lj mm la lb lc im bi translated">为了获得足够的数据来进行比较，我们首先声明不同类型的<code class="fe ld le lf lg b">map</code>,然后用相应的类型从0到2写/设置它的键⁴ -1，并观察它需要多少时间和内存。</p><p id="147b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">我们可以使用golang中内置的基准测试机制来实现。只有几行代码，我们就可以开始了:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="kb kc kd"><p id="3a9c" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">map[uint]interface{}</code>是加成，预计会比较慢。</p></blockquote><p id="0945" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">由于任何键的读性能应该是相似的，这里我们只对写/设置操作进行基准测试。</p><p id="1d38" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">执行命令可以产生统计数据:</p><figure class="mn mo mp mq gt ju"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="84b3" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">现在让我们检查结果。</p><h1 id="a819" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结果</h1><pre class="mn mo mp mq gt mt lg mu mv aw mw bi"><span id="dffa" class="mx ll it lg b gy my mz l na nb">name                        time/op <br/>SetWithBoolValueWrite        3.27s ± 0% <br/>SetWithStructValueWrite      3.12s ± 0% <br/>SetWithInterfaceValueWrite   5.96s ± 0% <br/> <br/>name                        alloc/op <br/>SetWithBoolValueWrite        884MB ± 0% <br/>SetWithStructValueWrite      802MB ± 0% <br/>SetWithInterfaceValueWrite  1.98GB ± 0%</span></pre><p id="0dda" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">从上面的结果来看，<code class="fe ld le lf lg b"><em class="kg">map[]struct{}</em></code>在大数据集上比<code class="fe ld le lf lg b"><em class="kg">map[]bool</em></code>快5%,内存消耗少10%。(使用<code class="fe ld le lf lg b">map[]interface{}</code>是一场灾难，因为它增加了很多开销，几乎使时间和内存翻倍。)</p><h1 id="3988" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="241d" class="pw-post-body-paragraph ke kf it kh b ki mi kk kl km mj ko kp lh mk ks kt li ml kw kx lj mm la lb lc im bi translated">虽然<code class="fe ld le lf lg b">map[]struct{}</code>速度更快，占用内存更少，但是到了大套的时候就更明显了。所以如果你很急，资源不是你最关心的，使用<code class="fe ld le lf lg b">map[]bool</code>应该完全没问题。如果你追求的是极致的性能，键的类型是uint，那么更推荐bitset。</p><p id="13dd" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">希望你喜欢这篇文章，并随时检查这个<a class="ae nc" href="https://github.com/jeromewu/go-set-benchmark" rel="noopener ugc nofollow" target="_blank">回购</a>的源代码。😃</p></div></div>    
</body>
</html>