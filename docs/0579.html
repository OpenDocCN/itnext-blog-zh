<html>
<head>
<title>Command line scripting with ClojureScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ClojureScript的命令行脚本</h1>
<blockquote>原文：<a href="https://itnext.io/command-line-scripting-with-clojurescript-5e5567367713?source=collection_archive---------2-----------------------#2018-04-04">https://itnext.io/command-line-scripting-with-clojurescript-5e5567367713?source=collection_archive---------2-----------------------#2018-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2aa82c96460b603782afe274376947a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dV1WifSvOi22DKGGXlxT7g.jpeg"/></div></div></figure><p id="349c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文的日文翻译版本可在<a class="ae kw" href="https://qiita.com/t-cool/items/1cf901a67dae55b09746" rel="noopener ugc nofollow" target="_blank"> Qiita </a>上获得。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="18b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢ClojureScript社区最近的发展，用Clojure编写命令行脚本对我来说是一种有趣的体验。主要归功于<a class="ae kw" href="https://github.com/anmonteiro" rel="noopener ugc nofollow" target="_blank"> @anmonteiro </a>开发<a class="ae kw" href="https://github.com/anmonteiro/lumo" rel="noopener ugc nofollow" target="_blank"> lumo </a>和核心ClojureScript团队。</p><p id="94c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为Clojure是编写一次性脚本来处理数据的绝佳语言，因为它内置了操作函数和不可变的结构，所以您不必担心引用和深度克隆。</p><h1 id="dfa1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Lumo运行脚本</h1><p id="fcfb" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">最简单的开始方式是在你的系统上安装<code class="fe mh mi mj mk b">lumo</code>并运行Clojure文件(如果你不想全局安装<code class="fe mh mi mj mk b">lumo</code>，请参见下面的NPM部分)。创建一个名为<code class="fe mh mi mj mk b">hello.cljs</code>的文件，内容如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7a66" class="mt lf iq mk b gy mu mv l mw mx">(println "Hello World!")</span></pre><p id="8229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并使用以下命令运行它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ead4" class="mt lf iq mk b gy mu mv l mw mx">$ npm i -g lumo-cljs ## or other package manager of your choice<br/>$ lumo hello.cljs<br/>Hello World!</span></pre><p id="5a3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再简单不过了。现在，让我们看看如何利用Node。JS APIs编写一个稍微实用一点的程序:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ab35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，<code class="fe mh mi mj mk b">require</code>函数现在可以像它的JS对应物一样工作，并像您使用下面的代码一样拉入JS模块:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1edd" class="mt lf iq mk b gy mu mv l mw mx">const { writeFileSync } = require('fs');<br/>const inputJson = require('./randomUsers.json');</span></pre><p id="3608" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它还可以与使用<code class="fe mh mi mj mk b">npm</code>安装在同一目录下的<code class="fe mh mi mj mk b">node_modules</code>文件夹中的模块一起工作(从<code class="fe mh mi mj mk b">lumo 1.8.0</code>开始)。u̵n̵f̵o̵r̵t̵u̵n̵a̵t̵e̵l̵y̵,̵̵t̵h̵e̵r̵e̵̵i̵s̵n̵'̵t̵̵a̵n̵̵e̵a̵s̵y̵̵w̵a̵y̵̵t̵o̵̵m̵a̵n̵a̵g̵e̵̵d̵e̵p̵e̵n̵d̵e̵n̵c̵i̵e̵s̵̵o̵n̵̵t̵h̵e̵̵c̵l̵o̵j̵u̵r̵e̵̵s̵i̵d̵e̵̵j̵u̵s̵t̵̵y̵e̵t̵̵s̵o̵̵f̵o̵r̵̵n̵o̵w̵̵w̵e̵̵a̵r̵e̵̵s̵t̵u̵c̵k̵̵w̵i̵t̵h̵̵m̵a̵n̵u̵a̵l̵l̵y̵̵h̵a̵n̵d̵l̵i̵n̵g̵̵j̵a̵r̵̵f̵i̵l̵e̵s̵̵w̵h̵e̵r̵e̵̵c̵l̵o̵j̵u̵r̵e̵̵l̵i̵b̵r̵a̵r̵i̵e̵s̵̵a̵r̵e̵̵u̵s̵u̵a̵l̵l̵y̵̵p̵a̵c̵k̵a̵g̵e̵d̵.̵̵(̵t̵a̵k̵e̵̵a̵̵l̵o̵o̵k̵̵a̵t̵̵t̵h̵e̵̵l̵u̵m̵o̵̵w̵i̵k̵i̵̵f̵o̵r̵̵m̵o̵r̵e̵̵d̵e̵t̵a̵i̵l̵s̵.̵)̵<br/><strong class="ka ir">更新2018年10月:</strong>我刚刚发现可以使用Clojure的CLI工具<code class="fe mh mi mj mk b">clj</code>通过<code class="fe mh mi mj mk b">deps.edn</code>(<a class="ae kw" href="https://clojure.org/guides/deps_and_cli" rel="noopener ugc nofollow" target="_blank">https://clojure.org/guides/deps_and_cli</a>)管理和设置Clojure端依赖的类路径。在下面的演示项目中，只需用<code class="fe mh mi mj mk b">-c `clj -Spath`</code>替换lumo标志<code class="fe mh mi mj mk b">-c src</code>，您应该能够要求在<code class="fe mh mi mj mk b">deps.edn</code>文件中指定的所有依赖项。</p><h1 id="5196" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与NPM融合</h1><p id="90ca" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">对于稍微大一点的项目，你可能希望有一个适当的<code class="fe mh mi mj mk b">package.json</code>并依赖于NPM。如果你不想在全球范围内安装或者希望在其他地方发布这个包，你也可以在每个项目的基础上安装<code class="fe mh mi mj mk b">lumo</code>。下面是一个示例项目，它的工作方式与上面的例子类似，但是使用NPM的<code class="fe mh mi mj mk b">request</code>库从<a class="ae kw" href="https://randomuser.me" rel="noopener ugc nofollow" target="_blank"> https://randomuser.me </a>中获取JSON，并将代码分成两个具有适当名称间距的Clojure文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e49d" class="mt lf iq mk b gy mu mv l mw mx">my-tool<br/>|\_ package.json<br/> \_ src<br/>     \_ my_tool<br/>        |\_ core.cljs<br/>         \_ user.cljs</span></pre><p id="68eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Clojure的名称空间系统镜像了目录结构，因此带有ns <code class="fe mh mi mj mk b">my-tool.core</code>的文件必须是<code class="fe mh mi mj mk b">my_tool/core.cljs</code>。</p><p id="329e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">明白了</strong>:名称空间中用连字符分隔的名称必须在文件系统中转换成snake_case。</p><p id="f2bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">core.cljs</code>:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b6f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">user.cljs</code>:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="49bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">package.json</code>:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="02c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">-c</code>标志告诉lumo你的源文件在哪里，而<code class="fe mh mi mj mk b">-m</code>标志指定你的<code class="fe mh mi mj mk b">-main</code>函数在哪个名称空间。您可以使用通常的npm程序运行此工具:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bfc7" class="mt lf iq mk b gy mu mv l mw mx">$ npm install<br/>$ npm start 12 ## fetches 12 users and outputs randomUsers.edn</span></pre><h1 id="8ff3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">REPL发展</h1><p id="709a" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">当然，没有基于REPL的交互式开发，任何Clojure体验都是不完整的。将以下行添加到您的<code class="fe mh mi mj mk b">package.json</code>文件的<code class="fe mh mi mj mk b">scripts</code>部分:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="737e" class="mt lf iq mk b gy mu mv l mw mx">"repl": "lumo -c src -i src/my_tool/core.cljs -n 5777 -r"</span></pre><p id="5237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">-i</code>标志用我们的入口点<code class="fe mh mi mj mk b">core.cljs</code>初始化REPL，<code class="fe mh mi mj mk b">-n</code>标志在端口5777上启动一个套接字REPL用于编辑器集成，最后<code class="fe mh mi mj mk b">-r</code>标志在终端中启动一个REPL。有了它，您可以在运行时执行任意代码，而不会丢失状态:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="88c9" class="mt lf iq mk b gy mu mv l mw mx">$ npm run repl<br/>...<br/>cljs.user=&gt; (in-ns 'my-tool.core) ;; switch to our core namespace<br/>my-tool.core=&gt; (user/parse {:name {:first "john" :last "smith"}})<br/>{:id "c1b61773-133e-434c-afbd-d82b95b814d3",<br/> :username nil,<br/> :password nil,<br/> :email nil,<br/> :full-name "John Smith"}</span></pre><h1 id="cf22" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最后的想法</h1><p id="c7b3" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">虽然目前的工具仍有一些粗糙的地方，但我认为这是用Clojure编写CLI脚本开始成为一个可行的选择和JS的良好替代的时候了。</p><p id="c248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Lumo的启动时间比任何运行在JVM上的clojur东西都要快，所以它是一股新鲜空气。</p><p id="035b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢Clojure，我肯定会推荐你试试这个。</p><h1 id="6436" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><div class="na nb gp gr nc nd"><a href="https://clojurescript.org/news/2017-07-12-clojurescript-is-not-an-island-integrating-node-modules" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">ClojureScript不是孤岛:集成节点模块</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">编辑描述</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">clojurescript.org</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://github.com/anmonteiro/lumo" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">安蒙泰罗/卢莫</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">lumo -快速、跨平台、独立的ClojureScript环境</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jw nd"/></div></div></a></div></div></div>    
</body>
</html>