<html>
<head>
<title>SwiftUI Grid Layout, or Is It Just a Bunch of HStacks?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI网格布局，还是只是一堆HStacks？</h1>
<blockquote>原文：<a href="https://itnext.io/grid-layout-or-is-it-just-a-banch-of-hstack-whats-new-in-swiftui4-f536acdb8fc2?source=collection_archive---------4-----------------------#2022-09-18">https://itnext.io/grid-layout-or-is-it-just-a-banch-of-hstack-whats-new-in-swiftui4-f536acdb8fc2?source=collection_archive---------4-----------------------#2022-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="582e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">三年后，我们终于在SwiftUI中实现了原生网格！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2a8668496ded7daeeae189ccfcc757b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T6jwWQORiOnAiaR6"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">凯莉·西克玛在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="kw kx ky"><p id="8b8e" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文是iOS 16和Mac OS 13中SwiftUI4新功能系列文章的一部分。如果你愿意看以前的文章，这里有第一篇文章的链接:<a class="ae kv" href="https://medium.com/better-programming/swiftui-navigation-stack-how-to-deeplink-and-whats-new-64b1401cb9af" rel="noopener">swift ui navigation stack——如何去深度链接和新功能</a>。其余的你可以直接在我的个人资料页面找到。现在，让我们继续阅读。</p></blockquote><p id="fe2d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">很久以前(或者说毕竟不是很久以前)在Apple API的《很远很远》中，在SwiftUI中实现网格可能会有点痛苦，至少可以这么说。主要是从代码的角度来看。</p><p id="9c48" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但在iOS 16中，我们将获得一个新的网格布局，以及一个名为Layout的自定义布局的实现协议。第二个很快会有一篇单独的文章，但是今天，让我们来关注这篇文章的主角:网格。</p><p id="7a02" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">对于今天的文章，我将使用本系列以前的部分，例如我创建的摊牌库:</p><div class="lz ma gp gr mb mc"><a href="https://github.com/LSWarss/iOS-16-MacOS-13-SwiftUI-Showdown" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd ir gy z fp mh fr fs mi fu fw ip bi translated">GitHub—lsw arss/iOS-16-MAC OS-13-swift ui-摊牌:新的SwiftUI 4为iOS16+提供了示例应用</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">你正面临着iOS16和MacOS13带来的所有新功能。下面你会看到…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq kp mc"/></div></div></a></div><h1 id="525b" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">先决条件</h1><p id="10bc" class="pw-post-body-paragraph kz la iq lc b ld nj jr lf lg nk ju li lw nl ll lm lx nm lp lq ly nn lt lu lv ij bi translated">首先，让我们讨论一下我们将使用什么以及如何使用:</p><h2 id="a745" class="no ms iq bd mt np nq dn mx nr ns dp nb lw nt nu nd lx nv nw nf ly nx ny nh nz bi translated">一个简单的<code class="fe oa ob oc od b">view</code></h2><p id="9120" class="pw-post-body-paragraph kz la iq lc b ld nj jr lf lg nk ju li lw nl ll lm lx nm lp lq ly nn lt lu lv ij bi translated">这代表一个字符，可以是表情符号或文本；没关系。有彩色背景。并且嵌入字符的视图可以缩放到容器的整个宽度。</p><p id="039b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">它看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/571d8d384ee40c9dfbc34ed96eed8219.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*2p-VANKlFIHX9i906a7hXA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">字符视图</figcaption></figure><h2 id="436c" class="no ms iq bd mt np nq dn mx nr ns dp nb lw nt nu nd lx nv nw nf ly nx ny nh nz bi translated">新的<code class="fe oa ob oc od b">GridLayout</code></h2><p id="343d" class="pw-post-body-paragraph kz la iq lc b ld nj jr lf lg nk ju li lw nl ll lm lx nm lp lq ly nn lt lu lv ij bi translated">我们将使用它来创建一个复杂的布局，它将包含以下内容:</p><ul class=""><li id="a37b" class="of og iq lc b ld le lg lh lw oh lx oi ly oj lv ok ol om on bi translated">第一行将有两个角色视图</li><li id="90ca" class="of og iq lc b ld oo lg op lw oq lx or ly os lv ok ol om on bi translated">第二行，有一个角色视图和四个角色视图的集合</li><li id="7117" class="of og iq lc b ld oo lg op lw oq lx or ly os lv ok ol om on bi translated">第三行横跨整个屏幕宽度，只有一个字符视图</li></ul><p id="5cff" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最终效果将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/0fcdecdadb2405e82e8b49637bd52538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zn98SEG_Js6oYC8EMy9B2w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">角色视图网格</figcaption></figure><h2 id="c727" class="no ms iq bd mt np nq dn mx nr ns dp nb lw nt nu nd lx nv nw nf ly nx ny nh nz bi translated">履行</h2><p id="c90f" class="pw-post-body-paragraph kz la iq lc b ld nj jr lf lg nk ju li lw nl ll lm lx nm lp lq ly nn lt lu lv ij bi translated">新<code class="fe oa ob oc od b">GridLayout</code>的实现过程非常简单。您用单词<code class="fe oa ob oc od b">Grid</code>指定它，用<code class="fe oa ob oc od b">GridRow</code>指定行。之后，我们将需要的每个视图传递到呈现的网格中。代码如下:</p><pre class="kg kh ki kj gt ou od ov bn ow ox bi"><span id="2738" class="oy ms iq od b be oz pa l pb pc">struct GridScreen: View {<br/>    var feature: Feature<br/>    <br/>    var body: some View {<br/>        VStack {<br/>            Text(feature.description)<br/>                .font(.footnote)<br/>                .padding()<br/>            <br/>            Spacer()<br/>            <br/>            Grid {<br/>                GridRow {<br/>                    getCharacterView(character: "🙈", .red)<br/>                    getCharacterView(character: "🐍", .orange)<br/>                }<br/>                <br/>                GridRow {<br/>                    getCharacterView(character: "🚀")<br/>                    <br/>                    Grid {<br/>                        GridRow {<br/>                            getCharacterView(character: "💾", .blue)<br/>                            getCharacterView(character: "🏃🏻")<br/>                        }<br/>                        <br/>                        GridRow {<br/>                            getCharacterView(character: "💾", .indigo)<br/>                            getCharacterView(character: "🏃🏻")<br/>                        }<br/>                    }<br/>                }<br/>                <br/>                GridRow {<br/>                    getCharacterView(character: "🦋", .green)<br/>                        .gridCellColumns(2)<br/>                }<br/>            }<br/>        }<br/>    }<br/>    <br/>    @ViewBuilder func getCharacterView(character: String, _ color: Color = .purple) -&gt; some View {<br/>        Text(character)<br/>            .frame(maxWidth: .infinity)<br/>            .padding()<br/>            .background(color.gradient.shadow(.inner(radius: 10)))<br/>            .cornerRadius(10)<br/>            .padding(2)<br/>    }<br/>}</span></pre><p id="f27c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">视图将会是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/371ad302de45517293fe5b12097e202a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eel_-ZMWNKjNuqI9Kw42nw.png"/></div></div></figure><p id="ad7d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这几乎是我们想要的，但是最后一个单元格没有跨越两行。这是为什么呢？这是因为布局是根据每行的元素数量来设置的。因此，如果前两行或后两行的元素比最后一行多，每行的元素数就会增加。</p><p id="26a1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在该怎么办呢？我们只需将这一行添加到最后一行:</p><pre class="kg kh ki kj gt ou od ov bn ow ox bi"><span id="1b95" class="oy ms iq od b be oz pa l pb pc">.gridCellColumns(2)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/8f7cf895cb35f46e9a3f7398f2b740ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27_zuV0HdjQHl0TJVK4Ezg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">代码中最后一个GridRow的网格布局</figcaption></figure><p id="a31a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">用户界面看起来就像我们希望的那样。您还可以删除最后一个元素的<code class="fe oa ob oc od b">GridRow </code>，它将跨越所有单元格。它的代码应该是这样的:</p><pre class="kg kh ki kj gt ou od ov bn ow ox bi"><span id="eb90" class="oy ms iq od b be oz pa l pb pc">                GridRow {<br/>                    getCharacterView(character: "🦋", .green)<br/>                        .gridCellColumns(2)<br/>                }</span></pre><p id="9519" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">结果是一样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/d4ba89ffac41e4f214686f5dd6b15409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPSdMBK95xRJuK9SU1hL9Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">代码中没有最后一个GridRow的网格布局</figcaption></figure><p id="0e30" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如您在上面的代码中看到的，如果您要将更多的行传递到其中一个<code class="fe oa ob oc od b">Grid </code>行中，UI将相应地扩展，这使得它非常容易以一种非常快捷的UI方式使用。</p></div><div class="ab cl pe pf hu pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="ij ik il im in"><p id="7333" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb">感谢阅读！敬请关注更多内容。</em></p></div></div>    
</body>
</html>