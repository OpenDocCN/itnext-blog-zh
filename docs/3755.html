<html>
<head>
<title>Micro In Action, Part 5: Message Broker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Micro在行动，第5部分:消息代理</h1>
<blockquote>原文：<a href="https://itnext.io/micro-in-action-part-5-message-broker-a3decf07f26a?source=collection_archive---------6-----------------------#2020-02-17">https://itnext.io/micro-in-action-part-5-message-broker-a3decf07f26a?source=collection_archive---------6-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bb77710605b042bea5d6c7b4bc278320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDbOP6bqPfyxsoUj7GUJ3Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">微在行动</figcaption></figure><p id="0d44" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是“微在行动”系列文章的第5篇，讨论<a class="ae ld" href="https://micro.mu/" rel="noopener ugc nofollow" target="_blank">微</a>。我们将从基本概念和主题开始，然后转向高级功能。</p><p id="2b02" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">今天的主题是消息代理。</p><p id="abfe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd">上一篇文章</a>中，我们讨论了如何在Micro中使用Pub/Sub。它的优点是简单，缺点是缺乏灵活性。如果您想控制发送和接收消息的底层细节，您将需要接口<code class="fe le lf lg lh b">github.com/micro/go-micro/v2/broker.Broker</code>。</p><p id="7e4b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个接口是微处理器中异步消息处理的核心。其实Pub/Sub也是建立在上面的。</p><p id="91dc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个优雅的设计。它使得Micro像任何其他设计良好的框架一样，具有一个有价值的特性:<strong class="kh iu">提供高层次的抽象，同时允许访问底层API </strong>。</p><p id="fe7b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">高级抽象适用于大多数场景，可以极大地简化问题。低级API用于不适合前者的不常见场景，对开发者没有太多限制。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="1628" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，让我们看一个使用<code class="fe le lf lg lh b">broker.Broker</code>处理消息的例子。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="3b0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面我们将解释代码的关键部分。</p><h1 id="9d46" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">主要功能</h1><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="4975" class="mx lw it lh b gy my mz l na nb">func main() {<br/>   // New Service<br/>   service := micro.NewService(<br/>      micro.Name("<strong class="lh iu">com.foo.broker.example</strong>"), // name the client service<br/>   )</span><span id="ef74" class="mx lw it lh b gy nc mz l na nb">   // Initialise service<br/>   service.Init(<strong class="lh iu">micro.AfterStart</strong>(func() error {<br/>      <strong class="lh iu">brk</strong> := service.Options().Broker<br/>      if err := brk.<strong class="lh iu">Connect</strong>(); err != nil {<br/>          log.Fatalf("Broker Connect error: %v", err)<br/>      }<br/>      go <strong class="lh iu">sub</strong>(brk)<br/>      go <strong class="lh iu">pub</strong>(brk)<br/>      return nil<br/>   }))</span><span id="57ce" class="mx lw it lh b gy nc mz l na nb">service.Run()<br/>}</span></pre><ul class=""><li id="6b7a" class="nd ne it kh b ki kj km kn kq nf ku ng ky nh lc ni nj nk nl bi translated">首先，创建一个名为<strong class="kh iu"> com.foo.broker.example </strong>的<code class="fe le lf lg lh b">micro.Service </code>实例</li><li id="f1b8" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated">然后用选项<code class="fe le lf lg lh b">micro.AfterStart</code>初始化<code class="fe le lf lg lh b">service</code>实例。我们可以确保只有在服务启动后代理才准备好。</li><li id="9971" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated">在回调函数中，我们获取<code class="fe le lf lg lh b">broker.Broker</code>的实例，然后将其传递给函数<code class="fe le lf lg lh b">sub</code>和<code class="fe le lf lg lh b">pub</code>，这两个函数分别用于接收和发送消息。</li></ul><h1 id="79a9" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">功能sub，订阅消息</h1><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="104c" class="mx lw it lh b gy my mz l na nb">func sub(<strong class="lh iu">brk</strong> broker.Broker) {<br/>   // subscribe a topic with queue specified<br/>   _, err := <strong class="lh iu">brk.Subscribe</strong>(topic, func(p <strong class="lh iu">broker.Event</strong>) error {<br/>      fmt.Println("[sub] received message:", string(p.Message().Body), "header", p.Message().Header)<br/>      return nil<br/>   }, <strong class="lh iu">broker.Queue(topic)</strong>)<br/>   if err != nil {<br/>      fmt.Println(err)<br/>   }<br/>}</span></pre><p id="97ea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">传入一个<code class="fe le lf lg lh b">broker.Broker</code>的实例，然后调用它的方法<code class="fe le lf lg lh b">Subscribe</code>。方法签名如下:</p><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="f2af" class="mx lw it lh b gy my mz l na nb">type <strong class="lh iu">Event</strong> interface {<br/>   Topic() string<br/>   Message() *Message<br/>   Ack() error<br/>}</span><span id="8fd5" class="mx lw it lh b gy nc mz l na nb">type <strong class="lh iu">Handler</strong> func(<strong class="lh iu">Event</strong>) error</span><span id="3f73" class="mx lw it lh b gy nc mz l na nb">type <strong class="lh iu">Broker</strong> interface {<br/>    ...</span><span id="51b5" class="mx lw it lh b gy nc mz l na nb"><strong class="lh iu">Subscribe</strong>(topic string, handler <strong class="lh iu">Handler</strong>, opts ...SubscribeOption) (Subscriber, error)<br/>    <br/>    ...<br/>}</span></pre><p id="8288" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个参数是订阅主题。</p><p id="d7dc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二个参数是一个事件处理程序，它是一个回调函数，在接收到新事件时将被执行。这个处理程序的参数是<code class="fe le lf lg lh b">broker.Event</code>，从中可以获取主题和消息对象<code class="fe le lf lg lh b">*broker.Message</code>。此外，该接口提供了用于手动确认的方法<code class="fe le lf lg lh b">Ack</code>(通常与<code class="fe le lf lg lh b">DisableAutoAck</code>选项一起使用，这将在下一段中解释)。</p><p id="9fc7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第三个参数是<code class="fe le lf lg lh b">broker.SubscribeOption</code>，其含义与<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd">上篇</a>中提到的<code class="fe le lf lg lh b">server.SubscriberOption</code>一致。Micro中有三个内置的订阅选项，<code class="fe le lf lg lh b">broker.DisableAutoAck, broker.Queue, broker.SubscribeContext</code>，它们与<code class="fe le lf lg lh b">server.SubscriberOption</code>也是一致的。不同之处在于，任何代理插件都可以实现额外的<code class="fe le lf lg lh b">broker.SubscribeOption</code>，提供特定于插件的功能。</p><p id="8c84" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">例如，<a class="ae ld" href="https://github.com/micro/go-plugins/tree/master/broker/rabbitmq" rel="noopener ugc nofollow" target="_blank"> RabbitMQ插件</a>提供了一个名为<strong class="kh iu"> DurableQueue </strong>的选项来控制队列的持久性:</p><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="4cf2" class="mx lw it lh b gy my mz l na nb">...<br/>import "github.com/micro/go-plugins/broker/rabbitmq"<br/>...</span><span id="c678" class="mx lw it lh b gy nc mz l na nb">_, err := broker.Subscribe(topic, func(p broker.Event) error {<br/>   ...<br/>   p.<strong class="lh iu">Ack</strong>()<br/>   return nil<br/>}, broker.Queue(topic), <strong class="lh iu">broker.DisableAutoAck(), </strong><strong class="lh iu">rabbitmq.DurableQueue()，</strong>)</span></pre><p id="1c76" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:当使用选项<code class="fe le lf lg lh b">DisableAutoAck</code>时，我们也调用<code class="fe le lf lg lh b">Ack</code>方法来手动确认。</p><p id="a8af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd">上一篇文章</a>所述，除了RabbitMQ插件，还有其他可用的broker插件如Kafka插件、NSQ插件等。所有这些插件和选项都可以以同样的方式使用。</p><p id="7fa2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这个例子中，我们遵循前面提到的最佳实践<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd"/>:<strong class="kh iu">总是显式地设置队列名</strong>。所以我们将<code class="fe le lf lg lh b">broker.Queue (topic)</code>作为该方法的第三个参数。</p><p id="10be" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">到目前为止，函数<code class="fe le lf lg lh b">sub</code>已经完成了消息订阅。当收到新消息时，将输出消息头和消息体的日志。</p><h1 id="257e" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">功能发布，发布消息</h1><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="1068" class="mx lw it lh b gy my mz l na nb">func pub(<strong class="lh iu">brk</strong> broker.Broker) {<br/>   i := 0<br/>   for range time.Tick(time.<em class="nr">Second</em>) {<br/>      // build a message<br/>      msg := <strong class="lh iu">&amp;broker.Message</strong>{<br/>         <strong class="lh iu">Header</strong>: map[string]string{<br/>            "id": fmt.Sprintf("%d", i),<br/>         },<br/>         <strong class="lh iu">Body</strong>: []byte(fmt.Sprintf("%d: %s", i, time.Now().String())),<br/>      }<br/>      // publish it<br/>      if err := <strong class="lh iu">brk.Publish</strong>(topic, msg); err != nil {<br/>         log.Printf("[pub] failed: %v", err)<br/>      } else {<br/>         fmt.Println("[pub] pubbed message:", string(msg.Body))<br/>      }<br/>      i++<br/>   }<br/>}</span></pre><p id="2980" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这段代码片段中的核心函数是<code class="fe le lf lg lh b">brk.Publish</code>，其签名如下:</p><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="cbae" class="mx lw it lh b gy my mz l na nb">type <strong class="lh iu">Message</strong> struct {<br/>   Header map[string]string<br/>   Body   []byte<br/>}<br/>type <strong class="lh iu">Broker</strong> interface {<br/>    ...</span><span id="01e9" class="mx lw it lh b gy nc mz l na nb"><strong class="lh iu">Publish</strong>(topic string, msg *<strong class="lh iu">Message</strong>, opts ...<strong class="lh iu">PublishOption</strong>) error</span><span id="eaf5" class="mx lw it lh b gy nc mz l na nb">...<br/>}</span></pre><p id="4f9a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个参数表示消息主题。</p><p id="1715" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二个是消息对象，类型是<code class="fe le lf lg lh b">*broker.Message</code>。每条消息可以包含多个字符串头和一个字节片作为正文。</p><p id="c456" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第三个参数是可选的，类型为<code class="fe le lf lg lh b">borker.PublishOption</code>。它表示发送消息时可以提供的附加选项。Micro没有内置选项，但是一个代理插件可以提供自己的选项，所以这些选项是特定于插件的。</p><p id="a7d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以RabbitMQ插件为例，它提供了选项<code class="fe le lf lg lh b">DeliveryMode</code>来控制消息持久性。我们可以从以下几个方面使用它(<code class="fe le lf lg lh b">mode</code>值的含义来自RabbitMQ文档):</p><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="153b" class="mx lw it lh b gy my mz l na nb">...<br/>import "github.com/micro/go-plugins/broker/rabbitmq"<br/>...</span><span id="bffa" class="mx lw it lh b gy nc mz l na nb">const mode = 2 // Transient (0 or 1) or Persistent (2)<br/>if err := <strong class="lh iu">broker.Publish</strong>(topic, msg, <strong class="lh iu">rabbitmq.DeliveryMode(</strong>mode<strong class="lh iu">)</strong>); err != nil {<br/>         log.Printf("[pub] failed: %v", err)<br/>} else {<br/>         fmt.Println("[pub] pubbed message:", string(msg.Body))<br/>}<br/>...</span></pre><p id="45ef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">代理插件的所有发布选项都与此相同。</p><p id="f584" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">解释完<code class="fe le lf lg lh b">broker.Publish </code>功能后，理解<code class="fe le lf lg lh b">pub</code>功能就变得非常容易了。</p><p id="fb2c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用<code class="fe le lf lg lh b">time.Tick</code>每秒循环一次。在每个循环中，创建一个<code class="fe le lf lg lh b">*broker.Message</code>并为其设置一个名为<strong class="kh iu"> id </strong>的头，将当前时间设置为消息体。然后发出去。</p><h1 id="83a6" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">跑起来</h1><p id="44c6" class="pw-post-body-paragraph kf kg it kh b ki ns kk kl km nt ko kp kq nu ks kt ku nv kw kx ky nw la lb lc im bi translated">准备好代码后，我们可以启动示例程序了。然后，我们将看到以下输出，每秒钟都会追加新的日志:</p><pre class="lp lq lr ls gt mt lh mu mv aw mw bi"><span id="7d22" class="mx lw it lh b gy my mz l na nb">$ go run main.go <br/>2020-04-03 12:34:38  level=info Starting [service] com.foo.broker.example<br/>2020-04-03 12:34:38  level=info Server [grpc] Listening on [::]:53616<br/>2020-04-03 12:34:38  level=info Registry [mdns] Registering node: com.foo.broker.example-d70b788e-344b-45bd-ae6c-4d78d1bd7039<br/>[pub] pubbed message: 0: 2020-04-03 12:34:39.170926 +0800 CST m=+1.152448710<br/>[sub] received message: 0: 2020-04-03 12:34:39.170926 +0800 CST m=+1.152448710 header map[id:0]<br/>[pub] pubbed message: 1: 2020-04-03 12:34:40.169054 +0800 CST m=+2.150609178<br/>[sub] received message: 1: 2020-04-03 12:34:40.169054 +0800 CST m=+2.150609178 header map[id:1]<br/>...</span></pre><p id="5a48" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">虽然在这个例子中<code class="fe le lf lg lh b">pub</code>和<code class="fe le lf lg lh b">sub</code>在同一个进程中运行，但这不是强制性的，这只是为了演示的方便。Micro封装了底层的跨进程通信，我们可以在单独的程序中运行它们，而不用考虑通信细节。</p><p id="66b5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注:此示例源自<a class="ae ld" href="https://github.com/micro/examples/blob/master/broker/main.go" rel="noopener ugc nofollow" target="_blank">官方示例</a>。我们没有使用原来的例子，因为我认为官方的例子不合适，可能会误导开发者。相比之下，你会发现我们的版本更加一致和简单:<code class="fe le lf lg lh b">micro.Service</code>始终是中枢，不需要考虑命令行解析问题，也不需要单独处理broker连接和初始化。</p><h1 id="0870" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="11b7" class="pw-post-body-paragraph kf kg it kh b ki ns kk kl km nt ko kp kq nu ks kt ku nv kw kx ky nw la lb lc im bi translated">当Pub/Sub不能满足你的需求时，你可以随时求助于<code class="fe le lf lg lh b">broker.Broker</code>来访问底层API。</p><p id="bc2f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所谓的“低级”意味着我们可以获得对底层消息代理系统的更详细的控制。<code class="fe le lf lg lh b">broker.Broker</code>由不同的代理插件实现，适应不同的代理系统，给了我们很大的灵活性。</p><p id="f508" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe le lf lg lh b">broker.Broker</code>和Pub/Sub共同为微开发者提供了一个完整的异步消息处理开发框架。这真是一个聪明而优雅的设计。</p><p id="c589" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">未完待续。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="3a96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另请参见:</p><ul class=""><li id="8c33" class="nd ne it kh b ki kj km kn kq nf ku ng ky nh lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-getting-started-a79916ae3cac"> Micro在行动，第1部分:入门</a></li><li id="be69" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-2-71230f01d6fb"> Micro In Action，第2部分:Bootstrap终极指南</a></li><li id="385e" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part-3-calling-a-service-55d865928f11">微在行动，第3部分:调用服务</a></li><li id="d003" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part4-pub-sub-564f3b054ecd">微在行动，第四部分:发布/订阅</a></li><li id="91cf" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-part6-service-discovery-f988988e5936">微在行动，第6部分:服务发现</a></li><li id="741c" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-7-circuit-breaker-rate-limiter-431ccff6a120">微动作，第7部分:断路器&amp;限速器</a></li><li id="0300" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/micro-in-action-coda-distributed-cron-job-a2b577885b24">微操作，Coda:分布式Cron作业</a></li><li id="6302" class="nd ne it kh b ki nm km nn kq no ku np ky nq lc ni nj nk nl bi translated"><a class="ae ld" href="https://medium.com/@dche423/micro-in-action-1be29b057f2d" rel="noopener">微在行动的索引页</a></li></ul></div></div>    
</body>
</html>