<html>
<head>
<title>Developing Web apps using QML and Qt for WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用QML和Qt为WebAssembly开发Web应用</h1>
<blockquote>原文：<a href="https://itnext.io/developing-web-apps-using-qml-and-qt-for-webassembly-aa84453f2f61?source=collection_archive---------0-----------------------#2019-11-10">https://itnext.io/developing-web-apps-using-qml-and-qt-for-webassembly-aa84453f2f61?source=collection_archive---------0-----------------------#2019-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ed4b0dadc22d2c424c0440d0106ef0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AWs6u3mPaPXzt6iY2s7Dw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作为HTML应用程序运行的QML应用程序</figcaption></figure><p id="52b0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这看起来很有趣，对吧？</p><p id="57ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<a class="ae ld" href="https://medium.com/@petar.koretic/why-you-should-use-qt-qml-for-you-next-cross-platform-application-part-1-desktop-5e6d8856b7b4" rel="noopener">的第1部分</a>中的<a class="ae ld" href="https://medium.com/@petar.koretic/why-you-should-use-qt-qml-for-you-next-cross-platform-application-part-1-desktop-5e6d8856b7b4" rel="noopener">为什么你应该为你的下一个跨平台应用使用Qt/QML</a>中，我们提到了用于WebAssembly 的<a class="ae ld" href="https://doc.qt.io/qt-5/wasm.html" rel="noopener ugc nofollow" target="_blank"> Qt。这是大约10个月前。</a></p><p id="1510" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在软件开发中，<a class="ae ld" href="https://github.blog/2019-11-06-the-state-of-the-octoverse-2019/" rel="noopener ugc nofollow" target="_blank">进展很快</a>，WebAssembly 的<a class="ae ld" href="https://doc.qt.io/qt-5/wasm.html" rel="noopener ugc nofollow" target="_blank"> Qt已经从技术预览版转移到支持平台。</a></p><p id="cbc1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，在这篇文章中，我们将探索使用<a class="ae ld" href="https://doc.qt.io/qt-5/qtqml-index.html" rel="noopener ugc nofollow" target="_blank"> QML </a>构建Web应用。</p><blockquote class="le lf lg"><p id="5c3f" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc im bi translated">Qt for WebAssembly是一个<a class="ae ld" href="https://doc.qt.io/qt-5/qpa.html" rel="noopener ugc nofollow" target="_blank">平台插件</a>，可以让你构建Qt应用程序，它可以集成到你的网页中。它不需要任何客户端安装，并减少了服务器端的资源使用。</p></blockquote><h1 id="8cf0" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">web程序集</h1><blockquote class="le lf lg"><p id="c4c5" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc im bi translated">WebAssembly(缩写为Wasm)是基于堆栈的虚拟机的二进制指令格式。Wasm被设计为C/C++/Rust等高级语言编译的可移植目标，支持客户端和服务器应用程序在web上的部署。</p><p id="869c" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc im bi translated">这种格式几乎和本机代码一样快，现在所有主流web浏览器都支持它。</p></blockquote><p id="5005" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本质上，<a class="ae ld" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>允许用不同语言编写的代码在任何嵌入了<a class="ae ld" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>虚拟机的环境中执行。</p><p id="81bd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">其中一个环境是网络浏览器，这是它有趣的地方，因为几乎所有其他平台Qt都已经支持了。</p><h1 id="bb95" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设置</h1><p id="b1d7" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">设置可能仍然有点棘手，但一如既往，关于这个主题的官方文件会让你明白。</p><p id="0d98" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本质上，我们需要做两件事，为Webassembly设置Emscripten编译器和Qt。</p><h2 id="e987" class="mo lm it bd ln mp mq dn lr mr ms dp lv kq mt mu lz ku mv mw md ky mx my mh mz bi translated">Emscripten</h2><p id="6d5a" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">在linux上，它大致如下:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="8ca7" class="mo lm it nf b gy nj nk l nl nm"># fetch Emscripten SDK and install target version<br/>git clone <a class="ae ld" href="https://github.com/emscripten-core/emsdk.git" rel="noopener ugc nofollow" target="_blank">https://github.com/emscripten-core/emsdk.git</a><br/>cd emsdk<br/>./emsdk install sdk-1.38.30-64bit<br/>./emsdk activate --embedded sdk-1.38.30-64bit<br/>source emsdk_env.sh</span></pre><p id="c7f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有关确切的要求和说明，请查阅<a class="ae ld" href="https://emscripten.org/docs/getting_started/downloads.html#sdk-download-and-install" rel="noopener ugc nofollow" target="_blank">官方文档</a>。最后，如果一切顺利，至少会有<code class="fe nn no np nf b">em++</code>在你的道路上。</p><p id="fa5f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，1.38.30是推荐的版本，也有多线程支持，所以现在不要尝试其他版本，因为他们会有问题(测试:)</p><blockquote class="le lf lg"><p id="1130" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc im bi translated">源文件emsdk_env.sh对于设置有效的Emscripten环境很重要，所以不要忘记运行它(每次打开新的终端时)</p></blockquote><h2 id="7a9c" class="mo lm it bd ln mp mq dn lr mr ms dp lv kq mt mu lz ku mv mw md ky mx my mh mz bi translated">Qt WebAssembly</h2><p id="55f0" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">这就更简单了。从<a class="ae ld" href="https://www.qt.io/download" rel="noopener ugc nofollow" target="_blank"> Qt下载页面</a>下载Qt安装程序，或者打开现有的<a class="ae ld" href="https://doc.qt.io/qt-5/gettingstarted.html#updating-or-removing-qt" rel="noopener ugc nofollow" target="_blank"> Qt维护工具</a>如果你已经安装了它。</p><p id="1003" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这两种情况下，您只需要为WebAssembly选择一个Qt，在我的例子中，我在撰写本文时使用了最新的Qt，5.13.2。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/b22f66c424d3000722d337e488632d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF9KMNHHaFMSjoUS6FbNpA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安装Qt WebAssembly</figcaption></figure><p id="262b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">安装完成后，我们就可以开始我们的Hello World了。</p><h1 id="eba2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Hello WebAssembly</h1><p id="de35" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">那么让我们从一个明显的例子开始。</p><p id="1e22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建一个包含基本内容的新Qt/Qml项目:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="06ab" class="mo lm it nf b gy nj nk l nl nm">import QtQuick 2.13<br/>import QtQuick.Window 2.13</span><span id="abe3" class="mo lm it nf b gy nr nk l nl nm">Window {<br/>    visible: true<br/>    width: 640<br/>    height: 480<br/>    title: qsTr("Hello WebAssembly")</span><span id="2bdd" class="mo lm it nf b gy nr nk l nl nm">    Text {<br/>        anchors.centerIn: parent<br/>        text: qsTr("Hello WebAssembly")<br/>        color: "black"<br/>    }<br/>}</span></pre><p id="464b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们在本地平台上构建并运行它，我们会得到:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/9fb0db650ebd2d6e8b5ebbb025170baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbC6E9-e1ZOGSUMr9LrEwg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这里没有多少WebAssembly</figcaption></figure><p id="6837" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">嗯，这正是我们想要的，并按预期工作。</p><p id="2f09" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，让我们继续真正的WebAssembly。如果没有，你必须如上所述设置脚本环境:<code class="fe nn no np nf b">source /path-to-emsdk/emsdk_env.sh</code></p><p id="cf22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">转到您的新项目并创建一个<code class="fe nn no np nf b">build</code>目录(或者您想怎么称呼它都可以，以进行一次源代码外的编译——可选)。然后调用WebAssembly支持的new <code class="fe nn no np nf b">qmake</code>:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="b567" class="mo lm it nf b gy nj nk l nl nm">cd /path-to-hello-webassembly-project<br/>mkdir build &amp;&amp; cd build<br/>/path-to-qt-with-webassembly/5.13.2/wasm_32/bin/qmake ..<br/>make </span></pre><p id="8ba1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将需要一段时间，尤其是在第一次运行。后续运行将有所改善，但目前在我的i7–7700上仍然需要大约2分32秒。<br/>请注意，<code class="fe nn no np nf b">make -j</code>标志并不十分有用，因为Emscripten构建已经并行化。</p><p id="e5dc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完成后，你将在你的构建目录中得到一堆文件，其中一个是<code class="fe nn no np nf b">projectname.html</code>文件。为了在浏览器中运行它，我们通常需要一个网络服务器。您可以使用任何您想要的来服务这些静态文件，但是也有一个方便的<a class="ae ld" href="https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html" rel="noopener ugc nofollow" target="_blank"> emrun命令行工具</a>可以用于此目的，因为它已经作为Emscripten环境的一部分可用。<br/>因此，要在Firefox网络浏览器中打开我们的应用程序，可以这样做:<code class="fe nn no np nf b">emrun — browser=firefox *.html</code></p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/69badc96a24d45bb5682df22d0f7c31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1M7I4T_HTSzrhhFjHKSi4A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">看起来完全一样，但这次是一个在浏览器中运行的HTML应用程序</figcaption></figure><p id="9620" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那感觉很好，不是吗？就连标签标题也如我们所料更新为应用标题。<br/>我们已经知道我们可以在多个平台上构建和运行这款应用，但现在无需任何代码更改，我们也可以在网络浏览器中运行它。干净利落。</p><h1 id="ca7e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">“真正的”应用程序</h1><p id="c395" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">构建一个简单的<code class="fe nn no np nf b">Hello WebAssembly</code>很有趣，但如果能看看它是否能处理一个真正的应用就更好了。为了方便起见，我们可以使用<a class="ae ld" href="https://medium.com/@petar.koretic/why-you-should-use-qt-qml-for-you-next-cross-platform-application-part-1-desktop-5e6d8856b7b4" rel="noopener">前几篇文章</a>中介绍的应用程序。</p><h2 id="65ab" class="mo lm it bd ln mp mq dn lr mr ms dp lv kq mt mu lz ku mv mw md ky mx my mh mz bi translated">待办事项应用程序</h2><p id="8fac" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">在<a class="ae ld" href="https://medium.com/@petar.koretic/why-you-should-use-qt-qml-for-your-next-cross-platform-application-part-2-mobile-todo-app-b4eb08fa8415" rel="noopener">为什么你应该使用Qt/QML进行跨平台开发</a>系列的<a class="ae ld" href="https://medium.com/@petar.koretic/why-you-should-use-qt-qml-for-your-next-cross-platform-application-part-2-mobile-todo-app-b4eb08fa8415" rel="noopener">第二部分</a>中，我们开发了一个小的Todo应用。让我们重复构建过程，看看这是否可以作为Web应用程序。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c630" class="mo lm it nf b gy nj nk l nl nm">git clone <a class="ae ld" href="https://github.com/pkoretic/Todo" rel="noopener ugc nofollow" target="_blank">https://github.com/pkoretic/Todo</a> &amp;&amp; cd Todo<br/>mkdir build &amp;&amp; cd build<br/>/path-to-qt-with-webassembly/5.13.2/wasm_32/bin/qmake ..<br/>make<br/>emrun --browser=firefox *.html</span></pre><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/185772835fb86d3edd86aded45758ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScDMBMZi3KlvaX0RilT49A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在QML开发的Todo应用程序作为HTML应用程序运行</figcaption></figure><p id="d629" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一次尝试，它确实工作，看起来几乎完全一样，我们开发它！</p><p id="8cae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意:我们替换了unicode plus /- heavy符号，因为当前字体不支持这些符号:</p><blockquote class="le lf lg"><p id="9cbb" class="kf kg lh kh b ki kj kk kl km kn ko kp li kr ks kt lj kv kw kx lk kz la lb lc im bi translated">应用程序无法访问系统字体。字体文件必须随应用程序一起分发，例如在Qt资源中。Qt for WebAssembly本身就嵌入了一种这样的字体。</p></blockquote><h2 id="e22d" class="mo lm it bd ln mp mq dn lr mr ms dp lv kq mt mu lz ku mv mw md ky mx my mh mz bi translated">预测应用程序</h2><p id="bdc2" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">转向更复杂的东西。</p><p id="9b05" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<a class="ae ld" href="https://medium.com/@petar.koretic/why-you-should-use-qt-qml-for-your-next-cross-platform-application-part-3-tv-forecast-app-91e3901ed64f" rel="noopener"> part-3 </a>中，我们做了一个电视应用。这个更大，使用图像和网络请求。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ed4b0dadc22d2c424c0440d0106ef0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AWs6u3mPaPXzt6iY2s7Dw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在QML开发的Todo应用程序作为HTML应用程序运行</figcaption></figure><p id="8c8a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完全没有代码变化的工作，甚至我们的关键导航。我们当时没有实现触摸支持，所以这里不可能有点击，但这将是一个小的增加，因为<a class="ae ld" href="https://doc.qt.io/qt-5/qml-qtquick-controls2-button.html" rel="noopener ugc nofollow" target="_blank">按钮</a>已经被使用。</p><h1 id="250b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">QtCreator</h1><p id="dd54" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">这将需要一篇单独的文章来了解细节，但是添加对QtCreator的支持就像<a class="ae ld" href="https://doc.qt.io/qtcreator/creator-targets.html" rel="noopener ugc nofollow" target="_blank">用Emscripten编译器创建一个新的工具包</a>一样简单。</p><p id="200a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它需要在工具—选项—套件—编译器中添加定制的<code class="fe nn no np nf b">emcc</code> / <code class="fe nn no np nf b">em++</code>编译器，在Qt版本中添加新的<code class="fe nn no np nf b">qmake</code>。然后剩下的部分就是使用官方文件中描述的<a class="ae ld" href="https://doc.qt.io/qtcreator/creator-targets.html" rel="noopener ugc nofollow" target="_blank">创建一个工具包，并构建你的应用程序。</a></p><h1 id="8e02" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="7409" class="pw-post-body-paragraph kf kg it kh b ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc im bi translated">尽管它出乎意料的好，但是仍然有一些重要的限制，你可以在<a class="ae ld" href="https://doc.qt.io/qt-5/qtwebassembly-platform-notes.html" rel="noopener ugc nofollow" target="_blank">官方平台说明</a>中读到。</p><p id="6670" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">构建时间也不是最快的，但请记住，这些都是优化的构建<code class="fe nn no np nf b">(-O3)</code>，没有必要在每次更改时都将应用程序编译为HTML，因为我们可以在默认平台上快速测试它。</p><p id="304b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<a class="ae ld" href="https://doc.qt.io/qt-5/wasm.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中还有很多例子，最近发布了一个非常好的例子——<a class="ae ld" href="https://www.qt.io/blog/web-based-qt-design-viewer" rel="noopener ugc nofollow" target="_blank">基于Web的Qt设计查看器</a>，所以请确保查看这些例子，以便进一步阅读。</p><p id="c3f5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们可以看到这是一个非常好的进步。请记住，Qt 5.13.x是第一个以Qt for WebAssmbly作为支持平台的版本，因此我们可以期待未来会有更好的事情发生。</p><p id="16ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">快乐编码。</p></div></div>    
</body>
</html>