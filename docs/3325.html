<html>
<head>
<title>JavaScript Fundamentals: Understanding Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:理解正则表达式</h1>
<blockquote>原文：<a href="https://itnext.io/javascript-fundamentals-understanding-regex-fd81891375e0?source=collection_archive---------0-----------------------#2019-11-22">https://itnext.io/javascript-fundamentals-understanding-regex-fd81891375e0?source=collection_archive---------0-----------------------#2019-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aff9ec72cdeed1a6d778865a5f2dc8d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmcPPNg2oD_d3_YQfkbu4Q.png"/></div></div></figure><p id="753b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript正则表达式(或<strong class="kd iu"> Regex </strong>)是一个字符序列，我们可以利用它来有效地处理字符串。使用这种语法，我们可以:</p><ul class=""><li id="d8c3" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">在</strong>中搜索字符串中的文本</li><li id="cceb" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><strong class="kd iu">替换字符串中的</strong>子字符串</li><li id="a407" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><strong class="kd iu">从字符串中提取</strong>信息</li></ul><p id="52bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">追溯到20世纪50年代，正则表达式被形式化为字符串处理算法中的模式搜索概念。</p><p id="82a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript在语言中直接内置了正则表达式支持。对正则表达式的深刻理解将使你成为一名更有效率的程序员。所以让我们开始吧！</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="fe53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🤓<em class="lu">想了解最新的web开发吗？</em>T15】🚀想要将最新的新闻直接发送到您的收件箱吗？<br/>🎉加入一个不断壮大的设计师&amp;开发者社区！</p><p id="9aa1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在这里订阅我的简讯→</strong><a class="ae lv" href="https://easeout.eo.page/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">https://ease out . EO . page</strong></a></p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="970f" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">一个非常基本的正则表达式模式</h1><p id="2399" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">这是一个基本模式:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="95be" class="ni lx it ne b gy nj nk l nl nm">var regex = /hello/;</span><span id="9ca1" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hello world'));  <br/>// true</span></pre><p id="857d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们只是将文字文本与测试字符串进行匹配。我们稍后将详细研究正则表达式测试方法..</p><h1 id="513f" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">为什么要使用正则表达式？</h1><p id="2216" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">如前所述，正则表达式是描述字符串数据模式的一种方式。我们可以使用它们来检查字符串，例如查找电子邮件地址——通过匹配正则表达式定义的模式。</p><h1 id="c565" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">创建正则表达式</h1><p id="3add" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">在JavaScript中，我们可以用两种方法创建正则表达式:要么使用RegExp构造函数，要么使用正斜杠<code class="fe nt nu nv ne b">/</code>将regex模式括起来。</p><h2 id="b439" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated">构造函数方法:</h2><p id="c4b4" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">语法是这样的:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="04f4" class="ni lx it ne b gy nj nk l nl nm">new RegExp(pattern[, flags])</span></pre><p id="1d36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比如说:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9dc0" class="ni lx it ne b gy nj nk l nl nm">var regexConst = new RegExp('abc');</span></pre><h2 id="4e9c" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated">字面法:</h2><p id="0ba1" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">语法是这样的:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8a44" class="ni lx it ne b gy nj nk l nl nm">/pattern/flags</span></pre><p id="c4fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个例子:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="200a" class="ni lx it ne b gy nj nk l nl nm">var regexLiteral = /abc/;</span></pre><p id="592b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意:标志是可选的，我们将在本文的后面看到它们！</p><p id="87e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在需要动态创建正则表达式的情况下，需要使用构造函数方法。</p><p id="c91e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这两种情况下，结果都将给出一个regex对象——它将具有相同的方法和属性，供我们使用。</p><h1 id="f496" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">正则表达式方法</h1><p id="250d" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">当测试我们的正则表达式时，我们通常使用两种方法之一:<code class="fe nt nu nv ne b">RegExp.prototype.test()</code>或<code class="fe nt nu nv ne b">RegExp.prototype.exec()</code>。</p><h2 id="bd47" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated">正则表达式.原型.测试()</h2><p id="2218" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">我们使用这种方法来测试是否找到了匹配。它接受我们用正则表达式测试的字符串，并根据是否找到匹配返回<code class="fe nt nu nv ne b">true </code>或<code class="fe nt nu nv ne b">false</code>。</p><p id="b3fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看一个例子:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2bdb" class="ni lx it ne b gy nj nk l nl nm">var regex = /hello/; <br/>var str = 'hello world';<br/>var result = regex.test(str);</span><span id="6335" class="ni lx it ne b gy nn nk l nl nm">console.log(result); <br/>// returns 'true' as hello is present in our string</span></pre><h2 id="29e3" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated">正则表达式.原型.执行()</h2><p id="2f18" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">我们使用这个方法来接收所有匹配组的数组。它接受我们用正则表达式测试的字符串。</p><p id="fc3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个例子:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9c8c" class="ni lx it ne b gy nj nk l nl nm">var regex = /hello/;<br/>var str = 'hello world';<br/>var result = regex.exec(str);<br/>console.log(result);</span><span id="3a91" class="ni lx it ne b gy nn nk l nl nm">// returns [ 'hello', index: 0, input: 'hello world', groups: undefined ]</span></pre><p id="c8a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，<code class="fe nt nu nv ne b">‘hello’</code>是我们匹配的模式，<code class="fe nt nu nv ne b">index</code>是正则表达式开始的地方，&amp; <code class="fe nt nu nv ne b">input</code>是被传递的字符串。</p><p id="31b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于本文的其余部分，我们将使用<code class="fe nt nu nv ne b">test()</code>方法。</p><h1 id="8b20" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">正则表达式的力量</h1><p id="3656" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">到目前为止，我们已经看到了如何创建简单的正则表达式模式。这真的只是冰山一角。现在让我们深入语法，看看正则表达式在处理更复杂的任务方面的全部能力！</p><p id="4939" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更复杂任务的一个例子是，如果我们需要匹配多个电子邮件地址。通过使用语法中定义的特殊字符，我们可以做到这一点！</p><p id="d153" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看一看，这样我们可以更全面地掌握&amp;因此在我们的程序中使用正则表达式。</p><h1 id="854a" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">标志:</h1><p id="d896" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">在任何正则表达式中，我们可以使用以下标志:</p><ul class=""><li id="58c6" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">g</code>:多次匹配模式</li><li id="7c19" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">i</code>:使正则表达式不区分大小写</li><li id="2a16" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">m</code>:启用多行模式。其中<code class="fe nt nu nv ne b">^</code>和<code class="fe nt nu nv ne b">$</code>匹配整个字符串的开始和结束。如果没有这个，多行字符串匹配每一行的开始和结束。</li><li id="c60d" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">u</code>:启用对unicode的支持</li><li id="fd4c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">s</code>:单行<em class="lu">的简称</em>，它使<code class="fe nt nu nv ne b">.</code>也匹配新的行字符</li></ul><p id="f5f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">标志也可以组合在一个正则表达式中&amp;标志的顺序无关紧要。它们被添加到regex <strong class="kd iu">文字</strong>中字符串的末尾:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="16dd" class="ni lx it ne b gy nj nk l nl nm">/hello/ig.test('HEllo')<br/>// returns true</span></pre><p id="147c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果使用RegExp对象<strong class="kd iu">构造函数</strong>，它们将作为第二个参数添加:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0ef0" class="ni lx it ne b gy nj nk l nl nm">new RegExp('hello', 'ig').test('HEllo') <br/>// returns true</span></pre><h1 id="2a1e" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">角色组:</h1><h2 id="3127" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated">字符集</h2><p id="560c" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">我们使用字符集来匹配单个位置的不同字符。它们将字符串中的任何单个字符与括号内的字符进行匹配:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1570" class="ni lx it ne b gy nj nk l nl nm">var regex = /[hc]ello/;</span><span id="6fc7" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hello'));<br/>// returns true</span><span id="b1d8" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('cello'));<br/>// returns true</span><span id="9fab" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('jello'));<br/>// returns false</span></pre><h2 id="aaae" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated"><strong class="ak">被否定的字符集【^abc】</strong></h2><p id="7056" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">它匹配方括号中的<strong class="kd iu">而不是</strong>的任何内容:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8a6e" class="ni lx it ne b gy nj nk l nl nm">var regex = /[^hc]ello/;</span><span id="7154" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hello'));<br/>// returns false</span><span id="ba20" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('cello'));<br/>// returns false</span><span id="4c48" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('jello'));<br/>// returns true</span></pre><h2 id="293d" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated"><strong class="ak">范围[a-z] </strong></h2><p id="9f32" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">如果我们想在一个位置匹配字母表中的所有字母，我们可以使用范围。比如:<strong class="kd iu">【A-j】</strong>会匹配从A到j的所有字母，我们也可以使用类似<strong class="kd iu">【0–9】</strong>这样的数字或者类似<strong class="kd iu">【A-Z】</strong>这样的大写字母:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="9716" class="ni lx it ne b gy nj nk l nl nm">var regex = /[a-z]ello/;</span><span id="41af" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hello'));<br/>// returns true</span><span id="d663" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('cello'));<br/>// returns true</span><span id="263e" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('jello'));<br/>// returns true</span></pre><p id="21ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在我们测试的范围内至少存在一个字符，它将返回true:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b3e0" class="ni lx it ne b gy nj nk l nl nm">/[a-z]/.test('a')  // true<br/>/[a-z]/.test('1')  // false<br/>/[a-z]/.test('A')  // false (as our range is in lower case)<br/>/[a-c]/.test('d')  // false<br/>/[a-c]/.test('cd') // true (as 'c' is in the range)</span></pre><p id="5f1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以使用<code class="fe nt nu nv ne b">-</code>组合范围:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b4c5" class="ni lx it ne b gy nj nk l nl nm">/[A-Z-0-9]/</span><span id="ef42" class="ni lx it ne b gy nn nk l nl nm">/[A-Z-0-9]/.test('a') // false<br/>/[A-Z-0-9]/.test('1') // true<br/>/[A-Z-0-9]/.test('A') // true</span></pre><p id="8041" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">多个范围项目匹配</strong></p><p id="0f09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以检查一个字符串是包含一个字符还是只包含一个字符。以<code class="fe nt nu nv ne b">^</code>开始正则表达式，以<code class="fe nt nu nv ne b">$</code>结束:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="41ac" class="ni lx it ne b gy nj nk l nl nm">/^[A-Z]$/.test('A')  // true<br/>/^[A-Z]$/.test('AB') // false<br/>/^[A-Z]$/.test('Ab') // false<br/>/^[A-Z-0-9]$/.test('1')  // true<br/>/^[A-Z-0-9]$/.test('A1') // false</span></pre><h2 id="5a52" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated"><strong class="ak">元字符</strong></h2><p id="b5a2" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">元字符是具有特殊含义的字符。让我们来看看其中的一些:</p><ul class=""><li id="be11" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\d</code>:匹配任意数字，为<code class="fe nt nu nv ne b">[0-9]</code></li><li id="e593" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\D</code>:匹配任何不是数字的字符，有效<code class="fe nt nu nv ne b">[^0-9]</code></li><li id="55fb" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\w</code>:匹配任意字母数字字符(加下划线)，相当于<code class="fe nt nu nv ne b">[A-Za-z_0-9]</code></li><li id="4a7c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\W</code>:匹配任何非字母数字字符，除了<code class="fe nt nu nv ne b">[^A-Za-z_0-9]</code></li><li id="f22c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\s</code>:匹配任何空白字符:空格、制表符、换行符和Unicode空格</li><li id="bd12" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\S</code>:匹配任何不是空格的字符</li><li id="a8e7" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\0</code>:匹配空值</li><li id="a62b" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\n</code>:匹配换行符</li><li id="91bf" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\t</code>:匹配一个制表符</li><li id="cfaa" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">\uXXXX</code>:用代码XXXX匹配一个<a class="ae lv" href="https://flaviocopes.com/unicode/" rel="noopener ugc nofollow" target="_blank"> unicode </a>字符(需要<code class="fe nt nu nv ne b">u</code>标志)</li><li id="23b9" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b"><strong class="kd iu">.</strong></code>:匹配任何不是换行符的字符(例如<code class="fe nt nu nv ne b">\n</code>)(除非你使用<code class="fe nt nu nv ne b">s</code>标志，稍后解释)</li><li id="54b9" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">[^]</code>:匹配任何字符，包括换行符。它在多行字符串上非常有用</li></ul><h2 id="64fd" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated"><strong class="ak">量词</strong></h2><p id="a94d" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">量词是在正则表达式中具有唯一意义的符号。</p><p id="7380" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看他们的行动:</p><ul class=""><li id="e9e4" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">+</code> <strong class="kd iu"> </strong>匹配前面的表达式1次或多次:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="cdde" class="ni lx it ne b gy nj nk l nl nm">var regex = /\d+/;</span><span id="071e" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('1'));<br/>// true</span><span id="07fa" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('1122'));<br/>// true</span></pre><ul class=""><li id="1319" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">*</code> <strong class="kd iu"> </strong>与前面的表达式匹配0次或更多次:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="bfdd" class="ni lx it ne b gy nj nk l nl nm">var regex = /hi*d/;</span><span id="4b1a" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hd'));<br/>// true</span><span id="6ae9" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hid'));<br/>// true</span></pre><ul class=""><li id="56a7" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">?</code> <strong class="kd iu"> </strong>匹配前面的表达式0或1次，即前面的模式是可选的:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0b16" class="ni lx it ne b gy nj nk l nl nm">var regex = /hii?d/;</span><span id="9d9b" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hid'));<br/>// true</span><span id="7a3e" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiid'));<br/>// true</span><span id="2684" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiiid'));<br/>// false</span></pre><ul class=""><li id="ff7b" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">^</code> <strong class="kd iu"> </strong>匹配字符串的开头，后面的正则表达式应该在测试字符串的开头:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="aeb2" class="ni lx it ne b gy nj nk l nl nm">var regex = /^h/;</span><span id="65e0" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hi'));<br/>// true</span><span id="7926" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('bye'));<br/>// false</span></pre><ul class=""><li id="226c" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">$</code>匹配字符串的结尾，它前面的正则表达式应该在测试字符串的结尾:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="fbc3" class="ni lx it ne b gy nj nk l nl nm">var regex = /.com$/;</span><span id="79ae" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('test@email.com'));<br/>// true</span><span id="5345" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('test@email'));<br/>// false</span></pre><ul class=""><li id="0c54" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">{N}</code>与<em class="lu">完全匹配</em>前面正则表达式的N次出现:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="079f" class="ni lx it ne b gy nj nk l nl nm">var regex = /hi{2}d/;</span><span id="89e2" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiid'));<br/>// true</span><span id="2194" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hid'));<br/>// false</span></pre><ul class=""><li id="76d5" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">{N,}</code>至少与前面正则表达式的匹配N次。</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e745" class="ni lx it ne b gy nj nk l nl nm">var regex = /hi{2,}d/;</span><span id="83a7" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiid'));<br/>// true</span><span id="0ad4" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiiid'));<br/>// true</span><span id="14d6" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiiiid'));<br/>// true</span></pre><ul class=""><li id="61b8" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">{N,M}</code>匹配前面正则表达式的<em class="lu">至少</em> N次和<em class="lu">最多</em> M次(当M &gt; N时)。</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7835" class="ni lx it ne b gy nj nk l nl nm">var regex = /hi{1,2}d/;</span><span id="cb63" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hid'));<br/>// true</span><span id="388b" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiid'));<br/>// true</span><span id="0410" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('hiiid'));<br/>// false</span></pre><ul class=""><li id="a150" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe nt nu nv ne b">X|Y</code>交替匹配<em class="lu"/>X或Y:</li></ul><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="c76d" class="ni lx it ne b gy nj nk l nl nm">var regex = /(red|yellow) bike/;</span><span id="d349" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('red bike'));<br/>// true</span><span id="70da" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('yellow bike'));<br/>// true</span><span id="fed6" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('brown bike'));<br/>// false</span></pre><p id="f92b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lu">注意:</em>使用任何特殊字符作为表达式的一部分，例如，如果你想匹配文字<code class="fe nt nu nv ne b">+</code>或<code class="fe nt nu nv ne b">.</code>，那么你需要用反斜杠<code class="fe nt nu nv ne b">\</code>对它们进行转义。像这样:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b677" class="ni lx it ne b gy nj nk l nl nm">var regex = /a+b/;  <br/>// this doesn't work</span><span id="d4b4" class="ni lx it ne b gy nn nk l nl nm">var regex = /a\+b/; <br/>// this works!</span><span id="c6da" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('a+b')); <br/>// true</span></pre><h1 id="c50c" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">查看正则表达式</h1><p id="668f" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">有了这些新鲜的概念，让我们来回顾一下我们所学的！</p><h2 id="f2b5" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated">匹配任意10位数字:</h2><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5985" class="ni lx it ne b gy nj nk l nl nm">var regex = /^\d{10}$/;</span><span id="9273" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('4658264822'));<br/>// true</span></pre><p id="8ef9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以<code class="fe nt nu nv ne b">\d</code>匹配任何数字字符。<code class="fe nt nu nv ne b">{10}</code>匹配前面的表达式，在本例中<code class="fe nt nu nv ne b">\d</code> <strong class="kd iu">正好是</strong>的10倍。因此，如果测试字符串包含少于或多于10个数字，结果将为假。</p><h2 id="5fb1" class="ni lx it bd ly nw nx dn mc ny nz dp mg km oa ob mk kq oc od mo ku oe of ms og bi translated"><strong class="ak">用以下格式匹配日期:</strong></h2><p id="85fd" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated"><code class="fe nt nu nv ne b"><strong class="kd iu">DD-MM-YYYY </strong></code> <strong class="kd iu">或</strong> <code class="fe nt nu nv ne b"><strong class="kd iu">DD-MM-YY</strong></code></p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3bc7" class="ni lx it ne b gy nj nk l nl nm">var regex = /^(\d{1,2}-){2}\d{2}(\d{2})?$/;</span><span id="ef50" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('01-01-2000'));<br/>// true</span><span id="85f2" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('01-01-00'));<br/>// true</span><span id="3ff1" class="ni lx it ne b gy nn nk l nl nm">console.log(regex.test('01-01-200'));<br/>// false</span></pre><p id="e0ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们将整个表达式包装在<code class="fe nt nu nv ne b">^ </code>和<code class="fe nt nu nv ne b">$</code>中，这样匹配就跨越了整个字符串。<code class="fe nt nu nv ne b">(</code>是第一个子表达式的开始。<code class="fe nt nu nv ne b">\d{1,2}</code>匹配最少<em class="lu">1位数字和最多<em class="lu">2位数字。<code class="fe nt nu nv ne b">-</code>匹配文字连字符。<code class="fe nt nu nv ne b">)</code>是第一个子表达式的结尾。</em></em></p><p id="dca1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后<code class="fe nt nu nv ne b">{2}</code>与第一个子表达式<em class="lu">精确匹配</em> 2次。<code class="fe nt nu nv ne b">\d{2}</code>与<em class="lu">完全匹配</em>的2位数。<code class="fe nt nu nv ne b">(\d{2})?</code>与<em class="lu">完全匹配</em>的2位数。然而，这是可选的，所以任何一年包含2位数或4位数。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="9988" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lu">你准备好让你的JavaScript技能更上一层楼了吗？</em> </strong> <em class="lu">今天就开始用我的新电子书吧！无论你是想学习你的第一行代码，还是想扩展你的知识面并真正学习基础知识..</em><a class="ae lv" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank"><em class="lu">《JavaScript精通完全指南》</em> </a> <em class="lu">带你从零到英雄！</em></p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/dde515044536421c6c999650977f80c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fUokZkbKj-qlRPVN_Txrg.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk translated"><em class="om">现已上市！👉</em><a class="ae lv" href="https://gum.co/mastering-javascript" rel="noopener ugc nofollow" target="_blank">https://gum.co/mastering-javascript</a></figcaption></figure><h1 id="f0dc" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">结论</h1><p id="a6e0" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">我们走吧！我们研究了正则表达式，从最基础的一直到更高级的实现。包括文字和构造方法、测试方法、标志和字符语法。</p><p id="6d53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正则表达式确实可以相当复杂！然而，花时间学习语法将极大地帮助您更容易地识别正则表达式模式。你获得的任何新的信心肯定会让你准备好征服你在编码之旅中遇到的下一个障碍！</p><p id="4025" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对你有用！你可以在媒体上关注我。我也在<a class="ae lv" href="https://twitter.com/easeoutco" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><h1 id="609c" class="lw lx it bd ly lz no mb mc md np mf mg mh nq mj mk ml nr mn mo mp ns mr ms mt bi translated">关于我的一点点..</h1><p id="72d3" class="pw-post-body-paragraph kb kc it kd b ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky im bi translated">嘿，我是提姆！👋我是一名开发人员、技术作家和作家。如果你想看我所有的教程，可以在<a class="ae lv" href="http://www.easeout.co" rel="noopener ugc nofollow" target="_blank">我的个人博客</a>上找到。</p><p id="50a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我目前正在构建我的<a class="ae lv" href="http://www.easeout.co/freelance" rel="noopener ugc nofollow" target="_blank">自由职业者完整指南</a>。坏消息是它还不可用！但是如果这是你可能感兴趣的东西，你可以<a class="ae lv" href="https://easeout.eo.page/news" rel="noopener ugc nofollow" target="_blank">注册，当它可用的时候会通知你</a>👍</p><p id="71dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读🎉</p></div></div>    
</body>
</html>