<html>
<head>
<title>Create a desktop app with Electron, React and C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Electron，React和C#创建一个桌面应用程序</h1>
<blockquote>原文：<a href="https://itnext.io/create-desktop-with-electron-react-and-c-86f9765809b7?source=collection_archive---------1-----------------------#2019-03-03">https://itnext.io/create-desktop-with-electron-react-and-c-86f9765809b7?source=collection_archive---------1-----------------------#2019-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eac91f2d0da9043af7c344b9c8e890e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Q-6VKshD1lsKvwkoQ0q4A.jpeg"/></div></div></figure><p id="7e1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我从事软件技术的第一年是从Delphi 7开始的。太神奇了，那是互联网半空的时候。很难找到例子，寻求帮助，基本上，你只能靠自己。哦，美好的旧时光，我不会改变这种体验，但我不想再做一次。</p><p id="2c8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着时间的推移，一切都在发展，新技术不断涌现。我不时停下来看看发生了什么变化。这太酷了，总是有一些新的东西值得研究。改变我自己的偏见，是的，很痛苦，但是这个世界没有被时间扭曲。</p><p id="e9a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">女士们先生们，我给你们带来了我使用<a class="ae kw" href="https://electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子</a>的经历。</p><h1 id="06bd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是电子</h1><p id="6d1d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Electron是一个为Windows、MacOS和Linux创建本地桌面应用程序的框架。你可以使用普通的javascript或任何其他javascript框架来构建UI。</p><p id="472e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太神奇了，你可以成为一名web应用开发者，通过重用相同的技能，你可以构建一个桌面应用。</p><blockquote class="ma mb mc"><p id="76b3" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">如果你能建立一个网站，你可以建立一个桌面应用程序。Electron是一个使用web技术(如JavaScript、HTML和CSS)创建本地应用程序的框架。它负责处理困难的部分，因此您可以专注于应用程序的核心。</p></blockquote><h1 id="94ab" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">该项目</h1><p id="1679" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们创建一个空的npm项目</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="845c" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> init --yes</span></pre><p id="6cbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加电子材料和启动命令</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7372" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> i -D electron</span></pre><p id="3d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mv mw mx mm b">package.json</code>中添加开始脚本</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9af4" class="mq ky iq mm b gy mr ms l mt mu">"start":"electron ."</span></pre><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0a28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们执行npm start，我们应该从electronic得到一个弹出错误。没关系，这只意味着电子是活的，我们不知道如何启动它。</p><h1 id="5e80" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主进程和渲染器进程</h1><p id="76f7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我们深入编码之前，理解<a class="ae kw" href="https://electronjs.org/docs/tutorial/application-architecture" rel="noopener ugc nofollow" target="_blank">电子架构</a>的基础很重要。</p><blockquote class="ma mb mc"><p id="139b" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">在electronic中，运行<code class="fe mv mw mx mm b">package.json</code>的<code class="fe mv mw mx mm b">main</code>脚本的进程被称为<strong class="ka ir">主进程</strong>。在主进程中运行的脚本可以通过创建网页来显示GUI。一个电子应用程序总是有一个主进程，但不会更多。</p><p id="ee68" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">由于Electron使用Chromium来显示网页，因此也使用了Chromium的多进程架构。Electron中的每个网页都运行在自己的进程中，这个进程被称为<strong class="ka ir">呈现器进程</strong>。</p><p id="02b2" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">在普通浏览器中，网页通常运行在沙箱环境中，不允许访问本地资源。然而，电子用户有权在网页中使用Node.js APIs，允许较低级别的操作系统交互。</p></blockquote><p id="d7b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我过于简单的解释是。有一个主要的进程创建了一个窗口，这个窗口就是Chromium。Chromium本身就是一个进程，也就是渲染器。</p><h1 id="adc7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">以打字打的文件</h1><p id="8d22" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">从2017年6月1日开始，<a class="ae kw" href="https://electronjs.org/blog/typescript" rel="noopener ugc nofollow" target="_blank">电子支持打字稿</a>。好，让我们使用它。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8d1b" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> i -D typescript<br/><strong class="mm ir">npm</strong> i -D tslint<br/><strong class="mm ir">npm</strong> i -D prettier</span></pre><p id="ca9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目根中添加<code class="fe mv mw mx mm b">tslint.json</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e9be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目的根中添加<code class="fe mv mw mx mm b">tsconfig.json</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="009b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于类型脚本编译，可以使用<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank"> tsc </a>，但是最终目的是使用React和操纵模板。Webpack是这次要走的路。</p><h1 id="084a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">网络包</h1><p id="39ce" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">web包的设置</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0f12" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm </strong>i -D webpack webpack-cli<br/><strong class="mm ir">npm</strong> i -D html-webpack-plugin<br/><strong class="mm ir">npm</strong> i -D @babel/cli @babel/core @babel/preset-env babel-loader @babel/plugin-proposal-class-properties @babel/plugin-transform-arrow-functions<br/><strong class="mm ir">npm</strong> i -D @babel/preset-typescript</span></pre><p id="d709" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目的根中添加<code class="fe mv mw mx mm b">.babelrc</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f596" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利，现在让我们创建一个电子的主进程，并向妈妈问好！</p><p id="ec4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个文件夹<code class="fe mv mw mx mm b">src</code></p><p id="2436" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mv mw mx mm b">src</code>文件夹中添加<code class="fe mv mw mx mm b">main.ts</code>文件</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3b4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx mm b">line 8</code>创建一个窗口并将<code class="fe mv mw mx mm b">index.html</code>加载到窗口中，又名Chromium。</p><p id="1be9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<code class="fe mv mw mx mm b">index.html</code>添加到<code class="fe mv mw mx mm b">src</code>文件夹</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a583" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在根中添加<code class="fe mv mw mx mm b">webpack.config.js</code>。web pack如何处理电子主流程构建的说明。<a class="ae kw" href="https://webpack.js.org/configuration/target/" rel="noopener ugc nofollow" target="_blank">重要</a>重要<code class="fe mv mw mx mm b">target:"electron-main"</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8f54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍微调整一下<code class="fe mv mw mx mm b">package.json</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8fda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行命令</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4981" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> run build<br/><strong class="mm ir">npm</strong> run start</span></pre><p id="2e68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是了。一个全功能的桌面应用程序。也就是向妈妈问好。</p><p id="ce8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上是您的前端开发人员技能发挥作用的地方。因为它是一个Chromium，你可以使用任何种类的前端技术，React，Vue，Angular，普通javascript。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/663b091f188f638e0b4b8f26e42bc8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_NwsN8Q1gbfsRLltINhkA.png"/></div></div></figure><h1 id="4fb8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">的反应</h1><p id="1a44" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">React将存在于电子渲染器进程中，因此我们必须创建一个单独的web pack构建配置。并教巴贝尔使用反应装载机</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b55c" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> i -D @babel/preset-react<br/><strong class="mm ir">npm </strong>i -S react react-dom<br/><strong class="mm ir">npm</strong> i -D @types/react @types/react-dom</span></pre><p id="b9f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整<code class="fe mv mw mx mm b">.babelrc</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d08d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过移除<code class="fe mv mw mx mm b">index.html</code>模板生成的职责来调整<code class="fe mv mw mx mm b">webpack.config.js</code>。这是渲染器构建过程的责任。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c715" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加新的web pack配置文件<code class="fe mv mw mx mm b">webpack.react.config.js</code>。该配置负责编译react素材，并确保编译结果注入到<code class="fe mv mw mx mm b">index.html</code>内部</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="755a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整<code class="fe mv mw mx mm b">index.html</code>使其包含一个React可以放置其组件的容器。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ffcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mv mw mx mm b">src</code>中创建一个文件夹<code class="fe mv mw mx mm b">app</code>并创建<code class="fe mv mw mx mm b">renderer.tsx</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7606" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们再次说你好妈妈，只是现在我们将使用React来这样做。</p><p id="ab03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mv mw mx mm b">app</code>中创建一个文件夹<code class="fe mv mw mx mm b">components</code>并创建<code class="fe mv mw mx mm b">Dashboard.tsx</code></p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b1d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整<code class="fe mv mw mx mm b">package.json</code>并添加一个新命令，这样我们就可以编译渲染器了。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2929" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> run build:react<br/><strong class="mm ir">npm</strong> run build<br/><strong class="mm ir">npm</strong> run start</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/28497f624af384501592ca6f219f72c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeLPD2aawk-WtXwIIilH1w.png"/></div></div></figure><p id="faef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是我每天都能看到的。一个运行React的本地桌面应用程序。也许我知道，我只是不知道，因为电子是一个流行的框架，到处都在使用。比如<a class="ae kw" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>，试着猜猜它的动力是什么；).</p><h1 id="0e7f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">C#什么？</h1><p id="de2b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Rui Figueiredo的一篇博客点燃了我对电子的兴趣。</p><p id="8401" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用C#的电子。这是一个有趣的协同作用。因为它是C#核心，所以也是跨平台的。</p><p id="c28e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用React for UI和C# goodness扩展功能的跨平台桌面应用程序。现在你不仅可以使用前端技能，也可以使用后端技能。</p><p id="94f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为npm项目安装新包</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="da3f" class="mq ky iq mm b gy mr ms l mt mu">npm i -D electron-cgi</span></pre><p id="28df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调整<code class="fe mv mw mx mm b">main.ts</code>为了测试运行，我们将发送妈妈到C#控制台应用程序，它将返回你好妈妈回来。我们将控制台日志记录下来。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4a42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个简单的<a class="ae kw" href="https://dotnet.microsoft.com/download/dotnet-core/3.0" rel="noopener ugc nofollow" target="_blank"> dotnet </a> C#核心控制台应用程序。添加<code class="fe mv mw mx mm b">ElectronCgi.DotNet</code> nuget。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e305" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> run build<br/><strong class="mm ir">npm</strong> run start</span></pre><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3bf1ac84e0932a3e612d8a6af8bdab1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*MnYRCwWcijUMe4WJlc83Jg.png"/></div></figure><p id="ab8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">令人惊奇不是吗？Rui做了额外的工作，并把它加入到C#中</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="04a6" class="mq ky iq mm b gy mr ms l mt mu">connection.OnAsync();</span></pre><p id="dbe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们在谈正经事。Imagen这会带来什么样的可能性？与数据库、Rest API、队列的异步通信，所有适用于云、Amazon、Azure等的优秀包。所有来自C#的好东西触手可及。</p><p id="cd54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且不仅限于发送字符串，在C#中可以是强类型对象。</p><p id="143f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是如何</p><blockquote class="ma mb mc"><p id="df55" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">ElectronCGI的灵感来自于第一个动态web请求是如何在web早期成为现实的。</p><p id="b5cb" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">在早期，web服务器能够提供的唯一服务是静态网页。为了提供动态页面，有人提出了让外部可执行程序接受web请求的表示并产生响应的想法。</p><p id="cd12" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">可执行文件获取web请求头的方式是通过环境变量，请求体通过标准输入流(stdin)发送。</p><p id="52f2" class="jy jz md ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">处理完请求后，可执行文件会通过标准输出流(stdout)将结果html发送回web服务器</p></blockquote><p id="205e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大量使用stdout。这不一定是坏事，例如，<code class="fe mv mw mx mm b">php.exe</code>和围绕它的框架；).</p><p id="d2c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我总的来说喜欢这种方法，干净，聪明，有创意。我支持读完芮的博客文章。</p><h1 id="0f6e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">React和C#的额外优势</h1><p id="0339" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们把它变得更有趣，从C#中发送消息以作出反应。</p><p id="2884" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，通过将仪表板功能组件更改为具有状态的组件，在呈现器中进行更改。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="958e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那里发生了什么？我们订阅了通道<code class="fe mv mw mx mm b">greeging</code>,当从主进程接收到消息时，我们将消息放入状态。从那时起，React接管权力，注意到状态变化并呈现消息。</p><p id="b2d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主进程通过发送从C#接收到的消息来做出反应</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/029330d88eae5c07209f83d98dae810c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VUwlpV9_aGqZJCLPcB9KQQ.gif"/></div></div></figure><h1 id="6e75" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建合法的EXE文件</h1><p id="ee3b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">添加包</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f222" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> i -D electron-packager</span></pre><p id="7423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加<code class="fe mv mw mx mm b">package-win</code>命令，将<code class="fe mv mw mx mm b">main</code>指向<code class="fe mv mw mx mm b">dist</code>文件夹文件<code class="fe mv mw mx mm b">main.js</code>，调整<code class="fe mv mw mx mm b">package.json</code>文件。</p><p id="1482" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有平台构建命令的教程<a class="ae kw" href="https://www.christianengvall.se/electron-packager-tutorial/" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cc14" class="mq ky iq mm b gy mr ms l mt mu"><strong class="mm ir">npm</strong> run package-win</span></pre><p id="0dc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将C#文件夹“<code class="fe mv mw mx mm b">core</code>复制到“<code class="fe mv mw mx mm b">release-builds\electron-demo-win32-ia32</code>”中，运行<code class="fe mv mw mx mm b">electron-demo.exe</code></p><h1 id="7fe0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结束了</h1><p id="db7e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我这段从Delphi 7到React，electronic，C#的旅程太牛逼了。正如我之前说过的，没有什么是一成不变的，每天都有新技术出现，让我们变得更好，打破了我们的个人偏见。</p><p id="96c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">保持开放的心态是我们最大的挑战。</p><p id="41c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/alzuma/electron-demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中演示的源代码</p><p id="25e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于完整的Ract管道，请在此处阅读<a class="ae kw" href="https://medium.com/@kristaps.vitolins/create-a-build-pipeline-for-react-app-f41cf3342168" rel="noopener"/>。</p></div></div>    
</body>
</html>