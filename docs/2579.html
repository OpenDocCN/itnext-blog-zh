<html>
<head>
<title>Typing React (4) Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">键入React (4) Routing</h1>
<blockquote>原文：<a href="https://itnext.io/typing-react-4-routing-8a67f97930f0?source=collection_archive---------7-----------------------#2019-06-17">https://itnext.io/typing-react-4-routing-8a67f97930f0?source=collection_archive---------7-----------------------#2019-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7526fbe1daf91a77249f71c371f415c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2eMKKRqx6EkVHNfqUGjfQ.jpeg"/></div></figure><p id="0443" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上一篇文章中，我们演示了如何将TypeScript与Redux和相关库一起使用。在本帖中，我们将讨论路由，这是几乎所有React应用程序都必须处理的重要部分。</p><p id="f23a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以前的文章:</p><ul class=""><li id="8121" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/typing-react-1-basic-488f661149f6?source=your_stories_page---------------------------">打字反应(1) —基本</a></li><li id="e3fc" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/typing-react-2-material-ui-9e95a4aec6bc?source=your_stories_page---------------------------">键入React (2) — Material-UI </a></li><li id="56b1" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/typing-react-3-redux-84e73e41db7f">输入React (3) — Redux </a></li></ul></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="a8b9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">反应-路由器-dom</h1><p id="afba" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">最常见的方法是使用<code class="fe mr ms mt mu b">react-router-dom</code>。要使用它，我们还必须安装类型:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="8a8e" class="nd lp iq mu b gy ne nf l ng nh">$ npm install --save react-router-dom @types/react-router-dom</span></pre><p id="4d06" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我将跳过基本设置部分，因为它非常简单(参见<a class="ae lb" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank">手册</a>)。我想展示的唯一一件事是，当我们需要使用路由参数时，我们需要组件具有<code class="fe mr ms mt mu b">match</code>属性，可以通过<code class="fe mr ms mt mu b">RouteComponentProps</code>像这样键入:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="25b7" class="nd lp iq mu b gy ne nf l ng nh">// Definition of IProps<br/>export interface IProps<br/>  extends RouteComponentProps&lt;{ id?: string }&gt;,<br/>  ReturnType&lt;typeof mapStateToProps&gt;,<br/>  ReturnType&lt;typeof mapDispatchToProps&gt; {<br/>  // other properties<br/>}<br/><br/>// In component<br/>const TodoList: React.FC&lt;IProps&gt; = props =&gt; {<br/>  const { match } = props;<br/>  if (match.params.id) {<br/>    ...<br/>  }<br/>}</span></pre><p id="161c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意<code class="fe mr ms mt mu b">RouteCompnentProps</code>的模板参数是<code class="fe mr ms mt mu b">match.params</code>的类型。<code class="fe mr ms mt mu b">RouteCommponentProps</code>的定义是:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="4184" class="nd lp iq mu b gy ne nf l ng nh">export interface RouteComponentProps&lt;Params extends { [K in keyof Params]?: string } = {}, ...&gt; { ... }</span></pre><p id="3e69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我们提供的类型必须是一个带有可选字符串值的字典。</p><h1 id="f93c" class="lo lp iq bd lq lr ni lt lu lv nj lx ly lz nk mb mc md nl mf mg mh nm mj mk ml bi translated">连接反应路由器</h1><p id="c747" class="pw-post-body-paragraph ju jv iq jw b jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr ij bi translated">如果你选择使用<code class="fe mr ms mt mu b">redux-observable</code>，那么很可能你将需要使用<code class="fe mr ms mt mu b">connected-react-router</code>。原因是，大多数时候我们希望在异步动作完成后使用重定向，但是使用<code class="fe mr ms mt mu b">redux-observable</code>，异步调用是在epics中完成的，组件没有办法知道调用何时完成。因此，只有史诗知道正确的时间，并相应地处理重定向。将<code class="fe mr ms mt mu b">&lt;Redirect&gt;</code>包装成一个动作，这样我们可以在epics中处理重定向。</p><p id="1e3d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们在Todo项目详细信息屏幕上，并希望在保存项目后导航回项目列表。动作流应该是这样的:</p><ul class=""><li id="cc34" class="ks kt iq jw b jx jy kb kc kf ku kj kv kn kw kr kx ky kz la bi translated">调度<code class="fe mr ms mt mu b">TODO:SAVE:REQUEST</code></li><li id="6c8f" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">epic在接收到<code class="fe mr ms mt mu b">TODO:SAVE:REQUEST</code>动作时发送异步调用</li><li id="c456" class="ks kt iq jw b jx lc kb ld kf le kj lf kn lg kr kx ky kz la bi translated">当异步调用返回时，将<code class="fe mr ms mt mu b">TODO:SAVE:SUCCESS</code>和<code class="fe mr ms mt mu b">REDIRECT</code>动作推送到动作流</li></ul><p id="22b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">诀窍在于，在最后一步中，我们需要通过两个动作将一个可观察对象(异步调用的响应)转换为另一个可观察对象。这部史诗可以这样写:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="b518" class="nd lp iq mu b gy ne nf l ng nh">export const SaveTodoEpic: RootEpic = (actions$, $state, { todos }) =&gt;<br/>  actions$.pipe(<br/>    filter(isOfType(getType(listTodo.request))),<br/>    mergeMap(action =&gt;<br/>      todos.updateTodos$().pipe(mergeMap(res =&gt; of(listTodo.success(res), push('/'))),<br/>    catchError(err =&gt; of(updateTodo.failure(err))),<br/>  );</span></pre><p id="dbdf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于<code class="fe mr ms mt mu b">push</code>成为动作流的一种可能类型，我们也需要改变<code class="fe mr ms mt mu b">store/types.d.ts</code>(注意添加到<code class="fe mr ms mt mu b">RootAction</code>的<code class="fe mr ms mt mu b">CallHistoryMethodAction</code>类型:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="5803" class="nd lp iq mu b gy ne nf l ng nh">declare module 'StoreTypes' {<br/>  export type Store = StateType&lt;typeof import('./index').default&gt;;<br/>  export type RootAction = ActionType&lt;typeof import('./actions').default&gt; | CallHistoryMethodAction;<br/>  export type RootState = StateType&lt;ReturnType&gt;typeof import('./reducers').default&gt;&gt;;<br/>  export type RootEpic = Epic&lt;RootAction, RootAction, RootState, Services&gt;;<br/>}</span></pre><p id="3e29" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这应该可以解决路由问题。</p></div></div>    
</body>
</html>