<html>
<head>
<title>Source Code Walkthrough of Telegram-iOS Part 2: SSignalKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Telegram-iOS第2部分源代码演练:SSignalKit</h1>
<blockquote>原文：<a href="https://itnext.io/source-code-walkthrough-of-telegram-ios-part-2-ssignalkit-afdf35ff60ba?source=collection_archive---------1-----------------------#2020-05-11">https://itnext.io/source-code-walkthrough-of-telegram-ios-part-2-ssignalkit-afdf35ff60ba?source=collection_archive---------1-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="8b5f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae kp" href="https://hubo.dev/2020-05-11-source-code-walkthrough-of-telegram-ios-part-2/" rel="noopener ugc nofollow" target="_blank"> hubo.dev </a>的镜像</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/aa3402e23af71ebf3c2b7fbfa7edea9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H-zyp_Iow9jgKVvJ"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3276" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">介绍</h1><p id="5049" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi mm translated">elegram-iOS在大多数模块中使用反应式编程。有三个框架来实现项目内部的反应功能:</p><ul class=""><li id="3fee" class="mv mw iq jt b ju jv jy jz mg mx mi my mk mz ko na nb nc nd bi translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/MtProtoKit/Sources/MTSignal.m" rel="noopener ugc nofollow" target="_blank">MTSignal</a></code>:这可能是他们在Objective-C中第一次尝试反应式范例。它主要用在模块<a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/tree/master/submodules/MtProtoKit" rel="noopener ugc nofollow" target="_blank"> MtProtoKit </a>中，该模块实现了<a class="ae kp" href="https://core.telegram.org/mtproto" rel="noopener ugc nofollow" target="_blank"> MTProto </a>，Telegram的移动协议。</li><li id="bf21" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/tree/master/submodules/SSignalKit/SSignalKit" rel="noopener ugc nofollow" target="_blank">SSignalKit</a></code>:它是MTSignal的后代，用于更一般的场景，原语和操作更丰富。</li><li id="12d0" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/tree/master/submodules/SSignalKit/SwiftSignalKit" rel="noopener ugc nofollow" target="_blank">SwiftSignalKit</a></code>:斯威夫特的一个对等港口。</li></ul><p id="693d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这篇文章关注SwiftSignalKit，用用例来解释它的设计。</p><h1 id="d208" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设计</h1><h2 id="b8dc" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">信号</h2><p id="973c" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal.swift#L41" rel="noopener ugc nofollow" target="_blank">Signal</a></code>是一个捕捉“随时间变化”概念的类。其签名如下所示:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f798" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">为了建立一个信号，它接受一个生成器闭包，该闭包定义了生成数据(<code class="fe ne nf ng nh b">&lt;T&gt;)</code>)、捕捉错误(<code class="fe ne nf ng nh b">&lt;E&gt;</code>)和更新完成状态的方法。一旦设置好，函数<code class="fe ne nf ng nh b">start</code>就可以注册观察器闭包。</p><h2 id="273c" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">订户</h2><p id="c4c3" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Subscriber.swift" rel="noopener ugc nofollow" target="_blank">Subscriber</a></code>具有将数据分发到每个观察者闭包的逻辑，并考虑到线程安全。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5ddc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">当错误发生或完成时，订户被终止。状态无法逆转。</p><ul class=""><li id="d068" class="mv mw iq jt b ju jv jy jz mg mx mi my mk mz ko na nb nc nd bi translated">只要订户没有被终止，<code class="fe ne nf ng nh b">putNext</code>就向<code class="fe ne nf ng nh b">next</code>闭包发送新数据</li><li id="e531" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated"><code class="fe ne nf ng nh b">putError</code>向<code class="fe ne nf ng nh b">error</code>闭包发送错误，并标记订户终止</li><li id="5b4b" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated"><code class="fe ne nf ng nh b">putCompletion</code>调用<code class="fe ne nf ng nh b">completed</code>关闭并标记用户终止。</li></ul><h2 id="cf11" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">经营者</h2><p id="f252" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">定义了一组丰富的操作符来提供信号的功能原语。这些原语根据其功能分为几类:<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Catch.swift" rel="noopener ugc nofollow" target="_blank">Catch</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Combine.swift" rel="noopener ugc nofollow" target="_blank">Combine</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Dispatch.swift" rel="noopener ugc nofollow" target="_blank">Dispatch</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Loop.swift" rel="noopener ugc nofollow" target="_blank">Loop</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Mapping.swift" rel="noopener ugc nofollow" target="_blank">Mapping</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Meta.swift" rel="noopener ugc nofollow" target="_blank">Meta</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Reduce.swift" rel="noopener ugc nofollow" target="_blank">Reduce</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_SideEffects.swift" rel="noopener ugc nofollow" target="_blank">SideEffects</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Single.swift" rel="noopener ugc nofollow" target="_blank">Single</a></code>、<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Take.swift" rel="noopener ugc nofollow" target="_blank">Take</a></code>和<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Signal_Timing.swift" rel="noopener ugc nofollow" target="_blank">Timing</a></code>。让我们以几个映射运算符为例:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="54eb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">像<code class="fe ne nf ng nh b">map()</code>这样的操作符接受一个转换闭包并返回一个函数来改变信号的数据类型。有一个方便的<code class="fe ne nf ng nh b">|&gt;</code>操作符可以帮助将这些操作符链接成管道:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2a44" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">运算符<code class="fe ne nf ng nh b">|&gt;</code>可能会受到JavaScript世界中提议的<a class="ae kp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator" rel="noopener ugc nofollow" target="_blank">管道运算符</a>的启发。通过Swift的尾随闭包支持，所有运算符都可以以直观的可读性进行流水线操作:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="2cde" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">长队</h2><p id="b4dd" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">类<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Queue.swift" rel="noopener ugc nofollow" target="_blank">Queue</a></code>是GCD上的一个包装器，用于管理在信号中调度数据的队列。一般用例有三个预置队列:<code class="fe ne nf ng nh b">globalMainQueue,</code> <code class="fe ne nf ng nh b">globalDefaultQueue,</code>和<code class="fe ne nf ng nh b">globalBackgroundQueue</code>。没有机制可以避免<a class="ae kp" href="https://forums.developer.apple.com/message/338719#338719" rel="noopener ugc nofollow" target="_blank">过度使用</a>队列，我认为这是可以改进的。</p><h2 id="ebff" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">可任意处理的</h2><p id="5ac6" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">协议<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Disposable.swift" rel="noopener ugc nofollow" target="_blank">Disposable</a></code>定义了一些可以被处理的东西。它通常与释放资源或取消任务有关。四个类实现了这个协议，并且可以覆盖大多数用例:<code class="fe ne nf ng nh b">ActionDisposable</code>、<code class="fe ne nf ng nh b">MetaDisposable</code>、<code class="fe ne nf ng nh b">DisposableSet</code>和<code class="fe ne nf ng nh b">DisposableDict</code>。</p><h2 id="1fce" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">承诺</h2><p id="91f0" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">类<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Promise.swift" rel="noopener ugc nofollow" target="_blank">Promise</a></code>和<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Promise.swift#L82" rel="noopener ugc nofollow" target="_blank">ValuePromise</a></code>是为多个观察者对一个数据源感兴趣的场景而构建的。<code class="fe ne nf ng nh b">Promise</code>支持使用信号更新数据值，而<code class="fe ne nf ng nh b">ValuePromise</code>被定义为直接接受值的变化。</p><h1 id="4c42" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">用例</h1><p id="b6df" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">让我们来看看项目中的一些真实用例，它们展示了SwiftSignalKit的使用模式。</p><h2 id="b8d3" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">#1请求授权</h2><p id="c1e5" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">iOS强制应用程序在访问设备上的敏感信息之前请求用户授权，如<a class="ae kp" href="https://developer.apple.com/documentation/contacts/requesting_authorization_to_access_contacts" rel="noopener ugc nofollow" target="_blank">联系人</a>、<a class="ae kp" href="https://developer.apple.com/documentation/avfoundation/cameras_and_media_capture/requesting_authorization_for_media_capture_on_ios" rel="noopener ugc nofollow" target="_blank">摄像头</a>、<a class="ae kp" href="https://developer.apple.com/documentation/corelocation/requesting_authorization_for_location_services" rel="noopener ugc nofollow" target="_blank">位置</a>等。在与朋友聊天时，Telegram-iOS有一个功能，可以将您的位置作为消息发送。让我们看看它是如何用信号获得位置授权的。</p><p id="0fb2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">该工作流是一个标准的异步任务，可以通过SwiftSignalKit进行建模。<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/DeviceAccess/Sources/DeviceAccess.swift" rel="noopener ugc nofollow" target="_blank">DeviceAccess.swift</a></code>中的函数<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/DeviceAccess/Sources/DeviceAccess.swift#L84" rel="noopener ugc nofollow" target="_blank">authorizationStatus</a></code>返回一个信号来检查当前的授权状态:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><blockquote class="jn jo jp"><p id="75f0" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">当前的实现通过管道传输了另一个<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/DeviceAccess/Sources/DeviceAccess.swift#L233" rel="noopener ugc nofollow" target="_blank">then</a></code>操作，我认为这是一段复制粘贴代码，应该删除。</p></blockquote><p id="1072" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">当<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/LocationUI/Sources/LocationPickerController.swift#L295" rel="noopener ugc nofollow" target="_blank">LocationPickerController</a></code>出现时，它观察来自<code class="fe ne nf ng nh b">authorizationStatus</code>的信号，如果未确定许可，则调用<code class="fe ne nf ng nh b">DeviceAccess.authrizeAccess</code>。</p><p id="5373" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated"><code class="fe ne nf ng nh b">Signal.start</code>返回<code class="fe ne nf ng nh b">Disposable</code>的一个实例。最佳实践是将它保存在一个字段变量中，并在<code class="fe ne nf ng nh b">deinit</code>中处理它。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="4026" class="nn lh iq bd li no np dn lm nq nr dp lq mg ns nt lu mi nu nv ly mk nw nx mc ny bi translated">#2更改用户名</h2><p id="bb31" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated">让我们看一个更复杂的例子。电报允许每个用户在<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift" rel="noopener ugc nofollow" target="_blank">UsernameSetupController</a></code>中更改唯一的用户名。用户名用于生成一个公共链接，供其他人联系您。</p><div class="kr ks kt ku gt ab cb"><figure class="ob kv oc od oe of og paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/27d5c73744038e7b42c33456317bc9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*4B3KzZjUpFRaHkGYH7BYCQ.jpeg"/></div></figure><figure class="ob kv oh od oe of og paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/f343466b65a05a64be941dc393fe7f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*jVOUrsKiX7T62UH1gUZIcw.jpeg"/></div></figure><figure class="ob kv oc od oe of og paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/c471afe902aee59e7c3e1c333a02e2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Q7loAo6OvvI6R2AH0fyzOQ.jpeg"/></div></figure></div><div class="ab cb"><figure class="ob kv oi od oe of og paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/3df2cc9f92b8afeed95819171ed26ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*AteumnKwtSM6XlXbuy_R5g.jpeg"/></div></figure><figure class="ob kv oi od oe of og paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/de9725395a8a54e78c640bfe93037c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*DIGQN7LBcf3eoozATsTLrQ.jpeg"/></div></figure><figure class="ob kv oi od oe of og paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><img src="../Images/157b16dbde827ef00569f03314fcef88.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*eqeaHyrJlULDpaVGi83NOA.jpeg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk oj di ok ol translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift" rel="noopener ugc nofollow" target="_blank">UsernameSetupController</a></code>的状态</figcaption></figure></div><p id="df1d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">实施应满足以下要求:</p><ul class=""><li id="e3e2" class="mv mw iq jt b ju jv jy jz mg mx mi my mk mz ko na nb nc nd bi translated">控制器从当前用户名和当前主题开始。Telegram有一个强大的<a class="ae kp" href="https://telegram.org/blog/android-themes" rel="noopener ugc nofollow" target="_blank">主题系统</a>，所有的控制器都应该是主题化的。</li><li id="25e5" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated">应该首先在本地验证输入字符串，以检查其长度和字符。</li><li id="2695" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated">应该向后端发送一个有效的字符串以进行可用性检查。在快速打字的情况下，应该限制请求的数量。</li><li id="8c38" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated">UI反馈应该跟随用户的输入。屏幕上的消息应该告诉新用户名的状态:正在检查、无效、不可用或可用。当输入字符串有效且可用时，应该启用右侧导航按钮。</li><li id="1bdc" class="mv mw iq jt b ju ni jy nj mg nk mi nl mk nm ko na nb nc nd bi translated">一旦用户想要更新用户名，右边的导航按钮应该在更新过程中显示一个活动指示器。</li></ul><p id="b1df" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">有三个数据源可能会随着时间的推移而改变:主题、当前帐户和编辑状态。主题和账户是项目中的基础数据组件，因此有专用的信号:<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/AccountContext/Sources/AccountContext.swift#L428" rel="noopener ugc nofollow" target="_blank">SharedAccountContext.presentationData</a></code>和<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/TelegramCore/Sources/AccountViewTracker.swift#L1153" rel="noopener ugc nofollow" target="_blank">Account.viewTracker.peerView</a></code>。我会试着在其他帖子中介绍它们。让我们一步一步来关注如何用Signal对编辑状态进行建模。</p><ol class=""><li id="b978" class="mv mw iq jt b ju jv jy jz mg mx mi my mk mz ko om nb nc nd bi translated">结构<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift#L130" rel="noopener ugc nofollow" target="_blank">UsernameSetupControllerState</a></code>用三个元素定义数据:编辑输入文本、验证状态和更新标志。提供了几个助手函数来更新它并获得一个新的实例。</li></ol><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8d39" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">2.状态变化由<code class="fe ne nf ng nh b">ValuePromise</code>中的<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift#L228" rel="noopener ugc nofollow" target="_blank">statePromise</a></code>传播，这也提供了一个简洁的特性来省略重复的数据更新。还有一个<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift#L229" rel="noopener ugc nofollow" target="_blank">stateValue</a></code>来保存最新状态，因为在外面<code class="fe ne nf ng nh b">ValuePromise</code>中的数据<a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SSignalKit/SwiftSignalKit/Source/Promise.swift#L83" rel="noopener ugc nofollow" target="_blank">不可见</a>。在项目中，价值承诺伴随着状态价值是一种常见的模式。对内部值公开读访问可能是对<code class="fe ne nf ng nh b">ValuePromise</code> IMO的一个适当的改进。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2e4a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">3.验证过程可以在管道信号中实现。操作员<code class="fe ne nf ng nh b">delay</code>将请求延迟0.3秒。为了快速输入，步骤4中的设置会取消之前未发送的请求。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6e0c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">4.A <code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift#L239" rel="noopener ugc nofollow" target="_blank">MetaDisposable</a></code>保持信号，当<code class="fe ne nf ng nh b">text</code>在<code class="fe ne nf ng nh b">TextFieldNode</code>中改变时，更新<code class="fe ne nf ng nh b">statePromise</code>和<code class="fe ne nf ng nh b">stateValue</code>中的数据。调用<code class="fe ne nf ng nh b">checkAddressNameDisposable.set()</code>时，前一个被处理，触发第三步操作符<code class="fe ne nf ng nh b">delay</code>内的取消任务。</p><blockquote class="jn jo jp"><p id="dfe5" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/Display/Source/EditableTextNode.swift" rel="noopener ugc nofollow" target="_blank">TextFieldNode</a></code>是<code class="fe ne nf ng nh b">ASDisplayNode</code>的子类，包装了一个用于文本输入的UITextField。Telegram-iOS利用来自<a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/tree/master/submodules/AsyncDisplayKit" rel="noopener ugc nofollow" target="_blank"> AsyncDisplayKit </a>的异步渲染机制，使其复杂的消息UI流畅且响应迅速。</p></blockquote><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5574" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">5.操作符<code class="fe ne nf ng nh b"><a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/SettingsUI/Sources/UsernameSetupController.swift#L288" rel="noopener ugc nofollow" target="_blank">combineLatest</a></code>组合这三个信号，如果其中任何一个发生变化，就更新控制器UI。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="12b3" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="c638" class="pw-post-body-paragraph jq jr iq jt b ju me jw jx jy mf ka kb mg mh ke kf mi mj ki kj mk ml km kn ko ij bi translated"><code class="fe ne nf ng nh b">SSignalKit</code>是Telegram-iOS对反应式编程的解决方案。核心组件，如<code class="fe ne nf ng nh b">Signal</code>和<code class="fe ne nf ng nh b">Promise</code>，以与其他反应式框架略有不同的方式实现。它在模块中广泛使用，将UI与数据更改联系起来。</p><p id="c131" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb mg kd ke kf mi kh ki kj mk kl km kn ko ij bi translated">这种设计鼓励大量使用闭包。有很多闭包相互嵌套，<a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/TelegramUI/Sources/ChatMediaInputNode.swift#L1125" rel="noopener ugc nofollow" target="_blank">缩进一些行</a>远。该项目还喜欢<a class="ae kp" href="https://github.com/TelegramMessenger/Telegram-iOS/blob/master/submodules/TelegramUI/Sources/ChatControllerInteraction.swift#L52" rel="noopener ugc nofollow" target="_blank">将许多动作公开为闭包</a>以获得灵活性。电报工程师如何保持代码质量并轻松调试信号对我来说仍然是一个神话。</p></div></div>    
</body>
</html>