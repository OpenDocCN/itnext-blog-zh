<html>
<head>
<title>Building a Unicorn with Reducers!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用减速器建造独角兽！</h1>
<blockquote>原文：<a href="https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e?source=collection_archive---------1-----------------------#2017-10-25">https://itnext.io/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e?source=collection_archive---------1-----------------------#2017-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/340a0bbf86d5ec4926929328322c8f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvPr1Dhzh8XB2BckHqZkrQ.png"/></div></div></figure><h2 id="1a0f" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">表情符号爱好者的函数式编程指南</h2><div class=""/><div class=""><h2 id="7844" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">深入探讨数组缩减、函数组合和curry。</h2></div><p id="f2c9" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="lv">用表情符号和JavaScript学习函数式编程。代码示例应该足够简单，不需要任何先验知识就可以理解，但是我可以想象它看起来有点奇怪。还有，JavaScript实际上不允许表情符号作为JavaScript变量名。出于这个原因，这些代码示例不会在没有修改的情况下运行。</em></p><ul class=""><li id="5d08" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-1-241d8d4c9223" rel="noopener"> <em class="lv">用食物表情符号制作便便。</em>T13】</a></li><li id="4cf2" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-2-800b438c7ce3" rel="noopener"> <em class="lv">把暴风云变成晴朗的云。</em> </a></li><li id="34ed" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-3-ef78e3156e" rel="noopener"> <em class="lv">用减速器造独角兽！</em> </a></li><li id="f0f3" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener"> <em class="lv">现在是管道操作员！</em>T25】</a></li><li id="cb51" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-5-a6bc3324a839" rel="noopener"> <em class="lv">为食肉动物过滤肉类。</em>T29】</a></li><li id="f3fa" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-6-5c1d441d36af" rel="noopener"> <em class="lv">用归约器递归。</em> </a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="4176" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">让我们从用传统方法制作独角兽开始:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="822a" class="nb nc jb mx b gy nd ne l nf ng">unicornParts = [🐴, 🤘, 🌈, ✨, 🎶]<br/>unicorn = 🐴</span><span id="89fe" class="nb nc jb mx b gy nh ne l nf ng">add = item =&gt; item + unicorn</span><span id="9e24" class="nb nc jb mx b gy nh ne l nf ng">unicornParts.forEach(add)</span><span id="bd68" class="nb nc jb mx b gy nh ne l nf ng">🦄 = unicorn</span></pre><p id="d740" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这类似于我们的数组<code class="fe ni nj nk mx b">reduce</code>在幕后做的事情。注意，在这个<code class="fe ni nj nk mx b">forEach</code>例子中，当在循环的每次迭代中将外部<code class="fe ni nj nk mx b">unicorn</code>变量设置为一个新值时会产生突变。为了消除这种变异，我们可以使用我们的函数<code class="fe ni nj nk mx b">add</code>而不用任何循环:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b1e0" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="aefb" class="nb nc jb mx b gy nh ne l nf ng">🦄 = (<br/>    add(🎶)(<br/>        add(✨)(<br/>            add(🌈)(<br/>                add(🤘)(🐴)<br/>            )<br/>        )<br/>    )<br/>)</span></pre><p id="11f8" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">乱七八糟的，而且你还得逆向编写函数。如果我们用管子呢？：</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f724" class="nb nc jb mx b gy nd ne l nf ng">pipeReducer = (item, change) =&gt; change(item)<br/>pipe = (...functions) =&gt; functions.reduce(pipeReducer)</span><span id="0cc0" class="nb nc jb mx b gy nh ne l nf ng">🦄 = pipe(add(🤘), add(🌈), add(🎶), add(✨))(🐴)</span></pre><p id="30ce" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">好些了，但还没到那一步。使用<code class="fe ni nj nk mx b">map</code>我们可以进一步改善这一点:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9513" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="3701" class="nb nc jb mx b gy nh ne l nf ng">unicornParts = [🤘, 🌈, ✨, 🎶].map(add)</span><span id="3bf3" class="nb nc jb mx b gy nh ne l nf ng">🦄 = pipe(...unicornParts)(🐴)</span></pre><p id="68c4" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们已经大大降低了复杂性，但似乎仍有一些问题。因为我们已经在数组上映射了<code class="fe ni nj nk mx b">add</code>，我们可以尝试直接使用ol' <code class="fe ni nj nk mx b">pipeReducer</code>而不是调用<code class="fe ni nj nk mx b">pipe</code>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="9158" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="f15c" class="nb nc jb mx b gy nh ne l nf ng">pipeReducer = (item, change) =&gt; change(item)</span><span id="d18e" class="nb nc jb mx b gy nh ne l nf ng">🦄 = (<br/>    [🤘, 🌈, ✨, 🎶]<br/>    .map(add)<br/>    .reduce(pipeReducer, 🐴)<br/>)</span></pre><p id="a382" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这就更难解释了。马离独角兽零件太远了，而且是主料！我们至少可以让它以一种有意义的方式排序:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="82d2" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="7067" class="nb nc jb mx b gy nh ne l nf ng">pipeReducer = (item, change) =&gt; change(item)<br/>initialValue = ???</span><span id="42fc" class="nb nc jb mx b gy nh ne l nf ng">🦄 = (<br/>    [🐴, 🤘, 🌈, ✨, 🎶]<br/>    .map(add)<br/>    .reduce(pipeReducer, initialValue)<br/>)</span></pre><p id="9b13" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">由于JavaScript实际上并不支持表情符号，而且我们也没有表情符号数据类型，所以也没有可以使用的起始值，比如:<code class="fe ni nj nk mx b">0</code>、<code class="fe ni nj nk mx b">''</code>、<code class="fe ni nj nk mx b">{}</code>、<code class="fe ni nj nk mx b">[]</code>、<code class="fe ni nj nk mx b">new Map()</code>等等。因此，虽然这个例子在视觉上更有意义，但我们不能使用它。相反，我们必须尝试一些更复杂的东西:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0a35" class="nb nc jb mx b gy nd ne l nf ng">pipeReducer = (item, change) =&gt; change(item)</span><span id="7af3" class="nb nc jb mx b gy nh ne l nf ng">🦄 = (<br/>    [🐴]<br/>    .concat([🤘, 🌈, ✨, 🎶].map(add))<br/>    .reduce(pipeReducer)<br/>)</span></pre><p id="005d" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这个方法绝对有代码味。很明显，我们看到了减速器的力量，但肯定有问题。因为<code class="fe ni nj nk mx b">add</code>包不住马，所以我们在设计中发现了一个瑕疵。相反，我们想使用<code class="fe ni nj nk mx b">add</code>创建一个缩减器:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ce76" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="7274" class="nb nc jb mx b gy nh ne l nf ng">sum = (combined, item) =&gt; add(combined)(item)</span><span id="c068" class="nb nc jb mx b gy nh ne l nf ng">🦄 = [🐴, 🤘, 🌈, ✨, 🎶].reduce(sum)</span></pre><p id="17c7" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">感谢我们对通用<code class="fe ni nj nk mx b">add</code>函数的重用，我们的代码看起来非常干净。我打赌我们还能做得更好！我们最大的问题是，无论何时我们想要这种功能，都必须从头开始创建像<code class="fe ni nj nk mx b">sum</code>这样的函数。我们真正需要的是一种像<code class="fe ni nj nk mx b">add</code>这样的函数生成器，并创建一种通用的方法来生成<code class="fe ni nj nk mx b">sum</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4fb0" class="nb nc jb mx b gy nd ne l nf ng">generateReducer = func =&gt; (combined, item) =&gt; func(combined)(item)</span><span id="d5ca" class="nb nc jb mx b gy nh ne l nf ng">sum = generateReducer(add)</span></pre><p id="c44e" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然这看起来没问题，但它非常有限，因为它只能接受两个值。我们真正想要构建的被称为<code class="fe ni nj nk mx b">uncurry</code>。与之相反的是，<code class="fe ni nj nk mx b">curry</code>，是一个基于参数列表创建函数生成器的函数。JavaScript有一个名为<code class="fe ni nj nk mx b">bind</code>的内置currying函数，但是它与我们需要的有点不同，因为我们不关心<code class="fe ni nj nk mx b">this</code>上下文。</p><p id="0b7a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">既然需要<code class="fe ni nj nk mx b">uncurry</code>，我们先写一个简单的<code class="fe ni nj nk mx b">curry</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="b66a" class="nb nc jb mx b gy nd ne l nf ng">curry = func =&gt; first =&gt; second =&gt; func(first, second)</span></pre><p id="ab13" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这个版本只支持最多有两个参数的函数，在传递给我们的函数之后，它只创建一个闭包。它可以把我们原来的不闭合<code class="fe ni nj nk mx b">add</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="72ba" class="nb nc jb mx b gy nd ne l nf ng">add = (additive, item) =&gt; item + additive</span></pre><p id="b100" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">并将其转换成我们一直使用的闭包版本:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ba2b" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span></pre><p id="c946" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">但是我们真的希望咖喱有更多的功能。取而代之，我们可以编写我们的<code class="fe ni nj nk mx b">curry</code>来不断返回规范的函数生成器，直到所有的参数都被赋值(也称为<code class="fe ni nj nk mx b">autocurry</code>:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5ff6" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">这个版本首先包装了我们原来的<code class="fe ni nj nk mx b">add</code>函数，返回另一个函数。当用任意数量的参数调用这个函数时，我们检查传入了多少个参数。我们要么调用带有所有参数的原始函数，要么返回另一个跟踪所有传入参数的curried函数。这意味着我们可以同时使用闭包版本和非闭包版本:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="bf7c" class="nb nc jb mx b gy nd ne l nf ng">add = (additive, item) =&gt; item + additive</span><span id="9693" class="nb nc jb mx b gy nh ne l nf ng">curriedAdd = curry(add)</span><span id="4052" class="nb nc jb mx b gy nh ne l nf ng">💩 = curriedAdd(👱, 🍫)</span><span id="3bb8" class="nb nc jb mx b gy nh ne l nf ng">💩 = curriedAdd(👱)(🍫)</span></pre><p id="9290" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">您可能已经意识到，如果我们只是从头开始，就没有理由从闭包中创建函数生成器；尽管，这并不完全正确。在很多情况下，您会希望编写闭包，而不是依赖于<code class="fe ni nj nk mx b">curry</code>:</p><ul class=""><li id="761e" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">如果你没有可用的<code class="fe ni nj nk mx b">curry</code>，你将不得不像以前一样自己编写或创建函数生成器。</li><li id="b3e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated">它创造了许多间接性和魔力，而这对于包括你自己在内的其他程序员来说可能并不明显。</li><li id="511e" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated">总是用<code class="fe ni nj nk mx b">curry</code>包装你的函数是很麻烦的，相反，编写闭包可能会更容易。</li><li id="4817" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated">如果需要微优化，currying会在代码周围添加更多的函数包装器和逻辑，最终在数万次调用后会明显变慢。</li><li id="b8d8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated">像<code class="fe ni nj nk mx b">pipe</code>这样接受未知数量参数的函数将无法用于我们的<code class="fe ni nj nk mx b">autocurry</code>示例，因为它需要已知数量的参数。使用<code class="fe ni nj nk mx b">...args</code>时，<code class="fe ni nj nk mx b">func.length</code>将始终返回<code class="fe ni nj nk mx b">0</code>。</li></ul><p id="8f32" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">我们学习<code class="fe ni nj nk mx b">curry</code>的主要原因是为了学习<code class="fe ni nj nk mx b">uncurry</code>，所以让我们深入了解一下如何扩展我们简单的<code class="fe ni nj nk mx b">sum</code>方法来创建一个函数，该函数采用函数生成器并返回一个多参数函数:</p><figure class="ms mt mu mv gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1dc5" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><code class="fe ni nj nk mx b">uncurry</code>比<code class="fe ni nj nk mx b">curry</code>复杂很多。它从用另一个函数包装我们的<code class="fe ni nj nk mx b">add</code>开始。如果您调用我们的wrapped <code class="fe ni nj nk mx b">add</code>，它将接受我们传递的任何参数，直到超过参数的数量。如果我们的<code class="fe ni nj nk mx b">add</code>函数返回一个函数，那么我们将把剩下的参数传递给那个函数，并重复这个过程，直到我们用完了传递的所有参数:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d9c1" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; item + additive</span><span id="0218" class="nb nc jb mx b gy nh ne l nf ng">💩 = add(👱)(🍓)<br/></span><span id="a909" class="nb nc jb mx b gy nh ne l nf ng">uncurriedAdd = uncurry(add)</span><span id="2632" class="nb nc jb mx b gy nh ne l nf ng">💩 = uncurriedAdd(👱, 🍓)</span></pre><p id="817f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有了工具箱中的<code class="fe ni nj nk mx b">curry</code>和<code class="fe ni nj nk mx b">uncurry</code>，我们现在可以使用<code class="fe ni nj nk mx b">uncurry</code>和<code class="fe ni nj nk mx b">add</code>来生成<code class="fe ni nj nk mx b">sum</code>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="70eb" class="nb nc jb mx b gy nd ne l nf ng">sum = uncurry(add)</span><span id="3a28" class="nb nc jb mx b gy nh ne l nf ng">🦄 = [🐴, 🤘, 🌈, ✨, 🎶].reduce(sum)</span></pre><p id="9eef" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">就这么简单，对吗？有点吧。最初的问题是不能用<code class="fe ni nj nk mx b">add</code>来<code class="fe ni nj nk mx b">map</code>所有的事情，这是因为我们的<code class="fe ni nj nk mx b">add</code>不是很通用。我们需要考虑这样一个事实，即我们可能没有将<code class="fe ni nj nk mx b">item</code>传递到我们返回的函数中:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cc84" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; (item = ???) =&gt; (<br/>    item + additive<br/>)</span></pre><p id="c336" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">虽然我们遇到了同样的问题，即没有一个假表情数据类型的默认值，但我们可以使用一个函数三元组来代替:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5d05" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; (<br/>    item<br/>    ? item + additive<br/>    : additive<br/>)</span></pre><p id="eb1c" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在我们可以做一个map-reduce来创建<code class="fe ni nj nk mx b">add</code>包装器并使用我们的<code class="fe ni nj nk mx b">pipeReducer</code>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="cb92" class="nb nc jb mx b gy nd ne l nf ng">add = additive =&gt; item =&gt; (<br/>    item<br/>    ? item + additive<br/>    : additive<br/>)</span><span id="b7cd" class="nb nc jb mx b gy nh ne l nf ng">pipeReducer = (item, change) =&gt; change(item)</span><span id="b9c6" class="nb nc jb mx b gy nh ne l nf ng">🦄 = (<br/>    [🐴, 🤘, 🌈, ✨, 🎶]<br/>    .map(add)<br/>    .reduce(pipeReducer, null)<br/>)</span></pre><p id="e69f" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当然，这不像我们之前的<code class="fe ni nj nk mx b">sum</code>函数那么简洁，但是如果你手头没有<code class="fe ni nj nk mx b">uncurry</code>，map-reduce可能就是你问题的解决方案。</p><p id="fe2a" class="pw-post-body-paragraph kz la jb lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><strong class="lb jl">感受号角！</strong></p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="6399" class="nb nc jb bd nn no np dn nq nr ns dp nt li nu nv nw lm nx ny nz lq oa ob oc jh bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/an-emoji-lovers-guide-to-functional-programming-part-4-735c17ca4113" rel="noopener">点击此处进入第4部分！</a></h2><h1 id="af41" class="od nc jb bd nn oe of og nq oh oi oj nt kq ok kr nw kt ol ku nz kw om kx oc on bi translated">更多阅读</h1><p id="b4c8" class="pw-post-body-paragraph kz la jb lb b lc oo kl le lf op ko lh li oq lk ll lm or lo lp lq os ls lt lu ij bi translated">如果您对与函数式编程相关的更多主题感兴趣，您应该看看我的其他文章:</p><ul class=""><li id="f12a" class="lw lx jb lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/how-to-safely-refactor-old-code-part-1-a1a853263fec">安全重构旧代码:第1部分</a></li><li id="21e8" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/the-secret-to-using-redux-createnamespacereducer-d3fed2ccca4a" rel="noopener">使用Redux的秘密:createNamespaceReducer </a></li><li id="c67f" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/using-redux-reducers-in-react-components-4e92985dd9cb" rel="noopener">在React组件中使用Redux还原剂</a></li><li id="7284" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/@Sawtaytoes/redux-observable-can-solve-your-state-problems-15b23a9649d7" rel="noopener"> Redux-Observable可以解决你的状态问题</a></li><li id="04cc" class="lw lx jb lb b lc mg lf mh li mi lm mj lq mk lu mb mc md me bi translated"><a class="ae mf" href="https://medium.com/flicblog/flic-buttons-and-the-observable-customization-using-rxjs-2214bc53d407" rel="noopener"> RxJS和可观察的Flic按钮</a></li></ul></div></div>    
</body>
</html>