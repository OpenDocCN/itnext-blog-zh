<html>
<head>
<title>How to survive breaking-changes of major React-Native release</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在主要反应性版本的重大变更中生存</h1>
<blockquote>原文：<a href="https://itnext.io/how-to-survive-breaking-changes-of-major-react-native-release-2464374a1ded?source=collection_archive---------3-----------------------#2020-04-14">https://itnext.io/how-to-survive-breaking-changes-of-major-react-native-release-2464374a1ded?source=collection_archive---------3-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0633" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://reactnative.dev/" rel="noopener ugc nofollow" target="_blank"> React-native </a>是最受欢迎的跨平台移动框架，拥有超过+86k GitHub明星和超过363k活跃社区开发者。</p><h1 id="ab2f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="864a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一个现实的假设是，一个新的RN版本包含了突破性的变化，这对开发者来说是一个新的挑战，引起了意想不到的头痛(！).面对升级困境，有一个简单而高效的解决方案—在内部查找:)</p><h1 id="2933" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">咚咚这是主要版本</h1><p id="667c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">最近我们公布了一个新的主要版本<code class="fe lp lq lr ls b">react-native</code> (0.62)。令人高兴的是，它包含了我们一直在等待的性能改进和关键错误修复— <em class="lt">万岁！</em></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/d82081d1151821d385c7d5f41730ea86.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*9YIjCLMKFRxOT1oVDS5D6A.png"/></div></figure><p id="01cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在我们让兴奋接管之前，我们知道当一个新的<code class="fe lp lq lr ls b">react-native</code>主要版本发布时，开发者会进入紧急情况🤯关心突破性的改变。</p><h1 id="33ef" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">巨大的困境</h1><p id="a605" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">您发现自己渴望升级到新版本，因为您等待了很久的重大改进和重要的错误修复(即<strong class="jp ir">用户</strong>等待)。</p><p id="ca3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，在查看版本发布说明时，现实给你留下了深刻印象，意识到升级成本将与其他一些恼人的问题作斗争😡突破性的改变。</p><p id="1bd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着升级将迫使您投入额外的精力来协调不可预测的突破性变化。</p><p id="c6d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，一个显而易见的问题是:在应用程序计划盖章后，还有时间可以分配吗？<br/>甚至更多:你真的要在这个敏感时期去触碰多个代码区吗？—当资源有限时，可能需要一些错误修复周期。</p><p id="ffb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把注意事项贴在墙上:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/4eea955bbfe70332e12c9769e9b892dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTzz4NMuAk1DclzoIecJVA.png"/></div></div></figure><p id="f97b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您选择升级，那么您可能会发现自己投入了比原始路线图更多的精力来协调差异，但是如果您不升级，那么您会发现自己落后了，携带一些连续的错误，并且可能会依赖于新版本…</p><p id="1260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">于是我们面临一个“情况”:<strong class="jp ir">到底该不该升级？</strong></p><p id="56e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你叫什么？</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mh"><img src="../Images/765267d0a04008a5e80b03bf68b14e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AphUV50IT6onkpfT.jpeg"/></div></div></figure><h1 id="b09d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">突破{through}个更改</h1><p id="602e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在急于下任何结论之前，让我们试着分析一下造成这种情况的原因。</p><p id="087f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，这里的主要问题是<strong class="jp ir">突破性变化</strong>。如果没有突破性的变化，那么升级会像威士忌酒一样顺利。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/3fbeafd93408e62e8765a38c924f239a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*tIx-vFyc6lyUiCcjZa2vXw.png"/></div></figure><p id="32d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">react-native</code>版本中的大部分突破性变化可以分为两类:</p><ol class=""><li id="b169" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">从<code class="fe lp lq lr ls b">react-native</code>堆芯、<strong class="jp ir">中取出的组件</strong>到外部回购，用于社区维护。</li><li id="262a" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">组件<strong class="jp ir"> API在<code class="fe lp lq lr ls b">react-native</code>内核内</strong>改变。</li></ol><p id="0723" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们中的智者会说，可能有第三种选择，即在不改变API的情况下改变组件的内部功能。但实际上这不是一个“突破性的改变”,而是行为的改变。</p><blockquote class="mx"><p id="4912" class="my mz iq bd na nb nc nd ne nf ng kk dk translated">为了降低中断更改的风险，我们应该找到一种方法来减少<code class="fe lp lq lr ls b">react-native</code> API与我们的应用程序代码库之间的摩擦。</p></blockquote><p id="3329" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">令人欣慰的是，这不一定是“蓝色药丸红色药丸”的情况，但有一盏灯😇在隧道的尽头。</p><h1 id="2fa9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">[2]裹在(1)里的鸟</h1><p id="b9d7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">减少两个代码部分之间的摩擦，也称为<strong class="jp ir">解耦</strong>和<strong class="jp ir">封装</strong>，是面向对象编程的优良原则。</p><p id="d0aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解耦</strong>确保两个不同的组件不会紧密依赖于彼此。</p><p id="cf2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">封装是将一个组件的内部功能隐藏在一个定义好的接口后面。</p><p id="59dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，字面意思是从<code class="fe lp lq lr ls b">react-native</code>包中导入并<strong class="jp ir">包装</strong>某个组件，并使用这个<strong class="jp ir">包装的组件</strong>作为所有代码库的源代码。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nm"><img src="../Images/46498c8ee78535cc4ba48d9cb14586e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GDfqhHtlXEeBhJyP.jpg"/></div></div></figure><p id="79af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来很简单，下面是一个从<code class="fe lp lq lr ls b">react-native</code>的核心包装<code class="fe lp lq lr ls b"><a class="ae kl" href="https://reactnative.dev/docs/textinput" rel="noopener ugc nofollow" target="_blank">TextInput</a></code>组件的简单例子:</p><ol class=""><li id="b1a4" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">在<code class="fe lp lq lr ls b">./components/core</code>目录下创建<code class="fe lp lq lr ls b">TextInput.js</code>文件</li></ol><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/78ff38f34b6820e5261867f45368e372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*QjzkCiPOLF7TNdrLYMsG9Q.png"/></div></figure><p id="4823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.直接从<code class="fe lp lq lr ls b">react-native</code>包导入原点<code class="fe lp lq lr ls b">TextInput</code>组件。</p><p id="b5c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.封装<code class="fe lp lq lr ls b"><em class="lt">font-family</em></code> <em class="lt"> </em>样式<em class="lt">的自定义功能。</em></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi no"><img src="../Images/ddc5b3a9c902f4a9315b489d76804588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6lW5IGeocxZlH6StZD9Cw.png"/></div></div></figure><p id="c149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.从你当地的来源消费<code class="fe lp lq lr ls b">TextInput</code>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi np"><img src="../Images/0a264422736d6172cfb4136584fdab55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z1BDIL2HuK5DQtsDsdSHIQ.png"/></div></div></figure><p id="d72c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vualá，<code class="fe lp lq lr ls b">TextInput</code>inner functional封装在<code class="fe lp lq lr ls b">TextInput.js</code>文件中，可以很容易地从一个“真实的单一来源”进行控制，而不需要改变消费事件。</p><p id="b3e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循这个简单而有效的<strong class="jp ir">包装</strong>，我们促进了<code class="fe lp lq lr ls b">react-native</code>与代码库之间的隔离，并实现了内部组件功能的轻松定制。一包两鸟— <em class="lt">万岁！</em></p><p id="39f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看如何用行动来克服这种破坏性的改变。</p><h1 id="3fe1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">展示橱窗</strong>研究</h1><p id="11e4" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">拥抱你自己的一个习惯，在一个新发布的<code class="fe lp lq lr ls b">react-native</code>版本上，推荐过一遍发布说明——让我们在<a class="ae kl" href="https://github.com/react-native-community/releases/blob/master/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank">最新版本0.62 </a>上检查一下🕵️。</p><p id="894a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在更改日志详细信息中找到“<strong class="jp ir">Breaking”</strong>部分，即“Breaking-changes”——不要太短…</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/2133e6e9f36c3d2894d51e5f70ef37fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M68jpxd0abylA3Ac7tZzQA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">React-Native v0.62更改日志，重大更改列表</figcaption></figure><p id="0337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">观察第二个项目符号:“<em class="lt">移除</em> <code class="fe lp lq lr ls b"><em class="lt">TextInput</em></code> <em class="lt">的</em> <code class="fe lp lq lr ls b"><em class="lt">onTextInput</em></code> <em class="lt">道具”。<br/> </em>当然我们都是<code class="fe lp lq lr ls b">TextInput</code>在我们的应用中的重度消费者，直接从<code class="fe lp lq lr ls b">react-native</code>包导入，在应用代码库中可能会出现<code class="fe lp lq lr ls b"><strong class="jp ir">onTextInput</strong></code>。但是正如我们注意到的，这个API在上一个主要版本中发生了变化。我们肯定能克服这种突破性的变化(*)。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nv"><img src="../Images/1d6adb32fde2f554317879a0818c32a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0Bhjm9okE_i4OEXJvTpBA.png"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">提交详细信息</figcaption></figure><h2 id="5dce" class="nw kn iq bd ko nx ny dn ks nz oa dp kw jy ob oc la kc od oe le kg of og li oh bi translated">1.<code class="fe lp lq lr ls b">onTextInput'</code>搞清楚功能</h2><p id="c812" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated"><code class="fe lp lq lr ls b">onTextInput</code>是一个回调函数，在用户输入新文本时被调用，与<code class="fe lp lq lr ls b"><a class="ae kl" href="https://reactnative.dev/docs/textinput#onchangetext" rel="noopener ugc nofollow" target="_blank">onChangeText</a></code>回调函数一样触发(我想这就是为什么由于冗余的重叠功能，它被从新的<code class="fe lp lq lr ls b">react-native</code>版本中删除了)。</p><p id="21c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件数据方案是:</p><pre class="lv lw lx ly gt oi ls oj ok aw ol bi"><span id="725b" class="nw kn iq ls b gy om on l oo op">{<br/>   nativeEvent: {<br/>      text,                 // value of *<strong class="ls ir">diff</strong>* text<br/>      previousText,         // the previous value of text<br/>      range: { start, end } // cursor position  <br/>   }<br/>}</span></pre><p id="9eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要有趣的是<code class="fe lp lq lr ls b">text</code>值属性。<br/>下面是升级前<strong class="jp ir">的使用方法:<br/>(注意<code class="fe lp lq lr ls b">TextInput</code>是直接从<code class="fe lp lq lr ls b">react-native</code>包导入的)</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oq"><img src="../Images/ec328258d62edcc062d1433f0a669c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DTMZvND6X27SSI2FcurLg.png"/></div></div></figure><h2 id="0db8" class="nw kn iq bd ko nx ny dn ks nz oa dp kw jy ob oc la kc od oe le kg of og li oh bi translated">2.包装</h2><p id="a40e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在您的<code class="fe lp lq lr ls b">./components/core</code>目录、<br/>中创建一个新的<code class="fe lp lq lr ls b">TextInput</code>文件组件(我建议将它嵌套在<code class="fe lp lq lr ls b">./components/core</code>下，这表明了它的重要性)。直接从<code class="fe lp lq lr ls b">react-native</code>包导入<code class="fe lp lq lr ls b">TextInput</code>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi or"><img src="../Images/a4b21ad14b45d6e5364f574a7eae7934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhG9soitG235f1_7MQHmPw.png"/></div></div></figure><p id="80a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将所有出现的<code class="fe lp lq lr ls b">TextInput</code>指向创建的本地源文件，而不是直接指向<code class="fe lp lq lr ls b">react-native</code>——通过仿真器运行应用程序，以确保不会出错。</p><pre class="lv lw lx ly gt oi ls oj ok aw ol bi"><span id="ea4f" class="nw kn iq ls b gy om on l oo op">import TextInput from './components/core/TextInput';</span><span id="fe3a" class="nw kn iq ls b gy os on l oo op">or</span><span id="024b" class="nw kn iq ls b gy os on l oo op">import { TextInput } from './components/core';</span></pre><p id="28b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您获得了一个<code class="fe lp lq lr ls b">TextInput</code>元件的去耦隔离层。</p><p id="c2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我们强调了避免大范围代码变更的愿望，那么我们现在为什么要这样做呢？—实际上我们没有，<strong class="jp ir">我们没有更改任何逻辑或功能</strong>，只是更改了导入引用。所以那次行动没有风险。</p><h2 id="cfe5" class="nw kn iq bd ko nx ny dn ks nz oa dp kw jy ob oc la kc od oe le kg of og li oh bi translated">3.封装对帐</h2><p id="f270" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在包装器内部实现一个对<code class="fe lp lq lr ls b">onTextInput</code>回调的模仿，以协调强制中断更改。</p><p id="41b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循代码说明:</p><ul class=""><li id="906e" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated">为<code class="fe lp lq lr ls b">TextInput</code>实现一个<code class="fe lp lq lr ls b">React</code>组件。记住<code class="fe lp lq lr ls b">import React from 'react'</code>，你需要<code class="fe lp lq lr ls b">Babel</code>到<em class="lt"> transpile </em>这个<code class="fe lp lq lr ls b">React</code>组件，否则这一切都不行。</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ou"><img src="../Images/fb09d93ffd11c6a8d5daaffdf76e4884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuFXIQZa03LkDt4IQOkurQ.png"/></div></div></figure><ul class=""><li id="71a1" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated">将<code class="fe lp lq lr ls b">onChangeText</code>与<code class="fe lp lq lr ls b">props</code>分开，并实现内部函数——验证它是否被正确调用。</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ov"><img src="../Images/1945b00010fa567bb22329e34549887b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L92ub9nlih2v-gCbS-BeEg.png"/></div></div></figure><ul class=""><li id="44b9" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated">“骑”在<code class="fe lp lq lr ls b">onChangeText</code>回调上触发<code class="fe lp lq lr ls b">onTextInput</code>事件(因为两者都是同样触发的，而在新的情况下没有这样的回调<code class="fe lp lq lr ls b">onTextInput</code>🤓).</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ow"><img src="../Images/174081d535bcb002ab4584941f280c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir-wBQ4EDW8nPU8_K6IoPg.png"/></div></div></figure><ul class=""><li id="2f47" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated">填充<code class="fe lp lq lr ls b">onTextInput</code> API以支持模式:</li></ul><pre class="lv lw lx ly gt oi ls oj ok aw ol bi"><span id="1858" class="nw kn iq ls b gy om on l oo op">{<br/>   nativeEvent: {<br/>      text,                 // value of *<strong class="ls ir">diff</strong>* text<br/>      previousText,         // the previous value of text<br/>      range: { start, end } // cursor position  <br/>   }<br/>}</span></pre><ul class=""><li id="7920" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated"><code class="fe lp lq lr ls b">previousText</code> —实际上是<code class="fe lp lq lr ls b">TextInput</code>的<code class="fe lp lq lr ls b">value</code>属性，还没有改变(将在<code class="fe lp lq lr ls b">onChangeText</code>结束后提交)。</li></ul><pre class="lv lw lx ly gt oi ls oj ok aw ol bi"><span id="0fc1" class="nw kn iq ls b gy om on l oo op">const { value: previousText } = rest;</span></pre><ul class=""><li id="2ab3" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated"><code class="fe lp lq lr ls b">text</code> —我使用<code class="fe lp lq lr ls b">lodash</code>来查找差异<code class="fe lp lq lr ls b">text</code>，但是你可以使用你喜欢的任何东西。</li></ul><pre class="lv lw lx ly gt oi ls oj ok aw ol bi"><span id="75b8" class="nw kn iq ls b gy om on l oo op">import _ from ‘lodash’;<br/>...</span><span id="3e7e" class="nw kn iq ls b gy os on l oo op">const { value: previousText } = rest;<br/>const diiText = _.difference((newText || '').split(''), (previousText || '').split('')).join('');</span></pre><ul class=""><li id="57ce" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated"><code class="fe lp lq lr ls b">range</code> —取自任何光标位置变化时触发的<code class="fe lp lq lr ls b"><a class="ae kl" href="https://reactnative.dev/docs/textinput#onselectionchange" rel="noopener ugc nofollow" target="_blank">onSelectionChange</a></code>回调，我在这里使用了<em class="lt">钩子</em>来保存它的状态(**)。</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ox"><img src="../Images/eae1059545b908f8af0caae7a01ba9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_N5Xa8zmKJD7afwDJR3Fw.png"/></div></div></figure><ul class=""><li id="2104" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated">让代码更具防御性以避免错误，以防某些回调不作为<code class="fe lp lq lr ls b">props</code>提供——我用的是<code class="fe lp lq lr ls b">lodash</code>，但是你可以使用你喜欢的任何东西。</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oy"><img src="../Images/2f71a4424dba55e2740b09a70a19e743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FItezlJGMNgwygi-rqMS6Q.png"/></div></div></figure><ul class=""><li id="e97f" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk ot mp mq mr bi translated">一起</li></ul><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oz"><img src="../Images/f4da692fc69d0584d4e58a35c3151a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rp1b8elFDMj5-g6lB2ofkA.png"/></div></div></figure><h2 id="0b83" class="nw kn iq bd ko nx ny dn ks nz oa dp kw jy ob oc la kc od oe le kg of og li oh bi translated">4.消费</h2><p id="5bb2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这种实现对于消费者来说是无缝的，并且功能与以前一样，不需要改变代码库中的任何逻辑或功能。从本地源头消费就行了。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/0dec2a14d70dce29b82c36f870faf6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*6wCelvecTKI00iKy.jpg"/></div></figure><h1 id="b5f8" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">全部包起来</h1><p id="b502" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">你有权利保护自己免受即将到来的破坏性变化，而不是与可能导致长QA周期的几个修改竞争。</p><p id="d0e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种包装方式大大降低了压制性中断-变更协调的风险。节省时间、金钱和紧张。</p><p id="b708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议:全部打包。你将拥有大约40个精简的<code class="fe lp lq lr ls b">./components/core</code>文件，而不是分散在整个代码库中。</p><p id="4502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">祝你下次升级好运！</strong></p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="52a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找到上面的代码示例@我的<a class="ae kl" href="https://github.com/domainio/RN-Breaking-Changes-Wrap" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">GitHub</strong></a><strong class="jp ir"><br/></strong>链接到我的<a class="ae kl" href="http://www.linkedin.com/in/erez-zohar-15960856" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">简历</strong> </a></p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="1192" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(*)适当披露:<code class="fe lp lq lr ls b">onTextInput</code>将在0.62.2版中完全删除，但在0.62版中仍然可用</p><p id="45ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(**)本文没有涵盖所有的<code class="fe lp lq lr ls b">onSelectionChange</code>边缘案例，它需要更长的代码示例，这超出了本文的范围。</p></div></div>    
</body>
</html>