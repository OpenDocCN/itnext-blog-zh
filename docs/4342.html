<html>
<head>
<title>Sourcebit: How to make friends with various data sources in the Jamstack?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sourcebit:如何与Jamstack中的各种数据源交朋友？</h1>
<blockquote>原文：<a href="https://itnext.io/sourcebit-how-to-make-friends-with-various-data-sources-in-the-jamstack-7bd552e86ff2?source=collection_archive---------2-----------------------#2020-06-11">https://itnext.io/sourcebit-how-to-make-friends-with-various-data-sources-in-the-jamstack-7bd552e86ff2?source=collection_archive---------2-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ba80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们使用多个CMS、API和它们的数据契约时，总是会变得很困难。如果有一种方法可以统一一些Jamstack组件，比如数据源和前端框架，会怎么样？</p><p id="4a3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为软件项目或网站选择正确的技术会带来很多困难。一旦你习惯了使用一个特定的堆栈，你会倾向于优先考虑它。根据我的经验，出于习惯使用特定的平台来构建项目是很常见的。此外，当开发团队最终切换到不同的平台时，他们被迫重写项目——本质上是扔掉工作并从头开始。</p><p id="ec59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有另一个极端，项目也是在原始平台上构建的。结果，仅仅因为缺乏创新，就有新的绿地项目建立在旧的平台和技术之上(年轻的我用Objective-C代替闪亮的新Swift)。</p><p id="036a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在web开发和JavaScript世界中更加明显。几乎每天都有新的框架出现，并悄悄地被摒弃。尝试检查新技术似乎不仅是浪费时间，而且也不可能跟上。静态站点生成器和整个Jamstack生态系统没有什么不同。掌握所有可用的CMS和可能的静态站点生成器的组合听起来像是一个没有希望的计划。</p><p id="4f97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">必须有某种方法来简化和统一所有不同的内容管理系统、数据源和静态站点生成器，对吗？</p><h1 id="e2e6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">数据标准化将一切简化成乐高积木</h1><p id="a61b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当我还是个孩子的时候，没有PlayStation或网飞，我最喜欢的消磨时间的方式就是玩积木。随着时间的推移，我收集了许多由不同的制造商用不同的材料和形状制作的各种套件。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0a28aa28a34d5133898f400acc9d3952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8s7eJ6MtHLBr8vpE3q_-w@2x.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">不相容的砖块。</figcaption></figure><p id="b664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谁会想到多年以后我会用Jamstack组件解决同样的问题呢？只是现在我们称之为互操作性、兼容性、不同合同或供应商锁定。</p><p id="2e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些术语不仅在软件开发中是一个相当广泛的概念。如果有一种方法可以将各种内容管理系统(具有不同的API、SDK和客户机)的数据契约与不同的静态站点生成器统一起来并连接起来，那岂不是很棒？一种不期望您深入研究各种数据源和前端框架的每种组合的方式？这就是Sourcebit的目标。把所有这些组件变成兼容的乐高块，让你玩。</p><h1 id="4ea0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是Sourcebit？</h1><p id="8a3a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Sourcebit是麻省理工学院许可的开源平台，提供数据标准化、转换和连接各种内容管理系统和目标静态站点生成器和前端框架。如果没有它，您必须使用API或SDK从CMS获取内容，并将这些数据处理到目标平台的特定合同中。</p><p id="e81c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多CMS可以使用，比如Contentful，Kontent，甚至Wordpress。所有这些CMS都有不同的输出、API和SDK。还有许多流行的静态站点生成器被广泛使用，如Hugo、Jekyll或Next.js。其中每一个都使用特定的平台——JavaScript、go或Ruby——来利用构建过程。其中的每一个都可以处理不同格式的数据——Markdown、Frontmatter、JSON、YAML或HTML。Sourcebit和它的插件生态系统为你做了这一切，所以你可以专注于开发项目。</p><h1 id="4359" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Sourcebit是如何工作的？</h1><p id="e9e1" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">Sourcebit与三种不同类型的插件一起工作— <em class="mf">源</em>、<em class="mf">转换</em>和<em class="mf">目标</em>。它们分别负责获取、转换和规范化数据。</p><p id="4640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">source插件负责从数据源(通常是CMS)中检索和规范化数据。转换插件处理特定的数据转换，例如，在本地保存远程资源和媒体文件。最后，目标插件获取所有这些规范化的数据，并将它们转换成所选目标框架或静态站点生成器要求的格式。这个概念是开放和可扩展的。除了使用现成的插件，你还可以开发自己的插件。Sourcebit的人在他们的维基上非常清楚地描述了整个插件的概念。</p><h1 id="e716" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">平滑配置</h1><p id="08a0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">每次我想评估新的平台、服务或框架时，仅仅为了得到一个简单的概念证明，就要努力正确地配置服务，这简直是地狱般的努力。令人惊讶的是，配置Sourcebit是一种愉快的体验。就我个人而言，这是Sourcebit中我最喜欢的部分。Sourcebit提供了这个简洁的交互式向导，可以为您完成所有困难的工作。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/f2d59604dd1ed7a78a02cd4213c98aea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*EqHaK2JlgRvePnpYgu64DQ.gif"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Sourcebit交互式向导。</figcaption></figure><p id="30ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，您仍然可以自己创建一个完整的配置文件，手动指定所有的标识符、插件和数据转换。但你为什么要这么做？</p><h1 id="7db2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">整个想法听起来不错…但它实际上是如何工作的呢？</h1><p id="fb7a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">为了向您展示Sourcebit是如何工作的，让我们尝试将markdown文件中硬编码的静态内容迁移到一个headless CMS中。对于这个例子，我使用了<a class="ae me" href="https://bit.ly/36ref8S" rel="noopener ugc nofollow" target="_blank"> Kentico Kontent </a>，然而，你可以使用任何支持的source bits<a class="ae me" href="https://github.com/stackbithq/sourcebit#source-plugins" rel="noopener ugc nofollow" target="_blank">源代码插件</a>。</p><p id="981e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进行演示，我们可以从头开始构建整个网站，然而，本文并不是关于Jekyll、Hugo或Next.js的细节，所以我选择了一个来自<a class="ae me" href="https://jamstackthemes.dev/" rel="noopener ugc nofollow" target="_blank">https://jamstackthemes . dev</a>的<a class="ae me" href="https://github.com/chesterhow/tale" rel="noopener ugc nofollow" target="_blank">现有的</a>博客模板(确实是一个非常好的灵感模板来源！).这个页面是用Jekyll构建的。话虽如此，同样的原则也适用于Hugo或Next.js目标插件和站点。</p><p id="97eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在此找到以下配方<a class="ae me" href="https://sourcebit-kontent-tale.netlify.app/" rel="noopener ugc nofollow" target="_blank">的运行输出。这项任务的方法非常简单:</a></p><ol class=""><li id="3cdc" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">派生项目并将内容迁移到CMS中。</li><li id="2863" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">配置Sourcebit以从CMS获取内容并使其正常化。</li><li id="5df1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">获取内容并在本地运行项目。</li><li id="5722" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">将站点配置和部署到网络。</li><li id="6921" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">当CMS中的内容发生变化时，配置重建站点。</li></ol><p id="dc06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">注意:您需要安装Node.js、npm和Jekyll来本地运行项目。如果你在代码或者教程的某个地方卡住了，可以在GitHub </em>  <em class="mf">上查看已经完成的</em> <a class="ae me" href="https://github.com/makma/tale" rel="noopener ugc nofollow" target="_blank"> <em class="mf">示例库。</em></a></p><h1 id="2059" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.派生项目并将内容迁移到CMS中</h1><ul class=""><li id="ee20" class="mh mi iq jp b jq lj ju lk jy mv kc mw kg mx kk my mn mo mp bi translated">在GitHub上分叉<a class="ae me" href="https://github.com/chesterhow/tale" rel="noopener ugc nofollow" target="_blank">项目</a>。</li><li id="ab9e" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">用<code class="fe mz na nb nc b">git clone https://github.com/&lt;your_handle&gt;/tale.git</code>在本地克隆您的分叉库。</li><li id="3204" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">如果您仔细检查代码，您会发现站点的内容位于<em class="mf"> _pages </em>和<em class="mf"> _post </em>目录中。我们需要将这些内容复制到<a class="ae me" href="https://bit.ly/36ref8S" rel="noopener ugc nofollow" target="_blank">Kentico kon content</a>中。</li><li id="4612" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">转到<em class="mf">项目</em>部分，在Kontent中创建<a class="ae me" href="https://bit.ly/36ref8S" rel="noopener ugc nofollow" target="_blank">一个新项目</a>。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nd"><img src="../Images/2b453e4bae3b3de2f0a209e7e1999d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnCj0kQjHx8Sg10ThdYQpg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">在Kentico Kontent中创建一个项目。</figcaption></figure><ul class=""><li id="4280" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">转到<em class="mf">内容模型</em>部分，创建<em class="mf">页面</em>内容类型。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ne"><img src="../Images/aca7f7bf42b82b3c0e0c021beb1d7105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Xp8gkMCQb7P62Y4jriyfw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">在Kentico Kontent中创建内容类型。</figcaption></figure><ul class=""><li id="f3be" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">添加<em class="mf">标题</em>、<em class="mf">作者</em>、<em class="mf">永久链接、</em>和<em class="mf">布局</em>文本元素。因为这个Jekyll网站使用markdown格式的内容，所以还添加了一个名为<em class="mf"> content </em>的markdown自定义元素。我已经为您准备好了我的markdown定制元素—您可以使用我的URL — <code class="fe mz na nb nc b">https://sourcebit-tale-article-markdown-element.netlify.app/</code>或者派生出<a class="ae me" href="https://github.com/Simply007/kontent-custom-element-toast-ui-editor" rel="noopener ugc nofollow" target="_blank">原始存储库</a>并将其部署到Netlify。(你可以在这里了解更多关于定制元素<a class="ae me" href="https://docs.kontent.ai/tutorials/develop-apps/integrate/content-editing-extensions" rel="noopener ugc nofollow" target="_blank">。)</a></li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nf"><img src="../Images/5586268df63617d6ad15083f04a16741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNwFn9Sx5tvB1Hi4tDpTuA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">页面内容类型。</figcaption></figure><ul class=""><li id="fcab" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">用<em class="mf">标题</em>、<em class="mf">作者</em>和<em class="mf">布局</em>文本元素创建<em class="mf">帖子</em>内容类型。对于内容，我们将再次需要一个markdown定制元素。使用您的降价编辑器URL创建一个自定义元素。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ng"><img src="../Images/fecdbe558dee7c2e57519b920c199a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZCKqa0imVn7AExF2Ikwcw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">自定义降价元素。</figcaption></figure><ul class=""><li id="a72e" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">在<em class="mf">内容&amp;资产</em>部分，创建一个页面和帖子——只需将静态文件中的内容(从<em class="mf"> _pages </em>和<em class="mf"> _posts </em>目录)复制并粘贴到Kontent中。</li></ul><h1 id="80de" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.配置Sourcebit以从CMS获取内容并使其正常化</h1><ul class=""><li id="c01a" class="mh mi iq jp b jq lj ju lk jy mv kc mw kg mx kk my mn mo mp bi translated">由于内容将由Sourcebit和<a class="ae me" href="https://github.com/kentico/sourcebit-source-kontent" rel="noopener ugc nofollow" target="_blank">koncontent Source plugin</a>获取，我们将不再需要任何硬编码的静态内容。删除项目中的<em class="mf"> _pages </em>和<em class="mf"> _posts </em>目录。您还应该将它们添加到<em class="mf">中。gitignore </em>文件。</li><li id="c804" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">让我们配置Sourcebit。在网站项目的根目录下，运行<code class="fe mz na nb nc b">npx create-sourcebit</code>命令启动交互式命令行配置。你可以用箭头键在项目间移动，用<em class="mf">空格键</em>选择选项，用<em class="mf">回车</em>键确认。</li><li id="3896" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">选择<code class="fe mz na nb nc b">@kentico/sourcebit-source-kontent (by Kentico): A Kontent source plugin for Sourcebit</code>并确认。</li><li id="5f73" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">在这个例子中，我们不需要转换资产，所以用<em class="mf"> Enter </em>键跳过这个步骤。</li><li id="889d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">选择<code class="fe mz na nb nc b">sourcebit-target-jekyll (by Stackbit): A Sourcebit plugin for Jekyll target plugin</code>并确认。</li><li id="4b16" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">输入Kontentʼ s项目<em class="mf">项目Id </em>并确认。你可以在<em class="mf">项目设置</em>-&gt;-<em class="mf">API键</em>部分找到你的项目中的<em class="mf">项目Id </em>。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nh"><img src="../Images/2d4b18d72bdf9dca6517efb8814c7114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0i-8SUGX7TvWMNKVlpICug.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">获取项目Id。</figcaption></figure><ul class=""><li id="a30c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">输入<code class="fe mz na nb nc b">default</code>语言并确认。</li><li id="b0fc" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">根据屏幕配置模型/内容类型。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ni"><img src="../Images/fc0778a4e7c6d7df20a5958d4caa9679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YIIcowiu7zDG_Du_ochLg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">在Kentico Kontent中配置Sourcebit和项目。</figcaption></figure><p id="0bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">完成交互式向导后，注意新创建的名为sourcebit.js的文件。这是sourcebit的配置文件，定义了如何获取、转换、序列化和使用内容。一旦您在CMS中更改了项目或数据的结构，您可以再次通过交互式向导来生成新的配置，或者您可以只编辑这个文件。完整的Sourcebit配置也在平滑配置部分提供的. gif文件中。</em></p><h1 id="9dc6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.获取内容并在本地运行项目</h1><ul class=""><li id="e04f" class="mh mi iq jp b jq lj ju lk jy mv kc mw kg mx kk my mn mo mp bi translated">运行<code class="fe mz na nb nc b">sourcebit fetch</code>命令。现在Sourcebit将从CMS获取所有数据，并根据我们生成的<em class="mf"> Sourcebit.js </em>配置将它们存储到已经定义的目录中。</li><li id="4714" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">您可以使用<code class="fe mz na nb nc b">jekyll serve</code>命令在本地运行站点。现在该网站正在使用来自Kontent的数据。</li></ul><h1 id="1a18" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.将站点配置和部署到网络服务器</h1><p id="4d63" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在这一步中，我们将配置Netlify版本。</p><ul class=""><li id="8e48" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">将部署脚本添加到<a class="ae me" href="https://github.com/makma/tale/blob/master/package.json#L8" rel="noopener ugc nofollow" target="_blank"><em class="mf">package . JSON</em></a><em class="mf">的脚本部分。</em><br/>T2。这将安装所有必要的依赖项，获取并规范化所有数据，并构建Jekyll站点。</li><li id="bed2" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">用<a class="ae me" href="https://github.com/makma/tale/blob/master/.ruby-version" rel="noopener ugc nofollow" target="_blank">创建一个文件<em class="mf">。</em>ruby-version</a>名称同Ruby的版本。我的情况是<code class="fe mz na nb nc b">2.6.2</code>。</li><li id="b7a7" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">因为我们想在webserver的根目录下运行站点，<a class="ae me" href="https://github.com/makma/tale/commit/328350b2d24c377e4b2aad19119f7eca3ac51b81#diff-aeb42283af8ef8e9da40ededd3ae2ab2" rel="noopener ugc nofollow" target="_blank">从<em class="mf"> _config.yml </em>中删除</a> <code class="fe mz na nb nc b">baseurl</code>。</li><li id="8f0e" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">推动所有的改变。</li><li id="98be" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">登录<a class="ae me" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>并从Git 用现有的GitHub库创建<em class="mf">新站点。</em></li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nj"><img src="../Images/1bd26a78671c8f8a94bd02ce264fb13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*it_TitXPLh6gzJ-KQyps3w.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用Netlify创建一个新站点。</figcaption></figure><ul class=""><li id="beca" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">在Netlify的用户界面中，选择要部署的<code class="fe mz na nb nc b">master</code>分支，输入<code class="fe mz na nb nc b">npm run deploy</code>作为构建命令，<code class="fe mz na nb nc b">_site/</code>作为发布目录，部署站点。成功构建后，您的站点将被部署并在Netlify上公开。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/eb8f7e678239a497860925f6c7a57d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*Y8TAeE1pRmnkawBs2IHsPA.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用Netlify构建和部署项目的设置。</figcaption></figure><h1 id="f536" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">5.当CMS中的内容发生变化时，配置重建站点</h1><p id="3d98" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">现在，我们已经部署了我们的站点，内容不是硬编码的，而是从CMS动态获取的。但是，当内容在CMS中更新时，所做的更改还没有反映在已部署的站点上。为了实现这一点，一旦CMS中的内容发生变化，我们必须触发一个新的Netlify构建。</p><ul class=""><li id="c03b" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">在Netlify界面，进入站点设置，进入<em class="mf">构建钩子</em>部分，点击<em class="mf">添加构建钩子</em>。命名你的钩子，例如<em class="mf"> Kontent.ai内容更新</em>，保存并复制生成的URL。</li><li id="8be4" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk my mn mo mp bi translated">进入<a class="ae me" href="https://app.kontent.ai/" rel="noopener ugc nofollow" target="_blank"> app.kontent.ai </a>到你的项目<em class="mf">设置</em> - &gt; <em class="mf"> Webhooks </em>创建一个新的webhook。将已经复制的webhook URL地址粘贴到<em class="mf"> URL地址</em>字段，并将您的webhook命名为，例如<em class="mf"> Netlify构建触发器</em>。保存更改。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nl"><img src="../Images/37dd05a55c9775d438803194d68af93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZLK0QiLnmrFbTuNiBPQEw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">触发Netlify构建的webhook的配置。</figcaption></figure><ul class=""><li id="810e" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk my mn mo mp bi translated">当您现在更改CMS中的内容时，在发布项目后，将会触发webhook，并且您的站点将会使用更新后的内容进行重建。</li></ul><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nm"><img src="../Images/9b728232dc4b0f2714fa6e12a5f362fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOIwbwsyVt3qXZsyysHrYA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">Netlify上已完成部署的站点。</figcaption></figure><h1 id="c2bc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">下一步是什么？</h1><p id="e4f4" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">使用Sourcebit和可用的插件，即使没有定制的获取和规范化逻辑，也可以很容易地将大量数据源与目标平台连接起来。这使得为各种前端框架和静态站点生成器开发网站变得更简单、更便宜。</p><p id="8aa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信Sourcebit可以改变人们开发Jamstack网站的方式。此外，从供应商的角度来看，Sourcebit可能是为每个目标平台实现生态系统的一个很好的替代方案。</p><p id="6e11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是Sourcebit功能的一个简单例子，只有一个源插件和一个目标插件。还有更多的东西可以探索，如Hugo或Next.js目标平台、观察和预览未发布的更改、多语言站点，甚至资产转换。另一个全新的挑战是创建你自己的定制插件——你可以看看我的插件(T17 ),然后在Twitter上告诉我你的想法(T18)。</p><h1 id="23a0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">奖金</h1><p id="4539" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果你不是一个Jekyll的家伙，你更愿意看到一些关于Sourcebit与Next.js结合的内容，我强烈推荐我的同事<a class="ae me" href="https://twitter.com/ondrabus" rel="noopener ugc nofollow" target="_blank"> @OndraBus </a>的这个很棒的视频。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="2b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">原载于</em><a class="ae me" href="https://kontent.ai/blog/sourcebit-how-to-make-friends-with-various-data-sources-in-the-jamstack" rel="noopener ugc nofollow" target="_blank"><em class="mf">kontent . ai</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>