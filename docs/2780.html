<html>
<head>
<title>Geting 4x Speedup With .NET Core 3.0 SIMD Intrinsics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">获得4倍的速度提升。NET Core 3.0 SIMD内部函数</h1>
<blockquote>原文：<a href="https://itnext.io/geting-4x-speedup-with-net-core-3-0-simd-intrinsics-5c9c31c47991?source=collection_archive---------2-----------------------#2019-07-31">https://itnext.io/geting-4x-speedup-with-net-core-3-0-simd-intrinsics-5c9c31c47991?source=collection_archive---------2-----------------------#2019-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几周前<a class="ae ko" href="https://twitter.com/denplusplus" rel="noopener ugc nofollow" target="_blank"> Den Raskovalov </a>和我就C#性能进行了一次有趣的谈话，这变成了一次微小但有趣的编码练习。证明或反驳的陈述是:</p><blockquote class="kp kq kr"><p id="2e78" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">“下面列出的C++代码，被翻译成C#，在速度上永远不会接近C++。”</em></p></blockquote><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="8aac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设:</p><ul class=""><li id="73eb" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">我们保持单线程</li><li id="3c3e" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">它读取的文件可能足够短(约1 GB或更少)，可以缓存在RAM中，即IO带宽不会成为瓶颈。</li></ul><p id="d7e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不想深入研究代码，下面是它的作用:</p><blockquote class="kp kq kr"><p id="44a1" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">该文件存储使用</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Variable-length_quantity" rel="noopener ugc nofollow" target="_blank"> <em class="it">变长数量编码方案</em> </a> <em class="it">编码的(0 … 1，000，000)范围内的整数列表。计算所有这些整数的和。</em></p><p id="43e9" class="jq jr ks js b jt ju jv jw jx jy jz ka kt kc kd ke ku kg kh ki kv kk kl km kn im bi translated"><em class="it">编码方案使用每个字节中的最高有效位(MSB)来表示当前数的位序列(MSB=0)是否有延续(MSB=1)。</em> <a class="ae ko" href="https://en.wikipedia.org/wiki/Variable-length_quantity#Examples" rel="noopener ugc nofollow" target="_blank"> <em class="it">下面是一个类似的整数编码方式的例子</em> </a> <em class="it">。</em></p></blockquote><p id="bca8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们开始改进我们的代码计算版本，在遵守上述规则的同时，尽可能地提高速度。Den在C++端玩。</p><p id="8406" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使这篇文章简短，我在这里将主要集中在C#方面，尽管<a class="ae ko" href="https://github.com/alexyakunin/YetAnotherStupidBenchmark" rel="noopener ugc nofollow" target="_blank">你可以在这里找到C#和C++代码</a>(我的仓库，我会用C#和C++代码的最新版本来更新它，以防将来有任何变化)和<a class="ae ko" href="https://github.com/evilmucedin/yetanotherstupidbenchmark/" rel="noopener ugc nofollow" target="_blank">这里</a> (Den的仓库，那里有最新的C++代码)。</p><p id="c21c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算总和的原始C#代码:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">高级包装器读取文件在这里很常见；它获得一个指向计算逻辑的具体实现的委托(即什么必须是最优的)。</p><p id="b67d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在酷睿i7–8700k、Ubuntu 19.04、gcc或。包含测试数据的NET Core 3.0预览版5和大约1GB文件:</p><ul class=""><li id="4dc0" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">对于C++，大约430毫秒</li><li id="da6c" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">C#约500毫秒</li></ul><p id="1319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一轮优化相对简单:</p><ul class=""><li id="e527" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">C++:通过编译器选项(<em class="ks">-Ofast-fomit-frame-pointer-March = native-mtune = native-funroll-loops-Wno-shift-count-overflow</em>)启用一组优化，启用PGO (profile guided optimization)，使用内存映射文件</li><li id="1dbc" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">C#:使用不安全的指针，展开主循环，添加一个依赖异步管道的版本。我做最后一部分主要是为了测试是否有任何好处——我使用的实现违反了最初的“单线程”条件，因为那里的生产者读取另一个块，而消费者计算总和；另一方面，依赖于内存映射文件的C++版本正在隐式地做类似的事情——所以在这两种情况下，它看起来都不像是对我们的“单线程”规则的明显违反(即，我们在这里同意文件读取操作可能是并发的)。</li></ul><p id="f4b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更新的C#代码:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="76a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果还是非常相似:</p><ul class=""><li id="e930" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">C++版本为394毫秒</li><li id="e349" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">带异步管道的C#版本为416毫秒</li><li id="187e" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">“常规”C#版本为462毫秒</li></ul><p id="d0b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我试图实现一些其他的想法——特别是，<a class="ae ko" href="https://github.com/alexyakunin/YetAnotherStupidBenchmark/blob/master/DotNetCore/Program.cs#L315" rel="noopener ugc nofollow" target="_blank">实现了一个几乎完全依赖于非分支指令的版本</a>,但是没有一个工作得更好。</p><p id="1352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一轮带来了近5倍的加速:<a class="ae ko" href="https://www.facebook.com/alexey.poyarkov.18" rel="noopener ugc nofollow" target="_blank">阿列克谢·波亚尔科夫</a>写了一个极其高效的<a class="ae ko" href="https://github.com/alexyakunin/YetAnotherStupidBenchmark/blob/master/Cpp/main.cpp#L127" rel="noopener ugc nofollow" target="_blank">基于AVX2的版本的和计算代码</a>。我把他的代码一行一行地翻译成C#。NET Core 3.0 SIMD是内在的，后来做了一些修饰性的改变。这就是C#代码的最终版本:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="68fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果是:</p><ul class=""><li id="2d20" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">C++版本为95毫秒</li><li id="881c" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">C#版本为130毫秒</li><li id="6c1b" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">带异步流水线的C#版本为113毫秒。</li></ul><p id="112a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我发现在Ubuntu的C#版本中使用内存映射文件实际上很有意义。从我过去的经验来看，它们在Windows上没有提供任何好处——此外，事实恰恰相反，所以我甚至没有尝试将这作为最初的优化之一。但是看起来这是阅读文件最快的方法。Ubuntu上的NET Core:</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="c0b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终排名:</p><ul class=""><li id="11d5" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">C++版本为95毫秒</li><li id="383f" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">C#版本为101毫秒</li></ul><p id="9587" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，这些结果几乎是完美的:计算总和的基线测试(假设它是Int64值的序列)花费的时间几乎相同，因此CPU不再是这段代码的瓶颈——它是RAM带宽。这就是我们必须停止的地方。</p><p id="233d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的结论是:</p><ul class=""><li id="2313" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">C#绝对适合类似的计算密集型任务——尤其是。网络核心3.0</li><li id="6057" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">如果您大规模运行类似的工作负载，差异预计会更小:只有在单线程的情况下，CPU才是这个测试的瓶颈。如果我们同时运行4个或更多类似的任务(想象一下一个web服务器解码UTF8输入，等等)。)，即使在非SIMD版本上也达到了内存带宽限制。</li></ul><p id="b801" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是来自Den Raskovalov的结论(我也完全同意他的观点):</p><p id="6997" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“我同意Alex得出的大部分结论，但我想强调您要注意几件事:</p><ul class=""><li id="e514" class="ld le it js b jt ju jx jy kb lf kf lg kj lh kn li lj lk ll bi translated">即使使用现代编译器和库，低级优化仍然很重要。实际上，该算法的第一个版本比最终版本慢10倍。编译器仍然吸收IO模式的优化，不能像有经验的工程师那样很好地使用AVX/SSE流水线。</li><li id="9649" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">C#和C++代码的最终版本几乎完全相同。微软显然明白利用低级优化的重要性。C#是真正的工具，不是CS玩具。我的荣誉属于这里的女士们。在我们开始“比赛”之前，我预计naive C++实现可以提高10倍，但没想到。NET可以使用相同的低级优化。</li><li id="36c5" class="ld le it js b jt lm jx ln kb lo kf lp kj lq kn li lj lk ll bi translated">即使在平台融合后的2019年，Alex在运行我在Linux上开发的C++代码时也遇到了麻烦。我跑步有困难。NET代码也是如此。Alex的版本需要最新版本的。NET核心，即使C++版本在6年前的GCC或clang上运行良好。"</li></ul><p id="a6d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看我的新项目:<a class="ae ko" href="https://github.com/servicetitan/Stl.Fusion" rel="noopener ugc nofollow" target="_blank"> Stl。Fusion </a>，一个面向。NET Core和Blazor力争成为您实时应用的首选。其统一的状态更新管道是真正的<a class="ae ko" href="https://medium.com/@alexyakunin/stl-fusion-in-simple-terms-65b1975967ab" rel="noopener">独特和令人兴奋的</a>。</p></div></div>    
</body>
</html>