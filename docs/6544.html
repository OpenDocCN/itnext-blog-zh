<html>
<head>
<title>Modern C++ in Advent of Code: Day14</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++代码的出现:第14天</h1>
<blockquote>原文：<a href="https://itnext.io/modern-c-in-advent-of-code-day14-6f8347ec68d5?source=collection_archive---------0-----------------------#2021-12-14">https://itnext.io/modern-c-in-advent-of-code-day14-6f8347ec68d5?source=collection_archive---------0-----------------------#2021-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f212" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是代码问世的第十四天<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">。今天，我们将使用C++20协同程序来扩展聚合物(然后使用频率计数的正确方法)。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/296361e992806fa396ac035f1666d6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsM3YIdw0y_6nC_s60y7mQ.png"/></div></div></figure><p id="a9fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，请先尝试解决问题，然后再看解决方案。对于本系列的所有文章，<a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">请查看此列表</a>。</p><h1 id="90ca" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第14天:第一部分</h1><p id="0fbf" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们的目标是重复扩展由大写字母表示的聚合物，使用扩展规则，通过在两个现有的两个字母之间插入一个新字母来扩展两个字母的序列。例如:<code class="fe mb mc md me b">NNCB</code>使用规则<code class="fe mb mc md me b">NN-&gt;C, NC-&gt;B, CB-&gt;H</code>扩展到<code class="fe mb mc md me b">NCNBCHB</code>。</p><p id="44d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果每对字母对应一条规则，我们最终会在每一步中使聚合物长度加倍，所以你可能会得到一个提示，简单地扩展聚合物可能不是正确的解决方案。然而，对于应用C++20协程来说，这是一个非常好的用例，以至于我不得不使用一种懒惰的强力方法来解决第1部分，我们将在第2部分讨论正确的解决方案。</p><p id="c8b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么是懒惰的强力方法呢？每一代将解决方案扩展2倍会带来两个问题。第一个是计算性的(每一步比前一步多运行2倍)。第二个问题是存储。对于具有32GB内存的典型机器，我们只能存储前34代的结果。</p><p id="9326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们懒散地对待这个问题呢？我们只会在需要的时候展现一个角色。当然，这并不能解决计算问题，但我们将所需内存限制为代数的小倍数。</p><p id="2b09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一个生成器协程。这个协程将产生字符，这些字符将被下一代或主进程使用，后者将计算字符的频率。然而，首先，我们还需要一个基线协程:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d0b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个协程将作为基础，从我们的初始输入生成字符。第二个协程是实际的扩展器，它将从上一代读取字符，然后在每两次读取之间产生一个额外的字符。</p><p id="1daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的main函数中，我们解析输入，然后根据需要将这些协程堆叠到所需的深度(代数):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d9c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样每一代消耗上一代生成的字符，最后main消耗结果，一个字符一个字符。</p><p id="c5d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个，我们需要实现我们的协程:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="910a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的基本协程中，我们从输入中读取并逐个生成字符(第2–3行)。在实际的扩展器中，我们从上一代中读取字符，并将其作为参数接收。然后我们检查是否有匹配的扩展规则(第12行),如果有，我们产生额外的字符(除了产生字符read——第11行和第15行)。</p><p id="d042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们就有了一个懒惰的强力解决方案，虽然速度很慢，但使用的内存很少。如果你觉得这很有趣，可以看看我的协程文章:<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/c-20-coroutines-complete-guide-7c3fc08db89d">完整指南</a>，<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/c-20-practical-coroutines-79202872ebba">实用示例</a>。</p><h1 id="826e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第14天:第二部分</h1><p id="78bf" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">好了，现在是时候妥善解决这个问题了。这里的核心观察是扩张是独立的。当我们扩展时，例如使用规则<code class="fe mb mc md me b">AB-&gt;C</code>将<code class="fe mb mc md me b">AB</code>扩展到<code class="fe mb mc md me b">ACB</code>，扩展完全是局部的。它不影响字符<code class="fe mb mc md me b">A</code>和<code class="fe mb mc md me b">B</code>或字符串的任何其他部分。</p><p id="a7bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用明确的术语来说:当我们应用扩展规则时，<code class="fe mb mc md me b">AB-&gt;C</code>我们正在减少<code class="fe mb mc md me b">AB</code>序列的数量，添加新的<code class="fe mb mc md me b">AC</code>和<code class="fe mb mc md me b">CB</code>序列，并添加字母<code class="fe mb mc md me b">C</code>。</p><p id="fe38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，最优解不需要展开聚合物。相反，它可以计算序列和字符的变化频率。</p><p id="2cff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们回到我们的典型结构，从声明开始:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="eef6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们引入了一个自定义对，将其用作unordered_map中的一个键。它遵循与前几天的观点相同的想法。最后，我们将间歇频率包装在一个结构中，用一个来自起始聚合物的构造器初始化器和一个tick方法，该方法采用转换规则并将生成向前推进一步。</p><p id="2dea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试，我们使用来自AoC的输入:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于输入解析，我们依赖于读取空格分隔的字符串，检查我们是否遇到了意外情况:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="beed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始化时，我们记录每个字符和每对字符:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="444b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Tick方法实现了前面提到的公式:</p><ul class=""><li id="1965" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">我们减少了输入对的实例数量(第19行)</li><li id="69e4" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">我们增加插入字符的频率(第20行)</li><li id="2c9d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">然后增加两个新对的频率(第22–25行)</li></ul><p id="d9d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，没有临时变量我们无法做到这一点，因为第22–25行生成的新对可能是循环中尚未处理的对之一。</p><p id="24ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的main中，我们解析输入，创建计数器的实例，并勾选所需的次数。最后，我们挑选最大和最小(非零)频率，并计算差异。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="07e3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">链接和技术说明</h1><p id="2da7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">每日解决方案存储库位于:<a class="ae kl" href="https://github.com/HappyCerberus/moderncpp-aoc-2021" rel="noopener ugc nofollow" target="_blank">https://github.com/HappyCerberus/moderncpp-aoc-2021</a>。</p><p id="13e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@happy.cerberus/list/advent-of-code-2021-using-modern-c-c5814cb6666e" rel="noopener">看看这个列表，里面有关于《代码降临》其他日子的文章</a>。</p><p id="7b59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且请不要忘记亲自尝试一下<a class="ae kl" href="https://adventofcode.com/2021" rel="noopener ugc nofollow" target="_blank">降临码</a>。</p><h1 id="d5c3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">感谢您的阅读</h1><p id="2ab1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">感谢您阅读这篇文章。你喜欢吗？</p><p id="1113" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在YouTube上发布视频。你有问题吗？在推特<a class="ae kl" href="https://twitter.com/SimonToth83" rel="noopener ugc nofollow" target="_blank">或LinkedIn </a>上联系我。</p></div></div>    
</body>
</html>