<html>
<head>
<title>Continuous Delivery On Kubernetes With GitOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过GitOps在Kubernetes上持续交付</h1>
<blockquote>原文：<a href="https://itnext.io/continuous-delivery-with-gitops-591ff031e8f9?source=collection_archive---------2-----------------------#2019-08-21">https://itnext.io/continuous-delivery-with-gitops-591ff031e8f9?source=collection_archive---------2-----------------------#2019-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fdca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从典型的CI/CD管道到GitOps</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2d50e58434f54c1ee02db1086ef4738d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXYkUt_-XNkOFSk3F-KxbQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://www.weave.works/blog/what-is-gitops-really" rel="noopener ugc nofollow" target="_blank">GitOps到底是什么？</a>(来源:Weaveworks)</figcaption></figure><h1 id="4c9c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="cf3c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">GitOps是由<a class="ae le" href="https://weave.works" rel="noopener ugc nofollow" target="_blank"> Weaveworks </a>推出的一种连续交付方式。它通过使用Git作为声明性基础设施和应用程序的单一事实来源来工作。</p><p id="9ed0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一个简单的项目中，我们将看到如何设置一个典型的CI/CD管道，然后如何修改它，将GitOps添加到图片中。</p><p id="3767" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本帖中，我们将演示几周前在CNCF的沙盒中接受的GitOps核心组件<a class="ae le" href="https://fluxcd.io" rel="noopener ugc nofollow" target="_blank"> Flux </a>。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="620a" class="lf lg it bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">我们将做什么</h1><p id="323e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">下面是我们将遵循的步骤列表:</p><ul class=""><li id="92a8" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">GitOps简介</li><li id="a9dc" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">设置一个简单的项目并在GitLab中管理它</li><li id="fd72" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">集成Kubernetes集群</li><li id="2186" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">设置典型的CI/CD管道</li><li id="28f7" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">用GitOps处理CD部分</li></ul><h1 id="0445" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">GitOps简介</h1><blockquote class="ni"><p id="1e6d" class="nj nk it bd nl nm nn no np nq nr kn dk translated">GitOps是一种持续交付的方式。它通过使用Git作为声明性基础设施和应用程序的事实来源来工作。当对Git进行更改时，自动化交付管道会向您的基础设施推出更改。</p><p id="98a7" class="nj nk it bd nl nm nn no np nq nr kn dk translated">—编织作品</p></blockquote><h2 id="7153" class="ns lg it bd lh nt nu dn ll nv nw dp lp kb nx ny lt kf nz oa lx kj ob oc mb od bi translated">将更改部署到集群:推还是拉</h2><p id="bfe8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在典型的CI/CD管道中，CI工具负责运行测试、构建映像、检查CVE以及将新映像重新部署到集群中，如下面的模式所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/8eddcf1c340e7394b40cf9256f5b93a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xBY9lJ6TVsg-9ECmw2WMA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">典型的CI/CD管道(来源:Weaveworks)</figcaption></figure><p id="b0f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GitOps方法有所不同，因为部署部分不是由CI工具完成的，而是由操作员完成的，操作员是在集群内的Pod中运行的流程(这里是Flux)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/4ed7b752712f574e5bce1ec9be64ee01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6kaBHrOIZchc9pdWSNa7Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">包括GitOps在内的CI/CD管道(来源:Weaveworks)</figcaption></figure><h2 id="290e" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">涉及的组件</h2><p id="40ce" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">下面的模式显示了在Kubernetes集群的上下文中使用GitOps时所涉及的组件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/92386acdc969f1a092d56597e3da00f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygi3faYya5TMeFTYS9cWhw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Kubernetes集群中的GitOps组件(来源:Weaveworks)</figcaption></figure><p id="70b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简单起见，Flux守护进程会持续运行并检查新的Docker映像。当检测到新的映像时，它调用API服务器来更新正在运行的部署。</p><p id="aa28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章的最后一部分，我们将设置Flux并使用它来部署一个简单的应用程序。</p><h1 id="bd54" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">该项目</h1><p id="952a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们将考虑一个简单(非常简单)的烧瓶应用程序。项目的复杂性在这里并不重要，最重要的是对整个CI/CD流程的理解。</p><h2 id="9253" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">源代码</h2><p id="bf65" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们只考虑以下文件:</p><ul class=""><li id="b3e8" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om"> app.py </em>公开一个HTTP端点并返回一个字符串</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="0b3b" class="ns lg it oo b gy os ot l ou ov">from flask import Flask<br/>app = Flask(__name__)<br/><br/>@app.route("/")<br/>def hello():<br/>    return "Hello World!"<br/><br/>if __name__ == "__main__":<br/>    app.run(host='0.0.0.0', port=8000)</span></pre><ul class=""><li id="9e0c" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om"> requirements.txt </em>定义了<em class="om"> Flask </em>库<em class="om"> app.py </em>所需的依赖关系</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="de56" class="ns lg it oo b gy os ot l ou ov">Flask==1.0.2</span></pre><ul class=""><li id="b813" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om"> Dockerfile </em>用于从源代码中构建一个映像</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="a8da" class="ns lg it oo b gy os ot l ou ov">FROM python:3-alpine<br/>COPY . /app<br/>WORKDIR /app<br/>RUN pip install -r requirements.txt<br/>CMD python /app/app.py</span></pre><h2 id="ac7b" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">确保它正常工作</h2><p id="ceba" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们首先为我们的应用程序创建第一个Docker图像</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="e2fc" class="ns lg it oo b gy os ot l ou ov">$ docker image build -t hello:1.0 .</span></pre><p id="2f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦构建了映像，我们就可以使用它运行容器。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="2760" class="ns lg it oo b gy os ot l ou ov">$ docker container run -p 8000:8000 hello:1.0<br/> * Serving Flask app “app” (lazy loading)<br/> * Environment: production<br/> WARNING: Do not use the development server in a production environment.<br/> Use a production WSGI server instead.<br/> * Debug mode: off<br/> * Running on <a class="ae le" href="http://0.0.0.0:8000/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000/</a> (Press CTRL+C to quit)</span></pre><p id="ba6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的服务器正在监听端口8000，如下图所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ow"><img src="../Images/31550b664d5edce98618e45b51fcbf6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8Ba9MgGEe7lM_XKfaVOeA.png"/></div></div></figure><h2 id="61c2" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">GitLab项目</h2><p id="7993" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们将使用GitLab来管理这个应用程序，所以让我们创建一个名为<em class="om"> hello </em>的新项目:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/67b7922fd2e6829c8c45a5fe9b4efd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLdyqxTB5T5l_6u5C-kaBg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在GitLab中创建新项目</figcaption></figure><p id="a184" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以为应用程序文件夹初始化git，并将所有内容推送到GitLab项目中:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="7c7f" class="ns lg it oo b gy os ot l ou ov">$ git init<br/>$ git remote add origin git@gitlab.com:lucj/hello.git<br/>$ git add .<br/>$ git commit -m "Initial commit"<br/>$ git push -u origin master</span></pre><p id="f59f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几秒钟后，我们可以通过GitLab web界面看到项目中的3个文件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/96839f5de6ead91b46b7afc21e631d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOfkRfZ9t4_oWhPwFmRDrg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">代码的首次提交</figcaption></figure><h1 id="891a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">进入Kubernetes</h1><p id="3ca1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">因为我们想在Kubernetes集群上部署我们的应用程序，所以我们将使用GitLab的Kubernetes集成功能来导入项目中外部集群的配置。</p><h2 id="d31d" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">创建受管集群</h2><p id="2c89" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">DOKS(<a class="ae le" href="https://digitalocean.com" rel="noopener ugc nofollow" target="_blank">digital ocean</a>managed Kubernetes cluster)是我最喜欢的解决方案，易于设置和使用。它可以从DigitalOcean web界面或使用专用的<a class="ae le" href="https://github.com/digitalocean/doctl" rel="noopener ugc nofollow" target="_blank"> doctl </a>命令行界面创建。在本例中，我们将建立一个3个工作节点的集群，管理节点由DigitalOcean为我们管理。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/4c552c2c1074cc053f693941dc07accc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZgFRFNpjpsx2xHLigdEcMA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从数字海洋网络界面创建受管理的Kubernetes集群</figcaption></figure><p id="83f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调配基础架构和创建群集需要几分钟时间。一旦完成，我们需要检索kubeconfig文件，这样我们的we <a class="ae le" href="https://kubernetes.io/fr/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>客户机就可以与集群的API服务器通信。我们将使用doctl命令行并将此配置保存在<em class="om"> k8s-demo.cfg </em>文件中:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="e3aa" class="ns lg it oo b gy os ot l ou ov">$ doctl k8s cluster cfg show k8s-demo &gt; k8s-demo.cfg</span></pre><p id="9c6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们配置<em class="om"> kubectl </em>与我们的集群通信，设置KUBECONFIG环境变量:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="712a" class="ns lg it oo b gy os ot l ou ov">$ export KUBECONFIG=$PWD/k8s-demo.cfg</span></pre><p id="9651" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切就绪。让我们检查一下集群的状态:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="2acb" class="ns lg it oo b gy os ot l ou ov"><strong class="oo iu">$ kubectl get nodes<br/></strong>NAME            STATUS   ROLES    AGE     VERSION<br/>k8s-demo-rlf5   Ready    &lt;none&gt;   2m10s   v1.15.2<br/>k8s-demo-rlfh   Ready    &lt;none&gt;   2m40s   v1.15.2<br/>k8s-demo-rlfk   Ready    &lt;none&gt;   2m33s   v1.15.2</span></pre><h2 id="a2c5" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">与GitLab项目集成</h2><p id="5ace" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在GitLab的web界面上，将外部Kubernetes集群集成到项目中非常容易。我们只需要进入<em class="om">操作&gt; Kubernetes </em>然后点击<em class="om">添加Kubernetes集群</em>:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/51c8779c54f08945e5e7f1821e88ddaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cBiWTBgbCrS4I37H6rbpXQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Kubernetes集群的集成</figcaption></figure><p id="b5e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们需要选择<em class="om">添加现有集群</em>选项卡。在那里，我们需要填写几个字段。它们中的第一个可以很容易地从配置文件中检索到:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/dabef351fe8cbccf4a47b694ca4bbac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_arcxf-pbDPrekg0AuFIOQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Kubernetes集群集成期间要填写的字段</figcaption></figure><ul class=""><li id="7bf6" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">集群名称</li><li id="00a0" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">API服务器的URL</li><li id="873e" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">群集的CA证书</li></ul><p id="052a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了向GitLab提供集群CA证书，我们需要对配置中指定的证书进行解码(因为它是以base64编码的)。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="8b64" class="ns lg it oo b gy os ot l ou ov">$ kubectl config view --raw \<br/>-o=jsonpath='{.clusters[0].cluster.certificate-authority-data}' \<br/>| base64 --decode</span></pre><ul class=""><li id="b858" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">服务令牌</li></ul><p id="ca59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取标识令牌的过程包括几个步骤。我们首先需要创建一个<code class="fe pa pb pc oo b">ServiceAccount</code>并为其提供<code class="fe pa pb pc oo b">cluster-admin</code>角色。这可以通过以下命令完成:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="0cac" class="ns lg it oo b gy os ot l ou ov"><strong class="oo iu">$ cat &lt;&lt;EOF | kubectl apply -f -</strong><br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: gitlab-admin<br/>  namespace: kube-system<br/>---<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: gitlab-admin<br/>roleRef:<br/>  apiGroup: rbac.authorization.k8s.io<br/>  kind: ClusterRole<br/>  name: cluster-admin<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: gitlab-admin<br/>  namespace: kube-system<br/><strong class="oo iu">EOF</strong></span></pre><p id="3761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦创建了ServiceAccount，我们就检索相关的<em class="om">机密</em>:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="4457" class="ns lg it oo b gy os ot l ou ov">$ SECRET=$(kubectl -n kube-system get secret | grep gitlab-admin | awk '{print $1}')</span></pre><p id="fbb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加提取它的JWT令牌，我们需要在GitLab界面的<em class="om">服务令牌</em>字段中输入的令牌:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="b927" class="ns lg it oo b gy os ot l ou ov">$ TOKEN=$(kubectl -n kube-system get secret $SECRET -o jsonpath='{.data.token}' | base64 --decode) &amp;&amp; echo $TOKEN</span></pre><p id="2bd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在验证集群集成之前，我们取消选中<em class="om"> GitLab-managed-cluster </em>复选框，因为我们将管理自己的名称空间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/6194264ebaa0db3bfd4a868a8596aaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIMXyuop8za9wYMbV6fCgA.png"/></div></div></figure><p id="52f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦集群被集成，GitLab允许通过Helm charts一键安装几个应用程序。虽然我们不会在这篇文章中使用它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/77da59cc6d08c2d87a47d9ea095a84fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwCnuHogun2MIvzNkXVUjQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Kubernetes集群与我们的GitLab项目相集成</figcaption></figure><h1 id="c2eb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置典型的CI/CD管道</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/1ccf0c0b550669de6eda9f631a092c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdzknNZ80b-nMr-YiDIU5A.png"/></div></div></figure><p id="d0d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从添加一个<em class="om">开始。gitlab-ci.yml </em>文件在我们项目的根目录下。它用于定义每次新代码提交到存储库时触发的操作。</p><p id="91e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在该文件的顶部，我们定义了管道的不同阶段:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="9a32" class="ns lg it oo b gy os ot l ou ov">stages:<br/>  - package<br/>  - test<br/>  - push<br/>  - deploy</span></pre><p id="9011" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，对于每个阶段，我们定义要执行的操作:</p><ul class=""><li id="c6d2" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om"> package </em> stage从源代码中创建一个Docker映像，并使用一个临时标签将它推送到项目的GitLab映像库(稍后将详细介绍)</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="3884" class="ns lg it oo b gy os ot l ou ov">build:<br/>  image: docker:stable<br/>  stage: package<br/>  services:<br/>    - docker:dind<br/>  script:<br/>   - docker build -t $CI_REGISTRY_IMAGE:tmp .<br/>   - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY<br/>   - docker push $CI_REGISTRY_IMAGE:tmp<br/>  only:<br/>  - master</span></pre><ul class=""><li id="9610" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om">测试</em>阶段从新创建的映像运行一个容器，并确保返回的消息以“Hello”开头</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="701d" class="ns lg it oo b gy os ot l ou ov">test:<br/>  image: docker:stable<br/>  stage: test<br/>  services:<br/>    - docker:dind<br/>  script:<br/>    - docker run -d --name hello $CI_REGISTRY_IMAGE:tmp<br/>    - sleep 10s<br/>    - TEST=$(docker run --link hello lucj/curl -s http://hello:8000)<br/>    - $([ "${TEST:0:5}" = "Hello" ])<br/>  only:<br/>  - master</span></pre><ul class=""><li id="6988" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om"> push </em>阶段向图像添加新的标签，第一个标签基于git commit的散列，第二个标签是当前分支的名称(这里是master，因为我们只在master分支上触发那些动作)。然后，它将这些新标签推送到GitLab注册表中。</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="7838" class="ns lg it oo b gy os ot l ou ov">push:<br/>  image: docker:stable<br/>  stage: push<br/>  services:<br/>    - docker:dind<br/>  script:<br/>   - docker image pull $CI_REGISTRY_IMAGE:tmp<br/>   - docker image tag $CI_REGISTRY_IMAGE:tmp $CI_REGISTRY_IMAGE:$CI_BUILD_REF<br/>   - docker image tag $CI_REGISTRY_IMAGE:tmp $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME<br/>   - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY<br/>   - docker push $CI_REGISTRY_IMAGE:$CI_BUILD_REF<br/>   - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME<br/>  only:<br/>  - master</span></pre><ul class=""><li id="b16e" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><em class="om">部署</em>阶段的目的是在我们的Kubernetes集群中创建/更新应用程序。我们将在一个<em class="om"> k8s </em>文件夹中定义两个清单文件:一个部署用于管理我们的web服务器的Pod，一个服务用于向外部公开它</li></ul><p id="71fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先定义下面的<em class="om"> k8s/deploy.tpl </em>模板。它将在<em class="om">部署</em>步骤中使用，以生成指定部署资源的<em class="om"> k8s/deploy.yml </em>文件。该模板定义了基于<em class="om">registry.gitlab.com/lucj/hello</em>映像管理Pod的单个副本的部署。</p><p id="5655" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个模板中，我们使用了一个名为<em class="om"> GIT_COMMIT </em>的占位符，它被替换为提交的实际散列，稍后我们将会看到。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="063c" class="ns lg it oo b gy os ot l ou ov">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello<br/>  labels:<br/>    app: hello<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: hello<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello<br/>    spec:<br/>      containers:<br/>      - name: hello<br/>        image: registry.gitlab.com/lucj/hello:<strong class="oo iu">GIT_COMMIT</strong></span></pre><p id="41bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还在<em class="om"> k8s/service.yml，</em>中定义了一个服务资源来公开应用程序。此服务属于负载平衡器类型。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="1ecc" class="ns lg it oo b gy os ot l ou ov">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hello<br/>spec:<br/>  type: LoadBalancer<br/>  ports:<br/>    - name: hello<br/>      port: 80<br/>      targetPort: 8000<br/>      protocol: TCP<br/>  selector:<br/>    app: hello</span></pre><p id="1367" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<em class="om">部署</em>步骤中执行的动作如下:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="9180" class="ns lg it oo b gy os ot l ou ov">deploy:<br/>  stage: deploy<br/>  image: lucj/kubectl:1.15.2<br/>  <!-- -->environment: test<br/>  script:<br/>    - kubectl config set-cluster my-cluster --server=${KUBE_URL} --certificate-authority="${KUBE_CA_PEM_FILE}"<br/>    - kubectl config set-credentials admin --token=${KUBE_TOKEN}<br/>    - kubectl config set-context my-context --cluster=my-cluster --user=admin --namespace default<br/>    - kubectl config use-context my-context<br/>    - cat k8s/deploy.tpl | sed 's/GIT_COMMIT/'"$CI_BUILD_REF/" &gt; k8s/deploy.yml<br/>    - kubectl apply -f k8s<br/>  only:<br/>  - master</span></pre><p id="7d3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里需要注意几件事:</p><ul class=""><li id="1dae" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">这个步骤在包含<em class="om"> kubectl </em>客户端的映像的上下文中运行</li><li id="508f" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">从GitLab自动设置的环境变量中检索集群信息。它们用于设置Kubernetes上下文</li><li id="b4b1" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">部署资源是在模板文件之外创建的，GIT_COMMIT占位符被替换为$CI_BUILD_REF环境变量中可用的实际提交</li><li id="14e7" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">分别位于<em class="om"> k8s/service.yml </em>和<em class="om"> k8s/deploy.yml </em>中的服务和部署资源是用常用的“<em class="om">ku bectl apply”</em>命令创建/更新的</li></ul><p id="5b2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:这个管道非常简单，不是最佳的，但是它可以很好地说明不同的流程</p><h2 id="f996" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">测试事物</h2><p id="e728" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们将这些更改推送到GitLab的项目中，并检查触发的CI/CD管道</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="ffee" class="ns lg it oo b gy os ot l ou ov">$ git add k8s<br/>$ git commit -m ‘Add K8s resources’</span><span id="71d7" class="ns lg it oo b gy pe ot l ou ov">$ git add .gitlab-ci.yml<br/>$ git commit -m ‘Add GitLab pipeline’</span><span id="4fc0" class="ns lg it oo b gy pe ot l ou ov">$ git push origin master</span></pre><p id="6682" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这触发了GitLab管道，正如我们在web界面上看到的</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/2a1a12faf7e6d07da8fe6b98fa262776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IDDsQX-JFQc5cmPBtrZdSQ.png"/></div></div></figure><p id="12e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在管道的<em class="om">部署</em>阶段(最后一个)，部署和服务都被创建，因为它们以前并不存在。由于服务属于类型<em class="om"> LoadBalancer，</em>在DigitalOcean基础设施上创建了一个负载平衡器资源，如下所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/32c8c8b79a0c31f4a07aa34172ed093c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tN9J_rlpGZMTErakTH0eow.png"/></div></div></figure><p id="47d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用与负载平衡器关联的外部IP地址，我们可以在端口80上访问应用程序，目标是运行我们的应用程序的底层Pod。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/b1f310917e1e6a5d831964b59c86ac12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuN9XF-mKBtZJDS6NSBFYA.png"/></div></div></figure><p id="d9b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这表明服务和部署都已正确创建。</p><p id="18af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们稍微修改一下<em class="om"> app.py </em>，让它返回“来自Kube的Hello”而不是“Hello World！”。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="9d71" class="ns lg it oo b gy os ot l ou ov">from flask import Flask<br/>app = Flask(__name__)</span><span id="2d20" class="ns lg it oo b gy pe ot l ou ov"><a class="ae le" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/")<br/>def hello():<br/>    return "Hello from Kube"</span><span id="7530" class="ns lg it oo b gy pe ot l ou ov">if __name__ == "__main__":<br/>    app.run(host='0.0.0.0', port=8000)</span></pre><p id="09d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们承诺并推动变革</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="f2bc" class="ns lg it oo b gy os ot l ou ov">$ git add app.py<br/>$ git commit -m 'change message to Hello from Kube'<br/>$ git push origin master</span></pre><p id="17df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">触发了新的CI/CD管道，如果刷新浏览器，我们可以看到新消息</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/c27e928de6b175139526d0e1de92d1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wD-85DBqbdmrxKOfHdbBg.png"/></div></div></figure><p id="8c94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经设置了一个简单的管道，当然，如果用于真实世界的应用程序，还需要一些改进。例如，我们可以添加更多的步骤，如:</p><ul class=""><li id="a25b" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">附加测试</li><li id="d422" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">图像扫描，以确保图像不包含任何cv(或者至少不包含关键cv)</li></ul><p id="1c8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想进一步了解图像扫描部分，你可能会发现这篇文章很有用<a class="ae le" href="https://medium.com/@lucjuggery/adding-cve-scanning-to-a-ci-cd-pipeline-d0f5695a555a" rel="noopener">https://medium . com/better-programming/adding-CVE-scanning-to-a-ci-CD-pipeline-d0f 5695 a 555 a</a></p><h1 id="49a8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">将GitOps添加到图片中</h1><p id="3c70" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们现在将稍微修改一下CI/CD管道，以便用GitOps方法处理CD部分。以下架构显示了GitOps部署工作流中涉及的组件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/481d9bf59bea21a0b5a600b326c9d684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwRRFTeZO9BrJm15jo4Bbw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">GitOps部署工作流(来源:Weaveworks)</figcaption></figure><p id="9fc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，在Pod内的集群中运行的<a class="ae le" href="https://fluxcd.io" rel="noopener ugc nofollow" target="_blank"> Flux </a>操作符负责在图像注册表中检测到新的图像标记时重新部署应用程序。</p><h2 id="fde2" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">焊剂安装</h2><p id="89f4" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Flux可以从部署手动安装，也可以用<a class="ae le" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">舵</a>安装。在本文中，我们将使用手动方法。第一步是克隆<a class="ae le" href="https://github.com/fluxcd/flux" rel="noopener ugc nofollow" target="_blank"> fluxcd </a>库:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="1812" class="ns lg it oo b gy os ot l ou ov">$ git clone <a class="ae le" href="https://github.com/fluxcd/flux" rel="noopener ugc nofollow" target="_blank">https://github.com/fluxcd/flux</a> &amp;&amp; cd flux</span></pre><p id="9500" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，在部署规范(<em class="om">deploy/flux-Deployment . YAML</em>)内，我们将更改以下参数:</p><ul class=""><li id="b243" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">-git-URL = Git @ Git lab . com:lucj/hello，这告诉Flux要观察哪个Git存储库</li><li id="8330" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">- git-path=k8s，在存储库中，只考虑<em class="om"> k8s </em>文件夹(我们的Kubernetes清单文件位于该文件夹中)</li><li id="24df" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">- git-ci-skip，该选项允许在Flux(标记和部署资源)更新GitLab的项目存储库时跳过ci管道</li></ul><p id="7746" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以将Flux部署到集群:</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="3c34" class="ns lg it oo b gy os ot l ou ov"><strong class="oo iu">$ kubectl apply -f deploy</strong><br/>serviceaccount/flux created<br/>clusterrole.rbac.authorization.k8s.io/flux created<br/>clusterrolebinding.rbac.authorization.k8s.io/flux created<br/>deployment.apps/flux created<br/>secret/flux-git-deploy created<br/>deployment.apps/memcached created<br/>service/memcached created</span></pre><p id="8a55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建了几个资源:</p><ul class=""><li id="26cb" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">ServiceAccount、ClusterRole和ClusterRoleBoinding用于向Flux Pod提供操作所需的身份验证/授权</li><li id="80c4" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">通量算子</li><li id="6572" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">一个memcached的服务和部署，Flux使用它来缓存图像元数据</li></ul><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="03dd" class="ns lg it oo b gy os ot l ou ov"><strong class="oo iu">$ kubectl get pods<br/></strong>NAMESPACE NAME                       READY  STATUS   RESTARTS  AGE<br/>default   flux-dcb965db7-pn97k       1/1    Running  0         56s<br/>default   memcached-554f994578-t2tss 1/1    Running  0         56s<br/>...</span></pre><p id="201d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们查看Flux pod的日志，我们会看到一条错误消息，因为Flux无法读取项目的Git存储库。</p><blockquote class="ph pi pj"><p id="160b" class="jq jr om js b jt ju jv jw jx jy jz ka pk kc kd ke pl kg kh ki pm kk kl km kn im bi translated">权限被拒绝(publickey)。致命错误:无法从远程存储库中读取。请确保您拥有正确的访问权限，并且该存储库存在。</p></blockquote><p id="25c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们可以使用<a class="ae le" href="https://docs.fluxcd.io/en/latest/references/fluxctl.html" rel="noopener ugc nofollow" target="_blank"> fluxctl </a>实用程序来检索安装过程中生成的公共ssh密钥。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="4a26" class="ns lg it oo b gy os ot l ou ov"><strong class="oo iu">$ fluxctl identity<br/></strong>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCx4fk4YjcM7cP1FL/AKWtHpN+cg9/Qz1p5dzAlsFLMKilUUy0uCQQmaptXDZQGaZrbvNSyezgT5/yH6qau6W6ICoLYAzBku47PoWlqbUfcbPhMxHSfivjv7s4lSeUE+u3kR2opROxdyHHL+VQMI6n9Xc7qnTq6YC+VJ+RkoUUd0bgBC+Rg/aMURLD9mkAVzmWw6+Y8QAJMVNMzNDgId+8iSHKtOYsHqoxg4GqexdB1R5goE0ChBU9DPsiqLfk8jzuD2I3xuZeGW6or+/JHxa/6vO8lX+of1ZGZGZKr5i3E4OIehSwFUP2A/ypeqXEEI5gmO1s2YrM49jpS+jW4oUMP</span></pre><p id="2bb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后将这个密钥添加到我们的GitLab存储库中，当它需要创建/更新标签时，给它一个R/W访问权限。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pn"><img src="../Images/86b01b2d332aa76c1be4312e41198c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qK79QKvmWGik1opYxX0vRw.png"/></div></div></figure><h2 id="3f30" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">修改以前的管道</h2><p id="2e72" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">由于Flux负责部署对项目所做的变更(我们将在bit中测试)，我们需要删除<em class="om">的部署阶段。我们之前创建的gitlab-ci.yml </em>文件，其他的都可以保持不变。<em class="om">。gitlab-ci.yml </em>现在看起来如下，没有更多的<em class="om"> kubectl </em>与集群的API服务器交互。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="cf6c" class="ns lg it oo b gy os ot l ou ov">stages:<br/>  - package<br/>  - test<br/>  - push</span><span id="d5a2" class="ns lg it oo b gy pe ot l ou ov">build:<br/>  image: docker:stable<br/>  stage: package<br/>  services:<br/>    - docker:dind<br/>  script:<br/>   - docker build -t $CI_REGISTRY_IMAGE:tmp .<br/>   - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY<br/>   - docker push $CI_REGISTRY_IMAGE:tmp<br/>  only:<br/>  - master</span><span id="8aec" class="ns lg it oo b gy pe ot l ou ov">test:<br/>  image: docker:stable<br/>  stage: test<br/>  services:<br/>    - docker:dind<br/>  script:<br/>    - docker run -d --name hello $CI_REGISTRY_IMAGE:tmp<br/>    - sleep 10s<br/>    - TEST=$(docker run --link hello lucj/curl -s <a class="ae le" href="http://hello:8000" rel="noopener ugc nofollow" target="_blank">http://hello:8000</a>)<br/>    - $([ "${TEST:0:5}" = "Hello" ])<br/>  only:<br/>  - master</span><span id="dd17" class="ns lg it oo b gy pe ot l ou ov">push:<br/>  image: docker:stable<br/>  stage: push<br/>  services:<br/>    - docker:dind<br/>  script:<br/>   - docker image pull $CI_REGISTRY_IMAGE:tmp<br/>   - docker image tag $CI_REGISTRY_IMAGE:tmp $CI_REGISTRY_IMAGE:$CI_BUILD_REF<br/>   - docker image tag $CI_REGISTRY_IMAGE:tmp $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME<br/>   - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY<br/>   - docker push $CI_REGISTRY_IMAGE:$CI_BUILD_REF<br/>   - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME<br/>  only:<br/>  - master</span></pre><p id="5ca4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们可以删除模板文件<em class="om"> k8s/deploy.tpl </em>，因为这个文件将不再用于更新部署的清单。相反，我们将使用下面的部署，在<em class="om"> k8s/deploy.yml </em>中，Flux将在每次检测到新的图像标签时更新。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="1221" class="ns lg it oo b gy os ot l ou ov">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello<br/>  annotations:<br/>    flux.weave.works/automated: "true"<br/>    flux.weave.works/tag.hello: regexp:^((?!tmp).)*$<br/>  labels:<br/>    app: hello<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: hello<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: hello<br/>    spec:<br/>      containers:<br/>      - name: hello<br/>        image: registry.gitlab.com/lucj/hello:master</span></pre><p id="9a74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该部署的通量配置在<em class="om">注释</em>键内完成:</p><ul class=""><li id="d1c2" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">flux.weave.works/automated:“真”，激活此资源的自动重新部署</li><li id="2663" class="mu mv it js b jt nd jx ne kb nf kf ng kj nh kn mz na nb nc bi translated">flux.weave.works/tag.hello:·regexp:^((？！tmp)。)*$，确保不考虑带有<em class="om"> tmp </em>标签的临时图像</li></ul><h2 id="413b" class="ns lg it bd lh nt og dn ll nv oh dp lp kb oi ny lt kf oj oa lx kj ok oc mb od bi translated">测试事物</h2><p id="d831" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们更改<em class="om"> app.py </em>中的代码，使其现在返回“Hello from Flux”。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="8fb2" class="ns lg it oo b gy os ot l ou ov">from flask import Flask<br/>app = Flask(__name__)</span><span id="e788" class="ns lg it oo b gy pe ot l ou ov"><a class="ae le" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/")<br/>def hello():<br/>    return "Hello from Flux"</span><span id="2355" class="ns lg it oo b gy pe ot l ou ov">if __name__ == "__main__":<br/>    app.run(host='0.0.0.0', port=8000)</span></pre><p id="23c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并将此修改推送到GitLab。</p><pre class="kp kq kr ks gt on oo op oq aw or bi"><span id="4d1d" class="ns lg it oo b gy os ot l ou ov">$ git rm k8s/deploy.tpl<br/>$ git add k8s/deploy.yml .gitlab-ci.yml app.py<br/>$ git commit -m 'CD with Flux'<br/>$ git push origin master</span></pre><p id="c63c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查GitLab接口，我们可以看到管道已经被触发了几次。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi po"><img src="../Images/80ea388c6f41d00bd7406a08a3f5c97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZygMnGXuFhTeEXu757Ez2g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">创建了几个管道(其中一些被跳过)</figcaption></figure><p id="ef62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个管道由我们所做的更改触发，另一个由Flux在更新<em class="om">主</em>分支上的部署清单(<em class="om"> k8s/deploy.yml) </em>和<em class="om"> flux-sync </em>分支上的标签时触发。由于我们在Flux配置中使用了<em class="om"> - git-ci-skip </em>选项(如果我们没有这样做，管道将在一个循环中运行)，由这两个动作触发的管道被跳过(相关的动作没有被执行)。</p><p id="e9b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过再次刷新浏览器，我们可以看到新版本的应用程序已经可用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/e01b5acc3665bd26d9ab9c22ab06b5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QVPUF36_ZTUdByQfbDvj0A.png"/></div></div></figure><p id="b1de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在幕后，当Flux操作符定期检查新的图像标记时，它检测到了在CI管道中由于代码更改而创建的图像标记。然后它会自动更新部署。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e0df" class="lf lg it bd lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly mt ma mb mc bi translated">摘要</h1><p id="697f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在这篇文章中，我想对GitOps做一个概述，并展示一个简单的例子，说明如何在GitLab CI管道旁边设置它。有些东西还可以改进，比如管道中定义的步骤，使用semver命名图像的标签，…但我希望这篇文章能让你对这种方法有一个全局的了解。</p><p id="d857" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GitOps是相当一段时间以来的热门话题。。请不要犹豫，深入阅读<a class="ae le" href="https://docs.fluxcd.io/en/latest/" rel="noopener ugc nofollow" target="_blank">官方文档</a>了解更多信息。</p><p id="beaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您已经在使用GitOps方法了吗？我很想听听你对此的看法。</p></div></div>    
</body>
</html>