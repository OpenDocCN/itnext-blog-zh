# 编写可测试的 Swift —第 1 部分:依赖注入

> 原文：<https://itnext.io/writing-testable-swift-part-1-dependency-injection-f7a9e3955369?source=collection_archive---------5----------------------->

*你可以在 Github* [*这里*](https://github.com/tnev/writing-testable-swift) *关注这个系列的发展。*

![](img/dd29f3495c5c7b1a5cdf93cf71598d6e.png)

[*点击这里在 LinkedIn*](https://www.linkedin.com/cws/share?url=https%3A%2F%2Fitnext.io%2Fwriting-testable-swift-part-1-dependency-injection-f7a9e3955369) 上分享这篇文章

作为软件开发人员，我们每天都要做出很多决定。我们正在修复错误、构建功能和设计新系统。我们有太多的选择要做，有时我们不确定我们是否在做正确的选择。

那么，如果我们对自己的解决方案充满信心会怎么样呢？如果我们能够高度确信我们的代码将按预期工作，那会怎么样呢？这就是编写可测试 Swift 的目标。

本课程介绍了如何在没有任何第三方依赖的情况下编写干净、健壮且可测试的 Swift 代码。

假设我们在一家机器人工厂工作，老板要求我们为机器人创建一个类。她说，机器人需要一根电线、一根天线和一个电源才能工作，而且一旦制造出来，我们就不能更换零件。

所以我们写了一个简洁的机器人类:

太好了！这符合所有要求。

所以我们把这个拿给我们的老板，我们的老板回答，“好的，但是我们需要能够制造所有不同种类的机器人。我们的一些客户喜欢绿色电线和 5000 瓦的电源。”

该死。所以回到制图板。我们如何在制造机器人的时候动态地创造它的零件？轻松点。我们将使用一个初始化器，它接受部件的自定义值:

好吧，看起来不错！我们跑到老板的办公室，大声说，“看这个。现在你可以制造任何你想要的机器人。”

我们的老板看起来有点被逗乐了，她说，“很好，但我们实际上刚刚决定把我们的零件制造转移到海外，所以我们的机器人不能自己制造零件。”

啊！我们闷闷不乐地走出她的办公室，遇到了一个在机器人测试部门工作的朋友。我们告诉他我们在机器人课上遇到的问题。

“为什么不用**依赖注入**？”我们的朋友问道。

“Dependsiwhatsit？”，我们回复。我们的朋友引用了詹姆斯·肖的话，

> *“依赖注入就是给一个对象赋予它的实例变量。真的。就是这样。”*

就是这样！我们跑回到我们的电脑前，很快想出了一个使用依赖注入的解决方案:

这被称为初始化器注入。当我们初始化机器人时，我们给了它依赖项(实例变量)。这在理论和实践上都很简单。

在我们的例子中，使用依赖注入实际上更简单。为了说明这一点，让我们看看在我们的第一个实现中，实例变量是如何赋值的:

看看所有的复杂性和特殊性。它给我们带来了什么？一种机器人。让我们看看在第二个实现中，我们的实例变量是如何分配的:

更好，但看看仍在发生的事情——我们的机器人知道如何创造自己的零件。这意味着我们的机器人**依赖**实现电线、天线和电源。如果任何一种类型的初始化器改变了，我们将不得不改变机器人初始化器的实现。这似乎不太对，是吗？

现在，让我们看看在使用依赖注入时如何设置实例变量:

很简单。

现在我们可能会问，“电线、天线和电源的实现在哪里？在不知道这些其他组件是如何创建的情况下，我们如何知道这真的如此简单？”

这是依赖注入最伟大的部分:*我们不关心*。我们不关心电线、天线、电源或机器人的任何其他依赖是如何产生的。我们是机器人工程师；我们唯一的工作就是创建一个机器人类。我们所关心的是当我们需要的时候(在初始化的时候)得到我们的部分。

让我们指出依赖注入的一些巨大优势:

# 透明度

对象的责任和需求(依赖)变得更加清晰。通过查看我们的对象需要什么功能，以及**仅**我们的对象需要什么功能，我们可以更容易地假设我们的对象做什么。

# 分离

我们希望我们的对象只知道它们绝对需要知道的东西，以便运行。我们的机器人需要知道如何创造它的部件才能发挥作用吗？正如我们看到的使用依赖注入，不，它没有。即使我们的机器人使用它的零件，它也不负责制造那些零件。

# 退耦

当我们的软件片段被**耦合**时，它们相互依赖才能运行。紧密耦合会降低可重用性和可维护性。当我们将依赖注入与 Swift 协议的使用结合起来时，我们将在本系列的后面看到，我们可以减少组件之间的耦合。通过让我们的对象依赖于其他组件的接口，而不是它们的实现，我们将能够在架构或需求改变时更快地改变代码。

# 易测性

这可以说是编写软件时使用依赖注入的最重要的原因。测试代码的能力*直接关系到*你的组件如何获得它们的依赖。正如我们很快会看到的，如果你的对象正在创建它们自己的依赖关系，那么控制它们的行为会非常困难，这意味着测试它们的行为会非常困难或者不可能。

**想想这个:**

如果我们一开始就实现了依赖注入，那么与我们老板的对话会是怎样的呢？

这些对话并不完全是虚构的——我们项目的需求和约束是不断变化和发展的。我们的工作是确保变革不会引起恐慌。使用依赖注入是在我们对代码所做的更改中变得*确定*和*自信*的第一步。

*你可以在这里* *阅读 part 2* [*。*](https://medium.com/@tneveldine/writing-testable-swift-part-2-interfaces-e4897c426028)