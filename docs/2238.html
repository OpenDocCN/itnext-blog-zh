<html>
<head>
<title>Lazy Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">惰性日志记录</h1>
<blockquote>原文：<a href="https://itnext.io/lazy-logging-40314cf9bb25?source=collection_archive---------3-----------------------#2019-04-21">https://itnext.io/lazy-logging-40314cf9bb25?source=collection_archive---------3-----------------------#2019-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/997b0efb823cdb4ddfb9e5f8033c1ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Ie_hhG7Ufrc9VH1n4Ro0TQ.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图片由<a class="ae kb" href="https://pixabay.com/users/27707-27707/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=951778" rel="noopener ugc nofollow" target="_blank">凯文·菲利普斯</a>来自<a class="ae kb" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=951778" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="6965" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">创建日志语句时要小心。即使日志实际上不记录您的输入，也不意味着它不评估log语句。</p><p id="5a5b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">例如:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c899" class="lj lk it lf b gy ll lm l ln lo"><strong class="lf iu"><em class="lp">log</em></strong>.debug(<strong class="lf iu">"I found {} and {}"</strong>, getone(), gettwo());</span></pre><p id="55de" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">似乎，很好。字符串中包含两个参数的调试日志。</p><p id="84cd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">一切都好吗？</p><p id="65f4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">不完全是。</p><p id="6d3b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您会看到日志中的两个输入:</p><ul class=""><li id="4b91" class="lq lr it ke b kf kg kj kk kn ls kr lt kv lu kz lv lw lx ly bi translated">getone()</li><li id="97ac" class="lq lr it ke b kf lz kj ma kn mb kr mc kv md kz lv lw lx ly bi translated">gettwo()</li></ul><p id="f019" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这两种方法总是被评估。也就是说，即使不使用log语句，我们仍然会计算log调用的所有输入。</p><p id="a637" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果这些调用是昂贵的，我们可能会白白浪费大量的CPU周期。</p><p id="4997" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">典型的解决方法如下所示:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="d424" class="lj lk it lf b gy ll lm l ln lo"><strong class="lf iu">if </strong>(<strong class="lf iu"><em class="lp">log</em></strong>.isDebugEnabled()) {<br/>    <strong class="lf iu"><em class="lp">log</em></strong>.debug(<strong class="lf iu">"I found {} and {}"</strong>, getone(), gettwo());<br/>}</span></pre><p id="5d59" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">但这相当难看。难道<em class="lp"> log.debug </em>的目的不就是为了确保我们的代码只有在启用调试的情况下才会被记录吗？</p><p id="764f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们想要的是一个单行调试器语句，并且只有在启用了记录器的情况下才评估输入参数。</p><p id="098c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了解决类似的情况，我们将使用Java 8的<a class="ae kb" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html" rel="noopener ugc nofollow" target="_blank">供应商模式</a>。供应商只会在需要时计算价值。</p><p id="355e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">不幸的是，大多数日志框架不支持供应商模式。</p><p id="0648" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">至少是直接的。</p><p id="7240" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">实际上，记录器并不期望参数是一个字符串。它实际上接受任何对象。记录器将调用对象上的<em class="lp"> toString </em>方法，将其翻译成一个字符串。这里的诀窍是，如果需要，记录器将只<strong class="ke iu">调用</strong>toString，即如果启用了日志记录。</p><p id="b23e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">所以我们只需要用一个对象包装我们的供应商，该对象在调用<em class="lp"> toString </em>时调用供应商。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7505" class="lj lk it lf b gy ll lm l ln lo"><strong class="lf iu">import </strong>java.util.function.Supplier;<br/><br/><strong class="lf iu">public class </strong>LazyString {<br/>    <strong class="lf iu">private final </strong>Supplier&lt;?&gt; <strong class="lf iu">stringSupplier</strong>;<br/>    <br/>    <strong class="lf iu">public static </strong>LazyString lazy(Supplier&lt;?&gt; stringSupplier) {<br/>        <strong class="lf iu">return new </strong>LazyString(stringSupplier);<br/>    }<br/><br/>    <strong class="lf iu">public </strong>LazyString(<strong class="lf iu">final </strong>Supplier&lt;?&gt; stringSupplier) {<br/>        <strong class="lf iu">this</strong>.<strong class="lf iu">stringSupplier </strong>= stringSupplier;<br/>    }<br/><br/>    @Override<br/>    <strong class="lf iu">public </strong>String toString() {<br/>        <strong class="lf iu">return </strong>String.<em class="lp">valueOf</em>(<strong class="lf iu">stringSupplier</strong>.get());<br/>    }<br/>}</span></pre><p id="efd4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们现在可以更新日志语句，如下所示:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7ab8" class="lj lk it lf b gy ll lm l ln lo"><strong class="lf iu">import static </strong>LazyString.<em class="lp">lazy</em>;</span><span id="97b1" class="lj lk it lf b gy me lm l ln lo"><strong class="lf iu"><em class="lp">log</em></strong>.debug(<strong class="lf iu">"I found {} and {}"</strong>, <em class="lp">lazy</em>(<strong class="lf iu">this</strong>::getone), <em class="lp">lazy</em>(<strong class="lf iu">this</strong>::gettwo));</span></pre><p id="55da" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，理想情况下，日志框架将直接支持供应商。但在他们这样做之前，这是一个可以接受的变通办法。</p><p id="58aa" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如需完整代码示例，请查看我的github repo:</p><div class="mf mg gp gr mh mi"><a href="https://github.com/efenglu/lazyLogger" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">埃丰卢/拉兹洛格</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">懒惰地评估日志语句。在GitHub上创建一个帐户，为efenglu/lazyLogger的开发做出贡献。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">github.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw jv mi"/></div></div></a></div></div></div>    
</body>
</html>