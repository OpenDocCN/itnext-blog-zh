<html>
<head>
<title>Object-Oriented Carbon, C++ and Go Compared</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的Carbon，C++和Go比较</h1>
<blockquote>原文：<a href="https://itnext.io/object-oriented-carbon-c-and-go-compared-e434fb78c4a8?source=collection_archive---------1-----------------------#2022-08-12">https://itnext.io/object-oriented-carbon-c-and-go-compared-e434fb78c4a8?source=collection_archive---------1-----------------------#2022-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="050a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Go、C++和Carbon编程语言中创建类或类型层次结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d400b8ffbc833c9302b776df8fe22a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJS8RdQ26lOylIBtaNUGbA.jpeg"/></div></div></figure><p id="bfcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di"> L </span>让我们看一个简单的例子，用go、C++和谷歌的新Carbon语言创建一个代表火箭引擎的抽象基类。准确地说，Carbon不是谷歌的官方项目，而是由在谷歌工作的人完成的。</p><p id="2d53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前还没有Carbon编译器，解释器非常简单，缺少很多功能，所以我在这里写的代码是基于语言规范的，而不是由编译器验证的。记住这一点，因为可能会有错误。</p><p id="1e19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我即将出版的编程书籍<a class="ae lz" href="https://www.manning.com/books/julia-as-a-second-language" rel="noopener ugc nofollow" target="_blank"> Julia as a Second Language </a>中，我将带领读者用代码建造一艘太空火箭。这个代码项目是专门教读者如何对类型层次结构建模，以及如何进行对象组合的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/39a6b7d3836e38f160af0edb940bf3dd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9Go-abMKu6nlUXsKWXWGVQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">分级火箭的类型层次和对象组成</figcaption></figure><p id="2c73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我发现这个例子非常有用，足以<a class="ae lz" href="https://github.com/ordovician/rocket" rel="noopener ugc nofollow" target="_blank">在Go code </a>中复制它，打算有一天以此为主题写一本Go编程书。在本文中，我将用C++和Carbon建模这种类型层次和对象组合的子集。</p><p id="bf29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于整个类型层次结构的例子在我的Julia书的多个章节中进行了探讨，所以在这个故事中我们只能涵盖它的一小部分。我选择放大火箭发动机的类型层次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/52af2a3f1ea3fdae1f7dcd2da779410e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6OzhuCZb7BGGUGgblLCrzQ.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">火箭发动机的UML图</figcaption></figure><p id="25d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">火箭发动机集群是多个发动机的集合。例如，土星V月球火箭的第一级有一个由五个F1发动机组成的发动机组。SpaceX公司的现代猎鹰9号火箭第一级有9个梅林引擎，第二级有一个梅林引擎。</p><h2 id="021a" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">定义接口</h2><p id="2320" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated"><a class="ae lz" href="https://github.com/ordovician/rocket" rel="noopener ugc nofollow" target="_blank">原始Go代码</a>定义了一个抽象接口<code class="fe nd ne nf ng b">Engine</code>，供所有具体引擎<code class="fe nd ne nf ng b">Merlin</code>和<code class="fe nd ne nf ng b">CustomeEngine</code>实现。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="ae23" class="mf mg it ng b gy nl nm l nn no">// Go code - Base interface<br/><strong class="ng iu">package</strong> engine<br/><br/>// Force that causes 1kg to move 1m in one second.<br/><strong class="ng iu">type</strong> Newton float64<br/><br/>// standard measurement unit for mass, a kilogram<br/><strong class="ng iu">type</strong> Kg float64<br/><br/><strong class="ng iu">type</strong> Engine <strong class="ng iu">interface</strong> {<br/>    Mass() Kg       // Mass of whole engine<br/>    Thrust() Newton // How much engine pushes<br/>    Isp() float64   // Fuel efficiency of engine<br/>}</span></pre><p id="e23e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会注意到，我利用Go的能力让你定义像牛顿和千克这样的单位，这可以防止开发人员不小心混淆不兼容的单位。例如，我不能，偶然地，在没有编译错误的情况下增加推力的质量。</p><p id="8c93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在C++中，我们没有为单元创建类型安全的能力，除非我们为每个单元类型定义全新的类。相反，移植的C++代码将使用<code class="fe nd ne nf ng b">typedef</code>。<code class="fe nd ne nf ng b">typedef</code>就像一个别名，不提供任何实际的类型安全。C++没有Go和Java这样的接口。因此，我们必须定义一个抽象类。我们通过添加未实现的虚拟方法来实现这一点。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="11f0" class="mf mg it ng b gy nl nm l nn no">// C++ code - Base interface<br/><strong class="ng iu">namespace</strong> engine {<br/><br/>    // Force that causes 1kg to move 1m in one second.<br/>    <strong class="ng iu">typedef</strong> double Newton;<br/><br/>    // standard measurement unit for mass, a kilogram.<br/>    <strong class="ng iu">typedef</strong> double Kg;<br/><br/>    <strong class="ng iu">class</strong> Engine {<br/>    <strong class="ng iu">public</strong>:<br/>        <strong class="ng iu">virtual</strong> Kg Mass() <strong class="ng iu">= 0</strong>;   // Mass of whole engine<br/>        <strong class="ng iu">virtual</strong> Newton Thrust() <strong class="ng iu">= 0</strong>; // Power of engine<br/>        <strong class="ng iu">virtual</strong> double Isp() <strong class="ng iu">= 0</strong>;    // Fuel efficiency<br/>    };<br/>}</span></pre><p id="cfd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不喜欢C++解决方案的几个方面。因为我们没有接口的概念，我们需要通过为每个方法重复关键字<code class="fe nd ne nf ng b">virtual</code>来创建更多的样板文件。我们指出该方法必须以<code class="fe nd ne nf ng b">= 0</code>表达式作为结尾来实现，这非常奇怪而且不直观。<code class="fe nd ne nf ng b">namespace</code>在C++中引起嵌套，这在我看来是非常不切实际的。在我看来，在代码中应该避免深度嵌套。直观地跟踪多级嵌套并不容易。</p><p id="77d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Carbon解决方案解决了其中一些问题，同时保留了一些C++的问题并引入了新的问题。使用<code class="fe nd ne nf ng b">package</code>关键字可以避免名称空间嵌套。<code class="fe nd ne nf ng b">alias</code>类似于C++ <code class="fe nd ne nf ng b">typedef</code>，因此不为不同的单元提供任何类型安全。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="1ffe" class="mf mg it ng b gy nl nm l nn no">// Carbon code - Base class<br/><strong class="ng iu">package</strong> Engine <strong class="ng iu">api</strong>;<br/><br/><strong class="ng iu">alias</strong> Kg = f64;<br/><strong class="ng iu">alias</strong> Newton = f64;<br/><br/><strong class="ng iu">abstract</strong> <strong class="ng iu">class</strong> Engine {<br/>    <strong class="ng iu">abstract</strong> <strong class="ng iu">fn</strong> Mass[me: Self]() -&gt; Kg;<br/>    <strong class="ng iu">abstract</strong> <strong class="ng iu">fn</strong> Thrust[me: Self]() -&gt; Kg;<br/>    <strong class="ng iu">abstract</strong> <strong class="ng iu">fn</strong> Isp[me: Self]() -&gt; f64;<br/>}</span></pre><p id="3e5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到Go和C++有几个重要的区别:</p><ul class=""><li id="5c9c" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">我们的包附加了一个额外的关键字<code class="fe nd ne nf ng b">api</code>，默认情况下，该关键字用于将文件中声明的所有类型和函数设为公共。在Go中，大写的类型和函数是公共的。</li><li id="eed9" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">你通过添加<code class="fe nd ne nf ng b">[me: Self]</code>澄清了一个函数是一个方法而不是一个类方法。</li><li id="8c62" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">未实现的方法必须标记为<code class="fe nd ne nf ng b">abstract</code>。</li></ul><p id="a101" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相对于Go和C++我认为使用<code class="fe nd ne nf ng b">[me: Self]</code>是一种否定。它增加了代码的冗长性和噪声。另一方面，使用<em class="od">介绍者</em>关键字，比如<code class="fe nd ne nf ng b">fn</code>意味着方法名容易对齐，并且更容易浏览。在C++中，程序员被迫手动缩进代码来达到同样的效果。</p><p id="a830" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还要说的是，对整个类使用<code class="fe nd ne nf ng b">abstract</code>关键字使得这个类的用途更加明确。在C++中，类是通过使用未实现的虚方法隐式抽象出来的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/0bdb532385bbc9aa5788c4ca025b1fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tStlSIQA1XZ9OVjqRw1Kw.jpeg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">猎鹰9号火箭上使用的SpaceX公司的三个梅林火箭发动机。</figcaption></figure><h2 id="bb47" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated">实现类</h2><p id="bae0" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">让我们看看如何在各种具体的类中实现我们的<code class="fe nd ne nf ng b">Engine</code>接口。我们将首先看一个只包含方法实现而不包含数据成员的引擎实现。</p><p id="28a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go使用了所谓的<em class="od">结构类型化，</em>这意味着你只需通过在一个接口上定义所有的方法来实现一个接口。您不需要明确声明您正在实现该接口。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="67a0" class="mf mg it ng b gy nl nm l nn no">// Go code - Merlin rocket engine<br/>// Engine used on the Falcon 9 rocket made by SpaceX<br/><strong class="ng iu">type</strong> Merlin <strong class="ng iu">struct</strong> {<br/>}<br/><br/>// The mass of the rocket engine.<br/><strong class="ng iu">func</strong> (engine Merlin) Mass() Kg {<br/>	<strong class="ng iu">return</strong> 470<br/>}<br/><br/>// Think of this as similar to the horse power of a car.<br/><strong class="ng iu">func</strong> (engine Merlin) Thrust() Newton {<br/>	<strong class="ng iu">return</strong> 845e3<br/>}<br/><br/>// Specific impulse of the rocket engine. <br/>// A measure of fuel efficiency.<br/><strong class="ng iu">func</strong> (engine Merlin) Isp() float64 {<br/>	<strong class="ng iu">return</strong> 282<br/>}</span></pre><p id="e023" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">C++和Carbon都使用<em class="od">名义类型</em>，这意味着我们必须明确声明我们正在实现什么类或接口。从C++开始，我们就有了<code class="fe nd ne nf ng b">override</code>关键字，它允许编译器检查我们正在实现的方法实际上是否覆盖了在基本接口中定义为虚拟的函数。然而，没有使用<code class="fe nd ne nf ng b">override</code>的要求，所以这里我们得到了一个潜在的bug源。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="fd6d" class="mf mg it ng b gy nl nm l nn no">// C++ code - Merlin rocket engine</span><span id="b9ec" class="mf mg it ng b gy of nm l nn no"><strong class="ng iu">class</strong> Merlin : <strong class="ng iu">public</strong> Engine {<br/><strong class="ng iu">public</strong>:<br/>  Engine() {}   // constructor<br/>  ~Engine() {}  // destructor<br/><br/>  Kg Mass() <strong class="ng iu">override</strong> {<br/>  	return 470;<br/>  }<br/>  <br/>  Newton Thrust() <strong class="ng iu">override</strong> {<br/>    	return 845e3;<br/>  }<br/>  <br/>  double Isp() <strong class="ng iu">override</strong> {<br/>    	return 282;<br/>  }<br/>};</span></pre><p id="a8a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Go和Carbon不同，C++有构造函数。创建C++对象时，总是运行构造函数。当C++对象被释放时，析构函数将被运行。Go避免了析构函数，因为当Go对象被释放时，它是不确定的，因为它使用垃圾收集器来管理内存。Go解决方案是使用<code class="fe nd ne nf ng b">defer</code>语句，它通常用于运行清理代码。</p><p id="9237" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Carbon被设计成与C++兼容，并且容易与C++代码接口。出于这个原因，Carbon不使用垃圾收集，实际上有析构函数。在下面的例子中，我们还没有显示析构函数，但是我们已经创建了一个<code class="fe nd ne nf ng b">Make</code>类方法来在堆上分配<code class="fe nd ne nf ng b">Merlin</code>的实例。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="ed9b" class="mf mg it ng b gy nl nm l nn no">// Carbon code - Merlin rocket engine</span><span id="88e9" class="mf mg it ng b gy of nm l nn no"><strong class="ng iu">final</strong> <strong class="ng iu">class</strong> Merlin <strong class="ng iu">extends</strong> Engine {<br/>    <strong class="ng iu">fn</strong> Make() -&gt; Merlin* {<br/>        <strong class="ng iu">let</strong> engine: Merlin = {};<br/>        <strong class="ng iu">return</strong> heap.New(engine);<br/>    }<br/>    <br/>    <strong class="ng iu">impl</strong> <strong class="ng iu">fn</strong> Mass[me: Self]() -&gt; Kg {<br/>        <strong class="ng iu">return</strong> 470;<br/>    }<br/>    <br/>    <strong class="ng iu">impl</strong> <strong class="ng iu">fn</strong> Thrust[me: Self]() -&gt; Newton {<br/>        <strong class="ng iu">return</strong> 845000;<br/>    }<br/>    <br/>    <strong class="ng iu">impl</strong> <strong class="ng iu">fn</strong> Isp[me: Self]() -&gt; f32 {<br/>        <strong class="ng iu">return</strong> 282;<br/>    }<br/>}</span></pre><p id="3da3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Carbon中，我们使用<code class="fe nd ne nf ng b">final</code>关键字来表示该类不能再进一步成为子类。使用<code class="fe nd ne nf ng b">final</code>可以实现更好的优化。如果你有一个类型为<code class="fe nd ne nf ng b">Merlin</code>的指针，那么当一个类是final的时候就不需要查找虚方法。在Go中，每个<code class="fe nd ne nf ng b">struct</code>都是隐式final，因为你不能继承structs。实际上，final在Carbon中是默认的，所以实际上你不必写它。</p><p id="899e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Carbon中，我们用关键字<code class="fe nd ne nf ng b">virtual</code>、<code class="fe nd ne nf ng b">abstract</code>和<code class="fe nd ne nf ng b">impl</code>修改方法。与C++相比，这些方法允许更好的编译器检查。如果你没有在一个方法前面写这些关键字中的任何一个，那意味着这个方法不能在子类中被覆盖，也不能覆盖在基类中定义的方法。</p><p id="0db4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果您打算以后允许子类覆盖您的方法，您需要将其定义为<code class="fe nd ne nf ng b">virtual</code>或<code class="fe nd ne nf ng b">abstract</code>。前者就好比C++里的<code class="fe nd ne nf ng b">virtual</code>。您声明在提供默认实现的同时可以覆盖该方法。</p><p id="4912" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，在C++中，当我们不实现虚方法时，我们会将奇数<code class="fe nd ne nf ng b">= 0</code>添加到虚方法中。在Carbon中，我们使用<code class="fe nd ne nf ng b">abstract</code>关键字。我认为这是一个更明智的选择。</p><p id="ecb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能认为<code class="fe nd ne nf ng b">impl</code>和C++里的<code class="fe nd ne nf ng b">override</code>一样，其实不然。你必须在Carbon中使用<code class="fe nd ne nf ng b">impl</code>来覆盖一个方法，否则你会得到一个编译器错误。换句话说，Carbon编译器会发现更多的问题。在C++中，您可能会无意中覆盖一个方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/81a253183404fae314ba19483cf3ce18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6csK6TbBZWGsMgw61x2gQ.jpeg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">俄罗斯联盟号火箭上的火箭发动机组</figcaption></figure><p id="f12b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用成员变量做一个类。今天大多数火箭的第一级，即所谓的助推级，都有多个火箭发动机。土星五号月球火箭有五个F1火箭发动机。猎鹰9号火箭的第一级有九个梅林引擎。为了简化火箭的建模，我们可以将一组引擎表示为另一种引擎。这就是<code class="fe nd ne nf ng b">Cluster</code>的作用。<code class="fe nd ne nf ng b">Cluster</code>类型实现了与其他引擎类型相同的所有方法。</p><p id="7ecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用一个<code class="fe nd ne nf ng b">Count</code>变量来跟踪集群中有多少个引擎。在Go中，我们可以利用嵌入的概念，它允许我们嵌入另一种类型并公开其接口。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d2a6" class="mf mg it ng b gy nl nm l nn no">// Go code - Rocket engine cluster<br/><strong class="ng iu">package</strong> engine<br/><br/><strong class="ng iu">type</strong> Cluster <strong class="ng iu">struct</strong> {<br/>    Engine<br/>    count uint8<br/>}<br/><br/><strong class="ng iu">func</strong> (cluster *Cluster) Mass() Kg {<br/>    <strong class="ng iu">return</strong> cluster.Engine.Mass() * Kg(cluster.count)<br/>}<br/><br/><strong class="ng iu">func</strong> (cluster *Cluster) Thrust() Newton {<br/>    <strong class="ng iu">return</strong> cluster.Engine.Thrust() * Newton(cluster.count)<br/>}<br/><br/>// Create a cluster. Go does not have constructors<br/><strong class="ng iu">func</strong> NewCluster(engine Engine, count uint8) *Cluster {<br/>    cluster := Cluster{<br/>        Engine: engine,<br/>        count: math.Max(count, 1.0)<br/>    }<br/>    <strong class="ng iu">return</strong> &amp;cluster<br/>}</span></pre><p id="b4df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们嵌入了<code class="fe nd ne nf ng b">Engine</code>接口，该接口向<code class="fe nd ne nf ng b">Cluster</code>添加了<code class="fe nd ne nf ng b">Mass</code>、<code class="fe nd ne nf ng b">Thrust</code>和<code class="fe nd ne nf ng b">Isp</code>方法。</p><p id="4f7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们显式地隐藏了<code class="fe nd ne nf ng b">Mass</code>和<code class="fe nd ne nf ng b">Thrust</code>方法。这种隐藏不同于重写。如果<code class="fe nd ne nf ng b">Isp</code>调用了<code class="fe nd ne nf ng b">Mass</code>和<code class="fe nd ne nf ng b">Thrust</code>，它们仍然会调用由嵌入的<code class="fe nd ne nf ng b">Engine</code>对象提供的实现，而不是由<code class="fe nd ne nf ng b">Cluster</code>类型提供的实现。</p><p id="5d36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与C++不同，Go没有构造函数。如果我们希望防止包的用户可能错误地初始化对象，我们将一个或多个结构成员设为私有。因为<code class="fe nd ne nf ng b">count</code>字段是私有的，所以<code class="fe nd ne nf ng b">engine</code>包外的代码不能用结构文字初始化<code class="fe nd ne nf ng b">Cluster</code>对象。在<code class="fe nd ne nf ng b">engine</code>包之外创建<code class="fe nd ne nf ng b">Cluster</code>对象的唯一方法是调用<code class="fe nd ne nf ng b">NewCluster</code>函数。</p><p id="81cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有必要在Go中的堆上显式分配。在<code class="fe nd ne nf ng b">NewCluster</code>方法中，我们创建了<code class="fe nd ne nf ng b">cluster</code>对象，它通常会被分配到堆栈中。然而，当Go编译器分析代码时，它会注意到返回了<code class="fe nd ne nf ng b">cluster</code>对象的地址。在Carbon或C++代码中，这将导致灾难。你将返回一个指向堆栈上已经被释放的内存的指针。在围棋中，这不是问题。编译器将简单地切换到在堆上分配<code class="fe nd ne nf ng b">cluster</code>。堆分配的对象由Go垃圾收集器管理，所以内存不会泄漏。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl ma"><img src="../Images/11ac8f76f665ff089b32a3b38f81cb51.png" data-original-src="https://miro.medium.com/v2/format:webp/1*32roa5iYW992SwsknMLzNw.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">内存堆栈和堆分配的区别。</figcaption></figure><p id="4808" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你将看到的，Carbon使用非常相似的方法来创造物体。我已经选择调用为<code class="fe nd ne nf ng b">Make</code>创建集群对象的函数，但是我可以把它命名为任何东西。你可以通过它不包含<code class="fe nd ne nf ng b">[me: Self]</code>部分来判断它是一个类函数而不是一个方法，T5部分指的是所有实例方法都有的隐式<code class="fe nd ne nf ng b">me</code>变量。</p><p id="c77d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">Make</code>比Go版本更复杂，因为我们没有垃圾收集器来跟踪有多少其他对象指向我们的<code class="fe nd ne nf ng b">engine</code>对象。因此，安全的选择是复制引擎对象。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8842" class="mf mg it ng b gy nl nm l nn no"><strong class="ng iu">class</strong> Cluster <strong class="ng iu">extends</strong> Engine {<br/>    <strong class="ng iu">fn</strong> Make(engine: Engine, count: i32) -&gt; Cluster* {<br/>        <strong class="ng iu">let</strong> cluster: Cluster = {<br/>            .engine = heap.New(*engine),  // create copy<br/>            .count = Math.Max(count, 1)};<br/>        <strong class="ng iu">return</strong> heap.New(cluster);<br/>    }<br/>    <br/>    <strong class="ng iu">impl</strong> <strong class="ng iu">fn</strong> Mass[me: Self]() -&gt; Kg {<br/>        <strong class="ng iu">return</strong> me.engine.Mass() * me.count;<br/>    }<br/>    <br/>    <strong class="ng iu">impl</strong> <strong class="ng iu">fn</strong> Thrust[me: Self]() -&gt; Newton {<br/>        <strong class="ng iu">return</strong> me.engine.Thrust() * me.count;<br/>    }<br/>    <br/>    <strong class="ng iu">impl</strong> <strong class="ng iu">fn</strong> Isp[me: Self]() -&gt; f32 {<br/>        <strong class="ng iu">return</strong> me.engine.Isp();<br/>    }<br/>    <br/>    <strong class="ng iu">destructor</strong> [addr me: Self*] {<br/>        heap.Delete(me-&gt;engine);     // deallocate copy we made<br/>    }<br/>    <br/>    <strong class="ng iu">var</strong> engine: Engine*;<br/>    <strong class="ng iu">var</strong> count: i32;<br/>}</span></pre><p id="045d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要创建一个集群对象，我们可以编写如下代码:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="ef12" class="mf mg it ng b gy nl nm l nn no"><strong class="ng iu">var</strong> merlin: Merlin* = Merlin.Make();<br/><strong class="ng iu">var</strong> cluster: Cluster* = Cluster.Make(merlin, 9);</span></pre><p id="3ea1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的Go实现还有其他一些不同之处。在Go中，我们写<code class="fe nd ne nf ng b">Cluster{ ... }</code>，而在Carbon中，当创建一个集群对象时，我们写<code class="fe nd ne nf ng b">{ ... }</code>。当名称在任何地方都不存在时，Carbon如何知道我们正在制造一个<code class="fe nd ne nf ng b">Cluster</code>对象？事实上，我们不是在用碳制造<code class="fe nd ne nf ng b">Cluster</code>物体。Carbon中的结构文字有<em class="od">结构类型</em>。这意味着任何两个具有相同字段的结构都是相同的类型。</p><p id="769e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Carbon允许将结构类型转换为类类型，当它们具有相同的字段时。在这种情况下，当我们返回时，我们的struct文本被转换成一个<code class="fe nd ne nf ng b">Cluster</code>类型，因为它们有相同的字段。</p><p id="1fc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Carbon没有Go嵌入特性，所以我们需要显式实现<code class="fe nd ne nf ng b">Isp</code>方法。然而，结果是一样的。</p><h1 id="6859" class="oh mg it bd mh oi oj ok mk ol om on mn jz oo ka mq kc op kd mt kf oq kg mw or bi translated">反光</h1><p id="7a2f" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">作为一个Go编程语言的粉丝，我喜欢Carbon中的许多东西与Go有相似之处，比如去掉构造函数。我认为构造函数是C++中许多问题的根源。如果从构造函数中间接调用虚方法，将会得到未定义的行为。对于较大的班级，这种情况时有发生。</p><p id="8933" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也有很多情况下，想要构造不同类型的对象，同时使用相同类型的参数。假设你有一门<code class="fe nd ne nf ng b">Point</code>课。您可能希望创建一个代表原点、最小值和最大值的点。有了碳，你可以写<code class="fe nd ne nf ng b">Point.Origin()</code>在<code class="fe nd ne nf ng b">(0, 0)</code>发表观点。当然，你可以在C++中做同样的事情，但是现在你缺乏对称性，因为不同的构造和对象的方法有不同的语法。</p><p id="845c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Swift和Objective-C是其他正确理解这一点的语言。两者都使用初始化函数，它可以被命名为任何名字，所以你可以告诉用户正在创建什么类型的对象。考虑一个文件类:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="441a" class="mf mg it ng b gy nl nm l nn no"><strong class="ng iu">var</strong> foo: <strong class="ng iu">auto</strong> = File.Open("foo/bar.txt");<br/><strong class="ng iu">var</strong> qux: <strong class="ng iu">auto</strong> = File.Create("foo/qux.txt");</span></pre><p id="3a79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，因为我们使用命名函数来创建文件对象，所以我们可以传达通过打开现有文件创建文件对象与创建新文件之间的区别。在C++中，你可能一开始用一个构造函数<code class="fe nd ne nf ng b">File(path)</code>来打开一个文件，后来才意识到你想要支持创建。你如何解决这个问题？你可以创建一个<code class="fe nd ne nf ng b">File::Create(path)</code>函数调用，但是这会在API中引入一个丑陋的不对称。</p><p id="13a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不喜欢碳的什么？如前所述，我认为<code class="fe nd ne nf ng b">[me: Self]</code>的使用有些不和谐。尽管有一些逻辑与Carbon generics非常匹配。碳将任何隐含定义的东西放在方括号内。这不仅仅是经典的<code class="fe nd ne nf ng b">this</code>和<code class="fe nd ne nf ng b">self</code>指针，还包括由类型系统推断出的任何类型参数。我们可以在Carbon快速排序示例代码中看到这样的示例:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="a597" class="mf mg it ng b gy nl nm l nn no"><strong class="ng iu">fn</strong> QuickSort[T:! Comparable &amp; Movable](s: Slice(T)) {<br/>  <strong class="ng iu">if</strong> (s.Size() &lt;= 1) {<br/>    <strong class="ng iu">return</strong>;<br/>  }<br/>  <strong class="ng iu">let</strong> p: i64 = Partition(s);<br/>  QuickSort(s[:p - 1]);<br/>  QuickSort(s[p + 1:]);<br/>}</span></pre><p id="f9fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">QuickSort</code>是递归函数。您会注意到，在<code class="fe nd ne nf ng b">QuickSort</code>的调用位置，我们不必指定<code class="fe nd ne nf ng b">T</code>。它不是函数的常规参数，而是可以经常推断出来的东西。</p><p id="20fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在<code class="fe nd ne nf ng b">me</code>和<code class="fe nd ne nf ng b">Self</code>之间写了一个冒号<code class="fe nd ne nf ng b">:</code>，因为<code class="fe nd ne nf ng b">me</code>是方法体中使用的一个实际变量。<code class="fe nd ne nf ng b">T</code>在快速排序中不支持被当作变量，而是当作类型参数。Carbon编译器如何知道它应该把<code class="fe nd ne nf ng b">T</code>当作类型参数而不是对象？因为我们使用了<code class="fe nd ne nf ng b">:!</code>而不是单个冒号。<code class="fe nd ne nf ng b">:!</code>用来表示我们正在指定某个约束的类型参数。我们告诉Carbon，<code class="fe nd ne nf ng b">T</code>必须是一个既是<code class="fe nd ne nf ng b">Comparable</code>又是<code class="fe nd ne nf ng b">Movable</code>的类型。</p><p id="1af2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，虽然<code class="fe nd ne nf ng b">me</code>和<code class="fe nd ne nf ng b">Self</code>在概念上是有意义的，但是它们看起来并不好，并且会在所有的类中导致许多看起来相似的代码的重复。这样写类方法会更简洁，但是那些很少被使用。我们不应该为最常见的情况优化语法吗？</p><p id="d4b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在编写这些代码示例时，我发现在Carbon中管理内存有点棘手。语言规范中没有太多关于这方面的内容，我们使用的Carbon解释器缺少语言规范中描述的许多特性。有人提醒我，碳含量非常低。Swift继承了Objective-C对所有对象的引用计数。这给了我们ARC(自动引用计数),这意味着在Swift中，内存分配和取消分配不是你需要考虑很多的事情。</p><p id="3a96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相比之下，Carbon继承了C++世界的语义，这意味着引用计数和其他形式的内存管理可能来自类似于C++模板库的东西。</p></div></div>    
</body>
</html>